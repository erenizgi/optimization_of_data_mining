{
    "author": "lukesandberg",
    "message": "[turbopack] Remove the `should_track_children` parameter of the turbo tasks backend (#83258)\n\nThis appears to be dead, is there a reason to keep it?",
    "sha": "de42be7c87340c06abd3a4cabf7b5ce5b1623a03",
    "files": [
        {
            "sha": "1ba740e971490d606a39e45ea7aae4911e31952e",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 29,
            "deletions": 56,
            "changes": 85,
            "blob_url": "https://github.com/vercel/next.js/blob/de42be7c87340c06abd3a4cabf7b5ce5b1623a03/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/de42be7c87340c06abd3a4cabf7b5ce5b1623a03/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=de42be7c87340c06abd3a4cabf7b5ce5b1623a03",
            "patch": "@@ -124,12 +124,6 @@ pub struct BackendOptions {\n     /// forever.\n     pub dependency_tracking: bool,\n \n-    /// Enables children tracking.\n-    ///\n-    /// When disabled: Strongly consistent reads are only eventually consistent. All tasks are\n-    /// considered as active. Collectibles are disabled.\n-    pub children_tracking: bool,\n-\n     /// Enables active tracking.\n     ///\n     /// Automatically disabled when `dependency_tracking` is disabled.\n@@ -148,7 +142,6 @@ impl Default for BackendOptions {\n     fn default() -> Self {\n         Self {\n             dependency_tracking: true,\n-            children_tracking: true,\n             active_tracking: true,\n             storage_mode: Some(StorageMode::ReadWrite),\n             small_preallocation: false,\n@@ -386,10 +379,6 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         self.options.active_tracking\n     }\n \n-    fn should_track_children(&self) -> bool {\n-        self.options.children_tracking\n-    }\n-\n     fn track_cache_hit(&self, task_type: &CachedTaskType) {\n         self.task_statistics\n             .map(|stats| stats.increment_cache_hit(task_type.native_fn));\n@@ -509,7 +498,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             }\n         }\n \n-        if self.should_track_children() && matches!(consistency, ReadConsistency::Strong) {\n+        if matches!(consistency, ReadConsistency::Strong) {\n             // Ensure it's an root node\n             loop {\n                 let aggregation_number = get_aggregation_number(&task);\n@@ -1597,27 +1586,23 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                 })),\n             });\n \n-            if self.should_track_children() {\n-                // Make all current collectibles outdated (remove left-over outdated collectibles)\n-                enum Collectible {\n-                    Current(CollectibleRef, i32),\n-                    Outdated(CollectibleRef),\n-                }\n-                let collectibles = iter_many!(task, Collectible { collectible } value => Collectible::Current(collectible, *value))\n+            // Make all current collectibles outdated (remove left-over outdated collectibles)\n+            enum Collectible {\n+                Current(CollectibleRef, i32),\n+                Outdated(CollectibleRef),\n+            }\n+            let collectibles = iter_many!(task, Collectible { collectible } value => Collectible::Current(collectible, *value))\n                     .chain(iter_many!(task, OutdatedCollectible { collectible } => Collectible::Outdated(collectible)))\n                     .collect::<Vec<_>>();\n-                for collectible in collectibles {\n-                    match collectible {\n-                        Collectible::Current(collectible, value) => {\n-                            let _ = task\n-                                .insert(CachedDataItem::OutdatedCollectible { collectible, value });\n-                        }\n-                        Collectible::Outdated(collectible) => {\n-                            if !task.has_key(&CachedDataItemKey::Collectible { collectible }) {\n-                                task.remove(&CachedDataItemKey::OutdatedCollectible {\n-                                    collectible,\n-                                });\n-                            }\n+            for collectible in collectibles {\n+                match collectible {\n+                    Collectible::Current(collectible, value) => {\n+                        let _ =\n+                            task.insert(CachedDataItem::OutdatedCollectible { collectible, value });\n+                    }\n+                    Collectible::Outdated(collectible) => {\n+                        if !task.has_key(&CachedDataItemKey::Collectible { collectible }) {\n+                            task.remove(&CachedDataItemKey::OutdatedCollectible { collectible });\n                         }\n                     }\n                 }\n@@ -1883,18 +1868,18 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                             .get(&cell.type_id).is_none_or(|start_index| cell.index >= *start_index))\n             }));\n         }\n-        if self.should_track_children() {\n-            old_edges.extend(\n-                task.iter(CachedDataItemType::OutdatedCollectible)\n-                    .filter_map(|(key, value)| match (key, value) {\n-                        (\n-                            CachedDataItemKey::OutdatedCollectible { collectible },\n-                            CachedDataItemValueRef::OutdatedCollectible { value },\n-                        ) => Some(OutdatedEdge::Collectible(collectible, *value)),\n-                        _ => None,\n-                    }),\n-            );\n-        }\n+\n+        old_edges.extend(\n+            task.iter(CachedDataItemType::OutdatedCollectible)\n+                .filter_map(|(key, value)| match (key, value) {\n+                    (\n+                        CachedDataItemKey::OutdatedCollectible { collectible },\n+                        CachedDataItemValueRef::OutdatedCollectible { value },\n+                    ) => Some(OutdatedEdge::Collectible(collectible, *value)),\n+                    _ => None,\n+                }),\n+        );\n+\n         if self.should_track_dependencies() {\n             old_edges.extend(iter_many!(task, OutdatedCellDependency { target } => OutdatedEdge::CellDependency(target)));\n             old_edges.extend(iter_many!(task, OutdatedOutputDependency { target } => OutdatedEdge::OutputDependency(target)));\n@@ -2080,9 +2065,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                 task.remove(&CachedDataItemKey::Dirty {});\n             }\n \n-            if self.should_track_children()\n-                && (old_dirty_state.is_some() || new_dirty_state.is_some())\n-            {\n+            if old_dirty_state.is_some() || new_dirty_state.is_some() {\n                 let mut dirty_containers = get!(task, AggregatedDirtyContainerCount)\n                     .cloned()\n                     .unwrap_or_default();\n@@ -2284,10 +2267,6 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         reader_id: TaskId,\n         turbo_tasks: &dyn TurboTasksBackendApi<TurboTasksBackend<B>>,\n     ) -> AutoMap<RawVc, i32, BuildHasherDefault<FxHasher>, 1> {\n-        if !self.should_track_children() {\n-            return AutoMap::default();\n-        }\n-\n         let mut ctx = self.execute_context(turbo_tasks);\n         let mut collectibles = AutoMap::default();\n         {\n@@ -2363,9 +2342,6 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         turbo_tasks: &dyn TurboTasksBackendApi<TurboTasksBackend<B>>,\n     ) {\n         self.assert_valid_collectible(task_id, collectible);\n-        if !self.should_track_children() {\n-            return;\n-        }\n \n         let RawVc::TaskCell(collectible_task, cell) = collectible else {\n             panic!(\"Collectibles need to be resolved\");\n@@ -2394,9 +2370,6 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         turbo_tasks: &dyn TurboTasksBackendApi<TurboTasksBackend<B>>,\n     ) {\n         self.assert_valid_collectible(task_id, collectible);\n-        if !self.should_track_children() {\n-            return;\n-        }\n \n         let RawVc::TaskCell(collectible_task, cell) = collectible else {\n             panic!(\"Collectibles need to be resolved\");"
        },
        {
            "sha": "c057fcf6d8297453cf84d0316fcbbe78dba3c1fd",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/aggregation_update.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/de42be7c87340c06abd3a4cabf7b5ce5b1623a03/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Faggregation_update.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/de42be7c87340c06abd3a4cabf7b5ce5b1623a03/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Faggregation_update.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Faggregation_update.rs?ref=de42be7c87340c06abd3a4cabf7b5ce5b1623a03",
            "patch": "@@ -733,7 +733,6 @@ impl AggregationUpdateQueue {\n     /// Runs the job and all dependent jobs until it's done. It can persist the operation, so\n     /// following code might not be executed when persisted.\n     pub fn run(job: AggregationUpdateJob, ctx: &mut impl ExecuteContext) {\n-        debug_assert!(ctx.should_track_children());\n         let mut queue = Self::new();\n         queue.push(job);\n         queue.execute(ctx);"
        },
        {
            "sha": "5b8c63c2677511f4698d489d6c9f97f912edc705",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/connect_child.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 13,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/de42be7c87340c06abd3a4cabf7b5ce5b1623a03/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fconnect_child.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/de42be7c87340c06abd3a4cabf7b5ce5b1623a03/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fconnect_child.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fconnect_child.rs?ref=de42be7c87340c06abd3a4cabf7b5ce5b1623a03",
            "patch": "@@ -24,19 +24,6 @@ pub enum ConnectChildOperation {\n \n impl ConnectChildOperation {\n     pub fn run(parent_task_id: TaskId, child_task_id: TaskId, mut ctx: impl ExecuteContext) {\n-        if !ctx.should_track_children() {\n-            let mut child_task = ctx.task(child_task_id, TaskDataCategory::All);\n-            if !child_task.has_key(&CachedDataItemKey::Output {})\n-                && child_task.add(CachedDataItem::new_scheduled(\n-                    TaskExecutionReason::Connect,\n-                    || ctx.get_task_desc_fn(child_task_id),\n-                ))\n-            {\n-                ctx.schedule_task(child_task);\n-            }\n-            return;\n-        }\n-\n         let mut parent_task = ctx.task(parent_task_id, TaskDataCategory::All);\n         let Some(InProgressState::InProgress(box InProgressStateInner { new_children, .. })) =\n             get_mut!(parent_task, InProgress)"
        },
        {
            "sha": "2b956fbc6fb73f4bf523dd5ac7fa09ea80a1b48e",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/invalidate.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 3,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/de42be7c87340c06abd3a4cabf7b5ce5b1623a03/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Finvalidate.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/de42be7c87340c06abd3a4cabf7b5ce5b1623a03/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Finvalidate.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Finvalidate.rs?ref=de42be7c87340c06abd3a4cabf7b5ce5b1623a03",
            "patch": "@@ -280,7 +280,7 @@ pub fn make_task_dirty_internal(\n     )\n     .entered();\n \n-    let should_schedule = if ctx.should_track_children() {\n+    let should_schedule = {\n         let aggregated_update = dirty_container.update_with_dirty_state(&DirtyState {\n             clean_in_session: None,\n         });\n@@ -291,8 +291,6 @@ pub fn make_task_dirty_internal(\n             ));\n         }\n         !ctx.should_track_activeness() || task.has_key(&CachedDataItemKey::Activeness {})\n-    } else {\n-        true\n     };\n \n     if should_schedule {"
        },
        {
            "sha": "5d2617d4d4d435923e2bca14c09f71903e6f4683",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/mod.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 5,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/de42be7c87340c06abd3a4cabf7b5ce5b1623a03/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/de42be7c87340c06abd3a4cabf7b5ce5b1623a03/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs?ref=de42be7c87340c06abd3a4cabf7b5ce5b1623a03",
            "patch": "@@ -65,7 +65,6 @@ pub trait ExecuteContext<'e>: Sized {\n     fn suspending_requested(&self) -> bool;\n     fn get_task_desc_fn(&self, task_id: TaskId) -> impl Fn() -> String + Send + Sync + 'static;\n     fn get_task_description(&self, task_id: TaskId) -> String;\n-    fn should_track_children(&self) -> bool;\n     fn should_track_dependencies(&self) -> bool;\n     fn should_track_activeness(&self) -> bool;\n }\n@@ -289,10 +288,6 @@ where\n         self.backend.get_task_description(task_id)\n     }\n \n-    fn should_track_children(&self) -> bool {\n-        self.backend.should_track_children()\n-    }\n-\n     fn should_track_dependencies(&self) -> bool {\n         self.backend.should_track_dependencies()\n     }"
        },
        {
            "sha": "fb39b6939a9692443619b392092f04a1dafa4aa5",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/update_collectible.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 4,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/de42be7c87340c06abd3a4cabf7b5ce5b1623a03/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fupdate_collectible.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/de42be7c87340c06abd3a4cabf7b5ce5b1623a03/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fupdate_collectible.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fupdate_collectible.rs?ref=de42be7c87340c06abd3a4cabf7b5ce5b1623a03",
            "patch": "@@ -24,10 +24,6 @@ impl UpdateCollectibleOperation {\n         mut count: i32,\n         mut ctx: impl ExecuteContext,\n     ) {\n-        if !ctx.should_track_children() {\n-            // Collectibles are not supported without children tracking\n-            return;\n-        }\n         let mut task = ctx.task(task_id, TaskDataCategory::All);\n         if count < 0 {\n             // Ensure it's an root node"
        },
        {
            "sha": "7b3427a5842f27e44e315e06ce851658dde705f9",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/update_output.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 4,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/de42be7c87340c06abd3a4cabf7b5ce5b1623a03/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fupdate_output.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/de42be7c87340c06abd3a4cabf7b5ce5b1623a03/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fupdate_output.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fupdate_output.rs?ref=de42be7c87340c06abd3a4cabf7b5ce5b1623a03",
            "patch": "@@ -46,7 +46,7 @@ impl UpdateOutputOperation {\n     pub fn run(\n         task_id: TaskId,\n         output: Result<RawVc, TurboTasksExecutionError>,\n-        mut ctx: impl ExecuteContext,\n+        mut ctx: impl ExecuteContext<'_>,\n     ) {\n         let mut dependent_tasks = Default::default();\n         let mut children = Default::default();\n@@ -66,9 +66,7 @@ impl UpdateOutputOperation {\n                 // Skip updating the output when the task is stale\n                 break 'output;\n             }\n-            if ctx.should_track_children() {\n-                children = new_children.iter().copied().collect();\n-            }\n+            children = new_children.iter().copied().collect();\n \n             let current_output = get!(task, Output);\n             let output_value = match output {"
        }
    ],
    "stats": {
        "total": 118,
        "additions": 32,
        "deletions": 86
    }
}