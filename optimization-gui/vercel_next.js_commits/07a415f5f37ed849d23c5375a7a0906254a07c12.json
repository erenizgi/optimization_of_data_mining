{
    "author": "lubieowoce",
    "message": "[Cache Components] set environment labels if caches are disabled (#85129)\n\nIf we're bypassing caches, we still want to provide some basic\nenvironment labelling and correct \"suspended by\" labels for Suspense\nDevtools. To achieve this, we do a simpler 2-task render, but still use\n`stagedRendering` and install all the `asyncApiPromises` stuff (because\nit's needed for \"suspended by\"). Note that because we only have 2 tasks\nand don't warm caches, we can only do `Prerender` and `Server`, and\ncaches are marked as IO. This isn't ideal but it's the best we can do\nunder the circumstances.",
    "sha": "07a415f5f37ed849d23c5375a7a0906254a07c12",
    "files": [
        {
            "sha": "a4788321d0082a6248fe4cb675e7b28d4a091dc2",
            "filename": "packages/next/src/server/app-render/app-render.tsx",
            "status": "modified",
            "additions": 227,
            "deletions": 105,
            "changes": 332,
            "blob_url": "https://github.com/vercel/next.js/blob/07a415f5f37ed849d23c5375a7a0906254a07c12/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/07a415f5f37ed849d23c5375a7a0906254a07c12/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx?ref=07a415f5f37ed849d23c5375a7a0906254a07c12",
            "patch": "@@ -168,7 +168,10 @@ import {\n   prerenderAndAbortInSequentialTasks,\n } from './app-render-prerender-utils'\n import { printDebugThrownValueForProspectiveRender } from './prospective-render-utils'\n-import { pipelineInSequentialTasks } from './app-render-render-utils'\n+import {\n+  pipelineInSequentialTasks,\n+  scheduleInSequentialTasks,\n+} from './app-render-render-utils'\n import { waitAtLeastOneReactRenderTask } from '../../lib/scheduler'\n import {\n   workUnitAsyncStorage,\n@@ -580,7 +583,7 @@ async function generateDynamicFlightRenderResult(\n ): Promise<RenderResult> {\n   const {\n     clientReferenceManifest,\n-    componentMod: { renderToReadableStream, createElement },\n+    componentMod: { renderToReadableStream },\n     htmlRequestId,\n     renderOpts,\n     requestId,\n@@ -605,26 +608,6 @@ async function generateDynamicFlightRenderResult(\n     onFlightDataRenderError\n   )\n \n-  const RSCPayload: RSCPayload & {\n-    /** Only available during cacheComponents development builds. Used for logging errors. */\n-    _validation?: Promise<ReactNode>\n-    _bypassCachesInDev?: React.ReactNode\n-  } = await workUnitAsyncStorage.run(\n-    requestStore,\n-    generateDynamicRSCPayload,\n-    ctx,\n-    options\n-  )\n-\n-  if (\n-    process.env.NODE_ENV === 'development' &&\n-    isBypassingCachesInDev(renderOpts, requestStore)\n-  ) {\n-    RSCPayload._bypassCachesInDev = createElement(WarnForBypassCachesInDev, {\n-      route: workStore.route,\n-    })\n-  }\n-\n   const debugChannel = setReactDebugChannel && createDebugChannel()\n \n   if (debugChannel) {\n@@ -633,10 +616,17 @@ async function generateDynamicFlightRenderResult(\n \n   // For app dir, use the bundled version of Flight server renderer (renderToReadableStream)\n   // which contains the subset React.\n+  const rscPayload = await workUnitAsyncStorage.run(\n+    requestStore,\n+    generateDynamicRSCPayload,\n+    ctx,\n+    options\n+  )\n+\n   const flightReadableStream = workUnitAsyncStorage.run(\n     requestStore,\n     renderToReadableStream,\n-    RSCPayload,\n+    rscPayload,\n     clientReferenceManifest.clientModules,\n     {\n       onError,\n@@ -651,31 +641,98 @@ async function generateDynamicFlightRenderResult(\n   })\n }\n \n+type RenderToReadableStreamServerOptions = NonNullable<\n+  Parameters<\n+    (typeof import('react-server-dom-webpack/server.node'))['renderToReadableStream']\n+  >[2]\n+>\n+\n+async function stagedRenderToReadableStreamWithoutCachesInDev(\n+  ctx: AppRenderContext,\n+  requestStore: RequestStore,\n+  getPayload: (requestStore: RequestStore) => Promise<RSCPayload>,\n+  clientReferenceManifest: NonNullable<RenderOpts['clientReferenceManifest']>,\n+  options: Omit<RenderToReadableStreamServerOptions, 'environmentName'>\n+) {\n+  const {\n+    componentMod: { renderToReadableStream },\n+  } = ctx\n+  // We're rendering while bypassing caches,\n+  // so we have no hope of showing a useful runtime stage.\n+  // But we still want things like `params` to show up in devtools correctly,\n+  // which relies on mechanisms we've set up for staged rendering,\n+  // so we do a 2-task version (Static -> Dynamic) instead.\n+\n+  const stageController = new StagedRenderingController()\n+  const environmentName = () => {\n+    const currentStage = stageController.currentStage\n+    switch (currentStage) {\n+      case RenderStage.Static:\n+        return 'Prerender'\n+      case RenderStage.Runtime:\n+      case RenderStage.Dynamic:\n+        return 'Server'\n+      default:\n+        currentStage satisfies never\n+        throw new InvariantError(`Invalid render stage: ${currentStage}`)\n+    }\n+  }\n+\n+  requestStore.stagedRendering = stageController\n+  requestStore.asyncApiPromises = createAsyncApiPromisesInDev(\n+    stageController,\n+    requestStore.cookies,\n+    requestStore.mutableCookies,\n+    requestStore.headers\n+  )\n+\n+  const rscPayload = await getPayload(requestStore)\n+\n+  return await workUnitAsyncStorage.run(\n+    requestStore,\n+    scheduleInSequentialTasks,\n+    () => {\n+      return renderToReadableStream(\n+        rscPayload,\n+        clientReferenceManifest.clientModules,\n+        {\n+          ...options,\n+          environmentName,\n+        }\n+      )\n+    },\n+    () => {\n+      stageController.advanceStage(RenderStage.Dynamic)\n+    }\n+  )\n+}\n+\n /**\n  * Fork of `generateDynamicFlightRenderResult` that renders using `renderWithRestartOnCacheMissInDev`\n  * to ensure correct separation of environments Prerender/Server (for use in Cache Components)\n  */\n-async function generateDynamicFlightRenderResultWithCachesInDev(\n+async function generateDynamicFlightRenderResultWithStagesInDev(\n   req: BaseNextRequest,\n   ctx: AppRenderContext,\n   initialRequestStore: RequestStore,\n-  createRequestStore: () => RequestStore\n+  createRequestStore: (() => RequestStore) | undefined\n ): Promise<RenderResult> {\n-  const { htmlRequestId, renderOpts, requestId, workStore } = ctx\n+  const {\n+    htmlRequestId,\n+    renderOpts,\n+    requestId,\n+    workStore,\n+    componentMod: { createElement },\n+  } = ctx\n \n   const {\n     dev = false,\n     onInstrumentationRequestError,\n     setReactDebugChannel,\n     setCacheStatus,\n+    clientReferenceManifest,\n   } = renderOpts\n \n-  // Before we kick off the render, we set the cache status back to it's initial state\n-  // in case a previous render bypassed the cache.\n-  if (process.env.NODE_ENV === 'development' && setCacheStatus) {\n-    setCacheStatus('ready', htmlRequestId, requestId)\n-  }\n-\n   function onFlightDataRenderError(err: DigestedError) {\n     return onInstrumentationRequestError?.(\n       err,\n@@ -688,21 +745,77 @@ async function generateDynamicFlightRenderResultWithCachesInDev(\n     onFlightDataRenderError\n   )\n \n-  const getPayload = (requestStore: RequestStore) =>\n-    workUnitAsyncStorage.run(\n-      requestStore,\n-      generateDynamicRSCPayload,\n+  const getPayload = async (requestStore: RequestStore) => {\n+    const payload: RSCPayload & RSCPayloadDevProperties =\n+      await workUnitAsyncStorage.run(\n+        requestStore,\n+        generateDynamicRSCPayload,\n+        ctx,\n+        undefined\n+      )\n+\n+    if (isBypassingCachesInDev(renderOpts, requestStore)) {\n+      // Mark the RSC payload to indicate that caches were bypassed in dev.\n+      // This lets the client know not to cache anything based on this render.\n+      payload._bypassCachesInDev = createElement(WarnForBypassCachesInDev, {\n+        route: workStore.route,\n+      })\n+    }\n+\n+    return payload\n+  }\n+\n+  let debugChannel: DebugChannelPair | undefined\n+  let stream: ReadableStream<Uint8Array>\n+\n+  if (\n+    // We only do this flow if we can safely recreate the store from scratch\n+    // (which is not the case for renders after an action)\n+    createRequestStore &&\n+    // We only do this flow if we're not bypassing caches in dev using\n+    // \"disable cache\" in devtools or a hard refresh (cache-control: \"no-store\")\n+    !isBypassingCachesInDev(renderOpts, initialRequestStore)\n+  ) {\n+    // Before we kick off the render, we set the cache status back to it's initial state\n+    // in case a previous render bypassed the cache.\n+    if (setCacheStatus) {\n+      setCacheStatus('ready', htmlRequestId, requestId)\n+    }\n+\n+    const result = await renderWithRestartOnCacheMissInDev(\n       ctx,\n-      undefined\n+      initialRequestStore,\n+      createRequestStore,\n+      getPayload,\n+      onError\n     )\n+    debugChannel = result.debugChannel\n+    stream = result.stream\n+  } else {\n+    // We're either bypassing caches or we can't restart the render.\n+    // Do a dynamic render, but with (basic) environment labels.\n \n-  const { stream, debugChannel } = await renderWithRestartOnCacheMissInDev(\n-    ctx,\n-    initialRequestStore,\n-    createRequestStore,\n-    getPayload,\n-    onError\n-  )\n+    assertClientReferenceManifest(clientReferenceManifest)\n+\n+    // Set cache status to bypass when specifically bypassing caches in dev\n+    if (setCacheStatus) {\n+      setCacheStatus('bypass', htmlRequestId, requestId)\n+    }\n+\n+    debugChannel = setReactDebugChannel && createDebugChannel()\n+\n+    stream = await stagedRenderToReadableStreamWithoutCachesInDev(\n+      ctx,\n+      initialRequestStore,\n+      getPayload,\n+      clientReferenceManifest,\n+      {\n+        onError: onError,\n+        filterStackFrame,\n+        debugChannel: debugChannel?.serverSide,\n+      }\n+    )\n+  }\n \n   if (debugChannel && setReactDebugChannel) {\n     setReactDebugChannel(debugChannel.clientSide, htmlRequestId, requestId)\n@@ -1882,32 +1995,18 @@ async function renderToHTMLOrFlightImpl(\n       if (isRuntimePrefetchRequest) {\n         return generateRuntimePrefetchResult(req, res, ctx, requestStore)\n       } else {\n-        const bypassCachesInDev = isBypassingCachesInDev(\n-          renderOpts,\n-          requestStore\n-        )\n         if (\n           process.env.NODE_ENV === 'development' &&\n           process.env.NEXT_RUNTIME !== 'edge' &&\n-          cacheComponents &&\n-          !bypassCachesInDev\n+          cacheComponents\n         ) {\n-          return generateDynamicFlightRenderResultWithCachesInDev(\n+          return generateDynamicFlightRenderResultWithStagesInDev(\n             req,\n             ctx,\n             requestStore,\n             createRequestStore\n           )\n         } else {\n-          // Set cache status to bypass when specifically bypassing caches in dev\n-          if (\n-            process.env.NODE_ENV === 'development' &&\n-            bypassCachesInDev &&\n-            renderOpts.setCacheStatus\n-          ) {\n-            const { setCacheStatus } = renderOpts\n-            setCacheStatus('bypass', htmlRequestId, requestId)\n-          }\n           return generateDynamicFlightRenderResult(req, ctx, requestStore)\n         }\n       }\n@@ -2193,6 +2292,12 @@ function applyMetadataFromPrerenderResult(\n   }\n }\n \n+type RSCPayloadDevProperties = {\n+  /** Only available during cacheComponents development builds. Used for logging errors. */\n+  _validation?: Promise<ReactNode>\n+  _bypassCachesInDev?: ReactNode\n+}\n+\n async function renderToStream(\n   requestStore: RequestStore,\n   req: BaseNextRequest,\n@@ -2335,26 +2440,15 @@ async function renderToStream(\n       // Edge routes never prerender so we don't have a Prerender environment for anything in edge runtime\n       process.env.NEXT_RUNTIME !== 'edge' &&\n       // We only have a Prerender environment for projects opted into cacheComponents\n-      cacheComponents &&\n-      // We only do this flow if we can safely recreate the store from scratch\n-      // (which is not the case for renders after an action)\n-      createRequestStore &&\n-      // We only do this flow if we're not bypassing caches in dev using\n-      // \"disable cache\" in devtools or a hard refresh (cache-control: \"no-store\")\n-      !isBypassingCachesInDev(renderOpts, requestStore)\n+      cacheComponents\n     ) {\n-      type RSCPayloadWithValidation = InitialRSCPayload & {\n-        /** Only available during cacheComponents development builds. Used for logging errors. */\n-        _validation?: Promise<ReactNode>\n-      }\n-\n       const [resolveValidation, validationOutlet] = createValidationOutlet()\n-\n+      let debugChannel: DebugChannelPair | undefined\n       const getPayload = async (\n         // eslint-disable-next-line @typescript-eslint/no-shadow\n         requestStore: RequestStore\n-      ): Promise<RSCPayloadWithValidation> => {\n-        const payload: RSCPayloadWithValidation =\n+      ) => {\n+        const payload: InitialRSCPayload & RSCPayloadDevProperties =\n           await workUnitAsyncStorage.run(\n             requestStore,\n             getRSCPayload,\n@@ -2367,23 +2461,61 @@ async function renderToStream(\n         // because we're not going to wait for the stream to complete,\n         // so leaving the validation unresolved is fine.\n         payload._validation = validationOutlet\n+\n+        if (isBypassingCachesInDev(renderOpts, requestStore)) {\n+          // Mark the RSC payload to indicate that caches were bypassed in dev.\n+          // This lets the client know not to cache anything based on this render.\n+          payload._bypassCachesInDev = createElement(WarnForBypassCachesInDev, {\n+            route: workStore.route,\n+          })\n+        }\n+\n         return payload\n       }\n \n-      const {\n-        stream: serverStream,\n-        debugChannel,\n-        requestStore: finalRequestStore,\n-      } = await renderWithRestartOnCacheMissInDev(\n-        ctx,\n-        requestStore,\n-        createRequestStore,\n-        getPayload,\n-        serverComponentsErrorHandler\n-      )\n+      if (\n+        // We only do this flow if we can safely recreate the store from scratch\n+        // (which is not the case for renders after an action)\n+        createRequestStore &&\n+        // We only do this flow if we're not bypassing caches in dev using\n+        // \"disable cache\" in devtools or a hard refresh (cache-control: \"no-store\")\n+        !isBypassingCachesInDev(renderOpts, requestStore)\n+      ) {\n+        const {\n+          stream: serverStream,\n+          debugChannel: returnedDebugChannel,\n+          requestStore: finalRequestStore,\n+        } = await renderWithRestartOnCacheMissInDev(\n+          ctx,\n+          requestStore,\n+          createRequestStore,\n+          getPayload,\n+          serverComponentsErrorHandler\n+        )\n \n-      reactServerResult = new ReactServerResult(serverStream)\n-      requestStore = finalRequestStore\n+        reactServerResult = new ReactServerResult(serverStream)\n+        requestStore = finalRequestStore\n+        debugChannel = returnedDebugChannel\n+      } else {\n+        // We're either bypassing caches or we can't restart the render.\n+        // Do a dynamic render, but with (basic) environment labels.\n+\n+        debugChannel = setReactDebugChannel && createDebugChannel()\n+\n+        const serverStream =\n+          await stagedRenderToReadableStreamWithoutCachesInDev(\n+            ctx,\n+            requestStore,\n+            getPayload,\n+            clientReferenceManifest,\n+            {\n+              onError: serverComponentsErrorHandler,\n+              filterStackFrame,\n+              debugChannel: debugChannel?.serverSide,\n+            }\n+          )\n+        reactServerResult = new ReactServerResult(serverStream)\n+      }\n \n       if (debugChannel && setReactDebugChannel) {\n         const [readableSsr, readableBrowser] =\n@@ -2414,24 +2546,14 @@ async function renderToStream(\n       )\n     } else {\n       // This is a dynamic render. We don't do dynamic tracking because we're not prerendering\n-      const RSCPayload: RSCPayload & {\n-        _bypassCachesInDev?: React.ReactNode\n-      } = await workUnitAsyncStorage.run(\n-        requestStore,\n-        getRSCPayload,\n-        tree,\n-        ctx,\n-        res.statusCode === 404\n-      )\n-\n-      if (isBypassingCachesInDev(renderOpts, requestStore)) {\n-        // Mark the RSC payload to indicate that caches were bypassed in dev.\n-        // This lets the client know not to cache anything based on this render.\n-        RSCPayload._bypassCachesInDev = createElement(\n-          WarnForBypassCachesInDev,\n-          { route: workStore.route }\n+      const RSCPayload: RSCPayload & RSCPayloadDevProperties =\n+        await workUnitAsyncStorage.run(\n+          requestStore,\n+          getRSCPayload,\n+          tree,\n+          ctx,\n+          res.statusCode === 404\n         )\n-      }\n \n       const debugChannel = setReactDebugChannel && createDebugChannel()\n "
        }
    ],
    "stats": {
        "total": 332,
        "additions": 227,
        "deletions": 105
    }
}