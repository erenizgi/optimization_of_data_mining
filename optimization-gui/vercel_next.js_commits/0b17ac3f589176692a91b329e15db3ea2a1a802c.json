{
    "author": "acdlite",
    "message": "Move unhandled rejection handling to shared path (#77997)\n\nThe conventional wisdom of Node.js and other runtimes is to treat\nunhandled errors as fatal and exit the process.\n\nBut Next.js is not a generic JS runtime — it's a specialized runtime for\nReact Server Components.\n\nMany unhandled rejections are due to the late-awaiting pattern for\nprefetching data. In Next.js it's OK to call an async function without\nimmediately awaiting it, to start the request as soon as possible\nwithout blocking unncessarily on the result. These can end up triggering\nan \"unhandledRejection\" if it later turns out that the data is not\nneeded to render the page. Example:\n\n```js\nconst promise = fetchData()\nconst shouldShow = await checkCondition()\nif (shouldShow) {\n  return <Component promise={promise} />\n}\n```\n\nIn this example, `fetchData` is called immediately to start the request\nas soon as possible, but if `shouldShow` is false, then it will be\ndiscarded without unwrapping its result. If it errors, it will trigger\nan \"unhandledRejection\" event.\n\nIdeally, we would suppress these rejections completely without warning,\nbecause we don't consider them real errors. But regardless of whether we\ndo or don't warn, we definitely shouldn't crash the entire process.\n\nEven a \"legit\" unhandled error unrelated to prefetching shouldn't\nprevent the rest of the page from rendering.\n\nSo, we intentionally override the default error handling behavior of the\nouter JS runtime to be more forgiving.\n\n---\n\nThis was already the behavior of Next.js for self-hosted deployments —\ni.e. `next start` — but the rejection listeners were being installed in\na code path that does not run for other deployment targets, like Vercel.\n\nSo what this PR does is move the rejection handling code to a path\nthat's common to all deployement targets.\n\nOne possibly controversial aspect that is new to this PR is that it\nremoves all existing \"unhandledRejection\" handlers, before Next.js\ninstalls its own. This is to override any handlers that exit the\nprocess. Generally we think this is fine because it's unlikely that\nNext.js will be deployed in such a way that it's sharing a process with\nnon-Next.js applications; however, if we get feedback to the contrary,\nwe'll figure out a strategy to deal with it.",
    "sha": "0b17ac3f589176692a91b329e15db3ea2a1a802c",
    "files": [
        {
            "sha": "463d270953f4f7025400d3932b3ec9f672631a2a",
            "filename": "packages/next/src/server/config-schema.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/0b17ac3f589176692a91b329e15db3ea2a1a802c/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-schema.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/0b17ac3f589176692a91b329e15db3ea2a1a802c/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-schema.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-schema.ts?ref=0b17ac3f589176692a91b329e15db3ea2a1a802c",
            "patch": "@@ -390,6 +390,7 @@ export const configSchema: zod.ZodType<NextConfig> = z.lazy(() =>\n         prerenderEarlyExit: z.boolean().optional(),\n         proxyTimeout: z.number().gte(0).optional(),\n         routerBFCache: z.boolean().optional(),\n+        removeUnhandledRejectionListeners: z.boolean().optional(),\n         scrollRestoration: z.boolean().optional(),\n         sri: z\n           .object({"
        },
        {
            "sha": "b975d18039f3ccf805b0ab768eb5a395b18b6640",
            "filename": "packages/next/src/server/config-shared.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/0b17ac3f589176692a91b329e15db3ea2a1a802c/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/0b17ac3f589176692a91b329e15db3ea2a1a802c/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts?ref=0b17ac3f589176692a91b329e15db3ea2a1a802c",
            "patch": "@@ -509,6 +509,16 @@ export interface ExperimentalConfig {\n    */\n   routerBFCache?: boolean\n \n+  /**\n+   * Uninstalls all \"unhandledRejection\" listeners from the global process so\n+   * that we can override the behavior, which in some runtimes is to exit the\n+   * process on an unhandled rejection.\n+   *\n+   * This is experimental until we've considered the impact in various\n+   * deployment environments.\n+   */\n+  removeUnhandledRejectionListeners?: boolean\n+\n   serverActions?: {\n     /**\n      * Allows adjusting body parser size limit for server actions.\n@@ -1302,6 +1312,7 @@ export const defaultConfig: NextConfig = {\n     useEarlyImport: false,\n     viewTransition: false,\n     routerBFCache: false,\n+    removeUnhandledRejectionListeners: false,\n     staleTimes: {\n       dynamic: 0,\n       static: 300,"
        },
        {
            "sha": "35f1e5af30d3cea397451010a4e85b981f142a3a",
            "filename": "packages/next/src/server/lib/start-server.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 17,
            "changes": 17,
            "blob_url": "https://github.com/vercel/next.js/blob/0b17ac3f589176692a91b329e15db3ea2a1a802c/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fstart-server.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/0b17ac3f589176692a91b329e15db3ea2a1a802c/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fstart-server.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fstart-server.ts?ref=0b17ac3f589176692a91b329e15db3ea2a1a802c",
            "patch": "@@ -30,7 +30,6 @@ import { CONFIG_FILES } from '../../shared/lib/constants'\n import { getStartServerInfo, logStartInfo } from './app-info-log'\n import { validateTurboNextConfig } from '../../lib/turbopack-warning'\n import { type Span, trace, flushAllTraces } from '../../trace'\n-import { isPostpone } from './router-utils/is-postpone'\n import { isIPv6 } from './is-ipv6'\n import { AsyncCallbackSet } from './async-callback-set'\n import type { NextServer } from '../next'\n@@ -331,29 +330,13 @@ export async function startServer(\n             process.exit(0)\n           })()\n         }\n-        const exception = (err: Error) => {\n-          if (isPostpone(err)) {\n-            // React postpones that are unhandled might end up logged here but they're\n-            // not really errors. They're just part of rendering.\n-            return\n-          }\n \n-          // This is the render worker, we keep the process alive\n-          console.error(err)\n-        }\n         // Make sure commands gracefully respect termination signals (e.g. from Docker)\n         // Allow the graceful termination to be manually configurable\n         if (!process.env.NEXT_MANUAL_SIG_HANDLE) {\n           process.on('SIGINT', cleanup)\n           process.on('SIGTERM', cleanup)\n         }\n-        process.on('rejectionHandled', () => {\n-          // It is ok to await a Promise late in Next.js as it allows for better\n-          // prefetching patterns to avoid waterfalls. We ignore loggining these.\n-          // We should've already errored in anyway unhandledRejection.\n-        })\n-        process.on('uncaughtException', exception)\n-        process.on('unhandledRejection', exception)\n \n         const initResult = await getRequestHandlers({\n           dir,"
        },
        {
            "sha": "a66633b09efeed4ffdd66c77bc7aa5100d1e8a76",
            "filename": "packages/next/src/server/next-server.ts",
            "status": "modified",
            "additions": 87,
            "deletions": 0,
            "changes": 87,
            "blob_url": "https://github.com/vercel/next.js/blob/0b17ac3f589176692a91b329e15db3ea2a1a802c/packages%2Fnext%2Fsrc%2Fserver%2Fnext-server.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/0b17ac3f589176692a91b329e15db3ea2a1a802c/packages%2Fnext%2Fsrc%2Fserver%2Fnext-server.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fnext-server.ts?ref=0b17ac3f589176692a91b329e15db3ea2a1a802c",
            "patch": "@@ -112,6 +112,7 @@ import { AsyncCallbackSet } from './lib/async-callback-set'\n import { initializeCacheHandlers, setCacheHandler } from './use-cache/handlers'\n import type { UnwrapPromise } from '../lib/coalesced-function'\n import { populateStaticEnv } from '../lib/static-env'\n+import { isPostpone } from './lib/router-utils/is-postpone'\n \n export * from './base-server'\n \n@@ -159,6 +160,87 @@ function getMiddlewareMatcher(\n   return matcher\n }\n \n+function installProcessErrorHandlers(\n+  shouldRemoveUnhandledRejectionListeners: boolean\n+) {\n+  // The conventional wisdom of Node.js and other runtimes is to treat\n+  // unhandled errors as fatal and exit the process.\n+  //\n+  // But Next.js is not a generic JS runtime — it's a specialized runtime for\n+  // React Server Components.\n+  //\n+  // Many unhandled rejections are due to the late-awaiting pattern for\n+  // prefetching data. In Next.js it's OK to call an async function without\n+  // immediately awaiting it, to start the request as soon as possible\n+  // without blocking unncessarily on the result. These can end up\n+  // triggering an \"unhandledRejection\" if it later turns out that the\n+  // data is not needed to render the page. Example:\n+  //\n+  //     const promise = fetchData()\n+  //     const shouldShow = await checkCondition()\n+  //     if (shouldShow) {\n+  //       return <Component promise={promise} />\n+  //     }\n+  //\n+  // In this example, `fetchData` is called immediately to start the request\n+  // as soon as possible, but if `shouldShow` is false, then it will be\n+  // discarded without unwrapping its result. If it errors, it will trigger\n+  // an \"unhandledRejection\" event.\n+  //\n+  // Ideally, we would suppress these rejections completely without warning,\n+  // because we don't consider them real errors. (TODO: Currently we do warn.)\n+  //\n+  // But regardless of whether we do or don't warn, we definitely shouldn't\n+  // crash the entire process.\n+  //\n+  // Even a \"legit\" unhandled error unrelated to prefetching shouldn't\n+  // prevent the rest of the page from rendering.\n+  //\n+  // So, we're going to intentionally override the default error handling\n+  // behavior of the outer JS runtime to be more forgiving\n+\n+  // Remove any existing \"unhandledRejection\" handlers. This is gated behind\n+  // an experimental flag until we've considered the impact in various\n+  // deployment environments. It's possible this may always need to\n+  // be configurable.\n+  if (shouldRemoveUnhandledRejectionListeners) {\n+    process.removeAllListeners('unhandledRejection')\n+  }\n+\n+  // Install a new handler to prevent the process from crashing.\n+  process.on('unhandledRejection', (reason: unknown) => {\n+    if (isPostpone(reason)) {\n+      // React postpones that are unhandled might end up logged here but they're\n+      // not really errors. They're just part of rendering.\n+      return\n+    }\n+    // Immediately log the error.\n+    // TODO: Ideally, if we knew that this error was triggered by application\n+    // code, we would suppress it entirely without logging. We can't reliably\n+    // detect all of these, but when dynamicIO is enabled, we could suppress\n+    // at least some of them by waiting to log the error until after all in-\n+    // progress renders have completed. Then, only log errors for which there\n+    // was not a corresponding \"rejectionHandled\" event.\n+    console.error(reason)\n+  })\n+\n+  process.on('rejectionHandled', () => {\n+    // TODO: See note in the unhandledRejection handler above. In the future,\n+    // we may use the \"rejectionHandled\" event to de-queue an error from\n+    // being logged.\n+  })\n+\n+  // Unhandled exceptions are errors triggered by non-async functions, so this\n+  // is unrelated to the late-awaiting pattern. However, for similar reasons,\n+  // we still shouldn't crash the process. Just log it.\n+  process.on('uncaughtException', (reason: unknown) => {\n+    if (isPostpone(reason)) {\n+      return\n+    }\n+    console.error(reason)\n+  })\n+}\n+\n export default class NextNodeServer extends BaseServer<\n   Options,\n   NodeNextRequest,\n@@ -287,6 +369,11 @@ export default class NextNodeServer extends BaseServer<\n     if (this.renderOpts.isExperimentalCompile) {\n       populateStaticEnv(this.nextConfig)\n     }\n+\n+    const shouldRemoveUnhandledRejectionListeners = Boolean(\n+      options.conf.experimental?.removeUnhandledRejectionListeners\n+    )\n+    installProcessErrorHandlers(shouldRemoveUnhandledRejectionListeners)\n   }\n \n   public async unstable_preloadEntries(): Promise<void> {"
        }
    ],
    "stats": {
        "total": 116,
        "additions": 99,
        "deletions": 17
    }
}