{
    "author": "mischnic",
    "message": "Turbopack: make stats.json useable (#81318)\n\nMake the `.next/server/webpack-stats.json` file that was already getting generated with `TURBOPACK_STATS=1` actually usable with https://statoscope.tech/.\r\n\r\nNot the most efficient implementation, but definitely works for small apps.\r\n\r\n- Chunks have the parent/child connection (though I can't see that in the UI)\r\n- Modules have the `reasons` set, so the module graph traversal works now. Note that this all ignores scope hoisting though, so there are some modules missing right now in some views\r\n\r\n![Bildschirmfoto 2025-07-04 um 22 44 42](https://github.com/user-attachments/assets/b51c93fd-fd6d-404c-b8db-26de4500beb2)",
    "sha": "f4f0c449968facd4e9a4f3fc5cbfcacd5a3972e7",
    "files": [
        {
            "sha": "44378f9ffe2535b3d77048f2af9e8391f3c625be",
            "filename": "crates/next-api/src/app.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 2,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/f4f0c449968facd4e9a4f3fc5cbfcacd5a3972e7/crates%2Fnext-api%2Fsrc%2Fapp.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f4f0c449968facd4e9a4f3fc5cbfcacd5a3972e7/crates%2Fnext-api%2Fsrc%2Fapp.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fapp.rs?ref=f4f0c449968facd4e9a4f3fc5cbfcacd5a3972e7",
            "patch": "@@ -1368,8 +1368,12 @@ impl AppEndpoint {\n                 .should_create_webpack_stats()\n                 .await?\n             {\n-                let webpack_stats =\n-                    generate_webpack_stats(app_entry.original_name.clone(), &client_assets).await?;\n+                let webpack_stats = generate_webpack_stats(\n+                    *module_graphs.base,\n+                    app_entry.original_name.clone(),\n+                    client_assets.iter().copied(),\n+                )\n+                .await?;\n                 let stats_output = VirtualOutputAsset::new(\n                     node_root.join(&format!(\n                         \"server/app{manifest_path_prefix}/webpack-stats.json\","
        },
        {
            "sha": "0b13452319de218e770bd7b9122639e3030c633f",
            "filename": "crates/next-api/src/pages.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 2,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/f4f0c449968facd4e9a4f3fc5cbfcacd5a3972e7/crates%2Fnext-api%2Fsrc%2Fpages.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f4f0c449968facd4e9a4f3fc5cbfcacd5a3972e7/crates%2Fnext-api%2Fsrc%2Fpages.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fpages.rs?ref=f4f0c449968facd4e9a4f3fc5cbfcacd5a3972e7",
            "patch": "@@ -1392,8 +1392,12 @@ impl PageEndpoint {\n             .should_create_webpack_stats()\n             .await?\n         {\n-            let webpack_stats =\n-                generate_webpack_stats(original_name.to_owned(), &client_assets.await?).await?;\n+            let webpack_stats = generate_webpack_stats(\n+                self.client_module_graph(),\n+                original_name.to_owned(),\n+                client_assets.await?.iter().copied(),\n+            )\n+            .await?;\n             let stats_output = VirtualOutputAsset::new(\n                 node_root.join(&format!(\n                     \"server/pages{manifest_path_prefix}/webpack-stats.json\","
        },
        {
            "sha": "9f466fb8bc0437b94da3dd468c796c633e7c323c",
            "filename": "crates/next-api/src/webpack_stats.rs",
            "status": "modified",
            "additions": 180,
            "deletions": 38,
            "changes": 218,
            "blob_url": "https://github.com/vercel/next.js/blob/f4f0c449968facd4e9a4f3fc5cbfcacd5a3972e7/crates%2Fnext-api%2Fsrc%2Fwebpack_stats.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f4f0c449968facd4e9a4f3fc5cbfcacd5a3972e7/crates%2Fnext-api%2Fsrc%2Fwebpack_stats.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fwebpack_stats.rs?ref=f4f0c449968facd4e9a4f3fc5cbfcacd5a3972e7",
            "patch": "@@ -1,79 +1,176 @@\n use anyhow::Result;\n+use rustc_hash::FxHashSet;\n use serde::Serialize;\n+use tracing::{Level, instrument};\n use turbo_rcstr::RcStr;\n-use turbo_tasks::{FxIndexMap, FxIndexSet, ResolvedVc, Vc};\n+use turbo_tasks::{\n+    FxIndexMap, FxIndexSet, ResolvedVc, TryJoinIterExt, ValueToString, Vc, fxindexmap,\n+};\n use turbopack_browser::ecmascript::EcmascriptBrowserChunk;\n use turbopack_core::{\n-    chunk::{Chunk, ChunkItem},\n+    chunk::{Chunk, ChunkItem, ChunkItemExt, ModuleId},\n+    module::Module,\n+    module_graph::ModuleGraph,\n     output::OutputAsset,\n };\n \n-pub async fn generate_webpack_stats<'a, I>(\n+#[instrument(level = Level::INFO, skip_all)]\n+pub async fn generate_webpack_stats<I>(\n+    module_graph: Vc<ModuleGraph>,\n     entry_name: RcStr,\n     entry_assets: I,\n ) -> Result<WebpackStats>\n where\n-    I: IntoIterator<Item = &'a ResolvedVc<Box<dyn OutputAsset>>>,\n+    I: IntoIterator<Item = ResolvedVc<Box<dyn OutputAsset>>>,\n {\n     let mut assets = vec![];\n     let mut chunks = vec![];\n     let mut chunk_items: FxIndexMap<Vc<Box<dyn ChunkItem>>, FxIndexSet<RcStr>> =\n         FxIndexMap::default();\n-    let mut modules = vec![];\n+\n+    let entry_assets = entry_assets.into_iter().collect::<Vec<_>>();\n+\n+    let (asset_parents, asset_children) = {\n+        let mut asset_children =\n+            FxIndexMap::with_capacity_and_hasher(entry_assets.len(), Default::default());\n+        let mut visited =\n+            FxHashSet::with_capacity_and_hasher(entry_assets.len(), Default::default());\n+        let mut queue = entry_assets.clone();\n+        while let Some(asset) = queue.pop() {\n+            if visited.insert(asset) {\n+                let references = asset.references().await?;\n+                asset_children.insert(asset, references.clone());\n+                queue.extend(references);\n+            }\n+        }\n+\n+        let mut asset_parents: FxIndexMap<_, Vec<_>> =\n+            FxIndexMap::with_capacity_and_hasher(entry_assets.len(), Default::default());\n+        for (&parent, children) in &asset_children {\n+            for child in children {\n+                asset_parents.entry(*child).or_default().push(parent);\n+            }\n+        }\n+\n+        (asset_parents, asset_children)\n+    };\n+\n+    let asset_reasons = {\n+        let module_graph = module_graph.await?;\n+        let mut edges = vec![];\n+        module_graph\n+            .traverse_all_edges_unordered(|(parent_node, r), current| {\n+                edges.push((\n+                    parent_node.module,\n+                    RcStr::from(format!(\"{}: {}\", r.chunking_type, r.export)),\n+                    current.module,\n+                ));\n+                Ok(())\n+            })\n+            .await?;\n+\n+        let edges = edges\n+            .into_iter()\n+            .map(async |(parent, ty, child)| {\n+                let parent_path = parent.ident().path().await?.path.clone();\n+                Ok((\n+                    child,\n+                    WebpackStatsReason {\n+                        module: parent_path.clone(),\n+                        module_identifier: parent.ident().to_string().owned().await?,\n+                        module_name: parent_path,\n+                        ty,\n+                    },\n+                ))\n+            })\n+            .try_join()\n+            .await?;\n+\n+        let mut asset_reasons: FxIndexMap<_, Vec<_>> = FxIndexMap::default();\n+        for (child, reason) in edges {\n+            asset_reasons.entry(child).or_default().push(reason);\n+        }\n+        asset_reasons\n+    };\n+\n     for asset in entry_assets {\n-        let path = normalize_client_path(&asset.path().await?.path);\n+        let path = RcStr::from(normalize_client_path(&asset.path().await?.path));\n \n         let Some(asset_len) = *asset.size_bytes().await? else {\n             continue;\n         };\n \n-        if let Some(chunk) = ResolvedVc::try_downcast_type::<EcmascriptBrowserChunk>(*asset) {\n-            let chunk_ident = normalize_client_path(&chunk.path().await?.path);\n+        if let Some(chunk) = ResolvedVc::try_downcast_type::<EcmascriptBrowserChunk>(asset) {\n             chunks.push(WebpackStatsChunk {\n                 size: asset_len,\n-                files: vec![chunk_ident.clone().into()],\n-                id: chunk_ident.clone().into(),\n+                files: vec![path.clone()],\n+                id: path.clone(),\n+                parents: if let Some(parents) = asset_parents.get(&asset) {\n+                    parents\n+                        .iter()\n+                        .map(async |c| Ok(normalize_client_path(&c.path().await?.path).into()))\n+                        .try_join()\n+                        .await?\n+                } else {\n+                    vec![]\n+                },\n+                children: if let Some(children) = asset_children.get(&asset) {\n+                    children\n+                        .iter()\n+                        .map(async |c| Ok(normalize_client_path(&c.path().await?.path).into()))\n+                        .try_join()\n+                        .await?\n+                } else {\n+                    vec![]\n+                },\n                 ..Default::default()\n             });\n \n             for item in chunk.chunk().chunk_items().await? {\n-                // let name =\n-                chunk_items\n-                    .entry(**item)\n-                    .or_default()\n-                    .insert(chunk_ident.clone().into());\n+                chunk_items.entry(**item).or_default().insert(path.clone());\n             }\n         }\n \n         assets.push(WebpackStatsAsset {\n             ty: \"asset\".into(),\n-            name: path.clone().into(),\n-            chunks: vec![path.into()],\n+            name: path.clone(),\n+            chunk_names: vec![path],\n             size: asset_len,\n             ..Default::default()\n         });\n     }\n \n-    for (chunk_item, chunks) in chunk_items {\n-        let size = *chunk_item\n-            .content_ident()\n-            .path()\n-            .await?\n-            .read()\n-            .len()\n-            .await?;\n-        let path = chunk_item.asset_ident().path().await?.path.clone();\n-        modules.push(WebpackStatsModule {\n-            name: path.clone(),\n-            id: path.clone(),\n-            chunks: chunks.into_iter().collect(),\n-            size,\n-        });\n-    }\n+    // TODO try to downcast modules to `EcmascriptMergedModule` to include the scope hoisted modules\n+    // as well\n+\n+    let modules = chunk_items\n+        .into_iter()\n+        .map(async |(chunk_item, chunks)| {\n+            let size = *chunk_item\n+                .content_ident()\n+                .path()\n+                .await?\n+                .read()\n+                .len()\n+                .await?;\n+            Ok(WebpackStatsModule {\n+                name: chunk_item.asset_ident().path().await?.path.clone(),\n+                id: chunk_item.id().owned().await?,\n+                identifier: chunk_item.asset_ident().to_string().owned().await?,\n+                chunks: chunks.into_iter().collect(),\n+                size,\n+                // TODO Find all incoming edges to this module\n+                reasons: asset_reasons\n+                    .get(&chunk_item.module().to_resolved().await?)\n+                    .cloned()\n+                    .unwrap_or_default(),\n+            })\n+        })\n+        .try_join()\n+        .await?;\n \n-    let mut entrypoints = FxIndexMap::default();\n-    entrypoints.insert(\n-        entry_name.clone(),\n+    let entrypoints: FxIndexMap<_, _> = fxindexmap!(\n+        entry_name.clone() =>\n         WebpackStatsEntrypoint {\n             name: entry_name.clone(),\n             chunks: chunks.iter().map(|c| c.id.clone()).collect(),\n@@ -83,7 +180,7 @@ where\n                     name: a.name.clone(),\n                 })\n                 .collect(),\n-        },\n+        }\n     );\n \n     Ok(WebpackStats {\n@@ -108,35 +205,80 @@ pub struct WebpackStatsAssetInfo {}\n pub struct WebpackStatsAsset {\n     #[serde(rename = \"type\")]\n     pub ty: RcStr,\n+    /// The `output` filename\n     pub name: RcStr,\n     pub info: WebpackStatsAssetInfo,\n+    /// The size of the file in bytes\n     pub size: u64,\n+    /// Indicates whether or not the asset made it to the `output` directory\n     pub emitted: bool,\n+    /// Indicates whether or not the asset was compared with the same file on the output file\n+    /// system\n     pub compared_for_emit: bool,\n     pub cached: bool,\n+    /// The chunks this asset contains\n+    pub chunk_names: Vec<RcStr>,\n+    /// The chunk IDs this asset contains\n     pub chunks: Vec<RcStr>,\n }\n \n #[derive(Serialize, Debug, Default)]\n #[serde(rename_all = \"camelCase\")]\n pub struct WebpackStatsChunk {\n+    /// Indicates whether or not the chunk went through Code Generation\n     pub rendered: bool,\n+    /// Indicates whether this chunk is loaded on initial page load or lazily.\n     pub initial: bool,\n+    /// Indicates whether or not the chunk contains the webpack runtime\n     pub entry: bool,\n     pub recorded: bool,\n+    /// The ID of this chunk\n     pub id: RcStr,\n+    /// Chunk size in bytes\n     pub size: u64,\n     pub hash: RcStr,\n+    /// An array of filename strings that contain this chunk\n     pub files: Vec<RcStr>,\n+    /// An list of chunk names contained within this chunk\n+    pub names: Vec<RcStr>,\n+    /// Parent chunk IDs\n+    pub parents: Vec<RcStr>,\n+    /// Child chunk IDs\n+    pub children: Vec<RcStr>,\n }\n \n #[derive(Serialize, Debug)]\n #[serde(rename_all = \"camelCase\")]\n pub struct WebpackStatsModule {\n+    /// Path to the actual file\n     pub name: RcStr,\n-    pub id: RcStr,\n+    /// The ID of the module\n+    pub id: ModuleId,\n+    /// A unique ID used internally\n+    pub identifier: RcStr,\n     pub chunks: Vec<RcStr>,\n     pub size: Option<u64>,\n+    pub reasons: Vec<WebpackStatsReason>,\n+}\n+\n+#[derive(Clone, Serialize, Debug)]\n+#[serde(rename_all = \"camelCase\")]\n+pub struct WebpackStatsReason {\n+    /// The [WebpackStatsModule::name]\n+    pub module: RcStr,\n+    // /// The [WebpackStatsModule::id]\n+    // pub module_id: ModuleId,\n+    /// The [WebpackStatsModule::identifier]\n+    pub module_identifier: RcStr,\n+    /// A more readable name for the module (used for \"pretty-printing\")\n+    pub module_name: RcStr,\n+    /// The [type of request](/api/module-methods) used\n+    #[serde(rename = \"type\")]\n+    pub ty: RcStr,\n+    // /// Raw string used for the `import` or `require` request\n+    // pub user_request: RcStr,\n+    // /// Lines of code that caused the module to be included\n+    // pub loc: RcStr\n }\n \n #[derive(Serialize, Debug)]"
        },
        {
            "sha": "9b56186d2cfffc9d08cbc2aa0dbb1238b70274c0",
            "filename": "packages/next/src/shared/lib/turbopack/manifest-loader.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/f4f0c449968facd4e9a4f3fc5cbfcacd5a3972e7/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fturbopack%2Fmanifest-loader.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f4f0c449968facd4e9a4f3fc5cbfcacd5a3972e7/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fturbopack%2Fmanifest-loader.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fturbopack%2Fmanifest-loader.ts?ref=f4f0c449968facd4e9a4f3fc5cbfcacd5a3972e7",
            "patch": "@@ -339,7 +339,7 @@ export class TurbopackManifestLoader {\n   private mergeWebpackStats(statsFiles: Iterable<WebpackStats>): WebpackStats {\n     const entrypoints: Record<string, StatsChunkGroup> = {}\n     const assets: Map<string, StatsAsset> = new Map()\n-    const chunks: Map<string, StatsChunk> = new Map()\n+    const chunks: Map<string | number, StatsChunk> = new Map()\n     const modules: Map<string | number, StatsModule> = new Map()\n \n     for (const statsFile of statsFiles) {\n@@ -361,8 +361,8 @@ export class TurbopackManifestLoader {\n \n       if (statsFile.chunks) {\n         for (const chunk of statsFile.chunks) {\n-          if (!chunks.has(chunk.name)) {\n-            chunks.set(chunk.name, chunk)\n+          if (!chunks.has(chunk.id!)) {\n+            chunks.set(chunk.id!, chunk)\n           }\n         }\n       }\n@@ -388,6 +388,7 @@ export class TurbopackManifestLoader {\n     }\n \n     return {\n+      version: 'Turbopack',\n       entrypoints,\n       assets: [...assets.values()],\n       chunks: [...chunks.values()],"
        },
        {
            "sha": "1bbd57da03082088451d5d34f0ef2b4dfcb46a86",
            "filename": "turbopack/crates/turbopack-core/src/chunk/mod.rs",
            "status": "modified",
            "additions": 45,
            "deletions": 0,
            "changes": 45,
            "blob_url": "https://github.com/vercel/next.js/blob/f4f0c449968facd4e9a4f3fc5cbfcacd5a3972e7/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f4f0c449968facd4e9a4f3fc5cbfcacd5a3972e7/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fmod.rs?ref=f4f0c449968facd4e9a4f3fc5cbfcacd5a3972e7",
            "patch": "@@ -294,6 +294,51 @@ pub enum ChunkingType {\n     Traced,\n }\n \n+impl Display for ChunkingType {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        match self {\n+            ChunkingType::Parallel {\n+                inherit_async,\n+                hoisted,\n+            } => {\n+                write!(\n+                    f,\n+                    \"Parallel(inherit_async: {inherit_async}, hoisted: {hoisted})\",\n+                )\n+            }\n+            ChunkingType::Async => write!(f, \"Async\"),\n+            ChunkingType::Isolated {\n+                _ty,\n+                merge_tag: Some(merge_tag),\n+            } => {\n+                write!(f, \"Isolated(merge_tag: {merge_tag})\")\n+            }\n+            ChunkingType::Isolated {\n+                _ty,\n+                merge_tag: None,\n+            } => {\n+                write!(f, \"Isolated\")\n+            }\n+            ChunkingType::Shared {\n+                inherit_async,\n+                merge_tag: Some(merge_tag),\n+            } => {\n+                write!(\n+                    f,\n+                    \"Shared(inherit_async: {inherit_async}, merge_tag: {merge_tag})\"\n+                )\n+            }\n+            ChunkingType::Shared {\n+                inherit_async,\n+                merge_tag: None,\n+            } => {\n+                write!(f, \"Shared(inherit_async: {inherit_async})\")\n+            }\n+            ChunkingType::Traced => write!(f, \"Traced\"),\n+        }\n+    }\n+}\n+\n impl ChunkingType {\n     pub fn is_inherit_async(&self) -> bool {\n         matches!("
        },
        {
            "sha": "2a58afa6e9d8839f1170be4c293fe1bb388d4cbd",
            "filename": "turbopack/crates/turbopack-core/src/resolve/mod.rs",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/f4f0c449968facd4e9a4f3fc5cbfcacd5a3972e7/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f4f0c449968facd4e9a4f3fc5cbfcacd5a3972e7/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fmod.rs?ref=f4f0c449968facd4e9a4f3fc5cbfcacd5a3972e7",
            "patch": "@@ -114,6 +114,16 @@ pub enum ExportUsage {\n     Evaluation,\n }\n \n+impl Display for ExportUsage {\n+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\n+        match self {\n+            ExportUsage::Named(name) => write!(f, \"export {name}\"),\n+            ExportUsage::All => write!(f, \"all\"),\n+            ExportUsage::Evaluation => write!(f, \"evaluation\"),\n+        }\n+    }\n+}\n+\n #[turbo_tasks::value_impl]\n impl ExportUsage {\n     #[turbo_tasks::function]"
        }
    ],
    "stats": {
        "total": 296,
        "additions": 251,
        "deletions": 45
    }
}