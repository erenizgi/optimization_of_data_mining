{
    "author": "sokra",
    "message": "Turbopack: parallel connect children (#84173)\n\n### What?\n\nparallize connecting children when there are a lot of children. This avoid the long single threaded work.",
    "sha": "bced1f7b207b6bfd50c70764a204cc9d70a3ffe3",
    "files": [
        {
            "sha": "2ebb71354d5ac1ac177fcbc69c2f6959946c1f13",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 28,
            "deletions": 32,
            "changes": 60,
            "blob_url": "https://github.com/vercel/next.js/blob/bced1f7b207b6bfd50c70764a204cc9d70a3ffe3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/bced1f7b207b6bfd50c70764a204cc9d70a3ffe3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=bced1f7b207b6bfd50c70764a204cc9d70a3ffe3",
            "patch": "@@ -1752,13 +1752,20 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         // suspend in `CleanupOldEdgesOperation`), but that's ok as the task is still dirty and\n         // would be executed again.\n \n-        if self.task_execution_completed_connect(&mut ctx, task_id, new_children, is_now_immutable)\n+        let has_new_children = !new_children.is_empty();\n+        if has_new_children\n+            && self.task_execution_completed_connect(&mut ctx, task_id, new_children)\n         {\n             // Task was stale and has been rescheduled\n             return true;\n         }\n \n-        if self.task_execution_completed_finish(&mut ctx, task_id, &mut removed_data) {\n+        if self.task_execution_completed_finish(\n+            &mut ctx,\n+            task_id,\n+            &mut removed_data,\n+            is_now_immutable,\n+        ) {\n             // Task was stale and has been rescheduled\n             return true;\n         }\n@@ -1997,8 +2004,9 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         ctx: &mut impl ExecuteContext<'_>,\n         task_id: TaskId,\n         new_children: FxHashSet<TaskId>,\n-        is_now_immutable: bool,\n     ) -> bool {\n+        debug_assert!(!new_children.is_empty());\n+\n         let mut task = ctx.task(task_id, TaskDataCategory::All);\n         let Some(in_progress) = get!(task, InProgress) else {\n             panic!(\"Task execution completed, but task is not in progress: {task:#?}\");\n@@ -2039,35 +2047,16 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             return true;\n         }\n \n-        // If the task is not stateful and has no mutable children, it does not have a way to be\n-        // invalidated and we can mark it as immutable.\n-        if is_now_immutable {\n-            let _ = task.add(CachedDataItem::Immutable { value: () });\n-        }\n-\n-        let mut queue = AggregationUpdateQueue::new();\n-\n-        let has_new_children = !new_children.is_empty();\n-        if has_new_children {\n-            let has_active_count = ctx.should_track_activeness()\n-                && get!(task, Activeness).map_or(false, |activeness| activeness.active_counter > 0);\n-            connect_children(\n-                task_id,\n-                &mut task,\n-                new_children,\n-                &mut queue,\n-                has_active_count,\n-                ctx.should_track_activeness(),\n-            );\n-        }\n-\n-        drop(task);\n-\n-        if has_new_children {\n-            #[cfg(feature = \"trace_task_completion\")]\n-            let _span = tracing::trace_span!(\"connect new children\").entered();\n-            queue.execute(ctx);\n-        }\n+        let has_active_count = ctx.should_track_activeness()\n+            && get!(task, Activeness).map_or(false, |activeness| activeness.active_counter > 0);\n+        connect_children(\n+            ctx,\n+            task_id,\n+            task,\n+            new_children,\n+            has_active_count,\n+            ctx.should_track_activeness(),\n+        );\n \n         false\n     }\n@@ -2077,6 +2066,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         ctx: &mut impl ExecuteContext<'_>,\n         task_id: TaskId,\n         removed_data: &mut Vec<CachedDataItem>,\n+        is_now_immutable: bool,\n     ) -> bool {\n         let mut task = ctx.task(task_id, TaskDataCategory::All);\n         let Some(in_progress) = remove!(task, InProgress) else {\n@@ -2107,6 +2097,12 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             return true;\n         }\n \n+        // If the task is not stateful and has no mutable children, it does not have a way to be\n+        // invalidated and we can mark it as immutable.\n+        if is_now_immutable {\n+            let _ = task.add(CachedDataItem::Immutable { value: () });\n+        }\n+\n         // Notify in progress cells\n         removed_data.extend(task.extract_if(\n             CachedDataItemType::InProgressCell,"
        },
        {
            "sha": "fd9a7ceede7e5c3d378f50e0fce29ffb33c17485",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/connect_children.rs",
            "status": "modified",
            "additions": 119,
            "deletions": 39,
            "changes": 158,
            "blob_url": "https://github.com/vercel/next.js/blob/bced1f7b207b6bfd50c70764a204cc9d70a3ffe3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fconnect_children.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/bced1f7b207b6bfd50c70764a204cc9d70a3ffe3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fconnect_children.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fconnect_children.rs?ref=bced1f7b207b6bfd50c70764a204cc9d70a3ffe3",
            "patch": "@@ -1,29 +1,31 @@\n use rustc_hash::FxHashSet;\n use smallvec::SmallVec;\n-use turbo_tasks::TaskId;\n+use turbo_tasks::{\n+    TaskId,\n+    scope::scope_and_block,\n+    util::{good_chunk_size, into_chunks},\n+};\n \n use crate::{\n     backend::operation::{\n-        AggregationUpdateJob, AggregationUpdateQueue, TaskGuard,\n-        aggregation_update::InnerOfUppersHasNewFollowersJob, get_aggregation_number, get_uppers,\n-        is_aggregating_node,\n+        AggregationUpdateJob, AggregationUpdateQueue, ChildExecuteContext, ExecuteContext,\n+        Operation, TaskGuard, aggregation_update::InnerOfUppersHasNewFollowersJob,\n+        get_aggregation_number, get_uppers, is_aggregating_node,\n     },\n     data::CachedDataItem,\n };\n \n pub fn connect_children(\n+    ctx: &mut impl ExecuteContext<'_>,\n     parent_task_id: TaskId,\n-    parent_task: &mut impl TaskGuard,\n+    mut parent_task: impl TaskGuard,\n     new_children: FxHashSet<TaskId>,\n-    queue: &mut AggregationUpdateQueue,\n     has_active_count: bool,\n     should_track_activeness: bool,\n ) {\n-    if new_children.is_empty() {\n-        return;\n-    }\n+    debug_assert!(!new_children.is_empty());\n \n-    let parent_aggregation = get_aggregation_number(parent_task);\n+    let parent_aggregation = get_aggregation_number(&parent_task);\n \n     for &new_child in new_children.iter() {\n         parent_task.add_new(CachedDataItem::Child {\n@@ -35,39 +37,117 @@ pub fn connect_children(\n     let new_follower_ids: SmallVec<_> = new_children.into_iter().collect();\n \n     let aggregating_node = is_aggregating_node(parent_aggregation);\n-    let upper_ids = (!aggregating_node).then(|| get_uppers(&*parent_task));\n+    let upper_ids = (!aggregating_node).then(|| get_uppers(&parent_task));\n \n-    if let Some(upper_ids) = upper_ids {\n-        // Parent is a leaf node, the children are followers of it now.\n-        if !upper_ids.is_empty() {\n-            queue.push(\n-                InnerOfUppersHasNewFollowersJob {\n-                    upper_ids,\n-                    new_follower_ids: new_follower_ids.clone(),\n-                }\n-                .into(),\n-            );\n-        }\n-        // We need to decrease the active count because we temporarily increased it during\n-        // connect_child. We need to increase the active count when the parent has active\n-        // count, because it's added as follower.\n-        if should_track_activeness && !has_active_count {\n-            queue.push(AggregationUpdateJob::DecreaseActiveCounts {\n-                task_ids: new_follower_ids,\n-            })\n-        }\n-    } else {\n-        // Parent is an aggregating node. We run the normal code to connect the children.\n-        queue.push(AggregationUpdateJob::InnerOfUpperHasNewFollowers {\n-            upper_id: parent_task_id,\n-            new_follower_ids: new_follower_ids.clone(),\n-        });\n-        // We need to decrease the active count because we temporarily increased it during\n-        // connect_child.\n-        if should_track_activeness {\n+    drop(parent_task);\n+\n+    fn process_new_children(\n+        ctx: &mut impl ExecuteContext<'_>,\n+        new_follower_ids: SmallVec<[TaskId; 4]>,\n+        upper_ids: Option<SmallVec<[TaskId; 4]>>,\n+        parent_task_id: TaskId,\n+        has_active_count: bool,\n+        should_track_activeness: bool,\n+    ) {\n+        debug_assert!(!new_follower_ids.is_empty());\n+\n+        let mut queue = AggregationUpdateQueue::new();\n+\n+        if let Some(upper_ids) = upper_ids {\n+            // We need to add new followers when there are upper ids as the parent is a leaf node\n+            // and new children are new followers.\n+            let add_followers = !upper_ids.is_empty();\n+\n+            // And we need decrease the active count when parent doesn't have an active count as the\n+            // active count was temporarily increased during connect_child. We need to\n+            // increase the active count when the parent has active count, because it's\n+            // added as follower.\n+            let decrease_active_count = should_track_activeness && !has_active_count;\n+\n+            // We special case the situation when we need to do both operations to avoid\n+            // cloning the new follower ids unnecessarily.\n+            if decrease_active_count && add_followers {\n+                queue.push(\n+                    InnerOfUppersHasNewFollowersJob {\n+                        upper_ids,\n+                        new_follower_ids: new_follower_ids.clone(),\n+                    }\n+                    .into(),\n+                );\n+                queue.push(AggregationUpdateJob::DecreaseActiveCounts {\n+                    task_ids: new_follower_ids,\n+                })\n+            } else if decrease_active_count {\n+                queue.push(AggregationUpdateJob::DecreaseActiveCounts {\n+                    task_ids: new_follower_ids,\n+                })\n+            } else if add_followers {\n+                queue.push(\n+                    InnerOfUppersHasNewFollowersJob {\n+                        upper_ids,\n+                        new_follower_ids,\n+                    }\n+                    .into(),\n+                );\n+            }\n+        } else if should_track_activeness {\n+            // Parent is an aggregating node. We run the normal code to connect the children.\n+            queue.push(AggregationUpdateJob::InnerOfUpperHasNewFollowers {\n+                upper_id: parent_task_id,\n+                new_follower_ids: new_follower_ids.clone(),\n+            });\n+            // We need to decrease the active count because we temporarily increased it during\n+            // connect_child.\n             queue.push(AggregationUpdateJob::DecreaseActiveCounts {\n                 task_ids: new_follower_ids,\n             });\n+        } else {\n+            // Parent is an aggregating node. We run the normal code to connect the children.\n+            queue.push(AggregationUpdateJob::InnerOfUpperHasNewFollowers {\n+                upper_id: parent_task_id,\n+                new_follower_ids,\n+            });\n+        }\n+\n+        {\n+            #[cfg(feature = \"trace_task_completion\")]\n+            let _span = tracing::trace_span!(\"connect new children\").entered();\n+            queue.execute(ctx);\n         }\n     }\n+\n+    const MIN_CHILDREN_FOR_PARALLEL: usize = 10000;\n+\n+    let len = new_follower_ids.len();\n+    if len >= MIN_CHILDREN_FOR_PARALLEL {\n+        let new_follower_ids = new_follower_ids.into_vec();\n+        let chunk_size = good_chunk_size(len);\n+        let _ = scope_and_block(len.div_ceil(chunk_size), |scope| {\n+            for chunk in into_chunks(new_follower_ids, chunk_size) {\n+                let upper_ids = &upper_ids;\n+                let child_ctx = ctx.child_context();\n+                scope.spawn(move || {\n+                    let mut ctx = child_ctx.create();\n+                    let new_follower_ids = chunk.collect::<SmallVec<[_; 4]>>();\n+                    process_new_children(\n+                        &mut ctx,\n+                        new_follower_ids,\n+                        upper_ids.clone(),\n+                        parent_task_id,\n+                        has_active_count,\n+                        should_track_activeness,\n+                    );\n+                });\n+            }\n+        });\n+    } else {\n+        process_new_children(\n+            ctx,\n+            new_follower_ids,\n+            upper_ids,\n+            parent_task_id,\n+            has_active_count,\n+            should_track_activeness,\n+        );\n+    }\n }"
        },
        {
            "sha": "ee37e2a2475508ae02c370c8597448fcd3dd6468",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/mod.rs",
            "status": "modified",
            "additions": 33,
            "deletions": 0,
            "changes": 33,
            "blob_url": "https://github.com/vercel/next.js/blob/bced1f7b207b6bfd50c70764a204cc9d70a3ffe3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/bced1f7b207b6bfd50c70764a204cc9d70a3ffe3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs?ref=bced1f7b207b6bfd50c70764a204cc9d70a3ffe3",
            "patch": "@@ -48,6 +48,9 @@ enum TransactionState<'a, 'tx, B: BackingStorage> {\n }\n \n pub trait ExecuteContext<'e>: Sized {\n+    fn child_context<'l, 'r>(&'r self) -> impl ChildExecuteContext<'l> + use<'e, 'l, Self>\n+    where\n+        'e: 'l;\n     fn session_id(&self) -> SessionId;\n     fn task(&mut self, task_id: TaskId, category: TaskDataCategory) -> impl TaskGuard + 'e;\n     fn is_once_task(&self, task_id: TaskId) -> bool;\n@@ -69,6 +72,10 @@ pub trait ExecuteContext<'e>: Sized {\n     fn should_track_activeness(&self) -> bool;\n }\n \n+pub trait ChildExecuteContext<'e>: Send + Sized {\n+    fn create(self) -> impl ExecuteContext<'e>;\n+}\n+\n pub struct ExecuteContextImpl<'e, 'tx, B: BackingStorage>\n where\n     Self: 'e,\n@@ -156,6 +163,16 @@ impl<'e, 'tx, B: BackingStorage> ExecuteContext<'e> for ExecuteContextImpl<'e, '\n where\n     'tx: 'e,\n {\n+    fn child_context<'l, 'r>(&'r self) -> impl ChildExecuteContext<'l> + use<'e, 'tx, 'l, B>\n+    where\n+        'e: 'l,\n+    {\n+        ChildExecuteContextImpl {\n+            backend: self.backend,\n+            turbo_tasks: self.turbo_tasks,\n+        }\n+    }\n+\n     fn session_id(&self) -> SessionId {\n         self.backend.session_id()\n     }\n@@ -297,6 +314,22 @@ where\n     }\n }\n \n+struct ChildExecuteContextImpl<'e, B: BackingStorage> {\n+    backend: &'e TurboTasksBackendInner<B>,\n+    turbo_tasks: &'e dyn TurboTasksBackendApi<TurboTasksBackend<B>>,\n+}\n+\n+impl<'e, B: BackingStorage> ChildExecuteContext<'e> for ChildExecuteContextImpl<'e, B> {\n+    fn create(self) -> impl ExecuteContext<'e> {\n+        ExecuteContextImpl {\n+            backend: self.backend,\n+            turbo_tasks: self.turbo_tasks,\n+            _operation_guard: None,\n+            transaction: TransactionState::None,\n+        }\n+    }\n+}\n+\n pub trait TaskGuard: Debug {\n     fn id(&self) -> TaskId;\n     #[must_use]"
        }
    ],
    "stats": {
        "total": 251,
        "additions": 180,
        "deletions": 71
    }
}