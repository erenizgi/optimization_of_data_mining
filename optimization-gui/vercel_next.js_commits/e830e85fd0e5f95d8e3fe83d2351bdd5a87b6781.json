{
    "author": "lukesandberg",
    "message": "[turbopack] Reorganize the fields in LocalTaskType to avoid an allocation (#80738)\n\n### What?\nCreate a new `struct` `LocalTaskSpec` that holds a `LocalTaskType` as an enum.  This allows us to share the common fields and push the formatting routines down to the LocalTaskType.\n\n### Why?\nThis allows us to avoid an `Arc::new` call when launching tasks since the `LocalTaskType` enum now becomes copyable.",
    "sha": "e830e85fd0e5f95d8e3fe83d2351bdd5a87b6781",
    "files": [
        {
            "sha": "734c7b28ae926f9106d91d6b01ff4514d89b8b42",
            "filename": "turbopack/crates/turbo-tasks/src/manager.rs",
            "status": "modified",
            "additions": 12,
            "deletions": 14,
            "changes": 26,
            "blob_url": "https://github.com/vercel/next.js/blob/e830e85fd0e5f95d8e3fe83d2351bdd5a87b6781/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e830e85fd0e5f95d8e3fe83d2351bdd5a87b6781/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs?ref=e830e85fd0e5f95d8e3fe83d2351bdd5a87b6781",
            "patch": "@@ -39,7 +39,7 @@ use crate::{\n     raw_vc::{CellId, RawVc},\n     registry,\n     serialization_invalidation::SerializationInvalidator,\n-    task::local_task::{LocalTask, LocalTaskType},\n+    task::local_task::{LocalTask, LocalTaskSpec, LocalTaskType},\n     task_statistics::TaskStatisticsApi,\n     trace::TraceRawVcs,\n     util::{IdFactory, StaticOrArc},\n@@ -595,8 +595,8 @@ impl<B: Backend + 'static> TurboTasks<B> {\n     ) -> RawVc {\n         match persistence {\n             TaskPersistence::Local => {\n-                let task_type = LocalTaskType::Native {\n-                    native_fn,\n+                let task_type = LocalTaskSpec {\n+                    task_type: LocalTaskType::Native { native_fn },\n                     this,\n                     arg,\n                 };\n@@ -645,8 +645,8 @@ impl<B: Backend + 'static> TurboTasks<B> {\n         if this.is_none_or(|this| this.is_resolved()) && native_fn.arg_meta.is_resolved(&*arg) {\n             return self.native_call(native_fn, this, arg, persistence);\n         }\n-        let task_type = LocalTaskType::ResolveNative {\n-            native_fn,\n+        let task_type = LocalTaskSpec {\n+            task_type: LocalTaskType::ResolveNative { native_fn },\n             this,\n             arg,\n         };\n@@ -678,9 +678,9 @@ impl<B: Backend + 'static> TurboTasks<B> {\n         }\n \n         // create a wrapper task to resolve all inputs\n-        let task_type = LocalTaskType::ResolveTrait {\n-            trait_method,\n-            this,\n+        let task_type = LocalTaskSpec {\n+            task_type: LocalTaskType::ResolveTrait { trait_method },\n+            this: Some(this),\n             arg,\n         };\n \n@@ -774,7 +774,7 @@ impl<B: Backend + 'static> TurboTasks<B> {\n \n     fn schedule_local_task(\n         &self,\n-        ty: LocalTaskType,\n+        ty: LocalTaskSpec,\n         // if this is a `LocalTaskType::Resolve*`, we may spawn another task with this persistence,\n         // if this is a `LocalTaskType::Native`, persistence is unused.\n         //\n@@ -784,14 +784,13 @@ impl<B: Backend + 'static> TurboTasks<B> {\n         // don't end up owning any cells.\n         persistence: TaskPersistence,\n     ) -> RawVc {\n-        let ty = Arc::new(ty);\n+        let task_type = ty.task_type;\n         let (global_task_state, parent_task_id, execution_id, local_task_id) = CURRENT_TASK_STATE\n             .with(|gts| {\n                 let mut gts_write = gts.write().unwrap();\n                 let local_task_id = gts_write.create_local_task(LocalTask::Scheduled {\n                     done_event: Event::new({\n-                        let ty = Arc::clone(&ty);\n-                        move || format!(\"LocalTask({ty})::done_event\")\n+                        move || format!(\"LocalTask({task_type})::done_event\")\n                     }),\n                 });\n                 (\n@@ -815,7 +814,6 @@ impl<B: Backend + 'static> TurboTasks<B> {\n         let future = async move {\n             let TaskExecutionSpec { future, span } =\n                 crate::task::local_task::get_local_task_execution_spec(&*this, &ty, persistence);\n-            let ty = ty.clone();\n             async move {\n                 let (result, _duration, _memory_usage) = CaptureFuture::new(future).await;\n \n@@ -828,7 +826,7 @@ impl<B: Backend + 'static> TurboTasks<B> {\n                 let local_task = LocalTask::Done {\n                     output: match result {\n                         Ok(raw_vc) => OutputContent::Link(raw_vc),\n-                        Err(err) => OutputContent::Error(err.task_context(ty)),\n+                        Err(err) => OutputContent::Error(err.task_context(task_type)),\n                     },\n                 };\n "
        },
        {
            "sha": "59e8116cbee3e28ac9b3513f155de9e3b3db8d78",
            "filename": "turbopack/crates/turbo-tasks/src/task/local_task.rs",
            "status": "modified",
            "additions": 30,
            "deletions": 86,
            "changes": 116,
            "blob_url": "https://github.com/vercel/next.js/blob/e830e85fd0e5f95d8e3fe83d2351bdd5a87b6781/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask%2Flocal_task.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e830e85fd0e5f95d8e3fe83d2351bdd5a87b6781/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask%2Flocal_task.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask%2Flocal_task.rs?ref=e830e85fd0e5f95d8e3fe83d2351bdd5a87b6781",
            "patch": "@@ -1,4 +1,4 @@\n-use std::{borrow::Cow, fmt, sync::Arc};\n+use std::{fmt, sync::Arc};\n \n use anyhow::{Result, anyhow};\n \n@@ -19,51 +19,39 @@ pub enum LocalTask {\n \n pub fn get_local_task_execution_spec<'a>(\n     turbo_tasks: &'_ dyn TurboTasksBackendApi<impl Backend + 'static>,\n-    ty: &'a LocalTaskType,\n+    ty: &'a LocalTaskSpec,\n     // if this is a `LocalTaskType::Resolve*`, we'll spawn another task with this persistence, if\n     // this is a `LocalTaskType::Native`, this refers to the parent non-local task.\n     persistence: TaskPersistence,\n ) -> TaskExecutionSpec<'a> {\n-    match ty {\n-        LocalTaskType::Native {\n-            native_fn,\n-            this,\n-            arg,\n-        } => {\n+    match ty.task_type {\n+        LocalTaskType::Native { native_fn } => {\n             let span = native_fn.span(TaskPersistence::Local);\n             let entered = span.enter();\n-            let future = native_fn.execute(*this, &**arg);\n+            let future = native_fn.execute(ty.this, &*ty.arg);\n             drop(entered);\n             TaskExecutionSpec { future, span }\n         }\n-        LocalTaskType::ResolveNative {\n-            native_fn,\n-            this,\n-            arg,\n-        } => {\n+        LocalTaskType::ResolveNative { native_fn } => {\n             let span = native_fn.resolve_span(TaskPersistence::Local);\n             let entered = span.enter();\n             let future = Box::pin(LocalTaskType::run_resolve_native(\n                 native_fn,\n-                *this,\n-                &**arg,\n+                ty.this,\n+                &*ty.arg,\n                 persistence,\n                 turbo_tasks.pin(),\n             ));\n             drop(entered);\n             TaskExecutionSpec { future, span }\n         }\n-        LocalTaskType::ResolveTrait {\n-            trait_method,\n-            this,\n-            arg,\n-        } => {\n+        LocalTaskType::ResolveTrait { trait_method } => {\n             let span = trait_method.resolve_span();\n             let entered = span.enter();\n             let future = Box::pin(LocalTaskType::run_resolve_trait(\n                 trait_method,\n-                *this,\n-                &**arg,\n+                ty.this.unwrap(),\n+                &*ty.arg,\n                 persistence,\n                 turbo_tasks.pin(),\n             ));\n@@ -73,50 +61,35 @@ pub fn get_local_task_execution_spec<'a>(\n     }\n }\n \n+pub struct LocalTaskSpec {\n+    /// The self value, will always be present for `ResolveTrait` tasks and is optional otherwise\n+    pub(crate) this: Option<RawVc>,\n+    /// Function arguments\n+    pub(crate) arg: Box<dyn MagicAny>,\n+    pub(crate) task_type: LocalTaskType,\n+}\n+\n+#[derive(Copy, Clone)]\n pub enum LocalTaskType {\n     /// A normal task execution a native (rust) function\n-    Native {\n-        native_fn: &'static NativeFunction,\n-        this: Option<RawVc>,\n-        arg: Box<dyn MagicAny>,\n-    },\n+    Native { native_fn: &'static NativeFunction },\n \n     /// A resolve task, which resolves arguments and calls the function with resolve arguments. The\n     /// inner function call will be a `PersistentTaskType` or `LocalTaskType::Native`.\n-    ResolveNative {\n-        native_fn: &'static NativeFunction,\n-        this: Option<RawVc>,\n-        arg: Box<dyn MagicAny>,\n-    },\n+    ResolveNative { native_fn: &'static NativeFunction },\n \n     /// A trait method resolve task. It resolves the first (`self`) argument and looks up the trait\n     /// method on that value. Then it calls that method. The method call will do a cache lookup and\n     /// might resolve arguments before.\n-    ResolveTrait {\n-        trait_method: &'static TraitMethod,\n-        this: RawVc,\n-        arg: Box<dyn MagicAny>,\n-    },\n+    ResolveTrait { trait_method: &'static TraitMethod },\n }\n \n impl fmt::Display for LocalTaskType {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n-            LocalTaskType::Native {\n-                native_fn,\n-                this: _,\n-                arg: _,\n-            } => f.write_str(native_fn.name),\n-            LocalTaskType::ResolveNative {\n-                native_fn,\n-                this: _,\n-                arg: _,\n-            } => write!(f, \"*{}\", native_fn.name),\n-            LocalTaskType::ResolveTrait {\n-                trait_method,\n-                this: _,\n-                arg: _,\n-            } => write!(\n+            LocalTaskType::Native { native_fn } => f.write_str(native_fn.name),\n+            LocalTaskType::ResolveNative { native_fn } => write!(f, \"*{}\", native_fn.name),\n+            LocalTaskType::ResolveTrait { trait_method } => write!(\n                 f,\n                 \"*{}::{}\",\n                 trait_method.trait_name, trait_method.method_name\n@@ -126,31 +99,6 @@ impl fmt::Display for LocalTaskType {\n }\n \n impl LocalTaskType {\n-    /// Returns the name of the function in the code. Trait methods are\n-    /// formatted as `TraitName::method_name`.\n-    ///\n-    /// Equivalent to [`ToString::to_string`], but potentially more efficient as\n-    /// it can return a `&'static str` in many cases.\n-    pub fn get_name(&self) -> Cow<'static, str> {\n-        match self {\n-            Self::Native {\n-                native_fn,\n-                this: _,\n-                arg: _,\n-            } => Cow::Borrowed(native_fn.name),\n-            Self::ResolveNative {\n-                native_fn,\n-                this: _,\n-                arg: _,\n-            } => format!(\"*{}\", native_fn.name).into(),\n-            Self::ResolveTrait {\n-                trait_method,\n-                this: _,\n-                arg: _,\n-            } => format!(\"*{}::{}\", trait_method.trait_name, trait_method.method_name).into(),\n-        }\n-    }\n-\n     /// Implementation of the LocalTaskType::ResolveNative task.\n     /// Resolves all the task inputs and then calls the given function.\n     async fn run_resolve_native<B: Backend + 'static>(\n@@ -200,7 +148,7 @@ impl LocalTaskType {\n #[cfg(test)]\n pub(crate) mod tests {\n     use super::*;\n-    use crate::{self as turbo_tasks, TaskId, Vc};\n+    use crate::{self as turbo_tasks, Vc};\n \n     #[turbo_tasks::function]\n     fn mock_func_task() -> Vc<()> {\n@@ -214,24 +162,20 @@ pub(crate) mod tests {\n     }\n \n     #[test]\n-    fn test_get_name() {\n+    fn test_fmt() {\n         crate::register();\n         assert_eq!(\n             LocalTaskType::Native {\n                 native_fn: &MOCK_FUNC_TASK_FUNCTION,\n-                this: None,\n-                arg: Box::new(()),\n             }\n-            .get_name(),\n+            .to_string(),\n             \"mock_func_task\",\n         );\n         assert_eq!(\n             LocalTaskType::ResolveTrait {\n                 trait_method: MOCKTRAIT_TRAIT_TYPE.get(\"mock_method_task\"),\n-                this: RawVc::TaskOutput(unsafe { TaskId::new_unchecked(1) }),\n-                arg: Box::new(()),\n             }\n-            .get_name(),\n+            .to_string(),\n             \"*MockTrait::mock_method_task\",\n         );\n     }"
        }
    ],
    "stats": {
        "total": 142,
        "additions": 42,
        "deletions": 100
    }
}