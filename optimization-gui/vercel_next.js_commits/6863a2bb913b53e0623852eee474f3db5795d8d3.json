{
    "author": "wyattjoh",
    "message": "Add build-time validation to detect ambiguous app routes (#85834)\n\n## What\n\nThis PR introduces build-time validation to detect ambiguous app routes\nthat were previously going undetected until runtime.\n\n## Why\n\nRoute conflicts could occur when different dynamic segment names (e.g.,\n`[slug]` vs `[modalSlug]`) normalize to the same routing pattern. This\nwas particularly problematic for:\n\n- Parallel routes with different parameter names that appeared to work\nbut had subtle conflicts\n- Interception routes where structural equivalence wasn't being\nvalidated\n- Complex routing structures where the ambiguity only manifested at\nruntime\n\nThese conflicts would slip through the build process and cause runtime\nissues that were difficult to diagnose.\n\n## How\n\nAdds a new `validateAppPaths()` function that:\n\n1. **Normalizes paths** to detect structural equivalence (e.g.,\n`/blog/[slug]` and `/blog/[modalSlug]` both normalize to `/blog/[*]`)\n2. **Validates individual paths** for syntax errors, duplicate slug\nnames, catch-all placement, and other issues\n3. **Cross-validates paths** to detect ambiguous routes that would\nconflict at runtime\n4. **Provides clear error messages** with actionable guidance when\nconflicts are detected\n\nThe validation is integrated into the build process in\n`packages/next/src/build/index.ts` and runs automatically for all app\nroutes.\n\n## Changes\n\n- **New**: `validate-app-paths.ts` - Core validation logic with\ncomprehensive path normalization and conflict detection\n- **New**: `validate-app-paths.test.ts` - Extensive test coverage (299\nlines) covering valid configs, ambiguous routes, syntax errors, and edge\ncases\n- **Modified**: `build/index.ts` - Integration of validation into the\nbuild process\n- **Modified**: `get-segment-param.tsx` - Export `SegmentParam` type for\nreuse\n\n## Test Coverage\n\nThe test suite covers:\n- Valid route configurations (different segments, depths, catch-all\npatterns)\n- Ambiguous route detection (parallel routes, different dynamic segment\nnames)\n- Individual path validation (syntax errors, duplicate slugs, catch-all\nplacement)\n- Edge cases (empty arrays, root routes, complex nested structures)\n- Clear error messaging with actionable guidance",
    "sha": "6863a2bb913b53e0623852eee474f3db5795d8d3",
    "files": [
        {
            "sha": "4ed266708c97ee0ffd931f50658eeb01ba171c5a",
            "filename": "packages/next/errors.json",
            "status": "modified",
            "additions": 18,
            "deletions": 1,
            "changes": 19,
            "blob_url": "https://github.com/vercel/next.js/blob/6863a2bb913b53e0623852eee474f3db5795d8d3/packages%2Fnext%2Ferrors.json",
            "raw_url": "https://github.com/vercel/next.js/raw/6863a2bb913b53e0623852eee474f3db5795d8d3/packages%2Fnext%2Ferrors.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Ferrors.json?ref=6863a2bb913b53e0623852eee474f3db5795d8d3",
            "patch": "@@ -907,5 +907,22 @@\n   \"906\": \"Bindings not loaded yet, but they are being loaded, did you forget to await?\",\n   \"907\": \"bindings not loaded yet.  Either call `loadBindings` to wait for them to be available or ensure that `installBindings` has already been called.\",\n   \"908\": \"Invalid flags should be run as node detached-flush dev ./path-to/project [eventsFile]\",\n-  \"909\": \"Failed to load SWC binary for %s/%s, see more info here: https://nextjs.org/docs/messages/failed-loading-swc\"\n+  \"909\": \"Failed to load SWC binary for %s/%s, see more info here: https://nextjs.org/docs/messages/failed-loading-swc\",\n+  \"910\": \"Optional route parameters are not yet supported (\\\"%s\\\") in route \\\"%s\\\".\",\n+  \"911\": \"You cannot use both a required and optional catch-all route at the same level in route \\\"%s\\\".\",\n+  \"912\": \"Ambiguous app routes detected:\\\\n\\\\n%s\\\\n\\\\nThese routes cannot be distinguished from each other when matching URLs. Please ensure that dynamic segments have unique patterns or use different static segments.\",\n+  \"913\": \"Optional catch-all must be the last part of the URL in route \\\"%s\\\".\",\n+  \"914\": \"You cannot have the same slug name \\\"%s\\\" repeat within a single dynamic path in route \\\"%s\\\".\",\n+  \"915\": \"Detected a three-dot character ('…') at ('%s') in route \\\"%s\\\". Did you mean ('...')?\",\n+  \"916\": \"Segment names may not start or end with extra brackets ('%s') in route \\\"%s\\\".\",\n+  \"917\": \"You cannot define a route with the same specificity as an optional catch-all route (\\\"%s\\\" and \\\"%s/[[...%s]]\\\").\",\n+  \"918\": \"Catch-all must be the last part of the URL in route \\\"%s\\\".\",\n+  \"919\": \"You cannot have the slug names \\\"%s\\\" and \\\"%s\\\" differ only by non-word symbols within a single dynamic path in route \\\"%s\\\".\",\n+  \"920\": \"Segment names may not start with erroneous periods ('%s') in route \\\"%s\\\".\",\n+  \"921\": \"Detected a three-dot character ('…') in parameter \\\"%s\\\" in route \\\"%s\\\". Did you mean ('...')?\",\n+  \"922\": \"Parameter names cannot be empty in route \\\"%s\\\".\",\n+  \"923\": \"%s is being parsed as a normalized route, but it has a route group or parallel route segment.\",\n+  \"924\": \"Invalid interception route: %s\",\n+  \"925\": \"You cannot define a route with the same specificity as an optional catch-all route (\\\"%s\\\" and \\\"/[[...%s]]\\\").\",\n+  \"926\": \"Optional route parameters are not yet supported (\\\"[%s]\\\") in route \\\"%s\\\".\"\n }"
        },
        {
            "sha": "0e271607e058734ffc4c3dbfe490cc9693694ed3",
            "filename": "packages/next/src/build/index.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/6863a2bb913b53e0623852eee474f3db5795d8d3/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/6863a2bb913b53e0623852eee474f3db5795d8d3/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts?ref=6863a2bb913b53e0623852eee474f3db5795d8d3",
            "patch": "@@ -230,6 +230,7 @@ import {\n   writeValidatorFile,\n } from '../server/lib/router-utils/route-types-utils'\n import { Lockfile } from './lockfile'\n+import { validateAppPaths } from './validate-app-paths'\n \n type Fallback = null | boolean | string\n \n@@ -1406,6 +1407,13 @@ export default async function build(\n       }\n \n       const appPaths = Array.from(appPageKeys)\n+\n+      // Validate that the app paths are valid. This is currently duplicating\n+      // the logic from packages/next/src/shared/lib/router/utils/sorted-routes.ts\n+      // but is instead specifically focused on code that can be shared\n+      // eventually with the development code.\n+      validateAppPaths(appPaths)\n+\n       // Interception routes are modelled as beforeFiles rewrites\n       rewrites.beforeFiles.push(\n         ...generateInterceptionRoutesRewrites(appPaths, config.basePath)"
        },
        {
            "sha": "4a22e966401b7edf800e16cabac84373e11f49e4",
            "filename": "packages/next/src/build/validate-app-paths.test.ts",
            "status": "added",
            "additions": 561,
            "deletions": 0,
            "changes": 561,
            "blob_url": "https://github.com/vercel/next.js/blob/6863a2bb913b53e0623852eee474f3db5795d8d3/packages%2Fnext%2Fsrc%2Fbuild%2Fvalidate-app-paths.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/6863a2bb913b53e0623852eee474f3db5795d8d3/packages%2Fnext%2Fsrc%2Fbuild%2Fvalidate-app-paths.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fvalidate-app-paths.test.ts?ref=6863a2bb913b53e0623852eee474f3db5795d8d3",
            "patch": "@@ -0,0 +1,561 @@\n+import { validateAppPaths } from './validate-app-paths'\n+\n+describe('validateAppPaths', () => {\n+  // NOTE: The paths passed to validateAppPaths have already been normalized\n+  // by normalizeAppPath, which strips out parallel route segments (@modal, etc.),\n+  // route groups ((group)), and the trailing /page or /route segment.\n+  //\n+  // So app/blog/@modal/[slug]/page.tsx becomes /blog/[slug]\n+  // and app/blog/[slug]/page.tsx also becomes /blog/[slug]\n+\n+  describe('should allow valid route configurations', () => {\n+    it('allows routes with different static segments', () => {\n+      const paths = ['/blog/posts', '/blog/authors', '/about']\n+\n+      expect(() => validateAppPaths(paths)).not.toThrow()\n+    })\n+\n+    it('allows routes with different depths', () => {\n+      const paths = ['/blog', '/blog/[slug]', '/blog/[slug]/comments']\n+\n+      expect(() => validateAppPaths(paths)).not.toThrow()\n+    })\n+\n+    it('allows routes with different dynamic segment positions', () => {\n+      const paths = ['/[category]/posts', '/posts/[slug]', '/posts/featured']\n+\n+      expect(() => validateAppPaths(paths)).not.toThrow()\n+    })\n+\n+    it('allows routes with different catch-all patterns', () => {\n+      const paths = ['/docs/[...slug]', '/blog/[slug]']\n+\n+      expect(() => validateAppPaths(paths)).not.toThrow()\n+    })\n+\n+    it('allows special routes', () => {\n+      const paths = ['/_not-found', '/_global-error', '/blog/[slug]', '/about']\n+\n+      expect(() => validateAppPaths(paths)).not.toThrow()\n+    })\n+\n+    it('allows same dynamic segment names in different paths', () => {\n+      const paths = ['/blog/[slug]', '/posts/[slug]', '/docs/[slug]']\n+\n+      expect(() => validateAppPaths(paths)).not.toThrow()\n+    })\n+\n+    it('allows routes with optional catch-all', () => {\n+      const paths = ['/docs/[[...slug]]', '/blog/[slug]']\n+\n+      expect(() => validateAppPaths(paths)).not.toThrow()\n+    })\n+\n+    it('allows catch-all at the end of path', () => {\n+      const paths = ['/docs/[...slug]', '/blog/posts/[...rest]']\n+\n+      expect(() => validateAppPaths(paths)).not.toThrow()\n+    })\n+\n+    it('allows same parameter name in intercepting and intercepted routes', () => {\n+      // Interception routes should validate the intercepting and intercepted parts separately\n+      // /[locale]/example is the intercepting route\n+      // /[locale]/intercepted is the intercepted route\n+      const paths = ['/[locale]/example/(...)[locale]/intercepted']\n+\n+      expect(() => validateAppPaths(paths)).not.toThrow()\n+    })\n+\n+    it('allows interception routes with different parameter names', () => {\n+      const paths = ['/blog/example/(...)[slug]/post']\n+\n+      expect(() => validateAppPaths(paths)).not.toThrow()\n+    })\n+  })\n+\n+  describe('interception route validation', () => {\n+    it('detects duplicate slug names in intercepting part', () => {\n+      const paths = ['/[locale]/[locale]/example/(...)intercepted']\n+\n+      expect(() => validateAppPaths(paths)).toThrowErrorMatchingInlineSnapshot(\n+        `\"You cannot have the same slug name \"locale\" repeat within a single dynamic path in route \"/[locale]/[locale]/example/\".\"`\n+      )\n+    })\n+\n+    it('detects duplicate slug names in intercepted part', () => {\n+      const paths = ['/blog/example/(...)[slug]/post/[slug]']\n+\n+      expect(() => validateAppPaths(paths)).toThrowErrorMatchingInlineSnapshot(\n+        `\"You cannot have the same slug name \"slug\" repeat within a single dynamic path in route \"[slug]/post/[slug]\".\"`\n+      )\n+    })\n+\n+    it('detects catch-all not at end in intercepting part', () => {\n+      const paths = ['/[...slug]/extra/(...)intercepted']\n+\n+      expect(() => validateAppPaths(paths)).toThrowErrorMatchingInlineSnapshot(\n+        `\"Catch-all must be the last part of the URL in route \"/[...slug]/extra/\".\"`\n+      )\n+    })\n+\n+    it('detects catch-all not at end in intercepted part', () => {\n+      const paths = ['/intercepting/(...)[...slug]/extra']\n+\n+      expect(() => validateAppPaths(paths)).toThrowErrorMatchingInlineSnapshot(\n+        `\"Catch-all must be the last part of the URL in route \"[...slug]/extra\".\"`\n+      )\n+    })\n+\n+    it('detects syntax error in intercepted part', () => {\n+      const paths = ['/blog/(...)[.slug]']\n+\n+      expect(() => validateAppPaths(paths)).toThrowErrorMatchingInlineSnapshot(\n+        `\"Segment names may not start with erroneous periods ('.slug') in route \"[.slug]\".\"`\n+      )\n+    })\n+\n+    it('detects syntax error in intercepting part', () => {\n+      const paths = ['/blog/[.invalid]/(...)intercepted']\n+\n+      expect(() => validateAppPaths(paths)).toThrowErrorMatchingInlineSnapshot(\n+        `\"Segment names may not start with erroneous periods ('.invalid') in route \"/blog/[.invalid]/\".\"`\n+      )\n+    })\n+\n+    it('does not error when routes differ only by interception markers', () => {\n+      expect(() =>\n+        validateAppPaths(['/blog/test', '/blog/(..)test'])\n+      ).not.toThrow()\n+      expect(() =>\n+        validateAppPaths(['/blog/[slug]', '/blog/(..)[slug]'])\n+      ).not.toThrow()\n+    })\n+  })\n+\n+  describe('should detect ambiguous routes', () => {\n+    it('detects conflict from normalized parallel routes (most common case)', () => {\n+      // This represents:\n+      // - app/blog/[slug]/page.tsx\n+      // - app/blog/@modal/[modalSlug]/page.tsx (normalized to /blog/[modalSlug])\n+      const paths = ['/blog/[slug]', '/blog/[modalSlug]']\n+\n+      expect(() => validateAppPaths(paths)).toThrowErrorMatchingInlineSnapshot(`\n+       \"Ambiguous app routes detected:\n+\n+       Ambiguous route pattern \"/blog/[*]\" matches multiple routes:\n+         - /blog/[slug]\n+         - /blog/[modalSlug]\n+\n+       These routes cannot be distinguished from each other when matching URLs. Please ensure that dynamic segments have unique patterns or use different static segments.\"\n+      `)\n+    })\n+\n+    it('detects conflict between three normalized parallel routes', () => {\n+      // This represents multiple parallel slots with dynamic segments\n+      const paths = ['/dashboard/[id]', '/dashboard/[userId]']\n+\n+      expect(() => validateAppPaths(paths)).toThrowErrorMatchingInlineSnapshot(`\n+       \"Ambiguous app routes detected:\n+\n+       Ambiguous route pattern \"/dashboard/[*]\" matches multiple routes:\n+         - /dashboard/[id]\n+         - /dashboard/[userId]\n+\n+       These routes cannot be distinguished from each other when matching URLs. Please ensure that dynamic segments have unique patterns or use different static segments.\"\n+      `)\n+    })\n+\n+    it('detects conflict with different dynamic segment names', () => {\n+      const paths = ['/blog/[slug]', '/blog/[id]']\n+\n+      expect(() => validateAppPaths(paths)).toThrowErrorMatchingInlineSnapshot(`\n+       \"Ambiguous app routes detected:\n+\n+       Ambiguous route pattern \"/blog/[*]\" matches multiple routes:\n+         - /blog/[slug]\n+         - /blog/[id]\n+\n+       These routes cannot be distinguished from each other when matching URLs. Please ensure that dynamic segments have unique patterns or use different static segments.\"\n+      `)\n+    })\n+\n+    it('detects conflict with catch-all segments', () => {\n+      const paths = ['/docs/[...slug]', '/docs/[...pages]']\n+\n+      expect(() => validateAppPaths(paths)).toThrowErrorMatchingInlineSnapshot(`\n+       \"Ambiguous app routes detected:\n+\n+       Ambiguous route pattern \"/docs/[...*]\" matches multiple routes:\n+         - /docs/[...slug]\n+         - /docs/[...pages]\n+\n+       These routes cannot be distinguished from each other when matching URLs. Please ensure that dynamic segments have unique patterns or use different static segments.\"\n+      `)\n+    })\n+\n+    it('detects conflict with optional catch-all segments', () => {\n+      const paths = ['/docs/[[...slug]]', '/docs/[[...pages]]']\n+\n+      expect(() => validateAppPaths(paths)).toThrowErrorMatchingInlineSnapshot(`\n+       \"Ambiguous app routes detected:\n+\n+       Ambiguous route pattern \"/docs/[[...*]]\" matches multiple routes:\n+         - /docs/[[...slug]]\n+         - /docs/[[...pages]]\n+\n+       These routes cannot be distinguished from each other when matching URLs. Please ensure that dynamic segments have unique patterns or use different static segments.\"\n+      `)\n+    })\n+\n+    it('detects multiple conflicts', () => {\n+      const paths = [\n+        '/blog/[slug]',\n+        '/blog/[id]',\n+        '/posts/[id]',\n+        '/posts/[slug]',\n+      ]\n+\n+      // Should report both conflicts\n+      expect(() => validateAppPaths(paths)).toThrowErrorMatchingInlineSnapshot(`\n+       \"Ambiguous app routes detected:\n+\n+       Ambiguous route pattern \"/blog/[*]\" matches multiple routes:\n+         - /blog/[slug]\n+         - /blog/[id]\n+\n+       Ambiguous route pattern \"/posts/[*]\" matches multiple routes:\n+         - /posts/[id]\n+         - /posts/[slug]\n+\n+       These routes cannot be distinguished from each other when matching URLs. Please ensure that dynamic segments have unique patterns or use different static segments.\"\n+      `)\n+    })\n+\n+    it('detects conflict with three or more routes', () => {\n+      // Three different routes that all normalize to the same pattern\n+      const paths = ['/blog/[slug]', '/blog/[id]', '/blog/[postId]']\n+\n+      // All three should be listed\n+      expect(() => validateAppPaths(paths)).toThrowErrorMatchingInlineSnapshot(`\n+       \"Ambiguous app routes detected:\n+\n+       Ambiguous route pattern \"/blog/[*]\" matches multiple routes:\n+         - /blog/[slug]\n+         - /blog/[id]\n+         - /blog/[postId]\n+\n+       These routes cannot be distinguished from each other when matching URLs. Please ensure that dynamic segments have unique patterns or use different static segments.\"\n+      `)\n+    })\n+\n+    it('detects conflict between routes differing only by case', () => {\n+      // Different paths with case-different parameter names\n+      const paths = ['/blog/[Slug]', '/blog/[slug]']\n+\n+      expect(() => validateAppPaths(paths)).toThrowErrorMatchingInlineSnapshot(`\n+       \"Ambiguous app routes detected:\n+\n+       Ambiguous route pattern \"/blog/[*]\" matches multiple routes:\n+         - /blog/[Slug]\n+         - /blog/[slug]\n+\n+       These routes cannot be distinguished from each other when matching URLs. Please ensure that dynamic segments have unique patterns or use different static segments.\"\n+      `)\n+    })\n+\n+    it('detects conflict between routes with underscores vs hyphens', () => {\n+      // These should be considered ambiguous even though underscore is a word character\n+      const paths = ['/blog/[hello_world]', '/blog/[hello-world]']\n+\n+      expect(() => validateAppPaths(paths)).toThrowErrorMatchingInlineSnapshot(`\n+       \"Ambiguous app routes detected:\n+\n+       Ambiguous route pattern \"/blog/[*]\" matches multiple routes:\n+         - /blog/[hello_world]\n+         - /blog/[hello-world]\n+\n+       These routes cannot be distinguished from each other when matching URLs. Please ensure that dynamic segments have unique patterns or use different static segments.\"\n+      `)\n+    })\n+  })\n+\n+  describe('individual path validation', () => {\n+    describe('segment syntax errors', () => {\n+      it('detects three-dot character (…) instead of ...', () => {\n+        const paths = ['/docs/[…slug]']\n+\n+        expect(() =>\n+          validateAppPaths(paths)\n+        ).toThrowErrorMatchingInlineSnapshot(\n+          `\"Detected a three-dot character ('…') in parameter \"…slug\" in route \"/docs/[…slug]\". Did you mean ('...')?\"`\n+        )\n+      })\n+\n+      it('detects extra brackets in segment names', () => {\n+        const paths = ['/blog/[[slug]']\n+\n+        expect(() =>\n+          validateAppPaths(paths)\n+        ).toThrowErrorMatchingInlineSnapshot(\n+          `\"Segment names may not start or end with extra brackets ('[slug') in route \"/blog/[[slug]\".\"`\n+        )\n+      })\n+\n+      it('detects erroneous periods at start of segment', () => {\n+        const paths = ['/blog/[.slug]']\n+\n+        expect(() =>\n+          validateAppPaths(paths)\n+        ).toThrowErrorMatchingInlineSnapshot(\n+          `\"Segment names may not start with erroneous periods ('.slug') in route \"/blog/[.slug]\".\"`\n+        )\n+      })\n+\n+      it('detects optional non-catch-all segments', () => {\n+        const paths = ['/blog/[[slug]]']\n+\n+        expect(() =>\n+          validateAppPaths(paths)\n+        ).toThrowErrorMatchingInlineSnapshot(\n+          `\"Optional route parameters are not yet supported (\"[[slug]]\") in route \"/blog/[[slug]]\".\"`\n+        )\n+      })\n+\n+      it('detects empty parameter name in dynamic segment', () => {\n+        const paths = ['/blog/[]']\n+\n+        expect(() => validateAppPaths(paths)).toThrow(/empty/i)\n+      })\n+\n+      it('detects empty parameter name in catch-all segment', () => {\n+        const paths = ['/docs/[...]']\n+\n+        expect(() => validateAppPaths(paths)).toThrow(/empty/i)\n+      })\n+\n+      it('detects empty parameter name in optional catch-all segment', () => {\n+        const paths = ['/docs/[[...]]]']\n+\n+        // Note: This malformed syntax triggers the \"extra brackets\" error first\n+        expect(() => validateAppPaths(paths)).toThrow(/extra brackets|empty/i)\n+      })\n+\n+      it('detects extra closing bracket only', () => {\n+        const paths = ['/blog/[slug]]']\n+\n+        expect(() =>\n+          validateAppPaths(paths)\n+        ).toThrowErrorMatchingInlineSnapshot(\n+          `\"Segment names may not start or end with extra brackets ('slug]') in route \"/blog/[slug]]\".\"`\n+        )\n+      })\n+\n+      it('detects two periods instead of three', () => {\n+        const paths = ['/blog/[..slug]']\n+\n+        expect(() => validateAppPaths(paths)).toThrow(\n+          /segment names may not start with erroneous periods/i\n+        )\n+      })\n+\n+      it('detects four periods in segment', () => {\n+        const paths = ['/blog/[....slug]']\n+\n+        expect(() => validateAppPaths(paths)).toThrow(\n+          /segment names may not start with erroneous periods/i\n+        )\n+      })\n+\n+      it('detects only periods in segment', () => {\n+        const paths = ['/blog/[....]]']\n+\n+        expect(() => validateAppPaths(paths)).toThrow()\n+      })\n+    })\n+\n+    describe('duplicate slug names', () => {\n+      it('detects duplicate slug names in same path', () => {\n+        const paths = ['/blog/[slug]/posts/[slug]']\n+\n+        expect(() =>\n+          validateAppPaths(paths)\n+        ).toThrowErrorMatchingInlineSnapshot(\n+          `\"You cannot have the same slug name \"slug\" repeat within a single dynamic path in route \"/blog/[slug]/posts/[slug]\".\"`\n+        )\n+      })\n+\n+      it('detects slug names differing only by non-word symbols', () => {\n+        const paths = ['/blog/[helloworld]/[hello-world]']\n+\n+        expect(() =>\n+          validateAppPaths(paths)\n+        ).toThrowErrorMatchingInlineSnapshot(\n+          `\"You cannot have the slug names \"helloworld\" and \"hello-world\" differ only by non-word symbols within a single dynamic path in route \"/blog/[helloworld]/[hello-world]\".\"`\n+        )\n+      })\n+    })\n+\n+    describe('catch-all placement', () => {\n+      it('detects catch-all not at the end', () => {\n+        const paths = ['/docs/[...slug]/more']\n+\n+        expect(() =>\n+          validateAppPaths(paths)\n+        ).toThrowErrorMatchingInlineSnapshot(\n+          `\"Catch-all must be the last part of the URL in route \"/docs/[...slug]/more\".\"`\n+        )\n+      })\n+\n+      it('detects optional catch-all not at the end', () => {\n+        const paths = ['/docs/[[...slug]]/more']\n+\n+        expect(() =>\n+          validateAppPaths(paths)\n+        ).toThrowErrorMatchingInlineSnapshot(\n+          `\"Optional catch-all must be the last part of the URL in route \"/docs/[[...slug]]/more\".\"`\n+        )\n+      })\n+\n+      it('detects both required and optional catch-all in same path', () => {\n+        // This would be impossible in practice but we should catch it\n+        const paths = ['/docs/[...required]/[[...optional]]']\n+\n+        expect(() =>\n+          validateAppPaths(paths)\n+        ).toThrowErrorMatchingInlineSnapshot(\n+          `\"You cannot use both a required and optional catch-all route at the same level in route \"/docs/[...required]/[[...optional]]\".\"`\n+        )\n+      })\n+    })\n+\n+    describe('optional catch-all specificity conflicts', () => {\n+      it('detects route with same specificity as optional catch-all', () => {\n+        const paths = ['/docs', '/docs/[[...slug]]']\n+\n+        expect(() =>\n+          validateAppPaths(paths)\n+        ).toThrowErrorMatchingInlineSnapshot(\n+          `\"You cannot define a route with the same specificity as an optional catch-all route (\"/docs\" and \"/docs/[[...slug]]\").\"`\n+        )\n+      })\n+\n+      it('allows optional catch-all without conflicting route', () => {\n+        const paths = ['/docs/[[...slug]]']\n+\n+        expect(() => validateAppPaths(paths)).not.toThrow()\n+      })\n+\n+      it('allows nested optional catch-all without conflict', () => {\n+        const paths = ['/docs/api/[[...slug]]', '/docs/guides']\n+\n+        expect(() => validateAppPaths(paths)).not.toThrow()\n+      })\n+    })\n+  })\n+\n+  describe('edge cases', () => {\n+    it('handles empty array', () => {\n+      expect(() => validateAppPaths([])).not.toThrow()\n+    })\n+\n+    it('handles single route', () => {\n+      expect(() => validateAppPaths(['/blog/[slug]'])).not.toThrow()\n+    })\n+\n+    it('handles complex nested structures', () => {\n+      const paths = [\n+        '/[locale]/blog/[category]/[slug]',\n+        '/[locale]/blog/[category]/featured',\n+      ]\n+\n+      expect(() => validateAppPaths(paths)).not.toThrow()\n+    })\n+\n+    it('handles root route', () => {\n+      const paths = ['/', '/blog']\n+\n+      expect(() => validateAppPaths(paths)).not.toThrow()\n+    })\n+\n+    // Test for optional catch-all at root level\n+    it('detects conflict between root route and root-level optional catch-all', () => {\n+      const paths = ['/', '/[[...slug]]']\n+\n+      expect(() => validateAppPaths(paths)).toThrow(\n+        /same specificity as an optional catch-all/\n+      )\n+    })\n+\n+    // Test for optional catch-all with dynamic segments in prefix\n+    it('detects conflict when optional catch-all prefix has dynamic segment with different param name', () => {\n+      // /blog/[category]/[[...slug]] with zero slug segments = /blog/[category]\n+      // /blog/[cat] is structurally identical to /blog/[category]\n+      const paths = ['/blog/[category]/[[...slug]]', '/blog/[cat]']\n+\n+      expect(() => validateAppPaths(paths)).toThrow(\n+        /same specificity as an optional catch-all/\n+      )\n+    })\n+\n+    // Test for optional catch-all with nested dynamic segments\n+    it('detects conflict with multiple dynamic segments in prefix', () => {\n+      // /[locale]/blog/[category]/[[...slug]] with zero slug = /[locale]/blog/[category]\n+      // /[lang]/blog/[cat] is structurally identical\n+      const paths = [\n+        '/[locale]/blog/[category]/[[...slug]]',\n+        '/[lang]/blog/[cat]',\n+      ]\n+\n+      expect(() => validateAppPaths(paths)).toThrow(\n+        /same specificity as an optional catch-all/\n+      )\n+    })\n+  })\n+\n+  describe('error message quality', () => {\n+    it('provides clear error message with normalized path', () => {\n+      const paths = ['/blog/[slug]', '/blog/[modalSlug]']\n+\n+      expect(() => validateAppPaths(paths)).toThrow(\n+        /Ambiguous route pattern \"\\/blog\\/\\[\\*\\]\"/\n+      )\n+    })\n+\n+    it('provides actionable guidance', () => {\n+      const paths = ['/blog/[slug]', '/blog/[id]']\n+\n+      expect(() => validateAppPaths(paths)).toThrowErrorMatchingInlineSnapshot(`\n+       \"Ambiguous app routes detected:\n+\n+       Ambiguous route pattern \"/blog/[*]\" matches multiple routes:\n+         - /blog/[slug]\n+         - /blog/[id]\n+\n+       These routes cannot be distinguished from each other when matching URLs. Please ensure that dynamic segments have unique patterns or use different static segments.\"\n+      `)\n+    })\n+\n+    it('lists all conflicting routes', () => {\n+      const paths = ['/blog/[slug]', '/blog/[id]', '/blog/[postId]']\n+\n+      expect(() => validateAppPaths(paths)).toThrowErrorMatchingInlineSnapshot(`\n+       \"Ambiguous app routes detected:\n+\n+       Ambiguous route pattern \"/blog/[*]\" matches multiple routes:\n+         - /blog/[slug]\n+         - /blog/[id]\n+         - /blog/[postId]\n+\n+       These routes cannot be distinguished from each other when matching URLs. Please ensure that dynamic segments have unique patterns or use different static segments.\"\n+      `)\n+    })\n+\n+    it('provides clear message for syntax errors', () => {\n+      const paths = ['/docs/[...slug]/more']\n+\n+      expect(() => validateAppPaths(paths)).toThrowErrorMatchingInlineSnapshot(\n+        `\"Catch-all must be the last part of the URL in route \"/docs/[...slug]/more\".\"`\n+      )\n+    })\n+  })\n+})"
        },
        {
            "sha": "701b4ce82b157d4de5d9c4a6599716ffbea6192c",
            "filename": "packages/next/src/build/validate-app-paths.ts",
            "status": "added",
            "additions": 281,
            "deletions": 0,
            "changes": 281,
            "blob_url": "https://github.com/vercel/next.js/blob/6863a2bb913b53e0623852eee474f3db5795d8d3/packages%2Fnext%2Fsrc%2Fbuild%2Fvalidate-app-paths.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/6863a2bb913b53e0623852eee474f3db5795d8d3/packages%2Fnext%2Fsrc%2Fbuild%2Fvalidate-app-paths.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fvalidate-app-paths.ts?ref=6863a2bb913b53e0623852eee474f3db5795d8d3",
            "patch": "@@ -0,0 +1,281 @@\n+import {\n+  getParamProperties,\n+  type SegmentParam,\n+} from '../shared/lib/router/utils/get-segment-param'\n+import {\n+  isInterceptionAppRoute,\n+  parseAppRoute,\n+  type NormalizedAppRoute,\n+  type NormalizedAppRouteSegment,\n+} from '../shared/lib/router/routes/app'\n+\n+/**\n+ * Validates segment parameters for common syntax errors.\n+ * Based on validation logic from sorted-routes.ts\n+ */\n+function validateSegmentParam(param: SegmentParam, pathname: string): void {\n+  // Check for empty parameter names\n+  if (param.param.length === 0) {\n+    throw new Error(`Parameter names cannot be empty in route \"${pathname}\".`)\n+  }\n+\n+  // Check for three-dot character (…) instead of ...\n+  if (param.param.includes('…')) {\n+    throw new Error(\n+      `Detected a three-dot character ('…') in parameter \"${param.param}\" in route \"${pathname}\". Did you mean ('...')?`\n+    )\n+  }\n+\n+  // Check for optional non-catch-all segments (not yet supported)\n+  if (\n+    param.type !== 'optional-catchall' &&\n+    param.param.startsWith('[') &&\n+    param.param.endsWith(']')\n+  ) {\n+    throw new Error(\n+      `Optional route parameters are not yet supported (\"[${param.param}]\") in route \"${pathname}\".`\n+    )\n+  }\n+\n+  // Check for extra brackets\n+  if (param.param.startsWith('[') || param.param.endsWith(']')) {\n+    throw new Error(\n+      `Segment names may not start or end with extra brackets ('${param.param}') in route \"${pathname}\".`\n+    )\n+  }\n+\n+  // Check for erroneous periods\n+  if (param.param.startsWith('.')) {\n+    throw new Error(\n+      `Segment names may not start with erroneous periods ('${param.param}') in route \"${pathname}\".`\n+    )\n+  }\n+}\n+\n+/**\n+ * Validates a Route object for internal consistency.\n+ * Checks for duplicate slugs, invalid catch-all placement, and other route errors.\n+ * For interception routes, validates both the intercepting and intercepted routes separately.\n+ * Returns the validated segment parameters.\n+ */\n+function validateAppRoute(route: NormalizedAppRoute): void {\n+  // For interception routes, validate the intercepting and intercepted routes separately\n+  // This allows the same parameter name to appear in both parts\n+  if (isInterceptionAppRoute(route)) {\n+    validateAppRoute(route.interceptingRoute)\n+    validateAppRoute(route.interceptedRoute)\n+    return\n+  }\n+\n+  // Then validate semantic constraints (duplicates, normalization, positioning)\n+  const slugNames = new Set<string>()\n+  const normalizedSegments = new Set<string>()\n+  let hasCatchAll = false\n+  let hasOptionalCatchAllInPath = false\n+  let catchAllPosition = -1\n+\n+  for (let i = 0; i < route.segments.length; i++) {\n+    const segment = route.segments[i]\n+\n+    // Type narrowing - only process dynamic segments\n+    if (segment.type === 'dynamic') {\n+      // First, validate syntax\n+      validateSegmentParam(segment.param, route.pathname)\n+\n+      const properties = getParamProperties(segment.param.type)\n+\n+      if (properties.repeat) {\n+        if (properties.optional) {\n+          hasOptionalCatchAllInPath = true\n+        } else {\n+          hasCatchAll = true\n+        }\n+\n+        catchAllPosition = i\n+      }\n+\n+      // Check to see if the parameter name is already in use.\n+      if (slugNames.has(segment.param.param)) {\n+        throw new Error(\n+          `You cannot have the same slug name \"${segment.param.param}\" repeat within a single dynamic path in route \"${route.pathname}\".`\n+        )\n+      }\n+\n+      // Normalize parameter name for comparison by removing all non-word\n+      // characters.\n+      const normalizedSegment = segment.param.param.replace(/\\W/g, '')\n+      if (normalizedSegments.has(normalizedSegment)) {\n+        const existing = Array.from(slugNames).find((s) => {\n+          return s.replace(/\\W/g, '') === normalizedSegment\n+        })\n+        throw new Error(\n+          `You cannot have the slug names \"${existing}\" and \"${segment.param.param}\" differ only by non-word symbols within a single dynamic path in route \"${route.pathname}\".`\n+        )\n+      }\n+\n+      slugNames.add(segment.param.param)\n+      normalizedSegments.add(normalizedSegment)\n+    }\n+\n+    // Check if catch-all is not at the end\n+    if (hasCatchAll && i > catchAllPosition) {\n+      throw new Error(\n+        `Catch-all must be the last part of the URL in route \"${route.pathname}\".`\n+      )\n+    }\n+    if (hasOptionalCatchAllInPath && i > catchAllPosition) {\n+      throw new Error(\n+        `Optional catch-all must be the last part of the URL in route \"${route.pathname}\".`\n+      )\n+    }\n+  }\n+\n+  // Check for both required and optional catch-all\n+  if (hasCatchAll && hasOptionalCatchAllInPath) {\n+    throw new Error(\n+      `You cannot use both a required and optional catch-all route at the same level in route \"${route.pathname}\".`\n+    )\n+  }\n+}\n+\n+/**\n+ * Validates a single path for internal consistency and returns its segment parameters.\n+ */\n+function parseAndValidateAppPath(path: string): NormalizedAppRoute {\n+  // Fast parse the route information. We're expecting this to be a normalized\n+  // route, so we pass `true` to the `parseAppRoute` function.\n+  const route = parseAppRoute(path, true)\n+\n+  // Slow walk the data from the route in order to validate it.\n+  validateAppRoute(route)\n+\n+  return route\n+}\n+\n+/**\n+ * Normalizes segments by replacing dynamic segment names with placeholders.\n+ * This allows us to compare routes for structural equivalence.\n+ * Preserves interception markers so that routes with different markers are not considered ambiguous.\n+ *\n+ * Examples:\n+ * - [slug] -> [*]\n+ * - [modalSlug] -> [*]\n+ * - [...slug] -> [...*]\n+ * - [[...slug]] -> [[...*]]\n+ * - (..)test -> (..)test\n+ * - (..)[slug] -> (..)[*]\n+ */\n+function normalizeSegments(\n+  segments: readonly NormalizedAppRouteSegment[]\n+): string {\n+  return (\n+    '/' +\n+    segments\n+      .map((segment) => {\n+        if (segment.type === 'static') {\n+          return segment.name\n+        }\n+\n+        // Dynamic segment - normalize the parameter name by replacing the\n+        // parameter name with a wildcard. The interception marker is already\n+        // included in the segment name, so no special handling is needed.\n+        return segment.name.replace(segment.param.param, '*')\n+      })\n+      .join('/')\n+  )\n+}\n+\n+/**\n+ * Validates that app paths don't create ambiguous routes.\n+ *\n+ * NOTE: The paths passed to this function should already have been normalized by normalizeAppPath,\n+ * which means parallel route segments (@modal, @sidebar, etc.) have been removed.\n+ *\n+ * This function performs two types of validation:\n+ * 1. Individual path validation (syntax, slug names, catch-all placement, etc.)\n+ * 2. Cross-path validation (ambiguous routes, conflicting patterns)\n+ *\n+ * @param appPaths - Array of normalized app router paths to validate\n+ * @returns Array of validated routes\n+ * @throws Error if validation fails\n+ */\n+export function validateAppPaths(\n+  appPaths: readonly string[]\n+): NormalizedAppRoute[] {\n+  // First, validate each path individually\n+  const paramsByPath = new Map<string, NormalizedAppRoute>()\n+  for (const path of appPaths) {\n+    paramsByPath.set(path, parseAndValidateAppPath(path))\n+  }\n+\n+  // Group paths by their normalized structure for ambiguity detection\n+  const structureMap = new Map<string, string[]>()\n+\n+  for (const [path, route] of paramsByPath) {\n+    // Check if the last segment is an optional catch-all and check to see if\n+    // there is a route with the same specificity that conflicts with it.\n+    const lastSegment = route.segments[route.segments.length - 1]\n+    if (\n+      lastSegment?.type === 'dynamic' &&\n+      lastSegment.param.type === 'optional-catchall'\n+    ) {\n+      const prefixSegments = route.segments.slice(0, -1)\n+      const normalizedPrefix = normalizeSegments(prefixSegments)\n+\n+      for (const [appPath, appRoute] of paramsByPath) {\n+        const normalizedAppPath = normalizeSegments(appRoute.segments)\n+\n+        // Special case: root-level optional catch-all\n+        // /[[...slug]] has prefix '' which should match '/'\n+        if (prefixSegments.length === 0 && appPath === '/') {\n+          throw new Error(\n+            `You cannot define a route with the same specificity as an optional catch-all route (\"${appPath}\" and \"/[[...${lastSegment.param.param}]]\").`\n+          )\n+        }\n+\n+        // General case: compare normalized structures\n+        if (normalizedAppPath === normalizedPrefix) {\n+          throw new Error(\n+            `You cannot define a route with the same specificity as an optional catch-all route (\"${appPath}\" and \"${normalizedPrefix}/[[...${lastSegment.param.param}]]\").`\n+          )\n+        }\n+      }\n+    }\n+\n+    // Normalize the route to get its structure\n+    const structure = normalizeSegments(route.segments)\n+\n+    // Track which paths map to this structure\n+    const existingPaths = structureMap.get(structure) ?? []\n+    existingPaths.push(path)\n+    structureMap.set(structure, existingPaths)\n+  }\n+\n+  // Check for ambiguous routes (different slug names, same structure)\n+  const conflicts: Array<{ paths: string[]; normalizedPath: string }> = []\n+\n+  for (const [structure, paths] of structureMap) {\n+    if (paths.length > 1) {\n+      // Multiple paths map to the same structure - this is ambiguous\n+      conflicts.push({\n+        paths,\n+        normalizedPath: structure,\n+      })\n+    }\n+  }\n+\n+  if (conflicts.length > 0) {\n+    const errorMessages = conflicts.map(({ paths, normalizedPath }) => {\n+      const pathsList = paths.map((p) => `  - ${p}`).join('\\n')\n+      return `Ambiguous route pattern \"${normalizedPath}\" matches multiple routes:\\n${pathsList}`\n+    })\n+\n+    throw new Error(\n+      `Ambiguous app routes detected:\\n\\n${errorMessages.join('\\n\\n')}\\n\\n` +\n+        `These routes cannot be distinguished from each other when matching URLs. ` +\n+        `Please ensure that dynamic segments have unique patterns or use different static segments.`\n+    )\n+  }\n+\n+  return Array.from(paramsByPath.values())\n+}"
        },
        {
            "sha": "b1d4df1831de4a56ff798b24870221232c139254",
            "filename": "packages/next/src/shared/lib/router/routes/app.ts",
            "status": "added",
            "additions": 227,
            "deletions": 0,
            "changes": 227,
            "blob_url": "https://github.com/vercel/next.js/blob/6863a2bb913b53e0623852eee474f3db5795d8d3/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Froutes%2Fapp.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/6863a2bb913b53e0623852eee474f3db5795d8d3/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Froutes%2Fapp.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Froutes%2Fapp.ts?ref=6863a2bb913b53e0623852eee474f3db5795d8d3",
            "patch": "@@ -0,0 +1,227 @@\n+import { InvariantError } from '../../invariant-error'\n+import { getSegmentParam, type SegmentParam } from '../utils/get-segment-param'\n+import {\n+  INTERCEPTION_ROUTE_MARKERS,\n+  type InterceptionMarker,\n+} from '../utils/interception-routes'\n+\n+export type RouteGroupAppRouteSegment = {\n+  type: 'route-group'\n+  name: string\n+\n+  /**\n+   * If present, this segment has an interception marker prefixing it.\n+   */\n+  interceptionMarker?: InterceptionMarker\n+}\n+\n+export type ParallelRouteAppRouteSegment = {\n+  type: 'parallel-route'\n+  name: string\n+\n+  /**\n+   * If present, this segment has an interception marker prefixing it.\n+   */\n+  interceptionMarker?: InterceptionMarker\n+}\n+\n+export type StaticAppRouteSegment = {\n+  type: 'static'\n+  name: string\n+\n+  /**\n+   * If present, this segment has an interception marker prefixing it.\n+   */\n+  interceptionMarker?: InterceptionMarker\n+}\n+\n+export type DynamicAppRouteSegment = {\n+  type: 'dynamic'\n+  name: string\n+  param: SegmentParam\n+\n+  /**\n+   * If present, this segment has an interception marker prefixing it.\n+   */\n+  interceptionMarker?: InterceptionMarker\n+}\n+\n+/**\n+ * Represents a single segment in a route path.\n+ * Can be either static (e.g., \"blog\") or dynamic (e.g., \"[slug]\").\n+ */\n+export type AppRouteSegment =\n+  | StaticAppRouteSegment\n+  | DynamicAppRouteSegment\n+  | RouteGroupAppRouteSegment\n+  | ParallelRouteAppRouteSegment\n+\n+export type NormalizedAppRouteSegment =\n+  | StaticAppRouteSegment\n+  | DynamicAppRouteSegment\n+\n+export function parseAppRouteSegment(segment: string): AppRouteSegment | null {\n+  if (segment === '') {\n+    return null\n+  }\n+\n+  // Check if the segment starts with an interception marker\n+  const interceptionMarker = INTERCEPTION_ROUTE_MARKERS.find((m) =>\n+    segment.startsWith(m)\n+  )\n+\n+  const param = getSegmentParam(segment)\n+  if (param) {\n+    return {\n+      type: 'dynamic',\n+      name: segment,\n+      param,\n+      interceptionMarker,\n+    }\n+  } else if (segment.startsWith('(') && segment.endsWith(')')) {\n+    return {\n+      type: 'route-group',\n+      name: segment,\n+      interceptionMarker,\n+    }\n+  } else if (segment.startsWith('@')) {\n+    return {\n+      type: 'parallel-route',\n+      name: segment,\n+      interceptionMarker,\n+    }\n+  } else {\n+    return {\n+      type: 'static',\n+      name: segment,\n+      interceptionMarker,\n+    }\n+  }\n+}\n+\n+export type AppRoute = {\n+  normalized: boolean\n+  pathname: string\n+  segments: AppRouteSegment[]\n+  dynamicSegments: DynamicAppRouteSegment[]\n+  interceptionMarker: InterceptionMarker | undefined\n+  interceptingRoute: AppRoute | undefined\n+  interceptedRoute: AppRoute | undefined\n+}\n+\n+export type NormalizedAppRoute = Omit<AppRoute, 'normalized' | 'segments'> & {\n+  normalized: true\n+  segments: NormalizedAppRouteSegment[]\n+}\n+\n+export function isNormalizedAppRoute(\n+  route: AppRoute\n+): route is NormalizedAppRoute {\n+  return route.normalized\n+}\n+\n+export type InterceptionAppRoute = Omit<\n+  AppRoute,\n+  'interceptionMarker' | 'interceptingRoute' | 'interceptedRoute'\n+> & {\n+  interceptionMarker: InterceptionMarker\n+  interceptingRoute: AppRoute\n+  interceptedRoute: AppRoute\n+}\n+\n+export type NormalizedInterceptionAppRoute = Omit<\n+  InterceptionAppRoute,\n+  | 'normalized'\n+  | 'segments'\n+  | 'interceptionMarker'\n+  | 'interceptingRoute'\n+  | 'interceptedRoute'\n+> & {\n+  normalized: true\n+  segments: NormalizedAppRouteSegment[]\n+  interceptionMarker: InterceptionMarker\n+  interceptingRoute: NormalizedAppRoute\n+  interceptedRoute: NormalizedAppRoute\n+}\n+\n+export function isInterceptionAppRoute(\n+  route: NormalizedAppRoute\n+): route is NormalizedInterceptionAppRoute\n+export function isInterceptionAppRoute(\n+  route: AppRoute\n+): route is InterceptionAppRoute {\n+  return (\n+    route.interceptionMarker !== undefined &&\n+    route.interceptingRoute !== undefined &&\n+    route.interceptedRoute !== undefined\n+  )\n+}\n+\n+export function parseAppRoute(\n+  pathname: string,\n+  normalized: true\n+): NormalizedAppRoute\n+export function parseAppRoute(pathname: string, normalized: false): AppRoute\n+export function parseAppRoute(\n+  pathname: string,\n+  normalized: boolean\n+): AppRoute | NormalizedAppRoute {\n+  const pathnameSegments = pathname.split('/').filter(Boolean)\n+\n+  // Build segments array with static and dynamic segments\n+  const segments: AppRouteSegment[] = []\n+\n+  // Parse if this is an interception route.\n+  let interceptionMarker: InterceptionMarker | undefined\n+  let interceptingRoute: AppRoute | NormalizedAppRoute | undefined\n+  let interceptedRoute: AppRoute | NormalizedAppRoute | undefined\n+\n+  for (const segment of pathnameSegments) {\n+    // Parse the segment into an AppSegment.\n+    const appSegment = parseAppRouteSegment(segment)\n+    if (!appSegment) {\n+      continue\n+    }\n+\n+    if (\n+      normalized &&\n+      (appSegment.type === 'route-group' ||\n+        appSegment.type === 'parallel-route')\n+    ) {\n+      throw new InvariantError(\n+        `${pathname} is being parsed as a normalized route, but it has a route group or parallel route segment.`\n+      )\n+    }\n+\n+    segments.push(appSegment)\n+\n+    if (appSegment.interceptionMarker) {\n+      const parts = pathname.split(appSegment.interceptionMarker)\n+      if (parts.length !== 2) {\n+        throw new Error(`Invalid interception route: ${pathname}`)\n+      }\n+\n+      interceptingRoute = normalized\n+        ? parseAppRoute(parts[0], true)\n+        : parseAppRoute(parts[0], false)\n+      interceptedRoute = normalized\n+        ? parseAppRoute(parts[1], true)\n+        : parseAppRoute(parts[1], false)\n+      interceptionMarker = appSegment.interceptionMarker\n+    }\n+  }\n+\n+  const dynamicSegments = segments.filter(\n+    (segment) => segment.type === 'dynamic'\n+  )\n+\n+  return {\n+    normalized,\n+    pathname,\n+    segments,\n+    dynamicSegments,\n+    interceptionMarker,\n+    interceptingRoute,\n+    interceptedRoute,\n+  }\n+}"
        },
        {
            "sha": "1777583d4951995b517aa186392b69435036ab0a",
            "filename": "packages/next/src/shared/lib/router/utils/get-segment-param.tsx",
            "status": "modified",
            "additions": 6,
            "deletions": 4,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/6863a2bb913b53e0623852eee474f3db5795d8d3/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Fget-segment-param.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/6863a2bb913b53e0623852eee474f3db5795d8d3/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Fget-segment-param.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Fget-segment-param.tsx?ref=6863a2bb913b53e0623852eee474f3db5795d8d3",
            "patch": "@@ -1,13 +1,15 @@\n import { INTERCEPTION_ROUTE_MARKERS } from './interception-routes'\n import type { DynamicParamTypes } from '../../app-router-types'\n \n+export type SegmentParam = {\n+  param: string\n+  type: DynamicParamTypes\n+}\n+\n /**\n  * Parse dynamic route segment to type of parameter\n  */\n-export function getSegmentParam(segment: string): {\n-  param: string\n-  type: DynamicParamTypes\n-} | null {\n+export function getSegmentParam(segment: string): SegmentParam | null {\n   const interceptionMarker = INTERCEPTION_ROUTE_MARKERS.find((marker) =>\n     segment.startsWith(marker)\n   )"
        },
        {
            "sha": "3f2107620d8005e0ff1896651d1b33929a9dbcec",
            "filename": "packages/next/src/shared/lib/router/utils/interception-routes.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/6863a2bb913b53e0623852eee474f3db5795d8d3/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Finterception-routes.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/6863a2bb913b53e0623852eee474f3db5795d8d3/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Finterception-routes.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Finterception-routes.ts?ref=6863a2bb913b53e0623852eee474f3db5795d8d3",
            "patch": "@@ -8,6 +8,8 @@ export const INTERCEPTION_ROUTE_MARKERS = [\n   '(...)',\n ] as const\n \n+export type InterceptionMarker = (typeof INTERCEPTION_ROUTE_MARKERS)[number]\n+\n export function isInterceptionRouteAppPath(path: string): boolean {\n   // TODO-APP: add more serious validation\n   return ("
        }
    ],
    "stats": {
        "total": 1108,
        "additions": 1103,
        "deletions": 5
    }
}