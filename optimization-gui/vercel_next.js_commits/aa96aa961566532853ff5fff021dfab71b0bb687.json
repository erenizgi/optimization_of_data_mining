{
    "author": "icyJoseph",
    "message": "Docs: Experimental taint option in next.config.js (#79293)\n\nCloses:\nhttps://linear.app/vercel/issue/DOC-4668/document-the-experimentaltaint-option-in-nextconfigts\n\n- Documents activation of taint APIs within Next.js\n- Documents basic usage of the taint APIs\n\n---------\n\nCo-authored-by: Delba de Oliveira <32464864+delbaoliveira@users.noreply.github.com>",
    "sha": "aa96aa961566532853ff5fff021dfab71b0bb687",
    "files": [
        {
            "sha": "36ed94b3892c60a6f6d595be02787f03fb0cfea3",
            "filename": "docs/01-app/05-api-reference/05-config/01-next-config-js/taint.mdx",
            "status": "added",
            "additions": 226,
            "deletions": 0,
            "changes": 226,
            "blob_url": "https://github.com/vercel/next.js/blob/aa96aa961566532853ff5fff021dfab71b0bb687/docs%2F01-app%2F05-api-reference%2F05-config%2F01-next-config-js%2Ftaint.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/aa96aa961566532853ff5fff021dfab71b0bb687/docs%2F01-app%2F05-api-reference%2F05-config%2F01-next-config-js%2Ftaint.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F05-api-reference%2F05-config%2F01-next-config-js%2Ftaint.mdx?ref=aa96aa961566532853ff5fff021dfab71b0bb687",
            "patch": "@@ -0,0 +1,226 @@\n+---\n+title: taint\n+description: Enable tainting Objects and Values.\n+version: experimental\n+---\n+\n+## Usage\n+\n+The `taint` option enables support for experimental React APIs for tainting objects and values. This feature helps prevent sensitive data from being accidentally passed to the client. When enabled, you can use:\n+\n+- [`experimental_taintObjectReference`](https://react.dev/reference/react/experimental_taintObjectReference) taint objects references.\n+- [`experimental_taintUniqueValue`](https://react.dev/reference/react/experimental_taintUniqueValue) to taint unique values.\n+\n+> **Good to know**: Activating this flag also enables the React `experimental` channel for `app` directory.\n+\n+```ts filename=\"next.config.ts\" switcher\n+import type { NextConfig } from 'next'\n+\n+const nextConfig: NextConfig = {\n+  experimental: {\n+    ppr: 'incremental',\n+  },\n+}\n+\n+export default nextConfig\n+```\n+\n+```js filename=\"next.config.js\" switcher\n+/** @type {import('next').NextConfig} */\n+const nextConfig = {\n+  experimental: {\n+    ppr: 'incremental',\n+  },\n+}\n+\n+module.exports = nextConfig\n+```\n+\n+> **Warning:** Do not rely on the taint API as your only mechanism to prevent exposing sensitive data to the client. See our [security recommendations](/blog/security-nextjs-server-components-actions).\n+\n+The taint APIs allows you to be defensive, by declaratively and explicitly marking data that is not allowed to pass through the Server-Client boundary. When an object or value, is passed through the Server-Client boundary, React throws an error.\n+\n+This is helpful for cases where:\n+\n+- The methods to read data are out of your control\n+- You have to work with sensitive data shapes not defined by you\n+- Sensitive data is accessed during Server Component rendering\n+\n+It is recommended to model your data and APIs so that sensitive data is not returned to contexts where it is not needed.\n+\n+## Caveats\n+\n+- Tainting can only keep track of objects by reference. Copying an object creates an untainted version, which loses all guarantees given by the API. You'll need to taint the copy.\n+- Tainting cannot keep track of data derived from a tainted value. You also need to taint the derived value.\n+- Values are tainted for as long as their lifetime reference is within scope. See the [`experimental_taintUniqueValue` parameters reference](https://react.dev/reference/react/experimental_taintUniqueValue#parameters), for more information.\n+\n+## Examples\n+\n+### Tainting an object reference\n+\n+In this case, the `getUserDetails` function returns data about a given user. We taint the user object reference, so that it cannot cross a Server-Client boundary. For example, assuming `UserCard` is a Client Component.\n+\n+```ts switcher\n+import { experimental_taintObjectReference } from 'react'\n+\n+function getUserDetails(id: string): UserDetails {\n+  const user = await db.queryUserById(id)\n+\n+  experimental_taintObjectReference(\n+    'Do not use the entire user info object. Instead, select only the fields you need.',\n+    user\n+  )\n+\n+  return user\n+}\n+```\n+\n+```js switcher\n+import { experimental_taintObjectReference } from 'react'\n+\n+function getUserDetails(id) {\n+  const user = await db.queryUserById(id)\n+\n+  experimental_taintObjectReference(\n+    'Do not use the entire user info object. Instead, select only the fields you need.',\n+    user\n+  )\n+\n+  return user\n+}\n+```\n+\n+We can still access individual fields from the tainted `userDetails` object.\n+\n+```tsx filename=\"app/contact/page.tsx switcher\n+export async function ContactPage({\n+  params,\n+}: {\n+  params: Promise<{ id: string }>\n+}) {\n+  const { id } = await params\n+  const userDetails = await getUserDetails(id)\n+\n+  return (\n+    <UserCard\n+      firstName={userDetails.firstName}\n+      lastName={userDetails.lastName}\n+    />\n+  )\n+}\n+```\n+\n+```jsx filename=\"app/contact/page.js switcher\n+export async function ContactPage({ params }) {\n+  const { id } = await params\n+  const userDetails = await getUserDetails(id)\n+\n+  return (\n+    <UserCard\n+      firstName={userDetails.firstName}\n+      lastName={userDetails.lastName}\n+    />\n+  )\n+}\n+```\n+\n+Now, passing the entire object to the Client Component will throw an error.\n+\n+```tsx switcher\n+export async function ContactPage({\n+  params,\n+}: {\n+  params: Promise<{ id: string }>\n+}) {\n+  const userDetails = await getUserDetails(id)\n+\n+  // Throws an error\n+  return <UserCard user={userDetails} />\n+}\n+```\n+\n+```jsx switcher\n+export async function ContactPage({ params }) {\n+  const { id } = await params\n+  const userDetails = await getUserDetails(id)\n+\n+  // Throws an error\n+  return <UserCard user={userDetails} />\n+}\n+```\n+\n+### Tainting a unique value\n+\n+In this case, we can access the server configuration by awaiting calls to `config.getConfigDetails`. However, the system configuration contains the `SERVICE_API_KEY` that we don't want to expose to clients.\n+\n+We can taint the `config.SERVICE_API_KEY` value.\n+\n+```ts switcher\n+import { experimental_taintUniqueValue } from 'react'\n+\n+function getSystemConfig(): SystemConfig {\n+  const config = await config.getConfigDetails()\n+\n+  experimental_taintUniqueValue(\n+    'Do not pass configuration tokens to the client',\n+    config,\n+    config.SERVICE_API_KEY\n+  )\n+\n+  return config\n+}\n+```\n+\n+```js switcher\n+import { experimental_taintUniqueValue } from 'react'\n+\n+function getSystemConfig() {\n+  const config = await config.getConfigDetails()\n+\n+  experimental_taintUniqueValue(\n+    'Do not pass configuration tokens to the client',\n+    config,\n+    config.SERVICE_API_KEY\n+  )\n+\n+  return config\n+}\n+```\n+\n+We can still access other properties of the `systemConfig` object.\n+\n+```tsx\n+export async function Dashboard() {\n+  const systemConfig = await getSystemConfig()\n+\n+  return <ClientDashboard version={systemConfig.SERVICE_API_VERSION} />\n+}\n+```\n+\n+However, passing `SERVICE_API_KEY` to `ClientDashboard` throws an error.\n+\n+```tsx\n+export async function Dashboard() {\n+  const systemConfig = await getSystemConfig()\n+  // Someone makes a mistake in a PR\n+  const version = systemConfig.SERVICE_API_KEY\n+\n+  return <ClientDashboard version={version} />\n+}\n+```\n+\n+Note that, even though, `systemConfig.SERVICE_API_KEY` is reassigned to a new variable. Passing it to a Client Component still throws an error.\n+\n+Whereas, a value derived from a tainted unique value, will be exposed to the client.\n+\n+```tsx\n+export async function Dashboard() {\n+  const systemConfig = await getSystemConfig()\n+  // Someone makes a mistake in a PR\n+  const version = `version::${systemConfig.SERVICE_API_KEY}`\n+\n+  return <ClientDashboard version={version} />\n+}\n+```\n+\n+A better approach is to remove `SERVICE_API_KEY` from the data returned by `getSystemConfig`."
        }
    ],
    "stats": {
        "total": 226,
        "additions": 226,
        "deletions": 0
    }
}