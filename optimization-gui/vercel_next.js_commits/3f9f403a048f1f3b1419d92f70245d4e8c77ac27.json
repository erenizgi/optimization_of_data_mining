{
    "author": "bgw",
    "message": "chore(CI): Split basepath test suite into smaller and more parallel test suites (#78892)\n\nSame basic idea as https://github.com/vercel/next.js/pull/78787\n\nThis test suite has a lot of timeouts with rspack, which causes it to take a long time to run (though not quite long enough that it breaks the job).\n\nIn general, large test suites are good to break up, because they benefit from parallelism.",
    "sha": "3f9f403a048f1f3b1419d92f70245d4e8c77ac27",
    "files": [
        {
            "sha": "df342d3c834209d1f78b3cc37558938221652f96",
            "filename": ".github/workflows/build_and_test.yml",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/3f9f403a048f1f3b1419d92f70245d4e8c77ac27/.github%2Fworkflows%2Fbuild_and_test.yml",
            "raw_url": "https://github.com/vercel/next.js/raw/3f9f403a048f1f3b1419d92f70245d4e8c77ac27/.github%2Fworkflows%2Fbuild_and_test.yml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/.github%2Fworkflows%2Fbuild_and_test.yml?ref=3f9f403a048f1f3b1419d92f70245d4e8c77ac27",
            "patch": "@@ -801,7 +801,8 @@ jobs:\n \n         NEXT_TEST_MODE=start BROWSER_NAME=safari node run-tests.js \\\n           test/production/pages-dir/production/test/index.test.ts \\\n-          test/e2e/basepath/basepath.test.ts\n+          test/e2e/basepath/basepath.test.ts \\\n+          test/e2e/basepath/error-pages.test.ts\n \n         BROWSER_NAME=safari DEVICE_NAME='iPhone XR' node run-tests.js \\\n           test/production/prerender-prefetch/index.test.ts"
        },
        {
            "sha": "467403bdafdbc78be24fb4b73cb5c39a0490185d",
            "filename": "test/e2e/basepath/basepath.test.ts",
            "status": "modified",
            "additions": 467,
            "deletions": 883,
            "changes": 1350,
            "blob_url": "https://github.com/vercel/next.js/blob/3f9f403a048f1f3b1419d92f70245d4e8c77ac27/test%2Fe2e%2Fbasepath%2Fbasepath.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/3f9f403a048f1f3b1419d92f70245d4e8c77ac27/test%2Fe2e%2Fbasepath%2Fbasepath.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fbasepath%2Fbasepath.test.ts?ref=3f9f403a048f1f3b1419d92f70245d4e8c77ac27",
            "patch": "@@ -2,8 +2,7 @@ import url from 'url'\n import assert from 'assert'\n import cheerio from 'cheerio'\n import webdriver from 'next-webdriver'\n-import { createNext } from 'e2e-utils'\n-import { NextInstance } from 'e2e-utils'\n+import { nextTestSetup } from 'e2e-utils'\n import {\n   assertNoRedbox,\n   check,\n@@ -13,980 +12,565 @@ import {\n } from 'next-test-utils'\n \n describe('basePath', () => {\n-  let next: NextInstance\n   const basePath = '/docs'\n \n-  beforeAll(async () => {\n-    next = await createNext({\n-      files: __dirname,\n-      nextConfig: {\n-        basePath,\n-        onDemandEntries: {\n-          // Make sure entries are not getting disposed.\n-          maxInactiveAge: 1000 * 60 * 60,\n-        },\n-        async rewrites() {\n-          return [\n-            {\n-              source: '/rewrite-1',\n-              destination: '/gssp',\n-            },\n-            {\n-              source: '/rewrite-no-basepath',\n-              destination: 'https://example.vercel.sh',\n-              basePath: false,\n-            },\n-            {\n-              source: '/rewrite/chain-1',\n-              destination: '/rewrite/chain-2',\n-            },\n-            {\n-              source: '/rewrite/chain-2',\n-              destination: '/gssp',\n-            },\n-          ]\n-        },\n-\n-        async redirects() {\n-          return [\n-            {\n-              source: '/redirect-1',\n-              destination: '/somewhere-else',\n-              permanent: false,\n-            },\n-            {\n-              source: '/redirect-no-basepath',\n-              destination: '/another-destination',\n-              permanent: false,\n-              basePath: false,\n-            },\n-          ]\n-        },\n+  const { next, isNextDev, isNextDeploy } = nextTestSetup({\n+    files: __dirname,\n+    nextConfig: {\n+      basePath,\n+      onDemandEntries: {\n+        // Make sure entries are not getting disposed.\n+        maxInactiveAge: 1000 * 60 * 60,\n+      },\n+      async rewrites() {\n+        return [\n+          {\n+            source: '/rewrite-no-basepath',\n+            destination: 'https://example.vercel.sh',\n+            basePath: false,\n+          },\n+        ]\n+      },\n \n-        async headers() {\n-          return [\n-            {\n-              source: '/add-header',\n-              headers: [\n-                {\n-                  key: 'x-hello',\n-                  value: 'world',\n-                },\n-              ],\n-            },\n-            {\n-              source: '/add-header-no-basepath',\n-              basePath: false,\n-              headers: [\n-                {\n-                  key: 'x-hello',\n-                  value: 'world',\n-                },\n-              ],\n-            },\n-          ]\n-        },\n+      async headers() {\n+        return [\n+          {\n+            source: '/add-header',\n+            headers: [\n+              {\n+                key: 'x-hello',\n+                value: 'world',\n+              },\n+            ],\n+          },\n+          {\n+            source: '/add-header-no-basepath',\n+            basePath: false,\n+            headers: [\n+              {\n+                key: 'x-hello',\n+                value: 'world',\n+              },\n+            ],\n+          },\n+        ]\n       },\n-    })\n+    },\n   })\n-  afterAll(() => next.destroy())\n \n-  const runTests = (isDev = false, isDeploy = false) => {\n-    it('should navigate to /404 correctly client-side', async () => {\n-      const browser = await webdriver(next.url, `${basePath}/slug-1`)\n-      await check(\n-        () => browser.eval('document.documentElement.innerHTML'),\n-        /slug-1/\n-      )\n-\n-      await browser.eval('next.router.push(\"/404\", \"/slug-2\")')\n-      await check(\n-        () => browser.eval('document.documentElement.innerHTML'),\n-        /page could not be found/\n-      )\n-      expect(await browser.eval('location.pathname')).toBe(`${basePath}/slug-2`)\n-    })\n-\n-    it('should navigate to /_error correctly client-side', async () => {\n-      const browser = await webdriver(next.url, `${basePath}/slug-1`)\n-      await check(\n-        () => browser.eval('document.documentElement.innerHTML'),\n-        /slug-1/\n-      )\n-\n-      await browser.eval('next.router.push(\"/_error\", \"/slug-2\")')\n-      await check(\n-        () => browser.eval('document.documentElement.innerHTML'),\n-        /page could not be found/\n-      )\n-      expect(await browser.eval('location.pathname')).toBe(`${basePath}/slug-2`)\n-    })\n-\n-    it('should navigate to external site and back', async () => {\n-      const browser = await webdriver(next.url, `${basePath}/external-and-back`)\n-      const initialText = await browser.elementByCss('p').text()\n-      expect(initialText).toBe('server')\n-\n-      await browser\n-        .elementByCss('a')\n-        .click()\n-        .waitForElementByCss('input')\n-        .back()\n-        .waitForElementByCss('p')\n-\n-      await waitFor(1000)\n-      const newText = await browser.elementByCss('p').text()\n-      expect(newText).toBe('server')\n-    })\n+  it('should navigate to external site and back', async () => {\n+    const browser = await webdriver(next.url, `${basePath}/external-and-back`)\n+    const initialText = await browser.elementByCss('p').text()\n+    expect(initialText).toBe('server')\n+\n+    await browser\n+      .elementByCss('a')\n+      .click()\n+      .waitForElementByCss('input')\n+      .back()\n+      .waitForElementByCss('p')\n+\n+    await waitFor(1000)\n+    const newText = await browser.elementByCss('p').text()\n+    expect(newText).toBe('server')\n+  })\n \n-    if (process.env.BROWSER_NAME === 'safari') {\n-      // currently only testing the above test in safari\n-      // we can investigate testing more cases below if desired\n-      return\n-    }\n+  if (process.env.BROWSER_NAME === 'safari') {\n+    // currently only testing the above test in safari\n+    // we can investigate testing more cases below if desired\n+    return\n+  }\n \n-    it.each([\n-      { hash: '#hello?' },\n-      { hash: '#?' },\n-      { hash: '##' },\n-      { hash: '##?' },\n-      { hash: '##hello?' },\n-      { hash: '##hello' },\n-      { hash: '#hello?world' },\n-      { search: '?hello=world', hash: '#a', query: { hello: 'world' } },\n-      { search: '?hello', hash: '#a', query: { hello: '' } },\n-      { search: '?hello=', hash: '#a', query: { hello: '' } },\n-    ])(\n-      'should handle query/hash correctly during query updating $hash $search',\n-      async ({ hash, search, query }) => {\n-        const browser = await webdriver(\n-          next.url,\n-          `${basePath}${search || ''}${hash || ''}`\n-        )\n+  it('should navigate back correctly to a dynamic route', async () => {\n+    const browser = await webdriver(next.url, `${basePath}`)\n \n-        await check(\n-          () =>\n-            browser.eval('window.next.router.isReady ? \"ready\" : \"not ready\"'),\n-          'ready'\n-        )\n-        expect(await browser.eval('window.location.pathname')).toBe(basePath)\n-        expect(await browser.eval('window.location.search')).toBe(search || '')\n-        expect(await browser.eval('window.location.hash')).toBe(hash || '')\n-        expect(await browser.eval('next.router.pathname')).toBe('/')\n-        expect(\n-          JSON.parse(await browser.eval('JSON.stringify(next.router.query)'))\n-        ).toEqual(query || {})\n-      }\n+    expect(await browser.elementByCss('#index-page').text()).toContain(\n+      'index page'\n     )\n \n-    it('should navigate back correctly to a dynamic route', async () => {\n-      const browser = await webdriver(next.url, `${basePath}`)\n-\n-      expect(await browser.elementByCss('#index-page').text()).toContain(\n-        'index page'\n-      )\n-\n-      await browser.eval('window.beforeNav = 1')\n-\n-      await browser.eval('window.next.router.push(\"/catchall/first\")')\n+    await browser.eval('window.beforeNav = 1')\n \n-      await check(() => browser.elementByCss('p').text(), /first/)\n-      expect(await browser.eval('window.beforeNav')).toBe(1)\n+    await browser.eval('window.next.router.push(\"/catchall/first\")')\n+    await check(() => browser.elementByCss('p').text(), /first/)\n+    expect(await browser.eval('window.beforeNav')).toBe(1)\n \n-      await browser.eval('window.next.router.push(\"/catchall/second\")')\n-      await check(() => browser.elementByCss('p').text(), /second/)\n-      expect(await browser.eval('window.beforeNav')).toBe(1)\n+    await browser.eval('window.next.router.push(\"/catchall/second\")')\n+    await check(() => browser.elementByCss('p').text(), /second/)\n+    expect(await browser.eval('window.beforeNav')).toBe(1)\n \n-      await browser.eval('window.next.router.back()')\n-      await check(() => browser.elementByCss('p').text(), /first/)\n-      expect(await browser.eval('window.beforeNav')).toBe(1)\n-\n-      await browser.eval('window.history.forward()')\n-      await check(() => browser.elementByCss('p').text(), /second/)\n-      expect(await browser.eval('window.beforeNav')).toBe(1)\n-    })\n+    await browser.eval('window.next.router.back()')\n+    await check(() => browser.elementByCss('p').text(), /first/)\n+    expect(await browser.eval('window.beforeNav')).toBe(1)\n \n-    it('should respect basePath in amphtml link rel', async () => {\n-      const html = await renderViaHTTP(next.url, `${basePath}/amp-hybrid`)\n-      const $ = cheerio.load(html)\n-      const expectedAmpHtmlUrl = isDev\n-        ? `${basePath}/amp-hybrid?amp=1`\n-        : `${basePath}/amp-hybrid.amp`\n-      expect($('link[rel=amphtml]').first().attr('href')).toBe(\n-        expectedAmpHtmlUrl\n-      )\n-    })\n-\n-    if (!isDev) {\n-      if (!(global as any).isNextDeploy) {\n-        it('should add basePath to routes-manifest', async () => {\n-          const routesManifest = JSON.parse(\n-            await next.readFile('.next/routes-manifest.json')\n-          )\n-          expect(routesManifest.basePath).toBe(basePath)\n-        })\n-      }\n-\n-      it('should prefetch pages correctly when manually called', async () => {\n-        const browser = await webdriver(next.url, `${basePath}/other-page`)\n-        await browser.eval('window.next.router.prefetch(\"/gssp\")')\n-\n-        await check(\n-          async () => {\n-            const links = await browser.elementsByCss('link[rel=prefetch]')\n-\n-            for (const link of links) {\n-              const href = await link.getAttribute('href')\n-              if (href.includes('gssp')) {\n-                return true\n-              }\n-            }\n+    await browser.eval('window.history.forward()')\n+    await check(() => browser.elementByCss('p').text(), /second/)\n+    expect(await browser.eval('window.beforeNav')).toBe(1)\n+  })\n \n-            const scripts = await browser.elementsByCss('script')\n+  it('should respect basePath in amphtml link rel', async () => {\n+    const html = await renderViaHTTP(next.url, `${basePath}/amp-hybrid`)\n+    const $ = cheerio.load(html)\n+    const expectedAmpHtmlUrl = isNextDev\n+      ? `${basePath}/amp-hybrid?amp=1`\n+      : `${basePath}/amp-hybrid.amp`\n+    expect($('link[rel=amphtml]').first().attr('href')).toBe(expectedAmpHtmlUrl)\n+  })\n \n-            for (const script of scripts) {\n-              const src = await script.getAttribute('src')\n-              if (src.includes('gssp')) {\n-                return true\n-              }\n-            }\n-            return false\n-          },\n-          {\n-            test(result) {\n-              return result === true\n-            },\n-          }\n+  if (!isNextDev) {\n+    if (!isNextDeploy) {\n+      it('should add basePath to routes-manifest', async () => {\n+        const routesManifest = JSON.parse(\n+          await next.readFile('.next/routes-manifest.json')\n         )\n-      })\n-\n-      it('should prefetch pages correctly in viewport with <Link>', async () => {\n-        const browser = await webdriver(next.url, `${basePath}/hello`)\n-        await browser.eval('window.next.router.prefetch(\"/gssp\")')\n-\n-        await check(async () => {\n-          const hrefs = await browser.eval(\n-            `Object.keys(window.next.router.sdc)`\n-          )\n-          hrefs.sort()\n-\n-          assert.deepEqual(\n-            hrefs.map((href) =>\n-              new URL(href).pathname.replace(/\\/_next\\/data\\/[^/]+/, '')\n-            ),\n-            [\n-              `${basePath}/gsp.json`,\n-              `${basePath}/index.json`,\n-              // `${basePath}/index/index.json`,\n-            ]\n-          )\n-\n-          const prefetches = await browser.eval(\n-            `[].slice.call(document.querySelectorAll(\"link[rel=prefetch]\")).map((e) => new URL(e.href).pathname)`\n-          )\n-          expect(prefetches).toContainEqual(\n-            expect.stringMatching(/\\/gsp-?([^./]+)?\\.js/)\n-          )\n-          expect(prefetches).toContainEqual(\n-            expect.stringMatching(/\\/gssp-?([^./]+)?\\.js/)\n-          )\n-          expect(prefetches).toContainEqual(\n-            expect.stringMatching(/\\/other-page-?([^./]+)?\\.js/)\n-          )\n-          return 'yes'\n-        }, 'yes')\n+        expect(routesManifest.basePath).toBe(basePath)\n       })\n     }\n \n-    it('should 404 for public file without basePath', async () => {\n-      const res = await fetchViaHTTP(next.url, '/data.txt')\n-      expect(res.status).toBe(404)\n-    })\n-\n-    it('should serve public file with basePath correctly', async () => {\n-      const res = await fetchViaHTTP(next.url, `${basePath}/data.txt`)\n-      expect(res.status).toBe(200)\n-      expect(await res.text()).toBe('hello world')\n-    })\n-\n-    it('should rewrite with basePath by default', async () => {\n-      const html = await renderViaHTTP(next.url, `${basePath}/rewrite-1`)\n-      expect(html).toContain('getServerSideProps')\n-    })\n+    it('should prefetch pages correctly when manually called', async () => {\n+      const browser = await webdriver(next.url, `${basePath}/other-page`)\n+      await browser.eval('window.next.router.prefetch(\"/gssp\")')\n \n-    it('should not rewrite without basePath without disabling', async () => {\n-      const res = await fetchViaHTTP(next.url, '/rewrite-1')\n-      expect(res.status).toBe(404)\n-    })\n+      await check(\n+        async () => {\n+          const links = await browser.elementsByCss('link[rel=prefetch]')\n \n-    it('should not rewrite with basePath when set to false', async () => {\n-      // won't 404 as it matches the dynamic [slug] route\n-      const html = await renderViaHTTP(\n-        next.url,\n-        `${basePath}/rewrite-no-basePath`\n-      )\n-      expect(html).toContain('slug')\n-    })\n+          for (const link of links) {\n+            const href = await link.getAttribute('href')\n+            if (href.includes('gssp')) {\n+              return true\n+            }\n+          }\n \n-    it('should rewrite without basePath when set to false', async () => {\n-      const html = await renderViaHTTP(next.url, '/rewrite-no-basePath')\n-      expect(html).toContain('Example Domain')\n-    })\n+          const scripts = await browser.elementsByCss('script')\n \n-    it('should redirect with basePath by default', async () => {\n-      const res = await fetchViaHTTP(\n-        next.url,\n-        `${basePath}/redirect-1`,\n-        undefined,\n+          for (const script of scripts) {\n+            const src = await script.getAttribute('src')\n+            if (src.includes('gssp')) {\n+              return true\n+            }\n+          }\n+          return false\n+        },\n         {\n-          redirect: 'manual',\n+          test(result) {\n+            return result === true\n+          },\n         }\n       )\n-      const { pathname } = url.parse(res.headers.get('location') || '')\n-      expect(pathname).toBe(`${basePath}/somewhere-else`)\n-      expect(res.status).toBe(307)\n-      const text = await res.text()\n-      expect(text).toContain(`${basePath}/somewhere-else`)\n     })\n \n-    it('should not redirect without basePath without disabling', async () => {\n-      const res = await fetchViaHTTP(next.url, '/redirect-1', undefined, {\n-        redirect: 'manual',\n-      })\n-      expect(res.status).toBe(404)\n-    })\n+    it('should prefetch pages correctly in viewport with <Link>', async () => {\n+      const browser = await webdriver(next.url, `${basePath}/hello`)\n+      await browser.eval('window.next.router.prefetch(\"/gssp\")')\n \n-    it('should not redirect with basePath when set to false', async () => {\n-      // won't 404 as it matches the dynamic [slug] route\n-      const html = await renderViaHTTP(\n-        next.url,\n-        `${basePath}/rewrite-no-basePath`\n-      )\n-      expect(html).toContain('slug')\n-    })\n+      await check(async () => {\n+        const hrefs = await browser.eval(`Object.keys(window.next.router.sdc)`)\n+        hrefs.sort()\n \n-    it('should redirect without basePath when set to false', async () => {\n-      const res = await fetchViaHTTP(\n-        next.url,\n-        '/redirect-no-basepath',\n-        undefined,\n-        {\n-          redirect: 'manual',\n-        }\n-      )\n-      const { pathname } = url.parse(res.headers.get('location') || '')\n-      expect(pathname).toBe('/another-destination')\n-      expect(res.status).toBe(307)\n-      const text = await res.text()\n-      expect(text).toContain('/another-destination')\n-    })\n+        assert.deepEqual(\n+          hrefs.map((href) =>\n+            new URL(href).pathname.replace(/\\/_next\\/data\\/[^/]+/, '')\n+          ),\n+          [\n+            `${basePath}/gsp.json`,\n+            `${basePath}/index.json`,\n+            // `${basePath}/index/index.json`,\n+          ]\n+        )\n \n-    //\n-    it('should add header with basePath by default', async () => {\n-      const res = await fetchViaHTTP(next.url, `${basePath}/add-header`)\n-      expect(res.headers.get('x-hello')).toBe('world')\n+        const prefetches = await browser.eval(\n+          `[].slice.call(document.querySelectorAll(\"link[rel=prefetch]\")).map((e) => new URL(e.href).pathname)`\n+        )\n+        expect(prefetches).toContainEqual(\n+          expect.stringMatching(/\\/gsp-?([^./]+)?\\.js/)\n+        )\n+        expect(prefetches).toContainEqual(\n+          expect.stringMatching(/\\/gssp-?([^./]+)?\\.js/)\n+        )\n+        expect(prefetches).toContainEqual(\n+          expect.stringMatching(/\\/other-page-?([^./]+)?\\.js/)\n+        )\n+        return 'yes'\n+      }, 'yes')\n     })\n+  }\n \n-    it('should not add header without basePath without disabling', async () => {\n-      const res = await fetchViaHTTP(next.url, '/add-header')\n-      expect(res.headers.get('x-hello')).toBe(null)\n-    })\n+  it('should serve public file with basePath correctly', async () => {\n+    const res = await fetchViaHTTP(next.url, `${basePath}/data.txt`)\n+    expect(res.status).toBe(200)\n+    expect(await res.text()).toBe('hello world')\n+  })\n \n-    it('should not add header with basePath when set to false', async () => {\n-      const res = await fetchViaHTTP(\n-        next.url,\n-        `${basePath}/add-header-no-basepath`\n-      )\n-      expect(res.headers.get('x-hello')).toBe(null)\n-    })\n+  it('should 404 for public file without basePath', async () => {\n+    const res = await fetchViaHTTP(next.url, '/data.txt')\n+    expect(res.status).toBe(404)\n+  })\n \n-    it('should add header without basePath when set to false', async () => {\n-      const res = await fetchViaHTTP(next.url, '/add-header-no-basepath')\n-      expect(res.headers.get('x-hello')).toBe('world')\n-    })\n+  it('should add header with basePath by default', async () => {\n+    const res = await fetchViaHTTP(next.url, `${basePath}/add-header`)\n+    expect(res.headers.get('x-hello')).toBe('world')\n+  })\n \n-    it('should not update URL for a 404', async () => {\n-      const browser = await webdriver(next.url, '/missing')\n-\n-      if (isDeploy) {\n-        // the custom 404 only shows inside of the basePath so this\n-        // will be the Vercel default 404 page\n-        expect(\n-          await browser.eval('document.documentElement.innerHTML')\n-        ).toContain('NOT_FOUND')\n-      } else {\n-        const pathname = await browser.eval(() => window.location.pathname)\n-        expect(\n-          await browser.eval(() => (window as any).next.router.asPath)\n-        ).toBe('/missing')\n-        expect(pathname).toBe('/missing')\n-      }\n-    })\n+  it('should not add header without basePath without disabling', async () => {\n+    const res = await fetchViaHTTP(next.url, '/add-header')\n+    expect(res.headers.get('x-hello')).toBe(null)\n+  })\n \n-    it('should handle 404 urls that start with basePath', async () => {\n-      const browser = await webdriver(next.url, `${basePath}hello`)\n-\n-      if (isDeploy) {\n-        // the custom 404 only shows inside of the basePath so this\n-        // will be the Vercel default 404 page\n-        expect(\n-          await browser.eval('document.documentElement.innerHTML')\n-        ).toContain('NOT_FOUND')\n-      } else {\n-        expect(\n-          await browser.eval(() => (window as any).next.router.asPath)\n-        ).toBe(`${basePath}hello`)\n-        expect(await browser.eval(() => window.location.pathname)).toBe(\n-          `${basePath}hello`\n-        )\n-      }\n-    })\n+  it('should not add header with basePath when set to false', async () => {\n+    const res = await fetchViaHTTP(\n+      next.url,\n+      `${basePath}/add-header-no-basepath`\n+    )\n+    expect(res.headers.get('x-hello')).toBe(null)\n+  })\n \n-    // TODO: this test has been passing incorrectly since the below check\n-    // wasn't being awaited. We need to investigate if this test is\n-    // correct or not.\n-    it.skip('should navigate back to a non-basepath 404 that starts with basepath', async () => {\n-      const browser = await webdriver(next.url, `${basePath}hello`)\n-      await browser.eval(() => ((window as any).navigationMarker = true))\n-      await browser.eval(() => (window as any).next.router.push('/hello'))\n-      await browser.waitForElementByCss('#pathname')\n-      await browser.back()\n-      await check(\n-        () => browser.eval(() => window.location.pathname),\n-        `${basePath}hello`\n-      )\n-      expect(await browser.eval(() => (window as any).next.router.asPath)).toBe(\n-        `${basePath}hello`\n-      )\n-      expect(await browser.eval(() => (window as any).navigationMarker)).toBe(\n-        true\n-      )\n-    })\n+  it('should add header without basePath when set to false', async () => {\n+    const res = await fetchViaHTTP(next.url, '/add-header-no-basepath')\n+    expect(res.headers.get('x-hello')).toBe('world')\n+  })\n \n-    it('should update dynamic params after mount correctly', async () => {\n-      const browser = await webdriver(next.url, `${basePath}/hello-dynamic`)\n-      await check(\n-        () => browser.elementByCss('#slug').text(),\n-        /slug: hello-dynamic/\n-      )\n-    })\n+  it('should update dynamic params after mount correctly', async () => {\n+    const browser = await webdriver(next.url, `${basePath}/hello-dynamic`)\n+    await check(\n+      () => browser.elementByCss('#slug').text(),\n+      /slug: hello-dynamic/\n+    )\n+  })\n \n-    it('should navigate to index page with getStaticProps', async () => {\n-      const browser = await webdriver(next.url, `${basePath}/hello`)\n-      await browser.eval('window.beforeNavigate = \"hi\"')\n+  it('should navigate to index page with getStaticProps', async () => {\n+    const browser = await webdriver(next.url, `${basePath}/hello`)\n+    await browser.eval('window.beforeNavigate = \"hi\"')\n \n-      await browser.elementByCss('#index-gsp').click()\n-      await browser.waitForElementByCss('#prop')\n+    await browser.elementByCss('#index-gsp').click()\n+    await browser.waitForElementByCss('#prop')\n \n-      expect(await browser.eval('window.beforeNavigate')).toBe('hi')\n-      expect(await browser.elementByCss('#prop').text()).toBe('hello world')\n-      expect(await browser.elementByCss('#nested').text()).toBe('no')\n-      expect(JSON.parse(await browser.elementByCss('#query').text())).toEqual(\n-        {}\n-      )\n-      expect(await browser.elementByCss('#pathname').text()).toBe('/')\n+    expect(await browser.eval('window.beforeNavigate')).toBe('hi')\n+    expect(await browser.elementByCss('#prop').text()).toBe('hello world')\n+    expect(await browser.elementByCss('#nested').text()).toBe('no')\n+    expect(JSON.parse(await browser.elementByCss('#query').text())).toEqual({})\n+    expect(await browser.elementByCss('#pathname').text()).toBe('/')\n \n-      if (!isDev) {\n-        const hrefs = await browser.eval(`Object.keys(window.next.router.sdc)`)\n-        hrefs.sort()\n+    if (!isNextDev) {\n+      const hrefs = await browser.eval(`Object.keys(window.next.router.sdc)`)\n+      hrefs.sort()\n \n-        expect(\n-          hrefs.map((href) =>\n-            new URL(href).pathname.replace(/\\/_next\\/data\\/[^/]+/, '')\n-          )\n-        ).toEqual([\n-          `${basePath}/gsp.json`,\n-          `${basePath}/index.json`,\n-          // `${basePath}/index/index.json`,\n-        ])\n-      }\n-    })\n+      expect(\n+        hrefs.map((href) =>\n+          new URL(href).pathname.replace(/\\/_next\\/data\\/[^/]+/, '')\n+        )\n+      ).toEqual([\n+        `${basePath}/gsp.json`,\n+        `${basePath}/index.json`,\n+        // `${basePath}/index/index.json`,\n+      ])\n+    }\n+  })\n \n-    // TODO: investigate index/index seems this shouldn't work\n-    // as pages/index.js conflicts with pages/index/index.js\n-    it.skip('should navigate to nested index page with getStaticProps', async () => {\n-      const browser = await webdriver(next.url, `${basePath}/hello`)\n-      await browser.eval('window.beforeNavigate = \"hi\"')\n+  // TODO: investigate index/index seems this shouldn't work\n+  // as pages/index.js conflicts with pages/index/index.js\n+  it.skip('should navigate to nested index page with getStaticProps', async () => {\n+    const browser = await webdriver(next.url, `${basePath}/hello`)\n+    await browser.eval('window.beforeNavigate = \"hi\"')\n \n-      await browser.elementByCss('#nested-index-gsp').click()\n-      await browser.waitForElementByCss('#prop')\n+    await browser.elementByCss('#nested-index-gsp').click()\n+    await browser.waitForElementByCss('#prop')\n \n-      expect(await browser.eval('window.beforeNavigate')).toBe('hi')\n-      expect(await browser.elementByCss('#prop').text()).toBe('hello world')\n-      expect(await browser.elementByCss('#nested').text()).toBe('yes')\n-      expect(JSON.parse(await browser.elementByCss('#query').text())).toEqual(\n-        {}\n-      )\n-      expect(await browser.elementByCss('#pathname').text()).toBe('/index')\n+    expect(await browser.eval('window.beforeNavigate')).toBe('hi')\n+    expect(await browser.elementByCss('#prop').text()).toBe('hello world')\n+    expect(await browser.elementByCss('#nested').text()).toBe('yes')\n+    expect(JSON.parse(await browser.elementByCss('#query').text())).toEqual({})\n+    expect(await browser.elementByCss('#pathname').text()).toBe('/index')\n \n-      if (!isDev) {\n-        const hrefs = await browser.eval(`Object.keys(window.next.router.sdc)`)\n-        hrefs.sort()\n+    if (!isNextDev) {\n+      const hrefs = await browser.eval(`Object.keys(window.next.router.sdc)`)\n+      hrefs.sort()\n \n-        expect(\n-          hrefs.map((href) =>\n-            new URL(href).pathname.replace(/\\/_next\\/data\\/[^/]+/, '')\n-          )\n-        ).toEqual([\n-          `${basePath}/gsp.json`,\n-          `${basePath}/index.json`,\n-          `${basePath}/index/index.json`,\n-        ])\n-      }\n-    })\n+      expect(\n+        hrefs.map((href) =>\n+          new URL(href).pathname.replace(/\\/_next\\/data\\/[^/]+/, '')\n+        )\n+      ).toEqual([\n+        `${basePath}/gsp.json`,\n+        `${basePath}/index.json`,\n+        `${basePath}/index/index.json`,\n+      ])\n+    }\n+  })\n \n-    it('should work with nested folder with same name as basePath', async () => {\n-      const html = await renderViaHTTP(next.url, `${basePath}/docs/another`)\n-      expect(html).toContain('hello from another')\n+  it('should work with nested folder with same name as basePath', async () => {\n+    const html = await renderViaHTTP(next.url, `${basePath}/docs/another`)\n+    expect(html).toContain('hello from another')\n \n-      const browser = await webdriver(next.url, `${basePath}/hello`)\n-      await browser.eval('window.next.router.push(\"/docs/another\")')\n+    const browser = await webdriver(next.url, `${basePath}/hello`)\n+    await browser.eval('window.next.router.push(\"/docs/another\")')\n \n-      await check(() => browser.elementByCss('p').text(), /hello from another/)\n-    })\n+    await check(() => browser.elementByCss('p').text(), /hello from another/)\n+  })\n \n-    it('should work with normal dynamic page', async () => {\n-      const browser = await webdriver(next.url, `${basePath}/hello`)\n-      await browser.elementByCss('#dynamic-link').click()\n-      await check(\n-        () => browser.eval(() => document.documentElement.innerHTML),\n-        /slug: first/\n-      )\n-    })\n+  it('should work with normal dynamic page', async () => {\n+    const browser = await webdriver(next.url, `${basePath}/hello`)\n+    await browser.elementByCss('#dynamic-link').click()\n+    await check(\n+      () => browser.eval(() => document.documentElement.innerHTML),\n+      /slug: first/\n+    )\n+  })\n \n-    it('should work with hash links', async () => {\n-      const browser = await webdriver(next.url, `${basePath}/hello`)\n-      await browser.elementByCss('#hashlink').click()\n-      const url = new URL(await browser.eval(() => window.location.href))\n-      expect(url.pathname).toBe(`${basePath}/hello`)\n-      expect(url.hash).toBe('#hashlink')\n-    })\n+  it('should work with catch-all page', async () => {\n+    const browser = await webdriver(next.url, `${basePath}/hello`)\n+    await browser.elementByCss('#catchall-link').click()\n+    await check(\n+      () => browser.eval(() => document.documentElement.innerHTML),\n+      /parts: hello\\/world/\n+    )\n+  })\n \n-    it('should work with catch-all page', async () => {\n-      const browser = await webdriver(next.url, `${basePath}/hello`)\n-      await browser.elementByCss('#catchall-link').click()\n-      await check(\n-        () => browser.eval(() => document.documentElement.innerHTML),\n-        /parts: hello\\/world/\n-      )\n-    })\n+  it('should redirect trailing slash correctly', async () => {\n+    const res = await fetchViaHTTP(\n+      next.url,\n+      `${basePath}/hello/`,\n+      {},\n+      { redirect: 'manual' }\n+    )\n+    expect(res.status).toBe(308)\n+    const { pathname } = new URL(res.headers.get('location'))\n+    expect(pathname).toBe(`${basePath}/hello`)\n+    const text = await res.text()\n+    expect(text).toContain(`${basePath}/hello`)\n+  })\n \n-    it('should redirect trailing slash correctly', async () => {\n-      const res = await fetchViaHTTP(\n-        next.url,\n-        `${basePath}/hello/`,\n-        {},\n-        { redirect: 'manual' }\n-      )\n-      expect(res.status).toBe(308)\n-      const { pathname } = new URL(res.headers.get('location'))\n-      expect(pathname).toBe(`${basePath}/hello`)\n-      const text = await res.text()\n-      expect(text).toContain(`${basePath}/hello`)\n-    })\n+  it('should redirect trailing slash on root correctly', async () => {\n+    const res = await fetchViaHTTP(\n+      next.url,\n+      `${basePath}/`,\n+      {},\n+      { redirect: 'manual' }\n+    )\n+    expect(res.status).toBe(308)\n+    const { pathname } = new URL(res.headers.get('location'))\n+    expect(pathname).toBe(`${basePath}`)\n+    const text = await res.text()\n+    expect(text).toContain(`${basePath}`)\n+  })\n \n-    it('should redirect trailing slash on root correctly', async () => {\n-      const res = await fetchViaHTTP(\n+  it('should navigate an absolute url', async () => {\n+    const browser = await webdriver(next.url, `${basePath}/absolute-url`)\n+    await browser.waitForElementByCss('#absolute-link').click()\n+    await check(\n+      () => browser.eval(() => window.location.origin),\n+      'https://vercel.com'\n+    )\n+  })\n+\n+  if (!isNextDeploy) {\n+    it('should navigate an absolute local url with basePath', async () => {\n+      const browser = await webdriver(\n         next.url,\n-        `${basePath}/`,\n-        {},\n-        { redirect: 'manual' }\n+        `${basePath}/absolute-url-basepath?port=${next.appPort}`\n       )\n-      expect(res.status).toBe(308)\n-      const { pathname } = new URL(res.headers.get('location'))\n-      expect(pathname).toBe(`${basePath}`)\n-      const text = await res.text()\n-      expect(text).toContain(`${basePath}`)\n-    })\n-\n-    it('should navigate an absolute url', async () => {\n-      const browser = await webdriver(next.url, `${basePath}/absolute-url`)\n+      await browser.eval('window._didNotNavigate = true')\n       await browser.waitForElementByCss('#absolute-link').click()\n-      await check(\n-        () => browser.eval(() => window.location.origin),\n-        'https://vercel.com'\n-      )\n-    })\n+      const text = await browser\n+        .waitForElementByCss('#something-else-page')\n+        .text()\n \n-    if (!(global as any).isNextDeploy) {\n-      it('should navigate an absolute local url with basePath', async () => {\n-        const browser = await webdriver(\n-          next.url,\n-          `${basePath}/absolute-url-basepath?port=${next.appPort}`\n-        )\n-        await browser.eval('window._didNotNavigate = true')\n-        await browser.waitForElementByCss('#absolute-link').click()\n-        const text = await browser\n-          .waitForElementByCss('#something-else-page')\n-          .text()\n-\n-        expect(text).toBe('something else')\n-        expect(await browser.eval('window._didNotNavigate')).toBe(true)\n-      })\n-\n-      it('should navigate an absolute local url without basePath', async () => {\n-        const browser = await webdriver(\n-          next.url,\n-          `${basePath}/absolute-url-no-basepath?port=${next.appPort}`\n-        )\n-        await browser.waitForElementByCss('#absolute-link').click()\n-        await check(\n-          () => browser.eval(() => location.pathname),\n-          '/rewrite-no-basepath'\n-        )\n-        const text = await browser.elementByCss('body').text()\n-\n-        expect(text).toContain('Example Domain')\n-      })\n-    }\n+      expect(text).toBe('something else')\n+      expect(await browser.eval('window._didNotNavigate')).toBe(true)\n+    })\n \n-    it('should 404 when manually adding basePath with <Link>', async () => {\n+    it('should navigate an absolute local url without basePath', async () => {\n       const browser = await webdriver(\n         next.url,\n-        `${basePath}/invalid-manual-basepath`\n+        `${basePath}/absolute-url-no-basepath?port=${next.appPort}`\n       )\n-      await browser.eval('window.beforeNav = \"hi\"')\n-      await browser.elementByCss('#other-page-link').click()\n-\n-      await check(() => browser.eval('window.beforeNav'), {\n-        test(content) {\n-          return content !== 'hi'\n-        },\n-      })\n-\n+      await browser.waitForElementByCss('#absolute-link').click()\n       await check(\n-        () => browser.eval('document.documentElement.innerHTML'),\n-        /This page could not be found/\n+        () => browser.eval(() => location.pathname),\n+        '/rewrite-no-basepath'\n       )\n-    })\n-\n-    it('should 404 when manually adding basePath with router.push', async () => {\n-      const browser = await webdriver(next.url, `${basePath}/hello`)\n-      await browser.eval('window.beforeNav = \"hi\"')\n-      await browser.eval(`window.next.router.push(\"${basePath}/other-page\")`)\n-\n-      await check(() => browser.eval('window.beforeNav'), {\n-        test(content) {\n-          return content !== 'hi'\n-        },\n-      })\n-\n-      const html = await browser.eval('document.documentElement.innerHTML')\n-      expect(html).toContain('This page could not be found')\n-    })\n-\n-    it('should 404 when manually adding basePath with router.replace', async () => {\n-      const browser = await webdriver(next.url, `${basePath}/hello`)\n-      await browser.eval('window.beforeNav = \"hi\"')\n-      await browser.eval(`window.next.router.replace(\"${basePath}/other-page\")`)\n-\n-      await check(() => browser.eval('window.beforeNav'), {\n-        test(content) {\n-          return content !== 'hi'\n-        },\n-      })\n-\n-      const html = await browser.eval('document.documentElement.innerHTML')\n-      expect(html).toContain('This page could not be found')\n-    })\n+      const text = await browser.elementByCss('body').text()\n \n-    it('should show the hello page under the /docs prefix', async () => {\n-      const browser = await webdriver(next.url, `${basePath}/hello`)\n-      try {\n-        const text = await browser.elementByCss('h1').text()\n-        expect(text).toBe('Hello World')\n-      } finally {\n-        await browser.close()\n-      }\n-    })\n-\n-    it('should have correct router paths on first load of /', async () => {\n-      const browser = await webdriver(next.url, `${basePath}`)\n-      await browser.waitForElementByCss('#pathname')\n-      const pathname = await browser.elementByCss('#pathname').text()\n-      expect(pathname).toBe('/')\n-      const asPath = await browser.elementByCss('#as-path').text()\n-      expect(asPath).toBe('/')\n+      expect(text).toContain('Example Domain')\n     })\n+  }\n \n-    it('should have correct router paths on first load of /hello', async () => {\n-      const browser = await webdriver(next.url, `${basePath}/hello`)\n-      await browser.waitForElementByCss('#pathname')\n-      const pathname = await browser.elementByCss('#pathname').text()\n-      expect(pathname).toBe('/hello')\n-      const asPath = await browser.elementByCss('#as-path').text()\n-      expect(asPath).toBe('/hello')\n-    })\n+  it('should show the hello page under the /docs prefix', async () => {\n+    const browser = await webdriver(next.url, `${basePath}/hello`)\n+    try {\n+      const text = await browser.elementByCss('h1').text()\n+      expect(text).toBe('Hello World')\n+    } finally {\n+      await browser.close()\n+    }\n+  })\n \n-    it('should fetch data for getStaticProps without reloading', async () => {\n-      const browser = await webdriver(next.url, `${basePath}/hello`)\n-      await browser.eval('window.beforeNavigate = true')\n-      await browser.elementByCss('#gsp-link').click()\n-      await browser.waitForElementByCss('#gsp')\n-      expect(await browser.eval('window.beforeNavigate')).toBe(true)\n+  it('should have correct router paths on first load of /', async () => {\n+    const browser = await webdriver(next.url, `${basePath}`)\n+    await browser.waitForElementByCss('#pathname')\n+    const pathname = await browser.elementByCss('#pathname').text()\n+    expect(pathname).toBe('/')\n+    const asPath = await browser.elementByCss('#as-path').text()\n+    expect(asPath).toBe('/')\n+  })\n \n-      const props = JSON.parse(await browser.elementByCss('#props').text())\n-      expect(props.hello).toBe('world')\n+  it('should have correct router paths on first load of /hello', async () => {\n+    const browser = await webdriver(next.url, `${basePath}/hello`)\n+    await browser.waitForElementByCss('#pathname')\n+    const pathname = await browser.elementByCss('#pathname').text()\n+    expect(pathname).toBe('/hello')\n+    const asPath = await browser.elementByCss('#as-path').text()\n+    expect(asPath).toBe('/hello')\n+  })\n \n-      const pathname = await browser.elementByCss('#pathname').text()\n-      expect(pathname).toBe('/gsp')\n-    })\n+  it('should fetch data for getStaticProps without reloading', async () => {\n+    const browser = await webdriver(next.url, `${basePath}/hello`)\n+    await browser.eval('window.beforeNavigate = true')\n+    await browser.elementByCss('#gsp-link').click()\n+    await browser.waitForElementByCss('#gsp')\n+    expect(await browser.eval('window.beforeNavigate')).toBe(true)\n \n-    it('should fetch data for getServerSideProps without reloading', async () => {\n-      const browser = await webdriver(next.url, `${basePath}/hello`)\n-      await browser.eval('window.beforeNavigate = true')\n-      await browser.elementByCss('#gssp-link').click()\n-      await browser.waitForElementByCss('#gssp')\n-      expect(await browser.eval('window.beforeNavigate')).toBe(true)\n+    const props = JSON.parse(await browser.elementByCss('#props').text())\n+    expect(props.hello).toBe('world')\n \n-      const props = JSON.parse(await browser.elementByCss('#props').text())\n-      expect(props.hello).toBe('world')\n+    const pathname = await browser.elementByCss('#pathname').text()\n+    expect(pathname).toBe('/gsp')\n+  })\n \n-      const pathname = await browser.elementByCss('#pathname').text()\n-      const asPath = await browser.elementByCss('#asPath').text()\n-      expect(pathname).toBe('/gssp')\n-      expect(asPath).toBe('/gssp')\n-    })\n+  it('should fetch data for getServerSideProps without reloading', async () => {\n+    const browser = await webdriver(next.url, `${basePath}/hello`)\n+    await browser.eval('window.beforeNavigate = true')\n+    await browser.elementByCss('#gssp-link').click()\n+    await browser.waitForElementByCss('#gssp')\n+    expect(await browser.eval('window.beforeNavigate')).toBe(true)\n \n-    it('should have correct href for a link', async () => {\n-      const browser = await webdriver(next.url, `${basePath}/hello`)\n-      const href = await browser.elementByCss('a').getAttribute('href')\n-      const { pathname } = url.parse(href)\n-      expect(pathname).toBe(`${basePath}/other-page`)\n-    })\n+    const props = JSON.parse(await browser.elementByCss('#props').text())\n+    expect(props.hello).toBe('world')\n \n-    it('should have correct href for a link to /', async () => {\n-      const browser = await webdriver(next.url, `${basePath}/link-to-root`)\n-      const href = await browser.elementByCss('#link-back').getAttribute('href')\n-      const { pathname } = url.parse(href)\n-      expect(pathname).toBe(`${basePath}`)\n-    })\n+    const pathname = await browser.elementByCss('#pathname').text()\n+    const asPath = await browser.elementByCss('#asPath').text()\n+    expect(pathname).toBe('/gssp')\n+    expect(asPath).toBe('/gssp')\n+  })\n \n-    it('should show 404 for page not under the /docs prefix', async () => {\n-      const text = await renderViaHTTP(next.url, '/hello')\n-      expect(text).not.toContain('Hello World')\n-      expect(text).toContain(\n-        isDeploy ? 'NOT_FOUND' : 'This page could not be found'\n-      )\n-    })\n+  it('should have correct href for a link', async () => {\n+    const browser = await webdriver(next.url, `${basePath}/hello`)\n+    const href = await browser.elementByCss('a').getAttribute('href')\n+    const { pathname } = url.parse(href)\n+    expect(pathname).toBe(`${basePath}/other-page`)\n+  })\n \n-    it('should show the other-page page under the /docs prefix', async () => {\n-      const browser = await webdriver(next.url, `${basePath}/other-page`)\n-      try {\n-        const text = await browser.elementByCss('h1').text()\n-        expect(text).toBe('Hello Other')\n-      } finally {\n-        await browser.close()\n-      }\n-    })\n+  it('should have correct href for a link to /', async () => {\n+    const browser = await webdriver(next.url, `${basePath}/link-to-root`)\n+    const href = await browser.elementByCss('#link-back').getAttribute('href')\n+    const { pathname } = url.parse(href)\n+    expect(pathname).toBe(`${basePath}`)\n+  })\n \n-    it('should have basePath field on Router', async () => {\n-      const html = await renderViaHTTP(next.url, `${basePath}/hello`)\n-      const $ = cheerio.load(html)\n-      expect($('#base-path').text()).toBe(`${basePath}`)\n-    })\n+  it('should show 404 for page not under the /docs prefix', async () => {\n+    const text = await renderViaHTTP(next.url, '/hello')\n+    expect(text).not.toContain('Hello World')\n+    expect(text).toContain(\n+      isNextDeploy ? 'NOT_FOUND' : 'This page could not be found'\n+    )\n+  })\n \n-    it('should navigate to the page without refresh', async () => {\n-      const browser = await webdriver(next.url, `${basePath}/hello`)\n-      try {\n-        await browser.eval('window.itdidnotrefresh = \"hello\"')\n-        const text = await browser\n-          .elementByCss('#other-page-link')\n-          .click()\n-          .waitForElementByCss('#other-page-title')\n-          .elementByCss('h1')\n-          .text()\n-\n-        expect(text).toBe('Hello Other')\n-        expect(await browser.eval('window.itdidnotrefresh')).toBe('hello')\n-      } finally {\n-        await browser.close()\n-      }\n-    })\n+  it('should show the other-page page under the /docs prefix', async () => {\n+    const browser = await webdriver(next.url, `${basePath}/other-page`)\n+    try {\n+      const text = await browser.elementByCss('h1').text()\n+      expect(text).toBe('Hello Other')\n+    } finally {\n+      await browser.close()\n+    }\n+  })\n \n-    it('should use urls with basepath in router events', async () => {\n-      const browser = await webdriver(next.url, `${basePath}/hello`)\n-      try {\n-        await check(\n-          () => browser.eval('window.next.router.isReady ? \"ready\" : \"no\"'),\n-          'ready'\n-        )\n-        await browser.eval('window._clearEventLog()')\n-        await browser\n-          .elementByCss('#other-page-link')\n-          .click()\n-          .waitForElementByCss('#other-page-title')\n-\n-        const eventLog = await browser.eval('window._getEventLog()')\n-        expect(\n-          eventLog.filter((item) => item[1]?.endsWith('/other-page'))\n-        ).toEqual([\n-          ['routeChangeStart', `${basePath}/other-page`, { shallow: false }],\n-          ['beforeHistoryChange', `${basePath}/other-page`, { shallow: false }],\n-          ['routeChangeComplete', `${basePath}/other-page`, { shallow: false }],\n-        ])\n-      } finally {\n-        await browser.close()\n-      }\n-    })\n+  it('should have basePath field on Router', async () => {\n+    const html = await renderViaHTTP(next.url, `${basePath}/hello`)\n+    const $ = cheerio.load(html)\n+    expect($('#base-path').text()).toBe(`${basePath}`)\n+  })\n \n-    it('should use urls with basepath in router events for hash changes', async () => {\n-      const browser = await webdriver(next.url, `${basePath}/hello`)\n-      try {\n-        await check(\n-          () => browser.eval('window.next.router.isReady ? \"ready\" : \"no\"'),\n-          'ready'\n-        )\n-        await browser.eval('window._clearEventLog()')\n-        await browser.elementByCss('#hash-change').click()\n+  it('should navigate to the page without refresh', async () => {\n+    const browser = await webdriver(next.url, `${basePath}/hello`)\n+    try {\n+      await browser.eval('window.itdidnotrefresh = \"hello\"')\n+      const text = await browser\n+        .elementByCss('#other-page-link')\n+        .click()\n+        .waitForElementByCss('#other-page-title')\n+        .elementByCss('h1')\n+        .text()\n+\n+      expect(text).toBe('Hello Other')\n+      expect(await browser.eval('window.itdidnotrefresh')).toBe('hello')\n+    } finally {\n+      await browser.close()\n+    }\n+  })\n \n-        const eventLog = await browser.eval('window._getEventLog()')\n-        expect(eventLog).toEqual([\n-          [\n-            'hashChangeStart',\n-            `${basePath}/hello#some-hash`,\n-            { shallow: false },\n-          ],\n-          [\n-            'hashChangeComplete',\n-            `${basePath}/hello#some-hash`,\n-            { shallow: false },\n-          ],\n-        ])\n-      } finally {\n-        await browser.close()\n-      }\n-    })\n+  it('should allow URL query strings without refresh', async () => {\n+    const browser = await webdriver(next.url, `${basePath}/hello?query=true`)\n+    try {\n+      await browser.eval('window.itdidnotrefresh = \"hello\"')\n+      await new Promise((resolve, reject) => {\n+        // Timeout of EventSource created in setupPing()\n+        // (on-demand-entries-utils.js) is 5000 ms (see #13132, #13560)\n+        setTimeout(resolve, isNextDev ? 10000 : 1000)\n+      })\n+      expect(await browser.eval('window.itdidnotrefresh')).toBe('hello')\n \n-    it('should use urls with basepath in router events for cancelled routes', async () => {\n-      const browser = await webdriver(next.url, `${basePath}/hello`)\n-      try {\n-        await check(\n-          () => browser.eval('window.next.router.isReady ? \"ready\" : \"no\"'),\n-          'ready'\n-        )\n-        await browser.eval('window._clearEventLog()')\n-\n-        await browser\n-          .elementByCss('#slow-route')\n-          .click()\n-          .elementByCss('#other-page-link')\n-          .click()\n-          .waitForElementByCss('#other-page-title')\n-\n-        const eventLog = await browser.eval('window._getEventLog()')\n-        expect(eventLog).toEqual([\n-          ['routeChangeStart', `${basePath}/slow-route`, { shallow: false }],\n-          [\n-            'routeChangeError',\n-            'Route Cancelled',\n-            true,\n-            `${basePath}/slow-route`,\n-            { shallow: false },\n-          ],\n-          ['routeChangeStart', `${basePath}/other-page`, { shallow: false }],\n-          ['beforeHistoryChange', `${basePath}/other-page`, { shallow: false }],\n-          ['routeChangeComplete', `${basePath}/other-page`, { shallow: false }],\n-        ])\n-      } finally {\n-        await browser.close()\n-      }\n-    })\n+      const pathname = await browser.elementByCss('#pathname').text()\n+      expect(pathname).toBe('/hello')\n+      expect(await browser.eval('window.location.pathname')).toBe(\n+        `${basePath}/hello`\n+      )\n+      expect(await browser.eval('window.location.search')).toBe('?query=true')\n \n-    it('should use urls with basepath in router events for failed route change', async () => {\n-      const browser = await webdriver(next.url, `${basePath}/hello`)\n-      try {\n-        await check(\n-          () => browser.eval('window.next.router.isReady ? \"ready\" : \"no\"'),\n-          'ready'\n-        )\n-        await browser.eval('window._clearEventLog()')\n-        await browser.elementByCss('#error-route').click()\n-\n-        await check(async () => {\n-          const eventLog = await browser.eval('window._getEventLog()')\n-          assert.deepEqual(eventLog, [\n-            ['routeChangeStart', `${basePath}/error-route`, { shallow: false }],\n-            [\n-              'routeChangeError',\n-              'Failed to load static props',\n-              null,\n-              `${basePath}/error-route`,\n-              { shallow: false },\n-            ],\n-          ])\n-          return 'success'\n-        }, 'success')\n-      } finally {\n-        await browser.close()\n+      if (isNextDev) {\n+        await assertNoRedbox(browser)\n       }\n-    })\n+    } finally {\n+      await browser.close()\n+    }\n+  })\n \n-    it('should allow URL query strings without refresh', async () => {\n-      const browser = await webdriver(next.url, `${basePath}/hello?query=true`)\n-      try {\n-        await browser.eval('window.itdidnotrefresh = \"hello\"')\n-        await new Promise((resolve, reject) => {\n-          // Timeout of EventSource created in setupPing()\n-          // (on-demand-entries-utils.js) is 5000 ms (see #13132, #13560)\n-          setTimeout(resolve, isDev ? 10000 : 1000)\n-        })\n-        expect(await browser.eval('window.itdidnotrefresh')).toBe('hello')\n-\n-        const pathname = await browser.elementByCss('#pathname').text()\n-        expect(pathname).toBe('/hello')\n-        expect(await browser.eval('window.location.pathname')).toBe(\n-          `${basePath}/hello`\n-        )\n-        expect(await browser.eval('window.location.search')).toBe('?query=true')\n+  it('should allow URL query strings on index without refresh', async () => {\n+    const browser = await webdriver(next.url, `${basePath}?query=true`)\n+    try {\n+      await browser.eval('window.itdidnotrefresh = \"hello\"')\n+      await new Promise((resolve, reject) => {\n+        // Timeout of EventSource created in setupPing()\n+        // (on-demand-entries-utils.js) is 5000 ms (see #13132, #13560)\n+        setTimeout(resolve, isNextDev ? 10000 : 1000)\n+      })\n+      expect(await browser.eval('window.itdidnotrefresh')).toBe('hello')\n \n-        if (isDev) {\n-          await assertNoRedbox(browser)\n-        }\n-      } finally {\n-        await browser.close()\n-      }\n-    })\n+      const pathname = await browser.elementByCss('#pathname').text()\n+      expect(pathname).toBe('/')\n+      expect(await browser.eval('window.location.pathname')).toBe(basePath)\n+      expect(await browser.eval('window.location.search')).toBe('?query=true')\n \n-    it('should allow URL query strings on index without refresh', async () => {\n-      const browser = await webdriver(next.url, `${basePath}?query=true`)\n-      try {\n-        await browser.eval('window.itdidnotrefresh = \"hello\"')\n-        await new Promise((resolve, reject) => {\n-          // Timeout of EventSource created in setupPing()\n-          // (on-demand-entries-utils.js) is 5000 ms (see #13132, #13560)\n-          setTimeout(resolve, isDev ? 10000 : 1000)\n-        })\n-        expect(await browser.eval('window.itdidnotrefresh')).toBe('hello')\n-\n-        const pathname = await browser.elementByCss('#pathname').text()\n-        expect(pathname).toBe('/')\n-        expect(await browser.eval('window.location.pathname')).toBe(basePath)\n-        expect(await browser.eval('window.location.search')).toBe('?query=true')\n-\n-        if (isDev) {\n-          await assertNoRedbox(browser)\n-        }\n-      } finally {\n-        await browser.close()\n+      if (isNextDev) {\n+        await assertNoRedbox(browser)\n       }\n-    })\n+    } finally {\n+      await browser.close()\n+    }\n+  })\n \n-    it('should correctly replace state when same asPath but different url', async () => {\n-      const browser = await webdriver(next.url, `${basePath}`)\n-      try {\n-        await browser.elementByCss('#hello-link').click()\n-        await browser.waitForElementByCss('#something-else-link')\n-        await browser.elementByCss('#something-else-link').click()\n-        await browser.waitForElementByCss('#something-else-page')\n-        await browser.back()\n-        await browser.waitForElementByCss('#index-page')\n-        await browser.forward()\n-        await browser.waitForElementByCss('#something-else-page')\n-      } finally {\n-        await browser.close()\n-      }\n-    })\n-  }\n-  runTests((global as any).isNextDev, (global as any).isNextDeploy)\n+  it('should correctly replace state when same asPath but different url', async () => {\n+    const browser = await webdriver(next.url, `${basePath}`)\n+    try {\n+      await browser.elementByCss('#hello-link').click()\n+      await browser.waitForElementByCss('#something-else-link')\n+      await browser.elementByCss('#something-else-link').click()\n+      await browser.waitForElementByCss('#something-else-page')\n+      await browser.back()\n+      await browser.waitForElementByCss('#index-page')\n+      await browser.forward()\n+      await browser.waitForElementByCss('#something-else-page')\n+    } finally {\n+      await browser.close()\n+    }\n+  })\n })"
        },
        {
            "sha": "b4a23361d54e1e4e478b154d40a20c84123a4202",
            "filename": "test/e2e/basepath/error-pages.test.ts",
            "status": "added",
            "additions": 174,
            "deletions": 0,
            "changes": 174,
            "blob_url": "https://github.com/vercel/next.js/blob/3f9f403a048f1f3b1419d92f70245d4e8c77ac27/test%2Fe2e%2Fbasepath%2Ferror-pages.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/3f9f403a048f1f3b1419d92f70245d4e8c77ac27/test%2Fe2e%2Fbasepath%2Ferror-pages.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fbasepath%2Ferror-pages.test.ts?ref=3f9f403a048f1f3b1419d92f70245d4e8c77ac27",
            "patch": "@@ -0,0 +1,174 @@\n+import webdriver from 'next-webdriver'\n+import { nextTestSetup } from 'e2e-utils'\n+import { check, renderViaHTTP } from 'next-test-utils'\n+\n+describe('basePath', () => {\n+  const basePath = '/docs'\n+\n+  const { next, isNextDeploy } = nextTestSetup({\n+    files: __dirname,\n+    nextConfig: {\n+      basePath,\n+      onDemandEntries: {\n+        // Make sure entries are not getting disposed.\n+        maxInactiveAge: 1000 * 60 * 60,\n+      },\n+    },\n+  })\n+\n+  describe('client-side navigation', () => {\n+    it('should navigate to /404 correctly client-side', async () => {\n+      const browser = await webdriver(next.url, `${basePath}/slug-1`)\n+      await check(\n+        () => browser.eval('document.documentElement.innerHTML'),\n+        /slug-1/\n+      )\n+\n+      await browser.eval('next.router.push(\"/404\", \"/slug-2\")')\n+      await check(\n+        () => browser.eval('document.documentElement.innerHTML'),\n+        /page could not be found/\n+      )\n+      expect(await browser.eval('location.pathname')).toBe(`${basePath}/slug-2`)\n+    })\n+\n+    it('should navigate to /_error correctly client-side', async () => {\n+      const browser = await webdriver(next.url, `${basePath}/slug-1`)\n+      await check(\n+        () => browser.eval('document.documentElement.innerHTML'),\n+        /slug-1/\n+      )\n+\n+      await browser.eval('next.router.push(\"/_error\", \"/slug-2\")')\n+      await check(\n+        () => browser.eval('document.documentElement.innerHTML'),\n+        /page could not be found/\n+      )\n+      expect(await browser.eval('location.pathname')).toBe(`${basePath}/slug-2`)\n+    })\n+  })\n+\n+  if (process.env.BROWSER_NAME === 'safari') {\n+    // currently only testing the above tests in safari\n+    // we can investigate testing more cases below if desired\n+    return\n+  }\n+\n+  it('should not update URL for a 404', async () => {\n+    const browser = await webdriver(next.url, '/missing')\n+\n+    if (isNextDeploy) {\n+      // the custom 404 only shows inside of the basePath so this\n+      // will be the Vercel default 404 page\n+      expect(\n+        await browser.eval('document.documentElement.innerHTML')\n+      ).toContain('NOT_FOUND')\n+    } else {\n+      const pathname = await browser.eval(() => window.location.pathname)\n+      expect(await browser.eval(() => (window as any).next.router.asPath)).toBe(\n+        '/missing'\n+      )\n+      expect(pathname).toBe('/missing')\n+    }\n+  })\n+\n+  it('should handle 404 urls that start with basePath', async () => {\n+    const browser = await webdriver(next.url, `${basePath}hello`)\n+\n+    if (isNextDeploy) {\n+      // the custom 404 only shows inside of the basePath so this\n+      // will be the Vercel default 404 page\n+      expect(\n+        await browser.eval('document.documentElement.innerHTML')\n+      ).toContain('404: This page could not be found')\n+    } else {\n+      expect(await browser.eval(() => (window as any).next.router.asPath)).toBe(\n+        `${basePath}hello`\n+      )\n+      expect(await browser.eval(() => window.location.pathname)).toBe(\n+        `${basePath}hello`\n+      )\n+    }\n+  })\n+\n+  // TODO: this test has been passing incorrectly since the below check\n+  // wasn't being awaited. We need to investigate if this test is\n+  // correct or not.\n+  it.skip('should navigate back to a non-basepath 404 that starts with basepath', async () => {\n+    const browser = await webdriver(next.url, `${basePath}hello`)\n+    await browser.eval(() => ((window as any).navigationMarker = true))\n+    await browser.eval(() => (window as any).next.router.push('/hello'))\n+    await browser.waitForElementByCss('#pathname')\n+    await browser.back()\n+    await check(\n+      () => browser.eval(() => window.location.pathname),\n+      `${basePath}hello`\n+    )\n+    expect(await browser.eval(() => (window as any).next.router.asPath)).toBe(\n+      `${basePath}hello`\n+    )\n+    expect(await browser.eval(() => (window as any).navigationMarker)).toBe(\n+      true\n+    )\n+  })\n+\n+  describe('manually added basePath in application logic', () => {\n+    it('should 404 when manually adding basePath with <Link>', async () => {\n+      const browser = await webdriver(\n+        next.url,\n+        `${basePath}/invalid-manual-basepath`\n+      )\n+      await browser.eval('window.beforeNav = \"hi\"')\n+      await browser.elementByCss('#other-page-link').click()\n+\n+      await check(() => browser.eval('window.beforeNav'), {\n+        test(content) {\n+          return content !== 'hi'\n+        },\n+      })\n+\n+      await check(\n+        () => browser.eval('document.documentElement.innerHTML'),\n+        /This page could not be found/\n+      )\n+    })\n+\n+    it('should 404 when manually adding basePath with router.push', async () => {\n+      const browser = await webdriver(next.url, `${basePath}/hello`)\n+      await browser.eval('window.beforeNav = \"hi\"')\n+      await browser.eval(`window.next.router.push(\"${basePath}/other-page\")`)\n+\n+      await check(() => browser.eval('window.beforeNav'), {\n+        test(content) {\n+          return content !== 'hi'\n+        },\n+      })\n+\n+      const html = await browser.eval('document.documentElement.innerHTML')\n+      expect(html).toContain('This page could not be found')\n+    })\n+\n+    it('should 404 when manually adding basePath with router.replace', async () => {\n+      const browser = await webdriver(next.url, `${basePath}/hello`)\n+      await browser.eval('window.beforeNav = \"hi\"')\n+      await browser.eval(`window.next.router.replace(\"${basePath}/other-page\")`)\n+\n+      await check(() => browser.eval('window.beforeNav'), {\n+        test(content) {\n+          return content !== 'hi'\n+        },\n+      })\n+\n+      const html = await browser.eval('document.documentElement.innerHTML')\n+      expect(html).toContain('This page could not be found')\n+    })\n+  })\n+\n+  it('should show 404 for page not under the /docs prefix', async () => {\n+    const text = await renderViaHTTP(next.url, '/hello')\n+    expect(text).not.toContain('Hello World')\n+    expect(text).toContain(\n+      isNextDeploy ? 'NOT_FOUND' : 'This page could not be found'\n+    )\n+  })\n+})"
        },
        {
            "sha": "972b5c997dca963ba1d93726b573e15a81691e9f",
            "filename": "test/e2e/basepath/pages/hello.js",
            "status": "modified",
            "additions": 6,
            "deletions": 2,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/3f9f403a048f1f3b1419d92f70245d4e8c77ac27/test%2Fe2e%2Fbasepath%2Fpages%2Fhello.js",
            "raw_url": "https://github.com/vercel/next.js/raw/3f9f403a048f1f3b1419d92f70245d4e8c77ac27/test%2Fe2e%2Fbasepath%2Fpages%2Fhello.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fbasepath%2Fpages%2Fhello.js?ref=3f9f403a048f1f3b1419d92f70245d4e8c77ac27",
            "patch": "@@ -42,7 +42,9 @@ function Page() {\n       </Link>\n       <br />\n       <div id=\"base-path\">{router.basePath}</div>\n-      <div id=\"pathname\">{routerObj.pathname}</div>\n+      <div id=\"pathname\" suppressHydrationWarning>\n+        {routerObj.pathname}\n+      </div>\n       <div\n         id=\"trigger-error\"\n         onClick={() => {\n@@ -52,7 +54,9 @@ function Page() {\n         click me for error\n       </div>\n       <br />\n-      <div id=\"as-path\">{routerObj.asPath}</div>\n+      <div id=\"as-path\" suppressHydrationWarning>\n+        {routerObj.asPath}\n+      </div>\n       <Link href=\"/slow-route\" id=\"slow-route\">\n         <h1>Slow route</h1>\n       </Link>"
        },
        {
            "sha": "5428e2f563fafcd85a6f8d92f6e96e6964140362",
            "filename": "test/e2e/basepath/query-hash.test.ts",
            "status": "added",
            "additions": 59,
            "deletions": 0,
            "changes": 59,
            "blob_url": "https://github.com/vercel/next.js/blob/3f9f403a048f1f3b1419d92f70245d4e8c77ac27/test%2Fe2e%2Fbasepath%2Fquery-hash.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/3f9f403a048f1f3b1419d92f70245d4e8c77ac27/test%2Fe2e%2Fbasepath%2Fquery-hash.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fbasepath%2Fquery-hash.test.ts?ref=3f9f403a048f1f3b1419d92f70245d4e8c77ac27",
            "patch": "@@ -0,0 +1,59 @@\n+import webdriver from 'next-webdriver'\n+import { check } from 'next-test-utils'\n+import { nextTestSetup } from 'e2e-utils'\n+\n+describe('basePath query/hash handling', () => {\n+  const basePath = '/docs'\n+  const { next } = nextTestSetup({\n+    files: __dirname,\n+    nextConfig: {\n+      basePath,\n+      onDemandEntries: {\n+        // Make sure entries are not getting disposed.\n+        maxInactiveAge: 1000 * 60 * 60,\n+      },\n+    },\n+  })\n+\n+  it.each([\n+    { hash: '#hello?' },\n+    { hash: '#?' },\n+    { hash: '##' },\n+    { hash: '##?' },\n+    { hash: '##hello?' },\n+    { hash: '##hello' },\n+    { hash: '#hello?world' },\n+    { search: '?hello=world', hash: '#a', query: { hello: 'world' } },\n+    { search: '?hello', hash: '#a', query: { hello: '' } },\n+    { search: '?hello=', hash: '#a', query: { hello: '' } },\n+  ])(\n+    'is correct during query updating $hash $search',\n+    async ({ hash, search, query }) => {\n+      const browser = await webdriver(\n+        next.url,\n+        `${basePath}${search || ''}${hash || ''}`\n+      )\n+\n+      await check(\n+        () =>\n+          browser.eval('window.next.router.isReady ? \"ready\" : \"not ready\"'),\n+        'ready'\n+      )\n+      expect(await browser.eval('window.location.pathname')).toBe(basePath)\n+      expect(await browser.eval('window.location.search')).toBe(search || '')\n+      expect(await browser.eval('window.location.hash')).toBe(hash || '')\n+      expect(await browser.eval('next.router.pathname')).toBe('/')\n+      expect(\n+        JSON.parse(await browser.eval('JSON.stringify(next.router.query)'))\n+      ).toEqual(query || {})\n+    }\n+  )\n+\n+  it('should work with hash links', async () => {\n+    const browser = await webdriver(next.url, `${basePath}/hello`)\n+    await browser.elementByCss('#hashlink').click()\n+    const url = new URL(await browser.eval(() => window.location.href))\n+    expect(url.pathname).toBe(`${basePath}/hello`)\n+    expect(url.hash).toBe('#hashlink')\n+  })\n+})"
        },
        {
            "sha": "786129159945903d8be7fa1d5491703587b6d03f",
            "filename": "test/e2e/basepath/redirect-and-rewrite.test.ts",
            "status": "added",
            "additions": 155,
            "deletions": 0,
            "changes": 155,
            "blob_url": "https://github.com/vercel/next.js/blob/3f9f403a048f1f3b1419d92f70245d4e8c77ac27/test%2Fe2e%2Fbasepath%2Fredirect-and-rewrite.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/3f9f403a048f1f3b1419d92f70245d4e8c77ac27/test%2Fe2e%2Fbasepath%2Fredirect-and-rewrite.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fbasepath%2Fredirect-and-rewrite.test.ts?ref=3f9f403a048f1f3b1419d92f70245d4e8c77ac27",
            "patch": "@@ -0,0 +1,155 @@\n+import url from 'url'\n+import { nextTestSetup } from 'e2e-utils'\n+import { fetchViaHTTP, renderViaHTTP } from 'next-test-utils'\n+\n+describe('basePath', () => {\n+  const basePath = '/docs'\n+\n+  const { next, isNextDeploy } = nextTestSetup({\n+    files: __dirname,\n+    nextConfig: {\n+      basePath,\n+      onDemandEntries: {\n+        // Make sure entries are not getting disposed.\n+        maxInactiveAge: 1000 * 60 * 60,\n+      },\n+      async rewrites() {\n+        return [\n+          {\n+            source: '/rewrite-1',\n+            destination: '/gssp',\n+          },\n+          {\n+            source: '/rewrite-no-basepath',\n+            destination: 'https://example.vercel.sh',\n+            basePath: false,\n+          },\n+          {\n+            source: '/rewrite/chain-1',\n+            destination: '/rewrite/chain-2',\n+          },\n+          {\n+            source: '/rewrite/chain-2',\n+            destination: '/gssp',\n+          },\n+        ]\n+      },\n+\n+      async redirects() {\n+        return [\n+          {\n+            source: '/redirect-1',\n+            destination: '/somewhere-else',\n+            permanent: false,\n+          },\n+          {\n+            source: '/redirect-no-basepath',\n+            destination: '/another-destination',\n+            permanent: false,\n+            basePath: false,\n+          },\n+        ]\n+      },\n+\n+      async headers() {\n+        return [\n+          {\n+            source: '/add-header',\n+            headers: [\n+              {\n+                key: 'x-hello',\n+                value: 'world',\n+              },\n+            ],\n+          },\n+          {\n+            source: '/add-header-no-basepath',\n+            basePath: false,\n+            headers: [\n+              {\n+                key: 'x-hello',\n+                value: 'world',\n+              },\n+            ],\n+          },\n+        ]\n+      },\n+    },\n+  })\n+\n+  it('should rewrite with basePath by default', async () => {\n+    const html = await renderViaHTTP(next.url, `${basePath}/rewrite-1`)\n+    expect(html).toContain('getServerSideProps')\n+  })\n+\n+  it('should not rewrite without basePath without disabling', async () => {\n+    const res = await fetchViaHTTP(next.url, '/rewrite-1')\n+    expect(res.status).toBe(404)\n+  })\n+\n+  it('should not rewrite with basePath when set to false', async () => {\n+    // won't 404 as it matches the dynamic [slug] route\n+    const html = await renderViaHTTP(\n+      next.url,\n+      `${basePath}/rewrite-no-basePath`\n+    )\n+    expect(html).toContain('slug')\n+  })\n+\n+  it('should rewrite without basePath when set to false', async () => {\n+    const html = await renderViaHTTP(next.url, '/rewrite-no-basePath')\n+    expect(html).toContain('Example Domain')\n+  })\n+\n+  it('should redirect with basePath by default', async () => {\n+    const res = await fetchViaHTTP(\n+      next.url,\n+      `${basePath}/redirect-1`,\n+      undefined,\n+      {\n+        redirect: 'manual',\n+      }\n+    )\n+    const { pathname } = url.parse(res.headers.get('location') || '')\n+    expect(pathname).toBe(`${basePath}/somewhere-else`)\n+    expect(res.status).toBe(307)\n+    const text = await res.text()\n+    if (!isNextDeploy) {\n+      expect(text).toContain(`${basePath}/somewhere-else`)\n+    }\n+  })\n+\n+  it('should not redirect without basePath without disabling', async () => {\n+    const res = await fetchViaHTTP(next.url, '/redirect-1', undefined, {\n+      redirect: 'manual',\n+    })\n+    expect(res.status).toBe(404)\n+  })\n+\n+  it('should not redirect with basePath when set to false', async () => {\n+    // won't 404 as it matches the dynamic [slug] route\n+    const html = await renderViaHTTP(\n+      next.url,\n+      `${basePath}/rewrite-no-basePath`\n+    )\n+    expect(html).toContain('slug')\n+  })\n+\n+  it('should redirect without basePath when set to false', async () => {\n+    const res = await fetchViaHTTP(\n+      next.url,\n+      '/redirect-no-basepath',\n+      undefined,\n+      {\n+        redirect: 'manual',\n+      }\n+    )\n+    const { pathname } = url.parse(res.headers.get('location') || '')\n+    expect(pathname).toBe('/another-destination')\n+    expect(res.status).toBe(307)\n+    const text = await res.text()\n+    if (!isNextDeploy) {\n+      expect(text).toContain('/another-destination')\n+    }\n+  })\n+})"
        },
        {
            "sha": "cdfc399b5eb2211cca1cbcd9a87040bce9293961",
            "filename": "test/e2e/basepath/router-events.test.ts",
            "status": "added",
            "additions": 132,
            "deletions": 0,
            "changes": 132,
            "blob_url": "https://github.com/vercel/next.js/blob/3f9f403a048f1f3b1419d92f70245d4e8c77ac27/test%2Fe2e%2Fbasepath%2Frouter-events.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/3f9f403a048f1f3b1419d92f70245d4e8c77ac27/test%2Fe2e%2Fbasepath%2Frouter-events.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fbasepath%2Frouter-events.test.ts?ref=3f9f403a048f1f3b1419d92f70245d4e8c77ac27",
            "patch": "@@ -0,0 +1,132 @@\n+import assert from 'assert'\n+import webdriver from 'next-webdriver'\n+import { nextTestSetup } from 'e2e-utils'\n+import { check, retry } from 'next-test-utils'\n+\n+describe('basePath', () => {\n+  const basePath = '/docs'\n+\n+  const { next } = nextTestSetup({\n+    files: __dirname,\n+    nextConfig: {\n+      basePath,\n+      onDemandEntries: {\n+        // Make sure entries are not getting disposed.\n+        maxInactiveAge: 1000 * 60 * 60,\n+      },\n+    },\n+  })\n+\n+  it('should use urls with basepath in router events', async () => {\n+    const browser = await webdriver(next.url, `${basePath}/hello`)\n+    try {\n+      await check(\n+        () => browser.eval('window.next.router.isReady ? \"ready\" : \"no\"'),\n+        'ready'\n+      )\n+      await browser.eval('window._clearEventLog()')\n+      await browser\n+        .elementByCss('#other-page-link')\n+        .click()\n+        .waitForElementByCss('#other-page-title')\n+\n+      const eventLog = await browser.eval('window._getEventLog()')\n+      expect(\n+        eventLog.filter((item) => item[1]?.endsWith('/other-page'))\n+      ).toEqual([\n+        ['routeChangeStart', `${basePath}/other-page`, { shallow: false }],\n+        ['beforeHistoryChange', `${basePath}/other-page`, { shallow: false }],\n+        ['routeChangeComplete', `${basePath}/other-page`, { shallow: false }],\n+      ])\n+    } finally {\n+      await browser.close()\n+    }\n+  })\n+\n+  it('should use urls with basepath in router events for hash changes', async () => {\n+    const browser = await webdriver(next.url, `${basePath}/hello`)\n+    try {\n+      await check(\n+        () => browser.eval('window.next.router.isReady ? \"ready\" : \"no\"'),\n+        'ready'\n+      )\n+      await browser.eval('window._clearEventLog()')\n+      await browser.elementByCss('#hash-change').click()\n+\n+      const eventLog = await browser.eval('window._getEventLog()')\n+      expect(eventLog).toEqual([\n+        ['hashChangeStart', `${basePath}/hello#some-hash`, { shallow: false }],\n+        [\n+          'hashChangeComplete',\n+          `${basePath}/hello#some-hash`,\n+          { shallow: false },\n+        ],\n+      ])\n+    } finally {\n+      await browser.close()\n+    }\n+  })\n+\n+  it('should use urls with basepath in router events for cancelled routes', async () => {\n+    const browser = await webdriver(next.url, `${basePath}/hello`)\n+    try {\n+      await check(\n+        () => browser.eval('window.next.router.isReady ? \"ready\" : \"no\"'),\n+        'ready'\n+      )\n+      await browser.eval('window._clearEventLog()')\n+\n+      await browser\n+        .elementByCss('#slow-route')\n+        .click()\n+        .elementByCss('#other-page-link')\n+        .click()\n+        .waitForElementByCss('#other-page-title')\n+\n+      const eventLog = await browser.eval('window._getEventLog()')\n+      expect(eventLog).toEqual([\n+        ['routeChangeStart', `${basePath}/slow-route`, { shallow: false }],\n+        [\n+          'routeChangeError',\n+          'Route Cancelled',\n+          true,\n+          `${basePath}/slow-route`,\n+          { shallow: false },\n+        ],\n+        ['routeChangeStart', `${basePath}/other-page`, { shallow: false }],\n+        ['beforeHistoryChange', `${basePath}/other-page`, { shallow: false }],\n+        ['routeChangeComplete', `${basePath}/other-page`, { shallow: false }],\n+      ])\n+    } finally {\n+      await browser.close()\n+    }\n+  })\n+\n+  it('should use urls with basepath in router events for failed route change', async () => {\n+    const browser = await webdriver(next.url, `${basePath}/hello`)\n+    try {\n+      await check(\n+        () => browser.eval('window.next.router.isReady ? \"ready\" : \"no\"'),\n+        'ready'\n+      )\n+      await browser.eval('window._clearEventLog()')\n+      await browser.elementByCss('#error-route').click()\n+\n+      await retry(async () => {\n+        const eventLog = await browser.eval('window._getEventLog()')\n+        assert.deepEqual(eventLog, [\n+          ['routeChangeStart', `${basePath}/error-route`, { shallow: false }],\n+          [\n+            'routeChangeError',\n+            'Failed to load static props',\n+            null,\n+            `${basePath}/error-route`,\n+            { shallow: false },\n+          ],\n+        ])\n+      })\n+    } finally {\n+      await browser.close()\n+    }\n+  })\n+})"
        },
        {
            "sha": "078ff69d4d97f47595899ae79d13736fa22b35a4",
            "filename": "test/e2e/basepath/trailing-slash.test.ts",
            "status": "renamed",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/vercel/next.js/blob/3f9f403a048f1f3b1419d92f70245d4e8c77ac27/test%2Fe2e%2Fbasepath%2Ftrailing-slash.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/3f9f403a048f1f3b1419d92f70245d4e8c77ac27/test%2Fe2e%2Fbasepath%2Ftrailing-slash.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fbasepath%2Ftrailing-slash.test.ts?ref=3f9f403a048f1f3b1419d92f70245d4e8c77ac27",
            "previous_filename": "test/e2e/basepath/basepath-trailing-slash.test.ts"
        }
    ],
    "stats": {
        "total": 1881,
        "additions": 995,
        "deletions": 886
    }
}