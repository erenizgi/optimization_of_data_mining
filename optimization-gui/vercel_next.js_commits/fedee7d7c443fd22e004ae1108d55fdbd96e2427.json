{
    "author": "icyJoseph",
    "message": "docs: follow up to getting started CC and use-cache API ref (#85582)\n\nExpanding on the Getting started for CC and also extending `use cache`\n\n---------\n\nCo-authored-by: Delba de Oliveira <32464864+delbaoliveira@users.noreply.github.com>",
    "sha": "fedee7d7c443fd22e004ae1108d55fdbd96e2427",
    "files": [
        {
            "sha": "54d13ded1d2062c5e598e25bbd3afe5c1b87351e",
            "filename": "docs/01-app/01-getting-started/06-cache-components.mdx",
            "status": "modified",
            "additions": 361,
            "deletions": 385,
            "changes": 746,
            "blob_url": "https://github.com/vercel/next.js/blob/fedee7d7c443fd22e004ae1108d55fdbd96e2427/docs%2F01-app%2F01-getting-started%2F06-cache-components.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/fedee7d7c443fd22e004ae1108d55fdbd96e2427/docs%2F01-app%2F01-getting-started%2F06-cache-components.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F01-getting-started%2F06-cache-components.mdx?ref=fedee7d7c443fd22e004ae1108d55fdbd96e2427",
            "patch": "@@ -1,7 +1,6 @@\n ---\n title: Cache Components\n description: Learn how to use Cache Components and combine the benefits of static and dynamic rendering.\n-version: beta\n related:\n   title: Next Steps\n   description: Learn more about the config option for Cache Components.\n@@ -14,22 +13,13 @@ related:\n     - app/api-reference/functions/updateTag\n ---\n \n-Cache Components is a new approach to rendering and caching in Next.js that provides fine-grained control over what gets cached and when, while ensuring a great user experience through **Partial Prerendering (PPR)**.\n-\n-## Cache Components\n-\n-When developing dynamic applications, you have to balance two primary approaches:\n-\n-- **Fully static pages** load fast but can't show personalized or real-time data\n-- **Fully dynamic pages** can show fresh data but require rendering everything on each request, leading to slower initial loads\n-\n-With Cache Components enabled, Next.js treats all routes as **dynamic by default**. Every request renders with the latest available data. However, most pages are made up of both static and dynamic parts, and not all dynamic data needs to be resolved from source on every request.\n+> **Good to know:** Cache Components is an opt-in feature. Enable it by setting the `cacheComponents` flag to `true` in your Next config file. See [Enabling Cache Components](#enabling-cache-components) for more details.\n \n-Cache Components allows you to mark data, and even parts of your UI as cacheable, which includes them in the pre-render pass alongside static parts of the page.\n+Cache Components lets you mix static, cached, and dynamic content in a single route, giving you the speed of static sites with the flexibility of dynamic rendering.\n \n-> **Before Cache Components**, Next.js tried to statically optimize **entire** pages automatically, which could lead to unexpected behavior when adding dynamic code.\n+Server-rendered applications typically force a choice between static pages (fast but stale) and dynamic pages (fresh but slow). Moving this work to the client trades server load for larger bundles and slower initial rendering.\n \n-Cache Components implements **Partial Prerendering (PPR)**, and `use cache` to give you the best of both worlds:\n+Cache Components eliminates these tradeoffs by prerendering routes into a **static HTML shell** that's immediately sent to the browser, with dynamic content updating the UI as it becomes ready.\n \n <Image\n   alt=\"Partially re-rendered Product Page showing static nav and product information, and dynamic cart and recommended products\"\n@@ -39,248 +29,356 @@ Cache Components implements **Partial Prerendering (PPR)**, and `use cache` to g\n   height=\"632\"\n />\n \n-When a user visits a route:\n+## How rendering works with Cache Components\n \n-- The server sends a **static shell** containing cached content, ensuring a fast initial load\n-- Dynamic sections wrapped in `Suspense` boundaries display fallback UI in the shell\n-- Only the dynamic parts render to replace their fallbacks, streaming in parallel as they become ready\n-- You can include otherwise-dynamic data in the initial shell by caching it with `use cache`\n+At build time, Next.js renders your route's component tree. As long as components don't access network resources, certain system APIs, or require an incoming request to render, their output is **automatically added to the static shell**. Otherwise, you must choose how to handle them:\n \n-> **ðŸŽ¥ Watch:** Why PPR and how it works â†’ [YouTube (10 minutes)](https://www.youtube.com/watch?v=MTcPrTIBkpA).\n+- Defer rendering to request time by wrapping components in React's [`<Suspense>`](https://react.dev/reference/react/Suspense), [showing fallback UI](#defer-rendering-to-request-time) until the content is ready, or\n+- Cache the result using the [`use cache`](/docs/app/api-reference/directives/use-cache) directive to [include it in the static shell](#using-use-cache) (if no request data is needed)\n \n-## How it works\n+Because this happens ahead of time, before a request arrives, we refer to it as prerendering. This generates a static shell consisting of HTML for initial page loads and a serialized [RSC Payload](/docs/app/getting-started/server-and-client-components#on-the-server) for client-side navigation, ensuring the browser receives fully rendered content instantly whether users navigate directly to the URL or transition from another page.\n \n-> **Good to know:** Cache Components is an opt-in feature. Enable it by setting the `cacheComponents` flag to `true` in your Next config file. See [Enabling Cache Components](#enabling-cache-components) for more details.\n+Next.js requires you to explicitly handle components that can't complete during prerendering. If they aren't wrapped in `<Suspense>` or marked with `use cache`, you'll see an [`Uncached data was accessed outside of <Suspense>`](https://nextjs.org/docs/messages/blocking-route) error during development and build time.\n \n-Cache Components gives you three key tools to control rendering:\n+> **Good to know**: Caching can be applied at the component or function level, while fallback UI can be defined around any subtree, which means you can compose static, cached, and dynamic content within a single route.\n \n-### 1. Suspense for runtime data\n+<Image\n+  alt=\"Diagram showing partially rendered page on the client, with loading UI for chunks that are being streamed.\"\n+  srcLight=\"/docs/light/server-rendering-with-streaming.png\"\n+  srcDark=\"/docs/dark/server-rendering-with-streaming.png\"\n+  width=\"1600\"\n+  height=\"785\"\n+/>\n \n-Some data is only available at runtime when an actual user makes a request. APIs like [`cookies`](/docs/app/api-reference/functions/cookies), [`headers`](/docs/app/api-reference/functions/headers), and [`searchParams`](/docs/app/api-reference/file-conventions/page#searchparams-optional) access request-specific information. Wrap components using these APIs in `Suspense` boundaries so the rest of the page can be pre-rendered as a static shell.\n+This rendering approach is called **Partial Prerendering**, and it's the default behavior with Cache Components. For the rest of this document, we simply refer to it as \"prerendering\" which can produce a partial or complete output.\n \n-**Runtime APIs include:**\n+> **ðŸŽ¥ Watch:** Why Partial Prerendering and how it works â†’ [YouTube (10 minutes)](https://www.youtube.com/watch?v=MTcPrTIBkpA).\n \n-- [`cookies`](/docs/app/api-reference/functions/cookies)\n-- [`headers`](/docs/app/api-reference/functions/headers)\n-- [`searchParams` prop](/docs/app/api-reference/file-conventions/page#searchparams-optional)\n-- [`params` prop](/docs/app/api-reference/file-conventions/page#params-optional) - This is runtime data unless you provide at least one example value through [`generateStaticParams`](/docs/app/api-reference/functions/generate-static-params). When provided, those specific param values are treated as static for prerendered paths, while other values remain runtime\n+## Automatically prerendered content\n \n-### 2. Suspense for dynamic data\n+Operations like synchronous I/O, module imports, and pure computations can complete during prerendering. Components using only these operations have their rendered output included in the static HTML shell.\n \n-Dynamic data like [`fetch`](/docs/app/api-reference/functions/fetch) calls or database queries (`db.query(...)`) can change between requests but isn't user-specific. The [`connection`](/docs/app/api-reference/functions/connection) API is meta-dynamicâ€”it represents waiting for a user navigation even though there's no actual data to return. Wrap components that use these in `Suspense` boundaries to enable streaming.\n+Because all operations in the `Page` component below complete during rendering, its rendered output is automatically included in the static shell. When both the layout and page prerender successfully, the entire route is the static shell.\n \n-**Dynamic data patterns include:**\n+```tsx filename=\"page.tsx\"\n+import fs from 'node:fs'\n \n-- [`fetch`](/docs/app/api-reference/functions/fetch) requests\n-- Database queries\n-- [`connection`](/docs/app/api-reference/functions/connection)\n+export default async function Page() {\n+  // Synchronous file system read\n+  const content = fs.readFileSync('./config.json', 'utf-8')\n \n-### 3. Cached data with `use cache`\n+  // Module imports\n+  const constants = await import('./constants.json')\n \n-Add `use cache` to any Server Component to make it cached and include it in the pre-rendered shell. You cannot use runtime APIs from inside a cached component. You can also mark utility functions as `use cache` and call them from Server Components.\n+  // Pure computations\n+  const processed = JSON.parse(content).items.map((item) => item.value * 2)\n \n-```tsx\n-export async function getProducts() {\n-  'use cache'\n-  const data = await db.query('SELECT * FROM products')\n-  return data\n+  return (\n+    <div>\n+      <h1>{constants.appName}</h1>\n+      <ul>\n+        {processed.map((value, i) => (\n+          <li key={i}>{value}</li>\n+        ))}\n+      </ul>\n+    </div>\n+  )\n }\n ```\n \n-## Using Suspense boundaries\n+> **Good to know**: You can verify that a route was fully prerendered by checking the build output summary. Alternatively see what content was added to the static shell of any page by viewing the page source in your browser.\n+\n+## Defer rendering to request time\n+\n+During prerendering, when Next.js encounters work it can't complete (like network requests, accessing request data, or async operations), it requires you to explicitly handle it. To defer rendering to request time, a parent component must provide fallback UI using a Suspense boundary. The fallback becomes part of the static shell while the actual content resolves at request time.\n+\n+Place Suspense boundaries as close as possible to the components that need them. This maximizes the amount of content in the static shell, since everything outside the boundary can still prerender normally.\n+\n+> **Good to know**: With Suspense boundaries, multiple dynamic sections can render in parallel rather than blocking each other, reducing total load time.\n \n-React [Suspense](https://react.dev/reference/react/Suspense) boundaries let you define what fallback UI to use when it wraps dynamic or runtime data.\n+### Dynamic content\n \n-Content outside the boundary, including the fallback UI, is pre-rendered as a static shell, while content inside the boundary streams in when ready.\n+External systems provide content asynchronously, which often takes an unpredictable time to resolve and may even fail. This is why prerendering doesn't execute them automatically.\n \n-Here's how to use `Suspense` with Cache Components:\n+In general, when you need the latest data from the source on each request (like real-time feeds or personalized content), defer rendering by providing fallback UI with a Suspense boundary.\n \n-```tsx filename=\"app/page.tsx\" switcher\n+For example the `DynamicContent` component below uses multiple operations that are not automatically prerendered.\n+\n+```tsx filename=\"page.tsx\"\n import { Suspense } from 'react'\n+import fs from 'node:fs/promises'\n+import { setTimeout } from 'node:timers/promises'\n \n-export default function Page() {\n+async function DynamicContent() {\n+  // Network request\n+  const data = await fetch('https://api.example.com/data')\n+\n+  // Database query\n+  const users = await db.query('SELECT * FROM users')\n+\n+  // Async file system operation\n+  const file = await fs.readFile('..', 'utf-8')\n+\n+  // Simulating external system delay\n+  await setTimeout(100) // from 'node:timers/promises'\n+\n+  return <div>Not in the static shell</div>\n+}\n+```\n+\n+To use `DynamicContent` within a page, wrap it in `<Suspense>` to define fallback UI:\n+\n+```tsx filename=\"page.tsx\"\n+export default async function Page(props) {\n   return (\n     <>\n-      <h1>This will be pre-rendered</h1>\n-      <Suspense fallback={<Skeleton />}>\n+      <h1>Part of the static shell</h1>\n+      {/* <p>Loading..</p> is part of the static shell */}\n+      <Suspense fallback={<p>Loading..</p>}>\n         <DynamicContent />\n+        <div>Sibling excluded from static shell</div>\n       </Suspense>\n     </>\n   )\n }\n+```\n \n-async function DynamicContent() {\n-  const res = await fetch('http://api.cms.com/posts')\n-  const { posts } = await res.json()\n-  return <div>{/* ... */}</div>\n+Prerendering stops at the `fetch` request. The request itself is not started, and any code after it is not executed.\n+\n+The fallback (`<p>Loading...</p>`) is included in the static shell, while the component's content streams at request time.\n+\n+In this example, since all operations (network request, database query, file read, and timeout) run sequentially within the same component, the content won't appear until they all complete.\n+\n+> **Good to know**: For dynamic content that doesn't change frequently, you can use `use cache` to include the dynamic data in the static shell instead of streaming it. See the [during prerendering](#during-prerendering) section for an example.\n+\n+### Runtime data\n+\n+A specific type of dynamic data that requires request context, only available when a user makes a request.\n+\n+- [`cookies()`](/docs/app/api-reference/functions/cookies) - User's cookie data\n+- [`headers()`](/docs/app/api-reference/functions/headers) - Request headers\n+- [`searchParams`](/docs/app/api-reference/file-conventions/page#searchparams-optional) - URL query parameters\n+- [`params`](/docs/app/api-reference/file-conventions/page#params-optional) - Dynamic route parameters (unless at least one sample is provided via [`generateStaticParams`](/docs/app/api-reference/functions/generate-static-params))\n+\n+```tsx filename=\"page.tsx\"\n+import { cookies, headers } from 'next/headers'\n+import { Suspense } from 'react'\n+\n+async function RuntimeData({ searchParams }) {\n+  // Accessing request data\n+  const cookieStore = await cookies()\n+  const headerStore = await headers()\n+  const search = await searchParams\n+\n+  return <div>Not in the static shell</div>\n }\n ```\n \n-```jsx filename=\"app/page.js\" switcher\n-import { Suspense } from 'react'\n+To use the `RuntimeData` component in, wrap it in a `<Suspense>` boundary:\n \n-export default function Page() {\n+```tsx filename=\"page.tsx\"\n+export default async function Page(props) {\n   return (\n     <>\n-      <h1>This will be pre-rendered</h1>\n-      <Suspense fallback={<Skeleton />}>\n-        <DynamicContent />\n+      <h1>Part of the static shell</h1>\n+      {/* <p>Loading..</p> is part of the static shell */}\n+      <Suspense fallback={<p>Loading..</p>}>\n+        <RuntimeData searchParams={props.searchParams} />\n+        <div>Sibling excluded from static shell</div>\n       </Suspense>\n     </>\n   )\n }\n-\n-async function DynamicContent() {\n-  const res = await fetch('http://api.cms.com/posts')\n-  const { posts } = await res.json()\n-  return <div>{/* ... */}</div>\n-}\n ```\n \n-At build time, Next.js pre-renders the static content and the `fallback` UI, while the dynamic content is postponed until a user requests the route.\n+Use [`connection()`](/docs/app/api-reference/functions/connection) if you need to defer to request time without accessing any of the runtime APIs above.\n \n-> **Good to know**: Wrapping a component in `Suspense` doesn't make it dynamic; your API usage does. `Suspense` acts as a boundary that encapsulates dynamic content and enables streaming.\n+> **Good to know**: Runtime data cannot be cached with `use cache` because it requires request context. Components that access runtime APIs must always be wrapped in `<Suspense>`. However, you can extract values from runtime data and pass them as arguments to cached functions. See the [with runtime data](#with-runtime-data) section for an example.\n \n-### Missing Suspense boundaries\n+### Non-deterministic operations\n \n-Cache Components enforces that dynamic code must be wrapped in a `Suspense` boundary. If you forget, you'll see the [Uncached data was accessed outside of `<Suspense>`](https://nextjs.org/docs/messages/blocking-route) error:\n+Operations like `Math.random()`, `Date.now()`, or `crypto.randomUUID()` produce different values each time they execute. To ensure these run at request time (generating unique values per request), Cache Components requires you to explicitly signal this intent by calling these operations after dynamic or runtime data access.\n \n-> **Uncached data was accessed outside of `<Suspense>`**\n->\n-> This delays the entire page from rendering, resulting in a slow user\n-> experience. Next.js uses this error to ensure your app loads instantly\n-> on every navigation.\n->\n-> To fix this, you can either:\n->\n-> **Wrap the component in a `<Suspense>`** boundary. This allows Next.js to stream its contents to the user as soon as it's ready, without blocking the rest of the app.\n->\n-> or\n->\n-> **Move the asynchronous await into a Cache Component(\"use cache\")**. This allows Next.js to statically prerender the component as part of the HTML document, so it's instantly visible to the user.\n->\n-> Note that request-specific information, such as params, cookies, and headers, is not available during static prerendering, so it must be wrapped in `<Suspense>`.\n+```tsx\n+import { connection } from 'next/server'\n+import { Suspense } from 'react'\n \n-This error helps prevent a situation where, instead of getting a static shell instantly, users would hit a blocking runtime render with nothing to show. To fix it, add a `Suspense` boundary or use `use cache` to cache the work instead.\n+async function UniqueContent() {\n+  // Explicitly defer to request time\n+  await connection()\n \n-### How streaming works\n+  // Non-deterministic operations\n+  const random = Math.random()\n+  const now = Date.now()\n+  const date = new Date()\n+  const uuid = crypto.randomUUID()\n+  const bytes = crypto.getRandomValues(new Uint8Array(16))\n \n-Streaming splits the route into chunks and progressively streams them to the client as they become ready.\n-This allows the user to see parts of the page immediately, before the entire content has finished\n-rendering.\n+  return (\n+    <div>\n+      <p>{random}</p>\n+      <p>{now}</p>\n+      <p>{date.getTime()}</p>\n+      <p>{uuid}</p>\n+      <p>{bytes}</p>\n+    </div>\n+  )\n+}\n+```\n \n-<Image\n-  alt=\"Diagram showing partially rendered page on the client, with loading UI for chunks that are being streamed.\"\n-  srcLight=\"/docs/light/server-rendering-with-streaming.png\"\n-  srcDark=\"/docs/dark/server-rendering-with-streaming.png\"\n-  width=\"1600\"\n-  height=\"785\"\n-/>\n+Because the `UniqueContent` component defers to request time, to use it within a route, it must be wrapped in `<Suspense>`:\n \n-With partial pre-rendering, the initial UI can be sent immediately to the browser while the dynamic parts render. This decreases time to UI and may decrease total request time depending on how much of your UI is pre-rendered.\n+```tsx filename=\"page.tsx\"\n+export default async function Page() {\n+  return (\n+    // <p>Loading..</p> is part of the static shell\n+    <Suspense fallback={<p>Loading..</p>}>\n+      <UniqueContent />\n+    </Suspense>\n+  )\n+}\n+```\n \n-<Image\n-  alt=\"Diagram showing parallelization of route segments during streaming, showing data fetching,rendering, and hydration of individual chunks.\"\n-  srcLight=\"/docs/light/sequential-parallel-data-fetching.png\"\n-  srcDark=\"/docs/dark/sequential-parallel-data-fetching.png\"\n-  width=\"1600\"\n-  height=\"525\"\n-/>\n+Every incoming request would see different random numbers, date, etc.\n \n-To reduce network overhead, the full response, including static HTML and streamed dynamic parts, is sent in a **single HTTP request**. This avoids extra round-trips and improves both initial load and overall performance.\n+> **Good to know**: You can cache non-deterministic operations with `use cache`. See the [with non-deterministic operations](#with-non-deterministic-operations) section for examples.\n \n ## Using `use cache`\n \n-While `Suspense` boundaries manage dynamic content, the [`use cache`](/docs/app/api-reference/directives/use-cache) directive is available for caching data or computations that don't change often.\n+The [`use cache`](/docs/app/api-reference/directives/use-cache) directive caches the return value of async functions and components. You can apply it at the function, component, or file level.\n+\n+Arguments and any closed-over values from parent scopes automatically become part of the [cache key](/docs/app/api-reference/directives/use-cache#cache-keys), which means different inputs produce separate cache entries. This enables personalized or parameterized cached content.\n+\n+When [dynamic content](#dynamic-content) doesn't need to be fetched fresh from the source on every request, caching it lets you include the content in the static shell during prerendering, or reuse the result at runtime across multiple requests.\n+\n+Cached content can be revalidated in two ways: automatically based on the cache lifetime, or on-demand using tags with [`revalidateTag`](/docs/app/api-reference/functions/revalidateTag) or [`updateTag`](/docs/app/api-reference/functions/updateTag).\n \n-### Basic usage\n+> **Good to know**: See [serialization requirements and constraints](/docs/app/api-reference/directives/use-cache#constraints) for details on what can be cached and how arguments work.\n \n-Add `use cache` to cache a page, component, or async function, and define a lifetime with [`cacheLife`](/docs/app/api-reference/functions/cacheLife):\n+### During prerendering\n \n-```tsx filename=\"app/page.tsx\" highlight={1,4,5} switcher\n+While [dynamic content](#dynamic-content) is fetched from external sources, it's often unlikely to change between accesses. Product catalog data updates with inventory changes, blog post content rarely changes after publishing, and analytics reports for past dates remain static.\n+\n+If this data doesn't depend on [runtime data](#runtime-data), you can use the `use cache` directive to include it in the static HTML shell. Use [`cacheLife`](/docs/app/api-reference/functions/cacheLife) to define how long to use the cached data.\n+\n+When revalidation occurs, the static shell is updated with fresh content. See [Tagging and revalidating](#tagging-and-revalidating) for details on on-demand revalidation.\n+\n+```tsx filename=\"app/page.tsx\" highlight={1,4,5}\n import { cacheLife } from 'next/cache'\n \n export default async function Page() {\n   'use cache'\n   cacheLife('hours')\n-  // fetch or compute\n-  return <div>...</div>\n+\n+  const users = await db.query('SELECT * FROM users')\n+\n+  return (\n+    <ul>\n+      {users.map((user) => (\n+        <li key={user.id}>{user.name}</li>\n+      ))}\n+    </ul>\n+  )\n }\n ```\n \n-```jsx filename=\"app/page.js\" highlight={1,4,5} switcher\n+The `cacheLife` function accepts a cache profile name (like `'hours'`, `'days'`, or `'weeks'`) or a custom configuration object to control cache behavior:\n+\n+```tsx filename=\"app/page.tsx\" highlight={1,4-8}\n import { cacheLife } from 'next/cache'\n \n export default async function Page() {\n   'use cache'\n-  cacheLife('hours')\n-  // fetch or compute\n-  return <div>...</div>\n+  cacheLife({\n+    stale: 3600, // 1 hour until considered stale\n+    revalidate: 7200, // 2 hours until revalidated\n+    expire: 86400, // 1 day until expired\n+  })\n+\n+  const users = await db.query('SELECT * FROM users')\n+\n+  return (\n+    <ul>\n+      {users.map((user) => (\n+        <li key={user.id}>{user.name}</li>\n+      ))}\n+    </ul>\n+  )\n }\n ```\n \n-### Caveats\n+See the [`cacheLife` API reference](/docs/app/api-reference/functions/cacheLife) for available profiles and custom configuration options.\n \n-When using `use cache`, keep these constraints in mind:\n+### With runtime data\n \n-#### Arguments must be serializable\n+Runtime data and [`use cache`](/docs/app/api-reference/directives/use-cache) cannot be used in the same scope. However, you can extract values from runtime APIs and pass them as arguments to cached functions.\n \n-Like Server Actions, arguments to cached functions must be serializable. This means you can pass primitives, plain objects, and arrays, but not class instances, functions, or other complex types.\n-\n-#### Accepting unserializable values without introspection\n+```tsx filename=\"app/profile/page.tsx\"\n+import { cookies } from 'next/headers'\n+import { Suspense } from 'react'\n \n-You can accept unserializable values as arguments as long as you don't introspect them. However, you can return them. This allows patterns like cached components that accept Server or Client Components as children:\n+export default function Page() {\n+  // Page itself creates the dynamic boundary\n+  return (\n+    <Suspense fallback={<div>Loading...</div>}>\n+      <ProfileContent />\n+    </Suspense>\n+  )\n+}\n \n-```tsx filename=\"app/cached-wrapper.tsx\" switcher\n-import type { ReactNode } from 'react'\n-import { setTimeout } from 'node:timers/promises'\n+// Component (not cached) reads runtime data\n+async function ProfileContent() {\n+  const session = (await cookies()).get('session')?.value\n \n-async function getSiteTitle() {\n-  // Simulate a slow database or API call\n-  await setTimeout(1000) // from 'node:timers/promises'\n-  return 'My Website'\n+  return <CachedContent sessionId={session} />\n }\n \n-export async function CachedWrapper({ children }: { children: ReactNode }) {\n+// Cached component/function receives data as props\n+async function CachedContent({ sessionId }: { sessionId: string }) {\n   'use cache'\n-  const title = await getSiteTitle()\n-\n-  // Don't introspect children, just pass it through\n-  return (\n-    <div className=\"wrapper\">\n-      <h1>{title}</h1>\n-      {children}\n-    </div>\n-  )\n+  // sessionId becomes part of cache key\n+  const data = await fetchUserData(sessionId)\n+  return <div>{data}</div>\n }\n ```\n \n-```jsx filename=\"app/cached-wrapper.js\" switcher\n-import { setTimeout } from 'node:timers/promises'\n+At request time, `CachedContent` executes if no matching cache entry is found, and stores the result for future requests.\n \n-async function getSiteTitle() {\n-  // Simulate a slow database or API call\n-  await setTimeout(1000) // from 'node:timers/promises'\n-  return 'My Website'\n-}\n+### With non-deterministic operations\n \n-export async function CachedWrapper({ children }) {\n+Within a `use cache` scope, non-deterministic operations execute during prerendering. This is useful when you want the same rendered output served to all users:\n+\n+```tsx\n+export default async function Page() {\n   'use cache'\n-  const title = await getSiteTitle()\n \n-  // Don't introspect children, just pass it through\n+  // Execute once, then cached for all requests\n+  const random = Math.random()\n+  const random2 = Math.random()\n+  const now = Date.now()\n+  const date = new Date()\n+  const uuid = crypto.randomUUID()\n+  const bytes = crypto.getRandomValues(new Uint8Array(16))\n+\n   return (\n-    <div className=\"wrapper\">\n-      <h1>{title}</h1>\n-      {children}\n+    <div>\n+      <p>\n+        {random} and {random2}\n+      </p>\n+      <p>{now}</p>\n+      <p>{date.getTime()}</p>\n+      <p>{uuid}</p>\n+      <p>{bytes}</p>\n     </div>\n   )\n }\n ```\n \n+All requests will be served a route containing same random numbers, timestamp, and UUID until the cache is revalidated.\n+\n ### Tagging and revalidating\n \n-Tag cached data with [`cacheTag`](/docs/app/api-reference/functions/cacheTag) and revalidate it after mutations using [`updateTag`](/docs/app/api-reference/functions/updateTag) in Server Actions for immediate updates, or [`revalidateTag`](/docs/app/api-reference/functions/revalidateTag) delay in updates are acceptable.\n+Tag cached data with [`cacheTag`](/docs/app/api-reference/functions/cacheTag) and revalidate it after mutations using [`updateTag`](/docs/app/api-reference/functions/updateTag) in Server Actions for immediate updates, or [`revalidateTag`](/docs/app/api-reference/functions/revalidateTag) when delays in updates are acceptable.\n \n #### With `updateTag`\n \n@@ -325,6 +423,87 @@ export async function createPost(post: FormData) {\n \n For more detailed explanation and usage examples, see the [`use cache` API reference](/docs/app/api-reference/directives/use-cache).\n \n+### What should I cache?\n+\n+What you cache should be a function of what you want your UI loading states to be. If data doesn't depend on runtime data and you're okay with a cached value being served for multiple requests over a period of time, use `use cache` with `cacheLife` to describe that behavior.\n+\n+For content management systems with update mechanisms, consider using tags with longer cache durations and rely on `revalidateTag` to mark static initial UI as ready for revalidation. This pattern allows you to serve fast, cached responses while still updating content when it actually changes, rather than expiring the cache preemptively.\n+\n+## Putting it all together\n+\n+Here's a complete example showing static content, cached dynamic content, and streaming dynamic content working together on a single page:\n+\n+```tsx filename=\"app/blog/page.tsx\"\n+import { Suspense } from 'react'\n+import { cookies } from 'next/headers'\n+import { cacheLife } from 'next/cache'\n+import Link from 'next/link'\n+\n+export default function BlogPage() {\n+  return (\n+    <>\n+      {/* Static content - prerendered automatically */}\n+      <header>\n+        <h1>Our Blog</h1>\n+        <nav>\n+          <Link href=\"/\">Home</Link> | <Link href=\"/about\">About</Link>\n+        </nav>\n+      </header>\n+\n+      {/* Cached dynamic content - included in the static shell */}\n+      <BlogPosts />\n+\n+      {/* Runtime dynamic content - streams at request time */}\n+      <Suspense fallback={<p>Loading your preferences...</p>}>\n+        <UserPreferences />\n+      </Suspense>\n+    </>\n+  )\n+}\n+\n+// Everyone sees the same blog posts (revalidated every hour)\n+async function BlogPosts() {\n+  'use cache'\n+  cacheLife('hours')\n+\n+  const res = await fetch('https://api.vercel.app/blog')\n+  const posts = await res.json()\n+\n+  return (\n+    <section>\n+      <h2>Latest Posts</h2>\n+      <ul>\n+        {posts.slice(0, 5).map((post: any) => (\n+          <li key={post.id}>\n+            <h3>{post.title}</h3>\n+            <p>\n+              By {post.author} on {post.date}\n+            </p>\n+          </li>\n+        ))}\n+      </ul>\n+    </section>\n+  )\n+}\n+\n+// Personalized per user based on their cookie\n+async function UserPreferences() {\n+  const theme = (await cookies()).get('theme')?.value || 'light'\n+  const favoriteCategory = (await cookies()).get('category')?.value\n+\n+  return (\n+    <aside>\n+      <p>Your theme: {theme}</p>\n+      {favoriteCategory && <p>Favorite category: {favoriteCategory}</p>}\n+    </aside>\n+  )\n+}\n+```\n+\n+During prerendering the header (static) and the blog posts fetched from the API (cached with `use cache`), both become part of the static shell along with the fallback UI for user preferences.\n+\n+When a user visits the page, they instantly see this prerendered shell with the header and blog posts. Only the personalized preferences need to stream in at request time since they depend on the user's cookies. This ensures fast initial page loads while still providing personalized content.\n+\n ## Enabling Cache Components\n \n You can enable Cache Components (which includes PPR) by adding the [`cacheComponents`](/docs/app/api-reference/config/next-config-js/cacheComponents) option to your Next config file:\n@@ -348,7 +527,9 @@ const nextConfig = {\n module.exports = nextConfig\n ```\n \n-### Navigation with Cache Components\n+> **Good to know:** When Cache Components is enabled, `GET` Route Handlers follow the same prerendering model as pages. See [Route Handlers with Cache Components](/docs/app/getting-started/route-handlers#with-cache-components) for details.\n+\n+## Navigation uses Activity\n \n When the [`cacheComponents`](/docs/app/api-reference/config/next-config-js/cacheComponents) flag is enabled, Next.js uses React's [`<Activity>`](https://react.dev/reference/react/Activity) component to preserve component state during client-side navigation.\n \n@@ -360,17 +541,17 @@ Rather than unmounting the previous route when you navigate away, Next.js sets t\n \n This behavior improves the navigation experience by maintaining UI state (form inputs, or expanded sections) when users navigate back and forth between routes.\n \n-> **Good to know**: Next.js uses heuristics to keep a few recently visited routes [`\"hidden\"`](https://react.dev/reference/react/Activity#activity), while older routes are removed from the DOM to prevent excessive growth.\n+> **Good to know**: Next.js uses heuristics to keep a few recently visited routes `\"hidden\"`, while older routes are removed from the DOM to prevent excessive growth.\n \n-### Effect on route segment config\n+## Migrating route segment configs\n \n-When Cache Components is enabled, several route segment config options are no longer needed or supported. Here's what changes and how to migrate:\n+When Cache Components is enabled, several route segment config options are no longer needed or supported:\n \n-#### `dynamic = \"force-dynamic\"`\n+### `dynamic = \"force-dynamic\"`\n \n-**Not needed.** All pages are dynamic by default with Cache Components enabled, so this configuration is unnecessary.\n+**Not needed.** All pages are dynamic by default.\n \n-```tsx\n+```tsx filename=\"app/page.tsx\"\n // Before - No longer needed\n export const dynamic = 'force-dynamic'\n \n@@ -379,20 +560,22 @@ export default function Page() {\n }\n ```\n \n-```tsx\n-// After - Just remove it, pages are dynamic by default\n+```tsx filename=\"app/page.tsx\"\n+// After - Just remove it\n export default function Page() {\n   return <div>...</div>\n }\n ```\n \n-#### `dynamic = \"force-static\"`\n+### `dynamic = \"force-static\"`\n \n-**Replace with `use cache`.** You must add `use cache` to each Layout and Page for the associated route instead.\n+Start by removing it. When unhandled dynamic or runtime data access is detected during development and built time, Next.js raises an error. Otherwise, the [prerendering](#automatically-prerendered-content) step automatically extracts the static HTML shell.\n \n-Note: `force-static` previously allowed the use of runtime APIs like `cookies()`, but this is no longer supported. If you add `use cache` and see an error related to runtime data, you must remove the use of runtime APIs.\n+For dynamic data access, add [`use cache`](#using-use-cache) as close to the data access as possible with a long [`cacheLife`](/docs/app/api-reference/functions/cacheLife) like `'max'` to maintain cached behavior. If needed, add it at the top of the page or layout.\n \n-```tsx\n+For runtime data access (`cookies()`, `headers()`, etc.), errors will direct you to [wrap it with `Suspense`](#runtime-data). Since you started by using `force-static`, you must remove the runtime data access to prevent any request time work.\n+\n+```tsx filename=\"app/page.tsx\"\n // Before\n export const dynamic = 'force-static'\n \n@@ -402,16 +585,19 @@ export default async function Page() {\n }\n ```\n \n-```tsx\n+```tsx filename=\"app/page.tsx\"\n+import { cacheLife } from 'next/cache'\n+\n // After - Use 'use cache' instead\n export default async function Page() {\n   'use cache'\n+  cacheLife('max')\n   const data = await fetch('https://api.example.com/data')\n   return <div>...</div>\n }\n ```\n \n-#### `revalidate`\n+### `revalidate`\n \n **Replace with `cacheLife`.** Use the `cacheLife` function to define cache duration instead of the route segment config.\n \n@@ -424,7 +610,7 @@ export default async function Page() {\n }\n ```\n \n-```tsx\n+```tsx filename=\"app/page.tsx\"\n // After - Use cacheLife\n import { cacheLife } from 'next/cache'\n \n@@ -435,16 +621,16 @@ export default async function Page() {\n }\n ```\n \n-#### `fetchCache`\n+### `fetchCache`\n \n **Not needed.** With `use cache`, all data fetching within a cached scope is automatically cached, making `fetchCache` unnecessary.\n \n-```tsx\n+```tsx filename=\"app/page.tsx\"\n // Before\n export const fetchCache = 'force-cache'\n ```\n \n-```tsx\n+```tsx filename=\"app/page.tsx\"\n // After - Use 'use cache' to control caching behavior\n export default async function Page() {\n   'use cache'\n@@ -453,216 +639,6 @@ export default async function Page() {\n }\n ```\n \n-#### `runtime = 'edge'`\n+### `runtime = 'edge'`\n \n **Not supported.** Cache Components requires Node.js runtime and will throw errors with [Edge Runtime](/docs/app/api-reference/edge).\n-\n-## Before vs. after Cache Components\n-\n-Understanding how Cache Components changes your mental model:\n-\n-### Before Cache Components\n-\n-- **Static by default**: Next.js tried to pre-render and cache as much as possible for you unless you opted out\n-- **Route-level controls**: Switches like `dynamic`, `revalidate`, `fetchCache` controlled caching for the whole page\n-- **Limits of `fetch`**: Using `fetch` alone was incomplete, as it didn't cover direct database clients or other server-side IO. A nested `fetch` switching to dynamic (e.g., `{ cache: 'no-store' }`) could unintentionally change the entire route behavior\n-\n-### With Cache Components\n-\n-- **Dynamic by default**: Everything is dynamic by default. You decide which parts to cache by adding [`use cache`](/docs/app/api-reference/directives/use-cache) where it helps\n-- **Fine-grained control**: File/component/function-level [`use cache`](/docs/app/api-reference/directives/use-cache) and [`cacheLife`](/docs/app/api-reference/functions/cacheLife) control caching exactly where you need it\n-- **Streaming stays**: Use `<Suspense>` or a `loading.(js|tsx)` file to stream dynamic parts while the shell shows immediately\n-- **Beyond `fetch`**: Using the `use cache` directive caching can be applied to all server IO (database calls, APIs, computations), not just `fetch`. Nested `fetch` calls won't silently flip an entire route because behavior is governed by explicit cache boundaries and `Suspense`\n-\n-## Examples\n-\n-### Dynamic APIs\n-\n-When accessing runtime APIs like `cookies()`, Next.js will only pre-render the fallback UI above this component.\n-\n-In this example, we have no fallback defined, so Next.js shows an error instructing us to provide one. The `<User />` component needs to be wrapped in `Suspense` because it uses the `cookies` API:\n-\n-```jsx filename=\"app/user.js\" switcher\n-import { cookies } from 'next/headers'\n-\n-export async function User() {\n-  const session = (await cookies()).get('session')?.value\n-  return '...'\n-}\n-```\n-\n-```tsx filename=\"app/user.tsx\" switcher\n-import { cookies } from 'next/headers'\n-\n-export async function User() {\n-  const session = (await cookies()).get('session')?.value\n-  return '...'\n-}\n-```\n-\n-Now we have a `Suspense` boundary around our User component we can pre-render the Page with a Skeleton UI and stream in the `<User />` UI when a specific user makes a request\n-\n-```tsx filename=\"app/page.tsx\" switcher\n-import { Suspense } from 'react'\n-import { User, AvatarSkeleton } from './user'\n-\n-export default function Page() {\n-  return (\n-    <section>\n-      <h1>This will be pre-rendered</h1>\n-      <Suspense fallback={<AvatarSkeleton />}>\n-        <User />\n-      </Suspense>\n-    </section>\n-  )\n-}\n-```\n-\n-```jsx filename=\"app/page.js\" switcher\n-import { Suspense } from 'react'\n-import { User, AvatarSkeleton } from './user'\n-\n-export default function Page() {\n-  return (\n-    <section>\n-      <h1>This will be pre-rendered</h1>\n-      <Suspense fallback={<AvatarSkeleton />}>\n-        <User />\n-      </Suspense>\n-    </section>\n-  )\n-}\n-```\n-\n-### Passing dynamic props\n-\n-Components that access runtime values like `cookies` or `searchParams` cannot be prerendered. To prerender more of a page's content, you can pass these props down and access their values lower in the tree. For example, if you are reading `searchParams` from a `<Page />` component, you can forward this value to another component as a prop:\n-\n-```tsx filename=\"app/page.tsx\" switcher\n-import { Table, TableSkeleton } from './table'\n-import { Suspense } from 'react'\n-\n-export default function Page({\n-  searchParams,\n-}: {\n-  searchParams: Promise<{ sort: string }>\n-}) {\n-  return (\n-    <section>\n-      <h1>This will be pre-rendered</h1>\n-      <Suspense fallback={<TableSkeleton />}>\n-        <Table searchParams={searchParams.then((search) => search.sort)} />\n-      </Suspense>\n-    </section>\n-  )\n-}\n-```\n-\n-```jsx filename=\"app/page.js\" switcher\n-import { Table, TableSkeleton } from './table'\n-import { Suspense } from 'react'\n-\n-export default function Page({ searchParams }) {\n-  return (\n-    <section>\n-      <h1>This will be pre-rendered</h1>\n-      <Suspense fallback={<TableSkeleton />}>\n-        <Table searchParams={searchParams.then((search) => search.sort)} />\n-      </Suspense>\n-    </section>\n-  )\n-}\n-```\n-\n-Inside of the table component, accessing the value from `searchParams` will make the component dynamic while the rest of the page will be pre-rendered.\n-\n-```tsx filename=\"app/table.tsx\" switcher\n-export async function Table({ sortPromise }: { sortPromise: Promise<string> }) {\n-  const sort = (await sortPromise) === 'true'\n-  return '...'\n-}\n-```\n-\n-```jsx filename=\"app/table.js\" switcher\n-export async function Table({ sortPromise }) {\n-  const sort = (await sortPromise) === 'true'\n-  return '...'\n-}\n-```\n-\n-## Route Handlers with Cache Components\n-\n-`GET` Route Handlers follow the same model as normal UI routes in your application. They are dynamic by default, can be pre-rendered when deterministic, and you can `use cache` to include more dynamic data in the cached response.\n-\n-Dynamic example, returns a different number for every request:\n-\n-```tsx filename=\"app/api/random-number/route.ts\"\n-export async function GET() {\n-  return Response.json({\n-    randomNumber: Math.random(),\n-  })\n-}\n-```\n-\n-A handler that returns only static data will be pre-rendered at build time:\n-\n-```tsx filename=\"app/api/project-info/route.ts\"\n-export async function GET() {\n-  return Response.json({\n-    projectName: 'Next.js',\n-  })\n-}\n-```\n-\n-If you had a route that returned fresh dynamic data on every request, say products from a database:\n-\n-```tsx filename=\"app/api/products/route.ts\"\n-export async function GET() {\n-  const products = await db.query('SELECT * FROM products')\n-\n-  return Response.json(products)\n-}\n-```\n-\n-To cache this and avoid hitting the database on every request, extract the dynamic work into a `use cache` function and set `cacheLife('hours')` so the database is queried at most once per hour:\n-\n-```tsx filename=\"app/api/products/route.ts\"\n-import { cacheLife } from 'next/cache'\n-\n-export async function GET() {\n-  const products = await getProducts()\n-\n-  return Response.json(products)\n-}\n-\n-async function getProducts() {\n-  'use cache'\n-  cacheLife('hours')\n-\n-  return await db.query('SELECT * FROM products')\n-}\n-```\n-\n-> **Good to know**\n->\n-> - `use cache` cannot be used directly inside a Route Handler body; extract to a helper.\n-> - Cached responses revalidate according to `cacheLife` when a new request arrives.\n-> - Using runtime APIs like [`cookies()`](/docs/app/api-reference/functions/cookies) or [`headers()`](/docs/app/api-reference/functions/headers), or calling [`connection()`](/docs/app/api-reference/functions/connection), always defers to request time (no pre-rendering).\n-\n-## Frequently Asked Questions\n-\n-### Does this replace Partial Prerendering (PPR)?\n-\n-No. Cache Components **implements** PPR as a feature. The old experimental PPR flag has been removed but PPR is here to stay.\n-\n-PPR provides the static shell and streaming infrastructure; `use cache` lets you include optimized dynamic output in that shell when beneficial.\n-\n-### What should I cache first?\n-\n-What you cache should be a function of what you want your UI loading states to be. If data doesn't depend on runtime data and you're okay with a cached value being served for multiple requests over a period of time, use `use cache` with `cacheLife` to describe that behavior.\n-\n-For content management systems with update mechanisms, consider using tags with longer cache durations and rely on `revalidateTag` to mark static initial UI as ready for revalidation. This pattern allows you to serve fast, cached responses while still updating content when it actually changes, rather than expiring the cache preemptively.\n-\n-### How do I update cached content quickly?\n-\n-Use [`cacheTag`](/docs/app/api-reference/functions/cacheTag) to tag your cached data, then trigger [`updateTag`](/docs/app/api-reference/functions/updateTag) or [`revalidateTag`](/docs/app/api-reference/functions/revalidateTag)."
        },
        {
            "sha": "392091db5d46a3eeae71860f2c72a819b9cedbc3",
            "filename": "docs/01-app/01-getting-started/15-route-handlers.mdx",
            "status": "modified",
            "additions": 40,
            "deletions": 21,
            "changes": 61,
            "blob_url": "https://github.com/vercel/next.js/blob/fedee7d7c443fd22e004ae1108d55fdbd96e2427/docs%2F01-app%2F01-getting-started%2F15-route-handlers.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/fedee7d7c443fd22e004ae1108d55fdbd96e2427/docs%2F01-app%2F01-getting-started%2F15-route-handlers.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F01-getting-started%2F15-route-handlers.mdx?ref=fedee7d7c443fd22e004ae1108d55fdbd96e2427",
            "patch": "@@ -86,43 +86,62 @@ export async function GET() {\n \n #### With Cache Components\n \n-When using [Cache Components](/docs/app/getting-started/cache-components), you can use the [`use cache`](/docs/app/api-reference/directives/use-cache) directive to cache data fetching within your Route Handlers. Route Handlers are dynamic by default, but can be pre-rendered at build time if they don't use runtime or dynamic data.\n+When [Cache Components](/docs/app/getting-started/cache-components) is enabled, `GET` Route Handlers follow the same model as normal UI routes in your application. They run at request time by default, can be prerendered when they don't access dynamic or runtime data, and you can use `use cache` to include dynamic data in the static response.\n \n-```ts filename=\"app/api/posts/route.ts\" switcher\n-import { cacheTag } from 'next/cache'\n+**Static example** - doesn't access dynamic or runtime data, so it will be prerendered at build time:\n \n-async function getPosts() {\n-  'use cache'\n-  cacheTag('posts')\n-\n-  const posts = await fetchPosts()\n-  return posts\n+```tsx filename=\"app/api/project-info/route.ts\"\n+export async function GET() {\n+  return Response.json({\n+    projectName: 'Next.js',\n+  })\n }\n+```\n \n+**Dynamic example** - accesses non-deterministic operations. During the build, prerendering stops when `Math.random()` is called, deferring to request-time rendering:\n+\n+```tsx filename=\"app/api/random-number/route.ts\"\n export async function GET() {\n-  const posts = await getPosts()\n-  return Response.json(posts)\n+  return Response.json({\n+    randomNumber: Math.random(),\n+  })\n }\n ```\n \n-```js filename=\"app/api/posts/route.js\" switcher\n-import { cacheTag } from 'next/cache'\n+**Runtime data example** - accesses request-specific data. Prerendering terminates when runtime APIs like `headers()` are called:\n \n-async function getPosts() {\n-  'use cache'\n-  cacheTag('posts')\n+```tsx filename=\"app/api/user-agent/route.ts\"\n+import { headers } from 'next/headers'\n+\n+export async function GET() {\n+  const headersList = await headers()\n+  const userAgent = headersList.get('user-agent')\n \n-  const posts = await fetchPosts()\n-  return posts\n+  return Response.json({ userAgent })\n }\n+```\n+\n+> **Good to know**: Prerendering stops if the `GET` handler accesses network requests, database queries, async file system operations, request object properties (like `req.url`, `request.headers`, `request.cookies`, `request.body`), runtime APIs like [`cookies()`](/docs/app/api-reference/functions/cookies), [`headers()`](/docs/app/api-reference/functions/headers), [`connection()`](/docs/app/api-reference/functions/connection), or non-deterministic operations.\n+\n+**Cached example** - accesses dynamic data (database query) but caches it with `use cache`, allowing it to be included in the prerendered response:\n+\n+```tsx filename=\"app/api/products/route.ts\"\n+import { cacheLife } from 'next/cache'\n \n export async function GET() {\n-  const posts = await getPosts()\n-  return Response.json(posts)\n+  const products = await getProducts()\n+  return Response.json(products)\n+}\n+\n+async function getProducts() {\n+  'use cache'\n+  cacheLife('hours')\n+\n+  return await db.query('SELECT * FROM products')\n }\n ```\n \n-See the [Cache Components documentation](/docs/app/getting-started/cache-components#route-handlers-with-cache-components) for more details on caching strategies and revalidation.\n+> **Good to know**: `use cache` cannot be used directly inside a Route Handler body; extract it to a helper function. Cached responses revalidate according to `cacheLife` when a new request arrives.\n \n ### Special Route Handlers\n "
        },
        {
            "sha": "bf2cd1ad92c334b2c8ff661a0da5620e83d231bb",
            "filename": "docs/01-app/03-api-reference/01-directives/use-cache.mdx",
            "status": "modified",
            "additions": 253,
            "deletions": 33,
            "changes": 286,
            "blob_url": "https://github.com/vercel/next.js/blob/fedee7d7c443fd22e004ae1108d55fdbd96e2427/docs%2F01-app%2F03-api-reference%2F01-directives%2Fuse-cache.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/fedee7d7c443fd22e004ae1108d55fdbd96e2427/docs%2F01-app%2F03-api-reference%2F01-directives%2Fuse-cache.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-api-reference%2F01-directives%2Fuse-cache.mdx?ref=fedee7d7c443fd22e004ae1108d55fdbd96e2427",
            "patch": "@@ -16,7 +16,11 @@ related:\n \n The `use cache` directive allows you to mark a route, React component, or a function as cacheable. It can be used at the top of a file to indicate that all exports in the file should be cached, or inline at the top of function or component to cache the return value.\n \n-> **Good to know:** For caching user-specific content that requires access to cookies or headers, see [`'use cache: private'`](/docs/app/api-reference/directives/use-cache-private).\n+> **Good to know:**\n+>\n+> - To use cookies or headers, read them outside cached scopes and pass values as arguments. This is the preferred pattern.\n+> - If the in-memory cache isn't sufficient for runtime data, [`'use cache: remote'`](/docs/app/api-reference/directives/use-cache-remote) allows platforms to provide a dedicated cache handler, though it may come with its own costs.\n+> - For compliance requirements where data must never be cached on the server, or when a deeply nested component needs to access runtime APIs and restructuring would be disruptive, see [`'use cache: private'`](/docs/app/api-reference/directives/use-cache-private).\n \n ## Usage\n \n@@ -65,68 +69,207 @@ export async function getData() {\n }\n ```\n \n+> **Good to know**: When used at file level, all function exports must be async functions.\n+\n ## How `use cache` works\n \n ### Cache keys\n \n A cache entry's key is generated using a serialized version of its inputs, which includes:\n \n-- Build ID (generated for each build)\n-- Function ID (a secure identifier unique to the function)\n-- The [serializable](https://react.dev/reference/rsc/use-server#serializable-parameters-and-return-values) function arguments (or props).\n+1. **Build ID** - Unique per build, changing this invalidates all cache entries\n+2. **Function ID** - A secure hash of the function's location and signature in the codebase\n+3. **Serializable arguments** - Props (for components) or function arguments\n+4. **HMR refresh hash** (development only) - Invalidates cache on hot module replacement\n+\n+When a cached function references variables from outer scopes, those variables are automatically captured and bound as arguments, making them part of the cache key.\n+\n+```tsx filename=\"lib/data.ts\"\n+async function Component({ userId }: { userId: string }) {\n+  const getData = async (filter: string) => {\n+    'use cache'\n+    // Cache key includes both userId (from closure) and filter (argument)\n+    return fetch(`/api/users/${userId}/data?filter=${filter}`)\n+  }\n+\n+  return getData('active')\n+}\n+```\n+\n+In the snippet above, `userId` is captured from the outer scope and `filter` is passed as an argument, so both become part of the `getData` function's cache key. This means different user and filter combinations will have separate cache entries.\n+\n+## Serialization\n+\n+Arguments to cached functions and their return values must be serializable.\n+\n+For a complete reference, see:\n+\n+- [Serializable arguments](https://react.dev/reference/rsc/use-server#serializable-parameters-and-return-values) - Uses **React Server Components** serialization\n+- [Serializable return types](https://react.dev/reference/rsc/use-client#serializable-types) - Uses **React Client Components** serialization\n \n-The arguments passed to the cached function, as well as any values it reads from the parent scope automatically become a part of the key. This means, the same cache entry will be reused as long as its inputs are the same.\n+> **Good to know:** Arguments and return values use different serialization systems. Server Component serialization (for arguments) is more restrictive than Client Component serialization (for return values). This means you can return JSX elements but cannot accept them as arguments unless using pass-through patterns.\n \n-## Non-serializable arguments\n+### Supported types\n \n-Any non-serializable arguments, props, or closed-over values will turn into references inside the cached function, and can be only passed through and not inspected nor modified. These non-serializable values will be filled in at the request time and won't become a part of the cache key.\n+**Arguments:**\n \n-For example, a cached function can take in JSX as a `children` prop and return `<div>{children}</div>`, but it won't be able to introspect the actual `children` object. This allows you to nest uncached content inside a cached component.\n+- Primitives: `string`, `number`, `boolean`, `null`, `undefined`\n+- Plain objects: `{ key: value }`\n+- Arrays: `[1, 2, 3]`\n+- Dates, Maps, Sets, TypedArrays, ArrayBuffers\n+- React elements (as pass-through only)\n \n-```tsx filename=\"app/ui/cached-component.tsx\" switcher\n-async function CachedComponent({ children }: { children: ReactNode }) {\n+**Return values:**\n+\n+- Same as arguments, plus JSX elements\n+\n+### Unsupported types\n+\n+- Class instances\n+- Functions (except as pass-through)\n+- Symbols, WeakMaps, WeakSets\n+- URL instances\n+\n+```tsx filename=\"app/components/user-card.tsx\"\n+// Valid - primitives and plain objects\n+async function UserCard({\n+  id,\n+  config,\n+}: {\n+  id: string\n+  config: { theme: string }\n+}) {\n   'use cache'\n-  return <div>{children}</div>\n+  return <div>{id}</div>\n+}\n+\n+// Invalid - class instance\n+async function UserProfile({ user }: { user: UserClass }) {\n+  'use cache'\n+  // Error: Cannot serialize class instance\n+  return <div>{user.name}</div>\n }\n ```\n \n-```jsx filename=\"app/ui/cached-component.js\" switcher\n-async function CachedComponent({ children }) {\n+### Pass-through (non-serializable arguments)\n+\n+You can accept non-serializable values **as long as you don't introspect them**. This enables composition patterns with `children` and Server Actions:\n+\n+```tsx filename=\"app/components/cached-wrapper.tsx\"\n+async function CachedWrapper({ children }: { children: ReactNode }) {\n   'use cache'\n-  return <div>{children}</div>\n+  // Don't read or modify children - just pass it through\n+  return (\n+    <div className=\"wrapper\">\n+      <header>Cached Header</header>\n+      {children}\n+    </div>\n+  )\n+}\n+\n+// Usage: children can be dynamic\n+export default function Page() {\n+  return (\n+    <CachedWrapper>\n+      <DynamicComponent /> {/* Not cached, passed through */}\n+    </CachedWrapper>\n+  )\n+}\n+```\n+\n+You can also pass Server Actions through cached components:\n+\n+```tsx filename=\"app/components/cached-form.tsx\"\n+async function CachedForm({ action }: { action: () => Promise<void> }) {\n+  'use cache'\n+  // Don't call action here - just pass it through\n+  return <form action={action}>{/* ... */}</form>\n }\n ```\n \n-## Return values\n+## Constraints\n+\n+Cached functions and components **cannot** directly access runtime APIs like `cookies()`, `headers()`, or `searchParams`. Instead, read these values outside the cached scope and pass them as arguments.\n \n-The return value of the cacheable function must be serializable props. This ensures that the cached data can be stored and retrieved correctly.\n+### Runtime caching considerations\n \n-> **Good to know:** The supported types for arguments and the supported types for returned values are **not the same**. For more details, refer to [Serializable Parameters and Return Values](https://react.dev/reference/rsc/use-server#serializable-parameters-and-return-values) for function arguments and [Serializable Types](https://react.dev/reference/rsc/use-client#serializable-types) for return values.\n+While `use cache` is designed primarily to include dynamic data in the static shell, it can also cache data at runtime using in-memory LRU (Least Recently Used) storage.\n \n-## `use cache` at build time\n+Runtime cache behavior depends on your hosting environment:\n \n-When used at the top of a [layout](/docs/app/api-reference/file-conventions/layout) or [page](/docs/app/api-reference/file-conventions/page), the route segment will be prerendered, allowing it to later be [revalidated](#during-revalidation).\n+| Environment     | Runtime Caching Behavior                                                                                                                                          |\n+| --------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n+| **Serverless**  | Cache entries may not persist across requests (each request can be a different instance). Build-time caching works normally.                                      |\n+| **Self-hosted** | Cache entries persist across requests. Control cache size with [`cacheMaxMemorySize`](/docs/app/api-reference/config/next-config-js/incrementalCacheHandlerPath). |\n \n-This means `use cache` cannot be used with [runtime data](/docs/app/getting-started/cache-components#1-suspense-for-runtime-data) like `cookies` or `headers`.\n+If the default in-memory cache isn't enough, consider **[`use cache: remote`](/docs/app/api-reference/directives/use-cache-remote)** which allows platforms to provide a dedicated cache handler (like Redis or KV database). This helps reduce hits against data sources not scaled to your total traffic, though it comes with costs (storage, network latency, platform fees).\n \n-> **Note:** If you need to cache content that depends on cookies, headers, or search params, use [`'use cache: private'`](/docs/app/api-reference/directives/use-cache-private) instead.\n+Very rarely, for compliance requirements where certain data must never be cached on the server (even ephemerally), or when a component within a `use cache` scope needs to access runtime APIs like `cookies()` and restructuring the component tree is impractical, you might need **[`use cache: private`](/docs/app/api-reference/directives/use-cache-private)**.\n \n ## `use cache` at runtime\n \n-On the **server**, the cache entries of individual components or functions will be cached in-memory by default. You can customize the cache storage by configuring [`cacheHandlers`](/docs/app/api-reference/config/next-config-js/cacheHandlers) in your `next.config.js` file.\n+On the **server**, cache entries are stored in-memory and respect the `revalidate` and `expire` times from your `cacheLife` configuration. You can customize the cache storage by configuring [`cacheHandlers`](/docs/app/api-reference/config/next-config-js/cacheHandlers) in your `next.config.js` file.\n+\n+On the **client**, content from the server cache is stored in the browser's memory for the duration defined by the `stale` time. The client router enforces a **minimum 30-second stale time**, regardless of configuration.\n+\n+The `x-nextjs-stale-time` response header communicates cache lifetime from server to client, ensuring coordinated behavior.\n+\n+## Revalidation\n+\n+By default, `use cache` uses the `default` profile with these settings:\n+\n+- **stale**: 5 minutes (client-side)\n+- **revalidate**: 15 minutes (server-side)\n+- **expire**: Never expires by time\n+\n+```tsx filename=\"lib/data.ts\"\n+async function getData() {\n+  'use cache'\n+  // Implicitly uses default profile\n+  return fetch('/api/data')\n+}\n+```\n+\n+### Customizing cache lifetime\n \n-Then, on the **client**, any content returned from the server cache will be stored in the browser's memory for the duration of the session or until [revalidated](#during-revalidation).\n+Use the [`cacheLife`](/docs/app/api-reference/functions/cacheLife) function to customize cache duration:\n \n-## During revalidation\n+```tsx filename=\"lib/data.ts\"\n+import { cacheLife } from 'next/cache'\n \n-By default, `use cache` has server-side revalidation period of **15 minutes**. While this period may be useful for content that doesn't require frequent updates, you can use the `cacheLife` and `cacheTag` APIs to configure when the individual cache entries should be revalidated.\n+async function getData() {\n+  'use cache'\n+  cacheLife('hours') // Use built-in 'hours' profile\n+  return fetch('/api/data')\n+}\n+```\n \n-- [`cacheLife`](/docs/app/api-reference/functions/cacheLife): Configure the cache entry lifetime.\n-- [`cacheTag`](/docs/app/api-reference/functions/cacheTag): Create tags for on-demand revalidation.\n+### On-demand revalidation\n \n-Both of these APIs integrate across the client and server caching layers, meaning you can configure your caching semantics in one place and have them apply everywhere.\n+Use [`cacheTag`](/docs/app/api-reference/functions/cacheTag), [`updateTag`](/docs/app/api-reference/functions/updateTag), or [`revalidateTag`](/docs/app/api-reference/functions/revalidateTag) for on-demand cache invalidation:\n \n-See the [`cacheLife`](/docs/app/api-reference/functions/cacheLife) and [`cacheTag`](/docs/app/api-reference/functions/cacheTag) API docs for more information.\n+```tsx filename=\"lib/data.ts\"\n+import { cacheTag } from 'next/cache'\n+\n+async function getProducts() {\n+  'use cache'\n+  cacheTag('products')\n+  return fetch('/api/products')\n+}\n+```\n+\n+```tsx filename=\"app/actions.ts\"\n+'use server'\n+\n+import { updateTag } from 'next/cache'\n+\n+export async function updateProduct() {\n+  await db.products.update(...)\n+  updateTag('products') // Invalidates all 'products' caches\n+}\n+```\n+\n+Both `cacheLife` and `cacheTag` integrate across client and server caching layers, meaning you configure your caching semantics in one place and they apply everywhere.\n \n ## Examples\n \n@@ -142,7 +285,7 @@ export default async function Layout({ children }: { children: ReactNode }) {\n }\n ```\n \n-```jsx filename=\"app/page.tsx\" switcher\n+```jsx filename=\"app/layout.js\" switcher\n 'use cache'\n \n export default async function Layout({ children }) {\n@@ -189,7 +332,6 @@ export default async function Page() {\n > **Good to know**:\n >\n > - If `use cache` is added only to the `layout` or the `page`, only that route segment and any components imported into it will be cached.\n-> - If any of the nested children in the route use [Dynamic APIs](/docs/app/guides/caching#dynamic-rendering), then the route will opt out of pre-rendering.\n \n ### Caching a component's output with `use cache`\n \n@@ -320,7 +462,7 @@ export default async function Page() {\n     await db.update(...)\n   }\n \n-  return <CacheComponent performUpdate={performUpdate} />\n+  return <CachedComponent performUpdate={performUpdate} />\n }\n \n async function CachedComponent({\n@@ -344,7 +486,7 @@ export default async function Page() {\n     await db.update(...)\n   }\n \n-  return <CacheComponent performUpdate={performUpdate} />\n+  return <CachedComponent performUpdate={performUpdate} />\n }\n \n async function CachedComponent({ performUpdate }) {\n@@ -374,6 +516,84 @@ export default function ClientComponent({ action }) {\n }\n ```\n \n+## Troubleshooting\n+\n+### Build Hangs (Cache Timeout)\n+\n+If your build hangs, you're accessing Promises that resolve to dynamic or runtime data, created outside a `use cache` boundary. The cached function waits for data that can't resolve during the build, causing a timeout after 50 seconds.\n+\n+When the build timeouts you'll see this error message:\n+\n+> Error: Filling a cache during prerender timed out, likely because request-specific arguments such as params, searchParams, cookies() or dynamic data were used inside \"use cache\".\n+\n+Common ways this happens: passing such Promises as props, accessing them via closure, or retrieving them from shared storage (Maps).\n+\n+> **Good to know:** Directly calling `cookies()` or `headers()` inside `use cache` fails immediately with a [different error](/docs/messages/next-request-in-use-cache), not a timeout.\n+\n+**Passing runtime data Promises as props:**\n+\n+```tsx filename=\"app/page.tsx\"\n+import { cookies } from 'next/headers'\n+import { Suspense } from 'react'\n+\n+export default function Page() {\n+  return (\n+    <Suspense fallback={<div>Loading...</div>}>\n+      <Dynamic />\n+    </Suspense>\n+  )\n+}\n+\n+async function Dynamic() {\n+  const cookieStore = cookies()\n+  return <Cached promise={cookieStore} /> // Build hangs\n+}\n+\n+async function Cached({ promise }: { promise: Promise<unknown> }) {\n+  'use cache'\n+  const data = await promise // Waits for runtime data during build\n+  return <p>..</p>\n+}\n+```\n+\n+Await the `cookies` store in the `Dynamic` component, and pass a cookie value to the `Cached` component.\n+\n+**Shared deduplication storage:**\n+\n+```tsx filename=\"app/page.tsx\"\n+// Problem: Map stores dynamic Promises, accessed by cached code\n+import { Suspense } from 'react'\n+\n+const cache = new Map<string, Promise<string>>()\n+\n+export default function Page() {\n+  return (\n+    <>\n+      <Suspense fallback={<div>Loading...</div>}>\n+        <Dynamic id=\"data\" />\n+      </Suspense>\n+      <Cached id=\"data\" />\n+    </>\n+  )\n+}\n+\n+async function Dynamic({ id }: { id: string }) {\n+  // Stores dynamic Promise in shared Map\n+  cache.set(\n+    id,\n+    fetch(`https://api.example.com/${id}`).then((r) => r.text())\n+  )\n+  return <p>Dynamic</p>\n+}\n+\n+async function Cached({ id }: { id: string }) {\n+  'use cache'\n+  return <p>{await cache.get(id)}</p> // Build hangs - retrieves dynamic Promise\n+}\n+```\n+\n+Use Next.js's built-in `fetch()` deduplication or use separate Maps for cached and uncached contexts.\n+\n ## Platform Support\n \n | Deployment Option                                                   | Supported         |"
        }
    ],
    "stats": {
        "total": 1093,
        "additions": 654,
        "deletions": 439
    }
}