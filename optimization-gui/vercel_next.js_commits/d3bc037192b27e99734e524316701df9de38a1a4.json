{
    "author": "mischnic",
    "message": "Turbopack: don't match dynamic pattern for node_modules packages (#83176)\n\nThis code would previously pull in every single package in node_modules\n\n```\nvar path = require(\"path\");\n\nvar dir = foo;\nif (bar) {\n  dir = process.cwd();\n}\npath.join(dir, \"node_modules\");\n```\n\nNow, `node_modules/<dynamic>` doesn't match every single package anymore. It effectively thinks that `node_modules` is an empty folder when enumerating it.",
    "sha": "d3bc037192b27e99734e524316701df9de38a1a4",
    "files": [
        {
            "sha": "4e5a34d58915bafb949733d84d8000fc83877856",
            "filename": "turbopack/crates/turbopack-core/src/resolve/pattern.rs",
            "status": "modified",
            "additions": 188,
            "deletions": 27,
            "changes": 215,
            "blob_url": "https://github.com/vercel/next.js/blob/d3bc037192b27e99734e524316701df9de38a1a4/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fpattern.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d3bc037192b27e99734e524316701df9de38a1a4/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fpattern.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fpattern.rs?ref=d3bc037192b27e99734e524316701df9de38a1a4",
            "patch": "@@ -812,70 +812,89 @@ impl Pattern {\n \n     pub fn is_match(&self, value: &str) -> bool {\n         if let Pattern::Alternatives(list) = self {\n-            list.iter()\n-                .any(|alt| alt.match_internal(value, None, false).is_match())\n+            list.iter().any(|alt| {\n+                alt.match_internal(value, None, InNodeModules::False, false)\n+                    .is_match()\n+            })\n         } else {\n-            self.match_internal(value, None, false).is_match()\n+            self.match_internal(value, None, InNodeModules::False, false)\n+                .is_match()\n         }\n     }\n \n     /// Like [`Pattern::is_match`], but does not consider any dynamic\n     /// pattern matching\n     pub fn is_match_ignore_dynamic(&self, value: &str) -> bool {\n         if let Pattern::Alternatives(list) = self {\n-            list.iter()\n-                .any(|alt| alt.match_internal(value, None, true).is_match())\n+            list.iter().any(|alt| {\n+                alt.match_internal(value, None, InNodeModules::False, true)\n+                    .is_match()\n+            })\n         } else {\n-            self.match_internal(value, None, true).is_match()\n+            self.match_internal(value, None, InNodeModules::False, true)\n+                .is_match()\n         }\n     }\n \n     pub fn match_position(&self, value: &str) -> Option<usize> {\n         if let Pattern::Alternatives(list) = self {\n-            list.iter()\n-                .position(|alt| alt.match_internal(value, None, false).is_match())\n+            list.iter().position(|alt| {\n+                alt.match_internal(value, None, InNodeModules::False, false)\n+                    .is_match()\n+            })\n         } else {\n-            self.match_internal(value, None, false)\n+            self.match_internal(value, None, InNodeModules::False, false)\n                 .is_match()\n                 .then_some(0)\n         }\n     }\n \n     pub fn could_match_others(&self, value: &str) -> bool {\n         if let Pattern::Alternatives(list) = self {\n-            list.iter()\n-                .any(|alt| alt.match_internal(value, None, false).could_match_others())\n+            list.iter().any(|alt| {\n+                alt.match_internal(value, None, InNodeModules::False, false)\n+                    .could_match_others()\n+            })\n         } else {\n-            self.match_internal(value, None, false).could_match_others()\n+            self.match_internal(value, None, InNodeModules::False, false)\n+                .could_match_others()\n         }\n     }\n \n     /// Returns true if all matches of the pattern start with `value`.\n     pub fn must_match(&self, value: &str) -> bool {\n         if let Pattern::Alternatives(list) = self {\n-            list.iter()\n-                .all(|alt| alt.match_internal(value, None, false).could_match())\n+            list.iter().all(|alt| {\n+                alt.match_internal(value, None, InNodeModules::False, false)\n+                    .could_match()\n+            })\n         } else {\n-            self.match_internal(value, None, false).could_match()\n+            self.match_internal(value, None, InNodeModules::False, false)\n+                .could_match()\n         }\n     }\n \n     /// Returns true the pattern could match something that starts with `value`.\n     pub fn could_match(&self, value: &str) -> bool {\n         if let Pattern::Alternatives(list) = self {\n-            list.iter()\n-                .any(|alt| alt.match_internal(value, None, false).could_match())\n+            list.iter().any(|alt| {\n+                alt.match_internal(value, None, InNodeModules::False, false)\n+                    .could_match()\n+            })\n         } else {\n-            self.match_internal(value, None, false).could_match()\n+            self.match_internal(value, None, InNodeModules::False, false)\n+                .could_match()\n         }\n     }\n \n     pub fn could_match_position(&self, value: &str) -> Option<usize> {\n         if let Pattern::Alternatives(list) = self {\n-            list.iter()\n-                .position(|alt| alt.match_internal(value, None, false).could_match())\n+            list.iter().position(|alt| {\n+                alt.match_internal(value, None, InNodeModules::False, false)\n+                    .could_match()\n+            })\n         } else {\n-            self.match_internal(value, None, false)\n+            self.match_internal(value, None, InNodeModules::False, false)\n                 .could_match()\n                 .then_some(0)\n         }\n@@ -884,6 +903,7 @@ impl Pattern {\n         &self,\n         mut value: &'a str,\n         mut any_offset: Option<usize>,\n+        mut in_node_modules: InNodeModules,\n         ignore_dynamic: bool,\n     ) -> MatchResult<'a> {\n         match self {\n@@ -894,6 +914,7 @@ impl Pattern {\n                             MatchResult::Consumed {\n                                 remaining: &value[index + c.len()..],\n                                 any_offset: None,\n+                                in_node_modules: InNodeModules::check(c),\n                             }\n                         } else {\n                             MatchResult::None\n@@ -907,6 +928,7 @@ impl Pattern {\n                     MatchResult::Consumed {\n                         remaining: &value[c.len()..],\n                         any_offset: None,\n+                        in_node_modules: InNodeModules::check(c),\n                     }\n                 } else if c.starts_with(value) {\n                     MatchResult::Partial\n@@ -920,10 +942,15 @@ impl Pattern {\n                 });\n                 static FORBIDDEN_MATCH: LazyLock<Regex> =\n                     LazyLock::new(|| Regex::new(r\"\\.d\\.ts$|\\.map$\").unwrap());\n-                if let Some(m) = FORBIDDEN.find(value) {\n+                if in_node_modules == InNodeModules::FolderSlashMatched\n+                    || (in_node_modules == InNodeModules::FolderMatched && value.starts_with('/'))\n+                {\n+                    MatchResult::None\n+                } else if let Some(m) = FORBIDDEN.find(value) {\n                     MatchResult::Consumed {\n                         remaining: value,\n                         any_offset: Some(m.start()),\n+                        in_node_modules: InNodeModules::False,\n                     }\n                 } else if FORBIDDEN_MATCH.find(value).is_some() {\n                     MatchResult::Partial\n@@ -937,6 +964,7 @@ impl Pattern {\n                     MatchResult::Consumed {\n                         remaining: value,\n                         any_offset: Some(match_length),\n+                        in_node_modules: InNodeModules::False,\n                     }\n                 }\n             }\n@@ -945,21 +973,24 @@ impl Pattern {\n             }\n             Pattern::Concatenation(list) => {\n                 for part in list {\n-                    match part.match_internal(value, any_offset, ignore_dynamic) {\n+                    match part.match_internal(value, any_offset, in_node_modules, ignore_dynamic) {\n                         MatchResult::None => return MatchResult::None,\n                         MatchResult::Partial => return MatchResult::Partial,\n                         MatchResult::Consumed {\n                             remaining: new_value,\n                             any_offset: new_any_offset,\n+                            in_node_modules: new_in_node_modules,\n                         } => {\n                             value = new_value;\n                             any_offset = new_any_offset;\n+                            in_node_modules = new_in_node_modules\n                         }\n                     }\n                 }\n                 MatchResult::Consumed {\n                     remaining: value,\n                     any_offset,\n+                    in_node_modules,\n                 }\n             }\n         }\n@@ -971,6 +1002,7 @@ impl Pattern {\n         &self,\n         mut value: &'a str,\n         mut any_offset: Option<usize>,\n+        mut in_node_modules: InNodeModules,\n         dynamics: &mut VecDeque<&'a str>,\n     ) -> MatchResult<'a> {\n         match self {\n@@ -984,6 +1016,7 @@ impl Pattern {\n                             MatchResult::Consumed {\n                                 remaining: &value[index + c.len()..],\n                                 any_offset: None,\n+                                in_node_modules: InNodeModules::check(c),\n                             }\n                         } else {\n                             MatchResult::None\n@@ -997,6 +1030,7 @@ impl Pattern {\n                     MatchResult::Consumed {\n                         remaining: &value[c.len()..],\n                         any_offset: None,\n+                        in_node_modules: InNodeModules::check(c),\n                     }\n                 } else if c.starts_with(value) {\n                     MatchResult::Partial\n@@ -1010,10 +1044,15 @@ impl Pattern {\n                 });\n                 static FORBIDDEN_MATCH: LazyLock<Regex> =\n                     LazyLock::new(|| Regex::new(r\"\\.d\\.ts$|\\.map$\").unwrap());\n-                if let Some(m) = FORBIDDEN.find(value) {\n+                if in_node_modules == InNodeModules::FolderSlashMatched\n+                    || (in_node_modules == InNodeModules::FolderMatched && value.starts_with('/'))\n+                {\n+                    MatchResult::None\n+                } else if let Some(m) = FORBIDDEN.find(value) {\n                     MatchResult::Consumed {\n                         remaining: value,\n                         any_offset: Some(m.start()),\n+                        in_node_modules: InNodeModules::False,\n                     }\n                 } else if FORBIDDEN_MATCH.find(value).is_some() {\n                     MatchResult::Partial\n@@ -1025,6 +1064,7 @@ impl Pattern {\n                     MatchResult::Consumed {\n                         remaining: value,\n                         any_offset: Some(match_length),\n+                        in_node_modules: InNodeModules::False,\n                     }\n                 }\n             }\n@@ -1033,15 +1073,18 @@ impl Pattern {\n             }\n             Pattern::Concatenation(list) => {\n                 for part in list {\n-                    match part.match_collect_internal(value, any_offset, dynamics) {\n+                    match part.match_collect_internal(value, any_offset, in_node_modules, dynamics)\n+                    {\n                         MatchResult::None => return MatchResult::None,\n                         MatchResult::Partial => return MatchResult::Partial,\n                         MatchResult::Consumed {\n                             remaining: new_value,\n                             any_offset: new_any_offset,\n+                            in_node_modules: new_in_node_modules,\n                         } => {\n                             value = new_value;\n                             any_offset = new_any_offset;\n+                            in_node_modules = new_in_node_modules\n                         }\n                     }\n                 }\n@@ -1053,6 +1096,7 @@ impl Pattern {\n                 MatchResult::Consumed {\n                     remaining: value,\n                     any_offset,\n+                    in_node_modules,\n                 }\n             }\n         }\n@@ -1249,7 +1293,7 @@ impl Pattern {\n \n         let mut dynamics = VecDeque::new();\n         // This is definitely a match, because it matched above in `self.match_position(value)`\n-        source.match_collect_internal(value, None, &mut dynamics);\n+        source.match_collect_internal(value, None, InNodeModules::False, &mut dynamics);\n \n         let mut result = \"\".to_string();\n         match target {\n@@ -1293,6 +1337,26 @@ impl Pattern {\n     }\n }\n \n+#[derive(PartialEq, Debug)]\n+enum InNodeModules {\n+    False,\n+    // Inside of a match ending in `node_modules`\n+    FolderMatched,\n+    // Inside of a match ending in `node_modules/`\n+    FolderSlashMatched,\n+}\n+impl InNodeModules {\n+    fn check(value: &str) -> Self {\n+        if value.ends_with(\"node_modules/\") {\n+            InNodeModules::FolderSlashMatched\n+        } else if value.ends_with(\"node_modules\") {\n+            InNodeModules::FolderMatched\n+        } else {\n+            InNodeModules::False\n+        }\n+    }\n+}\n+\n #[derive(PartialEq, Debug)]\n enum MatchResult<'a> {\n     /// No match\n@@ -1306,6 +1370,9 @@ enum MatchResult<'a> {\n         /// Set when the pattern ends with a dynamic part. The dynamic part\n         /// could match n bytes more of the string.\n         any_offset: Option<usize>,\n+        /// Set when the pattern ends with `node_modules` or `node_modules/` (and a following\n+        /// Pattern::Dynamic would thus match all existing packages)\n+        in_node_modules: InNodeModules,\n     },\n }\n \n@@ -1318,6 +1385,7 @@ impl MatchResult<'_> {\n             MatchResult::Consumed {\n                 remaining: rem,\n                 any_offset,\n+                in_node_modules: _,\n             } => {\n                 if let Some(offset) = any_offset {\n                     *offset == rem.len()\n@@ -1337,6 +1405,7 @@ impl MatchResult<'_> {\n             MatchResult::Consumed {\n                 remaining: rem,\n                 any_offset,\n+                in_node_modules: _,\n             } => {\n                 if let Some(offset) = any_offset {\n                     *offset == rem.len()\n@@ -1356,6 +1425,7 @@ impl MatchResult<'_> {\n             MatchResult::Consumed {\n                 remaining: rem,\n                 any_offset,\n+                in_node_modules: _,\n             } => {\n                 if let Some(offset) = any_offset {\n                     *offset == rem.len()\n@@ -1833,10 +1903,16 @@ fn split_last_segment(path: &str) -> (&str, &str) {\n \n #[cfg(test)]\n mod tests {\n+    use std::path::Path;\n+\n     use rstest::*;\n     use turbo_rcstr::{RcStr, rcstr};\n+    use turbo_tasks_backend::{BackendOptions, TurboTasksBackend, noop_backing_storage};\n+    use turbo_tasks_fs::{DiskFileSystem, FileSystem};\n \n-    use super::{Pattern, longest_common_prefix, longest_common_suffix, split_last_segment};\n+    use super::{\n+        Pattern, longest_common_prefix, longest_common_suffix, read_matches, split_last_segment,\n+    };\n \n     #[test]\n     fn longest_common_prefix_test() {\n@@ -2284,6 +2360,16 @@ mod tests {\n         assert!(pat.could_match(\"dir/inner/file.d.ts.map\"));\n     }\n \n+    #[rstest]\n+    #[case::slash(Pattern::Concatenation(vec![Pattern::Constant(rcstr!(\"node_modules/\")),Pattern::Dynamic]))]\n+    #[case::nested(Pattern::Constant(rcstr!(\"node_modules\")).or_any_nested_file())]\n+    fn dynamic_match_node_modules(#[case] pat: Pattern) {\n+        assert!(!pat.is_match(\"node_modules/package\"));\n+        assert!(!pat.could_match(\"node_modules/package\"));\n+        assert!(!pat.is_match(\"node_modules/package/index.js\"));\n+        assert!(!pat.could_match(\"node_modules/package/index.js\"));\n+    }\n+\n     #[rstest]\n     fn dynamic_match2() {\n         let pat = Pattern::Concatenation(vec![\n@@ -2567,4 +2653,79 @@ mod tests {\n         assert_eq!(split_last_segment(\"../../a\"), (\"../..\", \"a\"));\n         assert_eq!(split_last_segment(\"../../a/\"), (\"../..\", \"a\"));\n     }\n+\n+    #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n+    async fn test_read_matches() {\n+        let tt = turbo_tasks::TurboTasks::new(TurboTasksBackend::new(\n+            BackendOptions::default(),\n+            noop_backing_storage(),\n+        ));\n+        tt.run_once(async {\n+            crate::register();\n+            let root = DiskFileSystem::new(\n+                rcstr!(\"test\"),\n+                Path::new(env!(\"CARGO_MANIFEST_DIR\"))\n+                    .join(\"tests/pattern/read_matches\")\n+                    .to_str()\n+                    .unwrap()\n+                    .into(),\n+            )\n+            .root()\n+            .owned()\n+            .await?;\n+\n+            // node_modules shouldn't be matched by Dynamic here\n+            assert_eq!(\n+                vec![\"index.js\", \"sub\", \"sub/\", \"sub/foo-a.js\", \"sub/foo-b.js\"],\n+                read_matches(\n+                    root.clone(),\n+                    rcstr!(\"\"),\n+                    false,\n+                    Pattern::new(Pattern::Dynamic),\n+                )\n+                .await?\n+                .into_iter()\n+                .map(|m| m.name())\n+                .collect::<Vec<_>>()\n+            );\n+\n+            // basic dynamic file suffix\n+            assert_eq!(\n+                vec![\"sub/foo-a.js\", \"sub/foo-b.js\"],\n+                read_matches(\n+                    root.clone(),\n+                    rcstr!(\"\"),\n+                    false,\n+                    Pattern::new(Pattern::concat([\n+                        Pattern::Constant(rcstr!(\"sub/foo\")),\n+                        Pattern::Dynamic,\n+                    ])),\n+                )\n+                .await?\n+                .into_iter()\n+                .map(|m| m.name())\n+                .collect::<Vec<_>>()\n+            );\n+\n+            // read_matches \"node_modules/<dynamic>\" should not return anything inside. We never\n+            // want to enumerate the list of packages here.\n+            assert_eq!(\n+                vec![\"node_modules\"] as Vec<&str>,\n+                read_matches(\n+                    root.clone(),\n+                    rcstr!(\"\"),\n+                    false,\n+                    Pattern::new(Pattern::Constant(rcstr!(\"node_modules\")).or_any_nested_file()),\n+                )\n+                .await?\n+                .into_iter()\n+                .map(|m| m.name())\n+                .collect::<Vec<_>>()\n+            );\n+\n+            anyhow::Ok(())\n+        })\n+        .await\n+        .unwrap();\n+    }\n }"
        },
        {
            "sha": "5f2fb0a1311f1ccd4c7d8a0d23e897c09b7ed2fb",
            "filename": "turbopack/crates/turbopack-core/tests/.gitignore",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/d3bc037192b27e99734e524316701df9de38a1a4/turbopack%2Fcrates%2Fturbopack-core%2Ftests%2F.gitignore",
            "raw_url": "https://github.com/vercel/next.js/raw/d3bc037192b27e99734e524316701df9de38a1a4/turbopack%2Fcrates%2Fturbopack-core%2Ftests%2F.gitignore",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Ftests%2F.gitignore?ref=d3bc037192b27e99734e524316701df9de38a1a4",
            "patch": "@@ -0,0 +1 @@\n+!**"
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "turbopack/crates/turbopack-core/tests/pattern/read_matches/index.js",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/vercel/next.js/blob/d3bc037192b27e99734e524316701df9de38a1a4/turbopack%2Fcrates%2Fturbopack-core%2Ftests%2Fpattern%2Fread_matches%2Findex.js",
            "raw_url": "https://github.com/vercel/next.js/raw/d3bc037192b27e99734e524316701df9de38a1a4/turbopack%2Fcrates%2Fturbopack-core%2Ftests%2Fpattern%2Fread_matches%2Findex.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Ftests%2Fpattern%2Fread_matches%2Findex.js?ref=d3bc037192b27e99734e524316701df9de38a1a4"
        },
        {
            "sha": "5b1dd02ff27e8bee4fd465289285218a54318f80",
            "filename": "turbopack/crates/turbopack-core/tests/pattern/read_matches/node_modules/pkg/LICENSE",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/d3bc037192b27e99734e524316701df9de38a1a4/turbopack%2Fcrates%2Fturbopack-core%2Ftests%2Fpattern%2Fread_matches%2Fnode_modules%2Fpkg%2FLICENSE",
            "raw_url": "https://github.com/vercel/next.js/raw/d3bc037192b27e99734e524316701df9de38a1a4/turbopack%2Fcrates%2Fturbopack-core%2Ftests%2Fpattern%2Fread_matches%2Fnode_modules%2Fpkg%2FLICENSE",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Ftests%2Fpattern%2Fread_matches%2Fnode_modules%2Fpkg%2FLICENSE?ref=d3bc037192b27e99734e524316701df9de38a1a4",
            "patch": "@@ -0,0 +1 @@\n+Some Text"
        },
        {
            "sha": "5b1dd02ff27e8bee4fd465289285218a54318f80",
            "filename": "turbopack/crates/turbopack-core/tests/pattern/read_matches/node_modules/pkg/README.md",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/d3bc037192b27e99734e524316701df9de38a1a4/turbopack%2Fcrates%2Fturbopack-core%2Ftests%2Fpattern%2Fread_matches%2Fnode_modules%2Fpkg%2FREADME.md",
            "raw_url": "https://github.com/vercel/next.js/raw/d3bc037192b27e99734e524316701df9de38a1a4/turbopack%2Fcrates%2Fturbopack-core%2Ftests%2Fpattern%2Fread_matches%2Fnode_modules%2Fpkg%2FREADME.md",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Ftests%2Fpattern%2Fread_matches%2Fnode_modules%2Fpkg%2FREADME.md?ref=d3bc037192b27e99734e524316701df9de38a1a4",
            "patch": "@@ -0,0 +1 @@\n+Some Text"
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "turbopack/crates/turbopack-core/tests/pattern/read_matches/node_modules/pkg/index.js",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/vercel/next.js/blob/d3bc037192b27e99734e524316701df9de38a1a4/turbopack%2Fcrates%2Fturbopack-core%2Ftests%2Fpattern%2Fread_matches%2Fnode_modules%2Fpkg%2Findex.js",
            "raw_url": "https://github.com/vercel/next.js/raw/d3bc037192b27e99734e524316701df9de38a1a4/turbopack%2Fcrates%2Fturbopack-core%2Ftests%2Fpattern%2Fread_matches%2Fnode_modules%2Fpkg%2Findex.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Ftests%2Fpattern%2Fread_matches%2Fnode_modules%2Fpkg%2Findex.js?ref=d3bc037192b27e99734e524316701df9de38a1a4"
        },
        {
            "sha": "0967ef424bce6791893e9a57bb952f80fd536e93",
            "filename": "turbopack/crates/turbopack-core/tests/pattern/read_matches/node_modules/pkg/package.json",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/d3bc037192b27e99734e524316701df9de38a1a4/turbopack%2Fcrates%2Fturbopack-core%2Ftests%2Fpattern%2Fread_matches%2Fnode_modules%2Fpkg%2Fpackage.json",
            "raw_url": "https://github.com/vercel/next.js/raw/d3bc037192b27e99734e524316701df9de38a1a4/turbopack%2Fcrates%2Fturbopack-core%2Ftests%2Fpattern%2Fread_matches%2Fnode_modules%2Fpkg%2Fpackage.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Ftests%2Fpattern%2Fread_matches%2Fnode_modules%2Fpkg%2Fpackage.json?ref=d3bc037192b27e99734e524316701df9de38a1a4",
            "patch": "@@ -0,0 +1 @@\n+{}"
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "turbopack/crates/turbopack-core/tests/pattern/read_matches/sub/foo-a.js",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/vercel/next.js/blob/d3bc037192b27e99734e524316701df9de38a1a4/turbopack%2Fcrates%2Fturbopack-core%2Ftests%2Fpattern%2Fread_matches%2Fsub%2Ffoo-a.js",
            "raw_url": "https://github.com/vercel/next.js/raw/d3bc037192b27e99734e524316701df9de38a1a4/turbopack%2Fcrates%2Fturbopack-core%2Ftests%2Fpattern%2Fread_matches%2Fsub%2Ffoo-a.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Ftests%2Fpattern%2Fread_matches%2Fsub%2Ffoo-a.js?ref=d3bc037192b27e99734e524316701df9de38a1a4"
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "turbopack/crates/turbopack-core/tests/pattern/read_matches/sub/foo-a.js.map",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/vercel/next.js/blob/d3bc037192b27e99734e524316701df9de38a1a4/turbopack%2Fcrates%2Fturbopack-core%2Ftests%2Fpattern%2Fread_matches%2Fsub%2Ffoo-a.js.map",
            "raw_url": "https://github.com/vercel/next.js/raw/d3bc037192b27e99734e524316701df9de38a1a4/turbopack%2Fcrates%2Fturbopack-core%2Ftests%2Fpattern%2Fread_matches%2Fsub%2Ffoo-a.js.map",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Ftests%2Fpattern%2Fread_matches%2Fsub%2Ffoo-a.js.map?ref=d3bc037192b27e99734e524316701df9de38a1a4"
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "turbopack/crates/turbopack-core/tests/pattern/read_matches/sub/foo-b.js",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/vercel/next.js/blob/d3bc037192b27e99734e524316701df9de38a1a4/turbopack%2Fcrates%2Fturbopack-core%2Ftests%2Fpattern%2Fread_matches%2Fsub%2Ffoo-b.js",
            "raw_url": "https://github.com/vercel/next.js/raw/d3bc037192b27e99734e524316701df9de38a1a4/turbopack%2Fcrates%2Fturbopack-core%2Ftests%2Fpattern%2Fread_matches%2Fsub%2Ffoo-b.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Ftests%2Fpattern%2Fread_matches%2Fsub%2Ffoo-b.js?ref=d3bc037192b27e99734e524316701df9de38a1a4"
        },
        {
            "sha": "fc7f14b03fe6fb720e987e04739a8f3dd3ad5906",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/node.rs",
            "status": "modified",
            "additions": 24,
            "deletions": 34,
            "changes": 58,
            "blob_url": "https://github.com/vercel/next.js/blob/d3bc037192b27e99734e524316701df9de38a1a4/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fnode.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d3bc037192b27e99734e524316701df9de38a1a4/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fnode.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fnode.rs?ref=d3bc037192b27e99734e524316701df9de38a1a4",
            "patch": "@@ -1,5 +1,4 @@\n use anyhow::Result;\n-use either::Either;\n use tracing::Instrument;\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{ResolvedVc, ValueToString, Vc};\n@@ -78,51 +77,42 @@ async fn resolve_reference_from_dir(\n ) -> Result<Vc<ModuleResolveResult>> {\n     let path_ref = path.await?;\n     let (abs_path, rel_path) = path_ref.split_could_match(\"/ROOT/\");\n-    let matches = match (abs_path, rel_path) {\n-        (Some(abs_path), Some(rel_path)) => Either::Right(\n-            read_matches(\n-                parent_path.root().owned().await?,\n-                rcstr!(\"/ROOT/\"),\n-                true,\n-                Pattern::new(abs_path.or_any_nested_file()),\n-            )\n-            .await?\n-            .into_iter()\n-            .chain(\n-                read_matches(\n-                    parent_path,\n-                    rcstr!(\"\"),\n-                    true,\n-                    Pattern::new(rel_path.or_any_nested_file()),\n-                )\n-                .await?\n-                .into_iter(),\n-            ),\n-        ),\n-        (Some(abs_path), None) => Either::Left(\n-            // absolute path only\n+    if abs_path.is_none() && rel_path.is_none() {\n+        return Ok(*ModuleResolveResult::unresolvable());\n+    }\n+\n+    let abs_matches = if let Some(abs_path) = &abs_path {\n+        Some(\n             read_matches(\n                 parent_path.root().owned().await?,\n                 rcstr!(\"/ROOT/\"),\n                 true,\n                 Pattern::new(abs_path.or_any_nested_file()),\n             )\n-            .await?\n-            .into_iter(),\n-        ),\n-        (None, Some(rel_path)) => Either::Left(\n-            // relative path only\n+            .await?,\n+        )\n+    } else {\n+        None\n+    };\n+    let rel_matches = if let Some(rel_path) = &rel_path {\n+        Some(\n             read_matches(\n                 parent_path,\n                 rcstr!(\"\"),\n                 true,\n                 Pattern::new(rel_path.or_any_nested_file()),\n             )\n-            .await?\n-            .into_iter(),\n-        ),\n-        (None, None) => return Ok(*ModuleResolveResult::unresolvable()),\n+            .await?,\n+        )\n+    } else {\n+        None\n     };\n+\n+    let matches = abs_matches\n+        .into_iter()\n+        .flatten()\n+        .chain(rel_matches.into_iter().flatten());\n+\n     let mut affecting_sources = Vec::new();\n     let mut results = Vec::new();\n     for pat_match in matches {\n@@ -158,7 +148,7 @@ impl ModuleReference for DirAssetReference {\n     async fn resolve_reference(&self) -> Result<Vc<ModuleResolveResult>> {\n         let parent_path = self.source.ident().path().await?.parent();\n         let span = tracing::info_span!(\n-            \"resolve DirAssetReference\",\n+            \"trace directory\",\n             pattern = display(self.path.to_string().await?)\n         );\n         async {"
        },
        {
            "sha": "4983221972b1edd913fb7ea5a8f943cabae4f57c",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/raw.rs",
            "status": "modified",
            "additions": 13,
            "deletions": 1,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/d3bc037192b27e99734e524316701df9de38a1a4/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fraw.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d3bc037192b27e99734e524316701df9de38a1a4/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fraw.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fraw.rs?ref=d3bc037192b27e99734e524316701df9de38a1a4",
            "patch": "@@ -1,4 +1,5 @@\n use anyhow::Result;\n+use tracing::Instrument;\n use turbo_rcstr::RcStr;\n use turbo_tasks::{ResolvedVc, ValueToString, Vc};\n use turbopack_core::{\n@@ -28,7 +29,18 @@ impl ModuleReference for FileSourceReference {\n     async fn resolve_reference(&self) -> Result<Vc<ModuleResolveResult>> {\n         let context_dir = self.source.ident().path().await?.parent();\n \n-        Ok(resolve_raw(context_dir, *self.path, false).as_raw_module_result())\n+        let span = tracing::info_span!(\n+            \"trace file\",\n+            pattern = display(self.path.to_string().await?)\n+        );\n+        async {\n+            resolve_raw(context_dir, *self.path, false)\n+                .as_raw_module_result()\n+                .resolve()\n+                .await\n+        }\n+        .instrument(span)\n+        .await\n     }\n }\n "
        }
    ],
    "stats": {
        "total": 291,
        "additions": 229,
        "deletions": 62
    }
}