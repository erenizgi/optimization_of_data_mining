{
    "author": "mischnic",
    "message": "Migrate to VisitMut (#86347)\n\nThis is generally better for performance",
    "sha": "d93f4c8064f57d5a8db896017a49a6eb3f7a5988",
    "files": [
        {
            "sha": "1ddd5f5262699565e1ee5ea27fa8e6d7e50d2f2b",
            "filename": "crates/next-custom-transforms/src/transforms/dynamic.rs",
            "status": "modified",
            "additions": 20,
            "deletions": 27,
            "changes": 47,
            "blob_url": "https://github.com/vercel/next.js/blob/d93f4c8064f57d5a8db896017a49a6eb3f7a5988/crates%2Fnext-custom-transforms%2Fsrc%2Ftransforms%2Fdynamic.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d93f4c8064f57d5a8db896017a49a6eb3f7a5988/crates%2Fnext-custom-transforms%2Fsrc%2Ftransforms%2Fdynamic.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-custom-transforms%2Fsrc%2Ftransforms%2Fdynamic.rs?ref=d93f4c8064f57d5a8db896017a49a6eb3f7a5988",
            "patch": "@@ -15,7 +15,7 @@ use swc_core::{\n             PropName, PropOrSpread, Stmt, Str, Tpl, UnaryExpr, UnaryOp,\n         },\n         utils::{private_ident, quote_ident, ExprFactory},\n-        visit::{fold_pass, Fold, FoldWith, VisitMut, VisitMutWith},\n+        visit::{visit_mut_pass, VisitMut, VisitMutWith},\n     },\n     quote,\n };\n@@ -34,7 +34,7 @@ pub fn next_dynamic(\n     filename: Arc<FileName>,\n     pages_or_app_dir: Option<PathBuf>,\n ) -> impl Pass {\n-    fold_pass(NextDynamicPatcher {\n+    visit_mut_pass(NextDynamicPatcher {\n         is_development,\n         is_server_compiler,\n         is_react_server_layer,\n@@ -117,33 +117,24 @@ enum TurbopackImport {\n     },\n }\n \n-impl Fold for NextDynamicPatcher {\n-    fn fold_module_items(&mut self, mut items: Vec<ModuleItem>) -> Vec<ModuleItem> {\n-        items = items.fold_children_with(self);\n+impl VisitMut for NextDynamicPatcher {\n+    fn visit_mut_module_items(&mut self, items: &mut Vec<ModuleItem>) {\n+        items.visit_mut_children_with(self);\n \n-        self.maybe_add_dynamically_imported_specifier(&mut items);\n-\n-        items\n+        self.maybe_add_dynamically_imported_specifier(items);\n     }\n \n-    fn fold_import_decl(&mut self, decl: ImportDecl) -> ImportDecl {\n-        let ImportDecl {\n-            ref src,\n-            ref specifiers,\n-            ..\n-        } = decl;\n-        if &src.value == \"next/dynamic\" {\n-            for specifier in specifiers {\n+    fn visit_mut_import_decl(&mut self, decl: &mut ImportDecl) {\n+        if &decl.src.value == \"next/dynamic\" {\n+            for specifier in &decl.specifiers {\n                 if let ImportSpecifier::Default(default_specifier) = specifier {\n                     self.dynamic_bindings.push(default_specifier.local.to_id());\n                 }\n             }\n         }\n-\n-        decl\n     }\n \n-    fn fold_call_expr(&mut self, expr: CallExpr) -> CallExpr {\n+    fn visit_mut_call_expr(&mut self, expr: &mut CallExpr) {\n         if self.is_next_dynamic_first_arg {\n             if let Callee::Import(..) = &expr.callee {\n                 match &*expr.args[0].expr {\n@@ -157,9 +148,12 @@ impl Fold for NextDynamicPatcher {\n                     _ => {}\n                 }\n             }\n-            return expr.fold_children_with(self);\n+            expr.visit_mut_children_with(self);\n+            return;\n         }\n-        let mut expr = expr.fold_children_with(self);\n+\n+        expr.visit_mut_children_with(self);\n+\n         if let Callee::Expr(i) = &expr.callee {\n             if let Expr::Ident(identifier) = &**i {\n                 if self.dynamic_bindings.contains(&identifier.to_id()) {\n@@ -172,7 +166,7 @@ impl Fold for NextDynamicPatcher {\n                                 )\n                                 .emit()\n                         });\n-                        return expr;\n+                        return;\n                     } else if expr.args.len() > 2 {\n                         HANDLER.with(|handler| {\n                             handler\n@@ -182,7 +176,7 @@ impl Fold for NextDynamicPatcher {\n                                 )\n                                 .emit()\n                         });\n-                        return expr;\n+                        return;\n                     }\n                     if expr.args.len() == 2 {\n                         match &*expr.args[1].expr {\n@@ -196,19 +190,19 @@ impl Fold for NextDynamicPatcher {\n                               )\n                               .emit();\n                       });\n-                                return expr;\n+                                return;\n                             }\n                         }\n                     }\n \n                     self.is_next_dynamic_first_arg = true;\n-                    expr.args[0].expr = expr.args[0].expr.clone().fold_with(self);\n+                    expr.args[0].expr.visit_mut_with(self);\n                     self.is_next_dynamic_first_arg = false;\n \n                     let Some((dynamically_imported_specifier, dynamically_imported_specifier_span)) =\n                         self.dynamically_imported_specifier.take()\n                     else {\n-                        return expr;\n+                        return;\n                     };\n \n                     let project_dir = match self.pages_or_app_dir.as_deref() {\n@@ -419,7 +413,6 @@ impl Fold for NextDynamicPatcher {\n                 }\n             }\n         }\n-        expr\n     }\n }\n "
        },
        {
            "sha": "4ef0ca979185e56b7aac4f303de409a523fdee7d",
            "filename": "crates/next-custom-transforms/src/transforms/named_import_transform.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 13,
            "changes": 19,
            "blob_url": "https://github.com/vercel/next.js/blob/d93f4c8064f57d5a8db896017a49a6eb3f7a5988/crates%2Fnext-custom-transforms%2Fsrc%2Ftransforms%2Fnamed_import_transform.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d93f4c8064f57d5a8db896017a49a6eb3f7a5988/crates%2Fnext-custom-transforms%2Fsrc%2Ftransforms%2Fnamed_import_transform.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-custom-transforms%2Fsrc%2Ftransforms%2Fnamed_import_transform.rs?ref=d93f4c8064f57d5a8db896017a49a6eb3f7a5988",
            "patch": "@@ -5,7 +5,7 @@ use swc_core::{\n     common::DUMMY_SP,\n     ecma::{\n         ast::*,\n-        visit::{fold_pass, Fold},\n+        visit::{visit_mut_pass, VisitMut},\n     },\n };\n \n@@ -14,8 +14,8 @@ pub struct Config {\n     pub packages: Vec<String>,\n }\n \n-pub fn named_import_transform(config: Config) -> impl Pass {\n-    fold_pass(NamedImportTransform {\n+pub fn named_import_transform(config: Config) -> impl Pass + VisitMut {\n+    visit_mut_pass(NamedImportTransform {\n         packages: config.packages,\n     })\n }\n@@ -25,9 +25,8 @@ struct NamedImportTransform {\n     packages: Vec<String>,\n }\n \n-/// TODO: Implement this as a [Pass] instead of a full visitor ([Fold])\n-impl Fold for NamedImportTransform {\n-    fn fold_import_decl(&mut self, decl: ImportDecl) -> ImportDecl {\n+impl VisitMut for NamedImportTransform {\n+    fn visit_mut_import_decl(&mut self, decl: &mut ImportDecl) {\n         // Match named imports and check if it's included in the packages\n         let src_value = &decl.src.value;\n \n@@ -75,18 +74,12 @@ impl Fold for NamedImportTransform {\n                     src_value.to_string_lossy()\n                 );\n \n-                // Create a new import declaration, keep everything the same except the source\n-                let mut new_decl = decl.clone();\n-                *new_decl.src = Str {\n+                *decl.src = Str {\n                     span: DUMMY_SP,\n                     value: new_src.into(),\n                     raw: None,\n                 };\n-\n-                return new_decl;\n             }\n         }\n-\n-        decl\n     }\n }"
        },
        {
            "sha": "39dc2f7bd8e380eecc1616fe4a2243b817ac7b52",
            "filename": "crates/next-custom-transforms/src/transforms/next_ssg.rs",
            "status": "modified",
            "additions": 95,
            "deletions": 152,
            "changes": 247,
            "blob_url": "https://github.com/vercel/next.js/blob/d93f4c8064f57d5a8db896017a49a6eb3f7a5988/crates%2Fnext-custom-transforms%2Fsrc%2Ftransforms%2Fnext_ssg.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d93f4c8064f57d5a8db896017a49a6eb3f7a5988/crates%2Fnext-custom-transforms%2Fsrc%2Ftransforms%2Fnext_ssg.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-custom-transforms%2Fsrc%2Ftransforms%2Fnext_ssg.rs?ref=d93f4c8064f57d5a8db896017a49a6eb3f7a5988",
            "patch": "@@ -11,15 +11,15 @@ use swc_core::{\n     },\n     ecma::{\n         ast::*,\n-        visit::{fold_pass, noop_fold_type, Fold, FoldWith},\n+        visit::{noop_visit_mut_type, visit_mut_pass, VisitMut, VisitMutWith},\n     },\n };\n \n static SSG_EXPORTS: &[&str; 3] = &[\"getStaticProps\", \"getStaticPaths\", \"getServerSideProps\"];\n \n /// Note: This paths requires running `resolver` **before** running this.\n pub fn next_ssg(eliminated_packages: Rc<RefCell<FxHashSet<Atom>>>) -> impl Pass {\n-    fold_pass(Repeat::new(NextSsg {\n+    visit_mut_pass(Repeat::new(NextSsg {\n         state: State {\n             eliminated_packages,\n             ..Default::default()\n@@ -120,32 +120,28 @@ impl Analyzer<'_> {\n     }\n }\n \n-impl Fold for Analyzer<'_> {\n+impl VisitMut for Analyzer<'_> {\n     // This is important for reducing binary sizes.\n-    noop_fold_type!();\n+    noop_visit_mut_type!();\n \n-    fn fold_binding_ident(&mut self, i: BindingIdent) -> BindingIdent {\n+    fn visit_mut_binding_ident(&mut self, i: &mut BindingIdent) {\n         if !self.in_lhs_of_var || self.in_data_fn {\n             self.add_ref(i.id.to_id());\n         }\n-\n-        i\n     }\n \n-    fn fold_export_named_specifier(&mut self, s: ExportNamedSpecifier) -> ExportNamedSpecifier {\n+    fn visit_mut_export_named_specifier(&mut self, s: &mut ExportNamedSpecifier) {\n         if let ModuleExportName::Ident(id) = &s.orig {\n             if !SSG_EXPORTS.contains(&&*id.sym) {\n                 self.add_ref(id.to_id());\n             }\n         }\n-\n-        s\n     }\n \n-    fn fold_export_decl(&mut self, s: ExportDecl) -> ExportDecl {\n+    fn visit_mut_export_decl(&mut self, s: &mut ExportDecl) {\n         if let Decl::Var(d) = &s.decl {\n             if d.decls.is_empty() {\n-                return s;\n+                return;\n             }\n \n             if let Pat::Ident(id) = &d.decls[0].name {\n@@ -155,20 +151,18 @@ impl Fold for Analyzer<'_> {\n             }\n         }\n \n-        s.fold_children_with(self)\n+        s.visit_mut_children_with(self)\n     }\n \n-    fn fold_expr(&mut self, e: Expr) -> Expr {\n-        let e = e.fold_children_with(self);\n+    fn visit_mut_expr(&mut self, e: &mut Expr) {\n+        e.visit_mut_children_with(self);\n \n         if let Expr::Ident(i) = &e {\n             self.add_ref(i.to_id());\n         }\n-\n-        e\n     }\n \n-    fn fold_jsx_element(&mut self, jsx: JSXElement) -> JSXElement {\n+    fn visit_mut_jsx_element(&mut self, jsx: &mut JSXElement) {\n         fn get_leftmost_id_member_expr(e: &JSXMemberExpr) -> Id {\n             match &e.obj {\n                 JSXObject::Ident(i) => i.to_id(),\n@@ -186,18 +180,18 @@ impl Fold for Analyzer<'_> {\n             _ => {}\n         }\n \n-        jsx.fold_children_with(self)\n+        jsx.visit_mut_children_with(self);\n     }\n \n-    fn fold_fn_decl(&mut self, f: FnDecl) -> FnDecl {\n+    fn visit_mut_fn_decl(&mut self, f: &mut FnDecl) {\n         let old_in_data = self.in_data_fn;\n \n         self.state.cur_declaring.insert(f.ident.to_id());\n \n         if let Ok(is_data_identifier) = self.state.is_data_identifier(&f.ident) {\n             self.in_data_fn |= is_data_identifier;\n         } else {\n-            return f;\n+            return;\n         }\n         tracing::trace!(\n             \"ssg: Handling `{}{:?}`; in_data_fn = {:?}\",\n@@ -206,87 +200,76 @@ impl Fold for Analyzer<'_> {\n             self.in_data_fn\n         );\n \n-        let f = f.fold_children_with(self);\n+        f.visit_mut_children_with(self);\n \n         self.state.cur_declaring.remove(&f.ident.to_id());\n \n         self.in_data_fn = old_in_data;\n-\n-        f\n     }\n \n-    fn fold_fn_expr(&mut self, f: FnExpr) -> FnExpr {\n-        let f = f.fold_children_with(self);\n+    fn visit_mut_fn_expr(&mut self, f: &mut FnExpr) {\n+        f.visit_mut_children_with(self);\n \n         if let Some(id) = &f.ident {\n             self.add_ref(id.to_id());\n         }\n-\n-        f\n     }\n \n     /// Drops [ExportDecl] if all specifiers are removed.\n-    fn fold_module_item(&mut self, s: ModuleItem) -> ModuleItem {\n+    fn visit_mut_module_item(&mut self, s: &mut ModuleItem) {\n         match s {\n             ModuleItem::ModuleDecl(ModuleDecl::ExportNamed(e)) if !e.specifiers.is_empty() => {\n-                let e = e.fold_with(self);\n+                e.visit_mut_with(self);\n \n                 if e.specifiers.is_empty() {\n-                    return ModuleItem::Stmt(Stmt::Empty(EmptyStmt { span: DUMMY_SP }));\n+                    *s = ModuleItem::Stmt(Stmt::Empty(EmptyStmt { span: DUMMY_SP }));\n+                    return;\n                 }\n \n-                return ModuleItem::ModuleDecl(ModuleDecl::ExportNamed(e));\n+                return;\n             }\n             _ => {}\n         };\n \n         // Visit children to ensure that all references is added to the scope.\n-        let s = s.fold_children_with(self);\n+        s.visit_mut_children_with(self);\n \n         if let ModuleItem::ModuleDecl(ModuleDecl::ExportDecl(e)) = &s {\n             match &e.decl {\n                 Decl::Fn(f) => {\n                     // Drop getStaticProps.\n                     if let Ok(is_data_identifier) = self.state.is_data_identifier(&f.ident) {\n                         if is_data_identifier {\n-                            return ModuleItem::Stmt(Stmt::Empty(EmptyStmt { span: DUMMY_SP }));\n+                            *s = ModuleItem::Stmt(Stmt::Empty(EmptyStmt { span: DUMMY_SP }));\n                         }\n-                    } else {\n-                        return s;\n                     }\n                 }\n \n                 Decl::Var(d) => {\n                     if d.decls.is_empty() {\n-                        return ModuleItem::Stmt(Stmt::Empty(EmptyStmt { span: DUMMY_SP }));\n+                        *s = ModuleItem::Stmt(Stmt::Empty(EmptyStmt { span: DUMMY_SP }));\n                     }\n                 }\n                 _ => {}\n             }\n         }\n-\n-        s\n     }\n \n-    fn fold_named_export(&mut self, mut n: NamedExport) -> NamedExport {\n+    fn visit_mut_named_export(&mut self, n: &mut NamedExport) {\n         if n.src.is_some() {\n-            n.specifiers = n.specifiers.fold_with(self);\n+            n.specifiers.visit_mut_with(self);\n         }\n-\n-        n\n     }\n \n-    fn fold_prop(&mut self, p: Prop) -> Prop {\n-        let p = p.fold_children_with(self);\n+    fn visit_mut_prop(&mut self, p: &mut Prop) {\n+        p.visit_mut_children_with(self);\n \n         if let Prop::Shorthand(i) = &p {\n             self.add_ref(i.to_id());\n         }\n-\n-        p\n     }\n \n-    fn fold_var_declarator(&mut self, mut v: VarDeclarator) -> VarDeclarator {\n+    fn visit_mut_var_declarator(&mut self, v: &mut VarDeclarator) {\n         let old_in_data = self.in_data_fn;\n \n         if let Pat::Ident(name) = &v.name {\n@@ -295,23 +278,21 @@ impl Fold for Analyzer<'_> {\n                     self.in_data_fn = true;\n                 }\n             } else {\n-                return v;\n+                return;\n             }\n         }\n \n         let old_in_lhs_of_var = self.in_lhs_of_var;\n \n         self.in_lhs_of_var = true;\n-        v.name = v.name.fold_with(self);\n+        v.name.visit_mut_with(self);\n \n         self.in_lhs_of_var = false;\n-        v.init = v.init.fold_with(self);\n+        v.init.visit_mut_with(self);\n \n         self.in_lhs_of_var = old_in_lhs_of_var;\n \n         self.in_data_fn = old_in_data;\n-\n-        v\n     }\n }\n \n@@ -327,9 +308,9 @@ impl NextSsg {\n     }\n \n     /// Mark identifiers in `n` as a candidate for removal.\n-    fn mark_as_candidate<N>(&mut self, n: N) -> N\n+    fn mark_as_candidate<N>(&mut self, n: &mut N)\n     where\n-        N: for<'aa> FoldWith<Analyzer<'aa>>,\n+        N: for<'aa> VisitMutWith<Analyzer<'aa>>,\n     {\n         tracing::debug!(\"mark_as_candidate\");\n \n@@ -341,9 +322,8 @@ impl NextSsg {\n             in_data_fn: true,\n         };\n \n-        let n = n.fold_with(&mut v);\n+        n.visit_mut_with(&mut v);\n         self.state.should_run_again = true;\n-        n\n     }\n }\n \n@@ -359,18 +339,15 @@ impl Repeated for NextSsg {\n     }\n }\n \n-/// `VisitMut` is faster than [Fold], but we use [Fold] because it's much easier\n-/// to read.\n-///\n-/// Note: We don't implement `fold_script` because next.js doesn't use it.\n-impl Fold for NextSsg {\n+/// Note: We don't implement `visit_mut_script` because next.js doesn't use it.\n+impl VisitMut for NextSsg {\n     // This is important for reducing binary sizes.\n-    noop_fold_type!();\n+    noop_visit_mut_type!();\n \n-    fn fold_import_decl(&mut self, mut i: ImportDecl) -> ImportDecl {\n+    fn visit_mut_import_decl(&mut self, i: &mut ImportDecl) {\n         // Imports for side effects.\n         if i.specifiers.is_empty() {\n-            return i;\n+            return;\n         }\n \n         let import_src = &i.src.value;\n@@ -403,11 +380,9 @@ impl Fold for NextSsg {\n                 }\n             }\n         });\n-\n-        i\n     }\n \n-    fn fold_module(&mut self, mut m: Module) -> Module {\n+    fn visit_mut_module(&mut self, m: &mut Module) {\n         tracing::info!(\"ssg: Start\");\n         {\n             // Fill the state.\n@@ -416,43 +391,42 @@ impl Fold for NextSsg {\n                 in_lhs_of_var: false,\n                 in_data_fn: false,\n             };\n-            m = m.fold_with(&mut v);\n+            m.visit_mut_with(&mut v);\n         }\n \n         // TODO: Use better detection logic\n         // if !self.state.is_prerenderer && !self.state.is_server_props {\n         //     return m;\n         // }\n \n-        m.fold_children_with(self)\n+        m.visit_mut_children_with(self)\n     }\n \n-    fn fold_module_item(&mut self, i: ModuleItem) -> ModuleItem {\n-        if let ModuleItem::ModuleDecl(ModuleDecl::Import(i)) = i {\n-            let is_for_side_effect = i.specifiers.is_empty();\n-            let i = i.fold_with(self);\n+    fn visit_mut_module_item(&mut self, i: &mut ModuleItem) {\n+        if let ModuleItem::ModuleDecl(ModuleDecl::Import(decl)) = i {\n+            let is_for_side_effect = decl.specifiers.is_empty();\n+            decl.visit_mut_with(self);\n \n-            if !is_for_side_effect && i.specifiers.is_empty() {\n-                return ModuleItem::Stmt(Stmt::Empty(EmptyStmt { span: DUMMY_SP }));\n+            if !is_for_side_effect && decl.specifiers.is_empty() {\n+                *i = ModuleItem::Stmt(Stmt::Empty(EmptyStmt { span: DUMMY_SP }));\n+                return;\n             }\n \n-            return ModuleItem::ModuleDecl(ModuleDecl::Import(i));\n+            return;\n         }\n \n-        let i = i.fold_children_with(self);\n+        i.visit_mut_children_with(self);\n \n         match &i {\n             ModuleItem::ModuleDecl(ModuleDecl::ExportNamed(e)) if e.specifiers.is_empty() => {\n-                return ModuleItem::Stmt(Stmt::Empty(EmptyStmt { span: DUMMY_SP }));\n+                *i = ModuleItem::Stmt(Stmt::Empty(EmptyStmt { span: DUMMY_SP }));\n             }\n             _ => {}\n         }\n-\n-        i\n     }\n \n-    fn fold_module_items(&mut self, mut items: Vec<ModuleItem>) -> Vec<ModuleItem> {\n-        items = items.fold_children_with(self);\n+    fn visit_mut_module_items(&mut self, items: &mut Vec<ModuleItem>) {\n+        items.visit_mut_children_with(self);\n \n         // Drop nodes.\n         items.retain(|s| !matches!(s, ModuleItem::Stmt(Stmt::Empty(..))));\n@@ -485,7 +459,7 @@ impl Fold for NextSsg {\n                 });\n \n                 let mut new = Vec::with_capacity(items.len() + 1);\n-                for item in take(&mut items) {\n+                for item in take(items) {\n                     if let ModuleItem::ModuleDecl(\n                         ModuleDecl::ExportNamed(..)\n                         | ModuleDecl::ExportDecl(..)\n@@ -509,15 +483,13 @@ impl Fold for NextSsg {\n                     new.push(item);\n                 }\n \n-                return new;\n+                *items = new;\n             }\n         }\n-\n-        items\n     }\n \n-    fn fold_named_export(&mut self, mut n: NamedExport) -> NamedExport {\n-        n.specifiers = n.specifiers.fold_with(self);\n+    fn visit_mut_named_export(&mut self, n: &mut NamedExport) {\n+        n.specifiers.visit_mut_with(self);\n \n         n.specifiers.retain(|s| {\n             let preserve = match s {\n@@ -563,16 +535,14 @@ impl Fold for NextSsg {\n                 Err(_) => false,\n             }\n         });\n-\n-        n\n     }\n \n     /// This methods returns [Pat::Invalid] if the pattern should be removed.\n-    fn fold_pat(&mut self, mut p: Pat) -> Pat {\n-        p = p.fold_children_with(self);\n+    fn visit_mut_pat(&mut self, p: &mut Pat) {\n+        p.visit_mut_children_with(self);\n \n         if self.in_lhs_of_var {\n-            match &mut p {\n+            match p {\n                 Pat::Ident(name) => {\n                     if self.should_remove(name.id.to_id()) {\n                         self.state.should_run_again = true;\n@@ -582,112 +552,85 @@ impl Fold for NextSsg {\n                             name.id.ctxt\n                         );\n \n-                        return Pat::Invalid(Invalid { span: DUMMY_SP });\n+                        *p = Pat::Invalid(Invalid { span: DUMMY_SP });\n                     }\n                 }\n                 Pat::Array(arr) => {\n                     if !arr.elems.is_empty() {\n                         arr.elems.retain(|e| !matches!(e, Some(Pat::Invalid(..))));\n \n                         if arr.elems.is_empty() {\n-                            return Pat::Invalid(Invalid { span: DUMMY_SP });\n+                            *p = Pat::Invalid(Invalid { span: DUMMY_SP });\n                         }\n                     }\n                 }\n                 Pat::Object(obj) => {\n                     if !obj.props.is_empty() {\n-                        obj.props = take(&mut obj.props)\n-                            .into_iter()\n-                            .filter_map(|prop| match prop {\n-                                ObjectPatProp::KeyValue(prop) => {\n-                                    if prop.value.is_invalid() {\n-                                        None\n-                                    } else {\n-                                        Some(ObjectPatProp::KeyValue(prop))\n-                                    }\n-                                }\n-                                ObjectPatProp::Assign(prop) => {\n-                                    if self.should_remove(prop.key.to_id()) {\n-                                        self.mark_as_candidate(prop.value);\n-\n-                                        None\n-                                    } else {\n-                                        Some(ObjectPatProp::Assign(prop))\n-                                    }\n+                        obj.props.retain_mut(|prop| match prop {\n+                            ObjectPatProp::KeyValue(prop) => !prop.value.is_invalid(),\n+                            ObjectPatProp::Assign(prop) => {\n+                                if self.should_remove(prop.key.to_id()) {\n+                                    self.mark_as_candidate(&mut prop.value);\n+\n+                                    false\n+                                } else {\n+                                    true\n                                 }\n-                                ObjectPatProp::Rest(prop) => {\n-                                    if prop.arg.is_invalid() {\n-                                        None\n-                                    } else {\n-                                        Some(ObjectPatProp::Rest(prop))\n-                                    }\n-                                }\n-                            })\n-                            .collect();\n+                            }\n+                            ObjectPatProp::Rest(prop) => !prop.arg.is_invalid(),\n+                        });\n \n                         if obj.props.is_empty() {\n-                            return Pat::Invalid(Invalid { span: DUMMY_SP });\n+                            *p = Pat::Invalid(Invalid { span: DUMMY_SP });\n                         }\n                     }\n                 }\n                 Pat::Rest(rest) => {\n                     if rest.arg.is_invalid() {\n-                        return Pat::Invalid(Invalid { span: DUMMY_SP });\n+                        *p = Pat::Invalid(Invalid { span: DUMMY_SP });\n                     }\n                 }\n                 _ => {}\n             }\n         }\n-\n-        p\n     }\n \n     #[allow(clippy::single_match)]\n-    fn fold_stmt(&mut self, mut s: Stmt) -> Stmt {\n-        match s {\n-            Stmt::Decl(Decl::Fn(f)) => {\n-                if self.should_remove(f.ident.to_id()) {\n-                    self.mark_as_candidate(f.function);\n-                    return Stmt::Empty(EmptyStmt { span: DUMMY_SP });\n-                }\n-\n-                s = Stmt::Decl(Decl::Fn(f));\n+    fn visit_mut_stmt(&mut self, s: &mut Stmt) {\n+        if let Stmt::Decl(Decl::Fn(f)) = s {\n+            if self.should_remove(f.ident.to_id()) {\n+                self.mark_as_candidate(&mut f.function);\n+                *s = Stmt::Empty(EmptyStmt { span: DUMMY_SP });\n+                return;\n             }\n-            _ => {}\n         }\n \n-        let s = s.fold_children_with(self);\n+        s.visit_mut_children_with(self);\n         match s {\n             Stmt::Decl(Decl::Var(v)) if v.decls.is_empty() => {\n-                return Stmt::Empty(EmptyStmt { span: DUMMY_SP });\n+                *s = Stmt::Empty(EmptyStmt { span: DUMMY_SP });\n             }\n             _ => {}\n         }\n-\n-        s\n     }\n \n     /// This method make `name` of [VarDeclarator] to [Pat::Invalid] if it\n     /// should be removed.\n-    fn fold_var_declarator(&mut self, mut d: VarDeclarator) -> VarDeclarator {\n+    fn visit_mut_var_declarator(&mut self, d: &mut VarDeclarator) {\n         let old = self.in_lhs_of_var;\n         self.in_lhs_of_var = true;\n-        let name = d.name.fold_with(self);\n+        d.name.visit_mut_with(self);\n \n         self.in_lhs_of_var = false;\n-        if name.is_invalid() {\n-            d.init = self.mark_as_candidate(d.init);\n+        if d.name.is_invalid() {\n+            self.mark_as_candidate(&mut d.init);\n         }\n-        let init = d.init.fold_with(self);\n+        d.init.visit_mut_with(self);\n         self.in_lhs_of_var = old;\n-\n-        VarDeclarator { name, init, ..d }\n     }\n \n-    fn fold_var_declarators(&mut self, mut decls: Vec<VarDeclarator>) -> Vec<VarDeclarator> {\n-        decls = decls.fold_children_with(self);\n+    fn visit_mut_var_declarators(&mut self, decls: &mut Vec<VarDeclarator>) {\n+        decls.visit_mut_children_with(self);\n         decls.retain(|d| !d.name.is_invalid());\n-\n-        decls\n     }\n }"
        }
    ],
    "stats": {
        "total": 313,
        "additions": 121,
        "deletions": 192
    }
}