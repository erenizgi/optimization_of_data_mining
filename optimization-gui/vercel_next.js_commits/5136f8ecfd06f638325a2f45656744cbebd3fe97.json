{
    "author": "unstubbable",
    "message": "[dynamicIO] Avoid timeout errors with dynamic params in `\"use cache\"` (#78882)",
    "sha": "5136f8ecfd06f638325a2f45656744cbebd3fe97",
    "files": [
        {
            "sha": "b8d38dfa92379ec59d3725cb29070b1fd2f2f176",
            "filename": ".changeset/tricky-planes-worry.md",
            "status": "added",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/5136f8ecfd06f638325a2f45656744cbebd3fe97/.changeset%2Ftricky-planes-worry.md",
            "raw_url": "https://github.com/vercel/next.js/raw/5136f8ecfd06f638325a2f45656744cbebd3fe97/.changeset%2Ftricky-planes-worry.md",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/.changeset%2Ftricky-planes-worry.md?ref=5136f8ecfd06f638325a2f45656744cbebd3fe97",
            "patch": "@@ -0,0 +1,5 @@\n+---\n+\"next\": patch\n+---\n+\n+[dynamicIO] Avoid timeout errors with dynamic params in `\"use cache\"`"
        },
        {
            "sha": "b195325c3742be060cc487f2e41cbebd03ad1522",
            "filename": ".vscode/settings.json",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/5136f8ecfd06f638325a2f45656744cbebd3fe97/.vscode%2Fsettings.json",
            "raw_url": "https://github.com/vercel/next.js/raw/5136f8ecfd06f638325a2f45656744cbebd3fe97/.vscode%2Fsettings.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/.vscode%2Fsettings.json?ref=5136f8ecfd06f638325a2f45656744cbebd3fe97",
            "patch": "@@ -59,6 +59,7 @@\n     // singleton modules should always use \"*.external\" instead of \"*-instance\"\n     \"packages/next/src/server/app-render/action-async-storage-instance.ts\",\n     \"packages/next/src/server/app-render/after-task-async-storage-instance.ts\",\n+    \"packages/next/src/server/app-render/dynamic-access-async-storage-instance.ts\",\n     \"packages/next/src/server/app-render/work-async-storage-instance.ts\",\n     \"packages/next/src/server/app-render/work-unit-async-storage-instance.ts\",\n     \"packages/next/src/client/components/segment-cache-impl/*\""
        },
        {
            "sha": "e2b659778f996db1adb2cbfe4f7046399e75cdcf",
            "filename": "packages/next/errors.json",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/5136f8ecfd06f638325a2f45656744cbebd3fe97/packages%2Fnext%2Ferrors.json",
            "raw_url": "https://github.com/vercel/next.js/raw/5136f8ecfd06f638325a2f45656744cbebd3fe97/packages%2Fnext%2Ferrors.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Ferrors.json?ref=5136f8ecfd06f638325a2f45656744cbebd3fe97",
            "patch": "@@ -682,5 +682,7 @@\n   \"681\": \"Dynamic imports should not be instrumented in the edge runtime, because `dynamicIO` doesn't support it\",\n   \"682\": \"\\\\`experimental.ppr\\\\` can not be \\\\`%s\\\\` when \\\\`experimental.dynamicIO\\\\` is \\\\`true\\\\`. PPR is implicitly enabled when Dynamic IO is enabled.\",\n   \"683\": \"The \\\\`compiler.define\\\\` option is configured to replace the \\\\`%s\\\\` variable. This variable is either part of a Next.js built-in or is already configured.\",\n-  \"684\": \"The \\\\`compiler.defineServer\\\\` option is configured to replace the \\\\`%s\\\\` variable. This variable is either part of a Next.js built-in or is already configured.\"\n+  \"684\": \"The \\\\`compiler.defineServer\\\\` option is configured to replace the \\\\`%s\\\\` variable. This variable is either part of a Next.js built-in or is already configured.\",\n+  \"685\": \"Accessed fallback \\\\`params\\\\` during prerendering.\",\n+  \"686\": \"Expected clientReferenceManifest to be defined.\"\n }"
        },
        {
            "sha": "f352c723fd8dc32aa7d64680ee76058f54e92543",
            "filename": "packages/next/src/build/index.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/5136f8ecfd06f638325a2f45656744cbebd3fe97/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/5136f8ecfd06f638325a2f45656744cbebd3fe97/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts?ref=5136f8ecfd06f638325a2f45656744cbebd3fe97",
            "patch": "@@ -2683,8 +2683,7 @@ export default async function build(\n                     _isDynamicError: isDynamicError,\n                     _isAppDir: true,\n                     _isRoutePPREnabled: isRoutePPREnabled,\n-                    _doNotThrowOnEmptyStaticShell:\n-                      !route.throwOnEmptyStaticShell,\n+                    _allowEmptyStaticShell: !route.throwOnEmptyStaticShell,\n                   }\n                 })\n               })"
        },
        {
            "sha": "609b7a21651f0ac3949659a01cae712b0179d60a",
            "filename": "packages/next/src/build/webpack-config.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/5136f8ecfd06f638325a2f45656744cbebd3fe97/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack-config.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/5136f8ecfd06f638325a2f45656744cbebd3fe97/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack-config.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack-config.ts?ref=5136f8ecfd06f638325a2f45656744cbebd3fe97",
            "patch": "@@ -133,7 +133,7 @@ const browserNonTranspileModules = [\n const precompileRegex = /[\\\\/]next[\\\\/]dist[\\\\/]compiled[\\\\/]/\n \n const asyncStoragesRegex =\n-  /next[\\\\/]dist[\\\\/](esm[\\\\/])?server[\\\\/]app-render[\\\\/](work-async-storage|action-async-storage|work-unit-async-storage)/\n+  /next[\\\\/]dist[\\\\/](esm[\\\\/])?server[\\\\/]app-render[\\\\/](work-async-storage|action-async-storage|dynamic-access-async-storage|work-unit-async-storage)/\n \n // Support for NODE_PATH\n const nodePathList = (process.env.NODE_PATH || '')"
        },
        {
            "sha": "ee1acdee932f5165b064d53f0c8d85e567b8b8b7",
            "filename": "packages/next/src/export/worker.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/5136f8ecfd06f638325a2f45656744cbebd3fe97/packages%2Fnext%2Fsrc%2Fexport%2Fworker.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/5136f8ecfd06f638325a2f45656744cbebd3fe97/packages%2Fnext%2Fsrc%2Fexport%2Fworker.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fexport%2Fworker.ts?ref=5136f8ecfd06f638325a2f45656744cbebd3fe97",
            "patch": "@@ -104,9 +104,9 @@ async function exportPageImpl(\n     // the renderOpts.\n     _isRoutePPREnabled: isRoutePPREnabled,\n \n-    // Configure the rendering of the page not to throw if an empty static shell\n-    // is generated while rendering using PPR.\n-    _doNotThrowOnEmptyStaticShell: doNotThrowOnEmptyStaticShell = false,\n+    // Configure the rendering of the page to allow that an empty static shell\n+    // is generated while rendering using PPR and Dynamic IO.\n+    _allowEmptyStaticShell: allowEmptyStaticShell = false,\n \n     // Pull the original query out.\n     query: originalQuery = {},\n@@ -266,7 +266,7 @@ async function exportPageImpl(\n     // If it's static, then it won't affect anything.\n     // If it's dynamic, then it can be handled when request hits the route.\n     serveStreamingMetadata: true,\n-    doNotThrowOnEmptyStaticShell,\n+    allowEmptyStaticShell,\n     experimental: {\n       ...input.renderOpts.experimental,\n       isRoutePPREnabled,"
        },
        {
            "sha": "9d8c2f12a56273ce79dd8256daa689f918b9da49",
            "filename": "packages/next/src/server/app-render/app-render.tsx",
            "status": "modified",
            "additions": 187,
            "deletions": 125,
            "changes": 312,
            "blob_url": "https://github.com/vercel/next.js/blob/5136f8ecfd06f638325a2f45656744cbebd3fe97/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/5136f8ecfd06f638325a2f45656744cbebd3fe97/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx?ref=5136f8ecfd06f638325a2f45656744cbebd3fe97",
            "patch": "@@ -190,6 +190,7 @@ import {\n   trackPendingImport,\n   trackPendingModules,\n } from './module-loading/track-module-loading.external'\n+import { isUseCacheTimeoutError } from '../use-cache/use-cache-errors'\n \n export type GetDynamicParamFromSegment = (\n   // [slug] / [[slug]] / [...slug]\n@@ -665,7 +666,9 @@ async function warmupDevRender(\n     workStore,\n   } = ctx\n \n-  if (!renderOpts.dev) {\n+  const { dev, onInstrumentationRequestError } = renderOpts\n+\n+  if (!dev) {\n     throw new InvariantError(\n       'generateDynamicFlightRenderResult should never be called in `next start` mode.'\n     )\n@@ -677,7 +680,7 @@ async function warmupDevRender(\n   )\n \n   function onFlightDataRenderError(err: DigestedError) {\n-    return renderOpts.onInstrumentationRequestError?.(\n+    return onInstrumentationRequestError?.(\n       err,\n       req,\n       createErrorContext(ctx, 'react-server-components-payload')\n@@ -1022,6 +1025,16 @@ async function getErrorRSCPayload(\n   } satisfies InitialRSCPayload\n }\n \n+function assertClientReferenceManifest(\n+  clientReferenceManifest: RenderOpts['clientReferenceManifest']\n+): asserts clientReferenceManifest is NonNullable<\n+  RenderOpts['clientReferenceManifest']\n+> {\n+  if (!clientReferenceManifest) {\n+    throw new InvariantError('Expected clientReferenceManifest to be defined.')\n+  }\n+}\n+\n // This component must run in an SSR context. It will render the RSC root component\n function App<T>({\n   reactServerStream,\n@@ -1183,6 +1196,7 @@ async function renderToHTMLOrFlightImpl(\n   const requestTimestamp = Date.now()\n \n   const {\n+    clientReferenceManifest,\n     serverActionsManifest,\n     ComponentMod,\n     nextFontManifest,\n@@ -1274,8 +1288,7 @@ async function renderToHTMLOrFlightImpl(\n \n   const appUsingSizeAdjustment = !!nextFontManifest?.appUsingSizeAdjust\n \n-  // TODO: fix this typescript\n-  const clientReferenceManifest = renderOpts.clientReferenceManifest!\n+  assertClientReferenceManifest(clientReferenceManifest)\n \n   const serverModuleMap = createServerModuleMap({ serverActionsManifest })\n \n@@ -1729,69 +1742,86 @@ async function renderToStream(\n   formState: any,\n   postponedState: PostponedState | null\n ): Promise<ReadableStream<Uint8Array>> {\n-  const renderOpts = ctx.renderOpts\n-  const ComponentMod = renderOpts.ComponentMod\n-  // TODO: fix this typescript\n-  const clientReferenceManifest = renderOpts.clientReferenceManifest!\n+  const { assetPrefix, nonce, pagePath, renderOpts } = ctx\n+\n+  const {\n+    basePath,\n+    botType,\n+    buildManifest,\n+    clientReferenceManifest,\n+    ComponentMod,\n+    crossOrigin,\n+    dev = false,\n+    experimental,\n+    nextExport = false,\n+    onInstrumentationRequestError,\n+    page,\n+    reactMaxHeadersLength,\n+    shouldWaitOnAllReady,\n+    subresourceIntegrityManifest,\n+    supportsDynamicResponse,\n+  } = renderOpts\n+\n+  assertClientReferenceManifest(clientReferenceManifest)\n \n   const { ServerInsertedHTMLProvider, renderServerInsertedHTML } =\n     createServerInsertedHTML()\n   const { ServerInsertedMetadataProvider, getServerInsertedMetadata } =\n-    createServerInsertedMetadata(ctx.nonce)\n+    createServerInsertedMetadata(nonce)\n \n   const tracingMetadata = getTracedMetadata(\n     getTracer().getTracePropagationData(),\n-    renderOpts.experimental.clientTraceMetadata\n+    experimental.clientTraceMetadata\n   )\n \n   const polyfills: JSX.IntrinsicElements['script'][] =\n-    renderOpts.buildManifest.polyfillFiles\n+    buildManifest.polyfillFiles\n       .filter(\n         (polyfill) =>\n           polyfill.endsWith('.js') && !polyfill.endsWith('.module.js')\n       )\n       .map((polyfill) => ({\n-        src: `${ctx.assetPrefix}/_next/${polyfill}${getAssetQueryString(\n+        src: `${assetPrefix}/_next/${polyfill}${getAssetQueryString(\n           ctx,\n           false\n         )}`,\n-        integrity: renderOpts.subresourceIntegrityManifest?.[polyfill],\n-        crossOrigin: renderOpts.crossOrigin,\n+        integrity: subresourceIntegrityManifest?.[polyfill],\n+        crossOrigin,\n         noModule: true,\n-        nonce: ctx.nonce,\n+        nonce,\n       }))\n \n   const [preinitScripts, bootstrapScript] = getRequiredScripts(\n-    renderOpts.buildManifest,\n+    buildManifest,\n     // Why is assetPrefix optional on renderOpts?\n     // @TODO make it default empty string on renderOpts and get rid of it from ctx\n-    ctx.assetPrefix,\n-    renderOpts.crossOrigin,\n-    renderOpts.subresourceIntegrityManifest,\n+    assetPrefix,\n+    crossOrigin,\n+    subresourceIntegrityManifest,\n     getAssetQueryString(ctx, true),\n-    ctx.nonce,\n-    renderOpts.page\n+    nonce,\n+    page\n   )\n \n   const reactServerErrorsByDigest: Map<string, DigestedError> = new Map()\n   const silenceLogger = false\n   function onHTMLRenderRSCError(err: DigestedError) {\n-    return renderOpts.onInstrumentationRequestError?.(\n+    return onInstrumentationRequestError?.(\n       err,\n       req,\n       createErrorContext(ctx, 'react-server-components')\n     )\n   }\n   const serverComponentsErrorHandler = createHTMLReactServerErrorHandler(\n-    !!renderOpts.dev,\n-    !!renderOpts.nextExport,\n+    dev,\n+    nextExport,\n     reactServerErrorsByDigest,\n     silenceLogger,\n     onHTMLRenderRSCError\n   )\n \n   function onHTMLRenderSSRError(err: DigestedError) {\n-    return renderOpts.onInstrumentationRequestError?.(\n+    return onInstrumentationRequestError?.(\n       err,\n       req,\n       createErrorContext(ctx, 'server-rendering')\n@@ -1800,8 +1830,8 @@ async function renderToStream(\n \n   const allCapturedErrors: Array<unknown> = []\n   const htmlRendererErrorHandler = createHTMLErrorHandler(\n-    !!renderOpts.dev,\n-    !!renderOpts.nextExport,\n+    dev,\n+    nextExport,\n     reactServerErrorsByDigest,\n     allCapturedErrors,\n     silenceLogger,\n@@ -1816,13 +1846,13 @@ async function renderToStream(\n   try {\n     if (\n       // We only want this behavior when running `next dev`\n-      renderOpts.dev &&\n+      dev &&\n       // We only want this behavior when we have React's dev builds available\n       process.env.NODE_ENV === 'development' &&\n       // Edge routes never prerender so we don't have a Prerender environment for anything in edge runtime\n       process.env.NEXT_RUNTIME !== 'edge' &&\n       // We only have a Prerender environment for projects opted into dynamicIO\n-      renderOpts.experimental.dynamicIO\n+      experimental.dynamicIO\n     ) {\n       // This is a dynamic render. We don't do dynamic tracking because we're not prerendering\n       const RSCPayload: InitialRSCPayload & {\n@@ -1911,7 +1941,7 @@ async function renderToStream(\n         // in the static prelude.\n         const inlinedReactServerDataStream = createInlinedDataReadableStream(\n           reactServerResult.tee(),\n-          ctx.nonce,\n+          nonce,\n           formState\n         )\n \n@@ -1935,27 +1965,24 @@ async function renderToStream(\n             clientReferenceManifest={clientReferenceManifest}\n             ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n             ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n-            nonce={ctx.nonce}\n-            gracefullyDegrade={!!ctx.renderOpts.botType}\n+            nonce={nonce}\n+            gracefullyDegrade={!!botType}\n           />,\n           postponed,\n-          {\n-            onError: htmlRendererErrorHandler,\n-            nonce: ctx.nonce,\n-          }\n+          { onError: htmlRendererErrorHandler, nonce }\n         )\n \n         const getServerInsertedHTML = makeGetServerInsertedHTML({\n           polyfills,\n           renderServerInsertedHTML,\n           serverCapturedErrors: allCapturedErrors,\n-          basePath: renderOpts.basePath,\n+          basePath,\n           tracingMetadata: tracingMetadata,\n         })\n         return await continueDynamicHTMLResume(htmlStream, {\n           inlinedDataStream: createInlinedDataReadableStream(\n             reactServerResult.consume(),\n-            ctx.nonce,\n+            nonce,\n             formState\n           ),\n           getServerInsertedHTML,\n@@ -1977,18 +2004,18 @@ async function renderToStream(\n         clientReferenceManifest={clientReferenceManifest}\n         ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n         ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n-        gracefullyDegrade={!!ctx.renderOpts.botType}\n-        nonce={ctx.nonce}\n+        gracefullyDegrade={!!botType}\n+        nonce={nonce}\n       />,\n       {\n         onError: htmlRendererErrorHandler,\n-        nonce: ctx.nonce,\n+        nonce,\n         onHeaders: (headers: Headers) => {\n           headers.forEach((value, key) => {\n             appendHeader(key, value)\n           })\n         },\n-        maxHeadersLength: renderOpts.reactMaxHeadersLength,\n+        maxHeadersLength: reactMaxHeadersLength,\n         bootstrapScripts: [bootstrapScript],\n         formState,\n       }\n@@ -1998,7 +2025,7 @@ async function renderToStream(\n       polyfills,\n       renderServerInsertedHTML,\n       serverCapturedErrors: allCapturedErrors,\n-      basePath: renderOpts.basePath,\n+      basePath,\n       tracingMetadata: tracingMetadata,\n     })\n     /**\n@@ -2019,20 +2046,18 @@ async function renderToStream(\n      * coalescing, and ISR continue working as intended.\n      */\n     const generateStaticHTML =\n-      renderOpts.supportsDynamicResponse !== true ||\n-      !!renderOpts.shouldWaitOnAllReady\n+      supportsDynamicResponse !== true || !!shouldWaitOnAllReady\n \n-    const validateRootLayout = renderOpts.dev\n     return await continueFizzStream(htmlStream, {\n       inlinedDataStream: createInlinedDataReadableStream(\n         reactServerResult.consume(),\n-        ctx.nonce,\n+        nonce,\n         formState\n       ),\n       isStaticGeneration: generateStaticHTML,\n       getServerInsertedHTML,\n       getServerInsertedMetadata,\n-      validateRootLayout,\n+      validateRootLayout: dev,\n     })\n   } catch (err) {\n     if (\n@@ -2055,7 +2080,7 @@ async function renderToStream(\n     if (shouldBailoutToCSR) {\n       const stack = getStackWithoutErrorMessage(err)\n       error(\n-        `${err.reason} should be wrapped in a suspense boundary at page \"${ctx.pagePath}\". Read more: https://nextjs.org/docs/messages/missing-suspense-with-csr-bailout\\n${stack}`\n+        `${err.reason} should be wrapped in a suspense boundary at page \"${pagePath}\". Read more: https://nextjs.org/docs/messages/missing-suspense-with-csr-bailout\\n${stack}`\n       )\n \n       throw err\n@@ -2070,10 +2095,7 @@ async function renderToStream(\n       errorType = 'redirect'\n       res.statusCode = getRedirectStatusCodeFromError(err)\n \n-      const redirectUrl = addPathPrefix(\n-        getURLFromRedirectError(err),\n-        renderOpts.basePath\n-      )\n+      const redirectUrl = addPathPrefix(getURLFromRedirectError(err), basePath)\n \n       // If there were mutable cookies set, we need to set them on the\n       // response.\n@@ -2088,12 +2110,12 @@ async function renderToStream(\n     }\n \n     const [errorPreinitScripts, errorBootstrapScript] = getRequiredScripts(\n-      renderOpts.buildManifest,\n-      ctx.assetPrefix,\n-      renderOpts.crossOrigin,\n-      renderOpts.subresourceIntegrityManifest,\n+      buildManifest,\n+      assetPrefix,\n+      crossOrigin,\n+      subresourceIntegrityManifest,\n       getAssetQueryString(ctx, false),\n-      ctx.nonce,\n+      nonce,\n       '/_not-found/page'\n     )\n \n@@ -2135,12 +2157,12 @@ async function renderToStream(\n               ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n               preinitScripts={errorPreinitScripts}\n               clientReferenceManifest={clientReferenceManifest}\n-              gracefullyDegrade={!!ctx.renderOpts.botType}\n-              nonce={ctx.nonce}\n+              gracefullyDegrade={!!botType}\n+              nonce={nonce}\n             />\n           ),\n           streamOptions: {\n-            nonce: ctx.nonce,\n+            nonce,\n             // Include hydration scripts in the HTML\n             bootstrapScripts: [errorBootstrapScript],\n             formState,\n@@ -2165,28 +2187,26 @@ async function renderToStream(\n        * coalescing, and ISR continue working as intended.\n        */\n       const generateStaticHTML =\n-        renderOpts.supportsDynamicResponse !== true ||\n-        !!renderOpts.shouldWaitOnAllReady\n-      const validateRootLayout = renderOpts.dev\n+        supportsDynamicResponse !== true || !!shouldWaitOnAllReady\n       return await continueFizzStream(fizzStream, {\n         inlinedDataStream: createInlinedDataReadableStream(\n           // This is intentionally using the readable datastream from the\n           // main render rather than the flight data from the error page\n           // render\n           reactServerResult.consume(),\n-          ctx.nonce,\n+          nonce,\n           formState\n         ),\n         isStaticGeneration: generateStaticHTML,\n         getServerInsertedHTML: makeGetServerInsertedHTML({\n           polyfills,\n           renderServerInsertedHTML,\n           serverCapturedErrors: [],\n-          basePath: renderOpts.basePath,\n+          basePath,\n           tracingMetadata: tracingMetadata,\n         }),\n         getServerInsertedMetadata,\n-        validateRootLayout,\n+        validateRootLayout: dev,\n       })\n     } catch (finalErr: any) {\n       if (\n@@ -2218,10 +2238,20 @@ async function spawnDynamicValidationInDev(\n   clientReferenceManifest: NonNullable<RenderOpts['clientReferenceManifest']>,\n   requestStore: RequestStore\n ): Promise<void> {\n-  const { componentMod: ComponentMod, implicitTags, workStore } = ctx\n+  const {\n+    componentMod: ComponentMod,\n+    getDynamicParamFromSegment,\n+    implicitTags,\n+    nonce,\n+    renderOpts,\n+    workStore,\n+  } = ctx\n+\n+  const { botType } = renderOpts\n+\n   const rootParams = getRootParams(\n     ComponentMod.tree,\n-    ctx.getDynamicParamFromSegment\n+    getDynamicParamFromSegment\n   )\n \n   const hmrRefreshHash = requestStore.cookies.get(\n@@ -2334,7 +2364,6 @@ async function spawnDynamicValidationInDev(\n     }\n   }\n \n-  const nonce = '1'\n   const { ServerInsertedHTMLProvider } = createServerInsertedHTML()\n   const { ServerInsertedMetadataProvider } = createServerInsertedMetadata(nonce)\n \n@@ -2350,7 +2379,7 @@ async function spawnDynamicValidationInDev(\n         clientReferenceManifest={clientReferenceManifest}\n         ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n         ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n-        gracefullyDegrade={!!ctx.renderOpts.botType}\n+        gracefullyDegrade={!!botType}\n         nonce={nonce}\n       />,\n       {\n@@ -2496,8 +2525,8 @@ async function spawnDynamicValidationInDev(\n             clientReferenceManifest={clientReferenceManifest}\n             ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n             ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n-            gracefullyDegrade={!!ctx.renderOpts.botType}\n-            nonce={ctx.nonce}\n+            gracefullyDegrade={!!botType}\n+            nonce={nonce}\n           />,\n           {\n             signal: finalClientController.signal,\n@@ -2613,10 +2642,27 @@ async function prerenderToStream(\n     workStore,\n   } = ctx\n \n+  const {\n+    allowEmptyStaticShell = false,\n+    basePath,\n+    botType,\n+    buildManifest,\n+    clientReferenceManifest,\n+    ComponentMod,\n+    crossOrigin,\n+    dev = false,\n+    experimental,\n+    isDebugDynamicAccesses,\n+    nextExport = false,\n+    onInstrumentationRequestError,\n+    page,\n+    reactMaxHeadersLength,\n+    subresourceIntegrityManifest,\n+  } = renderOpts\n+\n+  assertClientReferenceManifest(clientReferenceManifest)\n+\n   const rootParams = getRootParams(tree, getDynamicParamFromSegment)\n-  const ComponentMod = renderOpts.ComponentMod\n-  // TODO: fix this typescript\n-  const clientReferenceManifest = renderOpts.clientReferenceManifest!\n   const fallbackRouteParams = workStore.fallbackRouteParams\n \n   const { ServerInsertedHTMLProvider, renderServerInsertedHTML } =\n@@ -2626,11 +2672,11 @@ async function prerenderToStream(\n \n   const tracingMetadata = getTracedMetadata(\n     getTracer().getTracePropagationData(),\n-    renderOpts.experimental.clientTraceMetadata\n+    experimental.clientTraceMetadata\n   )\n \n   const polyfills: JSX.IntrinsicElements['script'][] =\n-    renderOpts.buildManifest.polyfillFiles\n+    buildManifest.polyfillFiles\n       .filter(\n         (polyfill) =>\n           polyfill.endsWith('.js') && !polyfill.endsWith('.module.js')\n@@ -2640,53 +2686,53 @@ async function prerenderToStream(\n           ctx,\n           false\n         )}`,\n-        integrity: renderOpts.subresourceIntegrityManifest?.[polyfill],\n-        crossOrigin: renderOpts.crossOrigin,\n+        integrity: subresourceIntegrityManifest?.[polyfill],\n+        crossOrigin,\n         noModule: true,\n-        nonce: nonce,\n+        nonce,\n       }))\n \n   const [preinitScripts, bootstrapScript] = getRequiredScripts(\n-    renderOpts.buildManifest,\n+    buildManifest,\n     // Why is assetPrefix optional on renderOpts?\n     // @TODO make it default empty string on renderOpts and get rid of it from ctx\n     assetPrefix,\n-    renderOpts.crossOrigin,\n-    renderOpts.subresourceIntegrityManifest,\n+    crossOrigin,\n+    subresourceIntegrityManifest,\n     getAssetQueryString(ctx, true),\n     nonce,\n-    renderOpts.page\n+    page\n   )\n \n   const reactServerErrorsByDigest: Map<string, DigestedError> = new Map()\n   // We don't report errors during prerendering through our instrumentation hooks\n-  const silenceLogger = !!renderOpts.experimental.isRoutePPREnabled\n+  const silenceLogger = !!experimental.isRoutePPREnabled\n   function onHTMLRenderRSCError(err: DigestedError) {\n-    return renderOpts.onInstrumentationRequestError?.(\n+    return onInstrumentationRequestError?.(\n       err,\n       req,\n       createErrorContext(ctx, 'react-server-components')\n     )\n   }\n   const serverComponentsErrorHandler = createHTMLReactServerErrorHandler(\n-    !!renderOpts.dev,\n-    !!renderOpts.nextExport,\n+    dev,\n+    nextExport,\n     reactServerErrorsByDigest,\n     silenceLogger,\n     onHTMLRenderRSCError\n   )\n \n   function onHTMLRenderSSRError(err: DigestedError) {\n-    return renderOpts.onInstrumentationRequestError?.(\n+    return onInstrumentationRequestError?.(\n       err,\n       req,\n       createErrorContext(ctx, 'server-rendering')\n     )\n   }\n   const allCapturedErrors: Array<unknown> = []\n   const htmlRendererErrorHandler = createHTMLErrorHandler(\n-    !!renderOpts.dev,\n-    !!renderOpts.nextExport,\n+    dev,\n+    nextExport,\n     reactServerErrorsByDigest,\n     allCapturedErrors,\n     silenceLogger,\n@@ -2719,14 +2765,14 @@ async function prerenderToStream(\n \n   const selectStaleTime = (stale: number) =>\n     stale === INFINITE_CACHE &&\n-    typeof renderOpts.experimental.staleTimes?.static === 'number'\n-      ? renderOpts.experimental.staleTimes.static\n+    typeof experimental.staleTimes?.static === 'number'\n+      ? experimental.staleTimes.static\n       : stale\n \n   let prerenderStore: PrerenderStore | null = null\n \n   try {\n-    if (renderOpts.experimental.dynamicIO) {\n+    if (experimental.dynamicIO) {\n       /**\n        * dynamicIO with PPR\n        *\n@@ -2833,6 +2879,29 @@ async function prerenderToStream(\n       // We don't need to continue the prerender process if we already\n       // detected invalid dynamic usage in the initial prerender phase.\n       if (workStore.invalidDynamicUsageError) {\n+        if (\n+          isUseCacheTimeoutError(workStore.invalidDynamicUsageError) &&\n+          allowEmptyStaticShell\n+        ) {\n+          // If this is a \"use cache\" timeout error, and empty shells are\n+          // allowed (i.e. we're prerendering a fallback shell, and there are\n+          // also more specific routes prerendered) we return an empty shell.\n+          return {\n+            digestErrorsMap: reactServerErrorsByDigest,\n+            ssrErrors: allCapturedErrors,\n+            stream: new ReadableStream({\n+              start(controller) {\n+                controller.close()\n+              },\n+            }),\n+            collectedRevalidate: INFINITE_CACHE,\n+            collectedExpire: INFINITE_CACHE,\n+            collectedStale: selectStaleTime(INFINITE_CACHE),\n+            collectedTags: null,\n+          }\n+        }\n+\n+        // Otherwise we throw the error to fail the build.\n         throw workStore.invalidDynamicUsageError\n       }\n \n@@ -2887,7 +2956,7 @@ async function prerenderToStream(\n             clientReferenceManifest={clientReferenceManifest}\n             ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n             ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n-            gracefullyDegrade={!!ctx.renderOpts.botType}\n+            gracefullyDegrade={!!botType}\n             nonce={nonce}\n           />,\n           {\n@@ -2940,7 +3009,7 @@ async function prerenderToStream(\n       let serverIsDynamic = false\n       const finalServerController = new AbortController()\n       const serverDynamicTracking = createDynamicTrackingState(\n-        renderOpts.isDebugDynamicAccesses\n+        isDebugDynamicAccesses\n       )\n \n       const finalRenderPrerenderStore: PrerenderStore = (prerenderStore = {\n@@ -3010,7 +3079,7 @@ async function prerenderToStream(\n         ))\n \n       const clientDynamicTracking = createDynamicTrackingState(\n-        renderOpts.isDebugDynamicAccesses\n+        isDebugDynamicAccesses\n       )\n       const finalClientController = new AbortController()\n       const finalClientPrerenderStore: PrerenderStore = {\n@@ -3048,7 +3117,7 @@ async function prerenderToStream(\n                 clientReferenceManifest={clientReferenceManifest}\n                 ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n                 ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n-                gracefullyDegrade={!!ctx.renderOpts.botType}\n+                gracefullyDegrade={!!botType}\n                 nonce={nonce}\n               />,\n               {\n@@ -3080,7 +3149,7 @@ async function prerenderToStream(\n                     appendHeader(key, value)\n                   })\n                 },\n-                maxHeadersLength: renderOpts.reactMaxHeadersLength,\n+                maxHeadersLength: reactMaxHeadersLength,\n                 bootstrapScripts: [bootstrapScript],\n               }\n             ),\n@@ -3095,7 +3164,7 @@ async function prerenderToStream(\n       // If we've disabled throwing on empty static shell, then we don't need to\n       // track any dynamic access that occurs above the suspense boundary because\n       // we'll do so in the route shell.\n-      if (!ctx.renderOpts.doNotThrowOnEmptyStaticShell) {\n+      if (!allowEmptyStaticShell) {\n         throwIfDisallowedDynamic(\n           workStore,\n           preludeIsEmpty,\n@@ -3109,7 +3178,7 @@ async function prerenderToStream(\n         polyfills,\n         renderServerInsertedHTML,\n         serverCapturedErrors: allCapturedErrors,\n-        basePath: renderOpts.basePath,\n+        basePath,\n         tracingMetadata: tracingMetadata,\n       })\n \n@@ -3181,7 +3250,7 @@ async function prerenderToStream(\n               clientReferenceManifest={clientReferenceManifest}\n               ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n               ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n-              gracefullyDegrade={!!ctx.renderOpts.botType}\n+              gracefullyDegrade={!!botType}\n               nonce={nonce}\n             />,\n             JSON.parse(JSON.stringify(postponed)),\n@@ -3219,11 +3288,9 @@ async function prerenderToStream(\n           collectedTags: finalRenderPrerenderStore.tags,\n         }\n       }\n-    } else if (renderOpts.experimental.isRoutePPREnabled) {\n+    } else if (experimental.isRoutePPREnabled) {\n       // We're statically generating with PPR and need to do dynamic tracking\n-      let dynamicTracking = createDynamicTrackingState(\n-        renderOpts.isDebugDynamicAccesses\n-      )\n+      let dynamicTracking = createDynamicTrackingState(isDebugDynamicAccesses)\n \n       const prerenderResumeDataCache = createPrerenderResumeDataCache()\n       const reactServerPrerenderStore: PrerenderStore = (prerenderStore = {\n@@ -3282,7 +3349,7 @@ async function prerenderToStream(\n           clientReferenceManifest={clientReferenceManifest}\n           ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n           ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n-          gracefullyDegrade={!!ctx.renderOpts.botType}\n+          gracefullyDegrade={!!botType}\n           nonce={nonce}\n         />,\n         {\n@@ -3292,15 +3359,15 @@ async function prerenderToStream(\n               appendHeader(key, value)\n             })\n           },\n-          maxHeadersLength: renderOpts.reactMaxHeadersLength,\n+          maxHeadersLength: reactMaxHeadersLength,\n           bootstrapScripts: [bootstrapScript],\n         }\n       )\n       const getServerInsertedHTML = makeGetServerInsertedHTML({\n         polyfills,\n         renderServerInsertedHTML,\n         serverCapturedErrors: allCapturedErrors,\n-        basePath: renderOpts.basePath,\n+        basePath,\n         tracingMetadata: tracingMetadata,\n       })\n \n@@ -3415,7 +3482,7 @@ async function prerenderToStream(\n               clientReferenceManifest={clientReferenceManifest}\n               ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n               ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n-              gracefullyDegrade={!!ctx.renderOpts.botType}\n+              gracefullyDegrade={!!botType}\n               nonce={nonce}\n             />,\n             JSON.parse(JSON.stringify(postponed)),\n@@ -3495,7 +3562,7 @@ async function prerenderToStream(\n           clientReferenceManifest={clientReferenceManifest}\n           ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n           ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n-          gracefullyDegrade={!!ctx.renderOpts.botType}\n+          gracefullyDegrade={!!botType}\n           nonce={nonce}\n         />,\n         {\n@@ -3521,7 +3588,7 @@ async function prerenderToStream(\n         polyfills,\n         renderServerInsertedHTML,\n         serverCapturedErrors: allCapturedErrors,\n-        basePath: renderOpts.basePath,\n+        basePath,\n         tracingMetadata: tracingMetadata,\n       })\n       return {\n@@ -3592,21 +3659,18 @@ async function prerenderToStream(\n       errorType = 'redirect'\n       res.statusCode = getRedirectStatusCodeFromError(err)\n \n-      const redirectUrl = addPathPrefix(\n-        getURLFromRedirectError(err),\n-        renderOpts.basePath\n-      )\n+      const redirectUrl = addPathPrefix(getURLFromRedirectError(err), basePath)\n \n       setHeader('location', redirectUrl)\n     } else if (!shouldBailoutToCSR) {\n       res.statusCode = 500\n     }\n \n     const [errorPreinitScripts, errorBootstrapScript] = getRequiredScripts(\n-      renderOpts.buildManifest,\n+      buildManifest,\n       assetPrefix,\n-      renderOpts.crossOrigin,\n-      renderOpts.subresourceIntegrityManifest,\n+      crossOrigin,\n+      subresourceIntegrityManifest,\n       getAssetQueryString(ctx, false),\n       nonce,\n       '/_not-found/page'\n@@ -3660,7 +3724,7 @@ async function prerenderToStream(\n             ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n             preinitScripts={errorPreinitScripts}\n             clientReferenceManifest={clientReferenceManifest}\n-            gracefullyDegrade={!!ctx.renderOpts.botType}\n+            gracefullyDegrade={!!botType}\n             nonce={nonce}\n           />\n         ),\n@@ -3686,8 +3750,6 @@ async function prerenderToStream(\n         )\n       }\n \n-      const validateRootLayout = renderOpts.dev\n-\n       // This is intentionally using the readable datastream from the main\n       // render rather than the flight data from the error page render\n       const flightStream =\n@@ -3711,11 +3773,11 @@ async function prerenderToStream(\n             polyfills,\n             renderServerInsertedHTML,\n             serverCapturedErrors: [],\n-            basePath: renderOpts.basePath,\n+            basePath,\n             tracingMetadata: tracingMetadata,\n           }),\n           getServerInsertedMetadata,\n-          validateRootLayout,\n+          validateRootLayout: dev,\n         }),\n         dynamicAccess: null,\n         collectedRevalidate:"
        },
        {
            "sha": "7d5e6e326a311089345322ee4aa122d2ce63b250",
            "filename": "packages/next/src/server/app-render/create-component-tree.tsx",
            "status": "modified",
            "additions": 34,
            "deletions": 19,
            "changes": 53,
            "blob_url": "https://github.com/vercel/next.js/blob/5136f8ecfd06f638325a2f45656744cbebd3fe97/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcreate-component-tree.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/5136f8ecfd06f638325a2f45656744cbebd3fe97/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcreate-component-tree.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcreate-component-tree.tsx?ref=5136f8ecfd06f638325a2f45656744cbebd3fe97",
            "patch": "@@ -21,7 +21,10 @@ import type { LoadingModuleData } from '../../shared/lib/app-router-context.shar\n import type { Params } from '../request/params'\n import { workUnitAsyncStorage } from './work-unit-async-storage.external'\n import { OUTLET_BOUNDARY_NAME } from '../../lib/metadata/metadata-constants'\n-import type { UseCachePageComponentProps } from '../use-cache/use-cache-wrapper'\n+import type {\n+  UseCacheLayoutComponentProps,\n+  UseCachePageComponentProps,\n+} from '../use-cache/use-cache-wrapper'\n \n /**\n  * Use the provided loader tree to create the React Component tree.\n@@ -677,16 +680,21 @@ async function createComponentTreeInternal({\n         workStore\n       )\n \n-      // TODO(useCache): Should we use this trick also if dynamicIO is enabled,\n-      // instead of relying on the searchParams being a hanging promise?\n-      if (!experimental.dynamicIO && isUseCacheFunction(PageComponent)) {\n+      // If we are passing searchParams to a server component Page we need to\n+      // track their usage in case the current render mode tracks dynamic API\n+      // usage.\n+      let searchParams = createServerSearchParamsForServerPage(query, workStore)\n+\n+      if (isUseCacheFunction(PageComponent)) {\n         const UseCachePageComponent: React.ComponentType<UseCachePageComponentProps> =\n           PageComponent\n \n-        // The \"use cache\" wrapper takes care of converting this into an\n-        // erroring search params promise when passing it to the original\n-        // function.\n-        const searchParams = Promise.resolve({})\n+        if (!experimental.dynamicIO) {\n+          // The \"use cache\" wrapper takes care of converting this into an\n+          // erroring search params promise when passing it to the original\n+          // function.\n+          searchParams = Promise.resolve({})\n+        }\n \n         pageElement = (\n           <UseCachePageComponent\n@@ -696,14 +704,6 @@ async function createComponentTreeInternal({\n           />\n         )\n       } else {\n-        // If we are passing searchParams to a server component Page we need to\n-        // track their usage in case the current render mode tracks dynamic API\n-        // usage.\n-        const searchParams = createServerSearchParamsForServerPage(\n-          query,\n-          workStore\n-        )\n-\n         pageElement = (\n           <PageComponent params={params} searchParams={searchParams} />\n         )\n@@ -845,9 +845,24 @@ async function createComponentTreeInternal({\n         workStore\n       )\n \n-      let serverSegment = (\n-        <SegmentComponent {...parallelRouteProps} params={params} />\n-      )\n+      let serverSegment: React.ReactNode\n+\n+      if (isUseCacheFunction(SegmentComponent)) {\n+        const UseCacheLayoutComponent: React.ComponentType<UseCacheLayoutComponentProps> =\n+          SegmentComponent\n+\n+        serverSegment = (\n+          <UseCacheLayoutComponent\n+            {...parallelRouteProps}\n+            params={params}\n+            $$isLayoutComponent\n+          />\n+        )\n+      } else {\n+        serverSegment = (\n+          <SegmentComponent {...parallelRouteProps} params={params} />\n+        )\n+      }\n \n       if (isRootLayoutWithChildrenSlotAndAtLeastOneMoreSlot) {\n         // TODO-APP: This is a hack to support unmatched parallel routes, which will throw `notFound()`."
        },
        {
            "sha": "4364e4447ae21edcdebf2ba98a2d0fb0c0f72e19",
            "filename": "packages/next/src/server/app-render/dynamic-access-async-storage-instance.ts",
            "status": "added",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/5136f8ecfd06f638325a2f45656744cbebd3fe97/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fdynamic-access-async-storage-instance.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/5136f8ecfd06f638325a2f45656744cbebd3fe97/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fdynamic-access-async-storage-instance.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fdynamic-access-async-storage-instance.ts?ref=5136f8ecfd06f638325a2f45656744cbebd3fe97",
            "patch": "@@ -0,0 +1,5 @@\n+import { createAsyncLocalStorage } from './async-local-storage'\n+import type { DynamicAccessStorage } from './dynamic-access-async-storage.external'\n+\n+export const dynamicAccessAsyncStorageInstance: DynamicAccessStorage =\n+  createAsyncLocalStorage()"
        },
        {
            "sha": "b1e39da00050c8f85561fb457f7b993a6cd40c20",
            "filename": "packages/next/src/server/app-render/dynamic-access-async-storage.external.ts",
            "status": "added",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/5136f8ecfd06f638325a2f45656744cbebd3fe97/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fdynamic-access-async-storage.external.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/5136f8ecfd06f638325a2f45656744cbebd3fe97/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fdynamic-access-async-storage.external.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fdynamic-access-async-storage.external.ts?ref=5136f8ecfd06f638325a2f45656744cbebd3fe97",
            "patch": "@@ -0,0 +1,11 @@\n+import type { AsyncLocalStorage } from 'async_hooks'\n+\n+// Share the instance module in the next-shared layer\n+import { dynamicAccessAsyncStorageInstance } from './dynamic-access-async-storage-instance' with { 'turbopack-transition': 'next-shared' }\n+\n+export interface DynamicAccessAsyncStore {\n+  readonly abortController: AbortController\n+}\n+\n+export type DynamicAccessStorage = AsyncLocalStorage<DynamicAccessAsyncStore>\n+export { dynamicAccessAsyncStorageInstance as dynamicAccessAsyncStorage }"
        },
        {
            "sha": "d9684dddfc74e9ddd102b57bef374f6383ccb6a4",
            "filename": "packages/next/src/server/app-render/types.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 4,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/5136f8ecfd06f638325a2f45656744cbebd3fe97/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Ftypes.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/5136f8ecfd06f638325a2f45656744cbebd3fe97/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Ftypes.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Ftypes.ts?ref=5136f8ecfd06f638325a2f45656744cbebd3fe97",
            "patch": "@@ -269,11 +269,12 @@ export interface RenderOptsPartial {\n   isStaticGeneration?: boolean\n \n   /**\n-   * When true, the page will be rendered using the static rendering to detect\n-   * any dynamic API's that would have stopped the page from being fully\n-   * statically generated.\n+   * When true, the page is prerendered as a fallback shell, while allowing any\n+   * dynamic accesses to result in an empty shell. This is the case when there\n+   * are also routes prerendered with a more complete set of params.\n+   * Prerendering those routes would catch any invalid dynamic accesses.\n    */\n-  doNotThrowOnEmptyStaticShell?: boolean\n+  allowEmptyStaticShell?: boolean\n \n   /**\n    * next config experimental.devtoolSegmentExplorer"
        },
        {
            "sha": "239bb196ce88fb3ea06f326a28ed384adfdd61a3",
            "filename": "packages/next/src/server/app-render/work-unit-async-storage.external.ts",
            "status": "modified",
            "additions": 12,
            "deletions": 8,
            "changes": 20,
            "blob_url": "https://github.com/vercel/next.js/blob/5136f8ecfd06f638325a2f45656744cbebd3fe97/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwork-unit-async-storage.external.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/5136f8ecfd06f638325a2f45656744cbebd3fe97/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwork-unit-async-storage.external.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwork-unit-async-storage.external.ts?ref=5136f8ecfd06f638325a2f45656744cbebd3fe97",
            "patch": "@@ -163,6 +163,11 @@ export interface CommonCacheStore\n    * from which implicit tags could be inherited.\n    */\n   readonly implicitTags: ImplicitTags | undefined\n+  /**\n+   * Draft mode is only available if the outer work unit store is a request\n+   * store and draft mode is enabled.\n+   */\n+  readonly draftMode: DraftModeProvider | undefined\n }\n \n export interface UseCacheStore extends CommonCacheStore {\n@@ -179,21 +184,20 @@ export interface UseCacheStore extends CommonCacheStore {\n   readonly isHmrRefresh: boolean\n   readonly serverComponentsHmrCache: ServerComponentsHmrCache | undefined\n   readonly forceRevalidate: boolean\n-  // Draft mode is only available if the outer work unit store is a request\n-  // store and draft mode is enabled.\n-  readonly draftMode: DraftModeProvider | undefined\n }\n \n export interface UnstableCacheStore extends CommonCacheStore {\n   type: 'unstable-cache'\n-  // Draft mode is only available if the outer work unit store is a request\n-  // store and draft mode is enabled.\n-  readonly draftMode: DraftModeProvider | undefined\n }\n \n /**\n- * The Cache store is for tracking information inside a \"use cache\" or unstable_cache context.\n- * Inside this context we should never expose any request or page specific information.\n+ * The Cache store is for tracking information inside a \"use cache\" or\n+ * unstable_cache context. A cache store shadows an outer request store (if\n+ * present) as a work unit, so that we never accidentally expose any request or\n+ * page specific information to cache functions, unless it's explicitly desired.\n+ * For those exceptions, the data is copied over from the request store to the\n+ * cache store, instead of generally making the request store available to cache\n+ * functions.\n  */\n export type CacheStore = UseCacheStore | UnstableCacheStore\n "
        },
        {
            "sha": "e0800f749b8525e279987d7dcb9ff478699f33f1",
            "filename": "packages/next/src/server/config-schema.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/5136f8ecfd06f638325a2f45656744cbebd3fe97/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-schema.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/5136f8ecfd06f638325a2f45656744cbebd3fe97/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-schema.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-schema.ts?ref=5136f8ecfd06f638325a2f45656744cbebd3fe97",
            "patch": "@@ -41,7 +41,7 @@ const zExportMap: zod.ZodType<ExportPathMap> = z.record(\n     _isAppDir: z.boolean().optional(),\n     _isDynamicError: z.boolean().optional(),\n     _isRoutePPREnabled: z.boolean().optional(),\n-    _doNotThrowOnEmptyStaticShell: z.boolean().optional(),\n+    _allowEmptyStaticShell: z.boolean().optional(),\n   })\n )\n "
        },
        {
            "sha": "529ea5fce298c8fcde8d6d869f943b6f778f78de",
            "filename": "packages/next/src/server/config-shared.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 4,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/5136f8ecfd06f638325a2f45656744cbebd3fe97/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/5136f8ecfd06f638325a2f45656744cbebd3fe97/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts?ref=5136f8ecfd06f638325a2f45656744cbebd3fe97",
            "patch": "@@ -750,13 +750,15 @@ export type ExportPathMap = {\n     _isRoutePPREnabled?: boolean\n \n     /**\n-     * When true, it indicates that the diagnostic render for this page is\n-     * disabled. This is only used when the app has `experimental.ppr` and\n-     * `experimental.dynamicIO` enabled.\n+     * When true, the page is prerendered as a fallback shell, while allowing\n+     * any dynamic accesses to result in an empty shell. This is the case when\n+     * the app has `experimental.ppr` and `experimental.dynamicIO` enabled, and\n+     * there are also routes prerendered with a more complete set of params.\n+     * Prerendering those routes would catch any invalid dynamic accesses.\n      *\n      * @internal\n      */\n-    _doNotThrowOnEmptyStaticShell?: boolean\n+    _allowEmptyStaticShell?: boolean\n   }\n }\n "
        },
        {
            "sha": "1425a7381fef1c10502f192a44b01291a5461bca",
            "filename": "packages/next/src/server/request/params.ts",
            "status": "modified",
            "additions": 32,
            "deletions": 3,
            "changes": 35,
            "blob_url": "https://github.com/vercel/next.js/blob/5136f8ecfd06f638325a2f45656744cbebd3fe97/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fparams.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/5136f8ecfd06f638325a2f45656744cbebd3fe97/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fparams.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fparams.ts?ref=5136f8ecfd06f638325a2f45656744cbebd3fe97",
            "patch": "@@ -24,6 +24,7 @@ import {\n import { makeHangingPromise } from '../dynamic-rendering-utils'\n import { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\n import { scheduleImmediate } from '../../lib/scheduler'\n+import { dynamicAccessAsyncStorage } from '../app-render/dynamic-access-async-storage.external'\n \n export type ParamValue = string | Array<string> | undefined\n export type Params = Record<string, ParamValue>\n@@ -198,6 +199,33 @@ function createRenderParams(\n interface CacheLifetime {}\n const CachedParams = new WeakMap<CacheLifetime, Promise<Params>>()\n \n+const fallbackParamsProxyHandler: ProxyHandler<Promise<Params>> = {\n+  get: function get(target, prop, receiver) {\n+    if (prop === 'then' || prop === 'catch' || prop === 'finally') {\n+      const originalMethod = ReflectAdapter.get(target, prop, receiver)\n+\n+      return {\n+        [prop]: (...args: unknown[]) => {\n+          const store = dynamicAccessAsyncStorage.getStore()\n+\n+          if (store) {\n+            store.abortController.abort(\n+              new Error(`Accessed fallback \\`params\\` during prerendering.`)\n+            )\n+          }\n+\n+          return new Proxy(\n+            originalMethod.apply(target, args),\n+            fallbackParamsProxyHandler\n+          )\n+        },\n+      }[prop]\n+    }\n+\n+    return ReflectAdapter.get(target, prop, receiver)\n+  },\n+}\n+\n function makeAbortingExoticParams(\n   underlyingParams: Params,\n   route: string,\n@@ -208,10 +236,11 @@ function makeAbortingExoticParams(\n     return cachedParams\n   }\n \n-  const promise = makeHangingPromise<Params>(\n-    prerenderStore.renderSignal,\n-    '`params`'\n+  const promise = new Proxy(\n+    makeHangingPromise<Params>(prerenderStore.renderSignal, '`params`'),\n+    fallbackParamsProxyHandler\n   )\n+\n   CachedParams.set(underlyingParams, promise)\n \n   Object.keys(underlyingParams).forEach((prop) => {"
        },
        {
            "sha": "7b1c0ec839c9d89b916a22cb427ec22124b4d312",
            "filename": "packages/next/src/server/use-cache/use-cache-wrapper.ts",
            "status": "modified",
            "additions": 200,
            "deletions": 64,
            "changes": 264,
            "blob_url": "https://github.com/vercel/next.js/blob/5136f8ecfd06f638325a2f45656744cbebd3fe97/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/5136f8ecfd06f638325a2f45656744cbebd3fe97/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts?ref=5136f8ecfd06f638325a2f45656744cbebd3fe97",
            "patch": "@@ -52,6 +52,7 @@ import {\n import type { Params } from '../request/params'\n import React from 'react'\n import { createLazyResult, isResolvedLazyResult } from '../lib/lazy-result'\n+import { dynamicAccessAsyncStorage } from '../app-render/dynamic-access-async-storage.external'\n \n type CacheKeyParts =\n   | [buildId: string, id: string, args: unknown[]]\n@@ -63,6 +64,15 @@ export interface UseCachePageComponentProps {\n   $$isPageComponent: true\n }\n \n+export type UseCacheLayoutComponentProps = {\n+  params: Promise<Params>\n+  $$isLayoutComponent: true\n+} & {\n+  // The value type should be React.ReactNode. But such an index signature would\n+  // be incompatible with the other two props.\n+  [slot: string]: any\n+}\n+\n const isEdgeRuntime = process.env.NEXT_RUNTIME === 'edge'\n \n const debug = process.env.NEXT_PRIVATE_DEBUG_CACHE\n@@ -76,7 +86,7 @@ function generateCacheEntry(\n   encodedArguments: FormData | string,\n   fn: (...args: unknown[]) => Promise<unknown>,\n   timeoutError: UseCacheTimeoutError\n-): Promise<[ReadableStream, Promise<CacheEntry>]> {\n+) {\n   // We need to run this inside a clean AsyncLocalStorage snapshot so that the cache\n   // generation cannot read anything from the context we're currently executing which\n   // might include request specific things like cookies() inside a React.cache().\n@@ -173,16 +183,18 @@ function generateCacheEntryWithCacheContext(\n       getDraftModeProviderForCacheScope(workStore, outerWorkUnitStore),\n   }\n \n-  return workUnitAsyncStorage.run(\n-    cacheStore,\n-    generateCacheEntryImpl,\n-    workStore,\n-    outerWorkUnitStore,\n-    cacheStore,\n-    clientReferenceManifest,\n-    encodedArguments,\n-    fn,\n-    timeoutError\n+  return workUnitAsyncStorage.run(cacheStore, () =>\n+    dynamicAccessAsyncStorage.run(\n+      { abortController: new AbortController() },\n+      generateCacheEntryImpl,\n+      workStore,\n+      outerWorkUnitStore,\n+      cacheStore,\n+      clientReferenceManifest,\n+      encodedArguments,\n+      fn,\n+      timeoutError\n+    )\n   )\n }\n \n@@ -307,6 +319,17 @@ async function collectResult(\n   return entry\n }\n \n+type GenerateCacheEntryResult =\n+  | {\n+      readonly type: 'cached'\n+      readonly stream: ReadableStream\n+      readonly pendingCacheEntry: Promise<CacheEntry>\n+    }\n+  | {\n+      readonly type: 'prerender-dynamic'\n+      readonly hangingPromise: Promise<never>\n+    }\n+\n async function generateCacheEntryImpl(\n   workStore: WorkStore,\n   outerWorkUnitStore: WorkUnitStore | undefined,\n@@ -315,7 +338,7 @@ async function generateCacheEntryImpl(\n   encodedArguments: FormData | string,\n   fn: (...args: unknown[]) => Promise<unknown>,\n   timeoutError: UseCacheTimeoutError\n-): Promise<[ReadableStream, Promise<CacheEntry>]> {\n+): Promise<GenerateCacheEntryResult> {\n   const temporaryReferences = createServerTemporaryReferenceSet()\n \n   const [, , args] =\n@@ -400,12 +423,16 @@ async function generateCacheEntryImpl(\n       timeoutAbortController.abort(timeoutError)\n     }, 50000)\n \n-    const { renderSignal } = outerWorkUnitStore\n+    const dynamicAccessAbortSignal =\n+      dynamicAccessAsyncStorage.getStore()?.abortController.signal\n \n-    const abortSignal = AbortSignal.any([\n-      renderSignal,\n-      timeoutAbortController.signal,\n-    ])\n+    const abortSignal = dynamicAccessAbortSignal\n+      ? AbortSignal.any([\n+          dynamicAccessAbortSignal,\n+          outerWorkUnitStore.renderSignal,\n+          timeoutAbortController.signal,\n+        ])\n+      : timeoutAbortController.signal\n \n     const { prelude } = await prerender(\n       resultPromise,\n@@ -427,11 +454,31 @@ async function generateCacheEntryImpl(\n     clearTimeout(timer)\n \n     if (timeoutAbortController.signal.aborted) {\n+      // When the timeout is reached we always error the stream. Even for\n+      // fallback shell prerenders we don't want to return a hanging promise,\n+      // which would allow the function to become a dynamic hole. Because that\n+      // would mean that a non-empty shell could be generated which would be\n+      // subject to revalidation, and we don't want to create long revalidation\n+      // times.\n       stream = new ReadableStream({\n         start(controller) {\n           controller.error(timeoutError)\n         },\n       })\n+    } else if (dynamicAccessAbortSignal?.aborted) {\n+      // If the prerender is aborted because of dynamic access (e.g. reading\n+      // fallback params), we return a hanging promise. This essentially makes\n+      // the \"use cache\" function dynamic.\n+      const hangingPromise = makeHangingPromise<never>(\n+        outerWorkUnitStore.renderSignal,\n+        abortSignal.reason\n+      )\n+\n+      if (outerWorkUnitStore?.type === 'prerender') {\n+        outerWorkUnitStore.cacheSignal?.endRead()\n+      }\n+\n+      return { type: 'prerender-dynamic', hangingPromise }\n     } else {\n       stream = prelude\n     }\n@@ -449,7 +496,7 @@ async function generateCacheEntryImpl(\n \n   const [returnStream, savedStream] = stream.tee()\n \n-  const promiseOfCacheEntry = collectResult(\n+  const pendingCacheEntry = collectResult(\n     savedStream,\n     workStore,\n     outerWorkUnitStore,\n@@ -458,10 +505,14 @@ async function generateCacheEntryImpl(\n     errors\n   )\n \n-  // Return the stream as we're creating it. This means that if it ends up\n-  // erroring we cannot return a stale-while-error version but it allows\n-  // streaming back the result earlier.\n-  return [returnStream, promiseOfCacheEntry]\n+  return {\n+    type: 'cached',\n+    // Return the stream as we're creating it. This means that if it ends up\n+    // erroring we cannot return a stale-if-error version but it allows\n+    // streaming back the result earlier.\n+    stream: returnStream,\n+    pendingCacheEntry,\n+  }\n }\n \n function cloneCacheEntry(entry: CacheEntry): [CacheEntry, CacheEntry] {\n@@ -596,31 +647,61 @@ export function cache(\n           ? createHangingInputAbortSignal(workUnitStore)\n           : undefined\n \n-      // When dynamicIO is not enabled, we can not encode searchParams as\n-      // hanging promises. To still avoid unused search params from making a\n-      // page dynamic, we overwrite them here with a promise that resolves to an\n-      // empty object, while also overwriting the to-be-invoked function for\n-      // generating a cache entry with a function that creates an erroring\n-      // searchParams prop before invoking the original function. This ensures\n-      // that used searchParams inside of cached functions would still yield an\n-      // error.\n-      if (!workStore.dynamicIOEnabled && isPageComponent(args)) {\n-        const [{ params, searchParams }] = args\n+      let isPageOrLayout = false\n+\n+      // For page and layout components, the cache function is overwritten,\n+      // which allows us to apply special handling for params and searchParams.\n+      // For pages and layouts we're using the outer params prop, and not the\n+      // inner one that was serialized/deserialized. While it's not generally\n+      // true for \"use cache\" args, in the case of `params` the inner and outer\n+      // object are essentially equivalent, so this is safe to do (including\n+      // fallback params that are hanging promises). It allows us to avoid\n+      // waiting for the timeout, when prerendering a fallback shell of a cached\n+      // page or layout that awaits params.\n+      if (isPageComponent(args)) {\n+        isPageOrLayout = true\n+\n+        const [{ params: outerParams, searchParams: outerSearchParams }] = args\n         // Overwrite the props to omit $$isPageComponent.\n-        args = [{ params, searchParams }]\n+        args = [{ params: outerParams, searchParams: outerSearchParams }]\n \n         fn = {\n           [name]: async ({\n-            params: serializedParams,\n+            params: _innerParams,\n+            searchParams: innerSearchParams,\n           }: Omit<UseCachePageComponentProps, '$$isPageComponent'>) =>\n             originalFn.apply(null, [\n               {\n-                params: serializedParams,\n-                searchParams:\n-                  makeErroringExoticSearchParamsForUseCache(workStore),\n+                params: outerParams,\n+                searchParams: workStore.dynamicIOEnabled\n+                  ? innerSearchParams\n+                  : // When dynamicIO is not enabled, we can not encode\n+                    // searchParams as a hanging promise. To still avoid unused\n+                    // search params from making a page dynamic, we define them\n+                    // in `createComponentTree` as a promise that resolves to an\n+                    // empty object. And here, we're creating an erroring\n+                    // searchParams prop, when invoking the original function.\n+                    // This ensures that used searchParams inside of cached\n+                    // functions would still yield an error.\n+                    makeErroringExoticSearchParamsForUseCache(workStore),\n               },\n             ]),\n         }[name] as (...args: unknown[]) => Promise<unknown>\n+      } else if (isLayoutComponent(args)) {\n+        isPageOrLayout = true\n+\n+        const [{ params: outerParams, $$isLayoutComponent, ...outerSlots }] =\n+          args\n+        // Overwrite the props to omit $$isLayoutComponent.\n+        args = [{ params: outerParams, ...outerSlots }]\n+\n+        fn = {\n+          [name]: async ({\n+            params: _innerParams,\n+            ...innerSlots\n+          }: Omit<UseCacheLayoutComponentProps, '$$isLayoutComponent'>) =>\n+            originalFn.apply(null, [{ params: outerParams, ...innerSlots }]),\n+        }[name] as (...args: unknown[]) => Promise<unknown>\n       }\n \n       if (boundArgsLength > 0) {\n@@ -654,10 +735,38 @@ export function cache(\n         ? [buildId, id, args, hmrRefreshHash]\n         : [buildId, id, args]\n \n-      const encodedCacheKeyParts: FormData | string = await encodeReply(\n-        cacheKeyParts,\n-        { temporaryReferences, signal: hangingInputAbortSignal }\n-      )\n+      const encodeCacheKeyParts = () =>\n+        encodeReply(cacheKeyParts, {\n+          temporaryReferences,\n+          signal: hangingInputAbortSignal,\n+        })\n+\n+      let encodedCacheKeyParts: FormData | string\n+\n+      if (workUnitStore?.type === 'prerender' && !isPageOrLayout) {\n+        // If the \"use cache\" function is not a page or a layout, we need to\n+        // track dynamic access already when encoding the arguments. If params\n+        // are passed explicitly into a \"use cache\" function (as opposed to\n+        // receiving them automatically in a page or layout), we assume that the\n+        // params are also accessed. This allows us to abort early, and treat\n+        // the function as dynamic, instead of waiting for the timeout to be\n+        // reached.\n+        const dynamicAccessAbortController = new AbortController()\n+\n+        encodedCacheKeyParts = await dynamicAccessAsyncStorage.run(\n+          { abortController: dynamicAccessAbortController },\n+          encodeCacheKeyParts\n+        )\n+\n+        if (dynamicAccessAbortController.signal.aborted) {\n+          return makeHangingPromise(\n+            workUnitStore.renderSignal,\n+            dynamicAccessAbortController.signal.reason.message\n+          )\n+        }\n+      } else {\n+        encodedCacheKeyParts = await encodeCacheKeyParts()\n+      }\n \n       const serializedCacheKey =\n         typeof encodedCacheKeyParts === 'string'\n@@ -829,7 +938,7 @@ export function cache(\n             }\n           }\n \n-          const [newStream, pendingCacheEntry] = await generateCacheEntry(\n+          const result = await generateCacheEntry(\n             workStore,\n             workUnitStore,\n             clientReferenceManifest,\n@@ -838,6 +947,12 @@ export function cache(\n             timeoutError\n           )\n \n+          if (result.type === 'prerender-dynamic') {\n+            return result.hangingPromise\n+          }\n+\n+          const { stream: newStream, pendingCacheEntry } = result\n+\n           // When draft mode is enabled, we must not save the cache entry.\n           if (!workStore.isDraftMode) {\n             let savedCacheEntry\n@@ -892,40 +1007,44 @@ export function cache(\n           }\n \n           if (currentTime > entry.timestamp + entry.revalidate * 1000) {\n-            // If this is stale, and we're not in a prerender (i.e. this is dynamic render),\n-            // then we should warm up the cache with a fresh revalidated entry.\n-            const [ignoredStream, pendingCacheEntry] = await generateCacheEntry(\n+            // If this is stale, and we're not in a prerender (i.e. this is\n+            // dynamic render), then we should warm up the cache with a fresh\n+            // revalidated entry.\n+            const result = await generateCacheEntry(\n               workStore,\n-              undefined, // This is not running within the context of this unit.\n+              // This is not running within the context of this unit.\n+              undefined,\n               clientReferenceManifest,\n               encodedCacheKeyParts,\n               fn,\n               timeoutError\n             )\n \n-            let savedCacheEntry: Promise<CacheEntry>\n-            if (prerenderResumeDataCache) {\n-              const split = clonePendingCacheEntry(pendingCacheEntry)\n-              savedCacheEntry = getNthCacheEntry(split, 0)\n-              prerenderResumeDataCache.cache.set(\n+            if (result.type === 'cached') {\n+              const { stream: ignoredStream, pendingCacheEntry } = result\n+              let savedCacheEntry: Promise<CacheEntry>\n+\n+              if (prerenderResumeDataCache) {\n+                const split = clonePendingCacheEntry(pendingCacheEntry)\n+                savedCacheEntry = getNthCacheEntry(split, 0)\n+                prerenderResumeDataCache.cache.set(\n+                  serializedCacheKey,\n+                  getNthCacheEntry(split, 1)\n+                )\n+              } else {\n+                savedCacheEntry = pendingCacheEntry\n+              }\n+\n+              const promise = cacheHandler.set(\n                 serializedCacheKey,\n-                getNthCacheEntry(split, 1)\n+                savedCacheEntry\n               )\n-            } else {\n-              savedCacheEntry = pendingCacheEntry\n-            }\n \n-            const promise = cacheHandler.set(\n-              serializedCacheKey,\n-              savedCacheEntry\n-            )\n+              workStore.pendingRevalidateWrites ??= []\n+              workStore.pendingRevalidateWrites.push(promise)\n \n-            if (!workStore.pendingRevalidateWrites) {\n-              workStore.pendingRevalidateWrites = []\n+              await ignoredStream.cancel()\n             }\n-            workStore.pendingRevalidateWrites.push(promise)\n-\n-            await ignoredStream.cancel()\n           }\n         }\n       }\n@@ -979,6 +1098,23 @@ function isPageComponent(\n   )\n }\n \n+function isLayoutComponent(\n+  args: any[]\n+): args is [UseCacheLayoutComponentProps, undefined] {\n+  if (args.length !== 2) {\n+    return false\n+  }\n+\n+  const [props, ref] = args\n+\n+  return (\n+    ref === undefined && // server components receive an undefined ref arg\n+    props !== null &&\n+    typeof props === 'object' &&\n+    (props as UseCacheLayoutComponentProps).$$isLayoutComponent\n+  )\n+}\n+\n function shouldForceRevalidate(\n   workStore: WorkStore,\n   workUnitStore: WorkUnitStore | undefined"
        },
        {
            "sha": "35df71aa8770ee9467ab2ac55392333d24e867c5",
            "filename": "test/e2e/app-dir/empty-fallback-shells/app/with-cached-io/last-modified.jsx",
            "status": "added",
            "additions": 15,
            "deletions": 0,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/5136f8ecfd06f638325a2f45656744cbebd3fe97/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwith-cached-io%2Flast-modified.jsx",
            "raw_url": "https://github.com/vercel/next.js/raw/5136f8ecfd06f638325a2f45656744cbebd3fe97/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwith-cached-io%2Flast-modified.jsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwith-cached-io%2Flast-modified.jsx?ref=5136f8ecfd06f638325a2f45656744cbebd3fe97",
            "patch": "@@ -0,0 +1,15 @@\n+export async function LastModified({ params }) {\n+  const { slug } = await params\n+\n+  return (\n+    <p data-testid={`page-${slug}`}>\n+      Page /{slug} last modified: {new Date().toISOString()}\n+    </p>\n+  )\n+}\n+\n+export async function CachedLastModified({ params }) {\n+  'use cache'\n+\n+  return <LastModified params={params} />\n+}"
        },
        {
            "sha": "4571ba8f47bb8f0b9754bc789cfce6c305160536",
            "filename": "test/e2e/app-dir/empty-fallback-shells/app/with-cached-io/sentinel.ts",
            "status": "added",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/5136f8ecfd06f638325a2f45656744cbebd3fe97/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwith-cached-io%2Fsentinel.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/5136f8ecfd06f638325a2f45656744cbebd3fe97/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwith-cached-io%2Fsentinel.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwith-cached-io%2Fsentinel.ts?ref=5136f8ecfd06f638325a2f45656744cbebd3fe97",
            "patch": "@@ -0,0 +1,7 @@\n+const { PHASE_PRODUCTION_BUILD } = require('next/constants')\n+\n+export function getSentinelValue() {\n+  return process.env.NEXT_PHASE === PHASE_PRODUCTION_BUILD\n+    ? 'buildtime'\n+    : 'runtime'\n+}"
        },
        {
            "sha": "7e85641b121d2ab695622cc03e2117cc3bd2ab74",
            "filename": "test/e2e/app-dir/empty-fallback-shells/app/with-cached-io/with-suspense/layout.jsx",
            "status": "added",
            "additions": 17,
            "deletions": 0,
            "changes": 17,
            "blob_url": "https://github.com/vercel/next.js/blob/5136f8ecfd06f638325a2f45656744cbebd3fe97/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwith-cached-io%2Fwith-suspense%2Flayout.jsx",
            "raw_url": "https://github.com/vercel/next.js/raw/5136f8ecfd06f638325a2f45656744cbebd3fe97/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwith-cached-io%2Fwith-suspense%2Flayout.jsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwith-cached-io%2Fwith-suspense%2Flayout.jsx?ref=5136f8ecfd06f638325a2f45656744cbebd3fe97",
            "patch": "@@ -0,0 +1,17 @@\n+'use cache'\n+\n+import { Suspense } from 'react'\n+import { getSentinelValue } from '../sentinel'\n+\n+export default async function Layout({ children }) {\n+  return (\n+    <html>\n+      <body>\n+        <div data-testid={`layout-${getSentinelValue()}`}>\n+          Layout: {new Date().toISOString()}\n+        </div>\n+        <Suspense fallback={<p>Loading...</p>}>{children}</Suspense>\n+      </body>\n+    </html>\n+  )\n+}"
        },
        {
            "sha": "d4d9730aceeea6a87031ae7b84ffad440e2cb987",
            "filename": "test/e2e/app-dir/empty-fallback-shells/app/with-cached-io/with-suspense/params-in-page/[slug]/page.jsx",
            "status": "added",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/5136f8ecfd06f638325a2f45656744cbebd3fe97/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwith-cached-io%2Fwith-suspense%2Fparams-in-page%2F%5Bslug%5D%2Fpage.jsx",
            "raw_url": "https://github.com/vercel/next.js/raw/5136f8ecfd06f638325a2f45656744cbebd3fe97/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwith-cached-io%2Fwith-suspense%2Fparams-in-page%2F%5Bslug%5D%2Fpage.jsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwith-cached-io%2Fwith-suspense%2Fparams-in-page%2F%5Bslug%5D%2Fpage.jsx?ref=5136f8ecfd06f638325a2f45656744cbebd3fe97",
            "patch": "@@ -0,0 +1,11 @@\n+'use cache'\n+\n+import { LastModified } from '../../../last-modified'\n+\n+export default async function Page({ params }) {\n+  return <LastModified params={params} />\n+}\n+\n+export async function generateStaticParams() {\n+  return [{ slug: 'foo' }]\n+}"
        },
        {
            "sha": "8b9bedf3e6c74b377cb24cc1130dff2136c3c72f",
            "filename": "test/e2e/app-dir/empty-fallback-shells/app/with-cached-io/with-suspense/params-not-in-page/[slug]/page.jsx",
            "status": "added",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/5136f8ecfd06f638325a2f45656744cbebd3fe97/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwith-cached-io%2Fwith-suspense%2Fparams-not-in-page%2F%5Bslug%5D%2Fpage.jsx",
            "raw_url": "https://github.com/vercel/next.js/raw/5136f8ecfd06f638325a2f45656744cbebd3fe97/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwith-cached-io%2Fwith-suspense%2Fparams-not-in-page%2F%5Bslug%5D%2Fpage.jsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwith-cached-io%2Fwith-suspense%2Fparams-not-in-page%2F%5Bslug%5D%2Fpage.jsx?ref=5136f8ecfd06f638325a2f45656744cbebd3fe97",
            "patch": "@@ -0,0 +1,9 @@\n+import { CachedLastModified } from '../../../last-modified'\n+\n+export default async function Page({ params }) {\n+  return <CachedLastModified params={params} />\n+}\n+\n+export async function generateStaticParams() {\n+  return [{ slug: 'foo' }]\n+}"
        },
        {
            "sha": "6c479b8e4fa3589094ebd600ebeef8254cdc7d6a",
            "filename": "test/e2e/app-dir/empty-fallback-shells/app/with-cached-io/with-suspense/params-then-in-page/[slug]/page.jsx",
            "status": "added",
            "additions": 16,
            "deletions": 0,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/5136f8ecfd06f638325a2f45656744cbebd3fe97/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwith-cached-io%2Fwith-suspense%2Fparams-then-in-page%2F%5Bslug%5D%2Fpage.jsx",
            "raw_url": "https://github.com/vercel/next.js/raw/5136f8ecfd06f638325a2f45656744cbebd3fe97/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwith-cached-io%2Fwith-suspense%2Fparams-then-in-page%2F%5Bslug%5D%2Fpage.jsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwith-cached-io%2Fwith-suspense%2Fparams-then-in-page%2F%5Bslug%5D%2Fpage.jsx?ref=5136f8ecfd06f638325a2f45656744cbebd3fe97",
            "patch": "@@ -0,0 +1,16 @@\n+import { CachedLastModified } from '../../../last-modified'\n+\n+export default async function Page({ params }) {\n+  return (\n+    <>\n+      <CachedLastModified params={params.then((p) => ({ slug: p.slug }))} />\n+      <CachedLastModified params={params.catch(() => {})} />\n+      <CachedLastModified params={params.finally(() => {})} />\n+      <CachedLastModified params={params.finally().catch()} />\n+    </>\n+  )\n+}\n+\n+export async function generateStaticParams() {\n+  return [{ slug: 'foo' }]\n+}"
        },
        {
            "sha": "a9acdbda7e2b44c7f6ec6921049a668c69a33eb9",
            "filename": "test/e2e/app-dir/empty-fallback-shells/app/with-cached-io/without-suspense/layout.jsx",
            "status": "added",
            "additions": 16,
            "deletions": 0,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/5136f8ecfd06f638325a2f45656744cbebd3fe97/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwith-cached-io%2Fwithout-suspense%2Flayout.jsx",
            "raw_url": "https://github.com/vercel/next.js/raw/5136f8ecfd06f638325a2f45656744cbebd3fe97/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwith-cached-io%2Fwithout-suspense%2Flayout.jsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwith-cached-io%2Fwithout-suspense%2Flayout.jsx?ref=5136f8ecfd06f638325a2f45656744cbebd3fe97",
            "patch": "@@ -0,0 +1,16 @@\n+'use cache'\n+\n+import { getSentinelValue } from '../sentinel'\n+\n+export default async function Layout({ children }) {\n+  return (\n+    <html>\n+      <body>\n+        <div data-testid={`layout-${getSentinelValue()}`}>\n+          Layout: {new Date().toISOString()}\n+        </div>\n+        {children}\n+      </body>\n+    </html>\n+  )\n+}"
        },
        {
            "sha": "d4d9730aceeea6a87031ae7b84ffad440e2cb987",
            "filename": "test/e2e/app-dir/empty-fallback-shells/app/with-cached-io/without-suspense/params-in-page/[slug]/page.jsx",
            "status": "added",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/5136f8ecfd06f638325a2f45656744cbebd3fe97/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwith-cached-io%2Fwithout-suspense%2Fparams-in-page%2F%5Bslug%5D%2Fpage.jsx",
            "raw_url": "https://github.com/vercel/next.js/raw/5136f8ecfd06f638325a2f45656744cbebd3fe97/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwith-cached-io%2Fwithout-suspense%2Fparams-in-page%2F%5Bslug%5D%2Fpage.jsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwith-cached-io%2Fwithout-suspense%2Fparams-in-page%2F%5Bslug%5D%2Fpage.jsx?ref=5136f8ecfd06f638325a2f45656744cbebd3fe97",
            "patch": "@@ -0,0 +1,11 @@\n+'use cache'\n+\n+import { LastModified } from '../../../last-modified'\n+\n+export default async function Page({ params }) {\n+  return <LastModified params={params} />\n+}\n+\n+export async function generateStaticParams() {\n+  return [{ slug: 'foo' }]\n+}"
        },
        {
            "sha": "8b9bedf3e6c74b377cb24cc1130dff2136c3c72f",
            "filename": "test/e2e/app-dir/empty-fallback-shells/app/with-cached-io/without-suspense/params-not-in-page/[slug]/page.jsx",
            "status": "added",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/5136f8ecfd06f638325a2f45656744cbebd3fe97/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwith-cached-io%2Fwithout-suspense%2Fparams-not-in-page%2F%5Bslug%5D%2Fpage.jsx",
            "raw_url": "https://github.com/vercel/next.js/raw/5136f8ecfd06f638325a2f45656744cbebd3fe97/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwith-cached-io%2Fwithout-suspense%2Fparams-not-in-page%2F%5Bslug%5D%2Fpage.jsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwith-cached-io%2Fwithout-suspense%2Fparams-not-in-page%2F%5Bslug%5D%2Fpage.jsx?ref=5136f8ecfd06f638325a2f45656744cbebd3fe97",
            "patch": "@@ -0,0 +1,9 @@\n+import { CachedLastModified } from '../../../last-modified'\n+\n+export default async function Page({ params }) {\n+  return <CachedLastModified params={params} />\n+}\n+\n+export async function generateStaticParams() {\n+  return [{ slug: 'foo' }]\n+}"
        },
        {
            "sha": "6c479b8e4fa3589094ebd600ebeef8254cdc7d6a",
            "filename": "test/e2e/app-dir/empty-fallback-shells/app/with-cached-io/without-suspense/params-then-in-page/[slug]/page.jsx",
            "status": "added",
            "additions": 16,
            "deletions": 0,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/5136f8ecfd06f638325a2f45656744cbebd3fe97/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwith-cached-io%2Fwithout-suspense%2Fparams-then-in-page%2F%5Bslug%5D%2Fpage.jsx",
            "raw_url": "https://github.com/vercel/next.js/raw/5136f8ecfd06f638325a2f45656744cbebd3fe97/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwith-cached-io%2Fwithout-suspense%2Fparams-then-in-page%2F%5Bslug%5D%2Fpage.jsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwith-cached-io%2Fwithout-suspense%2Fparams-then-in-page%2F%5Bslug%5D%2Fpage.jsx?ref=5136f8ecfd06f638325a2f45656744cbebd3fe97",
            "patch": "@@ -0,0 +1,16 @@\n+import { CachedLastModified } from '../../../last-modified'\n+\n+export default async function Page({ params }) {\n+  return (\n+    <>\n+      <CachedLastModified params={params.then((p) => ({ slug: p.slug }))} />\n+      <CachedLastModified params={params.catch(() => {})} />\n+      <CachedLastModified params={params.finally(() => {})} />\n+      <CachedLastModified params={params.finally().catch()} />\n+    </>\n+  )\n+}\n+\n+export async function generateStaticParams() {\n+  return [{ slug: 'foo' }]\n+}"
        },
        {
            "sha": "aa74c6b2a1926a2bc77ce0b50d1fd79f9aed98e8",
            "filename": "test/e2e/app-dir/empty-fallback-shells/app/without-io/[slug]/page.jsx",
            "status": "renamed",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/vercel/next.js/blob/5136f8ecfd06f638325a2f45656744cbebd3fe97/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwithout-io%2F%5Bslug%5D%2Fpage.jsx",
            "raw_url": "https://github.com/vercel/next.js/raw/5136f8ecfd06f638325a2f45656744cbebd3fe97/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwithout-io%2F%5Bslug%5D%2Fpage.jsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwithout-io%2F%5Bslug%5D%2Fpage.jsx?ref=5136f8ecfd06f638325a2f45656744cbebd3fe97",
            "previous_filename": "test/e2e/app-dir/empty-fallback-shells/app/[slug]/page.jsx"
        },
        {
            "sha": "b2e098a76134eae53c547420ae93aca2644e2da3",
            "filename": "test/e2e/app-dir/empty-fallback-shells/app/without-io/layout.jsx",
            "status": "renamed",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/vercel/next.js/blob/5136f8ecfd06f638325a2f45656744cbebd3fe97/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwithout-io%2Flayout.jsx",
            "raw_url": "https://github.com/vercel/next.js/raw/5136f8ecfd06f638325a2f45656744cbebd3fe97/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwithout-io%2Flayout.jsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwithout-io%2Flayout.jsx?ref=5136f8ecfd06f638325a2f45656744cbebd3fe97",
            "previous_filename": "test/e2e/app-dir/empty-fallback-shells/app/layout.jsx"
        },
        {
            "sha": "c72980fb040de3d14606baed4dc41ace45696420",
            "filename": "test/e2e/app-dir/empty-fallback-shells/empty-fallback-shells.test.ts",
            "status": "modified",
            "additions": 160,
            "deletions": 11,
            "changes": 171,
            "blob_url": "https://github.com/vercel/next.js/blob/5136f8ecfd06f638325a2f45656744cbebd3fe97/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fempty-fallback-shells.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/5136f8ecfd06f638325a2f45656744cbebd3fe97/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fempty-fallback-shells.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fempty-fallback-shells.test.ts?ref=5136f8ecfd06f638325a2f45656744cbebd3fe97",
            "patch": "@@ -1,21 +1,170 @@\n import { nextTestSetup } from 'e2e-utils'\n \n describe('empty-fallback-shells', () => {\n-  const { next, isNextDeploy } = nextTestSetup({\n+  const { next, isNextDev, isNextDeploy, isNextStart } = nextTestSetup({\n     files: __dirname,\n   })\n \n-  it('should start and not postpone the response', async () => {\n-    const res = await next.fetch('/world')\n-    const html = await res.text()\n-    expect(html).toContain('hello-world')\n+  describe('without IO', () => {\n+    it('should start and not postpone the response', async () => {\n+      const res = await next.fetch('/without-io/world')\n+      const html = await res.text()\n+      expect(html).toContain('hello-world')\n \n-    if (isNextDeploy) {\n-      expect(res.headers.get('x-matched-path')).toBe('/[slug]')\n-    }\n+      if (isNextDeploy) {\n+        expect(res.headers.get('x-matched-path')).toBe('/without-io/[slug]')\n+      }\n \n-    // If we didn't use the fallback shell, then we didn't postpone the response\n-    // and therefore shouldn't have sent the postponed header.\n-    expect(res.headers.get('x-nextjs-postponed')).not.toBe('1')\n+      // If we didn't use the fallback shell, then we didn't postpone the\n+      // response and therefore shouldn't have sent the postponed header.\n+      expect(res.headers.get('x-nextjs-postponed')).not.toBe('1')\n+    })\n   })\n+\n+  describe('with cached IO', () => {\n+    describe('and the page wrapped in Suspense', () => {\n+      describe('and the params accessed in the cached page', () => {\n+        it('resumes a postponed fallback shell', async () => {\n+          const res = await next.fetch(\n+            '/with-cached-io/with-suspense/params-in-page/bar'\n+          )\n+\n+          const html = await res.text()\n+          expect(html).toContain('page-bar')\n+\n+          if (isNextDev) {\n+            expect(html).toContain('layout-runtime')\n+          } else {\n+            expect(html).toContain('layout-buildtime')\n+          }\n+\n+          if (isNextDeploy) {\n+            expect(res.headers.get('x-matched-path')).toBe(\n+              '/with-cached-io/with-suspense/params-in-page/[slug]'\n+            )\n+          } else if (isNextStart) {\n+            expect(res.headers.get('x-nextjs-postponed')).toBe('1')\n+          }\n+        })\n+      })\n+\n+      describe('and the params accessed in cached non-page function', () => {\n+        it('resumes a postponed fallback shell', async () => {\n+          const res = await next.fetch(\n+            '/with-cached-io/with-suspense/params-not-in-page/bar'\n+          )\n+\n+          const html = await res.text()\n+          expect(html).toContain('page-bar')\n+\n+          if (isNextDev) {\n+            expect(html).toContain('layout-runtime')\n+          } else {\n+            expect(html).toContain('layout-buildtime')\n+          }\n+\n+          if (isNextDeploy) {\n+            expect(res.headers.get('x-matched-path')).toBe(\n+              '/with-cached-io/with-suspense/params-not-in-page/[slug]'\n+            )\n+          } else if (isNextStart) {\n+            expect(res.headers.get('x-nextjs-postponed')).toBe('1')\n+          }\n+        })\n+      })\n+\n+      describe('and params.then/catch/finally passed to a cached function', () => {\n+        it('resumes a postponed fallback shell', async () => {\n+          const res = await next.fetch(\n+            '/with-cached-io/with-suspense/params-then-in-page/bar'\n+          )\n+\n+          const html = await res.text()\n+          expect(html).toIncludeRepeated('data-testid=\"page-bar\"', 4)\n+\n+          if (isNextDev) {\n+            expect(html).toContain('layout-runtime')\n+          } else {\n+            expect(html).toContain('layout-buildtime')\n+          }\n+\n+          if (isNextDeploy) {\n+            expect(res.headers.get('x-matched-path')).toBe(\n+              '/with-cached-io/with-suspense/params-then-in-page/[slug]'\n+            )\n+          } else if (isNextStart) {\n+            expect(res.headers.get('x-nextjs-postponed')).toBe('1')\n+          }\n+        })\n+      })\n+    })\n+\n+    describe('and the page not wrapped in Suspense', () => {\n+      describe('and the params accessed in the cached page', () => {\n+        it('does not resume a postponed fallback shell', async () => {\n+          const res = await next.fetch(\n+            '/with-cached-io/without-suspense/params-in-page/bar'\n+          )\n+\n+          const html = await res.text()\n+          expect(html).toContain('page-bar')\n+          expect(html).toContain('layout-runtime')\n+\n+          if (isNextDeploy) {\n+            expect(res.headers.get('x-matched-path')).toBe(\n+              '/with-cached-io/without-suspense/params-in-page/[slug]'\n+            )\n+          } else {\n+            expect(res.headers.get('x-nextjs-postponed')).not.toBe('1')\n+          }\n+        })\n+      })\n+\n+      describe('and the params accessed in a cached non-page function', () => {\n+        it('does not resume a postponed fallback shell', async () => {\n+          const res = await next.fetch(\n+            '/with-cached-io/without-suspense/params-not-in-page/bar'\n+          )\n+\n+          const html = await res.text()\n+          expect(html).toContain('page-bar')\n+          expect(html).toContain('layout-runtime')\n+\n+          if (isNextDeploy) {\n+            expect(res.headers.get('x-matched-path')).toBe(\n+              '/with-cached-io/without-suspense/params-not-in-page/[slug]'\n+            )\n+          } else {\n+            expect(res.headers.get('x-nextjs-postponed')).not.toBe('1')\n+          }\n+        })\n+      })\n+\n+      describe('and params.then/catch/finally passed to a cached function', () => {\n+        it('does not resume a postponed fallback shell', async () => {\n+          const res = await next.fetch(\n+            '/with-cached-io/without-suspense/params-then-in-page/bar'\n+          )\n+\n+          const html = await res.text()\n+          expect(html).toIncludeRepeated('data-testid=\"page-bar\"', 4)\n+          expect(html).toContain('layout-runtime')\n+\n+          if (isNextDeploy) {\n+            expect(res.headers.get('x-matched-path')).toBe(\n+              '/with-cached-io/without-suspense/params-then-in-page/[slug]'\n+            )\n+          } else {\n+            expect(res.headers.get('x-nextjs-postponed')).not.toBe('1')\n+          }\n+        })\n+      })\n+    })\n+  })\n+\n+  if (isNextStart) {\n+    it('should not log a HANGING_PROMISE_REJECTION error', async () => {\n+      expect(next.cliOutput).not.toContain('HANGING_PROMISE_REJECTION')\n+    })\n+  }\n })"
        },
        {
            "sha": "3dac20d4703cf497d300bffee5942f767606634c",
            "filename": "test/e2e/app-dir/empty-fallback-shells/next.config.js",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/5136f8ecfd06f638325a2f45656744cbebd3fe97/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fnext.config.js",
            "raw_url": "https://github.com/vercel/next.js/raw/5136f8ecfd06f638325a2f45656744cbebd3fe97/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fnext.config.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fnext.config.js?ref=5136f8ecfd06f638325a2f45656744cbebd3fe97",
            "patch": "@@ -4,6 +4,7 @@\n const nextConfig = {\n   experimental: {\n     dynamicIO: true,\n+    prerenderEarlyExit: false,\n   },\n }\n "
        },
        {
            "sha": "1f77b26ac270b188eff2675eae2fe49e0ef60943",
            "filename": "test/e2e/app-dir/use-cache-hanging-inputs/app/fallback-params/[slug]/page.tsx",
            "status": "removed",
            "additions": 0,
            "deletions": 14,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/6440778d60690fe74a564de47f54d9496ea3fead/test%2Fe2e%2Fapp-dir%2Fuse-cache-hanging-inputs%2Fapp%2Ffallback-params%2F%5Bslug%5D%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/6440778d60690fe74a564de47f54d9496ea3fead/test%2Fe2e%2Fapp-dir%2Fuse-cache-hanging-inputs%2Fapp%2Ffallback-params%2F%5Bslug%5D%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache-hanging-inputs%2Fapp%2Ffallback-params%2F%5Bslug%5D%2Fpage.tsx?ref=6440778d60690fe74a564de47f54d9496ea3fead",
            "patch": "@@ -1,14 +0,0 @@\n-'use cache'\n-\n-export default async function Page({\n-  params,\n-}: {\n-  params: Promise<{ slug: string }>\n-}) {\n-  const { slug } = await params\n-\n-  return <p>slug: {slug}</p>\n-}\n-\n-// If generateStaticParams would be used here to define at least one set of\n-// complete params, we would not yield a timeout error."
        },
        {
            "sha": "0c2be6ac6c88a443d7f5c65a4d661425838a6994",
            "filename": "test/e2e/app-dir/use-cache-hanging-inputs/app/transformed-params/[slug]/page.jsx",
            "status": "added",
            "additions": 25,
            "deletions": 0,
            "changes": 25,
            "blob_url": "https://github.com/vercel/next.js/blob/5136f8ecfd06f638325a2f45656744cbebd3fe97/test%2Fe2e%2Fapp-dir%2Fuse-cache-hanging-inputs%2Fapp%2Ftransformed-params%2F%5Bslug%5D%2Fpage.jsx",
            "raw_url": "https://github.com/vercel/next.js/raw/5136f8ecfd06f638325a2f45656744cbebd3fe97/test%2Fe2e%2Fapp-dir%2Fuse-cache-hanging-inputs%2Fapp%2Ftransformed-params%2F%5Bslug%5D%2Fpage.jsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache-hanging-inputs%2Fapp%2Ftransformed-params%2F%5Bslug%5D%2Fpage.jsx?ref=5136f8ecfd06f638325a2f45656744cbebd3fe97",
            "patch": "@@ -0,0 +1,25 @@\n+async function LastModified({ params }) {\n+  'use cache'\n+\n+  const { slug } = await params\n+\n+  return (\n+    <p data-testid={`page-${slug}`}>\n+      Page /{slug} last modified: {new Date().toISOString()}\n+    </p>\n+  )\n+}\n+\n+async function transformParams(params) {\n+  const { slug } = await params\n+\n+  return { slug }\n+}\n+\n+export default async function Page({ params }) {\n+  return <LastModified params={transformParams(params)} />\n+}\n+\n+export async function generateStaticParams() {\n+  return [{ slug: 'foo' }]\n+}"
        },
        {
            "sha": "5ed2ff8e4faf3c4dba854fa05a2a86bb5c70a825",
            "filename": "test/e2e/app-dir/use-cache-hanging-inputs/use-cache-hanging-inputs.test.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/5136f8ecfd06f638325a2f45656744cbebd3fe97/test%2Fe2e%2Fapp-dir%2Fuse-cache-hanging-inputs%2Fuse-cache-hanging-inputs.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/5136f8ecfd06f638325a2f45656744cbebd3fe97/test%2Fe2e%2Fapp-dir%2Fuse-cache-hanging-inputs%2Fuse-cache-hanging-inputs.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache-hanging-inputs%2Fuse-cache-hanging-inputs.test.ts?ref=5136f8ecfd06f638325a2f45656744cbebd3fe97",
            "patch": "@@ -335,15 +335,15 @@ describe('use-cache-hanging-inputs', () => {\n       )\n \n       expect(cliOutput).toInclude(\n-        createExpectedBuildErrorMessage('/fallback-params/[slug]')\n+        createExpectedBuildErrorMessage('/search-params')\n       )\n \n       expect(cliOutput).toInclude(\n-        createExpectedBuildErrorMessage('/search-params')\n+        createExpectedBuildErrorMessage('/search-params-caught')\n       )\n \n       expect(cliOutput).toInclude(\n-        createExpectedBuildErrorMessage('/search-params-caught')\n+        createExpectedBuildErrorMessage('/transformed-params/[slug]')\n       )\n \n       expect(cliOutput).toInclude("
        }
    ],
    "stats": {
        "total": 1088,
        "additions": 824,
        "deletions": 264
    }
}