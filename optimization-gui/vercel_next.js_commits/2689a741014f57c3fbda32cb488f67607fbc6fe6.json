{
    "author": "kdy1",
    "message": "perf(turbopack/rcstr): Add serialization-time optimization (#78645)\n\n### What?\n\nInterns `RcStr` as an index set upon serialization.\n\n### Why?\n\nIt's required for future optimization.",
    "sha": "2689a741014f57c3fbda32cb488f67607fbc6fe6",
    "files": [
        {
            "sha": "dc1214633965634be872e3d5c1b6573e8da02960",
            "filename": "Cargo.lock",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/2689a741014f57c3fbda32cb488f67607fbc6fe6/Cargo.lock",
            "raw_url": "https://github.com/vercel/next.js/raw/2689a741014f57c3fbda32cb488f67607fbc6fe6/Cargo.lock",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/Cargo.lock?ref=2689a741014f57c3fbda32cb488f67607fbc6fe6",
            "patch": "@@ -9163,9 +9163,11 @@ version = \"0.1.0\"\n dependencies = [\n  \"bytes-str\",\n  \"codspeed-criterion-compat\",\n+ \"indexmap 2.9.0\",\n  \"napi\",\n  \"new_debug_unreachable\",\n  \"rustc-hash 2.1.1\",\n+ \"scoped-tls\",\n  \"serde\",\n  \"shrink-to-fit\",\n  \"triomphe 0.1.12\",\n@@ -9257,6 +9259,7 @@ dependencies = [\n  \"rstest\",\n  \"rustc-hash 2.1.1\",\n  \"serde\",\n+ \"serde_bytes\",\n  \"serde_json\",\n  \"serde_path_to_error\",\n  \"smallvec\","
        },
        {
            "sha": "d4007a23836919d3e9bcdf84acac8b2e309ffb99",
            "filename": "turbopack/crates/turbo-persistence/src/lib.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 4,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/2689a741014f57c3fbda32cb488f67607fbc6fe6/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2689a741014f57c3fbda32cb488f67607fbc6fe6/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Flib.rs?ref=2689a741014f57c3fbda32cb488f67607fbc6fe6",
            "patch": "@@ -13,16 +13,15 @@ mod db;\n mod key;\n mod lookup_entry;\n mod merge_iter;\n-mod static_sorted_file;\n-mod static_sorted_file_builder;\n-mod write_batch;\n-\n mod meta_file;\n mod meta_file_builder;\n mod sst_filter;\n+mod static_sorted_file;\n+mod static_sorted_file_builder;\n #[cfg(test)]\n mod tests;\n mod value_buf;\n+mod write_batch;\n \n pub use arc_slice::ArcSlice;\n pub use db::{MetaFileEntryInfo, MetaFileInfo, TurboPersistence};"
        },
        {
            "sha": "dc2d344d03488b947e1242a3fe5b0f0589bb84bf",
            "filename": "turbopack/crates/turbo-rcstr/Cargo.toml",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/2689a741014f57c3fbda32cb488f67607fbc6fe6/turbopack%2Fcrates%2Fturbo-rcstr%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/2689a741014f57c3fbda32cb488f67607fbc6fe6/turbopack%2Fcrates%2Fturbo-rcstr%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-rcstr%2FCargo.toml?ref=2689a741014f57c3fbda32cb488f67607fbc6fe6",
            "patch": "@@ -15,11 +15,15 @@ turbo-tasks-hash = { workspace = true }\n serde = { workspace = true }\n new_debug_unreachable = \"1.0.6\"\n shrink-to-fit = { workspace = true }\n-rustc-hash = { workspace = true }\n bytes-str = { workspace = true }\n+indexmap = { workspace = true }\n+rustc-hash = { workspace = true }\n+scoped-tls = \"1.0.1\"\n \n [target.'cfg(not(target_family = \"wasm\"))'.dependencies]\n napi = { workspace = true, optional = true }\n+scoped-tls = \"1.0.1\"\n+indexmap = { workspace = true }\n \n [dev-dependencies]\n criterion = { workspace = true }"
        },
        {
            "sha": "0df65f3cf47089497582b4e884d3c794ea8e7644",
            "filename": "turbopack/crates/turbo-rcstr/src/lib.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 14,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/2689a741014f57c3fbda32cb488f67607fbc6fe6/turbopack%2Fcrates%2Fturbo-rcstr%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2689a741014f57c3fbda32cb488f67607fbc6fe6/turbopack%2Fcrates%2Fturbo-rcstr%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-rcstr%2Fsrc%2Flib.rs?ref=2689a741014f57c3fbda32cb488f67607fbc6fe6",
            "patch": "@@ -11,17 +11,18 @@ use std::{\n \n use bytes_str::BytesStr;\n use debug_unreachable::debug_unreachable;\n-use serde::{Deserialize, Deserializer, Serialize, Serializer};\n use shrink_to_fit::ShrinkToFit;\n use triomphe::Arc;\n use turbo_tasks_hash::{DeterministicHash, DeterministicHasher};\n \n+pub use crate::serde::{set_de_map, set_ser_map};\n use crate::{\n     dynamic::{deref_from, new_atom},\n     tagged_value::TaggedValue,\n };\n \n mod dynamic;\n+mod serde;\n mod tagged_value;\n \n /// An immutable reference counted [`String`], similar to [`Arc<String>`][std::sync::Arc].\n@@ -318,19 +319,6 @@ impl Hash for RcStr {\n     }\n }\n \n-impl Serialize for RcStr {\n-    fn serialize<S: Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {\n-        serializer.serialize_str(self.as_str())\n-    }\n-}\n-\n-impl<'de> Deserialize<'de> for RcStr {\n-    fn deserialize<D: Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {\n-        let s = String::deserialize(deserializer)?;\n-        Ok(RcStr::from(s))\n-    }\n-}\n-\n impl Drop for RcStr {\n     fn drop(&mut self) {\n         if self.tag() == DYNAMIC_TAG {"
        },
        {
            "sha": "ebac2688f6cb4cd19855eb8460dfa2269bea2e02",
            "filename": "turbopack/crates/turbo-rcstr/src/serde.rs",
            "status": "added",
            "additions": 99,
            "deletions": 0,
            "changes": 99,
            "blob_url": "https://github.com/vercel/next.js/blob/2689a741014f57c3fbda32cb488f67607fbc6fe6/turbopack%2Fcrates%2Fturbo-rcstr%2Fsrc%2Fserde.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2689a741014f57c3fbda32cb488f67607fbc6fe6/turbopack%2Fcrates%2Fturbo-rcstr%2Fsrc%2Fserde.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-rcstr%2Fsrc%2Fserde.rs?ref=2689a741014f57c3fbda32cb488f67607fbc6fe6",
            "patch": "@@ -0,0 +1,99 @@\n+use std::{cell::RefCell, hash::BuildHasherDefault};\n+\n+use indexmap::IndexSet;\n+use rustc_hash::FxHasher;\n+use scoped_tls::scoped_thread_local;\n+use serde::{Deserialize, Deserializer, Serialize, Serializer};\n+\n+use crate::RcStr;\n+\n+scoped_thread_local!(\n+    /// Map of strings to their interned ids.\n+    ///\n+    /// This is used to serialize strings to their interned ids.\n+    static SER_MAP: RefCell<IndexSet<RcStr, BuildHasherDefault<FxHasher>>>\n+);\n+\n+scoped_thread_local!(\n+    /// Read-only map interned ids to their strings\n+    static DE_MAP: Vec<RcStr>\n+);\n+\n+pub fn set_ser_map<F, R>(f: F) -> (R, IndexSet<RcStr, BuildHasherDefault<FxHasher>>)\n+where\n+    F: FnOnce() -> R,\n+{\n+    let map = Default::default();\n+\n+    let r = { SER_MAP.set(&map, f) };\n+\n+    (r, map.into_inner())\n+}\n+\n+pub fn set_de_map<F, R>(map: &Vec<RcStr>, f: F) -> R\n+where\n+    F: FnOnce() -> R,\n+{\n+    DE_MAP.set(map, f)\n+}\n+\n+/// Intern a string for serialization.\n+///\n+/// This function exists to move the logic for accessing the SER_MAP out of the hot path of\n+/// `Serialize::serialize`.\n+#[inline(never)]\n+fn intern_for_serialize(str: &RcStr) -> Option<u32> {\n+    if !SER_MAP.is_set() {\n+        return None;\n+    }\n+\n+    Some(SER_MAP.with(|ser| {\n+        let mut borrow = ser.borrow_mut();\n+        if let Some(id) = borrow.get_index_of(str) {\n+            id as u32\n+        } else {\n+            let id = borrow.len();\n+            borrow.insert(str.clone());\n+            id as u32\n+        }\n+    }))\n+}\n+\n+impl Serialize for RcStr {\n+    fn serialize<S: Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {\n+        // If it's too short, it's not worth interning.\n+        // If it's too long, it's unlikely to be repeated.\n+        if self.len() >= 3 && self.len() < 512 {\n+            let id = intern_for_serialize(self);\n+            if let Some(id) = id {\n+                return serializer.serialize_u32(id);\n+            }\n+        }\n+\n+        serializer.serialize_str(self.as_str())\n+    }\n+}\n+\n+impl<'de> Deserialize<'de> for RcStr {\n+    fn deserialize<D: Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {\n+        use serde::de::Error;\n+        #[derive(Deserialize)]\n+        #[serde(untagged)]\n+        enum Repr {\n+            Id(u32),\n+            String(String),\n+        }\n+\n+        let repr = Repr::deserialize(deserializer)?;\n+\n+        match repr {\n+            Repr::String(s) => Ok(RcStr::from(s)),\n+            Repr::Id(id) => DE_MAP.with(|map| {\n+                let s = map\n+                    .get(id as usize)\n+                    .ok_or_else(|| D::Error::custom(format!(\"failed to find id: {id}\")))?;\n+                Ok(s.clone())\n+            }),\n+        }\n+    }\n+}"
        },
        {
            "sha": "1c0bfb6d5f02e89da500399007c4733a2a361746",
            "filename": "turbopack/crates/turbo-tasks-backend/Cargo.toml",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/2689a741014f57c3fbda32cb488f67607fbc6fe6/turbopack%2Fcrates%2Fturbo-tasks-backend%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/2689a741014f57c3fbda32cb488f67607fbc6fe6/turbopack%2Fcrates%2Fturbo-tasks-backend%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2FCargo.toml?ref=2689a741014f57c3fbda32cb488f67607fbc6fe6",
            "patch": "@@ -42,9 +42,10 @@ rayon = { workspace = true }\n ringmap = { workspace = true, features = [\"serde\"] }\n rustc-hash = { workspace = true }\n serde = { workspace = true }\n+serde_bytes = { workspace = true }\n serde_json = { workspace = true }\n serde_path_to_error = { workspace = true }\n-smallvec = { workspace = true }\n+smallvec = { workspace = true, features = [\"write\"] }\n tokio = { workspace = true }\n tracing = { workspace = true }\n thread_local = { workspace = true }"
        },
        {
            "sha": "7f48b6f214d66532a129177bfcc83ec41cc9b5ed",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 7,
            "deletions": 3,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/2689a741014f57c3fbda32cb488f67607fbc6fe6/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2689a741014f57c3fbda32cb488f67607fbc6fe6/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=2689a741014f57c3fbda32cb488f67607fbc6fe6",
            "patch": "@@ -62,6 +62,7 @@ use crate::{\n         CachedDataItemValueRef, CellRef, CollectibleRef, CollectiblesRef, DirtyState,\n         InProgressCellState, InProgressState, InProgressStateInner, OutputValue, RootType,\n     },\n+    interning_serde::RcStrToLocalId,\n     utils::{\n         bi_map::BiMap, chunked_vec::ChunkedVec, ptr_eq_arc::PtrEqArc, sharded::Sharded, swap_retain,\n     },\n@@ -962,12 +963,14 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         let task_snapshots = snapshot\n             .into_iter()\n             .filter_map(|iter| {\n+                type SerializedData = (SmallVec<[u8; 16]>, RcStrToLocalId);\n+\n                 let mut iter = iter\n                     .filter_map(\n                         |(task_id, meta, data): (\n                             _,\n-                            Option<Result<SmallVec<_>>>,\n-                            Option<Result<SmallVec<_>>>,\n+                            Option<Result<SerializedData>>,\n+                            Option<Result<SerializedData>>,\n                         )| {\n                             let meta = match meta {\n                                 Some(Ok(meta)) => {\n@@ -1169,7 +1172,8 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             .flatten();\n         let task_id = {\n             // Safety: `tx` is a valid transaction from `self.backend.backing_storage`.\n-            if let Some(task_id) = unsafe {\n+            if let Some((task_id, _rcstr_map)) = unsafe {\n+                // We can ignore rcstr_map because those are all already stored in the database.\n                 self.backing_storage\n                     .forward_lookup_task_cache(tx.as_ref(), &task_type)\n                     .expect(\"Failed to lookup task id\")"
        },
        {
            "sha": "31af9a9a75682097752d2e9b136cc7950eab84ec",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backing_storage.rs",
            "status": "modified",
            "additions": 8,
            "deletions": 4,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/2689a741014f57c3fbda32cb488f67607fbc6fe6/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbacking_storage.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2689a741014f57c3fbda32cb488f67607fbc6fe6/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbacking_storage.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbacking_storage.rs?ref=2689a741014f57c3fbda32cb488f67607fbc6fe6",
            "patch": "@@ -7,6 +7,7 @@ use turbo_tasks::{SessionId, TaskId, backend::CachedTaskType};\n use crate::{\n     backend::{AnyOperation, TaskDataCategory},\n     data::CachedDataItem,\n+    interning_serde::RcStrToLocalId,\n     utils::chunked_vec::ChunkedVec,\n };\n \n@@ -48,7 +49,10 @@ pub trait BackingStorageSealed: 'static + Send + Sync {\n     fn next_session_id(&self) -> Result<SessionId>;\n     fn uncompleted_operations(&self) -> Result<Vec<AnyOperation>>;\n     #[allow(clippy::ptr_arg)]\n-    fn serialize(task: TaskId, data: &Vec<CachedDataItem>) -> Result<SmallVec<[u8; 16]>>;\n+    fn serialize(\n+        task: TaskId,\n+        data: &Vec<CachedDataItem>,\n+    ) -> Result<(SmallVec<[u8; 16]>, RcStrToLocalId)>;\n     fn save_snapshot<I>(\n         &self,\n         session_id: SessionId,\n@@ -60,8 +64,8 @@ pub trait BackingStorageSealed: 'static + Send + Sync {\n         I: Iterator<\n                 Item = (\n                     TaskId,\n-                    Option<SmallVec<[u8; 16]>>,\n-                    Option<SmallVec<[u8; 16]>>,\n+                    Option<(SmallVec<[u8; 16]>, RcStrToLocalId)>,\n+                    Option<(SmallVec<[u8; 16]>, RcStrToLocalId)>,\n                 ),\n             > + Send\n             + Sync;\n@@ -73,7 +77,7 @@ pub trait BackingStorageSealed: 'static + Send + Sync {\n         &self,\n         tx: Option<&Self::ReadTransaction<'_>>,\n         key: &CachedTaskType,\n-    ) -> Result<Option<TaskId>>;\n+    ) -> Result<Option<(TaskId, RcStrToLocalId)>>;\n     /// # Safety\n     ///\n     /// `tx` must be a transaction from this BackingStorage instance."
        },
        {
            "sha": "2e2ab005585a3dac63aa0dec98a0d23e2d0957df",
            "filename": "turbopack/crates/turbo-tasks-backend/src/database/key_value_database.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/2689a741014f57c3fbda32cb488f67607fbc6fe6/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdatabase%2Fkey_value_database.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2689a741014f57c3fbda32cb488f67607fbc6fe6/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdatabase%2Fkey_value_database.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdatabase%2Fkey_value_database.rs?ref=2689a741014f57c3fbda32cb488f67607fbc6fe6",
            "patch": "@@ -11,6 +11,8 @@ pub enum KeySpace {\n     TaskData = 2,\n     ForwardTaskCache = 3,\n     ReverseTaskCache = 4,\n+    StringInternMap = 5,\n+    ReverseStringInternMap = 6,\n }\n \n pub trait KeyValueDatabase {"
        },
        {
            "sha": "4abe26c8e73003504601cb866e680288ac716b44",
            "filename": "turbopack/crates/turbo-tasks-backend/src/database/turbo.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/2689a741014f57c3fbda32cb488f67607fbc6fe6/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdatabase%2Fturbo.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2689a741014f57c3fbda32cb488f67607fbc6fe6/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdatabase%2Fturbo.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdatabase%2Fturbo.rs?ref=2689a741014f57c3fbda32cb488f67607fbc6fe6",
            "patch": "@@ -112,7 +112,7 @@ impl KeyValueDatabase for TurboKeyValueDatabase {\n }\n \n pub struct TurboWriteBatch<'a> {\n-    batch: turbo_persistence::WriteBatch<WriteBuffer<'static>, 5>,\n+    batch: turbo_persistence::WriteBatch<WriteBuffer<'static>, 7>,\n     db: &'a Arc<TurboPersistence>,\n     compact_join_handle: &'a Mutex<Option<JoinHandle<Result<()>>>>,\n     initial_write: bool,"
        },
        {
            "sha": "fa9f3e83761638a4e92b4e09c6af28f44fdc108c",
            "filename": "turbopack/crates/turbo-tasks-backend/src/interning_serde/mod.rs",
            "status": "added",
            "additions": 104,
            "deletions": 0,
            "changes": 104,
            "blob_url": "https://github.com/vercel/next.js/blob/2689a741014f57c3fbda32cb488f67607fbc6fe6/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Finterning_serde%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2689a741014f57c3fbda32cb488f67607fbc6fe6/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Finterning_serde%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Finterning_serde%2Fmod.rs?ref=2689a741014f57c3fbda32cb488f67607fbc6fe6",
            "patch": "@@ -0,0 +1,104 @@\n+//! Exposed for usage in `turbo-tasks-backend`\n+\n+use std::io::Write;\n+\n+use serde::{Deserialize, Serialize};\n+use turbo_rcstr::RcStr;\n+use turbo_tasks::FxIndexSet;\n+\n+pub fn to_vec<T>(config: &pot::Config, value: &T) -> anyhow::Result<(Vec<u8>, RcStrToLocalId)>\n+where\n+    T: Serialize,\n+{\n+    let mut vec = Vec::new();\n+    let ser_map = to_writer(config, value, &mut vec)?;\n+    Ok((vec, ser_map))\n+}\n+\n+pub struct LocalIdToRcStr(Vec<RcStr>);\n+\n+impl From<Vec<RcStr>> for LocalIdToRcStr {\n+    fn from(value: Vec<RcStr>) -> Self {\n+        Self(value)\n+    }\n+}\n+\n+#[derive(Default)]\n+pub struct RcStrToLocalId(FxIndexSet<RcStr>);\n+\n+impl RcStrToLocalId {\n+    pub fn iter(&self) -> impl Iterator<Item = &RcStr> {\n+        self.0.iter()\n+    }\n+}\n+\n+#[derive(Default)]\n+pub struct LocalIdToGlobalId(Vec<u32>);\n+\n+impl From<Vec<u32>> for LocalIdToGlobalId {\n+    fn from(value: Vec<u32>) -> Self {\n+        Self(value)\n+    }\n+}\n+\n+impl LocalIdToGlobalId {\n+    pub fn len(&self) -> usize {\n+        self.0.len()\n+    }\n+\n+    pub fn iter(&self) -> impl '_ + Iterator<Item = u32> {\n+        self.0.iter().copied()\n+    }\n+\n+    pub fn write_to(&self, writer: &mut impl Write) -> anyhow::Result<()> {\n+        let len = self.0.len() as u32;\n+        for id in self.0.iter().rev() {\n+            writer.write_all(&id.to_le_bytes())?;\n+        }\n+\n+        writer.write_all(&len.to_le_bytes())?;\n+\n+        Ok(())\n+    }\n+\n+    pub fn read_from_slice(mut bytes: &[u8]) -> anyhow::Result<(Self, &[u8])> {\n+        let mut global_ids = Vec::new();\n+\n+        // Length is the last 4 bytes\n+        let len = u32::from_le_bytes(bytes[bytes.len() - 4..].try_into().unwrap());\n+        global_ids.reserve(len as usize);\n+\n+        bytes = &bytes[..bytes.len() - 4];\n+\n+        // Read the ids in reverse order\n+        for _ in 0..len {\n+            let id = u32::from_le_bytes(bytes[bytes.len() - 4..].try_into().unwrap());\n+            global_ids.push(id);\n+            bytes = &bytes[..bytes.len() - 4];\n+        }\n+\n+        Ok((Self(global_ids), bytes))\n+    }\n+}\n+\n+pub fn to_writer<T, W>(config: &pot::Config, value: &T, writer: W) -> anyhow::Result<RcStrToLocalId>\n+where\n+    T: Serialize,\n+    W: Write,\n+{\n+    let (result, ser_map) = turbo_rcstr::set_ser_map(|| config.serialize_into(value, writer));\n+    result?;\n+\n+    Ok(RcStrToLocalId(ser_map))\n+}\n+\n+pub fn from_slice<'de, T>(\n+    config: &pot::Config,\n+    bytes: &'de [u8],\n+    de_map: &LocalIdToRcStr,\n+) -> anyhow::Result<T>\n+where\n+    T: Deserialize<'de>,\n+{\n+    turbo_rcstr::set_de_map(&de_map.0, || Ok(config.deserialize(bytes)?))\n+}"
        },
        {
            "sha": "9599893cbd9dc8f02d4a8a5f36a2735cdb043c1e",
            "filename": "turbopack/crates/turbo-tasks-backend/src/kv_backing_storage.rs",
            "status": "modified",
            "additions": 274,
            "deletions": 43,
            "changes": 317,
            "blob_url": "https://github.com/vercel/next.js/blob/2689a741014f57c3fbda32cb488f67607fbc6fe6/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fkv_backing_storage.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2689a741014f57c3fbda32cb488f67607fbc6fe6/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fkv_backing_storage.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fkv_backing_storage.rs?ref=2689a741014f57c3fbda32cb488f67607fbc6fe6",
            "patch": "@@ -3,16 +3,21 @@ use std::{\n     cmp::max,\n     env,\n     path::PathBuf,\n-    sync::{Arc, LazyLock, Mutex, PoisonError, Weak},\n+    sync::{\n+        Arc, LazyLock, Mutex, OnceLock, PoisonError, Weak,\n+        atomic::{AtomicU32, Ordering},\n+    },\n };\n \n-use anyhow::{Context, Result, anyhow};\n+use anyhow::{Context, Result, anyhow, bail};\n use rayon::iter::{IndexedParallelIterator, IntoParallelIterator, ParallelIterator};\n+use rustc_hash::FxHashMap;\n use serde::{Deserialize, Serialize};\n use smallvec::SmallVec;\n use tracing::Span;\n+use turbo_rcstr::RcStr;\n use turbo_tasks::{\n-    SessionId, TaskId,\n+    FxDashMap, SessionId, TaskId,\n     backend::CachedTaskType,\n     panic_hooks::{PanicHookGuard, register_panic_hook},\n     turbo_tasks_scope,\n@@ -33,12 +38,16 @@ use crate::{\n         },\n     },\n     db_invalidation::invalidation_reasons,\n+    interning_serde,\n+    interning_serde::{LocalIdToGlobalId, LocalIdToRcStr, RcStrToLocalId},\n     utils::chunked_vec::ChunkedVec,\n };\n \n const POT_CONFIG: pot::Config = pot::Config::new().compatibility(pot::Compatibility::V4);\n \n-fn pot_serialize_small_vec<T: Serialize>(value: &T) -> pot::Result<SmallVec<[u8; 16]>> {\n+fn pot_serialize_small_vec<T: Serialize>(\n+    value: &T,\n+) -> Result<(SmallVec<[u8; 16]>, RcStrToLocalId)> {\n     struct SmallVecWrite<'l>(&'l mut SmallVec<[u8; 16]>);\n     impl std::io::Write for SmallVecWrite<'_> {\n         #[inline]\n@@ -60,8 +69,8 @@ fn pot_serialize_small_vec<T: Serialize>(value: &T) -> pot::Result<SmallVec<[u8;\n     }\n \n     let mut output = SmallVec::new();\n-    POT_CONFIG.serialize_into(value, SmallVecWrite(&mut output))?;\n-    Ok(output)\n+    let ser_map = interning_serde::to_writer(&POT_CONFIG, value, SmallVecWrite(&mut output))?;\n+    Ok((output, ser_map))\n }\n \n fn pot_ser_symbol_map() -> pot::ser::SymbolMap {\n@@ -75,6 +84,7 @@ fn pot_de_symbol_list<'l>() -> pot::de::SymbolList<'l> {\n const META_KEY_OPERATIONS: u32 = 0;\n const META_KEY_NEXT_FREE_TASK_ID: u32 = 1;\n const META_KEY_SESSION_ID: u32 = 2;\n+const META_KEY_NEXT_STRING_ID: u32 = 3;\n \n struct IntKey([u8; 4]);\n \n@@ -298,13 +308,16 @@ impl<T: KeyValueDatabase + Send + Sync + 'static> BackingStorageSealed\n             else {\n                 return Ok(Vec::new());\n             };\n-            let operations = deserialize_with_good_error(operations.borrow())?;\n+            let operations = deserialize_with_good_error(database, &tx, operations.borrow())?;\n             Ok(operations)\n         }\n         get(&self.inner.database).context(\"Unable to read uncompleted operations from database\")\n     }\n \n-    fn serialize(task: TaskId, data: &Vec<CachedDataItem>) -> Result<SmallVec<[u8; 16]>> {\n+    fn serialize(\n+        task: TaskId,\n+        data: &Vec<CachedDataItem>,\n+    ) -> Result<(SmallVec<[u8; 16]>, RcStrToLocalId)> {\n         serialize(task, data)\n     }\n \n@@ -319,8 +332,8 @@ impl<T: KeyValueDatabase + Send + Sync + 'static> BackingStorageSealed\n         I: Iterator<\n                 Item = (\n                     TaskId,\n-                    Option<SmallVec<[u8; 16]>>,\n-                    Option<SmallVec<[u8; 16]>>,\n+                    Option<(SmallVec<[u8; 16]>, RcStrToLocalId)>,\n+                    Option<(SmallVec<[u8; 16]>, RcStrToLocalId)>,\n                 ),\n             > + Send\n             + Sync,\n@@ -366,7 +379,11 @@ impl<T: KeyValueDatabase + Send + Sync + 'static> BackingStorageSealed\n                             let mut task_type_bytes = Vec::new();\n                             for (task_type, task_id) in updates {\n                                 let task_id: u32 = *task_id;\n-                                serialize_task_type(&task_type, &mut task_type_bytes, task_id)?;\n+                                let rcstr_map =\n+                                    serialize_task_type(&task_type, &mut task_type_bytes, task_id)?;\n+\n+                                let global_ids = save_strings_concurrent(batch, &rcstr_map)?;\n+                                global_ids.write_to(&mut task_type_bytes)?;\n \n                                 batch\n                                     .put(\n@@ -436,7 +453,11 @@ impl<T: KeyValueDatabase + Send + Sync + 'static> BackingStorageSealed\n                         let mut task_type_bytes = Vec::new();\n                         for (task_type, task_id) in task_cache_updates.into_iter().flatten() {\n                             let task_id = *task_id;\n-                            serialize_task_type(&task_type, &mut task_type_bytes, task_id)?;\n+                            let rcstr_map =\n+                                serialize_task_type(&task_type, &mut task_type_bytes, task_id)?;\n+\n+                            let global_ids = save_strings_serial(batch, &rcstr_map)?;\n+                            global_ids.write_to(&mut task_type_bytes)?;\n \n                             batch\n                                 .put(\n@@ -474,16 +495,30 @@ impl<T: KeyValueDatabase + Send + Sync + 'static> BackingStorageSealed\n                     for (task_id, meta, data) in task_items_result?.into_iter().flatten() {\n                         let key = IntKey::new(*task_id);\n                         let key = key.as_ref();\n-                        if let Some(meta) = meta {\n+                        if let Some((mut meta, rcstr_map)) = meta {\n+                            let global_ids = save_strings_serial(batch, &rcstr_map)?;\n+                            global_ids.write_to(&mut meta)?;\n+\n                             batch\n-                                .put(KeySpace::TaskMeta, WriteBuffer::Borrowed(key), meta)\n+                                .put(\n+                                    KeySpace::TaskMeta,\n+                                    WriteBuffer::Borrowed(key),\n+                                    WriteBuffer::SmallVec(meta),\n+                                )\n                                 .with_context(|| {\n                                     anyhow!(\"Unable to write meta items for {task_id}\")\n                                 })?;\n                         }\n-                        if let Some(data) = data {\n+                        if let Some((mut data, rcstr_map)) = data {\n+                            let global_ids = save_strings_serial(batch, &rcstr_map)?;\n+                            global_ids.write_to(&mut data)?;\n+\n                             batch\n-                                .put(KeySpace::TaskData, WriteBuffer::Borrowed(key), data)\n+                                .put(\n+                                    KeySpace::TaskData,\n+                                    WriteBuffer::Borrowed(key),\n+                                    WriteBuffer::SmallVec(data),\n+                                )\n                                 .with_context(|| {\n                                     anyhow!(\"Unable to write data items for {task_id}\")\n                                 })?;\n@@ -510,21 +545,22 @@ impl<T: KeyValueDatabase + Send + Sync + 'static> BackingStorageSealed\n         &self,\n         tx: Option<&T::ReadTransaction<'_>>,\n         task_type: &CachedTaskType,\n-    ) -> Result<Option<TaskId>> {\n-        let inner = &*self.inner;\n+    ) -> Result<Option<(TaskId, RcStrToLocalId)>> {\n         fn lookup<D: KeyValueDatabase>(\n             database: &D,\n             tx: &D::ReadTransaction<'_>,\n             task_type: &CachedTaskType,\n-        ) -> Result<Option<TaskId>> {\n-            let task_type = POT_CONFIG.serialize(task_type)?;\n+        ) -> Result<Option<(TaskId, RcStrToLocalId)>> {\n+            let (task_type, map) = interning_serde::to_vec(&POT_CONFIG, task_type)?;\n             let Some(bytes) = database.get(tx, KeySpace::ForwardTaskCache, &task_type)? else {\n                 return Ok(None);\n             };\n             let bytes = bytes.borrow().try_into()?;\n             let id = TaskId::try_from(u32::from_le_bytes(bytes)).unwrap();\n-            Ok(Some(id))\n+            Ok(Some((id, map)))\n         }\n+\n+        let inner = &*self.inner;\n         if inner.database.is_empty() {\n             // Checking if the database is empty is a performance optimization\n             // to avoid serializing the task type.\n@@ -554,7 +590,11 @@ impl<T: KeyValueDatabase + Send + Sync + 'static> BackingStorageSealed\n             else {\n                 return Ok(None);\n             };\n-            Ok(Some(deserialize_with_good_error(bytes.borrow())?))\n+            Ok(Some(deserialize_with_good_error(\n+                database,\n+                tx,\n+                bytes.borrow(),\n+            )?))\n         }\n         inner\n             .with_tx(tx, |tx| lookup(&inner.database, tx, task_id))\n@@ -586,7 +626,8 @@ impl<T: KeyValueDatabase + Send + Sync + 'static> BackingStorageSealed\n             else {\n                 return Ok(Vec::new());\n             };\n-            let result: Vec<CachedDataItem> = deserialize_with_good_error(bytes.borrow())?;\n+            let result: Vec<CachedDataItem> =\n+                deserialize_with_good_error(database, tx, bytes.borrow())?;\n             Ok(result)\n         }\n         inner\n@@ -599,6 +640,55 @@ impl<T: KeyValueDatabase + Send + Sync + 'static> BackingStorageSealed\n     }\n }\n \n+fn restore_strings<D: KeyValueDatabase>(\n+    database: &D,\n+    tx: &D::ReadTransaction<'_>,\n+    global_ids: &LocalIdToGlobalId,\n+) -> Result<LocalIdToRcStr> {\n+    let mut map = Vec::with_capacity(global_ids.len());\n+\n+    for global_id in global_ids.iter() {\n+        // First, check the in-memory cache\n+        let rcstr = {\n+            let cache = STRING_CACHE.lock().unwrap_or_else(PoisonError::into_inner);\n+            cache.get(&global_id).cloned()\n+        };\n+\n+        let rcstr = if let Some(rcstr) = rcstr {\n+            // Cache hit\n+            rcstr\n+        } else {\n+            // Cache miss, fetch from database\n+            let Some(value) = database.get(\n+                tx,\n+                KeySpace::ReverseStringInternMap,\n+                IntKey::new(global_id).as_ref(),\n+            )?\n+            else {\n+                bail!(\"Unable to find string for {global_id}\")\n+            };\n+\n+            let mut rcstr = unsafe {\n+                // Safety: We interned a rust string, so it is valid utf-8\n+                RcStr::from(str::from_utf8_unchecked(value.borrow()))\n+            };\n+\n+            // Update both caches\n+            {\n+                let mut cache = STRING_CACHE.lock().unwrap_or_else(PoisonError::into_inner);\n+                rcstr = cache.entry(global_id).or_insert(rcstr).clone();\n+            }\n+            STRING_TO_ID_CACHE.insert(rcstr.clone(), global_id);\n+\n+            rcstr\n+        };\n+\n+        map.push(rcstr);\n+    }\n+\n+    Ok(map.into())\n+}\n+\n fn get_next_free_task_id<'a, S, C>(\n     batch: &mut WriteBatchRef<'_, 'a, S, C>,\n ) -> Result<u32, anyhow::Error>\n@@ -649,8 +739,15 @@ where\n     {\n         let _span =\n             tracing::trace_span!(\"update operations\", operations = operations.len()).entered();\n-        let operations = pot_serialize_small_vec(&operations)\n+        let (mut operations, rcstr_map) = pot_serialize_small_vec(&operations)\n             .with_context(|| anyhow!(\"Unable to serialize operations\"))?;\n+        let global_ids = match batch {\n+            WriteBatchRef::Serial(_) => save_strings_serial(batch, &rcstr_map)?,\n+            WriteBatchRef::Concurrent(batch, _) => save_strings_concurrent(&**batch, &rcstr_map)?,\n+        };\n+        // Prepend the global ids to the operations\n+        global_ids.write_to(&mut operations)?;\n+\n         batch\n             .put(\n                 KeySpace::Infra,\n@@ -659,18 +756,33 @@ where\n             )\n             .with_context(|| anyhow!(\"Unable to write operations\"))?;\n     }\n+\n+    if let Some(next_string_id) = STRING_INTERN_ID.get() {\n+        let _span = tracing::trace_span!(\"update next string id\").entered();\n+\n+        let next_string_id = next_string_id.load(Ordering::SeqCst);\n+\n+        batch\n+            .put(\n+                KeySpace::Infra,\n+                WriteBuffer::Borrowed(IntKey::new(META_KEY_NEXT_STRING_ID).as_ref()),\n+                WriteBuffer::Borrowed(&next_string_id.to_le_bytes()),\n+            )\n+            .with_context(|| anyhow!(\"Unable to write next string id\"))?;\n+    }\n+\n     batch.flush(KeySpace::Infra)?;\n+\n     Ok(())\n }\n \n fn serialize_task_type(\n     task_type: &Arc<CachedTaskType>,\n     mut task_type_bytes: &mut Vec<u8>,\n     task_id: u32,\n-) -> Result<()> {\n+) -> Result<RcStrToLocalId> {\n     task_type_bytes.clear();\n-    POT_CONFIG\n-        .serialize_into(&**task_type, &mut task_type_bytes)\n+    let result = interning_serde::to_writer(&POT_CONFIG, task_type, &mut task_type_bytes)\n         .with_context(|| anyhow!(\"Unable to serialize task {task_id} cache key {task_type:?}\"))?;\n     #[cfg(feature = \"verify_serialization\")]\n     {\n@@ -682,14 +794,14 @@ fn serialize_task_type(\n             panic!(\"Task type would not be deserializable {task_id}: {err:?}\");\n         }\n     }\n-    Ok(())\n+    Ok(result)\n }\n \n type SerializedTasks = Vec<\n     Vec<(\n         TaskId,\n-        Option<WriteBuffer<'static>>,\n-        Option<WriteBuffer<'static>>,\n+        Option<(SmallVec<[u8; 16]>, RcStrToLocalId)>,\n+        Option<(SmallVec<[u8; 16]>, RcStrToLocalId)>,\n     )>,\n >;\n \n@@ -701,8 +813,8 @@ where\n     I: Iterator<\n             Item = (\n                 TaskId,\n-                Option<SmallVec<[u8; 16]>>,\n-                Option<SmallVec<[u8; 16]>>,\n+                Option<(SmallVec<[u8; 16]>, RcStrToLocalId)>,\n+                Option<(SmallVec<[u8; 16]>, RcStrToLocalId)>,\n             ),\n         > + Send\n         + Sync,\n@@ -721,14 +833,20 @@ where\n                     if let Some(batch) = batch {\n                         let key = IntKey::new(*task_id);\n                         let key = key.as_ref();\n-                        if let Some(meta) = meta {\n+                        if let Some((mut meta, rcstr_map)) = meta {\n+                            let global_ids = save_strings_concurrent(batch, &rcstr_map)?;\n+                            global_ids.write_to(&mut meta)?;\n+\n                             batch.put(\n                                 KeySpace::TaskMeta,\n                                 WriteBuffer::Borrowed(key),\n                                 WriteBuffer::SmallVec(meta),\n                             )?;\n                         }\n-                        if let Some(data) = data {\n+                        if let Some((mut data, rcstr_map)) = data {\n+                            let global_ids = save_strings_concurrent(batch, &rcstr_map)?;\n+                            global_ids.write_to(&mut data)?;\n+\n                             batch.put(\n                                 KeySpace::TaskData,\n                                 WriteBuffer::Borrowed(key),\n@@ -737,11 +855,7 @@ where\n                         }\n                     } else {\n                         // Store the new task data\n-                        result.push((\n-                            task_id,\n-                            meta.map(WriteBuffer::SmallVec),\n-                            data.map(WriteBuffer::SmallVec),\n-                        ));\n+                        result.push((task_id, meta, data));\n                     }\n                 }\n \n@@ -751,7 +865,10 @@ where\n         .collect::<Result<Vec<_>>>()\n }\n \n-fn serialize(task: TaskId, data: &Vec<CachedDataItem>) -> Result<SmallVec<[u8; 16]>> {\n+fn serialize(\n+    task: TaskId,\n+    data: &Vec<CachedDataItem>,\n+) -> Result<(SmallVec<[u8; 16]>, RcStrToLocalId)> {\n     Ok(match pot_serialize_small_vec(data) {\n         #[cfg(not(feature = \"verify_serialization\"))]\n         Ok(value) => value,\n@@ -797,14 +914,128 @@ fn serialize(task: TaskId, data: &Vec<CachedDataItem>) -> Result<SmallVec<[u8; 1\n     })\n }\n \n-fn deserialize_with_good_error<'de, T: Deserialize<'de>>(data: &'de [u8]) -> Result<T> {\n-    match POT_CONFIG.deserialize(data) {\n+fn deserialize_with_good_error<'de, D: KeyValueDatabase, T: Deserialize<'de>>(\n+    database: &D,\n+    tx: &D::ReadTransaction<'_>,\n+    data: &'de [u8],\n+) -> Result<T> {\n+    let (global_ids, data) = LocalIdToGlobalId::read_from_slice(data)?;\n+    let map = restore_strings(database, tx, &global_ids)?;\n+\n+    match interning_serde::from_slice::<T>(&POT_CONFIG, data, &map) {\n         Ok(value) => Ok(value),\n         Err(error) => serde_path_to_error::deserialize::<'_, _, T>(\n             &mut pot_de_symbol_list().deserializer_for_slice(data)?,\n         )\n         .map_err(anyhow::Error::from)\n-        .and(Err(error.into()))\n+        .and(Err(error))\n         .context(\"Deserialization failed\"),\n     }\n }\n+\n+/// Store the strings in the database and return the global ids.\n+fn save_strings_serial<'a>(\n+    batch: &mut impl SerialWriteBatch<'a>,\n+    strings: &RcStrToLocalId,\n+) -> Result<LocalIdToGlobalId> {\n+    let mut global_ids = Vec::new();\n+    for s in strings.iter() {\n+        let (global_id, is_new) = get_string_id(batch, s)?;\n+        if is_new {\n+            batch.put(\n+                KeySpace::StringInternMap,\n+                WriteBuffer::Borrowed(s.as_bytes()),\n+                WriteBuffer::Borrowed(&global_id.to_le_bytes()),\n+            )?;\n+            batch.put(\n+                KeySpace::ReverseStringInternMap,\n+                WriteBuffer::Borrowed(IntKey::new(global_id).as_ref()),\n+                WriteBuffer::Borrowed(s.as_bytes()),\n+            )?;\n+        }\n+\n+        global_ids.push(global_id);\n+    }\n+\n+    Ok(LocalIdToGlobalId::from(global_ids))\n+}\n+/// Store the strings in the database and return the global ids.\n+fn save_strings_concurrent<'a>(\n+    batch: &impl ConcurrentWriteBatch<'a>,\n+    strings: &RcStrToLocalId,\n+) -> Result<LocalIdToGlobalId> {\n+    let mut global_ids = Vec::new();\n+    for s in strings.iter() {\n+        let (global_id, is_new) = get_string_id(batch, s)?;\n+        if is_new {\n+            batch.put(\n+                KeySpace::StringInternMap,\n+                WriteBuffer::Borrowed(s.as_bytes()),\n+                WriteBuffer::Borrowed(&global_id.to_le_bytes()),\n+            )?;\n+            batch.put(\n+                KeySpace::ReverseStringInternMap,\n+                WriteBuffer::Borrowed(IntKey::new(global_id).as_ref()),\n+                WriteBuffer::Borrowed(s.as_bytes()),\n+            )?;\n+        }\n+\n+        global_ids.push(global_id);\n+    }\n+\n+    Ok(LocalIdToGlobalId::from(global_ids))\n+}\n+\n+static STRING_INTERN_ID: OnceLock<AtomicU32> = OnceLock::new();\n+static STRING_CACHE: LazyLock<Mutex<FxHashMap<u32, RcStr>>> =\n+    LazyLock::new(|| Mutex::new(FxHashMap::default()));\n+static STRING_TO_ID_CACHE: LazyLock<FxDashMap<RcStr, u32>> = LazyLock::new(FxDashMap::default);\n+\n+/// Returns `(global_id, is_new)`\n+fn get_string_id<'a>(batch: &impl BaseWriteBatch<'a>, s: &RcStr) -> Result<(u32, bool)> {\n+    // First check the synchronization cache\n+    if let Some(global_id) = STRING_TO_ID_CACHE.get(s) {\n+        return Ok((*global_id, false));\n+    }\n+\n+    // Check the database\n+    let original = batch.get(KeySpace::StringInternMap, s.as_bytes())?;\n+\n+    if let Some(bytes) = original {\n+        let global_id = as_u32(bytes)?;\n+        // Cache the result for future lookups\n+        STRING_TO_ID_CACHE.insert(s.clone(), global_id);\n+        STRING_CACHE.lock().unwrap().insert(global_id, s.clone());\n+        return Ok((global_id, false));\n+    }\n+\n+    // Allocate a new ID\n+    let global_id = STRING_INTERN_ID\n+        .get_or_try_init(|| {\n+            let Some(bytes) = batch.get(\n+                KeySpace::Infra,\n+                IntKey::new(META_KEY_NEXT_STRING_ID).as_ref(),\n+            )?\n+            else {\n+                return anyhow::Ok(AtomicU32::new(0));\n+            };\n+\n+            let latest_id = as_u32(bytes)?;\n+\n+            Ok(AtomicU32::new(latest_id))\n+        })?\n+        .fetch_add(1, Ordering::Relaxed);\n+\n+    // Cache the new assignment to prevent duplicates within the same batch\n+    match STRING_TO_ID_CACHE.entry(s.clone()) {\n+        dashmap::Entry::Occupied(occupied_entry) => {\n+            return Ok((*occupied_entry.get(), false));\n+        }\n+        dashmap::Entry::Vacant(vacant_entry) => {\n+            vacant_entry.insert(global_id);\n+        }\n+    }\n+    STRING_CACHE.lock().unwrap().insert(global_id, s.clone());\n+\n+    Ok((global_id, true))\n+}"
        },
        {
            "sha": "e411d30d3182cc007722eec8449a2a9e16c30e34",
            "filename": "turbopack/crates/turbo-tasks-backend/src/lib.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/2689a741014f57c3fbda32cb488f67607fbc6fe6/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2689a741014f57c3fbda32cb488f67607fbc6fe6/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Flib.rs?ref=2689a741014f57c3fbda32cb488f67607fbc6fe6",
            "patch": "@@ -2,12 +2,13 @@\n #![feature(associated_type_defaults)]\n #![feature(iter_collect_into)]\n #![feature(box_patterns)]\n-\n+#![feature(once_cell_try)]\n mod backend;\n mod backing_storage;\n mod data;\n mod data_storage;\n mod database;\n+mod interning_serde;\n mod kv_backing_storage;\n mod utils;\n "
        }
    ],
    "stats": {
        "total": 584,
        "additions": 512,
        "deletions": 72
    }
}