{
    "author": "mischnic",
    "message": "Turbopack: map_module_batch (#83885)\n\nturbo-task-ify this loop body",
    "sha": "c0a3cfb625f5d4ead518a2c5bf37860185bb935f",
    "files": [
        {
            "sha": "c42f02f00427e2b9718e650667ab510759553b34",
            "filename": "turbopack/crates/turbopack-core/src/chunk/chunk_group.rs",
            "status": "modified",
            "additions": 72,
            "deletions": 51,
            "changes": 123,
            "blob_url": "https://github.com/vercel/next.js/blob/c0a3cfb625f5d4ead518a2c5bf37860185bb935f/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fchunk_group.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c0a3cfb625f5d4ead518a2c5bf37860185bb935f/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fchunk_group.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fchunk_group.rs?ref=c0a3cfb625f5d4ead518a2c5bf37860185bb935f",
            "patch": "@@ -1,8 +1,7 @@\n-use std::{collections::HashSet, sync::atomic::AtomicBool};\n+use std::{cell::RefCell, collections::HashSet};\n \n use anyhow::{Context, Result};\n use rustc_hash::FxHashMap;\n-use smallvec::{SmallVec, smallvec};\n use turbo_rcstr::rcstr;\n use turbo_tasks::{FxIndexSet, ResolvedVc, TryFlatJoinIterExt, TryJoinIterExt, Vc};\n \n@@ -19,7 +18,10 @@ use crate::{\n     module::Module,\n     module_graph::{\n         GraphTraversalAction, ModuleGraph,\n-        module_batch::{ChunkableModuleBatchGroup, ChunkableModuleOrBatch, ModuleOrBatch},\n+        merged_modules::MergedModuleInfo,\n+        module_batch::{\n+            ChunkableModuleBatchGroup, ChunkableModuleOrBatch, ModuleBatch, ModuleOrBatch,\n+        },\n         module_batches::{BatchingConfig, ModuleBatchesGraphEdge},\n     },\n     output::OutputAssets,\n@@ -321,83 +323,102 @@ pub async fn chunk_group_content(\n         .with_modules(Vc::cell(state.chunkable_items.clone()))\n         .await?;\n \n-    if should_merge_modules {\n-        let merged_modules = module_graph.merged_modules().await?;\n-        state.chunkable_items = state\n+    let should_merge_modules = if should_merge_modules {\n+        let merged_modules = module_graph.merged_modules();\n+        let merged_modules_ref = merged_modules.await?;\n+        Some((merged_modules, merged_modules_ref))\n+    } else {\n+        None\n+    };\n+\n+    let chunkable_items = if let Some((merged_modules, merged_modules_ref)) = &should_merge_modules\n+    {\n+        state\n             .chunkable_items\n             .into_iter()\n             .map(async |chunkable_module| match chunkable_module {\n                 ChunkableModuleOrBatch::Module(module) => {\n-                    if !merged_modules.should_create_chunk_item_for(ResolvedVc::upcast(module)) {\n-                        return Ok(smallvec![]);\n+                    if !merged_modules_ref.should_create_chunk_item_for(ResolvedVc::upcast(module))\n+                    {\n+                        return Ok(None);\n                     }\n \n                     let module = if let Some(replacement) =\n-                        merged_modules.should_replace_module(ResolvedVc::upcast(module))\n+                        merged_modules_ref.should_replace_module(ResolvedVc::upcast(module))\n                     {\n                         replacement\n                     } else {\n                         module\n                     };\n \n-                    Ok(smallvec![ChunkableModuleOrBatch::Module(module)])\n+                    Ok(Some(ChunkableModuleOrBatch::Module(module)))\n                 }\n-                ChunkableModuleOrBatch::Batch(batch) => {\n-                    let batch_ref = batch.await?;\n-                    let modules = &batch_ref.modules;\n-\n-                    let modified = AtomicBool::new(false);\n-                    let modules = modules\n-                        .iter()\n-                        .filter(|module| {\n-                            if merged_modules\n-                                .should_create_chunk_item_for(ResolvedVc::upcast(**module))\n-                            {\n-                                true\n-                            } else {\n-                                modified.store(true, std::sync::atomic::Ordering::Relaxed);\n-                                false\n-                            }\n-                        })\n-                        .map(|&module| {\n-                            if let Some(replacement) =\n-                                merged_modules.should_replace_module(ResolvedVc::upcast(module))\n-                            {\n-                                modified.store(true, std::sync::atomic::Ordering::Relaxed);\n-                                replacement\n-                            } else {\n-                                module\n-                            }\n-                        })\n-                        .map(ChunkableModuleOrBatch::Module)\n-                        .collect::<SmallVec<[_; 1]>>();\n-\n-                    if modified.load(std::sync::atomic::Ordering::Relaxed) {\n-                        Ok(modules)\n-                    } else {\n-                        Ok(smallvec![ChunkableModuleOrBatch::Batch(batch)])\n-                    }\n-                }\n-                ChunkableModuleOrBatch::None(i) => Ok(smallvec![ChunkableModuleOrBatch::None(i)]),\n+                ChunkableModuleOrBatch::Batch(batch) => Ok(Some(ChunkableModuleOrBatch::Batch(\n+                    map_module_batch(*merged_modules, *batch)\n+                        .to_resolved()\n+                        .await?,\n+                ))),\n+                ChunkableModuleOrBatch::None(i) => Ok(Some(ChunkableModuleOrBatch::None(i))),\n             })\n             .try_flat_join()\n             .await?\n-            .into_iter()\n-            .collect();\n+    } else {\n+        state.chunkable_items.into_iter().collect()\n     };\n \n     let mut batch_groups = FxIndexSet::default();\n-    for &module in &state.chunkable_items {\n+    for &module in &chunkable_items {\n         if let Some(batch_group) = module_batches_graph.get_batch_group(&module.into()) {\n             batch_groups.insert(batch_group);\n         }\n     }\n \n     Ok(ChunkGroupContent {\n-        chunkable_items: state.chunkable_items,\n+        chunkable_items,\n         batch_groups,\n         async_modules: state.async_modules,\n         traced_modules: state.traced_modules,\n         availability_info,\n     })\n }\n+\n+#[turbo_tasks::function]\n+async fn map_module_batch(\n+    merged_modules: Vc<MergedModuleInfo>,\n+    batch: Vc<ModuleBatch>,\n+) -> Result<Vc<ModuleBatch>> {\n+    let merged_modules = merged_modules.await?;\n+    let batch_ref = batch.await?;\n+\n+    let modified = RefCell::new(false);\n+    let modules = batch_ref\n+        .modules\n+        .iter()\n+        .flat_map(|&module| {\n+            if !merged_modules.should_create_chunk_item_for(ResolvedVc::upcast(module)) {\n+                *modified.borrow_mut() = true;\n+                return None;\n+            }\n+\n+            let module = if let Some(replacement) =\n+                merged_modules.should_replace_module(ResolvedVc::upcast(module))\n+            {\n+                *modified.borrow_mut() = true;\n+                replacement\n+            } else {\n+                module\n+            };\n+\n+            Some(module)\n+        })\n+        .collect::<Vec<_>>();\n+\n+    if modified.into_inner() {\n+        Ok(ModuleBatch::new(\n+            ResolvedVc::deref_vec(modules),\n+            batch_ref.chunk_groups.clone(),\n+        ))\n+    } else {\n+        Ok(batch)\n+    }\n+}"
        },
        {
            "sha": "ce34b9d98d05cd81029c0e64c5712ccb318e5882",
            "filename": "turbopack/crates/turbopack-core/src/chunk/mod.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/c0a3cfb625f5d4ead518a2c5bf37860185bb935f/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c0a3cfb625f5d4ead518a2c5bf37860185bb935f/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fmod.rs?ref=c0a3cfb625f5d4ead518a2c5bf37860185bb935f",
            "patch": "@@ -427,7 +427,7 @@ pub trait ChunkableModuleReference: ModuleReference + ValueToString {\n }\n \n pub struct ChunkGroupContent {\n-    pub chunkable_items: FxIndexSet<ChunkableModuleOrBatch>,\n+    pub chunkable_items: Vec<ChunkableModuleOrBatch>,\n     pub batch_groups: FxIndexSet<ResolvedVc<ModuleBatchGroup>>,\n     pub async_modules: FxIndexSet<ResolvedVc<Box<dyn ChunkableModule>>>,\n     pub traced_modules: FxIndexSet<ResolvedVc<Box<dyn Module>>>,"
        }
    ],
    "stats": {
        "total": 125,
        "additions": 73,
        "deletions": 52
    }
}