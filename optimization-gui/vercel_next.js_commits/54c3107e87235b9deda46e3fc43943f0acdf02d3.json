{
    "author": "devjiwonchoi",
    "message": "[ts-next-plugin] warn to add correct type for metadata exports (#78254)\n\nFollow up of https://github.com/vercel/next.js/pull/78237,\nhttps://github.com/vercel/next.js/pull/78258\n\nIf the exports of metadata options are missing types, warn them to\nimport type to prevent breaking the app from invalid metadata.\n\nThe warning covers:\n\n- `metadata` export\n- `generateMetadata` export\n  - as function\n  - as async function\n  - as arrow function\n  - as async arrow function\n  - as function expression\n  - as async function expression\n- all of the above as `export { ... }`\n\n\nhttps://github.com/user-attachments/assets/a25f9734-0d36-4592-a6fb-71faa7c00dbd\n\n---------\n\nCo-authored-by: Sebastian \"Sebbie\" Silbermann <sebastian.silbermann@vercel.com>",
    "sha": "54c3107e87235b9deda46e3fc43943f0acdf02d3",
    "files": [
        {
            "sha": "f9f5ba40b829f127bbd2ff650295f15be0e1149e",
            "filename": "packages/next/src/server/typescript/index.ts",
            "status": "modified",
            "additions": 12,
            "deletions": 6,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/54c3107e87235b9deda46e3fc43943f0acdf02d3/packages%2Fnext%2Fsrc%2Fserver%2Ftypescript%2Findex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/54c3107e87235b9deda46e3fc43943f0acdf02d3/packages%2Fnext%2Fsrc%2Fserver%2Ftypescript%2Findex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Ftypescript%2Findex.ts?ref=54c3107e87235b9deda46e3fc43943f0acdf02d3",
            "patch": "@@ -223,11 +223,14 @@ export const createTSPlugin: tsModule.server.PluginModuleFactory = ({\n                 node\n               )\n             const metadataDiagnostics = isClientEntry\n-              ? metadata.getSemanticDiagnosticsForExportVariableStatementInClientEntry(\n+              ? metadata.client.getSemanticDiagnosticsForExportVariableStatement(\n+                  fileName,\n+                  node\n+                )\n+              : metadata.server.getSemanticDiagnosticsForExportVariableStatement(\n                   fileName,\n                   node\n                 )\n-              : []\n             prior.push(...diagnostics, ...metadataDiagnostics)\n           }\n \n@@ -283,11 +286,14 @@ export const createTSPlugin: tsModule.server.PluginModuleFactory = ({\n           // export function ...\n           if (isAppEntry) {\n             const metadataDiagnostics = isClientEntry\n-              ? metadata.getSemanticDiagnosticsForExportVariableStatementInClientEntry(\n+              ? metadata.client.getSemanticDiagnosticsForExportVariableStatement(\n+                  fileName,\n+                  node\n+                )\n+              : metadata.server.getSemanticDiagnosticsForExportVariableStatement(\n                   fileName,\n                   node\n                 )\n-              : []\n             prior.push(...metadataDiagnostics)\n           }\n \n@@ -312,11 +318,11 @@ export const createTSPlugin: tsModule.server.PluginModuleFactory = ({\n           // export { ... }\n           if (isAppEntry) {\n             const metadataDiagnostics = isClientEntry\n-              ? metadata.getSemanticDiagnosticsForExportDeclarationInClientEntry(\n+              ? metadata.client.getSemanticDiagnosticsForExportDeclaration(\n                   fileName,\n                   node\n                 )\n-              : metadata.getSemanticDiagnosticsForExportDeclaration(\n+              : metadata.server.getSemanticDiagnosticsForExportDeclaration(\n                   fileName,\n                   node\n                 )"
        },
        {
            "sha": "4a61a8d76ed240209859f780edbd81522a9a61fa",
            "filename": "packages/next/src/server/typescript/rules/error.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/54c3107e87235b9deda46e3fc43943f0acdf02d3/packages%2Fnext%2Fsrc%2Fserver%2Ftypescript%2Frules%2Ferror.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/54c3107e87235b9deda46e3fc43943f0acdf02d3/packages%2Fnext%2Fsrc%2Fserver%2Ftypescript%2Frules%2Ferror.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Ftypescript%2Frules%2Ferror.ts?ref=54c3107e87235b9deda46e3fc43943f0acdf02d3",
            "patch": "@@ -17,7 +17,7 @@ const errorEntry = {\n     const ts = getTs()\n \n     if (!isClientEntry) {\n-      // Error components must be Client components\n+      // Error components must be Client Components\n       return [\n         {\n           file: source,"
        },
        {
            "sha": "f00ca4a2797f8861212e770d70115e0b455f5370",
            "filename": "packages/next/src/server/typescript/rules/metadata.ts",
            "status": "modified",
            "additions": 349,
            "deletions": 89,
            "changes": 438,
            "blob_url": "https://github.com/vercel/next.js/blob/54c3107e87235b9deda46e3fc43943f0acdf02d3/packages%2Fnext%2Fsrc%2Fserver%2Ftypescript%2Frules%2Fmetadata.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/54c3107e87235b9deda46e3fc43943f0acdf02d3/packages%2Fnext%2Fsrc%2Fserver%2Ftypescript%2Frules%2Fmetadata.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Ftypescript%2Frules%2Fmetadata.ts?ref=54c3107e87235b9deda46e3fc43943f0acdf02d3",
            "patch": "@@ -4,118 +4,378 @@ import { getSource, getTs, getTypeChecker } from '../utils'\n import type tsModule from 'typescript/lib/tsserverlibrary'\n \n const metadata = {\n-  getSemanticDiagnosticsForExportVariableStatementInClientEntry(\n-    fileName: string,\n-    node: tsModule.VariableStatement | tsModule.FunctionDeclaration\n-  ) {\n-    const source = getSource(fileName)\n-    const ts = getTs()\n-\n-    // It is not allowed to export `metadata` or `generateMetadata` in client entry\n-    if (ts.isFunctionDeclaration(node)) {\n-      if (node.name?.getText() === 'generateMetadata') {\n-        return [\n-          {\n-            file: source,\n-            category: ts.DiagnosticCategory.Error,\n-            code: NEXT_TS_ERRORS.INVALID_METADATA_EXPORT,\n-            messageText: `The Next.js 'generateMetadata' API is not allowed in a client component.`,\n-            start: node.name.getStart(),\n-            length: node.name.getWidth(),\n-          },\n-        ]\n-      }\n-    } else {\n-      for (const declaration of node.declarationList.declarations) {\n-        const name = declaration.name.getText()\n-        if (name === 'metadata') {\n+  client: {\n+    getSemanticDiagnosticsForExportVariableStatement(\n+      fileName: string,\n+      node: tsModule.VariableStatement | tsModule.FunctionDeclaration\n+    ): tsModule.Diagnostic[] {\n+      const source = getSource(fileName)\n+      const ts = getTs()\n+\n+      // It is not allowed to export `metadata` or `generateMetadata` in client entry\n+      if (ts.isFunctionDeclaration(node)) {\n+        if (node.name?.getText() === 'generateMetadata') {\n           return [\n             {\n               file: source,\n               category: ts.DiagnosticCategory.Error,\n               code: NEXT_TS_ERRORS.INVALID_METADATA_EXPORT,\n-              messageText: `The Next.js 'metadata' API is not allowed in a client component.`,\n-              start: declaration.name.getStart(),\n-              length: declaration.name.getWidth(),\n+              messageText: `The Next.js 'generateMetadata' API is not allowed in a Client Component.`,\n+              start: node.name.getStart(),\n+              length: node.name.getWidth(),\n             },\n           ]\n         }\n+      } else {\n+        for (const declaration of node.declarationList.declarations) {\n+          const name = declaration.name.getText()\n+          if (name === 'metadata') {\n+            return [\n+              {\n+                file: source,\n+                category: ts.DiagnosticCategory.Error,\n+                code: NEXT_TS_ERRORS.INVALID_METADATA_EXPORT,\n+                messageText: `The Next.js 'metadata' API is not allowed in a Client Component.`,\n+                start: declaration.name.getStart(),\n+                length: declaration.name.getWidth(),\n+              },\n+            ]\n+          }\n+        }\n       }\n-    }\n-    return []\n-  },\n+      return []\n+    },\n+    getSemanticDiagnosticsForExportDeclaration(\n+      fileName: string,\n+      node: tsModule.ExportDeclaration\n+    ): tsModule.Diagnostic[] {\n+      const ts = getTs()\n+      const source = getSource(fileName)\n+      const diagnostics: tsModule.Diagnostic[] = []\n \n-  getSemanticDiagnosticsForExportDeclarationInClientEntry(\n-    fileName: string,\n-    node: tsModule.ExportDeclaration\n-  ) {\n-    const ts = getTs()\n-    const source = getSource(fileName)\n-    const diagnostics: tsModule.Diagnostic[] = []\n-\n-    const exportClause = node.exportClause\n-    if (exportClause && ts.isNamedExports(exportClause)) {\n-      for (const e of exportClause.elements) {\n-        if (['generateMetadata', 'metadata'].includes(e.name.getText())) {\n-          diagnostics.push({\n-            file: source,\n-            category: ts.DiagnosticCategory.Error,\n-            code: NEXT_TS_ERRORS.INVALID_METADATA_EXPORT,\n-            messageText: `The Next.js '${e.name.getText()}' API is not allowed in a client component.`,\n-            start: e.name.getStart(),\n-            length: e.name.getWidth(),\n-          })\n+      const exportClause = node.exportClause\n+      if (exportClause && ts.isNamedExports(exportClause)) {\n+        for (const e of exportClause.elements) {\n+          if (['generateMetadata', 'metadata'].includes(e.name.getText())) {\n+            diagnostics.push({\n+              file: source,\n+              category: ts.DiagnosticCategory.Error,\n+              code: NEXT_TS_ERRORS.INVALID_METADATA_EXPORT,\n+              messageText: `The Next.js '${e.name.getText()}' API is not allowed in a Client Component.`,\n+              start: e.name.getStart(),\n+              length: e.name.getWidth(),\n+            })\n+          }\n         }\n       }\n-    }\n \n-    return diagnostics\n+      return diagnostics\n+    },\n   },\n+  server: {\n+    getSemanticDiagnosticsForExportVariableStatement(\n+      fileName: string,\n+      node: tsModule.VariableStatement | tsModule.FunctionDeclaration\n+    ): tsModule.Diagnostic[] {\n+      const source = getSource(fileName)\n+      const ts = getTs()\n+\n+      if (ts.isFunctionDeclaration(node)) {\n+        if (node.name?.getText() === 'generateMetadata') {\n+          if (hasCorrectType(node)) {\n+            return []\n+          }\n+\n+          const isAsync = node.modifiers?.some(\n+            (m) => m.kind === ts.SyntaxKind.AsyncKeyword\n+          )\n+\n+          return [\n+            {\n+              file: source,\n+              category: ts.DiagnosticCategory.Warning,\n+              code: NEXT_TS_ERRORS.INVALID_METADATA_EXPORT,\n+              messageText: `The \"generateMetadata\" export should have a return type of ${isAsync ? '\"Promise<Metadata>\"' : '\"Metadata\"'} from \"next\".`,\n+              start: node.name.getStart(),\n+              length: node.name.getWidth(),\n+            },\n+          ]\n+        }\n+      } else {\n+        for (const declaration of node.declarationList.declarations) {\n+          if (hasCorrectType(declaration)) {\n+            return []\n+          }\n+\n+          const name = declaration.name.getText()\n+          if (name === 'metadata') {\n+            return [\n+              {\n+                file: source,\n+                category: ts.DiagnosticCategory.Warning,\n+                code: NEXT_TS_ERRORS.INVALID_METADATA_EXPORT,\n+                messageText: `The Next.js \"metadata\" export should be type of \"Metadata\" from \"next\".`,\n+                start: declaration.name.getStart(),\n+                length: declaration.name.getWidth(),\n+              },\n+            ]\n+          }\n+          if (name === 'generateMetadata') {\n+            // Check if it's a function expression or arrow function\n+            if (\n+              declaration.initializer &&\n+              (ts.isFunctionExpression(declaration.initializer) ||\n+                ts.isArrowFunction(declaration.initializer))\n+            ) {\n+              const isAsync = declaration.initializer.modifiers?.some(\n+                (m) => m.kind === ts.SyntaxKind.AsyncKeyword\n+              )\n+              return [\n+                {\n+                  file: source,\n+                  category: ts.DiagnosticCategory.Warning,\n+                  code: NEXT_TS_ERRORS.INVALID_METADATA_EXPORT,\n+                  messageText: `The \"generateMetadata\" export should have a return type of ${isAsync ? '\"Promise<Metadata>\"' : '\"Metadata\"'} from \"next\".`,\n+                  start: declaration.name.getStart(),\n+                  length: declaration.name.getWidth(),\n+                },\n+              ]\n+            }\n+          }\n+        }\n+      }\n+      return []\n+    },\n+    getSemanticDiagnosticsForExportDeclaration(\n+      fileName: string,\n+      node: tsModule.ExportDeclaration\n+    ) {\n+      const typeChecker = getTypeChecker()\n+      if (!typeChecker) {\n+        return []\n+      }\n+\n+      const ts = getTs()\n+      const source = getSource(fileName)\n+      const diagnostics: tsModule.Diagnostic[] = []\n+\n+      const exportClause = node.exportClause\n+      if (!node.isTypeOnly && exportClause && ts.isNamedExports(exportClause)) {\n+        for (const e of exportClause.elements) {\n+          if (e.isTypeOnly) {\n+            continue\n+          }\n+          const exportName = e.name.getText()\n+          if (exportName !== 'generateMetadata' && exportName !== 'metadata') {\n+            continue\n+          }\n+\n+          // Get the symbol and type for the export\n+          const symbol = typeChecker.getSymbolAtLocation(e.name)\n+          if (!symbol) continue\n+\n+          const type = typeChecker.getTypeOfSymbolAtLocation(symbol, e.name)\n+          if (!type) continue\n \n-  getSemanticDiagnosticsForExportDeclaration(\n-    fileName: string,\n-    node: tsModule.ExportDeclaration\n-  ) {\n-    const ts = getTs()\n-\n-    const exportClause = node.exportClause\n-    if (exportClause && ts.isNamedExports(exportClause)) {\n-      for (const e of exportClause.elements) {\n-        if (e.name.getText() === 'metadata') {\n-          // Get the original declaration node of element\n-          const typeChecker = getTypeChecker()\n-          if (typeChecker) {\n-            const symbol = typeChecker.getSymbolAtLocation(e.name)\n-            if (symbol) {\n-              const metadataSymbol = typeChecker.getAliasedSymbol(symbol)\n-              if (metadataSymbol && metadataSymbol.declarations) {\n-                const declaration = metadataSymbol.declarations[0]\n-                if (declaration && ts.isVariableDeclaration(declaration)) {\n-                  if (declaration.type) {\n-                    const typeText = declaration.type.getText()\n-                    if (!typeText.includes('Metadata')) {\n-                      return [\n-                        {\n-                          file: getSource(fileName),\n-                          category: ts.DiagnosticCategory.Error,\n-                          code: NEXT_TS_ERRORS.INVALID_METADATA_EXPORT,\n-                          messageText: `The 'metadata' export value is not typed correctly, please make sure it is typed as 'Metadata':\\nhttps://nextjs.org/docs/app/building-your-application/optimizing/metadata#static-metadata`,\n-                          start: e.name.getStart(),\n-                          length: e.name.getWidth(),\n-                        },\n-                      ]\n-                    }\n-                  }\n+          if (exportName === 'generateMetadata') {\n+            let isAsync = false\n+\n+            // For export declarations, we need to get the actual declaration through the type checker\n+            const originalSymbol = typeChecker.getAliasedSymbol(symbol)\n+            const declaration = originalSymbol?.declarations?.[0]\n+\n+            if (declaration) {\n+              if (ts.isFunctionDeclaration(declaration)) {\n+                isAsync =\n+                  declaration.modifiers?.some(\n+                    (m) => m.kind === ts.SyntaxKind.AsyncKeyword\n+                  ) ?? false\n+              } else if (\n+                ts.isVariableDeclaration(declaration) &&\n+                declaration.initializer\n+              ) {\n+                if (\n+                  ts.isArrowFunction(declaration.initializer) ||\n+                  ts.isFunctionExpression(declaration.initializer)\n+                ) {\n+                  isAsync =\n+                    declaration.initializer.modifiers?.some(\n+                      (m) => m.kind === ts.SyntaxKind.AsyncKeyword\n+                    ) ?? false\n                 }\n               }\n             }\n+\n+            if (!hasCorrectType(declaration as tsModule.FunctionDeclaration)) {\n+              diagnostics.push({\n+                file: source,\n+                category: ts.DiagnosticCategory.Warning,\n+                code: NEXT_TS_ERRORS.INVALID_METADATA_EXPORT,\n+                messageText: `The \"generateMetadata\" export should have a return type of ${isAsync ? '\"Promise<Metadata>\"' : '\"Metadata\"'} from \"next\".`,\n+                start: e.name.getStart(),\n+                length: e.name.getWidth(),\n+              })\n+            }\n+          } else {\n+            // must be 'metadata' at this point\n+            const declaration = symbol.declarations?.[0]\n+            if (!hasCorrectType(declaration as tsModule.VariableDeclaration)) {\n+              diagnostics.push({\n+                file: source,\n+                category: ts.DiagnosticCategory.Warning,\n+                code: NEXT_TS_ERRORS.INVALID_METADATA_EXPORT,\n+                messageText: `The Next.js \"metadata\" export should be type of \"Metadata\" from \"next\".`,\n+                start: e.name.getStart(),\n+                length: e.name.getWidth(),\n+              })\n+            }\n           }\n         }\n       }\n-    }\n \n-    return []\n+      return diagnostics\n+    },\n   },\n }\n \n+function hasCorrectType(\n+  node: tsModule.FunctionDeclaration | tsModule.VariableDeclaration\n+): boolean {\n+  // Skip if already has type.\n+  if (node.type) {\n+    return true\n+  }\n+\n+  const ts = getTs()\n+  const typeChecker = getTypeChecker()\n+  if (!typeChecker) {\n+    return false\n+  }\n+\n+  // For generateMetadata, check if it's Promise<Metadata> for async or Metadata for sync\n+  if (ts.isFunctionDeclaration(node)) {\n+    return checkFunctionReturnType(node, typeChecker)\n+  } else {\n+    // For variable declarations (const/let/var)\n+    const name = node.name.getText()\n+\n+    if (name === 'generateMetadata') {\n+      // For generateMetadata as a variable, it must be a function expression or arrow function\n+      if (\n+        !node.initializer ||\n+        (!ts.isFunctionExpression(node.initializer) &&\n+          !ts.isArrowFunction(node.initializer))\n+      ) {\n+        return false\n+      }\n+\n+      // Check the return type of the function expression/arrow function\n+      if (node.initializer.type) {\n+        // If it has an explicit return type annotation\n+        return checkFunctionReturnType(node.initializer, typeChecker)\n+      } else {\n+        // If no explicit return type, infer it from the function\n+        const signature = typeChecker.getSignatureFromDeclaration(\n+          node.initializer\n+        )\n+        if (!signature) return false\n+\n+        const returnType = typeChecker.getReturnTypeOfSignature(signature)\n+        if (!returnType) return false\n+\n+        const isAsync =\n+          node.initializer.modifiers?.some(\n+            (m) => m.kind === ts.SyntaxKind.AsyncKeyword\n+          ) ?? false\n+\n+        if (isAsync) {\n+          // For async functions, check if it's Promise<Metadata>\n+          const typeSymbol = returnType.getSymbol()\n+          if (!typeSymbol || typeSymbol.getName() !== 'Promise') return false\n+\n+          // Check if it's a reference type (like Promise<T>)\n+          if (\n+            !(returnType.flags & ts.TypeFlags.Object) ||\n+            !('typeArguments' in returnType)\n+          ) {\n+            return false\n+          }\n+\n+          const typeArgs = (\n+            returnType as { typeArguments: readonly tsModule.Type[] }\n+          ).typeArguments\n+          if (!typeArgs || typeArgs.length !== 1) return false\n+\n+          const promiseType = typeArgs[0]\n+          const promiseTypeSymbol = promiseType.getSymbol()\n+          return promiseTypeSymbol?.getName() === 'Metadata'\n+        } else {\n+          // For sync functions, check if it returns Metadata\n+          const returnTypeSymbol = returnType.getSymbol()\n+          return returnTypeSymbol?.getName() === 'Metadata'\n+        }\n+      }\n+    } else {\n+      // For metadata export, we just need Metadata type\n+      if (!node.type) return false\n+      const type = typeChecker.getTypeFromTypeNode(node.type)\n+      if (!type) return false\n+      const symbol = type.getSymbol()\n+      return symbol?.getName() === 'Metadata'\n+    }\n+  }\n+}\n+\n+function checkFunctionReturnType(\n+  node:\n+    | tsModule.FunctionDeclaration\n+    | tsModule.FunctionExpression\n+    | tsModule.ArrowFunction,\n+  typeChecker: tsModule.TypeChecker\n+): boolean {\n+  const ts = getTs()\n+\n+  if (!node.type) return false\n+\n+  const returnType = typeChecker.getTypeFromTypeNode(node.type)\n+  if (!returnType) return false\n+\n+  const isAsync =\n+    node.modifiers?.some((m) => m.kind === ts.SyntaxKind.AsyncKeyword) ?? false\n+\n+  if (isAsync) {\n+    // For async functions, we need Promise<Metadata>\n+    const typeSymbol = returnType.getSymbol()\n+    if (!typeSymbol || typeSymbol.getName() !== 'Promise') {\n+      return false\n+    }\n+\n+    // Get the type argument of Promise<T>\n+    if (!ts.isTypeReferenceNode(node.type)) {\n+      return false\n+    }\n+\n+    // Check if it's a reference type (like Promise<T>)\n+    if (\n+      !(returnType.flags & ts.TypeFlags.Object) ||\n+      !('typeArguments' in returnType)\n+    ) {\n+      return false\n+    }\n+\n+    const typeArgs = (returnType as { typeArguments: readonly tsModule.Type[] })\n+      .typeArguments\n+    if (!typeArgs || typeArgs.length !== 1) {\n+      return false\n+    }\n+    const promiseType = typeArgs[0]\n+    const promiseTypeSymbol = promiseType.getSymbol()\n+    return promiseTypeSymbol?.getName() === 'Metadata'\n+  } else {\n+    // For sync functions, we need Metadata directly\n+    const symbol = returnType.getSymbol()\n+    return symbol?.getName() === 'Metadata'\n+  }\n+}\n+\n export default metadata"
        }
    ],
    "stats": {
        "total": 458,
        "additions": 362,
        "deletions": 96
    }
}