{
    "author": "mischnic",
    "message": "Turbopack: Remove unused turbopack-node rendering code (#83414)\n\n- Remove dead code back from the old days\r\n- Update a few crates\r\n\r\nCodspeed didn't really have anything breaking in v3? https://github.com/CodSpeedHQ/codspeed-rust/releases",
    "sha": "085b7015cee5f08a48f2656066231c31b8fcdf1d",
    "files": [
        {
            "sha": "cf0f7d9ebb9a9a9c370c8c6c597a122851c6076d",
            "filename": "Cargo.lock",
            "status": "modified",
            "additions": 64,
            "deletions": 64,
            "changes": 128,
            "blob_url": "https://github.com/vercel/next.js/blob/085b7015cee5f08a48f2656066231c31b8fcdf1d/Cargo.lock",
            "raw_url": "https://github.com/vercel/next.js/raw/085b7015cee5f08a48f2656066231c31b8fcdf1d/Cargo.lock",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/Cargo.lock?ref=085b7015cee5f08a48f2656066231c31b8fcdf1d",
            "patch": "@@ -251,6 +251,15 @@ dependencies = [\n  \"backtrace\",\n ]\n \n+[[package]]\n+name = \"approx\"\n+version = \"0.5.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"cab112f0a86d568ea0e627cc1d6be74a1e9cd55214684db5561995f6dad897c6\"\n+dependencies = [\n+ \"num-traits\",\n+]\n+\n [[package]]\n name = \"arbitrary\"\n version = \"1.4.1\"\n@@ -971,12 +980,6 @@ version = \"1.0.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"9555578bc9e57714c812a1f84e4fc5b4d21fcb063490c624de019f7464c91268\"\n \n-[[package]]\n-name = \"cfg_aliases\"\n-version = \"0.1.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fd16c4719339c4530435d38e511904438d07cce7950afa3718a84ac36c10e89e\"\n-\n [[package]]\n name = \"cfg_aliases\"\n version = \"0.2.1\"\n@@ -1162,22 +1165,27 @@ dependencies = [\n \n [[package]]\n name = \"codspeed\"\n-version = \"2.10.1\"\n+version = \"3.0.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"93f4cce9c27c49c4f101fffeebb1826f41a9df2e7498b7cd4d95c0658b796c6c\"\n+checksum = \"35584c5fcba8059780748866387fb97c5a203bcfc563fc3d0790af406727a117\"\n dependencies = [\n+ \"anyhow\",\n+ \"bincode\",\n  \"colored\",\n+ \"glob\",\n  \"libc\",\n+ \"nix 0.29.0\",\n  \"serde\",\n  \"serde_json\",\n+ \"statrs\",\n  \"uuid\",\n ]\n \n [[package]]\n name = \"codspeed-criterion-compat\"\n-version = \"2.10.1\"\n+version = \"3.0.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c3c23d880a28a2aab52d38ca8481dd7a3187157d0a952196b6db1db3c8499725\"\n+checksum = \"78f6c1c6bed5fd84d319e8b0889da051daa361c79b7709c9394dfe1a882bba67\"\n dependencies = [\n  \"codspeed\",\n  \"codspeed-criterion-compat-walltime\",\n@@ -1188,9 +1196,9 @@ dependencies = [\n \n [[package]]\n name = \"codspeed-criterion-compat-walltime\"\n-version = \"2.10.1\"\n+version = \"3.0.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7b0a2f7365e347f4f22a67e9ea689bf7bc89900a354e22e26cf8a531a42c8fbb\"\n+checksum = \"c989289ce6b1cbde72ed560496cb8fbf5aa14d5ef5666f168e7f87751038352e\"\n dependencies = [\n  \"anes\",\n  \"cast\",\n@@ -1217,9 +1225,9 @@ dependencies = [\n \n [[package]]\n name = \"codspeed-divan-compat\"\n-version = \"2.10.1\"\n+version = \"3.0.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8620a09dfaf37b3c45f982c4b65bd8f9b0203944da3ffa705c0fcae6b84655ff\"\n+checksum = \"adf64eda57508448d59efd940bad62ede7c50b0d451a150b8d6a0eca642792a6\"\n dependencies = [\n  \"codspeed\",\n  \"codspeed-divan-compat-macros\",\n@@ -1228,9 +1236,9 @@ dependencies = [\n \n [[package]]\n name = \"codspeed-divan-compat-macros\"\n-version = \"2.10.1\"\n+version = \"3.0.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"30fe872bc4214626b35d3a1706a905d0243503bb6ba3bb7be2fc59083d5d680c\"\n+checksum = \"058167258e819b16a4ba601fdfe270349ef191154758dbce122c62a698f70ba8\"\n dependencies = [\n  \"divan-macros\",\n  \"itertools 0.14.0\",\n@@ -1242,9 +1250,9 @@ dependencies = [\n \n [[package]]\n name = \"codspeed-divan-compat-walltime\"\n-version = \"2.10.1\"\n+version = \"3.0.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"104caa97b36d4092d89e24e4b103b40ede1edab03c0372d19e14a33f9393132b\"\n+checksum = \"48f9866ee3a4ef9d2868823ea5811886763af244f2df584ca247f49281c43f1f\"\n dependencies = [\n  \"cfg-if\",\n  \"clap\",\n@@ -1618,7 +1626,7 @@ dependencies = [\n  \"autocfg\",\n  \"cfg-if\",\n  \"crossbeam-utils\",\n- \"memoffset 0.9.0\",\n+ \"memoffset\",\n  \"scopeguard\",\n ]\n \n@@ -1740,12 +1748,12 @@ dependencies = [\n \n [[package]]\n name = \"ctrlc\"\n-version = \"3.4.4\"\n+version = \"3.4.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"672465ae37dc1bc6380a6547a8883d5dd397b0f1faaad4f265726cc7042a5345\"\n+checksum = \"46f93780a459b7d656ef7f071fe699c4d3d2cb201c4b24d085b6ddc505276e73\"\n dependencies = [\n- \"nix 0.28.0\",\n- \"windows-sys 0.52.0\",\n+ \"nix 0.30.1\",\n+ \"windows-sys 0.59.0\",\n ]\n \n [[package]]\n@@ -2510,9 +2518,9 @@ dependencies = [\n \n [[package]]\n name = \"glob\"\n-version = \"0.3.1\"\n+version = \"0.3.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d2fabcfbdc87f4758337ca535fb41a6d701b65693ce38287d856d1674551ec9b\"\n+checksum = \"0cc23270f6e1808e30a928bdc84dea0b9b4136a8bc82338574f23baf47bbd280\"\n \n [[package]]\n name = \"globset\"\n@@ -3963,15 +3971,6 @@ dependencies = [\n  \"libc\",\n ]\n \n-[[package]]\n-name = \"memoffset\"\n-version = \"0.7.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5de893c32cde5f383baa4c04c5d6dbdd735cfd4a794b0debdb2bb1b421da5ff4\"\n-dependencies = [\n- \"autocfg\",\n-]\n-\n [[package]]\n name = \"memoffset\"\n version = \"0.9.0\"\n@@ -3989,7 +3988,7 @@ checksum = \"4edc8853320c2a0dab800fbda86253c8938f6ea88510dc92c5f1ed20e794afc1\"\n dependencies = [\n  \"cfg-if\",\n  \"miette-derive\",\n- \"owo-colors 4.0.0\",\n+ \"owo-colors\",\n  \"textwrap\",\n  \"thiserror 1.0.69\",\n  \"unicode-width 0.1.13\",\n@@ -4441,7 +4440,7 @@ dependencies = [\n  \"next-custom-transforms\",\n  \"next-taskless\",\n  \"once_cell\",\n- \"owo-colors 3.5.0\",\n+ \"owo-colors\",\n  \"rand 0.9.0\",\n  \"rustc-hash 2.1.1\",\n  \"serde\",\n@@ -4481,26 +4480,25 @@ dependencies = [\n \n [[package]]\n name = \"nix\"\n-version = \"0.26.4\"\n+version = \"0.29.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"598beaf3cc6fdd9a5dfb1630c2800c7acd31df7aaf0f565796fba2b53ca1af1b\"\n+checksum = \"71e2746dc3a24dd78b3cfcb7be93368c6de9963d30f43a6a73998a9cf4b17b46\"\n dependencies = [\n- \"bitflags 1.3.2\",\n+ \"bitflags 2.9.1\",\n  \"cfg-if\",\n+ \"cfg_aliases\",\n  \"libc\",\n- \"memoffset 0.7.1\",\n- \"pin-utils\",\n ]\n \n [[package]]\n name = \"nix\"\n-version = \"0.28.0\"\n+version = \"0.30.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ab2156c4fce2f8df6c499cc1c763e4394b7482525bf2a9701c9d79d215f519e4\"\n+checksum = \"74523f3a35e05aba87a1d978330aef40f67b0304ac79c1c00b294c9830543db6\"\n dependencies = [\n  \"bitflags 2.9.1\",\n  \"cfg-if\",\n- \"cfg_aliases 0.1.1\",\n+ \"cfg_aliases\",\n  \"libc\",\n ]\n \n@@ -4817,15 +4815,9 @@ checksum = \"b15813163c1d831bf4a13c3610c05c0d03b39feb07f7e09fa234dac9b15aaf39\"\n \n [[package]]\n name = \"owo-colors\"\n-version = \"3.5.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c1b04fb49957986fdce4d6ee7a65027d55d4b6d2265e5848bbb507b58ccfdb6f\"\n-\n-[[package]]\n-name = \"owo-colors\"\n-version = \"4.0.0\"\n+version = \"4.2.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"caff54706df99d2a78a5a4e3455ff45448d81ef1bb63c22cd14052ca0e993a3f\"\n+checksum = \"48dd4f4a2c8405440fd0462561f0e5806bd0f77e86f51c761481bdd4018b545e\"\n \n [[package]]\n name = \"papergrid\"\n@@ -5498,7 +5490,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"626214629cda6781b6dc1d316ba307189c85ba657213ce642d9c77670f8202c8\"\n dependencies = [\n  \"bytes\",\n- \"cfg_aliases 0.2.1\",\n+ \"cfg_aliases\",\n  \"pin-project-lite\",\n  \"quinn-proto\",\n  \"quinn-udp\",\n@@ -5538,7 +5530,7 @@ version = \"0.5.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"ee4e529991f949c5e25755532370b8af5d114acae52326361d68d47af64aa842\"\n dependencies = [\n- \"cfg_aliases 0.2.1\",\n+ \"cfg_aliases\",\n  \"libc\",\n  \"once_cell\",\n  \"socket2 0.5.10\",\n@@ -6890,6 +6882,16 @@ version = \"1.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"a2eb9349b6444b326872e140eb1cf5e7c522154d69e7a0ffb0fb81c06b37543f\"\n \n+[[package]]\n+name = \"statrs\"\n+version = \"0.18.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2a3fe7c28c6512e766b0874335db33c94ad7b8f9054228ae1c2abd47ce7d335e\"\n+dependencies = [\n+ \"approx\",\n+ \"num-traits\",\n+]\n+\n [[package]]\n name = \"string_enum\"\n version = \"1.0.2\"\n@@ -7038,7 +7040,7 @@ version = \"0.1.0\"\n dependencies = [\n  \"anyhow\",\n  \"clap\",\n- \"owo-colors 3.5.0\",\n+ \"owo-colors\",\n  \"regex\",\n  \"swc_core\",\n ]\n@@ -9505,9 +9507,9 @@ dependencies = [\n  \"chromiumoxide\",\n  \"codspeed-criterion-compat\",\n  \"futures\",\n- \"nix 0.26.4\",\n+ \"nix 0.30.1\",\n  \"once_cell\",\n- \"owo-colors 3.5.0\",\n+ \"owo-colors\",\n  \"parking_lot\",\n  \"portpicker\",\n  \"rand 0.9.0\",\n@@ -9555,7 +9557,7 @@ dependencies = [\n  \"console-subscriber\",\n  \"dunce\",\n  \"futures\",\n- \"owo-colors 3.5.0\",\n+ \"owo-colors\",\n  \"regex\",\n  \"rustc-hash 2.1.1\",\n  \"serde\",\n@@ -9590,9 +9592,8 @@ name = \"turbopack-cli-utils\"\n version = \"0.1.0\"\n dependencies = [\n  \"anyhow\",\n- \"clap\",\n  \"crossterm 0.26.1\",\n- \"owo-colors 3.5.0\",\n+ \"owo-colors\",\n  \"rustc-hash 2.1.1\",\n  \"serde\",\n  \"turbo-rcstr\",\n@@ -9909,7 +9910,7 @@ dependencies = [\n  \"futures-retry\",\n  \"indoc\",\n  \"once_cell\",\n- \"owo-colors 3.5.0\",\n+ \"owo-colors\",\n  \"parking_lot\",\n  \"regex\",\n  \"rustc-hash 2.1.1\",\n@@ -9925,7 +9926,6 @@ dependencies = [\n  \"turbo-tasks-fs\",\n  \"turbopack-cli-utils\",\n  \"turbopack-core\",\n- \"turbopack-dev-server\",\n  \"turbopack-ecmascript\",\n  \"turbopack-resolve\",\n ]\n@@ -10886,7 +10886,7 @@ dependencies = [\n  \"libc\",\n  \"libunwind\",\n  \"mach2\",\n- \"memoffset 0.9.0\",\n+ \"memoffset\",\n  \"more-asserts\",\n  \"region\",\n  \"rustversion\",\n@@ -11580,7 +11580,7 @@ dependencies = [\n  \"indexmap 2.9.0\",\n  \"inquire\",\n  \"num-format\",\n- \"owo-colors 3.5.0\",\n+ \"owo-colors\",\n  \"plotters\",\n  \"rustc-hash 2.1.1\",\n  \"semver\","
        },
        {
            "sha": "a6215e35dafc4789d9832097b959598f4dfcad3c",
            "filename": "Cargo.toml",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/085b7015cee5f08a48f2656066231c31b8fcdf1d/Cargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/085b7015cee5f08a48f2656066231c31b8fcdf1d/Cargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/Cargo.toml?ref=085b7015cee5f08a48f2656066231c31b8fcdf1d",
            "patch": "@@ -352,11 +352,11 @@ clap = { version = \"4.5.2\", features = [\"derive\"] }\n concurrent-queue = \"2.5.0\"\n console-subscriber = \"0.4.1\"\n const_format = \"0.2.30\"\n-criterion = { package = \"codspeed-criterion-compat\", version = \"2.10.1\" }\n+criterion = { package = \"codspeed-criterion-compat\", version = \"3.0.5\" }\n crossbeam-channel = \"0.5.8\"\n dashmap = \"6.1.0\"\n data-encoding = \"2.3.3\"\n-divan = { version = \"2.10.1\", package = \"codspeed-divan-compat\" }\n+divan = { package = \"codspeed-divan-compat\", version = \"3.0.5\" }\n dhat = { version = \"0.3.2\" }\n dunce = \"1.0.3\"\n either = \"1.9.0\"\n@@ -392,7 +392,7 @@ napi = { version = \"2\", default-features = false, features = [\n ] }\n notify = \"8.1.0\"\n once_cell = \"1.17.1\"\n-owo-colors = \"3.5.0\"\n+owo-colors = \"4.2.2\"\n parcel_selectors = \"0.28.2\"\n parking_lot = \"0.12.1\"\n pathdiff = \"0.2.1\""
        },
        {
            "sha": "89361f68ba67a4c355e3af85f5630051a375ca5d",
            "filename": "turbopack/crates/turbopack-bench/Cargo.toml",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/085b7015cee5f08a48f2656066231c31b8fcdf1d/turbopack%2Fcrates%2Fturbopack-bench%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/085b7015cee5f08a48f2656066231c31b8fcdf1d/turbopack%2Fcrates%2Fturbopack-bench%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-bench%2FCargo.toml?ref=085b7015cee5f08a48f2656066231c31b8fcdf1d",
            "patch": "@@ -40,4 +40,4 @@ turbopack-create-test-app = { workspace = true }\n url = { workspace = true }\n \n [target.'cfg(unix)'.dependencies]\n-nix = \"0.26.1\"\n+nix = \"0.30.1\""
        },
        {
            "sha": "2cae973901eff3dcc9e1b491b5079aab4a680bae",
            "filename": "turbopack/crates/turbopack-cli-utils/Cargo.toml",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/085b7015cee5f08a48f2656066231c31b8fcdf1d/turbopack%2Fcrates%2Fturbopack-cli-utils%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/085b7015cee5f08a48f2656066231c31b8fcdf1d/turbopack%2Fcrates%2Fturbopack-cli-utils%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-cli-utils%2FCargo.toml?ref=085b7015cee5f08a48f2656066231c31b8fcdf1d",
            "patch": "@@ -16,7 +16,6 @@ workspace = true\n \n [dependencies]\n anyhow = { workspace = true }\n-clap = { workspace = true, features = [\"derive\"] }\n crossterm = \"0.26.0\"\n owo-colors = { workspace = true }\n rustc-hash = { workspace = true }"
        },
        {
            "sha": "e20fbc557d7484cd002c88ed8f846e9536d9e066",
            "filename": "turbopack/crates/turbopack-cli-utils/src/issue.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 46,
            "changes": 47,
            "blob_url": "https://github.com/vercel/next.js/blob/085b7015cee5f08a48f2656066231c31b8fcdf1d/turbopack%2Fcrates%2Fturbopack-cli-utils%2Fsrc%2Fissue.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/085b7015cee5f08a48f2656066231c31b8fcdf1d/turbopack%2Fcrates%2Fturbopack-cli-utils%2Fsrc%2Fissue.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-cli-utils%2Fsrc%2Fissue.rs?ref=085b7015cee5f08a48f2656066231c31b8fcdf1d",
            "patch": "@@ -4,11 +4,10 @@ use std::{\n     collections::hash_map::Entry,\n     fmt::Write as _,\n     path::{Path, PathBuf},\n-    str::FromStr,\n     sync::{Arc, Mutex},\n };\n \n-use anyhow::{Result, anyhow};\n+use anyhow::Result;\n use crossterm::style::{StyledContent, Stylize};\n use owo_colors::{OwoColorize as _, Style};\n use rustc_hash::{FxHashMap, FxHashSet};\n@@ -22,50 +21,6 @@ use turbopack_core::issue::{\n \n use crate::source_context::format_source_context_lines;\n \n-#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n-pub struct IssueSeverityCliOption(pub IssueSeverity);\n-\n-impl serde::Serialize for IssueSeverityCliOption {\n-    fn serialize<S: serde::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {\n-        serializer.serialize_str(&self.0.to_string())\n-    }\n-}\n-\n-impl<'de> serde::Deserialize<'de> for IssueSeverityCliOption {\n-    fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {\n-        let s = String::deserialize(deserializer)?;\n-        IssueSeverityCliOption::from_str(&s).map_err(serde::de::Error::custom)\n-    }\n-}\n-\n-impl clap::ValueEnum for IssueSeverityCliOption {\n-    fn value_variants<'a>() -> &'a [Self] {\n-        const VARIANTS: [IssueSeverityCliOption; 8] = [\n-            IssueSeverityCliOption(IssueSeverity::Bug),\n-            IssueSeverityCliOption(IssueSeverity::Fatal),\n-            IssueSeverityCliOption(IssueSeverity::Error),\n-            IssueSeverityCliOption(IssueSeverity::Warning),\n-            IssueSeverityCliOption(IssueSeverity::Hint),\n-            IssueSeverityCliOption(IssueSeverity::Note),\n-            IssueSeverityCliOption(IssueSeverity::Suggestion),\n-            IssueSeverityCliOption(IssueSeverity::Info),\n-        ];\n-        &VARIANTS\n-    }\n-\n-    fn to_possible_value<'a>(&self) -> Option<clap::builder::PossibleValue> {\n-        Some(clap::builder::PossibleValue::new(self.0.as_str()).help(self.0.as_help_str()))\n-    }\n-}\n-\n-impl FromStr for IssueSeverityCliOption {\n-    type Err = anyhow::Error;\n-\n-    fn from_str(s: &str) -> Result<Self, Self::Err> {\n-        <IssueSeverityCliOption as clap::ValueEnum>::from_str(s, true).map_err(|s| anyhow!(\"{}\", s))\n-    }\n-}\n-\n fn severity_to_style(severity: IssueSeverity) -> Style {\n     match severity {\n         IssueSeverity::Bug => Style::new().bright_red().underline(),"
        },
        {
            "sha": "cd8b67641c903809ee876173a5f2d8584769e5db",
            "filename": "turbopack/crates/turbopack-cli/src/arguments.rs",
            "status": "modified",
            "additions": 48,
            "deletions": 1,
            "changes": 49,
            "blob_url": "https://github.com/vercel/next.js/blob/085b7015cee5f08a48f2656066231c31b8fcdf1d/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Farguments.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/085b7015cee5f08a48f2656066231c31b8fcdf1d/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Farguments.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Farguments.rs?ref=085b7015cee5f08a48f2656066231c31b8fcdf1d",
            "patch": "@@ -1,12 +1,14 @@\n use std::{\n     net::IpAddr,\n     path::{Path, PathBuf},\n+    str::FromStr,\n };\n \n+use anyhow::anyhow;\n use clap::{Args, Parser, ValueEnum};\n use serde::{Deserialize, Serialize};\n use turbo_tasks::{NonLocalValue, TaskInput, trace::TraceRawVcs};\n-use turbopack_cli_utils::issue::IssueSeverityCliOption;\n+use turbopack_core::issue::IssueSeverity;\n \n #[derive(Debug, Parser)]\n #[clap(author, version, about, long_about = None)]\n@@ -146,3 +148,48 @@ pub struct BuildArguments {\n     #[clap(long, hide = true)]\n     pub force_memory_cleanup: bool,\n }\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n+pub struct IssueSeverityCliOption(pub IssueSeverity);\n+\n+impl serde::Serialize for IssueSeverityCliOption {\n+    fn serialize<S: serde::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {\n+        serializer.serialize_str(&self.0.to_string())\n+    }\n+}\n+\n+impl<'de> serde::Deserialize<'de> for IssueSeverityCliOption {\n+    fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {\n+        let s = String::deserialize(deserializer)?;\n+        <IssueSeverityCliOption as std::str::FromStr>::from_str(&s)\n+            .map_err(serde::de::Error::custom)\n+    }\n+}\n+\n+impl ValueEnum for IssueSeverityCliOption {\n+    fn value_variants<'a>() -> &'a [Self] {\n+        const VARIANTS: [IssueSeverityCliOption; 8] = [\n+            IssueSeverityCliOption(IssueSeverity::Bug),\n+            IssueSeverityCliOption(IssueSeverity::Fatal),\n+            IssueSeverityCliOption(IssueSeverity::Error),\n+            IssueSeverityCliOption(IssueSeverity::Warning),\n+            IssueSeverityCliOption(IssueSeverity::Hint),\n+            IssueSeverityCliOption(IssueSeverity::Note),\n+            IssueSeverityCliOption(IssueSeverity::Suggestion),\n+            IssueSeverityCliOption(IssueSeverity::Info),\n+        ];\n+        &VARIANTS\n+    }\n+\n+    fn to_possible_value<'a>(&self) -> Option<clap::builder::PossibleValue> {\n+        Some(clap::builder::PossibleValue::new(self.0.as_str()).help(self.0.as_help_str()))\n+    }\n+}\n+\n+impl FromStr for IssueSeverityCliOption {\n+    type Err = anyhow::Error;\n+\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        <IssueSeverityCliOption as clap::ValueEnum>::from_str(s, true).map_err(|s| anyhow!(\"{}\", s))\n+    }\n+}"
        },
        {
            "sha": "646d64b259793991cb7301cf440fc1ba204ca7d9",
            "filename": "turbopack/crates/turbopack-node/Cargo.toml",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/085b7015cee5f08a48f2656066231c31b8fcdf1d/turbopack%2Fcrates%2Fturbopack-node%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/085b7015cee5f08a48f2656066231c31b8fcdf1d/turbopack%2Fcrates%2Fturbopack-node%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2FCargo.toml?ref=085b7015cee5f08a48f2656066231c31b8fcdf1d",
            "patch": "@@ -43,7 +43,6 @@ turbo-tasks-env = { workspace = true }\n turbo-tasks-fs = { workspace = true }\n turbopack-cli-utils = { workspace = true }\n turbopack-core = { workspace = true }\n-turbopack-dev-server = { workspace = true }\n turbopack-ecmascript = { workspace = true }\n turbopack-resolve = { workspace = true }\n "
        },
        {
            "sha": "93e694962907c80f5e971e1632c88ab6340c2f8c",
            "filename": "turbopack/crates/turbopack-node/src/lib.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 4,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/085b7015cee5f08a48f2656066231c31b8fcdf1d/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/085b7015cee5f08a48f2656066231c31b8fcdf1d/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Flib.rs?ref=085b7015cee5f08a48f2656066231c31b8fcdf1d",
            "patch": "@@ -5,7 +5,6 @@\n use std::{iter::once, thread::available_parallelism};\n \n use anyhow::{Result, bail};\n-pub use node_entry::{NodeEntry, NodeRenderingEntries, NodeRenderingEntry};\n use rustc_hash::FxHashMap;\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{\n@@ -25,16 +24,14 @@ use turbopack_core::{\n     virtual_output::VirtualOutputAsset,\n };\n \n-use self::{pool::NodeJsPool, source_map::StructuredError};\n+use self::pool::NodeJsPool;\n \n pub mod debug;\n pub mod embed_js;\n pub mod evaluate;\n pub mod execution_context;\n mod heap_queue;\n-mod node_entry;\n mod pool;\n-pub mod render;\n pub mod route_matcher;\n pub mod source_map;\n pub mod transforms;"
        },
        {
            "sha": "68dce1413d4637a1e44753e63ef9b2f3542a7532",
            "filename": "turbopack/crates/turbopack-node/src/node_entry.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 32,
            "changes": 32,
            "blob_url": "https://github.com/vercel/next.js/blob/38c4caf22a570868b8c1689c843044807560b4a7/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fnode_entry.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/38c4caf22a570868b8c1689c843044807560b4a7/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fnode_entry.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fnode_entry.rs?ref=38c4caf22a570868b8c1689c843044807560b4a7",
            "patch": "@@ -1,32 +0,0 @@\n-use anyhow::Result;\n-use turbo_tasks::{ResolvedVc, Vc};\n-use turbo_tasks_fs::FileSystemPath;\n-use turbopack_core::chunk::{ChunkingContext, EvaluatableAsset, EvaluatableAssets};\n-use turbopack_dev_server::source::ContentSourceData;\n-\n-#[turbo_tasks::value(shared)]\n-pub struct NodeRenderingEntry {\n-    pub runtime_entries: ResolvedVc<EvaluatableAssets>,\n-    pub module: ResolvedVc<Box<dyn EvaluatableAsset>>,\n-    pub chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n-    pub intermediate_output_path: FileSystemPath,\n-    pub output_root: FileSystemPath,\n-    pub project_dir: FileSystemPath,\n-}\n-\n-#[turbo_tasks::value(transparent)]\n-pub struct NodeRenderingEntries(Vec<ResolvedVc<NodeRenderingEntry>>);\n-\n-/// Trait that allows to get the entry module for rendering something in Node.js\n-#[turbo_tasks::value_trait]\n-pub trait NodeEntry {\n-    #[turbo_tasks::function]\n-    fn entry(self: Vc<Self>, data: ContentSourceData) -> Vc<NodeRenderingEntry>;\n-\n-    #[turbo_tasks::function]\n-    async fn entries(self: Vc<Self>) -> Result<Vc<NodeRenderingEntries>> {\n-        Ok(Vc::cell(vec![\n-            self.entry(Default::default()).to_resolved().await?,\n-        ]))\n-    }\n-}"
        },
        {
            "sha": "d0c82a201bd6c0588b54b9b36ff044f1d15d2e68",
            "filename": "turbopack/crates/turbopack-node/src/render/error.html",
            "status": "removed",
            "additions": 0,
            "deletions": 119,
            "changes": 119,
            "blob_url": "https://github.com/vercel/next.js/blob/38c4caf22a570868b8c1689c843044807560b4a7/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Ferror.html",
            "raw_url": "https://github.com/vercel/next.js/raw/38c4caf22a570868b8c1689c843044807560b4a7/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Ferror.html",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Ferror.html?ref=38c4caf22a570868b8c1689c843044807560b4a7",
            "patch": "@@ -1,119 +0,0 @@\n-<!doctype html>\n-<html lang=\"en\">\n-  <head>\n-    <meta charset=\"UTF-8\" />\n-    <title>${TITLE}</title>\n-  </head>\n-  <body>\n-    <div id=\"__next\">\n-      <!-- put it in here, so we can just use the body -->\n-      <style>\n-        body {\n-          color: #000;\n-          background: #fff;\n-          margin: 0;\n-        }\n-\n-        .next-error-h1 {\n-          border-right: 1px solid rgba(0, 0, 0, 0.3);\n-        }\n-\n-        @media (prefers-color-scheme: dark) {\n-          body {\n-            color: #fff;\n-            background: #000;\n-          }\n-          .next-error-h1 {\n-            border-right: 1px solid rgba(255, 255, 255, 0.3);\n-          }\n-        }\n-\n-        .error {\n-          /* https://github.com/sindresorhus/modern-normalize/blob/main/modern-normalize.css#L38-L52 */\n-          font-family:\n-            system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif,\n-            'Apple Color Emoji', 'Segoe UI Emoji';\n-          height: 100vh;\n-          max-height: 100vh;\n-          overflow: hidden;\n-          /*text-align: center;*/\n-          display: flex;\n-          flex-direction: column;\n-          align-items: center;\n-          justify-content: center;\n-        }\n-\n-        .error > div {\n-          max-width: 100%;\n-        }\n-\n-        .desc {\n-          display: inline-block;\n-          text-align: left;\n-        }\n-\n-        h1 {\n-          display: inline-block;\n-          margin: 0 20px 0 0;\n-          padding-right: 23px;\n-          font-size: 24px;\n-          font-weight: 500;\n-          vertical-align: top;\n-          line-height: 49px;\n-        }\n-\n-        h2 {\n-          font-size: 14px;\n-          font-weight: 400;\n-          line-height: 49px;\n-          margin: 0;\n-        }\n-\n-        h3 {\n-          margin-left: 15px;\n-          font-size: 14px;\n-          font-weight: 600;\n-        }\n-\n-        .details {\n-          margin-top: 100px;\n-          overflow: hidden;\n-          max-height: 70%;\n-        }\n-\n-        pre {\n-          padding: 15px;\n-          background: #ddd;\n-\n-          /*white-space: pre-wrap;*/\n-          /*word-break: keep-all;*/\n-\n-          max-width: 80vw;\n-          overflow: scroll;\n-          max-height: 90%;\n-\n-          border-radius: 10px;\n-        }\n-\n-        @media (prefers-color-scheme: dark) {\n-          pre {\n-            background: #222;\n-          }\n-        }\n-      </style>\n-\n-      <div class=\"error\">\n-        <div>\n-          <h1 class=\"next-error-h1\">${STATUS_CODE}</h1>\n-          <div class=\"desc\">\n-            <h2>${TITLE}.</h2>\n-          </div>\n-        </div>\n-        <section class=\"details\">\n-          <h3>Details</h3>\n-          <pre>${DETAILS}</pre>\n-        </section>\n-      </div>\n-    </div>\n-  </body>\n-</html>"
        },
        {
            "sha": "9fb62071d05e05ff7a833fd646391d1e3d1e4d1f",
            "filename": "turbopack/crates/turbopack-node/src/render/error_page.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 47,
            "changes": 47,
            "blob_url": "https://github.com/vercel/next.js/blob/38c4caf22a570868b8c1689c843044807560b4a7/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Ferror_page.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/38c4caf22a570868b8c1689c843044807560b4a7/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Ferror_page.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Ferror_page.rs?ref=38c4caf22a570868b8c1689c843044807560b4a7",
            "patch": "@@ -1,47 +0,0 @@\n-use anyhow::{Context, Result};\n-use turbo_rcstr::RcStr;\n-use turbo_tasks::Vc;\n-use turbo_tasks_fs::embed_file;\n-\n-#[turbo_tasks::function]\n-pub(super) async fn error_html(\n-    status_code: u16,\n-    title: RcStr,\n-    details: RcStr,\n-) -> Result<Vc<RcStr>> {\n-    let html = create_html(status_code, title, details).await?;\n-\n-    Ok(Vc::cell(html.into()))\n-}\n-\n-#[turbo_tasks::function]\n-pub(super) async fn error_html_body(\n-    status_code: u16,\n-    title: RcStr,\n-    details: RcStr,\n-) -> Result<Vc<RcStr>> {\n-    let html = create_html(status_code, title, details).await?;\n-\n-    let (_, body) = html.split_once(\"<body>\").context(\"no body in html\")?;\n-    let (body, _) = body.split_once(\"</body>\").context(\"no body in html\")?;\n-\n-    Ok(Vc::cell(body.into()))\n-}\n-\n-async fn create_html(status_code: u16, title: RcStr, details: RcStr) -> Result<String> {\n-    let file_content = embed_file!(\"src/render/error.html\").await?;\n-    let file = file_content\n-        .as_content()\n-        .context(\"embedded file not found (this should not happen)\")?;\n-\n-    let html = file\n-        .content()\n-        .to_str()\n-        .context(\"couldn't convert embedded html to string\")?;\n-\n-    let html = html.replace(\"${TITLE}\", &title);\n-    let html = html.replace(\"${STATUS_CODE}\", &status_code.to_string());\n-    let html = html.replace(\"${DETAILS}\", &details);\n-\n-    Ok(html)\n-}"
        },
        {
            "sha": "39d6f1caf5988fd4fb2762abdecffb5c2d40e342",
            "filename": "turbopack/crates/turbopack-node/src/render/issue.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 51,
            "changes": 51,
            "blob_url": "https://github.com/vercel/next.js/blob/38c4caf22a570868b8c1689c843044807560b4a7/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Fissue.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/38c4caf22a570868b8c1689c843044807560b4a7/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Fissue.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Fissue.rs?ref=38c4caf22a570868b8c1689c843044807560b4a7",
            "patch": "@@ -1,51 +0,0 @@\n-use turbo_rcstr::rcstr;\n-use turbo_tasks::{ResolvedVc, Vc};\n-use turbo_tasks_fs::FileSystemPath;\n-use turbopack_core::issue::{Issue, IssueStage, OptionStyledString, StyledString};\n-#[turbo_tasks::value(shared)]\n-#[derive(Clone)]\n-pub struct RenderingIssue {\n-    pub file_path: FileSystemPath,\n-    pub message: ResolvedVc<StyledString>,\n-    pub status: Option<i32>,\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl Issue for RenderingIssue {\n-    #[turbo_tasks::function]\n-    fn title(&self) -> Vc<StyledString> {\n-        StyledString::Text(rcstr!(\"Error during SSR Rendering\")).cell()\n-    }\n-\n-    #[turbo_tasks::function]\n-    fn stage(&self) -> Vc<IssueStage> {\n-        IssueStage::CodeGen.cell()\n-    }\n-\n-    #[turbo_tasks::function]\n-    fn file_path(&self) -> Vc<FileSystemPath> {\n-        self.file_path.clone().cell()\n-    }\n-\n-    #[turbo_tasks::function]\n-    fn description(&self) -> Vc<OptionStyledString> {\n-        Vc::cell(Some(self.message))\n-    }\n-\n-    #[turbo_tasks::function]\n-    fn detail(&self) -> Vc<OptionStyledString> {\n-        let mut details = vec![];\n-\n-        if let Some(status) = self.status\n-            && status != 0\n-        {\n-            details.push(StyledString::Text(\n-                format!(\"Node.js exit code: {status}\").into(),\n-            ));\n-        }\n-\n-        Vc::cell(Some(StyledString::Stack(details).resolved_cell()))\n-    }\n-\n-    // TODO parse stack trace into source location\n-}"
        },
        {
            "sha": "b7a133186687fefffff140df2167a1ad8a9282e2",
            "filename": "turbopack/crates/turbopack-node/src/render/mod.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 71,
            "changes": 71,
            "blob_url": "https://github.com/vercel/next.js/blob/38c4caf22a570868b8c1689c843044807560b4a7/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/38c4caf22a570868b8c1689c843044807560b4a7/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Fmod.rs?ref=38c4caf22a570868b8c1689c843044807560b4a7",
            "patch": "@@ -1,71 +0,0 @@\n-use serde::{Deserialize, Serialize};\n-use serde_json::Value as JsonValue;\n-use turbo_rcstr::RcStr;\n-use turbo_tasks::{FxIndexMap, ReadRef};\n-\n-use crate::{ResponseHeaders, StructuredError, route_matcher::Param};\n-\n-pub(crate) mod error_page;\n-pub mod issue;\n-pub mod node_api_source;\n-pub mod render_proxy;\n-pub mod render_static;\n-pub mod rendered_source;\n-\n-#[turbo_tasks::value(shared)]\n-#[serde(rename_all = \"camelCase\")]\n-pub struct RenderData {\n-    params: FxIndexMap<RcStr, Param>,\n-    method: RcStr,\n-    url: RcStr,\n-    original_url: RcStr,\n-    raw_query: RcStr,\n-    raw_headers: Vec<(RcStr, RcStr)>,\n-    path: RcStr,\n-    data: Option<ReadRef<JsonValue>>,\n-}\n-\n-#[derive(Serialize)]\n-#[serde(tag = \"type\", rename_all = \"camelCase\")]\n-enum RenderStaticOutgoingMessage<'a> {\n-    Headers { data: &'a RenderData },\n-}\n-\n-#[derive(Serialize)]\n-#[serde(tag = \"type\", rename_all = \"camelCase\")]\n-enum RenderProxyOutgoingMessage<'a> {\n-    Headers { data: &'a RenderData },\n-    BodyChunk { data: &'a [u8] },\n-    BodyEnd,\n-}\n-\n-#[derive(Deserialize, Debug)]\n-#[serde(tag = \"type\", rename_all = \"camelCase\")]\n-enum RenderProxyIncomingMessage {\n-    Headers { data: ResponseHeaders },\n-    BodyChunk { data: Vec<u8> },\n-    BodyEnd,\n-    Error(StructuredError),\n-}\n-\n-#[derive(Deserialize, Debug)]\n-#[serde(tag = \"type\", rename_all = \"camelCase\")]\n-enum RenderStaticIncomingMessage {\n-    #[serde(rename_all = \"camelCase\")]\n-    Response {\n-        status_code: u16,\n-        headers: Vec<(RcStr, RcStr)>,\n-        body: RcStr,\n-    },\n-    Headers {\n-        data: ResponseHeaders,\n-    },\n-    BodyChunk {\n-        data: Vec<u8>,\n-    },\n-    BodyEnd,\n-    Rewrite {\n-        path: RcStr,\n-    },\n-    Error(StructuredError),\n-}"
        },
        {
            "sha": "cdaf75f2936a019416a4b1da6e781ee6b25def41",
            "filename": "turbopack/crates/turbopack-node/src/render/node_api_source.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 202,
            "changes": 202,
            "blob_url": "https://github.com/vercel/next.js/blob/38c4caf22a570868b8c1689c843044807560b4a7/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Fnode_api_source.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/38c4caf22a570868b8c1689c843044807560b4a7/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Fnode_api_source.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Fnode_api_source.rs?ref=38c4caf22a570868b8c1689c843044807560b4a7",
            "patch": "@@ -1,202 +0,0 @@\n-use anyhow::Result;\n-use serde_json::Value as JsonValue;\n-use turbo_rcstr::{RcStr, rcstr};\n-use turbo_tasks::{FxIndexSet, ResolvedVc, Vc};\n-use turbo_tasks_env::ProcessEnv;\n-use turbo_tasks_fs::FileSystemPath;\n-use turbopack_core::introspect::{\n-    Introspectable, IntrospectableChildren, module::IntrospectableModule,\n-    output_asset::IntrospectableOutputAsset,\n-};\n-use turbopack_dev_server::source::{\n-    ContentSource, ContentSourceContent, ContentSourceData, ContentSourceDataVary,\n-    GetContentSourceContent,\n-    route_tree::{BaseSegment, RouteTree, RouteType},\n-};\n-\n-use super::{RenderData, render_proxy::render_proxy_operation};\n-use crate::{get_intermediate_asset, node_entry::NodeEntry, route_matcher::RouteMatcher};\n-\n-/// Creates a [NodeApiContentSource].\n-#[turbo_tasks::function]\n-pub fn create_node_api_source(\n-    cwd: FileSystemPath,\n-    env: ResolvedVc<Box<dyn ProcessEnv>>,\n-    base_segments: Vec<BaseSegment>,\n-    route_type: RouteType,\n-    server_root: FileSystemPath,\n-    route_match: ResolvedVc<Box<dyn RouteMatcher>>,\n-    pathname: ResolvedVc<RcStr>,\n-    entry: ResolvedVc<Box<dyn NodeEntry>>,\n-    render_data: ResolvedVc<JsonValue>,\n-    debug: bool,\n-) -> Vc<Box<dyn ContentSource>> {\n-    Vc::upcast(\n-        NodeApiContentSource {\n-            cwd,\n-            env,\n-            base_segments,\n-            route_type,\n-            server_root,\n-            pathname,\n-            route_match,\n-            entry,\n-            render_data,\n-            debug,\n-        }\n-        .cell(),\n-    )\n-}\n-\n-/// A content source that proxies API requests to one-off Node.js\n-/// servers running the passed `entry` when it matches a `path_regex`.\n-///\n-/// It needs a temporary directory (`intermediate_output_path`) to place file\n-/// for Node.js execution during rendering. The `chunking_context` should emit\n-/// to this directory.\n-#[turbo_tasks::value]\n-pub struct NodeApiContentSource {\n-    cwd: FileSystemPath,\n-    env: ResolvedVc<Box<dyn ProcessEnv>>,\n-    base_segments: Vec<BaseSegment>,\n-    route_type: RouteType,\n-    server_root: FileSystemPath,\n-    pathname: ResolvedVc<RcStr>,\n-    route_match: ResolvedVc<Box<dyn RouteMatcher>>,\n-    entry: ResolvedVc<Box<dyn NodeEntry>>,\n-    render_data: ResolvedVc<JsonValue>,\n-    debug: bool,\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl NodeApiContentSource {\n-    #[turbo_tasks::function]\n-    pub fn get_pathname(&self) -> Vc<RcStr> {\n-        *self.pathname\n-    }\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl ContentSource for NodeApiContentSource {\n-    #[turbo_tasks::function]\n-    async fn get_routes(self: Vc<Self>) -> Result<Vc<RouteTree>> {\n-        let this = self.await?;\n-        Ok(RouteTree::new_route(\n-            this.base_segments.clone(),\n-            this.route_type.clone(),\n-            Vc::upcast(self),\n-        ))\n-    }\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl GetContentSourceContent for NodeApiContentSource {\n-    #[turbo_tasks::function]\n-    fn vary(&self) -> Vc<ContentSourceDataVary> {\n-        ContentSourceDataVary {\n-            method: true,\n-            url: true,\n-            original_url: true,\n-            raw_headers: true,\n-            raw_query: true,\n-            body: true,\n-            cache_buster: true,\n-            ..Default::default()\n-        }\n-        .cell()\n-    }\n-\n-    #[turbo_tasks::function]\n-    async fn get(&self, path: RcStr, data: ContentSourceData) -> Result<Vc<ContentSourceContent>> {\n-        let Some(params) = &*self.route_match.params(path.clone()).await? else {\n-            anyhow::bail!(\"Non matching path provided\")\n-        };\n-        let ContentSourceData {\n-            method: Some(method),\n-            url: Some(url),\n-            original_url: Some(original_url),\n-            raw_headers: Some(raw_headers),\n-            raw_query: Some(raw_query),\n-            body: Some(body),\n-            ..\n-        } = &data\n-        else {\n-            anyhow::bail!(\"Missing request data\")\n-        };\n-        let entry = (*self.entry).entry(data.clone()).await?;\n-        Ok(ContentSourceContent::HttpProxy(render_proxy_operation(\n-            self.cwd.clone(),\n-            self.env,\n-            self.server_root.join(&path)?,\n-            ResolvedVc::upcast(entry.module),\n-            entry.runtime_entries,\n-            entry.chunking_context,\n-            entry.intermediate_output_path.clone(),\n-            entry.output_root.clone(),\n-            entry.project_dir.clone(),\n-            RenderData {\n-                params: params.clone(),\n-                method: method.clone(),\n-                url: url.clone(),\n-                original_url: original_url.clone(),\n-                raw_query: raw_query.clone(),\n-                raw_headers: raw_headers.clone(),\n-                path: format!(\"/{path}\").into(),\n-                data: Some(self.render_data.await?),\n-            }\n-            .resolved_cell(),\n-            *body,\n-            self.debug,\n-        ))\n-        .cell())\n-    }\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl Introspectable for NodeApiContentSource {\n-    #[turbo_tasks::function]\n-    fn ty(&self) -> Vc<RcStr> {\n-        Vc::cell(rcstr!(\"node api content source\"))\n-    }\n-\n-    #[turbo_tasks::function]\n-    fn title(&self) -> Vc<RcStr> {\n-        *self.pathname\n-    }\n-\n-    #[turbo_tasks::function]\n-    fn details(&self) -> Vc<RcStr> {\n-        Vc::cell(\n-            format!(\n-                \"base: {:?}\\ntype: {:?}\",\n-                self.base_segments, self.route_type\n-            )\n-            .into(),\n-        )\n-    }\n-\n-    #[turbo_tasks::function]\n-    async fn children(&self) -> Result<Vc<IntrospectableChildren>> {\n-        let mut set = FxIndexSet::default();\n-        for &entry in self.entry.entries().await?.iter() {\n-            let entry = entry.await?;\n-            set.insert((\n-                rcstr!(\"module\"),\n-                IntrospectableModule::new(Vc::upcast(*entry.module))\n-                    .to_resolved()\n-                    .await?,\n-            ));\n-            set.insert((\n-                rcstr!(\"intermediate asset\"),\n-                IntrospectableOutputAsset::new(get_intermediate_asset(\n-                    *entry.chunking_context,\n-                    Vc::upcast(*entry.module),\n-                    *entry.runtime_entries,\n-                ))\n-                .to_resolved()\n-                .await?,\n-            ));\n-        }\n-        Ok(Vc::cell(set))\n-    }\n-}"
        },
        {
            "sha": "02fd6c4c28b02a1b4e70c9f695536ab42d1e2e02",
            "filename": "turbopack/crates/turbopack-node/src/render/render_proxy.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 346,
            "changes": 346,
            "blob_url": "https://github.com/vercel/next.js/blob/38c4caf22a570868b8c1689c843044807560b4a7/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Frender_proxy.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/38c4caf22a570868b8c1689c843044807560b4a7/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Frender_proxy.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Frender_proxy.rs?ref=38c4caf22a570868b8c1689c843044807560b4a7",
            "patch": "@@ -1,346 +0,0 @@\n-use anyhow::{Result, anyhow, bail};\n-use async_stream::try_stream as generator;\n-use futures::{\n-    SinkExt, StreamExt, TryStreamExt,\n-    channel::mpsc::{UnboundedSender, unbounded},\n-    pin_mut,\n-};\n-use parking_lot::Mutex;\n-use serde::{Deserialize, Serialize};\n-use turbo_rcstr::{RcStr, rcstr};\n-use turbo_tasks::{\n-    RawVc, ResolvedVc, TaskInput, ValueToString, Vc, VcValueType, duration_span, mark_finished,\n-    prevent_gc, trace::TraceRawVcs, util::SharedError,\n-};\n-use turbo_tasks_bytes::{Bytes, Stream};\n-use turbo_tasks_env::ProcessEnv;\n-use turbo_tasks_fs::FileSystemPath;\n-use turbopack_core::{\n-    chunk::{ChunkingContext, EvaluatableAsset, EvaluatableAssets},\n-    error::PrettyPrintError,\n-    issue::{IssueExt, StyledString},\n-    module::Module,\n-};\n-use turbopack_dev_server::source::{Body, ProxyResult};\n-\n-use super::{\n-    RenderData, RenderProxyIncomingMessage, RenderProxyOutgoingMessage, ResponseHeaders,\n-    issue::RenderingIssue,\n-};\n-use crate::{\n-    get_intermediate_asset, get_renderer_pool_operation, pool::NodeJsOperation,\n-    render::error_page::error_html, source_map::trace_stack,\n-};\n-\n-/// Renders a module as static HTML in a node.js process.\n-#[turbo_tasks::function(operation)]\n-pub async fn render_proxy_operation(\n-    cwd: FileSystemPath,\n-    env: ResolvedVc<Box<dyn ProcessEnv>>,\n-    path: FileSystemPath,\n-    module: ResolvedVc<Box<dyn EvaluatableAsset>>,\n-    runtime_entries: ResolvedVc<EvaluatableAssets>,\n-    chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n-    intermediate_output_path: FileSystemPath,\n-    output_root: FileSystemPath,\n-    project_dir: FileSystemPath,\n-    data: ResolvedVc<RenderData>,\n-    body: ResolvedVc<Body>,\n-    debug: bool,\n-) -> Result<Vc<ProxyResult>> {\n-    let render = render_stream(RenderStreamOptions {\n-        cwd,\n-        env,\n-        path,\n-        module,\n-        runtime_entries,\n-        chunking_context,\n-        intermediate_output_path,\n-        output_root,\n-        project_dir,\n-        data,\n-        body,\n-        debug,\n-    })\n-    .await?;\n-\n-    let mut stream = render.read();\n-    let first = match stream.try_next().await? {\n-        Some(f) => f,\n-        None => {\n-            // If an Error was received first, then it would have been\n-            // transformed into a proxy err error response.\n-            bail!(\"did not receive response from render\");\n-        }\n-    };\n-\n-    let RenderItem::Headers(data) = first else {\n-        bail!(\"did not receive headers from render\");\n-    };\n-\n-    let body = Body::from_stream(stream.map(|item| match item {\n-        Ok(RenderItem::BodyChunk(b)) => Ok(b),\n-        Ok(v) => Err(SharedError::new(anyhow!(\n-            \"unexpected render item: {:#?}\",\n-            v\n-        ))),\n-        Err(e) => Err(e),\n-    }));\n-    let result = ProxyResult {\n-        status: data.status,\n-        headers: data.headers,\n-        body,\n-    };\n-\n-    Ok(result.cell())\n-}\n-\n-async fn proxy_error(\n-    path: FileSystemPath,\n-    error: anyhow::Error,\n-    operation: Option<NodeJsOperation>,\n-) -> Result<(u16, RcStr)> {\n-    let message = format!(\"{}\", PrettyPrintError(&error));\n-\n-    let status = match operation {\n-        Some(operation) => Some(operation.wait_or_kill().await?),\n-        None => None,\n-    };\n-\n-    let mut details = vec![];\n-    if let Some(status) = status {\n-        details.push(format!(\"status: {status}\"));\n-    }\n-\n-    let status_code = 500;\n-    let body = error_html(\n-        status_code,\n-        rcstr!(\"An error occurred while proxying the request to Node.js\"),\n-        format!(\"{message}\\n\\n{}\", details.join(\"\\n\")).into(),\n-    )\n-    .owned()\n-    .await?;\n-\n-    RenderingIssue {\n-        file_path: path,\n-        message: StyledString::Text(message.into()).resolved_cell(),\n-        status: status.and_then(|status| status.code()),\n-    }\n-    .resolved_cell()\n-    .emit();\n-\n-    Ok((status_code, body))\n-}\n-\n-#[derive(Clone, Debug)]\n-#[turbo_tasks::value]\n-enum RenderItem {\n-    Headers(ResponseHeaders),\n-    BodyChunk(Bytes),\n-}\n-\n-type RenderItemResult = Result<RenderItem, SharedError>;\n-\n-#[turbo_tasks::value(eq = \"manual\", cell = \"new\", serialization = \"none\")]\n-struct RenderStreamSender {\n-    #[turbo_tasks(trace_ignore, debug_ignore)]\n-    get: Box<dyn Fn() -> UnboundedSender<RenderItemResult> + Send + Sync>,\n-}\n-\n-#[turbo_tasks::value(transparent)]\n-struct RenderStream(#[turbo_tasks(trace_ignore)] Stream<RenderItemResult>);\n-\n-#[derive(Clone, Debug, TaskInput, PartialEq, Eq, Hash, Serialize, Deserialize, TraceRawVcs)]\n-struct RenderStreamOptions {\n-    cwd: FileSystemPath,\n-    env: ResolvedVc<Box<dyn ProcessEnv>>,\n-    path: FileSystemPath,\n-    module: ResolvedVc<Box<dyn EvaluatableAsset>>,\n-    runtime_entries: ResolvedVc<EvaluatableAssets>,\n-    chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n-    intermediate_output_path: FileSystemPath,\n-    output_root: FileSystemPath,\n-    project_dir: FileSystemPath,\n-    data: ResolvedVc<RenderData>,\n-    body: ResolvedVc<Body>,\n-    debug: bool,\n-}\n-\n-#[turbo_tasks::function]\n-fn render_stream(options: RenderStreamOptions) -> Vc<RenderStream> {\n-    // TODO: The way we invoke render_stream_internal as side effect is not\n-    // GC-safe, so we disable GC for this task.\n-    prevent_gc();\n-\n-    // Note the following code uses some hacks to create a child task that produces\n-    // a stream that is returned by this task.\n-\n-    // We create a new cell in this task, which will be updated from the\n-    // [render_stream_internal] task.\n-    let cell = turbo_tasks::macro_helpers::find_cell_by_type(\n-        <RenderStream as VcValueType>::get_value_type_id(),\n-    );\n-\n-    // We initialize the cell with a stream that is open, but has no values.\n-    // The first [render_stream_internal] pipe call will pick up that stream.\n-    let (sender, receiver) = unbounded();\n-    cell.update(RenderStream(Stream::new_open(vec![], Box::new(receiver))));\n-    let initial = Mutex::new(Some(sender));\n-\n-    // run the evaluation as side effect\n-    let _ = render_stream_internal(\n-        options,\n-        RenderStreamSender {\n-            get: Box::new(move || {\n-                if let Some(sender) = initial.lock().take() {\n-                    sender\n-                } else {\n-                    // In cases when only [render_stream_internal] is (re)executed, we need to\n-                    // update the old stream with a new value.\n-                    let (sender, receiver) = unbounded();\n-                    cell.update(RenderStream(Stream::new_open(vec![], Box::new(receiver))));\n-                    sender\n-                }\n-            }),\n-        }\n-        .cell(),\n-    );\n-\n-    let raw: RawVc = cell.into();\n-    raw.into()\n-}\n-\n-#[turbo_tasks::function]\n-async fn render_stream_internal(\n-    options: RenderStreamOptions,\n-    sender: Vc<RenderStreamSender>,\n-) -> Result<Vc<()>> {\n-    let RenderStreamOptions {\n-        cwd,\n-        env,\n-        path,\n-        module,\n-        runtime_entries,\n-        chunking_context,\n-        intermediate_output_path,\n-        output_root,\n-        project_dir,\n-        data,\n-        body,\n-        debug,\n-    } = options;\n-\n-    mark_finished();\n-    let Ok(sender) = sender.await else {\n-        // Impossible to handle the error in a good way.\n-        return Ok(Default::default());\n-    };\n-\n-    let stream = generator! {\n-        let intermediate_asset = get_intermediate_asset(\n-            *chunking_context,\n-            *module,\n-            *runtime_entries,\n-        ).to_resolved().await?;\n-        let pool_op = get_renderer_pool_operation(\n-            cwd,\n-            env,\n-            intermediate_asset,\n-            intermediate_output_path.clone(),\n-            output_root,\n-            project_dir.clone(),\n-            debug,\n-        );\n-\n-        // Read this strongly consistent, since we don't want to run inconsistent\n-        // node.js code.\n-        let pool = pool_op.read_strongly_consistent().await?;\n-        let data = data.await?;\n-        let mut operation = pool.operation().await?;\n-\n-        // First, send the render data.\n-        operation\n-            .send(RenderProxyOutgoingMessage::Headers { data: &data })\n-            .await?;\n-        // Then, send the binary body in chunks.\n-        let mut body = body.await?.read();\n-        while let Some(data) = body.next().await {\n-            operation\n-                .send(RenderProxyOutgoingMessage::BodyChunk { data: &data.unwrap() })\n-                .await?;\n-        }\n-        operation.send(RenderProxyOutgoingMessage::BodyEnd).await?;\n-\n-        let entry = module.ident().to_string().await?;\n-        let guard = duration_span!(\"Node.js api execution\", entry = display(entry));\n-\n-        match operation.recv().await? {\n-            RenderProxyIncomingMessage::Headers { data } => yield RenderItem::Headers(data),\n-            RenderProxyIncomingMessage::Error(error) => {\n-                drop(guard);\n-                // If we don't get headers, then something is very wrong. Instead, we send down a\n-                // 500 proxy error as if it were the proper result.\n-                let trace = trace_stack(\n-                    error,\n-                    *intermediate_asset,\n-                    intermediate_output_path.clone(),\n-                    project_dir.clone()\n-                )\n-                .await?;\n-                let (status, body) =  proxy_error(path, anyhow!(\"error rendering: {}\", trace), Some(operation)).await?;\n-                yield RenderItem::Headers(ResponseHeaders {\n-                    status,\n-                    headers: vec![(\n-                        rcstr!(\"content-type\"),\n-                        rcstr!(\"text/html; charset=utf-8\"),\n-                    )],\n-                });\n-                yield RenderItem::BodyChunk(body.into_owned().into_bytes().into());\n-                return;\n-            }\n-            v => {\n-                drop(guard);\n-                Err(anyhow!(\"unexpected message during rendering: {:#?}\", v))?;\n-                return;\n-            },\n-        };\n-\n-        loop {\n-            match operation.recv().await? {\n-                RenderProxyIncomingMessage::BodyChunk { data } => {\n-                    yield RenderItem::BodyChunk(data.into());\n-                }\n-                RenderProxyIncomingMessage::BodyEnd => break,\n-                RenderProxyIncomingMessage::Error(error) => {\n-                    drop(guard);\n-                    // We have already started to send a result, so we can't change the\n-                    // headers/body to a proxy error.\n-                    operation.disallow_reuse();\n-                    let trace =\n-                        trace_stack(error, *intermediate_asset, intermediate_output_path.clone(), project_dir.clone()).await?;\n-                    Err(anyhow!(\"error during streaming render: {}\", trace))?;\n-                    return;\n-                }\n-                v => {\n-                    drop(guard);\n-                    Err(anyhow!(\"unexpected message during rendering: {:#?}\", v))?;\n-                    return;\n-                },\n-            }\n-        }\n-        drop(guard);\n-    };\n-\n-    let mut sender = (sender.get)();\n-    pin_mut!(stream);\n-    while let Some(value) = stream.next().await {\n-        if sender.send(value).await.is_err() {\n-            return Ok(Default::default());\n-        }\n-        if sender.flush().await.is_err() {\n-            return Ok(Default::default());\n-        }\n-    }\n-\n-    Ok(Default::default())\n-}"
        },
        {
            "sha": "6e312d7da2be192c27109a8c264385a8658f27b8",
            "filename": "turbopack/crates/turbopack-node/src/render/render_static.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 411,
            "changes": 411,
            "blob_url": "https://github.com/vercel/next.js/blob/38c4caf22a570868b8c1689c843044807560b4a7/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Frender_static.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/38c4caf22a570868b8c1689c843044807560b4a7/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Frender_static.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Frender_static.rs?ref=38c4caf22a570868b8c1689c843044807560b4a7",
            "patch": "@@ -1,411 +0,0 @@\n-use anyhow::{Context, Result, anyhow, bail};\n-use async_stream::try_stream as generator;\n-use futures::{\n-    SinkExt, StreamExt, TryStreamExt,\n-    channel::mpsc::{UnboundedSender, unbounded},\n-    pin_mut,\n-};\n-use parking_lot::Mutex;\n-use serde::{Deserialize, Serialize};\n-use turbo_rcstr::rcstr;\n-use turbo_tasks::{\n-    RawVc, ResolvedVc, TaskInput, ValueToString, Vc, VcValueType, duration_span, mark_finished,\n-    prevent_gc, trace::TraceRawVcs, util::SharedError,\n-};\n-use turbo_tasks_bytes::{Bytes, Stream};\n-use turbo_tasks_env::ProcessEnv;\n-use turbo_tasks_fs::{File, FileSystemPath};\n-use turbopack_core::{\n-    asset::{Asset, AssetContent},\n-    chunk::{ChunkingContext, EvaluatableAsset, EvaluatableAssets},\n-    error::PrettyPrintError,\n-    issue::{IssueExt, StyledString},\n-    module::Module,\n-};\n-use turbopack_dev_server::{\n-    html::DevHtmlAsset,\n-    source::{Body, HeaderList, Rewrite, RewriteBuilder},\n-};\n-\n-use super::{\n-    RenderData, RenderStaticIncomingMessage, RenderStaticOutgoingMessage, issue::RenderingIssue,\n-};\n-use crate::{\n-    ResponseHeaders, get_intermediate_asset, get_renderer_pool_operation, pool::NodeJsOperation,\n-    render::error_page::error_html_body, source_map::trace_stack,\n-};\n-\n-#[derive(Clone, Debug)]\n-#[turbo_tasks::value]\n-pub enum StaticResult {\n-    Content {\n-        content: ResolvedVc<AssetContent>,\n-        status_code: u16,\n-        headers: ResolvedVc<HeaderList>,\n-    },\n-    StreamedContent {\n-        status: u16,\n-        headers: ResolvedVc<HeaderList>,\n-        body: Body,\n-    },\n-    Rewrite(ResolvedVc<Rewrite>),\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl StaticResult {\n-    #[turbo_tasks::function]\n-    pub fn content(\n-        content: ResolvedVc<AssetContent>,\n-        status_code: u16,\n-        headers: ResolvedVc<HeaderList>,\n-    ) -> Vc<Self> {\n-        StaticResult::Content {\n-            content,\n-            status_code,\n-            headers,\n-        }\n-        .cell()\n-    }\n-\n-    #[turbo_tasks::function]\n-    pub fn rewrite(rewrite: ResolvedVc<Rewrite>) -> Vc<Self> {\n-        StaticResult::Rewrite(rewrite).cell()\n-    }\n-}\n-\n-/// Renders a module as static HTML in a node.js process.\n-#[turbo_tasks::function(operation)]\n-pub async fn render_static_operation(\n-    cwd: FileSystemPath,\n-    env: ResolvedVc<Box<dyn ProcessEnv>>,\n-    path: FileSystemPath,\n-    module: ResolvedVc<Box<dyn EvaluatableAsset>>,\n-    runtime_entries: ResolvedVc<EvaluatableAssets>,\n-    fallback_page: ResolvedVc<DevHtmlAsset>,\n-    chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n-    intermediate_output_path: FileSystemPath,\n-    output_root: FileSystemPath,\n-    project_dir: FileSystemPath,\n-    data: ResolvedVc<RenderData>,\n-    debug: bool,\n-) -> Result<Vc<StaticResult>> {\n-    let render = render_stream(RenderStreamOptions {\n-        cwd,\n-        env,\n-        path,\n-        module,\n-        runtime_entries,\n-        fallback_page,\n-        chunking_context,\n-        intermediate_output_path,\n-        output_root,\n-        project_dir,\n-        data,\n-        debug,\n-    })\n-    .await?;\n-\n-    let mut stream = render.read();\n-    let first = match stream.try_next().await? {\n-        Some(f) => f,\n-        None => {\n-            // If an Error was received first, then it would have been\n-            // transformed into a proxy err error response.\n-            bail!(\"did not receive response from render\");\n-        }\n-    };\n-\n-    Ok(match first {\n-        RenderItem::Response(response) => *response,\n-        RenderItem::Headers(data) => {\n-            let body = stream.map(|item| match item {\n-                Ok(RenderItem::BodyChunk(b)) => Ok(b),\n-                Ok(v) => Err(SharedError::new(anyhow!(\n-                    \"unexpected render item: {:#?}\",\n-                    v\n-                ))),\n-                Err(e) => Err(e),\n-            });\n-            StaticResult::StreamedContent {\n-                status: data.status,\n-                headers: ResolvedVc::cell(data.headers),\n-                body: Body::from_stream(body),\n-            }\n-            .cell()\n-        }\n-        v => bail!(\"unexpected render item: {:#?}\", v),\n-    })\n-}\n-\n-async fn static_error(\n-    path: FileSystemPath,\n-    error: anyhow::Error,\n-    operation: Option<NodeJsOperation>,\n-    fallback_page: Vc<DevHtmlAsset>,\n-) -> Result<Vc<AssetContent>> {\n-    let status = match operation {\n-        Some(operation) => Some(operation.wait_or_kill().await?),\n-        None => None,\n-    };\n-\n-    let error = format!(\"{}\", PrettyPrintError(&error));\n-    let mut message = error\n-        // TODO this is pretty inefficient\n-        .replace('&', \"&amp;\")\n-        .replace('>', \"&gt;\")\n-        .replace('<', \"&lt;\");\n-\n-    if let Some(status) = status {\n-        message.push_str(&format!(\"\\n\\nStatus: {status}\"));\n-    }\n-\n-    let mut body = \"<script id=\\\"__NEXT_DATA__\\\" type=\\\"application/json\\\">{ \\\"props\\\": {} \\\n-                    }</script>\"\n-        .to_string();\n-\n-    body.push_str(\n-        error_html_body(500, rcstr!(\"Error rendering page\"), message.into())\n-            .await?\n-            .as_str(),\n-    );\n-\n-    let issue = RenderingIssue {\n-        file_path: path,\n-        message: StyledString::Text(error.into()).resolved_cell(),\n-        status: status.and_then(|status| status.code()),\n-    };\n-\n-    issue.resolved_cell().emit();\n-\n-    let html = fallback_page.with_body(body.into());\n-\n-    Ok(html.content())\n-}\n-\n-#[derive(Clone, Debug)]\n-#[turbo_tasks::value]\n-enum RenderItem {\n-    Response(ResolvedVc<StaticResult>),\n-    Headers(ResponseHeaders),\n-    BodyChunk(Bytes),\n-}\n-\n-type RenderItemResult = Result<RenderItem, SharedError>;\n-\n-#[turbo_tasks::value(eq = \"manual\", cell = \"new\", serialization = \"none\")]\n-struct RenderStreamSender {\n-    #[turbo_tasks(trace_ignore, debug_ignore)]\n-    get: Box<dyn Fn() -> UnboundedSender<RenderItemResult> + Send + Sync>,\n-}\n-\n-#[turbo_tasks::value(transparent)]\n-struct RenderStream(#[turbo_tasks(trace_ignore)] Stream<RenderItemResult>);\n-\n-#[derive(Clone, Debug, TaskInput, PartialEq, Eq, Hash, Deserialize, Serialize, TraceRawVcs)]\n-struct RenderStreamOptions {\n-    cwd: FileSystemPath,\n-    env: ResolvedVc<Box<dyn ProcessEnv>>,\n-    path: FileSystemPath,\n-    module: ResolvedVc<Box<dyn EvaluatableAsset>>,\n-    runtime_entries: ResolvedVc<EvaluatableAssets>,\n-    fallback_page: ResolvedVc<DevHtmlAsset>,\n-    chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n-    intermediate_output_path: FileSystemPath,\n-    output_root: FileSystemPath,\n-    project_dir: FileSystemPath,\n-    data: ResolvedVc<RenderData>,\n-    debug: bool,\n-}\n-\n-#[turbo_tasks::function]\n-fn render_stream(options: RenderStreamOptions) -> Vc<RenderStream> {\n-    // TODO: The way we invoke render_stream_internal as side effect is not\n-    // GC-safe, so we disable GC for this task.\n-    prevent_gc();\n-\n-    // Note the following code uses some hacks to create a child task that produces\n-    // a stream that is returned by this task.\n-\n-    // We create a new cell in this task, which will be updated from the\n-    // [render_stream_internal] task.\n-    let cell = turbo_tasks::macro_helpers::find_cell_by_type(\n-        <RenderStream as VcValueType>::get_value_type_id(),\n-    );\n-\n-    // We initialize the cell with a stream that is open, but has no values.\n-    // The first [render_stream_internal] pipe call will pick up that stream.\n-    let (sender, receiver) = unbounded();\n-    cell.update(RenderStream(Stream::new_open(vec![], Box::new(receiver))));\n-    let initial = Mutex::new(Some(sender));\n-\n-    // run the evaluation as side effect\n-    let _ = render_stream_internal(\n-        options,\n-        RenderStreamSender {\n-            get: Box::new(move || {\n-                if let Some(sender) = initial.lock().take() {\n-                    sender\n-                } else {\n-                    // In cases when only [render_stream_internal] is (re)executed, we need to\n-                    // update the old stream with a new value.\n-                    let (sender, receiver) = unbounded();\n-                    cell.update(RenderStream(Stream::new_open(vec![], Box::new(receiver))));\n-                    sender\n-                }\n-            }),\n-        }\n-        .cell(),\n-    );\n-\n-    let raw: RawVc = cell.into();\n-    raw.into()\n-}\n-\n-#[turbo_tasks::function]\n-async fn render_stream_internal(\n-    options: RenderStreamOptions,\n-    sender: Vc<RenderStreamSender>,\n-) -> Result<Vc<()>> {\n-    let RenderStreamOptions {\n-        cwd,\n-        env,\n-        path,\n-        module,\n-        runtime_entries,\n-        fallback_page,\n-        chunking_context,\n-        intermediate_output_path,\n-        output_root,\n-        project_dir,\n-        data,\n-        debug,\n-    } = options;\n-\n-    mark_finished();\n-    let Ok(sender) = sender.await else {\n-        // Impossible to handle the error in a good way.\n-        return Ok(Default::default());\n-    };\n-\n-    let stream = generator! {\n-        let intermediate_asset = get_intermediate_asset(\n-            *chunking_context,\n-            *module,\n-            *runtime_entries,\n-        ).to_resolved().await?;\n-        let renderer_pool_op = get_renderer_pool_operation(\n-            cwd,\n-            env,\n-            intermediate_asset,\n-            intermediate_output_path.clone(),\n-            output_root,\n-            project_dir.clone(),\n-            debug,\n-        );\n-\n-        // Read this strongly consistent, since we don't want to run inconsistent\n-        // node.js code.\n-        let pool = renderer_pool_op.read_strongly_consistent().await?;\n-        let data = data.await?;\n-        let mut operation = pool.operation().await?;\n-\n-        operation\n-            .send(RenderStaticOutgoingMessage::Headers { data: &data })\n-            .await\n-            .context(\"sending headers to node.js process\")?;\n-\n-        let entry = module.ident().to_string().await?;\n-        let guard = duration_span!(\"Node.js rendering\", entry = display(entry));\n-\n-        match operation.recv().await? {\n-            RenderStaticIncomingMessage::Headers { data } => yield RenderItem::Headers(data),\n-            RenderStaticIncomingMessage::Rewrite { path } => {\n-                drop(guard);\n-                yield RenderItem::Response(\n-                    StaticResult::rewrite(RewriteBuilder::new(path).build()).to_resolved().await?\n-                );\n-                return;\n-            }\n-            RenderStaticIncomingMessage::Response {\n-                status_code,\n-                headers,\n-                body,\n-            } => {\n-                drop(guard);\n-                yield RenderItem::Response(\n-                    StaticResult::content(\n-                        AssetContent::file(File::from(body).into()),\n-                        status_code,\n-                        Vc::cell(headers),\n-                    ).to_resolved().await?\n-                );\n-                return;\n-            }\n-            RenderStaticIncomingMessage::Error(error) => {\n-                drop(guard);\n-                // If we don't get headers, then something is very wrong. Instead, we send down a\n-                // 500 proxy error as if it were the proper result.\n-                let trace = trace_stack(\n-                    error,\n-                    *intermediate_asset,\n-                    intermediate_output_path.clone(),\n-                    project_dir.clone(),\n-                )\n-                .await?;\n-                yield RenderItem::Response(\n-                    StaticResult::content(\n-                        static_error(path, anyhow!(trace), Some(operation), *fallback_page).await?,\n-                        500,\n-                        HeaderList::empty(),\n-                    ).to_resolved().await?\n-                );\n-                return;\n-            }\n-            v => {\n-                drop(guard);\n-                Err(anyhow!(\"unexpected message during rendering: {:#?}\", v))?;\n-                return;\n-            },\n-        };\n-\n-        // If we get here, then the first message was a Headers. Now we need to stream out the body\n-        // chunks.\n-        loop {\n-            match operation.recv().await? {\n-                RenderStaticIncomingMessage::BodyChunk { data } => {\n-                    yield RenderItem::BodyChunk(data.into());\n-                }\n-                RenderStaticIncomingMessage::BodyEnd => break,\n-                RenderStaticIncomingMessage::Error(error) => {\n-                    // We have already started to send a result, so we can't change the\n-                    // headers/body to a proxy error.\n-                    operation.disallow_reuse();\n-                    let trace =\n-                        trace_stack(error, *intermediate_asset, intermediate_output_path.clone(), project_dir.clone()).await?;\n-                        drop(guard);\n-                    Err(anyhow!(\"error during streaming render: {}\", trace))?;\n-                    return;\n-                }\n-                v => {\n-                    drop(guard);\n-                    Err(anyhow!(\"unexpected message during rendering: {:#?}\", v))?;\n-                    return;\n-                },\n-            }\n-        }\n-        drop(guard);\n-    };\n-\n-    let mut sender = (sender.get)();\n-    pin_mut!(stream);\n-    while let Some(value) = stream.next().await {\n-        if sender.send(value).await.is_err() {\n-            return Ok(Default::default());\n-        }\n-        if sender.flush().await.is_err() {\n-            return Ok(Default::default());\n-        }\n-    }\n-\n-    Ok(Default::default())\n-}"
        },
        {
            "sha": "2e4579c2dd5739c31e19d707d6f1ba24843d8c24",
            "filename": "turbopack/crates/turbopack-node/src/render/rendered_source.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 304,
            "changes": 304,
            "blob_url": "https://github.com/vercel/next.js/blob/38c4caf22a570868b8c1689c843044807560b4a7/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Frendered_source.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/38c4caf22a570868b8c1689c843044807560b4a7/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Frendered_source.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Frendered_source.rs?ref=38c4caf22a570868b8c1689c843044807560b4a7",
            "patch": "@@ -1,304 +0,0 @@\n-use anyhow::Result;\n-use serde_json::Value as JsonValue;\n-use turbo_rcstr::{RcStr, rcstr};\n-use turbo_tasks::{FxIndexSet, OperationVc, ResolvedVc, Vc};\n-use turbo_tasks_env::ProcessEnv;\n-use turbo_tasks_fs::FileSystemPath;\n-use turbopack_core::{\n-    introspect::{\n-        Introspectable, IntrospectableChildren, module::IntrospectableModule,\n-        output_asset::IntrospectableOutputAsset,\n-    },\n-    issue::IssueDescriptionExt,\n-    module::Module,\n-    output::OutputAsset,\n-    version::VersionedContentExt,\n-};\n-use turbopack_dev_server::{\n-    html::DevHtmlAsset,\n-    source::{\n-        ContentSource, ContentSourceContent, ContentSourceData, ContentSourceDataVary,\n-        GetContentSourceContent, ProxyResult,\n-        asset_graph::AssetGraphContentSource,\n-        conditional::ConditionalContentSource,\n-        lazy_instantiated::{GetContentSource, LazyInstantiatedContentSource},\n-        route_tree::{BaseSegment, RouteTree, RouteType},\n-    },\n-};\n-\n-use super::{\n-    RenderData,\n-    render_static::{StaticResult, render_static_operation},\n-};\n-use crate::{\n-    external_asset_entrypoints, get_intermediate_asset, node_entry::NodeEntry,\n-    route_matcher::RouteMatcher,\n-};\n-\n-/// Creates a content source that renders something in Node.js with the passed\n-/// `entry` when it matches a `path_regex`. Once rendered it serves\n-/// all assets referenced by the `entry` that are within the `server_root`.\n-/// It needs a temporary directory (`intermediate_output_path`) to place file\n-/// for Node.js execution during rendering. The `chunking_context` should emit\n-/// to this directory.\n-#[turbo_tasks::function]\n-pub fn create_node_rendered_source(\n-    cwd: FileSystemPath,\n-    env: ResolvedVc<Box<dyn ProcessEnv>>,\n-    base_segments: Vec<BaseSegment>,\n-    route_type: RouteType,\n-    server_root: FileSystemPath,\n-    route_match: ResolvedVc<Box<dyn RouteMatcher>>,\n-    pathname: ResolvedVc<RcStr>,\n-    entry: ResolvedVc<Box<dyn NodeEntry>>,\n-    fallback_page: ResolvedVc<DevHtmlAsset>,\n-    render_data: ResolvedVc<JsonValue>,\n-    debug: bool,\n-) -> Vc<Box<dyn ContentSource>> {\n-    let source = NodeRenderContentSource {\n-        cwd,\n-        env,\n-        base_segments,\n-        route_type,\n-        server_root,\n-        route_match,\n-        pathname,\n-        entry,\n-        fallback_page,\n-        render_data,\n-        debug,\n-    }\n-    .resolved_cell();\n-    Vc::upcast(ConditionalContentSource::new(\n-        Vc::upcast(*source),\n-        Vc::upcast(\n-            LazyInstantiatedContentSource {\n-                get_source: ResolvedVc::upcast(source),\n-            }\n-            .cell(),\n-        ),\n-    ))\n-}\n-\n-/// see [create_node_rendered_source]\n-#[turbo_tasks::value]\n-pub struct NodeRenderContentSource {\n-    cwd: FileSystemPath,\n-    env: ResolvedVc<Box<dyn ProcessEnv>>,\n-    base_segments: Vec<BaseSegment>,\n-    route_type: RouteType,\n-    server_root: FileSystemPath,\n-    route_match: ResolvedVc<Box<dyn RouteMatcher>>,\n-    pathname: ResolvedVc<RcStr>,\n-    entry: ResolvedVc<Box<dyn NodeEntry>>,\n-    fallback_page: ResolvedVc<DevHtmlAsset>,\n-    render_data: ResolvedVc<JsonValue>,\n-    debug: bool,\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl NodeRenderContentSource {\n-    #[turbo_tasks::function]\n-    pub fn get_pathname(&self) -> Vc<RcStr> {\n-        *self.pathname\n-    }\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl GetContentSource for NodeRenderContentSource {\n-    /// Returns the [ContentSource] that serves all referenced external\n-    /// assets. This is wrapped into [LazyInstantiatedContentSource].\n-    #[turbo_tasks::function]\n-    async fn content_source(&self) -> Result<Vc<Box<dyn ContentSource>>> {\n-        let entries = self.entry.entries();\n-        let mut set = FxIndexSet::default();\n-        for &reference in self.fallback_page.references().await?.iter() {\n-            set.insert(reference);\n-        }\n-        for &entry in entries.await?.iter() {\n-            let entry = entry.await?;\n-            set.extend(\n-                external_asset_entrypoints(\n-                    *entry.module,\n-                    *entry.runtime_entries,\n-                    *entry.chunking_context,\n-                    entry.intermediate_output_path.clone(),\n-                )\n-                .await?\n-                .iter()\n-                .copied(),\n-            )\n-        }\n-        Ok(Vc::upcast(AssetGraphContentSource::new_lazy_multiple(\n-            self.server_root.clone(),\n-            Vc::cell(set),\n-        )))\n-    }\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl ContentSource for NodeRenderContentSource {\n-    #[turbo_tasks::function]\n-    async fn get_routes(self: Vc<Self>) -> Result<Vc<RouteTree>> {\n-        let this = self.await?;\n-        Ok(RouteTree::new_route(\n-            this.base_segments.clone(),\n-            this.route_type.clone(),\n-            Vc::upcast(self),\n-        ))\n-    }\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl GetContentSourceContent for NodeRenderContentSource {\n-    #[turbo_tasks::function]\n-    fn vary(&self) -> Vc<ContentSourceDataVary> {\n-        ContentSourceDataVary {\n-            method: true,\n-            url: true,\n-            original_url: true,\n-            raw_headers: true,\n-            raw_query: true,\n-            ..Default::default()\n-        }\n-        .cell()\n-    }\n-\n-    #[turbo_tasks::function]\n-    async fn get(&self, path: RcStr, data: ContentSourceData) -> Result<Vc<ContentSourceContent>> {\n-        let pathname = self.pathname.await?;\n-        let Some(params) = &*self.route_match.params(path.clone()).await? else {\n-            anyhow::bail!(\"Non matching path ({}) provided for {}\", path, pathname)\n-        };\n-        let ContentSourceData {\n-            method: Some(method),\n-            url: Some(url),\n-            original_url: Some(original_url),\n-            raw_headers: Some(raw_headers),\n-            raw_query: Some(raw_query),\n-            ..\n-        } = &data\n-        else {\n-            anyhow::bail!(\"Missing request data\")\n-        };\n-        let entry = (*self.entry).entry(data.clone()).await?;\n-        let result_op = render_static_operation(\n-            self.cwd.clone(),\n-            self.env,\n-            self.server_root.join(&path)?,\n-            ResolvedVc::upcast(entry.module),\n-            entry.runtime_entries,\n-            self.fallback_page,\n-            entry.chunking_context,\n-            entry.intermediate_output_path.clone(),\n-            entry.output_root.clone(),\n-            entry.project_dir.clone(),\n-            RenderData {\n-                params: params.clone(),\n-                method: method.clone(),\n-                url: url.clone(),\n-                original_url: original_url.clone(),\n-                raw_query: raw_query.clone(),\n-                raw_headers: raw_headers.clone(),\n-                path: pathname.as_str().into(),\n-                data: Some(self.render_data.await?),\n-            }\n-            .resolved_cell(),\n-            self.debug,\n-        )\n-        .issue_file_path(\n-            entry.module.ident().path().owned().await?,\n-            format!(\"server-side rendering {pathname}\"),\n-        )\n-        .await?;\n-        Ok(match *result_op.connect().await? {\n-            StaticResult::Content {\n-                content,\n-                status_code,\n-                headers,\n-            } => ContentSourceContent::static_with_headers(\n-                content.versioned(),\n-                status_code,\n-                *headers,\n-            ),\n-            StaticResult::StreamedContent {\n-                status,\n-                headers,\n-                ref body,\n-            } => {\n-                ContentSourceContent::HttpProxy(static_streamed_content_to_proxy_result_operation(\n-                    result_op,\n-                    ProxyResult {\n-                        status,\n-                        headers: headers.owned().await?,\n-                        body: body.clone(),\n-                    }\n-                    .resolved_cell(),\n-                ))\n-                .cell()\n-            }\n-            StaticResult::Rewrite(rewrite) => ContentSourceContent::Rewrite(rewrite).cell(),\n-        })\n-    }\n-}\n-\n-#[turbo_tasks::function(operation)]\n-async fn static_streamed_content_to_proxy_result_operation(\n-    result_op: OperationVc<StaticResult>,\n-    proxy_result: ResolvedVc<ProxyResult>,\n-) -> Result<Vc<ProxyResult>> {\n-    // we already assume `result_op`'s value here because we're called inside of a match arm, but\n-    // await `result_op` anyways, so that if it generates any collectible issues, they're captured\n-    // here.\n-    let _ = result_op.connect().await?;\n-    Ok(*proxy_result)\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl Introspectable for NodeRenderContentSource {\n-    #[turbo_tasks::function]\n-    fn ty(&self) -> Vc<RcStr> {\n-        Vc::cell(rcstr!(\"node render content source\"))\n-    }\n-\n-    #[turbo_tasks::function]\n-    fn title(&self) -> Vc<RcStr> {\n-        *self.pathname\n-    }\n-\n-    #[turbo_tasks::function]\n-    fn details(&self) -> Vc<RcStr> {\n-        Vc::cell(\n-            format!(\n-                \"base: {:?}\\ntype: {:?}\",\n-                self.base_segments, self.route_type\n-            )\n-            .into(),\n-        )\n-    }\n-\n-    #[turbo_tasks::function]\n-    async fn children(&self) -> Result<Vc<IntrospectableChildren>> {\n-        let mut set = FxIndexSet::default();\n-        for &entry in self.entry.entries().await?.iter() {\n-            let entry = entry.await?;\n-            set.insert((\n-                rcstr!(\"module\"),\n-                IntrospectableModule::new(Vc::upcast(*entry.module))\n-                    .to_resolved()\n-                    .await?,\n-            ));\n-            set.insert((\n-                rcstr!(\"intermediate asset\"),\n-                IntrospectableOutputAsset::new(get_intermediate_asset(\n-                    *entry.chunking_context,\n-                    *entry.module,\n-                    *entry.runtime_entries,\n-                ))\n-                .to_resolved()\n-                .await?,\n-            ));\n-        }\n-        Ok(Vc::cell(set))\n-    }\n-}"
        }
    ],
    "stats": {
        "total": 1822,
        "additions": 118,
        "deletions": 1704
    }
}