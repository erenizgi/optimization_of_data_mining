{
    "author": "acdlite",
    "message": "Delete old prefetch cache related code (#84977)\n\nDeletes code that's no longer reachable now that Client Segment Cache is\nalways enabled",
    "sha": "56db4345f2eca501712d1963b78521a68a73803e",
    "files": [
        {
            "sha": "a5ac75c3381b7143f508de734190d6ffc61d7284",
            "filename": "packages/next/src/client/app-index.tsx",
            "status": "modified",
            "additions": 0,
            "deletions": 3,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/56db4345f2eca501712d1963b78521a68a73803e/packages%2Fnext%2Fsrc%2Fclient%2Fapp-index.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/56db4345f2eca501712d1963b78521a68a73803e/packages%2Fnext%2Fsrc%2Fclient%2Fapp-index.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fapp-index.tsx?ref=56db4345f2eca501712d1963b78521a68a73803e",
            "patch": "@@ -286,9 +286,6 @@ export function hydrate(\n                 initialCanonicalUrlParts: initialRSCPayload.c,\n                 initialParallelRoutes: new Map(),\n                 location: window.location,\n-                couldBeIntercepted: initialRSCPayload.i,\n-                postponed: initialRSCPayload.s,\n-                prerendered: initialRSCPayload.S,\n               }),\n               instrumentationHooks\n             )"
        },
        {
            "sha": "a26bb04f3ea30303807a1af46f9314f8b2718ec3",
            "filename": "packages/next/src/client/components/app-router-instance.ts",
            "status": "modified",
            "additions": 42,
            "deletions": 63,
            "changes": 105,
            "blob_url": "https://github.com/vercel/next.js/blob/56db4345f2eca501712d1963b78521a68a73803e/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fapp-router-instance.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/56db4345f2eca501712d1963b78521a68a73803e/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fapp-router-instance.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fapp-router-instance.ts?ref=56db4345f2eca501712d1963b78521a68a73803e",
            "patch": "@@ -9,7 +9,6 @@ import {\n   type NavigateAction,\n   ACTION_HMR_REFRESH,\n   PrefetchKind,\n-  ACTION_PREFETCH,\n } from './router-reducer/router-reducer-types'\n import { reducer } from './router-reducer/router-reducer'\n import { startTransition } from 'react'\n@@ -21,8 +20,7 @@ import {\n } from './segment-cache'\n import { dispatchAppRouterAction } from './use-action-queue'\n import { addBasePath } from '../add-base-path'\n-import { createPrefetchURL, isExternalURL } from './app-router-utils'\n-import { prefetchReducer } from './router-reducer/reducers/prefetch-reducer'\n+import { isExternalURL } from './app-router-utils'\n import type {\n   AppRouterInstance,\n   NavigateOptions,\n@@ -302,7 +300,6 @@ export function dispatchNavigateAction(\n     locationSearch: location.search,\n     shouldScroll,\n     navigateType,\n-    allowAliasing: true,\n   })\n }\n \n@@ -329,67 +326,49 @@ export function dispatchTraverseAction(\n export const publicAppRouterInstance: AppRouterInstance = {\n   back: () => window.history.back(),\n   forward: () => window.history.forward(),\n-  prefetch: process.env.__NEXT_CLIENT_SEGMENT_CACHE\n-    ? // Unlike the old implementation, the Segment Cache doesn't store its\n-      // data in the router reducer state; it writes into a global mutable\n-      // cache. So we don't need to dispatch an action.\n-      (href: string, options?: PrefetchOptions) => {\n-        const actionQueue = getAppRouterActionQueue()\n-        const prefetchKind = options?.kind ?? PrefetchKind.AUTO\n-\n-        // We don't currently offer a way to issue a runtime prefetch via `router.prefetch()`.\n-        // This will be possible when we update its API to not take a PrefetchKind.\n-        let fetchStrategy: PrefetchTaskFetchStrategy\n-        switch (prefetchKind) {\n-          case PrefetchKind.AUTO: {\n-            // We default to PPR. We'll discover whether or not the route supports it with the initial prefetch.\n-            fetchStrategy = FetchStrategy.PPR\n-            break\n-          }\n-          case PrefetchKind.FULL: {\n-            fetchStrategy = FetchStrategy.Full\n-            break\n-          }\n-          case PrefetchKind.TEMPORARY: {\n-            // This concept doesn't exist in the segment cache implementation.\n-            return\n-          }\n-          default: {\n-            prefetchKind satisfies never\n-            // Despite typescript thinking that this can't happen,\n-            // we might get an unexpected value from user code.\n-            // We don't know what they want, but we know they want a prefetch,\n-            // so use the default.\n-            fetchStrategy = FetchStrategy.PPR\n-          }\n+  prefetch:\n+    // Unlike the old implementation, the Segment Cache doesn't store its\n+    // data in the router reducer state; it writes into a global mutable\n+    // cache. So we don't need to dispatch an action.\n+    (href: string, options?: PrefetchOptions) => {\n+      const actionQueue = getAppRouterActionQueue()\n+      const prefetchKind = options?.kind ?? PrefetchKind.AUTO\n+\n+      // We don't currently offer a way to issue a runtime prefetch via `router.prefetch()`.\n+      // This will be possible when we update its API to not take a PrefetchKind.\n+      let fetchStrategy: PrefetchTaskFetchStrategy\n+      switch (prefetchKind) {\n+        case PrefetchKind.AUTO: {\n+          // We default to PPR. We'll discover whether or not the route supports it with the initial prefetch.\n+          fetchStrategy = FetchStrategy.PPR\n+          break\n         }\n-\n-        prefetchWithSegmentCache(\n-          href,\n-          actionQueue.state.nextUrl,\n-          actionQueue.state.tree,\n-          fetchStrategy,\n-          options?.onInvalidate ?? null\n-        )\n-      }\n-    : (href: string, options?: PrefetchOptions) => {\n-        // Use the old prefetch implementation.\n-        const actionQueue = getAppRouterActionQueue()\n-        const url = createPrefetchURL(href)\n-        if (url !== null) {\n-          // The prefetch reducer doesn't actually update any state or\n-          // trigger a rerender. It just writes to a mutable cache. So we\n-          // shouldn't bother calling setState/dispatch; we can just re-run\n-          // the reducer directly using the current state.\n-          // TODO: Refactor this away from a \"reducer\" so it's\n-          // less confusing.\n-          prefetchReducer(actionQueue.state, {\n-            type: ACTION_PREFETCH,\n-            url,\n-            kind: options?.kind ?? PrefetchKind.FULL,\n-          })\n+        case PrefetchKind.FULL: {\n+          fetchStrategy = FetchStrategy.Full\n+          break\n+        }\n+        case PrefetchKind.TEMPORARY: {\n+          // This concept doesn't exist in the segment cache implementation.\n+          return\n+        }\n+        default: {\n+          prefetchKind satisfies never\n+          // Despite typescript thinking that this can't happen,\n+          // we might get an unexpected value from user code.\n+          // We don't know what they want, but we know they want a prefetch,\n+          // so use the default.\n+          fetchStrategy = FetchStrategy.PPR\n         }\n-      },\n+      }\n+\n+      prefetchWithSegmentCache(\n+        href,\n+        actionQueue.state.nextUrl,\n+        actionQueue.state.tree,\n+        fetchStrategy,\n+        options?.onInvalidate ?? null\n+      )\n+    },\n   replace: (href: string, options?: NavigateOptions) => {\n     startTransition(() => {\n       dispatchNavigateAction(href, 'replace', options?.scroll ?? true, null)"
        },
        {
            "sha": "605d9d7c3019225234f2cd654396f63871113877",
            "filename": "packages/next/src/client/components/app-router.tsx",
            "status": "modified",
            "additions": 2,
            "deletions": 3,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/56db4345f2eca501712d1963b78521a68a73803e/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fapp-router.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/56db4345f2eca501712d1963b78521a68a73803e/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fapp-router.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fapp-router.tsx?ref=56db4345f2eca501712d1963b78521a68a73803e",
            "patch": "@@ -180,7 +180,7 @@ function Router({\n   }, [canonicalUrl])\n \n   if (process.env.NODE_ENV !== 'production') {\n-    const { cache, prefetchCache, tree } = state\n+    const { cache, tree } = state\n \n     // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n     // eslint-disable-next-line react-hooks/rules-of-hooks\n@@ -191,10 +191,9 @@ function Router({\n       window.nd = {\n         router: publicAppRouterInstance,\n         cache,\n-        prefetchCache,\n         tree,\n       }\n-    }, [cache, prefetchCache, tree])\n+    }, [cache, tree])\n   }\n \n   useEffect(() => {"
        },
        {
            "sha": "310279cdb4dcac8d28c08b28f1848c15369bb479",
            "filename": "packages/next/src/client/components/router-reducer/apply-flight-data.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 12,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/56db4345f2eca501712d1963b78521a68a73803e/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fapply-flight-data.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/56db4345f2eca501712d1963b78521a68a73803e/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fapply-flight-data.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fapply-flight-data.ts?ref=56db4345f2eca501712d1963b78521a68a73803e",
            "patch": "@@ -1,15 +1,13 @@\n import type { CacheNode } from '../../../shared/lib/app-router-types'\n import { fillLazyItemsTillLeafWithHead } from './fill-lazy-items-till-leaf-with-head'\n import { fillCacheWithNewSubTreeData } from './fill-cache-with-new-subtree-data'\n-import type { PrefetchCacheEntry } from './router-reducer-types'\n import type { NormalizedFlightData } from '../../flight-data-helpers'\n \n export function applyFlightData(\n   navigatedAt: number,\n   existingCache: CacheNode,\n   cache: CacheNode,\n-  flightData: NormalizedFlightData,\n-  prefetchEntry?: PrefetchCacheEntry\n+  flightData: NormalizedFlightData\n ): boolean {\n   // The one before last item is the router state tree patch\n   const { tree: treePatch, seedData, head, isRootRender } = flightData\n@@ -36,8 +34,7 @@ export function applyFlightData(\n       existingCache,\n       treePatch,\n       seedData,\n-      head,\n-      prefetchEntry\n+      head\n     )\n   } else {\n     // Copy rsc for the root node of the cache.\n@@ -49,13 +46,7 @@ export function applyFlightData(\n     cache.parallelRoutes = new Map(existingCache.parallelRoutes)\n     cache.loading = existingCache.loading\n     // Create a copy of the existing cache with the rsc applied.\n-    fillCacheWithNewSubTreeData(\n-      navigatedAt,\n-      cache,\n-      existingCache,\n-      flightData,\n-      prefetchEntry\n-    )\n+    fillCacheWithNewSubTreeData(navigatedAt, cache, existingCache, flightData)\n   }\n \n   return true"
        },
        {
            "sha": "05c5fb292eece4e691c15e4c01895eaf873d59fd",
            "filename": "packages/next/src/client/components/router-reducer/create-initial-router-state.test.tsx",
            "status": "modified",
            "additions": 0,
            "deletions": 23,
            "changes": 23,
            "blob_url": "https://github.com/vercel/next.js/blob/56db4345f2eca501712d1963b78521a68a73803e/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fcreate-initial-router-state.test.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/56db4345f2eca501712d1963b78521a68a73803e/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fcreate-initial-router-state.test.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fcreate-initial-router-state.test.tsx?ref=56db4345f2eca501712d1963b78521a68a73803e",
            "patch": "@@ -4,7 +4,6 @@ import type {\n   CacheNode,\n } from '../../../shared/lib/app-router-types'\n import { createInitialRouterState } from './create-initial-router-state'\n-import { PrefetchCacheEntryStatus, PrefetchKind } from './router-reducer-types'\n \n const getInitialRouterStateTree = (): FlightRouterState => [\n   '',\n@@ -41,9 +40,6 @@ describe('createInitialRouterState', () => {\n       initialCanonicalUrlParts: initialCanonicalUrl.split('/'),\n       initialParallelRoutes,\n       location: new URL('/linking', 'https://localhost') as any,\n-      couldBeIntercepted: false,\n-      postponed: false,\n-      prerendered: false,\n     })\n \n     const state2 = createInitialRouterState({\n@@ -52,9 +48,6 @@ describe('createInitialRouterState', () => {\n       initialCanonicalUrlParts: initialCanonicalUrl.split('/'),\n       initialParallelRoutes,\n       location: new URL('/linking', 'https://localhost') as any,\n-      couldBeIntercepted: false,\n-      postponed: false,\n-      prerendered: false,\n     })\n \n     const expectedCache: CacheNode = {\n@@ -109,22 +102,6 @@ describe('createInitialRouterState', () => {\n     const expected: ReturnType<typeof createInitialRouterState> = {\n       tree: initialTree,\n       canonicalUrl: initialCanonicalUrl,\n-      prefetchCache: new Map([\n-        [\n-          '/linking',\n-          {\n-            key: '/linking',\n-            data: expect.any(Promise),\n-            prefetchTime: expect.any(Number),\n-            kind: PrefetchKind.AUTO,\n-            lastUsedTime: expect.any(Number),\n-            treeAtTimeOfPrefetch: initialTree,\n-            status: PrefetchCacheEntryStatus.fresh,\n-            url: new URL('/linking', 'https://localhost'),\n-            staleTime: -1,\n-          },\n-        ],\n-      ]),\n       pushRef: {\n         pendingPush: false,\n         mpaNavigation: false,"
        },
        {
            "sha": "40a3075ee083b58283752bc7c66640b607d097d2",
            "filename": "packages/next/src/client/components/router-reducer/create-initial-router-state.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 58,
            "changes": 59,
            "blob_url": "https://github.com/vercel/next.js/blob/56db4345f2eca501712d1963b78521a68a73803e/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fcreate-initial-router-state.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/56db4345f2eca501712d1963b78521a68a73803e/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fcreate-initial-router-state.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fcreate-initial-router-state.ts?ref=56db4345f2eca501712d1963b78521a68a73803e",
            "patch": "@@ -6,11 +6,6 @@ import type {\n import { createHrefFromUrl } from './create-href-from-url'\n import { fillLazyItemsTillLeafWithHead } from './fill-lazy-items-till-leaf-with-head'\n import { extractPathFromFlightRouterState } from './compute-changed-path'\n-import {\n-  createSeededPrefetchCacheEntry,\n-  STATIC_STALETIME_MS,\n-} from './prefetch-cache-utils'\n-import { PrefetchKind, type PrefetchCacheEntry } from './router-reducer-types'\n import { addRefreshMarkerToActiveParallelSegments } from './refetch-inactive-parallel-segments'\n import { getFlightDataPartsFromPath } from '../../flight-data-helpers'\n \n@@ -20,9 +15,6 @@ export interface InitialRouterStateParameters {\n   initialParallelRoutes: CacheNode['parallelRoutes']\n   initialFlightData: FlightDataPath[]\n   location: Location | null\n-  couldBeIntercepted: boolean\n-  postponed: boolean\n-  prerendered: boolean\n }\n \n export function createInitialRouterState({\n@@ -31,9 +23,6 @@ export function createInitialRouterState({\n   initialCanonicalUrlParts,\n   initialParallelRoutes,\n   location,\n-  couldBeIntercepted,\n-  postponed,\n-  prerendered,\n }: InitialRouterStateParameters) {\n   // When initialized on the server, the canonical URL is provided as an array of parts.\n   // This is to ensure that when the RSC payload streamed to the client, crawlers don't interpret it\n@@ -73,8 +62,6 @@ export function createInitialRouterState({\n \n   addRefreshMarkerToActiveParallelSegments(initialTree, canonicalUrl)\n \n-  const prefetchCache = new Map<string, PrefetchCacheEntry>()\n-\n   // When the cache hasn't been seeded yet we fill the cache with the head.\n   if (initialParallelRoutes === null || initialParallelRoutes.size === 0) {\n     fillLazyItemsTillLeafWithHead(\n@@ -83,15 +70,13 @@ export function createInitialRouterState({\n       undefined,\n       initialTree,\n       initialSeedData,\n-      initialHead,\n-      undefined\n+      initialHead\n     )\n   }\n \n   const initialState = {\n     tree: initialTree,\n     cache,\n-    prefetchCache,\n     pushRef: {\n       pendingPush: false,\n       mpaNavigation: false,\n@@ -114,47 +99,5 @@ export function createInitialRouterState({\n     debugInfo: null,\n   }\n \n-  if (process.env.NODE_ENV !== 'development' && location) {\n-    // Seed the prefetch cache with this page's data.\n-    // This is to prevent needlessly re-prefetching a page that is already reusable,\n-    // and will avoid triggering a loading state/data fetch stall when navigating back to the page.\n-    // We don't currently do this in development because links aren't prefetched in development\n-    // so having a mismatch between prefetch/no prefetch provides inconsistent behavior based on which page\n-    // was loaded first.\n-    const url = new URL(\n-      `${location.pathname}${location.search}`,\n-      location.origin\n-    )\n-\n-    createSeededPrefetchCacheEntry({\n-      url,\n-      data: {\n-        flightData: [normalizedFlightData],\n-        canonicalUrl: undefined,\n-        couldBeIntercepted: !!couldBeIntercepted,\n-        prerendered,\n-        postponed,\n-        // TODO: The initial RSC payload includes both static and dynamic data\n-        // in the same response, even if PPR is enabled. So if there's any\n-        // dynamic data at all, we can't set a stale time. In the future we may\n-        // add a way to split a single Flight stream into static and dynamic\n-        // parts. But in the meantime we should at least make this work for\n-        // fully static pages.\n-        staleTime:\n-          // In the old router, there was only a single configurable staleTime (experimental.staleTimes)\n-          // As an abundance of caution, this will only set the initial staleTime to the configured value\n-          // if we're not leveraging the segment cache, which has its own prefetching semantics.\n-          prerendered && !process.env.__NEXT_CLIENT_SEGMENT_CACHE\n-            ? STATIC_STALETIME_MS\n-            : -1,\n-        debugInfo: null,\n-      },\n-      tree: initialState.tree,\n-      prefetchCache: initialState.prefetchCache,\n-      nextUrl: initialState.nextUrl,\n-      kind: prerendered ? PrefetchKind.FULL : PrefetchKind.AUTO,\n-    })\n-  }\n-\n   return initialState\n }"
        },
        {
            "sha": "00994e7f4e2e717e5a54d893f261b6f01c5cc07d",
            "filename": "packages/next/src/client/components/router-reducer/fill-cache-with-new-subtree-data.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 24,
            "changes": 29,
            "blob_url": "https://github.com/vercel/next.js/blob/56db4345f2eca501712d1963b78521a68a73803e/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Ffill-cache-with-new-subtree-data.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/56db4345f2eca501712d1963b78521a68a73803e/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Ffill-cache-with-new-subtree-data.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Ffill-cache-with-new-subtree-data.ts?ref=56db4345f2eca501712d1963b78521a68a73803e",
            "patch": "@@ -2,7 +2,6 @@ import type { CacheNode, Segment } from '../../../shared/lib/app-router-types'\n import { invalidateCacheByRouterState } from './invalidate-cache-by-router-state'\n import { fillLazyItemsTillLeafWithHead } from './fill-lazy-items-till-leaf-with-head'\n import { createRouterCacheKey } from './create-router-cache-key'\n-import type { PrefetchCacheEntry } from './router-reducer-types'\n import { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\n import type { NormalizedFlightData } from '../../flight-data-helpers'\n \n@@ -14,7 +13,6 @@ function fillCacheHelper(\n   newCache: CacheNode,\n   existingCache: CacheNode,\n   flightData: NormalizedFlightData,\n-  prefetchEntry: PrefetchCacheEntry | undefined,\n   fillLazyItems: boolean\n ): void {\n   const {\n@@ -95,8 +93,7 @@ function fillCacheHelper(\n             existingChildCacheNode,\n             treePatch,\n             cacheNodeSeedData,\n-            head,\n-            prefetchEntry\n+            head\n           )\n         }\n \n@@ -137,32 +134,16 @@ export function fillCacheWithNewSubTreeData(\n   navigatedAt: number,\n   newCache: CacheNode,\n   existingCache: CacheNode,\n-  flightData: NormalizedFlightData,\n-  prefetchEntry?: PrefetchCacheEntry\n+  flightData: NormalizedFlightData\n ): void {\n-  fillCacheHelper(\n-    navigatedAt,\n-    newCache,\n-    existingCache,\n-    flightData,\n-    prefetchEntry,\n-    true\n-  )\n+  fillCacheHelper(navigatedAt, newCache, existingCache, flightData, true)\n }\n \n export function fillCacheWithNewSubTreeDataButOnlyLoading(\n   navigatedAt: number,\n   newCache: CacheNode,\n   existingCache: CacheNode,\n-  flightData: NormalizedFlightData,\n-  prefetchEntry?: PrefetchCacheEntry\n+  flightData: NormalizedFlightData\n ): void {\n-  fillCacheHelper(\n-    navigatedAt,\n-    newCache,\n-    existingCache,\n-    flightData,\n-    prefetchEntry,\n-    false\n-  )\n+  fillCacheHelper(navigatedAt, newCache, existingCache, flightData, false)\n }"
        },
        {
            "sha": "5c50be79549294e0b30fcc614a67d75b7b56e99f",
            "filename": "packages/next/src/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.test.tsx",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/56db4345f2eca501712d1963b78521a68a73803e/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Ffill-lazy-items-till-leaf-with-head.test.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/56db4345f2eca501712d1963b78521a68a73803e/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Ffill-lazy-items-till-leaf-with-head.test.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Ffill-lazy-items-till-leaf-with-head.test.tsx?ref=56db4345f2eca501712d1963b78521a68a73803e",
            "patch": "@@ -115,8 +115,7 @@ describe('fillLazyItemsTillLeafWithHead', () => {\n       existingCache,\n       treePatch,\n       cacheNodeSeedData,\n-      head,\n-      undefined\n+      head\n     )\n \n     const expectedCache: CacheNode = {"
        },
        {
            "sha": "e49951d136c47a7a7dcda5a38c3822a9921b6d36",
            "filename": "packages/next/src/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 29,
            "changes": 32,
            "blob_url": "https://github.com/vercel/next.js/blob/56db4345f2eca501712d1963b78521a68a73803e/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Ffill-lazy-items-till-leaf-with-head.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/56db4345f2eca501712d1963b78521a68a73803e/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Ffill-lazy-items-till-leaf-with-head.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Ffill-lazy-items-till-leaf-with-head.ts?ref=56db4345f2eca501712d1963b78521a68a73803e",
            "patch": "@@ -4,19 +4,14 @@ import type {\n   CacheNodeSeedData,\n } from '../../../shared/lib/app-router-types'\n import { createRouterCacheKey } from './create-router-cache-key'\n-import {\n-  PrefetchCacheEntryStatus,\n-  type PrefetchCacheEntry,\n-} from './router-reducer-types'\n \n export function fillLazyItemsTillLeafWithHead(\n   navigatedAt: number,\n   newCache: CacheNode,\n   existingCache: CacheNode | undefined,\n   routerState: FlightRouterState,\n   cacheNodeSeedData: CacheNodeSeedData | null,\n-  head: React.ReactNode,\n-  prefetchEntry: PrefetchCacheEntry | undefined\n+  head: React.ReactNode\n ): void {\n   const isLastSegment = Object.keys(routerState[1]).length === 0\n   if (isLastSegment) {\n@@ -47,10 +42,6 @@ export function fillLazyItemsTillLeafWithHead(\n       const existingParallelRoutesCacheNode =\n         existingCache.parallelRoutes.get(key)\n       if (existingParallelRoutesCacheNode) {\n-        const hasReusablePrefetch =\n-          prefetchEntry?.kind === 'auto' &&\n-          prefetchEntry.status === PrefetchCacheEntryStatus.reusable\n-\n         let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode)\n         const existingCacheNode = parallelRouteCacheNode.get(cacheKey)\n         let newCacheNode: CacheNode\n@@ -73,21 +64,6 @@ export function fillLazyItemsTillLeafWithHead(\n             parallelRoutes: new Map(existingCacheNode?.parallelRoutes),\n             navigatedAt,\n           }\n-        } else if (hasReusablePrefetch && existingCacheNode) {\n-          // No new data was sent from the server, but the existing cache node\n-          // was prefetched, so we should reuse that.\n-          newCacheNode = {\n-            lazyData: existingCacheNode.lazyData,\n-            rsc: existingCacheNode.rsc,\n-            // This is a PPR-only field. Unlike the previous branch, since we're\n-            // just cloning the existing cache node, we might as well keep the\n-            // PPR value, if it exists.\n-            prefetchRsc: existingCacheNode.prefetchRsc,\n-            head: existingCacheNode.head,\n-            prefetchHead: existingCacheNode.prefetchHead,\n-            parallelRoutes: new Map(existingCacheNode.parallelRoutes),\n-            loading: existingCacheNode.loading,\n-          } as CacheNode\n         } else {\n           // No data available for this node. This will trigger a lazy fetch\n           // during render.\n@@ -112,8 +88,7 @@ export function fillLazyItemsTillLeafWithHead(\n           existingCacheNode,\n           parallelRouteState,\n           parallelSeedData ? parallelSeedData : null,\n-          head,\n-          prefetchEntry\n+          head\n         )\n \n         newCache.parallelRoutes.set(key, parallelRouteCacheNode)\n@@ -164,8 +139,7 @@ export function fillLazyItemsTillLeafWithHead(\n       undefined,\n       parallelRouteState,\n       parallelSeedData,\n-      head,\n-      prefetchEntry\n+      head\n     )\n   }\n }"
        },
        {
            "sha": "071dc292f25fae8c97e368ea9a67bd9f3fb1d4e9",
            "filename": "packages/next/src/client/components/router-reducer/handle-mutable.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 3,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/56db4345f2eca501712d1963b78521a68a73803e/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fhandle-mutable.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/56db4345f2eca501712d1963b78521a68a73803e/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fhandle-mutable.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fhandle-mutable.ts?ref=56db4345f2eca501712d1963b78521a68a73803e",
            "patch": "@@ -78,9 +78,6 @@ export function handleMutable(\n     },\n     // Apply cache.\n     cache: mutable.cache ? mutable.cache : state.cache,\n-    prefetchCache: mutable.prefetchCache\n-      ? mutable.prefetchCache\n-      : state.prefetchCache,\n     // Apply patched router state.\n     tree: isNotUndefined(mutable.patchedTree)\n       ? mutable.patchedTree"
        },
        {
            "sha": "1155ebbaccaecc753ee5ca26d67a289b3ae85f2d",
            "filename": "packages/next/src/client/components/router-reducer/ppr-navigations.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/56db4345f2eca501712d1963b78521a68a73803e/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fppr-navigations.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/56db4345f2eca501712d1963b78521a68a73803e/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fppr-navigations.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fppr-navigations.ts?ref=56db4345f2eca501712d1963b78521a68a73803e",
            "patch": "@@ -19,7 +19,7 @@ import { createHrefFromUrl } from './create-href-from-url'\n import { createRouterCacheKey } from './create-router-cache-key'\n import type { FetchServerResponseResult } from './fetch-server-response'\n import { isNavigatingToNewRootLayout } from './is-navigating-to-new-root-layout'\n-import { DYNAMIC_STALETIME_MS } from './prefetch-cache-utils'\n+import { DYNAMIC_STALETIME_MS } from './reducers/navigate-reducer'\n \n // This is yet another tree type that is used to track pending promises that\n // need to be fulfilled once the dynamic data is received. The terminal nodes of"
        },
        {
            "sha": "ad58763260cb0e89ed86750bd88661070e12f423",
            "filename": "packages/next/src/client/components/router-reducer/prefetch-cache-utils.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 432,
            "changes": 432,
            "blob_url": "https://github.com/vercel/next.js/blob/bdc3d07ce85c84a2fff5d9540ac8e39a541d07f3/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fprefetch-cache-utils.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/bdc3d07ce85c84a2fff5d9540ac8e39a541d07f3/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fprefetch-cache-utils.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fprefetch-cache-utils.ts?ref=bdc3d07ce85c84a2fff5d9540ac8e39a541d07f3",
            "patch": "@@ -1,432 +0,0 @@\n-import {\n-  fetchServerResponse,\n-  type FetchServerResponseResult,\n-} from './fetch-server-response'\n-import {\n-  PrefetchCacheEntryStatus,\n-  type PrefetchCacheEntry,\n-  PrefetchKind,\n-  type ReadonlyReducerState,\n-} from './router-reducer-types'\n-import { prefetchQueue } from './reducers/prefetch-reducer'\n-\n-const INTERCEPTION_CACHE_KEY_MARKER = '%'\n-\n-export type AliasedPrefetchCacheEntry = PrefetchCacheEntry & {\n-  /** This is a special property that indicates a prefetch entry associated with a different URL\n-   * was returned rather than the requested URL. This signals to the router that it should only\n-   * apply the part that doesn't depend on searchParams (specifically the loading state).\n-   */\n-  aliased?: boolean\n-}\n-\n-/**\n- * Creates a cache key for the router prefetch cache\n- *\n- * @param url - The URL being navigated to\n- * @param nextUrl - an internal URL, primarily used for handling rewrites. Defaults to '/'.\n- * @return The generated prefetch cache key.\n- */\n-function createPrefetchCacheKeyImpl(\n-  url: URL,\n-  includeSearchParams: boolean,\n-  prefix?: string | null\n-) {\n-  // Initially we only use the pathname as the cache key. We don't want to include\n-  // search params so that multiple URLs with the same search parameter can re-use\n-  // loading states.\n-  let pathnameFromUrl = url.pathname\n-\n-  // RSC responses can differ based on search params, specifically in the case where we aren't\n-  // returning a partial response (ie with `PrefetchKind.AUTO`).\n-  // In the auto case, since loading.js & layout.js won't have access to search params,\n-  // we can safely re-use that cache entry. But for full prefetches, we should not\n-  // re-use the cache entry as the response may differ.\n-  if (includeSearchParams) {\n-    // if we have a full prefetch, we can include the search param in the key,\n-    // as we'll be getting back a full response. The server might have read the search\n-    // params when generating the full response.\n-    pathnameFromUrl += url.search\n-  }\n-\n-  if (prefix) {\n-    return `${prefix}${INTERCEPTION_CACHE_KEY_MARKER}${pathnameFromUrl}`\n-  }\n-\n-  return pathnameFromUrl\n-}\n-\n-function createPrefetchCacheKey(\n-  url: URL,\n-  kind: PrefetchKind | undefined,\n-  nextUrl?: string | null\n-) {\n-  return createPrefetchCacheKeyImpl(url, kind === PrefetchKind.FULL, nextUrl)\n-}\n-\n-function getExistingCacheEntry(\n-  url: URL,\n-  kind: PrefetchKind = PrefetchKind.TEMPORARY,\n-  nextUrl: string | null,\n-  prefetchCache: Map<string, PrefetchCacheEntry>,\n-  allowAliasing: boolean\n-): AliasedPrefetchCacheEntry | undefined {\n-  // We first check if there's a more specific interception route prefetch entry\n-  // This is because when we detect a prefetch that corresponds with an interception route, we prefix it with nextUrl (see `createPrefetchCacheKey`)\n-  // to avoid conflicts with other pages that may have the same URL but render different things depending on the `Next-URL` header.\n-  for (const maybeNextUrl of [nextUrl, null]) {\n-    const cacheKeyWithParams = createPrefetchCacheKeyImpl(\n-      url,\n-      true,\n-      maybeNextUrl\n-    )\n-    const cacheKeyWithoutParams = createPrefetchCacheKeyImpl(\n-      url,\n-      false,\n-      maybeNextUrl\n-    )\n-\n-    // First, we check if we have a cache entry that exactly matches the URL\n-    const cacheKeyToUse = url.search\n-      ? cacheKeyWithParams\n-      : cacheKeyWithoutParams\n-\n-    const existingEntry = prefetchCache.get(cacheKeyToUse)\n-    if (existingEntry && allowAliasing) {\n-      // We know we're returning an aliased entry when the pathname matches but the search params don't,\n-      const isAliased =\n-        existingEntry.url.pathname === url.pathname &&\n-        existingEntry.url.search !== url.search\n-\n-      if (isAliased) {\n-        return {\n-          ...existingEntry,\n-          aliased: true,\n-        }\n-      }\n-\n-      return existingEntry\n-    }\n-\n-    // If the request contains search params, and we're not doing a full prefetch, we can return the\n-    // param-less entry if it exists.\n-    // This is technically covered by the check at the bottom of this function, which iterates over cache entries,\n-    // but lets us arrive there quicker in the param-full case.\n-    const entryWithoutParams = prefetchCache.get(cacheKeyWithoutParams)\n-    if (\n-      process.env.NODE_ENV !== 'development' &&\n-      allowAliasing &&\n-      url.search &&\n-      kind !== PrefetchKind.FULL &&\n-      entryWithoutParams &&\n-      // We shouldn't return the aliased entry if it was relocated to a new cache key.\n-      // Since it's rewritten, it could respond with a completely different loading state.\n-      !entryWithoutParams.key.includes(INTERCEPTION_CACHE_KEY_MARKER)\n-    ) {\n-      return { ...entryWithoutParams, aliased: true }\n-    }\n-  }\n-\n-  // If we've gotten to this point, we didn't find a specific cache entry that matched\n-  // the request URL.\n-  // We attempt a partial match by checking if there's a cache entry with the same pathname.\n-  // Regardless of what we find, since it doesn't correspond with the requested URL, we'll mark it \"aliased\".\n-  // This will signal to the router that it should only apply the loading state on the prefetched data.\n-  if (\n-    process.env.NODE_ENV !== 'development' &&\n-    kind !== PrefetchKind.FULL &&\n-    allowAliasing\n-  ) {\n-    for (const cacheEntry of prefetchCache.values()) {\n-      if (\n-        cacheEntry.url.pathname === url.pathname &&\n-        // We shouldn't return the aliased entry if it was relocated to a new cache key.\n-        // Since it's rewritten, it could respond with a completely different loading state.\n-        !cacheEntry.key.includes(INTERCEPTION_CACHE_KEY_MARKER)\n-      ) {\n-        return { ...cacheEntry, aliased: true }\n-      }\n-    }\n-  }\n-\n-  return undefined\n-}\n-\n-/**\n- * Returns a prefetch cache entry if one exists. Otherwise creates a new one and enqueues a fetch request\n- * to retrieve the prefetch data from the server.\n- */\n-export function getOrCreatePrefetchCacheEntry({\n-  url,\n-  nextUrl,\n-  tree,\n-  prefetchCache,\n-  kind,\n-  allowAliasing = true,\n-}: Pick<ReadonlyReducerState, 'nextUrl' | 'prefetchCache' | 'tree'> & {\n-  url: URL\n-  kind?: PrefetchKind\n-  allowAliasing: boolean\n-}): AliasedPrefetchCacheEntry {\n-  const existingCacheEntry = getExistingCacheEntry(\n-    url,\n-    kind,\n-    nextUrl,\n-    prefetchCache,\n-    allowAliasing\n-  )\n-\n-  if (existingCacheEntry) {\n-    // Grab the latest status of the cache entry and update it\n-    existingCacheEntry.status = getPrefetchEntryCacheStatus(existingCacheEntry)\n-\n-    // when `kind` is provided, an explicit prefetch was requested.\n-    // if the requested prefetch is \"full\" and the current cache entry wasn't, we want to re-prefetch with the new intent\n-    const switchedToFullPrefetch =\n-      existingCacheEntry.kind !== PrefetchKind.FULL &&\n-      kind === PrefetchKind.FULL\n-\n-    if (switchedToFullPrefetch) {\n-      // If we switched to a full prefetch, validate that the existing cache entry contained partial data.\n-      // It's possible that the cache entry was seeded with full data but has a cache type of \"auto\" (ie when cache entries\n-      // are seeded but without a prefetch intent)\n-      existingCacheEntry.data.then((prefetchResponse) => {\n-        const isFullPrefetch =\n-          Array.isArray(prefetchResponse.flightData) &&\n-          prefetchResponse.flightData.some((flightData) => {\n-            // If we started rendering from the root and we returned RSC data (seedData), we already had a full prefetch.\n-            return flightData.isRootRender && flightData.seedData !== null\n-          })\n-\n-        if (!isFullPrefetch) {\n-          return createLazyPrefetchEntry({\n-            tree,\n-            url,\n-            nextUrl,\n-            prefetchCache,\n-            // If we didn't get an explicit prefetch kind, we want to set a temporary kind\n-            // rather than assuming the same intent as the previous entry, to be consistent with how we\n-            // lazily create prefetch entries when intent is left unspecified.\n-            kind: kind ?? PrefetchKind.TEMPORARY,\n-          })\n-        }\n-      })\n-    }\n-\n-    // If the existing cache entry was marked as temporary, it means it was lazily created when attempting to get an entry,\n-    // where we didn't have the prefetch intent. Now that we have the intent (in `kind`), we want to update the entry to the more accurate kind.\n-    if (kind && existingCacheEntry.kind === PrefetchKind.TEMPORARY) {\n-      existingCacheEntry.kind = kind\n-    }\n-\n-    // We've determined that the existing entry we found is still valid, so we return it.\n-    return existingCacheEntry\n-  }\n-\n-  // If we didn't return an entry, create a new one.\n-  return createLazyPrefetchEntry({\n-    tree,\n-    url,\n-    nextUrl,\n-    prefetchCache,\n-    kind: kind || PrefetchKind.TEMPORARY,\n-  })\n-}\n-\n-/*\n- * Used to take an existing cache entry and prefix it with the nextUrl, if it exists.\n- * This ensures that we don't have conflicting cache entries for the same URL (as is the case with route interception).\n- */\n-function prefixExistingPrefetchCacheEntry({\n-  url,\n-  nextUrl,\n-  prefetchCache,\n-  existingCacheKey,\n-}: Pick<ReadonlyReducerState, 'nextUrl' | 'prefetchCache'> & {\n-  url: URL\n-  existingCacheKey: string\n-}) {\n-  const existingCacheEntry = prefetchCache.get(existingCacheKey)\n-  if (!existingCacheEntry) {\n-    // no-op -- there wasn't an entry to move\n-    return\n-  }\n-\n-  const newCacheKey = createPrefetchCacheKey(\n-    url,\n-    existingCacheEntry.kind,\n-    nextUrl\n-  )\n-  prefetchCache.set(newCacheKey, { ...existingCacheEntry, key: newCacheKey })\n-  prefetchCache.delete(existingCacheKey)\n-\n-  return newCacheKey\n-}\n-\n-/**\n- * Use to seed the prefetch cache with data that has already been fetched.\n- */\n-export function createSeededPrefetchCacheEntry({\n-  nextUrl,\n-  tree,\n-  prefetchCache,\n-  url,\n-  data,\n-  kind,\n-}: Pick<ReadonlyReducerState, 'nextUrl' | 'tree' | 'prefetchCache'> & {\n-  url: URL\n-  data: FetchServerResponseResult\n-  kind: PrefetchKind\n-}) {\n-  // The initial cache entry technically includes full data, but it isn't explicitly prefetched -- we just seed the\n-  // prefetch cache so that we can skip an extra prefetch request later, since we already have the data.\n-  // if the prefetch corresponds with an interception route, we use the nextUrl to prefix the cache key\n-  const prefetchCacheKey = data.couldBeIntercepted\n-    ? createPrefetchCacheKey(url, kind, nextUrl)\n-    : createPrefetchCacheKey(url, kind)\n-\n-  const prefetchEntry = {\n-    treeAtTimeOfPrefetch: tree,\n-    data: Promise.resolve(data),\n-    kind,\n-    prefetchTime: Date.now(),\n-    lastUsedTime: Date.now(),\n-    staleTime: data.staleTime,\n-    key: prefetchCacheKey,\n-    status: PrefetchCacheEntryStatus.fresh,\n-    url,\n-  } satisfies PrefetchCacheEntry\n-\n-  prefetchCache.set(prefetchCacheKey, prefetchEntry)\n-\n-  return prefetchEntry\n-}\n-\n-/**\n- * Creates a prefetch entry entry and enqueues a fetch request to retrieve the data.\n- */\n-function createLazyPrefetchEntry({\n-  url,\n-  kind,\n-  tree,\n-  nextUrl,\n-  prefetchCache,\n-}: Pick<ReadonlyReducerState, 'nextUrl' | 'tree' | 'prefetchCache'> & {\n-  url: URL\n-  kind: PrefetchKind\n-}): PrefetchCacheEntry {\n-  const prefetchCacheKey = createPrefetchCacheKey(url, kind)\n-\n-  // initiates the fetch request for the prefetch and attaches a listener\n-  // to the promise to update the prefetch cache entry when the promise resolves (if necessary)\n-  const data = prefetchQueue.enqueue(() =>\n-    fetchServerResponse(url, {\n-      flightRouterState: tree,\n-      nextUrl,\n-      prefetchKind: kind,\n-    }).then((prefetchResponse) => {\n-      // TODO: `fetchServerResponse` should be more tighly coupled to these prefetch cache operations\n-      // to avoid drift between this cache key prefixing logic\n-      // (which is currently directly influenced by the server response)\n-      let newCacheKey\n-\n-      if (prefetchResponse.couldBeIntercepted) {\n-        // Determine if we need to prefix the cache key with the nextUrl\n-        newCacheKey = prefixExistingPrefetchCacheEntry({\n-          url,\n-          existingCacheKey: prefetchCacheKey,\n-          nextUrl,\n-          prefetchCache,\n-        })\n-      }\n-\n-      // If the prefetch was a cache hit, we want to update the existing cache entry to reflect that it was a full prefetch.\n-      // This is because we know that a static response will contain the full RSC payload, and can be updated to respect the `static`\n-      // staleTime.\n-      if (prefetchResponse.prerendered) {\n-        const existingCacheEntry = prefetchCache.get(\n-          // if we prefixed the cache key due to route interception, we want to use the new key. Otherwise we use the original key\n-          newCacheKey ?? prefetchCacheKey\n-        )\n-        if (existingCacheEntry) {\n-          existingCacheEntry.kind = PrefetchKind.FULL\n-          if (prefetchResponse.staleTime !== -1) {\n-            // This is the stale time that was collected by the server during\n-            // static generation. Use this in place of the default stale time.\n-            existingCacheEntry.staleTime = prefetchResponse.staleTime\n-          }\n-        }\n-      }\n-\n-      return prefetchResponse\n-    })\n-  )\n-\n-  const prefetchEntry = {\n-    treeAtTimeOfPrefetch: tree,\n-    data,\n-    kind,\n-    prefetchTime: Date.now(),\n-    lastUsedTime: null,\n-    staleTime: -1,\n-    key: prefetchCacheKey,\n-    status: PrefetchCacheEntryStatus.fresh,\n-    url,\n-  }\n-\n-  prefetchCache.set(prefetchCacheKey, prefetchEntry)\n-\n-  return prefetchEntry\n-}\n-\n-export function prunePrefetchCache(\n-  prefetchCache: ReadonlyReducerState['prefetchCache']\n-) {\n-  for (const [href, prefetchCacheEntry] of prefetchCache) {\n-    if (\n-      getPrefetchEntryCacheStatus(prefetchCacheEntry) ===\n-      PrefetchCacheEntryStatus.expired\n-    ) {\n-      prefetchCache.delete(href)\n-    }\n-  }\n-}\n-\n-// These values are set by `define-env-plugin` (based on `nextConfig.experimental.staleTimes`)\n-// and default to 5 minutes (static) / 0 seconds (dynamic)\n-export const DYNAMIC_STALETIME_MS =\n-  Number(process.env.__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME) * 1000\n-\n-export const STATIC_STALETIME_MS =\n-  Number(process.env.__NEXT_CLIENT_ROUTER_STATIC_STALETIME) * 1000\n-\n-function getPrefetchEntryCacheStatus({\n-  kind,\n-  prefetchTime,\n-  lastUsedTime,\n-}: PrefetchCacheEntry): PrefetchCacheEntryStatus {\n-  // We will re-use the cache entry data for up to the `dynamic` staletime window.\n-  if (Date.now() < (lastUsedTime ?? prefetchTime) + DYNAMIC_STALETIME_MS) {\n-    return lastUsedTime\n-      ? PrefetchCacheEntryStatus.reusable\n-      : PrefetchCacheEntryStatus.fresh\n-  }\n-\n-  // For \"auto\" prefetching, we'll re-use only the loading boundary for up to `static` staletime window.\n-  // A stale entry will only re-use the `loading` boundary, not the full data.\n-  // This will trigger a \"lazy fetch\" for the full data.\n-  if (kind === PrefetchKind.AUTO) {\n-    if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {\n-      return PrefetchCacheEntryStatus.stale\n-    }\n-  }\n-\n-  // for \"full\" prefetching, we'll re-use the cache entry data for up to `static` staletime window.\n-  if (kind === PrefetchKind.FULL) {\n-    if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {\n-      return PrefetchCacheEntryStatus.reusable\n-    }\n-  }\n-\n-  return PrefetchCacheEntryStatus.expired\n-}"
        },
        {
            "sha": "7dc4dea44b0659acab0277b7bdbee3af5e311a9f",
            "filename": "packages/next/src/client/components/router-reducer/reducers/navigate-reducer.ts",
            "status": "modified",
            "additions": 27,
            "deletions": 374,
            "changes": 401,
            "blob_url": "https://github.com/vercel/next.js/blob/56db4345f2eca501712d1963b78521a68a73803e/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fnavigate-reducer.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/56db4345f2eca501712d1963b78521a68a73803e/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fnavigate-reducer.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fnavigate-reducer.ts?ref=56db4345f2eca501712d1963b78521a68a73803e",
            "patch": "@@ -1,39 +1,30 @@\n-import type { CacheNode } from '../../../../shared/lib/app-router-types'\n import type {\n   FlightRouterState,\n   FlightSegmentPath,\n } from '../../../../shared/lib/app-router-types'\n-import { fetchServerResponse } from '../fetch-server-response'\n import { createHrefFromUrl } from '../create-href-from-url'\n-import { invalidateCacheBelowFlightSegmentPath } from '../invalidate-cache-below-flight-segmentpath'\n-import { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\n-import { shouldHardNavigate } from '../should-hard-navigate'\n-import { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\n-import {\n-  PrefetchCacheEntryStatus,\n-  type Mutable,\n-  type NavigateAction,\n-  type ReadonlyReducerState,\n-  type ReducerState,\n+import type {\n+  Mutable,\n+  NavigateAction,\n+  ReadonlyReducerState,\n+  ReducerState,\n } from '../router-reducer-types'\n import { handleMutable } from '../handle-mutable'\n-import { applyFlightData } from '../apply-flight-data'\n-import { prefetchQueue } from './prefetch-reducer'\n-import { createEmptyCacheNode } from '../../app-router'\n-import { DEFAULT_SEGMENT_KEY } from '../../../../shared/lib/segment'\n-import { listenForDynamicRequest, startPPRNavigation } from '../ppr-navigations'\n-import {\n-  getOrCreatePrefetchCacheEntry,\n-  prunePrefetchCache,\n-} from '../prefetch-cache-utils'\n-import { clearCacheNodeDataForSegmentPath } from '../clear-cache-node-data-for-segment-path'\n-import { handleAliasedPrefetchEntry } from '../aliased-prefetch-navigations'\n+\n import {\n   navigate as navigateUsingSegmentCache,\n   NavigationResultTag,\n   type NavigationResult,\n } from '../../segment-cache'\n \n+// These values are set by `define-env-plugin` (based on `nextConfig.experimental.staleTimes`)\n+// and default to 5 minutes (static) / 0 seconds (dynamic)\n+export const DYNAMIC_STALETIME_MS =\n+  Number(process.env.__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME) * 1000\n+\n+export const STATIC_STALETIME_MS =\n+  Number(process.env.__NEXT_CLIENT_ROUTER_STATIC_STALETIME) * 1000\n+\n export function handleExternalUrl(\n   state: ReadonlyReducerState,\n   mutable: Mutable,\n@@ -74,32 +65,6 @@ export function generateSegmentsFromPatch(\n   return segments\n }\n \n-function triggerLazyFetchForLeafSegments(\n-  newCache: CacheNode,\n-  currentCache: CacheNode,\n-  flightSegmentPath: FlightSegmentPath,\n-  treePatch: FlightRouterState\n-) {\n-  let appliedPatch = false\n-\n-  newCache.rsc = currentCache.rsc\n-  newCache.prefetchRsc = currentCache.prefetchRsc\n-  newCache.loading = currentCache.loading\n-  newCache.parallelRoutes = new Map(currentCache.parallelRoutes)\n-\n-  const segmentPathsToFill = generateSegmentsFromPatch(treePatch).map(\n-    (segment) => [...flightSegmentPath, ...segment]\n-  )\n-\n-  for (const segmentPaths of segmentPathsToFill) {\n-    clearCacheNodeDataForSegmentPath(newCache, currentCache, segmentPaths)\n-\n-    appliedPatch = true\n-  }\n-\n-  return appliedPatch\n-}\n-\n function handleNavigationResult(\n   url: URL,\n   state: ReadonlyReducerState,\n@@ -172,14 +137,10 @@ export function navigateReducer(\n   state: ReadonlyReducerState,\n   action: NavigateAction\n ): ReducerState {\n-  const { url, isExternalUrl, navigateType, shouldScroll, allowAliasing } =\n-    action\n+  const { url, isExternalUrl, navigateType, shouldScroll } = action\n   const mutable: Mutable = {}\n-  const { hash } = url\n   const href = createHrefFromUrl(url)\n   const pendingPush = navigateType === 'push'\n-  // we want to prune the prefetch cache on every navigation to avoid it growing too large\n-  prunePrefetchCache(state.prefetchCache)\n \n   mutable.preserveCustomHistoryState = false\n   mutable.pendingPush = pendingPush\n@@ -194,326 +155,18 @@ export function navigateReducer(\n     return handleExternalUrl(state, mutable, href, pendingPush)\n   }\n \n-  if (process.env.__NEXT_CLIENT_SEGMENT_CACHE) {\n-    // (Very Early Experimental Feature) Segment Cache\n-    //\n-    // Bypass the normal prefetch cache and use the new per-segment cache\n-    // implementation instead. This is only supported if PPR is enabled, too.\n-    //\n-    // Temporary glue code between the router reducer and the new navigation\n-    // implementation. Eventually we'll rewrite the router reducer to a\n-    // state machine.\n-    const currentUrl = new URL(state.canonicalUrl, location.origin)\n-    const result = navigateUsingSegmentCache(\n-      url,\n-      currentUrl,\n-      state.cache,\n-      state.tree,\n-      state.nextUrl,\n-      shouldScroll,\n-      mutable\n-    )\n-    return handleNavigationResult(url, state, mutable, pendingPush, result)\n-  }\n-\n-  const prefetchValues = getOrCreatePrefetchCacheEntry({\n+  // Temporary glue code between the router reducer and the new navigation\n+  // implementation. Eventually we'll rewrite the router reducer to a\n+  // state machine.\n+  const currentUrl = new URL(state.canonicalUrl, location.origin)\n+  const result = navigateUsingSegmentCache(\n     url,\n-    nextUrl: state.nextUrl,\n-    tree: state.tree,\n-    prefetchCache: state.prefetchCache,\n-    allowAliasing,\n-  })\n-  const { treeAtTimeOfPrefetch, data } = prefetchValues\n-\n-  prefetchQueue.bump(data)\n-\n-  return data.then(\n-    ({ flightData, canonicalUrl: canonicalUrlOverride, postponed }) => {\n-      const navigatedAt = Date.now()\n-\n-      let isFirstRead = false\n-      // we only want to mark this once\n-      if (!prefetchValues.lastUsedTime) {\n-        // important: we should only mark the cache node as dirty after we unsuspend from the call above\n-        prefetchValues.lastUsedTime = navigatedAt\n-        isFirstRead = true\n-      }\n-\n-      if (prefetchValues.aliased) {\n-        // When alias is enabled, search param may not be included in the canonicalUrl.\n-        // But we want to set url to canonicalUrl so that we use redirected path for fetching dynamic data.\n-        const urlWithCanonicalPathname = new URL(url.href)\n-        if (canonicalUrlOverride) {\n-          urlWithCanonicalPathname.pathname = canonicalUrlOverride.pathname\n-        }\n-\n-        const result = handleAliasedPrefetchEntry(\n-          navigatedAt,\n-          state,\n-          flightData,\n-          urlWithCanonicalPathname,\n-          mutable\n-        )\n-\n-        // We didn't return new router state because we didn't apply the aliased entry for some reason.\n-        // We'll re-invoke the navigation handler but ensure that we don't attempt to use the aliased entry. This\n-        // will create an on-demand prefetch entry.\n-        if (result === false) {\n-          return navigateReducer(state, { ...action, allowAliasing: false })\n-        }\n-\n-        return result\n-      }\n-\n-      // Handle case when navigating to page in `pages` from `app`\n-      if (typeof flightData === 'string') {\n-        return handleExternalUrl(state, mutable, flightData, pendingPush)\n-      }\n-\n-      const oldCanonicalUrl = state.canonicalUrl\n-      const updatedCanonicalUrl = canonicalUrlOverride\n-        ? createHrefFromUrl(canonicalUrlOverride)\n-        : href\n-\n-      const onlyHashChange =\n-        !!hash &&\n-        oldCanonicalUrl.split('#', 1)[0] ===\n-          updatedCanonicalUrl.split('#', 1)[0]\n-\n-      // If only the hash has changed, the server hasn't sent us any new data. We can just update\n-      // the mutable properties responsible for URL and scroll handling and return early.\n-      if (onlyHashChange) {\n-        mutable.onlyHashChange = true\n-        mutable.canonicalUrl = updatedCanonicalUrl\n-        mutable.shouldScroll = shouldScroll\n-        mutable.hashFragment = hash\n-        mutable.scrollableSegments = []\n-        return handleMutable(state, mutable)\n-      }\n-\n-      let currentTree = state.tree\n-      let currentCache = state.cache\n-      let scrollableSegments: FlightSegmentPath[] = []\n-      for (const normalizedFlightData of flightData) {\n-        const {\n-          pathToSegment: flightSegmentPath,\n-          seedData,\n-          head,\n-          isHeadPartial,\n-          isRootRender,\n-        } = normalizedFlightData\n-        let treePatch = normalizedFlightData.tree\n-\n-        // TODO-APP: remove ''\n-        const flightSegmentPathWithLeadingEmpty = ['', ...flightSegmentPath]\n-\n-        // Create new tree based on the flightSegmentPath and router state patch\n-        let newTree = applyRouterStatePatchToTree(\n-          // TODO-APP: remove ''\n-          flightSegmentPathWithLeadingEmpty,\n-          currentTree,\n-          treePatch,\n-          href\n-        )\n-\n-        // If the tree patch can't be applied to the current tree then we use the tree at time of prefetch\n-        // TODO-APP: This should instead fill in the missing pieces in `currentTree` with the data from `treeAtTimeOfPrefetch`, then apply the patch.\n-        if (newTree === null) {\n-          newTree = applyRouterStatePatchToTree(\n-            // TODO-APP: remove ''\n-            flightSegmentPathWithLeadingEmpty,\n-            treeAtTimeOfPrefetch,\n-            treePatch,\n-            href\n-          )\n-        }\n-\n-        if (newTree !== null) {\n-          if (\n-            // This is just a paranoid check. When a route is PPRed, the server\n-            // will send back a static response that's rendered from\n-            // the root. If for some reason it doesn't, we fall back to the\n-            // non-PPR implementation.\n-            // TODO: We should get rid of the else branch and do all navigations\n-            // via startPPRNavigation. The current structure is just\n-            // an incremental step.\n-            seedData &&\n-            isRootRender &&\n-            postponed\n-          ) {\n-            const task = startPPRNavigation(\n-              navigatedAt,\n-              new URL(oldCanonicalUrl, url.origin),\n-              currentCache,\n-              currentTree,\n-              treePatch,\n-              seedData,\n-              head,\n-              isHeadPartial,\n-              false,\n-              scrollableSegments\n-            )\n-\n-            if (task !== null) {\n-              if (task.route === null) {\n-                // Detected a change to the root layout. Perform an full-\n-                // page navigation.\n-                return handleExternalUrl(state, mutable, href, pendingPush)\n-              }\n-              // Use the tree computed by startPPRNavigation instead\n-              // of the one computed by applyRouterStatePatchToTree.\n-              // TODO: We should remove applyRouterStatePatchToTree\n-              // from the PPR path entirely.\n-              const patchedRouterState: FlightRouterState = task.route\n-              newTree = patchedRouterState\n-\n-              const newCache = task.node\n-              if (newCache !== null) {\n-                // We've created a new Cache Node tree that contains a prefetched\n-                // version of the next page. This can be rendered instantly.\n-                mutable.cache = newCache\n-              }\n-              const dynamicRequestTree = task.dynamicRequestTree\n-              if (dynamicRequestTree !== null) {\n-                // The prefetched tree has dynamic holes in it. We initiate a\n-                // dynamic request to fill them in.\n-                //\n-                // Do not block on the result. We'll immediately render the Cache\n-                // Node tree and suspend on the dynamic parts. When the request\n-                // comes in, we'll fill in missing data and ping React to\n-                // re-render. Unlike the lazy fetching model in the non-PPR\n-                // implementation, this is modeled as a single React update +\n-                // streaming, rather than multiple top-level updates. (However,\n-                // even in the new model, we'll still need to sometimes update the\n-                // root multiple times per navigation, like if the server sends us\n-                // a different response than we expected. For now, we revert back\n-                // to the lazy fetching mechanism in that case.)\n-                const dynamicRequest = fetchServerResponse(\n-                  new URL(updatedCanonicalUrl, url.origin),\n-                  {\n-                    flightRouterState: dynamicRequestTree,\n-                    // We always send the last next-url, not the current when\n-                    // performing a dynamic request. This is because we update\n-                    // the next-url after a navigation, but we want the same\n-                    // interception route to be matched that used the last\n-                    // next-url.\n-                    nextUrl: state.previousNextUrl || state.nextUrl,\n-                  }\n-                )\n-\n-                listenForDynamicRequest(task, dynamicRequest)\n-                // We store the dynamic request on the `lazyData` property of the CacheNode\n-                // because we're not going to await the dynamic request here. Since we're not blocking\n-                // on the dynamic request, `layout-router` will\n-                // task.node.lazyData = dynamicRequest\n-              } else {\n-                // The prefetched tree does not contain dynamic holes  it's\n-                // fully static. We can skip the dynamic request.\n-              }\n-            } else {\n-              // Nothing changed, so reuse the old cache.\n-              // TODO: What if the head changed but not any of the segment data?\n-              // Is that possible? If so, we should clone the whole tree and\n-              // update the head.\n-              newTree = treePatch\n-            }\n-          } else {\n-            // The static response does not include any dynamic holes, so\n-            // there's no need to do a second request.\n-            // TODO: As an incremental step this just reverts back to the\n-            // non-PPR implementation. We can simplify this branch further,\n-            // given that PPR prefetches are always static and return the whole\n-            // tree. Or in the meantime we could factor it out into a\n-            // separate function.\n-\n-            if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n-              return handleExternalUrl(state, mutable, href, pendingPush)\n-            }\n-\n-            const cache: CacheNode = createEmptyCacheNode()\n-            let applied = false\n-\n-            if (\n-              prefetchValues.status === PrefetchCacheEntryStatus.stale &&\n-              !isFirstRead\n-            ) {\n-              // When we have a stale prefetch entry, we only want to re-use the loading state of the route we're navigating to, to support instant loading navigations\n-              // this will trigger a lazy fetch for the actual page data by nulling the `rsc` and `prefetchRsc` values for page data,\n-              // while copying over the `loading` for the segment that contains the page data.\n-              // We only do this on subsequent reads, as otherwise there'd be no loading data to re-use.\n-\n-              // We skip this branch if only the hash fragment has changed, as we don't want to trigger a lazy fetch in that case\n-              applied = triggerLazyFetchForLeafSegments(\n-                cache,\n-                currentCache,\n-                flightSegmentPath,\n-                treePatch\n-              )\n-              // since we re-used the stale cache's loading state & refreshed the data,\n-              // update the `lastUsedTime` so that it can continue to be re-used for the next 30s\n-              prefetchValues.lastUsedTime = navigatedAt\n-            } else {\n-              applied = applyFlightData(\n-                navigatedAt,\n-                currentCache,\n-                cache,\n-                normalizedFlightData,\n-                prefetchValues\n-              )\n-            }\n-\n-            const hardNavigate = shouldHardNavigate(\n-              // TODO-APP: remove ''\n-              flightSegmentPathWithLeadingEmpty,\n-              currentTree\n-            )\n-\n-            if (hardNavigate) {\n-              // Copy rsc for the root node of the cache.\n-              cache.rsc = currentCache.rsc\n-              cache.prefetchRsc = currentCache.prefetchRsc\n-\n-              invalidateCacheBelowFlightSegmentPath(\n-                cache,\n-                currentCache,\n-                flightSegmentPath\n-              )\n-              // Ensure the existing cache value is used when the cache was not invalidated.\n-              mutable.cache = cache\n-            } else if (applied) {\n-              mutable.cache = cache\n-              // If we applied the cache, we update the \"current cache\" value so any other\n-              // segments in the FlightDataPath will be able to reference the updated cache.\n-              currentCache = cache\n-            }\n-\n-            for (const subSegment of generateSegmentsFromPatch(treePatch)) {\n-              const scrollableSegmentPath = [\n-                ...flightSegmentPath,\n-                ...subSegment,\n-              ]\n-              // Filter out the __DEFAULT__ paths as they shouldn't be scrolled to in this case.\n-              if (\n-                scrollableSegmentPath[scrollableSegmentPath.length - 1] !==\n-                DEFAULT_SEGMENT_KEY\n-              ) {\n-                scrollableSegments.push(scrollableSegmentPath)\n-              }\n-            }\n-          }\n-\n-          currentTree = newTree\n-        }\n-      }\n-\n-      mutable.patchedTree = currentTree\n-      mutable.canonicalUrl = updatedCanonicalUrl\n-      mutable.scrollableSegments = scrollableSegments\n-      mutable.hashFragment = hash\n-      mutable.shouldScroll = shouldScroll\n-\n-      return handleMutable(state, mutable)\n-    },\n-    () => state\n+    currentUrl,\n+    state.cache,\n+    state.tree,\n+    state.nextUrl,\n+    shouldScroll,\n+    mutable\n   )\n+  return handleNavigationResult(url, state, mutable, pendingPush, result)\n }"
        },
        {
            "sha": "74a4a0757e70330e02213a5b760191db4f5f326b",
            "filename": "packages/next/src/client/components/router-reducer/reducers/prefetch-reducer.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 46,
            "changes": 46,
            "blob_url": "https://github.com/vercel/next.js/blob/bdc3d07ce85c84a2fff5d9540ac8e39a541d07f3/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fprefetch-reducer.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/bdc3d07ce85c84a2fff5d9540ac8e39a541d07f3/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fprefetch-reducer.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fprefetch-reducer.ts?ref=bdc3d07ce85c84a2fff5d9540ac8e39a541d07f3",
            "patch": "@@ -1,46 +0,0 @@\n-import type {\n-  PrefetchAction,\n-  ReducerState,\n-  ReadonlyReducerState,\n-} from '../router-reducer-types'\n-import { PromiseQueue } from '../../promise-queue'\n-import {\n-  getOrCreatePrefetchCacheEntry,\n-  prunePrefetchCache,\n-} from '../prefetch-cache-utils'\n-export const prefetchQueue = new PromiseQueue(5)\n-\n-export const prefetchReducer = process.env.__NEXT_CLIENT_SEGMENT_CACHE\n-  ? identityReducerWhenSegmentCacheIsEnabled\n-  : prefetchReducerImpl\n-\n-function identityReducerWhenSegmentCacheIsEnabled<T>(state: T): T {\n-  // Unlike the old implementation, the Segment Cache doesn't store its data in\n-  // the router reducer state.\n-  //\n-  // This shouldn't be reachable because we wrap the prefetch API in a check,\n-  // too, which prevents the action from being dispatched. But it's here for\n-  // clarity + code elimination.\n-  return state\n-}\n-\n-function prefetchReducerImpl(\n-  state: ReadonlyReducerState,\n-  action: PrefetchAction\n-): ReducerState {\n-  // let's prune the prefetch cache before we do anything else\n-  prunePrefetchCache(state.prefetchCache)\n-\n-  const { url } = action\n-\n-  getOrCreatePrefetchCacheEntry({\n-    url,\n-    nextUrl: state.nextUrl,\n-    prefetchCache: state.prefetchCache,\n-    kind: action.kind,\n-    tree: state.tree,\n-    allowAliasing: true,\n-  })\n-\n-  return state\n-}"
        },
        {
            "sha": "11b8fd726835bb23e9a12ee5af571c43a5ba3eef",
            "filename": "packages/next/src/client/components/router-reducer/reducers/refresh-reducer.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 7,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/56db4345f2eca501712d1963b78521a68a73803e/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Frefresh-reducer.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/56db4345f2eca501712d1963b78521a68a73803e/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Frefresh-reducer.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Frefresh-reducer.ts?ref=56db4345f2eca501712d1963b78521a68a73803e",
            "patch": "@@ -121,14 +121,9 @@ export function refreshReducer(\n             undefined,\n             treePatch,\n             cacheNodeSeedData,\n-            head,\n-            undefined\n+            head\n           )\n-          if (process.env.__NEXT_CLIENT_SEGMENT_CACHE) {\n-            revalidateEntireCache(state.nextUrl, newTree)\n-          } else {\n-            mutable.prefetchCache = new Map()\n-          }\n+          revalidateEntireCache(state.nextUrl, newTree)\n         }\n \n         await refreshInactiveParallelSegments({"
        },
        {
            "sha": "b54643a1455b1a01fb82f2598f541c0ceee5250d",
            "filename": "packages/next/src/client/components/router-reducer/reducers/restore-reducer.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/56db4345f2eca501712d1963b78521a68a73803e/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Frestore-reducer.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/56db4345f2eca501712d1963b78521a68a73803e/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Frestore-reducer.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Frestore-reducer.ts?ref=56db4345f2eca501712d1963b78521a68a73803e",
            "patch": "@@ -41,7 +41,6 @@ export function restoreReducer(\n     },\n     focusAndScrollRef: state.focusAndScrollRef,\n     cache: newCache,\n-    prefetchCache: state.prefetchCache,\n     // Restore provided tree\n     tree: treeToRestore,\n     nextUrl: extractPathFromFlightRouterState(treeToRestore) ?? url.pathname,"
        },
        {
            "sha": "0b4690cf2ce0ad0495ad7d3d5c8ce135402dec97",
            "filename": "packages/next/src/client/components/router-reducer/reducers/server-action-reducer.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 47,
            "changes": 54,
            "blob_url": "https://github.com/vercel/next.js/blob/56db4345f2eca501712d1963b78521a68a73803e/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fserver-action-reducer.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/56db4345f2eca501712d1963b78521a68a73803e/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fserver-action-reducer.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fserver-action-reducer.ts?ref=56db4345f2eca501712d1963b78521a68a73803e",
            "patch": "@@ -24,12 +24,11 @@ import {\n   encodeReply,\n } from 'react-server-dom-webpack/client'\n \n-import {\n-  PrefetchKind,\n-  type ReadonlyReducerState,\n-  type ReducerState,\n-  type ServerActionAction,\n-  type ServerActionMutable,\n+import type {\n+  ReadonlyReducerState,\n+  ReducerState,\n+  ServerActionAction,\n+  ServerActionMutable,\n } from '../router-reducer-types'\n import { assignLocation } from '../../../assign-location'\n import { createHrefFromUrl } from '../create-href-from-url'\n@@ -50,7 +49,6 @@ import {\n } from '../../../flight-data-helpers'\n import { getRedirectError } from '../../redirect'\n import { RedirectType } from '../../redirect-error'\n-import { createSeededPrefetchCacheEntry } from '../prefetch-cache-utils'\n import { removeBasePath } from '../../../remove-base-path'\n import { hasBasePath } from '../../../has-base-path'\n import {\n@@ -275,7 +273,6 @@ export function serverActionReducer(\n       actionFlightData: flightData,\n       redirectLocation,\n       redirectType,\n-      isPrerender,\n       revalidatedParts,\n     }) => {\n       let redirectHref: string | undefined\n@@ -390,16 +387,11 @@ export function serverActionReducer(\n             undefined,\n             treePatch,\n             cacheNodeSeedData,\n-            head,\n-            undefined\n+            head\n           )\n \n           mutable.cache = cache\n-          if (process.env.__NEXT_CLIENT_SEGMENT_CACHE) {\n-            revalidateEntireCache(state.nextUrl, newTree)\n-          } else {\n-            mutable.prefetchCache = new Map()\n-          }\n+          revalidateEntireCache(state.nextUrl, newTree)\n           if (actionRevalidated) {\n             await refreshInactiveParallelSegments({\n               navigatedAt,\n@@ -417,38 +409,6 @@ export function serverActionReducer(\n       }\n \n       if (redirectLocation && redirectHref) {\n-        if (!process.env.__NEXT_CLIENT_SEGMENT_CACHE && !actionRevalidated) {\n-          // Because the RedirectBoundary will trigger a navigation, we need to seed the prefetch cache\n-          // with the FlightData that we got from the server action for the target page, so that it's\n-          // available when the page is navigated to and doesn't need to be re-fetched.\n-          // We only do this if the server action didn't revalidate any data, as in that case the\n-          // client cache will be cleared and the data will be re-fetched anyway.\n-          // NOTE: We don't do this in the Segment Cache implementation.\n-          // Dynamic data should never be placed into the cache, unless it's\n-          // \"converted\" to static data using <Link prefetch={true}>. What we\n-          // do instead is re-prefetch links and forms whenever the cache is\n-          // invalidated.\n-          createSeededPrefetchCacheEntry({\n-            url: redirectLocation,\n-            data: {\n-              flightData,\n-              canonicalUrl: undefined,\n-              couldBeIntercepted: false,\n-              prerendered: false,\n-              postponed: false,\n-              // TODO: We should be able to set this if the server action\n-              // returned a fully static response.\n-              staleTime: -1,\n-              debugInfo: null,\n-            },\n-            tree: state.tree,\n-            prefetchCache: state.prefetchCache,\n-            nextUrl: state.nextUrl,\n-            kind: isPrerender ? PrefetchKind.FULL : PrefetchKind.AUTO,\n-          })\n-          mutable.prefetchCache = state.prefetchCache\n-        }\n-\n         // If the action triggered a redirect, the action promise will be rejected with\n         // a redirect so that it's handled by RedirectBoundary as we won't have a valid\n         // action result to resolve the promise with. This will effectively reset the state of"
        },
        {
            "sha": "00b0b7dc728bcf13c31c312e1761dd937e97f183",
            "filename": "packages/next/src/client/components/router-reducer/router-reducer-types.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 33,
            "changes": 33,
            "blob_url": "https://github.com/vercel/next.js/blob/56db4345f2eca501712d1963b78521a68a73803e/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Frouter-reducer-types.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/56db4345f2eca501712d1963b78521a68a73803e/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Frouter-reducer-types.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Frouter-reducer-types.ts?ref=56db4345f2eca501712d1963b78521a68a73803e",
            "patch": "@@ -9,7 +9,6 @@ export const ACTION_REFRESH = 'refresh'\n export const ACTION_NAVIGATE = 'navigate'\n export const ACTION_RESTORE = 'restore'\n export const ACTION_SERVER_PATCH = 'server-patch'\n-export const ACTION_PREFETCH = 'prefetch'\n export const ACTION_HMR_REFRESH = 'hmr-refresh'\n export const ACTION_SERVER_ACTION = 'server-action'\n \n@@ -30,7 +29,6 @@ export interface Mutable {\n   scrollableSegments?: FlightSegmentPath[]\n   pendingPush?: boolean\n   cache?: CacheNode\n-  prefetchCache?: AppRouterState['prefetchCache']\n   hashFragment?: string\n   shouldScroll?: boolean\n   preserveCustomHistoryState?: boolean\n@@ -110,7 +108,6 @@ export interface NavigateAction {\n   locationSearch: Location['search']\n   navigateType: 'push' | 'replace'\n   shouldScroll: boolean\n-  allowAliasing: boolean\n }\n \n /**\n@@ -159,11 +156,6 @@ export enum PrefetchKind {\n  * - Adds the FlightData to the prefetch cache\n  * - In ACTION_NAVIGATE the prefetch cache is checked and the router state tree and FlightData are applied.\n  */\n-export interface PrefetchAction {\n-  type: typeof ACTION_PREFETCH\n-  url: URL\n-  kind: PrefetchKind\n-}\n \n export interface PushRef {\n   /**\n@@ -199,25 +191,6 @@ export type FocusAndScrollRef = {\n   onlyHashChange: boolean\n }\n \n-export type PrefetchCacheEntry = {\n-  treeAtTimeOfPrefetch: FlightRouterState\n-  data: Promise<FetchServerResponseResult>\n-  kind: PrefetchKind\n-  prefetchTime: number\n-  staleTime: number\n-  lastUsedTime: number | null\n-  key: string\n-  status: PrefetchCacheEntryStatus\n-  url: URL\n-}\n-\n-export enum PrefetchCacheEntryStatus {\n-  fresh = 'fresh',\n-  reusable = 'reusable',\n-  expired = 'expired',\n-  stale = 'stale',\n-}\n-\n /**\n  * Handles keeping the state of app-router.\n  */\n@@ -231,13 +204,8 @@ export type AppRouterState = {\n   /**\n    * The cache holds React nodes for every segment that is shown on screen as well as previously shown segments.\n    * It also holds in-progress data requests.\n-   * Prefetched data is stored separately in `prefetchCache`, that is applied during ACTION_NAVIGATE.\n    */\n   cache: CacheNode\n-  /**\n-   * Cache that holds prefetched Flight responses keyed by url.\n-   */\n-  prefetchCache: Map<string, PrefetchCacheEntry>\n   /**\n    * Decides if the update should create a new history entry and if the navigation has to trigger a browser navigation.\n    */\n@@ -273,7 +241,6 @@ export type ReducerActions = Readonly<\n   | NavigateAction\n   | RestoreAction\n   | ServerPatchAction\n-  | PrefetchAction\n   | HmrRefreshAction\n   | ServerActionAction\n >"
        },
        {
            "sha": "f0019b6a9d716f38d0698a6c4249628e2b00aa2d",
            "filename": "packages/next/src/client/components/router-reducer/router-reducer.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 5,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/56db4345f2eca501712d1963b78521a68a73803e/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Frouter-reducer.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/56db4345f2eca501712d1963b78521a68a73803e/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Frouter-reducer.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Frouter-reducer.ts?ref=56db4345f2eca501712d1963b78521a68a73803e",
            "patch": "@@ -3,7 +3,6 @@ import {\n   ACTION_SERVER_PATCH,\n   ACTION_RESTORE,\n   ACTION_REFRESH,\n-  ACTION_PREFETCH,\n   ACTION_HMR_REFRESH,\n   ACTION_SERVER_ACTION,\n } from './router-reducer-types'\n@@ -16,7 +15,6 @@ import { navigateReducer } from './reducers/navigate-reducer'\n import { serverPatchReducer } from './reducers/server-patch-reducer'\n import { restoreReducer } from './reducers/restore-reducer'\n import { refreshReducer } from './reducers/refresh-reducer'\n-import { prefetchReducer } from './reducers/prefetch-reducer'\n import { hmrRefreshReducer } from './reducers/hmr-refresh-reducer'\n import { serverActionReducer } from './reducers/server-action-reducer'\n \n@@ -43,9 +41,6 @@ function clientReducer(\n     case ACTION_HMR_REFRESH: {\n       return hmrRefreshReducer(state, action)\n     }\n-    case ACTION_PREFETCH: {\n-      return prefetchReducer(state, action)\n-    }\n     case ACTION_SERVER_ACTION: {\n       return serverActionReducer(state, action)\n     }"
        },
        {
            "sha": "fe39f84fdd525a60d6d63fafb2bac2f35b166697",
            "filename": "packages/next/src/client/components/segment-cache-impl/cache.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/56db4345f2eca501712d1963b78521a68a73803e/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/56db4345f2eca501712d1963b78521a68a73803e/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts?ref=56db4345f2eca501712d1963b78521a68a73803e",
            "patch": "@@ -75,7 +75,7 @@ import {\n   normalizeFlightData,\n   prepareFlightRouterStateForRequest,\n } from '../../flight-data-helpers'\n-import { STATIC_STALETIME_MS } from '../router-reducer/prefetch-cache-utils'\n+import { STATIC_STALETIME_MS } from '../router-reducer/reducers/navigate-reducer'\n import { pingVisibleLinks } from '../links'\n import { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\n import {"
        },
        {
            "sha": "d28b079c78cc7dc1f1c337e40f24c428c538ffa9",
            "filename": "packages/next/src/server/app-render/app-render.tsx",
            "status": "modified",
            "additions": 0,
            "deletions": 6,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/56db4345f2eca501712d1963b78521a68a73803e/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/56db4345f2eca501712d1963b78521a68a73803e/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx?ref=56db4345f2eca501712d1963b78521a68a73803e",
            "patch": "@@ -1349,9 +1349,6 @@ function App<T>({\n     // location is not initialized in the SSR render\n     // it's set to window.location during hydration\n     location: null,\n-    couldBeIntercepted: response.i,\n-    postponed: response.s,\n-    prerendered: response.S,\n   })\n \n   const actionQueue = createMutableActionQueue(initialState, null)\n@@ -1419,9 +1416,6 @@ function ErrorApp<T>({\n     // location is not initialized in the SSR render\n     // it's set to window.location during hydration\n     location: null,\n-    couldBeIntercepted: response.i,\n-    postponed: response.s,\n-    prerendered: response.S,\n   })\n \n   const actionQueue = createMutableActionQueue(initialState, null)"
        }
    ],
    "stats": {
        "total": 1268,
        "additions": 95,
        "deletions": 1173
    }
}