{
    "author": "bgw",
    "message": "refactor(turbopack): Implement `BackingStorage` for `Either`, replace `NextTurboTasks` with a type alias (#80823)\n\nThe `NextTurboTasks` enum existed to allow us to enable or disable persistent caching at runtime.\n\nThis PR implements `BackingStorage` for `Either`, so that the complexity of this branching is moved into `turbo-tasks-backend`.\n\nThis eliminates the need for the next.js and eventually other consumers (`turbopack-cli`, Utoo) to handle this branching if they want to support multiple backing storage layers.\n\nThe tradeoff is that moving these branches further down in the callstack might lead to more (easily predicted) branches in the code. We can see if codspeed notices anything. **Update:** Codspeed is performance-neutral.",
    "sha": "6951729f435f130c11d436ed9b8dabea253a0ee2",
    "files": [
        {
            "sha": "0417f6a658eac57205c141c8cd7e935722b83c5c",
            "filename": "Cargo.lock",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/6951729f435f130c11d436ed9b8dabea253a0ee2/Cargo.lock",
            "raw_url": "https://github.com/vercel/next.js/raw/6951729f435f130c11d436ed9b8dabea253a0ee2/Cargo.lock",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/Cargo.lock?ref=6951729f435f130c11d436ed9b8dabea253a0ee2",
            "patch": "@@ -4406,6 +4406,7 @@ dependencies = [\n  \"anyhow\",\n  \"console-subscriber\",\n  \"dhat\",\n+ \"either\",\n  \"getrandom 0.2.15\",\n  \"iana-time-zone\",\n  \"lightningcss-napi\","
        },
        {
            "sha": "f2af71b31e04dcb6cb453221cd4f1d12644d0f0d",
            "filename": "crates/napi/Cargo.toml",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/6951729f435f130c11d436ed9b8dabea253a0ee2/crates%2Fnapi%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/6951729f435f130c11d436ed9b8dabea253a0ee2/crates%2Fnapi%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnapi%2FCargo.toml?ref=6951729f435f130c11d436ed9b8dabea253a0ee2",
            "patch": "@@ -57,6 +57,7 @@ ignored = [\n anyhow = \"1.0.66\"\n console-subscriber = { workspace = true, optional = true }\n dhat = { workspace = true, optional = true }\n+either = { workspace = true }\n owo-colors = { workspace = true }\n napi = { workspace = true }\n napi-derive = \"2\""
        },
        {
            "sha": "8d2eef2179fa1b81ea16ee98a2d680fa864cab76",
            "filename": "crates/napi/src/next_api/project.rs",
            "status": "modified",
            "additions": 7,
            "deletions": 4,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/6951729f435f130c11d436ed9b8dabea253a0ee2/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/6951729f435f130c11d436ed9b8dabea253a0ee2/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs?ref=6951729f435f130c11d436ed9b8dabea253a0ee2",
            "patch": "@@ -31,11 +31,12 @@ use tracing_subscriber::{Registry, layer::SubscriberExt, util::SubscriberInitExt\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{\n     Completion, Effects, FxIndexSet, NonLocalValue, OperationValue, OperationVc, ReadRef,\n-    ResolvedVc, TaskInput, TransientInstance, TryJoinIterExt, UpdateInfo, Vc, get_effects,\n+    ResolvedVc, TaskInput, TransientInstance, TryJoinIterExt, TurboTasksApi, UpdateInfo, Vc,\n+    get_effects,\n     message_queue::{CompilationEvent, Severity, TimingEvent},\n     trace::TraceRawVcs,\n };\n-use turbo_tasks_backend::db_invalidation::invalidation_reasons;\n+use turbo_tasks_backend::{BackingStorage, db_invalidation::invalidation_reasons};\n use turbo_tasks_fs::{\n     DiskFileSystem, FileContent, FileSystem, FileSystemPath, get_relative_path_to,\n     util::uri_from_file,\n@@ -591,7 +592,9 @@ pub async fn project_invalidate_persistent_cache(\n         // how to generate a message for on the Rust side of the FFI.\n         project\n             .turbo_tasks\n-            .invalidate_persistent_cache(invalidation_reasons::USER_REQUEST)\n+            .backend()\n+            .backing_storage()\n+            .invalidate(invalidation_reasons::USER_REQUEST)\n     })\n     .await\n     .context(\"panicked while invalidating persistent cache\")??;\n@@ -1336,7 +1339,7 @@ pub fn project_compilation_events_subscribe(\n         })?;\n \n     tokio::spawn(async move {\n-        let mut receiver = turbo_tasks.get_compilation_events_stream(event_types);\n+        let mut receiver = turbo_tasks.subscribe_to_compilation_events(event_types);\n         while let Some(msg) = receiver.recv().await {\n             let status = tsfn.call(Ok(msg), ThreadsafeFunctionCallMode::Blocking);\n "
        },
        {
            "sha": "ff9c40f32364a7ea40f838fce48c49a66fcddb43",
            "filename": "crates/napi/src/next_api/utils.rs",
            "status": "modified",
            "additions": 19,
            "deletions": 151,
            "changes": 170,
            "blob_url": "https://github.com/vercel/next.js/blob/6951729f435f130c11d436ed9b8dabea253a0ee2/crates%2Fnapi%2Fsrc%2Fnext_api%2Futils.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/6951729f435f130c11d436ed9b8dabea253a0ee2/crates%2Fnapi%2Fsrc%2Fnext_api%2Futils.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnapi%2Fsrc%2Fnext_api%2Futils.rs?ref=6951729f435f130c11d436ed9b8dabea253a0ee2",
            "patch": "@@ -1,24 +1,23 @@\n-use std::{future::Future, ops::Deref, path::PathBuf, sync::Arc, time::Duration};\n+use std::{future::Future, ops::Deref, path::PathBuf, sync::Arc};\n \n use anyhow::{Context, Result, anyhow};\n+use either::Either;\n use napi::{\n     JsFunction, JsObject, JsUnknown, NapiRaw, NapiValue, Status,\n     bindgen_prelude::{External, ToNapiValue},\n     threadsafe_function::{ThreadSafeCallContext, ThreadsafeFunction, ThreadsafeFunctionCallMode},\n };\n use rustc_hash::FxHashMap;\n use serde::Serialize;\n-use tokio::sync::mpsc::Receiver;\n use turbo_tasks::{\n-    Effects, OperationVc, ReadRef, TaskId, TryJoinIterExt, TurboTasks, TurboTasksApi, UpdateInfo,\n-    Vc, VcValueType, get_effects,\n+    Effects, OperationVc, ReadRef, TaskId, TryJoinIterExt, TurboTasks, TurboTasksApi, Vc,\n+    VcValueType, get_effects,\n     message_queue::{CompilationEvent, Severity},\n-    task_statistics::TaskStatisticsApi,\n-    trace::TraceRawVcs,\n };\n use turbo_tasks_backend::{\n-    BackingStorage, DefaultBackingStorage, GitVersionInfo, NoopBackingStorage, StartupCacheState,\n-    db_invalidation::invalidation_reasons, default_backing_storage, noop_backing_storage,\n+    DefaultBackingStorage, GitVersionInfo, NoopBackingStorage, StartupCacheState,\n+    TurboTasksBackend, db_invalidation::invalidation_reasons, default_backing_storage,\n+    noop_backing_storage,\n };\n use turbo_tasks_fs::FileContent;\n use turbopack_core::{\n@@ -32,137 +31,8 @@ use turbopack_core::{\n \n use crate::util::log_internal_error_and_inform;\n \n-#[derive(Clone)]\n-pub enum NextTurboTasks {\n-    Memory(Arc<TurboTasks<turbo_tasks_backend::TurboTasksBackend<NoopBackingStorage>>>),\n-    PersistentCaching(\n-        Arc<TurboTasks<turbo_tasks_backend::TurboTasksBackend<DefaultBackingStorage>>>,\n-    ),\n-}\n-\n-impl NextTurboTasks {\n-    pub fn dispose_root_task(&self, task: TaskId) {\n-        match self {\n-            NextTurboTasks::Memory(turbo_tasks) => turbo_tasks.dispose_root_task(task),\n-            NextTurboTasks::PersistentCaching(turbo_tasks) => turbo_tasks.dispose_root_task(task),\n-        }\n-    }\n-\n-    pub fn spawn_root_task<T, F, Fut>(&self, functor: F) -> TaskId\n-    where\n-        T: Send,\n-        F: Fn() -> Fut + Send + Sync + Clone + 'static,\n-        Fut: Future<Output = Result<Vc<T>>> + Send,\n-    {\n-        match self {\n-            NextTurboTasks::Memory(turbo_tasks) => turbo_tasks.spawn_root_task(functor),\n-            NextTurboTasks::PersistentCaching(turbo_tasks) => turbo_tasks.spawn_root_task(functor),\n-        }\n-    }\n-\n-    pub async fn run_once<T: TraceRawVcs + Send + 'static>(\n-        &self,\n-        future: impl Future<Output = Result<T>> + Send + 'static,\n-    ) -> Result<T> {\n-        match self {\n-            NextTurboTasks::Memory(turbo_tasks) => turbo_tasks.run_once(future).await,\n-            NextTurboTasks::PersistentCaching(turbo_tasks) => turbo_tasks.run_once(future).await,\n-        }\n-    }\n-\n-    pub fn spawn_once_task<T, Fut>(&self, future: Fut) -> TaskId\n-    where\n-        T: Send,\n-        Fut: Future<Output = Result<Vc<T>>> + Send + 'static,\n-    {\n-        match self {\n-            NextTurboTasks::Memory(turbo_tasks) => turbo_tasks.spawn_once_task(future),\n-            NextTurboTasks::PersistentCaching(turbo_tasks) => turbo_tasks.spawn_once_task(future),\n-        }\n-    }\n-\n-    pub async fn aggregated_update_info(\n-        &self,\n-        aggregation: Duration,\n-        timeout: Duration,\n-    ) -> Option<UpdateInfo> {\n-        match self {\n-            NextTurboTasks::Memory(turbo_tasks) => {\n-                turbo_tasks\n-                    .aggregated_update_info(aggregation, timeout)\n-                    .await\n-            }\n-            NextTurboTasks::PersistentCaching(turbo_tasks) => {\n-                turbo_tasks\n-                    .aggregated_update_info(aggregation, timeout)\n-                    .await\n-            }\n-        }\n-    }\n-\n-    pub async fn get_or_wait_aggregated_update_info(&self, aggregation: Duration) -> UpdateInfo {\n-        match self {\n-            NextTurboTasks::Memory(turbo_tasks) => {\n-                turbo_tasks\n-                    .get_or_wait_aggregated_update_info(aggregation)\n-                    .await\n-            }\n-            NextTurboTasks::PersistentCaching(turbo_tasks) => {\n-                turbo_tasks\n-                    .get_or_wait_aggregated_update_info(aggregation)\n-                    .await\n-            }\n-        }\n-    }\n-\n-    pub async fn stop_and_wait(&self) {\n-        match self {\n-            NextTurboTasks::Memory(turbo_tasks) => turbo_tasks.stop_and_wait().await,\n-            NextTurboTasks::PersistentCaching(turbo_tasks) => turbo_tasks.stop_and_wait().await,\n-        }\n-    }\n-\n-    pub fn task_statistics(&self) -> &TaskStatisticsApi {\n-        match self {\n-            NextTurboTasks::Memory(turbo_tasks) => turbo_tasks.task_statistics(),\n-            NextTurboTasks::PersistentCaching(turbo_tasks) => turbo_tasks.task_statistics(),\n-        }\n-    }\n-\n-    pub fn get_compilation_events_stream(\n-        &self,\n-        event_types: Option<Vec<String>>,\n-    ) -> Receiver<Arc<dyn CompilationEvent>> {\n-        match self {\n-            NextTurboTasks::Memory(turbo_tasks) => {\n-                turbo_tasks.subscribe_to_compilation_events(event_types)\n-            }\n-            NextTurboTasks::PersistentCaching(turbo_tasks) => {\n-                turbo_tasks.subscribe_to_compilation_events(event_types)\n-            }\n-        }\n-    }\n-\n-    pub fn send_compilation_event(&self, event: Arc<dyn CompilationEvent>) {\n-        match self {\n-            NextTurboTasks::Memory(turbo_tasks) => turbo_tasks.send_compilation_event(event),\n-            NextTurboTasks::PersistentCaching(turbo_tasks) => {\n-                turbo_tasks.send_compilation_event(event)\n-            }\n-        }\n-    }\n-\n-    pub fn invalidate_persistent_cache(&self, reason_code: &str) -> Result<()> {\n-        match self {\n-            NextTurboTasks::Memory(_) => {}\n-            NextTurboTasks::PersistentCaching(turbo_tasks) => turbo_tasks\n-                .backend()\n-                .backing_storage()\n-                .invalidate(reason_code)?,\n-        }\n-        Ok(())\n-    }\n-}\n+pub type NextTurboTasks =\n+    Arc<TurboTasks<TurboTasksBackend<Either<DefaultBackingStorage, NoopBackingStorage>>>>;\n \n #[derive(Serialize)]\n struct StartupCacheInvalidationEvent {\n@@ -212,7 +82,7 @@ pub fn create_turbo_tasks(\n         };\n         let (backing_storage, cache_state) =\n             default_backing_storage(&output_path.join(\"cache/turbopack\"), &version_info, is_ci)?;\n-        let tt = TurboTasks::new(turbo_tasks_backend::TurboTasksBackend::new(\n+        let tt = TurboTasks::new(TurboTasksBackend::new(\n             turbo_tasks_backend::BackendOptions {\n                 storage_mode: Some(if std::env::var(\"TURBO_ENGINE_READ_ONLY\").is_ok() {\n                     turbo_tasks_backend::StorageMode::ReadOnly\n@@ -222,22 +92,20 @@ pub fn create_turbo_tasks(\n                 dependency_tracking,\n                 ..Default::default()\n             },\n-            backing_storage,\n+            Either::Left(backing_storage),\n         ));\n         if let StartupCacheState::Invalidated { reason_code } = cache_state {\n             tt.send_compilation_event(Arc::new(StartupCacheInvalidationEvent { reason_code }));\n         }\n-        NextTurboTasks::PersistentCaching(tt)\n+        tt\n     } else {\n-        NextTurboTasks::Memory(TurboTasks::new(\n-            turbo_tasks_backend::TurboTasksBackend::new(\n-                turbo_tasks_backend::BackendOptions {\n-                    storage_mode: None,\n-                    dependency_tracking,\n-                    ..Default::default()\n-                },\n-                noop_backing_storage(),\n-            ),\n+        TurboTasks::new(TurboTasksBackend::new(\n+            turbo_tasks_backend::BackendOptions {\n+                storage_mode: None,\n+                dependency_tracking,\n+                ..Default::default()\n+            },\n+            Either::Right(noop_backing_storage()),\n         ))\n     })\n }"
        },
        {
            "sha": "5deeecad6ea0c93befb6a56dda6f1d8f17e772d1",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/6951729f435f130c11d436ed9b8dabea253a0ee2/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/6951729f435f130c11d436ed9b8dabea253a0ee2/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=6951729f435f130c11d436ed9b8dabea253a0ee2",
            "patch": "@@ -894,8 +894,8 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         let process = |task_id: TaskId, (meta, data): (Option<Vec<_>>, Option<Vec<_>>)| {\n             (\n                 task_id,\n-                meta.map(|d| B::serialize(task_id, &d)),\n-                data.map(|d| B::serialize(task_id, &d)),\n+                meta.map(|d| self.backing_storage.serialize(task_id, &d)),\n+                data.map(|d| self.backing_storage.serialize(task_id, &d)),\n             )\n         };\n         let process_snapshot = |task_id: TaskId, inner: Box<InnerStorageSnapshot>| {\n@@ -924,8 +924,8 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             }\n             (\n                 task_id,\n-                meta.map(|meta| B::serialize(task_id, &meta)),\n-                data.map(|data| B::serialize(task_id, &data)),\n+                meta.map(|meta| self.backing_storage.serialize(task_id, &meta)),\n+                data.map(|data| self.backing_storage.serialize(task_id, &data)),\n             )\n         };\n "
        },
        {
            "sha": "7f597fe3ecf9eb0a3a77d163cfd707d23eabd78b",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backing_storage.rs",
            "status": "modified",
            "additions": 147,
            "deletions": 2,
            "changes": 149,
            "blob_url": "https://github.com/vercel/next.js/blob/6951729f435f130c11d436ed9b8dabea253a0ee2/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbacking_storage.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/6951729f435f130c11d436ed9b8dabea253a0ee2/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbacking_storage.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbacking_storage.rs?ref=6951729f435f130c11d436ed9b8dabea253a0ee2",
            "patch": "@@ -1,6 +1,7 @@\n-use std::sync::Arc;\n+use std::{any::type_name, sync::Arc};\n \n use anyhow::Result;\n+use either::Either;\n use smallvec::SmallVec;\n use turbo_tasks::{SessionId, TaskId, backend::CachedTaskType};\n \n@@ -45,7 +46,7 @@ pub trait BackingStorageSealed: 'static + Send + Sync {\n     fn next_session_id(&self) -> Result<SessionId>;\n     fn uncompleted_operations(&self) -> Result<Vec<AnyOperation>>;\n     #[allow(clippy::ptr_arg)]\n-    fn serialize(task: TaskId, data: &Vec<CachedDataItem>) -> Result<SmallVec<[u8; 16]>>;\n+    fn serialize(&self, task: TaskId, data: &Vec<CachedDataItem>) -> Result<SmallVec<[u8; 16]>>;\n     fn save_snapshot<I>(\n         &self,\n         session_id: SessionId,\n@@ -93,3 +94,147 @@ pub trait BackingStorageSealed: 'static + Send + Sync {\n         Ok(())\n     }\n }\n+\n+impl<L, R> BackingStorage for Either<L, R>\n+where\n+    L: BackingStorage,\n+    R: BackingStorage,\n+{\n+    fn invalidate(&self, reason_code: &str) -> Result<()> {\n+        either::for_both!(self, this => this.invalidate(reason_code))\n+    }\n+}\n+\n+impl<L, R> BackingStorageSealed for Either<L, R>\n+where\n+    L: BackingStorageSealed,\n+    R: BackingStorageSealed,\n+{\n+    type ReadTransaction<'l> = Either<L::ReadTransaction<'l>, R::ReadTransaction<'l>>;\n+\n+    fn next_free_task_id(&self) -> Result<TaskId> {\n+        either::for_both!(self, this => this.next_free_task_id())\n+    }\n+\n+    fn next_session_id(&self) -> Result<SessionId> {\n+        either::for_both!(self, this => this.next_session_id())\n+    }\n+\n+    fn uncompleted_operations(&self) -> Result<Vec<AnyOperation>> {\n+        either::for_both!(self, this => this.uncompleted_operations())\n+    }\n+\n+    fn serialize(&self, task: TaskId, data: &Vec<CachedDataItem>) -> Result<SmallVec<[u8; 16]>> {\n+        either::for_both!(self, this => this.serialize(task, data))\n+    }\n+\n+    fn save_snapshot<I>(\n+        &self,\n+        session_id: SessionId,\n+        operations: Vec<Arc<AnyOperation>>,\n+        task_cache_updates: Vec<ChunkedVec<(Arc<CachedTaskType>, TaskId)>>,\n+        snapshots: Vec<I>,\n+    ) -> Result<()>\n+    where\n+        I: Iterator<\n+                Item = (\n+                    TaskId,\n+                    Option<SmallVec<[u8; 16]>>,\n+                    Option<SmallVec<[u8; 16]>>,\n+                ),\n+            > + Send\n+            + Sync,\n+    {\n+        either::for_both!(self, this => this.save_snapshot(\n+            session_id,\n+            operations,\n+            task_cache_updates,\n+            snapshots,\n+        ))\n+    }\n+\n+    fn start_read_transaction(&self) -> Option<Self::ReadTransaction<'_>> {\n+        Some(match self {\n+            Either::Left(this) => Either::Left(this.start_read_transaction()?),\n+            Either::Right(this) => Either::Right(this.start_read_transaction()?),\n+        })\n+    }\n+\n+    unsafe fn forward_lookup_task_cache(\n+        &self,\n+        tx: Option<&Self::ReadTransaction<'_>>,\n+        key: &CachedTaskType,\n+    ) -> Result<Option<TaskId>> {\n+        match self {\n+            Either::Left(this) => {\n+                let tx = tx.map(|tx| read_transaction_left_or_panic(tx.as_ref()));\n+                unsafe { this.forward_lookup_task_cache(tx, key) }\n+            }\n+            Either::Right(this) => {\n+                let tx = tx.map(|tx| read_transaction_right_or_panic(tx.as_ref()));\n+                unsafe { this.forward_lookup_task_cache(tx, key) }\n+            }\n+        }\n+    }\n+\n+    unsafe fn reverse_lookup_task_cache(\n+        &self,\n+        tx: Option<&Self::ReadTransaction<'_>>,\n+        task_id: TaskId,\n+    ) -> Result<Option<Arc<CachedTaskType>>> {\n+        match self {\n+            Either::Left(this) => {\n+                let tx = tx.map(|tx| read_transaction_left_or_panic(tx.as_ref()));\n+                unsafe { this.reverse_lookup_task_cache(tx, task_id) }\n+            }\n+            Either::Right(this) => {\n+                let tx = tx.map(|tx| read_transaction_right_or_panic(tx.as_ref()));\n+                unsafe { this.reverse_lookup_task_cache(tx, task_id) }\n+            }\n+        }\n+    }\n+\n+    unsafe fn lookup_data(\n+        &self,\n+        tx: Option<&Self::ReadTransaction<'_>>,\n+        task_id: TaskId,\n+        category: TaskDataCategory,\n+    ) -> Result<Vec<CachedDataItem>> {\n+        match self {\n+            Either::Left(this) => {\n+                let tx = tx.map(|tx| read_transaction_left_or_panic(tx.as_ref()));\n+                unsafe { this.lookup_data(tx, task_id, category) }\n+            }\n+            Either::Right(this) => {\n+                let tx = tx.map(|tx| read_transaction_right_or_panic(tx.as_ref()));\n+                unsafe { this.lookup_data(tx, task_id, category) }\n+            }\n+        }\n+    }\n+}\n+\n+// similar to `Either::unwrap_left`, but does not require `R: Debug`.\n+fn read_transaction_left_or_panic<L, R>(either: Either<L, R>) -> L {\n+    match either {\n+        Either::Left(l) => l,\n+        Either::Right(_) => panic!(\n+            \"expected ReadTransaction of Either::Left containing {}, received Either::Right type \\\n+             of {}\",\n+            type_name::<L>(),\n+            type_name::<R>(),\n+        ),\n+    }\n+}\n+\n+// similar to `Either::unwrap_right`, but does not require `R: Debug`.\n+fn read_transaction_right_or_panic<L, R>(either: Either<L, R>) -> R {\n+    match either {\n+        Either::Left(_) => panic!(\n+            \"expected ReadTransaction of Either::Right containing {}, received Either::Left type \\\n+             of {}\",\n+            type_name::<R>(),\n+            type_name::<L>(),\n+        ),\n+        Either::Right(r) => r,\n+    }\n+}"
        },
        {
            "sha": "126be9e6f8f2bf3a4d72dd0d76ee5064895c7ebb",
            "filename": "turbopack/crates/turbo-tasks-backend/src/kv_backing_storage.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/6951729f435f130c11d436ed9b8dabea253a0ee2/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fkv_backing_storage.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/6951729f435f130c11d436ed9b8dabea253a0ee2/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fkv_backing_storage.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fkv_backing_storage.rs?ref=6951729f435f130c11d436ed9b8dabea253a0ee2",
            "patch": "@@ -298,7 +298,7 @@ impl<T: KeyValueDatabase + Send + Sync + 'static> BackingStorageSealed\n         get(&self.inner.database).context(\"Unable to read uncompleted operations from database\")\n     }\n \n-    fn serialize(task: TaskId, data: &Vec<CachedDataItem>) -> Result<SmallVec<[u8; 16]>> {\n+    fn serialize(&self, task: TaskId, data: &Vec<CachedDataItem>) -> Result<SmallVec<[u8; 16]>> {\n         serialize(task, data)\n     }\n "
        }
    ],
    "stats": {
        "total": 342,
        "additions": 180,
        "deletions": 162
    }
}