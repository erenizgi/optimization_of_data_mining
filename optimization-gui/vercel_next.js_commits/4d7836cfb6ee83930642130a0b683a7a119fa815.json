{
    "author": "sokra",
    "message": "Turbopack: use small thread local collector that flushes to global collector (#78343)\n\n### What?\r\n\r\nStoring many large thread local collectors can lead to high memory usage on systems with many cores. It also unnecessarily delays writing out files to disk.\r\n\r\nThis changes this to use very small thread local collector that flushes to a single global collector (per key family). The small thread local collectors still avoid contention. This also creates more compact files.",
    "sha": "4d7836cfb6ee83930642130a0b683a7a119fa815",
    "files": [
        {
            "sha": "86ac0daab07a2ced57a71eaf46bf03931d47e1c0",
            "filename": "turbopack/crates/turbo-persistence/src/collector.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 10,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/4d7836cfb6ee83930642130a0b683a7a119fa815/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fcollector.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4d7836cfb6ee83930642130a0b683a7a119fa815/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fcollector.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fcollector.rs?ref=4d7836cfb6ee83930642130a0b683a7a119fa815",
            "patch": "@@ -9,19 +9,19 @@ use crate::{\n \n /// A collector accumulates entries that should be eventually written to a file. It keeps track of\n /// count and size of the entries to decide when it's \"full\". Accessing the entries sorts them.\n-pub struct Collector<K: StoreKey> {\n+pub struct Collector<K: StoreKey, const SIZE_SHIFT: usize = 0> {\n     total_key_size: usize,\n     total_value_size: usize,\n     entries: Vec<CollectorEntry<K>>,\n }\n \n-impl<K: StoreKey> Collector<K> {\n+impl<K: StoreKey, const SIZE_SHIFT: usize> Collector<K, SIZE_SHIFT> {\n     /// Creates a new collector. Note that this allocates the full capacity for the entries.\n     pub fn new() -> Self {\n         Self {\n             total_key_size: 0,\n             total_value_size: 0,\n-            entries: Vec::with_capacity(MAX_ENTRIES_PER_INITIAL_FILE),\n+            entries: Vec::with_capacity(MAX_ENTRIES_PER_INITIAL_FILE >> SIZE_SHIFT),\n         }\n     }\n \n@@ -32,8 +32,9 @@ impl<K: StoreKey> Collector<K> {\n \n     /// Returns true if the collector is full.\n     pub fn is_full(&self) -> bool {\n-        self.entries.len() >= MAX_ENTRIES_PER_INITIAL_FILE\n-            || self.total_key_size + self.total_value_size > DATA_THRESHOLD_PER_INITIAL_FILE\n+        self.entries.len() >= MAX_ENTRIES_PER_INITIAL_FILE >> SIZE_SHIFT\n+            || self.total_key_size + self.total_value_size\n+                > DATA_THRESHOLD_PER_INITIAL_FILE >> SIZE_SHIFT\n     }\n \n     /// Adds a normal key-value pair to the collector.\n@@ -110,9 +111,4 @@ impl<K: StoreKey> Collector<K> {\n         self.total_value_size = 0;\n         self.entries.drain(..)\n     }\n-\n-    /// Returns the number of entries in the collector.\n-    pub fn len(&self) -> usize {\n-        self.entries.len()\n-    }\n }"
        },
        {
            "sha": "9a46fa00a31e333e4c1a65d0d8df256a181c98cc",
            "filename": "turbopack/crates/turbo-persistence/src/constants.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/4d7836cfb6ee83930642130a0b683a7a119fa815/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fconstants.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4d7836cfb6ee83930642130a0b683a7a119fa815/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fconstants.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fconstants.rs?ref=4d7836cfb6ee83930642130a0b683a7a119fa815",
            "patch": "@@ -17,6 +17,10 @@ pub const DATA_THRESHOLD_PER_INITIAL_FILE: usize = 256 * 1024 * 1024;\n /// Finish file when total amount of data exceeds this\n pub const DATA_THRESHOLD_PER_COMPACTED_FILE: usize = 256 * 1024 * 1024;\n \n+/// Reduction factor (as bit shift) for the size of the thread-local buffer as shift of\n+/// MAX_ENTRIES_PER_INITIAL_FILE and DATA_THRESHOLD_PER_INITIAL_FILE.\n+pub const THREAD_LOCAL_SIZE_SHIFT: usize = 7;\n+\n /// Maximum RAM bytes for AQMF cache\n pub const AQMF_CACHE_SIZE: u64 = 300 * 1024 * 1024;\n pub const AQMF_AVG_SIZE: usize = 37399;"
        },
        {
            "sha": "6a62c4cdb0a93c79cd7d13b9d02ff41446ffe8a8",
            "filename": "turbopack/crates/turbo-persistence/src/write_batch.rs",
            "status": "modified",
            "additions": 115,
            "deletions": 105,
            "changes": 220,
            "blob_url": "https://github.com/vercel/next.js/blob/4d7836cfb6ee83930642130a0b683a7a119fa815/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fwrite_batch.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4d7836cfb6ee83930642130a0b683a7a119fa815/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fwrite_batch.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fwrite_batch.rs?ref=4d7836cfb6ee83930642130a0b683a7a119fa815",
            "patch": "@@ -2,7 +2,7 @@ use std::{\n     cell::UnsafeCell,\n     fs::File,\n     io::Write,\n-    mem::{replace, swap},\n+    mem::{replace, take},\n     path::PathBuf,\n     sync::atomic::{AtomicU32, Ordering},\n };\n@@ -13,13 +13,18 @@ use lzzzz::lz4::{self, ACC_LEVEL_DEFAULT};\n use parking_lot::Mutex;\n use rayon::{\n     iter::{IndexedParallelIterator, IntoParallelIterator, ParallelIterator},\n-    scope, Scope,\n+    scope,\n };\n+use smallvec::SmallVec;\n use thread_local::ThreadLocal;\n \n use crate::{\n-    collector::Collector, collector_entry::CollectorEntry, constants::MAX_MEDIUM_VALUE_SIZE,\n-    key::StoreKey, static_sorted_file_builder::StaticSortedFileBuilder, ValueBuffer,\n+    collector::Collector,\n+    collector_entry::CollectorEntry,\n+    constants::{MAX_MEDIUM_VALUE_SIZE, THREAD_LOCAL_SIZE_SHIFT},\n+    key::StoreKey,\n+    static_sorted_file_builder::StaticSortedFileBuilder,\n+    ValueBuffer,\n };\n \n /// The thread local state of a `WriteBatch`. `FAMILIES` should fit within a `u32`.\n@@ -29,10 +34,7 @@ use crate::{\n // `min_generic_const_args` feature.\n struct ThreadLocalState<K: StoreKey + Send, const FAMILIES: usize> {\n     /// The collectors for each family.\n-    collectors: [Option<Collector<K>>; FAMILIES],\n-    /// The list of new SST files that have been created.\n-    /// Tuple of (sequence number, file).\n-    new_sst_files: Vec<(u32, File)>,\n+    collectors: [Option<Collector<K, THREAD_LOCAL_SIZE_SHIFT>>; FAMILIES],\n     /// The list of new blob files that have been created.\n     /// Tuple of (sequence number, file).\n     new_blob_files: Vec<(u32, File)>,\n@@ -55,8 +57,15 @@ pub struct WriteBatch<K: StoreKey + Send, const FAMILIES: usize> {\n     current_sequence_number: AtomicU32,\n     /// The thread local state.\n     thread_locals: ThreadLocal<UnsafeCell<ThreadLocalState<K, FAMILIES>>>,\n-    /// Collectors are are current unused, but have memory preallocated.\n+    /// Collectors in use. The thread local collectors flush into these when they are full.\n+    collectors: [Mutex<Collector<K>>; FAMILIES],\n+    /// The list of new SST files that have been created.\n+    /// Tuple of (sequence number, file).\n+    new_sst_files: Mutex<Vec<(u32, File)>>,\n+    /// Collectors that are currently unused, but have memory preallocated.\n     idle_collectors: Mutex<Vec<Collector<K>>>,\n+    /// Collectors that are currently unused, but have memory preallocated.\n+    idle_thread_local_collectors: Mutex<Vec<Collector<K, THREAD_LOCAL_SIZE_SHIFT>>>,\n }\n \n impl<K: StoreKey + Send + Sync, const FAMILIES: usize> WriteBatch<K, FAMILIES> {\n@@ -69,7 +78,10 @@ impl<K: StoreKey + Send + Sync, const FAMILIES: usize> WriteBatch<K, FAMILIES> {\n             path,\n             current_sequence_number: AtomicU32::new(current),\n             thread_locals: ThreadLocal::new(),\n+            collectors: [(); FAMILIES].map(|_| Mutex::new(Collector::new())),\n+            new_sst_files: Mutex::new(Vec::new()),\n             idle_collectors: Mutex::new(Vec::new()),\n+            idle_thread_local_collectors: Mutex::new(Vec::new()),\n         }\n     }\n \n@@ -86,7 +98,6 @@ impl<K: StoreKey + Send + Sync, const FAMILIES: usize> WriteBatch<K, FAMILIES> {\n         let cell = self.thread_locals.get_or(|| {\n             UnsafeCell::new(ThreadLocalState {\n                 collectors: [const { None }; FAMILIES],\n-                new_sst_files: Vec::new(),\n                 new_blob_files: Vec::new(),\n             })\n         });\n@@ -95,31 +106,59 @@ impl<K: StoreKey + Send + Sync, const FAMILIES: usize> WriteBatch<K, FAMILIES> {\n     }\n \n     /// Returns the collector for a family for the current thread.\n-    fn collector_mut<'l>(\n+    fn thread_local_collector_mut<'l>(\n         &self,\n         state: &'l mut ThreadLocalState<K, FAMILIES>,\n         family: u32,\n-    ) -> Result<&'l mut Collector<K>> {\n-        let family_idx = usize_from_u32(family);\n-        debug_assert!(family_idx < FAMILIES);\n-        let collector = state.collectors[family_idx].get_or_insert_with(|| {\n-            self.idle_collectors\n+    ) -> Result<&'l mut Collector<K, THREAD_LOCAL_SIZE_SHIFT>> {\n+        debug_assert!(usize_from_u32(family) < FAMILIES);\n+        let collector = state.collectors[usize_from_u32(family)].get_or_insert_with(|| {\n+            self.idle_thread_local_collectors\n                 .lock()\n                 .pop()\n                 .unwrap_or_else(|| Collector::new())\n         });\n         if collector.is_full() {\n-            let sst = self.create_sst_file(family, collector.sorted())?;\n-            collector.clear();\n-            state.new_sst_files.push(sst);\n+            self.flush_thread_local_collector(family, collector)?;\n         }\n         Ok(collector)\n     }\n \n+    fn flush_thread_local_collector(\n+        &self,\n+        family: u32,\n+        collector: &mut Collector<K, THREAD_LOCAL_SIZE_SHIFT>,\n+    ) -> Result<()> {\n+        let mut full_collectors = SmallVec::<[_; 2]>::new();\n+        {\n+            let mut global_collector = self.collectors[usize_from_u32(family)].lock();\n+            for entry in collector.drain() {\n+                global_collector.add_entry(entry);\n+                if global_collector.is_full() {\n+                    full_collectors.push(replace(\n+                        &mut *global_collector,\n+                        self.idle_collectors\n+                            .lock()\n+                            .pop()\n+                            .unwrap_or_else(|| Collector::new()),\n+                    ));\n+                }\n+            }\n+        }\n+        for mut global_collector in full_collectors {\n+            // When the global collector is full, we create a new SST file.\n+            let sst = self.create_sst_file(family, global_collector.sorted())?;\n+            global_collector.clear();\n+            self.new_sst_files.lock().push(sst);\n+            self.idle_collectors.lock().push(global_collector);\n+        }\n+        Ok(())\n+    }\n+\n     /// Puts a key-value pair into the write batch.\n     pub fn put(&self, family: u32, key: K, value: ValueBuffer<'_>) -> Result<()> {\n         let state = self.thread_local_state();\n-        let collector = self.collector_mut(state, family)?;\n+        let collector = self.thread_local_collector_mut(state, family)?;\n         if value.len() <= MAX_MEDIUM_VALUE_SIZE {\n             collector.put(key, value);\n         } else {\n@@ -133,106 +172,77 @@ impl<K: StoreKey + Send + Sync, const FAMILIES: usize> WriteBatch<K, FAMILIES> {\n     /// Puts a delete operation into the write batch.\n     pub fn delete(&self, family: u32, key: K) -> Result<()> {\n         let state = self.thread_local_state();\n-        let collector = self.collector_mut(state, family)?;\n+        let collector = self.thread_local_collector_mut(state, family)?;\n         collector.delete(key);\n         Ok(())\n     }\n \n     /// Finishes the write batch by returning the new sequence number and the new SST files. This\n     /// writes all outstanding thread local data to disk.\n     pub(crate) fn finish(&mut self) -> Result<FinishResult> {\n-        let mut new_sst_files = Vec::new();\n         let mut new_blob_files = Vec::new();\n-        let mut all_collectors = [(); FAMILIES].map(|_| Vec::new());\n-        for cell in self.thread_locals.iter_mut() {\n-            let state = cell.get_mut();\n-            new_sst_files.append(&mut state.new_sst_files);\n-            new_blob_files.append(&mut state.new_blob_files);\n-            for (family, global_collector) in all_collectors.iter_mut().enumerate() {\n-                if let Some(collector) = state.collectors[family].take() {\n-                    if !collector.is_empty() {\n-                        global_collector.push(Some(collector));\n-                    }\n-                }\n-            }\n-        }\n-        let shared_new_sst_files = Mutex::new(&mut new_sst_files);\n         let shared_error = Mutex::new(Ok(()));\n+\n+        // First, we flush all thread local collectors to the global collectors.\n         scope(|scope| {\n-            fn handle_done_collector<'scope, K: StoreKey + Send + Sync, const FAMILIES: usize>(\n-                this: &'scope WriteBatch<K, FAMILIES>,\n-                scope: &Scope<'scope>,\n-                family: u32,\n-                mut collector: Collector<K>,\n-                shared_new_sst_files: &'scope Mutex<&mut Vec<(u32, File)>>,\n-                shared_error: &'scope Mutex<Result<()>>,\n-            ) {\n-                scope.spawn(\n-                    move |_| match this.create_sst_file(family, collector.sorted()) {\n-                        Ok(sst) => {\n-                            collector.clear();\n-                            this.idle_collectors.lock().push(collector);\n-                            shared_new_sst_files.lock().push(sst);\n+            let mut collectors = [const { Vec::new() }; FAMILIES];\n+            for cell in self.thread_locals.iter_mut() {\n+                let state = cell.get_mut();\n+                new_blob_files.append(&mut state.new_blob_files);\n+                for (family, thread_local_collector) in state.collectors.iter_mut().enumerate() {\n+                    if let Some(collector) = thread_local_collector.take() {\n+                        if !collector.is_empty() {\n+                            collectors[family].push(collector);\n                         }\n-                        Err(err) => {\n+                    }\n+                }\n+            }\n+            for (family, thread_local_collectors) in collectors.into_iter().enumerate() {\n+                for mut collector in thread_local_collectors {\n+                    let this = &self;\n+                    let shared_error = &shared_error;\n+                    scope.spawn(move |_| {\n+                        if let Err(err) =\n+                            this.flush_thread_local_collector(family as u32, &mut collector)\n+                        {\n                             *shared_error.lock() = Err(err);\n                         }\n-                    },\n-                );\n+                        this.idle_thread_local_collectors.lock().push(collector);\n+                    });\n+                }\n             }\n-\n-            all_collectors\n-                .into_par_iter()\n-                .enumerate()\n-                .for_each(|(family_idx, collectors)| {\n-                    let family = u32::try_from(family_idx).unwrap();\n-                    let final_collector = collectors.into_par_iter().reduce(\n-                        || None,\n-                        |a, b| match (a, b) {\n-                            (Some(mut a), Some(mut b)) => {\n-                                if a.len() < b.len() {\n-                                    swap(&mut a, &mut b);\n-                                }\n-                                for entry in b.drain() {\n-                                    if a.is_full() {\n-                                        let full_collector = replace(\n-                                            &mut a,\n-                                            self.idle_collectors\n-                                                .lock()\n-                                                .pop()\n-                                                .unwrap_or_else(|| Collector::new()),\n-                                        );\n-                                        handle_done_collector(\n-                                            self,\n-                                            scope,\n-                                            family,\n-                                            full_collector,\n-                                            &shared_new_sst_files,\n-                                            &shared_error,\n-                                        );\n-                                    }\n-                                    a.add_entry(entry);\n-                                }\n-                                self.idle_collectors.lock().push(b);\n-                                Some(a)\n-                            }\n-                            (Some(a), None) => Some(a),\n-                            (None, Some(b)) => Some(b),\n-                            (None, None) => None,\n-                        },\n-                    );\n-                    if let Some(collector) = final_collector {\n-                        handle_done_collector(\n-                            self,\n-                            scope,\n-                            family,\n-                            collector,\n-                            &shared_new_sst_files,\n-                            &shared_error,\n-                        );\n-                    }\n-                });\n         });\n+\n+        // Now we reduce the global collectors in parallel\n+        let mut new_sst_files = take(self.new_sst_files.get_mut());\n+        let shared_new_sst_files = Mutex::new(&mut new_sst_files);\n+\n+        let collectors = replace(\n+            &mut self.collectors,\n+            [(); FAMILIES].map(|_| {\n+                Mutex::new(\n+                    self.idle_collectors\n+                        .lock()\n+                        .pop()\n+                        .unwrap_or_else(|| Collector::new()),\n+                )\n+            }),\n+        );\n+        collectors\n+            .into_par_iter()\n+            .enumerate()\n+            .try_for_each(|(family, collector)| {\n+                let family = family as u32;\n+                let mut collector = collector.into_inner();\n+                if !collector.is_empty() {\n+                    let sst = self.create_sst_file(family, collector.sorted())?;\n+                    collector.clear();\n+                    self.idle_collectors.lock().push(collector);\n+                    shared_new_sst_files.lock().push(sst);\n+                }\n+                anyhow::Ok(())\n+            })?;\n+\n         shared_error.into_inner()?;\n         let seq = self.current_sequence_number.load(Ordering::SeqCst);\n         new_sst_files.sort_by_key(|(seq, _)| *seq);"
        }
    ],
    "stats": {
        "total": 240,
        "additions": 125,
        "deletions": 115
    }
}