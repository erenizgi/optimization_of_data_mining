{
    "author": "sokra",
    "message": "Turbopack: improve compression dictionary generation (#80061)\n\n### What?\n\nImprove the generation of the compression dictionary.",
    "sha": "531e9384fec4f504b87136a9a4ca1e4e3adc8c6d",
    "files": [
        {
            "sha": "e9ec0076bd3314ccf97148e4e44d54450dd620fa",
            "filename": "turbopack/crates/turbo-persistence/src/static_sorted_file_builder.rs",
            "status": "modified",
            "additions": 54,
            "deletions": 44,
            "changes": 98,
            "blob_url": "https://github.com/vercel/next.js/blob/531e9384fec4f504b87136a9a4ca1e4e3adc8c6d/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fstatic_sorted_file_builder.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/531e9384fec4f504b87136a9a4ca1e4e3adc8c6d/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fstatic_sorted_file_builder.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fstatic_sorted_file_builder.rs?ref=531e9384fec4f504b87136a9a4ca1e4e3adc8c6d",
            "patch": "@@ -1,6 +1,6 @@\n use std::{\n     borrow::Cow,\n-    cmp::min,\n+    cmp::{max, min},\n     fs::File,\n     io::{self, BufWriter, Seek, Write},\n     path::Path,\n@@ -45,6 +45,8 @@ const MIN_VALUE_COMPRESSION_SAMPLES_SIZE: usize = 1024;\n const MIN_KEY_COMPRESSION_SAMPLES_SIZE: usize = 1024;\n /// The bytes that are used per key/value entry for a sample.\n const COMPRESSION_DICTIONARY_SAMPLE_PER_ENTRY: usize = 100;\n+/// The minimum bytes that are used per key/value entry for a sample.\n+const MIN_COMPRESSION_DICTIONARY_SAMPLE_PER_ENTRY: usize = 16;\n \n /// Trait for entries from that SST files can be created\n pub trait Entry {\n@@ -153,58 +155,75 @@ impl<'a> StaticSortedFileBuilder<'a> {\n         {\n             return Ok(());\n         }\n-        let key_compression_samples_size = min(KEY_COMPRESSION_SAMPLES_SIZE, total_key_size / 10);\n+        let key_compression_samples_size = min(KEY_COMPRESSION_SAMPLES_SIZE, total_key_size / 16);\n         let value_compression_samples_size =\n-            min(VALUE_COMPRESSION_SAMPLES_SIZE, total_value_size / 10);\n+            min(VALUE_COMPRESSION_SAMPLES_SIZE, total_value_size / 16);\n         let mut value_samples = Vec::with_capacity(value_compression_samples_size);\n         let mut value_sample_sizes = Vec::new();\n         let mut key_samples = Vec::with_capacity(key_compression_samples_size);\n         let mut key_sample_sizes = Vec::new();\n-        let mut i = 12345678 % entries.len();\n-        let mut j = 0;\n-        loop {\n-            let entry = &entries[i];\n+\n+        // Limit the number of iterations to avoid infinite loops\n+        let max_iterations =\n+            max(total_key_size, total_value_size) / COMPRESSION_DICTIONARY_SAMPLE_PER_ENTRY * 2;\n+        for i in 0..max_iterations {\n+            let entry = &entries[i % entries.len()];\n             let value_remaining = value_compression_samples_size - value_samples.len();\n-            let key_remaining = key_compression_samples_size - key_samples.len();\n-            if value_remaining > 0\n-                && let EntryValue::Small { value } | EntryValue::Medium { value } = entry.value()\n-            {\n-                let value = if value.len() <= COMPRESSION_DICTIONARY_SAMPLE_PER_ENTRY {\n-                    value\n-                } else {\n-                    j = (j + 12345678) % (value.len() - COMPRESSION_DICTIONARY_SAMPLE_PER_ENTRY);\n-                    &value[j..j + COMPRESSION_DICTIONARY_SAMPLE_PER_ENTRY]\n-                };\n-                if value.len() <= value_remaining {\n-                    value_sample_sizes.push(value.len());\n-                    value_samples.extend_from_slice(value);\n-                } else {\n-                    value_sample_sizes.push(value_remaining);\n-                    value_samples.extend_from_slice(&value[..value_remaining]);\n+            if value_remaining < MIN_COMPRESSION_DICTIONARY_SAMPLE_PER_ENTRY {\n+                break;\n+            }\n+            if let EntryValue::Small { value } | EntryValue::Medium { value } = entry.value() {\n+                let len = value.len();\n+                if len >= MIN_COMPRESSION_DICTIONARY_SAMPLE_PER_ENTRY {\n+                    let used_len = min(value_remaining, COMPRESSION_DICTIONARY_SAMPLE_PER_ENTRY);\n+                    if len <= used_len {\n+                        value_sample_sizes.push(len);\n+                        value_samples.extend_from_slice(value);\n+                    } else {\n+                        value_sample_sizes.push(used_len);\n+                        let p = value_samples.len() % (len - used_len);\n+                        value_samples.extend_from_slice(&value[p..p + used_len]);\n+                    };\n                 }\n             }\n-            if key_remaining > 0 {\n+        }\n+        assert!(value_samples.len() == value_sample_sizes.iter().sum::<usize>());\n+        if value_samples.len() > MIN_VALUE_COMPRESSION_SAMPLES_SIZE && value_sample_sizes.len() > 5\n+        {\n+            self.value_compression_dictionary = zstd::dict::from_continuous(\n+                &value_samples,\n+                &value_sample_sizes,\n+                VALUE_COMPRESSION_DICTIONARY_SIZE,\n+            )\n+            .context(\"Value dictionary creation failed\")?;\n+        } else {\n+            self.value_compression_dictionary = Vec::new();\n+        }\n+\n+        for i in 0..max_iterations {\n+            let entry = &entries[i % entries.len()];\n+            let key_remaining = key_compression_samples_size - key_samples.len();\n+            if key_remaining < MIN_COMPRESSION_DICTIONARY_SAMPLE_PER_ENTRY {\n+                break;\n+            }\n+            let len = entry.key_len();\n+            if len >= MIN_COMPRESSION_DICTIONARY_SAMPLE_PER_ENTRY {\n                 let used_len = min(key_remaining, COMPRESSION_DICTIONARY_SAMPLE_PER_ENTRY);\n-                if entry.key_len() <= used_len {\n-                    key_sample_sizes.push(entry.key_len());\n+                if len <= used_len {\n+                    key_sample_sizes.push(len);\n                     entry.write_key_to(&mut key_samples);\n                 } else {\n-                    let mut temp = Vec::with_capacity(entry.key_len());\n+                    let mut temp = Vec::with_capacity(len);\n                     entry.write_key_to(&mut temp);\n-                    debug_assert!(temp.len() == entry.key_len());\n+                    debug_assert!(temp.len() == len);\n \n-                    j = (j + 12345678) % (temp.len() - used_len);\n+                    let p = key_samples.len() % (len - used_len);\n                     key_sample_sizes.push(used_len);\n-                    key_samples.extend_from_slice(&temp[j..j + used_len]);\n+                    key_samples.extend_from_slice(&temp[p..p + used_len]);\n                 }\n             }\n-            if key_remaining == 0 && value_remaining == 0 {\n-                break;\n-            }\n-            i = (i + 12345678) % entries.len();\n         }\n         assert!(key_samples.len() == key_sample_sizes.iter().sum::<usize>());\n-        assert!(value_samples.len() == value_sample_sizes.iter().sum::<usize>());\n         if key_samples.len() > MIN_KEY_COMPRESSION_SAMPLES_SIZE && key_sample_sizes.len() > 5 {\n             self.key_compression_dictionary = zstd::dict::from_continuous(\n                 &key_samples,\n@@ -213,15 +232,6 @@ impl<'a> StaticSortedFileBuilder<'a> {\n             )\n             .context(\"Key dictionary creation failed\")?;\n         }\n-        if value_samples.len() > MIN_VALUE_COMPRESSION_SAMPLES_SIZE && value_sample_sizes.len() > 5\n-        {\n-            self.value_compression_dictionary = zstd::dict::from_continuous(\n-                &value_samples,\n-                &value_sample_sizes,\n-                VALUE_COMPRESSION_DICTIONARY_SIZE,\n-            )\n-            .context(\"Value dictionary creation failed\")?;\n-        }\n         Ok(())\n     }\n "
        }
    ],
    "stats": {
        "total": 98,
        "additions": 54,
        "deletions": 44
    }
}