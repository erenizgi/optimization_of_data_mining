{
    "author": "lukesandberg",
    "message": "[turbopack] Remove some unnecessary awaits now that FileSystemPath is synchronously available. (#81090)\n\n### Remove some unnecessary awaits now that FileSystemPath is synchronously available.\n\n### What?\n\n* Remove `async` from `ContextCondition::matches` simplifying the implementation and eliminating a bunch of temporary allocations\n* Remove some unnecessary FileSystemPath clones\n* Remove recursion from `resolve::base_options` this function really just wants the FileSystem::root so require that instead\n* Share the same same `cell` for most of the node externals\n\n### Why?\n\nNoticed this while reviewing the `resovle` codebase.  I expect them to by negligible perf wins, but wins nontheless",
    "sha": "1fc2dfb2fa3cc927bc08912e2396313b9d728f6c",
    "files": [
        {
            "sha": "3620f2f7933dbf3dd6ef427b0ffc2dd2b6b24c89",
            "filename": "turbopack/crates/turbopack-core/src/condition.rs",
            "status": "modified",
            "additions": 14,
            "deletions": 26,
            "changes": 40,
            "blob_url": "https://github.com/vercel/next.js/blob/1fc2dfb2fa3cc927bc08912e2396313b9d728f6c/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fcondition.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1fc2dfb2fa3cc927bc08912e2396313b9d728f6c/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fcondition.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fcondition.rs?ref=1fc2dfb2fa3cc927bc08912e2396313b9d728f6c",
            "patch": "@@ -1,5 +1,3 @@\n-use anyhow::Result;\n-use futures::{StreamExt, stream};\n use serde::{Deserialize, Serialize};\n use turbo_tasks::{NonLocalValue, trace::TraceRawVcs};\n use turbo_tasks_fs::FileSystemPath;\n@@ -31,32 +29,22 @@ impl ContextCondition {\n     }\n \n     /// Returns true if the condition matches the context.\n-    pub async fn matches(&self, path: &FileSystemPath) -> Result<bool> {\n+    pub fn matches(&self, path: &FileSystemPath) -> bool {\n         match self {\n-            ContextCondition::All(conditions) => {\n-                // False positive.\n-                #[allow(clippy::manual_try_fold)]\n-                stream::iter(conditions)\n-                    .fold(Ok(true), |acc, c| async move {\n-                        Ok(acc? && Box::pin(c.matches(path)).await?)\n-                    })\n-                    .await\n+            ContextCondition::All(conditions) => conditions.iter().all(|c| c.matches(path)),\n+            ContextCondition::Any(conditions) => conditions.iter().any(|c| c.matches(path)),\n+            ContextCondition::Not(condition) => !condition.matches(path),\n+            ContextCondition::InPath(other_path) => path.is_inside_or_equal_ref(other_path),\n+            ContextCondition::InDirectory(dir) => {\n+                // `dir` must be a substring and bracketd by either `'/'` or the end of the path.\n+                if let Some(pos) = path.path.find(dir) {\n+                    let end = pos + dir.len();\n+                    (pos == 0 || path.path.as_bytes()[pos - 1] == b'/')\n+                        && (end == path.path.len() || path.path.as_bytes()[end] == b'/')\n+                } else {\n+                    false\n+                }\n             }\n-            ContextCondition::Any(conditions) => {\n-                // False positive.\n-                #[allow(clippy::manual_try_fold)]\n-                stream::iter(conditions)\n-                    .fold(Ok(false), |acc, c| async move {\n-                        Ok(acc? || Box::pin(c.matches(path)).await?)\n-                    })\n-                    .await\n-            }\n-            ContextCondition::Not(condition) => Box::pin(condition.matches(path)).await.map(|b| !b),\n-            ContextCondition::InPath(other_path) => Ok(path.is_inside_or_equal_ref(other_path)),\n-            ContextCondition::InDirectory(dir) => Ok(path.path.starts_with(&format!(\"{dir}/\"))\n-                || path.path.contains(&format!(\"/{dir}/\"))\n-                || path.path.ends_with(&format!(\"/{dir}\"))\n-                || path.path == *dir),\n         }\n     }\n }"
        },
        {
            "sha": "0c607d0894e851098d00325495bf102eedf067e7",
            "filename": "turbopack/crates/turbopack-node/src/transforms/webpack.rs",
            "status": "modified",
            "additions": 7,
            "deletions": 5,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/1fc2dfb2fa3cc927bc08912e2396313b9d728f6c/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Fwebpack.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1fc2dfb2fa3cc927bc08912e2396313b9d728f6c/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Fwebpack.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Fwebpack.rs?ref=1fc2dfb2fa3cc927bc08912e2396313b9d728f6c",
            "patch": "@@ -583,8 +583,6 @@ impl EvaluateContext for WebpackLoaderContext {\n                     options,\n                 );\n \n-                let request_str = request.to_string().await?;\n-                let lookup_path_str = lookup_path.value_to_string().await?;\n                 if let Some(source) = *resolved.first_source().await? {\n                     if let Some(path) = self\n                         .cwd\n@@ -594,12 +592,16 @@ impl EvaluateContext for WebpackLoaderContext {\n                     } else {\n                         bail!(\n                             \"Resolving {} in {} ends up on a different filesystem\",\n-                            request_str,\n-                            lookup_path_str\n+                            request.to_string().await?,\n+                            lookup_path.value_to_string().await?\n                         );\n                     }\n                 } else {\n-                    bail!(\"Unable to resolve {} in {}\", request_str, lookup_path_str);\n+                    bail!(\n+                        \"Unable to resolve {} in {}\",\n+                        request.to_string().await?,\n+                        lookup_path.value_to_string().await?\n+                    );\n                 }\n             }\n         }"
        },
        {
            "sha": "7d1bdee5ee3667e2a1b1658fa936b0151e1d145d",
            "filename": "turbopack/crates/turbopack-resolve/src/resolve.rs",
            "status": "modified",
            "additions": 34,
            "deletions": 40,
            "changes": 74,
            "blob_url": "https://github.com/vercel/next.js/blob/1fc2dfb2fa3cc927bc08912e2396313b9d728f6c/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Fresolve.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1fc2dfb2fa3cc927bc08912e2396313b9d728f6c/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Fresolve.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Fresolve.rs?ref=1fc2dfb2fa3cc927bc08912e2396313b9d728f6c",
            "patch": "@@ -1,6 +1,6 @@\n use anyhow::Result;\n use turbo_rcstr::rcstr;\n-use turbo_tasks::Vc;\n+use turbo_tasks::{ResolvedVc, Vc};\n use turbo_tasks_fs::{FileSystem, FileSystemPath};\n use turbopack_core::resolve::{\n     AliasMap, AliasPattern, ExternalTraced, ExternalType, FindContextFileResult, find_context_file,\n@@ -86,53 +86,48 @@ const EDGE_NODE_EXTERNALS: [&str; 5] = [\"buffer\", \"events\", \"assert\", \"util\", \"a\n \n #[turbo_tasks::function]\n async fn base_resolve_options(\n-    resolve_path: FileSystemPath,\n+    fs: ResolvedVc<Box<dyn FileSystem>>,\n     options_context: Vc<ResolveOptionsContext>,\n ) -> Result<Vc<ResolveOptions>> {\n-    let parent = resolve_path.parent();\n-    if parent != resolve_path {\n-        return Ok(base_resolve_options(parent, options_context));\n-    }\n-    let resolve_path_value = resolve_path.clone();\n     let opt = options_context.await?;\n     let emulating = opt.emulate_environment;\n-    let root = resolve_path_value.fs.root().await?.clone_value();\n+    let root = fs.root().await?.clone_value();\n     let mut direct_mappings = AliasMap::new();\n     let node_externals = if let Some(environment) = emulating {\n         environment.node_externals().owned().await?\n     } else {\n         opt.enable_node_externals\n     };\n-    if node_externals {\n-        for req in NODE_EXTERNALS {\n-            direct_mappings.insert(\n-                AliasPattern::exact(req),\n-                ImportMapping::External(None, ExternalType::CommonJs, ExternalTraced::Untraced)\n-                    .resolved_cell(),\n-            );\n-            direct_mappings.insert(\n-                AliasPattern::exact(format!(\"node:{req}\")),\n-                ImportMapping::External(None, ExternalType::CommonJs, ExternalTraced::Untraced)\n-                    .resolved_cell(),\n-            );\n+    if node_externals || opt.enable_edge_node_externals {\n+        let untraced_external_cell =\n+            ImportMapping::External(None, ExternalType::CommonJs, ExternalTraced::Untraced)\n+                .resolved_cell();\n+\n+        if node_externals {\n+            for req in NODE_EXTERNALS {\n+                direct_mappings.insert(AliasPattern::exact(req), untraced_external_cell);\n+                direct_mappings.insert(\n+                    AliasPattern::exact(format!(\"node:{req}\")),\n+                    untraced_external_cell,\n+                );\n+            }\n         }\n-    }\n-    if opt.enable_edge_node_externals {\n-        for req in EDGE_NODE_EXTERNALS {\n-            direct_mappings.insert(\n-                AliasPattern::exact(req),\n-                ImportMapping::External(\n-                    Some(format!(\"node:{req}\").into()),\n-                    ExternalType::CommonJs,\n-                    ExternalTraced::Untraced,\n-                )\n-                .resolved_cell(),\n-            );\n-            direct_mappings.insert(\n-                AliasPattern::exact(format!(\"node:{req}\")),\n-                ImportMapping::External(None, ExternalType::CommonJs, ExternalTraced::Untraced)\n+        if opt.enable_edge_node_externals {\n+            for req in EDGE_NODE_EXTERNALS {\n+                direct_mappings.insert(\n+                    AliasPattern::exact(req),\n+                    ImportMapping::External(\n+                        Some(format!(\"node:{req}\").into()),\n+                        ExternalType::CommonJs,\n+                        ExternalTraced::Untraced,\n+                    )\n                     .resolved_cell(),\n-            );\n+                );\n+                direct_mappings.insert(\n+                    AliasPattern::exact(format!(\"node:{req}\")),\n+                    untraced_external_cell,\n+                );\n+            }\n         }\n     }\n \n@@ -284,15 +279,14 @@ pub async fn resolve_options(\n ) -> Result<Vc<ResolveOptions>> {\n     let options_context_value = options_context.await?;\n     if !options_context_value.rules.is_empty() {\n-        let context_value = resolve_path.clone();\n         for (condition, new_options_context) in options_context_value.rules.iter() {\n-            if condition.matches(&context_value).await? {\n-                return Ok(resolve_options(resolve_path.clone(), **new_options_context));\n+            if condition.matches(&resolve_path) {\n+                return Ok(resolve_options(resolve_path, **new_options_context));\n             }\n         }\n     }\n \n-    let resolve_options = base_resolve_options(resolve_path.clone(), options_context);\n+    let resolve_options = base_resolve_options(*resolve_path.fs, options_context);\n \n     let resolve_options = if options_context_value.enable_typescript {\n         let find_tsconfig = async || {"
        },
        {
            "sha": "b0df590d7b4b2f222dbe2438fe7fe05161d45a1d",
            "filename": "turbopack/crates/turbopack/src/module_options/mod.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 3,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/1fc2dfb2fa3cc927bc08912e2396313b9d728f6c/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1fc2dfb2fa3cc927bc08912e2396313b9d728f6c/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Fmod.rs?ref=1fc2dfb2fa3cc927bc08912e2396313b9d728f6c",
            "patch": "@@ -76,10 +76,8 @@ impl ModuleOptions {\n         } = *module_options_context.await?;\n \n         if !rules.is_empty() {\n-            let path_value = path.clone();\n-\n             for (condition, new_context) in rules.iter() {\n-                if condition.matches(&path_value).await? {\n+                if condition.matches(&path) {\n                     return Ok(ModuleOptions::new(\n                         path,\n                         **new_context,"
        }
    ],
    "stats": {
        "total": 130,
        "additions": 56,
        "deletions": 74
    }
}