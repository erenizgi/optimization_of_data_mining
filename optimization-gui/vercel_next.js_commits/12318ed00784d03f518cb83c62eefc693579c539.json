{
    "author": "icyJoseph",
    "message": "docs: cacheHandlers (#85311)",
    "sha": "12318ed00784d03f518cb83c62eefc693579c539",
    "files": [
        {
            "sha": "321f482c2ff0325484106fed0ecb958e4a174d86",
            "filename": "docs/01-app/03-api-reference/01-directives/use-cache-private.mdx",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/12318ed00784d03f518cb83c62eefc693579c539/docs%2F01-app%2F03-api-reference%2F01-directives%2Fuse-cache-private.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/12318ed00784d03f518cb83c62eefc693579c539/docs%2F01-app%2F03-api-reference%2F01-directives%2Fuse-cache-private.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-api-reference%2F01-directives%2Fuse-cache-private.mdx?ref=12318ed00784d03f518cb83c62eefc693579c539",
            "patch": "@@ -7,6 +7,7 @@ related:\n   links:\n     - app/api-reference/directives/use-cache\n     - app/api-reference/config/next-config-js/cacheComponents\n+    - app/api-reference/config/next-config-js/cacheHandlers\n     - app/api-reference/functions/cacheLife\n     - app/api-reference/functions/cacheTag\n     - app/guides/prefetching"
        },
        {
            "sha": "430d92ee4af9b47b4e3d1166667172d1fca08348",
            "filename": "docs/01-app/03-api-reference/01-directives/use-cache-remote.mdx",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/12318ed00784d03f518cb83c62eefc693579c539/docs%2F01-app%2F03-api-reference%2F01-directives%2Fuse-cache-remote.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/12318ed00784d03f518cb83c62eefc693579c539/docs%2F01-app%2F03-api-reference%2F01-directives%2Fuse-cache-remote.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-api-reference%2F01-directives%2Fuse-cache-remote.mdx?ref=12318ed00784d03f518cb83c62eefc693579c539",
            "patch": "@@ -8,6 +8,7 @@ related:\n     - app/api-reference/directives/use-cache\n     - app/api-reference/directives/use-cache-private\n     - app/api-reference/config/next-config-js/cacheComponents\n+    - app/api-reference/config/next-config-js/cacheHandlers\n     - app/api-reference/functions/cacheLife\n     - app/api-reference/functions/cacheTag\n     - app/api-reference/functions/connection"
        },
        {
            "sha": "95a25344b0bb601119fe5428db5304dacac3784a",
            "filename": "docs/01-app/03-api-reference/01-directives/use-cache.mdx",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/12318ed00784d03f518cb83c62eefc693579c539/docs%2F01-app%2F03-api-reference%2F01-directives%2Fuse-cache.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/12318ed00784d03f518cb83c62eefc693579c539/docs%2F01-app%2F03-api-reference%2F01-directives%2Fuse-cache.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-api-reference%2F01-directives%2Fuse-cache.mdx?ref=12318ed00784d03f518cb83c62eefc693579c539",
            "patch": "@@ -8,6 +8,7 @@ related:\n     - app/api-reference/directives/use-cache-private\n     - app/api-reference/config/next-config-js/cacheComponents\n     - app/api-reference/config/next-config-js/cacheLife\n+    - app/api-reference/config/next-config-js/cacheHandlers\n     - app/api-reference/functions/cacheTag\n     - app/api-reference/functions/cacheLife\n     - app/api-reference/functions/revalidateTag\n@@ -112,7 +113,7 @@ This means `use cache` cannot be used with [runtime data](/docs/app/getting-star\n \n ## `use cache` at runtime\n \n-On the **server**, the cache entries of individual components or functions will be cached in-memory.\n+On the **server**, the cache entries of individual components or functions will be cached in-memory by default. You can customize the cache storage by configuring [`cacheHandlers`](/docs/app/api-reference/config/next-config-js/cacheHandlers) in your `next.config.js` file.\n \n Then, on the **client**, any content returned from the server cache will be stored in the browser's memory for the duration of the session or until [revalidated](#during-revalidation).\n "
        },
        {
            "sha": "9f8b287de7606cb5fb2e43133c5b140ddb05c49c",
            "filename": "docs/01-app/03-api-reference/05-config/01-next-config-js/cacheHandlers.mdx",
            "status": "added",
            "additions": 431,
            "deletions": 0,
            "changes": 431,
            "blob_url": "https://github.com/vercel/next.js/blob/12318ed00784d03f518cb83c62eefc693579c539/docs%2F01-app%2F03-api-reference%2F05-config%2F01-next-config-js%2FcacheHandlers.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/12318ed00784d03f518cb83c62eefc693579c539/docs%2F01-app%2F03-api-reference%2F05-config%2F01-next-config-js%2FcacheHandlers.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-api-reference%2F05-config%2F01-next-config-js%2FcacheHandlers.mdx?ref=12318ed00784d03f518cb83c62eefc693579c539",
            "patch": "@@ -0,0 +1,431 @@\n+---\n+title: cacheHandlers\n+description: Configure custom cache handlers for use cache directives in Next.js.\n+related:\n+  title: Related\n+  description: View related API references.\n+  links:\n+    - app/api-reference/directives/use-cache\n+    - app/api-reference/directives/use-cache-remote\n+    - app/api-reference/directives/use-cache-private\n+    - app/api-reference/config/next-config-js/cacheLife\n+---\n+\n+The `cacheHandlers` configuration allows you to define custom cache storage implementations for [`'use cache'`](/docs/app/api-reference/directives/use-cache) and [`'use cache: remote'`](/docs/app/api-reference/directives/use-cache-remote). This enables you to store cached components and functions in external services or customize the caching behavior. [`'use cache: private'`](/docs/app/api-reference/directives/use-cache-private) is not configurable.\n+\n+## When to use custom cache handlers\n+\n+**Most applications don't need custom cache handlers.** The default in-memory cache works well in the typical use case.\n+\n+Custom cache handlers are for advanced scenarios where you need to either share cache across multiple instances or change where the cache is stored. For example, you can configure a custom `remote` handler for external storage (like a key-value store), then use `'use cache'` in your code for in-memory caching and `'use cache: remote'` for the external storage, allowing different caching strategies within the same application.\n+\n+**Sharing cache across instances**\n+\n+The default in-memory cache is isolated to each Next.js process. If you're running multiple servers or containers, each instance will have its own cache that isn't shared with others and is lost on restart.\n+\n+Custom handlers let you integrate with shared storage systems (like Redis, Memcached, or DynamoDB) that all your Next.js instances can access.\n+\n+**Changing storage type**\n+\n+You might want to store cache differently than the default in-memory approach. You can implement a custom handler to store cache on disk, in a database, or in an external caching service. Reasons include: persistence across restarts, reducing memory usage, or integrating with existing infrastructure.\n+\n+## Usage\n+\n+To configure custom cache handlers:\n+\n+1. Define your cache handler in a separate file, see [examples](#examples) for implementation details.\n+2. Reference the file path in your Next config file\n+\n+```ts filename=\"next.config.ts\" switcher\n+import type { NextConfig } from 'next'\n+\n+const nextConfig: NextConfig = {\n+  cacheHandlers: {\n+    default: './cache-handlers/default-handler.js',\n+    remote: './cache-handlers/remote-handler.js',\n+  },\n+}\n+\n+export default nextConfig\n+```\n+\n+```js filename=\"next.config.js\" switcher\n+module.exports = {\n+  cacheHandlers: {\n+    default: './cache-handlers/default-handler.js',\n+    remote: './cache-handlers/remote-handler.js',\n+  },\n+}\n+```\n+\n+### Handler types\n+\n+- **`default`**: Used by the `'use cache'` directive\n+- **`remote`**: Used by the `'use cache: remote'` directive\n+\n+If you don't configure `cacheHandlers`, Next.js uses an in-memory LRU (Least Recently Used) cache for both `default` and `remote`. You can view the [default implementation](https://github.com/vercel/next.js/blob/canary/packages/next/src/server/lib/cache-handlers/default.ts) as a reference.\n+\n+You can also define additional named handlers (e.g., `sessions`, `analytics`) and reference them with `'use cache: <name>'`.\n+\n+Note that `'use cache: private'` does not use cache handlers and cannot be customized.\n+\n+## API Reference\n+\n+A cache handler must implement the [`CacheHandler`](https://github.com/vercel/next.js/blob/canary/packages/next/src/server/lib/cache-handlers/types.ts) interface with the following methods:\n+\n+### `get()`\n+\n+Retrieve a cache entry for the given cache key.\n+\n+```ts\n+get(cacheKey: string, softTags: string[]): Promise<CacheEntry | undefined>\n+```\n+\n+| Parameter  | Type       | Description                                                  |\n+| ---------- | ---------- | ------------------------------------------------------------ |\n+| `cacheKey` | `string`   | The unique key for the cache entry.                          |\n+| `softTags` | `string[]` | Tags to check for staleness (used in some cache strategies). |\n+\n+Returns a `CacheEntry` object if found, or `undefined` if not found or expired.\n+\n+Your `get` method should retrieve the cache entry from storage, check if it has expired based on the `revalidate` time, and return `undefined` for missing or expired entries.\n+\n+```js\n+class CacheHandler {\n+  async get(cacheKey, softTags) {\n+    const entry = cache.get(cacheKey)\n+    if (!entry) return undefined\n+\n+    // Check if expired\n+    const now = Date.now()\n+    if (now > entry.timestamp + entry.revalidate * 1000) {\n+      return undefined\n+    }\n+\n+    return entry\n+  }\n+}\n+```\n+\n+### `set()`\n+\n+Store a cache entry for the given cache key.\n+\n+```ts\n+set(cacheKey: string, pendingEntry: Promise<CacheEntry>): Promise<void>\n+```\n+\n+| Parameter      | Type                  | Description                                 |\n+| -------------- | --------------------- | ------------------------------------------- |\n+| `cacheKey`     | `string`              | The unique key to store the entry under.    |\n+| `pendingEntry` | `Promise<CacheEntry>` | A promise that resolves to the cache entry. |\n+\n+The entry may still be pending when this is called (i.e., its value stream may still be written to). Your handler should await the promise before processing the entry.\n+\n+Returns `Promise<void>`.\n+\n+Your `set` method must await the `pendingEntry` promise before storing it, since the cache entry may still be generating when this method is called. Once resolved, store the entry in your cache system.\n+\n+```js\n+class CacheHandler {\n+  async set(cacheKey, pendingEntry) {\n+    // Wait for the entry to be ready\n+    const entry = await pendingEntry\n+\n+    // Store in your cache system\n+    cache.set(cacheKey, entry)\n+  }\n+}\n+```\n+\n+### `refreshTags()`\n+\n+Called periodically before starting a new request to sync with external tag services.\n+\n+```ts\n+refreshTags(): Promise<void>\n+```\n+\n+This is useful if you're coordinating cache invalidation across multiple instances or services. For in-memory caches, this can be a no-op.\n+\n+Returns `Promise<void>`.\n+\n+For in-memory caches, this can be a no-op. For distributed caches, use this to sync tag state from an external service or database before processing requests.\n+\n+```js\n+class CacheHandler {\n+  async refreshTags() {\n+    // For in-memory cache, no action needed\n+    // For distributed cache, sync tag state from external service\n+  }\n+}\n+```\n+\n+### `getExpiration()`\n+\n+Get the maximum revalidation timestamp for a set of tags.\n+\n+```ts\n+getExpiration(tags: string[]): Promise<number>\n+```\n+\n+| Parameter | Type       | Description                            |\n+| --------- | ---------- | -------------------------------------- |\n+| `tags`    | `string[]` | Array of tags to check expiration for. |\n+\n+Returns:\n+\n+- `0` if none of the tags were ever revalidated\n+- A timestamp (in milliseconds) representing the most recent revalidation\n+- `Infinity` to indicate soft tags should be checked in the `get` method instead\n+\n+If you're not tracking tag revalidation timestamps, return `0`. Otherwise, find the most recent revalidation timestamp across all the provided tags. Return `Infinity` if you prefer to handle soft tag checking in the `get` method.\n+\n+```js\n+class CacheHandler {\n+  async getExpiration(tags) {\n+    // Return 0 if not tracking tag revalidation\n+    return 0\n+\n+    // Or return the most recent revalidation timestamp\n+    // return Math.max(...tags.map(tag => tagTimestamps.get(tag) || 0));\n+  }\n+}\n+```\n+\n+### `updateTags()`\n+\n+Called when tags are revalidated or expired.\n+\n+```ts\n+updateTags(tags: string[], durations?: { expire?: number }): Promise<void>\n+```\n+\n+| Parameter   | Type                  | Description                              |\n+| ----------- | --------------------- | ---------------------------------------- |\n+| `tags`      | `string[]`            | Array of tags to update.                 |\n+| `durations` | `{ expire?: number }` | Optional expiration duration in seconds. |\n+\n+Your handler should update its internal state to mark these tags as invalidated.\n+\n+Returns `Promise<void>`.\n+\n+When tags are revalidated, your handler should invalidate all cache entries that have any of those tags. Iterate through your cache and remove entries whose tags match the provided list.\n+\n+```js\n+class CacheHandler {\n+  async updateTags(tags, durations) {\n+    // Invalidate all cache entries with matching tags\n+    for (const [key, entry] of cache.entries()) {\n+      if (entry.tags.some((tag) => tags.includes(tag))) {\n+        cache.delete(key)\n+      }\n+    }\n+  }\n+}\n+```\n+\n+## CacheEntry Type\n+\n+The [`CacheEntry`](https://github.com/vercel/next.js/blob/canary/packages/next/src/server/lib/cache-handlers/types.ts) object has the following structure:\n+\n+```ts\n+interface CacheEntry {\n+  value: ReadableStream<Uint8Array>\n+  tags: string[]\n+  stale: number\n+  timestamp: number\n+  expire: number\n+  revalidate: number\n+}\n+```\n+\n+| Property     | Type                         | Description                                                  |\n+| ------------ | ---------------------------- | ------------------------------------------------------------ |\n+| `value`      | `ReadableStream<Uint8Array>` | The cached data as a stream.                                 |\n+| `tags`       | `string[]`                   | Cache tags (excluding soft tags).                            |\n+| `stale`      | `number`                     | Duration in seconds for client-side staleness.               |\n+| `timestamp`  | `number`                     | When the entry was created (timestamp in milliseconds).      |\n+| `expire`     | `number`                     | How long the entry is allowed to be used (in seconds).       |\n+| `revalidate` | `number`                     | How long until the entry should be revalidated (in seconds). |\n+\n+> **Good to know**:\n+>\n+> - The `value` is a [`ReadableStream`](https://developer.mozilla.org/docs/Web/API/ReadableStream). Use [`.tee()`](https://developer.mozilla.org/docs/Web/API/ReadableStream/tee) if you need to read and store the stream data.\n+> - If the stream errors with partial data, your handler must decide whether to keep the partial cache or discard it.\n+\n+## Examples\n+\n+### Basic in-memory cache handler\n+\n+Here's a minimal implementation using a `Map` for storage. This example demonstrates the core concepts, but for a production-ready implementation with LRU eviction, error handling, and tag management, see the [default cache handler](https://github.com/vercel/next.js/blob/canary/packages/next/src/server/lib/cache-handlers/default.ts).\n+\n+```js filename=\"cache-handlers/memory-handler.js\"\n+const cache = new Map()\n+const pendingSets = new Map()\n+\n+module.exports = class MemoryCacheHandler {\n+  async get(cacheKey, softTags) {\n+    // Wait for any pending set operation to complete\n+    const pendingPromise = pendingSets.get(cacheKey)\n+    if (pendingPromise) {\n+      await pendingPromise\n+    }\n+\n+    const entry = cache.get(cacheKey)\n+    if (!entry) {\n+      return undefined\n+    }\n+\n+    // Check if entry has expired\n+    const now = Date.now()\n+    if (now > entry.timestamp + entry.revalidate * 1000) {\n+      return undefined\n+    }\n+\n+    return entry\n+  }\n+\n+  async set(cacheKey, pendingEntry) {\n+    // Create a promise to track this set operation\n+    let resolvePending\n+    const pendingPromise = new Promise((resolve) => {\n+      resolvePending = resolve\n+    })\n+    pendingSets.set(cacheKey, pendingPromise)\n+\n+    try {\n+      // Wait for the entry to be ready\n+      const entry = await pendingEntry\n+\n+      // Store the entry in the cache\n+      cache.set(cacheKey, entry)\n+    } finally {\n+      resolvePending()\n+      pendingSets.delete(cacheKey)\n+    }\n+  }\n+\n+  async refreshTags() {\n+    // No-op for in-memory cache\n+  }\n+\n+  async getExpiration(tags) {\n+    // Return 0 to indicate no tags have been revalidated\n+    return 0\n+  }\n+\n+  async updateTags(tags, durations) {\n+    // Implement tag-based invalidation\n+    for (const [key, entry] of cache.entries()) {\n+      if (entry.tags.some((tag) => tags.includes(tag))) {\n+        cache.delete(key)\n+      }\n+    }\n+  }\n+}\n+```\n+\n+### External storage pattern\n+\n+For durable storage like Redis or a database, you'll need to serialize the cache entries. Here's a simple Redis example:\n+\n+```js filename=\"cache-handlers/redis-handler.js\"\n+const { createClient } = require('redis')\n+\n+module.exports = class RedisCacheHandler {\n+  constructor() {\n+    this.client = createClient({ url: process.env.REDIS_URL })\n+    this.client.connect()\n+  }\n+\n+  async get(cacheKey, softTags) {\n+    // Retrieve from Redis\n+    const stored = await this.client.get(cacheKey)\n+    if (!stored) return undefined\n+\n+    // Deserialize the entry\n+    const data = JSON.parse(stored)\n+\n+    // Reconstruct the ReadableStream from stored data\n+    return {\n+      value: new ReadableStream({\n+        start(controller) {\n+          controller.enqueue(Buffer.from(data.value, 'base64'))\n+          controller.close()\n+        },\n+      }),\n+      tags: data.tags,\n+      stale: data.stale,\n+      timestamp: data.timestamp,\n+      expire: data.expire,\n+      revalidate: data.revalidate,\n+    }\n+  }\n+\n+  async set(cacheKey, pendingEntry) {\n+    const entry = await pendingEntry\n+\n+    // Read the stream to get the data\n+    const reader = entry.value.getReader()\n+    const chunks = []\n+\n+    try {\n+      while (true) {\n+        const { done, value } = await reader.read()\n+        if (done) break\n+        chunks.push(value)\n+      }\n+    } finally {\n+      reader.releaseLock()\n+    }\n+\n+    // Combine chunks and serialize for Redis storage\n+    const data = Buffer.concat(chunks.map((chunk) => Buffer.from(chunk)))\n+\n+    await this.client.set(\n+      cacheKey,\n+      JSON.stringify({\n+        value: data.toString('base64'),\n+        tags: entry.tags,\n+        stale: entry.stale,\n+        timestamp: entry.timestamp,\n+        expire: entry.expire,\n+        revalidate: entry.revalidate,\n+      }),\n+      { EX: entry.expire } // Use Redis TTL for automatic expiration\n+    )\n+  }\n+\n+  async refreshTags() {\n+    // No-op for basic Redis implementation\n+    // Could sync with external tag service if needed\n+  }\n+\n+  async getExpiration(tags) {\n+    // Return 0 to indicate no tags have been revalidated\n+    // Could query Redis for tag expiration timestamps if tracking them\n+    return 0\n+  }\n+\n+  async updateTags(tags, durations) {\n+    // Implement tag-based invalidation if needed\n+    // Could iterate over keys with matching tags and delete them\n+  }\n+}\n+```\n+\n+## Platform Support\n+\n+| Deployment Option                                                   | Supported         |\n+| ------------------------------------------------------------------- | ----------------- |\n+| [Node.js server](/docs/app/getting-started/deploying#nodejs-server) | Yes               |\n+| [Docker container](/docs/app/getting-started/deploying#docker)      | Yes               |\n+| [Static export](/docs/app/getting-started/deploying#static-export)  | No                |\n+| [Adapters](/docs/app/getting-started/deploying#adapters)            | Platform-specific |\n+\n+## Version History\n+\n+| Version   | Changes                     |\n+| --------- | --------------------------- |\n+| `v16.0.0` | `cacheHandlers` introduced. |"
        },
        {
            "sha": "adcb2a51cf7e4788caefcce1955b5f4f1cc44c79",
            "filename": "docs/01-app/03-api-reference/05-config/01-next-config-js/cacheLife.mdx",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/12318ed00784d03f518cb83c62eefc693579c539/docs%2F01-app%2F03-api-reference%2F05-config%2F01-next-config-js%2FcacheLife.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/12318ed00784d03f518cb83c62eefc693579c539/docs%2F01-app%2F03-api-reference%2F05-config%2F01-next-config-js%2FcacheLife.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-api-reference%2F05-config%2F01-next-config-js%2FcacheLife.mdx?ref=12318ed00784d03f518cb83c62eefc693579c539",
            "patch": "@@ -1,6 +1,13 @@\n ---\n title: cacheLife\n description: Learn how to set up cacheLife configurations in Next.js.\n+related:\n+  title: Related\n+  description: View related API references.\n+  links:\n+    - app/api-reference/directives/use-cache\n+    - app/api-reference/config/next-config-js/cacheHandlers\n+    - app/api-reference/functions/cacheLife\n ---\n \n The `cacheLife` option allows you to define **custom cache profiles** when using the [`cacheLife`](/docs/app/api-reference/functions/cacheLife) function inside components or functions, and within the scope of the [`use cache` directive](/docs/app/api-reference/directives/use-cache)."
        },
        {
            "sha": "4a021b4a6f09b6724a35cc61996e914ff151168b",
            "filename": "docs/01-app/03-api-reference/05-config/01-next-config-js/incrementalCacheHandlerPath.mdx",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/12318ed00784d03f518cb83c62eefc693579c539/docs%2F01-app%2F03-api-reference%2F05-config%2F01-next-config-js%2FincrementalCacheHandlerPath.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/12318ed00784d03f518cb83c62eefc693579c539/docs%2F01-app%2F03-api-reference%2F05-config%2F01-next-config-js%2FincrementalCacheHandlerPath.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-api-reference%2F05-config%2F01-next-config-js%2FincrementalCacheHandlerPath.mdx?ref=12318ed00784d03f518cb83c62eefc693579c539",
            "patch": "@@ -6,7 +6,7 @@ description: Configure the Next.js cache used for storing and revalidating data\n \n You can configure the Next.js cache location if you want to persist cached pages and data to durable storage, or share the cache across multiple containers or instances of your Next.js application.\n \n-> **Good to know**: The `cacheHandler` configuration is specifically used by Next.js for server cache operations such as storing and revalidating ISR and route handler responses. It is not used by `'use cache'`, `'use cache: remote'`, nor `'use cache: private'`, which manage their own cache independently.\n+> **Good to know**: The `cacheHandler` (singular) configuration is specifically used by Next.js for server cache operations such as storing and revalidating ISR and route handler responses. It is **not** used by `'use cache'` directives. For `'use cache'` directives, use [`cacheHandlers`](/docs/app/api-reference/config/next-config-js/cacheHandlers) (plural) instead.\n \n ```js filename=\"next.config.js\"\n module.exports = {"
        }
    ],
    "stats": {
        "total": 445,
        "additions": 443,
        "deletions": 2
    }
}