{
    "author": "mischnic",
    "message": "Turbopack: correctly overwrite existing symlinks (#86808)",
    "sha": "3606db59ded25e8d738c035d41ca3131cdf20535",
    "files": [
        {
            "sha": "0ddd4e3f3d2c5c4ef950aa2419db6f6d2c79159d",
            "filename": "turbopack/crates/turbo-tasks-fs/src/lib.rs",
            "status": "modified",
            "additions": 128,
            "deletions": 1,
            "changes": 129,
            "blob_url": "https://github.com/vercel/next.js/blob/3606db59ded25e8d738c035d41ca3131cdf20535/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3606db59ded25e8d738c035d41ca3131cdf20535/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs?ref=3606db59ded25e8d738c035d41ca3131cdf20535",
            "patch": "@@ -1127,6 +1127,26 @@ impl FileSystem for DiskFileSystem {\n                         PathBuf::from(unix_to_sys(target).as_ref())\n                     };\n                     let full_path = full_path.into_owned();\n+\n+                    if old_content.is_some() {\n+                        // Remove existing symlink before creating a new one. At least on Unix,\n+                        // symlink(2) fails with EEXIST if the link already exists instead of\n+                        // overwriting it\n+                        retry_blocking(full_path.clone(), |path| std::fs::remove_file(path))\n+                            .concurrency_limited(&inner.write_semaphore)\n+                            .await\n+                            .or_else(|err| {\n+                                if err.kind() == ErrorKind::NotFound {\n+                                    Ok(())\n+                                } else {\n+                                    Err(err)\n+                                }\n+                            })\n+                            .with_context(|| {\n+                                anyhow!(\"removing existing symlink {} failed\", full_path.display())\n+                            })?;\n+                    }\n+\n                     retry_blocking(target_path, move |target_path| {\n                         let _span = tracing::info_span!(\n                             \"write symlink\",\n@@ -2915,7 +2935,114 @@ mod tests {\n         .unwrap();\n     }\n \n-    // Test helpers for denied_path tests\n+    #[cfg(test)]\n+    mod symlink_tests {\n+        use std::{\n+            fs::{File, create_dir_all, read_to_string},\n+            io::Write,\n+        };\n+\n+        use turbo_rcstr::{RcStr, rcstr};\n+        use turbo_tasks::{ResolvedVc, apply_effects};\n+        use turbo_tasks_backend::{BackendOptions, TurboTasksBackend, noop_backing_storage};\n+\n+        use crate::{DiskFileSystem, FileSystem, FileSystemPath, LinkContent, LinkType};\n+\n+        #[turbo_tasks::function(operation)]\n+        async fn test_write_link_effect(\n+            fs: ResolvedVc<DiskFileSystem>,\n+            path: FileSystemPath,\n+            target: RcStr,\n+        ) -> anyhow::Result<()> {\n+            let write_file = |f| {\n+                fs.write_link(\n+                    f,\n+                    LinkContent::Link {\n+                        target: format!(\"{target}/data.txt\").into(),\n+                        link_type: LinkType::empty(),\n+                    }\n+                    .cell(),\n+                )\n+            };\n+            // Write it twice (same content)\n+            write_file(path.join(\"symlink-file\")?).await?;\n+            write_file(path.join(\"symlink-file\")?).await?;\n+\n+            let write_dir = |f| {\n+                fs.write_link(\n+                    f,\n+                    LinkContent::Link {\n+                        target: target.clone(),\n+                        link_type: LinkType::DIRECTORY,\n+                    }\n+                    .cell(),\n+                )\n+            };\n+            // Write it twice (same content)\n+            write_dir(path.join(\"symlink-dir\")?).await?;\n+            write_dir(path.join(\"symlink-dir\")?).await?;\n+\n+            Ok(())\n+        }\n+\n+        #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n+        async fn test_write_link() {\n+            let scratch = tempfile::tempdir().unwrap();\n+            let path = scratch.path().to_owned();\n+\n+            create_dir_all(path.join(\"subdir-a\")).unwrap();\n+            File::create_new(path.join(\"subdir-a/data.txt\"))\n+                .unwrap()\n+                .write_all(b\"foo\")\n+                .unwrap();\n+            create_dir_all(path.join(\"subdir-b\")).unwrap();\n+            File::create_new(path.join(\"subdir-b/data.txt\"))\n+                .unwrap()\n+                .write_all(b\"bar\")\n+                .unwrap();\n+            let root = path.to_str().unwrap().into();\n+\n+            let tt = turbo_tasks::TurboTasks::new(TurboTasksBackend::new(\n+                BackendOptions::default(),\n+                noop_backing_storage(),\n+            ));\n+\n+            tt.run_once(async move {\n+                let fs = DiskFileSystem::new(rcstr!(\"test\"), root)\n+                    .to_resolved()\n+                    .await?;\n+                let root_path = fs.root().owned().await?;\n+\n+                let write_result =\n+                    test_write_link_effect(fs, root_path.clone(), rcstr!(\"subdir-a\"));\n+                write_result.read_strongly_consistent().await?;\n+                apply_effects(write_result).await?;\n+\n+                assert_eq!(read_to_string(path.join(\"symlink-file\")).unwrap(), \"foo\");\n+                assert_eq!(\n+                    read_to_string(path.join(\"symlink-dir/data.txt\")).unwrap(),\n+                    \"foo\"\n+                );\n+\n+                // Write the same links again but with different targets\n+                let write_result = test_write_link_effect(fs, root_path, rcstr!(\"subdir-b\"));\n+                write_result.read_strongly_consistent().await?;\n+                apply_effects(write_result).await?;\n+\n+                assert_eq!(read_to_string(path.join(\"symlink-file\")).unwrap(), \"bar\");\n+                assert_eq!(\n+                    read_to_string(path.join(\"symlink-dir/data.txt\")).unwrap(),\n+                    \"bar\"\n+                );\n+\n+                anyhow::Ok(())\n+            })\n+            .await\n+            .unwrap();\n+        }\n+    }\n+\n+    // Tests helpers for denied_path tests\n     #[cfg(test)]\n     mod denied_path_tests {\n         use std::{"
        }
    ],
    "stats": {
        "total": 129,
        "additions": 128,
        "deletions": 1
    }
}