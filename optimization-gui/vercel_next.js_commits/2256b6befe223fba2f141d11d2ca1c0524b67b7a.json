{
    "author": "unstubbable",
    "message": "Properly handle hanging promise rejections during prerendering (#81754)\n\nWe are using hanging promises for excluding request-specific data from a\nprerender. When prerendering is aborted, we reject all hanging promises.\nIn dev mode, React uses these rejections to construct more detailed\nowner stacks. This allows us to provide better errors during the\nprerender validation.\n\nFor this to work reliably, we need to ensure that all hanging promises\nare rejected after React's rendering is aborted. However, some hanging\npromises are created before React starts rendering (when creating the\nRSC component tree). Furthermore, for memory reasons, the first hanging\npromise adds a single abort listener that's shared with all subsequent\nhanging promises (see #77480). In this case, the shared abort listener\nfor rejections is added before React can add its own abort listener.\n\nWhen using the same abort signal for both the React render and the\nhanging promises, the hanging promises would be rejected too early,\npreventing React from properly constructing the owner stacks.\n\nTo ensure that the order of operations is correct, we now use a separate\nabort signal for React's rendering that is aborted before the \"render\nsignal\" [^1], which is used by the hanging promises, is aborted. For\nparity, we're doing this not only in dev mode but also in production\nmode, so that the hanging promise rejection handling is always the same.\n\nTechnically, I don't think this change is necessary for the SSR\nprerender pass, but it felt cleaner to apply it there as well. However,\nwe could revisit that when we properly split the two prerender stores.\nFor example, the `cacheSignal` and `prerenderResumeDataCache` also don't\nneed to be present on the client prerender store.\n\nReverts #81501.\n\n[^1]: This is an unfortunate name clash. We could also call this one\n\"cache signal\", which would be in line with `React.cacheSignal()` â€“ its\npotential successor. But that clashes with our current `cacheSignal`,\nwhich tracks the cache reads. We might revisit this naming problem in a\nfuture PR.",
    "sha": "2256b6befe223fba2f141d11d2ca1c0524b67b7a",
    "files": [
        {
            "sha": "de62c77c9a4c3a0cb08d10dca8637dfafa9b1ef3",
            "filename": "packages/next/src/server/app-render/app-render.tsx",
            "status": "modified",
            "additions": 202,
            "deletions": 67,
            "changes": 269,
            "blob_url": "https://github.com/vercel/next.js/blob/2256b6befe223fba2f141d11d2ca1c0524b67b7a/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/2256b6befe223fba2f141d11d2ca1c0524b67b7a/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx?ref=2256b6befe223fba2f141d11d2ca1c0524b67b7a",
            "patch": "@@ -711,6 +711,7 @@ async function warmupDevRender(\n \n   const renderController = new AbortController()\n   const prerenderController = new AbortController()\n+  const reactController = new AbortController()\n   const cacheSignal = new CacheSignal()\n \n   const prerenderStore: PrerenderStore = {\n@@ -760,6 +761,7 @@ async function warmupDevRender(\n   // We unset the cache so any late over-run renders aren't able to write into this cache\n   prerenderStore.prerenderResumeDataCache = null\n   // Abort the render\n+  reactController.abort()\n   renderController.abort()\n \n   // We don't really want to return a result here but the stack of functions\n@@ -2314,19 +2316,30 @@ async function spawnDynamicValidationInDev(\n     NEXT_HMR_REFRESH_HASH_COOKIE\n   )?.value\n \n-  // Prerender controller represents the lifetime of the prerender.\n-  // It will be aborted when a Task is complete or a synchronously aborting\n-  // API is called. Notably during cache-filling renders this does not actually\n-  // terminate the render itself which will continue until all caches are filled\n+  // The prerender controller represents the lifetime of the prerender. It will\n+  // be aborted when a task is complete or a synchronously aborting API is\n+  // called. Notably, during prospective prerenders, this does not actually\n+  // terminate the prerender itself, which will continue until all caches are\n+  // filled.\n   const initialServerPrerenderController = new AbortController()\n \n-  // This controller represents the lifetime of the React render call. Notably\n-  // during the cache-filling render it is different from the prerender controller\n-  // because we don't want to end the react render until all caches are filled.\n+  // This controller is used to abort the React prerender.\n+  const initialServerReactController = new AbortController()\n+\n+  // This controller represents the lifetime of the React prerender. Its signal\n+  // can be used for any I/O operation to abort the I/O and/or to reject, when\n+  // prerendering aborts. This includes our own hanging promises for accessing\n+  // request data, and for fetch calls. It might be replaced in the future by\n+  // React.cacheSignal(). It's aborted after the React controller, so that no\n+  // pending I/O can register abort listeners that are called before React's\n+  // abort listener is called. This ensures that pending I/O is not rejected too\n+  // early when aborting the prerender. Notably, during the prospective\n+  // prerender, it is different from the prerender controller because we don't\n+  // want to end the React prerender until all caches are filled.\n   const initialServerRenderController = new AbortController()\n \n-  // The cacheSignal helps us track whether caches are still filling or we are ready\n-  // to cut the render off.\n+  // The cacheSignal helps us track whether caches are still filling or we are\n+  // ready to cut the render off.\n   const cacheSignal = new CacheSignal()\n \n   const captureOwnerStackClient = React.captureOwnerStack\n@@ -2407,16 +2420,26 @@ async function spawnDynamicValidationInDev(\n       // We don't want to stop rendering until the cacheSignal is complete so we pass\n       // a different signal to this render call than is used by dynamic APIs to signify\n       // transitioning out of the prerender environment\n-      signal: initialServerRenderController.signal,\n+      signal: initialServerReactController.signal,\n     }\n   )\n \n+  // The listener to abort our own render controller must be added after React\n+  // has added its listener, to ensure that pending I/O is not aborted/rejected\n+  // too early.\n+  initialServerReactController.signal.addEventListener(\n+    'abort',\n+    () => {\n+      initialServerRenderController.abort()\n+    },\n+    { once: true }\n+  )\n+\n   // Wait for all caches to be finished filling and for async imports to resolve\n   trackPendingModules(cacheSignal)\n   await cacheSignal.cacheReady()\n \n-  initialServerRenderController.abort()\n-  initialServerPrerenderController.abort()\n+  initialServerReactController.abort()\n \n   // We don't need to continue the prerender process if we already\n   // detected invalid dynamic usage in the initial prerender phase.\n@@ -2438,7 +2461,7 @@ async function spawnDynamicValidationInDev(\n     )\n   } catch (err) {\n     if (\n-      initialServerRenderController.signal.aborted ||\n+      initialServerReactController.signal.aborted ||\n       initialServerPrerenderController.signal.aborted\n     ) {\n       // These are expected errors that might error the prerender. we ignore them.\n@@ -2453,8 +2476,10 @@ async function spawnDynamicValidationInDev(\n   }\n \n   if (initialServerResult) {\n-    const initialClientRenderController = new AbortController()\n     const initialClientPrerenderController = new AbortController()\n+    const initialClientReactController = new AbortController()\n+    const initialClientRenderController = new AbortController()\n+\n     const initialClientPrerenderStore: PrerenderStore = {\n       type: 'prerender-client',\n       phase: 'render',\n@@ -2492,7 +2517,7 @@ async function spawnDynamicValidationInDev(\n         nonce={nonce}\n       />,\n       {\n-        signal: initialClientRenderController.signal,\n+        signal: initialClientReactController.signal,\n         onError: (err) => {\n           const digest = getDigestForWellKnownError(err)\n \n@@ -2506,7 +2531,7 @@ async function spawnDynamicValidationInDev(\n             return undefined\n           }\n \n-          if (initialClientRenderController.signal.aborted) {\n+          if (initialClientReactController.signal.aborted) {\n             // These are expected errors that might error the prerender. we ignore them.\n           } else if (\n             process.env.NEXT_DEBUG_BUILD ||\n@@ -2522,9 +2547,20 @@ async function spawnDynamicValidationInDev(\n       }\n     )\n \n+    // The listener to abort our own render controller must be added after React\n+    // has added its listener, to ensure that pending I/O is not\n+    // aborted/rejected too early.\n+    initialClientReactController.signal.addEventListener(\n+      'abort',\n+      () => {\n+        initialClientRenderController.abort()\n+      },\n+      { once: true }\n+    )\n+\n     pendingInitialClientResult.catch((err) => {\n       if (\n-        initialServerRenderController.signal.aborted ||\n+        initialClientReactController.signal.aborted ||\n         isPrerenderInterruptedError(err)\n       ) {\n         // These are expected errors that might error the prerender. we ignore them.\n@@ -2542,10 +2578,12 @@ async function spawnDynamicValidationInDev(\n     // Promises passed to client were already awaited above (assuming that they came from cached functions)\n     trackPendingModules(cacheSignal)\n     await cacheSignal.cacheReady()\n-    initialClientRenderController.abort()\n+    initialClientReactController.abort()\n   }\n \n-  const finalServerController = new AbortController()\n+  const finalServerReactController = new AbortController()\n+  const finalServerRenderController = new AbortController()\n+\n   const serverDynamicTracking = createDynamicTrackingState(\n     false // isDebugDynamicAccesses\n   )\n@@ -2555,8 +2593,8 @@ async function spawnDynamicValidationInDev(\n     phase: 'render',\n     rootParams,\n     implicitTags,\n-    renderSignal: finalServerController.signal,\n-    controller: finalServerController,\n+    renderSignal: finalServerRenderController.signal,\n+    controller: finalServerReactController,\n     // All caches we could read must already be filled so no tracking is necessary\n     cacheSignal: null,\n     dynamicTracking: serverDynamicTracking,\n@@ -2582,7 +2620,7 @@ async function spawnDynamicValidationInDev(\n   const reactServerResult = await createReactServerPrerenderResult(\n     prerenderAndAbortInSequentialTasks(\n       async () => {\n-        const prerenderResult = await workUnitAsyncStorage.run(\n+        const pendingPrerenderResult = workUnitAsyncStorage.run(\n           // The store to scope\n           finalServerPrerenderStore,\n           // The function to run\n@@ -2594,7 +2632,7 @@ async function spawnDynamicValidationInDev(\n             filterStackFrame,\n             onError: (err: unknown) => {\n               if (\n-                finalServerController.signal.aborted &&\n+                finalServerReactController.signal.aborted &&\n                 isPrerenderInterruptedError(err)\n               ) {\n                 return err.digest\n@@ -2608,28 +2646,42 @@ async function spawnDynamicValidationInDev(\n \n               return getDigestForWellKnownError(err)\n             },\n-            signal: finalServerController.signal,\n+            signal: finalServerReactController.signal,\n           }\n         )\n-        return prerenderResult\n+\n+        // The listener to abort our own render controller must be added after\n+        // React has added its listener, to ensure that pending I/O is not\n+        // aborted/rejected too early.\n+        finalServerReactController.signal.addEventListener(\n+          'abort',\n+          () => {\n+            finalServerRenderController.abort()\n+          },\n+          { once: true }\n+        )\n+\n+        return pendingPrerenderResult\n       },\n       () => {\n-        finalServerController.abort()\n+        finalServerReactController.abort()\n       }\n     )\n   )\n \n   const clientDynamicTracking = createDynamicTrackingState(\n     false //isDebugDynamicAccesses\n   )\n-  const finalClientController = new AbortController()\n+  const finalClientReactController = new AbortController()\n+  const finalClientRenderController = new AbortController()\n+\n   const finalClientPrerenderStore: PrerenderStore = {\n     type: 'prerender-client',\n     phase: 'render',\n     rootParams,\n     implicitTags,\n-    renderSignal: finalClientController.signal,\n-    controller: finalClientController,\n+    renderSignal: finalClientRenderController.signal,\n+    controller: finalClientReactController,\n     // No APIs require a cacheSignal through the workUnitStore during the HTML prerender\n     cacheSignal: null,\n     dynamicTracking: clientDynamicTracking,\n@@ -2652,8 +2704,8 @@ async function spawnDynamicValidationInDev(\n     ).prerender\n     let { prelude: unprocessedPrelude } =\n       await prerenderAndAbortInSequentialTasks(\n-        () =>\n-          workUnitAsyncStorage.run(\n+        () => {\n+          const pendingFinalClientResult = workUnitAsyncStorage.run(\n             finalClientPrerenderStore,\n             prerender,\n             <App\n@@ -2665,11 +2717,11 @@ async function spawnDynamicValidationInDev(\n               nonce={nonce}\n             />,\n             {\n-              signal: finalClientController.signal,\n+              signal: finalClientReactController.signal,\n               onError: (err: unknown, errorInfo: ErrorInfo) => {\n                 if (\n                   isPrerenderInterruptedError(err) ||\n-                  finalClientController.signal.aborted\n+                  finalClientReactController.signal.aborted\n                 ) {\n                   const componentStack = errorInfo.componentStack\n                   if (typeof componentStack === 'string') {\n@@ -2694,9 +2746,23 @@ async function spawnDynamicValidationInDev(\n               // We don't need bootstrap scripts in this prerender\n               // bootstrapScripts: [bootstrapScript],\n             }\n-          ),\n+          )\n+\n+          // The listener to abort our own render controller must be added after\n+          // React has added its listener, to ensure that pending I/O is not\n+          // aborted/rejected too early.\n+          finalClientReactController.signal.addEventListener(\n+            'abort',\n+            () => {\n+              finalClientRenderController.abort()\n+            },\n+            { once: true }\n+          )\n+\n+          return pendingFinalClientResult\n+        },\n         () => {\n-          finalClientController.abort()\n+          finalClientReactController.abort()\n         }\n       )\n \n@@ -2933,15 +2999,27 @@ async function prerenderToStream(\n        * and the reactServerIsDynamic value to determine how to treat the resulting render\n        */\n \n-      // Prerender controller represents the lifetime of the prerender.\n-      // It will be aborted when a Task is complete or a synchronously aborting\n-      // API is called. Notably during cache-filling renders this does not actually\n-      // terminate the render itself which will continue until all caches are filled\n+      // The prerender controller represents the lifetime of the prerender. It\n+      // will be aborted when a task is complete or a synchronously aborting API\n+      // is called. Notably, during prospective prerenders, this does not\n+      // actually terminate the prerender itself, which will continue until all\n+      // caches are filled.\n       const initialServerPrerenderController = new AbortController()\n \n-      // This controller represents the lifetime of the React render call. Notably\n-      // during the cache-filling render it is different from the prerender controller\n-      // because we don't want to end the react render until all caches are filled.\n+      // This controller is used to abort the React prerender.\n+      const initialServerReactController = new AbortController()\n+\n+      // This controller represents the lifetime of the React prerender. Its\n+      // signal can be used for any I/O operation to abort the I/O and/or to\n+      // reject, when prerendering aborts. This includes our own hanging\n+      // promises for accessing request data, and for fetch calls. It might be\n+      // replaced in the future by React.cacheSignal(). It's aborted after the\n+      // React controller, so that no pending I/O can register abort listeners\n+      // that are called before React's abort listener is called. This ensures\n+      // that pending I/O is not rejected too early when aborting the prerender.\n+      // Notably, during the prospective prerender, it is different from the\n+      // prerender controller because we don't want to end the React prerender\n+      // until all caches are filled.\n       const initialServerRenderController = new AbortController()\n \n       // The cacheSignal helps us track whether caches are still filling or we are ready\n@@ -3035,16 +3113,26 @@ async function prerenderToStream(\n           // We don't want to stop rendering until the cacheSignal is complete so we pass\n           // a different signal to this render call than is used by dynamic APIs to signify\n           // transitioning out of the prerender environment\n-          signal: initialServerRenderController.signal,\n+          signal: initialServerReactController.signal,\n         }\n       )\n \n+      // The listener to abort our own render controller must be added after\n+      // React has added its listener, to ensure that pending I/O is not\n+      // aborted/rejected too early.\n+      initialServerReactController.signal.addEventListener(\n+        'abort',\n+        () => {\n+          initialServerRenderController.abort()\n+        },\n+        { once: true }\n+      )\n+\n       // Wait for all caches to be finished filling and for async imports to resolve\n       trackPendingModules(cacheSignal)\n       await cacheSignal.cacheReady()\n \n-      initialServerRenderController.abort()\n-      initialServerPrerenderController.abort()\n+      initialServerReactController.abort()\n \n       // We don't need to continue the prerender process if we already\n       // detected invalid dynamic usage in the initial prerender phase.\n@@ -3060,7 +3148,7 @@ async function prerenderToStream(\n         )\n       } catch (err) {\n         if (\n-          initialServerRenderController.signal.aborted ||\n+          initialServerReactController.signal.aborted ||\n           initialServerPrerenderController.signal.aborted\n         ) {\n           // These are expected errors that might error the prerender. we ignore them.\n@@ -3075,8 +3163,10 @@ async function prerenderToStream(\n       }\n \n       if (initialServerResult) {\n-        const initialClientRenderController = new AbortController()\n         const initialClientPrerenderController = new AbortController()\n+        const initialClientReactController = new AbortController()\n+        const initialClientRenderController = new AbortController()\n+\n         const initialClientPrerenderStore: PrerenderStore = {\n           type: 'prerender-client',\n           phase: 'render',\n@@ -3114,7 +3204,7 @@ async function prerenderToStream(\n             nonce={nonce}\n           />,\n           {\n-            signal: initialClientRenderController.signal,\n+            signal: initialClientReactController.signal,\n             onError: (err) => {\n               const digest = getDigestForWellKnownError(err)\n \n@@ -3128,7 +3218,7 @@ async function prerenderToStream(\n                 return undefined\n               }\n \n-              if (initialClientRenderController.signal.aborted) {\n+              if (initialClientReactController.signal.aborted) {\n                 // These are expected errors that might error the prerender. we ignore them.\n               } else if (\n                 process.env.NEXT_DEBUG_BUILD ||\n@@ -3143,9 +3233,20 @@ async function prerenderToStream(\n           }\n         )\n \n+        // The listener to abort our own render controller must be added after\n+        // React has added its listener, to ensure that pending I/O is not\n+        // aborted/rejected too early.\n+        initialClientReactController.signal.addEventListener(\n+          'abort',\n+          () => {\n+            initialClientRenderController.abort()\n+          },\n+          { once: true }\n+        )\n+\n         pendingInitialClientResult.catch((err) => {\n           if (\n-            initialServerRenderController.signal.aborted ||\n+            initialClientReactController.signal.aborted ||\n             isPrerenderInterruptedError(err)\n           ) {\n             // These are expected errors that might error the prerender. we ignore them.\n@@ -3163,11 +3264,13 @@ async function prerenderToStream(\n         // Promises passed to client were already awaited above (assuming that they came from cached functions)\n         trackPendingModules(cacheSignal)\n         await cacheSignal.cacheReady()\n-        initialClientRenderController.abort()\n+        initialClientReactController.abort()\n       }\n \n       let serverIsDynamic = false\n-      const finalServerController = new AbortController()\n+      const finalServerReactController = new AbortController()\n+      const finalServerRenderController = new AbortController()\n+\n       const serverDynamicTracking = createDynamicTrackingState(\n         isDebugDynamicAccesses\n       )\n@@ -3177,8 +3280,8 @@ async function prerenderToStream(\n         phase: 'render',\n         rootParams,\n         implicitTags,\n-        renderSignal: finalServerController.signal,\n-        controller: finalServerController,\n+        renderSignal: finalServerRenderController.signal,\n+        controller: finalServerReactController,\n         // All caches we could read must already be filled so no tracking is necessary\n         cacheSignal: null,\n         dynamicTracking: serverDynamicTracking,\n@@ -3205,7 +3308,7 @@ async function prerenderToStream(\n         await createReactServerPrerenderResult(\n           prerenderAndAbortInSequentialTasks(\n             async () => {\n-              const prerenderResult = await workUnitAsyncStorage.run(\n+              const pendingPrerenderResult = workUnitAsyncStorage.run(\n                 // The store to scope\n                 finalServerPrerenderStore,\n                 // The function to run\n@@ -3218,14 +3321,28 @@ async function prerenderToStream(\n                   onError: (err: unknown) => {\n                     return serverComponentsErrorHandler(err)\n                   },\n-                  signal: finalServerController.signal,\n+                  signal: finalServerReactController.signal,\n                 }\n               )\n+\n+              // The listener to abort our own render controller must be added\n+              // after React has added its listener, to ensure that pending I/O\n+              // is not aborted/rejected too early.\n+              finalServerReactController.signal.addEventListener(\n+                'abort',\n+                () => {\n+                  finalServerRenderController.abort()\n+                },\n+                { once: true }\n+              )\n+\n+              const prerenderResult = await pendingPrerenderResult\n               prerenderIsPending = false\n+\n               return prerenderResult\n             },\n             () => {\n-              if (finalServerController.signal.aborted) {\n+              if (finalServerReactController.signal.aborted) {\n                 // If the server controller is already aborted we must have called something\n                 // that required aborting the prerender synchronously such as with new Date()\n                 serverIsDynamic = true\n@@ -3237,22 +3354,26 @@ async function prerenderToStream(\n                 // there is something unfinished.\n                 serverIsDynamic = true\n               }\n-              finalServerController.abort()\n+\n+              finalServerReactController.abort()\n             }\n           )\n         ))\n \n       const clientDynamicTracking = createDynamicTrackingState(\n         isDebugDynamicAccesses\n       )\n-      const finalClientController = new AbortController()\n+\n+      const finalClientReactController = new AbortController()\n+      const finalClientRenderController = new AbortController()\n+\n       const finalClientPrerenderStore: PrerenderStore = {\n         type: 'prerender-client',\n         phase: 'render',\n         rootParams,\n         implicitTags,\n-        renderSignal: finalClientController.signal,\n-        controller: finalClientController,\n+        renderSignal: finalClientRenderController.signal,\n+        controller: finalClientReactController,\n         // No APIs require a cacheSignal through the workUnitStore during the HTML prerender\n         cacheSignal: null,\n         dynamicTracking: clientDynamicTracking,\n@@ -3274,8 +3395,8 @@ async function prerenderToStream(\n       ).prerender\n       let { prelude: unprocessedPrelude, postponed } =\n         await prerenderAndAbortInSequentialTasks(\n-          () =>\n-            workUnitAsyncStorage.run(\n+          () => {\n+            const pendingFinalClientResult = workUnitAsyncStorage.run(\n               finalClientPrerenderStore,\n               prerender,\n               <App\n@@ -3287,11 +3408,11 @@ async function prerenderToStream(\n                 nonce={nonce}\n               />,\n               {\n-                signal: finalClientController.signal,\n+                signal: finalClientReactController.signal,\n                 onError: (err: unknown, errorInfo: ErrorInfo) => {\n                   if (\n                     isPrerenderInterruptedError(err) ||\n-                    finalClientController.signal.aborted\n+                    finalClientReactController.signal.aborted\n                   ) {\n                     const componentStack: string | undefined = (\n                       errorInfo as any\n@@ -3317,9 +3438,23 @@ async function prerenderToStream(\n                 maxHeadersLength: reactMaxHeadersLength,\n                 bootstrapScripts: [bootstrapScript],\n               }\n-            ),\n+            )\n+\n+            // The listener to abort our own render controller must be added\n+            // after React has added its listener, to ensure that pending I/O is\n+            // not aborted/rejected too early.\n+            finalClientReactController.signal.addEventListener(\n+              'abort',\n+              () => {\n+                finalClientRenderController.abort()\n+              },\n+              { once: true }\n+            )\n+\n+            return pendingFinalClientResult\n+          },\n           () => {\n-            finalClientController.abort()\n+            finalClientReactController.abort()\n           }\n         )\n "
        },
        {
            "sha": "9e3639214ff9d9f41d40294b3d63e4dddcf24885",
            "filename": "packages/next/src/server/app-render/work-unit-async-storage.external.ts",
            "status": "modified",
            "additions": 19,
            "deletions": 7,
            "changes": 26,
            "blob_url": "https://github.com/vercel/next.js/blob/2256b6befe223fba2f141d11d2ca1c0524b67b7a/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwork-unit-async-storage.external.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/2256b6befe223fba2f141d11d2ca1c0524b67b7a/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwork-unit-async-storage.external.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwork-unit-async-storage.external.ts?ref=2256b6befe223fba2f141d11d2ca1c0524b67b7a",
            "patch": "@@ -92,20 +92,32 @@ interface PrerenderStoreModernServer extends PrerenderStoreModernCommon {\n \n interface PrerenderStoreModernCommon extends CommonWorkUnitStore {\n   /**\n-   * This signal is aborted when the React render is complete. (i.e. it is the same signal passed to react)\n+   * The render signal is aborted after React's `prerender` function is aborted\n+   * (using a separate signal), which happens in two cases:\n+   *\n+   * 1. When all caches are filled during the prospective prerender.\n+   * 2. When the final prerender is aborted immediately after the prerender was\n+   *    started.\n+   *\n+   * It can be used to reject any pending I/O, including hanging promises. This\n+   * allows React to properly track the async I/O in dev mode, which yields\n+   * better owner stacks for dynamic validation errors.\n    */\n   readonly renderSignal: AbortSignal\n+\n   /**\n-   * This is the AbortController which represents the boundary between Prerender and dynamic. In some renders it is\n-   * the same as the controller for the renderSignal but in others it is a separate controller. It should be aborted\n-   * whenever the we are no longer in the prerender phase of rendering. Typically this is after one task or when you call\n-   * a sync API which requires the prerender to end immediately\n+   * This is the AbortController which represents the boundary between Prerender\n+   * and dynamic. In some renders it is the same as the controller for React,\n+   * but in others it is a separate controller. It should be aborted whenever we\n+   * are no longer in the prerender phase of rendering. Typically this is after\n+   * one task, or when you call a sync API which requires the prerender to end\n+   * immediately.\n    */\n   readonly controller: AbortController\n \n   /**\n-   * when not null this signal is used to track cache reads during prerendering and\n-   * to await all cache reads completing before aborting the prerender.\n+   * When not null, this signal is used to track cache reads during prerendering\n+   * and to await all cache reads completing, before aborting the prerender.\n    */\n   readonly cacheSignal: null | CacheSignal\n "
        },
        {
            "sha": "01afd201247dce8f582276baa1ed32a00e8a5ae6",
            "filename": "packages/next/src/server/lib/patch-fetch.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/2256b6befe223fba2f141d11d2ca1c0524b67b7a/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fpatch-fetch.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/2256b6befe223fba2f141d11d2ca1c0524b67b7a/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fpatch-fetch.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fpatch-fetch.ts?ref=2256b6befe223fba2f141d11d2ca1c0524b67b7a",
            "patch": "@@ -559,7 +559,7 @@ export function createPatchedFetcher(\n                 cacheSignal = null\n               }\n \n-              return await makeHangingPromise<Response>(\n+              return makeHangingPromise<Response>(\n                 workUnitStore.renderSignal,\n                 'fetch()'\n               )\n@@ -669,7 +669,7 @@ export function createPatchedFetcher(\n                     cacheSignal.endRead()\n                     cacheSignal = null\n                   }\n-                  return await makeHangingPromise<Response>(\n+                  return makeHangingPromise<Response>(\n                     workUnitStore.renderSignal,\n                     'fetch()'\n                   )\n@@ -1010,7 +1010,7 @@ export function createPatchedFetcher(\n                     cacheSignal.endRead()\n                     cacheSignal = null\n                   }\n-                  return await makeHangingPromise<Response>(\n+                  return makeHangingPromise<Response>(\n                     workUnitStore.renderSignal,\n                     'fetch()'\n                   )\n@@ -1044,7 +1044,7 @@ export function createPatchedFetcher(\n                 switch (workUnitStore.type) {\n                   case 'prerender':\n                   case 'prerender-client':\n-                    return await makeHangingPromise<Response>(\n+                    return makeHangingPromise<Response>(\n                       workUnitStore.renderSignal,\n                       'fetch()'\n                     )"
        },
        {
            "sha": "efdbd4c21a7bc5e5c0a728f8df4bcdb6a9bc46f9",
            "filename": "packages/next/src/server/use-cache/use-cache-wrapper.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/2256b6befe223fba2f141d11d2ca1c0524b67b7a/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/2256b6befe223fba2f141d11d2ca1c0524b67b7a/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts?ref=2256b6befe223fba2f141d11d2ca1c0524b67b7a",
            "patch": "@@ -821,7 +821,7 @@ export function cache(\n             )\n \n             if (dynamicAccessAbortController.signal.aborted) {\n-              return await makeHangingPromise(\n+              return makeHangingPromise(\n                 workUnitStore.renderSignal,\n                 dynamicAccessAbortController.signal.reason.message\n               )\n@@ -886,7 +886,7 @@ export function cache(\n                 if (cacheSignal) {\n                   cacheSignal.endRead()\n                 }\n-                return await makeHangingPromise(\n+                return makeHangingPromise(\n                   workUnitStore.renderSignal,\n                   'dynamic \"use cache\"'\n                 )\n@@ -935,7 +935,7 @@ export function cache(\n                 // transformed with an async function, before being passed into\n                 // the \"use cache\" function, which escapes the instrumentation.\n                 if (workUnitStore.allowEmptyStaticShell) {\n-                  return await makeHangingPromise(\n+                  return makeHangingPromise(\n                     workUnitStore.renderSignal,\n                     'dynamic \"use cache\"'\n                   )\n@@ -1030,7 +1030,7 @@ export function cache(\n               if (cacheSignal) {\n                 cacheSignal.endRead()\n               }\n-              return await makeHangingPromise(\n+              return makeHangingPromise(\n                 workUnitStore.renderSignal,\n                 'dynamic \"use cache\"'\n               )\n@@ -1087,7 +1087,7 @@ export function cache(\n           )\n \n           if (result.type === 'prerender-dynamic') {\n-            return await result.hangingPromise\n+            return result.hangingPromise\n           }\n \n           const { stream: newStream, pendingCacheEntry } = result"
        },
        {
            "sha": "74cacf9621f84c0c320b2877c242e78e44f8447c",
            "filename": "test/e2e/app-dir/cache-components-errors/cache-components-errors.test.ts",
            "status": "modified",
            "additions": 14,
            "deletions": 14,
            "changes": 28,
            "blob_url": "https://github.com/vercel/next.js/blob/2256b6befe223fba2f141d11d2ca1c0524b67b7a/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Fcache-components-errors.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/2256b6befe223fba2f141d11d2ca1c0524b67b7a/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Fcache-components-errors.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Fcache-components-errors.test.ts?ref=2256b6befe223fba2f141d11d2ca1c0524b67b7a",
            "patch": "@@ -1758,20 +1758,20 @@ describe('Cache Components Errors', () => {\n               `)\n             } else {\n               await expect(browser).toDisplayCollapsedRedbox(`\n-                            {\n-                              \"description\": \"Route \"/sync-attribution/unguarded-async-guarded-clientsync\": A component accessed data, headers, params, searchParams, or a short-lived cache without a Suspense boundary nor a \"use cache\" above it. See more info: https://nextjs.org/docs/messages/next-prerender-missing-suspense\",\n-                              \"environmentLabel\": \"Server\",\n-                              \"label\": \"Console Error\",\n-                              \"source\": \"app/sync-attribution/unguarded-async-guarded-clientsync/page.tsx (33:16) @ RequestData\n-                            > 33 | async function RequestData() {\n-                                 |                ^\",\n-                              \"stack\": [\n-                                \"RequestData app/sync-attribution/unguarded-async-guarded-clientsync/page.tsx (33:16)\",\n-                                \"Page app/sync-attribution/unguarded-async-guarded-clientsync/page.tsx (27:9)\",\n-                                \"LogSafely <anonymous>\",\n-                              ],\n-                            }\n-                          `)\n+               {\n+                 \"description\": \"Route \"/sync-attribution/unguarded-async-guarded-clientsync\": A component accessed data, headers, params, searchParams, or a short-lived cache without a Suspense boundary nor a \"use cache\" above it. See more info: https://nextjs.org/docs/messages/next-prerender-missing-suspense\",\n+                 \"environmentLabel\": \"Server\",\n+                 \"label\": \"Console Error\",\n+                 \"source\": \"app/sync-attribution/unguarded-async-guarded-clientsync/page.tsx (34:18) @ RequestData\n+               > 34 |   ;(await cookies()).get('foo')\n+                    |                  ^\",\n+                 \"stack\": [\n+                   \"RequestData app/sync-attribution/unguarded-async-guarded-clientsync/page.tsx (34:18)\",\n+                   \"Page app/sync-attribution/unguarded-async-guarded-clientsync/page.tsx (27:9)\",\n+                   \"LogSafely <anonymous>\",\n+                 ],\n+               }\n+              `)\n             }\n           })\n         } else {"
        },
        {
            "sha": "794d8b55ec906d3ca4a94bf703c3e8e39a362b53",
            "filename": "test/e2e/app-dir/cache-components-errors/update-snapshots.sh",
            "status": "modified",
            "additions": 28,
            "deletions": 6,
            "changes": 34,
            "blob_url": "https://github.com/vercel/next.js/blob/2256b6befe223fba2f141d11d2ca1c0524b67b7a/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Fupdate-snapshots.sh",
            "raw_url": "https://github.com/vercel/next.js/raw/2256b6befe223fba2f141d11d2ca1c0524b67b7a/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Fupdate-snapshots.sh",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Fupdate-snapshots.sh?ref=2256b6befe223fba2f141d11d2ca1c0524b67b7a",
            "patch": "@@ -1,17 +1,39 @@\n #!/usr/bin/env bash\n \n-# Run `test/e2e/app-dir/cache-components-errors/update-snapshots.sh` from the root of\n-# the monorepo to update the snapshots of the cache components errors test suite.\n+# Run `test/e2e/app-dir/cache-components-errors/update-snapshots.sh` from the\n+# root of the monorepo to update the snapshots of the cache components errors\n+# test suite.\n \n set -xeuo pipefail\n \n-SCRIPT_DIR=`dirname ${BASH_SOURCE[0]-$0}`\n+SCRIPT_DIR=$(dirname \"${BASH_SOURCE[0]-$0}\")\n TESTS=(\"$SCRIPT_DIR/cache-components-errors.test.ts\")\n+DEV=false\n+START=false\n+\n+# Parse CLI flags\n+for arg in \"$@\"; do\n+  case \"$arg\" in\n+    --dev)   DEV=true ;;\n+    --start) START=true ;;\n+    *)       echo \"Unknown option: $arg\"; exit 1 ;;\n+  esac\n+done\n+\n+# If no flags are provided, update all snapshots.\n+if [ \"$DEV\" = false ] && [ \"$START\" = false ]; then\n+  DEV=true\n+  START=true\n+fi\n \n # Update `next dev` snapshots for both Turbopack and Webpack.\n-pnpm test-dev \"${TESTS[@]}\" --projects jest.config.* -u\n+if [ \"$DEV\" = true ]; then\n+  pnpm test-dev \"${TESTS[@]}\" --projects jest.config.* -u\n+fi\n \n # The `next start` snapshots can't be created for both prerender modes at the\n # same time because of an issue in the typescript plugin for prettier.\n-NEXT_TEST_DEBUG_PRERENDER=false pnpm test-start \"${TESTS[@]}\" --projects jest.config.* -u\n-NEXT_TEST_DEBUG_PRERENDER=true pnpm test-start \"${TESTS[@]}\" --projects jest.config.* -u\n+if [ \"$START\" = true ]; then\n+  NEXT_TEST_DEBUG_PRERENDER=false pnpm test-start \"${TESTS[@]}\" --projects jest.config.* -u\n+  NEXT_TEST_DEBUG_PRERENDER=true  pnpm test-start \"${TESTS[@]}\" --projects jest.config.* -u\n+fi"
        }
    ],
    "stats": {
        "total": 375,
        "additions": 272,
        "deletions": 103
    }
}