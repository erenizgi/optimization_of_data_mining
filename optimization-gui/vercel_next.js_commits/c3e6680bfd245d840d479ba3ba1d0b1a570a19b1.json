{
    "author": "wyattjoh",
    "message": "perf(build): optimize buildAppStaticPaths performance and add helper function (#81386)\n\n### What?\n\nOptimizes the `buildAppStaticPaths` function performance and extracts a\nhelper function `calculateFallbackMode` to reduce code duplication.\n\n### Why?\n\nThe `buildAppStaticPaths` function had several performance bottlenecks:\n\n1. **Repeated regex pattern compilation**: Route parameter patterns were\nbeing compiled inside the loop for every route, causing unnecessary\noverhead\n2. **Inefficient root parameter lookups**: Using `Array.includes()` for\nroot parameter checks resulted in O(n) lookups for each parameter\n3. **Duplicated fallback mode logic**: The same fallback mode\ncalculation was repeated in multiple places, making the code harder to\nmaintain and prone to inconsistencies\n\nThese inefficiencies became more apparent when processing large numbers\nof routes with complex parameter structures.\n\n### How?\n\n**Performance optimizations:**\n- Pre-compile regex patterns for route parameters outside the loop and\nstore them in a Map for O(1) lookups\n- Convert `rootParamKeys` to a Set for O(1) lookup time instead of O(n)\narray searches\n- Optimize the fallback parameter collection loop to break early and\navoid redundant iterations\n\n**Code organization:**\n- Extract `calculateFallbackMode` helper function to eliminate code\nduplication\n- Add comprehensive tests for the new helper function to ensure\ncorrectness\n- Simplify the main loop logic by using the pre-compiled patterns and\noptimized data structures",
    "sha": "c3e6680bfd245d840d479ba3ba1d0b1a570a19b1",
    "files": [
        {
            "sha": "88b5806d7a7d6fd0bc91dcd6dbc2eb9a6fd5cc9c",
            "filename": "packages/next/src/build/static-paths/app.test.ts",
            "status": "modified",
            "additions": 90,
            "deletions": 23,
            "changes": 113,
            "blob_url": "https://github.com/vercel/next.js/blob/c3e6680bfd245d840d479ba3ba1d0b1a570a19b1/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/c3e6680bfd245d840d479ba3ba1d0b1a570a19b1/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp.test.ts?ref=c3e6680bfd245d840d479ba3ba1d0b1a570a19b1",
            "patch": "@@ -2,7 +2,8 @@ import { FallbackMode } from '../../lib/fallback'\n import type { Params } from '../../server/request/params'\n import {\n   assignErrorIfEmpty,\n-  generateParamPrefixCombinations,\n+  generateAllParamCombinations,\n+  calculateFallbackMode,\n   filterUniqueParams,\n   generateRouteStaticParams,\n } from './app'\n@@ -356,7 +357,7 @@ describe('generateParamPrefixCombinations', () => {\n       { id: '2', name: 'test' },\n     ]\n \n-    const unique = generateParamPrefixCombinations(['id'], params, [])\n+    const unique = generateAllParamCombinations(['id'], params, [])\n \n     expect(unique).toEqual([{ id: '1' }, { id: '2' }])\n   })\n@@ -369,11 +370,7 @@ describe('generateParamPrefixCombinations', () => {\n       { lang: 'fr', region: 'CA', page: 'about' },\n     ]\n \n-    const unique = generateParamPrefixCombinations(\n-      ['lang', 'region'],\n-      params,\n-      []\n-    )\n+    const unique = generateAllParamCombinations(['lang', 'region'], params, [])\n \n     expect(unique).toEqual([\n       { lang: 'en' },\n@@ -386,20 +383,20 @@ describe('generateParamPrefixCombinations', () => {\n   it('should handle parameter value collisions', () => {\n     const params = [{ slug: ['foo', 'bar'] }, { slug: 'foo,bar' }]\n \n-    const unique = generateParamPrefixCombinations(['slug'], params, [])\n+    const unique = generateAllParamCombinations(['slug'], params, [])\n \n     expect(unique).toEqual([{ slug: ['foo', 'bar'] }, { slug: 'foo,bar' }])\n   })\n \n   it('should handle empty inputs', () => {\n     // Empty routeParamKeys\n-    expect(generateParamPrefixCombinations([], [{ id: '1' }], [])).toEqual([])\n+    expect(generateAllParamCombinations([], [{ id: '1' }], [])).toEqual([])\n \n     // Empty routeParams\n-    expect(generateParamPrefixCombinations(['id'], [], [])).toEqual([])\n+    expect(generateAllParamCombinations(['id'], [], [])).toEqual([])\n \n     // Both empty\n-    expect(generateParamPrefixCombinations([], [], [])).toEqual([])\n+    expect(generateAllParamCombinations([], [], [])).toEqual([])\n   })\n \n   it('should handle undefined parameters', () => {\n@@ -409,7 +406,7 @@ describe('generateParamPrefixCombinations', () => {\n       { id: '3' }, // missing name key\n     ]\n \n-    const unique = generateParamPrefixCombinations(['id', 'name'], params, [])\n+    const unique = generateAllParamCombinations(['id', 'name'], params, [])\n \n     expect(unique).toEqual([\n       { id: '1' },\n@@ -426,7 +423,7 @@ describe('generateParamPrefixCombinations', () => {\n       { lang: 'fr' }, // missing region and category\n     ]\n \n-    const unique = generateParamPrefixCombinations(\n+    const unique = generateAllParamCombinations(\n       ['lang', 'region', 'category'],\n       params,\n       []\n@@ -450,7 +447,7 @@ describe('generateParamPrefixCombinations', () => {\n       { slug: 'U:undefined' }, // String that looks like undefined prefix\n     ]\n \n-    const unique = generateParamPrefixCombinations(['slug'], params, [])\n+    const unique = generateAllParamCombinations(['slug'], params, [])\n \n     expect(unique).toEqual([\n       { slug: ['foo', 'bar'] },\n@@ -468,7 +465,7 @@ describe('generateParamPrefixCombinations', () => {\n       { slug: ['foo', 'bar|baz'] }, // Array with pipe in element\n     ]\n \n-    const unique = generateParamPrefixCombinations(['slug'], params, [])\n+    const unique = generateAllParamCombinations(['slug'], params, [])\n \n     expect(unique).toEqual([{ slug: 'foo|bar' }, { slug: ['foo', 'bar|baz'] }])\n   })\n@@ -480,7 +477,7 @@ describe('generateParamPrefixCombinations', () => {\n       { a: '1', b: '2', c: '3', d: '7' },\n     ]\n \n-    const unique = generateParamPrefixCombinations(\n+    const unique = generateAllParamCombinations(\n       ['a', 'b', 'c', 'd', 'e'],\n       params,\n       []\n@@ -505,7 +502,7 @@ describe('generateParamPrefixCombinations', () => {\n       { lang: 'fr', region: 'CA', slug: 'about' },\n     ]\n \n-    const unique = generateParamPrefixCombinations(\n+    const unique = generateAllParamCombinations(\n       ['lang', 'region', 'slug'],\n       params,\n       ['lang', 'region'] // Root params\n@@ -529,7 +526,7 @@ describe('generateParamPrefixCombinations', () => {\n       { category: 'sports', slug: 'news' },\n     ]\n \n-    const unique = generateParamPrefixCombinations(\n+    const unique = generateAllParamCombinations(\n       ['category', 'slug'],\n       params,\n       [] // No root params\n@@ -552,7 +549,7 @@ describe('generateParamPrefixCombinations', () => {\n       { lang: 'fr', page: 'home' },\n     ]\n \n-    const unique = generateParamPrefixCombinations(\n+    const unique = generateAllParamCombinations(\n       ['lang', 'page'],\n       params,\n       ['lang'] // Single root param\n@@ -575,7 +572,7 @@ describe('generateParamPrefixCombinations', () => {\n       { page: 'contact' }, // Missing lang root param\n     ]\n \n-    const unique = generateParamPrefixCombinations(\n+    const unique = generateAllParamCombinations(\n       ['lang', 'page'],\n       params,\n       ['lang'] // Root param\n@@ -596,7 +593,7 @@ describe('generateParamPrefixCombinations', () => {\n       { category: 'sports', slug: 'news' },\n     ]\n \n-    const unique = generateParamPrefixCombinations(\n+    const unique = generateAllParamCombinations(\n       ['category', 'slug'],\n       params,\n       ['lang', 'region'] // Root params not in route params\n@@ -620,7 +617,7 @@ describe('generateParamPrefixCombinations', () => {\n       { lang: 'en', locale: 'us' }, // Missing slug parameter\n     ]\n \n-    const unique = generateParamPrefixCombinations(\n+    const unique = generateAllParamCombinations(\n       ['lang', 'locale', 'slug'], // All route params\n       params,\n       ['lang', 'locale'] // Root params\n@@ -637,7 +634,7 @@ describe('generateParamPrefixCombinations', () => {\n     // This might be what's happening for the [slug] route\n     const params: Params[] = [] // No generateStaticParams results\n \n-    const unique = generateParamPrefixCombinations(\n+    const unique = generateAllParamCombinations(\n       ['lang', 'locale', 'slug'], // All route params\n       params,\n       ['lang', 'locale'] // Root params\n@@ -1027,3 +1024,73 @@ describe('generateRouteStaticParams', () => {\n     })\n   })\n })\n+\n+describe('calculateFallbackMode', () => {\n+  it('should return NOT_FOUND when dynamic params are disabled', () => {\n+    const result = calculateFallbackMode(false, [], FallbackMode.PRERENDER)\n+\n+    expect(result).toBe(FallbackMode.NOT_FOUND)\n+  })\n+\n+  it('should return NOT_FOUND when dynamic params are disabled regardless of root params', () => {\n+    const result = calculateFallbackMode(\n+      false,\n+      ['rootParam'],\n+      FallbackMode.BLOCKING_STATIC_RENDER\n+    )\n+\n+    expect(result).toBe(FallbackMode.NOT_FOUND)\n+  })\n+\n+  it('should return BLOCKING_STATIC_RENDER when dynamic params are enabled and root params exist', () => {\n+    const result = calculateFallbackMode(\n+      true,\n+      ['rootParam1', 'rootParam2'],\n+      FallbackMode.PRERENDER\n+    )\n+\n+    expect(result).toBe(FallbackMode.BLOCKING_STATIC_RENDER)\n+  })\n+\n+  it('should return base fallback mode when dynamic params are enabled and no root params', () => {\n+    const result = calculateFallbackMode(true, [], FallbackMode.PRERENDER)\n+\n+    expect(result).toBe(FallbackMode.PRERENDER)\n+  })\n+\n+  it('should return base fallback mode when dynamic params are enabled and empty root params', () => {\n+    const result = calculateFallbackMode(\n+      true,\n+      [],\n+      FallbackMode.BLOCKING_STATIC_RENDER\n+    )\n+\n+    expect(result).toBe(FallbackMode.BLOCKING_STATIC_RENDER)\n+  })\n+\n+  it('should return NOT_FOUND when dynamic params are enabled but no base fallback mode provided', () => {\n+    const result = calculateFallbackMode(true, [], undefined)\n+\n+    expect(result).toBe(FallbackMode.NOT_FOUND)\n+  })\n+\n+  it('should prioritize root params over base fallback mode', () => {\n+    const result = calculateFallbackMode(\n+      true,\n+      ['rootParam'],\n+      FallbackMode.PRERENDER\n+    )\n+\n+    expect(result).toBe(FallbackMode.BLOCKING_STATIC_RENDER)\n+  })\n+\n+  it('should handle single root param correctly', () => {\n+    const result = calculateFallbackMode(\n+      true,\n+      ['singleParam'],\n+      FallbackMode.PRERENDER\n+    )\n+\n+    expect(result).toBe(FallbackMode.BLOCKING_STATIC_RENDER)\n+  })\n+})"
        },
        {
            "sha": "94be2a22e594baaad4880e864b2a5d8c8d3189fb",
            "filename": "packages/next/src/build/static-paths/app.ts",
            "status": "modified",
            "additions": 117,
            "deletions": 87,
            "changes": 204,
            "blob_url": "https://github.com/vercel/next.js/blob/c3e6680bfd245d840d479ba3ba1d0b1a570a19b1/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/c3e6680bfd245d840d479ba3ba1d0b1a570a19b1/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp.ts?ref=c3e6680bfd245d840d479ba3ba1d0b1a570a19b1",
            "patch": "@@ -76,17 +76,17 @@ export function filterUniqueParams(\n }\n \n /**\n- * Generates all unique sub-combinations of route params from a list of parameters.\n- * This function creates all possible prefixes of the route parameters, which is\n- * useful for generating partial routes that can serve as shells for more specific routes.\n+ * Generates all unique sub-combinations of Route Parameters from a list of Static Parameters.\n+ * This function creates all possible prefixes of the Route Parameters, which is\n+ * useful for generating Static Shells that can serve as Fallback Shells for more specific Route Shells.\n  *\n- * When rootParamKeys are provided, the function ensures that partial shells only\n- * include complete sets of root params. This prevents generating invalid partial\n- * routes that are missing required root parameters.\n+ * When Root Parameters are provided, the function ensures that Static Shells only\n+ * include complete sets of Root Parameters. This prevents generating invalid Static Shells\n+ * that are missing required Root Parameters.\n  *\n- * Example with root params ('lang', 'region') and route params ('lang', 'region', 'slug'):\n+ * Example with Root Parameters ('lang', 'region') and Route Parameters ('lang', 'region', 'slug'):\n  *\n- * Given the following routeParams:\n+ * Given the following Static Parameters:\n  * ```\n  * [\n  *   { lang: 'en', region: 'US', slug: ['home'] },\n@@ -98,84 +98,84 @@ export function filterUniqueParams(\n  * The result will be:\n  * ```\n  * [\n- *   { lang: 'en', region: 'US' },  // Complete root params\n+ *   { lang: 'en', region: 'US' },  // Complete Root Parameters\n  *   { lang: 'en', region: 'US', slug: ['home'] },\n  *   { lang: 'en', region: 'US', slug: ['about'] },\n- *   { lang: 'fr', region: 'CA' },  // Complete root params\n+ *   { lang: 'fr', region: 'CA' },  // Complete Root Parameters\n  *   { lang: 'fr', region: 'CA', slug: ['about'] },\n  * ]\n  * ```\n  *\n  * Note that partial combinations like `{ lang: 'en' }` are NOT generated because\n- * they don't include the complete set of root params.\n+ * they don't include the complete set of Root Parameters.\n  *\n- * For routes without root params (e.g., `/[slug]`), all sub-combinations are generated\n+ * For routes without Root Parameters (e.g., `/[slug]`), all sub-combinations are generated\n  * as before.\n  *\n- * @param routeParamKeys - The keys of the route params. These should be sorted\n+ * @param routeParamKeys - The keys of the Route Parameters. These should be sorted\n  *   to ensure consistent key generation for the internal Map.\n- * @param routeParams - The list of parameter objects to filter.\n- * @param rootParamKeys - The keys of the root params. When provided, ensures partial\n- *   shells include all root params.\n- * @returns A new array containing all unique sub-combinations of route params.\n+ * @param routeParams - The list of Static Parameters to filter.\n+ * @param rootParamKeys - The keys of the Root Parameters. When provided, ensures Static Shells\n+ *   include all Root Parameters.\n+ * @returns A new array containing all unique sub-combinations of Route Parameters.\n  */\n-export function generateParamPrefixCombinations(\n+export function generateAllParamCombinations(\n   routeParamKeys: readonly string[],\n   routeParams: readonly Params[],\n   rootParamKeys: readonly string[]\n ): Params[] {\n-  // A Map is used to store unique combinations of route parameters.\n-  // The key of the Map is a string representation of the route parameter\n+  // A Map is used to store unique combinations of Route Parameters.\n+  // The key of the Map is a string representation of the Route Parameter\n   // combination, and the value is the `Params` object containing only\n-  // the route parameters.\n+  // the Route Parameters.\n   const combinations = new Map<string, Params>()\n \n-  // Determine the minimum index where all root params are included.\n+  // Determine the minimum index where all Root Parameters are included.\n   // This optimization ensures we only generate combinations that include\n-  // a complete set of root parameters, preventing invalid partial shells.\n+  // a complete set of Root Parameters, preventing invalid Static Shells.\n   //\n   // For example, if rootParamKeys = ['lang', 'region'] and routeParamKeys = ['lang', 'region', 'slug']:\n   // - 'lang' is at index 0, 'region' is at index 1\n   // - minIndexForCompleteRootParams = max(0, 1) = 1\n   // - We'll only generate combinations starting from index 1 (which includes both lang and region)\n   let minIndexForCompleteRootParams = -1\n   if (rootParamKeys.length > 0) {\n-    // Find the index of the last root param in routeParamKeys.\n-    // This tells us the minimum combination length needed to include all root params.\n+    // Find the index of the last Root Parameter in routeParamKeys.\n+    // This tells us the minimum combination length needed to include all Root Parameters.\n     for (const rootParamKey of rootParamKeys) {\n       const index = routeParamKeys.indexOf(rootParamKey)\n       if (index === -1) {\n-        // Root param not found in route params - this shouldn't happen in normal cases\n-        // but we handle it gracefully by treating it as if there are no root params.\n+        // Root Parameter not found in Route Parameters - this shouldn't happen in normal cases\n+        // but we handle it gracefully by treating it as if there are no Root Parameters.\n         // This allows the function to fall back to generating all sub-combinations.\n         minIndexForCompleteRootParams = -1\n         break\n       }\n-      // Track the highest index among all root params.\n-      // This ensures all root params are included in any generated combination.\n+      // Track the highest index among all Root Parameters.\n+      // This ensures all Root Parameters are included in any generated combination.\n       minIndexForCompleteRootParams = Math.max(\n         minIndexForCompleteRootParams,\n         index\n       )\n     }\n   }\n \n-  // Iterate over each parameter object in the input array.\n+  // Iterate over each Static Parameter object in the input array.\n   // Each params object represents one potential route combination (e.g., { lang: 'en', region: 'US', slug: 'home' })\n   for (const params of routeParams) {\n-    // Generate all possible prefix combinations for this parameter set.\n+    // Generate all possible prefix combinations for this Static Parameter set.\n     // For routeParamKeys = ['lang', 'region', 'slug'], we'll generate combinations at:\n     // - i=0: { lang: 'en' }\n     // - i=1: { lang: 'en', region: 'US' }\n     // - i=2: { lang: 'en', region: 'US', slug: 'home' }\n     //\n     // The iteration order is crucial for generating stable and unique keys\n-    // for each route parameter combination.\n+    // for each Route Parameter combination.\n     for (let i = 0; i < routeParamKeys.length; i++) {\n-      // Skip generating combinations that don't include all root params.\n-      // This prevents creating invalid partial shells that are missing required root parameters.\n+      // Skip generating combinations that don't include all Root Parameters.\n+      // This prevents creating invalid Static Shells that are missing required Root Parameters.\n       //\n-      // For example, if root params are ['lang', 'region'] and minIndexForCompleteRootParams = 1:\n+      // For example, if Root Parameters are ['lang', 'region'] and minIndexForCompleteRootParams = 1:\n       // - Skip i=0 (would only include 'lang', missing 'region')\n       // - Process i=1 and higher (includes both 'lang' and 'region')\n       if (\n@@ -207,8 +207,8 @@ export function generateParamPrefixCombinations(\n           !params.hasOwnProperty(routeKey) ||\n           params[routeKey] === undefined\n         ) {\n-          // If this missing parameter is a root param, mark the combination as invalid.\n-          // Root params are required for PPR shells, so we can't generate partial combinations without them.\n+          // If this missing parameter is a Root Parameter, mark the combination as invalid.\n+          // Root Parameters are required for Static Shells, so we can't generate partial combinations without them.\n           if (rootParamKeys.includes(routeKey)) {\n             hasAllRootParams = false\n           }\n@@ -243,10 +243,10 @@ export function generateParamPrefixCombinations(\n       const currentKey = keyParts.join('|')\n \n       // Only add the combination if it meets our criteria:\n-      // 1. hasAllRequiredParams: Contains all required root parameters\n+      // 1. hasAllRootParams: Contains all required Root Parameters\n       // 2. !combinations.has(currentKey): Is not a duplicate of an existing combination\n       //\n-      // This ensures we only generate valid, unique parameter combinations for PPR shells.\n+      // This ensures we only generate valid, unique parameter combinations for Static Shells.\n       if (hasAllRootParams && !combinations.has(currentKey)) {\n         combinations.set(currentKey, combination)\n       }\n@@ -259,6 +259,28 @@ export function generateParamPrefixCombinations(\n   return Array.from(combinations.values())\n }\n \n+/**\n+ * Calculates the fallback mode based on the given parameters.\n+ *\n+ * @param dynamicParams - Whether dynamic params are enabled.\n+ * @param fallbackRootParams - The root params that are part of the fallback.\n+ * @param baseFallbackMode - The base fallback mode to use.\n+ * @returns The calculated fallback mode.\n+ */\n+export function calculateFallbackMode(\n+  dynamicParams: boolean,\n+  fallbackRootParams: readonly string[],\n+  baseFallbackMode: FallbackMode | undefined\n+): FallbackMode {\n+  return dynamicParams\n+    ? // If the fallback params includes any root params, then we need to\n+      // perform a blocking static render.\n+      fallbackRootParams.length > 0\n+      ? FallbackMode.BLOCKING_STATIC_RENDER\n+      : baseFallbackMode ?? FallbackMode.NOT_FOUND\n+    : FallbackMode.NOT_FOUND\n+}\n+\n /**\n  * Validates the parameters to ensure they're accessible and have the correct\n  * types.\n@@ -755,33 +777,46 @@ export async function buildAppStaticPaths({\n \n   const prerenderedRoutesByPathname = new Map<string, PrerenderedRoute>()\n \n+  // Precompile the regex patterns for the route params.\n+  const paramPatterns = new Map<string, string>()\n+  for (const key of routeParamKeys) {\n+    const { repeat, optional } = regex.groups[key]\n+    let pattern = `[${repeat ? '...' : ''}${key}]`\n+    if (optional) {\n+      pattern = `[${pattern}]`\n+    }\n+    paramPatterns.set(key, pattern)\n+  }\n+\n+  // Convert rootParamKeys to Set for O(1) lookup.\n+  const rootParamSet = new Set(rootParamKeys)\n+\n   if (hadAllParamsGenerated || isRoutePPREnabled) {\n+    let paramsToProcess = routeParams\n+\n     if (isRoutePPREnabled) {\n       // Discover all unique combinations of the routeParams so we can generate\n       // routes that won't throw on empty static shell for each of them if\n       // they're available.\n-      routeParams.unshift(\n-        ...generateParamPrefixCombinations(\n-          routeParamKeys,\n-          routeParams,\n-          rootParamKeys\n-        )\n+      paramsToProcess = generateAllParamCombinations(\n+        routeParamKeys,\n+        routeParams,\n+        rootParamKeys\n       )\n \n+      // Add the base route, this is the route with all the placeholders as it's\n+      // derived from the `page` string.\n       prerenderedRoutesByPathname.set(page, {\n         params: {},\n         pathname: page,\n         encodedPathname: page,\n         fallbackRouteParams: routeParamKeys,\n-        fallbackMode: dynamicParams\n-          ? // If the fallback params includes any root params, then we need to\n-            // perform a blocking static render.\n-            rootParamKeys.length > 0\n-            ? FallbackMode.BLOCKING_STATIC_RENDER\n-            : fallbackMode\n-          : FallbackMode.NOT_FOUND,\n+        fallbackMode: calculateFallbackMode(\n+          dynamicParams,\n+          rootParamKeys,\n+          fallbackMode\n+        ),\n         fallbackRootParams: rootParamKeys,\n-        // This is set later after all the routes have been processed.\n         throwOnEmptyStaticShell: true,\n       })\n     }\n@@ -794,56 +829,54 @@ export async function buildAppStaticPaths({\n         isRoutePPREnabled,\n         routeParamKeys,\n         rootParamKeys,\n-        routeParams\n+        paramsToProcess\n       )\n     ).forEach((params) => {\n-      let pathname: string = page\n-      let encodedPathname: string = page\n+      let pathname = page\n+      let encodedPathname = page\n \n-      let fallbackRouteParams: string[] = []\n+      const fallbackRouteParams: string[] = []\n \n       for (const key of routeParamKeys) {\n-        if (fallbackRouteParams.length > 0) {\n-          // This is a partial route, so we should add the value to the\n-          // fallbackRouteParams.\n-          fallbackRouteParams.push(key)\n-          continue\n-        }\n-\n-        let paramValue = params[key]\n+        const paramValue = params[key]\n \n         if (!paramValue) {\n           if (isRoutePPREnabled) {\n-            // This is a partial route, so we should add the value to the\n-            // fallbackRouteParams.\n+            // Mark remaining params as fallback params.\n             fallbackRouteParams.push(key)\n-            continue\n+            for (\n+              let i = routeParamKeys.indexOf(key) + 1;\n+              i < routeParamKeys.length;\n+              i++\n+            ) {\n+              fallbackRouteParams.push(routeParamKeys[i])\n+            }\n+            break\n           } else {\n             // This route is not complete, and we aren't performing a partial\n             // prerender, so we should return, skipping this route.\n             return\n           }\n         }\n \n-        const { repeat, optional } = regex.groups[key]\n-        let replaced = `[${repeat ? '...' : ''}${key}]`\n-        if (optional) {\n-          replaced = `[${replaced}]`\n-        }\n-\n+        // Use pre-compiled pattern for replacement\n+        const pattern = paramPatterns.get(key)!\n         pathname = pathname.replace(\n-          replaced,\n+          pattern,\n           encodeParam(paramValue, (value) => escapePathDelimiters(value, true))\n         )\n         encodedPathname = encodedPathname.replace(\n-          replaced,\n+          pattern,\n           encodeParam(paramValue, encodeURIComponent)\n         )\n       }\n \n-      const fallbackRootParams = rootParamKeys.filter((param) =>\n-        fallbackRouteParams.includes(param)\n-      )\n+      const fallbackRootParams: string[] = []\n+      for (const param of fallbackRouteParams) {\n+        if (rootParamSet.has(param)) {\n+          fallbackRootParams.push(param)\n+        }\n+      }\n \n       pathname = normalizePathname(pathname)\n \n@@ -852,15 +885,12 @@ export async function buildAppStaticPaths({\n         pathname,\n         encodedPathname: normalizePathname(encodedPathname),\n         fallbackRouteParams,\n-        fallbackMode: dynamicParams\n-          ? // If the fallback params includes any root params, then we need to\n-            // perform a blocking static render.\n-            fallbackRootParams.length > 0\n-            ? FallbackMode.BLOCKING_STATIC_RENDER\n-            : fallbackMode\n-          : FallbackMode.NOT_FOUND,\n+        fallbackMode: calculateFallbackMode(\n+          dynamicParams,\n+          fallbackRootParams,\n+          fallbackMode\n+        ),\n         fallbackRootParams,\n-        // This is set later after all the routes have been processed.\n         throwOnEmptyStaticShell: true,\n       })\n     })"
        }
    ],
    "stats": {
        "total": 317,
        "additions": 207,
        "deletions": 110
    }
}