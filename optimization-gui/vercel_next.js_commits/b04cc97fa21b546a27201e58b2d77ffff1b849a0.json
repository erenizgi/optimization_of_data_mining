{
    "author": "mischnic",
    "message": "Turbopack: align chunking with graph entries (#76441)\n\nShouldn't have any change in behavior, but prepares for #76211",
    "sha": "b04cc97fa21b546a27201e58b2d77ffff1b849a0",
    "files": [
        {
            "sha": "dc60d9fa0ba99c72dfadd9f7d619943313246d60",
            "filename": "crates/next-api/src/app.rs",
            "status": "modified",
            "additions": 43,
            "deletions": 37,
            "changes": 80,
            "blob_url": "https://github.com/vercel/next.js/blob/b04cc97fa21b546a27201e58b2d77ffff1b849a0/crates%2Fnext-api%2Fsrc%2Fapp.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b04cc97fa21b546a27201e58b2d77ffff1b849a0/crates%2Fnext-api%2Fsrc%2Fapp.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fapp.rs?ref=b04cc97fa21b546a27201e58b2d77ffff1b849a0",
            "patch": "@@ -31,7 +31,7 @@ use next_core::{\n         get_server_module_options_context, get_server_resolve_options_context,\n         get_server_runtime_entries, ServerContextType,\n     },\n-    next_server_utility::NextServerUtilityTransition,\n+    next_server_utility::{NextServerUtilityTransition, NEXT_SERVER_UTILITY_MERGE_TAG},\n     parse_segment_config_from_source,\n     util::NextRuntime,\n };\n@@ -53,14 +53,15 @@ use turbopack::{\n use turbopack_core::{\n     asset::AssetContent,\n     chunk::{\n-        availability_info::AvailabilityInfo, ChunkGroupType, ChunkingContext, ChunkingContextExt,\n+        availability_info::AvailabilityInfo, ChunkGroupResult, ChunkingContext, ChunkingContextExt,\n         EvaluatableAsset, EvaluatableAssets,\n     },\n     file_source::FileSource,\n     ident::AssetIdent,\n     module::Module,\n     module_graph::{\n-        chunk_group_info::ChunkGroup, GraphEntries, ModuleGraph, SingleModuleGraph, VisitedModules,\n+        chunk_group_info::{ChunkGroup, ChunkGroupEntry},\n+        GraphEntries, ModuleGraph, SingleModuleGraph, VisitedModules,\n     },\n     output::{OutputAsset, OutputAssets},\n     raw_output::RawOutput,\n@@ -826,6 +827,9 @@ impl AppProject {\n             // Implements layout segment optimization to compute a graph \"chain\" for each layout\n             // segment\n             async move {\n+                let rsc_entry_chunk_group =\n+                    ChunkGroupEntry::Entry(vec![ResolvedVc::upcast(rsc_entry)]);\n+\n                 let mut graphs = vec![];\n                 let mut visited_modules = if has_layout_segments {\n                     let ServerEntries {\n@@ -835,15 +839,16 @@ impl AppProject {\n \n                     let graph = SingleModuleGraph::new_with_entries_visited_intern(\n                         vec![\n-                            (\n-                                server_utils\n+                            ChunkGroupEntry::SharedMerged {\n+                                parent: Box::new(rsc_entry_chunk_group.clone()),\n+                                merge_tag: NEXT_SERVER_UTILITY_MERGE_TAG.clone(),\n+                                entries: server_utils\n                                     .iter()\n                                     .map(async |m| Ok(ResolvedVc::upcast(m.await?.module)))\n                                     .try_join()\n                                     .await?,\n-                                ChunkGroupType::Entry,\n-                            ),\n-                            (client_shared_entries, ChunkGroupType::Evaluated),\n+                            },\n+                            ChunkGroupEntry::Entry(client_shared_entries),\n                         ],\n                         VisitedModules::empty(),\n                     );\n@@ -852,7 +857,9 @@ impl AppProject {\n \n                     for module in server_component_entries.iter() {\n                         let graph = SingleModuleGraph::new_with_entries_visited_intern(\n-                            vec![(vec![ResolvedVc::upcast(*module)], ChunkGroupType::Entry)],\n+                            // This should really be ChunkGroupEntry::Shared(module.await?.module),\n+                            // but that breaks everything for some reason.\n+                            vec![ChunkGroupEntry::Entry(vec![ResolvedVc::upcast(*module)])],\n                             visited_modules,\n                         );\n                         graphs.push(graph);\n@@ -873,15 +880,15 @@ impl AppProject {\n                     visited_modules\n                 } else {\n                     let graph = SingleModuleGraph::new_with_entries_visited_intern(\n-                        vec![(client_shared_entries, ChunkGroupType::Evaluated)],\n+                        vec![ChunkGroupEntry::Entry(client_shared_entries)],\n                         VisitedModules::empty(),\n                     );\n                     graphs.push(graph);\n                     VisitedModules::from_graph(graph)\n                 };\n \n                 let graph = SingleModuleGraph::new_with_entries_visited_intern(\n-                    vec![(vec![ResolvedVc::upcast(rsc_entry)], ChunkGroupType::Entry)],\n+                    vec![rsc_entry_chunk_group],\n                     visited_modules,\n                 );\n                 graphs.push(graph);\n@@ -1664,25 +1671,35 @@ impl AppEndpoint {\n \n         Ok(match runtime {\n             NextRuntime::Edge => {\n+                let ChunkGroupResult {\n+                    assets,\n+                    availability_info,\n+                } = *chunking_context\n+                    .evaluated_chunk_group(\n+                        server_action_manifest_loader.ident(),\n+                        Vc::cell(vec![server_action_manifest_loader]),\n+                        module_graph,\n+                        Value::new(AvailabilityInfo::Root),\n+                    )\n+                    .await?;\n+\n                 let mut evaluatable_assets =\n                     this.app_project.edge_rsc_runtime_entries().owned().await?;\n                 let evaluatable = ResolvedVc::try_sidecast(app_entry.rsc_entry)\n                     .context(\"Entry module must be evaluatable\")?;\n                 evaluatable_assets.push(evaluatable);\n-                evaluatable_assets.push(server_action_manifest_loader);\n \n-                {\n-                    let _span = tracing::info_span!(\"Server Components\");\n+                assets.concatenate(\n                     chunking_context\n                         .evaluated_chunk_group_assets(\n                             app_entry.rsc_entry.ident(),\n                             Vc::cell(evaluatable_assets.clone()),\n                             module_graph,\n-                            Value::new(AvailabilityInfo::Root),\n+                            Value::new(availability_info),\n                         )\n                         .resolve()\n-                        .await?\n-                }\n+                        .await?,\n+                )\n             }\n             NextRuntime::NodeJs => {\n                 let mut evaluatable_assets = this.app_project.rsc_runtime_entries().owned().await?;\n@@ -1712,10 +1729,7 @@ impl AppEndpoint {\n                                 AssetIdent::from_path(this.app_project.project().project_path())\n                                     .with_modifier(server_utils_modifier()),\n                                 // TODO this should be ChunkGroup::Shared\n-                                ChunkGroup::Entry {\n-                                    entries: server_utils,\n-                                    ty: ChunkGroupType::Entry,\n-                                },\n+                                ChunkGroup::Entry(server_utils),\n                                 module_graph,\n                                 Value::new(current_availability_info),\n                             )\n@@ -1751,12 +1765,9 @@ impl AppEndpoint {\n                                 .chunk_group(\n                                     server_component.ident(),\n                                     // TODO this should be ChunkGroup::Shared\n-                                    ChunkGroup::Entry {\n-                                        entries: vec![ResolvedVc::upcast(\n-                                            server_component.await?.module,\n-                                        )],\n-                                        ty: ChunkGroupType::Entry,\n-                                    },\n+                                    ChunkGroup::Entry(vec![ResolvedVc::upcast(\n+                                        server_component.await?.module,\n+                                    )]),\n                                     module_graph,\n                                     Value::new(current_availability_info),\n                                 )\n@@ -1930,19 +1941,15 @@ impl Endpoint for AppEndpoint {\n     async fn entries(self: Vc<Self>) -> Result<Vc<GraphEntries>> {\n         let this = self.await?;\n         Ok(Vc::cell(vec![\n-            (\n-                vec![self.app_endpoint_entry().await?.rsc_entry],\n-                ChunkGroupType::Entry,\n-            ),\n-            (\n+            ChunkGroupEntry::Entry(vec![self.app_endpoint_entry().await?.rsc_entry]),\n+            ChunkGroupEntry::Entry(\n                 this.app_project\n                     .client_runtime_entries()\n                     .await?\n                     .iter()\n                     .copied()\n                     .map(ResolvedVc::upcast)\n                     .collect(),\n-                ChunkGroupType::Entry,\n             ),\n         ]))\n     }\n@@ -1983,10 +1990,9 @@ impl Endpoint for AppEndpoint {\n             .await?,\n         );\n \n-        Ok(Vc::cell(vec![(\n-            vec![server_actions_loader],\n-            ChunkGroupType::Entry,\n-        )]))\n+        Ok(Vc::cell(vec![ChunkGroupEntry::Entry(vec![\n+            server_actions_loader,\n+        ])]))\n     }\n }\n "
        },
        {
            "sha": "349a148e5fd5f4c471dd752c0a430768bfcc1162",
            "filename": "crates/next-api/src/instrumentation.rs",
            "status": "modified",
            "additions": 10,
            "deletions": 20,
            "changes": 30,
            "blob_url": "https://github.com/vercel/next.js/blob/b04cc97fa21b546a27201e58b2d77ffff1b849a0/crates%2Fnext-api%2Fsrc%2Finstrumentation.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b04cc97fa21b546a27201e58b2d77ffff1b849a0/crates%2Fnext-api%2Fsrc%2Finstrumentation.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Finstrumentation.rs?ref=b04cc97fa21b546a27201e58b2d77ffff1b849a0",
            "patch": "@@ -12,12 +12,12 @@ use turbo_tasks_fs::{File, FileContent, FileSystemPath};\n use turbopack_core::{\n     asset::AssetContent,\n     chunk::{\n-        availability_info::AvailabilityInfo, ChunkGroupType, ChunkingContext, ChunkingContextExt,\n+        availability_info::AvailabilityInfo, ChunkingContext, ChunkingContextExt,\n         EntryChunkGroupResult,\n     },\n     context::AssetContext,\n     module::Module,\n-    module_graph::GraphEntries,\n+    module_graph::{chunk_group_info::ChunkGroupEntry, GraphEntries},\n     output::{OutputAsset, OutputAssets},\n     reference_type::{EntryReferenceSubType, ReferenceType},\n     source::Source,\n@@ -95,24 +95,13 @@ impl InstrumentationEndpoint {\n         .cell())\n     }\n \n-    #[turbo_tasks::function]\n-    async fn entry_module(self: Vc<Self>) -> Result<Vc<Box<dyn Module>>> {\n-        if self.await?.is_edge {\n-            Ok(*self.core_modules().await?.edge_entry_module)\n-        } else {\n-            Ok(*self.core_modules().await?.userland_module)\n-        }\n-    }\n-\n     #[turbo_tasks::function]\n     async fn edge_files(self: Vc<Self>) -> Result<Vc<OutputAssets>> {\n         let this = self.await?;\n \n         let module = self.core_modules().await?.edge_entry_module;\n \n-        let module_graph = this\n-            .project\n-            .module_graph(*module, ChunkGroupType::Evaluated);\n+        let module_graph = this.project.module_graph(*module);\n \n         let mut evaluatable_assets = get_server_runtime_entries(\n             Value::new(ServerContextType::Instrumentation {\n@@ -155,9 +144,7 @@ impl InstrumentationEndpoint {\n         let chunking_context = this.project.server_chunking_context(false);\n \n         let userland_module = self.core_modules().await?.userland_module;\n-        let module_graph = this\n-            .project\n-            .module_graph(*userland_module, ChunkGroupType::Entry);\n+        let module_graph = this.project.module_graph(*userland_module);\n \n         let Some(module) = ResolvedVc::try_downcast(userland_module) else {\n             bail!(\"Entry module must be evaluatable\");\n@@ -294,9 +281,12 @@ impl Endpoint for InstrumentationEndpoint {\n     #[turbo_tasks::function]\n     async fn entries(self: Vc<Self>) -> Result<Vc<GraphEntries>> {\n         let core_modules = self.core_modules().await?;\n-        Ok(Vc::cell(vec![(\n-            vec![core_modules.edge_entry_module],\n-            ChunkGroupType::Evaluated,\n+        Ok(Vc::cell(vec![ChunkGroupEntry::Entry(\n+            if self.await?.is_edge {\n+                vec![core_modules.edge_entry_module]\n+            } else {\n+                vec![core_modules.userland_module]\n+            },\n         )]))\n     }\n }"
        },
        {
            "sha": "e5bd14ac0665a2d47f53e8627b8f75b2c8667260",
            "filename": "crates/next-api/src/middleware.rs",
            "status": "modified",
            "additions": 7,
            "deletions": 12,
            "changes": 19,
            "blob_url": "https://github.com/vercel/next.js/blob/b04cc97fa21b546a27201e58b2d77ffff1b849a0/crates%2Fnext-api%2Fsrc%2Fmiddleware.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b04cc97fa21b546a27201e58b2d77ffff1b849a0/crates%2Fnext-api%2Fsrc%2Fmiddleware.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fmiddleware.rs?ref=b04cc97fa21b546a27201e58b2d77ffff1b849a0",
            "patch": "@@ -16,12 +16,12 @@ use turbo_tasks_fs::{self, File, FileContent, FileSystemPath};\n use turbopack_core::{\n     asset::AssetContent,\n     chunk::{\n-        availability_info::AvailabilityInfo, ChunkGroupType, ChunkingContext, ChunkingContextExt,\n+        availability_info::AvailabilityInfo, ChunkingContext, ChunkingContextExt,\n         EntryChunkGroupResult, EvaluatableAsset,\n     },\n     context::AssetContext,\n     module::Module,\n-    module_graph::GraphEntries,\n+    module_graph::{chunk_group_info::ChunkGroupEntry, GraphEntries},\n     output::{OutputAsset, OutputAssets},\n     reference_type::{EntryReferenceSubType, ReferenceType},\n     source::Source,\n@@ -128,9 +128,7 @@ impl MiddlewareEndpoint {\n         evaluatable_assets.push(evaluatable.to_resolved().await?);\n \n         let evaluatable_assets = Vc::cell(evaluatable_assets);\n-        let module_graph = this\n-            .project\n-            .module_graph_for_entries(evaluatable_assets, ChunkGroupType::Evaluated);\n+        let module_graph = this.project.module_graph_for_entries(evaluatable_assets);\n \n         let edge_chunking_context = this.project.edge_chunking_context(false);\n \n@@ -150,9 +148,7 @@ impl MiddlewareEndpoint {\n         let chunking_context = this.project.server_chunking_context(false);\n \n         let userland_module = self.entry_module().to_resolved().await?;\n-        let module_graph = this\n-            .project\n-            .module_graph(*userland_module, ChunkGroupType::Entry);\n+        let module_graph = this.project.module_graph(*userland_module);\n \n         let Some(module) = ResolvedVc::try_downcast(userland_module) else {\n             bail!(\"Entry module must be evaluatable\");\n@@ -409,9 +405,8 @@ impl Endpoint for MiddlewareEndpoint {\n \n     #[turbo_tasks::function]\n     async fn entries(self: Vc<Self>) -> Result<Vc<GraphEntries>> {\n-        Ok(Vc::cell(vec![(\n-            vec![self.entry_module().to_resolved().await?],\n-            ChunkGroupType::Evaluated,\n-        )]))\n+        Ok(Vc::cell(vec![ChunkGroupEntry::Entry(vec![\n+            self.entry_module().to_resolved().await?,\n+        ])]))\n     }\n }"
        },
        {
            "sha": "e29086970da88f63ef4de238790acebd8d1387c1",
            "filename": "crates/next-api/src/pages.rs",
            "status": "modified",
            "additions": 7,
            "deletions": 9,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/b04cc97fa21b546a27201e58b2d77ffff1b849a0/crates%2Fnext-api%2Fsrc%2Fpages.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b04cc97fa21b546a27201e58b2d77ffff1b849a0/crates%2Fnext-api%2Fsrc%2Fpages.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fpages.rs?ref=b04cc97fa21b546a27201e58b2d77ffff1b849a0",
            "patch": "@@ -45,14 +45,14 @@ use turbopack::{\n use turbopack_core::{\n     asset::AssetContent,\n     chunk::{\n-        availability_info::AvailabilityInfo, ChunkGroupResult, ChunkGroupType, ChunkingContext,\n-        ChunkingContextExt, EntryChunkGroupResult, EvaluatableAsset, EvaluatableAssets,\n+        availability_info::AvailabilityInfo, ChunkGroupResult, ChunkingContext, ChunkingContextExt,\n+        EntryChunkGroupResult, EvaluatableAsset, EvaluatableAssets,\n     },\n     context::AssetContext,\n     file_source::FileSource,\n     ident::AssetIdent,\n     module::Module,\n-    module_graph::{GraphEntries, ModuleGraph},\n+    module_graph::{chunk_group_info::ChunkGroupEntry, GraphEntries, ModuleGraph},\n     output::{OptionOutputAsset, OutputAsset, OutputAssets},\n     reference_type::{EcmaScriptModulesReferenceSubType, EntryReferenceSubType, ReferenceType},\n     resolve::{origin::PlainResolveOrigin, parse::Request, pattern::Pattern},\n@@ -769,7 +769,7 @@ impl PageEndpoint {\n         let this = self.await?;\n         let project = this.pages_project.project();\n         let evaluatable_assets = self.client_evaluatable_assets();\n-        Ok(project.module_graph_for_entries(evaluatable_assets, ChunkGroupType::Evaluated))\n+        Ok(project.module_graph_for_entries(evaluatable_assets))\n     }\n \n     #[turbo_tasks::function]\n@@ -909,7 +909,7 @@ impl PageEndpoint {\n             // The SSR and Client Graphs are not connected in Pages Router.\n             // We are only interested in get_next_dynamic_imports_for_endpoint at the\n             // moment, which only needs the client graph anyway.\n-            let module_graph = project.module_graph(*ssr_module, ChunkGroupType::Entry);\n+            let module_graph = project.module_graph(*ssr_module);\n \n             let next_dynamic_imports = if let PageEndpointType::Html = this.ty {\n                 let client_availability_info = self.client_chunks().await?.availability_info;\n@@ -1454,19 +1454,17 @@ impl Endpoint for PageEndpoint {\n     #[turbo_tasks::function]\n     async fn entries(self: Vc<Self>) -> Result<Vc<GraphEntries>> {\n         let this = self.await?;\n-        let mut modules = vec![];\n \n         let ssr_chunk_module = self.internal_ssr_chunk_module().await?;\n-        modules.push((vec![ssr_chunk_module.ssr_module], ChunkGroupType::Entry));\n+        let mut modules = vec![ChunkGroupEntry::Entry(vec![ssr_chunk_module.ssr_module])];\n \n         if let PageEndpointType::Html = this.ty {\n-            modules.push((\n+            modules.push(ChunkGroupEntry::Entry(\n                 self.client_evaluatable_assets()\n                     .await?\n                     .iter()\n                     .map(|m| ResolvedVc::upcast(*m))\n                     .collect(),\n-                ChunkGroupType::Evaluated,\n             ));\n         }\n "
        },
        {
            "sha": "ecda6ea683b2c3766d2ec1cc86f30f800b417359",
            "filename": "crates/next-api/src/project.rs",
            "status": "modified",
            "additions": 13,
            "deletions": 14,
            "changes": 27,
            "blob_url": "https://github.com/vercel/next.js/blob/b04cc97fa21b546a27201e58b2d77ffff1b849a0/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b04cc97fa21b546a27201e58b2d77ffff1b849a0/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fproject.rs?ref=b04cc97fa21b546a27201e58b2d77ffff1b849a0",
            "patch": "@@ -42,7 +42,7 @@ use turbopack_core::{\n     changed::content_changed,\n     chunk::{\n         module_id_strategies::{DevModuleIdStrategy, ModuleIdStrategy},\n-        ChunkGroupType, ChunkingContext, EvaluatableAssets, SourceMapsType,\n+        ChunkingContext, EvaluatableAssets, SourceMapsType,\n     },\n     compile_time_info::CompileTimeInfo,\n     context::AssetContext,\n@@ -53,7 +53,10 @@ use turbopack_core::{\n         StyledString,\n     },\n     module::Module,\n-    module_graph::{GraphEntries, ModuleGraph, SingleModuleGraph, VisitedModules},\n+    module_graph::{\n+        chunk_group_info::ChunkGroupEntry, GraphEntries, ModuleGraph, SingleModuleGraph,\n+        VisitedModules,\n+    },\n     output::{OutputAsset, OutputAssets},\n     reference_type::{EntryReferenceSubType, ReferenceType},\n     resolve::{find_context_file, FindContextFileResult},\n@@ -883,10 +886,9 @@ impl Project {\n     pub async fn module_graph(\n         self: Vc<Self>,\n         entry: ResolvedVc<Box<dyn Module>>,\n-        chunk_group_type: ChunkGroupType,\n     ) -> Result<Vc<ModuleGraph>> {\n         Ok(if *self.per_page_module_graph().await? {\n-            ModuleGraph::from_module(*entry, chunk_group_type)\n+            ModuleGraph::from_entry_module(*entry)\n         } else {\n             *self.whole_app_module_graphs().await?.full\n         })\n@@ -896,7 +898,6 @@ impl Project {\n     pub async fn module_graph_for_entries(\n         self: Vc<Self>,\n         evaluatable_assets: Vc<EvaluatableAssets>,\n-        chunk_group_type: ChunkGroupType,\n     ) -> Result<Vc<ModuleGraph>> {\n         Ok(if *self.per_page_module_graph().await? {\n             let entries = evaluatable_assets\n@@ -905,7 +906,7 @@ impl Project {\n                 .copied()\n                 .map(ResolvedVc::upcast)\n                 .collect();\n-            ModuleGraph::from_modules(Vc::cell(vec![(entries, chunk_group_type)]))\n+            ModuleGraph::from_modules(Vc::cell(vec![ChunkGroupEntry::Entry(entries)]))\n         } else {\n             *self.whole_app_module_graphs().await?.full\n         })\n@@ -1681,16 +1682,14 @@ impl Project {\n     #[turbo_tasks::function]\n     pub async fn client_main_modules(self: Vc<Self>) -> Result<Vc<GraphEntries>> {\n         let pages_project = self.pages_project();\n-        let mut modules = vec![(\n-            vec![pages_project.client_main_module().to_resolved().await?],\n-            ChunkGroupType::Evaluated,\n-        )];\n+        let mut modules = vec![ChunkGroupEntry::Entry(vec![\n+            pages_project.client_main_module().to_resolved().await?,\n+        ])];\n \n         if let Some(app_project) = *self.app_project().await? {\n-            modules.push((\n-                vec![app_project.client_main_module().to_resolved().await?],\n-                ChunkGroupType::Evaluated,\n-            ));\n+            modules.push(ChunkGroupEntry::Entry(vec![\n+                app_project.client_main_module().to_resolved().await?,\n+            ]));\n         }\n \n         Ok(Vc::cell(modules))"
        },
        {
            "sha": "9c4f5f05c3e787a2b1a9c1c975fd920c46e73719",
            "filename": "crates/next-core/src/next_server_utility/mod.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/b04cc97fa21b546a27201e58b2d77ffff1b849a0/crates%2Fnext-core%2Fsrc%2Fnext_server_utility%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b04cc97fa21b546a27201e58b2d77ffff1b849a0/crates%2Fnext-core%2Fsrc%2Fnext_server_utility%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_server_utility%2Fmod.rs?ref=b04cc97fa21b546a27201e58b2d77ffff1b849a0",
            "patch": "@@ -2,4 +2,5 @@ pub mod server_utility_module;\n pub(crate) mod server_utility_reference;\n pub(crate) mod server_utility_transition;\n \n+pub use server_utility_reference::NEXT_SERVER_UTILITY_MERGE_TAG;\n pub use server_utility_transition::NextServerUtilityTransition;"
        },
        {
            "sha": "31b8531aac9adf7dab215b78e460fce1546432ac",
            "filename": "crates/next-core/src/next_server_utility/server_utility_reference.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/b04cc97fa21b546a27201e58b2d77ffff1b849a0/crates%2Fnext-core%2Fsrc%2Fnext_server_utility%2Fserver_utility_reference.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b04cc97fa21b546a27201e58b2d77ffff1b849a0/crates%2Fnext-core%2Fsrc%2Fnext_server_utility%2Fserver_utility_reference.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_server_utility%2Fserver_utility_reference.rs?ref=b04cc97fa21b546a27201e58b2d77ffff1b849a0",
            "patch": "@@ -1,4 +1,5 @@\n use anyhow::Result;\n+use once_cell::sync::Lazy;\n use turbo_rcstr::RcStr;\n use turbo_tasks::{ResolvedVc, ValueToString, Vc};\n use turbopack_core::{\n@@ -43,13 +44,15 @@ impl ModuleReference for NextServerUtilityModuleReference {\n     }\n }\n \n+pub static NEXT_SERVER_UTILITY_MERGE_TAG: Lazy<RcStr> = Lazy::new(|| \"next-server-utility\".into());\n+\n #[turbo_tasks::value_impl]\n impl ChunkableModuleReference for NextServerUtilityModuleReference {\n     #[turbo_tasks::function]\n     fn chunking_type(&self) -> Vc<ChunkingTypeOption> {\n         Vc::cell(Some(ChunkingType::Shared {\n             inherit_async: true,\n-            merge_tag: Some(\"next-server-utility\".into()),\n+            merge_tag: Some(NEXT_SERVER_UTILITY_MERGE_TAG.clone()),\n         }))\n     }\n }"
        },
        {
            "sha": "c0adf58102519b0204e3fe5524249ac6162a5f35",
            "filename": "turbopack/crates/turbo-tasks/src/task/task_input.rs",
            "status": "modified",
            "additions": 17,
            "deletions": 0,
            "changes": 17,
            "blob_url": "https://github.com/vercel/next.js/blob/b04cc97fa21b546a27201e58b2d77ffff1b849a0/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask%2Ftask_input.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b04cc97fa21b546a27201e58b2d77ffff1b849a0/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask%2Ftask_input.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask%2Ftask_input.rs?ref=b04cc97fa21b546a27201e58b2d77ffff1b849a0",
            "patch": "@@ -71,6 +71,23 @@ where\n     }\n }\n \n+impl<T> TaskInput for Box<T>\n+where\n+    T: TaskInput,\n+{\n+    fn is_resolved(&self) -> bool {\n+        self.as_ref().is_resolved()\n+    }\n+\n+    fn is_transient(&self) -> bool {\n+        self.as_ref().is_transient()\n+    }\n+\n+    async fn resolve_input(&self) -> Result<Self> {\n+        Ok(Box::new(Box::pin(self.as_ref().resolve_input()).await?))\n+    }\n+}\n+\n impl<T> TaskInput for Option<T>\n where\n     T: TaskInput,"
        },
        {
            "sha": "712603c5b9b7c2439a6a6a37ee6658b761d39d7a",
            "filename": "turbopack/crates/turbopack-cli/src/build/mod.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 10,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/b04cc97fa21b546a27201e58b2d77ffff1b849a0/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fbuild%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b04cc97fa21b546a27201e58b2d77ffff1b849a0/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fbuild%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fbuild%2Fmod.rs?ref=b04cc97fa21b546a27201e58b2d77ffff1b849a0",
            "patch": "@@ -22,14 +22,14 @@ use turbopack_cli_utils::issue::{ConsoleUi, LogOptions};\n use turbopack_core::{\n     asset::Asset,\n     chunk::{\n-        availability_info::AvailabilityInfo, ChunkGroupType, ChunkingConfig, ChunkingContext,\n-        EvaluatableAsset, EvaluatableAssets, MinifyType, SourceMapsType,\n+        availability_info::AvailabilityInfo, ChunkingConfig, ChunkingContext, EvaluatableAsset,\n+        EvaluatableAssets, MinifyType, SourceMapsType,\n     },\n     environment::{BrowserEnvironment, Environment, ExecutionEnvironment, NodeJsEnvironment},\n     ident::AssetIdent,\n     issue::{handle_issues, IssueReporter, IssueSeverity},\n     module::Module,\n-    module_graph::ModuleGraph,\n+    module_graph::{chunk_group_info::ChunkGroupEntry, ModuleGraph},\n     output::{OutputAsset, OutputAssets},\n     reference::all_assets_from_entries,\n     reference_type::{EntryReferenceSubType, ReferenceType},\n@@ -288,13 +288,8 @@ async fn build_internal(\n         .try_join()\n         .await?;\n \n-    let module_graph = ModuleGraph::from_modules(Vc::cell(vec![(\n-        entries.clone(),\n-        match target {\n-            Target::Browser => ChunkGroupType::Evaluated,\n-            Target::Node => ChunkGroupType::Entry,\n-        },\n-    )]));\n+    let module_graph =\n+        ModuleGraph::from_modules(Vc::cell(vec![ChunkGroupEntry::Entry(entries.clone())]));\n     let module_id_strategy = ResolvedVc::upcast(\n         get_global_module_id_strategy(module_graph)\n             .to_resolved()"
        },
        {
            "sha": "554da13f601e2c0bda190d65724dd1d008dffb5b",
            "filename": "turbopack/crates/turbopack-cli/src/dev/web_entry_source.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/b04cc97fa21b546a27201e58b2d77ffff1b849a0/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fdev%2Fweb_entry_source.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b04cc97fa21b546a27201e58b2d77ffff1b849a0/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fdev%2Fweb_entry_source.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fdev%2Fweb_entry_source.rs?ref=b04cc97fa21b546a27201e58b2d77ffff1b849a0",
            "patch": "@@ -6,11 +6,11 @@ use turbo_tasks_fs::FileSystemPath;\n use turbopack_browser::{react_refresh::assert_can_resolve_react_refresh, BrowserChunkingContext};\n use turbopack_cli_utils::runtime_entry::{RuntimeEntries, RuntimeEntry};\n use turbopack_core::{\n-    chunk::{ChunkGroupType, ChunkableModule, ChunkingContext, EvaluatableAsset, SourceMapsType},\n+    chunk::{ChunkableModule, ChunkingContext, EvaluatableAsset, SourceMapsType},\n     environment::Environment,\n     file_source::FileSource,\n     module::Module,\n-    module_graph::ModuleGraph,\n+    module_graph::{chunk_group_info::ChunkGroupEntry, ModuleGraph},\n     reference_type::{EntryReferenceSubType, ReferenceType},\n     resolve::{\n         origin::{PlainResolveOrigin, ResolveOriginExt},\n@@ -156,7 +156,7 @@ pub async fn create_web_entry_source(\n         )\n         .collect::<Vec<ResolvedVc<Box<dyn Module>>>>();\n     let module_graph =\n-        ModuleGraph::from_modules(Vc::cell(vec![(all_modules, ChunkGroupType::Evaluated)]))\n+        ModuleGraph::from_modules(Vc::cell(vec![ChunkGroupEntry::Entry(all_modules)]))\n             .to_resolved()\n             .await?;\n "
        },
        {
            "sha": "2f0101ed490c30503c63d235c86b3cc033d775f4",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/chunk_group_info.rs",
            "status": "modified",
            "additions": 105,
            "deletions": 28,
            "changes": 133,
            "blob_url": "https://github.com/vercel/next.js/blob/b04cc97fa21b546a27201e58b2d77ffff1b849a0/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fchunk_group_info.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b04cc97fa21b546a27201e58b2d77ffff1b849a0/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fchunk_group_info.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fchunk_group_info.rs?ref=b04cc97fa21b546a27201e58b2d77ffff1b849a0",
            "patch": "@@ -18,7 +18,7 @@ use turbo_tasks::{\n };\n \n use crate::{\n-    chunk::{ChunkGroupType, ChunkingType},\n+    chunk::ChunkingType,\n     module::Module,\n     module_graph::{\n         get_node, get_node_idx, traced_di_graph::iter_neighbors_rev, GraphNodeIndex,\n@@ -111,13 +111,48 @@ impl ChunkGroupInfo {\n     }\n }\n \n-#[derive(Debug, Clone, Hash, TaskInput, PartialEq, Eq, Serialize, Deserialize)]\n-pub enum ChunkGroup {\n+#[derive(\n+    Debug, Clone, Hash, TaskInput, PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, NonLocalValue,\n+)]\n+pub enum ChunkGroupEntry {\n     /// e.g. a page\n-    Entry {\n+    Entry(Vec<ResolvedVc<Box<dyn Module>>>),\n+    /// a module with an incoming async edge\n+    Async(ResolvedVc<Box<dyn Module>>),\n+    /// a module with an incoming non-merged isolated edge\n+    Isolated(ResolvedVc<Box<dyn Module>>),\n+    /// a module with an incoming merging isolated edge\n+    IsolatedMerged {\n+        parent: Box<ChunkGroupEntry>,\n+        merge_tag: RcStr,\n         entries: Vec<ResolvedVc<Box<dyn Module>>>,\n-        ty: ChunkGroupType,\n     },\n+    /// a module with an incoming non-merging shared edge\n+    Shared(ResolvedVc<Box<dyn Module>>),\n+    /// a module with an incoming merging shared edge\n+    SharedMerged {\n+        parent: Box<ChunkGroupEntry>,\n+        merge_tag: RcStr,\n+        entries: Vec<ResolvedVc<Box<dyn Module>>>,\n+    },\n+}\n+impl ChunkGroupEntry {\n+    pub fn entries(&self) -> impl Iterator<Item = ResolvedVc<Box<dyn Module>>> + '_ {\n+        match self {\n+            Self::Async(e) | Self::Isolated(e) | Self::Shared(e) => {\n+                Either::Left(std::iter::once(*e))\n+            }\n+            Self::Entry(entries)\n+            | Self::IsolatedMerged { entries, .. }\n+            | Self::SharedMerged { entries, .. } => Either::Right(entries.iter().copied()),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, Hash, TaskInput, PartialEq, Eq, Serialize, Deserialize)]\n+pub enum ChunkGroup {\n+    /// e.g. a page\n+    Entry(Vec<ResolvedVc<Box<dyn Module>>>),\n     /// a module with an incoming async edge\n     Async(ResolvedVc<Box<dyn Module>>),\n     /// a module with an incoming non-merged isolated edge\n@@ -144,17 +179,16 @@ impl ChunkGroup {\n             ChunkGroup::Async(e) | ChunkGroup::Isolated(e) | ChunkGroup::Shared(e) => {\n                 Either::Left(std::iter::once(*e))\n             }\n-            ChunkGroup::Entry { entries, .. }\n+            ChunkGroup::Entry(entries)\n             | ChunkGroup::IsolatedMerged { entries, .. }\n             | ChunkGroup::SharedMerged { entries, .. } => Either::Right(entries.iter().copied()),\n         }\n     }\n \n     pub async fn debug_str(&self, chunk_group_info: &ChunkGroupInfo) -> Result<String> {\n         Ok(match self {\n-            ChunkGroup::Entry { entries, ty } => format!(\n-                \"ChunkGroup::Entry({:?}, {:?})\",\n-                ty,\n+            ChunkGroup::Entry(entries) => format!(\n+                \"ChunkGroup::Entry({:?})\",\n                 entries\n                     .iter()\n                     .map(|m| m.ident().to_string())\n@@ -214,10 +248,7 @@ impl ChunkGroup {\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n enum ChunkGroupKey {\n     /// e.g. a page\n-    Entry {\n-        entries: Vec<ResolvedVc<Box<dyn Module>>>,\n-        ty: ChunkGroupType,\n-    },\n+    Entry(Vec<ResolvedVc<Box<dyn Module>>>),\n     /// a module with an incoming async edge\n     Async(ResolvedVc<Box<dyn Module>>),\n     /// a module with an incoming non-merging isolated edge\n@@ -305,7 +336,7 @@ pub async fn compute_chunk_group_info(graph: &ModuleGraph) -> Result<Vc<ChunkGro\n             .collect::<Vec<_>>();\n         graph\n             .traverse_edges_from_entries_bfs(\n-                entries.iter().flat_map(|(e, _)| e).copied(),\n+                entries.iter().flat_map(|e| e.entries()),\n                 |parent, node| {\n                     if let Some((parent, _)) = parent {\n                         let parent_depth = *module_depth.get(&parent.module).unwrap();\n@@ -323,19 +354,65 @@ pub async fn compute_chunk_group_info(graph: &ModuleGraph) -> Result<Vc<ChunkGro\n \n         // ----\n \n+        #[allow(clippy::type_complexity)]\n+        fn entry_to_chunk_group_id(\n+            entry: ChunkGroupEntry,\n+            chunk_groups_map: &mut FxIndexMap<\n+                ChunkGroupKey,\n+                (ChunkGroupId, FxIndexSet<ResolvedVc<Box<dyn Module>>>),\n+            >,\n+        ) -> ChunkGroupKey {\n+            match entry {\n+                ChunkGroupEntry::Entry(entries) => ChunkGroupKey::Entry(entries),\n+                ChunkGroupEntry::Async(entry) => ChunkGroupKey::Async(entry),\n+                ChunkGroupEntry::Isolated(entry) => ChunkGroupKey::Isolated(entry),\n+                ChunkGroupEntry::Shared(entry) => ChunkGroupKey::Shared(entry),\n+                ChunkGroupEntry::IsolatedMerged {\n+                    parent,\n+                    merge_tag,\n+                    entries: _,\n+                } => {\n+                    let parent = entry_to_chunk_group_id(*parent, chunk_groups_map);\n+                    let len = chunk_groups_map.len();\n+                    let parent = chunk_groups_map\n+                        .entry(parent)\n+                        .or_insert_with(|| (ChunkGroupId(len as u32), FxIndexSet::default()))\n+                        .0;\n+\n+                    ChunkGroupKey::IsolatedMerged {\n+                        parent: ChunkGroupId(*parent as u32),\n+                        merge_tag,\n+                    }\n+                }\n+                ChunkGroupEntry::SharedMerged {\n+                    parent,\n+                    merge_tag,\n+                    entries: _,\n+                } => {\n+                    let parent = entry_to_chunk_group_id(*parent, chunk_groups_map);\n+                    let len = chunk_groups_map.len();\n+                    let parent = chunk_groups_map\n+                        .entry(parent)\n+                        .or_insert_with(|| (ChunkGroupId(len as u32), FxIndexSet::default()))\n+                        .0;\n+\n+                    ChunkGroupKey::SharedMerged {\n+                        parent: ChunkGroupId(*parent as u32),\n+                        merge_tag,\n+                    }\n+                }\n+            }\n+        }\n+\n         let entry_chunk_group_keys = graphs\n             .iter()\n             .flat_map(|g| g.entries.iter())\n-            .flat_map(|(entries, ty)| {\n-                entries.iter().map(|e| {\n-                    (\n-                        *e,\n-                        ChunkGroupKey::Entry {\n-                            entries: entries.clone(),\n-                            ty: *ty,\n-                        },\n-                    )\n-                })\n+            .flat_map(|chunk_group| {\n+                let chunk_group_key =\n+                    entry_to_chunk_group_id(chunk_group.clone(), &mut chunk_groups_map);\n+                chunk_group\n+                    .entries()\n+                    .map(move |e| (e, chunk_group_key.clone()))\n             })\n             .collect::<FxHashMap<_, _>>();\n \n@@ -490,11 +567,11 @@ pub async fn compute_chunk_group_info(graph: &ModuleGraph) -> Result<Vc<ChunkGro\n         {\n             let mut queue_set = FxHashSet::default();\n             let mut queue = BinaryHeap::with_capacity(entries.len());\n-            for e in entries.iter().flat_map(|(e, _)| e) {\n+            for e in entries.iter().flat_map(|e| e.entries()) {\n                 queue.push(NodeWithPriority {\n-                    depth: *module_depth.get(e).unwrap(),\n+                    depth: *module_depth.get(&e).unwrap(),\n                     chunk_group_len: 0,\n-                    node: ModuleGraph::get_entry(&graphs, *e).await?,\n+                    node: ModuleGraph::get_entry(&graphs, e).await?,\n                 });\n             }\n             for entry_node in &queue {\n@@ -547,7 +624,7 @@ pub async fn compute_chunk_group_info(graph: &ModuleGraph) -> Result<Vc<ChunkGro\n             chunk_groups: chunk_groups_map\n                 .into_iter()\n                 .map(|(k, (_, merged_entries))| match k {\n-                    ChunkGroupKey::Entry { entries, ty } => ChunkGroup::Entry { entries, ty },\n+                    ChunkGroupKey::Entry(entries) => ChunkGroup::Entry(entries),\n                     ChunkGroupKey::Async(module) => ChunkGroup::Async(module),\n                     ChunkGroupKey::Isolated(module) => ChunkGroup::Isolated(module),\n                     ChunkGroupKey::IsolatedMerged { parent, merge_tag } => {"
        },
        {
            "sha": "cbdebd63fa72fe5773bd51a97b7836e538a4b8bd",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/mod.rs",
            "status": "modified",
            "additions": 13,
            "deletions": 13,
            "changes": 26,
            "blob_url": "https://github.com/vercel/next.js/blob/b04cc97fa21b546a27201e58b2d77ffff1b849a0/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b04cc97fa21b546a27201e58b2d77ffff1b849a0/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs?ref=b04cc97fa21b546a27201e58b2d77ffff1b849a0",
            "patch": "@@ -20,12 +20,12 @@ use turbo_tasks::{\n };\n \n use crate::{\n-    chunk::{AsyncModuleInfo, ChunkGroupType, ChunkingType},\n+    chunk::{AsyncModuleInfo, ChunkingType},\n     issue::Issue,\n     module::Module,\n     module_graph::{\n         async_module_info::{compute_async_module_info, AsyncModulesInfo},\n-        chunk_group_info::{compute_chunk_group_info, ChunkGroupInfo},\n+        chunk_group_info::{compute_chunk_group_info, ChunkGroupEntry, ChunkGroupInfo},\n         module_batches::{compute_module_batches, ModuleBatchesGraph},\n         traced_di_graph::{iter_neighbors_rev, TracedDiGraph},\n     },\n@@ -144,10 +144,11 @@ impl VisitedModules {\n     }\n }\n \n-pub type GraphEntriesT = Vec<(Vec<ResolvedVc<Box<dyn Module>>>, ChunkGroupType)>;\n+pub type GraphEntriesT = Vec<ChunkGroupEntry>;\n \n #[turbo_tasks::value(transparent)]\n pub struct GraphEntries(GraphEntriesT);\n+\n #[turbo_tasks::value_impl]\n impl GraphEntries {\n     #[turbo_tasks::function]\n@@ -187,7 +188,7 @@ impl SingleModuleGraph {\n     ) -> Result<Vc<Self>> {\n         let root_edges = entries\n             .iter()\n-            .flat_map(|(e, _)| e.clone())\n+            .flat_map(|e| e.entries())\n             .map(|e| async move {\n                 Ok(SingleModuleGraphBuilderEdge {\n                     to: SingleModuleGraphBuilderNode::new_module(e).await?,\n@@ -348,7 +349,7 @@ impl SingleModuleGraph {\n \n     /// Iterate over all nodes in the graph\n     pub fn entry_modules(&self) -> impl Iterator<Item = ResolvedVc<Box<dyn Module>>> + '_ {\n-        self.entries.iter().flat_map(|(e, _)| e).copied()\n+        self.entries.iter().flat_map(|e| e.entries())\n     }\n \n     /// Enumerate all nodes in the graph\n@@ -460,8 +461,8 @@ impl SingleModuleGraph {\n         let mut stack: Vec<NodeIndex> = self\n             .entries\n             .iter()\n-            .flat_map(|(e, _)| e)\n-            .map(|e| *self.modules.get(e).unwrap())\n+            .flat_map(|e| e.entries())\n+            .map(|e| *self.modules.get(&e).unwrap())\n             .collect();\n         let mut discovered = graph.visit_map();\n         for entry_node in &stack {\n@@ -708,11 +709,10 @@ impl ModuleGraph {\n     }\n \n     #[turbo_tasks::function]\n-    pub fn from_module(module: ResolvedVc<Box<dyn Module>>, ty: ChunkGroupType) -> Vc<Self> {\n-        Self::from_single_graph(SingleModuleGraph::new_with_entries(Vc::cell(vec![(\n-            vec![module],\n-            ty,\n-        )])))\n+    pub fn from_entry_module(module: ResolvedVc<Box<dyn Module>>) -> Vc<Self> {\n+        Self::from_single_graph(SingleModuleGraph::new_with_entries(Vc::cell(vec![\n+            ChunkGroupEntry::Entry(vec![module]),\n+        ])))\n     }\n \n     #[turbo_tasks::function]\n@@ -859,7 +859,7 @@ impl ModuleGraph {\n                 graphs\n                     .iter()\n                     .flat_map(|g| g.entries.iter())\n-                    .flat_map(|(e, _)| e)\n+                    .flat_map(|e| e.entries())\n                     .map(|e| e.ident().to_string())\n                     .try_join()\n                     .await?"
        },
        {
            "sha": "9049b14560916c86b45668bb190c42ae73c0c478",
            "filename": "turbopack/crates/turbopack-dev-server/src/html.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 6,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/b04cc97fa21b546a27201e58b2d77ffff1b849a0/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fhtml.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b04cc97fa21b546a27201e58b2d77ffff1b849a0/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fhtml.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fhtml.rs?ref=b04cc97fa21b546a27201e58b2d77ffff1b849a0",
            "patch": "@@ -10,8 +10,8 @@ use turbo_tasks_hash::{encode_hex, Xxh3Hash64Hasher};\n use turbopack_core::{\n     asset::{Asset, AssetContent},\n     chunk::{\n-        availability_info::AvailabilityInfo, ChunkGroupType, ChunkableModule, ChunkingContext,\n-        ChunkingContextExt, EvaluatableAssets,\n+        availability_info::AvailabilityInfo, ChunkableModule, ChunkingContext, ChunkingContextExt,\n+        EvaluatableAssets,\n     },\n     module::Module,\n     module_graph::{chunk_group_info::ChunkGroup, ModuleGraph},\n@@ -163,10 +163,7 @@ impl DevHtmlAsset {\n                 } else {\n                     chunking_context.root_chunk_group_assets(\n                         chunkable_module.ident(),\n-                        ChunkGroup::Entry {\n-                            entries: vec![ResolvedVc::upcast(chunkable_module)],\n-                            ty: ChunkGroupType::Evaluated,\n-                        },\n+                        ChunkGroup::Entry(vec![ResolvedVc::upcast(chunkable_module)]),\n                         *module_graph,\n                     )\n                 };"
        },
        {
            "sha": "a46d77fce75175d0a31a64f45a6491a18f017855",
            "filename": "turbopack/crates/turbopack-node/src/evaluate.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 6,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/b04cc97fa21b546a27201e58b2d77ffff1b849a0/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fevaluate.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b04cc97fa21b546a27201e58b2d77ffff1b849a0/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fevaluate.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fevaluate.rs?ref=b04cc97fa21b546a27201e58b2d77ffff1b849a0",
            "patch": "@@ -22,16 +22,14 @@ use turbo_tasks_fs::{to_sys_path, File, FileSystemPath};\n use turbopack_core::{\n     asset::AssetContent,\n     changed::content_changed,\n-    chunk::{\n-        ChunkGroupType, ChunkingContext, ChunkingContextExt, EvaluatableAsset, EvaluatableAssets,\n-    },\n+    chunk::{ChunkingContext, ChunkingContextExt, EvaluatableAsset, EvaluatableAssets},\n     context::AssetContext,\n     error::PrettyPrintError,\n     file_source::FileSource,\n     ident::AssetIdent,\n     issue::{Issue, IssueExt, IssueStage, OptionStyledString, StyledString},\n     module::Module,\n-    module_graph::ModuleGraph,\n+    module_graph::{chunk_group_info::ChunkGroupEntry, ModuleGraph},\n     output::{OutputAsset, OutputAssets},\n     reference_type::{InnerAssets, ReferenceType},\n     virtual_source::VirtualSource,\n@@ -158,11 +156,10 @@ async fn emit_evaluate_pool_assets_operation(\n         entries\n     };\n \n-    let module_graph = ModuleGraph::from_modules(Vc::cell(vec![(\n+    let module_graph = ModuleGraph::from_modules(Vc::cell(vec![ChunkGroupEntry::Entry(\n         iter::once(entry_module)\n             .chain(runtime_entries.iter().copied().map(ResolvedVc::upcast))\n             .collect(),\n-        ChunkGroupType::Entry,\n     )]));\n \n     let bootstrap = chunking_context.root_entry_chunk_group_asset("
        },
        {
            "sha": "3c5a87962383c47dd01db612679086b045abc54d",
            "filename": "turbopack/crates/turbopack-node/src/lib.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 6,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/b04cc97fa21b546a27201e58b2d77ffff1b849a0/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b04cc97fa21b546a27201e58b2d77ffff1b849a0/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Flib.rs?ref=b04cc97fa21b546a27201e58b2d77ffff1b849a0",
            "patch": "@@ -18,11 +18,9 @@ use turbo_tasks_fs::{to_sys_path, File, FileSystemPath};\n use turbopack_core::{\n     asset::{Asset, AssetContent},\n     changed::content_changed,\n-    chunk::{\n-        ChunkGroupType, ChunkingContext, ChunkingContextExt, EvaluatableAsset, EvaluatableAssets,\n-    },\n+    chunk::{ChunkingContext, ChunkingContextExt, EvaluatableAsset, EvaluatableAssets},\n     module::Module,\n-    module_graph::ModuleGraph,\n+    module_graph::{chunk_group_info::ChunkGroupEntry, ModuleGraph},\n     output::{OutputAsset, OutputAssets, OutputAssetsSet},\n     source_map::GenerateSourceMap,\n     virtual_output::VirtualOutputAsset,\n@@ -260,15 +258,14 @@ pub async fn get_intermediate_asset(\n     Ok(Vc::upcast(chunking_context.root_entry_chunk_group_asset(\n         chunking_context.chunk_path(main_entry.ident(), \".js\".into()),\n         other_entries.with_entry(*main_entry),\n-        ModuleGraph::from_modules(Vc::cell(vec![(\n+        ModuleGraph::from_modules(Vc::cell(vec![ChunkGroupEntry::Entry(\n                 other_entries\n                     .await?\n                     .into_iter()\n                     .copied()\n                     .chain(std::iter::once(main_entry))\n                     .map(ResolvedVc::upcast)\n                     .collect(),\n-                ChunkGroupType::Entry,\n             )])),\n         OutputAssets::empty(),\n     )))"
        },
        {
            "sha": "fa802e2a8208a8e737affccb69a3594649b42f4f",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 10,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/b04cc97fa21b546a27201e58b2d77ffff1b849a0/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b04cc97fa21b546a27201e58b2d77ffff1b849a0/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot.rs?ref=b04cc97fa21b546a27201e58b2d77ffff1b849a0",
            "patch": "@@ -33,8 +33,8 @@ use turbopack_browser::BrowserChunkingContext;\n use turbopack_core::{\n     asset::Asset,\n     chunk::{\n-        availability_info::AvailabilityInfo, ChunkGroupType, ChunkingContext, ChunkingContextExt,\n-        EvaluatableAsset, EvaluatableAssetExt, EvaluatableAssets, MinifyType,\n+        availability_info::AvailabilityInfo, ChunkingContext, ChunkingContextExt, EvaluatableAsset,\n+        EvaluatableAssetExt, EvaluatableAssets, MinifyType,\n     },\n     compile_time_defines,\n     compile_time_info::CompileTimeInfo,\n@@ -45,7 +45,7 @@ use turbopack_core::{\n     free_var_references,\n     issue::{Issue, IssueDescriptionExt},\n     module::Module,\n-    module_graph::ModuleGraph,\n+    module_graph::{chunk_group_info::ChunkGroupEntry, ModuleGraph},\n     output::{OutputAsset, OutputAssets},\n     reference_type::{EntryReferenceSubType, ReferenceType},\n     source::Source,\n@@ -397,13 +397,8 @@ async fn run_test_operation(resource: RcStr) -> Result<Vc<FileSystemPath>> {\n             .copied()\n             .map(ResolvedVc::upcast)\n             .collect();\n-        let module_graph = ModuleGraph::from_modules(Vc::cell(vec![(\n-            all_modules,\n-            match options.runtime {\n-                Runtime::Browser => ChunkGroupType::Evaluated,\n-                Runtime::NodeJs => ChunkGroupType::Entry,\n-            },\n-        )]));\n+        let module_graph =\n+            ModuleGraph::from_modules(Vc::cell(vec![ChunkGroupEntry::Entry(all_modules)]));\n         // TODO: Load runtime entries from snapshots\n         match options.runtime {\n             Runtime::Browser => chunking_context.evaluated_chunk_group_assets("
        }
    ],
    "stats": {
        "total": 417,
        "additions": 242,
        "deletions": 175
    }
}