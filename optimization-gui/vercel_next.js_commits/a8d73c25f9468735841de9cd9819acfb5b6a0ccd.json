{
    "author": "sokra",
    "message": "Turbopack: Refactor output assets to allow to lazy compute output assets (#85753)\n\n### What?\n\nRefactor the OutputAssets of chunk groups to not eagerly return all referenced output assets from async loaders, but instead return a list of references that can be followed to get the full list.\nThat solves a problem that will happen when the async loaders create cycles in the output graph.",
    "sha": "a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
    "files": [
        {
            "sha": "97d042e944a51f320bbbfd6bfcecf24a9acf14bf",
            "filename": "crates/next-api/src/analyze.rs",
            "status": "modified",
            "additions": 7,
            "deletions": 1,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-api%2Fsrc%2Fanalyze.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-api%2Fsrc%2Fanalyze.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fanalyze.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -19,7 +19,7 @@ use turbopack_core::{\n     asset::{Asset, AssetContent},\n     chunk::ChunkingType,\n     module::Module,\n-    output::{OutputAsset, OutputAssets},\n+    output::{OutputAsset, OutputAssets, OutputAssetsReference},\n     reference::all_assets_from_entries,\n };\n \n@@ -566,6 +566,9 @@ impl Asset for AnalyzeDataOutputAsset {\n     }\n }\n \n+#[turbo_tasks::value_impl]\n+impl OutputAssetsReference for AnalyzeDataOutputAsset {}\n+\n #[turbo_tasks::value_impl]\n impl OutputAsset for AnalyzeDataOutputAsset {\n     #[turbo_tasks::function]\n@@ -601,6 +604,9 @@ impl Asset for ModulesDataOutputAsset {\n     }\n }\n \n+#[turbo_tasks::value_impl]\n+impl OutputAssetsReference for ModulesDataOutputAsset {}\n+\n #[turbo_tasks::value_impl]\n impl OutputAsset for ModulesDataOutputAsset {\n     #[turbo_tasks::function]"
        },
        {
            "sha": "789be53c69739e4358aca5e31258f0f2891cdf59",
            "filename": "crates/next-api/src/app.rs",
            "status": "modified",
            "additions": 79,
            "deletions": 144,
            "changes": 223,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-api%2Fsrc%2Fapp.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-api%2Fsrc%2Fapp.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fapp.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -1,6 +1,5 @@\n use anyhow::{Context, Result, bail};\n use next_core::{\n-    all_assets_from_entries,\n     app_structure::{\n         AppPageLoaderTree, CollectedRootParams, Entrypoint as AppEntrypoint,\n         Entrypoints as AppEntrypoints, FileSystemPathVec, MetadataItem, collect_root_params,\n@@ -64,6 +63,7 @@ use turbopack_core::{\n     },\n     output::{OutputAsset, OutputAssets, OutputAssetsWithReferenced},\n     raw_output::RawOutput,\n+    reference::all_assets_from_entries,\n     reference_type::{CommonJsReferenceSubType, CssReferenceSubType, ReferenceType},\n     resolve::{origin::PlainResolveOrigin, parse::Request, pattern::Pattern},\n     source::Source,\n@@ -1237,17 +1237,14 @@ impl AppEndpoint {\n                 this.app_project.client_runtime_entries(),\n                 *module_graphs.full,\n                 *client_chunking_context,\n-            )\n-            .await?;\n-\n-            client_assets.extend(client_shared_chunk_group.referenced_assets.await?);\n+            );\n \n-            let client_shared_chunks = client_shared_chunk_group.assets.owned().await?;\n-            client_assets.extend(client_shared_chunks.iter().copied());\n+            client_assets.extend(client_shared_chunk_group.all_assets().await?);\n \n+            let client_shared_chunk_group = client_shared_chunk_group.await?;\n             (\n                 client_shared_chunk_group.availability_info,\n-                client_shared_chunks,\n+                client_shared_chunk_group.assets.owned().await?,\n             )\n         } else {\n             (AvailabilityInfo::Root, vec![])\n@@ -1281,38 +1278,24 @@ impl AppEndpoint {\n         .await?;\n         let client_references_chunks_ref = client_references_chunks.await?;\n \n-        for OutputAssetsWithReferenced {\n-            assets,\n-            referenced_assets,\n-        } in client_references_chunks_ref\n+        for &assets in client_references_chunks_ref\n             .layout_segment_client_chunks\n             .values()\n         {\n-            client_assets.extend(assets.await?.iter().copied());\n-            client_assets.extend(referenced_assets.await?.iter().copied());\n+            client_assets.extend(assets.all_assets().await?.iter().copied());\n         }\n-        for ChunkGroupResult {\n-            assets,\n-            referenced_assets,\n-            availability_info: _,\n-        } in client_references_chunks_ref\n+        for &assets in client_references_chunks_ref\n             .client_component_client_chunks\n             .values()\n         {\n-            client_assets.extend(assets.await?.iter().copied());\n-            client_assets.extend(referenced_assets.await?.iter().copied());\n+            client_assets.extend(assets.all_assets().await?.iter().copied());\n         }\n-        for ChunkGroupResult {\n-            assets,\n-            referenced_assets,\n-            availability_info: _,\n-        } in client_references_chunks_ref\n+        for &assets in client_references_chunks_ref\n             .client_component_ssr_chunks\n             .values()\n         {\n             // TODO(alexkirsz) In which manifest does this go?\n-            server_assets.extend(assets.await?.iter().copied());\n-            server_assets.extend(referenced_assets.await?.iter().copied());\n+            server_assets.extend(assets.all_assets().await?.iter().copied());\n         }\n \n         let manifest_path_prefix = &app_entry.original_name;\n@@ -1338,6 +1321,9 @@ impl AppEndpoint {\n         );\n         client_assets.insert(polyfill_output_asset);\n \n+        let client_assets: ResolvedVc<OutputAssets> =\n+            ResolvedVc::cell(client_assets.into_iter().collect::<Vec<_>>());\n+\n         if emit_manifests != EmitManifests::None {\n             if *this\n                 .app_project\n@@ -1348,7 +1334,7 @@ impl AppEndpoint {\n                 let webpack_stats = generate_webpack_stats(\n                     *module_graphs.base,\n                     app_entry.original_name.clone(),\n-                    client_assets.iter().copied(),\n+                    client_assets.await?.into_iter().copied(),\n                 )\n                 .await?;\n                 let stats_output = VirtualOutputAsset::new(\n@@ -1382,16 +1368,11 @@ impl AppEndpoint {\n             // initialization\n             let client_references_chunks = &*client_references_chunks.await?;\n \n-            for ChunkGroupResult {\n-                assets,\n-                referenced_assets,\n-                availability_info: _,\n-            } in client_references_chunks\n+            for &assets in client_references_chunks\n                 .client_component_ssr_chunks\n                 .values()\n             {\n-                middleware_assets.extend(assets.await?);\n-                middleware_assets.extend(referenced_assets.await?);\n+                middleware_assets.extend(assets.all_assets().await?);\n             }\n         }\n \n@@ -1436,21 +1417,10 @@ impl AppEndpoint {\n             )\n             .to_resolved()\n             .await?;\n+        server_assets.extend(app_entry_chunks.all_assets().await?.into_iter().copied());\n         let app_entry_chunk_group_ref = app_entry_chunks.await?;\n         let app_entry_chunks = app_entry_chunk_group_ref.assets;\n         let app_entry_chunks_ref = app_entry_chunks.await?;\n-        server_assets.extend(app_entry_chunks_ref.iter().copied());\n-        server_assets.extend(\n-            app_entry_chunk_group_ref\n-                .referenced_assets\n-                .await?\n-                .iter()\n-                .copied(),\n-        );\n-\n-        let client_assets = OutputAssets::new(client_assets.iter().map(|asset| **asset).collect())\n-            .to_resolved()\n-            .await?;\n \n         // these references are important for turbotrace\n         let mut client_reference_manifest = None;\n@@ -1619,11 +1589,11 @@ impl AppEndpoint {\n                     server_assets.insert(app_paths_manifest_output);\n                 }\n \n+                let server_assets = ResolvedVc::cell(server_assets.into_iter().collect::<Vec<_>>());\n+\n                 AppEndpointOutput::Edge {\n                     files: app_entry_chunks,\n-                    server_assets: ResolvedVc::cell(\n-                        server_assets.iter().cloned().collect::<Vec<_>>(),\n-                    ),\n+                    server_assets,\n                     client_assets,\n                 }\n             }\n@@ -1700,11 +1670,11 @@ impl AppEndpoint {\n                     ));\n                 }\n \n+                let server_assets = ResolvedVc::cell(server_assets.into_iter().collect::<Vec<_>>());\n+\n                 AppEndpointOutput::NodeJs {\n                     rsc_chunk,\n-                    server_assets: ResolvedVc::cell(\n-                        server_assets.iter().cloned().collect::<Vec<_>>(),\n-                    ),\n+                    server_assets,\n                     client_assets,\n                 }\n             }\n@@ -1732,42 +1702,27 @@ impl AppEndpoint {\n \n         Ok(match runtime {\n             NextRuntime::Edge => {\n-                let ChunkGroupResult {\n-                    assets,\n-                    referenced_assets,\n-                    availability_info,\n-                } = *chunking_context\n-                    .chunk_group(\n-                        server_action_manifest_loader.ident(),\n-                        ChunkGroup::Entry(\n-                            [ResolvedVc::upcast(server_action_manifest_loader)]\n-                                .into_iter()\n-                                .collect(),\n-                        ),\n-                        module_graph,\n-                        AvailabilityInfo::Root,\n-                    )\n-                    .await?;\n+                let chunk_group1 = chunking_context.chunk_group(\n+                    server_action_manifest_loader.ident(),\n+                    ChunkGroup::Entry(\n+                        [ResolvedVc::upcast(server_action_manifest_loader)]\n+                            .into_iter()\n+                            .collect(),\n+                    ),\n+                    module_graph,\n+                    AvailabilityInfo::Root,\n+                );\n \n-                let chunk_group = chunking_context\n-                    .evaluated_chunk_group_assets(\n-                        app_entry.rsc_entry.ident(),\n-                        ChunkGroup::Entry(vec![app_entry.rsc_entry]),\n-                        module_graph,\n-                        availability_info,\n-                    )\n-                    .await?;\n-                OutputAssetsWithReferenced {\n-                    assets: assets\n-                        .concatenate(*chunk_group.assets)\n-                        .to_resolved()\n-                        .await?,\n-                    referenced_assets: referenced_assets\n-                        .concatenate(*chunk_group.referenced_assets)\n-                        .to_resolved()\n-                        .await?,\n-                }\n-                .cell()\n+                let chunk_group2_assets = chunking_context.evaluated_chunk_group_assets(\n+                    app_entry.rsc_entry.ident(),\n+                    ChunkGroup::Entry(vec![app_entry.rsc_entry]),\n+                    module_graph,\n+                    chunk_group1.await?.availability_info,\n+                );\n+\n+                chunk_group1\n+                    .output_assets_with_referenced()\n+                    .concatenate(chunk_group2_assets)\n             }\n             NextRuntime::NodeJs => {\n                 let Some(rsc_entry) = ResolvedVc::try_downcast(app_entry.rsc_entry) else {\n@@ -1777,9 +1732,7 @@ impl AppEndpoint {\n                 let evaluatable_assets = Vc::cell(vec![rsc_entry]);\n \n                 async {\n-                    let mut current_chunks = OutputAssets::empty();\n-                    let mut current_referenced_assets = OutputAssets::empty();\n-                    let mut current_availability_info = AvailabilityInfo::Root;\n+                    let mut current_chunk_group = ChunkGroupResult::empty_resolved();\n \n                     let client_references = client_references.await?;\n                     let span = tracing::trace_span!(\"server utils\");\n@@ -1790,11 +1743,7 @@ impl AppEndpoint {\n                             .map(async |m| Ok(ResolvedVc::upcast(m.await?.module)))\n                             .try_join()\n                             .await?;\n-                        let ChunkGroupResult {\n-                            assets,\n-                            referenced_assets,\n-                            availability_info,\n-                        } = *chunking_context\n+                        let chunk_group = chunking_context\n                             .chunk_group(\n                                 AssetIdent::from_path(\n                                     this.app_project.project().project_path().owned().await?,\n@@ -1803,16 +1752,12 @@ impl AppEndpoint {\n                                 // TODO this should be ChunkGroup::Shared\n                                 ChunkGroup::Entry(server_utils),\n                                 module_graph,\n-                                current_availability_info,\n+                                AvailabilityInfo::Root,\n                             )\n+                            .to_resolved()\n                             .await?;\n \n-                        current_chunks = current_chunks.concatenate(*assets).resolve().await?;\n-                        current_referenced_assets = current_referenced_assets\n-                            .concatenate(*referenced_assets)\n-                            .resolve()\n-                            .await?;\n-                        current_availability_info = availability_info;\n+                        current_chunk_group = chunk_group;\n \n                         anyhow::Ok(())\n                     }\n@@ -1834,28 +1779,20 @@ impl AppEndpoint {\n                             name = display(server_component.ident().to_string().await?)\n                         );\n                         async {\n-                            let ChunkGroupResult {\n-                                assets,\n-                                referenced_assets,\n-                                availability_info,\n-                            } = *chunking_context\n-                                .chunk_group(\n-                                    server_component.ident(),\n-                                    // TODO this should be ChunkGroup::Shared\n-                                    ChunkGroup::Entry(vec![ResolvedVc::upcast(\n-                                        server_component.await?.module,\n-                                    )]),\n-                                    module_graph,\n-                                    current_availability_info,\n-                                )\n-                                .await?;\n+                            let chunk_group = chunking_context.chunk_group(\n+                                server_component.ident(),\n+                                // TODO this should be ChunkGroup::Shared\n+                                ChunkGroup::Entry(vec![ResolvedVc::upcast(\n+                                    server_component.await?.module,\n+                                )]),\n+                                module_graph,\n+                                current_chunk_group.await?.availability_info,\n+                            );\n \n-                            current_chunks = current_chunks.concatenate(*assets).resolve().await?;\n-                            current_referenced_assets = current_referenced_assets\n-                                .concatenate(*referenced_assets)\n-                                .resolve()\n+                            current_chunk_group = current_chunk_group\n+                                .concatenate(chunk_group)\n+                                .to_resolved()\n                                 .await?;\n-                            current_availability_info = availability_info;\n \n                             anyhow::Ok(())\n                         }\n@@ -1864,29 +1801,26 @@ impl AppEndpoint {\n                     }\n \n                     {\n-                        let ChunkGroupResult {\n-                            assets,\n-                            referenced_assets,\n-                            availability_info,\n-                        } = *chunking_context\n-                            .chunk_group(\n-                                server_action_manifest_loader.ident(),\n-                                ChunkGroup::Entry(vec![ResolvedVc::upcast(\n-                                    server_action_manifest_loader,\n-                                )]),\n-                                module_graph,\n-                                current_availability_info,\n-                            )\n-                            .await?;\n+                        let chunk_group = chunking_context.chunk_group(\n+                            server_action_manifest_loader.ident(),\n+                            ChunkGroup::Entry(vec![ResolvedVc::upcast(\n+                                server_action_manifest_loader,\n+                            )]),\n+                            module_graph,\n+                            current_chunk_group.await?.availability_info,\n+                        );\n \n-                        current_chunks = current_chunks.concatenate(*assets).resolve().await?;\n-                        current_referenced_assets = current_referenced_assets\n-                            .concatenate(*referenced_assets)\n-                            .resolve()\n+                        current_chunk_group = current_chunk_group\n+                            .concatenate(chunk_group)\n+                            .to_resolved()\n                             .await?;\n-                        current_availability_info = availability_info;\n                     }\n \n+                    let current_referenced_assets = current_chunk_group.referenced_assets();\n+                    let chunk_group = current_chunk_group.await?;\n+                    let current_availability_info = chunk_group.availability_info;\n+                    let current_chunks = chunk_group.assets;\n+\n                     anyhow::Ok(\n                         OutputAssetsWithReferenced {\n                             assets: ResolvedVc::cell(vec![\n@@ -1898,14 +1832,15 @@ impl AppEndpoint {\n                                         ))?,\n                                         evaluatable_assets,\n                                         module_graph,\n-                                        current_chunks,\n+                                        *current_chunks,\n                                         current_referenced_assets,\n                                         current_availability_info,\n                                     )\n                                     .to_resolved()\n                                     .await?,\n                             ]),\n                             referenced_assets: ResolvedVc::cell(vec![]),\n+                            references: ResolvedVc::cell(vec![]),\n                         }\n                         .cell(),\n                     )"
        },
        {
            "sha": "436a375f13f2f0d11fe444d4efb6871c6cfc58c1",
            "filename": "crates/next-api/src/dynamic_imports.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-api%2Fsrc%2Fdynamic_imports.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-api%2Fsrc%2Fdynamic_imports.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fdynamic_imports.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -31,12 +31,12 @@ use turbo_tasks::{\n };\n use turbopack_core::{\n     chunk::{\n-        ChunkItem, ChunkableModule, ChunkingContext, ModuleChunkItemIdExt, ModuleId,\n+        ChunkableModule, ChunkingContext, ModuleChunkItemIdExt, ModuleId,\n         availability_info::AvailabilityInfo,\n     },\n     module::Module,\n     module_graph::{ModuleGraph, SingleModuleGraph},\n-    output::OutputAssets,\n+    output::{OutputAssetsReference, OutputAssetsWithReferenced},\n };\n \n use crate::module_graph::DynamicImportEntriesWithImporter;\n@@ -72,6 +72,7 @@ pub(crate) async fn collect_next_dynamic_chunks(\n                             )?,\n                         )\n                         .context(\"Client reference chunk group not found for next/dynamic import\")?\n+                        .await?\n                         .availability_info\n                 }\n                 NextDynamicChunkAvailability::AvailabilityInfo(availability_info) => {\n@@ -103,7 +104,7 @@ pub(crate) async fn collect_next_dynamic_chunks(\n pub struct DynamicImportedChunks(\n     pub  FxIndexMap<\n         ResolvedVc<NextDynamicEntryModule>,\n-        (ResolvedVc<ModuleId>, ResolvedVc<OutputAssets>),\n+        (ResolvedVc<ModuleId>, ResolvedVc<OutputAssetsWithReferenced>),\n     >,\n );\n "
        },
        {
            "sha": "ad3c6ab5674c9c6966c91d9b8219930e95ca51d2",
            "filename": "crates/next-api/src/font.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 2,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-api%2Fsrc%2Ffont.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-api%2Fsrc%2Ffont.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Ffont.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -1,11 +1,12 @@\n use anyhow::Result;\n-use next_core::{all_assets_from_entries, next_manifests::NextFontManifest};\n+use next_core::next_manifests::NextFontManifest;\n use turbo_rcstr::RcStr;\n use turbo_tasks::{ResolvedVc, Vc};\n use turbo_tasks_fs::{File, FileSystemPath};\n use turbopack_core::{\n     asset::{Asset, AssetContent},\n-    output::{OutputAsset, OutputAssets},\n+    output::{OutputAsset, OutputAssets, OutputAssetsReference},\n+    reference::all_assets_from_entries,\n };\n \n use crate::paths::get_font_paths_from_root;\n@@ -22,6 +23,9 @@ pub struct FontManifest {\n     pub app_dir: bool,\n }\n \n+#[turbo_tasks::value_impl]\n+impl OutputAssetsReference for FontManifest {}\n+\n #[turbo_tasks::value_impl]\n impl OutputAsset for FontManifest {\n     #[turbo_tasks::function]"
        },
        {
            "sha": "a361643d91218149f0f781ae3addd61afc03744d",
            "filename": "crates/next-api/src/instrumentation.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 4,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-api%2Fsrc%2Finstrumentation.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-api%2Fsrc%2Finstrumentation.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Finstrumentation.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -1,6 +1,5 @@\n use anyhow::{Result, bail};\n use next_core::{\n-    all_assets_from_entries,\n     next_edge::entry::wrap_edge_entry,\n     next_manifests::{InstrumentationDefinition, MiddlewaresManifestV2},\n };\n@@ -147,7 +146,7 @@ impl InstrumentationEndpoint {\n \n         if this.is_edge {\n             let edge_chunk_group = self.edge_chunk_group();\n-            let edge_all_assets = edge_chunk_group.all_assets();\n+            let edge_all_assets = edge_chunk_group.expand_all_assets();\n \n             let node_root = this.project.node_root().owned().await?;\n             let node_root_value = node_root.clone();\n@@ -156,10 +155,10 @@ impl InstrumentationEndpoint {\n                 get_js_paths_from_root(&node_root_value, &edge_chunk_group.await?.assets.await?)\n                     .await?;\n \n-            let mut output_assets = all_assets_from_entries(edge_all_assets).owned().await?;\n+            let mut output_assets = edge_chunk_group.all_assets().owned().await?;\n \n             let wasm_paths_from_root =\n-                get_wasm_paths_from_root(&node_root_value, &output_assets).await?;\n+                get_wasm_paths_from_root(&node_root_value, edge_all_assets.await?).await?;\n \n             let instrumentation_definition = InstrumentationDefinition {\n                 files: file_paths_from_root,"
        },
        {
            "sha": "3f5fff4a4a87a6cf6d7ab907a3b3d0ab86d3d6a9",
            "filename": "crates/next-api/src/loadable_manifest.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-api%2Fsrc%2Floadable_manifest.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-api%2Fsrc%2Floadable_manifest.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Floadable_manifest.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -23,7 +23,7 @@ pub async fn create_react_loadable_manifest(\n     let mut loadable_manifest: FxIndexMap<String, LoadableManifest> = FxIndexMap::default();\n \n     for (_, (module_id, chunk_output)) in dynamic_import_entries.into_iter() {\n-        let chunk_output = chunk_output.await?;\n+        let chunk_output = chunk_output.primary_assets().await?;\n \n         let id = &*module_id.await?;\n "
        },
        {
            "sha": "f6ed30d804347a36445c88bf09723a55e683dbf0",
            "filename": "crates/next-api/src/middleware.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-api%2Fsrc%2Fmiddleware.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-api%2Fsrc%2Fmiddleware.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fmiddleware.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -2,7 +2,6 @@ use std::future::IntoFuture;\n \n use anyhow::{Result, bail};\n use next_core::{\n-    all_assets_from_entries,\n     middleware::get_middleware_module,\n     next_edge::entry::wrap_edge_entry,\n     next_manifests::{EdgeFunctionDefinition, MiddlewaresManifestV2, ProxyMatcher, Regions},\n@@ -258,7 +257,7 @@ impl MiddlewareEndpoint {\n             Ok(Vc::cell(output_assets))\n         } else {\n             let edge_chunk_group = self.edge_chunk_group();\n-            let edge_all_assets = edge_chunk_group.all_assets();\n+            let edge_all_assets = edge_chunk_group.expand_all_assets();\n \n             let node_root = this.project.node_root().owned().await?;\n             let node_root_value = node_root.clone();\n@@ -267,12 +266,13 @@ impl MiddlewareEndpoint {\n                 get_js_paths_from_root(&node_root_value, &edge_chunk_group.await?.assets.await?)\n                     .await?;\n \n-            let mut output_assets = all_assets_from_entries(edge_all_assets).owned().await?;\n+            let mut output_assets = edge_chunk_group.all_assets().owned().await?;\n \n             let wasm_paths_from_root =\n-                get_wasm_paths_from_root(&node_root_value, &output_assets).await?;\n+                get_wasm_paths_from_root(&node_root_value, edge_all_assets.await?).await?;\n \n-            let all_assets = get_asset_paths_from_root(&node_root_value, &output_assets).await?;\n+            let all_assets =\n+                get_asset_paths_from_root(&node_root_value, &edge_all_assets.await?).await?;\n \n             let regions = if let Some(regions) = config.preferred_region.as_ref() {\n                 if regions.len() == 1 {"
        },
        {
            "sha": "2732409b6b51fb24e38c2216f889045b83cd063f",
            "filename": "crates/next-api/src/next_server_nft.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-api%2Fsrc%2Fnext_server_nft.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-api%2Fsrc%2Fnext_server_nft.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fnext_server_nft.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -16,7 +16,7 @@ use turbopack_core::{\n     asset::{Asset, AssetContent},\n     context::AssetContext,\n     file_source::FileSource,\n-    output::{OutputAsset, OutputAssets},\n+    output::{OutputAsset, OutputAssets, OutputAssetsReference},\n     reference_type::{CommonJsReferenceSubType, ReferenceType},\n     resolve::{origin::PlainResolveOrigin, parse::Request},\n     traced_asset::TracedAsset,\n@@ -76,6 +76,9 @@ impl ServerNftJsonAsset {\n     }\n }\n \n+#[turbo_tasks::value_impl]\n+impl OutputAssetsReference for ServerNftJsonAsset {}\n+\n #[turbo_tasks::value_impl]\n impl OutputAsset for ServerNftJsonAsset {\n     #[turbo_tasks::function]"
        },
        {
            "sha": "95bc9544fcc7a310aa2d87537ef9cee2ead8348d",
            "filename": "crates/next-api/src/nft_json.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 3,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-api%2Fsrc%2Fnft_json.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-api%2Fsrc%2Fnft_json.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fnft_json.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -14,7 +14,7 @@ use turbo_tasks_fs::{\n };\n use turbopack_core::{\n     asset::{Asset, AssetContent},\n-    output::{OutputAsset, OutputAssets},\n+    output::{OutputAsset, OutputAssets, OutputAssetsReference},\n };\n \n use crate::project::Project;\n@@ -59,6 +59,9 @@ impl NftJsonAsset {\n     }\n }\n \n+#[turbo_tasks::value_impl]\n+impl OutputAssetsReference for NftJsonAsset {}\n+\n #[turbo_tasks::value_impl]\n impl OutputAsset for NftJsonAsset {\n     #[turbo_tasks::function]\n@@ -454,7 +457,7 @@ impl Visit<(ResolvedVc<Box<dyn OutputAsset>>, Option<ReadRef<RcStr>>)>\n         node: &(ResolvedVc<Box<dyn OutputAsset>>, Option<ReadRef<RcStr>>),\n     ) -> Self::EdgesFuture {\n         let client_root = self.client_root.clone();\n-        let exclude_glob = self.exclude_glob.clone();\n+        let exclude_glob: Option<ReadRef<Glob>> = self.exclude_glob.clone();\n         get_referenced_server_assets(self.emit_spans, node.0, client_root, exclude_glob)\n     }\n \n@@ -478,7 +481,7 @@ async fn get_referenced_server_assets(\n     client_root: Option<FileSystemPath>,\n     exclude_glob: Option<ReadRef<Glob>>,\n ) -> Result<Vec<(ResolvedVc<Box<dyn OutputAsset>>, Option<ReadRef<RcStr>>)>> {\n-    let refs = asset.references().await?;\n+    let refs = asset.references().all_assets().await?;\n \n     refs.iter()\n         .map(async |asset| {"
        },
        {
            "sha": "5ffc7227bd004056d81b6f08428a32362c8b9c8f",
            "filename": "crates/next-api/src/pages.rs",
            "status": "modified",
            "additions": 37,
            "deletions": 58,
            "changes": 95,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-api%2Fsrc%2Fpages.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-api%2Fsrc%2Fpages.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fpages.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -1,8 +1,8 @@\n use anyhow::{Context, Result, bail};\n use futures::future::BoxFuture;\n use next_core::{\n-    PageLoaderAsset, all_assets_from_entries, create_page_loader_entry_module,\n-    get_asset_path_from_pathname, get_edge_resolve_options_context,\n+    PageLoaderAsset, create_page_loader_entry_module, get_asset_path_from_pathname,\n+    get_edge_resolve_options_context,\n     hmr_entry::HmrEntryModule,\n     mode::NextMode,\n     next_client::{\n@@ -56,7 +56,8 @@ use turbopack_core::{\n         GraphEntries, ModuleGraph, SingleModuleGraph, VisitedModules,\n         chunk_group_info::{ChunkGroup, ChunkGroupEntry},\n     },\n-    output::{OptionOutputAsset, OutputAsset, OutputAssets, OutputAssetsWithReferenced},\n+    output::{OptionOutputAsset, OutputAsset, OutputAssets},\n+    reference::all_assets_from_entries,\n     reference_type::{EcmaScriptModulesReferenceSubType, EntryReferenceSubType, ReferenceType},\n     resolve::{origin::PlainResolveOrigin, parse::Request, pattern::Pattern},\n     source::Source,\n@@ -1003,34 +1004,24 @@ impl PageEndpoint {\n                 NextRuntime::Edge => edge_chunking_context,\n             };\n \n-            let mut current_chunks = OutputAssets::empty();\n-            let mut current_referenced_assets = OutputAssets::empty();\n-            let mut current_availability_info = AvailabilityInfo::Root;\n+            let mut current_chunk_group = ChunkGroupResult::empty_resolved();\n             for layout in [document_module, app_module].iter().flatten().copied() {\n                 let span = tracing::trace_span!(\n                     \"layout segment\",\n                     name = display(layout.ident().to_string().await?)\n                 );\n                 async {\n-                    let ChunkGroupResult {\n-                        assets,\n-                        referenced_assets,\n-                        availability_info,\n-                    } = *chunking_context\n-                        .chunk_group(\n-                            layout.ident(),\n-                            ChunkGroup::Shared(layout),\n-                            ssr_module_graph,\n-                            current_availability_info,\n-                        )\n-                        .await?;\n+                    let chunk_group = chunking_context.chunk_group(\n+                        layout.ident(),\n+                        ChunkGroup::Shared(layout),\n+                        ssr_module_graph,\n+                        current_chunk_group.await?.availability_info,\n+                    );\n \n-                    current_chunks = current_chunks.concatenate(*assets).resolve().await?;\n-                    current_referenced_assets = current_referenced_assets\n-                        .concatenate(*referenced_assets)\n-                        .resolve()\n+                    current_chunk_group = current_chunk_group\n+                        .concatenate(chunk_group)\n+                        .to_resolved()\n                         .await?;\n-                    current_availability_info = availability_info;\n \n                     anyhow::Ok(())\n                 }\n@@ -1042,27 +1033,22 @@ impl PageEndpoint {\n                 .context(\"could not process page loader entry module\")?;\n             let is_edge = matches!(runtime, NextRuntime::Edge);\n             if is_edge {\n-                let OutputAssetsWithReferenced {\n-                    assets: edge_assets,\n-                    referenced_assets: edge_referenced_assets,\n-                } = *edge_chunking_context\n-                    .evaluated_chunk_group_assets(\n-                        ssr_module.ident(),\n-                        ChunkGroup::Entry(vec![ResolvedVc::upcast(ssr_module_evaluatable)]),\n-                        ssr_module_graph,\n-                        current_availability_info,\n-                    )\n+                let chunk_assets = edge_chunking_context.evaluated_chunk_group_assets(\n+                    ssr_module.ident(),\n+                    ChunkGroup::Entry(vec![ResolvedVc::upcast(ssr_module_evaluatable)]),\n+                    ssr_module_graph,\n+                    current_chunk_group.await?.availability_info,\n+                );\n+\n+                let chunk_assets = current_chunk_group\n+                    .output_assets_with_referenced()\n+                    .concatenate(chunk_assets)\n+                    .to_resolved()\n                     .await?;\n \n                 Ok(SsrChunk::Edge {\n-                    assets: current_chunks\n-                        .concatenate(*edge_assets)\n-                        .to_resolved()\n-                        .await?,\n-                    referenced_assets: current_referenced_assets\n-                        .concatenate(*edge_referenced_assets)\n-                        .to_resolved()\n-                        .await?,\n+                    assets: chunk_assets.primary_assets().to_resolved().await?,\n+                    referenced_assets: chunk_assets.referenced_assets().to_resolved().await?,\n                     dynamic_import_entries,\n                     regions: regions.clone(),\n                 }\n@@ -1079,9 +1065,9 @@ impl PageEndpoint {\n                         ssr_entry_chunk_path,\n                         EvaluatableAssets::empty().with_entry(*ssr_module_evaluatable),\n                         ssr_module_graph,\n-                        current_chunks,\n-                        current_referenced_assets,\n-                        current_availability_info,\n+                        current_chunk_group.primary_assets(),\n+                        current_chunk_group.referenced_assets(),\n+                        current_chunk_group.await?.availability_info,\n                     )\n                     .to_resolved()\n                     .await?;\n@@ -1321,21 +1307,14 @@ impl PageEndpoint {\n \n         let ssr_chunk = match this.ty {\n             PageEndpointType::Html => {\n-                let client_chunk_group = self.client_chunk_group().await?;\n-                let client_chunks = *client_chunk_group.assets;\n-                client_assets.extend(client_chunks.await?.iter().map(|asset| **asset));\n-                client_assets.extend(\n-                    client_chunk_group\n-                        .referenced_assets\n-                        .await?\n-                        .iter()\n-                        .map(|asset| **asset),\n-                );\n+                let client_chunk_group = self.client_chunk_group();\n+                client_assets.extend(client_chunk_group.all_assets().await?.iter().copied());\n+                let client_chunks = *client_chunk_group.await?.assets;\n \n                 let build_manifest = self.build_manifest(client_chunks).to_resolved().await?;\n-                let page_loader = self.page_loader(client_chunks);\n+                let page_loader = self.page_loader(client_chunks).to_resolved().await?;\n                 let client_build_manifest = self\n-                    .client_build_manifest(page_loader)\n+                    .client_build_manifest(*page_loader)\n                     .to_resolved()\n                     .await?;\n                 client_assets.push(page_loader);\n@@ -1350,7 +1329,7 @@ impl PageEndpoint {\n             PageEndpointType::SsrOnly => self.ssr_chunk(emit_manifests),\n         };\n \n-        let client_assets = OutputAssets::new(client_assets).to_resolved().await?;\n+        let client_assets: ResolvedVc<OutputAssets> = ResolvedVc::cell(client_assets);\n \n         let manifest_path_prefix = get_asset_prefix_from_pathname(&this.pathname);\n         let node_root = this.pages_project.project().node_root().owned().await?;\n@@ -1381,7 +1360,7 @@ impl PageEndpoint {\n             let webpack_stats = generate_webpack_stats(\n                 self.client_module_graph(),\n                 this.original_name.clone(),\n-                client_assets.await?.iter().copied(),\n+                client_assets.await?.into_iter().copied(),\n             )\n             .await?;\n             let stats_output = VirtualOutputAsset::new("
        },
        {
            "sha": "0aaa68bc9f3f539fe7f04004eacf913023289eaf",
            "filename": "crates/next-api/src/paths.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-api%2Fsrc%2Fpaths.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-api%2Fsrc%2Fpaths.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fpaths.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -1,12 +1,13 @@\n use anyhow::Result;\n-use next_core::{all_assets_from_entries, next_manifests::AssetBinding};\n+use next_core::next_manifests::AssetBinding;\n use tracing::Instrument;\n use turbo_rcstr::RcStr;\n use turbo_tasks::{ResolvedVc, TryFlatJoinIterExt, TryJoinIterExt, Vc};\n use turbo_tasks_fs::FileSystemPath;\n use turbopack_core::{\n     asset::Asset,\n     output::{OutputAsset, OutputAssets},\n+    reference::all_assets_from_entries,\n };\n use turbopack_wasm::wasm_edge_var_name;\n "
        },
        {
            "sha": "f8fa52aebbdcfae28aa80915e441c75377707b29",
            "filename": "crates/next-api/src/project.rs",
            "status": "modified",
            "additions": 17,
            "deletions": 21,
            "changes": 38,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fproject.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -3,7 +3,6 @@ use std::time::Duration;\n use anyhow::{Context, Result, bail};\n use indexmap::map::Entry;\n use next_core::{\n-    all_assets_from_entries,\n     app_structure::find_app_dir,\n     emit_assets, get_edge_chunking_context, get_edge_chunking_context_with_client_assets,\n     get_edge_compile_time_info, get_edge_resolve_options_context,\n@@ -31,11 +30,7 @@ use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{\n     Completion, Completions, FxIndexMap, IntoTraitRef, NonLocalValue, OperationValue, OperationVc,\n     ReadRef, ResolvedVc, State, TaskInput, TransientInstance, TryFlatJoinIterExt, Vc,\n-    debug::ValueDebugFormat,\n-    fxindexmap,\n-    graph::{AdjacencyMap, GraphTraversal},\n-    mark_root,\n-    trace::TraceRawVcs,\n+    debug::ValueDebugFormat, fxindexmap, mark_root, trace::TraceRawVcs,\n };\n use turbo_tasks_env::{EnvMap, ProcessEnv};\n use turbo_tasks_fs::{DiskFileSystem, FileSystem, FileSystemPath, VirtualFileSystem, invalidation};\n@@ -67,7 +62,11 @@ use turbopack_core::{\n         chunk_group_info::ChunkGroupEntry,\n         export_usage::{OptionExportUsageInfo, compute_export_usage_info},\n     },\n-    output::{OutputAsset, OutputAssets},\n+    output::{\n+        ExpandOutputAssetsInput, ExpandedOutputAssets, OutputAsset, OutputAssets,\n+        expand_output_assets,\n+    },\n+    reference::all_assets_from_entries,\n     resolve::{FindContextFileResult, find_context_file},\n     source_map::OptionStringifiedSourceMap,\n     version::{\n@@ -1939,13 +1938,16 @@ async fn any_output_changed(\n     path: FileSystemPath,\n     server: bool,\n ) -> Result<Vc<Completion>> {\n-    let completions = AdjacencyMap::new()\n-        .skip_duplicates()\n-        .visit(roots.await?.iter().copied(), get_referenced_output_assets)\n-        .await\n-        .completed()?\n-        .into_inner()\n-        .into_postorder_topological()\n+    let all_assets = expand_output_assets(\n+        roots\n+            .await?\n+            .into_iter()\n+            .map(|&a| ExpandOutputAssetsInput::Asset(a)),\n+        true,\n+    )\n+    .await?;\n+    let completions = all_assets\n+        .into_iter()\n         .map(|m| {\n             let path = path.clone();\n \n@@ -1971,16 +1973,10 @@ async fn any_output_changed(\n     Ok(Vc::<Completions>::cell(completions).completed())\n }\n \n-async fn get_referenced_output_assets(\n-    parent: ResolvedVc<Box<dyn OutputAsset>>,\n-) -> Result<impl Iterator<Item = ResolvedVc<Box<dyn OutputAsset>>> + Send> {\n-    Ok(parent.references().owned().await?.into_iter())\n-}\n-\n #[turbo_tasks::function(operation)]\n fn all_assets_from_entries_operation(\n     operation: OperationVc<OutputAssets>,\n-) -> Result<Vc<OutputAssets>> {\n+) -> Result<Vc<ExpandedOutputAssets>> {\n     let assets = operation.connect();\n     Ok(all_assets_from_entries(assets))\n }"
        },
        {
            "sha": "7aa8d232e97249bf43220abbfb8129d336cf3a7e",
            "filename": "crates/next-api/src/versioned_content_map.rs",
            "status": "modified",
            "additions": 10,
            "deletions": 9,
            "changes": 19,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-api%2Fsrc%2Fversioned_content_map.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-api%2Fsrc%2Fversioned_content_map.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fversioned_content_map.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -10,7 +10,7 @@ use turbo_tasks::{\n use turbo_tasks_fs::FileSystemPath;\n use turbopack_core::{\n     asset::Asset,\n-    output::{OptionOutputAsset, OutputAsset, OutputAssets},\n+    output::{ExpandedOutputAssets, OptionOutputAsset, OutputAsset},\n     source_map::{GenerateSourceMap, OptionStringifiedSourceMap},\n     version::OptionVersionedContent,\n };\n@@ -27,7 +27,7 @@ use turbopack_core::{\n     NonLocalValue,\n )]\n struct MapEntry {\n-    assets_operation: OperationVc<OutputAssets>,\n+    assets_operation: OperationVc<ExpandedOutputAssets>,\n     /// Precomputed map for quick access to output asset by filepath\n     path_to_asset: FxHashMap<FileSystemPath, ResolvedVc<Box<dyn OutputAsset>>>,\n }\n@@ -47,19 +47,20 @@ pub struct PathToOutputOperation(\n     /// It may not be 100% correct for the key (`FileSystemPath`) to be in a `ResolvedVc` here, but\n     /// it's impractical to make it an `OperationVc`/`OperationValue`, and it's unlikely to\n     /// change/break?\n-    FxHashMap<FileSystemPath, FxIndexSet<OperationVc<OutputAssets>>>,\n+    FxHashMap<FileSystemPath, FxIndexSet<OperationVc<ExpandedOutputAssets>>>,\n );\n \n // HACK: This is technically incorrect because the map's key is a `ResolvedVc`...\n unsafe impl OperationValue for PathToOutputOperation {}\n \n // A precomputed map for quick access to output asset by filepath\n type OutputOperationToComputeEntry =\n-    FxHashMap<OperationVc<OutputAssets>, OperationVc<OptionMapEntry>>;\n+    FxHashMap<OperationVc<ExpandedOutputAssets>, OperationVc<OptionMapEntry>>;\n \n #[turbo_tasks::value]\n pub struct VersionedContentMap {\n-    // TODO: turn into a bi-directional multimap, OutputAssets -> FxIndexSet<FileSystemPath>\n+    // TODO: turn into a bi-directional multimap, ExpandedOutputAssets ->\n+    // FxIndexSet<FileSystemPath>\n     map_path_to_op: State<PathToOutputOperation>,\n     map_op_to_compute_entry: State<OutputOperationToComputeEntry>,\n }\n@@ -90,7 +91,7 @@ impl VersionedContentMap {\n     pub async fn insert_output_assets(\n         self: ResolvedVc<Self>,\n         // Output assets to emit\n-        assets_operation: OperationVc<OutputAssets>,\n+        assets_operation: OperationVc<ExpandedOutputAssets>,\n         node_root: FileSystemPath,\n         client_relative_path: FileSystemPath,\n         client_output_path: FileSystemPath,\n@@ -114,7 +115,7 @@ impl VersionedContentMap {\n     #[turbo_tasks::function]\n     async fn compute_entry(\n         &self,\n-        assets_operation: OperationVc<OutputAssets>,\n+        assets_operation: OperationVc<ExpandedOutputAssets>,\n         node_root: FileSystemPath,\n         client_relative_path: FileSystemPath,\n         client_output_path: FileSystemPath,\n@@ -259,7 +260,7 @@ type GetEntriesResultT = Vec<(FileSystemPath, ResolvedVc<Box<dyn OutputAsset>>)>\n struct GetEntriesResult(GetEntriesResultT);\n \n #[turbo_tasks::function(operation)]\n-async fn get_entries(assets: OperationVc<OutputAssets>) -> Result<Vc<GetEntriesResult>> {\n+async fn get_entries(assets: OperationVc<ExpandedOutputAssets>) -> Result<Vc<GetEntriesResult>> {\n     let assets_ref = assets.connect().await?;\n     let entries = assets_ref\n         .iter()\n@@ -275,7 +276,7 @@ async fn get_entries(assets: OperationVc<OutputAssets>) -> Result<Vc<GetEntriesR\n #[turbo_tasks::function(operation)]\n fn compute_entry_operation(\n     map: ResolvedVc<VersionedContentMap>,\n-    assets_operation: OperationVc<OutputAssets>,\n+    assets_operation: OperationVc<ExpandedOutputAssets>,\n     node_root: FileSystemPath,\n     client_relative_path: FileSystemPath,\n     client_output_path: FileSystemPath,"
        },
        {
            "sha": "9caeb4af2365ea1a85bcd81f1337c3c05bf6f772",
            "filename": "crates/next-api/src/webpack_stats.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-api%2Fsrc%2Fwebpack_stats.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-api%2Fsrc%2Fwebpack_stats.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fwebpack_stats.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -11,7 +11,7 @@ use turbopack_core::{\n     chunk::{Chunk, ChunkItem, ChunkItemExt, ModuleId},\n     module::Module,\n     module_graph::ModuleGraph,\n-    output::OutputAsset,\n+    output::{OutputAsset, OutputAssetsReference},\n };\n \n #[instrument(level = \"info\", name = \"generate webpack stats\", skip_all)]\n@@ -38,7 +38,7 @@ where\n         let mut queue = entry_assets.clone();\n         while let Some(asset) = queue.pop() {\n             if visited.insert(asset) {\n-                let references = asset.references().await?;\n+                let references = asset.references().all_assets().await?;\n                 asset_children.insert(asset, references.clone());\n                 queue.extend(references);\n             }"
        },
        {
            "sha": "dcae1d1d4c72492cb3e1b64e379be93aee710f62",
            "filename": "crates/next-core/src/emit.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 103,
            "changes": 108,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-core%2Fsrc%2Femit.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-core%2Fsrc%2Femit.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Femit.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -1,14 +1,11 @@\n use anyhow::Result;\n-use tracing::{Instrument, Level, Span};\n-use turbo_rcstr::RcStr;\n-use turbo_tasks::{\n-    FxIndexSet, ReadRef, ResolvedVc, TryFlatJoinIterExt, TryJoinIterExt, Vc,\n-    graph::{AdjacencyMap, GraphTraversal, Visit, VisitControlFlow},\n-};\n+use tracing::Instrument;\n+use turbo_tasks::{TryFlatJoinIterExt, Vc};\n use turbo_tasks_fs::{FileSystemPath, rebase};\n use turbopack_core::{\n     asset::Asset,\n-    output::{OutputAsset, OutputAssets},\n+    output::{ExpandedOutputAssets, OutputAsset, OutputAssets},\n+    reference::all_assets_from_entries,\n };\n \n /// Emits all assets transitively reachable from the given chunks, that are\n@@ -41,7 +38,7 @@ pub async fn emit_all_assets(\n /// path.\n #[turbo_tasks::function]\n pub async fn emit_assets(\n-    assets: Vc<OutputAssets>,\n+    assets: Vc<ExpandedOutputAssets>,\n     node_root: FileSystemPath,\n     client_relative_path: FileSystemPath,\n     client_output_path: FileSystemPath,\n@@ -113,98 +110,3 @@ async fn emit_rebase(\n         .await?;\n     Ok(())\n }\n-\n-struct OutputAssetVisit {\n-    emit_spans: bool,\n-}\n-impl Visit<(ResolvedVc<Box<dyn OutputAsset>>, Option<ReadRef<RcStr>>)> for OutputAssetVisit {\n-    type Edge = (ResolvedVc<Box<dyn OutputAsset>>, Option<ReadRef<RcStr>>);\n-    type EdgesIntoIter = Vec<Self::Edge>;\n-    type EdgesFuture = impl Future<Output = Result<Self::EdgesIntoIter>>;\n-\n-    fn visit(&mut self, edge: Self::Edge) -> VisitControlFlow<Self::Edge> {\n-        VisitControlFlow::Continue(edge)\n-    }\n-\n-    fn edges(\n-        &mut self,\n-        node: &(ResolvedVc<Box<dyn OutputAsset>>, Option<ReadRef<RcStr>>),\n-    ) -> Self::EdgesFuture {\n-        get_referenced_assets(self.emit_spans, node.0)\n-    }\n-\n-    fn span(\n-        &mut self,\n-        node: &(ResolvedVc<Box<dyn OutputAsset>>, Option<ReadRef<RcStr>>),\n-    ) -> tracing::Span {\n-        if let Some(ident) = &node.1 {\n-            tracing::trace_span!(\"asset\", name = display(ident))\n-        } else {\n-            Span::current()\n-        }\n-    }\n-}\n-\n-/// Walks the asset graph from multiple assets and collect all referenced\n-/// assets.\n-#[turbo_tasks::function]\n-pub async fn all_assets_from_entries(entries: Vc<OutputAssets>) -> Result<Vc<OutputAssets>> {\n-    let emit_spans = tracing::enabled!(Level::INFO);\n-    Ok(Vc::cell(\n-        AdjacencyMap::new()\n-            .skip_duplicates()\n-            .visit(\n-                entries\n-                    .await?\n-                    .iter()\n-                    .map(async |asset| {\n-                        Ok((\n-                            *asset,\n-                            if emit_spans {\n-                                // INVALIDATION: we don't need to invalidate when the span name\n-                                // changes\n-                                Some(asset.path_string().untracked().await?)\n-                            } else {\n-                                None\n-                            },\n-                        ))\n-                    })\n-                    .try_join()\n-                    .await?,\n-                OutputAssetVisit { emit_spans },\n-            )\n-            .await\n-            .completed()?\n-            .into_inner()\n-            .into_postorder_topological()\n-            .map(|(asset, _)| asset)\n-            .collect::<FxIndexSet<_>>()\n-            .into_iter()\n-            .collect(),\n-    ))\n-}\n-\n-/// Computes the list of all chunk children of a given chunk.\n-async fn get_referenced_assets(\n-    emit_spans: bool,\n-    asset: ResolvedVc<Box<dyn OutputAsset>>,\n-) -> Result<Vec<(ResolvedVc<Box<dyn OutputAsset>>, Option<ReadRef<RcStr>>)>> {\n-    asset\n-        .references()\n-        .await?\n-        .iter()\n-        .map(async |asset| {\n-            Ok((\n-                *asset,\n-                if emit_spans {\n-                    // INVALIDATION: we don't need to invalidate the list of assets when the span\n-                    // name changes\n-                    Some(asset.path_string().untracked().await?)\n-                } else {\n-                    None\n-                },\n-            ))\n-        })\n-        .try_join()\n-        .await\n-}"
        },
        {
            "sha": "d10b294ad44a316433be160c75f951b2e8253f83",
            "filename": "crates/next-core/src/hmr_entry.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-core%2Fsrc%2Fhmr_entry.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-core%2Fsrc%2Fhmr_entry.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fhmr_entry.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -13,6 +13,7 @@ use turbopack_core::{\n     ident::AssetIdent,\n     module::Module,\n     module_graph::ModuleGraph,\n+    output::OutputAssetsReference,\n     reference::{ModuleReference, ModuleReferences},\n     resolve::ModuleResolveResult,\n };\n@@ -154,6 +155,9 @@ struct HmrEntryChunkItem {\n     chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n }\n \n+#[turbo_tasks::value_impl]\n+impl OutputAssetsReference for HmrEntryChunkItem {}\n+\n #[turbo_tasks::value_impl]\n impl ChunkItem for HmrEntryChunkItem {\n     #[turbo_tasks::function]"
        },
        {
            "sha": "fa6c840c0f50e99d0ccd95c46246bf03ccddbc3f",
            "filename": "crates/next-core/src/lib.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-core%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-core%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Flib.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -41,7 +41,7 @@ mod transform_options;\n pub mod url_node;\n pub mod util;\n \n-pub use emit::{all_assets_from_entries, emit_all_assets, emit_assets};\n+pub use emit::{emit_all_assets, emit_assets};\n pub use next_edge::context::{\n     get_edge_chunking_context, get_edge_chunking_context_with_client_assets,\n     get_edge_compile_time_info, get_edge_resolve_options_context,"
        },
        {
            "sha": "552768dc589cdb645edca2732d093b5e748fcd5c",
            "filename": "crates/next-core/src/next_app/app_client_references_chunks.rs",
            "status": "modified",
            "additions": 53,
            "deletions": 78,
            "changes": 131,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fapp_client_references_chunks.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fapp_client_references_chunks.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fapp_client_references_chunks.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -6,7 +6,7 @@ use turbopack_core::{\n     chunk::{ChunkGroupResult, ChunkingContext, availability_info::AvailabilityInfo},\n     module::Module,\n     module_graph::{ModuleGraph, chunk_group_info::ChunkGroup},\n-    output::{OutputAssets, OutputAssetsWithReferenced},\n+    output::OutputAssetsWithReferenced,\n };\n \n use crate::{\n@@ -22,10 +22,12 @@ use crate::{\n \n #[turbo_tasks::value]\n pub struct ClientReferencesChunks {\n-    pub client_component_client_chunks: FxIndexMap<ClientReferenceType, ChunkGroupResult>,\n-    pub client_component_ssr_chunks: FxIndexMap<ClientReferenceType, ChunkGroupResult>,\n+    pub client_component_client_chunks:\n+        FxIndexMap<ClientReferenceType, ResolvedVc<ChunkGroupResult>>,\n+    pub client_component_ssr_chunks:\n+        FxIndexMap<ClientReferenceType, ResolvedVc<OutputAssetsWithReferenced>>,\n     pub layout_segment_client_chunks:\n-        FxIndexMap<ResolvedVc<NextServerComponentModule>, OutputAssetsWithReferenced>,\n+        FxIndexMap<ResolvedVc<NextServerComponentModule>, ResolvedVc<OutputAssetsWithReferenced>>,\n }\n \n /// Computes all client references chunks.\n@@ -156,12 +158,14 @@ pub async fn get_app_client_references_chunks(\n \n             let chunk_group_info = module_graph.chunk_group_info();\n \n-            let mut current_client_availability_info = client_availability_info;\n-            let mut current_client_chunks = OutputAssets::empty().to_resolved().await?;\n-            let mut current_client_referenced_assets = OutputAssets::empty().to_resolved().await?;\n-            let mut current_ssr_availability_info = AvailabilityInfo::Root;\n-            let mut current_ssr_chunks = OutputAssets::empty().to_resolved().await?;\n-            let mut current_ssr_referenced_assets = OutputAssets::empty().to_resolved().await?;\n+            let mut current_client_chunk_group = ChunkGroupResult {\n+                assets: ResolvedVc::cell(vec![]),\n+                referenced_assets: ResolvedVc::cell(vec![]),\n+                references: ResolvedVc::cell(vec![]),\n+                availability_info: client_availability_info,\n+            }\n+            .resolved_cell();\n+            let mut current_ssr_chunk_group = ChunkGroupResult::empty_resolved();\n \n             let mut layout_segment_client_chunks = FxIndexMap::default();\n             let mut client_component_ssr_chunks = FxIndexMap::default();\n@@ -202,25 +206,26 @@ pub async fn get_app_client_references_chunks(\n                     .try_flat_join()\n                     .await?;\n \n-                let ssr_chunk_group = if !ssr_modules.is_empty() {\n-                    ssr_chunking_context.map(|ssr_chunking_context| {\n-                        let _span = tracing::info_span!(\n-                            \"server side rendering\",\n-                            layout_segment = display(&server_component_path),\n-                        )\n-                        .entered();\n+                let ssr_chunk_group = if !ssr_modules.is_empty()\n+                    && let Some(ssr_chunking_context) = ssr_chunking_context\n+                {\n+                    let availability_info = current_ssr_chunk_group.await?.availability_info;\n+                    let _span = tracing::info_span!(\n+                        \"server side rendering\",\n+                        layout_segment = display(&server_component_path),\n+                    )\n+                    .entered();\n \n-                        ssr_chunking_context.chunk_group(\n-                            base_ident.with_modifier(rcstr!(\"ssr modules\")),\n-                            ChunkGroup::IsolatedMerged {\n-                                parent: parent_chunk_group,\n-                                merge_tag: ecmascript_client_reference_merge_tag_ssr(),\n-                                entries: ssr_modules,\n-                            },\n-                            module_graph,\n-                            current_ssr_availability_info,\n-                        )\n-                    })\n+                    Some(ssr_chunking_context.chunk_group(\n+                        base_ident.with_modifier(rcstr!(\"ssr modules\")),\n+                        ChunkGroup::IsolatedMerged {\n+                            parent: parent_chunk_group,\n+                            merge_tag: ecmascript_client_reference_merge_tag_ssr(),\n+                            entries: ssr_modules,\n+                        },\n+                        module_graph,\n+                        availability_info,\n+                    ))\n                 } else {\n                     None\n                 };\n@@ -242,6 +247,7 @@ pub async fn get_app_client_references_chunks(\n                     .try_join()\n                     .await?;\n                 let client_chunk_group = if !client_modules.is_empty() {\n+                    let availability_info = current_client_chunk_group.await?.availability_info;\n                     let _span = tracing::info_span!(\n                         \"client side rendering\",\n                         layout_segment = display(&server_component_path),\n@@ -256,88 +262,57 @@ pub async fn get_app_client_references_chunks(\n                             entries: client_modules,\n                         },\n                         module_graph,\n-                        current_client_availability_info,\n+                        availability_info,\n                     ))\n                 } else {\n                     None\n                 };\n \n                 if let Some(client_chunk_group) = client_chunk_group {\n-                    let ChunkGroupResult {\n-                        assets,\n-                        referenced_assets,\n-                        availability_info,\n-                    } = *client_chunk_group.await?;\n-\n-                    let client_chunks = current_client_chunks\n-                        .concatenate(*assets)\n-                        .to_resolved()\n-                        .await?;\n-                    let client_referenced_assets = current_client_referenced_assets\n-                        .concatenate(*referenced_assets)\n+                    let client_chunk_group = current_client_chunk_group\n+                        .concatenate(client_chunk_group)\n                         .to_resolved()\n                         .await?;\n \n                     if is_layout {\n-                        current_client_availability_info = availability_info;\n-                        current_client_chunks = client_chunks;\n-                        current_client_referenced_assets = client_referenced_assets;\n+                        current_client_chunk_group = client_chunk_group;\n                     }\n \n-                    layout_segment_client_chunks.insert(\n-                        server_component,\n-                        OutputAssetsWithReferenced {\n-                            assets: client_chunks,\n-                            referenced_assets: client_referenced_assets,\n-                        },\n-                    );\n+                    let assets = client_chunk_group\n+                        .output_assets_with_referenced()\n+                        .to_resolved()\n+                        .await?;\n+                    layout_segment_client_chunks.insert(server_component, assets);\n \n                     for &client_reference_ty in client_reference_types.iter() {\n                         if let ClientReferenceType::EcmascriptClientReference(_) =\n                             client_reference_ty\n                         {\n-                            client_component_client_chunks.insert(\n-                                client_reference_ty,\n-                                ChunkGroupResult {\n-                                    assets: client_chunks,\n-                                    referenced_assets: client_referenced_assets,\n-                                    availability_info,\n-                                },\n-                            );\n+                            client_component_client_chunks\n+                                .insert(client_reference_ty, client_chunk_group);\n                         }\n                     }\n                 }\n \n                 if let Some(ssr_chunk_group) = ssr_chunk_group {\n-                    let ssr_chunk_group = ssr_chunk_group.await?;\n-\n-                    let ssr_chunks = current_ssr_chunks\n-                        .concatenate(*ssr_chunk_group.assets)\n-                        .to_resolved()\n-                        .await?;\n-                    let ssr_referenced_assets = current_ssr_referenced_assets\n-                        .concatenate(*ssr_chunk_group.referenced_assets)\n+                    let ssr_chunk_group = current_ssr_chunk_group\n+                        .concatenate(ssr_chunk_group)\n                         .to_resolved()\n                         .await?;\n \n                     if is_layout {\n-                        current_ssr_availability_info = ssr_chunk_group.availability_info;\n-                        current_ssr_chunks = ssr_chunks;\n-                        current_ssr_referenced_assets = ssr_referenced_assets;\n+                        current_ssr_chunk_group = ssr_chunk_group;\n                     }\n \n+                    let assets = ssr_chunk_group\n+                        .output_assets_with_referenced()\n+                        .to_resolved()\n+                        .await?;\n                     for &client_reference_ty in client_reference_types.iter() {\n                         if let ClientReferenceType::EcmascriptClientReference(_) =\n                             client_reference_ty\n                         {\n-                            client_component_ssr_chunks.insert(\n-                                client_reference_ty,\n-                                ChunkGroupResult {\n-                                    assets: ssr_chunks,\n-                                    referenced_assets: ssr_referenced_assets,\n-                                    availability_info: ssr_chunk_group.availability_info,\n-                                },\n-                            );\n+                            client_component_ssr_chunks.insert(client_reference_ty, assets);\n                         }\n                     }\n                 }"
        },
        {
            "sha": "e369ab4d005c41013a733c7bfd3928ca17d95967",
            "filename": "crates/next-core/src/next_app/app_client_shared_chunks.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 7,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fapp_client_shared_chunks.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fapp_client_shared_chunks.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fapp_client_shared_chunks.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -7,7 +7,6 @@ use turbopack_core::{\n     },\n     ident::AssetIdent,\n     module_graph::{ModuleGraph, chunk_group_info::ChunkGroup},\n-    output::OutputAssets,\n };\n \n #[turbo_tasks::function]\n@@ -18,12 +17,7 @@ pub async fn get_app_client_shared_chunk_group(\n     client_chunking_context: Vc<Box<dyn ChunkingContext>>,\n ) -> Result<Vc<ChunkGroupResult>> {\n     if app_client_runtime_entries.await?.is_empty() {\n-        return Ok(ChunkGroupResult {\n-            assets: OutputAssets::empty().to_resolved().await?,\n-            referenced_assets: OutputAssets::empty().to_resolved().await?,\n-            availability_info: AvailabilityInfo::Root,\n-        }\n-        .cell());\n+        return Ok(ChunkGroupResult::empty());\n     }\n \n     let span = tracing::trace_span!(\"app client shared\");"
        },
        {
            "sha": "68d460a3510bb1285448bddd597fb1a6bf1d6c51",
            "filename": "crates/next-core/src/next_client_reference/ecmascript_client_reference/ecmascript_client_reference_module.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-core%2Fsrc%2Fnext_client_reference%2Fecmascript_client_reference%2Fecmascript_client_reference_module.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-core%2Fsrc%2Fnext_client_reference%2Fecmascript_client_reference%2Fecmascript_client_reference_module.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_client_reference%2Fecmascript_client_reference%2Fecmascript_client_reference_module.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -16,6 +16,7 @@ use turbopack_core::{\n     ident::AssetIdent,\n     module::Module,\n     module_graph::{ModuleGraph, export_usage::ModuleExportUsageInfo},\n+    output::OutputAssetsReference,\n     reference::{ModuleReference, ModuleReferences},\n     reference_type::ReferenceType,\n     resolve::ModuleResolveResult,\n@@ -291,6 +292,9 @@ struct EcmascriptClientReferenceProxyChunkItem {\n     chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n }\n \n+#[turbo_tasks::value_impl]\n+impl OutputAssetsReference for EcmascriptClientReferenceProxyChunkItem {}\n+\n #[turbo_tasks::value_impl]\n impl ChunkItem for EcmascriptClientReferenceProxyChunkItem {\n     #[turbo_tasks::function]"
        },
        {
            "sha": "76eea6d7612c7edfb0ddd7996279b739a85584c3",
            "filename": "crates/next-core/src/next_dynamic/dynamic_module.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-core%2Fsrc%2Fnext_dynamic%2Fdynamic_module.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-core%2Fsrc%2Fnext_dynamic%2Fdynamic_module.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_dynamic%2Fdynamic_module.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -10,6 +10,7 @@ use turbopack_core::{\n     ident::AssetIdent,\n     module::Module,\n     module_graph::ModuleGraph,\n+    output::OutputAssetsReference,\n     reference::{ModuleReferences, SingleChunkableModuleReference},\n     resolve::ExportUsage,\n };\n@@ -131,6 +132,9 @@ struct NextDynamicEntryChunkItem {\n     inner: ResolvedVc<NextDynamicEntryModule>,\n }\n \n+#[turbo_tasks::value_impl]\n+impl OutputAssetsReference for NextDynamicEntryChunkItem {}\n+\n #[turbo_tasks::value_impl]\n impl EcmascriptChunkItem for NextDynamicEntryChunkItem {\n     #[turbo_tasks::function]"
        },
        {
            "sha": "326263d9ef164cf7b93b4b4beefb139926b51edc",
            "filename": "crates/next-core/src/next_manifests/client_reference_manifest.rs",
            "status": "modified",
            "additions": 21,
            "deletions": 32,
            "changes": 53,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-core%2Fsrc%2Fnext_manifests%2Fclient_reference_manifest.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-core%2Fsrc%2Fnext_manifests%2Fclient_reference_manifest.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_manifests%2Fclient_reference_manifest.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -12,11 +12,9 @@ use turbo_tasks::{\n use turbo_tasks_fs::{File, FileSystemPath};\n use turbopack_core::{\n     asset::{Asset, AssetContent},\n-    chunk::{\n-        ChunkGroupResult, ChunkingContext, ModuleChunkItemIdExt, ModuleId as TurbopackModuleId,\n-    },\n+    chunk::{ChunkingContext, ModuleChunkItemIdExt, ModuleId as TurbopackModuleId},\n     module_graph::async_module_info::AsyncModulesInfo,\n-    output::{OutputAsset, OutputAssets, OutputAssetsWithReferenced},\n+    output::{OutputAsset, OutputAssets, OutputAssetsReference, OutputAssetsWithReferenced},\n };\n use turbopack_ecmascript::utils::StringifyJs;\n \n@@ -107,6 +105,16 @@ pub struct ClientReferenceManifest {\n     pub mode: NextMode,\n }\n \n+#[turbo_tasks::value_impl]\n+impl OutputAssetsReference for ClientReferenceManifest {\n+    #[turbo_tasks::function]\n+    async fn references(self: Vc<Self>) -> Result<Vc<OutputAssetsWithReferenced>> {\n+        Ok(OutputAssetsWithReferenced::from_assets(\n+            *build_manifest(self).await?.references,\n+        ))\n+    }\n+}\n+\n #[turbo_tasks::value_impl]\n impl OutputAsset for ClientReferenceManifest {\n     #[turbo_tasks::function]\n@@ -119,11 +127,6 @@ impl OutputAsset for ClientReferenceManifest {\n             ))?\n             .cell())\n     }\n-\n-    #[turbo_tasks::function]\n-    async fn references(self: Vc<Self>) -> Result<Vc<OutputAssets>> {\n-        Ok(*build_manifest(self).await?.references)\n-    }\n }\n \n #[turbo_tasks::value_impl]\n@@ -253,15 +256,11 @@ async fn build_manifest(\n                 .chunk_item_id(**client_chunking_context)\n                 .await?;\n \n-            let (client_chunks_paths, client_is_async) = if let Some(ChunkGroupResult {\n-                assets: client_chunks,\n-                referenced_assets: client_referenced_assets,\n-                availability_info: _,\n-            }) =\n+            let (client_chunks_paths, client_is_async) = if let Some(client_assets) =\n                 client_component_client_chunks.get(&app_client_reference_ty)\n             {\n-                let client_chunks = client_chunks.await?;\n-                let client_referenced_assets = client_referenced_assets.await?;\n+                let client_chunks = client_assets.primary_assets().await?;\n+                let client_referenced_assets = client_assets.referenced_assets().await?;\n                 references.extend(client_chunks.iter());\n                 references.extend(client_referenced_assets.iter());\n \n@@ -310,14 +309,11 @@ async fn build_manifest(\n                     // edge runtime doesn't support dynamically\n                     // loading chunks.\n                     (Vec::new(), false)\n-                } else if let Some(ChunkGroupResult {\n-                    assets: ssr_chunks,\n-                    referenced_assets: ssr_referenced_assets,\n-                    availability_info: _,\n-                }) = client_component_ssr_chunks.get(&app_client_reference_ty)\n+                } else if let Some(ssr_assets) =\n+                    client_component_ssr_chunks.get(&app_client_reference_ty)\n                 {\n-                    let ssr_chunks = ssr_chunks.await?;\n-                    let ssr_referenced_assets = ssr_referenced_assets.await?;\n+                    let ssr_chunks = ssr_assets.primary_assets().await?;\n+                    let ssr_referenced_assets = ssr_assets.referenced_assets().await?;\n                     references.extend(ssr_chunks.iter());\n                     references.extend(ssr_referenced_assets.iter());\n \n@@ -405,14 +401,7 @@ async fn build_manifest(\n         }\n \n         // per layout segment chunks need to be emitted into the manifest too\n-        for (\n-            server_component,\n-            OutputAssetsWithReferenced {\n-                assets: client_chunks,\n-                referenced_assets: _,\n-            },\n-        ) in layout_segment_client_chunks.iter()\n-        {\n+        for (server_component, client_assets) in layout_segment_client_chunks.iter() {\n             let server_component_name = server_component\n                 .server_path()\n                 .await?\n@@ -429,7 +418,7 @@ async fn build_manifest(\n                 .entry(server_component_name)\n                 .or_default();\n \n-            let client_chunks = &client_chunks.await?;\n+            let client_chunks = client_assets.primary_assets().await?;\n             let client_chunks_with_path =\n                 cached_chunk_paths(&mut client_chunk_path_cache, client_chunks.iter().copied())\n                     .await?;"
        },
        {
            "sha": "c7e48d03bd87efcf7cdfbd3b24ef73e6a9bce2ba",
            "filename": "crates/next-core/src/next_manifests/mod.rs",
            "status": "modified",
            "additions": 23,
            "deletions": 15,
            "changes": 38,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-core%2Fsrc%2Fnext_manifests%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-core%2Fsrc%2Fnext_manifests%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_manifests%2Fmod.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -13,7 +13,7 @@ use turbo_tasks::{\n use turbo_tasks_fs::{File, FileSystemPath};\n use turbopack_core::{\n     asset::{Asset, AssetContent},\n-    output::{OutputAsset, OutputAssets},\n+    output::{OutputAsset, OutputAssets, OutputAssetsReference, OutputAssetsWithReferenced},\n };\n \n use crate::next_config::RouteHas;\n@@ -36,14 +36,9 @@ pub struct BuildManifest {\n }\n \n #[turbo_tasks::value_impl]\n-impl OutputAsset for BuildManifest {\n-    #[turbo_tasks::function]\n-    async fn path(&self) -> Vc<FileSystemPath> {\n-        self.output_path.clone().cell()\n-    }\n-\n+impl OutputAssetsReference for BuildManifest {\n     #[turbo_tasks::function]\n-    async fn references(&self) -> Result<Vc<OutputAssets>> {\n+    async fn references(&self) -> Result<Vc<OutputAssetsWithReferenced>> {\n         let chunks: Vec<ReadRef<OutputAssets>> = self.pages.values().try_join().await?;\n \n         let root_main_files = self\n@@ -61,7 +56,17 @@ impl OutputAsset for BuildManifest {\n             .chain(self.polyfill_files.iter().copied())\n             .collect();\n \n-        Ok(Vc::cell(references))\n+        Ok(OutputAssetsWithReferenced::from_assets(Vc::cell(\n+            references,\n+        )))\n+    }\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl OutputAsset for BuildManifest {\n+    #[turbo_tasks::function]\n+    async fn path(&self) -> Vc<FileSystemPath> {\n+        self.output_path.clone().cell()\n     }\n }\n \n@@ -163,16 +168,19 @@ pub struct ClientBuildManifest {\n }\n \n #[turbo_tasks::value_impl]\n-impl OutputAsset for ClientBuildManifest {\n+impl OutputAssetsReference for ClientBuildManifest {\n     #[turbo_tasks::function]\n-    async fn path(&self) -> Vc<FileSystemPath> {\n-        self.output_path.clone().cell()\n+    async fn references(&self) -> Result<Vc<OutputAssetsWithReferenced>> {\n+        let chunks: Vec<ResolvedVc<Box<dyn OutputAsset>>> = self.pages.values().copied().collect();\n+        Ok(OutputAssetsWithReferenced::from_assets(Vc::cell(chunks)))\n     }\n+}\n \n+#[turbo_tasks::value_impl]\n+impl OutputAsset for ClientBuildManifest {\n     #[turbo_tasks::function]\n-    async fn references(&self) -> Result<Vc<OutputAssets>> {\n-        let chunks: Vec<ResolvedVc<Box<dyn OutputAsset>>> = self.pages.values().copied().collect();\n-        Ok(Vc::cell(chunks))\n+    async fn path(&self) -> Vc<FileSystemPath> {\n+        self.output_path.clone().cell()\n     }\n }\n "
        },
        {
            "sha": "2ef9071d177d158548218421abb679361c8f2cbf",
            "filename": "crates/next-core/src/next_server_component/server_component_module.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-core%2Fsrc%2Fnext_server_component%2Fserver_component_module.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-core%2Fsrc%2Fnext_server_component%2Fserver_component_module.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_server_component%2Fserver_component_module.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -11,6 +11,7 @@ use turbopack_core::{\n     ident::AssetIdent,\n     module::Module,\n     module_graph::ModuleGraph,\n+    output::OutputAssetsReference,\n     reference::ModuleReferences,\n };\n use turbopack_ecmascript::{\n@@ -124,6 +125,9 @@ struct NextServerComponentChunkItem {\n     inner: ResolvedVc<NextServerComponentModule>,\n }\n \n+#[turbo_tasks::value_impl]\n+impl OutputAssetsReference for NextServerComponentChunkItem {}\n+\n #[turbo_tasks::value_impl]\n impl EcmascriptChunkItem for NextServerComponentChunkItem {\n     #[turbo_tasks::function]"
        },
        {
            "sha": "3a4b4a971122391ee25c0931d497965415625c0b",
            "filename": "crates/next-core/src/next_server_utility/server_utility_module.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-core%2Fsrc%2Fnext_server_utility%2Fserver_utility_module.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-core%2Fsrc%2Fnext_server_utility%2Fserver_utility_module.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_server_utility%2Fserver_utility_module.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -11,6 +11,7 @@ use turbopack_core::{\n     ident::AssetIdent,\n     module::Module,\n     module_graph::ModuleGraph,\n+    output::OutputAssetsReference,\n     reference::ModuleReferences,\n };\n use turbopack_ecmascript::{\n@@ -124,6 +125,9 @@ struct NextServerComponentChunkItem {\n     inner: ResolvedVc<NextServerUtilityModule>,\n }\n \n+#[turbo_tasks::value_impl]\n+impl OutputAssetsReference for NextServerComponentChunkItem {}\n+\n #[turbo_tasks::value_impl]\n impl EcmascriptChunkItem for NextServerComponentChunkItem {\n     #[turbo_tasks::function]"
        },
        {
            "sha": "f7bdb18b8879e51654e870c2cf62216679906b3c",
            "filename": "crates/next-core/src/page_loader.rs",
            "status": "modified",
            "additions": 11,
            "deletions": 6,
            "changes": 17,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-core%2Fsrc%2Fpage_loader.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-core%2Fsrc%2Fpage_loader.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fpage_loader.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -12,7 +12,7 @@ use turbopack_core::{\n     context::AssetContext,\n     ident::AssetIdent,\n     module::Module,\n-    output::{OutputAsset, OutputAssets},\n+    output::{OutputAsset, OutputAssets, OutputAssetsReference, OutputAssetsWithReferenced},\n     proxied_asset::ProxiedAsset,\n     reference_type::{EntryReferenceSubType, ReferenceType},\n     source::Source,\n@@ -153,6 +153,16 @@ impl PageLoaderAsset {\n     }\n }\n \n+#[turbo_tasks::value_impl]\n+impl OutputAssetsReference for PageLoaderAsset {\n+    #[turbo_tasks::function]\n+    async fn references(self: Vc<Self>) -> Result<Vc<OutputAssetsWithReferenced>> {\n+        Ok(OutputAssetsWithReferenced::from_assets(\n+            *self.await?.page_chunks,\n+        ))\n+    }\n+}\n+\n #[turbo_tasks::value_impl]\n impl OutputAsset for PageLoaderAsset {\n     #[turbo_tasks::function]\n@@ -171,11 +181,6 @@ impl OutputAsset for PageLoaderAsset {\n                 .chunk_path(Some(Vc::upcast(self)), ident, None, rcstr!(\".js\")))\n         }\n     }\n-\n-    #[turbo_tasks::function]\n-    async fn references(self: Vc<Self>) -> Result<Vc<OutputAssets>> {\n-        Ok(*self.await?.page_chunks)\n-    }\n }\n \n #[turbo_tasks::value_impl]"
        },
        {
            "sha": "69f5f5f27138a70773151a4e66c2198e010ad83d",
            "filename": "crates/next-core/src/raw_ecmascript_module.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-core%2Fsrc%2Fraw_ecmascript_module.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/crates%2Fnext-core%2Fsrc%2Fraw_ecmascript_module.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fraw_ecmascript_module.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -20,6 +20,7 @@ use turbopack_core::{\n     ident::AssetIdent,\n     module::Module,\n     module_graph::ModuleGraph,\n+    output::OutputAssetsReference,\n     resolve::ModulePart,\n     source::Source,\n     source_map::GenerateSourceMap,\n@@ -138,6 +139,9 @@ struct RawEcmascriptChunkItem {\n     chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n }\n \n+#[turbo_tasks::value_impl]\n+impl OutputAssetsReference for RawEcmascriptChunkItem {}\n+\n #[turbo_tasks::value_impl]\n impl ChunkItem for RawEcmascriptChunkItem {\n     #[turbo_tasks::function]"
        },
        {
            "sha": "5455e200e88067f916f7fa3b42d6d657eef904d2",
            "filename": "turbopack/crates/turbo-tasks/src/vc/resolved.rs",
            "status": "modified",
            "additions": 16,
            "deletions": 0,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fvc%2Fresolved.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fvc%2Fresolved.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fvc%2Fresolved.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -221,6 +221,22 @@ where\n         }\n     }\n \n+    /// Upcasts the given `Vec<ResolvedVc<T>>` to a `Vec<ResolvedVc<K>>`.\n+    ///\n+    /// See also: [`Vc::upcast`].\n+    #[inline(always)]\n+    pub fn upcast_vec<K>(vec: Vec<Self>) -> Vec<ResolvedVc<K>>\n+    where\n+        T: UpcastStrict<K>,\n+        K: VcValueTrait + ?Sized,\n+    {\n+        debug_assert!(size_of::<ResolvedVc<T>>() == size_of::<ResolvedVc<K>>());\n+        debug_assert!(size_of::<Vec<ResolvedVc<T>>>() == size_of::<Vec<ResolvedVc<K>>>());\n+        let (ptr, len, capacity) = vec.into_raw_parts();\n+        // Safety: The memory layout of `ResolvedVc<T>` and `ResolvedVc<K>` is the same.\n+        unsafe { Vec::from_raw_parts(ptr as *mut ResolvedVc<K>, len, capacity) }\n+    }\n+\n     /// Cheaply converts a Vec of resolved Vcs to a Vec of Vcs.\n     pub fn deref_vec(vec: Vec<ResolvedVc<T>>) -> Vec<Vc<T>> {\n         debug_assert!(size_of::<ResolvedVc<T>>() == size_of::<Vc<T>>());"
        },
        {
            "sha": "53aa2c80c8b3a7a874cd8472016b6b340ab57de7",
            "filename": "turbopack/crates/turbopack-analyze/tests/split_chunk.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-analyze%2Ftests%2Fsplit_chunk.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-analyze%2Ftests%2Fsplit_chunk.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-analyze%2Ftests%2Fsplit_chunk.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -12,7 +12,7 @@ use turbopack_analyze::split_chunk::{ChunkPart, ChunkPartRange, split_output_ass\n use turbopack_core::{\n     asset::{Asset, AssetContent},\n     code_builder::{Code, CodeBuilder},\n-    output::OutputAsset,\n+    output::{OutputAsset, OutputAssetsReference},\n     source_map::{GenerateSourceMap, OptionStringifiedSourceMap},\n };\n \n@@ -102,6 +102,9 @@ struct TestAsset {\n     code: ResolvedVc<Code>,\n }\n \n+#[turbo_tasks::value_impl]\n+impl OutputAssetsReference for TestAsset {}\n+\n #[turbo_tasks::value_impl]\n impl OutputAsset for TestAsset {\n     #[turbo_tasks::function]"
        },
        {
            "sha": "adce03f365c3b5f5f148ac58d0358d476f4f72a9",
            "filename": "turbopack/crates/turbopack-browser/src/chunking_context.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fchunking_context.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fchunking_context.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fchunking_context.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -662,6 +662,7 @@ impl ChunkingContext for BrowserChunkingContext {\n             let MakeChunkGroupResult {\n                 chunks,\n                 referenced_output_assets,\n+                references,\n                 availability_info,\n             } = make_chunk_group(\n                 entries,\n@@ -705,6 +706,7 @@ impl ChunkingContext for BrowserChunkingContext {\n             Ok(ChunkGroupResult {\n                 assets: ResolvedVc::cell(assets),\n                 referenced_assets: ResolvedVc::cell(referenced_output_assets),\n+                references: ResolvedVc::cell(references),\n                 availability_info,\n             }\n             .cell())\n@@ -732,6 +734,7 @@ impl ChunkingContext for BrowserChunkingContext {\n             let MakeChunkGroupResult {\n                 chunks,\n                 referenced_output_assets,\n+                references,\n                 availability_info,\n             } = make_chunk_group(\n                 entries,\n@@ -792,6 +795,7 @@ impl ChunkingContext for BrowserChunkingContext {\n             Ok(ChunkGroupResult {\n                 assets: ResolvedVc::cell(assets),\n                 referenced_assets: ResolvedVc::cell(referenced_output_assets),\n+                references: ResolvedVc::cell(references),\n                 availability_info,\n             }\n             .cell())"
        },
        {
            "sha": "b3e69666543cbf803fcd1fd28bba37c7d5a95127",
            "filename": "turbopack/crates/turbopack-browser/src/ecmascript/chunk.rs",
            "status": "modified",
            "additions": 30,
            "deletions": 21,
            "changes": 51,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fecmascript%2Fchunk.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fecmascript%2Fchunk.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fecmascript%2Fchunk.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -7,7 +7,7 @@ use turbopack_core::{\n     chunk::{Chunk, ChunkingContext, OutputChunk, OutputChunkRuntimeInfo},\n     ident::AssetIdent,\n     introspect::{Introspectable, IntrospectableChildren},\n-    output::{OutputAsset, OutputAssets},\n+    output::{OutputAsset, OutputAssetsReference, OutputAssetsWithReferenced},\n     source_map::{GenerateSourceMap, OptionStringifiedSourceMap, SourceMapAsset},\n     version::VersionedContent,\n };\n@@ -95,6 +95,35 @@ impl EcmascriptBrowserChunk {\n     }\n }\n \n+#[turbo_tasks::value_impl]\n+impl OutputAssetsReference for EcmascriptBrowserChunk {\n+    #[turbo_tasks::function]\n+    async fn references(self: Vc<Self>) -> Result<Vc<OutputAssetsWithReferenced>> {\n+        let this = self.await?;\n+        let chunk_references = this.chunk.references().await?;\n+        let include_source_map = *this\n+            .chunking_context\n+            .reference_chunk_source_maps(Vc::upcast(self))\n+            .await?;\n+        let ref_assets = chunk_references.assets.await?;\n+        let mut assets =\n+            Vec::with_capacity(ref_assets.len() + if include_source_map { 1 } else { 0 });\n+\n+        assets.extend(ref_assets.iter().copied());\n+\n+        if include_source_map {\n+            assets.push(ResolvedVc::upcast(self.source_map().to_resolved().await?));\n+        }\n+\n+        Ok(OutputAssetsWithReferenced {\n+            assets: ResolvedVc::cell(assets),\n+            referenced_assets: chunk_references.referenced_assets,\n+            references: chunk_references.references,\n+        }\n+        .cell())\n+    }\n+}\n+\n #[turbo_tasks::value_impl]\n impl OutputAsset for EcmascriptBrowserChunk {\n     #[turbo_tasks::function]\n@@ -110,26 +139,6 @@ impl OutputAsset for EcmascriptBrowserChunk {\n     fn size_bytes(self: Vc<Self>) -> Vc<Option<u64>> {\n         self.own_content().content().len()\n     }\n-\n-    #[turbo_tasks::function]\n-    async fn references(self: Vc<Self>) -> Result<Vc<OutputAssets>> {\n-        let this = self.await?;\n-        let chunk_references = this.chunk.references().await?;\n-        let include_source_map = *this\n-            .chunking_context\n-            .reference_chunk_source_maps(Vc::upcast(self))\n-            .await?;\n-        let mut references =\n-            Vec::with_capacity(chunk_references.len() + if include_source_map { 1 } else { 0 });\n-\n-        references.extend(chunk_references.iter().copied());\n-\n-        if include_source_map {\n-            references.push(ResolvedVc::upcast(self.source_map().to_resolved().await?));\n-        }\n-\n-        Ok(Vc::cell(references))\n-    }\n }\n \n #[turbo_tasks::value_impl]"
        },
        {
            "sha": "d79d1e1ab470b693ff49d87d50819b61d88669a4",
            "filename": "turbopack/crates/turbopack-browser/src/ecmascript/evaluate/chunk.rs",
            "status": "modified",
            "additions": 21,
            "deletions": 16,
            "changes": 37,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fecmascript%2Fevaluate%2Fchunk.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fecmascript%2Fevaluate%2Fchunk.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fecmascript%2Fevaluate%2Fchunk.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -17,7 +17,7 @@ use turbopack_core::{\n     ident::AssetIdent,\n     module::Module,\n     module_graph::ModuleGraph,\n-    output::{OutputAsset, OutputAssets},\n+    output::{OutputAsset, OutputAssets, OutputAssetsReference, OutputAssetsWithReferenced},\n     source_map::{GenerateSourceMap, OptionStringifiedSourceMap, SourceMapAsset},\n };\n use turbopack_ecmascript::{\n@@ -243,21 +243,9 @@ impl ValueToString for EcmascriptBrowserEvaluateChunk {\n }\n \n #[turbo_tasks::value_impl]\n-impl OutputAsset for EcmascriptBrowserEvaluateChunk {\n-    #[turbo_tasks::function]\n-    async fn path(self: Vc<Self>) -> Result<Vc<FileSystemPath>> {\n-        let this = self.await?;\n-        let ident = self.ident_for_path();\n-        Ok(this.chunking_context.chunk_path(\n-            Some(Vc::upcast(self)),\n-            ident,\n-            Some(rcstr!(\"turbopack\")),\n-            rcstr!(\".js\"),\n-        ))\n-    }\n-\n+impl OutputAssetsReference for EcmascriptBrowserEvaluateChunk {\n     #[turbo_tasks::function]\n-    async fn references(self: Vc<Self>) -> Result<Vc<OutputAssets>> {\n+    async fn references(self: Vc<Self>) -> Result<Vc<OutputAssetsWithReferenced>> {\n         let this = self.await?;\n         let mut references = Vec::new();\n \n@@ -272,7 +260,24 @@ impl OutputAsset for EcmascriptBrowserEvaluateChunk {\n \n         references.extend(this.other_chunks.await?.iter().copied());\n \n-        Ok(Vc::cell(references))\n+        Ok(OutputAssetsWithReferenced::from_assets(Vc::cell(\n+            references,\n+        )))\n+    }\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl OutputAsset for EcmascriptBrowserEvaluateChunk {\n+    #[turbo_tasks::function]\n+    async fn path(self: Vc<Self>) -> Result<Vc<FileSystemPath>> {\n+        let this = self.await?;\n+        let ident = self.ident_for_path();\n+        Ok(this.chunking_context.chunk_path(\n+            Some(Vc::upcast(self)),\n+            ident,\n+            Some(rcstr!(\"turbopack\")),\n+            rcstr!(\".js\"),\n+        ))\n     }\n }\n "
        },
        {
            "sha": "ade85ada809a310ac89214a185e970921c296a13",
            "filename": "turbopack/crates/turbopack-browser/src/ecmascript/list/asset.rs",
            "status": "modified",
            "additions": 9,
            "deletions": 6,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fecmascript%2Flist%2Fasset.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fecmascript%2Flist%2Fasset.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fecmascript%2Flist%2Fasset.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -7,7 +7,7 @@ use turbopack_core::{\n     asset::{Asset, AssetContent},\n     chunk::{ChunkingContext, EvaluatableAssets},\n     ident::AssetIdent,\n-    output::{OutputAsset, OutputAssets},\n+    output::{OutputAsset, OutputAssets, OutputAssetsReference, OutputAssetsWithReferenced},\n     version::VersionedContent,\n };\n \n@@ -69,6 +69,14 @@ impl ValueToString for EcmascriptDevChunkList {\n     }\n }\n \n+#[turbo_tasks::value_impl]\n+impl OutputAssetsReference for EcmascriptDevChunkList {\n+    #[turbo_tasks::function]\n+    fn references(&self) -> Vc<OutputAssetsWithReferenced> {\n+        OutputAssetsWithReferenced::from_assets(*self.chunks)\n+    }\n+}\n+\n #[turbo_tasks::value_impl]\n impl OutputAsset for EcmascriptDevChunkList {\n     #[turbo_tasks::function]\n@@ -93,11 +101,6 @@ impl OutputAsset for EcmascriptDevChunkList {\n             .chunking_context\n             .chunk_path(Some(Vc::upcast(self)), ident, None, rcstr!(\".js\")))\n     }\n-\n-    #[turbo_tasks::function]\n-    fn references(&self) -> Vc<OutputAssets> {\n-        *self.chunks\n-    }\n }\n \n #[turbo_tasks::value_impl]"
        },
        {
            "sha": "28115e4df451f317b19c0c961621b1c899c251ce",
            "filename": "turbopack/crates/turbopack-cli/src/build/mod.rs",
            "status": "modified",
            "additions": 19,
            "deletions": 37,
            "changes": 56,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fbuild%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fbuild%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fbuild%2Fmod.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -37,7 +37,6 @@ use turbopack_core::{\n         export_usage::compute_export_usage_info,\n     },\n     output::{OutputAsset, OutputAssets, OutputAssetsWithReferenced},\n-    reference::all_assets_from_entries,\n     reference_type::{EntryReferenceSubType, ReferenceType},\n     resolve::{\n         origin::{PlainResolveOrigin, ResolveOriginExt},\n@@ -433,29 +432,20 @@ async fn build_internal(\n                         ResolvedVc::try_sidecast::<Box<dyn EvaluatableAsset>>(entry_module)\n                     {\n                         match target {\n-                            Target::Browser => {\n-                                *chunking_context\n-                                    .evaluated_chunk_group_assets(\n-                                        AssetIdent::from_path(\n-                                            build_output_root\n-                                                .join(\n-                                                    ecmascript\n-                                                        .ident()\n-                                                        .path()\n-                                                        .await?\n-                                                        .file_stem()\n-                                                        .unwrap(),\n-                                                )?\n-                                                .with_extension(\"entry.js\"),\n-                                        ),\n-                                        ChunkGroup::Entry(\n-                                            [ResolvedVc::upcast(ecmascript)].into_iter().collect(),\n-                                        ),\n-                                        module_graph,\n-                                        AvailabilityInfo::Root,\n-                                    )\n-                                    .await?\n-                            }\n+                            Target::Browser => chunking_context.evaluated_chunk_group_assets(\n+                                AssetIdent::from_path(\n+                                    build_output_root\n+                                        .join(\n+                                            ecmascript.ident().path().await?.file_stem().unwrap(),\n+                                        )?\n+                                        .with_extension(\"entry.js\"),\n+                                ),\n+                                ChunkGroup::Entry(\n+                                    [ResolvedVc::upcast(ecmascript)].into_iter().collect(),\n+                                ),\n+                                module_graph,\n+                                AvailabilityInfo::Root,\n+                            ),\n                             Target::Node => OutputAssetsWithReferenced {\n                                 assets: ResolvedVc::cell(vec![\n                                     chunking_context\n@@ -480,7 +470,9 @@ async fn build_internal(\n                                         .asset,\n                                 ]),\n                                 referenced_assets: ResolvedVc::cell(vec![]),\n-                            },\n+                                references: ResolvedVc::cell(vec![]),\n+                            }\n+                            .cell(),\n                         }\n                     } else {\n                         bail!(\n@@ -496,18 +488,8 @@ async fn build_internal(\n \n     let all_assets = async move {\n         let mut all_assets: FxHashSet<ResolvedVc<Box<dyn OutputAsset>>> = FxHashSet::default();\n-        for OutputAssetsWithReferenced {\n-            assets,\n-            referenced_assets,\n-        } in entry_chunk_groups\n-        {\n-            all_assets.extend(all_assets_from_entries(*assets).await?.into_iter().copied());\n-            all_assets.extend(\n-                all_assets_from_entries(*referenced_assets)\n-                    .await?\n-                    .into_iter()\n-                    .copied(),\n-            );\n+        for group in entry_chunk_groups {\n+            all_assets.extend(group.expand_all_assets().await?);\n         }\n         anyhow::Ok(all_assets)\n     }"
        },
        {
            "sha": "8d392c8cd6c22d3b8ea31bfb71628c4839404c04",
            "filename": "turbopack/crates/turbopack-core/src/changed.rs",
            "status": "modified",
            "additions": 10,
            "deletions": 19,
            "changes": 29,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchanged.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchanged.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchanged.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -1,22 +1,16 @@\n use anyhow::Result;\n use turbo_tasks::{\n     Completion, Completions, ResolvedVc, TryJoinIterExt, Vc,\n-    graph::{AdjacencyMap, GraphTraversal, NonDeterministic},\n+    graph::{AdjacencyMap, GraphTraversal},\n };\n \n use crate::{\n     asset::Asset,\n     module::Module,\n-    output::{OutputAsset, OutputAssets},\n+    output::{ExpandOutputAssetsInput, OutputAsset, OutputAssets, expand_output_assets},\n     reference::primary_referenced_modules,\n };\n \n-async fn get_referenced_output_assets(\n-    parent: ResolvedVc<Box<dyn OutputAsset>>,\n-) -> Result<impl Iterator<Item = ResolvedVc<Box<dyn OutputAsset>>> + Send> {\n-    Ok(parent.references().owned().await?.into_iter())\n-}\n-\n pub async fn get_referenced_modules(\n     parent: ResolvedVc<Box<dyn Module>>,\n ) -> Result<impl Iterator<Item = ResolvedVc<Box<dyn Module>>> + Send> {\n@@ -53,17 +47,14 @@ pub async fn any_content_changed_of_module(\n pub async fn any_content_changed_of_output_asset(\n     root: ResolvedVc<Box<dyn OutputAsset>>,\n ) -> Result<Vc<Completion>> {\n-    let completions = NonDeterministic::new()\n-        .skip_duplicates()\n-        .visit([root], get_referenced_output_assets)\n-        .await\n-        .completed()?\n-        .into_inner()\n-        .into_iter()\n-        .map(|m| content_changed(*ResolvedVc::upcast(m)))\n-        .map(|v| v.to_resolved())\n-        .try_join()\n-        .await?;\n+    let completions =\n+        expand_output_assets(std::iter::once(ExpandOutputAssetsInput::Asset(root)), true)\n+            .await?\n+            .into_iter()\n+            .map(|m| content_changed(*ResolvedVc::upcast(m)))\n+            .map(|v| v.to_resolved())\n+            .try_join()\n+            .await?;\n \n     Ok(Vc::<Completions>::cell(completions).completed())\n }"
        },
        {
            "sha": "fbedc78312f2910f5ebf1049b7e0be1390e96d3c",
            "filename": "turbopack/crates/turbopack-core/src/chunk/chunk_group.rs",
            "status": "modified",
            "additions": 15,
            "deletions": 20,
            "changes": 35,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fchunk_group.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fchunk_group.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fchunk_group.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -6,7 +6,7 @@ use turbo_rcstr::rcstr;\n use turbo_tasks::{FxIndexSet, ResolvedVc, TryFlatJoinIterExt, TryJoinIterExt, Vc};\n \n use super::{\n-    Chunk, ChunkGroupContent, ChunkItem, ChunkItemWithAsyncModuleInfo, ChunkingContext,\n+    Chunk, ChunkGroupContent, ChunkItemWithAsyncModuleInfo, ChunkingContext,\n     availability_info::AvailabilityInfo, chunking::make_chunks,\n };\n use crate::{\n@@ -25,14 +25,18 @@ use crate::{\n         },\n         module_batches::{BatchingConfig, ModuleBatchesGraphEdge},\n     },\n-    output::{OutputAsset, OutputAssets},\n+    output::{\n+        OutputAsset, OutputAssets, OutputAssetsReference, OutputAssetsReferences,\n+        OutputAssetsWithReferenced,\n+    },\n     reference::ModuleReference,\n     traced_asset::TracedAsset,\n };\n \n pub struct MakeChunkGroupResult {\n     pub chunks: Vec<ResolvedVc<Box<dyn Chunk>>>,\n     pub referenced_output_assets: Vec<ResolvedVc<Box<dyn OutputAsset>>>,\n+    pub references: Vec<ResolvedVc<Box<dyn OutputAssetsReference>>>,\n     pub availability_info: AvailabilityInfo,\n }\n \n@@ -123,14 +127,7 @@ pub async fn make_chunk_group(\n         })\n     });\n \n-    // And also add output assets referenced by async chunk loaders\n-    let async_loader_references = async_loaders\n-        .iter()\n-        .map(|&loader| loader.references())\n-        .try_join()\n-        .await?;\n-\n-    let mut referenced_output_assets = traced_modules\n+    let referenced_output_assets = traced_modules\n         .into_iter()\n         .map(|module| async move {\n             Ok(ResolvedVc::upcast(\n@@ -141,13 +138,6 @@ pub async fn make_chunk_group(\n         .await?;\n \n     chunk_items.extend(async_loader_chunk_items);\n-    referenced_output_assets.reserve(\n-        async_loader_references\n-            .iter()\n-            .map(|r| r.len())\n-            .sum::<usize>(),\n-    );\n-    referenced_output_assets.extend(async_loader_references.into_iter().flatten());\n \n     // Pass chunk items to chunking algorithm\n     let chunks = make_chunks(\n@@ -162,13 +152,14 @@ pub async fn make_chunk_group(\n     Ok(MakeChunkGroupResult {\n         chunks,\n         referenced_output_assets,\n+        references: ResolvedVc::upcast_vec(async_loaders),\n         availability_info,\n     })\n }\n \n pub async fn references_to_output_assets(\n     references: impl IntoIterator<Item = &ResolvedVc<Box<dyn ModuleReference>>>,\n-) -> Result<Vc<OutputAssets>> {\n+) -> Result<Vc<OutputAssetsWithReferenced>> {\n     let output_assets = references\n         .into_iter()\n         .map(|reference| reference.resolve_reference().primary_output_assets())\n@@ -180,9 +171,13 @@ pub async fn references_to_output_assets(\n         .flatten()\n         .copied()\n         .filter(|&asset| set.insert(asset))\n-        .map(|asset| *asset)\n         .collect::<Vec<_>>();\n-    Ok(OutputAssets::new(output_assets))\n+    Ok(OutputAssetsWithReferenced {\n+        assets: ResolvedVc::cell(output_assets),\n+        referenced_assets: OutputAssets::empty_resolved(),\n+        references: OutputAssetsReferences::empty_resolved(),\n+    }\n+    .cell())\n }\n \n pub async fn chunk_group_content("
        },
        {
            "sha": "2ab1e7052966ad617a778429655341ed27b44d09",
            "filename": "turbopack/crates/turbopack-core/src/chunk/chunking_context.rs",
            "status": "modified",
            "additions": 125,
            "deletions": 29,
            "changes": 154,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fchunking_context.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fchunking_context.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fchunking_context.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -17,7 +17,10 @@ use crate::{\n         ModuleGraph, chunk_group_info::ChunkGroup, export_usage::ModuleExportUsage,\n         module_batches::BatchingConfig,\n     },\n-    output::{OutputAsset, OutputAssets, OutputAssetsWithReferenced},\n+    output::{\n+        ExpandOutputAssetsInput, OutputAsset, OutputAssets, OutputAssetsReferences,\n+        OutputAssetsWithReferenced, expand_output_assets,\n+    },\n };\n \n #[derive(\n@@ -87,13 +90,121 @@ pub enum ChunkGroupType {\n }\n \n #[turbo_tasks::value(shared)]\n-#[derive(Clone, Copy)]\n+#[derive(Clone)]\n pub struct ChunkGroupResult {\n     pub assets: ResolvedVc<OutputAssets>,\n     pub referenced_assets: ResolvedVc<OutputAssets>,\n+    pub references: ResolvedVc<OutputAssetsReferences>,\n     pub availability_info: AvailabilityInfo,\n }\n \n+impl ChunkGroupResult {\n+    pub fn empty() -> Vc<Self> {\n+        ChunkGroupResult {\n+            assets: ResolvedVc::cell(vec![]),\n+            referenced_assets: ResolvedVc::cell(vec![]),\n+            references: ResolvedVc::cell(vec![]),\n+            availability_info: AvailabilityInfo::Root,\n+        }\n+        .cell()\n+    }\n+\n+    pub fn empty_resolved() -> ResolvedVc<Self> {\n+        ChunkGroupResult {\n+            assets: ResolvedVc::cell(vec![]),\n+            referenced_assets: ResolvedVc::cell(vec![]),\n+            references: ResolvedVc::cell(vec![]),\n+            availability_info: AvailabilityInfo::Root,\n+        }\n+        .resolved_cell()\n+    }\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl ChunkGroupResult {\n+    #[turbo_tasks::function]\n+    pub async fn output_assets_with_referenced(&self) -> Result<Vc<OutputAssetsWithReferenced>> {\n+        Ok(OutputAssetsWithReferenced {\n+            assets: self.assets,\n+            referenced_assets: self.referenced_assets,\n+            references: self.references,\n+        }\n+        .cell())\n+    }\n+\n+    #[turbo_tasks::function]\n+    pub async fn concatenate(&self, next: Vc<Self>) -> Result<Vc<Self>> {\n+        let next = next.await?;\n+        Ok(ChunkGroupResult {\n+            assets: self.assets.concatenate(*next.assets).to_resolved().await?,\n+            referenced_assets: self\n+                .referenced_assets\n+                .concatenate(*next.referenced_assets)\n+                .to_resolved()\n+                .await?,\n+            references: self\n+                .references\n+                .concatenate(*next.references)\n+                .to_resolved()\n+                .await?,\n+            availability_info: next.availability_info,\n+        }\n+        .cell())\n+    }\n+\n+    #[turbo_tasks::function]\n+    pub async fn all_assets(&self) -> Result<Vc<OutputAssets>> {\n+        Ok(Vc::cell(\n+            expand_output_assets(\n+                self.assets\n+                    .await?\n+                    .into_iter()\n+                    .chain(self.referenced_assets.await?.into_iter())\n+                    .copied()\n+                    .map(ExpandOutputAssetsInput::Asset)\n+                    .chain(\n+                        self.references\n+                            .await?\n+                            .into_iter()\n+                            .copied()\n+                            .map(ExpandOutputAssetsInput::Reference),\n+                    ),\n+                false,\n+            )\n+            .await?,\n+        ))\n+    }\n+\n+    /// Returns only primary asset entries. Doesn't expand OutputAssets. Doesn't return referenced\n+    /// assets.\n+    #[turbo_tasks::function]\n+    pub fn primary_assets(&self) -> Vc<OutputAssets> {\n+        *self.assets\n+    }\n+\n+    #[turbo_tasks::function]\n+    pub async fn referenced_assets(&self) -> Result<Vc<OutputAssets>> {\n+        Ok(Vc::cell(\n+            expand_output_assets(\n+                self.referenced_assets\n+                    .await?\n+                    .into_iter()\n+                    .copied()\n+                    .map(ExpandOutputAssetsInput::Asset)\n+                    .chain(\n+                        self.references\n+                            .await?\n+                            .into_iter()\n+                            .copied()\n+                            .map(ExpandOutputAssetsInput::Reference),\n+                    ),\n+                false,\n+            )\n+            .await?,\n+        ))\n+    }\n+}\n+\n #[turbo_tasks::value(shared)]\n pub struct EntryChunkGroupResult {\n     pub asset: ResolvedVc<Box<dyn OutputAsset>>,\n@@ -564,38 +675,28 @@ async fn relative_path_from_chunk_root_to_project_root(\n }\n \n #[turbo_tasks::function]\n-async fn root_chunk_group_assets(\n+fn root_chunk_group_assets(\n     chunking_context: Vc<Box<dyn ChunkingContext>>,\n     ident: Vc<AssetIdent>,\n     chunk_group: ChunkGroup,\n     module_graph: Vc<ModuleGraph>,\n-) -> Result<Vc<OutputAssetsWithReferenced>> {\n-    let root_chunk_group = chunking_context\n+) -> Vc<OutputAssetsWithReferenced> {\n+    chunking_context\n         .root_chunk_group(ident, chunk_group, module_graph)\n-        .await?;\n-    Ok(OutputAssetsWithReferenced {\n-        assets: root_chunk_group.assets,\n-        referenced_assets: root_chunk_group.referenced_assets,\n-    }\n-    .cell())\n+        .output_assets_with_referenced()\n }\n \n #[turbo_tasks::function]\n-async fn evaluated_chunk_group_assets(\n+fn evaluated_chunk_group_assets(\n     chunking_context: Vc<Box<dyn ChunkingContext>>,\n     ident: Vc<AssetIdent>,\n     chunk_group: ChunkGroup,\n     module_graph: Vc<ModuleGraph>,\n     availability_info: AvailabilityInfo,\n-) -> Result<Vc<OutputAssetsWithReferenced>> {\n-    let evaluated_chunk_group = chunking_context\n+) -> Vc<OutputAssetsWithReferenced> {\n+    chunking_context\n         .evaluated_chunk_group(ident, chunk_group, module_graph, availability_info)\n-        .await?;\n-    Ok(OutputAssetsWithReferenced {\n-        assets: evaluated_chunk_group.assets,\n-        referenced_assets: evaluated_chunk_group.referenced_assets,\n-    }\n-    .cell())\n+        .output_assets_with_referenced()\n }\n \n #[turbo_tasks::function]\n@@ -622,19 +723,14 @@ async fn entry_chunk_group_asset(\n }\n \n #[turbo_tasks::function]\n-async fn chunk_group_assets(\n+fn chunk_group_assets(\n     chunking_context: Vc<Box<dyn ChunkingContext>>,\n     ident: Vc<AssetIdent>,\n     chunk_group: ChunkGroup,\n     module_graph: Vc<ModuleGraph>,\n     availability_info: AvailabilityInfo,\n-) -> Result<Vc<OutputAssetsWithReferenced>> {\n-    let chunk_group = chunking_context\n+) -> Vc<OutputAssetsWithReferenced> {\n+    chunking_context\n         .chunk_group(ident, chunk_group, module_graph, availability_info)\n-        .await?;\n-    Ok(OutputAssetsWithReferenced {\n-        assets: chunk_group.assets,\n-        referenced_assets: chunk_group.referenced_assets,\n-    }\n-    .cell())\n+        .output_assets_with_referenced()\n }"
        },
        {
            "sha": "604d5cf7ac1608857ee1599ee043fcb9a69be074",
            "filename": "turbopack/crates/turbopack-core/src/chunk/mod.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 14,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fmod.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -44,7 +44,7 @@ use crate::{\n         ModuleGraph,\n         module_batch::{ChunkableModuleOrBatch, ModuleBatchGroup},\n     },\n-    output::OutputAssets,\n+    output::{OutputAssets, OutputAssetsReference},\n     reference::ModuleReference,\n     resolve::ExportUsage,\n };\n@@ -209,7 +209,7 @@ impl Chunks {\n /// It usually contains multiple chunk items.\n // TODO This could be simplified to and merged with [OutputChunk]\n #[turbo_tasks::value_trait]\n-pub trait Chunk {\n+pub trait Chunk: OutputAssetsReference {\n     #[turbo_tasks::function]\n     fn ident(self: Vc<Self>) -> Vc<AssetIdent>;\n     #[turbo_tasks::function]\n@@ -218,12 +218,6 @@ pub trait Chunk {\n     //     self.ident().path()\n     // }\n \n-    /// Other [OutputAsset]s referenced from this [Chunk].\n-    #[turbo_tasks::function]\n-    fn references(self: Vc<Self>) -> Vc<OutputAssets> {\n-        OutputAssets::empty()\n-    }\n-\n     #[turbo_tasks::function]\n     fn chunk_items(self: Vc<Self>) -> Vc<ChunkItems> {\n         ChunkItems(vec![]).cell()\n@@ -436,12 +430,13 @@ pub struct ChunkGroupContent {\n }\n \n #[turbo_tasks::value_trait]\n-pub trait ChunkItem {\n+pub trait ChunkItem: OutputAssetsReference {\n     /// The [AssetIdent] of the [Module] that this [ChunkItem] was created from.\n     /// For most chunk types this must uniquely identify the chunk item at\n     /// runtime as it's the source of the module id used at runtime.\n     #[turbo_tasks::function]\n     fn asset_ident(self: Vc<Self>) -> Vc<AssetIdent>;\n+\n     /// A [AssetIdent] that uniquely identifies the content of this [ChunkItem].\n     /// It is usually identical to [ChunkItem::asset_ident] but can be\n     /// different when the chunk item content depends on available modules e. g.\n@@ -450,11 +445,6 @@ pub trait ChunkItem {\n     fn content_ident(self: Vc<Self>) -> Vc<AssetIdent> {\n         self.asset_ident()\n     }\n-    /// A [ChunkItem] can reference OutputAssets, unlike [Module]s referencing other [Module]s.\n-    #[turbo_tasks::function]\n-    fn references(self: Vc<Self>) -> Vc<OutputAssets> {\n-        OutputAssets::empty()\n-    }\n \n     /// The type of chunk this item should be assembled into.\n     #[turbo_tasks::function]"
        },
        {
            "sha": "77160047612181bf15c4a2aafd26b8342d68306a",
            "filename": "turbopack/crates/turbopack-core/src/introspect/output_asset.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fintrospect%2Foutput_asset.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fintrospect%2Foutput_asset.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fintrospect%2Foutput_asset.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -6,7 +6,10 @@ use super::{\n     Introspectable, IntrospectableChildren,\n     utils::{children_from_output_assets, content_to_details},\n };\n-use crate::{asset::Asset, output::OutputAsset};\n+use crate::{\n+    asset::Asset,\n+    output::{OutputAsset, OutputAssetsReference},\n+};\n \n #[turbo_tasks::value]\n pub struct IntrospectableOutputAsset(ResolvedVc<Box<dyn OutputAsset>>);"
        },
        {
            "sha": "8ff7d93e005e2930b8a112219b9c43e8840e0107",
            "filename": "turbopack/crates/turbopack-core/src/introspect/utils.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fintrospect%2Futils.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fintrospect%2Futils.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fintrospect%2Futils.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -9,7 +9,7 @@ use super::{\n use crate::{\n     asset::AssetContent,\n     chunk::{ChunkableModuleReference, ChunkingType},\n-    output::OutputAssets,\n+    output::OutputAssetsWithReferenced,\n     reference::{ModuleReference, ModuleReferences},\n };\n \n@@ -121,11 +121,11 @@ pub async fn children_from_module_references(\n \n #[turbo_tasks::function]\n pub async fn children_from_output_assets(\n-    references: Vc<OutputAssets>,\n+    references: Vc<OutputAssetsWithReferenced>,\n ) -> Result<Vc<IntrospectableChildren>> {\n     let key = reference_ty();\n     let mut children = FxIndexSet::default();\n-    let references = references.await?;\n+    let references = references.expand_all_assets().await?;\n     for &reference in &*references {\n         children.insert((\n             key.clone(),"
        },
        {
            "sha": "8f7542f8d6cb91abf9c584a80b063582d868b6f5",
            "filename": "turbopack/crates/turbopack-core/src/output.rs",
            "status": "modified",
            "additions": 210,
            "deletions": 16,
            "changes": 226,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Foutput.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Foutput.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Foutput.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -1,17 +1,35 @@\n use anyhow::Result;\n+use either::Either;\n use turbo_rcstr::RcStr;\n-use turbo_tasks::{FxIndexSet, ResolvedVc, ValueToString, Vc};\n+use turbo_tasks::{\n+    FxIndexSet, ResolvedVc, ValueToString, Vc,\n+    graph::{AdjacencyMap, GraphTraversal},\n+};\n use turbo_tasks_fs::FileSystemPath;\n \n use crate::asset::Asset;\n \n #[turbo_tasks::value(transparent)]\n pub struct OptionOutputAsset(Option<ResolvedVc<Box<dyn OutputAsset>>>);\n \n+#[turbo_tasks::value_trait]\n+pub trait OutputAssetsReference {\n+    /// References to other [OutputAsset]s from this [OutputAssetReference].\n+    #[turbo_tasks::function]\n+    fn references(self: Vc<Self>) -> Vc<OutputAssetsWithReferenced> {\n+        OutputAssetsWithReferenced {\n+            assets: OutputAssets::empty_resolved(),\n+            referenced_assets: OutputAssets::empty_resolved(),\n+            references: OutputAssetsReferences::empty_resolved(),\n+        }\n+        .cell()\n+    }\n+}\n+\n /// An asset that should be outputted, e. g. written to disk or served from a\n /// server.\n #[turbo_tasks::value_trait]\n-pub trait OutputAsset: Asset {\n+pub trait OutputAsset: Asset + OutputAssetsReference {\n     /// The identifier of the [OutputAsset]. It's expected to be unique and\n     /// capture all properties of the [OutputAsset].\n     #[turbo_tasks::function]\n@@ -24,28 +42,39 @@ pub trait OutputAsset: Asset {\n         self.path().to_string()\n     }\n \n-    /// Other references [OutputAsset]s from this [OutputAsset].\n-    #[turbo_tasks::function]\n-    fn references(self: Vc<Self>) -> Vc<OutputAssets> {\n-        OutputAssets::empty()\n-    }\n-\n     #[turbo_tasks::function]\n     fn size_bytes(self: Vc<Self>) -> Vc<Option<u64>> {\n         Vc::cell(None)\n     }\n }\n \n #[turbo_tasks::value(transparent)]\n-pub struct OutputAssets(Vec<ResolvedVc<Box<dyn OutputAsset>>>);\n+pub struct OutputAssetsReferences(Vec<ResolvedVc<Box<dyn OutputAssetsReference>>>);\n \n #[turbo_tasks::value_impl]\n-impl OutputAssets {\n+impl OutputAssetsReferences {\n     #[turbo_tasks::function]\n-    pub fn new(assets: Vec<ResolvedVc<Box<dyn OutputAsset>>>) -> Vc<Self> {\n-        Vc::cell(assets)\n+    pub async fn concatenate(&self, other: Vc<Self>) -> Result<Vc<Self>> {\n+        let mut references: FxIndexSet<_> = self.0.iter().copied().collect();\n+        references.extend(other.await?.iter().copied());\n+        Ok(Vc::cell(references.into_iter().collect()))\n+    }\n+}\n+impl OutputAssetsReferences {\n+    pub fn empty() -> Vc<Self> {\n+        Vc::cell(vec![])\n     }\n \n+    pub fn empty_resolved() -> ResolvedVc<Self> {\n+        ResolvedVc::cell(vec![])\n+    }\n+}\n+\n+#[turbo_tasks::value(transparent)]\n+pub struct OutputAssets(Vec<ResolvedVc<Box<dyn OutputAsset>>>);\n+\n+#[turbo_tasks::value_impl]\n+impl OutputAssets {\n     #[turbo_tasks::function]\n     pub async fn concatenate(&self, other: Vc<Self>) -> Result<Vc<Self>> {\n         let mut assets: FxIndexSet<_> = self.0.iter().copied().collect();\n@@ -65,29 +94,194 @@ impl OutputAssets {\n \n impl OutputAssets {\n     pub fn empty() -> Vc<Self> {\n-        Self::new(vec![])\n+        Vc::cell(vec![])\n     }\n \n     pub fn empty_resolved() -> ResolvedVc<Self> {\n         ResolvedVc::cell(vec![])\n     }\n }\n \n+#[turbo_tasks::value(transparent)]\n+pub struct ExpandedOutputAssets(Vec<ResolvedVc<Box<dyn OutputAsset>>>);\n+\n /// A set of [OutputAsset]s\n #[turbo_tasks::value(transparent)]\n pub struct OutputAssetsSet(FxIndexSet<ResolvedVc<Box<dyn OutputAsset>>>);\n \n #[turbo_tasks::value(shared)]\n-#[derive(Clone, Copy)]\n+#[derive(Clone)]\n pub struct OutputAssetsWithReferenced {\n+    /// Primary output assets. These are e. g. the chunks needed for a chunk group.\n     pub assets: ResolvedVc<OutputAssets>,\n+    /// Secondary output assets that are referenced by the primary assets.\n     pub referenced_assets: ResolvedVc<OutputAssets>,\n+    /// Secondary output assets that are referenced by the primary assets. These are unresolved\n+    /// `OutputAssetsReference`s and need to be expanded to get the actual assets. These are e. g.\n+    /// async loaders that reference other chunk groups.\n+    pub references: ResolvedVc<OutputAssetsReferences>,\n+}\n+\n+impl OutputAssetsWithReferenced {\n+    async fn expand_assets(\n+        &self,\n+        inner_output_assets: bool,\n+    ) -> Result<Vec<ResolvedVc<Box<dyn OutputAsset>>>> {\n+        expand_output_assets(\n+            self.assets\n+                .await?\n+                .into_iter()\n+                .chain(self.referenced_assets.await?.into_iter())\n+                .map(|&asset| ExpandOutputAssetsInput::Asset(asset))\n+                .chain(\n+                    self.references\n+                        .await?\n+                        .into_iter()\n+                        .map(|&reference| ExpandOutputAssetsInput::Reference(reference)),\n+                ),\n+            inner_output_assets,\n+        )\n+        .await\n+    }\n }\n \n #[turbo_tasks::value_impl]\n impl OutputAssetsWithReferenced {\n     #[turbo_tasks::function]\n-    pub fn all_assets(&self) -> Vc<OutputAssets> {\n-        self.assets.concatenate(*self.referenced_assets)\n+    pub fn from_assets(assets: ResolvedVc<OutputAssets>) -> Vc<Self> {\n+        OutputAssetsWithReferenced {\n+            assets,\n+            referenced_assets: OutputAssets::empty_resolved(),\n+            references: OutputAssetsReferences::empty_resolved(),\n+        }\n+        .cell()\n+    }\n+\n+    #[turbo_tasks::function]\n+    pub async fn concatenate(&self, other: Vc<Self>) -> Result<Vc<Self>> {\n+        Ok(Self {\n+            assets: self\n+                .assets\n+                .concatenate(*other.await?.assets)\n+                .to_resolved()\n+                .await?,\n+            referenced_assets: self\n+                .referenced_assets\n+                .concatenate(*other.await?.referenced_assets)\n+                .to_resolved()\n+                .await?,\n+            references: self\n+                .references\n+                .concatenate(*other.await?.references)\n+                .to_resolved()\n+                .await?,\n+        }\n+        .cell())\n+    }\n+\n+    /// Returns all assets, including referenced assets and nested assets.\n+    #[turbo_tasks::function]\n+    pub async fn expand_all_assets(&self) -> Result<Vc<ExpandedOutputAssets>> {\n+        Ok(Vc::cell(self.expand_assets(true).await?))\n+    }\n+\n+    /// Returns only direct referenced assets and does not include assets referenced indirectly by\n+    /// them.\n+    #[turbo_tasks::function]\n+    pub async fn all_assets(&self) -> Result<Vc<OutputAssets>> {\n+        Ok(Vc::cell(self.expand_assets(false).await?))\n+    }\n+\n+    /// Returns only primary asset entries. Doesn't expand OutputAssets. Doesn't return referenced\n+    /// assets.\n+    #[turbo_tasks::function]\n+    pub fn primary_assets(&self) -> Vc<OutputAssets> {\n+        *self.assets\n+    }\n+\n+    /// Returns only secondary referenced asset entries. Doesn't expand OutputAssets. Doesn't return\n+    /// primary assets.\n+    #[turbo_tasks::function]\n+    pub async fn referenced_assets(&self) -> Result<Vc<OutputAssets>> {\n+        Ok(Vc::cell(\n+            expand_output_assets(\n+                self.referenced_assets\n+                    .await?\n+                    .into_iter()\n+                    .copied()\n+                    .map(ExpandOutputAssetsInput::Asset)\n+                    .chain(\n+                        self.references\n+                            .await?\n+                            .into_iter()\n+                            .copied()\n+                            .map(ExpandOutputAssetsInput::Reference),\n+                    ),\n+                false,\n+            )\n+            .await?,\n+        ))\n     }\n }\n+\n+/// Computes the list of all chunk children of a given chunk.\n+async fn get_referenced_assets(\n+    inner_output_assets: bool,\n+    input: ExpandOutputAssetsInput,\n+) -> Result<impl Iterator<Item = ExpandOutputAssetsInput>> {\n+    let refs = match input {\n+        ExpandOutputAssetsInput::Asset(output_asset) => {\n+            if !inner_output_assets {\n+                return Ok(Either::Left(std::iter::empty()));\n+            }\n+            output_asset.references().await?\n+        }\n+        ExpandOutputAssetsInput::Reference(reference) => reference.references().await?,\n+    };\n+    let assets = refs\n+        .assets\n+        .await?\n+        .into_iter()\n+        .chain(refs.referenced_assets.await?.into_iter())\n+        .map(|&asset| ExpandOutputAssetsInput::Asset(asset))\n+        .chain(\n+            refs.references\n+                .await?\n+                .into_iter()\n+                .map(|&reference| ExpandOutputAssetsInput::Reference(reference)),\n+        );\n+    Ok(Either::Right(assets))\n+}\n+\n+#[derive(PartialEq, Eq, Hash, Clone, Copy)]\n+pub enum ExpandOutputAssetsInput {\n+    Asset(ResolvedVc<Box<dyn OutputAsset>>),\n+    Reference(ResolvedVc<Box<dyn OutputAssetsReference>>),\n+}\n+\n+pub async fn expand_output_assets(\n+    inputs: impl Iterator<Item = ExpandOutputAssetsInput>,\n+    inner_output_assets: bool,\n+) -> Result<Vec<ResolvedVc<Box<dyn OutputAsset>>>> {\n+    let edges = AdjacencyMap::new()\n+        .skip_duplicates()\n+        .visit(inputs, async |input| {\n+            get_referenced_assets(inner_output_assets, input).await\n+        })\n+        .await\n+        .completed()?\n+        .into_inner()\n+        .into_postorder_topological();\n+\n+    let mut assets = Vec::new();\n+    for input in edges {\n+        match input {\n+            ExpandOutputAssetsInput::Asset(asset) => {\n+                assets.push(asset);\n+            }\n+            ExpandOutputAssetsInput::Reference(_) => {}\n+        }\n+    }\n+\n+    Ok(assets)\n+}"
        },
        {
            "sha": "d8f375945480a7db6fd37990c205e48dce943088",
            "filename": "turbopack/crates/turbopack-core/src/proxied_asset.rs",
            "status": "modified",
            "additions": 9,
            "deletions": 6,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fproxied_asset.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fproxied_asset.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fproxied_asset.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -3,7 +3,7 @@ use turbo_tasks_fs::FileSystemPath;\n \n use crate::{\n     asset::{Asset, AssetContent},\n-    output::{OutputAsset, OutputAssets},\n+    output::{OutputAsset, OutputAssetsReference, OutputAssetsWithReferenced},\n     version::VersionedContent,\n };\n \n@@ -28,15 +28,18 @@ impl ProxiedAsset {\n }\n \n #[turbo_tasks::value_impl]\n-impl OutputAsset for ProxiedAsset {\n+impl OutputAssetsReference for ProxiedAsset {\n     #[turbo_tasks::function]\n-    fn path(&self) -> Vc<FileSystemPath> {\n-        self.path.clone().cell()\n+    fn references(&self) -> Vc<OutputAssetsWithReferenced> {\n+        self.asset.references()\n     }\n+}\n \n+#[turbo_tasks::value_impl]\n+impl OutputAsset for ProxiedAsset {\n     #[turbo_tasks::function]\n-    fn references(&self) -> Vc<OutputAssets> {\n-        self.asset.references()\n+    fn path(&self) -> Vc<FileSystemPath> {\n+        self.path.clone().cell()\n     }\n }\n "
        },
        {
            "sha": "64ad680c42e9c51049d339a99d4b6205df757681",
            "filename": "turbopack/crates/turbopack-core/src/raw_output.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fraw_output.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fraw_output.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fraw_output.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -3,7 +3,7 @@ use turbo_tasks_fs::FileSystemPath;\n \n use crate::{\n     asset::{Asset, AssetContent},\n-    output::OutputAsset,\n+    output::{OutputAsset, OutputAssetsReference},\n     source::Source,\n };\n \n@@ -15,6 +15,9 @@ pub struct RawOutput {\n     source: ResolvedVc<Box<dyn Source>>,\n }\n \n+#[turbo_tasks::value_impl]\n+impl OutputAssetsReference for RawOutput {}\n+\n #[turbo_tasks::value_impl]\n impl OutputAsset for RawOutput {\n     #[turbo_tasks::function]"
        },
        {
            "sha": "13a676b529c47c8418b9dcdcc05619f9fb16728b",
            "filename": "turbopack/crates/turbopack-core/src/rebase.rs",
            "status": "modified",
            "additions": 18,
            "deletions": 13,
            "changes": 31,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Frebase.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Frebase.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Frebase.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -7,7 +7,7 @@ use turbo_tasks_fs::FileSystemPath;\n use crate::{\n     asset::{Asset, AssetContent},\n     module::Module,\n-    output::{OutputAsset, OutputAssets},\n+    output::{OutputAsset, OutputAssetsReference, OutputAssetsWithReferenced},\n     reference::referenced_modules_and_affecting_sources,\n };\n \n@@ -38,18 +38,9 @@ impl RebasedAsset {\n }\n \n #[turbo_tasks::value_impl]\n-impl OutputAsset for RebasedAsset {\n+impl OutputAssetsReference for RebasedAsset {\n     #[turbo_tasks::function]\n-    async fn path(&self) -> Result<Vc<FileSystemPath>> {\n-        Ok(FileSystemPath::rebase(\n-            self.module.ident().path().owned().await?,\n-            self.input_dir.clone(),\n-            self.output_dir.clone(),\n-        ))\n-    }\n-\n-    #[turbo_tasks::function]\n-    async fn references(&self) -> Result<Vc<OutputAssets>> {\n+    async fn references(&self) -> Result<Vc<OutputAssetsWithReferenced>> {\n         let references = referenced_modules_and_affecting_sources(*self.module)\n             .await?\n             .iter()\n@@ -62,7 +53,21 @@ impl OutputAsset for RebasedAsset {\n             })\n             .try_join()\n             .await?;\n-        Ok(Vc::cell(references))\n+        Ok(OutputAssetsWithReferenced::from_assets(Vc::cell(\n+            references,\n+        )))\n+    }\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl OutputAsset for RebasedAsset {\n+    #[turbo_tasks::function]\n+    async fn path(&self) -> Result<Vc<FileSystemPath>> {\n+        Ok(FileSystemPath::rebase(\n+            self.module.ident().path().owned().await?,\n+            self.input_dir.clone(),\n+            self.output_dir.clone(),\n+        ))\n     }\n }\n "
        },
        {
            "sha": "e8fa51bcf3ae14cfa8491936e3c155a0f73ef82f",
            "filename": "turbopack/crates/turbopack-core/src/reference/mod.rs",
            "status": "modified",
            "additions": 24,
            "deletions": 22,
            "changes": 46,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Freference%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Freference%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Freference%2Fmod.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -4,13 +4,15 @@ use anyhow::Result;\n use turbo_rcstr::RcStr;\n use turbo_tasks::{\n     FxIndexSet, ReadRef, ResolvedVc, TryFlatJoinIterExt, TryJoinIterExt, ValueToString, Vc,\n-    graph::{AdjacencyMap, GraphTraversal},\n };\n \n use crate::{\n     chunk::{ChunkableModuleReference, ChunkingType, ChunkingTypeOption},\n     module::{Module, Modules},\n-    output::{OutputAsset, OutputAssets},\n+    output::{\n+        ExpandOutputAssetsInput, ExpandedOutputAssets, OutputAsset, OutputAssets,\n+        expand_output_assets,\n+    },\n     raw_module::RawModule,\n     resolve::{ExportUsage, ModuleResolveResult, RequestKey},\n };\n@@ -331,28 +333,28 @@ pub async fn primary_chunkable_referenced_modules(\n /// Walks the asset graph from multiple assets and collect all referenced\n /// assets.\n #[turbo_tasks::function]\n-pub async fn all_assets_from_entries(entries: Vc<OutputAssets>) -> Result<Vc<OutputAssets>> {\n+pub async fn all_assets_from_entries(\n+    entries: Vc<OutputAssets>,\n+) -> Result<Vc<ExpandedOutputAssets>> {\n     Ok(Vc::cell(\n-        AdjacencyMap::new()\n-            .skip_duplicates()\n-            .visit(entries.await?.iter().copied(), get_referenced_assets)\n-            .await\n-            .completed()?\n-            .into_inner()\n-            .into_postorder_topological()\n-            .collect(),\n+        expand_output_assets(\n+            entries\n+                .await?\n+                .into_iter()\n+                .map(|&asset| ExpandOutputAssetsInput::Asset(asset)),\n+            true,\n+        )\n+        .await?,\n     ))\n }\n \n-/// Computes the list of all chunk children of a given chunk.\n-pub async fn get_referenced_assets(\n-    asset: ResolvedVc<Box<dyn OutputAsset>>,\n-) -> Result<impl Iterator<Item = ResolvedVc<Box<dyn OutputAsset>>> + Send> {\n-    Ok(asset\n-        .references()\n-        .await?\n-        .iter()\n-        .copied()\n-        .collect::<Vec<_>>()\n-        .into_iter())\n+/// Walks the asset graph from multiple assets and collect all referenced\n+/// assets.\n+#[turbo_tasks::function]\n+pub async fn all_assets_from_entry(\n+    entry: ResolvedVc<Box<dyn OutputAsset>>,\n+) -> Result<Vc<ExpandedOutputAssets>> {\n+    Ok(Vc::cell(\n+        expand_output_assets(std::iter::once(ExpandOutputAssetsInput::Asset(entry)), true).await?,\n+    ))\n }"
        },
        {
            "sha": "db0e18da26d19f585712f240ebd0cc7036edbab5",
            "filename": "turbopack/crates/turbopack-core/src/source_map/source_map_asset.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fsource_map%2Fsource_map_asset.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fsource_map%2Fsource_map_asset.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fsource_map%2Fsource_map_asset.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -12,7 +12,7 @@ use crate::{\n     chunk::ChunkingContext,\n     ident::AssetIdent,\n     introspect::{Introspectable, IntrospectableChildren},\n-    output::OutputAsset,\n+    output::{OutputAsset, OutputAssetsReference},\n     source_map::{GenerateSourceMap, SourceMap},\n };\n \n@@ -65,6 +65,9 @@ impl SourceMapAsset {\n     }\n }\n \n+#[turbo_tasks::value_impl]\n+impl OutputAssetsReference for SourceMapAsset {}\n+\n #[turbo_tasks::value_impl]\n impl OutputAsset for SourceMapAsset {\n     #[turbo_tasks::function]"
        },
        {
            "sha": "ec8e092fe8343b346b8914edc9804e5662c578d4",
            "filename": "turbopack/crates/turbopack-core/src/traced_asset.rs",
            "status": "modified",
            "additions": 14,
            "deletions": 9,
            "changes": 23,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Ftraced_asset.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Ftraced_asset.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Ftraced_asset.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -5,7 +5,7 @@ use turbo_tasks_fs::FileSystemPath;\n use crate::{\n     asset::{Asset, AssetContent},\n     module::Module,\n-    output::{OutputAsset, OutputAssets},\n+    output::{OutputAsset, OutputAssetsReference, OutputAssetsWithReferenced},\n     reference::referenced_modules_and_affecting_sources,\n };\n \n@@ -24,14 +24,9 @@ impl TracedAsset {\n }\n \n #[turbo_tasks::value_impl]\n-impl OutputAsset for TracedAsset {\n+impl OutputAssetsReference for TracedAsset {\n     #[turbo_tasks::function]\n-    fn path(&self) -> Vc<FileSystemPath> {\n-        self.module.ident().path()\n-    }\n-\n-    #[turbo_tasks::function]\n-    async fn references(&self) -> Result<Vc<OutputAssets>> {\n+    async fn references(&self) -> Result<Vc<OutputAssetsWithReferenced>> {\n         let references = referenced_modules_and_affecting_sources(*self.module)\n             .await?\n             .iter()\n@@ -42,7 +37,17 @@ impl OutputAsset for TracedAsset {\n             })\n             .try_join()\n             .await?;\n-        Ok(Vc::cell(references))\n+        Ok(OutputAssetsWithReferenced::from_assets(Vc::cell(\n+            references,\n+        )))\n+    }\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl OutputAsset for TracedAsset {\n+    #[turbo_tasks::function]\n+    fn path(&self) -> Vc<FileSystemPath> {\n+        self.module.ident().path()\n     }\n }\n "
        },
        {
            "sha": "c21fe0e7ef7483c5d02df88c053b119c0239acae",
            "filename": "turbopack/crates/turbopack-core/src/virtual_output.rs",
            "status": "modified",
            "additions": 9,
            "deletions": 6,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fvirtual_output.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fvirtual_output.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fvirtual_output.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -3,7 +3,7 @@ use turbo_tasks_fs::FileSystemPath;\n \n use crate::{\n     asset::{Asset, AssetContent},\n-    output::{OutputAsset, OutputAssets},\n+    output::{OutputAsset, OutputAssets, OutputAssetsReference, OutputAssetsWithReferenced},\n };\n \n /// An [OutputAsset] that is created from some passed source code and can have a list of references\n@@ -43,15 +43,18 @@ impl VirtualOutputAsset {\n }\n \n #[turbo_tasks::value_impl]\n-impl OutputAsset for VirtualOutputAsset {\n+impl OutputAssetsReference for VirtualOutputAsset {\n     #[turbo_tasks::function]\n-    fn path(&self) -> Vc<FileSystemPath> {\n-        self.path.clone().cell()\n+    fn references(&self) -> Vc<OutputAssetsWithReferenced> {\n+        OutputAssetsWithReferenced::from_assets(*self.references)\n     }\n+}\n \n+#[turbo_tasks::value_impl]\n+impl OutputAsset for VirtualOutputAsset {\n     #[turbo_tasks::function]\n-    fn references(&self) -> Vc<OutputAssets> {\n-        *self.references\n+    fn path(&self) -> Vc<FileSystemPath> {\n+        self.path.clone().cell()\n     }\n }\n "
        },
        {
            "sha": "426ccc5727ca1e37d6c3ea9f4aa0acbdbe02260c",
            "filename": "turbopack/crates/turbopack-css/src/asset.rs",
            "status": "modified",
            "additions": 22,
            "deletions": 17,
            "changes": 39,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fasset.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fasset.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fasset.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -10,7 +10,7 @@ use turbopack_core::{\n     ident::AssetIdent,\n     module::{Module, StyleModule, StyleType},\n     module_graph::ModuleGraph,\n-    output::OutputAssets,\n+    output::{OutputAssetsReference, OutputAssetsWithReferenced},\n     reference::{ModuleReference, ModuleReferences},\n     reference_type::ImportContext,\n     resolve::origin::ResolveOrigin,\n@@ -208,6 +208,27 @@ struct CssModuleChunkItem {\n     chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n }\n \n+#[turbo_tasks::value_impl]\n+impl OutputAssetsReference for CssModuleChunkItem {\n+    #[turbo_tasks::function]\n+    async fn references(&self) -> Result<Vc<OutputAssetsWithReferenced>> {\n+        let mut references = Vec::new();\n+        if let ParseCssResult::Ok { url_references, .. } = &*self.module.parse_css().await? {\n+            for (_, reference) in url_references.await? {\n+                if let ReferencedAsset::Some(asset) = *reference\n+                    .get_referenced_asset(*self.chunking_context)\n+                    .await?\n+                {\n+                    references.push(asset);\n+                }\n+            }\n+        }\n+        Ok(OutputAssetsWithReferenced::from_assets(Vc::cell(\n+            references,\n+        )))\n+    }\n+}\n+\n #[turbo_tasks::value_impl]\n impl ChunkItem for CssModuleChunkItem {\n     #[turbo_tasks::function]\n@@ -229,22 +250,6 @@ impl ChunkItem for CssModuleChunkItem {\n     fn module(&self) -> Vc<Box<dyn Module>> {\n         Vc::upcast(*self.module)\n     }\n-\n-    #[turbo_tasks::function]\n-    async fn references(&self) -> Result<Vc<OutputAssets>> {\n-        let mut references = Vec::new();\n-        if let ParseCssResult::Ok { url_references, .. } = &*self.module.parse_css().await? {\n-            for (_, reference) in url_references.await? {\n-                if let ReferencedAsset::Some(asset) = *reference\n-                    .get_referenced_asset(*self.chunking_context)\n-                    .await?\n-                {\n-                    references.push(asset);\n-                }\n-            }\n-        }\n-        Ok(Vc::cell(references))\n-    }\n }\n \n #[turbo_tasks::value_impl]"
        },
        {
            "sha": "2106f81b87a235b6de6eb695366bada073673d73",
            "filename": "turbopack/crates/turbopack-css/src/chunk/mod.rs",
            "status": "modified",
            "additions": 80,
            "deletions": 47,
            "changes": 127,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fmod.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -4,11 +4,8 @@ pub mod source_map;\n use std::fmt::Write;\n \n use anyhow::{Result, bail};\n-use swc_core::common::pass::Either;\n use turbo_rcstr::{RcStr, rcstr};\n-use turbo_tasks::{\n-    FxIndexSet, ResolvedVc, TryFlatJoinIterExt, TryJoinIterExt, ValueDefault, ValueToString, Vc,\n-};\n+use turbo_tasks::{FxIndexSet, ResolvedVc, TryJoinIterExt, ValueDefault, ValueToString, Vc};\n use turbo_tasks_fs::{\n     File, FileSystem, FileSystemPath,\n     rope::{Rope, RopeBuilder},\n@@ -29,7 +26,7 @@ use turbopack_core::{\n         utils::{children_from_output_assets, content_to_details},\n     },\n     module::Module,\n-    output::{OutputAsset, OutputAssets},\n+    output::{OutputAsset, OutputAssetsReference, OutputAssetsWithReferenced},\n     reference_type::ImportContext,\n     server_fs::ServerFileSystem,\n     source_map::{\n@@ -251,6 +248,82 @@ pub struct CssChunkContent {\n     pub chunk_items: Vec<ResolvedVc<Box<dyn CssChunkItem>>>,\n }\n \n+#[turbo_tasks::value_impl]\n+impl OutputAssetsReference for CssChunk {\n+    #[turbo_tasks::function]\n+    async fn references(self: Vc<Self>) -> Result<Vc<OutputAssetsWithReferenced>> {\n+        let this = self.await?;\n+        let content = this.content.await?;\n+        let should_generate_single_item_chunks = content.chunk_items.len() > 1\n+            && *this\n+                .chunking_context\n+                .is_dynamic_chunk_content_loading_enabled()\n+                .await?;\n+        let references = content\n+            .chunk_items\n+            .iter()\n+            .map(|item| async {\n+                let refs = item.references().await?;\n+                let single_css_chunk = if should_generate_single_item_chunks {\n+                    Some(ResolvedVc::upcast(\n+                        SingleItemCssChunk::new(*this.chunking_context, **item)\n+                            .to_resolved()\n+                            .await?,\n+                    ))\n+                } else {\n+                    None\n+                };\n+                Ok((\n+                    refs.assets.await?,\n+                    single_css_chunk,\n+                    refs.referenced_assets.await?,\n+                    refs.references.await?,\n+                ))\n+            })\n+            .try_join()\n+            .await?;\n+        let source_map = if *this\n+            .chunking_context\n+            .reference_chunk_source_maps(Vc::upcast(self))\n+            .await?\n+        {\n+            Some(ResolvedVc::upcast(\n+                CssChunkSourceMapAsset::new(self).to_resolved().await?,\n+            ))\n+        } else {\n+            None\n+        };\n+\n+        Ok(OutputAssetsWithReferenced {\n+            assets: ResolvedVc::cell(\n+                references\n+                    .iter()\n+                    .flat_map(|(assets, single_css_chunk, _, _)| {\n+                        assets\n+                            .iter()\n+                            .copied()\n+                            .chain(single_css_chunk.iter().copied())\n+                    })\n+                    .chain(source_map.into_iter())\n+                    .collect(),\n+            ),\n+            referenced_assets: ResolvedVc::cell(\n+                references\n+                    .iter()\n+                    .flat_map(|(_, _, referenced_assets, _)| referenced_assets.iter().copied())\n+                    .collect(),\n+            ),\n+            references: ResolvedVc::cell(\n+                references\n+                    .iter()\n+                    .flat_map(|(_, _, _, references)| references.iter().copied())\n+                    .collect(),\n+            ),\n+        }\n+        .cell())\n+    }\n+}\n+\n #[turbo_tasks::value_impl]\n impl Chunk for CssChunk {\n     #[turbo_tasks::function]\n@@ -344,46 +417,6 @@ impl OutputAsset for CssChunk {\n             rcstr!(\".css\"),\n         ))\n     }\n-\n-    #[turbo_tasks::function]\n-    async fn references(self: Vc<Self>) -> Result<Vc<OutputAssets>> {\n-        let this = self.await?;\n-        let content = this.content.await?;\n-        let should_generate_single_item_chunks = content.chunk_items.len() > 1\n-            && *this\n-                .chunking_context\n-                .is_dynamic_chunk_content_loading_enabled()\n-                .await?;\n-        let mut references = content\n-            .chunk_items\n-            .iter()\n-            .map(|item| async {\n-                let references = item.references().await?.into_iter().copied();\n-                Ok(if should_generate_single_item_chunks {\n-                    Either::Left(\n-                        references.chain(std::iter::once(ResolvedVc::upcast(\n-                            SingleItemCssChunk::new(*this.chunking_context, **item)\n-                                .to_resolved()\n-                                .await?,\n-                        ))),\n-                    )\n-                } else {\n-                    Either::Right(references)\n-                })\n-            })\n-            .try_flat_join()\n-            .await?;\n-        if *this\n-            .chunking_context\n-            .reference_chunk_source_maps(Vc::upcast(self))\n-            .await?\n-        {\n-            references.push(ResolvedVc::upcast(\n-                CssChunkSourceMapAsset::new(self).to_resolved().await?,\n-            ));\n-        }\n-        Ok(Vc::cell(references))\n-    }\n }\n \n #[turbo_tasks::value_impl]\n@@ -427,7 +460,7 @@ pub struct CssChunkItemContent {\n }\n \n #[turbo_tasks::value_trait]\n-pub trait CssChunkItem: ChunkItem {\n+pub trait CssChunkItem: ChunkItem + OutputAssetsReference {\n     #[turbo_tasks::function]\n     fn content(self: Vc<Self>) -> Vc<CssChunkItemContent>;\n }\n@@ -461,7 +494,7 @@ impl Introspectable for CssChunk {\n \n     #[turbo_tasks::function]\n     async fn children(self: Vc<Self>) -> Result<Vc<IntrospectableChildren>> {\n-        let mut children = children_from_output_assets(OutputAsset::references(self))\n+        let mut children = children_from_output_assets(OutputAssetsReference::references(self))\n             .owned()\n             .await?;\n         children.extend("
        },
        {
            "sha": "41e78aeea7be15c7dda86b0be29b89cf614c09d3",
            "filename": "turbopack/crates/turbopack-css/src/chunk/single_item_chunk/chunk.rs",
            "status": "modified",
            "additions": 24,
            "deletions": 19,
            "changes": 43,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fsingle_item_chunk%2Fchunk.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fsingle_item_chunk%2Fchunk.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fsingle_item_chunk%2Fchunk.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -10,7 +10,7 @@ use turbopack_core::{\n     code_builder::{Code, CodeBuilder},\n     ident::AssetIdent,\n     introspect::Introspectable,\n-    output::{OutputAsset, OutputAssets},\n+    output::{OutputAsset, OutputAssetsReference, OutputAssetsWithReferenced},\n     source_map::{GenerateSourceMap, OptionStringifiedSourceMap},\n };\n \n@@ -80,6 +80,29 @@ impl SingleItemCssChunk {\n     }\n }\n \n+#[turbo_tasks::value_impl]\n+impl OutputAssetsReference for SingleItemCssChunk {\n+    #[turbo_tasks::function]\n+    async fn references(self: Vc<Self>) -> Result<Vc<OutputAssetsWithReferenced>> {\n+        let this = self.await?;\n+        let mut references = Vec::new();\n+        if *this\n+            .chunking_context\n+            .reference_chunk_source_maps(Vc::upcast(self))\n+            .await?\n+        {\n+            references.push(ResolvedVc::upcast(\n+                SingleItemCssChunkSourceMapAsset::new(self)\n+                    .to_resolved()\n+                    .await?,\n+            ));\n+        }\n+        Ok(OutputAssetsWithReferenced::from_assets(Vc::cell(\n+            references,\n+        )))\n+    }\n+}\n+\n #[turbo_tasks::value_impl]\n impl Chunk for SingleItemCssChunk {\n     #[turbo_tasks::function]\n@@ -107,24 +130,6 @@ impl OutputAsset for SingleItemCssChunk {\n             rcstr!(\".single.css\"),\n         ))\n     }\n-\n-    #[turbo_tasks::function]\n-    async fn references(self: Vc<Self>) -> Result<Vc<OutputAssets>> {\n-        let this = self.await?;\n-        let mut references = Vec::new();\n-        if *this\n-            .chunking_context\n-            .reference_chunk_source_maps(Vc::upcast(self))\n-            .await?\n-        {\n-            references.push(ResolvedVc::upcast(\n-                SingleItemCssChunkSourceMapAsset::new(self)\n-                    .to_resolved()\n-                    .await?,\n-            ));\n-        }\n-        Ok(Vc::cell(references))\n-    }\n }\n \n #[turbo_tasks::value_impl]"
        },
        {
            "sha": "e3f98d6e53ccb46a046e9e2b45dc8bba9ad8f769",
            "filename": "turbopack/crates/turbopack-css/src/chunk/single_item_chunk/source_map.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fsingle_item_chunk%2Fsource_map.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fsingle_item_chunk%2Fsource_map.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fsingle_item_chunk%2Fsource_map.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -5,7 +5,7 @@ use turbo_tasks_fs::{File, FileSystemPath};\n use turbopack_core::{\n     asset::{Asset, AssetContent},\n     chunk::ChunkingContext,\n-    output::OutputAsset,\n+    output::{OutputAsset, OutputAssetsReference},\n     source_map::{GenerateSourceMap, SourceMap},\n };\n \n@@ -25,6 +25,9 @@ impl SingleItemCssChunkSourceMapAsset {\n     }\n }\n \n+#[turbo_tasks::value_impl]\n+impl OutputAssetsReference for SingleItemCssChunkSourceMapAsset {}\n+\n #[turbo_tasks::value_impl]\n impl OutputAsset for SingleItemCssChunkSourceMapAsset {\n     #[turbo_tasks::function]"
        },
        {
            "sha": "617305c35f8fef1c82e161bea38be50b8dee691b",
            "filename": "turbopack/crates/turbopack-css/src/chunk/source_map.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fsource_map.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fsource_map.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fsource_map.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -5,7 +5,7 @@ use turbo_tasks_fs::{File, FileSystemPath};\n use turbopack_core::{\n     asset::{Asset, AssetContent},\n     chunk::ChunkingContext,\n-    output::OutputAsset,\n+    output::{OutputAsset, OutputAssetsReference},\n     source_map::{GenerateSourceMap, SourceMap},\n };\n \n@@ -25,6 +25,9 @@ impl CssChunkSourceMapAsset {\n     }\n }\n \n+#[turbo_tasks::value_impl]\n+impl OutputAssetsReference for CssChunkSourceMapAsset {}\n+\n #[turbo_tasks::value_impl]\n impl OutputAsset for CssChunkSourceMapAsset {\n     #[turbo_tasks::function]"
        },
        {
            "sha": "3ddb531cd7b698c5a9d5a9dc31a3d212ca6ac54b",
            "filename": "turbopack/crates/turbopack-css/src/module_asset.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fmodule_asset.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fmodule_asset.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fmodule_asset.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -18,6 +18,7 @@ use turbopack_core::{\n     },\n     module::Module,\n     module_graph::ModuleGraph,\n+    output::OutputAssetsReference,\n     reference::{ModuleReference, ModuleReferences},\n     reference_type::{CssReferenceSubType, ReferenceType},\n     resolve::{origin::ResolveOrigin, parse::Request},\n@@ -287,6 +288,9 @@ struct ModuleChunkItem {\n     chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n }\n \n+#[turbo_tasks::value_impl]\n+impl OutputAssetsReference for ModuleChunkItem {}\n+\n #[turbo_tasks::value_impl]\n impl ChunkItem for ModuleChunkItem {\n     #[turbo_tasks::function]"
        },
        {
            "sha": "10066589286bd1c920dc85aec08d4d91548b30a4",
            "filename": "turbopack/crates/turbopack-dev-server/src/html.rs",
            "status": "modified",
            "additions": 14,
            "deletions": 7,
            "changes": 21,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fhtml.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fhtml.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fhtml.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -15,7 +15,7 @@ use turbopack_core::{\n     },\n     module::Module,\n     module_graph::{ModuleGraph, chunk_group_info::ChunkGroup},\n-    output::{OutputAsset, OutputAssets, OutputAssetsWithReferenced},\n+    output::{OutputAsset, OutputAssetsReference, OutputAssetsWithReferenced},\n     version::{Version, VersionedContent},\n };\n \n@@ -41,15 +41,18 @@ pub struct DevHtmlAsset {\n }\n \n #[turbo_tasks::value_impl]\n-impl OutputAsset for DevHtmlAsset {\n+impl OutputAssetsReference for DevHtmlAsset {\n     #[turbo_tasks::function]\n-    fn path(&self) -> Vc<FileSystemPath> {\n-        self.path.clone().cell()\n+    fn references(self: Vc<Self>) -> Vc<OutputAssetsWithReferenced> {\n+        self.chunk_group()\n     }\n+}\n \n+#[turbo_tasks::value_impl]\n+impl OutputAsset for DevHtmlAsset {\n     #[turbo_tasks::function]\n-    fn references(self: Vc<Self>) -> Vc<OutputAssets> {\n-        self.chunk_group().all_assets()\n+    fn path(&self) -> Vc<FileSystemPath> {\n+        self.path.clone().cell()\n     }\n }\n \n@@ -176,21 +179,25 @@ impl DevHtmlAsset {\n                 Ok((\n                     asset_with_referenced.assets.await?,\n                     asset_with_referenced.referenced_assets.await?,\n+                    asset_with_referenced.references.await?,\n                 ))\n             })\n             .try_join()\n             .await?;\n \n         let mut all_assets = Vec::new();\n         let mut all_referenced_assets = Vec::new();\n-        for (asset, referenced_asset) in all_chunk_groups {\n+        let mut all_references = Vec::new();\n+        for (asset, referenced_asset, reference) in all_chunk_groups {\n             all_assets.extend(asset);\n             all_referenced_assets.extend(referenced_asset);\n+            all_references.extend(reference);\n         }\n \n         Ok(OutputAssetsWithReferenced {\n             assets: ResolvedVc::cell(all_assets),\n             referenced_assets: ResolvedVc::cell(all_referenced_assets),\n+            references: ResolvedVc::cell(all_references),\n         }\n         .cell())\n     }"
        },
        {
            "sha": "caac20386eac98c16df0f913ffba5ac9908a81ca",
            "filename": "turbopack/crates/turbopack-dev-server/src/source/asset_graph.rs",
            "status": "modified",
            "additions": 19,
            "deletions": 9,
            "changes": 28,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fsource%2Fasset_graph.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fsource%2Fasset_graph.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fsource%2Fasset_graph.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -10,7 +10,7 @@ use turbo_tasks_fs::FileSystemPath;\n use turbopack_core::{\n     asset::Asset,\n     introspect::{Introspectable, IntrospectableChildren, output_asset::IntrospectableOutputAsset},\n-    output::{OutputAsset, OutputAssetsSet},\n+    output::{OutputAsset, OutputAssetsReference, OutputAssetsSet},\n };\n \n use super::{\n@@ -107,7 +107,8 @@ async fn expand(\n ) -> Result<FxIndexMap<RcStr, ResolvedVc<Box<dyn OutputAsset>>>> {\n     let mut map = FxIndexMap::default();\n     let mut assets = Vec::new();\n-    let mut queue = VecDeque::with_capacity(32);\n+    let mut queue: VecDeque<ResolvedVc<Box<dyn OutputAssetsReference>>> =\n+        VecDeque::with_capacity(32);\n     let mut assets_set = FxHashSet::default();\n     let root_assets_with_path = root_assets\n         .iter()\n@@ -132,7 +133,7 @@ async fn expand(\n                 }\n                 assets_set.insert(root_asset);\n                 if expanded {\n-                    queue.push_back(root_asset.references());\n+                    queue.push_back(ResolvedVc::upcast(root_asset));\n                 }\n             }\n         }\n@@ -143,15 +144,24 @@ async fn expand(\n                 for sub_path in sub_paths_buffer.into_iter().take(sub_paths) {\n                     assets.push((sub_path, root_asset));\n                 }\n-                queue.push_back(root_asset.references());\n+                queue.push_back(ResolvedVc::upcast(root_asset));\n                 assets_set.insert(root_asset);\n             }\n         }\n     }\n \n-    while let Some(references) = queue.pop_front() {\n-        for asset in references.await?.iter() {\n-            if assets_set.insert(*asset) {\n+    while let Some(asset) = queue.pop_front() {\n+        let refs = asset.references().await?;\n+        for &reference in refs.references.await?.iter() {\n+            queue.push_back(reference);\n+        }\n+        let ref_assets = refs\n+            .assets\n+            .await?\n+            .into_iter()\n+            .chain(refs.referenced_assets.await?.into_iter());\n+        for &asset in ref_assets {\n+            if assets_set.insert(asset) {\n                 let path = asset.path().await?;\n                 if let Some(sub_path) = root_path.get_path_to(&path) {\n                     let (sub_paths_buffer, sub_paths) = get_sub_paths(sub_path);\n@@ -165,10 +175,10 @@ async fn expand(\n                         true\n                     };\n                     if expanded {\n-                        queue.push_back(asset.references());\n+                        queue.push_back(ResolvedVc::upcast(asset));\n                     }\n                     for sub_path in sub_paths_buffer.into_iter().take(sub_paths) {\n-                        assets.push((sub_path, *asset));\n+                        assets.push((sub_path, asset));\n                     }\n                 }\n             }"
        },
        {
            "sha": "aadc4578fe96b9f8f7f428ea47e637a02cc42c64",
            "filename": "turbopack/crates/turbopack-ecmascript/src/async_chunk/chunk_item.rs",
            "status": "modified",
            "additions": 10,
            "deletions": 6,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fasync_chunk%2Fchunk_item.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fasync_chunk%2Fchunk_item.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fasync_chunk%2Fchunk_item.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -11,7 +11,7 @@ use turbopack_core::{\n     module_graph::{\n         ModuleGraph, chunk_group_info::ChunkGroup, module_batch::ChunkableModuleOrBatch,\n     },\n-    output::{OutputAssets, OutputAssetsWithReferenced},\n+    output::{OutputAssetsReference, OutputAssetsWithReferenced},\n };\n \n use crate::{\n@@ -50,6 +50,7 @@ impl AsyncLoaderChunkItem {\n                 return Ok(OutputAssetsWithReferenced {\n                     assets: ResolvedVc::cell(vec![]),\n                     referenced_assets: ResolvedVc::cell(vec![]),\n+                    references: ResolvedVc::cell(vec![]),\n                 }\n                 .cell());\n             }\n@@ -150,6 +151,14 @@ impl EcmascriptChunkItem for AsyncLoaderChunkItem {\n     }\n }\n \n+#[turbo_tasks::value_impl]\n+impl OutputAssetsReference for AsyncLoaderChunkItem {\n+    #[turbo_tasks::function]\n+    fn references(self: Vc<Self>) -> Vc<OutputAssetsWithReferenced> {\n+        self.chunk_group()\n+    }\n+}\n+\n #[turbo_tasks::value_impl]\n impl ChunkItem for AsyncLoaderChunkItem {\n     #[turbo_tasks::function]\n@@ -164,11 +173,6 @@ impl ChunkItem for AsyncLoaderChunkItem {\n         Ok(ident.with_modifier(self.chunks_data().hash().await?.to_string().into()))\n     }\n \n-    #[turbo_tasks::function]\n-    fn references(self: Vc<Self>) -> Vc<OutputAssets> {\n-        self.chunk_group().all_assets()\n-    }\n-\n     #[turbo_tasks::function]\n     fn chunking_context(&self) -> Vc<Box<dyn ChunkingContext>> {\n         *self.chunking_context"
        },
        {
            "sha": "8df254d87683bf911b3fcd0aeb0a55c8ff07fd77",
            "filename": "turbopack/crates/turbopack-ecmascript/src/chunk/batch.rs",
            "status": "modified",
            "additions": 16,
            "deletions": 7,
            "changes": 23,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fchunk%2Fbatch.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fchunk%2Fbatch.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fchunk%2Fbatch.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -3,10 +3,9 @@ use serde::{Deserialize, Serialize};\n use turbo_tasks::{NonLocalValue, ResolvedVc, TaskInput, TryJoinIterExt, Vc, trace::TraceRawVcs};\n use turbopack_core::{\n     chunk::{\n-        ChunkItem, ChunkItemBatchGroup, ChunkItemBatchWithAsyncModuleInfo,\n-        ChunkItemOrBatchWithAsyncModuleInfo,\n+        ChunkItemBatchGroup, ChunkItemBatchWithAsyncModuleInfo, ChunkItemOrBatchWithAsyncModuleInfo,\n     },\n-    output::OutputAssets,\n+    output::{OutputAssetsReference, OutputAssetsWithReferenced},\n };\n \n use crate::chunk::EcmascriptChunkItemWithAsyncInfo;\n@@ -39,7 +38,7 @@ impl EcmascriptChunkItemOrBatchWithAsyncInfo {\n         })\n     }\n \n-    pub fn references(&self) -> Vc<OutputAssets> {\n+    pub fn references(&self) -> Vc<OutputAssetsWithReferenced> {\n         match self {\n             EcmascriptChunkItemOrBatchWithAsyncInfo::ChunkItem(item) => {\n                 item.chunk_item.references()\n@@ -70,13 +69,23 @@ impl EcmascriptChunkBatchWithAsyncInfo {\n     }\n \n     #[turbo_tasks::function]\n-    pub async fn references(&self) -> Result<Vc<OutputAssets>> {\n+    pub async fn references(&self) -> Result<Vc<OutputAssetsWithReferenced>> {\n+        let mut output_assets = Vec::new();\n+        let mut referenced_output_assets = Vec::new();\n         let mut references = Vec::new();\n         // We expect most references to be empty, and avoiding try_join to avoid allocating the Vec\n         for item in &self.chunk_items {\n-            references.extend(item.chunk_item.references().await?.into_iter().copied());\n+            let r = item.chunk_item.references().await?;\n+            output_assets.extend(r.assets.await?);\n+            referenced_output_assets.extend(r.referenced_assets.await?);\n+            references.extend(r.references.await?);\n         }\n-        Ok(Vc::cell(references))\n+        Ok(OutputAssetsWithReferenced {\n+            assets: ResolvedVc::cell(output_assets),\n+            referenced_assets: ResolvedVc::cell(referenced_output_assets),\n+            references: ResolvedVc::cell(references),\n+        }\n+        .cell())\n     }\n }\n "
        },
        {
            "sha": "c3970f8ff9ceb909198afd3b6fa288f5c3fb49b5",
            "filename": "turbopack/crates/turbopack-ecmascript/src/chunk/item.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fchunk%2Fitem.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fchunk%2Fitem.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fchunk%2Fitem.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -17,6 +17,7 @@ use turbopack_core::{\n     code_builder::{Code, CodeBuilder},\n     error::PrettyPrintError,\n     issue::{IssueExt, IssueSeverity, StyledString, code_gen::CodeGenerationIssue},\n+    output::OutputAssetsReference,\n     source_map::utils::{absolute_fileify_source_map, relative_fileify_source_map},\n };\n \n@@ -223,7 +224,7 @@ impl EcmascriptChunkItemWithAsyncInfo {\n }\n \n #[turbo_tasks::value_trait]\n-pub trait EcmascriptChunkItem: ChunkItem {\n+pub trait EcmascriptChunkItem: ChunkItem + OutputAssetsReference {\n     #[turbo_tasks::function]\n     fn content(self: Vc<Self>) -> Vc<EcmascriptChunkItemContent>;\n     #[turbo_tasks::function]"
        },
        {
            "sha": "d4c46d84cfa90c58ccaa38fbb71136def50a509b",
            "filename": "turbopack/crates/turbopack-ecmascript/src/chunk/mod.rs",
            "status": "modified",
            "additions": 44,
            "deletions": 14,
            "changes": 58,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fchunk%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fchunk%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fchunk%2Fmod.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -10,7 +10,7 @@ use std::fmt::Write;\n \n use anyhow::Result;\n use turbo_rcstr::{RcStr, rcstr};\n-use turbo_tasks::{ResolvedVc, TryFlatJoinIterExt, TryJoinIterExt, ValueToString, Vc};\n+use turbo_tasks::{ResolvedVc, TryJoinIterExt, ValueToString, Vc};\n use turbo_tasks_fs::FileSystem;\n use turbopack_core::{\n     chunk::{Chunk, ChunkItem, ChunkItems, ChunkingContext, ModuleIds},\n@@ -19,7 +19,7 @@ use turbopack_core::{\n         Introspectable, IntrospectableChildren, module::IntrospectableModule,\n         utils::children_from_output_assets,\n     },\n-    output::OutputAssets,\n+    output::{OutputAssetsReference, OutputAssetsWithReferenced},\n     server_fs::ServerFileSystem,\n };\n \n@@ -66,6 +66,48 @@ impl EcmascriptChunk {\n     }\n }\n \n+#[turbo_tasks::value_impl]\n+impl OutputAssetsReference for EcmascriptChunk {\n+    #[turbo_tasks::function]\n+    async fn references(&self) -> Result<Vc<OutputAssetsWithReferenced>> {\n+        let content = self.content.await?;\n+        let references = content\n+            .chunk_items\n+            .iter()\n+            .map(async |with_info| {\n+                let r = with_info.references().await?;\n+                Ok((\n+                    r.assets.await?,\n+                    r.referenced_assets.await?,\n+                    r.references.await?,\n+                ))\n+            })\n+            .try_join()\n+            .await?;\n+        Ok(OutputAssetsWithReferenced {\n+            assets: ResolvedVc::cell(\n+                references\n+                    .iter()\n+                    .flat_map(|(assets, _, _)| assets.into_iter().copied())\n+                    .collect(),\n+            ),\n+            referenced_assets: ResolvedVc::cell(\n+                references\n+                    .iter()\n+                    .flat_map(|(_, referenced_assets, _)| referenced_assets.into_iter().copied())\n+                    .collect(),\n+            ),\n+            references: ResolvedVc::cell(\n+                references\n+                    .iter()\n+                    .flat_map(|(_, _, references)| references.into_iter().copied())\n+                    .collect(),\n+            ),\n+        }\n+        .cell())\n+    }\n+}\n+\n #[turbo_tasks::value_impl]\n impl Chunk for EcmascriptChunk {\n     #[turbo_tasks::function]\n@@ -127,18 +169,6 @@ impl Chunk for EcmascriptChunk {\n         *self.chunking_context\n     }\n \n-    #[turbo_tasks::function]\n-    async fn references(&self) -> Result<Vc<OutputAssets>> {\n-        let content = self.content.await?;\n-        let referenced_output_assets = content\n-            .chunk_items\n-            .iter()\n-            .map(async |with_info| Ok(with_info.references().await?.into_iter().copied()))\n-            .try_flat_join()\n-            .await?;\n-        Ok(Vc::cell(referenced_output_assets))\n-    }\n-\n     #[turbo_tasks::function]\n     fn chunk_items(&self) -> Vc<ChunkItems> {\n         self.content.included_chunk_items()"
        },
        {
            "sha": "9e0f7d67f0c70aa017913d34ae2044dce424b330",
            "filename": "turbopack/crates/turbopack-ecmascript/src/inlined_bytes_module.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Finlined_bytes_module.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Finlined_bytes_module.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Finlined_bytes_module.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -10,6 +10,7 @@ use turbopack_core::{\n     ident::AssetIdent,\n     module::Module,\n     module_graph::ModuleGraph,\n+    output::OutputAssetsReference,\n     source::Source,\n };\n \n@@ -87,6 +88,9 @@ struct InlinedBytesJsChunkItem {\n     chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n }\n \n+#[turbo_tasks::value_impl]\n+impl OutputAssetsReference for InlinedBytesJsChunkItem {}\n+\n #[turbo_tasks::value_impl]\n impl ChunkItem for InlinedBytesJsChunkItem {\n     #[turbo_tasks::function]"
        },
        {
            "sha": "349086ba28a85d652290db1640e49497a1b8b1f9",
            "filename": "turbopack/crates/turbopack-ecmascript/src/lib.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -100,6 +100,7 @@ use turbopack_core::{\n     ident::AssetIdent,\n     module::{Module, OptionModule},\n     module_graph::ModuleGraph,\n+    output::OutputAssetsReference,\n     reference::ModuleReferences,\n     reference_type::InnerAssets,\n     resolve::{\n@@ -869,6 +870,9 @@ struct ModuleChunkItem {\n     chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n }\n \n+#[turbo_tasks::value_impl]\n+impl OutputAssetsReference for ModuleChunkItem {}\n+\n #[turbo_tasks::value_impl]\n impl ChunkItem for ModuleChunkItem {\n     #[turbo_tasks::function]"
        },
        {
            "sha": "a2e034de6c00cc3921a3774ac4c6a0db5db66a13",
            "filename": "turbopack/crates/turbopack-ecmascript/src/manifest/chunk_asset.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fmanifest%2Fchunk_asset.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fmanifest%2Fchunk_asset.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fmanifest%2Fchunk_asset.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -83,6 +83,7 @@ impl ManifestAsyncModule {\n                 return Ok(OutputAssetsWithReferenced {\n                     assets: ResolvedVc::cell(vec![]),\n                     referenced_assets: ResolvedVc::cell(vec![]),\n+                    references: ResolvedVc::cell(vec![]),\n                 }\n                 .cell());\n             }\n@@ -125,7 +126,7 @@ impl Module for ManifestAsyncModule {\n \n     #[turbo_tasks::function]\n     async fn references(self: Vc<Self>) -> Result<Vc<ModuleReferences>> {\n-        let assets = self.chunk_group().all_assets().await?;\n+        let assets = self.chunk_group().expand_all_assets().await?;\n \n         Ok(Vc::cell(\n             assets"
        },
        {
            "sha": "f561d44d3c910cf7a33ddf3d0f6eae8c1b4b6a24",
            "filename": "turbopack/crates/turbopack-ecmascript/src/manifest/chunk_item.rs",
            "status": "modified",
            "additions": 9,
            "deletions": 6,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fmanifest%2Fchunk_item.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fmanifest%2Fchunk_item.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fmanifest%2Fchunk_item.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -5,7 +5,7 @@ use turbopack_core::{\n     chunk::{ChunkData, ChunkItem, ChunkType, ChunkingContext, ChunksData},\n     ident::AssetIdent,\n     module::Module,\n-    output::OutputAssets,\n+    output::{OutputAssetsReference, OutputAssetsWithReferenced},\n };\n \n use super::chunk_asset::ManifestAsyncModule;\n@@ -64,6 +64,14 @@ impl EcmascriptChunkItem for ManifestChunkItem {\n     }\n }\n \n+#[turbo_tasks::value_impl]\n+impl OutputAssetsReference for ManifestChunkItem {\n+    #[turbo_tasks::function]\n+    fn references(&self) -> Vc<OutputAssetsWithReferenced> {\n+        self.manifest.chunk_group()\n+    }\n+}\n+\n #[turbo_tasks::value_impl]\n impl ChunkItem for ManifestChunkItem {\n     #[turbo_tasks::function]\n@@ -76,11 +84,6 @@ impl ChunkItem for ManifestChunkItem {\n         self.manifest.content_ident()\n     }\n \n-    #[turbo_tasks::function]\n-    fn references(&self) -> Vc<OutputAssets> {\n-        self.manifest.chunk_group().all_assets()\n-    }\n-\n     #[turbo_tasks::function]\n     fn chunking_context(&self) -> Vc<Box<dyn ChunkingContext>> {\n         *self.chunking_context"
        },
        {
            "sha": "c559a50ae5dabef2d62a3e190e6fd3d282e2378f",
            "filename": "turbopack/crates/turbopack-ecmascript/src/manifest/loader_item.rs",
            "status": "modified",
            "additions": 9,
            "deletions": 6,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fmanifest%2Floader_item.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fmanifest%2Floader_item.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fmanifest%2Floader_item.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -12,7 +12,7 @@ use turbopack_core::{\n     ident::AssetIdent,\n     module::Module,\n     module_graph::ModuleGraph,\n-    output::OutputAssets,\n+    output::{OutputAssetsReference, OutputAssetsWithReferenced},\n };\n \n use super::chunk_asset::ManifestAsyncModule;\n@@ -80,6 +80,14 @@ impl ManifestLoaderChunkItem {\n     }\n }\n \n+#[turbo_tasks::value_impl]\n+impl OutputAssetsReference for ManifestLoaderChunkItem {\n+    #[turbo_tasks::function]\n+    fn references(&self) -> Vc<OutputAssetsWithReferenced> {\n+        self.manifest.manifest_chunk_group()\n+    }\n+}\n+\n #[turbo_tasks::value_impl]\n impl ChunkItem for ManifestLoaderChunkItem {\n     #[turbo_tasks::function]\n@@ -92,11 +100,6 @@ impl ChunkItem for ManifestLoaderChunkItem {\n         self.manifest.content_ident().with_modifier(modifier())\n     }\n \n-    #[turbo_tasks::function]\n-    fn references(&self) -> Vc<OutputAssets> {\n-        self.manifest.manifest_chunk_group().all_assets()\n-    }\n-\n     #[turbo_tasks::function]\n     fn chunking_context(&self) -> Vc<Box<dyn ChunkingContext>> {\n         *self.chunking_context"
        },
        {
            "sha": "2c036d250367b82131c0f9ee2f06d8d13eb6886b",
            "filename": "turbopack/crates/turbopack-ecmascript/src/merged_module.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fmerged_module.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fmerged_module.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fmerged_module.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -9,6 +9,7 @@ use turbopack_core::{\n     ident::AssetIdent,\n     module::Module,\n     module_graph::ModuleGraph,\n+    output::OutputAssetsReference,\n     reference::ModuleReferences,\n };\n \n@@ -111,6 +112,9 @@ struct MergedEcmascriptModuleChunkItem {\n     chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n }\n \n+#[turbo_tasks::value_impl]\n+impl OutputAssetsReference for MergedEcmascriptModuleChunkItem {}\n+\n #[turbo_tasks::value_impl]\n impl ChunkItem for MergedEcmascriptModuleChunkItem {\n     #[turbo_tasks::function]"
        },
        {
            "sha": "ca0dfbe6a31e21181962021e658255237aa5991e",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/external_module.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fexternal_module.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fexternal_module.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fexternal_module.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -11,6 +11,7 @@ use turbopack_core::{\n     ident::{AssetIdent, Layer},\n     module::Module,\n     module_graph::ModuleGraph,\n+    output::OutputAssetsReference,\n     raw_module::RawModule,\n     reference::{ModuleReference, ModuleReferences, TracedModuleReference},\n     reference_type::ReferenceType,\n@@ -372,6 +373,9 @@ pub struct CachedExternalModuleChunkItem {\n     chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n }\n \n+#[turbo_tasks::value_impl]\n+impl OutputAssetsReference for CachedExternalModuleChunkItem {}\n+\n #[turbo_tasks::value_impl]\n impl ChunkItem for CachedExternalModuleChunkItem {\n     #[turbo_tasks::function]"
        },
        {
            "sha": "565f00b28b31303b9a68aadbedf11e6a681e350d",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/require_context.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Frequire_context.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Frequire_context.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Frequire_context.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -30,6 +30,7 @@ use turbopack_core::{\n     issue::IssueSource,\n     module::Module,\n     module_graph::ModuleGraph,\n+    output::OutputAssetsReference,\n     reference::{ModuleReference, ModuleReferences},\n     reference_type::CommonJsReferenceSubType,\n     resolve::{ModuleResolveResult, origin::ResolveOrigin, parse::Request},\n@@ -469,6 +470,9 @@ pub struct RequireContextChunkItem {\n     map: ResolvedVc<RequireContextMap>,\n }\n \n+#[turbo_tasks::value_impl]\n+impl OutputAssetsReference for RequireContextChunkItem {}\n+\n #[turbo_tasks::value_impl]\n impl EcmascriptChunkItem for RequireContextChunkItem {\n     #[turbo_tasks::function]"
        },
        {
            "sha": "0a44fd735c3ea69bd855cff05091e6ea0cf410fe",
            "filename": "turbopack/crates/turbopack-ecmascript/src/side_effect_optimization/facade/chunk_item.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Ffacade%2Fchunk_item.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Ffacade%2Fchunk_item.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Ffacade%2Fchunk_item.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -4,6 +4,7 @@ use turbopack_core::{\n     chunk::{AsyncModuleInfo, ChunkItem, ChunkType, ChunkingContext},\n     ident::AssetIdent,\n     module::Module,\n+    output::OutputAssetsReference,\n };\n \n use super::module::EcmascriptModuleFacadeModule;\n@@ -53,6 +54,9 @@ impl EcmascriptChunkItem for EcmascriptModuleFacadeChunkItem {\n     }\n }\n \n+#[turbo_tasks::value_impl]\n+impl OutputAssetsReference for EcmascriptModuleFacadeChunkItem {}\n+\n #[turbo_tasks::value_impl]\n impl ChunkItem for EcmascriptModuleFacadeChunkItem {\n     #[turbo_tasks::function]"
        },
        {
            "sha": "84f69b5559f9f8c7b9a119c16170f900eb6a3481",
            "filename": "turbopack/crates/turbopack-ecmascript/src/side_effect_optimization/locals/chunk_item.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Flocals%2Fchunk_item.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Flocals%2Fchunk_item.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Flocals%2Fchunk_item.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -4,6 +4,7 @@ use turbopack_core::{\n     chunk::{AsyncModuleInfo, ChunkItem, ChunkType, ChunkingContext},\n     ident::AssetIdent,\n     module::Module,\n+    output::OutputAssetsReference,\n };\n \n use super::module::EcmascriptModuleLocalsModule;\n@@ -53,6 +54,9 @@ impl EcmascriptChunkItem for EcmascriptModuleLocalsChunkItem {\n     }\n }\n \n+#[turbo_tasks::value_impl]\n+impl OutputAssetsReference for EcmascriptModuleLocalsChunkItem {}\n+\n #[turbo_tasks::value_impl]\n impl ChunkItem for EcmascriptModuleLocalsChunkItem {\n     #[turbo_tasks::function]"
        },
        {
            "sha": "dfe90d8dffae2640e221ce3874769b7f4aa15bee",
            "filename": "turbopack/crates/turbopack-ecmascript/src/tree_shake/chunk_item.rs",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fchunk_item.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fchunk_item.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fchunk_item.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -6,6 +6,7 @@ use turbopack_core::{\n     ident::AssetIdent,\n     module::Module,\n     module_graph::ModuleGraph,\n+    output::OutputAssetsReference,\n };\n \n use super::asset::EcmascriptModulePartAsset;\n@@ -59,6 +60,9 @@ impl EcmascriptChunkItem for EcmascriptModulePartChunkItem {\n     }\n }\n \n+#[turbo_tasks::value_impl]\n+impl OutputAssetsReference for EcmascriptModulePartChunkItem {}\n+\n #[turbo_tasks::value_impl]\n impl ChunkItem for EcmascriptModulePartChunkItem {\n     #[turbo_tasks::function]\n@@ -91,6 +95,9 @@ pub(super) struct SideEffectsModuleChunkItem {\n     pub chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n }\n \n+#[turbo_tasks::value_impl]\n+impl OutputAssetsReference for SideEffectsModuleChunkItem {}\n+\n #[turbo_tasks::value_impl]\n impl ChunkItem for SideEffectsModuleChunkItem {\n     #[turbo_tasks::function]"
        },
        {
            "sha": "56d3674f1168d3d9e622da91a8ca004558f0133a",
            "filename": "turbopack/crates/turbopack-ecmascript/src/worker_chunk/chunk_item.rs",
            "status": "modified",
            "additions": 9,
            "deletions": 6,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fworker_chunk%2Fchunk_item.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fworker_chunk%2Fchunk_item.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fworker_chunk%2Fchunk_item.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -10,7 +10,7 @@ use turbopack_core::{\n     ident::AssetIdent,\n     module::Module,\n     module_graph::{ModuleGraph, chunk_group_info::ChunkGroup},\n-    output::{OutputAssets, OutputAssetsWithReferenced},\n+    output::{OutputAssetsReference, OutputAssetsWithReferenced},\n };\n \n use super::module::WorkerLoaderModule;\n@@ -80,6 +80,14 @@ impl EcmascriptChunkItem for WorkerLoaderChunkItem {\n     }\n }\n \n+#[turbo_tasks::value_impl]\n+impl OutputAssetsReference for WorkerLoaderChunkItem {\n+    #[turbo_tasks::function]\n+    fn references(self: Vc<Self>) -> Vc<OutputAssetsWithReferenced> {\n+        self.chunk_group()\n+    }\n+}\n+\n #[turbo_tasks::value_impl]\n impl ChunkItem for WorkerLoaderChunkItem {\n     #[turbo_tasks::function]\n@@ -92,11 +100,6 @@ impl ChunkItem for WorkerLoaderChunkItem {\n         self.module.ident()\n     }\n \n-    #[turbo_tasks::function]\n-    fn references(self: Vc<Self>) -> Vc<OutputAssets> {\n-        self.chunk_group().all_assets()\n-    }\n-\n     #[turbo_tasks::function]\n     fn chunking_context(&self) -> Vc<Box<dyn ChunkingContext>> {\n         *self.chunking_context"
        },
        {
            "sha": "5186b809d231073681559873d5a0aa1932e3a5b9",
            "filename": "turbopack/crates/turbopack-json/src/lib.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-json%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-json%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-json%2Fsrc%2Flib.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -22,6 +22,7 @@ use turbopack_core::{\n     ident::AssetIdent,\n     module::Module,\n     module_graph::ModuleGraph,\n+    output::OutputAssetsReference,\n     source::Source,\n };\n use turbopack_ecmascript::{\n@@ -95,6 +96,9 @@ struct JsonChunkItem {\n     chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n }\n \n+#[turbo_tasks::value_impl]\n+impl OutputAssetsReference for JsonChunkItem {}\n+\n #[turbo_tasks::value_impl]\n impl ChunkItem for JsonChunkItem {\n     #[turbo_tasks::function]"
        },
        {
            "sha": "ce00fff02eb245d4c51a934bb85cf695bb1cd926",
            "filename": "turbopack/crates/turbopack-nft/src/nft.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-nft%2Fsrc%2Fnft.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-nft%2Fsrc%2Fnft.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-nft%2Fsrc%2Fnft.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -20,7 +20,7 @@ use turbopack_core::{\n     file_source::FileSource,\n     ident::Layer,\n     issue::{IssueReporter, IssueSeverity, handle_issues},\n-    output::OutputAsset,\n+    output::{OutputAsset, OutputAssetsReference},\n     reference::all_assets_from_entries,\n     reference_type::ReferenceType,\n     traced_asset::TracedAsset,\n@@ -150,7 +150,7 @@ async fn to_graph(asset: ResolvedVc<Box<dyn OutputAsset>>, max_depth: usize) ->\n \n     let mut result = vec![];\n     while let Some((depth, asset)) = queue.pop() {\n-        let references = asset.references().await?;\n+        let references = asset.references().all_assets().await?;\n         let mut indent = String::new();\n         for _ in 0..depth {\n             indent.push_str(\"  \");"
        },
        {
            "sha": "315e3b9347e6a8fd93ce93be8ab75921a4be86d6",
            "filename": "turbopack/crates/turbopack-node/src/lib.rs",
            "status": "modified",
            "additions": 21,
            "deletions": 108,
            "changes": 129,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Flib.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -2,15 +2,12 @@\n #![feature(arbitrary_self_types)]\n #![feature(arbitrary_self_types_pointers)]\n \n-use std::{iter::once, thread::available_parallelism};\n+use std::thread::available_parallelism;\n \n use anyhow::{Result, bail};\n use rustc_hash::FxHashMap;\n use turbo_rcstr::{RcStr, rcstr};\n-use turbo_tasks::{\n-    FxIndexSet, ResolvedVc, TryJoinIterExt, Vc,\n-    graph::{AdjacencyMap, GraphTraversal},\n-};\n+use turbo_tasks::{ResolvedVc, TryFlatJoinIterExt, Vc};\n use turbo_tasks_env::ProcessEnv;\n use turbo_tasks_fs::{File, FileSystemPath, to_sys_path};\n use turbopack_core::{\n@@ -19,7 +16,7 @@ use turbopack_core::{\n     chunk::{ChunkingContext, ChunkingContextExt, EvaluatableAsset, EvaluatableAssets},\n     module::Module,\n     module_graph::{ModuleGraph, chunk_group_info::ChunkGroupEntry},\n-    output::{OutputAsset, OutputAssets, OutputAssetsSet},\n+    output::{ExpandOutputAssetsInput, OutputAsset, OutputAssets, expand_output_assets},\n     source_map::GenerateSourceMap,\n     virtual_output::VirtualOutputAsset,\n };\n@@ -50,29 +47,32 @@ async fn emit(\n     Ok(())\n }\n \n-/// List of the all assets of the \"internal\" subgraph and a list of boundary\n-/// assets that are not considered \"internal\" (\"external\")\n-#[derive(Debug)]\n-#[turbo_tasks::value]\n-struct SeparatedAssets {\n-    internal_assets: ResolvedVc<OutputAssetsSet>,\n-    external_asset_entrypoints: ResolvedVc<OutputAssetsSet>,\n-}\n-\n /// Extracts the subgraph of \"internal\" assets (assets within the passes\n /// directory). Also lists all boundary assets that are not part of the\n /// \"internal\" subgraph.\n #[turbo_tasks::function]\n async fn internal_assets(\n     intermediate_asset: ResolvedVc<Box<dyn OutputAsset>>,\n     intermediate_output_path: FileSystemPath,\n-) -> Result<Vc<OutputAssetsSet>> {\n-    Ok(\n-        *separate_assets_operation(intermediate_asset, intermediate_output_path)\n-            .read_strongly_consistent()\n-            .await?\n-            .internal_assets,\n+) -> Result<Vc<OutputAssets>> {\n+    let all_assets = expand_output_assets(\n+        std::iter::once(ExpandOutputAssetsInput::Asset(intermediate_asset)),\n+        true,\n     )\n+    .await?;\n+    let internal_assets = all_assets\n+        .into_iter()\n+        .map(async |asset| {\n+            let path = asset.path().await?;\n+            if path.is_inside_ref(&intermediate_output_path) {\n+                Ok(Some(asset))\n+            } else {\n+                Ok(None)\n+            }\n+        })\n+        .try_flat_join()\n+        .await?;\n+    Ok(Vc::cell(internal_assets))\n }\n \n #[turbo_tasks::value(transparent)]\n@@ -100,93 +100,6 @@ async fn internal_assets_for_source_mapping(\n     Ok(Vc::cell(internal_assets_for_source_mapping))\n }\n \n-/// Returns a set of \"external\" assets on the boundary of the \"internal\"\n-/// subgraph\n-#[turbo_tasks::function]\n-pub async fn external_asset_entrypoints(\n-    module: Vc<Box<dyn EvaluatableAsset>>,\n-    runtime_entries: Vc<EvaluatableAssets>,\n-    chunking_context: Vc<Box<dyn ChunkingContext>>,\n-    intermediate_output_path: FileSystemPath,\n-) -> Result<Vc<OutputAssetsSet>> {\n-    Ok(*separate_assets_operation(\n-        get_intermediate_asset(chunking_context, module, runtime_entries)\n-            .to_resolved()\n-            .await?,\n-        intermediate_output_path,\n-    )\n-    .read_strongly_consistent()\n-    .await?\n-    .external_asset_entrypoints)\n-}\n-\n-/// Splits the asset graph into \"internal\" assets and boundaries to \"external\"\n-/// assets.\n-#[turbo_tasks::function(operation)]\n-async fn separate_assets_operation(\n-    intermediate_asset: ResolvedVc<Box<dyn OutputAsset>>,\n-    intermediate_output_path: FileSystemPath,\n-) -> Result<Vc<SeparatedAssets>> {\n-    let intermediate_output_path = intermediate_output_path.clone();\n-    #[derive(PartialEq, Eq, Hash, Clone, Copy)]\n-    enum Type {\n-        Internal(ResolvedVc<Box<dyn OutputAsset>>),\n-        External(ResolvedVc<Box<dyn OutputAsset>>),\n-    }\n-    let get_asset_children = |asset| {\n-        let intermediate_output_path = intermediate_output_path.clone();\n-        async move {\n-            let Type::Internal(asset) = asset else {\n-                return Ok(Vec::new());\n-            };\n-            asset\n-                .references()\n-                .await?\n-                .iter()\n-                .map(|asset| async {\n-                    // Assets within the output directory are considered as \"internal\" and all\n-                    // others as \"external\". We follow references on \"internal\" assets, but do not\n-                    // look into references of \"external\" assets, since there are no \"internal\"\n-                    // assets behind \"externals\"\n-                    if asset.path().await?.is_inside_ref(&intermediate_output_path) {\n-                        Ok(Type::Internal(*asset))\n-                    } else {\n-                        Ok(Type::External(*asset))\n-                    }\n-                })\n-                .try_join()\n-                .await\n-        }\n-    };\n-\n-    let graph = AdjacencyMap::new()\n-        .skip_duplicates()\n-        .visit(once(Type::Internal(intermediate_asset)), get_asset_children)\n-        .await\n-        .completed()?\n-        .into_inner();\n-\n-    let mut internal_assets = FxIndexSet::default();\n-    let mut external_asset_entrypoints = FxIndexSet::default();\n-\n-    for item in graph.into_postorder_topological() {\n-        match item {\n-            Type::Internal(asset) => {\n-                internal_assets.insert(asset);\n-            }\n-            Type::External(asset) => {\n-                external_asset_entrypoints.insert(asset);\n-            }\n-        }\n-    }\n-\n-    Ok(SeparatedAssets {\n-        internal_assets: ResolvedVc::cell(internal_assets),\n-        external_asset_entrypoints: ResolvedVc::cell(external_asset_entrypoints),\n-    }\n-    .cell())\n-}\n-\n /// Emit a basic package.json that sets the type of the package to commonjs.\n /// Currently code generated for Node is CommonJS, while authored code may be\n /// ESM, for example."
        },
        {
            "sha": "9ca564473bf0d398440e4c8243b268add007a3c4",
            "filename": "turbopack/crates/turbopack-nodejs/src/chunking_context.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fchunking_context.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fchunking_context.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fchunking_context.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -439,6 +439,7 @@ impl ChunkingContext for NodeJsChunkingContext {\n             let MakeChunkGroupResult {\n                 chunks,\n                 referenced_output_assets,\n+                references,\n                 availability_info,\n             } = make_chunk_group(\n                 modules,\n@@ -457,6 +458,7 @@ impl ChunkingContext for NodeJsChunkingContext {\n             Ok(ChunkGroupResult {\n                 assets: ResolvedVc::cell(assets),\n                 referenced_assets: ResolvedVc::cell(referenced_output_assets),\n+                references: ResolvedVc::cell(references),\n                 availability_info,\n             }\n             .cell())\n@@ -489,6 +491,7 @@ impl ChunkingContext for NodeJsChunkingContext {\n             let MakeChunkGroupResult {\n                 chunks,\n                 mut referenced_output_assets,\n+                references,\n                 availability_info,\n             } = make_chunk_group(\n                 entries,\n@@ -520,6 +523,7 @@ impl ChunkingContext for NodeJsChunkingContext {\n                     evaluatable_assets,\n                     *module,\n                     Vc::cell(referenced_output_assets),\n+                    Vc::cell(references),\n                     module_graph,\n                     *self,\n                 )"
        },
        {
            "sha": "3d20fa3fe069fbe6d781db79983ba6306c7a41bf",
            "filename": "turbopack/crates/turbopack-nodejs/src/ecmascript/node/chunk.rs",
            "status": "modified",
            "additions": 26,
            "deletions": 19,
            "changes": 45,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fchunk.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fchunk.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fchunk.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -6,7 +6,7 @@ use turbopack_core::{\n     asset::{Asset, AssetContent},\n     chunk::{Chunk, ChunkingContext},\n     introspect::{Introspectable, IntrospectableChildren},\n-    output::{OutputAsset, OutputAssets},\n+    output::{OutputAsset, OutputAssetsReference, OutputAssetsWithReferenced},\n     source_map::{GenerateSourceMap, OptionStringifiedSourceMap, SourceMapAsset},\n     version::VersionedContent,\n };\n@@ -75,36 +75,43 @@ impl EcmascriptBuildNodeChunk {\n }\n \n #[turbo_tasks::value_impl]\n-impl OutputAsset for EcmascriptBuildNodeChunk {\n-    #[turbo_tasks::function]\n-    async fn path(self: Vc<Self>) -> Result<Vc<FileSystemPath>> {\n-        let this = self.await?;\n-        let ident = this.chunk.ident().with_modifier(modifier());\n-        Ok(this\n-            .chunking_context\n-            .chunk_path(Some(Vc::upcast(self)), ident, None, rcstr!(\".js\")))\n-    }\n-\n+impl OutputAssetsReference for EcmascriptBuildNodeChunk {\n     #[turbo_tasks::function]\n-    async fn references(self: Vc<Self>) -> Result<Vc<OutputAssets>> {\n+    async fn references(self: Vc<Self>) -> Result<Vc<OutputAssetsWithReferenced>> {\n         let this = self.await?;\n         let chunk_references = this.chunk.references().await?;\n         let include_source_map = *this\n             .chunking_context\n             .reference_chunk_source_maps(Vc::upcast(self))\n             .await?;\n-        let mut references =\n-            Vec::with_capacity(chunk_references.len() + if include_source_map { 1 } else { 0 });\n+        let ref_assets = chunk_references.assets.await?;\n+        let mut assets =\n+            Vec::with_capacity(ref_assets.len() + if include_source_map { 1 } else { 0 });\n \n-        for reference in &*chunk_references {\n-            references.push(*reference);\n-        }\n+        assets.extend(ref_assets.iter().copied());\n \n         if include_source_map {\n-            references.push(ResolvedVc::upcast(self.source_map().to_resolved().await?));\n+            assets.push(ResolvedVc::upcast(self.source_map().to_resolved().await?));\n+        }\n+\n+        Ok(OutputAssetsWithReferenced {\n+            assets: ResolvedVc::cell(assets),\n+            referenced_assets: chunk_references.referenced_assets,\n+            references: chunk_references.references,\n         }\n+        .cell())\n+    }\n+}\n \n-        Ok(Vc::cell(references))\n+#[turbo_tasks::value_impl]\n+impl OutputAsset for EcmascriptBuildNodeChunk {\n+    #[turbo_tasks::function]\n+    async fn path(self: Vc<Self>) -> Result<Vc<FileSystemPath>> {\n+        let this = self.await?;\n+        let ident = this.chunk.ident().with_modifier(modifier());\n+        Ok(this\n+            .chunking_context\n+            .chunk_path(Some(Vc::upcast(self)), ident, None, rcstr!(\".js\")))\n     }\n }\n "
        },
        {
            "sha": "8a01a83ad000acd9bef0da795a9c7d50b9beebdb",
            "filename": "turbopack/crates/turbopack-nodejs/src/ecmascript/node/entry/chunk.rs",
            "status": "modified",
            "additions": 24,
            "deletions": 15,
            "changes": 39,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fentry%2Fchunk.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fentry%2Fchunk.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fentry%2Fchunk.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -10,7 +10,10 @@ use turbopack_core::{\n     chunk::{ChunkingContext, EvaluatableAssets, ModuleChunkItemIdExt},\n     code_builder::{Code, CodeBuilder},\n     module_graph::ModuleGraph,\n-    output::{OutputAsset, OutputAssets},\n+    output::{\n+        OutputAsset, OutputAssets, OutputAssetsReference, OutputAssetsReferences,\n+        OutputAssetsWithReferenced,\n+    },\n     source_map::{GenerateSourceMap, OptionStringifiedSourceMap, SourceMapAsset},\n };\n use turbopack_ecmascript::{chunk::EcmascriptChunkPlaceable, utils::StringifyJs};\n@@ -27,6 +30,7 @@ pub(crate) struct EcmascriptBuildNodeEntryChunk {\n     evaluatable_assets: ResolvedVc<EvaluatableAssets>,\n     exported_module: ResolvedVc<Box<dyn EcmascriptChunkPlaceable>>,\n     referenced_output_assets: ResolvedVc<OutputAssets>,\n+    references: ResolvedVc<OutputAssetsReferences>,\n     module_graph: ResolvedVc<ModuleGraph>,\n     chunking_context: ResolvedVc<NodeJsChunkingContext>,\n }\n@@ -41,6 +45,7 @@ impl EcmascriptBuildNodeEntryChunk {\n         evaluatable_assets: ResolvedVc<EvaluatableAssets>,\n         exported_module: ResolvedVc<Box<dyn EcmascriptChunkPlaceable>>,\n         referenced_output_assets: ResolvedVc<OutputAssets>,\n+        references: ResolvedVc<OutputAssetsReferences>,\n         module_graph: ResolvedVc<ModuleGraph>,\n         chunking_context: ResolvedVc<NodeJsChunkingContext>,\n     ) -> Vc<Self> {\n@@ -50,6 +55,7 @@ impl EcmascriptBuildNodeEntryChunk {\n             evaluatable_assets,\n             exported_module,\n             referenced_output_assets,\n+            references,\n             module_graph,\n             chunking_context,\n         }\n@@ -165,16 +171,11 @@ impl ValueToString for EcmascriptBuildNodeEntryChunk {\n }\n \n #[turbo_tasks::value_impl]\n-impl OutputAsset for EcmascriptBuildNodeEntryChunk {\n+impl OutputAssetsReference for EcmascriptBuildNodeEntryChunk {\n     #[turbo_tasks::function]\n-    fn path(&self) -> Vc<FileSystemPath> {\n-        self.path.clone().cell()\n-    }\n-\n-    #[turbo_tasks::function]\n-    async fn references(self: Vc<Self>) -> Result<Vc<OutputAssets>> {\n+    async fn references(self: Vc<Self>) -> Result<Vc<OutputAssetsWithReferenced>> {\n         let this = self.await?;\n-        let mut references = vec![ResolvedVc::upcast(\n+        let mut assets = vec![ResolvedVc::upcast(\n             self.runtime_chunk().to_resolved().await?,\n         )];\n \n@@ -183,18 +184,26 @@ impl OutputAsset for EcmascriptBuildNodeEntryChunk {\n             .reference_chunk_source_maps(Vc::upcast(self))\n             .await?\n         {\n-            references.push(ResolvedVc::upcast(self.source_map().to_resolved().await?))\n+            assets.push(ResolvedVc::upcast(self.source_map().to_resolved().await?))\n         }\n \n         let other_chunks = this.other_chunks.await?;\n-        references.extend(other_chunks.iter().copied());\n+        assets.extend(other_chunks.iter().copied());\n \n-        let referenced_output_assets = this.referenced_output_assets.await?;\n-        for &referenced_output_asset in &*referenced_output_assets {\n-            references.push(referenced_output_asset);\n+        Ok(OutputAssetsWithReferenced {\n+            assets: ResolvedVc::cell(assets),\n+            referenced_assets: this.referenced_output_assets,\n+            references: this.references,\n         }\n+        .cell())\n+    }\n+}\n \n-        Ok(Vc::cell(references))\n+#[turbo_tasks::value_impl]\n+impl OutputAsset for EcmascriptBuildNodeEntryChunk {\n+    #[turbo_tasks::function]\n+    fn path(&self) -> Vc<FileSystemPath> {\n+        self.path.clone().cell()\n     }\n }\n "
        },
        {
            "sha": "3faff0430daa0af97bcd8d2966489ff432e425a1",
            "filename": "turbopack/crates/turbopack-nodejs/src/ecmascript/node/entry/runtime.rs",
            "status": "modified",
            "additions": 19,
            "deletions": 14,
            "changes": 33,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fentry%2Fruntime.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fentry%2Fruntime.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fentry%2Fruntime.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -10,7 +10,7 @@ use turbopack_core::{\n     chunk::ChunkingContext,\n     code_builder::{Code, CodeBuilder},\n     ident::AssetIdent,\n-    output::{OutputAsset, OutputAssets},\n+    output::{OutputAsset, OutputAssetsReference, OutputAssetsWithReferenced},\n     source_map::{GenerateSourceMap, OptionStringifiedSourceMap, SourceMapAsset},\n };\n use turbopack_ecmascript::utils::StringifyJs;\n@@ -120,19 +120,9 @@ impl ValueToString for EcmascriptBuildNodeRuntimeChunk {\n }\n \n #[turbo_tasks::value_impl]\n-impl OutputAsset for EcmascriptBuildNodeRuntimeChunk {\n-    #[turbo_tasks::function]\n-    async fn path(self: Vc<Self>) -> Result<Vc<FileSystemPath>> {\n-        let this = self.await?;\n-        let ident = self.ident_for_path();\n-\n-        Ok(this\n-            .chunking_context\n-            .chunk_path(Some(Vc::upcast(self)), ident, None, rcstr!(\".js\")))\n-    }\n-\n+impl OutputAssetsReference for EcmascriptBuildNodeRuntimeChunk {\n     #[turbo_tasks::function]\n-    async fn references(self: Vc<Self>) -> Result<Vc<OutputAssets>> {\n+    async fn references(self: Vc<Self>) -> Result<Vc<OutputAssetsWithReferenced>> {\n         let this = self.await?;\n         let mut references = vec![];\n \n@@ -144,7 +134,22 @@ impl OutputAsset for EcmascriptBuildNodeRuntimeChunk {\n             references.push(ResolvedVc::upcast(self.source_map().to_resolved().await?))\n         }\n \n-        Ok(Vc::cell(references))\n+        Ok(OutputAssetsWithReferenced::from_assets(Vc::cell(\n+            references,\n+        )))\n+    }\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl OutputAsset for EcmascriptBuildNodeRuntimeChunk {\n+    #[turbo_tasks::function]\n+    async fn path(self: Vc<Self>) -> Result<Vc<FileSystemPath>> {\n+        let this = self.await?;\n+        let ident = self.ident_for_path();\n+\n+        Ok(this\n+            .chunking_context\n+            .chunk_path(Some(Vc::upcast(self)), ident, None, rcstr!(\".js\")))\n     }\n }\n "
        },
        {
            "sha": "2d8aa557cec5fad23018b7c85f7b4eb3ada85c41",
            "filename": "turbopack/crates/turbopack-static/src/ecma.rs",
            "status": "modified",
            "additions": 11,
            "deletions": 6,
            "changes": 17,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-static%2Fsrc%2Fecma.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-static%2Fsrc%2Fecma.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-static%2Fsrc%2Fecma.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -7,7 +7,7 @@ use turbopack_core::{\n     ident::AssetIdent,\n     module::Module,\n     module_graph::ModuleGraph,\n-    output::{OutputAsset, OutputAssets},\n+    output::{OutputAsset, OutputAssetsReference, OutputAssetsWithReferenced},\n     source::Source,\n };\n use turbopack_ecmascript::{\n@@ -106,15 +106,20 @@ struct StaticUrlJsChunkItem {\n }\n \n #[turbo_tasks::value_impl]\n-impl ChunkItem for StaticUrlJsChunkItem {\n+impl OutputAssetsReference for StaticUrlJsChunkItem {\n     #[turbo_tasks::function]\n-    fn asset_ident(&self) -> Vc<AssetIdent> {\n-        self.module.ident()\n+    fn references(&self) -> Vc<OutputAssetsWithReferenced> {\n+        OutputAssetsWithReferenced::from_assets(Vc::cell(vec![ResolvedVc::upcast(\n+            self.static_asset,\n+        )]))\n     }\n+}\n \n+#[turbo_tasks::value_impl]\n+impl ChunkItem for StaticUrlJsChunkItem {\n     #[turbo_tasks::function]\n-    fn references(&self) -> Vc<OutputAssets> {\n-        Vc::cell(vec![ResolvedVc::upcast(self.static_asset)])\n+    fn asset_ident(&self) -> Vc<AssetIdent> {\n+        self.module.ident()\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "c35711b18eb736e3685350af17131504084c108a",
            "filename": "turbopack/crates/turbopack-static/src/fixed.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-static%2Fsrc%2Ffixed.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-static%2Fsrc%2Ffixed.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-static%2Fsrc%2Ffixed.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -2,7 +2,7 @@ use turbo_tasks::{ResolvedVc, Vc};\n use turbo_tasks_fs::FileSystemPath;\n use turbopack_core::{\n     asset::{Asset, AssetContent},\n-    output::OutputAsset,\n+    output::{OutputAsset, OutputAssetsReference},\n     source::Source,\n };\n \n@@ -26,6 +26,9 @@ impl FixedStaticAsset {\n     }\n }\n \n+#[turbo_tasks::value_impl]\n+impl OutputAssetsReference for FixedStaticAsset {}\n+\n #[turbo_tasks::value_impl]\n impl OutputAsset for FixedStaticAsset {\n     #[turbo_tasks::function]"
        },
        {
            "sha": "3c5f8db87623d8e3c47d79aa8731ba9e801035d9",
            "filename": "turbopack/crates/turbopack-static/src/output_asset.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-static%2Fsrc%2Foutput_asset.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-static%2Fsrc%2Foutput_asset.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-static%2Fsrc%2Foutput_asset.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -5,7 +5,7 @@ use turbo_tasks_fs::{FileContent, FileSystemPath};\n use turbopack_core::{\n     asset::{Asset, AssetContent},\n     chunk::ChunkingContext,\n-    output::OutputAsset,\n+    output::{OutputAsset, OutputAssetsReference},\n     source::Source,\n };\n #[turbo_tasks::value]\n@@ -31,6 +31,9 @@ impl StaticOutputAsset {\n     }\n }\n \n+#[turbo_tasks::value_impl]\n+impl OutputAssetsReference for StaticOutputAsset {}\n+\n #[turbo_tasks::value_impl]\n impl OutputAsset for StaticOutputAsset {\n     #[turbo_tasks::function]"
        },
        {
            "sha": "1157cfd36f645f63bd8709b538337a8c9a8fb3a9",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -50,7 +50,7 @@ use turbopack_core::{\n         chunk_group_info::{ChunkGroup, ChunkGroupEntry},\n         export_usage::compute_export_usage_info,\n     },\n-    output::{OutputAsset, OutputAssets, OutputAssetsWithReferenced},\n+    output::{OutputAsset, OutputAssets, OutputAssetsReference, OutputAssetsWithReferenced},\n     reference_type::{EntryReferenceSubType, ReferenceType},\n     source::Source,\n };\n@@ -541,13 +541,14 @@ async fn run_test_operation(resource: RcStr) -> Result<Vc<FileSystemPath>> {\n                         .asset,\n                 ]),\n                 referenced_assets: ResolvedVc::cell(vec![]),\n+                references: ResolvedVc::cell(vec![]),\n             }\n             .cell()\n         }\n     };\n \n     let mut seen = FxHashSet::default();\n-    let mut queue: VecDeque<_> = chunks.all_assets().await?.iter().copied().collect();\n+    let mut queue: VecDeque<_> = chunks.expand_all_assets().await?.iter().copied().collect();\n \n     let output_path = project_path.clone();\n     while let Some(asset) = queue.pop_front() {\n@@ -583,7 +584,7 @@ async fn walk_asset(\n         diff(path.clone(), asset.content()).await?;\n     }\n \n-    queue.extend(asset.references().await?.iter().copied());\n+    queue.extend(asset.references().all_assets().await?.iter().copied());\n \n     Ok(())\n }"
        },
        {
            "sha": "5efb849ed0b5e78ab12ecdbfbf8fd0d6ff22d39d",
            "filename": "turbopack/crates/turbopack-tracing/benches/node_file_trace.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 5,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-tracing%2Fbenches%2Fnode_file_trace.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-tracing%2Fbenches%2Fnode_file_trace.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tracing%2Fbenches%2Fnode_file_trace.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -3,11 +3,11 @@ use std::{fs, path::PathBuf};\n use criterion::{Bencher, BenchmarkId, Criterion};\n use regex::Regex;\n use turbo_rcstr::{RcStr, rcstr};\n-use turbo_tasks::{ResolvedVc, TurboTasks, Vc, apply_effects};\n+use turbo_tasks::{TurboTasks, Vc, apply_effects};\n use turbo_tasks_backend::{BackendOptions, TurboTasksBackend, noop_backing_storage};\n use turbo_tasks_fs::{DiskFileSystem, FileSystem, NullFileSystem};\n use turbopack::{\n-    ModuleAssetContext, emit_with_completion_operation,\n+    ModuleAssetContext, emit_assets_into_dir_operation,\n     module_options::{EcmascriptOptionsContext, ModuleOptionsContext},\n };\n use turbopack_core::{\n@@ -17,6 +17,7 @@ use turbopack_core::{\n     file_source::FileSource,\n     ident::Layer,\n     rebase::RebasedAsset,\n+    reference::all_assets_from_entry,\n     reference_type::ReferenceType,\n };\n use turbopack_resolve::resolve_options_context::ResolveOptionsContext;\n@@ -117,12 +118,12 @@ fn bench_emit(b: &mut Bencher, bench_input: &BenchInput) {\n                 let module = module_asset_context\n                     .process(Vc::upcast(source), ReferenceType::Undefined)\n                     .module();\n-                let rebased = RebasedAsset::new(module, input_dir, output_dir.clone())\n+                let rebased = RebasedAsset::new(module, input_dir, output_dir.clone());\n+                let assets = all_assets_from_entry(Vc::upcast(rebased))\n                     .to_resolved()\n                     .await?;\n \n-                let emit_op =\n-                    emit_with_completion_operation(ResolvedVc::upcast(rebased), output_dir);\n+                let emit_op = emit_assets_into_dir_operation(assets, output_dir);\n                 emit_op.read_strongly_consistent().await?;\n                 apply_effects(emit_op).await?;\n "
        },
        {
            "sha": "bc0f1a97d503a4bc760488adc6854ef87696220e",
            "filename": "turbopack/crates/turbopack-tracing/tests/node-file-trace.rs",
            "status": "modified",
            "additions": 8,
            "deletions": 4,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-tracing%2Ftests%2Fnode-file-trace.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-tracing%2Ftests%2Fnode-file-trace.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tracing%2Ftests%2Fnode-file-trace.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -35,7 +35,7 @@ use turbo_tasks_fs::{DiskFileSystem, FileSystem};\n use turbopack::{\n     ModuleAssetContext,\n     ecmascript::AnalyzeMode,\n-    emit_with_completion_operation,\n+    emit_assets_into_dir_operation,\n     module_options::{\n         CssOptionsContext, EcmascriptOptionsContext, ModuleOptionsContext,\n         TypescriptTransformOptions,\n@@ -47,8 +47,9 @@ use turbopack_core::{\n     environment::{Environment, ExecutionEnvironment, NodeJsEnvironment},\n     file_source::FileSource,\n     ident::Layer,\n-    output::OutputAsset,\n+    output::{OutputAsset, OutputAssetsReference},\n     rebase::RebasedAsset,\n+    reference::all_assets_from_entry,\n     reference_type::ReferenceType,\n };\n use turbopack_resolve::resolve_options_context::ResolveOptionsContext;\n@@ -407,8 +408,11 @@ async fn node_file_trace_operation(\n     let rebased = RebasedAsset::new(module, input_dir.clone(), output_dir.clone())\n         .to_resolved()\n         .await?;\n+    let assets = all_assets_from_entry(Vc::upcast(*rebased))\n+        .to_resolved()\n+        .await?;\n \n-    let emit_op = emit_with_completion_operation(ResolvedVc::upcast(rebased), output_dir.clone());\n+    let emit_op = emit_assets_into_dir_operation(assets, output_dir.clone());\n     emit_op.read_strongly_consistent().await?;\n     apply_effects(emit_op).await?;\n \n@@ -746,7 +750,7 @@ async fn print_graph(asset: ResolvedVc<Box<dyn OutputAsset>>) -> Result<()> {\n     let mut queue = Vec::new();\n     queue.push((0, asset));\n     while let Some((depth, asset)) = queue.pop() {\n-        let references = asset.references().await?;\n+        let references = asset.references().all_assets().await?;\n         let mut indent = String::new();\n         for _ in 0..depth {\n             indent.push_str(\"  \");"
        },
        {
            "sha": "beddfd85e9e0e79420fbf680252c8fdee853aa70",
            "filename": "turbopack/crates/turbopack-wasm/src/module_asset.rs",
            "status": "modified",
            "additions": 10,
            "deletions": 7,
            "changes": 17,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-wasm%2Fsrc%2Fmodule_asset.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-wasm%2Fsrc%2Fmodule_asset.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-wasm%2Fsrc%2Fmodule_asset.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -12,7 +12,7 @@ use turbopack_core::{\n     ident::AssetIdent,\n     module::{Module, OptionModule},\n     module_graph::ModuleGraph,\n-    output::OutputAssets,\n+    output::{OutputAssetsReference, OutputAssetsWithReferenced},\n     reference::{ModuleReferences, SingleChunkableModuleReference},\n     reference_type::ReferenceType,\n     resolve::{ExportUsage, origin::ResolveOrigin, parse::Request},\n@@ -207,16 +207,19 @@ struct ModuleChunkItem {\n }\n \n #[turbo_tasks::value_impl]\n-impl ChunkItem for ModuleChunkItem {\n+impl OutputAssetsReference for ModuleChunkItem {\n     #[turbo_tasks::function]\n-    fn asset_ident(&self) -> Vc<AssetIdent> {\n-        self.module.ident()\n+    async fn references(&self) -> Result<Vc<OutputAssetsWithReferenced>> {\n+        let loader_references = self.module.loader().references().await?;\n+        references_to_output_assets(&*loader_references).await\n     }\n+}\n \n+#[turbo_tasks::value_impl]\n+impl ChunkItem for ModuleChunkItem {\n     #[turbo_tasks::function]\n-    async fn references(&self) -> Result<Vc<OutputAssets>> {\n-        let loader_references = self.module.loader().references().await?;\n-        references_to_output_assets(&*loader_references).await\n+    fn asset_ident(&self) -> Vc<AssetIdent> {\n+        self.module.ident()\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "729d583085701ae5ba3c631de7d8155f3b4b67ea",
            "filename": "turbopack/crates/turbopack-wasm/src/output_asset.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-wasm%2Fsrc%2Foutput_asset.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-wasm%2Fsrc%2Foutput_asset.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-wasm%2Fsrc%2Foutput_asset.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -5,7 +5,7 @@ use turbo_tasks_fs::FileSystemPath;\n use turbopack_core::{\n     asset::{Asset, AssetContent},\n     chunk::ChunkingContext,\n-    output::OutputAsset,\n+    output::{OutputAsset, OutputAssetsReference},\n     source::Source,\n };\n \n@@ -33,6 +33,9 @@ impl WebAssemblyAsset {\n     }\n }\n \n+#[turbo_tasks::value_impl]\n+impl OutputAssetsReference for WebAssemblyAsset {}\n+\n #[turbo_tasks::value_impl]\n impl OutputAsset for WebAssemblyAsset {\n     #[turbo_tasks::function]"
        },
        {
            "sha": "809a2312111300be7ea850743231bdfce64e2b85",
            "filename": "turbopack/crates/turbopack-wasm/src/raw.rs",
            "status": "modified",
            "additions": 9,
            "deletions": 6,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-wasm%2Fsrc%2Fraw.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack-wasm%2Fsrc%2Fraw.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-wasm%2Fsrc%2Fraw.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -8,7 +8,7 @@ use turbopack_core::{\n     ident::AssetIdent,\n     module::Module,\n     module_graph::ModuleGraph,\n-    output::{OutputAsset, OutputAssets},\n+    output::{OutputAsset, OutputAssetsReference, OutputAssetsWithReferenced},\n     source::Source,\n };\n use turbopack_ecmascript::{\n@@ -104,15 +104,18 @@ struct RawModuleChunkItem {\n }\n \n #[turbo_tasks::value_impl]\n-impl ChunkItem for RawModuleChunkItem {\n+impl OutputAssetsReference for RawModuleChunkItem {\n     #[turbo_tasks::function]\n-    fn asset_ident(&self) -> Vc<AssetIdent> {\n-        self.module.ident()\n+    fn references(&self) -> Vc<OutputAssetsWithReferenced> {\n+        OutputAssetsWithReferenced::from_assets(Vc::cell(vec![ResolvedVc::upcast(self.wasm_asset)]))\n     }\n+}\n \n+#[turbo_tasks::value_impl]\n+impl ChunkItem for RawModuleChunkItem {\n     #[turbo_tasks::function]\n-    fn references(&self) -> Result<Vc<OutputAssets>> {\n-        Ok(Vc::cell(vec![ResolvedVc::upcast(self.wasm_asset)]))\n+    fn asset_ident(&self) -> Vc<AssetIdent> {\n+        self.module.ident()\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "098d0374a58ef86b02c463c19a8f6c271dfa21a2",
            "filename": "turbopack/crates/turbopack/examples/turbopack.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack%2Fexamples%2Fturbopack.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack%2Fexamples%2Fturbopack.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack%2Fexamples%2Fturbopack.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -12,7 +12,7 @@ use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{ReadConsistency, TurboTasks, UpdateInfo, Vc, util::FormatDuration};\n use turbo_tasks_backend::{BackendOptions, TurboTasksBackend, noop_backing_storage};\n use turbo_tasks_fs::{DiskFileSystem, FileSystem};\n-use turbopack::emit_with_completion;\n+use turbopack::emit_assets_into_dir;\n use turbopack_core::{\n     PROJECT_FILESYSTEM_NAME,\n     compile_time_info::CompileTimeInfo,\n@@ -21,6 +21,7 @@ use turbopack_core::{\n     file_source::FileSource,\n     ident::Layer,\n     rebase::RebasedAsset,\n+    reference::all_assets_from_entry,\n };\n use turbopack_resolve::resolve_options_context::ResolveOptionsContext;\n \n@@ -68,7 +69,8 @@ async fn main() -> Result<()> {\n                 )\n                 .module();\n             let rebased = RebasedAsset::new(module, input, output.clone());\n-            emit_with_completion(Vc::upcast(rebased), output).await?;\n+            let assets = all_assets_from_entry(Vc::upcast(rebased));\n+            emit_assets_into_dir(assets, output).await?;\n \n             anyhow::Ok::<Vc<()>>(Default::default())\n         })"
        },
        {
            "sha": "373d224bed324a0c80d73e201dfdbeedd8e8a88a",
            "filename": "turbopack/crates/turbopack/src/graph/mod.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 201,
            "changes": 201,
            "blob_url": "https://github.com/vercel/next.js/blob/f6c2d4913233109ea49256e587db9b7ce636a1a5/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fgraph%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f6c2d4913233109ea49256e587db9b7ce636a1a5/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fgraph%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fgraph%2Fmod.rs?ref=f6c2d4913233109ea49256e587db9b7ce636a1a5",
            "patch": "@@ -1,201 +0,0 @@\n-use anyhow::Result;\n-use rustc_hash::FxHashSet;\n-use turbo_tasks::{ResolvedVc, Vc};\n-use turbopack_core::output::OutputAsset;\n-\n-#[turbo_tasks::value(shared)]\n-pub enum AggregatedGraph {\n-    Leaf(ResolvedVc<Box<dyn OutputAsset>>),\n-    Node {\n-        depth: usize,\n-        content: FxHashSet<ResolvedVc<AggregatedGraph>>,\n-        references: FxHashSet<ResolvedVc<AggregatedGraph>>,\n-    },\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl AggregatedGraph {\n-    #[turbo_tasks::function]\n-    fn leaf(asset: ResolvedVc<Box<dyn OutputAsset>>) -> Vc<Self> {\n-        Self::cell(AggregatedGraph::Leaf(asset))\n-    }\n-}\n-\n-impl AggregatedGraph {\n-    fn depth(&self) -> usize {\n-        match self {\n-            AggregatedGraph::Leaf(_) => 0,\n-            AggregatedGraph::Node { depth, .. } => *depth,\n-        }\n-    }\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl AggregatedGraph {\n-    #[turbo_tasks::function]\n-    pub async fn content(self: Vc<Self>) -> Result<Vc<AggregatedGraphNodeContent>> {\n-        Ok(match *self.await? {\n-            AggregatedGraph::Leaf(asset) => AggregatedGraphNodeContent::Asset(asset).cell(),\n-            AggregatedGraph::Node { ref content, .. } => {\n-                AggregatedGraphNodeContent::Children(content.clone()).cell()\n-            }\n-        })\n-    }\n-\n-    #[turbo_tasks::function]\n-    async fn references(self: Vc<Self>) -> Result<Vc<AggregatedGraphsSet>> {\n-        Ok(match &*self.await? {\n-            AggregatedGraph::Leaf(asset) => {\n-                let mut refs = FxHashSet::default();\n-                for reference in asset.references().await? {\n-                    if asset != reference {\n-                        refs.insert(AggregatedGraph::leaf(**reference).to_resolved().await?);\n-                    }\n-                }\n-                AggregatedGraphsSet { set: refs }.cell()\n-            }\n-            AggregatedGraph::Node { references, .. } => {\n-                let mut set = FxHashSet::default();\n-                for item in references\n-                    .iter()\n-                    .map(|&reference| aggregate_more(*reference))\n-                    .collect::<Vec<_>>()\n-                    .into_iter()\n-                {\n-                    set.insert(item.to_resolved().await?);\n-                }\n-                AggregatedGraphsSet { set }.cell()\n-            }\n-        })\n-    }\n-\n-    #[turbo_tasks::function]\n-    async fn cost(self: Vc<Self>) -> Result<Vc<AggregationCost>> {\n-        Ok(match *self.await? {\n-            AggregatedGraph::Leaf(asset) => AggregationCost(asset.references().await?.len()).cell(),\n-            AggregatedGraph::Node { ref references, .. } => {\n-                AggregationCost(references.len()).cell()\n-            }\n-        })\n-    }\n-\n-    #[turbo_tasks::function]\n-    async fn valued_references(self: Vc<Self>) -> Result<Vc<AggregatedGraphsValuedReferences>> {\n-        let self_cost = self.cost().await?.0;\n-        let mut inner = FxHashSet::default();\n-        let mut outer = FxHashSet::default();\n-        let mut references = FxHashSet::default();\n-        for (reference, cost) in self\n-            .references()\n-            .await?\n-            .set\n-            .iter()\n-            .map(|&reference| (reference, reference.cost()))\n-            .collect::<Vec<_>>()\n-        {\n-            let cost = cost.await?.0;\n-            if cost == 0 {\n-                inner.insert(reference);\n-            } else if cost > self_cost {\n-                references.insert(reference);\n-            } else {\n-                outer.insert(reference);\n-            }\n-        }\n-        Ok(AggregatedGraphsValuedReferences {\n-            inner,\n-            outer,\n-            references,\n-        }\n-        .cell())\n-    }\n-}\n-\n-#[turbo_tasks::function]\n-pub async fn aggregate(asset: Vc<Box<dyn OutputAsset>>) -> Result<Vc<AggregatedGraph>> {\n-    let mut current = AggregatedGraph::leaf(asset);\n-    loop {\n-        if current.references().await?.set.is_empty() {\n-            return Ok(current);\n-        }\n-        current = aggregate_more(current);\n-    }\n-}\n-\n-#[turbo_tasks::value(shared)]\n-#[derive(Clone, Hash, Debug)]\n-struct AggregationCost(usize);\n-\n-#[turbo_tasks::function]\n-async fn aggregate_more(node: ResolvedVc<AggregatedGraph>) -> Result<Vc<AggregatedGraph>> {\n-    let node_data = node.await?;\n-    let depth = node_data.depth();\n-    let mut in_progress = FxHashSet::default();\n-    let mut content = FxHashSet::default();\n-    let mut references = FxHashSet::default();\n-    in_progress.insert(node);\n-\n-    // only one kind of aggregation can't eliminate cycles with that\n-    // number of nodes. Alternating the aggregation will get rid of all\n-    // cycles\n-    let aggregation = if depth > 0 && depth.is_multiple_of(2) {\n-        3\n-    } else {\n-        2\n-    };\n-    for _ in 0..aggregation {\n-        for &node in in_progress.iter() {\n-            content.insert(node);\n-        }\n-        let valued_refs = in_progress\n-            .drain()\n-            .map(|node| node.valued_references())\n-            .collect::<Vec<_>>();\n-        for valued_refs in valued_refs {\n-            let valued_refs = valued_refs.await?;\n-            for &reference in valued_refs.inner.iter() {\n-                content.insert(reference);\n-            }\n-            for &reference in valued_refs.references.iter() {\n-                if content.contains(&reference) {\n-                    continue;\n-                }\n-                references.insert(reference);\n-            }\n-            for &reference in valued_refs.outer.iter() {\n-                if content.contains(&reference) {\n-                    continue;\n-                }\n-                references.remove(&reference);\n-                in_progress.insert(reference);\n-            }\n-        }\n-    }\n-    for node in in_progress.into_iter() {\n-        references.insert(node);\n-    }\n-    Ok(AggregatedGraph::Node {\n-        depth: depth + 1,\n-        content,\n-        references,\n-    }\n-    .cell())\n-}\n-\n-#[turbo_tasks::value(shared)]\n-struct AggregatedGraphsSet {\n-    pub set: FxHashSet<ResolvedVc<AggregatedGraph>>,\n-}\n-\n-#[turbo_tasks::value(shared)]\n-pub enum AggregatedGraphNodeContent {\n-    Asset(ResolvedVc<Box<dyn OutputAsset>>),\n-    Children(FxHashSet<ResolvedVc<AggregatedGraph>>),\n-}\n-\n-#[turbo_tasks::value(shared)]\n-struct AggregatedGraphsValuedReferences {\n-    pub inner: FxHashSet<ResolvedVc<AggregatedGraph>>,\n-    pub outer: FxHashSet<ResolvedVc<AggregatedGraph>>,\n-    pub references: FxHashSet<ResolvedVc<AggregatedGraph>>,\n-}"
        },
        {
            "sha": "e1ff992eb8cdc3bf0ca08901a0bbb8508356e846",
            "filename": "turbopack/crates/turbopack/src/lib.rs",
            "status": "modified",
            "additions": 28,
            "deletions": 55,
            "changes": 83,
            "blob_url": "https://github.com/vercel/next.js/blob/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a8d73c25f9468735841de9cd9819acfb5b6a0ccd/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Flib.rs?ref=a8d73c25f9468735841de9cd9819acfb5b6a0ccd",
            "patch": "@@ -9,7 +9,6 @@\n \n pub mod evaluate_context;\n pub mod global_module_ids;\n-mod graph;\n pub mod module_options;\n pub mod transition;\n \n@@ -21,11 +20,10 @@ use ecmascript::{\n     references::{FollowExportsResult, follow_reexports},\n     side_effect_optimization::facade::module::EcmascriptModuleFacadeModule,\n };\n-use graph::{AggregatedGraph, AggregatedGraphNodeContent, aggregate};\n use module_options::{ModuleOptions, ModuleOptionsContext, ModuleRuleEffect, ModuleType};\n use tracing::{Instrument, field::Empty};\n use turbo_rcstr::{RcStr, rcstr};\n-use turbo_tasks::{ResolvedVc, ValueToString, Vc};\n+use turbo_tasks::{ResolvedVc, TryJoinIterExt, ValueToString, Vc};\n use turbo_tasks_fs::{\n     FileSystemPath,\n     glob::{Glob, GlobOptions},\n@@ -40,7 +38,7 @@ use turbopack_core::{\n     issue::{IssueExt, IssueSource, module::ModuleIssue},\n     module::Module,\n     node_addon_module::NodeAddonModule,\n-    output::OutputAsset,\n+    output::{ExpandedOutputAssets, OutputAsset},\n     raw_module::RawModule,\n     reference_type::{\n         CssReferenceSubType, EcmaScriptModulesReferenceSubType, ImportContext, ImportWithType,\n@@ -973,57 +971,6 @@ impl AssetContext for ModuleAssetContext {\n     }\n }\n \n-#[turbo_tasks::function]\n-pub async fn emit_with_completion(\n-    asset: Vc<Box<dyn OutputAsset>>,\n-    output_dir: FileSystemPath,\n-) -> Result<()> {\n-    emit_assets_aggregated(asset, output_dir)\n-        .as_side_effect()\n-        .await\n-}\n-\n-#[turbo_tasks::function(operation)]\n-pub fn emit_with_completion_operation(\n-    asset: ResolvedVc<Box<dyn OutputAsset>>,\n-    output_dir: FileSystemPath,\n-) -> Vc<()> {\n-    emit_with_completion(*asset, output_dir)\n-}\n-\n-#[turbo_tasks::function]\n-async fn emit_assets_aggregated(\n-    asset: Vc<Box<dyn OutputAsset>>,\n-    output_dir: FileSystemPath,\n-) -> Result<()> {\n-    let aggregated = aggregate(asset);\n-    emit_aggregated_assets(aggregated, output_dir)\n-        .as_side_effect()\n-        .await\n-}\n-\n-#[turbo_tasks::function]\n-async fn emit_aggregated_assets(\n-    aggregated: Vc<AggregatedGraph>,\n-    output_dir: FileSystemPath,\n-) -> Result<()> {\n-    match &*aggregated.content().await? {\n-        AggregatedGraphNodeContent::Asset(asset) => {\n-            emit_asset_into_dir(**asset, output_dir)\n-                .as_side_effect()\n-                .await?;\n-        }\n-        AggregatedGraphNodeContent::Children(children) => {\n-            for aggregated in children {\n-                emit_aggregated_assets(**aggregated, output_dir.clone())\n-                    .as_side_effect()\n-                    .await?;\n-            }\n-        }\n-    }\n-    Ok(())\n-}\n-\n #[turbo_tasks::function]\n pub async fn emit_asset(asset: Vc<Box<dyn OutputAsset>>) -> Result<()> {\n     asset\n@@ -1047,6 +994,32 @@ pub async fn emit_asset_into_dir(\n     Ok(())\n }\n \n+#[turbo_tasks::function]\n+pub async fn emit_assets_into_dir(\n+    assets: Vc<ExpandedOutputAssets>,\n+    output_dir: FileSystemPath,\n+) -> Result<()> {\n+    let assets = assets.await?;\n+    let paths = assets.iter().map(|&asset| asset.path()).try_join().await?;\n+    for (&asset, path) in assets.iter().zip(paths.iter()) {\n+        if path.is_inside_ref(&output_dir) {\n+            emit_asset(*asset).as_side_effect().await?;\n+        }\n+    }\n+    Ok(())\n+}\n+\n+#[turbo_tasks::function(operation)]\n+pub async fn emit_assets_into_dir_operation(\n+    assets: ResolvedVc<ExpandedOutputAssets>,\n+    output_dir: FileSystemPath,\n+) -> Result<Vc<()>> {\n+    emit_assets_into_dir(*assets, output_dir)\n+        .as_side_effect()\n+        .await?;\n+    Ok(Vc::cell(()))\n+}\n+\n /// Replaces the externals in the result with `ExternalModuleAsset` instances.\n pub async fn replace_external(\n     name: &RcStr,"
        }
    ],
    "stats": {
        "total": 2713,
        "additions": 1377,
        "deletions": 1336
    }
}