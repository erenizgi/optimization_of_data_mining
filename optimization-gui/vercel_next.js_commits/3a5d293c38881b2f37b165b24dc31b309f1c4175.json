{
    "author": "bgw",
    "message": "feat(turbopack): Log anonymized internal error (panic) information to telemetry (#81272)\n\n## Goals\n\n- Pass through a custom `TurbopackInternalError` type when a Rust panic or an unexpected top-level `anyhow::Error` occurs.\n- Make a best-effort attempt to log a location of the error to telemetry.\n  - In the case of a panic, we should have the file, line, and column where the panic occured. This could be obscured inside of a helper method, but it's better than nothing. Since this is a position in Turbopack's source code, there's zero risk of user data being included here, so it should be safe to log to telemetry.\n\n## How it works\n\nIn previous PRs, @wbinnssmith did the following:\n- Added a thread-local for storing the most recent panic information in Rust\n- Added `catch_unwind` logic to intercept the panic in turbo-tasks and read the thread-local information, with care take to make sure we're reading from the same thread (not across an `await` boundary).\n- Added a custom `std::error::Error` type for internal errors, with support for storing information about a source panic.\n- Ensured we set up `Error::source` correctly everywhere so that you can trace an error back to the root cause (presumably a panic).\n\nIn #80881, I added a `NextTurbopackContext` type that we can extend to store additional helpers on.\n\nIn this PR:\n- Adds a callback to the `Project` constructor called `throwTurbopackInternalError` that constructs and throws a custom `TurbopackInternalError`. The definition of `TurbopackInternalError` must be in JS, as we cannot reasonably define the error subclass using NAPI.\n- Wraps the callback in a `ThreadsafeFunction` so that it can be called in any of our async functions.\n- Replaces all the places we were previously converting to `napi::Error` with logic to run `throwTurbopackInternalError`.\n\nIn a subsequent PR, we could move more of the panic handling into JS using `throwTurbopackInternalError`.\n\n## Testing\n\nAdded a panic and ran:\n\n```\nNEXT_TELEMETRY_DEBUG=1 pnpm next dev --turbopack examples/basic-css/\n```\n\n<img src=\"https://graphite-user-uploaded-assets-prod.s3.amazonaws.com/HAZVitxRNnZz8QMiPn4a/7f261d3f-351e-436a-9345-fd6e9056d20c.png\" width=\"600\">",
    "sha": "3a5d293c38881b2f37b165b24dc31b309f1c4175",
    "files": [
        {
            "sha": "6071641eae8f538d11e6fa525d04a9e504604bc4",
            "filename": "Cargo.lock",
            "status": "modified",
            "additions": 5,
            "deletions": 4,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/3a5d293c38881b2f37b165b24dc31b309f1c4175/Cargo.lock",
            "raw_url": "https://github.com/vercel/next.js/raw/3a5d293c38881b2f37b165b24dc31b309f1c4175/Cargo.lock",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/Cargo.lock?ref=3a5d293c38881b2f37b165b24dc31b309f1c4175",
            "patch": "@@ -2321,9 +2321,9 @@ checksum = \"e6d5a32815ae3f33302d95fdcb2ce17862f8c65363dcfd29360480ba1001fc9c\"\n \n [[package]]\n name = \"futures\"\n-version = \"0.3.30\"\n+version = \"0.3.31\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"645c6916888f6cb6350d2550b80fb63e734897a8498abe35cfb732b6487804b0\"\n+checksum = \"65bc07b1a8bc7c85c5f2e110c476c7389b4554ba72af57d8445ea63a576b0876\"\n dependencies = [\n  \"futures-channel\",\n  \"futures-core\",\n@@ -2352,9 +2352,9 @@ checksum = \"05f29059c0c2090612e8d742178b0580d2dc940c837851ad723096f87af6663e\"\n \n [[package]]\n name = \"futures-executor\"\n-version = \"0.3.30\"\n+version = \"0.3.31\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a576fc72ae164fca6b9db127eaa9a9dda0d61316034f33a0a0d4eda41f02b01d\"\n+checksum = \"1e28d1d997f585e54aebc3f97d39e72338912123a67330d723fdbb564d646c9f\"\n dependencies = [\n  \"futures-core\",\n  \"futures-task\",\n@@ -4415,6 +4415,7 @@ dependencies = [\n  \"console-subscriber\",\n  \"dhat\",\n  \"either\",\n+ \"futures-util\",\n  \"getrandom 0.2.15\",\n  \"iana-time-zone\",\n  \"lightningcss-napi\","
        },
        {
            "sha": "62387d2a26980fdea7b93978c19a6af3e485d18a",
            "filename": "Cargo.toml",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/3a5d293c38881b2f37b165b24dc31b309f1c4175/Cargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/3a5d293c38881b2f37b165b24dc31b309f1c4175/Cargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/Cargo.toml?ref=3a5d293c38881b2f37b165b24dc31b309f1c4175",
            "patch": "@@ -349,7 +349,8 @@ dhat = { version = \"0.3.2\" }\n dunce = \"1.0.3\"\n either = \"1.9.0\"\n erased-serde = \"0.4.5\"\n-futures = \"0.3.26\"\n+futures = \"0.3.31\"\n+futures-util = \"0.3.31\"\n futures-retry = \"0.6.0\"\n hashbrown = \"0.14.5\"\n image = { version = \"0.25.0\", default-features = false }"
        },
        {
            "sha": "74b7f2e57e45b5a193d5dbb4ac68c2145911d12a",
            "filename": "crates/napi/Cargo.toml",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/3a5d293c38881b2f37b165b24dc31b309f1c4175/crates%2Fnapi%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/3a5d293c38881b2f37b165b24dc31b309f1c4175/crates%2Fnapi%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnapi%2FCargo.toml?ref=3a5d293c38881b2f37b165b24dc31b309f1c4175",
            "patch": "@@ -58,6 +58,7 @@ anyhow = \"1.0.66\"\n console-subscriber = { workspace = true, optional = true }\n dhat = { workspace = true, optional = true }\n either = { workspace = true }\n+futures-util = { workspace = true }\n owo-colors = { workspace = true }\n napi = { workspace = true }\n napi-derive = \"2\""
        },
        {
            "sha": "01f7cba26e57fb3a9e25df44d1e58fc91282681d",
            "filename": "crates/napi/src/next_api/endpoint.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 3,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/3a5d293c38881b2f37b165b24dc31b309f1c4175/crates%2Fnapi%2Fsrc%2Fnext_api%2Fendpoint.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3a5d293c38881b2f37b165b24dc31b309f1c4175/crates%2Fnapi%2Fsrc%2Fnext_api%2Fendpoint.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnapi%2Fsrc%2Fnext_api%2Fendpoint.rs?ref=3a5d293c38881b2f37b165b24dc31b309f1c4175",
            "patch": "@@ -1,6 +1,7 @@\n use std::{ops::Deref, sync::Arc};\n \n use anyhow::Result;\n+use futures_util::TryFutureExt;\n use napi::{JsFunction, bindgen_prelude::External};\n use next_api::{\n     operation::OptionEndpoint,\n@@ -12,7 +13,7 @@ use next_api::{\n };\n use tracing::Instrument;\n use turbo_tasks::{Completion, Effects, OperationVc, ReadRef, Vc};\n-use turbopack_core::{diagnostics::PlainDiagnostic, error::PrettyPrintError, issue::PlainIssue};\n+use turbopack_core::{diagnostics::PlainDiagnostic, issue::PlainIssue};\n \n use super::utils::{\n     DetachedVc, NapiDiagnostic, NapiIssue, RootTask, TurbopackResult,\n@@ -125,6 +126,7 @@ async fn get_written_endpoint_with_issues_operation(\n pub async fn endpoint_write_to_disk(\n     #[napi(ts_arg_type = \"{ __napiType: \\\"Endpoint\\\" }\")] endpoint: External<ExternalEndpoint>,\n ) -> napi::Result<TurbopackResult<NapiWrittenEndpoint>> {\n+    let ctx = endpoint.turbopack_ctx();\n     let endpoint_op = ***endpoint;\n     let (written, issues, diags) = endpoint\n         .turbopack_ctx()\n@@ -144,8 +146,8 @@ pub async fn endpoint_write_to_disk(\n \n             Ok((written.clone(), issues.clone(), diagnostics.clone()))\n         })\n-        .await\n-        .map_err(|e| napi::Error::from_reason(PrettyPrintError(&e).to_string()))?;\n+        .or_else(|e| ctx.throw_turbopack_internal_result(&e))\n+        .await?;\n     Ok(TurbopackResult {\n         result: NapiWrittenEndpoint::from(written.map(ReadRef::into_owned)),\n         issues: issues.iter().map(|i| NapiIssue::from(&**i)).collect(),"
        },
        {
            "sha": "2d045a831d017e104d3a03bd160bb45f0465afa6",
            "filename": "crates/napi/src/next_api/project.rs",
            "status": "modified",
            "additions": 160,
            "deletions": 150,
            "changes": 310,
            "blob_url": "https://github.com/vercel/next.js/blob/3a5d293c38881b2f37b165b24dc31b309f1c4175/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3a5d293c38881b2f37b165b24dc31b309f1c4175/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs?ref=3a5d293c38881b2f37b165b24dc31b309f1c4175",
            "patch": "@@ -1,8 +1,9 @@\n use std::{borrow::Cow, io::Write, path::PathBuf, sync::Arc, thread, time::Duration};\n \n use anyhow::{Context, Result, anyhow, bail};\n+use futures_util::TryFutureExt;\n use napi::{\n-    JsFunction, Status,\n+    Env, JsFunction, JsObject, Status,\n     bindgen_prelude::{External, within_runtime_if_available},\n     threadsafe_function::{ThreadsafeFunction, ThreadsafeFunctionCallMode},\n };\n@@ -62,7 +63,10 @@ use url::Url;\n use crate::{\n     next_api::{\n         endpoint::ExternalEndpoint,\n-        turbopack_ctx::{NextTurboTasks, NextTurbopackContext, create_turbo_tasks},\n+        turbopack_ctx::{\n+            NapiNextTurbopackCallbacks, NapiNextTurbopackCallbacksJsObject, NextTurboTasks,\n+            NextTurbopackContext, create_turbo_tasks,\n+        },\n         utils::{\n             DetachedVc, NapiDiagnostic, NapiIssue, RootTask, TurbopackResult, get_diagnostics,\n             get_issues, subscribe,\n@@ -330,143 +334,149 @@ pub struct ProjectInstance {\n }\n \n #[napi(ts_return_type = \"Promise<{ __napiType: \\\"Project\\\" }>\")]\n-pub async fn project_new(\n+pub fn project_new(\n+    env: Env,\n     options: NapiProjectOptions,\n     turbo_engine_options: NapiTurboEngineOptions,\n-) -> napi::Result<External<ProjectInstance>> {\n-    register();\n-    let (exit, exit_receiver) = ExitHandler::new_receiver();\n-\n-    if let Some(dhat_profiler) = DhatProfilerGuard::try_init() {\n-        exit.on_exit(async move {\n-            tokio::task::spawn_blocking(move || drop(dhat_profiler))\n-                .await\n-                .unwrap()\n-        });\n-    }\n+    napi_callbacks: NapiNextTurbopackCallbacksJsObject,\n+) -> napi::Result<JsObject> {\n+    let napi_callbacks = NapiNextTurbopackCallbacks::from_js(napi_callbacks)?;\n+    env.spawn_future(async move {\n+        register();\n+        let (exit, exit_receiver) = ExitHandler::new_receiver();\n+\n+        if let Some(dhat_profiler) = DhatProfilerGuard::try_init() {\n+            exit.on_exit(async move {\n+                tokio::task::spawn_blocking(move || drop(dhat_profiler))\n+                    .await\n+                    .unwrap()\n+            });\n+        }\n \n-    let mut trace = std::env::var(\"NEXT_TURBOPACK_TRACING\")\n-        .ok()\n-        .filter(|v| !v.is_empty());\n+        let mut trace = std::env::var(\"NEXT_TURBOPACK_TRACING\")\n+            .ok()\n+            .filter(|v| !v.is_empty());\n \n-    if cfg!(feature = \"tokio-console\") && trace.is_none() {\n-        // ensure `trace` is set to *something* so that the `tokio-console` feature works, otherwise\n-        // you just get empty output from `tokio-console`, which can be confusing.\n-        trace = Some(\"overview\".to_owned());\n-    }\n+        if cfg!(feature = \"tokio-console\") && trace.is_none() {\n+            // ensure `trace` is set to *something* so that the `tokio-console` feature works,\n+            // otherwise you just get empty output from `tokio-console`, which can be\n+            // confusing.\n+            trace = Some(\"overview\".to_owned());\n+        }\n \n-    if let Some(mut trace) = trace {\n-        // Trace presets\n-        match trace.as_str() {\n-            \"overview\" | \"1\" => {\n-                trace = TRACING_NEXT_OVERVIEW_TARGETS.join(\",\");\n-            }\n-            \"next\" => {\n-                trace = TRACING_NEXT_TARGETS.join(\",\");\n-            }\n-            \"turbopack\" => {\n-                trace = TRACING_NEXT_TURBOPACK_TARGETS.join(\",\");\n+        if let Some(mut trace) = trace {\n+            // Trace presets\n+            match trace.as_str() {\n+                \"overview\" | \"1\" => {\n+                    trace = TRACING_NEXT_OVERVIEW_TARGETS.join(\",\");\n+                }\n+                \"next\" => {\n+                    trace = TRACING_NEXT_TARGETS.join(\",\");\n+                }\n+                \"turbopack\" => {\n+                    trace = TRACING_NEXT_TURBOPACK_TARGETS.join(\",\");\n+                }\n+                \"turbo-tasks\" => {\n+                    trace = TRACING_NEXT_TURBO_TASKS_TARGETS.join(\",\");\n+                }\n+                _ => {}\n             }\n-            \"turbo-tasks\" => {\n-                trace = TRACING_NEXT_TURBO_TASKS_TARGETS.join(\",\");\n+\n+            let subscriber = Registry::default();\n+\n+            if cfg!(feature = \"tokio-console\") {\n+                trace = format!(\"{trace},tokio=trace,runtime=trace\");\n             }\n-            _ => {}\n-        }\n+            #[cfg(feature = \"tokio-console\")]\n+            let subscriber = subscriber.with(console_subscriber::spawn());\n \n-        let subscriber = Registry::default();\n+            let subscriber = subscriber.with(FilterLayer::try_new(&trace).unwrap());\n \n-        if cfg!(feature = \"tokio-console\") {\n-            trace = format!(\"{trace},tokio=trace,runtime=trace\");\n-        }\n-        #[cfg(feature = \"tokio-console\")]\n-        let subscriber = subscriber.with(console_subscriber::spawn());\n-\n-        let subscriber = subscriber.with(FilterLayer::try_new(&trace).unwrap());\n-\n-        let internal_dir = PathBuf::from(&options.project_path).join(&options.dist_dir);\n-        std::fs::create_dir_all(&internal_dir)\n-            .context(\"Unable to create .next directory\")\n-            .unwrap();\n-        let trace_file = internal_dir.join(\"trace-turbopack\");\n-        let trace_writer = std::fs::File::create(trace_file.clone()).unwrap();\n-        let (trace_writer, trace_writer_guard) = TraceWriter::new(trace_writer);\n-        let subscriber = subscriber.with(RawTraceLayer::new(trace_writer));\n-\n-        exit.on_exit(async move {\n-            tokio::task::spawn_blocking(move || drop(trace_writer_guard))\n-                .await\n+            let internal_dir = PathBuf::from(&options.project_path).join(&options.dist_dir);\n+            std::fs::create_dir_all(&internal_dir)\n+                .context(\"Unable to create .next directory\")\n                 .unwrap();\n-        });\n+            let trace_file = internal_dir.join(\"trace-turbopack\");\n+            let trace_writer = std::fs::File::create(trace_file.clone()).unwrap();\n+            let (trace_writer, trace_writer_guard) = TraceWriter::new(trace_writer);\n+            let subscriber = subscriber.with(RawTraceLayer::new(trace_writer));\n \n-        let trace_server = std::env::var(\"NEXT_TURBOPACK_TRACE_SERVER\").ok();\n-        if trace_server.is_some() {\n-            thread::spawn(move || {\n-                turbopack_trace_server::start_turbopack_trace_server(trace_file);\n+            exit.on_exit(async move {\n+                tokio::task::spawn_blocking(move || drop(trace_writer_guard))\n+                    .await\n+                    .unwrap();\n             });\n-            println!(\"Turbopack trace server started. View trace at https://trace.nextjs.org\");\n+\n+            let trace_server = std::env::var(\"NEXT_TURBOPACK_TRACE_SERVER\").ok();\n+            if trace_server.is_some() {\n+                thread::spawn(move || {\n+                    turbopack_trace_server::start_turbopack_trace_server(trace_file);\n+                });\n+                println!(\"Turbopack trace server started. View trace at https://trace.nextjs.org\");\n+            }\n+\n+            subscriber.init();\n         }\n \n-        subscriber.init();\n-    }\n+        let memory_limit = turbo_engine_options\n+            .memory_limit\n+            .map(|m| m as usize)\n+            .unwrap_or(usize::MAX);\n+        let persistent_caching = turbo_engine_options.persistent_caching.unwrap_or_default();\n+        let dependency_tracking = turbo_engine_options.dependency_tracking.unwrap_or(true);\n+        let is_ci = turbo_engine_options.is_ci.unwrap_or(false);\n+        let turbo_tasks = create_turbo_tasks(\n+            PathBuf::from(&options.dist_dir),\n+            persistent_caching,\n+            memory_limit,\n+            dependency_tracking,\n+            is_ci,\n+        )?;\n+        let turbopack_ctx = NextTurbopackContext::new(turbo_tasks.clone(), napi_callbacks);\n+\n+        let stats_path = std::env::var_os(\"NEXT_TURBOPACK_TASK_STATISTICS\");\n+        if let Some(stats_path) = stats_path {\n+            let task_stats = turbo_tasks.task_statistics().enable().clone();\n+            exit.on_exit(async move {\n+                tokio::task::spawn_blocking(move || {\n+                    let mut file = std::fs::File::create(&stats_path)\n+                        .with_context(|| format!(\"failed to create or open {stats_path:?}\"))?;\n+                    serde_json::to_writer(&file, &task_stats)\n+                        .context(\"failed to serialize or write task statistics\")?;\n+                    file.flush().context(\"failed to flush file\")\n+                })\n+                .await\n+                .unwrap()\n+                .unwrap();\n+            });\n+        }\n \n-    let memory_limit = turbo_engine_options\n-        .memory_limit\n-        .map(|m| m as usize)\n-        .unwrap_or(usize::MAX);\n-    let persistent_caching = turbo_engine_options.persistent_caching.unwrap_or_default();\n-    let dependency_tracking = turbo_engine_options.dependency_tracking.unwrap_or(true);\n-    let is_ci = turbo_engine_options.is_ci.unwrap_or(false);\n-    let turbo_tasks = create_turbo_tasks(\n-        PathBuf::from(&options.dist_dir),\n-        persistent_caching,\n-        memory_limit,\n-        dependency_tracking,\n-        is_ci,\n-    )?;\n-\n-    let stats_path = std::env::var_os(\"NEXT_TURBOPACK_TASK_STATISTICS\");\n-    if let Some(stats_path) = stats_path {\n-        let task_stats = turbo_tasks.task_statistics().enable().clone();\n-        exit.on_exit(async move {\n-            tokio::task::spawn_blocking(move || {\n-                let mut file = std::fs::File::create(&stats_path)\n-                    .with_context(|| format!(\"failed to create or open {stats_path:?}\"))?;\n-                serde_json::to_writer(&file, &task_stats)\n-                    .context(\"failed to serialize or write task statistics\")?;\n-                file.flush().context(\"failed to flush file\")\n+        let options: ProjectOptions = options.into();\n+        let container = turbo_tasks\n+            .run_once(async move {\n+                let project = ProjectContainer::new(rcstr!(\"next.js\"), options.dev);\n+                let project = project.to_resolved().await?;\n+                project.initialize(options).await?;\n+                Ok(project)\n             })\n-            .await\n-            .unwrap()\n-            .unwrap();\n+            .or_else(|e| turbopack_ctx.throw_turbopack_internal_result(&e))\n+            .await?;\n+\n+        turbo_tasks.spawn_once_task({\n+            let tt = turbo_tasks.clone();\n+            async move {\n+                benchmark_file_io(tt, container.project().node_root().owned().await?)\n+                    .await\n+                    .inspect_err(|err| tracing::warn!(%err, \"failed to benchmark file IO\"))\n+            }\n         });\n-    }\n-    let options: ProjectOptions = options.into();\n-    let container = turbo_tasks\n-        .run_once(async move {\n-            let project = ProjectContainer::new(rcstr!(\"next.js\"), options.dev);\n-            let project = project.to_resolved().await?;\n-            project.initialize(options).await?;\n-            Ok(project)\n-        })\n-        .await\n-        .map_err(|e| napi::Error::from_reason(PrettyPrintError(&e).to_string()))?;\n \n-    turbo_tasks.spawn_once_task({\n-        let tt = turbo_tasks.clone();\n-        async move {\n-            benchmark_file_io(tt, container.project().node_root().owned().await?)\n-                .await\n-                .inspect_err(|err| tracing::warn!(%err, \"failed to benchmark file IO\"))\n-        }\n-    });\n-    Ok(External::new_with_size_hint(\n-        ProjectInstance {\n-            turbopack_ctx: NextTurbopackContext::new(turbo_tasks),\n+        Ok(External::new(ProjectInstance {\n+            turbopack_ctx,\n             container,\n             exit_receiver: tokio::sync::Mutex::new(Some(exit_receiver)),\n-        },\n-        100,\n-    ))\n+        }))\n+    })\n }\n \n #[derive(Debug, Clone, Serialize)]\n@@ -571,18 +581,16 @@ pub async fn project_update(\n     #[napi(ts_arg_type = \"{ __napiType: \\\"Project\\\" }\")] project: External<ProjectInstance>,\n     options: NapiPartialProjectOptions,\n ) -> napi::Result<()> {\n+    let ctx = &project.turbopack_ctx;\n     let options = options.into();\n     let container = project.container;\n-    project\n-        .turbopack_ctx\n-        .turbo_tasks()\n+    ctx.turbo_tasks()\n         .run_once(async move {\n             container.update(options).await?;\n             Ok(())\n         })\n+        .or_else(|e| ctx.throw_turbopack_internal_result(&e))\n         .await\n-        .map_err(|e| napi::Error::from_reason(PrettyPrintError(&e).to_string()))?;\n-    Ok(())\n }\n \n /// Invalidates the persistent cache so that it will be deleted next time that a turbopack project\n@@ -876,12 +884,12 @@ pub async fn project_write_all_entrypoints_to_disk(\n     #[napi(ts_arg_type = \"{ __napiType: \\\"Project\\\" }\")] project: External<ProjectInstance>,\n     app_dir_only: bool,\n ) -> napi::Result<TurbopackResult<NapiEntrypoints>> {\n+    let ctx = &project.turbopack_ctx;\n     let container = project.container;\n-    let tt = project.turbopack_ctx.turbo_tasks().clone();\n+    let tt = ctx.turbo_tasks();\n+    let tt_clone = tt.clone();\n \n-    let (entrypoints, issues, diags) = project\n-        .turbopack_ctx\n-        .turbo_tasks()\n+    let (entrypoints, issues, diags) = tt\n         .run_once(async move {\n             let entrypoints_with_issues_op =\n                 get_all_written_entrypoints_with_issues_operation(container, app_dir_only);\n@@ -903,15 +911,15 @@ pub async fn project_write_all_entrypoints_to_disk(\n             effects.apply().await?;\n \n             // Send a compilation event to indicate that the files have been written to disk\n-            tt.send_compilation_event(Arc::new(TimingEvent::new(\n+            tt_clone.send_compilation_event(Arc::new(TimingEvent::new(\n                 \"Finished writing to disk\".to_owned(),\n                 now.elapsed(),\n             )));\n \n             Ok((entrypoints.clone(), issues.clone(), diagnostics.clone()))\n         })\n-        .await\n-        .map_err(|e| napi::Error::from_reason(PrettyPrintError(&e).to_string()))?;\n+        .or_else(|e| ctx.throw_turbopack_internal_result(&e))\n+        .await?;\n \n     Ok(TurbopackResult {\n         result: NapiEntrypoints::from_entrypoints_op(&entrypoints, &project.turbopack_ctx)?,\n@@ -1560,21 +1568,23 @@ pub async fn project_trace_source(\n     current_directory_file_url: String,\n ) -> napi::Result<Option<StackFrame>> {\n     let container = project.container;\n-    let traced_frame = project\n-        .turbopack_ctx\n-        .turbo_tasks()\n+    let ctx = &project.turbopack_ctx;\n+    ctx.turbo_tasks()\n         .run_once(async move {\n-            project_trace_source_operation(\n+            let traced_frame = project_trace_source_operation(\n                 container,\n                 frame,\n                 RcStr::from(current_directory_file_url),\n             )\n             .read_strongly_consistent()\n-            .await\n+            .await?;\n+            Ok(ReadRef::into_owned(traced_frame))\n         })\n+        // HACK: Don't use `TurbopackInternalError`, this function is race-condition prone (the\n+        // source files may have changed or been deleted), so these probably aren't internal errors?\n+        // Ideally we should differentiate.\n         .await\n-        .map_err(|e| napi::Error::from_reason(PrettyPrintError(&e).to_string()))?;\n-    Ok(ReadRef::into_owned(traced_frame))\n+        .map_err(|e| napi::Error::from_reason(PrettyPrintError(&e).to_string()))\n }\n \n #[napi]\n@@ -1583,9 +1593,8 @@ pub async fn project_get_source_for_asset(\n     file_path: RcStr,\n ) -> napi::Result<Option<String>> {\n     let container = project.container;\n-    let source = project\n-        .turbopack_ctx\n-        .turbo_tasks()\n+    let ctx = &project.turbopack_ctx;\n+    ctx.turbo_tasks()\n         .run_once(async move {\n             let source_content = &*container\n                 .project()\n@@ -1604,10 +1613,11 @@ pub async fn project_get_source_for_asset(\n \n             Ok(Some(source_content.content().to_str()?.into_owned()))\n         })\n+        // HACK: Don't use `TurbopackInternalError`, this function is race-condition prone (the\n+        // source files may have changed or been deleted), so these probably aren't internal errors?\n+        // Ideally we should differentiate.\n         .await\n-        .map_err(|e| napi::Error::from_reason(PrettyPrintError(&e).to_string()))?;\n-\n-    Ok(source)\n+        .map_err(|e| napi::Error::from_reason(PrettyPrintError(&e).to_string()))\n }\n \n #[napi]\n@@ -1616,9 +1626,8 @@ pub async fn project_get_source_map(\n     file_path: RcStr,\n ) -> napi::Result<Option<String>> {\n     let container = project.container;\n-    let source_map = project\n-        .turbopack_ctx\n-        .turbo_tasks()\n+    let ctx = &project.turbopack_ctx;\n+    ctx.turbo_tasks()\n         .run_once(async move {\n             let Some(map) = &*get_source_map_rope_operation(container, file_path)\n                 .read_strongly_consistent()\n@@ -1628,10 +1637,11 @@ pub async fn project_get_source_map(\n             };\n             Ok(Some(map.to_str()?.to_string()))\n         })\n+        // HACK: Don't use `TurbopackInternalError`, this function is race-condition prone (the\n+        // source files may have changed or been deleted), so these probably aren't internal errors?\n+        // Ideally we should differentiate.\n         .await\n-        .map_err(|e| napi::Error::from_reason(PrettyPrintError(&e).to_string()))?;\n-\n-    Ok(source_map)\n+        .map_err(|e| napi::Error::from_reason(PrettyPrintError(&e).to_string()))\n }\n \n #[napi]"
        },
        {
            "sha": "f728b1700397b2be6148e86ea350e91021b9ec87",
            "filename": "crates/napi/src/next_api/turbopack_ctx.rs",
            "status": "modified",
            "additions": 260,
            "deletions": 6,
            "changes": 266,
            "blob_url": "https://github.com/vercel/next.js/blob/3a5d293c38881b2f37b165b24dc31b309f1c4175/crates%2Fnapi%2Fsrc%2Fnext_api%2Fturbopack_ctx.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3a5d293c38881b2f37b165b24dc31b309f1c4175/crates%2Fnapi%2Fsrc%2Fnext_api%2Fturbopack_ctx.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnapi%2Fsrc%2Fnext_api%2Fturbopack_ctx.rs?ref=3a5d293c38881b2f37b165b24dc31b309f1c4175",
            "patch": "@@ -1,48 +1,182 @@\n //! Utilities for constructing and using the [`NextTurbopackContext`] type.\n \n-use std::{path::PathBuf, sync::Arc};\n+use std::{\n+    env,\n+    fs::OpenOptions,\n+    io::{self, BufRead, Write},\n+    path::PathBuf,\n+    sync::{Arc, Mutex},\n+    time::Instant,\n+};\n \n use anyhow::Result;\n use either::Either;\n+use napi::{JsFunction, threadsafe_function::ThreadsafeFunction};\n+use once_cell::sync::Lazy;\n+use owo_colors::OwoColorize;\n use serde::Serialize;\n+use terminal_hyperlink::Hyperlink;\n use turbo_tasks::{\n     TurboTasks, TurboTasksApi,\n+    backend::TurboTasksExecutionError,\n     message_queue::{CompilationEvent, Severity},\n };\n use turbo_tasks_backend::{\n     BackendOptions, DefaultBackingStorage, GitVersionInfo, NoopBackingStorage, StartupCacheState,\n     TurboTasksBackend, db_invalidation::invalidation_reasons, default_backing_storage,\n     noop_backing_storage,\n };\n+use turbopack_core::error::PrettyPrintError;\n \n pub type NextTurboTasks =\n     Arc<TurboTasks<TurboTasksBackend<Either<DefaultBackingStorage, NoopBackingStorage>>>>;\n \n-/// A value often wrapped in [`napi::bindgen_prelude::External`] that retains the Turbopack instance\n-/// used by Next.js, and various napi helpers that may have been passed to us from JS.\n+/// A value often wrapped in [`napi::bindgen_prelude::External`] that retains the [TurboTasks]\n+/// instance used by Next.js, and [various napi helpers that are passed to us from\n+/// JavaScript][NapiNextTurbopackCallbacks].\n ///\n /// This is not a [`turbo_tasks::value`], and should only be used within the top-level napi layer.\n /// It should not be passed to a [`turbo_tasks::function`]. For serializable information about the\n-/// project, use the [`next_api::project::Project`] type.\n+/// project, use the [`next_api::project::Project`] type instead.\n+///\n+/// This type is a wrapper around an [`Arc`] and is therefore cheaply clonable. It is [`Send`] and\n+/// [`Sync`].\n #[derive(Clone)]\n pub struct NextTurbopackContext {\n     inner: Arc<NextTurboContextInner>,\n }\n \n struct NextTurboContextInner {\n     turbo_tasks: NextTurboTasks,\n+    napi_callbacks: NapiNextTurbopackCallbacks,\n }\n \n impl NextTurbopackContext {\n-    pub fn new(turbo_tasks: NextTurboTasks) -> Self {\n+    pub fn new(turbo_tasks: NextTurboTasks, napi_callbacks: NapiNextTurbopackCallbacks) -> Self {\n         NextTurbopackContext {\n-            inner: Arc::new(NextTurboContextInner { turbo_tasks }),\n+            inner: Arc::new(NextTurboContextInner {\n+                turbo_tasks,\n+                napi_callbacks,\n+            }),\n         }\n     }\n \n     pub fn turbo_tasks(&self) -> &NextTurboTasks {\n         &self.inner.turbo_tasks\n     }\n+\n+    /// Constructs and throws a `TurbopackInternalError` from within JavaScript. This type is\n+    /// defined within Next.js, and passed via [`NapiNextTurbopackCallbacks`]. This should be called\n+    /// at the top level (a `napi` function) and only for errors that are not expected to occur an\n+    /// indicate a bug in Turbopack or Next.js.\n+    ///\n+    /// This may log anonymized information about the error to our telemetry service (via the\n+    /// JS callback). It may log to stderr and write a log file to disk (in Rust), subject to\n+    /// throttling.\n+    ///\n+    /// The caller should exit immediately with the returned [`napi::Error`] after calling this, as\n+    /// it sets a pending exception.\n+    ///\n+    /// The returned future does not depend on the lifetime of `&self` or `&err`, making it easier\n+    /// to compose with [`futures_util::TryFutureExt`] and similar utilities.\n+    pub fn throw_turbopack_internal_error(\n+        &self,\n+        err: &anyhow::Error,\n+    ) -> impl Future<Output = napi::Error> + use<> {\n+        let this = self.clone();\n+        let message = PrettyPrintError(err).to_string();\n+        let downcast_root_cause_err = err.root_cause().downcast_ref::<TurboTasksExecutionError>();\n+        let panic_location =\n+            if let Some(TurboTasksExecutionError::Panic(p)) = downcast_root_cause_err {\n+                p.location.clone()\n+            } else {\n+                None\n+            };\n+\n+        log_internal_error_and_inform(err);\n+\n+        async move {\n+            this.inner\n+                .napi_callbacks\n+                .throw_turbopack_internal_error\n+                .call_async::<()>(Ok(TurbopackInternalErrorOpts {\n+                    message,\n+                    anonymized_location: panic_location,\n+                }))\n+                .await\n+                .expect_err(\"throwTurbopackInternalError must throw an error\")\n+        }\n+    }\n+\n+    /// A utility method that calls [`NextTurbopackContext::throw_turbopack_internal_error`] and\n+    /// wraps the [`napi::Error`] in a [`napi::Result`].\n+    ///\n+    /// The returned future does not depend on the lifetime of `&self` or `&err`, making it easier\n+    /// to compose with [`futures_util::TryFutureExt::or_else`].\n+    ///\n+    /// The returned type uses a generic (`T`), but should be a never type (`!`) once that nightly\n+    /// feature is stabilized.\n+    pub fn throw_turbopack_internal_result<T>(\n+        &self,\n+        err: &anyhow::Error,\n+    ) -> impl Future<Output = napi::Result<T>> + use<T> {\n+        let err_fut = self.throw_turbopack_internal_error(err);\n+        async move { Err(err_fut.await) }\n+    }\n+}\n+\n+/// A version of [`NapiNextTurbopackCallbacks`] that can accepted as an argument to a napi function.\n+///\n+/// This can be converted into a [`NapiNextTurbopackCallbacks`] with\n+/// [`NapiNextTurbopackCallbacks::from_js`].\n+#[napi(object)]\n+pub struct NapiNextTurbopackCallbacksJsObject {\n+    /// Called when we've encountered a bug in Turbopack and not in the user's code. Constructs and\n+    /// throws a `TurbopackInternalError` type. Logs to anonymized telemetry.\n+    ///\n+    /// As a result of the use of `ErrorStrategy::CalleeHandled`, the first argument is an error if\n+    /// there's a runtime conversion error. This should never happen, but if it does, the function\n+    /// can throw it instead.\n+    #[napi(ts_type = \"(conversionError: Error | null, opts: TurbopackInternalErrorOpts) => never\")]\n+    pub throw_turbopack_internal_error: JsFunction,\n+}\n+\n+/// A collection of helper JavaScript functions passed into\n+/// [`crate::next_api::project::project_new`] and stored in the [`NextTurbopackContext`].\n+///\n+/// This type is [`Send`] and [`Sync`]. Callbacks are wrapped in [`ThreadsafeFunction`].\n+pub struct NapiNextTurbopackCallbacks {\n+    // It's a little nasty to use a `ThreadsafeFunction` for this, but we don't expect exceptions\n+    // to be a hot codepath.\n+    //\n+    // More ideally, we'd convert the error type in the JS thread after the execution of the future\n+    // when resolving the JS `Promise` object. However, doing that would add a lot more boilerplate\n+    // to all of our async entrypoints, and would be complicated by `FunctionRef` being `!Send` (I\n+    // think it could be `Send`, as long as `napi::Env` is checked at call-time, which it should be\n+    // anyways).\n+    throw_turbopack_internal_error: ThreadsafeFunction<TurbopackInternalErrorOpts>,\n+}\n+\n+/// Arguments for [`NapiNextTurbopackCallbacks::throw_turbopack_internal_error`].\n+#[napi(object)]\n+pub struct TurbopackInternalErrorOpts {\n+    pub message: String,\n+    pub anonymized_location: Option<String>,\n+}\n+\n+impl NapiNextTurbopackCallbacks {\n+    pub fn from_js(obj: NapiNextTurbopackCallbacksJsObject) -> napi::Result<Self> {\n+        Ok(NapiNextTurbopackCallbacks {\n+            throw_turbopack_internal_error: obj\n+                .throw_turbopack_internal_error\n+                .create_threadsafe_function(0, |ctx| {\n+                    // Avoid unpacking the struct into positional arguments, we really want to make\n+                    // sure we don't incorrectly order arguments and accidentally log a potentially\n+                    // PII-containing message in anonymized telemetry.\n+                    Ok(vec![ctx.value])\n+                })?,\n+        })\n+    }\n }\n \n pub fn create_turbo_tasks(\n@@ -120,3 +254,123 @@ impl CompilationEvent for StartupCacheInvalidationEvent {\n         serde_json::to_string(self).unwrap()\n     }\n }\n+\n+static LOG_THROTTLE: Mutex<Option<Instant>> = Mutex::new(None);\n+static LOG_DIVIDER: &str = \"---------------------------\";\n+static PANIC_LOG: Lazy<PathBuf> = Lazy::new(|| {\n+    let mut path = env::temp_dir();\n+    path.push(format!(\"next-panic-{:x}.log\", rand::random::<u128>()));\n+    path\n+});\n+\n+/// Log the error to stderr and write a log file to disk, subject to throttling.\n+//\n+// TODO: Now that we're passing the error to a JS callback, handle this logic in Next.js using the\n+// logger there instead of writing directly to stderr.\n+pub fn log_internal_error_and_inform(internal_error: &anyhow::Error) {\n+    if cfg!(debug_assertions)\n+        || env::var(\"SWC_DEBUG\") == Ok(\"1\".to_string())\n+        || env::var(\"CI\").is_ok_and(|v| !v.is_empty())\n+        // Next's run-tests unsets CI and sets NEXT_TEST_CI\n+        || env::var(\"NEXT_TEST_CI\").is_ok_and(|v| !v.is_empty())\n+    {\n+        eprintln!(\n+            \"{}: An unexpected Turbopack error occurred:\\n{}\",\n+            \"FATAL\".red().bold(),\n+            PrettyPrintError(internal_error)\n+        );\n+        return;\n+    }\n+\n+    // hold open this mutex guard to prevent concurrent writes to the file!\n+    let mut last_error_time = LOG_THROTTLE.lock().unwrap();\n+    if let Some(last_error_time) = last_error_time.as_ref()\n+        && last_error_time.elapsed().as_secs() < 1\n+    {\n+        // Throttle panic logging to once per second\n+        return;\n+    }\n+    *last_error_time = Some(Instant::now());\n+\n+    let size = std::fs::metadata(PANIC_LOG.as_path()).map(|m| m.len());\n+    if let Ok(size) = size\n+        && size > 512 * 1024\n+    {\n+        // Truncate the earliest error from log file if it's larger than 512KB\n+        let new_lines = {\n+            let log_read = OpenOptions::new()\n+                .read(true)\n+                .open(PANIC_LOG.as_path())\n+                .unwrap_or_else(|_| panic!(\"Failed to open {}\", PANIC_LOG.to_string_lossy()));\n+\n+            io::BufReader::new(&log_read)\n+                .lines()\n+                .skip(1)\n+                .skip_while(|line| match line {\n+                    Ok(line) => !line.starts_with(LOG_DIVIDER),\n+                    Err(_) => false,\n+                })\n+                .collect::<Vec<_>>()\n+        };\n+\n+        let mut log_write = OpenOptions::new()\n+            .create(true)\n+            .truncate(true)\n+            .write(true)\n+            .open(PANIC_LOG.as_path())\n+            .unwrap_or_else(|_| panic!(\"Failed to open {}\", PANIC_LOG.to_string_lossy()));\n+\n+        for line in new_lines {\n+            match line {\n+                Ok(line) => {\n+                    writeln!(log_write, \"{line}\").unwrap();\n+                }\n+                Err(_) => {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    let mut log_file = OpenOptions::new()\n+        .create(true)\n+        .append(true)\n+        .open(PANIC_LOG.as_path())\n+        .unwrap_or_else(|_| panic!(\"Failed to open {}\", PANIC_LOG.to_string_lossy()));\n+\n+    let internal_error_str: String = PrettyPrintError(internal_error).to_string();\n+    writeln!(log_file, \"{}\\n{}\", LOG_DIVIDER, &internal_error_str).unwrap();\n+\n+    let title = format!(\n+        \"Turbopack Error: {}\",\n+        internal_error_str.lines().next().unwrap_or(\"Unknown\")\n+    );\n+    let version_str = format!(\n+        \"Turbopack version: `{}`\\nNext.js version: `{}`\",\n+        env!(\"VERGEN_GIT_DESCRIBE\"),\n+        env!(\"NEXTJS_VERSION\")\n+    );\n+    let new_discussion_url = if supports_hyperlinks::supports_hyperlinks() {\n+        \"clicking here.\".hyperlink(\n+            format!(\n+                \"https://github.com/vercel/next.js/discussions/new?category=turbopack-error-report&title={}&body={}&labels=Turbopack,Turbopack%20Panic%20Backtrace\",\n+                &urlencoding::encode(&title),\n+                &urlencoding::encode(&format!(\"{}\\n\\nError message:\\n```\\n{}\\n```\", &version_str, &internal_error_str))\n+            )\n+        )\n+    } else {\n+        format!(\n+            \"clicking here: https://github.com/vercel/next.js/discussions/new?category=turbopack-error-report&title={}&body={}&labels=Turbopack,Turbopack%20Panic%20Backtrace\",\n+            &urlencoding::encode(&title),\n+            &urlencoding::encode(&format!(\"{}\\n\\nError message:\\n```\\n{}\\n```\", &version_str, &title))\n+        )\n+    };\n+\n+    eprintln!(\n+        \"\\n-----\\n{}: An unexpected Turbopack error occurred. A panic log has been written to \\\n+         {}.\\n\\nTo help make Turbopack better, report this error by {}\\n-----\\n\",\n+        \"FATAL\".red().bold(),\n+        PANIC_LOG.to_string_lossy(),\n+        &new_discussion_url\n+    );\n+}"
        },
        {
            "sha": "d67ca5b73798bee0a0eb2bef070cd9381a78610f",
            "filename": "crates/napi/src/next_api/utils.rs",
            "status": "modified",
            "additions": 23,
            "deletions": 23,
            "changes": 46,
            "blob_url": "https://github.com/vercel/next.js/blob/3a5d293c38881b2f37b165b24dc31b309f1c4175/crates%2Fnapi%2Fsrc%2Fnext_api%2Futils.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3a5d293c38881b2f37b165b24dc31b309f1c4175/crates%2Fnapi%2Fsrc%2Fnext_api%2Futils.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnapi%2Fsrc%2Fnext_api%2Futils.rs?ref=3a5d293c38881b2f37b165b24dc31b309f1c4175",
            "patch": "@@ -1,6 +1,7 @@\n use std::{future::Future, ops::Deref, sync::Arc};\n \n use anyhow::{Context, Result, anyhow};\n+use futures_util::TryFutureExt;\n use napi::{\n     JsFunction, JsObject, JsUnknown, NapiRaw, NapiValue, Status,\n     bindgen_prelude::{External, ToNapiValue},\n@@ -14,14 +15,13 @@ use turbo_tasks::{\n use turbo_tasks_fs::FileContent;\n use turbopack_core::{\n     diagnostics::{Diagnostic, DiagnosticContextExt, PlainDiagnostic},\n-    error::PrettyPrintError,\n     issue::{\n         IssueDescriptionExt, IssueSeverity, PlainIssue, PlainIssueSource, PlainSource, StyledString,\n     },\n     source_pos::SourcePos,\n };\n \n-use crate::{next_api::turbopack_ctx::NextTurbopackContext, util::log_internal_error_and_inform};\n+use crate::next_api::turbopack_ctx::NextTurbopackContext;\n \n /// An [`OperationVc`] that can be passed back and forth to JS across the [`napi`][mod@napi]\n /// boundary via [`External`].\n@@ -324,35 +324,35 @@ impl<T: ToNapiValue> ToNapiValue for TurbopackResult<T> {\n }\n \n pub fn subscribe<T: 'static + Send + Sync, F: Future<Output = Result<T>> + Send, V: ToNapiValue>(\n-    turbopack_ctx: NextTurbopackContext,\n+    ctx: NextTurbopackContext,\n     func: JsFunction,\n     handler: impl 'static + Sync + Send + Clone + Fn() -> F,\n     mapper: impl 'static + Sync + Send + FnMut(ThreadSafeCallContext<T>) -> napi::Result<Vec<V>>,\n ) -> napi::Result<External<RootTask>> {\n     let func: ThreadsafeFunction<T> = func.create_threadsafe_function(0, mapper)?;\n-    let task_id = turbopack_ctx.turbo_tasks().spawn_root_task(move || {\n-        let handler = handler.clone();\n-        let func = func.clone();\n-        Box::pin(async move {\n-            let result = handler().await;\n-\n-            let status = func.call(\n-                result.map_err(|e| {\n-                    log_internal_error_and_inform(&e);\n-                    napi::Error::from_reason(PrettyPrintError(&e).to_string())\n-                }),\n-                ThreadsafeFunctionCallMode::NonBlocking,\n-            );\n-            if !matches!(status, Status::Ok) {\n-                let error = anyhow!(\"Error calling JS function: {}\", status);\n-                eprintln!(\"{error}\");\n-                return Err::<Vc<()>, _>(error);\n+    let task_id = ctx.turbo_tasks().spawn_root_task({\n+        let ctx = ctx.clone();\n+        move || {\n+            let ctx = ctx.clone();\n+            let handler = handler.clone();\n+            let func = func.clone();\n+            async move {\n+                let result = handler()\n+                    .or_else(|e| ctx.throw_turbopack_internal_result(&e))\n+                    .await;\n+\n+                let status = func.call(result, ThreadsafeFunctionCallMode::NonBlocking);\n+                if !matches!(status, Status::Ok) {\n+                    let error = anyhow!(\"Error calling JS function: {}\", status);\n+                    eprintln!(\"{error}\");\n+                    return Err::<Vc<()>, _>(error);\n+                }\n+                Ok(Default::default())\n             }\n-            Ok(Default::default())\n-        })\n+        }\n     });\n     Ok(External::new(RootTask {\n-        turbopack_ctx,\n+        turbopack_ctx: ctx,\n         task_id: Some(task_id),\n     }))\n }"
        },
        {
            "sha": "e1a9698cd7ada7c4baa8b254ffa366d2ecf89f94",
            "filename": "crates/napi/src/util.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 130,
            "changes": 132,
            "blob_url": "https://github.com/vercel/next.js/blob/3a5d293c38881b2f37b165b24dc31b309f1c4175/crates%2Fnapi%2Fsrc%2Futil.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3a5d293c38881b2f37b165b24dc31b309f1c4175/crates%2Fnapi%2Fsrc%2Futil.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnapi%2Fsrc%2Futil.rs?ref=3a5d293c38881b2f37b165b24dc31b309f1c4175",
            "patch": "@@ -26,140 +26,12 @@ IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n DEALINGS IN THE SOFTWARE.\n */\n \n-use std::{\n-    cell::RefCell,\n-    env,\n-    fs::OpenOptions,\n-    io::{self, BufRead, Write},\n-    path::PathBuf,\n-    sync::Mutex,\n-    time::Instant,\n-};\n+use std::{cell::RefCell, env, path::PathBuf};\n \n use anyhow::anyhow;\n use napi::bindgen_prelude::{External, Status};\n-use once_cell::sync::Lazy;\n-use owo_colors::OwoColorize;\n-use terminal_hyperlink::Hyperlink;\n use tracing_chrome::{ChromeLayerBuilder, FlushGuard};\n-use tracing_subscriber::{Layer, filter, prelude::*, util::SubscriberInitExt};\n-use turbopack_core::error::PrettyPrintError;\n-\n-static LOG_THROTTLE: Mutex<Option<Instant>> = Mutex::new(None);\n-static LOG_DIVIDER: &str = \"---------------------------\";\n-static PANIC_LOG: Lazy<PathBuf> = Lazy::new(|| {\n-    let mut path = env::temp_dir();\n-    path.push(format!(\"next-panic-{:x}.log\", rand::random::<u128>()));\n-    path\n-});\n-\n-pub fn log_internal_error_and_inform(internal_error: &anyhow::Error) {\n-    if cfg!(debug_assertions)\n-        || env::var(\"SWC_DEBUG\") == Ok(\"1\".to_string())\n-        || env::var(\"CI\").is_ok_and(|v| !v.is_empty())\n-        // Next's run-tests unsets CI and sets NEXT_TEST_CI\n-        || env::var(\"NEXT_TEST_CI\").is_ok_and(|v| !v.is_empty())\n-    {\n-        eprintln!(\n-            \"{}: An unexpected Turbopack error occurred:\\n{}\",\n-            \"FATAL\".red().bold(),\n-            PrettyPrintError(internal_error)\n-        );\n-        return;\n-    }\n-\n-    // hold open this mutex guard to prevent concurrent writes to the file!\n-    let mut last_error_time = LOG_THROTTLE.lock().unwrap();\n-    if let Some(last_error_time) = last_error_time.as_ref()\n-        && last_error_time.elapsed().as_secs() < 1\n-    {\n-        // Throttle panic logging to once per second\n-        return;\n-    }\n-    *last_error_time = Some(Instant::now());\n-\n-    let size = std::fs::metadata(PANIC_LOG.as_path()).map(|m| m.len());\n-    if let Ok(size) = size\n-        && size > 512 * 1024\n-    {\n-        // Truncate the earliest error from log file if it's larger than 512KB\n-        let new_lines = {\n-            let log_read = OpenOptions::new()\n-                .read(true)\n-                .open(PANIC_LOG.as_path())\n-                .unwrap_or_else(|_| panic!(\"Failed to open {}\", PANIC_LOG.to_string_lossy()));\n-\n-            io::BufReader::new(&log_read)\n-                .lines()\n-                .skip(1)\n-                .skip_while(|line| match line {\n-                    Ok(line) => !line.starts_with(LOG_DIVIDER),\n-                    Err(_) => false,\n-                })\n-                .collect::<Vec<_>>()\n-        };\n-\n-        let mut log_write = OpenOptions::new()\n-            .create(true)\n-            .truncate(true)\n-            .write(true)\n-            .open(PANIC_LOG.as_path())\n-            .unwrap_or_else(|_| panic!(\"Failed to open {}\", PANIC_LOG.to_string_lossy()));\n-\n-        for line in new_lines {\n-            match line {\n-                Ok(line) => {\n-                    writeln!(log_write, \"{line}\").unwrap();\n-                }\n-                Err(_) => {\n-                    break;\n-                }\n-            }\n-        }\n-    }\n-\n-    let mut log_file = OpenOptions::new()\n-        .create(true)\n-        .append(true)\n-        .open(PANIC_LOG.as_path())\n-        .unwrap_or_else(|_| panic!(\"Failed to open {}\", PANIC_LOG.to_string_lossy()));\n-\n-    let internal_error_str: String = PrettyPrintError(internal_error).to_string();\n-    writeln!(log_file, \"{}\\n{}\", LOG_DIVIDER, &internal_error_str).unwrap();\n-\n-    let title = format!(\n-        \"Turbopack Error: {}\",\n-        internal_error_str.lines().next().unwrap_or(\"Unknown\")\n-    );\n-    let version_str = format!(\n-        \"Turbopack version: `{}`\\nNext.js version: `{}`\",\n-        env!(\"VERGEN_GIT_DESCRIBE\"),\n-        env!(\"NEXTJS_VERSION\")\n-    );\n-    let new_discussion_url = if supports_hyperlinks::supports_hyperlinks() {\n-        \"clicking here.\".hyperlink(\n-            format!(\n-                \"https://github.com/vercel/next.js/discussions/new?category=turbopack-error-report&title={}&body={}&labels=Turbopack,Turbopack%20Panic%20Backtrace\",\n-                &urlencoding::encode(&title),\n-                &urlencoding::encode(&format!(\"{}\\n\\nError message:\\n```\\n{}\\n```\", &version_str, &internal_error_str))\n-            )\n-        )\n-    } else {\n-        format!(\n-            \"clicking here: https://github.com/vercel/next.js/discussions/new?category=turbopack-error-report&title={}&body={}&labels=Turbopack,Turbopack%20Panic%20Backtrace\",\n-            &urlencoding::encode(&title),\n-            &urlencoding::encode(&format!(\"{}\\n\\nError message:\\n```\\n{}\\n```\", &version_str, &title))\n-        )\n-    };\n-\n-    eprintln!(\n-        \"\\n-----\\n{}: An unexpected Turbopack error occurred. A panic log has been written to \\\n-         {}.\\n\\nTo help make Turbopack better, report this error by {}\\n-----\\n\",\n-        \"FATAL\".red().bold(),\n-        PANIC_LOG.to_string_lossy(),\n-        &new_discussion_url\n-    );\n-}\n+use tracing_subscriber::{Layer, filter, layer::SubscriberExt, util::SubscriberInitExt};\n \n #[napi]\n pub fn get_target_triple() -> &'static str {"
        },
        {
            "sha": "6125900a995d34949a6d9a22b3724a00f53d62c5",
            "filename": "packages/next/errors.json",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/3a5d293c38881b2f37b165b24dc31b309f1c4175/packages%2Fnext%2Ferrors.json",
            "raw_url": "https://github.com/vercel/next.js/raw/3a5d293c38881b2f37b165b24dc31b309f1c4175/packages%2Fnext%2Ferrors.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Ferrors.json?ref=3a5d293c38881b2f37b165b24dc31b309f1c4175",
            "patch": "@@ -720,5 +720,6 @@\n   \"719\": \"Failed to get source map for '%s'. This is a bug in Next.js\",\n   \"720\": \"A client prerender store should not be used for a route handler.\",\n   \"721\": \"Render in Browser\",\n-  \"722\": \"Unable to match pathname to a dynamic route\"\n+  \"722\": \"Unable to match pathname to a dynamic route\",\n+  \"723\": \"NAPI type conversion error in throwTurbopackInternalError\"\n }"
        },
        {
            "sha": "85bf4c77681ec2a71f874c24cbd015ec6ff9c918",
            "filename": "packages/next/src/build/swc/generated-native.d.ts",
            "status": "modified",
            "additions": 27,
            "deletions": 1,
            "changes": 28,
            "blob_url": "https://github.com/vercel/next.js/blob/3a5d293c38881b2f37b165b24dc31b309f1c4175/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Fgenerated-native.d.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/3a5d293c38881b2f37b165b24dc31b309f1c4175/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Fgenerated-native.d.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Fgenerated-native.d.ts?ref=3a5d293c38881b2f37b165b24dc31b309f1c4175",
            "patch": "@@ -204,7 +204,8 @@ export interface NapiTurboEngineOptions {\n }\n export declare function projectNew(\n   options: NapiProjectOptions,\n-  turboEngineOptions: NapiTurboEngineOptions\n+  turboEngineOptions: NapiTurboEngineOptions,\n+  napiCallbacks: NapiNextTurbopackCallbacksJsObject\n ): Promise<{ __napiType: 'Project' }>\n export declare function projectUpdate(\n   project: { __napiType: 'Project' },\n@@ -350,6 +351,31 @@ export declare function projectGetSourceMapSync(\n   project: { __napiType: 'Project' },\n   filePath: RcStr\n ): string | null\n+/**\n+ * A version of [`NapiNextTurbopackCallbacks`] that can accepted as an argument to a napi function.\n+ *\n+ * This can be converted into a [`NapiNextTurbopackCallbacks`] with\n+ * [`NapiNextTurbopackCallbacks::from_js`].\n+ */\n+export interface NapiNextTurbopackCallbacksJsObject {\n+  /**\n+   * Called when we've encountered a bug in Turbopack and not in the user's code. Constructs and\n+   * throws a `TurbopackInternalError` type. Logs to anonymized telemetry.\n+   *\n+   * As a result of the use of `ErrorStrategy::CalleeHandled`, the first argument is an error if\n+   * there's a runtime conversion error. This should never happen, but if it does, the function\n+   * can throw it instead.\n+   */\n+  throwTurbopackInternalError: (\n+    conversionError: Error | null,\n+    opts: TurbopackInternalErrorOpts\n+  ) => never\n+}\n+/** Arguments for [`NapiNextTurbopackCallbacks::throw_turbopack_internal_error`]. */\n+export interface TurbopackInternalErrorOpts {\n+  message: string\n+  anonymizedLocation?: string\n+}\n export declare function rootTaskDispose(rootTask: {\n   __napiType: 'RootTask'\n }): void"
        },
        {
            "sha": "1fcdb4887e392cd4a31c56d2d90d930d5ca90451",
            "filename": "packages/next/src/build/swc/generated-wasm.d.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/3a5d293c38881b2f37b165b24dc31b309f1c4175/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Fgenerated-wasm.d.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/3a5d293c38881b2f37b165b24dc31b309f1c4175/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Fgenerated-wasm.d.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Fgenerated-wasm.d.ts?ref=3a5d293c38881b2f37b165b24dc31b309f1c4175",
            "patch": "@@ -3,11 +3,11 @@\n \n /* tslint:disable */\n /* eslint-disable */\n+export function mdxCompileSync(value: string, opts: any): any\n+export function mdxCompile(value: string, opts: any): Promise<any>\n export function minifySync(s: string, opts: any): any\n export function minify(s: string, opts: any): Promise<any>\n export function transformSync(s: any, opts: any): any\n export function transform(s: any, opts: any): Promise<any>\n export function parseSync(s: string, opts: any): any\n export function parse(s: string, opts: any): Promise<any>\n-export function mdxCompileSync(value: string, opts: any): any\n-export function mdxCompile(value: string, opts: any): Promise<any>"
        },
        {
            "sha": "910e9c9fc84f30c083f46fe2b384c98b65223766",
            "filename": "packages/next/src/build/swc/index.ts",
            "status": "modified",
            "additions": 19,
            "deletions": 39,
            "changes": 58,
            "blob_url": "https://github.com/vercel/next.js/blob/3a5d293c38881b2f37b165b24dc31b309f1c4175/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Findex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/3a5d293c38881b2f37b165b24dc31b309f1c4175/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Findex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Findex.ts?ref=3a5d293c38881b2f37b165b24dc31b309f1c4175",
            "patch": "@@ -40,7 +40,7 @@ import type {\n   UpdateMessage,\n   WrittenEndpoint,\n } from './types'\n-import { TurbopackInternalError } from '../../shared/lib/turbopack/utils'\n+import { throwTurbopackInternalError } from '../../shared/lib/turbopack/internal-error'\n \n type RawBindings = typeof import('./generated-native')\n type RawWasmBindings = typeof import('./generated-wasm') & {\n@@ -536,14 +536,6 @@ function bindingToApi(\n     throw new Error(`Invariant: ${computeMessage(never)}`)\n   }\n \n-  async function withErrorCause<T>(fn: () => Promise<T>): Promise<T> {\n-    try {\n-      return await fn()\n-    } catch (nativeError: any) {\n-      throw TurbopackInternalError.createAndRecordTelemetry(nativeError)\n-    }\n-  }\n-\n   /**\n    * Calls a native function and streams the result.\n    * If useBuffer is true, all values will be preserved, potentially buffered\n@@ -589,9 +581,7 @@ function bindingToApi(\n     }\n \n     async function* createIterator() {\n-      const task = await withErrorCause<{ __napiType: 'RootTask' } | void>(() =>\n-        nativeFunction(emitResult)\n-      )\n+      const task = await nativeFunction(emitResult)\n       try {\n         while (!canceled) {\n           if (buffer.length > 0) {\n@@ -607,9 +597,6 @@ function bindingToApi(\n         }\n       } catch (e) {\n         if (e === cancel) return\n-        if (e instanceof Error) {\n-          throw TurbopackInternalError.createAndRecordTelemetry(e)\n-        }\n         throw e\n       } finally {\n         if (task) {\n@@ -662,25 +649,21 @@ function bindingToApi(\n     }\n \n     async update(options: Partial<ProjectOptions>) {\n-      await withErrorCause(async () =>\n-        binding.projectUpdate(\n-          this._nativeProject,\n-          await rustifyPartialProjectOptions(options)\n-        )\n+      await binding.projectUpdate(\n+        this._nativeProject,\n+        await rustifyPartialProjectOptions(options)\n       )\n     }\n \n     async writeAllEntrypointsToDisk(\n       appDirOnly: boolean\n     ): Promise<TurbopackResult<RawEntrypoints>> {\n-      return await withErrorCause(async () => {\n-        const napiEndpoints = (await binding.projectWriteAllEntrypointsToDisk(\n-          this._nativeProject,\n-          appDirOnly\n-        )) as TurbopackResult<NapiEntrypoints>\n+      const napiEndpoints = (await binding.projectWriteAllEntrypointsToDisk(\n+        this._nativeProject,\n+        appDirOnly\n+      )) as TurbopackResult<NapiEntrypoints>\n \n-        return napiEntrypointsToRawEntrypoints(napiEndpoints)\n-      })\n+      return napiEntrypointsToRawEntrypoints(napiEndpoints)\n     }\n \n     entrypointsSubscribe() {\n@@ -777,22 +760,16 @@ function bindingToApi(\n     }\n \n     async writeToDisk(): Promise<TurbopackResult<WrittenEndpoint>> {\n-      return await withErrorCause(\n-        () =>\n-          binding.endpointWriteToDisk(this._nativeEndpoint) as Promise<\n-            TurbopackResult<WrittenEndpoint>\n-          >\n-      )\n+      return (await binding.endpointWriteToDisk(\n+        this._nativeEndpoint\n+      )) as TurbopackResult<WrittenEndpoint>\n     }\n \n     async clientChanged(): Promise<AsyncIterableIterator<TurbopackResult<{}>>> {\n       const clientSubscription = subscribe<TurbopackResult>(\n         false,\n         async (callback) =>\n-          binding.endpointClientChangedSubscribe(\n-            await this._nativeEndpoint,\n-            callback\n-          )\n+          binding.endpointClientChangedSubscribe(this._nativeEndpoint, callback)\n       )\n       await clientSubscription.next()\n       return clientSubscription\n@@ -805,7 +782,7 @@ function bindingToApi(\n         false,\n         async (callback) =>\n           binding.endpointServerChangedSubscribe(\n-            await this._nativeEndpoint,\n+            this._nativeEndpoint,\n             includeIssues,\n             callback\n           )\n@@ -1085,7 +1062,10 @@ function bindingToApi(\n     return new ProjectImpl(\n       await binding.projectNew(\n         await rustifyProjectOptions(options),\n-        turboEngineOptions || {}\n+        turboEngineOptions || {},\n+        {\n+          throwTurbopackInternalError,\n+        }\n       )\n     )\n   }"
        },
        {
            "sha": "a9c10bc0c9ec74a2e7fa14b48c76e8f76f7450b0",
            "filename": "packages/next/src/server/lib/router-utils/setup-dev-bundler.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/3a5d293c38881b2f37b165b24dc31b309f1c4175/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Fsetup-dev-bundler.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/3a5d293c38881b2f37b165b24dc31b309f1c4175/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Fsetup-dev-bundler.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Fsetup-dev-bundler.ts?ref=3a5d293c38881b2f37b165b24dc31b309f1c4175",
            "patch": "@@ -80,9 +80,9 @@ import { store as consoleStore } from '../../../build/output/store'\n import {\n   isPersistentCachingEnabled,\n   ModuleBuildError,\n-  TurbopackInternalError,\n } from '../../../shared/lib/turbopack/utils'\n import { getDefineEnv } from '../../../build/define-env'\n+import { TurbopackInternalError } from '../../../shared/lib/turbopack/internal-error'\n \n export type SetupOpts = {\n   renderServer: LazyRenderServerInstance"
        },
        {
            "sha": "cb4ae633c0956785e914b1a42709301df650e124",
            "filename": "packages/next/src/shared/lib/turbopack/internal-error.ts",
            "status": "added",
            "additions": 50,
            "deletions": 0,
            "changes": 50,
            "blob_url": "https://github.com/vercel/next.js/blob/3a5d293c38881b2f37b165b24dc31b309f1c4175/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fturbopack%2Finternal-error.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/3a5d293c38881b2f37b165b24dc31b309f1c4175/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fturbopack%2Finternal-error.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fturbopack%2Finternal-error.ts?ref=3a5d293c38881b2f37b165b24dc31b309f1c4175",
            "patch": "@@ -0,0 +1,50 @@\n+import type { TurbopackInternalErrorOpts } from '../../../build/swc/generated-native'\n+import { eventErrorThrown } from '../../../telemetry/events'\n+import { traceGlobals } from '../../../trace/shared'\n+\n+/**\n+ * An error caused by a bug in Turbopack, and not the user's code (e.g. a Rust panic). These should\n+ * be written to a log file and details should not be shown to the user.\n+ *\n+ * These are constructed in Turbopack by calling `throwTurbopackInternalError`.\n+ */\n+export class TurbopackInternalError extends Error {\n+  name = 'TurbopackInternalError'\n+  location: string | undefined\n+\n+  // Manually set this as this isn't statically determinable\n+  __NEXT_ERROR_CODE = 'TurbopackInternalError'\n+\n+  constructor({ message, anonymizedLocation }: TurbopackInternalErrorOpts) {\n+    super(message)\n+    this.location = anonymizedLocation\n+  }\n+}\n+\n+/**\n+ * A helper used by the napi Rust entrypoints to construct and throw a `TurbopackInternalError`.\n+ *\n+ * When called, this will emit a telemetry event.\n+ */\n+export function throwTurbopackInternalError(\n+  conversionError: Error | null,\n+  opts: TurbopackInternalErrorOpts\n+): never {\n+  if (conversionError != null) {\n+    // Somehow napi failed to convert `opts` to a JS object??? Just give up and throw that instead.\n+    throw new Error(\n+      'NAPI type conversion error in throwTurbopackInternalError',\n+      {\n+        cause: conversionError,\n+      }\n+    )\n+  }\n+  const err = new TurbopackInternalError(opts)\n+  const telemetry = traceGlobals.get('telemetry')\n+  if (telemetry) {\n+    telemetry.record(eventErrorThrown(err, opts.anonymizedLocation))\n+  } else {\n+    console.error('Expected `telemetry` to be set in globals')\n+  }\n+  throw err\n+}"
        },
        {
            "sha": "88f08d95b7aebd2d8b8bc93f00647a11bf41c36b",
            "filename": "packages/next/src/shared/lib/turbopack/utils.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 31,
            "changes": 35,
            "blob_url": "https://github.com/vercel/next.js/blob/3a5d293c38881b2f37b165b24dc31b309f1c4175/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fturbopack%2Futils.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/3a5d293c38881b2f37b165b24dc31b309f1c4175/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fturbopack%2Futils.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fturbopack%2Futils.ts?ref=3a5d293c38881b2f37b165b24dc31b309f1c4175",
            "patch": "@@ -15,47 +15,20 @@ import type { EntryKey } from './entry-key'\n import * as Log from '../../../build/output/log'\n import type { NextConfigComplete } from '../../../server/config-shared'\n import loadJsConfig from '../../../build/load-jsconfig'\n-import { eventErrorThrown } from '../../../telemetry/events'\n-import { traceGlobals } from '../../../trace/shared'\n \n type IssueKey = `${Issue['severity']}-${Issue['filePath']}-${string}-${string}`\n export type IssuesMap = Map<IssueKey, Issue>\n export type EntryIssuesMap = Map<EntryKey, IssuesMap>\n export type TopLevelIssuesMap = IssuesMap\n \n-// An error generated from emitted Turbopack issues. This can include build\n-// errors caused by issues with user code.\n+/**\n+ * An error generated from emitted Turbopack issues. This can include build\n+ * errors caused by issues with user code.\n+ */\n export class ModuleBuildError extends Error {\n   name = 'ModuleBuildError'\n }\n \n-// An error caused by an internal issue in Turbopack. These should be written\n-// to a log file and details should not be shown to the user.\n-export class TurbopackInternalError extends Error {\n-  name = 'TurbopackInternalError'\n-\n-  // Manually set this as this isn't statically determinable\n-  __NEXT_ERROR_CODE = 'TurbopackInternalError'\n-\n-  static createAndRecordTelemetry(cause: Error) {\n-    const error = new TurbopackInternalError(cause)\n-\n-    const telemetry = traceGlobals.get('telemetry')\n-    if (telemetry) {\n-      telemetry.record(eventErrorThrown(error))\n-    } else {\n-      console.error('Expected `telemetry` to be set in globals')\n-    }\n-\n-    return error\n-  }\n-\n-  constructor(cause: Error) {\n-    super(cause.message)\n-    this.stack = cause.stack\n-  }\n-}\n-\n /**\n  * Thin stopgap workaround layer to mimic existing wellknown-errors-plugin in webpack's build\n  * to emit certain type of errors into cli."
        },
        {
            "sha": "76429e3da90313889d20e8ebb6861ff509199367",
            "filename": "packages/next/src/telemetry/events/build.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 2,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/3a5d293c38881b2f37b165b24dc31b309f1c4175/packages%2Fnext%2Fsrc%2Ftelemetry%2Fevents%2Fbuild.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/3a5d293c38881b2f37b165b24dc31b309f1c4175/packages%2Fnext%2Fsrc%2Ftelemetry%2Fevents%2Fbuild.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Ftelemetry%2Fevents%2Fbuild.ts?ref=3a5d293c38881b2f37b165b24dc31b309f1c4175",
            "patch": "@@ -235,15 +235,24 @@ type ErrorThrownEvent = {\n   eventName: typeof ERROR_THROWN_EVENT\n   payload: {\n     errorCode: string | undefined\n+    location: string | undefined\n   }\n }\n \n-// Creates a Telemetry event for errors. For privacy, only includes the error code.\n-export function eventErrorThrown(error: Error): ErrorThrownEvent {\n+// Creates a Telemetry event for errors. For privacy, only includes the error code and not the error\n+// message.\n+//\n+// `location` may be included if it's a location internal to the next.js source tree (i.e. a\n+// non-absolute path).\n+export function eventErrorThrown(\n+  error: Error,\n+  anonymizedLocation: string | undefined\n+): ErrorThrownEvent {\n   return {\n     eventName: ERROR_THROWN_EVENT,\n     payload: {\n       errorCode: extractNextErrorCode(error) || 'Unknown',\n+      location: anonymizedLocation,\n     },\n   }\n }"
        },
        {
            "sha": "974c2336229ccd8cd4bab6541bdab829550c90b0",
            "filename": "test/unit/TurbopackInternalError.test.ts",
            "status": "modified",
            "additions": 18,
            "deletions": 3,
            "changes": 21,
            "blob_url": "https://github.com/vercel/next.js/blob/3a5d293c38881b2f37b165b24dc31b309f1c4175/test%2Funit%2FTurbopackInternalError.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/3a5d293c38881b2f37b165b24dc31b309f1c4175/test%2Funit%2FTurbopackInternalError.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Funit%2FTurbopackInternalError.test.ts?ref=3a5d293c38881b2f37b165b24dc31b309f1c4175",
            "patch": "@@ -1,12 +1,15 @@\n import path from 'path'\n import os from 'os'\n-import { TurbopackInternalError } from 'next/dist/shared/lib/turbopack/utils'\n+import {\n+  throwTurbopackInternalError,\n+  TurbopackInternalError,\n+} from 'next/dist/shared/lib/turbopack/internal-error'\n import { Telemetry } from 'next/dist/telemetry/storage'\n import { setGlobal } from 'next/dist/trace'\n import { traceGlobals } from 'next/dist/trace/shared'\n \n describe('TurbopackInternalError', () => {\n-  it('sends a telemetry event when TurbopackInternalError.createAndRecordTelemetry() is called', async () => {\n+  it('sends a telemetry event when throwTurbopackInternalError() is called', async () => {\n     const oldTelemetry = traceGlobals.get('telemetry')\n \n     try {\n@@ -18,12 +21,24 @@ describe('TurbopackInternalError', () => {\n         .spyOn(telemetry, 'submitRecord')\n         // @ts-ignore\n         .mockImplementation(() => Promise.resolve())\n-      TurbopackInternalError.createAndRecordTelemetry(new Error('test error'))\n+\n+      let internalError = null\n+      try {\n+        throwTurbopackInternalError(null, {\n+          message: 'test error',\n+          anonymizedLocation: 'file.rs:120:1',\n+        })\n+      } catch (err) {\n+        internalError = err\n+      }\n+\n+      expect(internalError).toBeInstanceOf(TurbopackInternalError)\n \n       expect(submitRecord).toHaveBeenCalledWith({\n         eventName: 'NEXT_ERROR_THROWN',\n         payload: {\n           errorCode: 'TurbopackInternalError',\n+          location: 'file.rs:120:1',\n         },\n       })\n     } finally {"
        },
        {
            "sha": "fc47ffeb3439f945f77d0a67123b9e6ff27729ef",
            "filename": "turbopack/crates/turbo-tasks/src/backend.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/3a5d293c38881b2f37b165b24dc31b309f1c4175/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fbackend.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3a5d293c38881b2f37b165b24dc31b309f1c4175/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fbackend.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fbackend.rs?ref=3a5d293c38881b2f37b165b24dc31b309f1c4175",
            "patch": "@@ -447,7 +447,7 @@ pub enum TurboTasksExecutionError {\n }\n \n impl TurboTasksExecutionError {\n-    pub fn task_context(&self, task: impl Display) -> Self {\n+    pub fn with_task_context(&self, task: impl Display) -> Self {\n         TurboTasksExecutionError::TaskContext(Arc::new(TurboTaskContextError {\n             task: RcStr::from(task.to_string()),\n             source: Some(self.clone()),"
        },
        {
            "sha": "eaa31f420ed5dc0dedc0aa24b45915e76b87ef2c",
            "filename": "turbopack/crates/turbo-tasks/src/manager.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/3a5d293c38881b2f37b165b24dc31b309f1c4175/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3a5d293c38881b2f37b165b24dc31b309f1c4175/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs?ref=3a5d293c38881b2f37b165b24dc31b309f1c4175",
            "patch": "@@ -831,7 +831,7 @@ impl<B: Backend + 'static> TurboTasks<B> {\n                 let local_task = LocalTask::Done {\n                     output: match result {\n                         Ok(raw_vc) => OutputContent::Link(raw_vc),\n-                        Err(err) => OutputContent::Error(err.task_context(task_type)),\n+                        Err(err) => OutputContent::Error(err.with_task_context(task_type)),\n                     },\n                 };\n "
        }
    ],
    "stats": {
        "total": 993,
        "additions": 594,
        "deletions": 399
    }
}