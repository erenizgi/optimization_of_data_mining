{
    "author": "mischnic",
    "message": "Turbopack: simplify `ReducedGraphs` and `find_server_entries` (#81118)\n\n- Renamed `ReducedGraphs` to `GlobalInformation`, these graphs never ended up getting reduced\n- Simplify and rename `VisitClientReference`, as its only remaining use is finding server entries (layout segments), and not client references anymore.",
    "sha": "08bd8fb0f4a6617bba24d3b0aa8f8d9ee3c878f4",
    "files": [
        {
            "sha": "5c01b67c5e526569708e192aa6650b4ab7a6be87",
            "filename": "crates/next-api/src/app.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/08bd8fb0f4a6617bba24d3b0aa8f8d9ee3c878f4/crates%2Fnext-api%2Fsrc%2Fapp.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/08bd8fb0f4a6617bba24d3b0aa8f8d9ee3c878f4/crates%2Fnext-api%2Fsrc%2Fapp.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fapp.rs?ref=08bd8fb0f4a6617bba24d3b0aa8f8d9ee3c878f4",
            "patch": "@@ -76,7 +76,7 @@ use crate::{\n     dynamic_imports::{NextDynamicChunkAvailability, collect_next_dynamic_chunks},\n     font::create_font_manifest,\n     loadable_manifest::create_react_loadable_manifest,\n-    module_graph::get_reduced_graphs_for_endpoint,\n+    module_graph::get_global_information_for_endpoint,\n     nft_json::NftJsonAsset,\n     paths::{\n         all_paths_in_root, all_server_paths, get_asset_paths_from_root, get_js_paths_from_root,\n@@ -1261,15 +1261,15 @@ impl AppEndpoint {\n         }\n         let client_shared_availability_info = client_shared_chunk_group.availability_info;\n \n-        let reduced_graphs = get_reduced_graphs_for_endpoint(\n+        let global_information = get_global_information_for_endpoint(\n             *module_graphs.base,\n             *project.per_page_module_graph().await?,\n         );\n-        let next_dynamic_imports = reduced_graphs\n+        let next_dynamic_imports = global_information\n             .get_next_dynamic_imports_for_endpoint(*rsc_entry)\n             .await?;\n \n-        let client_references = reduced_graphs\n+        let client_references = global_information\n             .get_client_references_for_endpoint(\n                 *rsc_entry,\n                 matches!(this.ty, AppEndpointType::Page { .. }),\n@@ -1419,7 +1419,7 @@ impl AppEndpoint {\n             }\n         }\n \n-        let actions = reduced_graphs.get_server_actions_for_endpoint(\n+        let actions = global_information.get_server_actions_for_endpoint(\n             *rsc_entry,\n             match runtime {\n                 NextRuntime::Edge => Vc::upcast(this.app_project.edge_rsc_module_context()),\n@@ -2044,7 +2044,7 @@ impl Endpoint for AppEndpoint {\n         let rsc_entry = app_entry.rsc_entry;\n         let runtime = app_entry.config.await?.runtime.unwrap_or_default();\n \n-        let actions = get_reduced_graphs_for_endpoint(\n+        let actions = get_global_information_for_endpoint(\n             graph,\n             *this.app_project.project().per_page_module_graph().await?,\n         )"
        },
        {
            "sha": "010b201db3e4f730c1c958cf80d0f7caae63311e",
            "filename": "crates/next-api/src/module_graph.rs",
            "status": "modified",
            "additions": 15,
            "deletions": 47,
            "changes": 62,
            "blob_url": "https://github.com/vercel/next.js/blob/08bd8fb0f4a6617bba24d3b0aa8f8d9ee3c878f4/crates%2Fnext-api%2Fsrc%2Fmodule_graph.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/08bd8fb0f4a6617bba24d3b0aa8f8d9ee3c878f4/crates%2Fnext-api%2Fsrc%2Fmodule_graph.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fmodule_graph.rs?ref=08bd8fb0f4a6617bba24d3b0aa8f8d9ee3c878f4",
            "patch": "@@ -5,7 +5,7 @@ use either::Either;\n use next_core::{\n     next_client_reference::{\n         ClientReference, ClientReferenceGraphResult, ClientReferenceType, ServerEntries,\n-        VisitedClientReferenceGraphNodes, find_server_entries,\n+        find_server_entries,\n     },\n     next_dynamic::NextDynamicEntryModule,\n     next_manifests::ActionLayer,\n@@ -57,30 +57,6 @@ impl NextDynamicGraph {\n     ) -> Result<Vc<Self>> {\n         let mapped = map_next_dynamic(*graph);\n \n-        // TODO shrink graph here, using the information from\n-        //  - `mapped` (which lists the relevant nodes)\n-        //  - `graph.entries` (which lists the page/route/... entries we need to keep)\n-\n-        // This would clone the graph and allow changing the node weights. We can probably get away\n-        // with keeping the sidecar information separate from the graph itself, though.\n-        //\n-        // let mut reduced_modules: FxHashMap<Vc<Box<dyn Module>>, NodeIndex<u32>> =\n-        // FxHashMap::default(); let mut reduced_graph = DiGraph::new();\n-        // for idx in graph.node_indices() {\n-        //     let weight = *graph.node_weight(idx).unwrap();\n-        //     let new_idx = reduced_graph.add_node(weight);\n-        //     reduced_modules.insert(weight, new_idx);\n-        //     for e in graph.edges_directed(idx, petgraph::Direction::Outgoing) {\n-        //         let target_weight = *graph.node_weight(e.target()).context(\"Missing\n-        // target\")?;         if let Some(new_target_idx) =\n-        // reduced_modules.get(&target_weight) {\n-        // reduced_graph.add_edge(new_idx, *new_target_idx, ());         } else {\n-        //             let new_idx = reduced_graph.add_node(target_weight);\n-        //             reduced_modules.insert(target_weight, new_idx);\n-        //         }\n-        //     }\n-        // }\n-\n         Ok(NextDynamicGraph {\n             is_single_page,\n             graph,\n@@ -185,8 +161,6 @@ impl ServerActionsGraph {\n     ) -> Result<Vc<Self>> {\n         let mapped = map_server_actions(*graph);\n \n-        // TODO shrink graph here\n-\n         Ok(ServerActionsGraph {\n             is_single_page,\n             graph,\n@@ -283,8 +257,6 @@ impl ClientReferencesGraph {\n         // already, which saves us a traversal.\n         let mapped = map_client_references(*graph);\n \n-        // TODO shrink graph here\n-\n         Ok(Self {\n             is_single_page,\n             graph,\n@@ -390,10 +362,6 @@ impl ClientReferencesGraph {\n                 client_references_by_server_component,\n                 server_utils: vec![],\n                 server_component_entries: vec![],\n-                // TODO remove\n-                visited_nodes: VisitedClientReferenceGraphNodes::empty()\n-                    .to_resolved()\n-                    .await?,\n             }\n             .cell())\n         }\n@@ -564,20 +532,19 @@ async fn validate_pages_css_imports(\n /// The consumers of this shouldn't need to care about the exact contents since it's abstracted away\n /// by the accessor functions, but\n /// - In dev, contains information about the modules of the current endpoint only\n-/// - In prod, there is a single `ReducedGraphs` for the whole app, containing all pages\n+/// - In prod, there is a single `GlobalBuildInformation` for the whole app, containing all pages\n #[turbo_tasks::value]\n-pub struct ReducedGraphs {\n+pub struct GlobalBuildInformation {\n     next_dynamic: Vec<ResolvedVc<NextDynamicGraph>>,\n     server_actions: Vec<ResolvedVc<ServerActionsGraph>>,\n     client_references: Vec<ResolvedVc<ClientReferencesGraph>>,\n     // Data for some more ad-hoc operations\n     bare_graphs: ResolvedVc<ModuleGraph>,\n     is_single_page: bool,\n-    // TODO add other graphs\n }\n \n #[turbo_tasks::value_impl]\n-impl ReducedGraphs {\n+impl GlobalBuildInformation {\n     #[turbo_tasks::function]\n     pub async fn new(graphs: Vc<ModuleGraph>, is_single_page: bool) -> Result<Vc<Self>> {\n         let graphs_ref = &graphs.await?.graphs;\n@@ -809,24 +776,25 @@ impl ReducedGraphs {\n }\n \n #[turbo_tasks::function(operation)]\n-fn get_reduced_graphs_for_endpoint_inner_operation(\n+fn get_global_information_for_endpoint_inner_operation(\n     module_graph: ResolvedVc<ModuleGraph>,\n     is_single_page: bool,\n-) -> Vc<ReducedGraphs> {\n-    ReducedGraphs::new(*module_graph, is_single_page)\n+) -> Vc<GlobalBuildInformation> {\n+    GlobalBuildInformation::new(*module_graph, is_single_page)\n }\n \n-/// Generates a [ReducedGraph] for the given project and endpoint containing information that is\n-/// either global (module ids, chunking) or computed globally as a performance optimization (client\n-/// references, etc).\n+/// Generates a [GlobalBuildInformation] for the given project and endpoint containing information\n+/// that is either global (module ids, chunking) or computed globally as a performance optimization\n+/// (client references, etc).\n #[turbo_tasks::function]\n-pub async fn get_reduced_graphs_for_endpoint(\n+pub async fn get_global_information_for_endpoint(\n     module_graph: ResolvedVc<ModuleGraph>,\n     is_single_page: bool,\n-) -> Result<Vc<ReducedGraphs>> {\n+) -> Result<Vc<GlobalBuildInformation>> {\n     // TODO get rid of this function once everything inside of\n-    // `get_reduced_graphs_for_endpoint_inner` calls `take_collectibles()` when needed\n-    let result_op = get_reduced_graphs_for_endpoint_inner_operation(module_graph, is_single_page);\n+    // `get_global_information_for_endpoint_inner` calls `take_collectibles()` when needed\n+    let result_op =\n+        get_global_information_for_endpoint_inner_operation(module_graph, is_single_page);\n     let result_vc = if !is_single_page {\n         let result_vc = result_op.resolve_strongly_consistent().await?;\n         let _issues = result_op.take_collectibles::<Box<dyn Issue>>();"
        },
        {
            "sha": "6daa0dd48b5ed545e3518894a4a28b7bad8c89e9",
            "filename": "crates/next-api/src/pages.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/08bd8fb0f4a6617bba24d3b0aa8f8d9ee3c878f4/crates%2Fnext-api%2Fsrc%2Fpages.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/08bd8fb0f4a6617bba24d3b0aa8f8d9ee3c878f4/crates%2Fnext-api%2Fsrc%2Fpages.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fpages.rs?ref=08bd8fb0f4a6617bba24d3b0aa8f8d9ee3c878f4",
            "patch": "@@ -70,7 +70,7 @@ use crate::{\n     },\n     font::create_font_manifest,\n     loadable_manifest::create_react_loadable_manifest,\n-    module_graph::get_reduced_graphs_for_endpoint,\n+    module_graph::get_global_information_for_endpoint,\n     nft_json::NftJsonAsset,\n     paths::{\n         all_paths_in_root, all_server_paths, get_asset_paths_from_root, get_js_paths_from_root,\n@@ -1012,7 +1012,7 @@ impl PageEndpoint {\n \n                 let client_module_graph = self.client_module_graph();\n \n-                let reduced_graphs = get_reduced_graphs_for_endpoint(\n+                let global_information = get_global_information_for_endpoint(\n                     client_module_graph,\n                     *project.per_page_module_graph().await?,\n                 );\n@@ -1043,12 +1043,12 @@ impl PageEndpoint {\n                         .await?\n                         .module();\n \n-                    reduced_graphs\n+                    global_information\n                         .validate_pages_css_imports(self.client_module(), app_module)\n                         .await?;\n                 }\n \n-                let next_dynamic_imports = reduced_graphs\n+                let next_dynamic_imports = global_information\n                     .get_next_dynamic_imports_for_endpoint(self.client_module())\n                     .await?;\n                 Some((next_dynamic_imports, client_availability_info))"
        },
        {
            "sha": "6edd2874558a81a97474d8e48345d77a18e6ac93",
            "filename": "crates/next-core/src/next_client_reference/visit_client_reference.rs",
            "status": "modified",
            "additions": 68,
            "deletions": 194,
            "changes": 262,
            "blob_url": "https://github.com/vercel/next.js/blob/08bd8fb0f4a6617bba24d3b0aa8f8d9ee3c878f4/crates%2Fnext-core%2Fsrc%2Fnext_client_reference%2Fvisit_client_reference.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/08bd8fb0f4a6617bba24d3b0aa8f8d9ee3c878f4/crates%2Fnext-core%2Fsrc%2Fnext_client_reference%2Fvisit_client_reference.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_client_reference%2Fvisit_client_reference.rs?ref=08bd8fb0f4a6617bba24d3b0aa8f8d9ee3c878f4",
            "patch": "@@ -11,7 +11,6 @@ use turbo_tasks::{\n     graph::{AdjacencyMap, GraphTraversal, Visit, VisitControlFlow},\n     trace::TraceRawVcs,\n };\n-use turbo_tasks_fs::FileSystemPath;\n use turbopack::css::chunk::CssChunkPlaceable;\n use turbopack_core::{\n     chunk::ChunkingType, module::Module, reference::primary_chunkable_referenced_modules,\n@@ -73,7 +72,7 @@ pub enum ClientReferenceType {\n }\n \n #[turbo_tasks::value(shared)]\n-#[derive(Clone, Debug)]\n+#[derive(Clone, Debug, Default)]\n pub struct ClientReferenceGraphResult {\n     pub client_references: Vec<ClientReference>,\n     /// Only the [`ClientReferenceType::EcmascriptClientReference`]s are listed in this map.\n@@ -82,23 +81,10 @@ pub struct ClientReferenceGraphResult {\n         FxIndexMap<Option<ResolvedVc<NextServerComponentModule>>, Vec<ResolvedVc<Box<dyn Module>>>>,\n     pub server_component_entries: Vec<ResolvedVc<NextServerComponentModule>>,\n     pub server_utils: Vec<ResolvedVc<NextServerUtilityModule>>,\n-    pub visited_nodes: ResolvedVc<VisitedClientReferenceGraphNodes>,\n-}\n-\n-impl Default for ClientReferenceGraphResult {\n-    fn default() -> Self {\n-        ClientReferenceGraphResult {\n-            client_references: Default::default(),\n-            client_references_by_server_component: Default::default(),\n-            server_component_entries: Default::default(),\n-            server_utils: Default::default(),\n-            visited_nodes: VisitedClientReferenceGraphNodes(Default::default()).resolved_cell(),\n-        }\n-    }\n }\n \n #[turbo_tasks::value(shared)]\n-pub struct VisitedClientReferenceGraphNodes(FxHashSet<VisitClientReferenceNode>);\n+pub struct VisitedClientReferenceGraphNodes(FxHashSet<FindServerEntriesNode>);\n \n #[turbo_tasks::value_impl]\n impl VisitedClientReferenceGraphNodes {\n@@ -138,8 +124,6 @@ impl ClientReferenceGraphResult {\n         self.server_component_entries\n             .extend(other.server_component_entries.iter().copied());\n         self.server_utils.extend(other.server_utils.iter().copied());\n-        // This is merged already by `client_reference_graph` itself\n-        self.visited_nodes = other.visited_nodes;\n     }\n }\n \n@@ -150,27 +134,22 @@ pub struct ServerEntries {\n     pub server_utils: Vec<ResolvedVc<NextServerUtilityModule>>,\n }\n \n+/// For a given RSC entry, finds all server components (i.e. layout segments) and server utils that\n+/// are referenced by the entry.\n #[turbo_tasks::function]\n pub async fn find_server_entries(\n     entry: ResolvedVc<Box<dyn Module>>,\n     include_traced: bool,\n ) -> Result<Vc<ServerEntries>> {\n     async move {\n-        let entry_path = entry.ident().path().await?.clone_value();\n         let graph = AdjacencyMap::new()\n             .skip_duplicates()\n             .visit(\n-                vec![VisitClientReferenceNode {\n-                    state: { VisitClientReferenceNodeState::Entry { entry_path } },\n-                    ty: VisitClientReferenceNodeType::Internal(\n-                        entry,\n-                        entry.ident().to_string().await?,\n-                    ),\n-                }],\n-                VisitClientReference {\n-                    stop_at_server_entries: true,\n-                    include_traced,\n-                },\n+                vec![FindServerEntriesNode::Internal(\n+                    entry,\n+                    entry.ident().to_string().await?,\n+                )],\n+                FindServerEntries { include_traced },\n             )\n             .await\n             .completed()?\n@@ -179,15 +158,14 @@ pub async fn find_server_entries(\n         let mut server_component_entries = vec![];\n         let mut server_utils = vec![];\n         for node in graph.postorder_topological() {\n-            match &node.ty {\n-                VisitClientReferenceNodeType::ServerUtilEntry(server_util, _) => {\n+            match node {\n+                FindServerEntriesNode::ServerUtilEntry(server_util, _) => {\n                     server_utils.push(*server_util);\n                 }\n-                VisitClientReferenceNodeType::ServerComponentEntry(server_component, _) => {\n+                FindServerEntriesNode::ServerComponentEntry(server_component, _) => {\n                     server_component_entries.push(*server_component);\n                 }\n-                VisitClientReferenceNodeType::Internal(_, _)\n-                | VisitClientReferenceNodeType::ClientReference(_, _) => {}\n+                FindServerEntriesNode::Internal(_, _) | FindServerEntriesNode::ClientReference => {}\n             }\n         }\n \n@@ -201,61 +179,9 @@ pub async fn find_server_entries(\n     .await\n }\n \n-struct VisitClientReference {\n+struct FindServerEntries {\n     /// Whether to walk ChunkingType::Traced references\n     include_traced: bool,\n-    /// Used to discover ServerComponents and ServerUtils\n-    stop_at_server_entries: bool,\n-}\n-\n-#[derive(\n-    Clone,\n-    Eq,\n-    PartialEq,\n-    Hash,\n-    Serialize,\n-    Deserialize,\n-    Debug,\n-    ValueDebugFormat,\n-    TraceRawVcs,\n-    NonLocalValue,\n-)]\n-struct VisitClientReferenceNode {\n-    state: VisitClientReferenceNodeState,\n-    ty: VisitClientReferenceNodeType,\n-}\n-\n-#[derive(\n-    Clone,\n-    Eq,\n-    PartialEq,\n-    Hash,\n-    Serialize,\n-    Deserialize,\n-    Debug,\n-    ValueDebugFormat,\n-    TraceRawVcs,\n-    NonLocalValue,\n-)]\n-enum VisitClientReferenceNodeState {\n-    Entry {\n-        entry_path: FileSystemPath,\n-    },\n-    InServerComponent {\n-        server_component: ResolvedVc<NextServerComponentModule>,\n-    },\n-    InServerUtil,\n-}\n-impl VisitClientReferenceNodeState {\n-    fn server_component(&self) -> Option<ResolvedVc<NextServerComponentModule>> {\n-        match self {\n-            VisitClientReferenceNodeState::Entry { .. } => None,\n-            VisitClientReferenceNodeState::InServerComponent { server_component } => {\n-                Some(*server_component)\n-            }\n-            VisitClientReferenceNodeState::InServerUtil => None,\n-        }\n-    }\n }\n \n #[derive(\n@@ -270,56 +196,46 @@ impl VisitClientReferenceNodeState {\n     TraceRawVcs,\n     NonLocalValue,\n )]\n-enum VisitClientReferenceNodeType {\n-    ClientReference(ClientReference, ReadRef<RcStr>),\n+enum FindServerEntriesNode {\n+    ClientReference,\n     ServerComponentEntry(ResolvedVc<NextServerComponentModule>, ReadRef<RcStr>),\n     ServerUtilEntry(ResolvedVc<NextServerUtilityModule>, ReadRef<RcStr>),\n     Internal(ResolvedVc<Box<dyn Module>>, ReadRef<RcStr>),\n }\n \n-impl Visit<VisitClientReferenceNode> for VisitClientReference {\n-    type Edge = VisitClientReferenceNode;\n+impl Visit<FindServerEntriesNode> for FindServerEntries {\n+    type Edge = FindServerEntriesNode;\n     type EdgesIntoIter = Vec<Self::Edge>;\n     type EdgesFuture = impl Future<Output = Result<Self::EdgesIntoIter>>;\n \n-    fn visit(&mut self, edge: Self::Edge) -> VisitControlFlow<VisitClientReferenceNode> {\n-        if self.stop_at_server_entries\n-            && matches!(\n-                edge.ty,\n-                VisitClientReferenceNodeType::ServerUtilEntry(..)\n-                    | VisitClientReferenceNodeType::ServerComponentEntry(..)\n-            )\n-        {\n-            return VisitControlFlow::Skip(edge);\n-        }\n-\n-        match edge.ty {\n-            VisitClientReferenceNodeType::ClientReference(..) => VisitControlFlow::Skip(edge),\n-            VisitClientReferenceNodeType::Internal(..)\n-            | VisitClientReferenceNodeType::ServerUtilEntry(..)\n-            | VisitClientReferenceNodeType::ServerComponentEntry(..) => {\n-                VisitControlFlow::Continue(edge)\n-            }\n+    fn visit(&mut self, edge: Self::Edge) -> VisitControlFlow<FindServerEntriesNode> {\n+        match edge {\n+            FindServerEntriesNode::Internal(..) => VisitControlFlow::Continue(edge),\n+            FindServerEntriesNode::ClientReference\n+            | FindServerEntriesNode::ServerUtilEntry(..)\n+            | FindServerEntriesNode::ServerComponentEntry(..) => VisitControlFlow::Skip(edge),\n         }\n     }\n \n-    fn edges(&mut self, node: &VisitClientReferenceNode) -> Self::EdgesFuture {\n+    fn edges(&mut self, node: &FindServerEntriesNode) -> Self::EdgesFuture {\n         let node = node.clone();\n         let include_traced = self.include_traced;\n         async move {\n-            let parent_module = match node.ty {\n+            let parent_module = match node {\n                 // This should never occur since we always skip visiting these\n                 // nodes' edges.\n-                VisitClientReferenceNodeType::ClientReference(..) => return Ok(vec![]),\n-                VisitClientReferenceNodeType::Internal(module, _) => module,\n-                VisitClientReferenceNodeType::ServerUtilEntry(module, _) => {\n-                    ResolvedVc::upcast(module)\n+                FindServerEntriesNode::ClientReference => {\n+                    unreachable!(\"ClientReference node should not be visited\")\n                 }\n-                VisitClientReferenceNodeType::ServerComponentEntry(module, _) => {\n+                FindServerEntriesNode::Internal(module, _) => module,\n+                FindServerEntriesNode::ServerUtilEntry(module, _) => ResolvedVc::upcast(module),\n+                FindServerEntriesNode::ServerComponentEntry(module, _) => {\n                     ResolvedVc::upcast(module)\n                 }\n             };\n \n+            // Pass include_traced to reuse the same cached `primary_chunkable_referenced_modules`\n+            // task result, but the traced references will be filtered out again afterwards.\n             let referenced_modules =\n                 primary_chunkable_referenced_modules(*parent_module, include_traced).await?;\n \n@@ -330,79 +246,37 @@ impl Visit<VisitClientReferenceNode> for VisitClientReference {\n                     _ => Some(modules.iter()),\n                 })\n                 .flatten()\n-                .map(|module| {\n-                    let node_state = node.state.clone();\n-\n-                    async move {\n-                        if let Some(client_reference_module) = ResolvedVc::try_downcast_type::<\n-                            EcmascriptClientReferenceModule,\n-                        >(*module)\n-                        {\n-                            return Ok(VisitClientReferenceNode {\n-                                state: node_state.clone(),\n-                                ty: VisitClientReferenceNodeType::ClientReference(\n-                                    ClientReference {\n-                                        server_component: node_state.clone().server_component(),\n-                                        ty: ClientReferenceType::EcmascriptClientReference(\n-                                            client_reference_module,\n-                                        ),\n-                                    },\n-                                    client_reference_module.ident().to_string().await?,\n-                                ),\n-                            });\n-                        }\n-\n-                        if let Some(client_reference_module) =\n-                            ResolvedVc::try_downcast_type::<CssClientReferenceModule>(*module)\n-                        {\n-                            return Ok(VisitClientReferenceNode {\n-                                state: node_state.clone(),\n-                                ty: VisitClientReferenceNodeType::ClientReference(\n-                                    ClientReference {\n-                                        server_component: node_state.clone().server_component(),\n-                                        ty: ClientReferenceType::CssClientReference(\n-                                            client_reference_module.await?.client_module,\n-                                        ),\n-                                    },\n-                                    client_reference_module.ident().to_string().await?,\n-                                ),\n-                            });\n-                        }\n-\n-                        if let Some(server_component_asset) =\n-                            ResolvedVc::try_downcast_type::<NextServerComponentModule>(*module)\n-                        {\n-                            return Ok(VisitClientReferenceNode {\n-                                state: VisitClientReferenceNodeState::InServerComponent {\n-                                    server_component: server_component_asset,\n-                                },\n-                                ty: VisitClientReferenceNodeType::ServerComponentEntry(\n-                                    server_component_asset,\n-                                    server_component_asset.ident().to_string().await?,\n-                                ),\n-                            });\n-                        }\n+                .map(async |module| {\n+                    if ResolvedVc::try_downcast_type::<EcmascriptClientReferenceModule>(*module)\n+                        .is_some()\n+                        || ResolvedVc::try_downcast_type::<CssClientReferenceModule>(*module)\n+                            .is_some()\n+                    {\n+                        return Ok(FindServerEntriesNode::ClientReference);\n+                    }\n \n-                        if let Some(server_util_module) =\n-                            ResolvedVc::try_downcast_type::<NextServerUtilityModule>(*module)\n-                        {\n-                            return Ok(VisitClientReferenceNode {\n-                                state: VisitClientReferenceNodeState::InServerUtil,\n-                                ty: VisitClientReferenceNodeType::ServerUtilEntry(\n-                                    server_util_module,\n-                                    module.ident().to_string().await?,\n-                                ),\n-                            });\n-                        }\n+                    if let Some(server_component_asset) =\n+                        ResolvedVc::try_downcast_type::<NextServerComponentModule>(*module)\n+                    {\n+                        return Ok(FindServerEntriesNode::ServerComponentEntry(\n+                            server_component_asset,\n+                            server_component_asset.ident().to_string().await?,\n+                        ));\n+                    }\n \n-                        Ok(VisitClientReferenceNode {\n-                            state: node_state,\n-                            ty: VisitClientReferenceNodeType::Internal(\n-                                *module,\n-                                module.ident().to_string().await?,\n-                            ),\n-                        })\n+                    if let Some(server_util_module) =\n+                        ResolvedVc::try_downcast_type::<NextServerUtilityModule>(*module)\n+                    {\n+                        return Ok(FindServerEntriesNode::ServerUtilEntry(\n+                            server_util_module,\n+                            module.ident().to_string().await?,\n+                        ));\n                     }\n+\n+                    Ok(FindServerEntriesNode::Internal(\n+                        *module,\n+                        module.ident().to_string().await?,\n+                    ))\n                 });\n \n             let assets = referenced_modules.try_join().await?;\n@@ -411,18 +285,18 @@ impl Visit<VisitClientReferenceNode> for VisitClientReference {\n         }\n     }\n \n-    fn span(&mut self, node: &VisitClientReferenceNode) -> tracing::Span {\n-        match &node.ty {\n-            VisitClientReferenceNodeType::ClientReference(_, name) => {\n-                tracing::info_span!(\"client reference\", name = name.to_string())\n+    fn span(&mut self, node: &FindServerEntriesNode) -> tracing::Span {\n+        match node {\n+            FindServerEntriesNode::ClientReference => {\n+                tracing::info_span!(\"client reference\")\n             }\n-            VisitClientReferenceNodeType::Internal(_, name) => {\n+            FindServerEntriesNode::Internal(_, name) => {\n                 tracing::info_span!(\"module\", name = name.to_string())\n             }\n-            VisitClientReferenceNodeType::ServerUtilEntry(_, name) => {\n+            FindServerEntriesNode::ServerUtilEntry(_, name) => {\n                 tracing::info_span!(\"server util\", name = name.to_string())\n             }\n-            VisitClientReferenceNodeType::ServerComponentEntry(_, name) => {\n+            FindServerEntriesNode::ServerComponentEntry(_, name) => {\n                 tracing::info_span!(\"layout segment\", name = name.to_string())\n             }\n         }"
        }
    ],
    "stats": {
        "total": 344,
        "additions": 93,
        "deletions": 251
    }
}