{
    "author": "ztanner",
    "message": "[runtime prefetching]: fix runtime prefetching when deployed (#85595)\n\nRuntime prefetching relies on the presence of headers to determine\ncaching behavior: `x-nextjs-postponed` indicates if the response was\npartial (so it knows if it should trigger a dynamic request to retrieve\nthe missing data), and `x-nextjs-stale-time` provided stale time\ninformation to the client router. This worked fine in `next start` but\ndue to how this is modeled in our Vercel deployment adapter, it was not\npossible to set runtime headers after the initial headers have been\nsent, as these requests were routed to prerenders.\n\nAs a result of this limitation, this moves both the isPartial flag and\nthe stale time value into the payload body. The response is run through\na transform stream that replaces a sentinel value (`\"rp\": [sentinel]`)\nwith the final stale time/isPartial values after we determine them. This\navoids regenerating the entire RSC payload while ensuring correct values\nare sent to the client. Both properties are only included in runtime\nprefetch responses.\n\nCloses NAR-494\n\n---------\n\nCo-authored-by: Josh Story <story@hey.com>",
    "sha": "2f86fbab810d3dd6ceb95bc5dea5b96525fe03b9",
    "files": [
        {
            "sha": "f1b5b31f5ed558adf65fcc8200b98cf1a70f1197",
            "filename": "packages/next/src/client/components/segment-cache/cache.ts",
            "status": "modified",
            "additions": 19,
            "deletions": 16,
            "changes": 35,
            "blob_url": "https://github.com/vercel/next.js/blob/2f86fbab810d3dd6ceb95bc5dea5b96525fe03b9/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fcache.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/2f86fbab810d3dd6ceb95bc5dea5b96525fe03b9/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fcache.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fcache.ts?ref=2f86fbab810d3dd6ceb95bc5dea5b96525fe03b9",
            "patch": "@@ -1654,7 +1654,7 @@ export async function fetchSegmentPrefetchesUsingDynamicRequest(\n     const isResponsePartial =\n       fetchStrategy === FetchStrategy.PPRRuntime\n         ? // A runtime prefetch may have holes.\n-          !!response.headers.get(NEXT_DID_POSTPONE_HEADER)\n+          serverData.rp?.[0] === true\n         : // Full and LoadingBoundary prefetches cannot have holes.\n           // (even if we did set the prefetch header, we only use this codepath for non-PPR-enabled routes)\n           false\n@@ -1719,14 +1719,15 @@ function writeDynamicTreeResponseIntoCache(\n   }\n \n   const flightRouterState = flightData.tree\n-  // TODO: Extract to function\n-  const staleTimeHeaderSeconds = response.headers.get(\n-    NEXT_ROUTER_STALE_TIME_HEADER\n-  )\n-  const staleTimeMs =\n-    staleTimeHeaderSeconds !== null\n-      ? getStaleTimeMs(parseInt(staleTimeHeaderSeconds, 10))\n-      : STATIC_STALETIME_MS\n+  // For runtime prefetches, stale time is in the payload at rp[1].\n+  // For other responses, fall back to the header.\n+  const staleTimeSeconds =\n+    typeof serverData.rp?.[1] === 'number'\n+      ? serverData.rp[1]\n+      : parseInt(response.headers.get(NEXT_ROUTER_STALE_TIME_HEADER) ?? '', 10)\n+  const staleTimeMs = !isNaN(staleTimeSeconds)\n+    ? getStaleTimeMs(staleTimeSeconds)\n+    : STATIC_STALETIME_MS\n \n   // If the response contains dynamic holes, then we must conservatively assume\n   // that any individual segment might contain dynamic holes, and also the\n@@ -1814,13 +1815,15 @@ function writeDynamicRenderResponseIntoCache(\n     return null\n   }\n \n-  const staleTimeHeaderSeconds = response.headers.get(\n-    NEXT_ROUTER_STALE_TIME_HEADER\n-  )\n-  const staleTimeMs =\n-    staleTimeHeaderSeconds !== null\n-      ? getStaleTimeMs(parseInt(staleTimeHeaderSeconds, 10))\n-      : STATIC_STALETIME_MS\n+  // For runtime prefetches, stale time is in the payload at rp[1].\n+  // For other responses, fall back to the header.\n+  const staleTimeSeconds =\n+    typeof serverData.rp?.[1] === 'number'\n+      ? serverData.rp[1]\n+      : parseInt(response.headers.get(NEXT_ROUTER_STALE_TIME_HEADER) ?? '', 10)\n+  const staleTimeMs = !isNaN(staleTimeSeconds)\n+    ? getStaleTimeMs(staleTimeSeconds)\n+    : STATIC_STALETIME_MS\n   const staleAt = now + staleTimeMs\n \n   for (const flightData of flightDatas) {"
        },
        {
            "sha": "b1b890115ced1a3ca0ac20bcfcb809fb86f8de9e",
            "filename": "packages/next/src/server/app-render/app-render.tsx",
            "status": "modified",
            "additions": 152,
            "deletions": 14,
            "changes": 166,
            "blob_url": "https://github.com/vercel/next.js/blob/2f86fbab810d3dd6ceb95bc5dea5b96525fe03b9/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/2f86fbab810d3dd6ceb95bc5dea5b96525fe03b9/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx?ref=2f86fbab810d3dd6ceb95bc5dea5b96525fe03b9",
            "patch": "@@ -57,7 +57,6 @@ import {\n   RSC_HEADER,\n   NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n   NEXT_HMR_REFRESH_HASH_COOKIE,\n-  NEXT_DID_POSTPONE_HEADER,\n   NEXT_REQUEST_ID_HEADER,\n   NEXT_HTML_REQUEST_ID_HEADER,\n } from '../../client/components/app-router-headers'\n@@ -453,8 +452,9 @@ function NonIndex({\n async function generateDynamicRSCPayload(\n   ctx: AppRenderContext,\n   options?: {\n-    actionResult: ActionResult\n-    skipFlight: boolean\n+    actionResult?: ActionResult\n+    skipFlight?: boolean\n+    runtimePrefetchSentinel?: number\n   }\n ): Promise<RSCPayload> {\n   // Flight data that is going to be passed to the browser.\n@@ -545,11 +545,23 @@ async function generateDynamicRSCPayload(\n   }\n \n   // Otherwise, it's a regular RSC response.\n-  return {\n+  const baseResponse = {\n     b: ctx.sharedContext.buildId,\n     f: flightData,\n     S: workStore.isStaticGeneration,\n   }\n+\n+  // For runtime prefetches, we encode the stale time and isPartial flag in the response body\n+  // rather than relying on response headers. Both of these values will be transformed\n+  // by a transform stream before being sent to the client.\n+  if (options?.runtimePrefetchSentinel !== undefined) {\n+    return {\n+      ...baseResponse,\n+      rp: [options.runtimePrefetchSentinel] as any,\n+    }\n+  }\n+\n+  return baseResponse\n }\n \n function createErrorContext(\n@@ -829,7 +841,6 @@ async function generateDynamicFlightRenderResultWithStagesInDev(\n \n async function generateRuntimePrefetchResult(\n   req: BaseNextRequest,\n-  res: BaseNextResponse,\n   ctx: AppRenderContext,\n   requestStore: RequestStore\n ): Promise<RenderResult> {\n@@ -851,7 +862,14 @@ async function generateRuntimePrefetchResult(\n \n   const metadata: AppPageRenderResultMetadata = {}\n \n-  const generatePayload = () => generateDynamicRSCPayload(ctx, undefined)\n+  // Generate a random sentinel that will be used as a placeholder in the payload\n+  // and later replaced by the transform stream\n+  const runtimePrefetchSentinel = Math.floor(\n+    Math.random() * Number.MAX_SAFE_INTEGER\n+  )\n+\n+  const generatePayload = () =>\n+    generateDynamicRSCPayload(ctx, { runtimePrefetchSentinel })\n \n   const {\n     componentMod: {\n@@ -889,16 +907,13 @@ async function generateRuntimePrefetchResult(\n     requestStore.headers,\n     requestStore.cookies,\n     requestStore.draftMode,\n-    onError\n+    onError,\n+    runtimePrefetchSentinel\n   )\n \n   applyMetadataFromPrerenderResult(response, metadata, workStore)\n   metadata.fetchMetrics = ctx.workStore.fetchMetrics\n \n-  if (response.isPartial) {\n-    res.setHeader(NEXT_DID_POSTPONE_HEADER, '1')\n-  }\n-\n   return new FlightRenderResult(response.result.prelude, metadata)\n }\n \n@@ -1037,6 +1052,117 @@ async function prospectiveRuntimeServerPrerender(\n     return null\n   }\n }\n+/**\n+ * Updates the runtime prefetch metadata in the RSC payload as it streams:\n+ *   \"rp\":[<sentinel>] -> \"rp\":[<isPartial>,<staleTime>]\n+ *\n+ * We use a transform stream to do this to avoid needing to trigger an additional render.\n+ * A random sentinel number guarantees no collision with user data.\n+ */\n+function createRuntimePrefetchTransformStream(\n+  sentinel: number,\n+  isPartial: boolean,\n+  staleTime: number\n+): TransformStream<Uint8Array, Uint8Array> {\n+  const encoder = new TextEncoder()\n+\n+  // Search for: [<sentinel>]\n+  // Replace with: [<isPartial>,<staleTime>]\n+  const search = encoder.encode(`[${sentinel}]`)\n+  const first = search[0]\n+  const replace = encoder.encode(`[${isPartial},${staleTime}]`)\n+  const searchLen = search.length\n+\n+  let currentChunk: Uint8Array | null = null\n+  let found = false\n+\n+  function processChunk(\n+    controller: TransformStreamDefaultController<Uint8Array>,\n+    nextChunk: null | Uint8Array\n+  ) {\n+    if (found) {\n+      if (nextChunk) {\n+        controller.enqueue(nextChunk)\n+      }\n+      return\n+    }\n+\n+    if (currentChunk) {\n+      // We can't search past the index that can contain a full match\n+      let exclusiveUpperBound = currentChunk.length - (searchLen - 1)\n+      if (nextChunk) {\n+        // If we have any overflow bytes we can search up to the chunk's final byte\n+        exclusiveUpperBound += Math.min(nextChunk.length, searchLen - 1)\n+      }\n+      if (exclusiveUpperBound < 1) {\n+        // we can't match the current chunk.\n+        controller.enqueue(currentChunk)\n+        currentChunk = nextChunk // advance so we don't process this chunk again\n+        return\n+      }\n+\n+      let currentIndex = currentChunk.indexOf(first)\n+\n+      // check the current candidate match if it is within the bounds of our search space for the currentChunk\n+      candidateLoop: while (\n+        -1 < currentIndex &&\n+        currentIndex < exclusiveUpperBound\n+      ) {\n+        // We already know index 0 matches because we used indexOf to find the candidateIndex so we start at index 1\n+        let matchIndex = 1\n+        while (matchIndex < searchLen) {\n+          const candidateIndex = currentIndex + matchIndex\n+          const candidateValue =\n+            candidateIndex < currentChunk.length\n+              ? currentChunk[candidateIndex]\n+              : // if we ever hit this condition it is because there is a nextChunk we can read from\n+                nextChunk![candidateIndex - currentChunk.length]\n+          if (candidateValue !== search[matchIndex]) {\n+            // No match, reset and continue the search from the next position\n+            currentIndex = currentChunk.indexOf(first, currentIndex + 1)\n+            continue candidateLoop\n+          }\n+          matchIndex++\n+        }\n+        // We found a complete match. currentIndex is our starting point to replace the value.\n+        found = true\n+        // enqueue everything up to the match\n+        controller.enqueue(currentChunk.subarray(0, currentIndex))\n+        // enqueue the replacement value\n+        controller.enqueue(replace)\n+        // If there are bytes in the currentChunk after the match enqueue them\n+        if (currentIndex + searchLen < currentChunk.length) {\n+          controller.enqueue(currentChunk.subarray(currentIndex + searchLen))\n+        }\n+        // If we have a next chunk we enqueue it now\n+        if (nextChunk) {\n+          // if replacement spills over to the next chunk we first exclude the replaced bytes\n+          const overflowBytes = currentIndex + searchLen - currentChunk.length\n+          const truncatedChunk =\n+            overflowBytes > 0 ? nextChunk!.subarray(overflowBytes) : nextChunk\n+          controller.enqueue(truncatedChunk)\n+        }\n+        // We are now in found mode and don't need to track currentChunk anymore\n+        currentChunk = null\n+        return\n+      }\n+      // No match found in this chunk, emit it and wait for the next one\n+      controller.enqueue(currentChunk)\n+    }\n+\n+    // Advance to the next chunk\n+    currentChunk = nextChunk\n+  }\n+\n+  return new TransformStream<Uint8Array, Uint8Array>({\n+    transform(chunk, controller) {\n+      processChunk(controller, chunk)\n+    },\n+    flush(controller) {\n+      processChunk(controller, null)\n+    },\n+  })\n+}\n \n async function finalRuntimeServerPrerender(\n   ctx: AppRenderContext,\n@@ -1047,7 +1173,8 @@ async function finalRuntimeServerPrerender(\n   headers: PrerenderStoreModernRuntime['headers'],\n   cookies: PrerenderStoreModernRuntime['cookies'],\n   draftMode: PrerenderStoreModernRuntime['draftMode'],\n-  onError: (err: unknown) => string | undefined\n+  onError: (err: unknown) => string | undefined,\n+  runtimePrefetchSentinel: number\n ) {\n   const { implicitTags, renderOpts } = ctx\n \n@@ -1150,6 +1277,17 @@ async function finalRuntimeServerPrerender(\n     }\n   )\n \n+  // Update the RSC payload stream to replace the sentinel with actual values.\n+  // React has already serialized the payload with the sentinel, so we need to transform the stream.\n+  const collectedStale = selectStaleTime(finalServerPrerenderStore.stale)\n+  result.prelude = result.prelude.pipeThrough(\n+    createRuntimePrefetchTransformStream(\n+      runtimePrefetchSentinel,\n+      serverIsDynamic,\n+      collectedStale\n+    )\n+  )\n+\n   return {\n     result,\n     // TODO(runtime-ppr): do we need to produce a digest map here?\n@@ -1158,7 +1296,7 @@ async function finalRuntimeServerPrerender(\n     isPartial: serverIsDynamic,\n     collectedRevalidate: finalServerPrerenderStore.revalidate,\n     collectedExpire: finalServerPrerenderStore.expire,\n-    collectedStale: selectStaleTime(finalServerPrerenderStore.stale),\n+    collectedStale,\n     collectedTags: finalServerPrerenderStore.tags,\n   }\n }\n@@ -2001,7 +2139,7 @@ async function renderToHTMLOrFlightImpl(\n \n     if (isRSCRequest) {\n       if (isRuntimePrefetchRequest) {\n-        return generateRuntimePrefetchResult(req, res, ctx, requestStore)\n+        return generateRuntimePrefetchResult(req, ctx, requestStore)\n       } else {\n         if (\n           process.env.NODE_ENV === 'development' &&"
        },
        {
            "sha": "46cb4d8b29b4cc8b2c71dcda97572766e475dbfe",
            "filename": "packages/next/src/shared/lib/app-router-types.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/2f86fbab810d3dd6ceb95bc5dea5b96525fe03b9/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fapp-router-types.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/2f86fbab810d3dd6ceb95bc5dea5b96525fe03b9/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fapp-router-types.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fapp-router-types.ts?ref=2f86fbab810d3dd6ceb95bc5dea5b96525fe03b9",
            "patch": "@@ -300,6 +300,8 @@ export type NavigationFlightResponse = {\n   f: FlightData\n   /** prerendered */\n   S: boolean\n+  /** runtimePrefetch - [isPartial, staleTime]. Only present in runtime prefetch responses. */\n+  rp?: [boolean, number]\n }\n \n // Response from `createFromFetch` for server actions. Action's flight data can be null"
        },
        {
            "sha": "6945f629b975414ed51aec6cfc3d6f2c249506e6",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-runtime/prefetch-runtime.test.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 5,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/2f86fbab810d3dd6ceb95bc5dea5b96525fe03b9/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fprefetch-runtime.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/2f86fbab810d3dd6ceb95bc5dea5b96525fe03b9/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fprefetch-runtime.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fprefetch-runtime.test.ts?ref=2f86fbab810d3dd6ceb95bc5dea5b96525fe03b9",
            "patch": "@@ -4,12 +4,10 @@ import type * as Playwright from 'playwright'\n import { createRouterAct } from 'router-act'\n \n describe('runtime prefetching', () => {\n-  const { next, isNextDev, isNextDeploy, skipped } = nextTestSetup({\n+  const { next, isNextDev, isNextDeploy } = nextTestSetup({\n     files: __dirname,\n-    // TODO (runtime-prefetching): investigate failures when deployed to Vercel.\n-    skipDeployment: true,\n   })\n-  if (isNextDev || skipped) {\n+  if (isNextDev) {\n     it('is skipped', () => {})\n     return\n   }\n@@ -475,7 +473,8 @@ describe('runtime prefetching', () => {\n       await browser.back()\n \n       // wait a tick before navigating\n-      await waitFor(500)\n+      // TODO: Why does this need to be so long when deployed? What other signal do we have that we can wait on?\n+      await waitFor(2000)\n \n       // Navigate to the page\n       await act(async () => {"
        },
        {
            "sha": "d33614c7efea7963c11348717e6ee3071dbfb09e",
            "filename": "test/e2e/app-dir/segment-cache/staleness/segment-cache-stale-time.test.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/2f86fbab810d3dd6ceb95bc5dea5b96525fe03b9/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fstaleness%2Fsegment-cache-stale-time.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/2f86fbab810d3dd6ceb95bc5dea5b96525fe03b9/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fstaleness%2Fsegment-cache-stale-time.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fstaleness%2Fsegment-cache-stale-time.test.ts?ref=2f86fbab810d3dd6ceb95bc5dea5b96525fe03b9",
            "patch": "@@ -3,10 +3,10 @@ import type * as Playwright from 'playwright'\n import { createRouterAct } from 'router-act'\n \n describe('segment cache (staleness)', () => {\n-  const { next, isNextDev, isNextDeploy } = nextTestSetup({\n+  const { next, isNextDev } = nextTestSetup({\n     files: __dirname,\n   })\n-  if (isNextDev || isNextDeploy) {\n+  if (isNextDev) {\n     test('disabled in development / deployment', () => {})\n     return\n   }"
        }
    ],
    "stats": {
        "total": 216,
        "additions": 179,
        "deletions": 37
    }
}