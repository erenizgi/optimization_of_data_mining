{
    "author": "acdlite",
    "message": "Parse dynamic params on the client (#82185)\n\nThis is part of a larger effort to remove dynamic params from server\nresponses except in cases where they are needed to render a Server\nComponent. If a param is not rendered by a Server Component, then it can\nbe omitted from the cache key, and cached responses can be reused across\npages with different param values.\n\nIn this step, I've implemented client parsing of the params from the\nresponse headers.\n\nThe basic approach is to split the URL into parts, then traverse the\nroute tree to pick off the param values, taking care to skip over things\nlike interception routes.\n\nNotably, this is not how the server parses param values. The server gets\nthe params from the regex that's also used for routing. Originally, I\nthought I'd send the regex to the client and use it there, too. However,\nthis ended up being needlessly complicated, because the server regexes\nare also used for things like interception route matching. But this is\nalready encapsulated by the structure of the route tree. So it's easier\nto just walk the tree and pick off the params.\n\nMy main hesitation is that this introduces some risk of drift between\nthe server and client params parsing; we'll need to keep them in sync.\nHowever, I think the solution is actually to update the server to also\npick the params off the URL, rather than use the ones passed from the\nbase router. It's conceptually cleaner, since it's less likely that\nextra concerns from the base server leaking into the application layer.\nAs an example, compare the code needed to get a catchall param value in\nthe\n[client](https://github.com/acdlite/next.js/blob/09b16a816ff4d595b5111cb1a6de540838caf97e/packages/next/src/client/client-params.ts#L57-L61)\nversus the\n[server](https://github.com/acdlite/next.js/blob/09b16a816ff4d595b5111cb1a6de540838caf97e/packages/next/src/shared/lib/router/utils/get-dynamic-param.ts#L37-L84)\nimplementation.\n\nNote: Although the ultimate goal is to remove the dynamic params from\nthe response body (e.g. FlightRouterState), I have not done so yet this\nPR. The rest of the work will be split up into multiple subsequent PRs.",
    "sha": "e8b99e142b41531b38672f1c8afb3c2d0ff00fa3",
    "files": [
        {
            "sha": "adfa6e636994f3e241c24393bdf1de6dffad3705",
            "filename": "packages/next/src/client/components/router-reducer/create-initial-router-state.ts",
            "status": "modified",
            "additions": 20,
            "deletions": 1,
            "changes": 21,
            "blob_url": "https://github.com/vercel/next.js/blob/e8b99e142b41531b38672f1c8afb3c2d0ff00fa3/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fcreate-initial-router-state.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/e8b99e142b41531b38672f1c8afb3c2d0ff00fa3/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fcreate-initial-router-state.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fcreate-initial-router-state.ts?ref=e8b99e142b41531b38672f1c8afb3c2d0ff00fa3",
            "patch": "@@ -37,7 +37,26 @@ export function createInitialRouterState({\n   // This is to ensure that when the RSC payload streamed to the client, crawlers don't interpret it\n   // as a URL that should be crawled.\n   const initialCanonicalUrl = initialCanonicalUrlParts.join('/')\n-  const normalizedFlightData = getFlightDataPartsFromPath(initialFlightData[0])\n+\n+  // TODO: Eventually we want to always read the rendered params from the URL\n+  // and/or the x-rewritten-path header, so that we can omit them from the\n+  // response body. This lets reuse cached responses if params aren't referenced\n+  // anywhere in the actual page data, e.g. if they're only accessed by client\n+  // components. However, during the initial render, there's no way to access\n+  // the headers. For a partially dynamic page, this is OK, because there's\n+  // going to be a dynamic server render regardless, so we can send the URL\n+  // in the resume body. For a completely static page, though, there's no\n+  // dynamic server render, so that won't work.\n+  //\n+  // Instead, we'll perform a HEAD request and read the rewritten URL from\n+  // that response.\n+  const renderedPathname = new URL(initialCanonicalUrl, 'http://localhost')\n+    .pathname\n+\n+  const normalizedFlightData = getFlightDataPartsFromPath(\n+    initialFlightData[0],\n+    renderedPathname\n+  )\n   const {\n     tree: initialTree,\n     seedData: initialSeedData,"
        },
        {
            "sha": "eaa298696a9b264daa5796857a741e804d28d891",
            "filename": "packages/next/src/client/components/router-reducer/fetch-server-response.ts",
            "status": "modified",
            "additions": 15,
            "deletions": 1,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/e8b99e142b41531b38672f1c8afb3c2d0ff00fa3/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Ffetch-server-response.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/e8b99e142b41531b38672f1c8afb3c2d0ff00fa3/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Ffetch-server-response.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Ffetch-server-response.ts?ref=e8b99e142b41531b38672f1c8afb3c2d0ff00fa3",
            "patch": "@@ -31,6 +31,7 @@ import {\n } from '../../flight-data-helpers'\n import { getAppBuildId } from '../../app-build-id'\n import { setCacheBustingSearchParam } from './set-cache-busting-search-param'\n+import { getRenderedPathname } from '../../route-params'\n \n const createFromReadableStream =\n   createFromReadableStreamBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromReadableStream']\n@@ -235,8 +236,21 @@ export async function fetchServerResponse(\n       return doMpaNavigation(res.url)\n     }\n \n+    let renderedPathname\n+    if (process.env.__NEXT_CLIENT_SEGMENT_CACHE) {\n+      // Read the URL from the response object.\n+      renderedPathname = getRenderedPathname(res)\n+    } else {\n+      // Before Segment Cache is enabled, we should not rely on the new\n+      // rewrite headers (x-rewritten-path, x-rewritten-query) because that\n+      // is a breaking change. Read the URL from the response body.\n+      const renderedUrlParts = response.c\n+      renderedPathname = new URL(renderedUrlParts.join('/'), 'http://localhost')\n+        .pathname\n+    }\n+\n     return {\n-      flightData: normalizeFlightData(response.f),\n+      flightData: normalizeFlightData(response.f, renderedPathname),\n       canonicalUrl: canonicalUrl,\n       couldBeIntercepted: interception,\n       prerendered: response.S,"
        },
        {
            "sha": "3ad2815b5a4ef07b9f5e7b54710dbca41a6cf9d9",
            "filename": "packages/next/src/client/components/router-reducer/reducers/server-action-reducer.ts",
            "status": "modified",
            "additions": 18,
            "deletions": 1,
            "changes": 19,
            "blob_url": "https://github.com/vercel/next.js/blob/e8b99e142b41531b38672f1c8afb3c2d0ff00fa3/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fserver-action-reducer.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/e8b99e142b41531b38672f1c8afb3c2d0ff00fa3/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fserver-action-reducer.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fserver-action-reducer.ts?ref=e8b99e142b41531b38672f1c8afb3c2d0ff00fa3",
            "patch": "@@ -55,6 +55,7 @@ import {\n   omitUnusedArgs,\n } from '../../../../shared/lib/server-reference-info'\n import { revalidateEntireCache } from '../../segment-cache'\n+import { getRenderedPathname } from '../../../route-params'\n \n const createFromFetch =\n   createFromFetchBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromFetch']\n@@ -180,9 +181,25 @@ async function fetchServerAction(\n       Promise.resolve(res),\n       { callServer, findSourceMapURL, temporaryReferences }\n     )\n+\n+    let renderedPathname\n+    if (process.env.__NEXT_CLIENT_SEGMENT_CACHE) {\n+      // Read the URL from the response object.\n+      renderedPathname = getRenderedPathname(res)\n+    } else {\n+      // Before Segment Cache is enabled, we should not rely on the new\n+      // rewrite headers (x-rewritten-path, x-rewritten-query) because that\n+      // is a breaking change. Read the URL from the response body.\n+      const canonicalUrlParts = response.c\n+      renderedPathname = new URL(\n+        canonicalUrlParts.join('/'),\n+        'http://localhost'\n+      ).pathname\n+    }\n+\n     // An internal redirect can send an RSC response, but does not have a useful `actionResult`.\n     actionResult = redirectLocation ? undefined : response.a\n-    actionFlightData = normalizeFlightData(response.f)\n+    actionFlightData = normalizeFlightData(response.f, renderedPathname)\n   } else {\n     // An external redirect doesn't contain RSC data.\n     actionResult = undefined"
        },
        {
            "sha": "5a15113cebeb8547fcd6fe602aeea5760020850e",
            "filename": "packages/next/src/client/components/segment-cache-impl/cache-key.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 18,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/e8b99e142b41531b38672f1c8afb3c2d0ff00fa3/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache-key.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/e8b99e142b41531b38672f1c8afb3c2d0ff00fa3/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache-key.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache-key.ts?ref=e8b99e142b41531b38672f1c8afb3c2d0ff00fa3",
            "patch": "@@ -1,6 +1,3 @@\n-import { NEXT_REWRITTEN_QUERY_HEADER } from '../app-router-headers'\n-import type { RSCResponse } from '../router-reducer/fetch-server-response'\n-\n // TypeScript trick to simulate opaque types, like in Flow.\n type Opaque<K, T> = T & { __brand: K }\n \n@@ -32,18 +29,3 @@ export function createCacheKey(\n   } as RouteCacheKey\n   return cacheKey\n }\n-\n-export function getRenderedSearch(response: RSCResponse): NormalizedSearch {\n-  // If the server performed a rewrite, the search params used to render the\n-  // page will be different from the params in the request URL. In this case,\n-  // the response will include a header that gives the rewritten search query.\n-  const rewrittenQuery = response.headers.get(NEXT_REWRITTEN_QUERY_HEADER)\n-  if (rewrittenQuery !== null) {\n-    return (\n-      rewrittenQuery === '' ? '' : '?' + rewrittenQuery\n-    ) as NormalizedSearch\n-  }\n-  // If the header is not present, there was no rewrite, so we use the search\n-  // query of the response URL.\n-  return new URL(response.url).search as NormalizedSearch\n-}"
        },
        {
            "sha": "a69461c4c833fd5523abb10f8b706a6d1edf6831",
            "filename": "packages/next/src/client/components/segment-cache-impl/cache.ts",
            "status": "modified",
            "additions": 123,
            "deletions": 32,
            "changes": 155,
            "blob_url": "https://github.com/vercel/next.js/blob/e8b99e142b41531b38672f1c8afb3c2d0ff00fa3/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/e8b99e142b41531b38672f1c8afb3c2d0ff00fa3/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts?ref=e8b99e142b41531b38672f1c8afb3c2d0ff00fa3",
            "patch": "@@ -9,6 +9,7 @@ import type {\n } from '../../../shared/lib/app-router-context.shared-runtime'\n import type {\n   CacheNodeSeedData,\n+  DynamicParamTypesShort,\n   Segment as FlightRouterStateSegment,\n } from '../../../server/app-render/types'\n import { HasLoadingBoundary } from '../../../server/app-render/types'\n@@ -42,7 +43,13 @@ import type {\n   NormalizedSearch,\n   RouteCacheKey,\n } from './cache-key'\n-import { getRenderedSearch } from './cache-key'\n+import {\n+  doesStaticSegmentAppearInURL,\n+  getRenderedPathname,\n+  getRenderedSearch,\n+  parseDynamicParamFromURLPart,\n+  type RouteParam,\n+} from '../../route-params'\n import { createTupleMap, type TupleMap, type Prefix } from './tuple-map'\n import { createLRU } from './lru'\n import {\n@@ -88,7 +95,10 @@ import { FetchStrategy } from '../segment-cache'\n \n export type RouteTree = {\n   key: string\n+  // TODO: Remove the `segment` field, now that it can be reconstructed\n+  // from `param`.\n   segment: FlightRouterStateSegment\n+  param: RouteParam | null\n   slots: null | {\n     [parallelRouteKey: string]: RouteTree\n   }\n@@ -869,19 +879,69 @@ function rejectSegmentCacheEntry(\n   }\n }\n \n-function convertRootTreePrefetchToRouteTree(rootTree: RootTreePrefetch) {\n-  return convertTreePrefetchToRouteTree(rootTree.tree, ROOT_SEGMENT_KEY)\n+function convertRootTreePrefetchToRouteTree(\n+  rootTree: RootTreePrefetch,\n+  renderedPathname: string\n+) {\n+  // Remove trailing and leading slashes\n+  const pathnameParts = renderedPathname.split('/').filter((p) => p !== '')\n+  const index = 0\n+  return convertTreePrefetchToRouteTree(\n+    rootTree.tree,\n+    ROOT_SEGMENT_KEY,\n+    pathnameParts,\n+    index\n+  )\n }\n \n function convertTreePrefetchToRouteTree(\n   prefetch: TreePrefetch,\n-  key: string\n+  key: string,\n+  pathnameParts: Array<string>,\n+  pathnamePartsIndex: number\n ): RouteTree {\n   // Converts the route tree sent by the server into the format used by the\n   // cache. The cached version of the tree includes additional fields, such as a\n   // cache key for each segment. Since this is frequently accessed, we compute\n   // it once instead of on every access. This same cache key is also used to\n   // request the segment from the server.\n+\n+  let segment = prefetch.segment\n+\n+  let doesAppearInURL: boolean\n+  let param: RouteParam | null = null\n+  if (Array.isArray(segment)) {\n+    // This segment is parameterized. Get the param from the pathname.\n+    const paramType = segment[2] as DynamicParamTypesShort\n+    const paramValue = parseDynamicParamFromURLPart(\n+      paramType,\n+      pathnameParts,\n+      pathnamePartsIndex\n+    )\n+    param = {\n+      name: segment[0],\n+      value: paramValue,\n+      type: paramType,\n+    }\n+\n+    // Assign a cache key to the segment, based on the param value. In the\n+    // pre-Segment Cache implementation, the server computes this and sends it\n+    // in the body of the response. In the Segment Cache implementation, the\n+    // server sends an empty string and we fill it in here.\n+    // TODO: This will land in a follow up PR.\n+    // segment[1] = getCacheKeyForDynamicParam(paramValue)\n+\n+    doesAppearInURL = true\n+  } else {\n+    doesAppearInURL = doesStaticSegmentAppearInURL(segment)\n+  }\n+\n+  // Only increment the index if the segment appears in the URL. If it's a\n+  // \"virtual\" segment, like a route group, it remains the same.\n+  const childPathnamePartsIndex = doesAppearInURL\n+    ? pathnamePartsIndex + 1\n+    : pathnamePartsIndex\n+\n   let slots: { [parallelRouteKey: string]: RouteTree } | null = null\n   const prefetchSlots = prefetch.slots\n   if (prefetchSlots !== null) {\n@@ -899,13 +959,17 @@ function convertTreePrefetchToRouteTree(\n       )\n       slots[parallelRouteKey] = convertTreePrefetchToRouteTree(\n         childPrefetch,\n-        childKey\n+        childKey,\n+        pathnameParts,\n+        childPathnamePartsIndex\n       )\n     }\n   }\n+\n   return {\n     key,\n-    segment: prefetch.segment,\n+    segment,\n+    param,\n     slots,\n     isRootLayout: prefetch.isRootLayout,\n     // This field is only relevant to dynamic routes. For a PPR/static route,\n@@ -953,26 +1017,39 @@ function convertFlightRouterStateToRouteTree(\n       slots[parallelRouteKey] = childTree\n     }\n   }\n-\n-  // The navigation implementation expects the search params to be included\n-  // in the segment. However, in the case of a static response, the search\n-  // params are omitted. So the client needs to add them back in when reading\n-  // from the Segment Cache.\n-  //\n-  // For consistency, we'll do this for dynamic responses, too.\n-  //\n-  // TODO: We should move search params out of FlightRouterState and handle them\n-  // entirely on the client, similar to our plan for dynamic params.\n   const originalSegment = flightRouterState[0]\n-  const segmentWithoutSearchParams =\n-    typeof originalSegment === 'string' &&\n-    originalSegment.startsWith(PAGE_SEGMENT_KEY)\n-      ? PAGE_SEGMENT_KEY\n-      : originalSegment\n+\n+  let segment: FlightRouterStateSegment\n+  let param: RouteParam | null = null\n+  if (Array.isArray(originalSegment)) {\n+    const paramValue = originalSegment[3]\n+    param = {\n+      name: originalSegment[0],\n+      value: paramValue === undefined ? null : paramValue,\n+      type: originalSegment[2] as DynamicParamTypesShort,\n+    }\n+    segment = originalSegment\n+  } else {\n+    // The navigation implementation expects the search params to be included\n+    // in the segment. However, in the case of a static response, the search\n+    // params are omitted. So the client needs to add them back in when reading\n+    // from the Segment Cache.\n+    //\n+    // For consistency, we'll do this for dynamic responses, too.\n+    //\n+    // TODO: We should move search params out of FlightRouterState and handle\n+    // them entirely on the client, similar to our plan for dynamic params.\n+    segment =\n+      typeof originalSegment === 'string' &&\n+      originalSegment.startsWith(PAGE_SEGMENT_KEY)\n+        ? PAGE_SEGMENT_KEY\n+        : originalSegment\n+  }\n \n   return {\n     key,\n-    segment: segmentWithoutSearchParams,\n+    segment,\n+    param,\n     slots,\n     isRootLayout: flightRouterState[4] === true,\n     hasLoadingBoundary:\n@@ -1157,15 +1234,21 @@ export async function fetchRouteOnCacheMiss(\n         return null\n       }\n \n-      // Get the search params that were used to render the target page. This may\n-      // be different from the search params in the request URL, if the page\n+      // Get the params that were used to render the target page. These may\n+      // be different from the params in the request URL, if the page\n       // was rewritten.\n+      const renderedPathname = getRenderedPathname(response)\n       const renderedSearch = getRenderedSearch(response)\n \n+      const routeTree = convertRootTreePrefetchToRouteTree(\n+        serverData,\n+        renderedPathname\n+      )\n+\n       const staleTimeMs = serverData.staleTime * 1000\n       fulfillRouteCacheEntry(\n         entry,\n-        convertRootTreePrefetchToRouteTree(serverData),\n+        routeTree,\n         serverData.head,\n         serverData.isHeadPartial,\n         Date.now() + staleTimeMs,\n@@ -1499,7 +1582,15 @@ function writeDynamicTreeResponseIntoCache(\n   canonicalUrl: string,\n   routeIsPPREnabled: boolean\n ) {\n-  const normalizedFlightDataResult = normalizeFlightData(serverData.f)\n+  // Get the URL that was used to render the target page. This may be different\n+  // from the URL in the request URL, if the page was rewritten.\n+  const renderedSearch = getRenderedSearch(response)\n+  const renderedPathname = getRenderedPathname(response)\n+\n+  const normalizedFlightDataResult = normalizeFlightData(\n+    serverData.f,\n+    renderedPathname\n+  )\n   if (\n     // A string result means navigating to this route will result in an\n     // MPA navigation.\n@@ -1533,11 +1624,6 @@ function writeDynamicTreeResponseIntoCache(\n   const isResponsePartial =\n     response.headers.get(NEXT_DID_POSTPONE_HEADER) === '1'\n \n-  // Get the search params that were used to render the target page. This may\n-  // be different from the search params in the request URL, if the page\n-  // was rewritten.\n-  const renderedSearch = getRenderedSearch(response)\n-\n   const fulfilledEntry = fulfillRouteCacheEntry(\n     entry,\n     convertRootFlightRouterStateToRouteTree(flightRouterState),\n@@ -1610,7 +1696,12 @@ function writeDynamicRenderResponseIntoCache(\n     }\n     return null\n   }\n-  const flightDatas = normalizeFlightData(serverData.f)\n+\n+  // Get the URL that was used to render the target page. This may be different\n+  // from the URL in the request URL, if the page was rewritten.\n+  const renderedPathname = getRenderedPathname(response)\n+\n+  const flightDatas = normalizeFlightData(serverData.f, renderedPathname)\n   if (typeof flightDatas === 'string') {\n     // This means navigating to this route will result in an MPA navigation.\n     // TODO: We should cache this, too, so that the MPA navigation is immediate."
        },
        {
            "sha": "e2ad1fed065c2345323ff43c32c3d359b5108d9e",
            "filename": "packages/next/src/client/components/segment-cache.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/e8b99e142b41531b38672f1c8afb3c2d0ff00fa3/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/e8b99e142b41531b38672f1c8afb3c2d0ff00fa3/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache.ts?ref=e8b99e142b41531b38672f1c8afb3c2d0ff00fa3",
            "patch": "@@ -19,6 +19,7 @@\n \n export type { NavigationResult } from './segment-cache-impl/navigation'\n export type { PrefetchTask } from './segment-cache-impl/scheduler'\n+export type { NormalizedSearch } from './segment-cache-impl/cache-key'\n \n const notEnabled: any = () => {\n   throw new Error("
        },
        {
            "sha": "c241277036bfdf79fb7f7232b6c17ce24261b4cb",
            "filename": "packages/next/src/client/flight-data-helpers.ts",
            "status": "modified",
            "additions": 104,
            "deletions": 3,
            "changes": 107,
            "blob_url": "https://github.com/vercel/next.js/blob/e8b99e142b41531b38672f1c8afb3c2d0ff00fa3/packages%2Fnext%2Fsrc%2Fclient%2Fflight-data-helpers.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/e8b99e142b41531b38672f1c8afb3c2d0ff00fa3/packages%2Fnext%2Fsrc%2Fclient%2Fflight-data-helpers.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fflight-data-helpers.ts?ref=e8b99e142b41531b38672f1c8afb3c2d0ff00fa3",
            "patch": "@@ -1,5 +1,6 @@\n import type {\n   CacheNodeSeedData,\n+  DynamicParamTypesShort,\n   FlightData,\n   FlightDataPath,\n   FlightRouterState,\n@@ -8,6 +9,10 @@ import type {\n } from '../server/app-render/types'\n import type { HeadData } from '../shared/lib/app-router-context.shared-runtime'\n import { PAGE_SEGMENT_KEY } from '../shared/lib/segment'\n+import {\n+  doesStaticSegmentAppearInURL,\n+  parseDynamicParamFromURLPart,\n+} from './route-params'\n \n export type NormalizedFlightData = {\n   /**\n@@ -31,7 +36,8 @@ export type NormalizedFlightData = {\n // we're currently exporting it so we can use it directly. This should be fixed as part of the unification of\n // the different ways we express `FlightSegmentPath`.\n export function getFlightDataPartsFromPath(\n-  flightDataPath: FlightDataPath\n+  flightDataPath: FlightDataPath,\n+  renderedPathname: string\n ): NormalizedFlightData {\n   // Pick the last 4 items from the `FlightDataPath` to get the [tree, seedData, viewport, isHeadPartial].\n   const flightDataPathLength = 4\n@@ -41,6 +47,8 @@ export function getFlightDataPartsFromPath(\n   // The `FlightSegmentPath` is everything except the last three items. For a root render, it won't be present.\n   const segmentPath = flightDataPath.slice(0, -flightDataPathLength)\n \n+  fillTreeWithParamValues(renderedPathname, segmentPath, tree)\n+\n   return {\n     // TODO: Unify these two segment path helpers. We are inconsistently pushing an empty segment (\"\")\n     // to the start of the segment path in some places which makes it hard to use solely the segment path.\n@@ -67,15 +75,18 @@ export function getNextFlightSegmentPath(\n }\n \n export function normalizeFlightData(\n-  flightData: FlightData\n+  flightData: FlightData,\n+  renderedPathname: string\n ): NormalizedFlightData[] | string {\n   // FlightData can be a string when the server didn't respond with a proper flight response,\n   // or when a redirect happens, to signal to the client that it needs to perform an MPA navigation.\n   if (typeof flightData === 'string') {\n     return flightData\n   }\n \n-  return flightData.map(getFlightDataPartsFromPath)\n+  return flightData.map((flightDataPath) =>\n+    getFlightDataPartsFromPath(flightDataPath, renderedPathname)\n+  )\n }\n \n /**\n@@ -169,3 +180,93 @@ function shouldPreserveRefreshMarker(\n ): boolean {\n   return Boolean(refreshMarker && refreshMarker !== 'refresh')\n }\n+\n+function fillTreeWithParamValues(\n+  renderedPathname: string,\n+  segmentPath: FlightSegmentPath,\n+  flightRouterState: FlightRouterState\n+): void {\n+  // Traverse the FlightRouterState and fill in the param values using the\n+  // rendered pathname.\n+\n+  // Remove trailing and leading slashes, then split the pathname into parts.\n+  // These will be assigned as params as we traverse the tree.\n+  const pathnameParts = renderedPathname.split('/').filter((p) => p !== '')\n+\n+  let pathnamePartsIndex = 0\n+\n+  // segmentPath represents the parent path of subtree. It's a repeating pattern\n+  // of parallel route key and segment:\n+  //\n+  //   [string, Segment, string, Segment, string, Segment, ...]\n+  //\n+  // Iterate through the path and skip over the corresponding pathname parts.\n+  for (let i = 0; i < segmentPath.length; i += 2) {\n+    const segment: Segment = segmentPath[i + 1]\n+    if (Array.isArray(segment) || doesStaticSegmentAppearInURL(segment)) {\n+      // This segment appears in the URL, so we need to skip over this part\n+      // of the pathname\n+      pathnamePartsIndex++\n+    }\n+  }\n+\n+  fillTreeWithParamValuesImpl(\n+    renderedPathname,\n+    flightRouterState,\n+    pathnameParts,\n+    pathnamePartsIndex\n+  )\n+}\n+\n+function fillTreeWithParamValuesImpl(\n+  renderedPathname: string,\n+  flightRouterState: FlightRouterState,\n+  pathnameParts: Array<string>,\n+  pathnamePartsIndex: number\n+): void {\n+  const segment = flightRouterState[0]\n+\n+  let doesAppearInURL: boolean\n+  if (Array.isArray(segment)) {\n+    doesAppearInURL = true\n+\n+    // This segment is parameterized. Get the param from the pathname.\n+    const paramType = segment[2] as DynamicParamTypesShort\n+    const paramValue = parseDynamicParamFromURLPart(\n+      paramType,\n+      pathnameParts,\n+      pathnamePartsIndex\n+    )\n+\n+    // Insert the param value into the segment.\n+    // TODO: Eventually this is the value that will be passed to client\n+    // components that render this param.\n+    segment[3] = paramValue\n+\n+    // Assign a cache key to the segment, based on the param value. In the\n+    // pre-Segment Cache implementation, the server computes this and sends it\n+    // in the body of the response. In the Segment Cache implementation, the\n+    // server sends an empty string and we fill it in here.\n+    // TODO: This will land in a follow up PR.\n+    // const segmentCacheKey = getCacheKeyForDynamicParam(paramValue)\n+    // segment[1] = segmentCacheKey\n+  } else {\n+    doesAppearInURL = doesStaticSegmentAppearInURL(segment)\n+  }\n+\n+  // Only increment the index if the segment appears in the URL. If it's a\n+  // \"virtual\" segment, like a route group, it remains the same.\n+  const childPathnamePartsIndex = doesAppearInURL\n+    ? pathnamePartsIndex + 1\n+    : pathnamePartsIndex\n+\n+  const parallelRoutes = flightRouterState[1]\n+  for (const parallelRouteKey in parallelRoutes) {\n+    fillTreeWithParamValuesImpl(\n+      renderedPathname,\n+      parallelRoutes[parallelRouteKey],\n+      pathnameParts,\n+      childPathnamePartsIndex\n+    )\n+  }\n+}"
        },
        {
            "sha": "52e665ca68118f47d110c790d82ecae6aefa2d58",
            "filename": "packages/next/src/client/route-params.ts",
            "status": "added",
            "additions": 124,
            "deletions": 0,
            "changes": 124,
            "blob_url": "https://github.com/vercel/next.js/blob/e8b99e142b41531b38672f1c8afb3c2d0ff00fa3/packages%2Fnext%2Fsrc%2Fclient%2Froute-params.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/e8b99e142b41531b38672f1c8afb3c2d0ff00fa3/packages%2Fnext%2Fsrc%2Fclient%2Froute-params.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Froute-params.ts?ref=e8b99e142b41531b38672f1c8afb3c2d0ff00fa3",
            "patch": "@@ -0,0 +1,124 @@\n+import type { DynamicParamTypesShort } from '../server/app-render/types'\n+import { PAGE_SEGMENT_KEY } from '../shared/lib/segment'\n+import { ROOT_SEGMENT_KEY } from '../shared/lib/segment-cache/segment-value-encoding'\n+import {\n+  NEXT_REWRITTEN_PATH_HEADER,\n+  NEXT_REWRITTEN_QUERY_HEADER,\n+} from './components/app-router-headers'\n+import type { RSCResponse } from './components/router-reducer/fetch-server-response'\n+import type { NormalizedSearch } from './components/segment-cache'\n+\n+type RouteParamValue = string | Array<string> | null\n+\n+export type RouteParam = {\n+  name: string\n+  value: RouteParamValue\n+  type: DynamicParamTypesShort\n+}\n+\n+export function getRenderedSearch(response: RSCResponse): NormalizedSearch {\n+  // If the server performed a rewrite, the search params used to render the\n+  // page will be different from the params in the request URL. In this case,\n+  // the response will include a header that gives the rewritten search query.\n+  const rewrittenQuery = response.headers.get(NEXT_REWRITTEN_QUERY_HEADER)\n+  if (rewrittenQuery !== null) {\n+    return (\n+      rewrittenQuery === '' ? '' : '?' + rewrittenQuery\n+    ) as NormalizedSearch\n+  }\n+  // If the header is not present, there was no rewrite, so we use the search\n+  // query of the response URL.\n+  return new URL(response.url).search as NormalizedSearch\n+}\n+\n+export function getRenderedPathname(response: RSCResponse): string {\n+  // If the server performed a rewrite, the pathname used to render the\n+  // page will be different from the pathname in the request URL. In this case,\n+  // the response will include a header that gives the rewritten pathname.\n+  const rewrittenPath = response.headers.get(NEXT_REWRITTEN_PATH_HEADER)\n+  return rewrittenPath ?? new URL(response.url).pathname\n+}\n+\n+export function parseDynamicParamFromURLPart(\n+  paramType: DynamicParamTypesShort,\n+  pathnameParts: Array<string>,\n+  partIndex: number\n+): RouteParamValue {\n+  // This needs to match the behavior in get-dynamic-param.ts.\n+  switch (paramType) {\n+    // Catchalls\n+    case 'c':\n+    case 'ci': {\n+      // Catchalls receive all the remaining URL parts. If there are no\n+      // remaining pathname parts, return an empty array.\n+      return partIndex < pathnameParts.length\n+        ? pathnameParts.slice(partIndex).map((s) => encodeURIComponent(s))\n+        : []\n+    }\n+    // Optional catchalls\n+    case 'oc': {\n+      // Optional catchalls receive all the remaining URL parts, unless this is\n+      // the end of the pathname, in which case they return null.\n+      return partIndex < pathnameParts.length\n+        ? pathnameParts.slice(partIndex).map((s) => encodeURIComponent(s))\n+        : null\n+    }\n+    // Dynamic\n+    case 'd':\n+    case 'di': {\n+      if (partIndex >= pathnameParts.length) {\n+        // The route tree expected there to be more parts in the URL than there\n+        // actually are. This could happen if the x-nextjs-rewritten-path header\n+        // is incorrectly set, or potentially due to bug in Next.js. TODO:\n+        // Should this be a hard error? During a prefetch, we can just abort.\n+        // During a client navigation, we could trigger a hard refresh. But if\n+        // it happens during initial render, we don't really have any\n+        // recovery options.\n+        return ''\n+      }\n+      return encodeURIComponent(pathnameParts[partIndex])\n+    }\n+    default:\n+      paramType satisfies never\n+      return ''\n+  }\n+}\n+\n+export function doesStaticSegmentAppearInURL(segment: string): boolean {\n+  // This is not a parameterized segment; however, we need to determine\n+  // whether or not this segment appears in the URL. For example, this route\n+  // groups do not appear in the URL, so they should be skipped. Any other\n+  // special cases must be handled here.\n+  // TODO: Consider encoding this directly into the router tree instead of\n+  // inferring it on the client based on the segment type. Something like\n+  // a `doesAppearInURL` flag in FlightRouterState.\n+  if (\n+    segment === ROOT_SEGMENT_KEY ||\n+    // For some reason, the loader tree sometimes includes extra __PAGE__\n+    // \"layouts\" when part of a parallel route. But it's not a leaf node.\n+    // Otherwise, we wouldn't need this special case because pages are\n+    // always leaf nodes.\n+    // TODO: Investigate why the loader produces these fake page segments.\n+    segment.startsWith(PAGE_SEGMENT_KEY) ||\n+    // Route groups.\n+    (segment[0] === '(' && segment.endsWith(')'))\n+  ) {\n+    return false\n+  } else {\n+    // All other segment types appear in the URL\n+    return true\n+  }\n+}\n+\n+export function getCacheKeyForDynamicParam(\n+  paramValue: RouteParamValue\n+): string {\n+  // This needs to match the logic in get-dynamic-param.ts, until we're able to\n+  // unify the various implementations so that these are always computed on\n+  // the client.\n+  return typeof paramValue === 'string'\n+    ? paramValue\n+    : paramValue === null\n+      ? ''\n+      : paramValue.join('/')\n+}"
        },
        {
            "sha": "9409bb9a5ac007e239ac50081fcf2f145a74cc36",
            "filename": "packages/next/src/server/app-render/app-render.tsx",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/e8b99e142b41531b38672f1c8afb3c2d0ff00fa3/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/e8b99e142b41531b38672f1c8afb3c2d0ff00fa3/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx?ref=e8b99e142b41531b38672f1c8afb3c2d0ff00fa3",
            "patch": "@@ -505,12 +505,14 @@ async function generateDynamicRSCPayload(\n       a: options.actionResult,\n       f: flightData,\n       b: ctx.sharedContext.buildId,\n+      c: prepareInitialCanonicalUrl(url),\n     }\n   }\n \n   // Otherwise, it's a regular RSC response.\n   return {\n     b: ctx.sharedContext.buildId,\n+    c: prepareInitialCanonicalUrl(url),\n     f: flightData,\n     S: workStore.isStaticGeneration,\n   }"
        },
        {
            "sha": "4cf8143a92f1d55dabbfbf789ce49e3792bd6adb",
            "filename": "packages/next/src/server/app-render/collect-segment-data.tsx",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/e8b99e142b41531b38672f1c8afb3c2d0ff00fa3/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcollect-segment-data.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/e8b99e142b41531b38672f1c8afb3c2d0ff00fa3/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcollect-segment-data.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcollect-segment-data.tsx?ref=e8b99e142b41531b38672f1c8afb3c2d0ff00fa3",
            "patch": "@@ -3,7 +3,6 @@ import type {\n   FlightRouterState,\n   InitialRSCPayload,\n   Segment as FlightRouterStateSegment,\n-  DynamicParamTypesShort,\n } from './types'\n import type { ManifestNode } from '../../build/webpack/plugins/flight-manifest-plugin'\n \n@@ -309,7 +308,7 @@ function collectSegmentDataImpl(\n }\n \n function encodeSegmentWithPossibleFallbackParam(\n-  segment: [string, string, DynamicParamTypesShort],\n+  segment: Exclude<FlightRouterStateSegment, string>,\n   fallbackRouteParams: FallbackRouteParams\n ): EncodedSegment {\n   const name = segment[0]"
        },
        {
            "sha": "253ba03eb8bbedec511b7772d7f8f5873532ff82",
            "filename": "packages/next/src/server/app-render/types.ts",
            "status": "modified",
            "additions": 29,
            "deletions": 1,
            "changes": 30,
            "blob_url": "https://github.com/vercel/next.js/blob/e8b99e142b41531b38672f1c8afb3c2d0ff00fa3/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Ftypes.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/e8b99e142b41531b38672f1c8afb3c2d0ff00fa3/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Ftypes.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Ftypes.ts?ref=e8b99e142b41531b38672f1c8afb3c2d0ff00fa3",
            "patch": "@@ -36,7 +36,22 @@ export type DynamicParamTypesShort = s.Infer<typeof dynamicParamTypesSchema>\n \n const segmentSchema = s.union([\n   s.string(),\n-  s.tuple([s.string(), s.string(), dynamicParamTypesSchema]),\n+  s.union([\n+    s.tuple([s.string(), s.string(), dynamicParamTypesSchema]),\n+    // On the client, the dynamic param array contains an additional\n+    // slot for param value.\n+    s.tuple([\n+      // Param name\n+      s.string(),\n+      // Param cache key (almost the same as the value, but arrays are\n+      // concatenated into strings)\n+      s.string(),\n+      // Dynamic param type\n+      dynamicParamTypesSchema,\n+      // Param value (the one passed to components)\n+      s.nullable(s.union([s.string(), s.array(s.string())])),\n+    ]),\n+  ]),\n ])\n \n export type Segment = s.Infer<typeof segmentSchema>\n@@ -313,6 +328,9 @@ export type InitialRSCPayload = {\n   b: string\n   /** assetPrefix */\n   p: string\n+  // TODO: This isn't really the \"canonical\" URL (which we usually use to refer\n+  // to the URL shown in the browser), it's the URL used to render the page,\n+  // which may have been rewritten on the server.\n   /** initialCanonicalUrlParts */\n   c: string[]\n   /** couldBeIntercepted */\n@@ -333,6 +351,11 @@ export type InitialRSCPayload = {\n export type NavigationFlightResponse = {\n   /** buildId */\n   b: string\n+  // TODO: This isn't really the \"canonical\" URL (which we usually use to refer\n+  // to the URL shown in the browser), it's the URL used to render the page,\n+  // which may have been rewritten on the server.\n+  /** canonicalUrlParts */\n+  c: string[]\n   /** flightData */\n   f: FlightData\n   /** prerendered */\n@@ -345,6 +368,11 @@ export type ActionFlightResponse = {\n   a: ActionResult\n   /** buildId */\n   b: string\n+  // TODO: This isn't really the \"canonical\" URL (which we usually use to refer\n+  // to the URL shown in the browser), it's the URL used to render the page,\n+  // which may have been rewritten on the server.\n+  /** canonicalUrlParts */\n+  c: string[]\n   /** flightData */\n   f: FlightData\n }"
        }
    ],
    "stats": {
        "total": 496,
        "additions": 437,
        "deletions": 59
    }
}