{
    "author": "ztanner",
    "message": "switch development origin verification to be opt-in rather than opt-out (#77395)\n\nTo avoid breaking local development proxies and more complex setups,\nthis ensures that we only block cross-origin development requests when\nopting into the configuration. In a future major release, this will not\nbe opt-in, and will require explicitly providing the allowed origins\nthat can access the special `/_next` endpoints.\n\nThis adds a warning when a cross origin request is detected that would\nbe blocked without explicit configuration.\n\nFixes #77073\nFixes #77253\nFixes #77344",
    "sha": "cdb9a8c3b355593ab19ee6dec7c59e622bf59c81",
    "files": [
        {
            "sha": "028f426b1131916ab12fd73381c59325107ba634",
            "filename": "docs/01-app/04-api-reference/05-config/01-next-config-js/allowedDevOrigins.mdx",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/cdb9a8c3b355593ab19ee6dec7c59e622bf59c81/docs%2F01-app%2F04-api-reference%2F05-config%2F01-next-config-js%2FallowedDevOrigins.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/cdb9a8c3b355593ab19ee6dec7c59e622bf59c81/docs%2F01-app%2F04-api-reference%2F05-config%2F01-next-config-js%2FallowedDevOrigins.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F04-api-reference%2F05-config%2F01-next-config-js%2FallowedDevOrigins.mdx?ref=cdb9a8c3b355593ab19ee6dec7c59e622bf59c81",
            "patch": "@@ -5,6 +5,8 @@ description: Use `allowedDevOrigins` to configure additional origins that can re\n \n {/* The content of this doc is shared between the app and pages router. You can use the `<PagesOnly>Content</PagesOnly>` component to add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. */}\n \n+Next.js does not automatically block cross-origin requests during development, but will block by default in a future major version of Next.js to prevent unauthorized requesting of internal assets/endpoints that are available in development mode.\n+\n To configure a Next.js application to allow requests from origins other than the hostname the server was initialized with (`localhost` by default) you can use the `allowedDevOrigins` config option.\n \n `allowedDevOrigins` allows you to set additional origins that can be used in development mode. For example, to use `local-origin.dev` instead of only `localhost`, open `next.config.js` and add the `allowedDevOrigins` config:\n@@ -14,5 +16,3 @@ module.exports = {\n   allowedDevOrigins: ['local-origin.dev', '*.local-origin.dev'],\n }\n ```\n-\n-Cross-origin requests are blocked by default to prevent unauthorized requesting of internal assets/endpoints which are available in development mode. This behavior is similar to other dev servers like `webpack-dev-middleware` to ensure the same protection."
        },
        {
            "sha": "4fb7dac5e8cf2ae6b0b9850ade3396a46cb7c23d",
            "filename": "packages/next/src/server/config-shared.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/cdb9a8c3b355593ab19ee6dec7c59e622bf59c81/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/cdb9a8c3b355593ab19ee6dec7c59e622bf59c81/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts?ref=cdb9a8c3b355593ab19ee6dec7c59e622bf59c81",
            "patch": "@@ -1144,7 +1144,7 @@ export const defaultConfig: NextConfig = {\n   output: !!process.env.NEXT_PRIVATE_STANDALONE ? 'standalone' : undefined,\n   modularizeImports: undefined,\n   outputFileTracingRoot: process.env.NEXT_PRIVATE_OUTPUT_TRACE_ROOT || '',\n-  allowedDevOrigins: [],\n+  allowedDevOrigins: undefined,\n   experimental: {\n     nodeMiddleware: false,\n     cacheLife: {"
        },
        {
            "sha": "e39c71e66a619ebdcb4fa9212ad5bd12c66e701c",
            "filename": "packages/next/src/server/lib/router-server.ts",
            "status": "modified",
            "additions": 18,
            "deletions": 11,
            "changes": 29,
            "blob_url": "https://github.com/vercel/next.js/blob/cdb9a8c3b355593ab19ee6dec7c59e622bf59c81/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-server.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/cdb9a8c3b355593ab19ee6dec7c59e622bf59c81/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-server.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-server.ts?ref=cdb9a8c3b355593ab19ee6dec7c59e622bf59c81",
            "patch": "@@ -172,15 +172,6 @@ export async function initialize(opts: {\n   ;(globalThis as any)[Symbol.for('@next/middleware-subrequest-id')] =\n     middlewareSubrequestId\n \n-  const allowedOrigins = [\n-    '*.localhost',\n-    'localhost',\n-    ...(config.allowedDevOrigins || []),\n-  ]\n-  if (opts.hostname) {\n-    allowedOrigins.push(opts.hostname)\n-  }\n-\n   const requestHandlerImpl: WorkerRequestHandler = async (req, res) => {\n     // internal headers should not be honored by the request handler\n     if (!process.env.NEXT_PRIVATE_TEST_HEADERS) {\n@@ -332,7 +323,15 @@ export async function initialize(opts: {\n \n       // handle hot-reloader first\n       if (developmentBundler) {\n-        if (blockCrossSite(req, res, allowedOrigins, `${opts.port}`)) {\n+        if (\n+          blockCrossSite(\n+            req,\n+            res,\n+            config.allowedDevOrigins,\n+            opts.hostname,\n+            `${opts.port}`\n+          )\n+        ) {\n           return\n         }\n         const origUrl = req.url || '/'\n@@ -698,7 +697,15 @@ export async function initialize(opts: {\n       })\n \n       if (opts.dev && developmentBundler && req.url) {\n-        if (blockCrossSite(req, socket, allowedOrigins, `${opts.port}`)) {\n+        if (\n+          blockCrossSite(\n+            req,\n+            socket,\n+            config.allowedDevOrigins,\n+            opts.hostname,\n+            `${opts.port}`\n+          )\n+        ) {\n           return\n         }\n         const { basePath, assetPrefix } = config"
        },
        {
            "sha": "ccdefa728cbffcad83602809d783740444bce5e9",
            "filename": "packages/next/src/server/lib/router-utils/block-cross-site.ts",
            "status": "modified",
            "additions": 45,
            "deletions": 18,
            "changes": 63,
            "blob_url": "https://github.com/vercel/next.js/blob/cdb9a8c3b355593ab19ee6dec7c59e622bf59c81/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Fblock-cross-site.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/cdb9a8c3b355593ab19ee6dec7c59e622bf59c81/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Fblock-cross-site.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Fblock-cross-site.ts?ref=cdb9a8c3b355593ab19ee6dec7c59e622bf59c81",
            "patch": "@@ -5,13 +5,54 @@ import net from 'net'\n import { warnOnce } from '../../../build/output/log'\n import { isCsrfOriginAllowed } from '../../app-render/csrf-protection'\n \n+function warnOrBlockRequest(\n+  res: ServerResponse | Duplex,\n+  origin: string | undefined,\n+  mode: 'warn' | 'block'\n+): boolean {\n+  const originString = origin ? `from ${origin}` : ''\n+  if (mode === 'warn') {\n+    warnOnce(\n+      `Cross origin request detected ${originString} to /_next/* resource. In a future major version of Next.js, you will need to explicitly configure \"allowedDevOrigins\" in next.config to allow this.\\nRead more: https://nextjs.org/docs/app/api-reference/config/next-config-js/allowedDevOrigins`\n+    )\n+\n+    return false\n+  }\n+\n+  warnOnce(\n+    `Blocked cross-origin request ${originString} to /_next/* resource. To allow this, configure \"allowedDevOrigins\" in next.config\\nRead more: https://nextjs.org/docs/app/api-reference/config/next-config-js/allowedDevOrigins`\n+  )\n+\n+  if ('statusCode' in res) {\n+    res.statusCode = 403\n+  }\n+\n+  res.end('Unauthorized')\n+\n+  return true\n+}\n+\n export const blockCrossSite = (\n   req: IncomingMessage,\n   res: ServerResponse | Duplex,\n-  allowedOrigins: string[],\n+  allowedDevOrigins: string[] | undefined,\n+  hostname: string | undefined,\n   activePort: string\n ): boolean => {\n-  // only process _next URLs\n+  // in the future, these will be blocked by default when allowed origins aren't configured.\n+  // for now, we warn when allowed origins aren't configured\n+  const mode = typeof allowedDevOrigins === 'undefined' ? 'warn' : 'block'\n+\n+  const allowedOrigins = [\n+    '*.localhost',\n+    'localhost',\n+    ...(allowedDevOrigins || []),\n+  ]\n+  if (hostname) {\n+    allowedOrigins.push(hostname)\n+  }\n+\n+  // only process _next URLs when\n   if (!req.url?.includes('/_next')) {\n     return false\n   }\n@@ -21,14 +62,7 @@ export const blockCrossSite = (\n     req.headers['sec-fetch-mode'] === 'no-cors' &&\n     req.headers['sec-fetch-site'] === 'cross-site'\n   ) {\n-    if ('statusCode' in res) {\n-      res.statusCode = 403\n-    }\n-    res.end('Unauthorized')\n-    warnOnce(\n-      `Blocked cross-origin request to /_next/*. Cross-site requests are blocked in \"no-cors\" mode.`\n-    )\n-    return true\n+    return warnOrBlockRequest(res, undefined, mode)\n   }\n \n   // ensure websocket requests from allowed origin\n@@ -49,14 +83,7 @@ export const blockCrossSite = (\n         !(isIpRequest && isMatchingPort) &&\n         !isCsrfOriginAllowed(originLowerCase, allowedOrigins)\n       ) {\n-        if ('statusCode' in res) {\n-          res.statusCode = 403\n-        }\n-        res.end('Unauthorized')\n-        warnOnce(\n-          `Blocked cross-origin request from ${originLowerCase}. To allow this, configure \"allowedDevOrigins\" in next.config\\nRead more: https://nextjs.org/docs/app/api-reference/config/next-config-js/allowedDevOrigins`\n-        )\n-        return true\n+        return warnOrBlockRequest(res, originLowerCase, mode)\n       }\n     }\n   }"
        },
        {
            "sha": "ee948269293288312f2e0d90d807110a34fa9c72",
            "filename": "test/development/basic/allowed-dev-origins.test.ts",
            "status": "added",
            "additions": 277,
            "deletions": 0,
            "changes": 277,
            "blob_url": "https://github.com/vercel/next.js/blob/cdb9a8c3b355593ab19ee6dec7c59e622bf59c81/test%2Fdevelopment%2Fbasic%2Fallowed-dev-origins.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/cdb9a8c3b355593ab19ee6dec7c59e622bf59c81/test%2Fdevelopment%2Fbasic%2Fallowed-dev-origins.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Fbasic%2Fallowed-dev-origins.test.ts?ref=cdb9a8c3b355593ab19ee6dec7c59e622bf59c81",
            "patch": "@@ -0,0 +1,277 @@\n+import http from 'http'\n+import { join } from 'path'\n+import webdriver from 'next-webdriver'\n+import { createNext, FileRef } from 'e2e-utils'\n+import { NextInstance } from 'e2e-utils'\n+import { fetchViaHTTP, findPort, retry } from 'next-test-utils'\n+\n+describe.each([['', '/docs']])(\n+  'allowed-dev-origins, basePath: %p',\n+  (basePath: string) => {\n+    let next: NextInstance\n+\n+    describe('warn mode', () => {\n+      beforeAll(async () => {\n+        next = await createNext({\n+          files: {\n+            pages: new FileRef(join(__dirname, 'misc/pages')),\n+            public: new FileRef(join(__dirname, 'misc/public')),\n+          },\n+          nextConfig: {\n+            basePath,\n+          },\n+        })\n+\n+        await retry(async () => {\n+          // make sure host server is running\n+          const asset = await fetchViaHTTP(\n+            next.appPort,\n+            '/_next/static/chunks/pages/_app.js'\n+          )\n+          expect(asset.status).toBe(200)\n+        })\n+      })\n+      afterAll(() => next.destroy())\n+\n+      it('should warn about WebSocket from cross-site', async () => {\n+        let server = http.createServer((req, res) => {\n+          res.end(`\n+              <html>\n+                <head>\n+                  <title>testing cross-site</title>\n+                </head>\n+                <body></body>\n+              </html>\n+            `)\n+        })\n+        try {\n+          const port = await findPort()\n+          await new Promise<void>((res) => {\n+            server.listen(port, () => res())\n+          })\n+          const websocketSnippet = `(() => {\n+              const statusEl = document.createElement('p')\n+              statusEl.id = 'status'\n+              document.querySelector('body').appendChild(statusEl)\n+  \n+              const ws = new WebSocket(\"${next.url}/_next/webpack-hmr\")\n+              \n+              ws.addEventListener('error', (err) => {\n+                statusEl.innerText = 'error'\n+              })\n+              ws.addEventListener('open', () => {\n+                statusEl.innerText = 'connected'\n+              })\n+            })()`\n+\n+          // ensure direct port with mismatching port is blocked\n+          const browser = await webdriver(`http://127.0.0.1:${port}`, '/about')\n+          await browser.eval(websocketSnippet)\n+          await retry(async () => {\n+            expect(await browser.elementByCss('#status').text()).toBe(\n+              'connected'\n+            )\n+          })\n+\n+          // ensure different host is blocked\n+          await browser.get(`https://example.vercel.sh/`)\n+          await browser.eval(websocketSnippet)\n+          await retry(async () => {\n+            expect(await browser.elementByCss('#status').text()).toBe(\n+              'connected'\n+            )\n+          })\n+\n+          expect(next.cliOutput).toContain('Cross origin request detected from')\n+        } finally {\n+          server.close()\n+        }\n+      })\n+\n+      it('should not allow loading scripts from cross-site', async () => {\n+        let server = http.createServer((req, res) => {\n+          res.end(`\n+              <html>\n+                <head>\n+                  <title>testing cross-site</title>\n+                </head>\n+                <body></body>\n+              </html>\n+            `)\n+        })\n+        try {\n+          const port = await findPort()\n+          await new Promise<void>((res) => {\n+            server.listen(port, () => res())\n+          })\n+          const scriptSnippet = `(() => {\n+              const statusEl = document.createElement('p')\n+              statusEl.id = 'status'\n+              document.querySelector('body').appendChild(statusEl)\n+  \n+              const script = document.createElement('script')\n+              script.src = \"${next.url}/_next/static/chunks/pages/_app.js\"\n+              \n+              script.onerror = (err) => {\n+                statusEl.innerText = 'error'\n+              }\n+              script.onload = () => {\n+                statusEl.innerText = 'connected'\n+              }\n+              document.querySelector('body').appendChild(script)\n+            })()`\n+\n+          // ensure direct port with mismatching port is blocked\n+          const browser = await webdriver(`http://127.0.0.1:${port}`, '/about')\n+          await browser.eval(scriptSnippet)\n+\n+          await retry(async () => {\n+            expect(await browser.elementByCss('#status').text()).toBe(\n+              'connected'\n+            )\n+          })\n+\n+          // ensure different host is blocked\n+          await browser.get(`https://example.vercel.sh/`)\n+          await browser.eval(scriptSnippet)\n+\n+          await retry(async () => {\n+            expect(await browser.elementByCss('#status').text()).toBe(\n+              'connected'\n+            )\n+          })\n+\n+          expect(next.cliOutput).toContain('Cross origin request detected from')\n+        } finally {\n+          server.close()\n+        }\n+      })\n+    })\n+\n+    describe('block mode', () => {\n+      beforeAll(async () => {\n+        next = await createNext({\n+          files: {\n+            pages: new FileRef(join(__dirname, 'misc/pages')),\n+            public: new FileRef(join(__dirname, 'misc/public')),\n+          },\n+          nextConfig: {\n+            basePath,\n+            allowedDevOrigins: ['localhost'],\n+          },\n+        })\n+\n+        await retry(async () => {\n+          // make sure host server is running\n+          const asset = await fetchViaHTTP(\n+            next.appPort,\n+            '/_next/static/chunks/pages/_app.js'\n+          )\n+          expect(asset.status).toBe(200)\n+        })\n+      })\n+      afterAll(() => next.destroy())\n+\n+      it('should not allow dev WebSocket from cross-site', async () => {\n+        let server = http.createServer((req, res) => {\n+          res.end(`\n+              <html>\n+                <head>\n+                  <title>testing cross-site</title>\n+                </head>\n+                <body></body>\n+              </html>\n+            `)\n+        })\n+        try {\n+          const port = await findPort()\n+          await new Promise<void>((res) => {\n+            server.listen(port, () => res())\n+          })\n+          const websocketSnippet = `(() => {\n+              const statusEl = document.createElement('p')\n+              statusEl.id = 'status'\n+              document.querySelector('body').appendChild(statusEl)\n+  \n+              const ws = new WebSocket(\"${next.url}/_next/webpack-hmr\")\n+              \n+              ws.addEventListener('error', (err) => {\n+                statusEl.innerText = 'error'\n+              })\n+              ws.addEventListener('open', () => {\n+                statusEl.innerText = 'connected'\n+              })\n+            })()`\n+\n+          // ensure direct port with mismatching port is blocked\n+          const browser = await webdriver(`http://127.0.0.1:${port}`, '/about')\n+          await browser.eval(websocketSnippet)\n+          await retry(async () => {\n+            expect(await browser.elementByCss('#status').text()).toBe('error')\n+          })\n+\n+          // ensure different host is blocked\n+          await browser.get(`https://example.vercel.sh/`)\n+          await browser.eval(websocketSnippet)\n+          await retry(async () => {\n+            expect(await browser.elementByCss('#status').text()).toBe('error')\n+          })\n+        } finally {\n+          server.close()\n+        }\n+      })\n+\n+      it('should not allow loading scripts from cross-site', async () => {\n+        let server = http.createServer((req, res) => {\n+          res.end(`\n+              <html>\n+                <head>\n+                  <title>testing cross-site</title>\n+                </head>\n+                <body></body>\n+              </html>\n+            `)\n+        })\n+        try {\n+          const port = await findPort()\n+          await new Promise<void>((res) => {\n+            server.listen(port, () => res())\n+          })\n+          const scriptSnippet = `(() => {\n+              const statusEl = document.createElement('p')\n+              statusEl.id = 'status'\n+              document.querySelector('body').appendChild(statusEl)\n+  \n+              const script = document.createElement('script')\n+              script.src = \"${next.url}/_next/static/chunks/pages/_app.js\"\n+              \n+              script.onerror = (err) => {\n+                statusEl.innerText = 'error'\n+              }\n+              script.onload = () => {\n+                statusEl.innerText = 'connected'\n+              }\n+              document.querySelector('body').appendChild(script)\n+            })()`\n+\n+          // ensure direct port with mismatching port is blocked\n+          const browser = await webdriver(`http://127.0.0.1:${port}`, '/about')\n+          await browser.eval(scriptSnippet)\n+          await retry(async () => {\n+            expect(await browser.elementByCss('#status').text()).toBe('error')\n+          })\n+\n+          // ensure different host is blocked\n+          await browser.get(`https://example.vercel.sh/`)\n+          await browser.eval(scriptSnippet)\n+\n+          await retry(async () => {\n+            expect(await browser.elementByCss('#status').text()).toBe('error')\n+          })\n+        } finally {\n+          server.close()\n+        }\n+      })\n+    })\n+  }\n+)"
        },
        {
            "sha": "ddb24527c11a4621769dd5215dab348b9d801ec8",
            "filename": "test/development/basic/misc.test.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 103,
            "changes": 104,
            "blob_url": "https://github.com/vercel/next.js/blob/cdb9a8c3b355593ab19ee6dec7c59e622bf59c81/test%2Fdevelopment%2Fbasic%2Fmisc.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/cdb9a8c3b355593ab19ee6dec7c59e622bf59c81/test%2Fdevelopment%2Fbasic%2Fmisc.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Fbasic%2Fmisc.test.ts?ref=cdb9a8c3b355593ab19ee6dec7c59e622bf59c81",
            "patch": "@@ -1,10 +1,9 @@\n import url from 'url'\n-import http from 'http'\n import { join } from 'path'\n import webdriver from 'next-webdriver'\n import { createNext, FileRef } from 'e2e-utils'\n import { NextInstance } from 'e2e-utils'\n-import { fetchViaHTTP, findPort, renderViaHTTP, retry } from 'next-test-utils'\n+import { fetchViaHTTP, renderViaHTTP } from 'next-test-utils'\n \n describe.each([[''], ['/docs']])(\n   'misc basic dev tests, basePath: %p',\n@@ -43,107 +42,6 @@ describe.each([[''], ['/docs']])(\n     })\n \n     describe('With Security Related Issues', () => {\n-      it('should not allow dev WebSocket from cross-site', async () => {\n-        let server = http.createServer((req, res) => {\n-          res.end(`\n-            <html>\n-              <head>\n-                <title>testing cross-site</title>\n-              </head>\n-              <body></body>\n-            </html>\n-          `)\n-        })\n-        try {\n-          const port = await findPort()\n-          await new Promise<void>((res) => {\n-            server.listen(port, () => res())\n-          })\n-          const websocketSnippet = `(() => {\n-            const statusEl = document.createElement('p')\n-            statusEl.id = 'status'\n-            document.querySelector('body').appendChild(statusEl)\n-\n-            const ws = new WebSocket(\"${next.url}/_next/webpack-hmr\")\n-            \n-            ws.addEventListener('error', (err) => {\n-              statusEl.innerText = 'error'\n-            })\n-            ws.addEventListener('open', () => {\n-              statusEl.innerText = 'connected'\n-            })\n-          })()`\n-\n-          // ensure direct port with mismatching port is blocked\n-          const browser = await webdriver(`http://127.0.0.1:${port}`, '/about')\n-          await browser.eval(websocketSnippet)\n-          await retry(async () => {\n-            expect(await browser.elementByCss('#status').text()).toBe('error')\n-          })\n-\n-          // ensure different host is blocked\n-          await browser.get(`https://example.vercel.sh/`)\n-          await browser.eval(websocketSnippet)\n-          await retry(async () => {\n-            expect(await browser.elementByCss('#status').text()).toBe('error')\n-          })\n-        } finally {\n-          server.close()\n-        }\n-      })\n-\n-      it('should not allow loading scripts from cross-site', async () => {\n-        let server = http.createServer((req, res) => {\n-          res.end(`\n-            <html>\n-              <head>\n-                <title>testing cross-site</title>\n-              </head>\n-              <body></body>\n-            </html>\n-          `)\n-        })\n-        try {\n-          const port = await findPort()\n-          await new Promise<void>((res) => {\n-            server.listen(port, () => res())\n-          })\n-          const scriptSnippet = `(() => {\n-            const statusEl = document.createElement('p')\n-            statusEl.id = 'status'\n-            document.querySelector('body').appendChild(statusEl)\n-\n-            const script = document.createElement('script')\n-            script.src = \"${next.url}/_next/static/chunks/pages/_app.js\"\n-            \n-            script.onerror = (err) => {\n-              statusEl.innerText = 'error'\n-            }\n-            script.onload = () => {\n-              statusEl.innerText = 'connected'\n-            }\n-            document.querySelector('body').appendChild(script)\n-          })()`\n-\n-          // ensure direct port with mismatching port is blocked\n-          const browser = await webdriver(`http://127.0.0.1:${port}`, '/about')\n-          await browser.eval(scriptSnippet)\n-          await retry(async () => {\n-            expect(await browser.elementByCss('#status').text()).toBe('error')\n-          })\n-\n-          // ensure different host is blocked\n-          await browser.get(`https://example.vercel.sh/`)\n-          await browser.eval(scriptSnippet)\n-\n-          await retry(async () => {\n-            expect(await browser.elementByCss('#status').text()).toBe('error')\n-          })\n-        } finally {\n-          server.close()\n-        }\n-      })\n-\n       it('should not allow accessing files outside .next/static and .next/server directory', async () => {\n         const pathsToCheck = [\n           basePath + '/_next/static/../BUILD_ID',"
        }
    ],
    "stats": {
        "total": 479,
        "additions": 344,
        "deletions": 135
    }
}