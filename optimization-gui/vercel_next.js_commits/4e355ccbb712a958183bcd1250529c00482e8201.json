{
    "author": "bgw",
    "message": "Turbopack: Use a BTreeMap in InvalidatorMap to avoid many `O(n)` traversals when finding child paths (#82133)\n\nThis fixes an `O(n)` iteration of the invalidators (which can be quite large) in `invalidate_path_and_children_execute`.\n\nIt requires the nightly `btree_cursors` API. It's possible to implement this without that API, but it'd be a lot less efficient, and I'm concerned about how hot this codepath might be.\n\nThis codepath is used for both the recursive and non-recursive filesystem watcher, so it impacts all platforms.",
    "sha": "4e355ccbb712a958183bcd1250529c00482e8201",
    "files": [
        {
            "sha": "7381550034d2f1904c059cbe1131be5369e69e4a",
            "filename": "turbopack/crates/turbo-tasks-fs/src/invalidator_map.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 5,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/4e355ccbb712a958183bcd1250529c00482e8201/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Finvalidator_map.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4e355ccbb712a958183bcd1250529c00482e8201/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Finvalidator_map.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Finvalidator_map.rs?ref=4e355ccbb712a958183bcd1250529c00482e8201",
            "patch": "@@ -1,4 +1,5 @@\n use std::{\n+    collections::BTreeMap,\n     path::PathBuf,\n     sync::{LockResult, Mutex, MutexGuard},\n };\n@@ -16,18 +17,18 @@ pub enum WriteContent {\n     Link(ReadRef<LinkContent>),\n }\n \n-type InnerMap = FxHashMap<PathBuf, FxHashMap<Invalidator, Option<WriteContent>>>;\n+pub type LockedInvalidatorMap = BTreeMap<PathBuf, FxHashMap<Invalidator, Option<WriteContent>>>;\n \n pub struct InvalidatorMap {\n     queue: ConcurrentQueue<(PathBuf, Invalidator, Option<WriteContent>)>,\n-    map: Mutex<InnerMap>,\n+    map: Mutex<LockedInvalidatorMap>,\n }\n \n impl Default for InvalidatorMap {\n     fn default() -> Self {\n         Self {\n             queue: ConcurrentQueue::unbounded(),\n-            map: Default::default(),\n+            map: Mutex::<LockedInvalidatorMap>::default(),\n         }\n     }\n }\n@@ -37,7 +38,7 @@ impl InvalidatorMap {\n         Self::default()\n     }\n \n-    pub fn lock(&self) -> LockResult<MutexGuard<'_, InnerMap>> {\n+    pub fn lock(&self) -> LockResult<MutexGuard<'_, LockedInvalidatorMap>> {\n         let mut guard = self.map.lock()?;\n         while let Ok((key, value, write_content)) = self.queue.pop() {\n             guard.entry(key).or_default().insert(value, write_content);\n@@ -76,7 +77,7 @@ impl Serialize for InvalidatorMap {\n         // persisted cache, but we don't invalidate the fs writes. Those read invalidations trigger\n         // re-inserts into the `InvalidatorMap`. If we knew that certain invalidators were only\n         // needed for reads, we could potentially avoid serializing those paths entirely.\n-        let inner: &InnerMap = &self.lock().unwrap();\n+        let inner: &LockedInvalidatorMap = &self.lock().unwrap();\n         serializer.serialize_newtype_struct(\"InvalidatorMap\", inner)\n     }\n }"
        },
        {
            "sha": "6955035d4d7cac7b66520dfd6a7220d29f6e7c44",
            "filename": "turbopack/crates/turbo-tasks-fs/src/lib.rs",
            "status": "modified",
            "additions": 9,
            "deletions": 8,
            "changes": 17,
            "blob_url": "https://github.com/vercel/next.js/blob/4e355ccbb712a958183bcd1250529c00482e8201/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4e355ccbb712a958183bcd1250529c00482e8201/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs?ref=4e355ccbb712a958183bcd1250529c00482e8201",
            "patch": "@@ -1,4 +1,5 @@\n #![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n+#![feature(btree_cursors)] // needed for the `InvalidatorMap` and watcher, reduces time complexity\n #![feature(trivial_bounds)]\n #![feature(min_specialization)]\n #![feature(iter_advance_by)]\n@@ -16,13 +17,15 @@ pub mod invalidation;\n mod invalidator_map;\n pub mod json;\n mod mutex_map;\n+mod path_map;\n mod read_glob;\n mod retry;\n pub mod rope;\n pub mod source_context;\n pub mod util;\n pub(crate) mod virtual_fs;\n mod watcher;\n+\n use std::{\n     borrow::Cow,\n     cmp::{Ordering, min},\n@@ -40,14 +43,10 @@ use anyhow::{Context, Result, anyhow, bail};\n use auto_hash_map::{AutoMap, AutoSet};\n use bitflags::bitflags;\n use dunce::simplified;\n-use glob::Glob;\n use indexmap::IndexSet;\n-use invalidator_map::InvalidatorMap;\n use jsonc_parser::{ParseOptions, parse_to_serde_value};\n use mime::Mime;\n use rayon::iter::{IntoParallelIterator, ParallelIterator};\n-pub use read_glob::ReadGlobResult;\n-use read_glob::{read_glob, track_glob};\n use rustc_hash::FxHashSet;\n use serde::{Deserialize, Serialize};\n use serde_json::Value;\n@@ -60,17 +59,19 @@ use turbo_tasks::{\n     mark_session_dependent, mark_stateful, trace::TraceRawVcs,\n };\n use turbo_tasks_hash::{DeterministicHash, DeterministicHasher, hash_xxh3_hash64};\n-use util::{extract_disk_access, join_path, normalize_path, sys_to_unix, unix_to_sys};\n-pub use virtual_fs::VirtualFileSystem;\n-use watcher::DiskWatcher;\n \n use self::{invalidation::Write, json::UnparsableJson, mutex_map::MutexMap};\n use crate::{\n     attach::AttachedFileSystem,\n-    invalidator_map::WriteContent,\n+    glob::Glob,\n+    invalidator_map::{InvalidatorMap, WriteContent},\n+    read_glob::{read_glob, track_glob},\n     retry::retry_blocking,\n     rope::{Rope, RopeReader},\n+    util::{extract_disk_access, join_path, normalize_path, sys_to_unix, unix_to_sys},\n+    watcher::DiskWatcher,\n };\n+pub use crate::{read_glob::ReadGlobResult, virtual_fs::VirtualFileSystem};\n \n /// A (somewhat arbitrary) filename limit that we should try to keep output file names below.\n ///"
        },
        {
            "sha": "82ad3925078a765c04d170d885ce0531df921868",
            "filename": "turbopack/crates/turbo-tasks-fs/src/path_map.rs",
            "status": "added",
            "additions": 80,
            "deletions": 0,
            "changes": 80,
            "blob_url": "https://github.com/vercel/next.js/blob/4e355ccbb712a958183bcd1250529c00482e8201/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fpath_map.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4e355ccbb712a958183bcd1250529c00482e8201/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fpath_map.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fpath_map.rs?ref=4e355ccbb712a958183bcd1250529c00482e8201",
            "patch": "@@ -0,0 +1,80 @@\n+use std::{\n+    collections::{BTreeMap, btree_map::CursorMut},\n+    ops::Bound,\n+    path::{Path, PathBuf},\n+};\n+\n+/// A thin wrapper around [`BTreeMap<PathBuf, V>`] that provides efficient extraction of child\n+/// paths.\n+///\n+/// In the future, this may use a more efficient representation, like a radix tree or trie.\n+pub trait OrderedPathMapExt<V> {\n+    fn extract_path_with_children<'a>(&'a mut self, path: &'a Path) -> ExtractWithChildren<'a, V>;\n+}\n+\n+impl<V> OrderedPathMapExt<V> for BTreeMap<PathBuf, V> {\n+    fn extract_path_with_children<'a>(&'a mut self, path: &'a Path) -> ExtractWithChildren<'a, V> {\n+        ExtractWithChildren {\n+            cursor: self.lower_bound_mut(Bound::Included(path)),\n+            parent_path: path,\n+        }\n+    }\n+}\n+\n+pub struct ExtractWithChildren<'a, V> {\n+    cursor: CursorMut<'a, PathBuf, V>,\n+    parent_path: &'a Path,\n+}\n+\n+impl<V> Iterator for ExtractWithChildren<'_, V> {\n+    type Item = (PathBuf, V);\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        // this simple implementation works because `Path` implements `Ord` (and `starts_with`)\n+        // using path component comparision, rather than raw byte comparisions. The parent path is\n+        // always guaranteed to be placed immediately before its children (pre-order traversal).\n+        if self\n+            .cursor\n+            .peek_next()\n+            .is_none_or(|(k, _v)| !k.starts_with(self.parent_path))\n+        {\n+            return None;\n+        }\n+        self.cursor.remove_next()\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn test_extract_with_children() {\n+        let mut map = BTreeMap::default();\n+        map.insert(PathBuf::from(\"a\"), 1);\n+        map.insert(PathBuf::from(\"a/b\"), 2);\n+        map.insert(PathBuf::from(\"a/b/c\"), 3);\n+        map.insert(PathBuf::from(\"a/b/d\"), 4);\n+        map.insert(PathBuf::from(\"a/c\"), 5);\n+        map.insert(PathBuf::from(\"x/y/z\"), 6);\n+        map.insert(PathBuf::from(\"z/a/b\"), 7);\n+\n+        let parent_path = PathBuf::from(\"a/b\");\n+        let extracted: Vec<_> = map.extract_path_with_children(&parent_path).collect();\n+\n+        let expected_extracted = vec![\n+            (PathBuf::from(\"a/b\"), 2),\n+            (PathBuf::from(\"a/b/c\"), 3),\n+            (PathBuf::from(\"a/b/d\"), 4),\n+        ];\n+        assert_eq!(extracted, expected_extracted);\n+\n+        let mut expected_remaining = BTreeMap::new();\n+        expected_remaining.insert(PathBuf::from(\"a\"), 1);\n+        expected_remaining.insert(PathBuf::from(\"a/c\"), 5);\n+        expected_remaining.insert(PathBuf::from(\"x/y/z\"), 6);\n+        expected_remaining.insert(PathBuf::from(\"z/a/b\"), 7);\n+\n+        assert_eq!(map, expected_remaining);\n+    }\n+}"
        },
        {
            "sha": "0717076b93ff5c637260efc9448d18423e2506d4",
            "filename": "turbopack/crates/turbo-tasks-fs/src/watcher.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 5,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/4e355ccbb712a958183bcd1250529c00482e8201/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fwatcher.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4e355ccbb712a958183bcd1250529c00482e8201/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fwatcher.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fwatcher.rs?ref=4e355ccbb712a958183bcd1250529c00482e8201",
            "patch": "@@ -17,7 +17,7 @@ use notify::{\n     event::{MetadataKind, ModifyKind, RenameMode},\n };\n use rayon::iter::{IntoParallelIterator, ParallelIterator};\n-use rustc_hash::{FxHashMap, FxHashSet};\n+use rustc_hash::FxHashSet;\n use serde::{Deserialize, Serialize};\n use tracing::instrument;\n use turbo_rcstr::RcStr;\n@@ -29,7 +29,8 @@ use turbo_tasks::{\n use crate::{\n     DiskFileSystemInner, format_absolute_fs_path,\n     invalidation::{WatchChange, WatchStart},\n-    invalidator_map::WriteContent,\n+    invalidator_map::LockedInvalidatorMap,\n+    path_map::OrderedPathMapExt,\n };\n \n static WATCH_RECURSIVE_MODE: LazyLock<RecursiveMode> = LazyLock::new(|| {\n@@ -602,7 +603,7 @@ fn invalidate(\n fn invalidate_path(\n     inner: &DiskFileSystemInner,\n     report_invalidation_reason: bool,\n-    invalidator_map: &mut FxHashMap<PathBuf, FxHashMap<Invalidator, Option<WriteContent>>>,\n+    invalidator_map: &mut LockedInvalidatorMap,\n     paths: impl Iterator<Item = PathBuf>,\n ) {\n     for path in paths {\n@@ -617,11 +618,11 @@ fn invalidate_path(\n fn invalidate_path_and_children_execute(\n     inner: &DiskFileSystemInner,\n     report_invalidation_reason: bool,\n-    invalidator_map: &mut FxHashMap<PathBuf, FxHashMap<Invalidator, Option<WriteContent>>>,\n+    invalidator_map: &mut LockedInvalidatorMap,\n     paths: impl Iterator<Item = PathBuf>,\n ) {\n     for path in paths {\n-        for (_, invalidators) in invalidator_map.extract_if(|key, _| key.starts_with(&path)) {\n+        for (_, invalidators) in invalidator_map.extract_path_with_children(&path) {\n             invalidators\n                 .into_iter()\n                 .for_each(|(i, _)| invalidate(inner, report_invalidation_reason, &path, i));"
        }
    ],
    "stats": {
        "total": 119,
        "additions": 101,
        "deletions": 18
    }
}