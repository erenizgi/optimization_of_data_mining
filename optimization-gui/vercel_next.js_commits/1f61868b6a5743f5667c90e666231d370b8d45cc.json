{
    "author": "mischnic",
    "message": "Turbopack: hierarchical output asset trace (#83041)",
    "sha": "1f61868b6a5743f5667c90e666231d370b8d45cc",
    "files": [
        {
            "sha": "9160e079b8704a0c6b4f397b2a3aad0a4afdb453",
            "filename": "crates/next-api/src/nft_json.rs",
            "status": "modified",
            "additions": 81,
            "deletions": 12,
            "changes": 93,
            "blob_url": "https://github.com/vercel/next.js/blob/1f61868b6a5743f5667c90e666231d370b8d45cc/crates%2Fnext-api%2Fsrc%2Fnft_json.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1f61868b6a5743f5667c90e666231d370b8d45cc/crates%2Fnext-api%2Fsrc%2Fnft_json.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fnft_json.rs?ref=1f61868b6a5743f5667c90e666231d370b8d45cc",
            "patch": "@@ -2,10 +2,11 @@ use std::collections::{BTreeSet, VecDeque};\n \n use anyhow::{Result, bail};\n use serde_json::json;\n+use tracing::{Level, Span};\n use turbo_rcstr::RcStr;\n use turbo_tasks::{\n-    FxIndexMap, ReadRef, ResolvedVc, TryFlatJoinIterExt, TryJoinIterExt, Vc,\n-    graph::{AdjacencyMap, GraphTraversal},\n+    FxIndexMap, ReadRef, ResolvedVc, TryFlatJoinIterExt, TryJoinIterExt, ValueToString, Vc,\n+    graph::{AdjacencyMap, GraphTraversal, Visit, VisitControlFlow},\n };\n use turbo_tasks_fs::{\n     DirectoryEntry, File, FileSystem, FileSystemPath,\n@@ -229,7 +230,8 @@ impl Asset for NftJsonAsset {\n \n         // Collect base assets first\n         for referenced_chunk in\n-            all_assets_from_entries_filtered(Vc::cell(entries), client_root, exclude_glob).await?\n+            all_assets_from_entries_filtered(Vc::cell(entries), Some(client_root), exclude_glob)\n+                .await?\n         {\n             if chunk.eq(referenced_chunk) {\n                 continue;\n@@ -373,45 +375,105 @@ fn relativize_glob(glob: &str, relative_to: FileSystemPath) -> Result<(&str, Fil\n /// Walks the asset graph from multiple assets and collect all referenced\n /// assets, but filters out all client assets and glob matches.\n #[turbo_tasks::function]\n-async fn all_assets_from_entries_filtered(\n+pub async fn all_assets_from_entries_filtered(\n     entries: Vc<OutputAssets>,\n-    client_root: FileSystemPath,\n+    client_root: Option<FileSystemPath>,\n     exclude_glob: Option<Vc<Glob>>,\n ) -> Result<Vc<OutputAssets>> {\n     let exclude_glob = if let Some(exclude_glob) = exclude_glob {\n         Some(exclude_glob.await?)\n     } else {\n         None\n     };\n+    let emit_spans = tracing::enabled!(Level::INFO);\n     Ok(Vc::cell(\n         AdjacencyMap::new()\n             .skip_duplicates()\n             .visit(\n-                entries.await?.iter().copied().map(ResolvedVc::upcast),\n-                |asset| get_referenced_server_assets(asset, &client_root, &exclude_glob),\n+                entries\n+                    .await?\n+                    .iter()\n+                    .map(async |asset| {\n+                        Ok((\n+                            ResolvedVc::upcast(*asset),\n+                            if emit_spans {\n+                                Some(asset.path().to_string().await?)\n+                            } else {\n+                                None\n+                            },\n+                        ))\n+                    })\n+                    .try_join()\n+                    .await?,\n+                OutputAssetFilteredVisit {\n+                    client_root,\n+                    exclude_glob,\n+                    emit_spans,\n+                },\n             )\n             .await\n             .completed()?\n             .into_inner()\n             .into_postorder_topological()\n+            .map(|n| n.0)\n             .collect(),\n     ))\n }\n \n+struct OutputAssetFilteredVisit {\n+    client_root: Option<FileSystemPath>,\n+    exclude_glob: Option<ReadRef<Glob>>,\n+    emit_spans: bool,\n+}\n+impl Visit<(ResolvedVc<Box<dyn OutputAsset>>, Option<ReadRef<RcStr>>)>\n+    for OutputAssetFilteredVisit\n+{\n+    type Edge = (ResolvedVc<Box<dyn OutputAsset>>, Option<ReadRef<RcStr>>);\n+    type EdgesIntoIter = Vec<Self::Edge>;\n+    type EdgesFuture = impl Future<Output = Result<Self::EdgesIntoIter>>;\n+\n+    fn visit(&mut self, edge: Self::Edge) -> VisitControlFlow<Self::Edge> {\n+        VisitControlFlow::Continue(edge)\n+    }\n+\n+    fn edges(\n+        &mut self,\n+        node: &(ResolvedVc<Box<dyn OutputAsset>>, Option<ReadRef<RcStr>>),\n+    ) -> Self::EdgesFuture {\n+        let client_root = self.client_root.clone();\n+        let exclude_glob = self.exclude_glob.clone();\n+        get_referenced_server_assets(self.emit_spans, node.0, client_root, exclude_glob)\n+    }\n+\n+    fn span(\n+        &mut self,\n+        node: &(ResolvedVc<Box<dyn OutputAsset>>, Option<ReadRef<RcStr>>),\n+    ) -> tracing::Span {\n+        if let Some(ident) = &node.1 {\n+            tracing::info_span!(\"asset\", name = display(ident))\n+        } else {\n+            Span::current()\n+        }\n+    }\n+}\n+\n /// Computes the list of all chunk children of a given chunk, but filters out all client assets and\n /// glob matches.\n async fn get_referenced_server_assets(\n+    emit_spans: bool,\n     asset: ResolvedVc<Box<dyn OutputAsset>>,\n-    client_root: &FileSystemPath,\n-    exclude_glob: &Option<ReadRef<Glob>>,\n-) -> Result<Vec<ResolvedVc<Box<dyn OutputAsset>>>> {\n+    client_root: Option<FileSystemPath>,\n+    exclude_glob: Option<ReadRef<Glob>>,\n+) -> Result<Vec<(ResolvedVc<Box<dyn OutputAsset>>, Option<ReadRef<RcStr>>)>> {\n     asset\n         .references()\n         .await?\n         .iter()\n         .map(async |asset| {\n             let asset_path = asset.path().await?;\n-            if asset_path.is_inside_ref(client_root) {\n+            if let Some(client_root) = &client_root\n+                && asset_path.is_inside_ref(client_root)\n+            {\n                 return Ok(None);\n             }\n \n@@ -422,7 +484,14 @@ async fn get_referenced_server_assets(\n                 return Ok(None);\n             }\n \n-            Ok(Some(*asset))\n+            Ok(Some((\n+                *asset,\n+                if emit_spans {\n+                    Some(asset.path().to_string().await?)\n+                } else {\n+                    None\n+                },\n+            )))\n         })\n         .try_flat_join()\n         .await"
        },
        {
            "sha": "51f0baff905d83545578a0896bb94f8a996132fc",
            "filename": "crates/next-core/src/emit.rs",
            "status": "modified",
            "additions": 70,
            "deletions": 9,
            "changes": 79,
            "blob_url": "https://github.com/vercel/next.js/blob/1f61868b6a5743f5667c90e666231d370b8d45cc/crates%2Fnext-core%2Fsrc%2Femit.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1f61868b6a5743f5667c90e666231d370b8d45cc/crates%2Fnext-core%2Fsrc%2Femit.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Femit.rs?ref=1f61868b6a5743f5667c90e666231d370b8d45cc",
            "patch": "@@ -1,8 +1,9 @@\n use anyhow::Result;\n-use tracing::Instrument;\n+use tracing::{Instrument, Level, Span};\n+use turbo_rcstr::RcStr;\n use turbo_tasks::{\n-    FxIndexSet, ResolvedVc, TryFlatJoinIterExt, Vc,\n-    graph::{AdjacencyMap, GraphTraversal},\n+    FxIndexSet, ReadRef, ResolvedVc, TryFlatJoinIterExt, TryJoinIterExt, ValueToString, Vc,\n+    graph::{AdjacencyMap, GraphTraversal, Visit, VisitControlFlow},\n };\n use turbo_tasks_fs::{FileSystemPath, rebase};\n use turbopack_core::{\n@@ -113,18 +114,68 @@ async fn emit_rebase(\n     Ok(())\n }\n \n+struct OutputAssetVisit {\n+    emit_spans: bool,\n+}\n+impl Visit<(ResolvedVc<Box<dyn OutputAsset>>, Option<ReadRef<RcStr>>)> for OutputAssetVisit {\n+    type Edge = (ResolvedVc<Box<dyn OutputAsset>>, Option<ReadRef<RcStr>>);\n+    type EdgesIntoIter = Vec<Self::Edge>;\n+    type EdgesFuture = impl Future<Output = Result<Self::EdgesIntoIter>>;\n+\n+    fn visit(&mut self, edge: Self::Edge) -> VisitControlFlow<Self::Edge> {\n+        VisitControlFlow::Continue(edge)\n+    }\n+\n+    fn edges(\n+        &mut self,\n+        node: &(ResolvedVc<Box<dyn OutputAsset>>, Option<ReadRef<RcStr>>),\n+    ) -> Self::EdgesFuture {\n+        get_referenced_assets(self.emit_spans, node.0)\n+    }\n+\n+    fn span(\n+        &mut self,\n+        node: &(ResolvedVc<Box<dyn OutputAsset>>, Option<ReadRef<RcStr>>),\n+    ) -> tracing::Span {\n+        if let Some(ident) = &node.1 {\n+            tracing::info_span!(\"asset\", name = display(ident))\n+        } else {\n+            Span::current()\n+        }\n+    }\n+}\n+\n /// Walks the asset graph from multiple assets and collect all referenced\n /// assets.\n #[turbo_tasks::function]\n pub async fn all_assets_from_entries(entries: Vc<OutputAssets>) -> Result<Vc<OutputAssets>> {\n+    let emit_spans = tracing::enabled!(Level::INFO);\n     Ok(Vc::cell(\n         AdjacencyMap::new()\n             .skip_duplicates()\n-            .visit(entries.await?.iter().copied(), get_referenced_assets)\n+            .visit(\n+                entries\n+                    .await?\n+                    .iter()\n+                    .map(async |asset| {\n+                        Ok((\n+                            ResolvedVc::upcast(*asset),\n+                            if emit_spans {\n+                                Some(asset.path().to_string().await?)\n+                            } else {\n+                                None\n+                            },\n+                        ))\n+                    })\n+                    .try_join()\n+                    .await?,\n+                OutputAssetVisit { emit_spans },\n+            )\n             .await\n             .completed()?\n             .into_inner()\n             .into_postorder_topological()\n+            .map(|(asset, _)| asset)\n             .collect::<FxIndexSet<_>>()\n             .into_iter()\n             .collect(),\n@@ -133,13 +184,23 @@ pub async fn all_assets_from_entries(entries: Vc<OutputAssets>) -> Result<Vc<Out\n \n /// Computes the list of all chunk children of a given chunk.\n async fn get_referenced_assets(\n+    emit_spans: bool,\n     asset: ResolvedVc<Box<dyn OutputAsset>>,\n-) -> Result<impl Iterator<Item = ResolvedVc<Box<dyn OutputAsset>>> + Send> {\n-    Ok(asset\n+) -> Result<Vec<(ResolvedVc<Box<dyn OutputAsset>>, Option<ReadRef<RcStr>>)>> {\n+    asset\n         .references()\n         .await?\n         .iter()\n-        .copied()\n-        .collect::<Vec<_>>()\n-        .into_iter())\n+        .map(async |asset| {\n+            Ok((\n+                *asset,\n+                if emit_spans {\n+                    Some(asset.path().to_string().await?)\n+                } else {\n+                    None\n+                },\n+            ))\n+        })\n+        .try_join()\n+        .await\n }"
        },
        {
            "sha": "7a956e79f9e81f47a1a359d5a953087a59bd35d8",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/mod.rs",
            "status": "modified",
            "additions": 46,
            "deletions": 15,
            "changes": 61,
            "blob_url": "https://github.com/vercel/next.js/blob/1f61868b6a5743f5667c90e666231d370b8d45cc/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1f61868b6a5743f5667c90e666231d370b8d45cc/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs?ref=1f61868b6a5743f5667c90e666231d370b8d45cc",
            "patch": "@@ -14,7 +14,7 @@ use petgraph::{\n };\n use rustc_hash::{FxHashMap, FxHashSet};\n use serde::{Deserialize, Serialize};\n-use tracing::{Instrument, Span};\n+use tracing::{Instrument, Level, Span};\n use turbo_rcstr::RcStr;\n use turbo_tasks::{\n     CollectiblesSource, FxIndexMap, NonLocalValue, ReadRef, ResolvedVc, TryJoinIterExt,\n@@ -223,12 +223,13 @@ impl SingleModuleGraph {\n         visited_modules: &FxIndexMap<ResolvedVc<Box<dyn Module>>, GraphNodeIndex>,\n         include_traced: bool,\n     ) -> Result<Vc<Self>> {\n+        let emit_spans = tracing::enabled!(Level::INFO);\n         let root_edges = entries\n             .iter()\n             .flat_map(|e| e.entries())\n             .map(|e| async move {\n                 Ok(SingleModuleGraphBuilderEdge {\n-                    to: SingleModuleGraphBuilderNode::new_module(e).await?,\n+                    to: SingleModuleGraphBuilderNode::new_module(emit_spans, e).await?,\n                     export: ExportUsage::All,\n                 })\n             })\n@@ -241,6 +242,7 @@ impl SingleModuleGraph {\n                 root_edges,\n                 SingleModuleGraphBuilder {\n                     visited_modules,\n+                    emit_spans,\n                     include_traced,\n                 },\n             )\n@@ -1667,14 +1669,14 @@ enum SingleModuleGraphBuilderNode {\n         target: ResolvedVc<Box<dyn Module>>,\n         // These two fields are only used for tracing. Derived from `source.ident()` and\n         // `target.ident()`\n-        source_ident: ReadRef<RcStr>,\n-        target_ident: ReadRef<RcStr>,\n+        source_ident: Option<ReadRef<RcStr>>,\n+        target_ident: Option<ReadRef<RcStr>>,\n     },\n     /// A regular module\n     Module {\n         module: ResolvedVc<Box<dyn Module>>,\n         // module.ident().to_string(), eagerly computed for tracing\n-        ident: ReadRef<RcStr>,\n+        ident: Option<ReadRef<RcStr>>,\n     },\n     /// A reference to a module that is already listed in visited_modules\n     VisitedModule {\n@@ -1684,24 +1686,37 @@ enum SingleModuleGraphBuilderNode {\n }\n \n impl SingleModuleGraphBuilderNode {\n-    async fn new_module(module: ResolvedVc<Box<dyn Module>>) -> Result<Self> {\n+    async fn new_module(emit_spans: bool, module: ResolvedVc<Box<dyn Module>>) -> Result<Self> {\n         let ident = module.ident();\n         Ok(Self::Module {\n             module,\n-            ident: ident.to_string().await?,\n+            ident: if emit_spans {\n+                Some(ident.to_string().await?)\n+            } else {\n+                None\n+            },\n         })\n     }\n     async fn new_chunkable_ref(\n+        emit_spans: bool,\n         source: ResolvedVc<Box<dyn Module>>,\n         target: ResolvedVc<Box<dyn Module>>,\n         ref_data: RefData,\n     ) -> Result<Self> {\n         Ok(Self::ChunkableReference {\n             ref_data,\n             source,\n-            source_ident: source.ident().to_string().await?,\n+            source_ident: if emit_spans {\n+                Some(source.ident().to_string().await?)\n+            } else {\n+                None\n+            },\n             target,\n-            target_ident: target.ident().to_string().await?,\n+            target_ident: if emit_spans {\n+                Some(target.ident().to_string().await?)\n+            } else {\n+                None\n+            },\n         })\n     }\n     fn new_visited_module(module: ResolvedVc<Box<dyn Module>>, idx: GraphNodeIndex) -> Self {\n@@ -1722,6 +1737,9 @@ const COMMON_CHUNKING_TYPE: ChunkingType = ChunkingType::Parallel {\n \n struct SingleModuleGraphBuilder<'a> {\n     visited_modules: &'a FxIndexMap<ResolvedVc<Box<dyn Module>>, GraphNodeIndex>,\n+\n+    emit_spans: bool,\n+\n     /// Whether to walk ChunkingType::Traced references\n     include_traced: bool,\n }\n@@ -1767,6 +1785,7 @@ impl Visit<(SingleModuleGraphBuilderNode, ExportUsage)> for SingleModuleGraphBui\n             SingleModuleGraphBuilderNode::VisitedModule { .. } => unreachable!(),\n         };\n         let visited_modules = self.visited_modules;\n+        let emit_spans = self.emit_spans;\n         let include_traced = self.include_traced;\n         async move {\n             Ok(match (module, chunkable_ref_target) {\n@@ -1788,10 +1807,12 @@ impl Visit<(SingleModuleGraphBuilderNode, ExportUsage)> for SingleModuleGraphBui\n                                 if let Some(idx) = visited_modules.get(&target) {\n                                     SingleModuleGraphBuilderNode::new_visited_module(target, *idx)\n                                 } else {\n-                                    SingleModuleGraphBuilderNode::new_module(target).await?\n+                                    SingleModuleGraphBuilderNode::new_module(emit_spans, target)\n+                                        .await?\n                                 }\n                             } else {\n                                 SingleModuleGraphBuilderNode::new_chunkable_ref(\n+                                    emit_spans,\n                                     module,\n                                     target,\n                                     RefData {\n@@ -1814,7 +1835,11 @@ impl Visit<(SingleModuleGraphBuilderNode, ExportUsage)> for SingleModuleGraphBui\n                                 *idx,\n                             )\n                         } else {\n-                            SingleModuleGraphBuilderNode::new_module(chunkable_ref_target).await?\n+                            SingleModuleGraphBuilderNode::new_module(\n+                                emit_spans,\n+                                chunkable_ref_target,\n+                            )\n+                            .await?\n                         },\n                         export,\n                     }]\n@@ -1825,15 +1850,20 @@ impl Visit<(SingleModuleGraphBuilderNode, ExportUsage)> for SingleModuleGraphBui\n     }\n \n     fn span(&mut self, (node, _): &(SingleModuleGraphBuilderNode, ExportUsage)) -> tracing::Span {\n+        if !self.emit_spans {\n+            return Span::current();\n+        }\n+\n         match node {\n-            SingleModuleGraphBuilderNode::Module { ident, .. } => {\n+            SingleModuleGraphBuilderNode::Module {\n+                ident: Some(ident), ..\n+            } => {\n                 tracing::info_span!(\"module\", name = display(ident))\n             }\n-\n             SingleModuleGraphBuilderNode::ChunkableReference {\n                 ref_data,\n-                source_ident,\n-                target_ident,\n+                source_ident: Some(source_ident),\n+                target_ident: Some(target_ident),\n                 ..\n             } => match &ref_data.chunking_type {\n                 ChunkingType::Parallel {\n@@ -1852,6 +1882,7 @@ impl Visit<(SingleModuleGraphBuilderNode, ExportUsage)> for SingleModuleGraphBui\n             SingleModuleGraphBuilderNode::VisitedModule { .. } => {\n                 tracing::info_span!(\"visited module\")\n             }\n+            _ => Span::current(),\n         }\n     }\n }"
        }
    ],
    "stats": {
        "total": 233,
        "additions": 197,
        "deletions": 36
    }
}