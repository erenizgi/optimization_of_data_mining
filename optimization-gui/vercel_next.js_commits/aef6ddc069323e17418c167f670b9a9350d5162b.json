{
    "author": "bgw",
    "message": "Turbopack: Rewrite IntervalMap using a BTreeMap (#81095)\n\nChanges:\r\n- Rewrote using a `BTreeMap`. This makes `update` `O(log n)`. It was previously `O(n)` which could give accidentally-quadratic time complexity when inserting `n` intervals. We don't think we have enough SST files for this to have been an issue, but how this data structure is used could change over time, and it was a bit risky.\r\n- There was some implicit `Option<T>` behavior in `IntervalMap` making it act like a sparse array. This made the type signature and behavior of some of its methods confusing. Removed that from `IntervalMap` and made the few callsites that actually need it explicitly use `Option<T>`.\r\n- Added a small `NaiveIntervalMap` implementation along with a narrowly bounded `TinyInt` type, and prove the correctness of `replace`, `update`, and `iter` by exhaustively comparing against it.\r\n- Added logic to merge adjacent intervals. This isn't really needed given how the map is currently used, but it's a possible optimization for some use-cases, and it helped align the behavior with `NaiveIntervalMap`.\r\n- Use `RangeInclusive<T>` or `impl RangeBounds<T>` instead of just `(u64, u64)` so that the inclusive/exclusive behaviors are always as explicit as possible.\r\n\r\nThe implementation is not entirely optimal, but in part that's because it avoids using the nightly `btree_cursors` feature. However, the big-O time complexity should still be optimal.\r\n\r\nSome additional minor changes to `turbopack/crates/turbo-persistence/src/compaction/selector.rs`:\r\n\r\n- Avoid implicitly-overflowing `as u64` casts, prefer `from` and `try_from`.\r\n- Make `spread` return a `u128`, since that's slightly more correct than a `saturating_add`, the callsites were casting it to a `u128` anyways.\r\n- Add some more comments that are hopefully correct.",
    "sha": "aef6ddc069323e17418c167f670b9a9350d5162b",
    "files": [
        {
            "sha": "97101bedd90d34b9d699059e172859a42e96ecd5",
            "filename": "turbopack/crates/turbo-persistence/src/compaction/interval_map.rs",
            "status": "modified",
            "additions": 366,
            "deletions": 127,
            "changes": 493,
            "blob_url": "https://github.com/vercel/next.js/blob/aef6ddc069323e17418c167f670b9a9350d5162b/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fcompaction%2Finterval_map.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/aef6ddc069323e17418c167f670b9a9350d5162b/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fcompaction%2Finterval_map.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fcompaction%2Finterval_map.rs?ref=aef6ddc069323e17418c167f670b9a9350d5162b",
            "patch": "@@ -1,183 +1,422 @@\n-struct IntervalPoint<T> {\n-    start: u64,\n-    value: Option<T>,\n+use std::{\n+    collections::{BTreeMap, btree_map},\n+    iter::Peekable,\n+    ops::{Bound, RangeBounds, RangeInclusive},\n+};\n+\n+/// Values that can be used as the bound of an interval.\n+///\n+/// Currently only implemented for `u64`.\n+pub trait IntervalBound: Copy + Ord {\n+    fn bound_min() -> Self;\n+    fn bound_max() -> Self;\n+    fn checked_increment(&self) -> Option<Self>;\n+    fn checked_decrement(&self) -> Option<Self>;\n+}\n+\n+impl IntervalBound for u64 {\n+    fn bound_min() -> Self {\n+        Self::MIN\n+    }\n+    fn bound_max() -> Self {\n+        Self::MAX\n+    }\n+    fn checked_increment(&self) -> Option<Self> {\n+        self.checked_add(1)\n+    }\n+    fn checked_decrement(&self) -> Option<Self> {\n+        self.checked_sub(1)\n+    }\n }\n \n-pub struct IntervalMap<T> {\n-    intervals: Vec<IntervalPoint<T>>,\n+fn into_range_inclusive<B>(bounds: impl RangeBounds<B>) -> RangeInclusive<B>\n+where\n+    B: IntervalBound,\n+{\n+    let start = match bounds.start_bound() {\n+        Bound::Included(b) => *b,\n+        Bound::Excluded(b) => b.checked_increment().unwrap_or_else(B::bound_max),\n+        Bound::Unbounded => B::bound_min(),\n+    };\n+\n+    let end = match bounds.end_bound() {\n+        Bound::Included(b) => *b,\n+        Bound::Excluded(b) => b.checked_decrement().unwrap_or_else(B::bound_min),\n+        Bound::Unbounded => B::bound_max(),\n+    };\n+\n+    start..=end\n }\n \n-impl<T> Default for IntervalMap<T> {\n+/// This is a conceptually more efficient version of an array `[T: u64::MAX]` (or `[T:\n+/// B::bound_max()]`), where entries are deduplicated using a variation on [run-length\n+/// encoding][rle].\n+///\n+/// Ranges can be split or merged by [`IntervalMap::update`] and [`IntervalMap::replace`].\n+///\n+/// [rle]: https://en.wikipedia.org/wiki/Run-length_encoding\n+pub struct IntervalMap<T, B = u64> {\n+    /// Represents the start of non-overlapping ranges with values.\n+    ///\n+    /// When constructing `IntervalMap`, we add a `Default::default()` interval starting at\n+    /// `B::bound_min()`.\n+    ///\n+    /// Each interval extends until the start of the next one (exclusive). The last span in the map\n+    /// extends to `B::bound_max()` (inclusive).\n+    interval_starts: BTreeMap<B, T>,\n+}\n+\n+impl<T, B> Default for IntervalMap<T, B>\n+where\n+    T: Default,\n+    B: IntervalBound,\n+{\n     fn default() -> Self {\n-        Self {\n-            intervals: Vec::new(),\n-        }\n+        Self::new()\n     }\n }\n \n-impl<T> IntervalMap<T> {\n+impl<T, B> IntervalMap<T, B>\n+where\n+    T: Default,\n+    B: IntervalBound,\n+{\n+    /// Creates a new [`IntervalMap`] with a [`Default::default`] value spanning from\n+    /// [`IntervalBound::bound_min`] to [`IntervalBound::bound_max`] (inclusive). Typically, that's\n+    /// `0..=u64::MAX`.\n+    ///\n+    /// Note: Unlike many stdlib collections, this collection will perform an allocation during\n+    /// construction. This could be avoided in the future by special-casing of the initial default\n+    /// interval as a lazily constructed or stack allocated value.\n     pub fn new() -> Self {\n-        Default::default()\n+        let mut interval_starts = BTreeMap::new();\n+        interval_starts.insert(B::bound_min(), Default::default());\n+        Self { interval_starts }\n     }\n+}\n \n-    /// Ensures that there is an interval point at the specified location.\n-    fn ensure_point(&mut self, location: u64) -> usize\n-    where\n-        T: Clone,\n-    {\n-        match self\n-            .intervals\n-            .binary_search_by_key(&location, |point| point.start)\n-        {\n-            Ok(index) => index,\n-            Err(index) => {\n-                // If the location does not exist, we need to insert a new interval\n-                let value = if index > 0 {\n-                    self.intervals[index - 1].value.clone()\n-                } else {\n-                    None\n-                };\n-                self.intervals.insert(\n-                    index,\n-                    IntervalPoint {\n-                        start: location,\n-                        value,\n-                    },\n-                );\n-                index\n-            }\n-        }\n+impl<T, B> IntervalMap<T, B>\n+where\n+    B: Ord,\n+{\n+    /// Returns the largest value that's less than ([`Bound::Excluded`]) or equal to\n+    /// ([`Bound::Included`]) the given `bound`.\n+    ///\n+    /// It is guaranteed to return a value, as there's always an interval starting at\n+    /// [`IntervalBound::bound_min`].\n+    ///\n+    /// This is an approximation of the nightly-only `BTreeMap::upper_bound` API, but it returns a\n+    /// key-value pair instead of a cursor.\n+    ///\n+    /// Panics if `bound` is `Bound::Excluded(IntervalBound::bound_min())`, as that would imply an\n+    /// empty range.\n+    fn upper_bound(&self, bound: Bound<&B>) -> Option<(&B, &T)> {\n+        self.interval_starts\n+            .range((Bound::Unbounded, bound))\n+            .next_back()\n     }\n+}\n \n-    /// Applies the update function to all values in the specified range.\n-    pub fn update(&mut self, range: &(u64, u64), mut update: impl FnMut(&mut T))\n-    where\n-        T: Default + Clone,\n-    {\n-        let start = range.0;\n-        let end = range.1;\n-        if start > end {\n+impl<T, B> IntervalMap<T, B>\n+where\n+    B: IntervalBound,\n+    T: Clone + Eq,\n+{\n+    /// Applies the update function to all values in the specified range. It doesn't iterate over\n+    /// every value one-by-one, but instead it iterates over intersecting ranges.\n+    ///\n+    /// Newly equal intervals are merged.\n+    pub fn update(&mut self, range: impl RangeBounds<B>, mut update: impl FnMut(&mut T)) {\n+        let range = into_range_inclusive(range);\n+        let start_bound = *range.start();\n+        let end_bound = *range.end();\n+        if start_bound > end_bound {\n             return;\n         }\n \n-        let start = self.ensure_point(start);\n-        if end == u64::MAX {\n-            for i in start..self.intervals.len() {\n-                update(self.intervals[i].value.get_or_insert_default());\n+        let tail = end_bound.checked_increment().map(|tb| {\n+            (\n+                tb,\n+                self.upper_bound(Bound::Included(&tb))\n+                    .expect(\"at least one interval starting at `B::bound_min`\")\n+                    .1\n+                    .clone(),\n+            )\n+        });\n+\n+        // defer insertions and removals to avoid multiple simultaneous mutable borrows\n+        let mut updated_start_value = None;\n+        let mut remove_list = Vec::new();\n+\n+        // N.B. `prev_value` can be `None` if `start_bound` is `B::bound_min()`\n+        // this value must be cloned because we mutably borrow `interval_starts` below\n+        let prev_value = self\n+            .upper_bound(Bound::Excluded(&start_bound))\n+            .map(|(_, v)| v.clone());\n+\n+        let mut starts_iter = self\n+            .interval_starts\n+            .range_mut((Bound::Included(start_bound), Bound::Included(end_bound)))\n+            .peekable();\n+\n+        // insert or update an interval starting at `start_bound`\n+        let mut prev_value_inner;\n+        let mut prev_value =\n+            if let Some((_, cur_value)) = starts_iter.next_if(|(b, _)| *b == &start_bound) {\n+                update(cur_value);\n+\n+                if Some(&*cur_value) == prev_value.as_ref() {\n+                    // merge identical adjacent intervals\n+                    remove_list.push(start_bound);\n+                }\n+\n+                cur_value\n+            } else {\n+                prev_value_inner = prev_value.expect(\n+                    \"there's no interval starting at `start_bound`, so there must be one before it\",\n+                );\n+\n+                let mut cur_value = prev_value_inner.clone();\n+                update(&mut cur_value);\n+                if cur_value != prev_value_inner {\n+                    // only start a new interval if it's different\n+                    updated_start_value.get_or_insert(cur_value)\n+                } else {\n+                    &mut prev_value_inner\n+                }\n+            };\n+\n+        // update existing intervals from start_bound (exclusive) to end_bound (inclusive)\n+        if start_bound < end_bound {\n+            for (cur_bound, cur_value) in starts_iter {\n+                update(cur_value);\n+                if cur_value == prev_value {\n+                    remove_list.push(*cur_bound);\n+                }\n+                prev_value = cur_value;\n             }\n-        } else {\n-            let end = self.ensure_point(end + 1);\n+        }\n \n-            for i in start..end {\n-                update(self.intervals[i].value.get_or_insert_default());\n+        // don't modify any intervals following the ones we updated\n+        if let Some((tail_bound, tail_value)) = tail {\n+            if prev_value != &tail_value {\n+                self.interval_starts.insert(tail_bound, tail_value);\n+            } else {\n+                // there *might* be a no-longer-needed interval start here, try to remove it\n+                remove_list.push(tail_bound);\n             }\n         }\n-    }\n \n-    /// Tests if any values in the specified range satisfy the predicate.\n-    pub fn test(&self, range: &(u64, u64), mut predicate: impl FnMut(&T) -> bool) -> bool {\n-        let start = range.0;\n-        let end = range.1;\n-        if start > end {\n-            return false;\n+        // apply deferred insertions and removals\n+        for pos in remove_list {\n+            self.interval_starts.remove(&pos);\n+        }\n+        if let Some(start_value) = updated_start_value {\n+            self.interval_starts.insert(start_bound, start_value);\n         }\n+    }\n \n-        let start_index = match self\n-            .intervals\n-            .binary_search_by_key(&start, |point| point.start)\n-        {\n-            Ok(index) => index,\n-            Err(0) => 0,\n-            Err(index) => index - 1,\n-        };\n-\n-        let end_index = match self\n-            .intervals\n-            .binary_search_by_key(&end, |point| point.start)\n+    pub fn replace(&mut self, bounds: impl RangeBounds<B>, value: T) {\n+        // it would be more efficient to implement this directly, but this is good enough for our\n+        // current use-cases\n+        self.update(bounds, |v| *v = value.clone());\n+    }\n+}\n+\n+impl<T, B> IntervalMap<T, B>\n+where\n+    B: IntervalBound,\n+{\n+    /// Returns an iterator over all the intervals intersecting with the given range and their\n+    /// associated values.\n+    pub fn iter_intersecting(&self, range: impl RangeBounds<B>) -> IntervalMapIterator<'_, T, B> {\n+        fn inner<T, B>(\n+            this: &IntervalMap<T, B>,\n+            range: RangeInclusive<B>,\n+        ) -> IntervalMapIterator<'_, T, B>\n+        where\n+            B: IntervalBound,\n         {\n-            Ok(index) => index + 1,\n-            Err(index) => index,\n-        };\n-\n-        for i in start_index..end_index {\n-            if let Some(value) = &self.intervals[i].value\n-                && predicate(value)\n-            {\n-                return true;\n+            // the first intersecting range may begin before `range.start()`\n+            let (start_position, _) = this\n+                .upper_bound(Bound::Included(range.start()))\n+                .expect(\"at least one interval starting at `B::bound_min`\");\n+            IntervalMapIterator {\n+                starts_iter: this.interval_starts.range(start_position..).peekable(),\n+                end_bound: *range.end(),\n             }\n         }\n-        false\n+        // slightly reduce monomorphization\n+        inner(self, into_range_inclusive(range))\n     }\n \n-    /// Returns an iterator over the ranges and their associated values.\n-    pub fn ranges(&self) -> impl Iterator<Item = ((u64, u64), &T)> {\n-        (0..self.intervals.len()).filter_map(move |i| {\n-            let start = self.intervals[i].start;\n-            let end = if i + 1 < self.intervals.len() {\n-                self.intervals[i + 1].start - 1\n-            } else {\n-                u64::MAX\n-            };\n-            self.intervals[i]\n-                .value\n-                .as_ref()\n-                .map(|value| ((start, end), value))\n-        })\n+    /// Returns an iterator over all the intervals and their associated values.\n+    pub fn iter(&self) -> IntervalMapIterator<'_, T, B> {\n+        IntervalMapIterator {\n+            starts_iter: self.interval_starts.range(..).peekable(),\n+            end_bound: B::bound_max(),\n+        }\n+    }\n+}\n+\n+pub struct IntervalMapIterator<'a, T, B> {\n+    /// An iterator of `interval_starts` with an unbounded end.\n+    starts_iter: Peekable<btree_map::Range<'a, B, T>>,\n+    end_bound: B,\n+}\n+\n+impl<'a, T, B> Iterator for IntervalMapIterator<'a, T, B>\n+where\n+    B: IntervalBound,\n+{\n+    type Item = (RangeInclusive<B>, &'a T);\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        let (start_bound, value) = self.starts_iter.next()?;\n+        if start_bound > &self.end_bound {\n+            return None;\n+        }\n+        let bound_end = self\n+            .starts_iter\n+            .peek()\n+            .map(|entry| entry.0.checked_decrement().unwrap_or_else(B::bound_min))\n+            .unwrap_or_else(|| B::bound_max());\n+        Some(((*start_bound)..=bound_end, value))\n     }\n }\n \n #[cfg(test)]\n mod tests {\n     use super::*;\n+    use crate::compaction::naive_interval_map::{NaiveIntervalMap, TinyInt};\n \n     #[test]\n     fn test_interval_map() {\n         let mut map = IntervalMap::new();\n-        map.update(&(5, 15), |v| *v |= 1);\n-        map.update(&(10, 15), |v| *v |= 2);\n-        map.update(&(10, 20), |v| *v |= 4);\n-        map.update(&(0, u64::MAX), |v| *v |= 8);\n-        map.update(&(15, 20), |v| *v |= 16);\n+        map.update(5..=15, |v| *v |= 1);\n+        map.update(10..=15, |v| *v |= 2);\n+        map.update(10..=20, |v| *v |= 4);\n+        map.update(0..=u64::MAX, |v| *v |= 8);\n+        map.update(15..=20, |v| *v |= 16);\n+        map.update(25..=30, |v| *v |= 32);\n+\n+        let result: Vec<_> = map.iter().collect();\n+        let expected = vec![\n+            (0..=4, &8),\n+            (5..=9, &(1 | 8)),\n+            (10..=14, &(1 | 2 | 4 | 8)),\n+            (15..=15, &(1 | 2 | 4 | 8 | 16)),\n+            (16..=20, &(4 | 8 | 16)),\n+            (21..=24, &8),\n+            (25..=30, &(8 | 32)),\n+            (31..=u64::MAX, &8),\n+        ];\n+        assert_eq!(result, expected);\n+\n+        // re-use expecting from above\n+        let result: Vec<_> = map.iter_intersecting(..).collect();\n+        assert_eq!(result, expected);\n \n+        let result: Vec<_> = map.iter_intersecting(14..=20).collect();\n         let expected = vec![\n-            ((0, 4), &8),\n-            ((5, 9), &(1 | 8)),\n-            ((10, 14), &(1 | 2 | 4 | 8)),\n-            ((15, 15), &(1 | 2 | 4 | 8 | 16)),\n-            ((16, 20), &(4 | 8 | 16)),\n-            ((21, u64::MAX), &8),\n+            (10..=14, &(1 | 2 | 4 | 8)),\n+            (15..=15, &(1 | 2 | 4 | 8 | 16)),\n+            (16..=20, &(4 | 8 | 16)),\n         ];\n-        let result: Vec<_> = map.ranges().collect();\n         assert_eq!(result, expected);\n \n-        // test the `test` method\n-        assert!(map.test(&(0, 10), |v| *v & 1 != 0));\n-        assert!(map.test(&(0, 10), |v| *v & 2 != 0));\n-        assert!(map.test(&(0, 50), |v| *v & 4 != 0));\n-        assert!(map.test(&(15, 15), |v| *v & 16 != 0));\n-        assert!(map.test(&(0, 15), |v| *v & 16 != 0));\n-        assert!(map.test(&(20, 20), |v| *v & 16 != 0));\n-        assert!(map.test(&(20, u64::MAX), |v| *v & 16 != 0));\n-        assert!(map.test(&(0, u64::MAX), |v| *v & 8 != 0));\n-        assert!(map.test(&(0, 0), |v| *v & 8 != 0));\n-        assert!(map.test(&(u64::MAX, u64::MAX), |v| *v & 8 != 0));\n-        assert!(map.test(&(123, 1234), |v| *v & 8 != 0));\n+        let result: Vec<_> = map.iter_intersecting(..=0).collect();\n+        let expected = vec![(0..=4, &8)];\n+        assert_eq!(result, expected);\n+\n+        let result: Vec<_> = map.iter_intersecting(u64::MAX..).collect();\n+        let expected = vec![(31..=u64::MAX, &8)];\n+        assert_eq!(result, expected);\n+\n+        assert!(map.iter_intersecting(0..=10).any(|(_, v)| *v & 1 != 0));\n+        assert!(map.iter_intersecting(0..=10).any(|(_, v)| *v & 2 != 0));\n+        assert!(!map.iter_intersecting(0..10).any(|(_, v)| *v & 2 != 0));\n+        assert!(map.iter_intersecting(0..=50).any(|(_, v)| *v & 4 != 0));\n+        assert!(map.iter_intersecting(15..=15).all(|(_, v)| *v & 16 != 0));\n+        assert!(!map.iter_intersecting(0..=15).all(|(_, v)| *v & 16 != 0));\n+        assert!(map.iter_intersecting(0..=15).any(|(_, v)| *v & 16 != 0));\n+        assert!(map.iter_intersecting(20..=20).all(|(_, v)| *v & 16 != 0));\n+        assert!(map.iter_intersecting(20..).any(|(_, v)| *v & 16 != 0));\n+        assert!(map.iter_intersecting(..).all(|(_, v)| *v & 8 != 0));\n+        assert!(map.iter_intersecting(0..=0).all(|(_, v)| *v & 8 != 0));\n+        assert!(map.iter_intersecting(u64::MAX..).all(|(_, v)| *v & 8 != 0));\n+        assert!(map.iter_intersecting(123..=1234).all(|(_, v)| *v & 8 != 0));\n     }\n \n     #[test]\n     fn test_interval_map_empty() {\n         let map: IntervalMap<u32> = IntervalMap::new();\n-        let result: Vec<_> = map.ranges().collect();\n-        assert!(result.is_empty());\n+        let result: Vec<_> = map.iter().collect();\n+\n+        assert_eq!(result.len(), 1);\n+        assert_eq!(result[0], (0..=u64::MAX, &0));\n     }\n \n     #[test]\n     fn test_interval_map_single_point() {\n         let mut map: IntervalMap<u32> = IntervalMap::new();\n-        map.update(&(10, 10), |v| *v += 1);\n+        map.replace(10..=10, 1);\n \n-        let result: Vec<_> = map.ranges().collect();\n-        assert_eq!(result.len(), 1);\n-        assert_eq!(result[0], ((10, 10), &1));\n+        let expected = vec![(0..=9, &0), (10..=10, &1), (11..=u64::MAX, &0)];\n+        let result: Vec<_> = map.iter().collect();\n+        assert_eq!(result, expected);\n+    }\n+\n+    fn for_all_tiny_int_ranges<T: Copy>(\n+        values: impl IntoIterator<Item = T>,\n+        mut cb: impl FnMut((RangeInclusive<TinyInt>, T)),\n+    ) {\n+        for value in values {\n+            for start in 0..=TinyInt::MAX.0 {\n+                for end in start..=TinyInt::MAX.0 {\n+                    cb((TinyInt(start)..=TinyInt(end), value));\n+                }\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_exhaustive_replace_versus_naive() {\n+        for_all_tiny_int_ranges([0, 1], |a| {\n+            for_all_tiny_int_ranges([1, 2], |b| {\n+                for_all_tiny_int_ranges([2, 3], |c| {\n+                    let mut real_map = IntervalMap::<u32, TinyInt>::new();\n+                    let mut naive_map = NaiveIntervalMap::<u32, TinyInt>::new();\n+                    for (range, value) in [&a, &b, &c] {\n+                        real_map.replace(range.clone(), *value);\n+                        naive_map.replace(range.clone(), *value);\n+                    }\n+                    assert_eq!(\n+                        real_map.iter().collect::<Vec<_>>(),\n+                        naive_map.iter().collect::<Vec<_>>(),\n+                    )\n+                });\n+            });\n+        });\n+    }\n+\n+    #[test]\n+    fn test_exhaustive_update_versus_naive() {\n+        for_all_tiny_int_ranges([1, 2], |a| {\n+            for_all_tiny_int_ranges([2, 4], |b| {\n+                for_all_tiny_int_ranges([4, 8], |c| {\n+                    let mut real_map = IntervalMap::<u32, TinyInt>::new();\n+                    let mut naive_map = NaiveIntervalMap::<u32, TinyInt>::new();\n+                    for (range, flag) in [&a, &b, &c] {\n+                        real_map.update(range.clone(), |v| *v |= flag);\n+                        naive_map.update(range.clone(), |v| *v |= flag);\n+                    }\n+                    assert_eq!(\n+                        real_map.iter().collect::<Vec<_>>(),\n+                        naive_map.iter().collect::<Vec<_>>(),\n+                    )\n+                });\n+            });\n+        });\n     }\n }"
        },
        {
            "sha": "d7356bf576938c08649bc85c46b13f2f8e5ab36c",
            "filename": "turbopack/crates/turbo-persistence/src/compaction/mod.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/aef6ddc069323e17418c167f670b9a9350d5162b/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fcompaction%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/aef6ddc069323e17418c167f670b9a9350d5162b/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fcompaction%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fcompaction%2Fmod.rs?ref=aef6ddc069323e17418c167f670b9a9350d5162b",
            "patch": "@@ -1,2 +1,5 @@\n mod interval_map;\n pub mod selector;\n+\n+#[cfg(test)]\n+mod naive_interval_map;"
        },
        {
            "sha": "a0eb9054945135dcf6509042916fedd709f9c0a5",
            "filename": "turbopack/crates/turbo-persistence/src/compaction/naive_interval_map.rs",
            "status": "added",
            "additions": 120,
            "deletions": 0,
            "changes": 120,
            "blob_url": "https://github.com/vercel/next.js/blob/aef6ddc069323e17418c167f670b9a9350d5162b/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fcompaction%2Fnaive_interval_map.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/aef6ddc069323e17418c167f670b9a9350d5162b/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fcompaction%2Fnaive_interval_map.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fcompaction%2Fnaive_interval_map.rs?ref=aef6ddc069323e17418c167f670b9a9350d5162b",
            "patch": "@@ -0,0 +1,120 @@\n+use std::{\n+    fmt::{self, Display},\n+    iter::Peekable,\n+    ops::{RangeBounds, RangeInclusive},\n+    slice,\n+};\n+\n+use crate::compaction::interval_map::IntervalBound;\n+\n+/// An integer with a very limited range to allow for exhaustive unit tests of\n+/// all possible values.\n+#[derive(Clone, Copy, Debug, Default, Eq, Ord, PartialEq, PartialOrd)]\n+pub struct TinyInt(pub u8);\n+\n+impl TinyInt {\n+    pub const MIN: TinyInt = TinyInt(0);\n+    pub const MAX: TinyInt = TinyInt(6);\n+}\n+\n+impl IntervalBound for TinyInt {\n+    fn bound_min() -> Self {\n+        Self::MIN\n+    }\n+    fn bound_max() -> Self {\n+        Self::MAX\n+    }\n+    fn checked_increment(&self) -> Option<Self> {\n+        if self < &Self::bound_max() {\n+            Some(Self(self.0 + 1))\n+        } else {\n+            None\n+        }\n+    }\n+    fn checked_decrement(&self) -> Option<Self> {\n+        if self > &Self::bound_min() {\n+            Some(Self(self.0 - 1))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl Display for TinyInt {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}\", self.0)\n+    }\n+}\n+\n+/// An impractically slow but very simple implementation of `IntervalMap` used as a known-good\n+/// version for testing the correctness of `IntervalMap`.\n+#[allow(dead_code)]\n+pub struct NaiveIntervalMap<T, B = TinyInt> {\n+    values: Vec<(B, T)>,\n+}\n+\n+impl<T, B> NaiveIntervalMap<T, B>\n+where\n+    T: Default,\n+    B: IntervalBound,\n+{\n+    pub fn new() -> Self {\n+        let mut values = Vec::new();\n+        let mut pos = Some(B::bound_min());\n+        while let Some(cur) = &pos {\n+            values.push((*cur, T::default()));\n+            pos = cur.checked_increment();\n+        }\n+\n+        Self { values }\n+    }\n+}\n+\n+impl<T, B> NaiveIntervalMap<T, B>\n+where\n+    B: IntervalBound,\n+    T: Clone,\n+{\n+    pub fn update(&mut self, bounds: impl RangeBounds<B>, mut update: impl FnMut(&mut T)) {\n+        for (pos, cur_value) in &mut self.values {\n+            if bounds.contains(pos) {\n+                update(cur_value);\n+            }\n+        }\n+    }\n+\n+    pub fn replace(&mut self, bounds: impl RangeBounds<B>, value: T) {\n+        self.update(bounds, |v| *v = value.clone());\n+    }\n+}\n+\n+impl<T, B> NaiveIntervalMap<T, B>\n+where\n+    B: IntervalBound,\n+{\n+    pub fn iter(&self) -> NaiveIntervalMapIterator<'_, T, B> {\n+        NaiveIntervalMapIterator {\n+            values_iter: self.values.iter().peekable(),\n+        }\n+    }\n+}\n+pub struct NaiveIntervalMapIterator<'a, T, B> {\n+    values_iter: Peekable<slice::Iter<'a, (B, T)>>,\n+}\n+\n+impl<'a, T, B> Iterator for NaiveIntervalMapIterator<'a, T, B>\n+where\n+    B: IntervalBound,\n+    T: Eq,\n+{\n+    type Item = (RangeInclusive<B>, &'a T);\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        let (start_pos, cur_value) = self.values_iter.next()?;\n+        let mut end_pos = *start_pos;\n+        while self.values_iter.peek().is_some_and(|(_, v)| v == cur_value) {\n+            end_pos = self.values_iter.next().unwrap().0;\n+        }\n+        Some(((*start_pos)..=end_pos, cur_value))\n+    }\n+}"
        },
        {
            "sha": "7cd8b53c39adce35f789ae3a8b88baa795cd0a72",
            "filename": "turbopack/crates/turbo-persistence/src/compaction/selector.rs",
            "status": "modified",
            "additions": 119,
            "deletions": 98,
            "changes": 217,
            "blob_url": "https://github.com/vercel/next.js/blob/aef6ddc069323e17418c167f670b9a9350d5162b/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fcompaction%2Fselector.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/aef6ddc069323e17418c167f670b9a9350d5162b/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fcompaction%2Fselector.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fcompaction%2Fselector.rs?ref=aef6ddc069323e17418c167f670b9a9350d5162b",
            "patch": "@@ -1,35 +1,37 @@\n+use std::ops::RangeInclusive;\n+\n use smallvec::{SmallVec, smallvec};\n \n use crate::compaction::interval_map::IntervalMap;\n \n-type Range = (u64, u64);\n-\n-/// The trait for the input of the compaction algorithm.\n+/// Represents part of a database (i.e. an SST file) with a range of keys (i.e. hashes) and a size\n+/// of that data in bytes.\n pub trait Compactable {\n-    /// Returns the range of the compactable.\n-    fn range(&self) -> Range;\n+    /// The range of keys stored in this database segment.\n+    fn range(&self) -> RangeInclusive<u64>;\n \n-    /// Returns the size of the compactable.\n+    /// The size of the compactable database segment in bytes.\n     fn size(&self) -> u64;\n }\n \n-fn is_overlapping(a: &Range, b: &Range) -> bool {\n-    a.0 <= b.1 && b.0 <= a.1\n+fn is_overlapping(a: &RangeInclusive<u64>, b: &RangeInclusive<u64>) -> bool {\n+    a.start() <= b.end() && b.start() <= a.end()\n }\n \n-fn spread(range: &Range) -> u64 {\n-    (range.1 - range.0).saturating_add(1)\n+fn spread(range: &RangeInclusive<u64>) -> u128 {\n+    // the spread of `0..=u64::MAX` is `u64::MAX + 1`, so this could overflow as u64\n+    u128::from(range.end() - range.start()) + 1\n }\n \n /// Extends the range `a` to include the range `b`, returns `true` if the range was extended.\n-fn extend_range(a: &mut Range, b: &Range) -> bool {\n+fn extend_range(a: &mut RangeInclusive<u64>, b: &RangeInclusive<u64>) -> bool {\n     let mut extended = false;\n-    if b.0 < a.0 {\n-        a.0 = b.0;\n+    if b.start() < a.start() {\n+        *a = (*b.start())..=(*a.end());\n         extended = true;\n     }\n-    if b.1 > a.1 {\n-        a.1 = b.1;\n+    if b.end() > a.end() {\n+        *a = (*a.start())..=(*b.end());\n         extended = true;\n     }\n     extended\n@@ -53,22 +55,24 @@ pub struct CompactableMetrics {\n /// Computes metrics about the compactables.\n pub fn compute_metrics<T: Compactable>(\n     compactables: &[T],\n-    full_range: Range,\n+    full_range: RangeInclusive<u64>,\n ) -> CompactableMetrics {\n-    let mut interval_map: IntervalMap<(DuplicationInfo, usize)> = IntervalMap::new();\n+    let mut interval_map = IntervalMap::<Option<(DuplicationInfo, usize)>>::new();\n     let mut coverage = 0.0f32;\n     for c in compactables {\n         let range = c.range();\n         coverage += spread(&range) as f32;\n-        interval_map.update(&range, |(dup_info, count)| {\n+        interval_map.update(range.clone(), |value| {\n+            let (dup_info, count) = value.get_or_insert_default();\n             dup_info.add(c.size(), &range);\n             *count += 1;\n         });\n     }\n     let full_spread = spread(&full_range) as f32;\n \n     let (duplicated_size, duplication, overlap) = interval_map\n-        .ranges()\n+        .iter()\n+        .flat_map(|(range, value)| Some((range, value.as_ref()?)))\n         .map(|(range, (dup_info, count))| {\n             let duplicated_size = dup_info.duplication(&range);\n             let total_size = dup_info.size(&range);\n@@ -138,39 +142,57 @@ impl Default for CompactConfig {\n     }\n }\n \n-#[derive(Clone, Default)]\n+#[derive(Clone, Default, Eq, PartialEq)]\n struct DuplicationInfo {\n+    /// The sum of all encountered scaled sizes.\n     total_size: u64,\n+    /// The largest encountered single scaled size.\n     max_size: u64,\n }\n \n impl DuplicationInfo {\n-    fn duplication(&self, range: &Range) -> u64 {\n+    /// Get a value in the range `0..=u64` that represents the estimated amount of duplication\n+    /// across the given range. The units are arbitrary, but linear.\n+    fn duplication(&self, range: &RangeInclusive<u64>) -> u64 {\n         if self.total_size == 0 {\n             return 0;\n         }\n-        ((self.total_size - self.max_size) as u128 * spread(range) as u128 / (u64::MAX as u128 + 1))\n-            as u64\n+        // the maximum numerator value is `u64::MAX + 1`\n+        u64::try_from(\n+            u128::from(self.total_size - self.max_size) * spread(range)\n+                / (u128::from(u64::MAX) + 1),\n+        )\n+        .expect(\"should not overflow, denominator was `u64::MAX+1`\")\n     }\n \n-    fn size(&self, range: &Range) -> u64 {\n+    /// The estimated size (in bytes) of a database segment containing `range` keys.\n+    fn size(&self, range: &RangeInclusive<u64>) -> u64 {\n         if self.total_size == 0 {\n             return 0;\n         }\n-        (self.total_size as u128 * spread(range) as u128 / (u64::MAX as u128 + 1)) as u64\n+        // the maximum numerator value is `u64::MAX + 1`\n+        u64::try_from(u128::from(self.total_size) * spread(range) / (u128::from(u64::MAX) + 1))\n+            .expect(\"should not overflow, denominator was `u64::MAX+1`\")\n     }\n \n-    fn add(&mut self, size: u64, range: &Range) {\n+    fn add(&mut self, size: u64, range: &RangeInclusive<u64>) {\n+        // Assumption: `size` is typically much smaller than `spread(range)`. The spread is some\n+        // fraction of `u64` (the full possible key-space), but no SST file is anywhere close to\n+        // `u64::MAX` bytes.\n+\n         // Scale size to full range:\n-        let scaled_size = (size as u128 * (u64::MAX as u128 + 1) / spread(range) as u128) as u64;\n+        let scaled_size =\n+            u64::try_from(u128::from(size) * (u128::from(u64::MAX) + 1) / spread(range))\n+                .unwrap_or(u64::MAX);\n         self.total_size = self.total_size.saturating_add(scaled_size);\n         self.max_size = self.max_size.max(scaled_size);\n     }\n }\n \n-fn total_duplication_size(duplication: &IntervalMap<DuplicationInfo>) -> u64 {\n+fn total_duplication_size(duplication: &IntervalMap<Option<DuplicationInfo>>) -> u64 {\n     duplication\n-        .ranges()\n+        .iter()\n+        .flat_map(|(range, info)| Some((range, info.as_ref()?)))\n         .map(|(range, info)| info.duplication(&range))\n         .sum()\n }\n@@ -216,7 +238,7 @@ pub fn get_merge_segments<T: Compactable>(\n         'search: loop {\n             let mut current_set = smallvec![start_index];\n             let mut current_size = start_compactable.size();\n-            let mut duplication: IntervalMap<DuplicationInfo> = IntervalMap::new();\n+            let mut duplication = IntervalMap::<Option<DuplicationInfo>>::new();\n             let mut current_skip = 0;\n \n             // We will capture compactables in the current_range until we find a optimal merge\n@@ -304,8 +326,8 @@ pub fn get_merge_segments<T: Compactable>(\n                 // set.\n                 current_set.push(next_index);\n                 current_size += size;\n-                duplication.update(&range, |dup_info| {\n-                    dup_info.add(size, &range);\n+                duplication.update(range.clone(), |dup_info| {\n+                    dup_info.get_or_insert_default().add(size, &range);\n                 });\n             }\n         }\n@@ -321,23 +343,19 @@ pub fn get_merge_segments<T: Compactable>(\n \n     // Remove single compectable segments that don't overlap with previous segments. We don't need\n     // to touch them.\n-    // TODO: Technically it's a bit inefficient to use an IntervalMap here, but\n-    // it's not very hot code anyway.\n-    let mut used_ranges: IntervalMap<bool> = IntervalMap::new();\n+    let mut used_ranges = IntervalMap::<bool>::new();\n     merge_segments.retain(|segment| {\n         // Remove a single element segments which doesn't overlap with previous used ranges.\n         if segment.len() == 1 {\n             let range = compactables[segment[0]].range();\n-            if !used_ranges.test(&range, |in_use| *in_use) {\n+            if !used_ranges.iter_intersecting(range).any(|(_, v)| *v) {\n                 return false;\n             }\n         }\n         // Mark the ranges of the segment as used.\n         for i in segment {\n             let range = compactables[*i].range();\n-            used_ranges.update(&range, |in_use| {\n-                *in_use = true;\n-            });\n+            used_ranges.replace(range, true);\n         }\n         true\n     });\n@@ -357,24 +375,27 @@ mod tests {\n     use super::*;\n \n     struct TestCompactable {\n-        range: Range,\n+        range: RangeInclusive<u64>,\n         size: u64,\n     }\n \n     impl Compactable for TestCompactable {\n-        fn range(&self) -> Range {\n-            self.range\n+        fn range(&self) -> RangeInclusive<u64> {\n+            self.range.clone()\n         }\n \n         fn size(&self) -> u64 {\n             self.size\n         }\n     }\n \n-    fn compact<const N: usize>(ranges: [(u64, u64); N], config: &CompactConfig) -> Vec<Vec<usize>> {\n+    fn compact<const N: usize>(\n+        ranges: [RangeInclusive<u64>; N],\n+        config: &CompactConfig,\n+    ) -> Vec<Vec<usize>> {\n         let compactables = ranges\n-            .iter()\n-            .map(|&range| TestCompactable { range, size: 100 })\n+            .into_iter()\n+            .map(|range| TestCompactable { range, size: 100 })\n             .collect::<Vec<_>>();\n         let jobs = get_merge_segments(&compactables, config);\n         jobs.into_iter()\n@@ -386,15 +407,15 @@ mod tests {\n     fn test_compaction_jobs_by_count() {\n         let merge_jobs = compact(\n             [\n-                (0, 10),\n-                (10, 30),\n-                (9, 13),\n-                (0, 30),\n-                (40, 44),\n-                (41, 42),\n-                (41, 47),\n-                (90, 100),\n-                (30, 40),\n+                0..=10,\n+                10..=30,\n+                9..=13,\n+                0..=30,\n+                40..=44,\n+                41..=42,\n+                41..=47,\n+                90..=100,\n+                30..=40,\n             ],\n             &CompactConfig {\n                 min_merge_count: 2,\n@@ -413,15 +434,15 @@ mod tests {\n     fn test_compaction_jobs_by_size() {\n         let merge_jobs = compact(\n             [\n-                (0, 10),\n-                (10, 30),\n-                (9, 13),\n-                (0, 30),\n-                (40, 44),\n-                (41, 42),\n-                (41, 47),\n-                (90, 100),\n-                (30, 40),\n+                0..=10,\n+                10..=30,\n+                9..=13,\n+                0..=30,\n+                40..=44,\n+                41..=42,\n+                41..=47,\n+                90..=100,\n+                30..=40,\n             ],\n             &CompactConfig {\n                 min_merge_count: 2,\n@@ -440,15 +461,15 @@ mod tests {\n     fn test_compaction_jobs_full() {\n         let merge_jobs = compact(\n             [\n-                (0, 10),\n-                (10, 30),\n-                (9, 13),\n-                (0, 30),\n-                (40, 44),\n-                (41, 42),\n-                (41, 47),\n-                (90, 100),\n-                (30, 40),\n+                0..=10,\n+                10..=30,\n+                9..=13,\n+                0..=30,\n+                40..=44,\n+                41..=42,\n+                41..=47,\n+                90..=100,\n+                30..=40,\n             ],\n             &CompactConfig {\n                 min_merge_count: 2,\n@@ -467,15 +488,15 @@ mod tests {\n     fn test_compaction_jobs_big() {\n         let merge_jobs = compact(\n             [\n-                (0, 10),\n-                (10, 30),\n-                (9, 13),\n-                (0, 30),\n-                (40, 44),\n-                (41, 42),\n-                (41, 47),\n-                (90, 100),\n-                (30, 40),\n+                0..=10,\n+                10..=30,\n+                9..=13,\n+                0..=30,\n+                40..=44,\n+                41..=42,\n+                41..=47,\n+                90..=100,\n+                30..=40,\n             ],\n             &CompactConfig {\n                 min_merge_count: 2,\n@@ -494,15 +515,15 @@ mod tests {\n     fn test_compaction_jobs_small() {\n         let merge_jobs = compact(\n             [\n-                (0, 10),\n-                (10, 30),\n-                (9, 13),\n-                (0, 30),\n-                (40, 44),\n-                (41, 42),\n-                (41, 47),\n-                (90, 100),\n-                (30, 40),\n+                0..=10,\n+                10..=30,\n+                9..=13,\n+                0..=30,\n+                40..=44,\n+                41..=42,\n+                41..=47,\n+                90..=100,\n+                30..=40,\n             ],\n             &CompactConfig {\n                 min_merge_count: 2,\n@@ -526,8 +547,8 @@ mod tests {\n         for (i, c) in compactables.iter().enumerate() {\n             let range = c.range();\n             let size = c.size();\n-            let start = (range.0 / char_width) as usize;\n-            let end = (range.1 / char_width) as usize;\n+            let start = usize::try_from(range.start() / char_width).unwrap();\n+            let end = usize::try_from(range.end() / char_width).unwrap();\n             let mut line = format!(\"{i:>3} | \");\n             for j in 0..WIDTH {\n                 if j >= start && j <= end {\n@@ -568,7 +589,7 @@ mod tests {\n \n         for _ in 0..ITERATIONS {\n             let total_size = containers.iter().map(|c| c.keys.len()).sum::<usize>();\n-            let metrics = compute_metrics(&containers, (0, KEY_RANGE));\n+            let metrics = compute_metrics(&containers, 0..=KEY_RANGE);\n             debug_print_compactables(&containers, KEY_RANGE);\n             println!(\n                 \"size: {}, coverage: {}, overlap: {}, duplication: {}, items: {}\",\n@@ -599,7 +620,7 @@ mod tests {\n                 do_compact(&mut containers, jobs, batch_index);\n                 number_of_compactions += 1;\n \n-                let new_metrics = compute_metrics(&containers, (0, KEY_RANGE));\n+                let new_metrics = compute_metrics(&containers, 0..=KEY_RANGE);\n                 println!(\n                     \"Compaction done: coverage: {} ({}), overlap: {} ({}), duplication: {} ({})\",\n                     new_metrics.coverage,\n@@ -630,7 +651,7 @@ mod tests {\n         }\n         println!(\"Number of compactions: {number_of_compactions}\");\n \n-        let metrics = compute_metrics(&containers, (0, KEY_RANGE));\n+        let metrics = compute_metrics(&containers, 0..=KEY_RANGE);\n         assert!(number_of_compactions < 40);\n         assert!(containers.len() < 30);\n         assert!(metrics.duplication < 0.5);\n@@ -649,8 +670,8 @@ mod tests {\n     }\n \n     impl Compactable for Container {\n-        fn range(&self) -> Range {\n-            (self.keys[0], *self.keys.last().unwrap())\n+        fn range(&self) -> RangeInclusive<u64> {\n+            (self.keys[0])..=(*self.keys.last().unwrap())\n         }\n \n         fn size(&self) -> u64 {\n@@ -660,7 +681,7 @@ mod tests {\n \n     impl Debug for Container {\n         fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-            let (l, r) = self.range();\n+            let (l, r) = self.range().into_inner();\n             write!(\n                 f,\n                 \"#{} {}b {l} - {r} ({})\","
        },
        {
            "sha": "b43cfb771dc8f74b554aafaeb8301372d50b3053",
            "filename": "turbopack/crates/turbo-persistence/src/db.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 4,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/aef6ddc069323e17418c167f670b9a9350d5162b/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fdb.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/aef6ddc069323e17418c167f670b9a9350d5162b/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fdb.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fdb.rs?ref=aef6ddc069323e17418c167f670b9a9350d5162b",
            "patch": "@@ -5,6 +5,7 @@ use std::{\n     fs::{self, File, OpenOptions, ReadDir},\n     io::{BufWriter, Write},\n     mem::{MaybeUninit, swap, transmute},\n+    ops::RangeInclusive,\n     path::{Path, PathBuf},\n     sync::{\n         Arc,\n@@ -747,8 +748,8 @@ impl TurboPersistence {\n         }\n \n         impl Compactable for SstWithRange {\n-            fn range(&self) -> (u64, u64) {\n-                (self.range.min_hash, self.range.max_hash)\n+            fn range(&self) -> RangeInclusive<u64> {\n+                self.range.min_hash..=self.range.max_hash\n             }\n \n             fn size(&self) -> u64 {\n@@ -823,7 +824,7 @@ impl TurboPersistence {\n                 }\n \n                 {\n-                    let metrics = compute_metrics(&ssts_with_ranges, (0, u64::MAX));\n+                    let metrics = compute_metrics(&ssts_with_ranges, 0..=u64::MAX);\n                     let guard = log_mutex.lock();\n                     let mut log = self.open_log()?;\n                     writeln!(\n@@ -839,7 +840,7 @@ impl TurboPersistence {\n                         writeln!(log, \"  merge\")?;\n                         for i in job.iter() {\n                             let seq = ssts_with_ranges[*i].seq;\n-                            let (min, max) = ssts_with_ranges[*i].range();\n+                            let (min, max) = ssts_with_ranges[*i].range().into_inner();\n                             writeln!(log, \"    {seq:08} {min:016x}-{max:016x}\")?;\n                         }\n                     }"
        }
    ],
    "stats": {
        "total": 842,
        "additions": 613,
        "deletions": 229
    }
}