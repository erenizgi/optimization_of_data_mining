{
    "author": "lukesandberg",
    "message": "[turbopack] Make internal functions private and use rcstr! macro (#81041)\n\n## Refactor resolve module and improve RcStr usage\n\n### What?\n- Made several internal methods private that were unnecessarily public\n- Removed unused methods like `ResolveResult.map()`\n- Removed redundant fragment resolution code path\n- Improved RcStr usage by using `rcstr!` macro instead of `.into()` conversions\n- Fixed string handling in resolve functions to use RcStr consistently\n\n### Why?\n\nI was taking a close look at `resolve` to understand how it worked and stumbled across these improvements",
    "sha": "d5d10e17a9330abd2cf7dab5c0b3ae742b9b5c57",
    "files": [
        {
            "sha": "e1cf569c8ccd60884dfe894d0305bc2b4c5257a3",
            "filename": "crates/next-core/src/next_server/resolve.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/d5d10e17a9330abd2cf7dab5c0b3ae742b9b5c57/crates%2Fnext-core%2Fsrc%2Fnext_server%2Fresolve.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d5d10e17a9330abd2cf7dab5c0b3ae742b9b5c57/crates%2Fnext-core%2Fsrc%2Fnext_server%2Fresolve.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_server%2Fresolve.rs?ref=d5d10e17a9330abd2cf7dab5c0b3ae742b9b5c57",
            "patch": "@@ -1,6 +1,6 @@\n use anyhow::Result;\n use serde::{Deserialize, Serialize};\n-use turbo_rcstr::RcStr;\n+use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{NonLocalValue, ResolvedVc, Vc, trace::TraceRawVcs};\n use turbo_tasks_fs::{self, FileJsonContent, FileSystemPath, glob::Glob};\n use turbopack_core::{\n@@ -64,7 +64,7 @@ impl ExternalCjsModulesResolvePlugin {\n \n #[turbo_tasks::function]\n fn condition(root: FileSystemPath) -> Vc<AfterResolvePluginCondition> {\n-    AfterResolvePluginCondition::new(root, Glob::new(\"**/node_modules/**\".into()))\n+    AfterResolvePluginCondition::new(root, Glob::new(rcstr!(\"**/node_modules/**\")))\n }\n \n #[turbo_tasks::value_impl]"
        },
        {
            "sha": "1dd3c70678b212c9aa3d7d08268630efe06e5947",
            "filename": "turbopack/crates/turbopack-core/src/resolve/mod.rs",
            "status": "modified",
            "additions": 31,
            "deletions": 86,
            "changes": 117,
            "blob_url": "https://github.com/vercel/next.js/blob/d5d10e17a9330abd2cf7dab5c0b3ae742b9b5c57/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d5d10e17a9330abd2cf7dab5c0b3ae742b9b5c57/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fmod.rs?ref=d5d10e17a9330abd2cf7dab5c0b3ae742b9b5c57",
            "patch": "@@ -87,7 +87,7 @@ pub enum ModuleResolveResultItem {\n }\n \n impl ModuleResolveResultItem {\n-    pub async fn as_module(&self) -> Result<Option<ResolvedVc<Box<dyn Module>>>> {\n+    async fn as_module(&self) -> Result<Option<ResolvedVc<Box<dyn Module>>>> {\n         Ok(match *self {\n             ModuleResolveResultItem::Module(module) => Some(module),\n             ModuleResolveResultItem::Unknown(source) => {\n@@ -317,7 +317,7 @@ impl ModuleResolveResult {\n     /// [ModuleResolveResult::Unresolvable] in the given list, while keeping\n     /// track of all the affecting_sources in all the [ModuleResolveResult]s.\n     #[turbo_tasks::function]\n-    pub async fn select_first(results: Vec<Vc<ModuleResolveResult>>) -> Result<Vc<Self>> {\n+    async fn select_first(results: Vec<Vc<ModuleResolveResult>>) -> Result<Vc<Self>> {\n         let mut affecting_sources = vec![];\n         for result in &results {\n             affecting_sources.extend(result.await?.affecting_sources_iter());\n@@ -357,7 +357,7 @@ impl ModuleResolveResult {\n     }\n \n     #[turbo_tasks::function]\n-    pub async fn alternatives_with_affecting_sources(\n+    async fn alternatives_with_affecting_sources(\n         results: Vec<Vc<ModuleResolveResult>>,\n         affecting_sources: Vec<ResolvedVc<Box<dyn Source>>>,\n     ) -> Result<Vc<Self>> {\n@@ -694,44 +694,6 @@ impl ResolveResult {\n         self.primary.is_empty()\n     }\n \n-    pub async fn map<A, AF, R, RF>(&self, source_fn: A, affecting_source_fn: R) -> Result<Self>\n-    where\n-        A: Fn(ResolvedVc<Box<dyn Source>>) -> AF,\n-        AF: Future<Output = Result<ResolvedVc<Box<dyn Source>>>>,\n-        R: Fn(ResolvedVc<Box<dyn Source>>) -> RF,\n-        RF: Future<Output = Result<ResolvedVc<Box<dyn Source>>>>,\n-    {\n-        Ok(Self {\n-            primary: self\n-                .primary\n-                .iter()\n-                .map(|(request, result)| {\n-                    let asset_fn = &source_fn;\n-                    let request = request.clone();\n-                    let result = result.clone();\n-                    async move {\n-                        if let ResolveResultItem::Source(asset) = result {\n-                            Ok((request, ResolveResultItem::Source(asset_fn(asset).await?)))\n-                        } else {\n-                            Ok((request, result))\n-                        }\n-                    }\n-                })\n-                .try_join()\n-                .await?\n-                .into_iter()\n-                .collect(),\n-            affecting_sources: self\n-                .affecting_sources\n-                .iter()\n-                .copied()\n-                .map(affecting_source_fn)\n-                .try_join()\n-                .await?\n-                .into_boxed_slice(),\n-        })\n-    }\n-\n     pub async fn map_module<A, AF>(&self, source_fn: A) -> Result<ModuleResolveResult>\n     where\n         A: Fn(ResolvedVc<Box<dyn Source>>) -> AF,\n@@ -804,7 +766,7 @@ impl ResolveResult {\n \n     /// Returns a new [ResolveResult] where all [RequestKey]s are set to the\n     /// passed `request`.\n-    pub fn with_request_ref(&self, request: RcStr) -> Self {\n+    fn with_request_ref(&self, request: RcStr) -> Self {\n         let new_primary = self\n             .primary\n             .iter()\n@@ -840,9 +802,9 @@ impl ResolveResult {\n     }\n }\n \n-pub struct ResolveResultBuilder {\n-    pub primary: FxIndexMap<RequestKey, ResolveResultItem>,\n-    pub affecting_sources: Vec<ResolvedVc<Box<dyn Source>>>,\n+struct ResolveResultBuilder {\n+    primary: FxIndexMap<RequestKey, ResolveResultItem>,\n+    affecting_sources: Vec<ResolvedVc<Box<dyn Source>>>,\n }\n \n impl From<ResolveResultBuilder> for ResolveResult {\n@@ -898,7 +860,7 @@ impl ResolveResult {\n     }\n \n     #[turbo_tasks::function]\n-    pub fn with_affecting_source(&self, source: ResolvedVc<Box<dyn Source>>) -> Result<Vc<Self>> {\n+    fn with_affecting_source(&self, source: ResolvedVc<Box<dyn Source>>) -> Result<Vc<Self>> {\n         Ok(Self {\n             primary: self.primary.clone(),\n             affecting_sources: self\n@@ -912,7 +874,7 @@ impl ResolveResult {\n     }\n \n     #[turbo_tasks::function]\n-    pub fn with_affecting_sources(\n+    fn with_affecting_sources(\n         &self,\n         sources: Vec<ResolvedVc<Box<dyn Source>>>,\n     ) -> Result<Vc<Self>> {\n@@ -932,7 +894,7 @@ impl ResolveResult {\n     /// [ResolveResult::Unresolvable] in the given list, while keeping track\n     /// of all the affecting_sources in all the [ResolveResult]s.\n     #[turbo_tasks::function]\n-    pub async fn select_first(results: Vec<Vc<ResolveResult>>) -> Result<Vc<Self>> {\n+    async fn select_first(results: Vec<Vc<ResolveResult>>) -> Result<Vc<Self>> {\n         let mut affecting_sources = vec![];\n         for result in &results {\n             affecting_sources.extend(result.await?.get_affecting_sources());\n@@ -953,7 +915,7 @@ impl ResolveResult {\n     }\n \n     #[turbo_tasks::function]\n-    pub async fn alternatives(results: Vec<Vc<ResolveResult>>) -> Result<Vc<Self>> {\n+    async fn alternatives(results: Vec<Vc<ResolveResult>>) -> Result<Vc<Self>> {\n         if results.len() == 1 {\n             return Ok(results.into_iter().next().unwrap());\n         }\n@@ -972,7 +934,7 @@ impl ResolveResult {\n     }\n \n     #[turbo_tasks::function]\n-    pub async fn alternatives_with_affecting_sources(\n+    async fn alternatives_with_affecting_sources(\n         results: Vec<Vc<ResolveResult>>,\n         affecting_sources: Vec<ResolvedVc<Box<dyn Source>>>,\n     ) -> Result<Vc<Self>> {\n@@ -1040,7 +1002,7 @@ impl ResolveResult {\n     /// contains [RequestKey]s that don't have the `old_request_key` prefix, but if there are still\n     /// some, they are discarded.\n     #[turbo_tasks::function]\n-    pub fn with_replaced_request_key(\n+    fn with_replaced_request_key(\n         &self,\n         old_request_key: RcStr,\n         request_key: RequestKey,\n@@ -1074,7 +1036,7 @@ impl ResolveResult {\n     /// [ResolveResult] contains [RequestKey]s that do not match the `old_request_key` prefix, but\n     /// if there are still some, they are discarded.\n     #[turbo_tasks::function]\n-    pub async fn with_replaced_request_key_pattern(\n+    async fn with_replaced_request_key_pattern(\n         &self,\n         old_request_key: Vc<Pattern>,\n         request_key: Vc<Pattern>,\n@@ -1109,7 +1071,7 @@ impl ResolveResult {\n     /// Returns a new [ResolveResult] where all [RequestKey]s are set to the\n     /// passed `request`.\n     #[turbo_tasks::function]\n-    pub fn with_request(&self, request: RcStr) -> Vc<Self> {\n+    fn with_request(&self, request: RcStr) -> Vc<Self> {\n         let new_primary = self\n             .primary\n             .iter()\n@@ -1506,10 +1468,10 @@ pub async fn resolve_raw(\n     path: Vc<Pattern>,\n     force_in_lookup_dir: bool,\n ) -> Result<Vc<ResolveResult>> {\n-    async fn to_result(request: &str, path: FileSystemPath) -> Result<Vc<ResolveResult>> {\n+    async fn to_result(request: RcStr, path: FileSystemPath) -> Result<Vc<ResolveResult>> {\n         let RealPathResult { path, symlinks } = &*path.realpath_with_links().await?;\n         Ok(*ResolveResult::source_with_affecting_sources(\n-            RequestKey::new(request.into()),\n+            RequestKey::new(request),\n             ResolvedVc::upcast(FileSource::new(path.clone()).to_resolved().await?),\n             symlinks\n                 .iter()\n@@ -1550,7 +1512,7 @@ pub async fn resolve_raw(\n         } else {\n             for m in matches.iter() {\n                 if let PatternMatch::File(request, path) = m {\n-                    results.push(to_result(request, path.clone()).await?);\n+                    results.push(to_result(request.clone(), path.clone()).await?);\n                 }\n             }\n         }\n@@ -1568,7 +1530,7 @@ pub async fn resolve_raw(\n         }\n         for m in matches.iter() {\n             if let PatternMatch::File(request, path) = m {\n-                results.push(to_result(request, path.clone()).await?);\n+                results.push(to_result(request.clone(), path.clone()).await?);\n             }\n         }\n     }\n@@ -1911,22 +1873,6 @@ async fn resolve_internal_inline(\n                 force_in_lookup_dir,\n                 fragment,\n             } => {\n-                if !fragment.is_empty()\n-                    && let Ok(result) = resolve_relative_request(\n-                        lookup_path.clone(),\n-                        request,\n-                        options,\n-                        options_value,\n-                        path,\n-                        query.clone(),\n-                        *force_in_lookup_dir,\n-                        fragment.clone(),\n-                    )\n-                    .await\n-                {\n-                    return Ok(result);\n-                }\n-                // Resolve without fragment\n                 resolve_relative_request(\n                     lookup_path.clone(),\n                     request,\n@@ -1935,7 +1881,7 @@ async fn resolve_internal_inline(\n                     path,\n                     query.clone(),\n                     *force_in_lookup_dir,\n-                    RcStr::default(),\n+                    fragment.clone(),\n                 )\n                 .await?\n             }\n@@ -2014,7 +1960,6 @@ async fn resolve_internal_inline(\n             }\n             Request::Empty => *ResolveResult::unresolvable(),\n             Request::PackageInternal { path } => {\n-                let options_value = options.await?;\n                 let (conditions, unspecified_conditions) = options_value\n                     .in_package\n                     .iter()\n@@ -2045,7 +1990,7 @@ async fn resolve_internal_inline(\n                 let uri: RcStr = stringify_data_uri(media_type, encoding, *data)\n                     .await?\n                     .into();\n-                if options.await?.parse_data_uris {\n+                if options_value.parse_data_uris {\n                     *ResolveResult::primary_with_key(\n                         RequestKey::new(uri.clone()),\n                         ResolveResultItem::Source(ResolvedVc::upcast(\n@@ -2550,7 +2495,7 @@ async fn resolve_module_request(\n     request: Vc<Request>,\n     options: Vc<ResolveOptions>,\n     options_value: &ResolveOptions,\n-    module: &str,\n+    module: &RcStr,\n     path: &Pattern,\n     query: RcStr,\n     fragment: RcStr,\n@@ -2561,7 +2506,7 @@ async fn resolve_module_request(\n         options,\n         options_value,\n         |_| {\n-            let full_pattern = Pattern::concat([RcStr::from(module).into(), path.clone()]);\n+            let full_pattern = Pattern::concat([module.clone().into(), path.clone()]);\n             full_pattern.into_string()\n         },\n         query.clone(),\n@@ -2577,7 +2522,7 @@ async fn resolve_module_request(\n     // fields/fallbacks.\n     if let FindSelfReferencePackageResult::Found { name, package_path } =\n         &*find_self_reference(lookup_path.clone()).await?\n-        && name == module\n+        && module == name\n     {\n         let result = resolve_into_package(\n             path.clone(),\n@@ -2593,7 +2538,7 @@ async fn resolve_module_request(\n \n     let result = find_package(\n         lookup_path.clone(),\n-        module.into(),\n+        module.clone(),\n         resolve_modules_options(options).resolve().await?,\n     )\n     .await?;\n@@ -2643,7 +2588,7 @@ async fn resolve_module_request(\n \n     let module_result =\n         merge_results_with_affecting_sources(results, result.affecting_sources.clone())\n-            .with_replaced_request_key(rcstr!(\".\"), RequestKey::new(module.into()));\n+            .with_replaced_request_key(rcstr!(\".\"), RequestKey::new(module.clone()));\n \n     if options_value.prefer_relative {\n         let module_prefix: RcStr = format!(\"./{module}\").into();\n@@ -2662,7 +2607,7 @@ async fn resolve_module_request(\n         ))\n         .await?;\n         let relative_result = relative_result\n-            .with_replaced_request_key(module_prefix, RequestKey::new(module.into()));\n+            .with_replaced_request_key(module_prefix, RequestKey::new(module.clone()));\n \n         Ok(merge_results(vec![relative_result, module_result]))\n     } else {\n@@ -2704,9 +2649,9 @@ async fn resolve_into_package(\n                 };\n \n                 let path = if &*path == \"/\" {\n-                    \".\".to_string()\n+                    rcstr!(\".\")\n                 } else {\n-                    format!(\".{path}\")\n+                    format!(\".{path}\").into()\n                 };\n \n                 results.push(\n@@ -2831,14 +2776,14 @@ async fn resolve_import_map_result(\n             let results = list\n                 .iter()\n                 .map(|result| {\n-                    Box::pin(resolve_import_map_result(\n+                    resolve_import_map_result(\n                         result,\n                         lookup_path.clone(),\n                         original_lookup_path.clone(),\n                         original_request,\n                         options,\n                         query.clone(),\n-                    ))\n+                    )\n                 })\n                 .try_join()\n                 .await?;"
        },
        {
            "sha": "ccbfd692d04d1bd4b85bcf0ca9c80fe1ac6a8737",
            "filename": "turbopack/crates/turbopack-core/src/resolve/remap.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/d5d10e17a9330abd2cf7dab5c0b3ae742b9b5c57/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fremap.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d5d10e17a9330abd2cf7dab5c0b3ae742b9b5c57/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fremap.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fremap.rs?ref=d5d10e17a9330abd2cf7dab5c0b3ae742b9b5c57",
            "patch": "@@ -4,7 +4,7 @@ use anyhow::{Result, bail};\n use rustc_hash::FxHashMap;\n use serde::{Deserialize, Serialize};\n use serde_json::Value;\n-use turbo_rcstr::RcStr;\n+use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::FxIndexMap;\n \n use super::{\n@@ -380,7 +380,7 @@ impl TryFrom<&Value> for ExportsField {\n \n                 if !conditions.is_empty() {\n                     map.insert(\n-                        AliasPattern::Exact(\".\".into()),\n+                        AliasPattern::Exact(rcstr!(\".\")),\n                         SubpathValue::Conditional(\n                             conditions\n                                 .into_iter()\n@@ -400,15 +400,15 @@ impl TryFrom<&Value> for ExportsField {\n             Value::String(string) => {\n                 let mut map = AliasMap::new();\n                 map.insert(\n-                    AliasPattern::exact(\".\"),\n+                    AliasPattern::Exact(rcstr!(\".\")),\n                     SubpathValue::Result(string.as_str().into()),\n                 );\n                 map\n             }\n             Value::Array(array) => {\n                 let mut map = AliasMap::new();\n                 map.insert(\n-                    AliasPattern::exact(\".\"),\n+                    AliasPattern::Exact(rcstr!(\".\")),\n                     // This allows for more complex patterns than the spec allows, since we accept\n                     // the following:\n                     // [{ \"node\": \"./node.js\", \"default\": \"./index.js\" }, \"./index.js\"]"
        }
    ],
    "stats": {
        "total": 129,
        "additions": 37,
        "deletions": 92
    }
}