{
    "author": "ijjk",
    "message": "Add experimental routing package for resolving adapter routes (#86404)\n\nThis adds a shared routing package which can be used to resolve routes\nprovided from the adapter API to the final output that should be\nserved/invoked. It aims to handle all the routing done in `next-server`\nand allows a simplified interface for invoking the middleware output\nhowever that is deployed.\n\n---------\n\nCo-authored-by: vercel[bot] <35613825+vercel[bot]@users.noreply.github.com>",
    "sha": "840643f2078cb3fbf5e0689d1e7948b711b9de62",
    "files": [
        {
            "sha": "b1219cbd5819ca0f7941f68779fffd9d83a83a08",
            "filename": "jest.config.js",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/840643f2078cb3fbf5e0689d1e7948b711b9de62/jest.config.js",
            "raw_url": "https://github.com/vercel/next.js/raw/840643f2078cb3fbf5e0689d1e7948b711b9de62/jest.config.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/jest.config.js?ref=840643f2078cb3fbf5e0689d1e7948b711b9de62",
            "patch": "@@ -16,6 +16,7 @@ const customJestConfig = {\n     '<rootDir>/../packages/next-codemod/',\n     '<rootDir>/../packages/eslint-plugin-internal/',\n     '<rootDir>/../packages/font/src/',\n+    '<rootDir>/../packages/next-routing/',\n   ],\n   modulePathIgnorePatterns: ['/\\\\.next/'],\n   modulePaths: ['<rootDir>/lib'],"
        },
        {
            "sha": "3a3d50a64943565f5cafbb19f2ff38c0aa4db7be",
            "filename": "packages/next-routing/README.md",
            "status": "added",
            "additions": 89,
            "deletions": 0,
            "changes": 89,
            "blob_url": "https://github.com/vercel/next.js/blob/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext-routing%2FREADME.md",
            "raw_url": "https://github.com/vercel/next.js/raw/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext-routing%2FREADME.md",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext-routing%2FREADME.md?ref=840643f2078cb3fbf5e0689d1e7948b711b9de62",
            "patch": "@@ -0,0 +1,89 @@\n+# @next/routing\n+\n+Shared route resolving package for Next.js.\n+\n+**NOTE: This package is experimental and will become stable along with adapters API**\n+\n+## Overview\n+\n+This package provides a comprehensive route resolution system that handles rewrites, redirects, middleware invocation, and dynamic route matching with support for conditional routing based on headers, cookies, queries, and host.\n+\n+## Installation\n+\n+```bash\n+npm install @next/routing\n+```\n+\n+## Usage\n+\n+```typescript\n+import { resolveRoutes } from '@next/routing'\n+\n+const result = await resolveRoutes({\n+  url: new URL('https://example.com/api/users'),\n+  basePath: '',\n+  requestBody: readableStream,\n+  headers: new Headers(),\n+  pathnames: ['/api/users', '/api/posts'],\n+  routes: {\n+    beforeMiddleware: [],\n+    beforeFiles: [],\n+    afterFiles: [],\n+    dynamicRoutes: [],\n+    onMatch: [],\n+    fallback: [],\n+  },\n+  invokeMiddleware: async (ctx) => {\n+    // Your middleware logic\n+    return {}\n+  },\n+})\n+\n+if (result.matchedPathname) {\n+  console.log('Matched:', result.matchedPathname)\n+}\n+```\n+\n+## Route Resolution Flow\n+\n+1. **beforeMiddleware routes** - Applied before middleware execution\n+2. **invokeMiddleware** - Custom middleware logic\n+3. **beforeFiles routes** - Applied before checking filesystem\n+4. **Static pathname matching** - Check against provided pathnames\n+5. **afterFiles routes** - Applied after filesystem checks\n+6. **dynamicRoutes** - Dynamic route matching with parameter extraction\n+7. **fallback routes** - Final fallback routes\n+\n+## Route Configuration\n+\n+Each route can have:\n+\n+- `sourceRegex` - Regular expression to match against pathname\n+- `destination` - Destination path with support for replacements ($1, $name)\n+- `headers` - Headers to apply on match\n+- `has` - Conditions that must match\n+- `missing` - Conditions that must not match\n+- `status` - HTTP status code (3xx for redirects)\n+\n+### Redirects\n+\n+When a route has:\n+- A redirect status code (300-399)\n+- Headers containing `Location` or `Refresh`\n+\n+The routing will end immediately and return a `redirect` result with the destination URL and status code.\n+\n+### Has/Missing Conditions\n+\n+Conditions support:\n+\n+- `header` - Match HTTP headers\n+- `cookie` - Match cookies\n+- `query` - Match query parameters\n+- `host` - Match hostname\n+\n+Values can be:\n+\n+- `undefined` - Match if key exists\n+- String - Direct string match\n+- Regex string - Match against regex pattern"
        },
        {
            "sha": "9abea49cdd295643e1e52d1ad35bd7b3ecec51ed",
            "filename": "packages/next-routing/jest.config.js",
            "status": "added",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext-routing%2Fjest.config.js",
            "raw_url": "https://github.com/vercel/next.js/raw/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext-routing%2Fjest.config.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext-routing%2Fjest.config.js?ref=840643f2078cb3fbf5e0689d1e7948b711b9de62",
            "patch": "@@ -0,0 +1,7 @@\n+module.exports = {\n+  preset: 'ts-jest',\n+  testEnvironment: 'node',\n+  testMatch: ['**/__tests__/**/*.test.ts'],\n+  collectCoverageFrom: ['src/**/*.ts', '!src/**/*.d.ts'],\n+  moduleFileExtensions: ['ts', 'js'],\n+}"
        },
        {
            "sha": "730eb2f6dd570bb0331e037127b69f1d451facbe",
            "filename": "packages/next-routing/package.json",
            "status": "added",
            "additions": 39,
            "deletions": 0,
            "changes": 39,
            "blob_url": "https://github.com/vercel/next.js/blob/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext-routing%2Fpackage.json",
            "raw_url": "https://github.com/vercel/next.js/raw/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext-routing%2Fpackage.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext-routing%2Fpackage.json?ref=840643f2078cb3fbf5e0689d1e7948b711b9de62",
            "patch": "@@ -0,0 +1,39 @@\n+{\n+  \"name\": \"@next/routing\",\n+  \"version\": \"16.1.1-canary.6\",\n+  \"keywords\": [\n+    \"react\",\n+    \"next\",\n+    \"next.js\",\n+    \"routing\"\n+  ],\n+  \"description\": \"Next.js shared route resolving\",\n+  \"repository\": {\n+    \"type\": \"git\",\n+    \"url\": \"https://github.com/vercel/next.js\",\n+    \"directory\": \"packages/next-routing\"\n+  },\n+  \"author\": \"Next.js Team <support@vercel.com>\",\n+  \"license\": \"MIT\",\n+  \"main\": \"dist/index.js\",\n+  \"types\": \"dist/index.d.ts\",\n+  \"files\": [\n+    \"dist\"\n+  ],\n+  \"scripts\": {\n+    \"dev\": \"ncc build ./src/index.ts -w -o dist/\",\n+    \"prerelease\": \"node ../../scripts/rm.mjs dist\",\n+    \"types\": \"tsc --declaration --emitDeclarationOnly --declarationDir dist\",\n+    \"release\": \"ncc build ./src/index.ts -o ./dist/ --minify --no-cache --no-source-map-register\",\n+    \"build\": \"pnpm release && pnpm types\",\n+    \"test\": \"jest\",\n+    \"test:watch\": \"jest --watch\",\n+    \"prepublishOnly\": \"cd ../../ && turbo run build\"\n+  },\n+  \"devDependencies\": {\n+    \"@types/jest\": \"^29.5.0\",\n+    \"@vercel/ncc\": \"0.34.0\",\n+    \"jest\": \"^29.5.0\",\n+    \"ts-jest\": \"^29.1.0\"\n+  }\n+}"
        },
        {
            "sha": "5b72c8e636f8b0f1bc4102842819d5a8f34c0dcb",
            "filename": "packages/next-routing/src/__tests__/captures.test.ts",
            "status": "added",
            "additions": 712,
            "deletions": 0,
            "changes": 712,
            "blob_url": "https://github.com/vercel/next.js/blob/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext-routing%2Fsrc%2F__tests__%2Fcaptures.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext-routing%2Fsrc%2F__tests__%2Fcaptures.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext-routing%2Fsrc%2F__tests__%2Fcaptures.test.ts?ref=840643f2078cb3fbf5e0689d1e7948b711b9de62",
            "patch": "@@ -0,0 +1,712 @@\n+import { resolveRoutes } from '../resolve-routes'\n+import type { ResolveRoutesParams } from '../types'\n+\n+function createReadableStream(): ReadableStream {\n+  return new ReadableStream({\n+    start(controller) {\n+      controller.close()\n+    },\n+  })\n+}\n+\n+function createBaseParams(\n+  overrides: Partial<ResolveRoutesParams> = {}\n+): ResolveRoutesParams {\n+  return {\n+    url: new URL('https://example.com/'),\n+    buildId: 'BUILD_ID',\n+    basePath: '',\n+    requestBody: createReadableStream(),\n+    headers: new Headers(),\n+    pathnames: [],\n+    routes: {\n+      beforeMiddleware: [],\n+      beforeFiles: [],\n+      afterFiles: [],\n+      dynamicRoutes: [],\n+      onMatch: [],\n+      fallback: [],\n+    },\n+    invokeMiddleware: async () => ({}),\n+    ...overrides,\n+  }\n+}\n+\n+describe('Regex Captures in Destination', () => {\n+  it('should replace $1 with first regex capture', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/blog/my-post'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/blog/([^/]+)$',\n+            destination: '/posts/$1',\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/posts/my-post'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/posts/my-post')\n+  })\n+\n+  it('should replace multiple numbered captures $1, $2, $3', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/2024/01/post-title'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/([^/]+)/([^/]+)/([^/]+)$',\n+            destination: '/archive/$1/$2/$3',\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/archive/2024/01/post-title'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/archive/2024/01/post-title')\n+  })\n+\n+  it('should replace named captures in destination', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/users/alice/posts/123'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/users/(?<username>[^/]+)/posts/(?<postId>[^/]+)$',\n+            destination: '/u/$username/p/$postId',\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/u/alice/p/123'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/u/alice/p/123')\n+  })\n+\n+  it('should mix numbered and named captures', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/api/v1/users/john'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/api/([^/]+)/users/(?<username>[^/]+)$',\n+            destination: '/internal/$1/user/$username',\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/internal/v1/user/john'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/internal/v1/user/john')\n+  })\n+\n+  it('should use captures in query parameters', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/product/electronics/123'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/product/(?<category>[^/]+)/(?<id>[^/]+)$',\n+            destination: '/api/products?category=$category&id=$id',\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/api/products'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/api/products')\n+  })\n+\n+  it('should replace captures in external rewrite', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/cdn/images/photo.jpg'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/cdn/(.+)$',\n+            destination: 'https://cdn.example.com/$1',\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.externalRewrite?.toString()).toBe(\n+      'https://cdn.example.com/images/photo.jpg'\n+    )\n+  })\n+\n+  it('should replace captures in redirect destination', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/old/page-123'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/old/(.+)$',\n+            destination: '/new/$1',\n+            status: 301,\n+            headers: {\n+              Location: '/new/$1',\n+            },\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.redirect).toBeDefined()\n+    expect(result.redirect?.url.pathname).toBe('/new/page-123')\n+  })\n+})\n+\n+describe('Has Condition Captures in Destination', () => {\n+  it('should use header value in destination when has matches', async () => {\n+    const headers = new Headers({\n+      'x-user-id': '12345',\n+    })\n+\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/profile'),\n+      headers,\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/profile$',\n+            destination: '/users/$xuserid/profile',\n+            has: [\n+              {\n+                type: 'header',\n+                key: 'x-user-id',\n+              },\n+            ],\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/users/12345/profile'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/users/12345/profile')\n+  })\n+\n+  it('should use cookie value in destination', async () => {\n+    const headers = new Headers({\n+      cookie: 'session=abc123xyz; theme=dark',\n+    })\n+\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/dashboard'),\n+      headers,\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/dashboard$',\n+            destination: '/sessions/$session/dashboard',\n+            has: [\n+              {\n+                type: 'cookie',\n+                key: 'session',\n+              },\n+            ],\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/sessions/abc123xyz/dashboard'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/sessions/abc123xyz/dashboard')\n+  })\n+\n+  it('should use query parameter value in destination', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/search?q=nextjs'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/search$',\n+            destination: '/results/$q',\n+            has: [\n+              {\n+                type: 'query',\n+                key: 'q',\n+              },\n+            ],\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/results/nextjs'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/results/nextjs')\n+  })\n+\n+  it('should combine regex captures and has captures', async () => {\n+    const headers = new Headers({\n+      'x-tenant': 'acme',\n+    })\n+\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/api/users/123'),\n+      headers,\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/api/users/([^/]+)$',\n+            destination: '/tenants/$xtenant/users/$1',\n+            has: [\n+              {\n+                type: 'header',\n+                key: 'x-tenant',\n+              },\n+            ],\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/tenants/acme/users/123'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/tenants/acme/users/123')\n+  })\n+\n+  it('should combine named regex captures and has captures', async () => {\n+    const headers = new Headers({\n+      'x-api-version': 'v2',\n+    })\n+\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/products/electronics'),\n+      headers,\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/products/(?<category>[^/]+)$',\n+            destination: '/api/$xapiversion/products/$category',\n+            has: [\n+              {\n+                type: 'header',\n+                key: 'x-api-version',\n+              },\n+            ],\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/api/v2/products/electronics'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/api/v2/products/electronics')\n+  })\n+\n+  it('should use multiple has captures in destination', async () => {\n+    const headers = new Headers({\n+      'x-tenant': 'acme',\n+      'x-region': 'us-west',\n+    })\n+\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/data'),\n+      headers,\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/data$',\n+            destination: '/regions/$xregion/tenants/$xtenant/data',\n+            has: [\n+              {\n+                type: 'header',\n+                key: 'x-tenant',\n+              },\n+              {\n+                type: 'header',\n+                key: 'x-region',\n+              },\n+            ],\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/regions/us-west/tenants/acme/data'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/regions/us-west/tenants/acme/data')\n+  })\n+\n+  it('should use has captures with regex pattern match', async () => {\n+    const headers = new Headers({\n+      'x-locale': 'en-US',\n+    })\n+\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/page'),\n+      headers,\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/page$',\n+            destination: '/localized/$xlocale/page',\n+            has: [\n+              {\n+                type: 'header',\n+                key: 'x-locale',\n+                value: '^[a-z]{2}-[A-Z]{2}$',\n+              },\n+            ],\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/localized/en-US/page'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/localized/en-US/page')\n+  })\n+\n+  it('should use has captures in query string', async () => {\n+    const headers = new Headers({\n+      'x-user-id': '999',\n+    })\n+\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/dashboard'),\n+      headers,\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/dashboard$',\n+            destination: '/internal/dashboard?userId=$xuserid',\n+            has: [\n+              {\n+                type: 'header',\n+                key: 'x-user-id',\n+              },\n+            ],\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/internal/dashboard'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/internal/dashboard')\n+  })\n+\n+  it('should use has captures in external rewrite', async () => {\n+    const headers = new Headers({\n+      'x-backend-id': 'server-1',\n+    })\n+\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/api/data'),\n+      headers,\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/api/data$',\n+            destination: 'https://$xbackendid.example.com/data',\n+            has: [\n+              {\n+                type: 'header',\n+                key: 'x-backend-id',\n+              },\n+            ],\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.externalRewrite?.toString()).toBe(\n+      'https://server-1.example.com/data'\n+    )\n+  })\n+\n+  it('should use has captures in redirect', async () => {\n+    const headers = new Headers({\n+      'x-language': 'es',\n+    })\n+\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/home'),\n+      headers,\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/home$',\n+            destination: '/$xlanguage/home',\n+            status: 302,\n+            headers: {\n+              Location: '/$xlanguage/home',\n+            },\n+            has: [\n+              {\n+                type: 'header',\n+                key: 'x-language',\n+              },\n+            ],\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.redirect).toBeDefined()\n+    expect(result.redirect?.url.pathname).toBe('/es/home')\n+  })\n+})\n+\n+describe('Complex Capture Scenarios', () => {\n+  it('should handle deeply nested capture replacements', async () => {\n+    const headers = new Headers({\n+      'x-org': 'myorg',\n+      cookie: 'user=john',\n+    })\n+\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/projects/backend/issues/42'),\n+      headers,\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex:\n+              '^/projects/(?<project>[^/]+)/issues/(?<issueId>[^/]+)$',\n+            destination:\n+              '/orgs/$xorg/users/$user/projects/$project/issues/$issueId',\n+            has: [\n+              {\n+                type: 'header',\n+                key: 'x-org',\n+              },\n+              {\n+                type: 'cookie',\n+                key: 'user',\n+              },\n+            ],\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/orgs/myorg/users/john/projects/backend/issues/42'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe(\n+      '/orgs/myorg/users/john/projects/backend/issues/42'\n+    )\n+  })\n+\n+  it('should handle same variable name multiple times in destination', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/mirror/test'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/mirror/([^/]+)$',\n+            destination: '/a/$1/b/$1/c/$1',\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/a/test/b/test/c/test'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/a/test/b/test/c/test')\n+  })\n+\n+  it('should handle capture with special characters', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/files/my-file.test.js'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/files/(.+)$',\n+            destination: '/storage/$1',\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/storage/my-file.test.js'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/storage/my-file.test.js')\n+  })\n+\n+  it('should not replace undefined captures', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/test'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/test$',\n+            destination: '/result/$1/$2', // $1 and $2 don't exist\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/result/$1/$2'], // Should remain as literal $1/$2\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/result/$1/$2')\n+  })\n+\n+  it('should handle captures across chained rewrites', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/v1/users/alice'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/v1/users/([^/]+)$',\n+            destination: '/api/users/$1',\n+          },\n+          {\n+            sourceRegex: '^/api/users/([^/]+)$',\n+            destination: '/internal/user-service/$1',\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/internal/user-service/alice'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/internal/user-service/alice')\n+  })\n+})"
        },
        {
            "sha": "f5a9e02109b3347ef13da66dc26e85629a91beb8",
            "filename": "packages/next-routing/src/__tests__/conditions.test.ts",
            "status": "added",
            "additions": 734,
            "deletions": 0,
            "changes": 734,
            "blob_url": "https://github.com/vercel/next.js/blob/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext-routing%2Fsrc%2F__tests__%2Fconditions.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext-routing%2Fsrc%2F__tests__%2Fconditions.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext-routing%2Fsrc%2F__tests__%2Fconditions.test.ts?ref=840643f2078cb3fbf5e0689d1e7948b711b9de62",
            "patch": "@@ -0,0 +1,734 @@\n+import { resolveRoutes } from '../resolve-routes'\n+import type { ResolveRoutesParams } from '../types'\n+\n+function createReadableStream(): ReadableStream {\n+  return new ReadableStream({\n+    start(controller) {\n+      controller.close()\n+    },\n+  })\n+}\n+\n+function createBaseParams(\n+  overrides: Partial<ResolveRoutesParams> = {}\n+): ResolveRoutesParams {\n+  return {\n+    url: new URL('https://example.com/'),\n+    buildId: 'BUILD_ID',\n+    basePath: '',\n+    requestBody: createReadableStream(),\n+    headers: new Headers(),\n+    pathnames: [],\n+    routes: {\n+      beforeMiddleware: [],\n+      beforeFiles: [],\n+      afterFiles: [],\n+      dynamicRoutes: [],\n+      onMatch: [],\n+      fallback: [],\n+    },\n+    invokeMiddleware: async () => ({}),\n+    ...overrides,\n+  }\n+}\n+\n+describe('Has conditions', () => {\n+  it('should match route with header condition', async () => {\n+    const headers = new Headers({\n+      'x-user-role': 'admin',\n+    })\n+\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/dashboard'),\n+      headers,\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/dashboard$',\n+            destination: '/admin-dashboard',\n+            has: [\n+              {\n+                type: 'header',\n+                key: 'x-user-role',\n+                value: 'admin',\n+              },\n+            ],\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/admin-dashboard'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/admin-dashboard')\n+  })\n+\n+  it('should match route with cookie condition', async () => {\n+    const headers = new Headers({\n+      cookie: 'session=abc123; theme=dark',\n+    })\n+\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/page'),\n+      headers,\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/page$',\n+            destination: '/dark-theme-page',\n+            has: [\n+              {\n+                type: 'cookie',\n+                key: 'theme',\n+                value: 'dark',\n+              },\n+            ],\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/dark-theme-page'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/dark-theme-page')\n+  })\n+\n+  it('should match route with query condition', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/page?preview=true'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/page$',\n+            destination: '/preview-page',\n+            has: [\n+              {\n+                type: 'query',\n+                key: 'preview',\n+                value: 'true',\n+              },\n+            ],\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/preview-page'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/preview-page')\n+  })\n+\n+  it('should match route with host condition', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://subdomain.example.com/'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/$',\n+            destination: '/subdomain-home',\n+            has: [\n+              {\n+                type: 'host',\n+                value: 'subdomain.example.com',\n+              },\n+            ],\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/subdomain-home'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/subdomain-home')\n+  })\n+\n+  it('should match when has condition checks key existence only', async () => {\n+    const headers = new Headers({\n+      'x-feature-flag': 'enabled',\n+    })\n+\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/feature'),\n+      headers,\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/feature$',\n+            destination: '/feature-enabled',\n+            has: [\n+              {\n+                type: 'header',\n+                key: 'x-feature-flag',\n+                // No value - just check existence\n+              },\n+            ],\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/feature-enabled'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/feature-enabled')\n+  })\n+\n+  it('should match with regex pattern in has condition', async () => {\n+    const headers = new Headers({\n+      'user-agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_0)',\n+    })\n+\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/'),\n+      headers,\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/$',\n+            destination: '/mobile',\n+            has: [\n+              {\n+                type: 'header',\n+                key: 'user-agent',\n+                value: '.*iPhone.*',\n+              },\n+            ],\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/mobile'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/mobile')\n+  })\n+\n+  it('should require ALL has conditions to match', async () => {\n+    const headers = new Headers({\n+      'x-user-role': 'admin',\n+      'x-feature': 'beta',\n+    })\n+\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/feature'),\n+      headers,\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/feature$',\n+            destination: '/admin-beta-feature',\n+            has: [\n+              {\n+                type: 'header',\n+                key: 'x-user-role',\n+                value: 'admin',\n+              },\n+              {\n+                type: 'header',\n+                key: 'x-feature',\n+                value: 'beta',\n+              },\n+            ],\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/admin-beta-feature'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/admin-beta-feature')\n+  })\n+\n+  it('should NOT match when one has condition fails', async () => {\n+    const headers = new Headers({\n+      'x-user-role': 'admin',\n+      // Missing x-feature header\n+    })\n+\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/feature'),\n+      headers,\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/feature$',\n+            destination: '/admin-beta-feature',\n+            has: [\n+              {\n+                type: 'header',\n+                key: 'x-user-role',\n+                value: 'admin',\n+              },\n+              {\n+                type: 'header',\n+                key: 'x-feature',\n+                value: 'beta',\n+              },\n+            ],\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/feature'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    // Should not match the route, so stays at /feature\n+    expect(result.matchedPathname).toBe('/feature')\n+  })\n+})\n+\n+describe('Missing conditions', () => {\n+  it('should match when missing condition is not present', async () => {\n+    const headers = new Headers({\n+      'x-feature': 'enabled',\n+    })\n+\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/page'),\n+      headers,\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/page$',\n+            destination: '/no-debug-page',\n+            missing: [\n+              {\n+                type: 'header',\n+                key: 'x-debug',\n+              },\n+            ],\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/no-debug-page'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/no-debug-page')\n+  })\n+\n+  it('should NOT match when missing condition is present', async () => {\n+    const headers = new Headers({\n+      'x-debug': 'true',\n+    })\n+\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/page'),\n+      headers,\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/page$',\n+            destination: '/no-debug-page',\n+            missing: [\n+              {\n+                type: 'header',\n+                key: 'x-debug',\n+              },\n+            ],\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/page'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    // Route should not match, stays at /page\n+    expect(result.matchedPathname).toBe('/page')\n+  })\n+\n+  it('should match when missing cookie is not present', async () => {\n+    const headers = new Headers({\n+      cookie: 'session=abc123',\n+    })\n+\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/page'),\n+      headers,\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/page$',\n+            destination: '/no-tracking',\n+            missing: [\n+              {\n+                type: 'cookie',\n+                key: 'tracking',\n+              },\n+            ],\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/no-tracking'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/no-tracking')\n+  })\n+\n+  it('should match when missing query is not present', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/page?foo=bar'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/page$',\n+            destination: '/no-preview',\n+            missing: [\n+              {\n+                type: 'query',\n+                key: 'preview',\n+              },\n+            ],\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/no-preview'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/no-preview')\n+  })\n+\n+  it('should require ALL missing conditions to be absent', async () => {\n+    const headers = new Headers({\n+      'x-feature': 'enabled',\n+      // No x-debug or x-admin headers\n+    })\n+\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/page'),\n+      headers,\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/page$',\n+            destination: '/standard-page',\n+            missing: [\n+              {\n+                type: 'header',\n+                key: 'x-debug',\n+              },\n+              {\n+                type: 'header',\n+                key: 'x-admin',\n+              },\n+            ],\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/standard-page'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/standard-page')\n+  })\n+})\n+\n+describe('Combined has and missing conditions', () => {\n+  it('should match when has is satisfied and missing is absent', async () => {\n+    const headers = new Headers({\n+      'x-user-role': 'member',\n+      // No x-admin header\n+    })\n+\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/content'),\n+      headers,\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/content$',\n+            destination: '/member-content',\n+            has: [\n+              {\n+                type: 'header',\n+                key: 'x-user-role',\n+                value: 'member',\n+              },\n+            ],\n+            missing: [\n+              {\n+                type: 'header',\n+                key: 'x-admin',\n+              },\n+            ],\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/member-content'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/member-content')\n+  })\n+\n+  it('should NOT match when has is satisfied but missing is present', async () => {\n+    const headers = new Headers({\n+      'x-user-role': 'member',\n+      'x-admin': 'true',\n+    })\n+\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/content'),\n+      headers,\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/content$',\n+            destination: '/member-content',\n+            has: [\n+              {\n+                type: 'header',\n+                key: 'x-user-role',\n+                value: 'member',\n+              },\n+            ],\n+            missing: [\n+              {\n+                type: 'header',\n+                key: 'x-admin',\n+              },\n+            ],\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/content'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    // Should not match, stays at /content\n+    expect(result.matchedPathname).toBe('/content')\n+  })\n+\n+  it('should NOT match when has fails even if missing is satisfied', async () => {\n+    const headers = new Headers({\n+      'x-user-role': 'guest',\n+      // No x-admin header\n+    })\n+\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/content'),\n+      headers,\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/content$',\n+            destination: '/member-content',\n+            has: [\n+              {\n+                type: 'header',\n+                key: 'x-user-role',\n+                value: 'member',\n+              },\n+            ],\n+            missing: [\n+              {\n+                type: 'header',\n+                key: 'x-admin',\n+              },\n+            ],\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/content'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    // Should not match, stays at /content\n+    expect(result.matchedPathname).toBe('/content')\n+  })\n+})\n+\n+describe('Dynamic routes', () => {\n+  it('should match dynamic route and extract params', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/posts/123'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [],\n+        afterFiles: [],\n+        dynamicRoutes: [\n+          {\n+            sourceRegex: '^/posts/([^/]+)$',\n+            destination: '/post',\n+          },\n+        ],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/posts/123'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/posts/123')\n+    expect(result.routeMatches).toEqual({\n+      '1': '123',\n+    })\n+  })\n+\n+  it('should match dynamic route with named groups', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/users/alice/posts/456'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [],\n+        afterFiles: [],\n+        dynamicRoutes: [\n+          {\n+            sourceRegex: '^/users/(?<username>[^/]+)/posts/(?<postId>[^/]+)$',\n+            destination: '/user-post',\n+          },\n+        ],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/users/alice/posts/456'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/users/alice/posts/456')\n+    expect(result.routeMatches).toEqual({\n+      '1': 'alice',\n+      '2': '456',\n+      username: 'alice',\n+      postId: '456',\n+    })\n+  })\n+\n+  it('should check has/missing conditions on dynamic routes', async () => {\n+    const headers = new Headers({\n+      'x-authenticated': 'true',\n+    })\n+\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/profile/john'),\n+      headers,\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [],\n+        afterFiles: [],\n+        dynamicRoutes: [\n+          {\n+            sourceRegex: '^/profile/([^/]+)$',\n+            destination: '/user-profile',\n+            has: [\n+              {\n+                type: 'header',\n+                key: 'x-authenticated',\n+                value: 'true',\n+              },\n+            ],\n+          },\n+        ],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/profile/john'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/profile/john')\n+    expect(result.routeMatches).toEqual({\n+      '1': 'john',\n+    })\n+  })\n+})"
        },
        {
            "sha": "222b5c10bff45843b6422cdb7499a9f47986fd3f",
            "filename": "packages/next-routing/src/__tests__/dynamic-after-rewrites.test.ts",
            "status": "added",
            "additions": 494,
            "deletions": 0,
            "changes": 494,
            "blob_url": "https://github.com/vercel/next.js/blob/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext-routing%2Fsrc%2F__tests__%2Fdynamic-after-rewrites.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext-routing%2Fsrc%2F__tests__%2Fdynamic-after-rewrites.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext-routing%2Fsrc%2F__tests__%2Fdynamic-after-rewrites.test.ts?ref=840643f2078cb3fbf5e0689d1e7948b711b9de62",
            "patch": "@@ -0,0 +1,494 @@\n+import { resolveRoutes } from '../resolve-routes'\n+import type { ResolveRoutesParams } from '../types'\n+\n+function createReadableStream(): ReadableStream {\n+  return new ReadableStream({\n+    start(controller) {\n+      controller.close()\n+    },\n+  })\n+}\n+\n+function createBaseParams(\n+  overrides: Partial<ResolveRoutesParams> = {}\n+): ResolveRoutesParams {\n+  return {\n+    url: new URL('https://example.com/'),\n+    buildId: 'BUILD_ID',\n+    basePath: '',\n+    requestBody: createReadableStream(),\n+    headers: new Headers(),\n+    pathnames: [],\n+    routes: {\n+      beforeMiddleware: [],\n+      beforeFiles: [],\n+      afterFiles: [],\n+      dynamicRoutes: [],\n+      onMatch: [],\n+      fallback: [],\n+    },\n+    invokeMiddleware: async () => ({}),\n+    ...overrides,\n+  }\n+}\n+\n+describe('Dynamic Routes After afterFiles Rewrites', () => {\n+  it('should check dynamic routes after first afterFiles rewrite', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/blog/my-post'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [],\n+        afterFiles: [\n+          {\n+            sourceRegex: '^/blog/([^/]+)$',\n+            destination: '/posts/$1',\n+          },\n+        ],\n+        dynamicRoutes: [\n+          {\n+            sourceRegex: '^/posts/(?<slug>[^/]+)$',\n+            destination: '/posts/my-post', // Destination matches pathname\n+          },\n+        ],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/posts/my-post'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/posts/my-post')\n+    expect(result.routeMatches).toEqual({\n+      '1': 'my-post',\n+      slug: 'my-post',\n+    })\n+  })\n+\n+  it('should check dynamic routes after second afterFiles rewrite', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/content/article'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [],\n+        afterFiles: [\n+          {\n+            sourceRegex: '^/content/(.+)$',\n+            destination: '/internal/$1',\n+          },\n+          {\n+            sourceRegex: '^/internal/(.+)$',\n+            destination: '/posts/$1',\n+          },\n+        ],\n+        dynamicRoutes: [\n+          {\n+            sourceRegex: '^/posts/(?<slug>[^/]+)$',\n+            destination: '/posts/article', // Destination matches pathname\n+          },\n+        ],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/posts/article'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/posts/article')\n+    expect(result.routeMatches).toEqual({\n+      '1': 'article',\n+      slug: 'article',\n+    })\n+  })\n+\n+  it('should check dynamic routes after each afterFiles rewrite individually', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/step1/test'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [],\n+        afterFiles: [\n+          {\n+            sourceRegex: '^/step1/(.+)$',\n+            destination: '/step2/$1',\n+          },\n+          {\n+            sourceRegex: '^/step2/(.+)$',\n+            destination: '/users/$1', // This matches dynamic route\n+          },\n+          {\n+            sourceRegex: '^/users/(.+)$',\n+            destination: '/final/$1', // Should not reach here\n+          },\n+        ],\n+        dynamicRoutes: [\n+          {\n+            sourceRegex: '^/users/(?<username>[^/]+)$',\n+            destination: '/users/test', // Destination matches pathname\n+          },\n+        ],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/users/test'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/users/test')\n+    expect(result.routeMatches).toEqual({\n+      '1': 'test',\n+      username: 'test',\n+    })\n+  })\n+\n+  it('should continue to next afterFiles route if dynamic route does not match', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/blog/post'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [],\n+        afterFiles: [\n+          {\n+            sourceRegex: '^/blog/(.+)$',\n+            destination: '/content/$1',\n+          },\n+          {\n+            sourceRegex: '^/content/(.+)$',\n+            destination: '/posts/$1',\n+          },\n+        ],\n+        dynamicRoutes: [\n+          {\n+            sourceRegex: '^/users/(?<username>[^/]+)$', // Won't match /content/post\n+            destination: '/users/someuser',\n+          },\n+          {\n+            sourceRegex: '^/posts/(?<slug>[^/]+)$', // Will match /posts/post\n+            destination: '/posts/post', // Destination matches pathname\n+          },\n+        ],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/posts/post'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/posts/post')\n+    expect(result.routeMatches).toEqual({\n+      '1': 'post',\n+      slug: 'post',\n+    })\n+  })\n+\n+  it('should check dynamic routes with has conditions after afterFiles', async () => {\n+    const headers = new Headers({\n+      'x-user-id': '123',\n+    })\n+\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/profile'),\n+      headers,\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [],\n+        afterFiles: [\n+          {\n+            sourceRegex: '^/profile$',\n+            destination: '/users/profile',\n+          },\n+        ],\n+        dynamicRoutes: [\n+          {\n+            sourceRegex: '^/users/(?<page>[^/]+)$',\n+            destination: '/users/profile', // Destination matches pathname\n+            has: [\n+              {\n+                type: 'header',\n+                key: 'x-user-id',\n+              },\n+            ],\n+          },\n+        ],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/users/profile'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/users/profile')\n+    expect(result.routeMatches).toEqual({\n+      '1': 'profile',\n+      page: 'profile',\n+    })\n+  })\n+})\n+\n+describe('Dynamic Routes After fallback Rewrites', () => {\n+  it('should check dynamic routes after first fallback rewrite', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/unknown/page'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [],\n+        afterFiles: [],\n+        dynamicRoutes: [\n+          {\n+            sourceRegex: '^/catch-all/(?<path>.+)$',\n+            destination: '/catch-all/page', // Destination matches pathname\n+          },\n+        ],\n+        onMatch: [],\n+        fallback: [\n+          {\n+            sourceRegex: '^/unknown/(.+)$',\n+            destination: '/catch-all/$1',\n+          },\n+        ],\n+      },\n+      pathnames: ['/catch-all/page'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/catch-all/page')\n+    expect(result.routeMatches).toEqual({\n+      '1': 'page',\n+      path: 'page',\n+    })\n+  })\n+\n+  it('should check dynamic routes after second fallback rewrite', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/not-found'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [],\n+        afterFiles: [],\n+        dynamicRoutes: [\n+          {\n+            sourceRegex: '^/error/(?<code>[^/]+)$',\n+            destination: '/error/404', // Destination matches pathname\n+          },\n+        ],\n+        onMatch: [],\n+        fallback: [\n+          {\n+            sourceRegex: '^/not-found$',\n+            destination: '/404',\n+          },\n+          {\n+            sourceRegex: '^/404$',\n+            destination: '/error/404',\n+          },\n+        ],\n+      },\n+      pathnames: ['/error/404'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/error/404')\n+    expect(result.routeMatches).toEqual({\n+      '1': '404',\n+      code: '404',\n+    })\n+  })\n+\n+  it('should check dynamic routes after each fallback rewrite individually', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/missing'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [],\n+        afterFiles: [],\n+        dynamicRoutes: [\n+          {\n+            sourceRegex: '^/fallback/(?<type>[^/]+)$',\n+            destination: '/fallback/404', // Destination matches pathname\n+          },\n+        ],\n+        onMatch: [],\n+        fallback: [\n+          {\n+            sourceRegex: '^/missing$',\n+            destination: '/fallback/404',\n+          },\n+          {\n+            sourceRegex: '^/fallback/(.+)$',\n+            destination: '/final/$1', // Should not reach here\n+          },\n+        ],\n+      },\n+      pathnames: ['/fallback/404'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/fallback/404')\n+    expect(result.routeMatches).toEqual({\n+      '1': '404',\n+      type: '404',\n+    })\n+  })\n+\n+  it('should continue to next fallback route if dynamic route does not match', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/unknown'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [],\n+        afterFiles: [],\n+        dynamicRoutes: [\n+          {\n+            sourceRegex: '^/error/(?<code>[^/]+)$', // Won't match intermediate paths\n+            destination: '/error/500', // Destination matches pathname\n+          },\n+        ],\n+        onMatch: [],\n+        fallback: [\n+          {\n+            sourceRegex: '^/unknown$',\n+            destination: '/temp',\n+          },\n+          {\n+            sourceRegex: '^/temp$',\n+            destination: '/error/500',\n+          },\n+        ],\n+      },\n+      pathnames: ['/error/500'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/error/500')\n+    expect(result.routeMatches).toEqual({\n+      '1': '500',\n+      code: '500',\n+    })\n+  })\n+\n+  it('should prioritize dynamic route match over continuing fallback chain', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/start'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [],\n+        afterFiles: [],\n+        dynamicRoutes: [\n+          {\n+            sourceRegex: '^/users/(?<id>[^/]+)$',\n+            destination: '/users/123', // Destination matches pathname\n+          },\n+        ],\n+        onMatch: [],\n+        fallback: [\n+          {\n+            sourceRegex: '^/start$',\n+            destination: '/users/123', // Matches dynamic route\n+          },\n+          {\n+            sourceRegex: '^/users/(.+)$',\n+            destination: '/should-not-reach', // Should not process this\n+          },\n+        ],\n+      },\n+      pathnames: ['/users/123'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/users/123')\n+    expect(result.routeMatches).toEqual({\n+      '1': '123',\n+      id: '123',\n+    })\n+  })\n+})\n+\n+describe('Mixed afterFiles and fallback with Dynamic Routes', () => {\n+  it('should not check dynamic routes twice if already matched in afterFiles', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/content/article'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [],\n+        afterFiles: [\n+          {\n+            sourceRegex: '^/content/(.+)$',\n+            destination: '/posts/$1',\n+          },\n+        ],\n+        dynamicRoutes: [\n+          {\n+            sourceRegex: '^/posts/(?<slug>[^/]+)$',\n+            destination: '/posts/article', // Destination matches pathname\n+          },\n+        ],\n+        onMatch: [],\n+        fallback: [\n+          {\n+            sourceRegex: '^/posts/(.+)$',\n+            destination: '/should-not-reach',\n+          },\n+        ],\n+      },\n+      pathnames: ['/posts/article'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    // Should match in afterFiles -> dynamic routes, not reach fallback\n+    expect(result.matchedPathname).toBe('/posts/article')\n+    expect(result.routeMatches).toEqual({\n+      '1': 'article',\n+      slug: 'article',\n+    })\n+  })\n+\n+  it('should reach fallback if afterFiles does not result in match', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/test'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [],\n+        afterFiles: [\n+          {\n+            sourceRegex: '^/test$',\n+            destination: '/intermediate',\n+          },\n+        ],\n+        dynamicRoutes: [\n+          {\n+            sourceRegex: '^/posts/(?<slug>[^/]+)$',\n+            destination: '/posts/fallback', // Destination matches pathname\n+          },\n+        ],\n+        onMatch: [],\n+        fallback: [\n+          {\n+            sourceRegex: '^/intermediate$',\n+            destination: '/posts/fallback',\n+          },\n+        ],\n+      },\n+      pathnames: ['/posts/fallback'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    // Should go through: test -> intermediate (no match) -> fallback -> posts/fallback (dynamic match)\n+    expect(result.matchedPathname).toBe('/posts/fallback')\n+    expect(result.routeMatches).toEqual({\n+      '1': 'fallback',\n+      slug: 'fallback',\n+    })\n+  })\n+})"
        },
        {
            "sha": "1ae8ee25a786c172db5aa8d18da1d4bcdbde5666",
            "filename": "packages/next-routing/src/__tests__/i18n-resolve-routes.test.ts",
            "status": "added",
            "additions": 316,
            "deletions": 0,
            "changes": 316,
            "blob_url": "https://github.com/vercel/next.js/blob/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext-routing%2Fsrc%2F__tests__%2Fi18n-resolve-routes.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext-routing%2Fsrc%2F__tests__%2Fi18n-resolve-routes.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext-routing%2Fsrc%2F__tests__%2Fi18n-resolve-routes.test.ts?ref=840643f2078cb3fbf5e0689d1e7948b711b9de62",
            "patch": "@@ -0,0 +1,316 @@\n+import { resolveRoutes } from '../resolve-routes'\n+import type { ResolveRoutesParams } from '../types'\n+\n+describe('resolveRoutes with i18n', () => {\n+  const baseParams: Omit<ResolveRoutesParams, 'url' | 'headers'> = {\n+    buildId: 'BUILD_ID',\n+    basePath: '',\n+    requestBody: new ReadableStream(),\n+    pathnames: ['/en/about', '/fr/about', '/de/about', '/about'],\n+    routes: {\n+      beforeMiddleware: [],\n+      beforeFiles: [],\n+      afterFiles: [],\n+      dynamicRoutes: [],\n+      onMatch: [],\n+      fallback: [],\n+    },\n+    invokeMiddleware: async () => ({ bodySent: false }),\n+  }\n+\n+  const i18nConfig = {\n+    defaultLocale: 'en',\n+    locales: ['en', 'fr', 'de', 'ja'],\n+    domains: [\n+      { domain: 'example.com', defaultLocale: 'en' },\n+      { domain: 'example.fr', defaultLocale: 'fr' },\n+      { domain: 'example.de', defaultLocale: 'de' },\n+    ],\n+  }\n+\n+  const i18nConfigNoDomains = {\n+    defaultLocale: 'en',\n+    locales: ['en', 'fr', 'de', 'ja'],\n+  }\n+\n+  describe('locale detection from accept-language header', () => {\n+    it('should redirect to locale prefix when accept-language is set', async () => {\n+      const result = await resolveRoutes({\n+        ...baseParams,\n+        url: new URL('http://example.com/about'),\n+        headers: new Headers({\n+          'accept-language': 'fr,en;q=0.9',\n+        }),\n+        i18n: i18nConfigNoDomains,\n+      })\n+\n+      expect(result.redirect).toBeDefined()\n+      expect(result.redirect?.url.pathname).toBe('/fr/about')\n+      expect(result.redirect?.status).toBe(307)\n+    })\n+\n+    it('should use quality values from accept-language', async () => {\n+      const result = await resolveRoutes({\n+        ...baseParams,\n+        url: new URL('http://example.com/about'),\n+        headers: new Headers({\n+          'accept-language': 'de;q=0.8,fr;q=0.9,en;q=0.7',\n+        }),\n+        i18n: i18nConfigNoDomains,\n+      })\n+\n+      expect(result.redirect).toBeDefined()\n+      expect(result.redirect?.url.pathname).toBe('/fr/about')\n+    })\n+\n+    it('should not redirect when locale matches default', async () => {\n+      const result = await resolveRoutes({\n+        ...baseParams,\n+        url: new URL('http://example.com/about'),\n+        headers: new Headers({\n+          'accept-language': 'en',\n+        }),\n+        i18n: i18nConfig,\n+      })\n+\n+      // Should prefix internally but not redirect\n+      expect(result.redirect).toBeUndefined()\n+    })\n+  })\n+\n+  describe('locale detection from cookie', () => {\n+    it('should redirect to locale from NEXT_LOCALE cookie', async () => {\n+      const result = await resolveRoutes({\n+        ...baseParams,\n+        url: new URL('http://example.com/about'),\n+        headers: new Headers({\n+          cookie: 'NEXT_LOCALE=ja',\n+        }),\n+        i18n: i18nConfigNoDomains,\n+      })\n+\n+      expect(result.redirect).toBeDefined()\n+      expect(result.redirect?.url.pathname).toBe('/ja/about')\n+    })\n+\n+    it('should prioritize cookie over accept-language', async () => {\n+      const result = await resolveRoutes({\n+        ...baseParams,\n+        url: new URL('http://example.com/about'),\n+        headers: new Headers({\n+          cookie: 'session=abc; NEXT_LOCALE=ja; theme=dark',\n+          'accept-language': 'fr',\n+        }),\n+        i18n: i18nConfigNoDomains,\n+      })\n+\n+      expect(result.redirect).toBeDefined()\n+      expect(result.redirect?.url.pathname).toBe('/ja/about')\n+    })\n+  })\n+\n+  describe('domain locale handling', () => {\n+    it('should use domain default locale without redirect', async () => {\n+      const result = await resolveRoutes({\n+        ...baseParams,\n+        url: new URL('http://example.fr/about'),\n+        headers: new Headers({}),\n+        i18n: i18nConfig,\n+      })\n+\n+      // Should not redirect since we're on the FR domain\n+      expect(result.redirect).toBeUndefined()\n+    })\n+\n+    it('should redirect to correct domain for preferred locale', async () => {\n+      const result = await resolveRoutes({\n+        ...baseParams,\n+        url: new URL('http://example.com/about'),\n+        headers: new Headers({\n+          'accept-language': 'fr',\n+        }),\n+        i18n: i18nConfig,\n+      })\n+\n+      expect(result.redirect).toBeDefined()\n+      expect(result.redirect?.url.hostname).toBe('example.fr')\n+      expect(result.redirect?.url.pathname).toBe('/about')\n+    })\n+\n+    it('should not include locale prefix for domain default locale', async () => {\n+      const result = await resolveRoutes({\n+        ...baseParams,\n+        url: new URL('http://example.com/about'),\n+        headers: new Headers({\n+          'accept-language': 'de',\n+        }),\n+        i18n: i18nConfig,\n+      })\n+\n+      expect(result.redirect).toBeDefined()\n+      expect(result.redirect?.url.hostname).toBe('example.de')\n+      expect(result.redirect?.url.pathname).toBe('/about')\n+    })\n+  })\n+\n+  describe('locale prefix in pathname', () => {\n+    it('should use locale from pathname', async () => {\n+      const result = await resolveRoutes({\n+        ...baseParams,\n+        url: new URL('http://example.com/fr/about'),\n+        headers: new Headers({\n+          'accept-language': 'de',\n+        }),\n+        i18n: i18nConfig,\n+      })\n+\n+      // Path locale takes priority, so no redirect\n+      expect(result.redirect).toBeUndefined()\n+      expect(result.matchedPathname).toBe('/fr/about')\n+    })\n+\n+    it('should handle locale prefix with trailing slash', async () => {\n+      const result = await resolveRoutes({\n+        ...baseParams,\n+        url: new URL('http://example.com/fr/about/'),\n+        headers: new Headers({}),\n+        pathnames: ['/fr/about/', '/fr/about'],\n+        i18n: i18nConfig,\n+      })\n+\n+      expect(result.redirect).toBeUndefined()\n+      expect(result.matchedPathname).toBe('/fr/about/')\n+    })\n+  })\n+\n+  describe('_next/data routes', () => {\n+    it('should not handle locale for _next/data routes', async () => {\n+      const result = await resolveRoutes({\n+        ...baseParams,\n+        buildId: 'build123',\n+        url: new URL('http://example.com/_next/data/build123/about.json'),\n+        headers: new Headers({\n+          'accept-language': 'fr',\n+        }),\n+        i18n: i18nConfig,\n+        routes: {\n+          ...baseParams.routes,\n+          shouldNormalizeNextData: true,\n+        },\n+      })\n+\n+      // Should not redirect for _next/data routes\n+      expect(result.redirect).toBeUndefined()\n+    })\n+  })\n+\n+  describe('localeDetection disabled', () => {\n+    it('should not redirect when localeDetection is false', async () => {\n+      const result = await resolveRoutes({\n+        ...baseParams,\n+        url: new URL('http://example.com/about'),\n+        headers: new Headers({\n+          'accept-language': 'fr',\n+          cookie: 'NEXT_LOCALE=de',\n+        }),\n+        i18n: { ...i18nConfig, localeDetection: false },\n+      })\n+\n+      // Should prefix internally with default locale but not redirect\n+      expect(result.redirect).toBeUndefined()\n+    })\n+\n+    it('should still use domain locale when localeDetection is false', async () => {\n+      const result = await resolveRoutes({\n+        ...baseParams,\n+        url: new URL('http://example.fr/about'),\n+        headers: new Headers({\n+          'accept-language': 'de',\n+        }),\n+        i18n: { ...i18nConfig, localeDetection: false },\n+      })\n+\n+      // Domain locale still applies\n+      expect(result.redirect).toBeUndefined()\n+    })\n+  })\n+\n+  describe('basePath with i18n', () => {\n+    it('should handle basePath with locale prefix redirect', async () => {\n+      const result = await resolveRoutes({\n+        ...baseParams,\n+        basePath: '/base',\n+        url: new URL('http://example.com/base/about'),\n+        headers: new Headers({\n+          'accept-language': 'ja',\n+        }),\n+        i18n: i18nConfigNoDomains,\n+      })\n+\n+      expect(result.redirect).toBeDefined()\n+      expect(result.redirect?.url.pathname).toBe('/base/ja/about')\n+    })\n+\n+    it('should handle basePath with domain redirect', async () => {\n+      const result = await resolveRoutes({\n+        ...baseParams,\n+        basePath: '/base',\n+        url: new URL('http://example.com/base/about'),\n+        headers: new Headers({\n+          'accept-language': 'de',\n+        }),\n+        i18n: i18nConfig,\n+      })\n+\n+      expect(result.redirect).toBeDefined()\n+      expect(result.redirect?.url.hostname).toBe('example.de')\n+      expect(result.redirect?.url.pathname).toBe('/base/about')\n+    })\n+  })\n+\n+  describe('edge cases', () => {\n+    it('should handle root path', async () => {\n+      const result = await resolveRoutes({\n+        ...baseParams,\n+        url: new URL('http://example.com/'),\n+        headers: new Headers({\n+          'accept-language': 'ja',\n+        }),\n+        pathnames: ['/', '/ja/', '/en/'],\n+        i18n: i18nConfigNoDomains,\n+      })\n+\n+      expect(result.redirect).toBeDefined()\n+      expect(result.redirect?.url.pathname).toBe('/ja/')\n+    })\n+\n+    it('should handle query strings', async () => {\n+      const result = await resolveRoutes({\n+        ...baseParams,\n+        url: new URL('http://example.com/about?foo=bar'),\n+        headers: new Headers({\n+          'accept-language': 'ja',\n+        }),\n+        i18n: i18nConfigNoDomains,\n+      })\n+\n+      expect(result.redirect).toBeDefined()\n+      expect(result.redirect?.url.pathname).toBe('/ja/about')\n+      expect(result.redirect?.url.search).toBe('?foo=bar')\n+    })\n+\n+    it('should skip locale handling for _next routes', async () => {\n+      const result = await resolveRoutes({\n+        ...baseParams,\n+        url: new URL('http://example.com/_next/static/chunk.js'),\n+        headers: new Headers({\n+          'accept-language': 'fr',\n+        }),\n+        i18n: i18nConfig,\n+      })\n+\n+      // Should not redirect for _next routes\n+      expect(result.redirect).toBeUndefined()\n+    })\n+  })\n+})"
        },
        {
            "sha": "d76ad5435593b5eb47d5df167db5910d2964e00f",
            "filename": "packages/next-routing/src/__tests__/i18n.test.ts",
            "status": "added",
            "additions": 254,
            "deletions": 0,
            "changes": 254,
            "blob_url": "https://github.com/vercel/next.js/blob/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext-routing%2Fsrc%2F__tests__%2Fi18n.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext-routing%2Fsrc%2F__tests__%2Fi18n.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext-routing%2Fsrc%2F__tests__%2Fi18n.test.ts?ref=840643f2078cb3fbf5e0689d1e7948b711b9de62",
            "patch": "@@ -0,0 +1,254 @@\n+import {\n+  detectDomainLocale,\n+  normalizeLocalePath,\n+  getAcceptLanguageLocale,\n+  getCookieLocale,\n+  detectLocale,\n+} from '../i18n'\n+import type { I18nConfig } from '../i18n'\n+\n+describe('i18n utilities', () => {\n+  describe('detectDomainLocale', () => {\n+    const domains = [\n+      { domain: 'example.com', defaultLocale: 'en', locales: ['en', 'en-US'] },\n+      { domain: 'example.fr', defaultLocale: 'fr' },\n+      { domain: 'example.de:3000', defaultLocale: 'de' },\n+    ]\n+\n+    it('should detect locale by hostname', () => {\n+      expect(detectDomainLocale(domains, 'example.com')).toEqual(domains[0])\n+      expect(detectDomainLocale(domains, 'example.fr')).toEqual(domains[1])\n+    })\n+\n+    it('should detect locale by hostname without port', () => {\n+      expect(detectDomainLocale(domains, 'example.de')).toEqual(domains[2])\n+    })\n+\n+    it('should detect locale by detected locale', () => {\n+      expect(detectDomainLocale(domains, 'other.com', 'fr')).toEqual(domains[1])\n+      expect(detectDomainLocale(domains, 'other.com', 'en-US')).toEqual(\n+        domains[0]\n+      )\n+    })\n+\n+    it('should return undefined for no match', () => {\n+      expect(detectDomainLocale(domains, 'unknown.com')).toBeUndefined()\n+      expect(detectDomainLocale(undefined, 'example.com')).toBeUndefined()\n+    })\n+\n+    it('should be case-insensitive', () => {\n+      expect(detectDomainLocale(domains, 'EXAMPLE.COM')).toEqual(domains[0])\n+      expect(detectDomainLocale(domains, 'other.com', 'FR')).toEqual(domains[1])\n+    })\n+  })\n+\n+  describe('normalizeLocalePath', () => {\n+    const locales = ['en', 'fr', 'de', 'en-US']\n+\n+    it('should detect and remove locale from pathname', () => {\n+      expect(normalizeLocalePath('/en/about', locales)).toEqual({\n+        pathname: '/about',\n+        detectedLocale: 'en',\n+      })\n+      expect(normalizeLocalePath('/fr/products/item', locales)).toEqual({\n+        pathname: '/products/item',\n+        detectedLocale: 'fr',\n+      })\n+    })\n+\n+    it('should handle root path with locale', () => {\n+      expect(normalizeLocalePath('/en', locales)).toEqual({\n+        pathname: '/',\n+        detectedLocale: 'en',\n+      })\n+    })\n+\n+    it('should return original pathname when no locale detected', () => {\n+      expect(normalizeLocalePath('/about', locales)).toEqual({\n+        pathname: '/about',\n+      })\n+      expect(normalizeLocalePath('/', locales)).toEqual({\n+        pathname: '/',\n+      })\n+    })\n+\n+    it('should be case-insensitive', () => {\n+      expect(normalizeLocalePath('/EN/about', locales)).toEqual({\n+        pathname: '/about',\n+        detectedLocale: 'en',\n+      })\n+      expect(normalizeLocalePath('/Fr/products', locales)).toEqual({\n+        pathname: '/products',\n+        detectedLocale: 'fr',\n+      })\n+    })\n+\n+    it('should handle locales with hyphens', () => {\n+      expect(normalizeLocalePath('/en-US/about', locales)).toEqual({\n+        pathname: '/about',\n+        detectedLocale: 'en-US',\n+      })\n+    })\n+  })\n+\n+  describe('getAcceptLanguageLocale', () => {\n+    const locales = ['en', 'fr', 'de', 'ja']\n+\n+    it('should parse simple accept-language header', () => {\n+      expect(getAcceptLanguageLocale('fr', locales)).toBe('fr')\n+      expect(getAcceptLanguageLocale('de', locales)).toBe('de')\n+    })\n+\n+    it('should parse accept-language with quality values', () => {\n+      expect(getAcceptLanguageLocale('fr;q=0.9,en;q=0.8', locales)).toBe('fr')\n+      expect(getAcceptLanguageLocale('en;q=0.8,fr;q=0.9', locales)).toBe('fr')\n+    })\n+\n+    it('should handle multiple locales', () => {\n+      expect(getAcceptLanguageLocale('ja,en;q=0.9,fr;q=0.8', locales)).toBe(\n+        'ja'\n+      )\n+    })\n+\n+    it('should match prefix for regional variants', () => {\n+      expect(getAcceptLanguageLocale('fr-FR', locales)).toBe('fr')\n+      expect(getAcceptLanguageLocale('en-US,en;q=0.9', locales)).toBe('en')\n+    })\n+\n+    it('should return undefined for no match', () => {\n+      expect(getAcceptLanguageLocale('es', locales)).toBeUndefined()\n+      expect(getAcceptLanguageLocale('', locales)).toBeUndefined()\n+    })\n+\n+    it('should handle malformed headers gracefully', () => {\n+      expect(getAcceptLanguageLocale('invalid;;;', locales)).toBeUndefined()\n+    })\n+  })\n+\n+  describe('getCookieLocale', () => {\n+    const locales = ['en', 'fr', 'de']\n+\n+    it('should extract locale from NEXT_LOCALE cookie', () => {\n+      expect(getCookieLocale('NEXT_LOCALE=fr', locales)).toBe('fr')\n+      expect(getCookieLocale('NEXT_LOCALE=de', locales)).toBe('de')\n+    })\n+\n+    it('should handle multiple cookies', () => {\n+      expect(\n+        getCookieLocale('session=abc123; NEXT_LOCALE=fr; theme=dark', locales)\n+      ).toBe('fr')\n+    })\n+\n+    it('should be case-insensitive for locale value', () => {\n+      expect(getCookieLocale('NEXT_LOCALE=FR', locales)).toBe('fr')\n+      expect(getCookieLocale('NEXT_LOCALE=De', locales)).toBe('de')\n+    })\n+\n+    it('should return undefined for no match', () => {\n+      expect(getCookieLocale('NEXT_LOCALE=es', locales)).toBeUndefined()\n+      expect(getCookieLocale('session=abc123', locales)).toBeUndefined()\n+      expect(getCookieLocale('', locales)).toBeUndefined()\n+      expect(getCookieLocale(undefined, locales)).toBeUndefined()\n+    })\n+\n+    it('should handle URL-encoded values', () => {\n+      expect(getCookieLocale('NEXT_LOCALE=fr%2DFR', locales)).toBeUndefined()\n+    })\n+  })\n+\n+  describe('detectLocale', () => {\n+    const i18nConfig: I18nConfig = {\n+      defaultLocale: 'en',\n+      locales: ['en', 'fr', 'de', 'ja'],\n+      domains: [\n+        { domain: 'example.com', defaultLocale: 'en' },\n+        { domain: 'example.fr', defaultLocale: 'fr' },\n+      ],\n+    }\n+\n+    it('should prioritize locale in pathname', () => {\n+      const result = detectLocale({\n+        pathname: '/fr/about',\n+        hostname: 'example.com',\n+        cookieHeader: 'NEXT_LOCALE=de',\n+        acceptLanguageHeader: 'ja',\n+        i18n: i18nConfig,\n+      })\n+      expect(result.locale).toBe('fr')\n+      expect(result.pathnameWithoutLocale).toBe('/about')\n+      expect(result.localeInPath).toBe(true)\n+    })\n+\n+    it('should use domain locale when no locale in path', () => {\n+      const result = detectLocale({\n+        pathname: '/about',\n+        hostname: 'example.fr',\n+        cookieHeader: undefined,\n+        acceptLanguageHeader: undefined,\n+        i18n: i18nConfig,\n+      })\n+      expect(result.locale).toBe('fr')\n+      expect(result.localeInPath).toBe(false)\n+    })\n+\n+    it('should use cookie locale when no path or domain match', () => {\n+      const result = detectLocale({\n+        pathname: '/about',\n+        hostname: 'other.com',\n+        cookieHeader: 'NEXT_LOCALE=de',\n+        acceptLanguageHeader: 'ja',\n+        i18n: i18nConfig,\n+      })\n+      expect(result.locale).toBe('de')\n+      expect(result.localeInPath).toBe(false)\n+    })\n+\n+    it('should use accept-language when no other match', () => {\n+      const result = detectLocale({\n+        pathname: '/about',\n+        hostname: 'other.com',\n+        cookieHeader: undefined,\n+        acceptLanguageHeader: 'ja,en;q=0.9',\n+        i18n: i18nConfig,\n+      })\n+      expect(result.locale).toBe('ja')\n+      expect(result.localeInPath).toBe(false)\n+    })\n+\n+    it('should fallback to default locale', () => {\n+      const result = detectLocale({\n+        pathname: '/about',\n+        hostname: 'other.com',\n+        cookieHeader: undefined,\n+        acceptLanguageHeader: undefined,\n+        i18n: i18nConfig,\n+      })\n+      expect(result.locale).toBe('en')\n+      expect(result.localeInPath).toBe(false)\n+    })\n+\n+    it('should use default locale when localeDetection is disabled', () => {\n+      const result = detectLocale({\n+        pathname: '/about',\n+        hostname: 'other.com',\n+        cookieHeader: 'NEXT_LOCALE=fr',\n+        acceptLanguageHeader: 'ja',\n+        i18n: { ...i18nConfig, localeDetection: false },\n+      })\n+      expect(result.locale).toBe('en')\n+      expect(result.localeInPath).toBe(false)\n+    })\n+\n+    it('should respect domain locale even with localeDetection disabled', () => {\n+      const result = detectLocale({\n+        pathname: '/about',\n+        hostname: 'example.fr',\n+        cookieHeader: 'NEXT_LOCALE=de',\n+        acceptLanguageHeader: 'ja',\n+        i18n: { ...i18nConfig, localeDetection: false },\n+      })\n+      expect(result.locale).toBe('fr')\n+      expect(result.localeInPath).toBe(false)\n+    })\n+  })\n+})"
        },
        {
            "sha": "4e88a927a6b430a39fe6d23a9fa333a2592b7c20",
            "filename": "packages/next-routing/src/__tests__/middleware.test.ts",
            "status": "added",
            "additions": 641,
            "deletions": 0,
            "changes": 641,
            "blob_url": "https://github.com/vercel/next.js/blob/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext-routing%2Fsrc%2F__tests__%2Fmiddleware.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext-routing%2Fsrc%2F__tests__%2Fmiddleware.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext-routing%2Fsrc%2F__tests__%2Fmiddleware.test.ts?ref=840643f2078cb3fbf5e0689d1e7948b711b9de62",
            "patch": "@@ -0,0 +1,641 @@\n+import { responseToMiddlewareResult } from '../middleware'\n+\n+describe('responseToMiddlewareResult', () => {\n+  describe('basic response handling', () => {\n+    it('should handle a simple response with no special headers', () => {\n+      const response = new Response(null, {\n+        status: 200,\n+        headers: {\n+          'content-type': 'text/html',\n+          'x-custom-header': 'value',\n+        },\n+      })\n+      const requestHeaders = new Headers({\n+        'user-agent': 'test',\n+        accept: 'text/html',\n+      })\n+      const url = new URL('https://example.com/test')\n+\n+      const result = responseToMiddlewareResult(response, requestHeaders, url)\n+\n+      expect(result.bodySent).toBe(true)\n+      expect(result.responseHeaders?.get('content-type')).toBe('text/html')\n+      expect(result.responseHeaders?.get('x-custom-header')).toBe('value')\n+      expect(requestHeaders.get('content-type')).toBe('text/html')\n+      expect(requestHeaders.get('x-custom-header')).toBe('value')\n+    })\n+\n+    it('should set x-middleware-refresh when no routing headers present', () => {\n+      const response = new Response(null, {\n+        status: 200,\n+        headers: {\n+          'content-type': 'text/html',\n+        },\n+      })\n+      const requestHeaders = new Headers()\n+      const url = new URL('https://example.com/test')\n+\n+      const result = responseToMiddlewareResult(response, requestHeaders, url)\n+\n+      expect(result.bodySent).toBe(true)\n+    })\n+\n+    it('should handle multiple values for the same header', () => {\n+      const response = new Response(null, {\n+        status: 200,\n+      })\n+      response.headers.append('set-cookie', 'cookie1=value1')\n+      response.headers.append('set-cookie', 'cookie2=value2')\n+\n+      const requestHeaders = new Headers()\n+      const url = new URL('https://example.com/test')\n+\n+      const result = responseToMiddlewareResult(response, requestHeaders, url)\n+\n+      expect(result.responseHeaders).toBeDefined()\n+      const setCookieValues = result.responseHeaders?.get('set-cookie')\n+      expect(setCookieValues).toBeDefined()\n+    })\n+  })\n+\n+  describe('header override handling', () => {\n+    it('should override request headers based on x-middleware-override-headers', () => {\n+      const response = new Response(null, {\n+        status: 200,\n+        headers: {\n+          'x-middleware-override-headers': 'authorization,x-custom',\n+          'x-middleware-request-authorization': 'Bearer new-token',\n+          'x-middleware-request-x-custom': 'new-value',\n+        },\n+      })\n+      const requestHeaders = new Headers({\n+        authorization: 'Bearer old-token',\n+        'x-custom': 'old-value',\n+        'user-agent': 'test-agent',\n+        accept: 'text/html',\n+      })\n+      const url = new URL('https://example.com/test')\n+\n+      responseToMiddlewareResult(response, requestHeaders, url)\n+\n+      // Headers in override list should be updated\n+      expect(requestHeaders.get('authorization')).toBe('Bearer new-token')\n+      expect(requestHeaders.get('x-custom')).toBe('new-value')\n+\n+      // Headers not in override list should be deleted\n+      expect(requestHeaders.get('user-agent')).toBeNull()\n+      expect(requestHeaders.get('accept')).toBeNull()\n+    })\n+\n+    it('should handle comma-separated override headers list', () => {\n+      const response = new Response(null, {\n+        status: 200,\n+        headers: {\n+          'x-middleware-override-headers': 'host, authorization, x-custom',\n+          'x-middleware-request-host': 'new-host.com',\n+          'x-middleware-request-authorization': 'Bearer token',\n+          'x-middleware-request-x-custom': 'custom-value',\n+        },\n+      })\n+      const requestHeaders = new Headers({\n+        host: 'old-host.com',\n+        authorization: 'old-auth',\n+        'x-custom': 'old-custom',\n+        'user-agent': 'browser',\n+      })\n+      const url = new URL('https://example.com/test')\n+\n+      responseToMiddlewareResult(response, requestHeaders, url)\n+\n+      expect(requestHeaders.get('host')).toBe('new-host.com')\n+      expect(requestHeaders.get('authorization')).toBe('Bearer token')\n+      expect(requestHeaders.get('x-custom')).toBe('custom-value')\n+      expect(requestHeaders.get('user-agent')).toBeNull()\n+    })\n+\n+    it('should delete header when override value is null', () => {\n+      const response = new Response(null, {\n+        status: 200,\n+        headers: {\n+          'x-middleware-override-headers': 'authorization',\n+        },\n+      })\n+      const requestHeaders = new Headers({\n+        authorization: 'Bearer token',\n+        'user-agent': 'test',\n+      })\n+      const url = new URL('https://example.com/test')\n+\n+      const result = responseToMiddlewareResult(response, requestHeaders, url)\n+\n+      expect(result.responseHeaders).toBeDefined()\n+      expect(requestHeaders.get('authorization')).toBeNull()\n+    })\n+\n+    it('should not include x-middleware-override-headers in response', () => {\n+      const response = new Response(null, {\n+        status: 200,\n+        headers: {\n+          'x-middleware-override-headers': 'authorization',\n+          'x-middleware-request-authorization': 'Bearer token',\n+        },\n+      })\n+      const requestHeaders = new Headers()\n+      const url = new URL('https://example.com/test')\n+\n+      const result = responseToMiddlewareResult(response, requestHeaders, url)\n+\n+      expect(\n+        result.responseHeaders?.get('x-middleware-override-headers')\n+      ).toBeNull()\n+      expect(\n+        result.responseHeaders?.get('x-middleware-request-authorization')\n+      ).toBeNull()\n+    })\n+  })\n+\n+  describe('rewrite handling', () => {\n+    it('should handle x-middleware-rewrite with relative path', () => {\n+      const response = new Response(null, {\n+        status: 200,\n+        headers: {\n+          'x-middleware-rewrite': '/new-path',\n+        },\n+      })\n+      const requestHeaders = new Headers()\n+      const url = new URL('https://example.com/old-path')\n+\n+      const result = responseToMiddlewareResult(response, requestHeaders, url)\n+\n+      expect(result.rewrite).toBeDefined()\n+      expect(result.rewrite?.pathname).toBe('/new-path')\n+      expect(result.rewrite?.origin).toBe('https://example.com')\n+      expect(result.responseHeaders?.get('x-middleware-rewrite')).toBe(\n+        '/new-path'\n+      )\n+    })\n+\n+    it('should handle x-middleware-rewrite with absolute same-origin URL', () => {\n+      const response = new Response(null, {\n+        status: 200,\n+        headers: {\n+          'x-middleware-rewrite': 'https://example.com/new-path?query=value',\n+        },\n+      })\n+      const requestHeaders = new Headers()\n+      const url = new URL('https://example.com/old-path')\n+\n+      const result = responseToMiddlewareResult(response, requestHeaders, url)\n+\n+      expect(result.rewrite).toBeDefined()\n+      expect(result.rewrite?.pathname).toBe('/new-path')\n+      expect(result.rewrite?.search).toBe('?query=value')\n+      expect(result.responseHeaders?.get('x-middleware-rewrite')).toBe(\n+        '/new-path?query=value'\n+      )\n+    })\n+\n+    it('should handle x-middleware-rewrite with external URL', () => {\n+      const response = new Response(null, {\n+        status: 200,\n+        headers: {\n+          'x-middleware-rewrite': 'https://external.com/path',\n+        },\n+      })\n+      const requestHeaders = new Headers()\n+      const url = new URL('https://example.com/old-path')\n+\n+      const result = responseToMiddlewareResult(response, requestHeaders, url)\n+\n+      expect(result.rewrite).toBeDefined()\n+      expect(result.rewrite?.origin).toBe('https://external.com')\n+      expect(result.bodySent).toBeUndefined()\n+      expect(result.responseHeaders?.get('x-middleware-rewrite')).toBe(\n+        'https://external.com/path'\n+      )\n+    })\n+\n+    it('should not include x-middleware-rewrite in final response headers', () => {\n+      const response = new Response(null, {\n+        status: 200,\n+        headers: {\n+          'x-middleware-rewrite': '/new-path',\n+          'content-type': 'text/html',\n+        },\n+      })\n+      const requestHeaders = new Headers()\n+      const url = new URL('https://example.com/old-path')\n+\n+      const result = responseToMiddlewareResult(response, requestHeaders, url)\n+\n+      // x-middleware-rewrite should be filtered out\n+      expect(result.responseHeaders?.get('x-middleware-rewrite')).toBe(\n+        '/new-path'\n+      )\n+      expect(result.responseHeaders?.get('content-type')).toBe('text/html')\n+    })\n+  })\n+\n+  describe('redirect handling', () => {\n+    it('should handle 301 permanent redirect', () => {\n+      const response = new Response(null, {\n+        status: 301,\n+        headers: {\n+          location: '/new-location',\n+        },\n+      })\n+      const requestHeaders = new Headers()\n+      const url = new URL('https://example.com/old-location')\n+\n+      const result = responseToMiddlewareResult(response, requestHeaders, url)\n+\n+      expect(result.redirect).toBeDefined()\n+      expect(result.redirect?.status).toBe(301)\n+      expect(result.redirect?.url.pathname).toBe('/new-location')\n+      expect(result.bodySent).toBeUndefined()\n+      expect(result.responseHeaders?.get('location')).toBe('/new-location')\n+    })\n+\n+    it('should handle 302 temporary redirect', () => {\n+      const response = new Response(null, {\n+        status: 302,\n+        headers: {\n+          location: 'https://example.com/redirect',\n+        },\n+      })\n+      const requestHeaders = new Headers()\n+      const url = new URL('https://example.com/original')\n+\n+      const result = responseToMiddlewareResult(response, requestHeaders, url)\n+\n+      expect(result.redirect).toBeDefined()\n+      expect(result.redirect?.status).toBe(302)\n+      expect(result.redirect?.url.pathname).toBe('/redirect')\n+    })\n+\n+    it('should handle 307 and 308 redirects', () => {\n+      const redirectStatuses = [307, 308]\n+\n+      redirectStatuses.forEach((status) => {\n+        const response = new Response(null, {\n+          status,\n+          headers: {\n+            location: '/redirect',\n+          },\n+        })\n+        const requestHeaders = new Headers()\n+        const url = new URL('https://example.com/original')\n+\n+        const result = responseToMiddlewareResult(response, requestHeaders, url)\n+\n+        expect(result.redirect).toBeDefined()\n+        expect(result.redirect?.status).toBe(status)\n+        expect(result.bodySent).toBeUndefined()\n+      })\n+    })\n+\n+    it('should handle external redirect with absolute URL', () => {\n+      const response = new Response(null, {\n+        status: 302,\n+        headers: {\n+          location: 'https://external.com/path',\n+        },\n+      })\n+      const requestHeaders = new Headers()\n+      const url = new URL('https://example.com/original')\n+\n+      const result = responseToMiddlewareResult(response, requestHeaders, url)\n+\n+      expect(result.redirect).toBeDefined()\n+      expect(result.redirect?.url.origin).toBe('https://external.com')\n+      expect(result.redirect?.url.pathname).toBe('/path')\n+      expect(result.responseHeaders?.get('location')).toBe(\n+        'https://external.com/path'\n+      )\n+    })\n+\n+    it('should convert same-origin absolute URL to relative', () => {\n+      const response = new Response(null, {\n+        status: 301,\n+        headers: {\n+          location: 'https://example.com/new-path?foo=bar',\n+        },\n+      })\n+      const requestHeaders = new Headers()\n+      const url = new URL('https://example.com/old-path')\n+\n+      const result = responseToMiddlewareResult(response, requestHeaders, url)\n+\n+      expect(result.redirect).toBeDefined()\n+      expect(result.responseHeaders?.get('location')).toBe('/new-path?foo=bar')\n+    })\n+\n+    it('should not treat location header as redirect for non-redirect status codes', () => {\n+      const response = new Response(null, {\n+        status: 200,\n+        headers: {\n+          location: '/some-path',\n+        },\n+      })\n+      const requestHeaders = new Headers()\n+      const url = new URL('https://example.com/original')\n+\n+      const result = responseToMiddlewareResult(response, requestHeaders, url)\n+\n+      expect(result.redirect).toBeUndefined()\n+      expect(result.responseHeaders?.get('location')).toBe('/some-path')\n+      // Non-redirect location doesn't set bodySent\n+      expect(result.bodySent).toBeUndefined()\n+    })\n+\n+    it('should not treat location header as redirect for 304 status', () => {\n+      const response = new Response(null, {\n+        status: 304,\n+        headers: {\n+          location: '/cached',\n+        },\n+      })\n+      const requestHeaders = new Headers()\n+      const url = new URL('https://example.com/original')\n+\n+      const result = responseToMiddlewareResult(response, requestHeaders, url)\n+\n+      expect(result.redirect).toBeUndefined()\n+      expect(result.responseHeaders?.get('location')).toBe('/cached')\n+      // Non-redirect location doesn't set bodySent\n+      expect(result.bodySent).toBeUndefined()\n+    })\n+  })\n+\n+  describe('x-middleware-set-cookie handling', () => {\n+    it('should add x-middleware-set-cookie to request headers only', () => {\n+      const response = new Response(null, {\n+        status: 200,\n+        headers: {\n+          'x-middleware-set-cookie': 'session=abc123; Path=/',\n+        },\n+      })\n+      const requestHeaders = new Headers()\n+      const url = new URL('https://example.com/test')\n+\n+      const result = responseToMiddlewareResult(response, requestHeaders, url)\n+\n+      expect(requestHeaders.get('x-middleware-set-cookie')).toBe(\n+        'session=abc123; Path=/'\n+      )\n+      expect(result.responseHeaders?.get('x-middleware-set-cookie')).toBeNull()\n+    })\n+\n+    it('should handle multiple x-middleware-set-cookie values', () => {\n+      const response = new Response(null, {\n+        status: 200,\n+      })\n+      response.headers.append('x-middleware-set-cookie', 'cookie1=value1')\n+      response.headers.append('x-middleware-set-cookie', 'cookie2=value2')\n+\n+      const requestHeaders = new Headers()\n+      const url = new URL('https://example.com/test')\n+\n+      const result = responseToMiddlewareResult(response, requestHeaders, url)\n+\n+      expect(result.responseHeaders).toBeDefined()\n+      expect(requestHeaders.get('x-middleware-set-cookie')).toBeDefined()\n+      expect(result.responseHeaders?.get('x-middleware-set-cookie')).toBeNull()\n+    })\n+  })\n+\n+  describe('x-middleware-next handling', () => {\n+    it('should remove x-middleware-next from headers', () => {\n+      const response = new Response(null, {\n+        status: 200,\n+        headers: {\n+          'x-middleware-next': '1',\n+          'content-type': 'text/html',\n+        },\n+      })\n+      const requestHeaders = new Headers()\n+      const url = new URL('https://example.com/test')\n+\n+      const result = responseToMiddlewareResult(response, requestHeaders, url)\n+\n+      expect(result.responseHeaders?.get('x-middleware-next')).toBeNull()\n+      expect(result.responseHeaders?.get('content-type')).toBe('text/html')\n+    })\n+\n+    it('should not set x-middleware-refresh when x-middleware-next is present', () => {\n+      const response = new Response(null, {\n+        status: 200,\n+        headers: {\n+          'x-middleware-next': '1',\n+        },\n+      })\n+      const requestHeaders = new Headers()\n+      const url = new URL('https://example.com/test')\n+\n+      const result = responseToMiddlewareResult(response, requestHeaders, url)\n+\n+      // When x-middleware-next is present, refresh should not be set\n+      // and bodySent should not be true (middleware continues processing)\n+      expect(result.bodySent).toBeUndefined()\n+      expect(result.responseHeaders?.get('x-middleware-next')).toBeNull()\n+    })\n+  })\n+\n+  describe('internal header filtering', () => {\n+    it('should filter out content-length from response headers', () => {\n+      const response = new Response(null, {\n+        status: 200,\n+        headers: {\n+          'content-length': '12345',\n+          'content-type': 'text/html',\n+        },\n+      })\n+      const requestHeaders = new Headers()\n+      const url = new URL('https://example.com/test')\n+\n+      const result = responseToMiddlewareResult(response, requestHeaders, url)\n+\n+      expect(result.responseHeaders?.get('content-length')).toBeNull()\n+      expect(result.responseHeaders?.get('content-type')).toBe('text/html')\n+    })\n+\n+    it('should filter out x-middleware-redirect from response headers', () => {\n+      const response = new Response(null, {\n+        status: 200,\n+        headers: {\n+          'x-middleware-redirect': '/redirect',\n+          'content-type': 'text/html',\n+        },\n+      })\n+      const requestHeaders = new Headers()\n+      const url = new URL('https://example.com/test')\n+\n+      const result = responseToMiddlewareResult(response, requestHeaders, url)\n+\n+      expect(result.responseHeaders?.get('x-middleware-redirect')).toBeNull()\n+      expect(result.responseHeaders?.get('content-type')).toBe('text/html')\n+    })\n+\n+    it('should filter out x-middleware-refresh from response headers', () => {\n+      const response = new Response(null, {\n+        status: 200,\n+        headers: {\n+          'x-middleware-refresh': '1',\n+          'content-type': 'text/html',\n+        },\n+      })\n+      const requestHeaders = new Headers()\n+      const url = new URL('https://example.com/test')\n+\n+      const result = responseToMiddlewareResult(response, requestHeaders, url)\n+\n+      expect(result.responseHeaders?.get('x-middleware-refresh')).toBeNull()\n+      expect(result.bodySent).toBe(true)\n+    })\n+  })\n+\n+  describe('complex scenarios', () => {\n+    it('should handle rewrite with header overrides', () => {\n+      const response = new Response(null, {\n+        status: 200,\n+        headers: {\n+          'x-middleware-rewrite': '/api/v2/endpoint',\n+          'x-middleware-override-headers': 'authorization',\n+          'x-middleware-request-authorization': 'Bearer new-token',\n+          'x-custom-header': 'custom-value',\n+        },\n+      })\n+      const requestHeaders = new Headers({\n+        authorization: 'Bearer old-token',\n+        'user-agent': 'test',\n+      })\n+      const url = new URL('https://example.com/api/v1/endpoint')\n+\n+      const result = responseToMiddlewareResult(response, requestHeaders, url)\n+\n+      expect(result.rewrite).toBeDefined()\n+      expect(result.rewrite?.pathname).toBe('/api/v2/endpoint')\n+      expect(requestHeaders.get('authorization')).toBe('Bearer new-token')\n+      expect(requestHeaders.get('user-agent')).toBeNull()\n+      expect(result.responseHeaders?.get('x-custom-header')).toBe(\n+        'custom-value'\n+      )\n+    })\n+\n+    it('should prioritize redirect over rewrite', () => {\n+      const response = new Response(null, {\n+        status: 302,\n+        headers: {\n+          'x-middleware-rewrite': '/rewrite-path',\n+          location: '/redirect-path',\n+        },\n+      })\n+      const requestHeaders = new Headers()\n+      const url = new URL('https://example.com/original')\n+\n+      const result = responseToMiddlewareResult(response, requestHeaders, url)\n+\n+      // Redirect should take precedence\n+      expect(result.redirect).toBeDefined()\n+      expect(result.redirect?.url.pathname).toBe('/redirect-path')\n+      expect(result.bodySent).toBeUndefined()\n+    })\n+\n+    it('should handle query parameters in rewrites', () => {\n+      const response = new Response(null, {\n+        status: 200,\n+        headers: {\n+          'x-middleware-rewrite': '/new-path?foo=bar&baz=qux',\n+        },\n+      })\n+      const requestHeaders = new Headers()\n+      const url = new URL('https://example.com/old-path?original=param')\n+\n+      const result = responseToMiddlewareResult(response, requestHeaders, url)\n+\n+      expect(result.rewrite).toBeDefined()\n+      expect(result.rewrite?.pathname).toBe('/new-path')\n+      expect(result.rewrite?.search).toBe('?foo=bar&baz=qux')\n+    })\n+\n+    it('should preserve hash in redirects', () => {\n+      const response = new Response(null, {\n+        status: 301,\n+        headers: {\n+          location: '/new-path#section',\n+        },\n+      })\n+      const requestHeaders = new Headers()\n+      const url = new URL('https://example.com/old-path')\n+\n+      const result = responseToMiddlewareResult(response, requestHeaders, url)\n+\n+      expect(result.redirect).toBeDefined()\n+      expect(result.redirect?.url.hash).toBe('#section')\n+    })\n+  })\n+\n+  describe('edge cases', () => {\n+    it('should handle empty response headers', () => {\n+      const response = new Response(null, {\n+        status: 200,\n+      })\n+      const requestHeaders = new Headers()\n+      const url = new URL('https://example.com/test')\n+\n+      const result = responseToMiddlewareResult(response, requestHeaders, url)\n+\n+      expect(result.bodySent).toBe(true)\n+      expect(result.responseHeaders).toBeDefined()\n+    })\n+\n+    it('should handle response with only internal headers', () => {\n+      const response = new Response(null, {\n+        status: 200,\n+        headers: {\n+          'content-length': '0',\n+          'x-middleware-next': '1',\n+        },\n+      })\n+      const requestHeaders = new Headers()\n+      const url = new URL('https://example.com/test')\n+\n+      const result = responseToMiddlewareResult(response, requestHeaders, url)\n+\n+      expect(result.responseHeaders).toBeDefined()\n+      expect(result.responseHeaders?.get('content-length')).toBeNull()\n+      expect(result.responseHeaders?.get('x-middleware-next')).toBeNull()\n+    })\n+\n+    it('should handle malformed URLs in rewrites gracefully', () => {\n+      const response = new Response(null, {\n+        status: 200,\n+        headers: {\n+          'x-middleware-rewrite': '/valid-path',\n+        },\n+      })\n+      const requestHeaders = new Headers()\n+      const url = new URL('https://example.com/test')\n+\n+      const result = responseToMiddlewareResult(response, requestHeaders, url)\n+\n+      expect(result.rewrite).toBeDefined()\n+      expect(result.rewrite?.pathname).toBe('/valid-path')\n+    })\n+\n+    it('should handle protocol-relative URLs in rewrites', () => {\n+      const response = new Response(null, {\n+        status: 200,\n+        headers: {\n+          'x-middleware-rewrite': '//external.com/path',\n+        },\n+      })\n+      const requestHeaders = new Headers()\n+      const url = new URL('https://example.com/test')\n+\n+      const result = responseToMiddlewareResult(response, requestHeaders, url)\n+\n+      expect(result.rewrite).toBeDefined()\n+    })\n+  })\n+})"
        },
        {
            "sha": "53939eed565b5a30d99b0bafb7e7b37623a35b08",
            "filename": "packages/next-routing/src/__tests__/normalize-next-data.test.ts",
            "status": "added",
            "additions": 770,
            "deletions": 0,
            "changes": 770,
            "blob_url": "https://github.com/vercel/next.js/blob/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext-routing%2Fsrc%2F__tests__%2Fnormalize-next-data.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext-routing%2Fsrc%2F__tests__%2Fnormalize-next-data.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext-routing%2Fsrc%2F__tests__%2Fnormalize-next-data.test.ts?ref=840643f2078cb3fbf5e0689d1e7948b711b9de62",
            "patch": "@@ -0,0 +1,770 @@\n+import { resolveRoutes } from '../resolve-routes'\n+import type { ResolveRoutesParams } from '../types'\n+\n+function createReadableStream(): ReadableStream {\n+  return new ReadableStream({\n+    start(controller) {\n+      controller.close()\n+    },\n+  })\n+}\n+\n+function createBaseParams(\n+  overrides: Partial<ResolveRoutesParams> = {}\n+): ResolveRoutesParams {\n+  return {\n+    url: new URL('https://example.com/'),\n+    buildId: 'BUILD_ID',\n+    basePath: '',\n+    requestBody: createReadableStream(),\n+    headers: new Headers(),\n+    pathnames: [],\n+    routes: {\n+      beforeMiddleware: [],\n+      beforeFiles: [],\n+      afterFiles: [],\n+      dynamicRoutes: [],\n+      onMatch: [],\n+      fallback: [],\n+    },\n+    invokeMiddleware: async () => ({}),\n+    ...overrides,\n+  }\n+}\n+\n+describe('normalizeNextData - beforeMiddleware', () => {\n+  it('should normalize data URL before processing beforeMiddleware', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/_next/data/BUILD_ID/blog/post.json'),\n+      basePath: '',\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/blog/(.+)$',\n+            destination: '/api/blog/$1',\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+        shouldNormalizeNextData: true,\n+      },\n+      pathnames: ['/_next/data/BUILD_ID/api/blog/post.json'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe(\n+      '/_next/data/BUILD_ID/api/blog/post.json'\n+    )\n+  })\n+\n+  it('should normalize with basePath', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/base/_next/data/BUILD_ID/page.json'),\n+      basePath: '/base',\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/base/page$',\n+            destination: '/base/api/page',\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+        shouldNormalizeNextData: true,\n+      },\n+      pathnames: ['/base/_next/data/BUILD_ID/api/page.json'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe(\n+      '/base/_next/data/BUILD_ID/api/page.json'\n+    )\n+  })\n+})\n+\n+describe('normalizeNextData - pathname checking', () => {\n+  it('should denormalize before checking pathnames after beforeFiles', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/_next/data/BUILD_ID/posts/hello.json'),\n+      basePath: '',\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+        shouldNormalizeNextData: true,\n+      },\n+      pathnames: ['/_next/data/BUILD_ID/posts/hello.json'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/_next/data/BUILD_ID/posts/hello.json')\n+  })\n+\n+  it('should work with rewrites then pathname check', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/_next/data/BUILD_ID/blog.json'),\n+      basePath: '',\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/blog$',\n+            destination: '/posts',\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+        shouldNormalizeNextData: true,\n+      },\n+      pathnames: ['/_next/data/BUILD_ID/posts.json'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/_next/data/BUILD_ID/posts.json')\n+  })\n+})\n+\n+describe('normalizeNextData - afterFiles', () => {\n+  it('should normalize again before processing afterFiles', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/_next/data/BUILD_ID/not-found.json'),\n+      basePath: '',\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [],\n+        afterFiles: [\n+          {\n+            sourceRegex: '^/not-found$',\n+            destination: '/404',\n+          },\n+        ],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+        shouldNormalizeNextData: true,\n+      },\n+      pathnames: ['/_next/data/BUILD_ID/404.json'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/_next/data/BUILD_ID/404.json')\n+  })\n+\n+  it('should handle complex flow: normalize -> beforeFiles -> denormalize -> normalize -> afterFiles -> denormalize', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/_next/data/BUILD_ID/api/users.json'),\n+      basePath: '',\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/api/users$',\n+            destination: '/users-data',\n+          },\n+        ],\n+        afterFiles: [\n+          {\n+            sourceRegex: '^/users-data$',\n+            destination: '/internal/users',\n+          },\n+        ],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+        shouldNormalizeNextData: true,\n+      },\n+      pathnames: ['/_next/data/BUILD_ID/internal/users.json'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe(\n+      '/_next/data/BUILD_ID/internal/users.json'\n+    )\n+  })\n+})\n+\n+describe('normalizeNextData - dynamic routes', () => {\n+  it('should denormalize before checking dynamic routes', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/_next/data/BUILD_ID/posts/123.json'),\n+      basePath: '',\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [],\n+        afterFiles: [],\n+        dynamicRoutes: [\n+          {\n+            sourceRegex: '^/_next/data/BUILD_ID/posts/(?<id>[^/]+)\\\\.json$',\n+            destination: '/_next/data/BUILD_ID/posts/123.json',\n+          },\n+        ],\n+        onMatch: [],\n+        fallback: [],\n+        shouldNormalizeNextData: true,\n+      },\n+      pathnames: ['/_next/data/BUILD_ID/posts/123.json'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/_next/data/BUILD_ID/posts/123.json')\n+    expect(result.routeMatches).toEqual({\n+      '1': '123',\n+      id: '123',\n+    })\n+  })\n+\n+  it('should reset URL to denormalized version after dynamic route match', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/_next/data/BUILD_ID/user/alice.json'),\n+      basePath: '',\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [],\n+        afterFiles: [\n+          {\n+            sourceRegex: '^/user/(.+)$',\n+            destination: '/users/$1',\n+          },\n+        ],\n+        dynamicRoutes: [\n+          {\n+            sourceRegex:\n+              '^/_next/data/BUILD_ID/users/(?<username>[^/]+)\\\\.json$',\n+            destination: '/_next/data/BUILD_ID/users/alice.json',\n+          },\n+        ],\n+        onMatch: [],\n+        fallback: [],\n+        shouldNormalizeNextData: true,\n+      },\n+      pathnames: ['/_next/data/BUILD_ID/users/alice.json'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    // Should match with denormalized pathname\n+    expect(result.matchedPathname).toBe('/_next/data/BUILD_ID/users/alice.json')\n+    expect(result.routeMatches).toEqual({\n+      '1': 'alice',\n+      username: 'alice',\n+    })\n+  })\n+\n+  it('should work with dynamic routes after afterFiles rewrite', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/_next/data/BUILD_ID/blog/post-1.json'),\n+      basePath: '',\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [],\n+        afterFiles: [\n+          {\n+            sourceRegex: '^/blog/(.+)$',\n+            destination: '/posts/$1',\n+          },\n+        ],\n+        dynamicRoutes: [\n+          {\n+            sourceRegex: '^/_next/data/BUILD_ID/posts/(?<slug>[^/]+)\\\\.json$',\n+            destination: '/_next/data/BUILD_ID/posts/post-1.json',\n+          },\n+        ],\n+        onMatch: [],\n+        fallback: [],\n+        shouldNormalizeNextData: true,\n+      },\n+      pathnames: ['/_next/data/BUILD_ID/posts/post-1.json'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe(\n+      '/_next/data/BUILD_ID/posts/post-1.json'\n+    )\n+    expect(result.routeMatches).toEqual({\n+      '1': 'post-1',\n+      slug: 'post-1',\n+    })\n+  })\n+})\n+\n+describe('normalizeNextData - fallback routes', () => {\n+  it('should handle normalization with fallback routes', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/_next/data/BUILD_ID/unknown.json'),\n+      basePath: '',\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [\n+          {\n+            sourceRegex: '^/unknown$',\n+            destination: '/404',\n+          },\n+        ],\n+        shouldNormalizeNextData: true,\n+      },\n+      pathnames: ['/_next/data/BUILD_ID/404.json'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/_next/data/BUILD_ID/404.json')\n+  })\n+})\n+\n+describe('normalizeNextData - without normalization', () => {\n+  it('should work normally when normalizeNextData is not provided', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/blog/post'),\n+      basePath: '',\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/blog/(.+)$',\n+            destination: '/posts/$1',\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/posts/post'],\n+      // normalizeNextData not provided\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/posts/post')\n+  })\n+\n+  it('should not normalize when normalizeNextData is undefined', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/_next/data/BUILD_ID/page.json'),\n+      basePath: '',\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/_next/data/BUILD_ID/page\\\\.json$',\n+            destination: '/api/page',\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+        shouldNormalizeNextData: undefined,\n+      },\n+      pathnames: ['/api/page'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/api/page')\n+  })\n+\n+  it('should not normalize URLs that are not data URLs', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/regular/path'),\n+      basePath: '',\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+        shouldNormalizeNextData: true,\n+      },\n+      pathnames: ['/regular/path'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/regular/path')\n+  })\n+\n+  it('should not apply normalization to non-data URLs even with rewrites', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/blog/post'),\n+      basePath: '',\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/blog/(.+)$',\n+            destination: '/posts/$1',\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+        shouldNormalizeNextData: true,\n+      },\n+      pathnames: ['/posts/post'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/posts/post')\n+  })\n+\n+  it('should not normalize if rewrite creates a data URL pattern from non-data URL', async () => {\n+    // Edge case: original URL is NOT a data URL, but rewrite creates path that looks like one\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/redirect-to-data'),\n+      basePath: '',\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/redirect-to-data$',\n+            destination: '/_next/data/BUILD_ID/some/path.json',\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+        shouldNormalizeNextData: true,\n+      },\n+      pathnames: ['/_next/data/BUILD_ID/some/path.json'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    // Should NOT normalize because original URL was not a data URL\n+    expect(result.matchedPathname).toBe('/_next/data/BUILD_ID/some/path.json')\n+  })\n+\n+  it('should not normalize in afterFiles if original URL was not a data URL', async () => {\n+    // Edge case: rewrite in beforeFiles creates data URL pattern,\n+    // then afterFiles tries to rewrite again - should NOT normalize before afterFiles\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/api/data'),\n+      basePath: '',\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/api/data$',\n+            destination: '/_next/data/BUILD_ID/raw.json',\n+          },\n+        ],\n+        afterFiles: [\n+          {\n+            sourceRegex: '^/_next/data/BUILD_ID/raw\\\\.json$',\n+            destination: '/processed.json',\n+          },\n+        ],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+        shouldNormalizeNextData: true,\n+      },\n+      pathnames: ['/processed.json'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    // Should match because afterFiles rewrite should work on the unrewritten data URL path\n+    expect(result.matchedPathname).toBe('/processed.json')\n+  })\n+\n+  it('should not normalize data URLs with different buildId', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/_next/data/DIFFERENT_ID/page.json'),\n+      basePath: '',\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+        shouldNormalizeNextData: true,\n+      },\n+      pathnames: ['/_next/data/DIFFERENT_ID/page.json'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/_next/data/DIFFERENT_ID/page.json')\n+  })\n+\n+  it('should handle data URL without .json extension', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/_next/data/BUILD_ID/page'),\n+      basePath: '',\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+        shouldNormalizeNextData: true,\n+      },\n+      pathnames: ['/_next/data/BUILD_ID/page.json'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/_next/data/BUILD_ID/page.json')\n+  })\n+\n+  it('should resolve to _next/data pathname when both exist and URL is a data URL', async () => {\n+    // When both normalized and denormalized paths exist, data URL should match denormalized\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/_next/data/BUILD_ID/posts.json'),\n+      basePath: '',\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+        shouldNormalizeNextData: true,\n+      },\n+      pathnames: ['/posts', '/_next/data/BUILD_ID/posts.json'], // Both exist\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    // Should match the denormalized path\n+    expect(result.matchedPathname).toBe('/_next/data/BUILD_ID/posts.json')\n+  })\n+\n+  it('should resolve to normalized pathname when both exist and URL is NOT a data URL', async () => {\n+    // When both normalized and denormalized paths exist, regular URL should match normalized\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/posts'),\n+      basePath: '',\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+        shouldNormalizeNextData: true,\n+      },\n+      pathnames: ['/posts', '/_next/data/BUILD_ID/posts.json'], // Both exist\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    // Should match the normalized path\n+    expect(result.matchedPathname).toBe('/posts')\n+  })\n+\n+  it('should resolve to _next/data pathname after rewrite when both exist and original URL is data URL', async () => {\n+    // After rewrite, should still use denormalized pathname check\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/_next/data/BUILD_ID/blog.json'),\n+      basePath: '',\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/blog$',\n+            destination: '/posts',\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+        shouldNormalizeNextData: true,\n+      },\n+      pathnames: ['/posts', '/_next/data/BUILD_ID/posts.json'], // Both exist\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    // Should match the denormalized path\n+    expect(result.matchedPathname).toBe('/_next/data/BUILD_ID/posts.json')\n+  })\n+\n+  it('should resolve to normalized pathname after rewrite when both exist and original URL is NOT data URL', async () => {\n+    // After rewrite, regular URL should still use normalized pathname check\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/blog'),\n+      basePath: '',\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/blog$',\n+            destination: '/posts',\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+        shouldNormalizeNextData: true,\n+      },\n+      pathnames: ['/posts', '/_next/data/BUILD_ID/posts.json'], // Both exist\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    // Should match the normalized path\n+    expect(result.matchedPathname).toBe('/posts')\n+  })\n+\n+  it('should resolve to _next/data pathname after afterFiles rewrite when original URL is data URL', async () => {\n+    // afterFiles phase should also denormalize for data URLs\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/_next/data/BUILD_ID/notfound.json'),\n+      basePath: '',\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [],\n+        afterFiles: [\n+          {\n+            sourceRegex: '^/notfound$',\n+            destination: '/404',\n+          },\n+        ],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+        shouldNormalizeNextData: true,\n+      },\n+      pathnames: ['/404', '/_next/data/BUILD_ID/404.json'], // Both exist\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    // Should match the denormalized path\n+    expect(result.matchedPathname).toBe('/_next/data/BUILD_ID/404.json')\n+  })\n+\n+  it('should resolve to normalized pathname after afterFiles rewrite when original URL is NOT data URL', async () => {\n+    // afterFiles phase should use normalized check for regular URLs\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/notfound'),\n+      basePath: '',\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [],\n+        afterFiles: [\n+          {\n+            sourceRegex: '^/notfound$',\n+            destination: '/404',\n+          },\n+        ],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+        shouldNormalizeNextData: true,\n+      },\n+      pathnames: ['/404', '/_next/data/BUILD_ID/404.json'], // Both exist\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    // Should match the normalized path\n+    expect(result.matchedPathname).toBe('/404')\n+  })\n+\n+  it('should resolve to _next/data pathname with dynamic routes when both exist and original URL is data URL', async () => {\n+    // Dynamic routes with data URLs\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/_next/data/BUILD_ID/posts/hello.json'),\n+      basePath: '',\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [],\n+        afterFiles: [],\n+        dynamicRoutes: [\n+          {\n+            sourceRegex: '^/_next/data/BUILD_ID/posts/(?<slug>[^/]+)\\\\.json$',\n+            destination: '/_next/data/BUILD_ID/posts/hello.json',\n+          },\n+          {\n+            sourceRegex: '^/posts/(?<slug>[^/]+)$',\n+            destination: '/posts/hello',\n+          },\n+        ],\n+        onMatch: [],\n+        fallback: [],\n+        shouldNormalizeNextData: true,\n+      },\n+      pathnames: ['/posts/hello', '/_next/data/BUILD_ID/posts/hello.json'], // Both exist\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    // Should match the denormalized path with the first dynamic route\n+    expect(result.matchedPathname).toBe('/_next/data/BUILD_ID/posts/hello.json')\n+    expect(result.routeMatches).toEqual({\n+      '1': 'hello',\n+      slug: 'hello',\n+    })\n+  })\n+\n+  it('should resolve to normalized pathname with dynamic routes when both exist and original URL is NOT data URL', async () => {\n+    // Dynamic routes with regular URLs\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/posts/hello'),\n+      basePath: '',\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [],\n+        afterFiles: [],\n+        dynamicRoutes: [\n+          {\n+            sourceRegex: '^/_next/data/BUILD_ID/posts/(?<slug>[^/]+)\\\\.json$',\n+            destination: '/_next/data/BUILD_ID/posts/hello.json',\n+          },\n+          {\n+            sourceRegex: '^/posts/(?<slug>[^/]+)$',\n+            destination: '/posts/hello',\n+          },\n+        ],\n+        onMatch: [],\n+        fallback: [],\n+        shouldNormalizeNextData: true,\n+      },\n+      pathnames: ['/posts/hello', '/_next/data/BUILD_ID/posts/hello.json'], // Both exist\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    // Should match the normalized path with the second dynamic route\n+    expect(result.matchedPathname).toBe('/posts/hello')\n+    expect(result.routeMatches).toEqual({\n+      '1': 'hello',\n+      slug: 'hello',\n+    })\n+  })\n+})"
        },
        {
            "sha": "7f4e4e2ebb06424081f855f0bc94bb595811476b",
            "filename": "packages/next-routing/src/__tests__/redirects.test.ts",
            "status": "added",
            "additions": 635,
            "deletions": 0,
            "changes": 635,
            "blob_url": "https://github.com/vercel/next.js/blob/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext-routing%2Fsrc%2F__tests__%2Fredirects.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext-routing%2Fsrc%2F__tests__%2Fredirects.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext-routing%2Fsrc%2F__tests__%2Fredirects.test.ts?ref=840643f2078cb3fbf5e0689d1e7948b711b9de62",
            "patch": "@@ -0,0 +1,635 @@\n+import { resolveRoutes } from '../resolve-routes'\n+import type { ResolveRoutesParams } from '../types'\n+\n+function createReadableStream(): ReadableStream {\n+  return new ReadableStream({\n+    start(controller) {\n+      controller.close()\n+    },\n+  })\n+}\n+\n+function createBaseParams(\n+  overrides: Partial<ResolveRoutesParams> = {}\n+): ResolveRoutesParams {\n+  return {\n+    url: new URL('https://example.com/'),\n+    buildId: 'BUILD_ID',\n+    basePath: '',\n+    requestBody: createReadableStream(),\n+    headers: new Headers(),\n+    pathnames: [],\n+    routes: {\n+      beforeMiddleware: [],\n+      beforeFiles: [],\n+      afterFiles: [],\n+      dynamicRoutes: [],\n+      onMatch: [],\n+      fallback: [],\n+    },\n+    invokeMiddleware: async () => ({}),\n+    ...overrides,\n+  }\n+}\n+\n+describe('Redirects with Location header', () => {\n+  it('should handle 301 permanent redirect', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/old'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/old$',\n+            destination: '/new',\n+            status: 301,\n+            headers: {\n+              Location: '/new',\n+            },\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.redirect).toBeDefined()\n+    expect(result.redirect?.status).toBe(301)\n+    expect(result.redirect?.url.pathname).toBe('/new')\n+    expect(result.matchedPathname).toBeUndefined()\n+    expect(result.externalRewrite).toBeUndefined()\n+  })\n+\n+  it('should handle 302 temporary redirect', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/temp'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/temp$',\n+            destination: '/temporary',\n+            status: 302,\n+            headers: {\n+              Location: '/temporary',\n+            },\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.redirect).toBeDefined()\n+    expect(result.redirect?.status).toBe(302)\n+    expect(result.redirect?.url.pathname).toBe('/temporary')\n+  })\n+\n+  it('should handle 307 temporary redirect', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/api/v1'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/api/v1$',\n+            destination: '/api/v2',\n+            status: 307,\n+            headers: {\n+              Location: '/api/v2',\n+            },\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.redirect).toBeDefined()\n+    expect(result.redirect?.status).toBe(307)\n+    expect(result.redirect?.url.pathname).toBe('/api/v2')\n+  })\n+\n+  it('should handle 308 permanent redirect', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/legacy'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/legacy$',\n+            destination: '/modern',\n+            status: 308,\n+            headers: {\n+              Location: '/modern',\n+            },\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.redirect).toBeDefined()\n+    expect(result.redirect?.status).toBe(308)\n+    expect(result.redirect?.url.pathname).toBe('/modern')\n+  })\n+\n+  it('should handle external redirect with Location header', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/external'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/external$',\n+            destination: 'https://newdomain.com/page',\n+            status: 301,\n+            headers: {\n+              Location: 'https://newdomain.com/page',\n+            },\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.redirect).toBeDefined()\n+    expect(result.redirect?.status).toBe(301)\n+    expect(result.redirect?.url.toString()).toBe('https://newdomain.com/page')\n+  })\n+\n+  it('should handle redirect with regex captures', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/users/123'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/users/([^/]+)$',\n+            destination: '/profile/$1',\n+            status: 301,\n+            headers: {\n+              Location: '/profile/$1',\n+            },\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.redirect).toBeDefined()\n+    expect(result.redirect?.url.pathname).toBe('/profile/123')\n+  })\n+\n+  it('should handle redirect with named captures', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/blog/2024/my-post'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/blog/(?<year>[^/]+)/(?<slug>[^/]+)$',\n+            destination: '/$year/posts/$slug',\n+            status: 301,\n+            headers: {\n+              Location: '/$year/posts/$slug',\n+            },\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.redirect).toBeDefined()\n+    expect(result.redirect?.url.pathname).toBe('/2024/posts/my-post')\n+  })\n+})\n+\n+describe('Redirects with Refresh header', () => {\n+  it('should handle redirect with Refresh header', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/refresh'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/refresh$',\n+            destination: '/refreshed',\n+            status: 302,\n+            headers: {\n+              Refresh: '0; url=/refreshed',\n+            },\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.redirect).toBeDefined()\n+    expect(result.redirect?.status).toBe(302)\n+    expect(result.redirect?.url.pathname).toBe('/refreshed')\n+  })\n+\n+  it('should prioritize redirect over rewrite when status is 3xx', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/priority-test'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/priority-test$',\n+            destination: '/target',\n+            status: 301,\n+            headers: {\n+              Location: '/target',\n+            },\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/target'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    // Should return redirect, not matchedPathname\n+    expect(result.redirect).toBeDefined()\n+    expect(result.matchedPathname).toBeUndefined()\n+  })\n+})\n+\n+describe('Redirects in different route phases', () => {\n+  it('should handle redirect in beforeMiddleware', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/early-redirect'),\n+      routes: {\n+        beforeMiddleware: [\n+          {\n+            sourceRegex: '^/early-redirect$',\n+            destination: '/redirected',\n+            status: 301,\n+            headers: {\n+              Location: '/redirected',\n+            },\n+          },\n+        ],\n+        beforeFiles: [],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.redirect).toBeDefined()\n+    expect(result.redirect?.status).toBe(301)\n+  })\n+\n+  it('should handle redirect in beforeFiles', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/before-files-redirect'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/before-files-redirect$',\n+            destination: '/redirected',\n+            status: 302,\n+            headers: {\n+              Location: '/redirected',\n+            },\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.redirect).toBeDefined()\n+    expect(result.redirect?.status).toBe(302)\n+  })\n+\n+  it('should handle redirect in afterFiles', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/after-files-redirect'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [],\n+        afterFiles: [\n+          {\n+            sourceRegex: '^/after-files-redirect$',\n+            destination: '/redirected',\n+            status: 307,\n+            headers: {\n+              Location: '/redirected',\n+            },\n+          },\n+        ],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.redirect).toBeDefined()\n+    expect(result.redirect?.status).toBe(307)\n+  })\n+\n+  it('should handle redirect in fallback', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/fallback-redirect'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [\n+          {\n+            sourceRegex: '^/fallback-redirect$',\n+            destination: '/redirected',\n+            status: 308,\n+            headers: {\n+              Location: '/redirected',\n+            },\n+          },\n+        ],\n+      },\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.redirect).toBeDefined()\n+    expect(result.redirect?.status).toBe(308)\n+  })\n+})\n+\n+describe('Redirect edge cases', () => {\n+  it('should NOT redirect when status is 200 even with Location header', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/not-redirect'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/not-redirect$',\n+            destination: '/target',\n+            status: 200,\n+            headers: {\n+              Location: '/target',\n+            },\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/target'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    // Should not redirect, should rewrite instead\n+    expect(result.redirect).toBeUndefined()\n+    expect(result.matchedPathname).toBe('/target')\n+  })\n+\n+  it('should NOT redirect when status is 3xx but no Location/Refresh header', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/no-location'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/no-location$',\n+            destination: '/target',\n+            status: 301,\n+            headers: {\n+              'X-Custom': 'value',\n+            },\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/target'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    // Should not redirect without Location or Refresh header\n+    expect(result.redirect).toBeUndefined()\n+    expect(result.matchedPathname).toBe('/target')\n+  })\n+\n+  it('should stop processing routes after redirect', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/stop-after-redirect'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/stop-after-redirect$',\n+            destination: '/redirected',\n+            status: 301,\n+            headers: {\n+              Location: '/redirected',\n+            },\n+          },\n+          {\n+            sourceRegex: '^/redirected$',\n+            destination: '/should-not-reach',\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.redirect).toBeDefined()\n+    expect(result.redirect?.url.pathname).toBe('/redirected')\n+    expect(result.matchedPathname).toBeUndefined()\n+  })\n+\n+  it('should handle case-insensitive Location header check', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/case-test'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/case-test$',\n+            destination: '/target',\n+            status: 301,\n+            headers: {\n+              location: '/target', // lowercase\n+            },\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.redirect).toBeDefined()\n+    expect(result.redirect?.status).toBe(301)\n+  })\n+\n+  it('should handle redirect with query parameters', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/search?q=test'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/search$',\n+            destination: '/find?q=test&source=redirect',\n+            status: 302,\n+            headers: {\n+              Location: '/find?q=test&source=redirect',\n+            },\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.redirect).toBeDefined()\n+    expect(result.redirect?.url.pathname).toBe('/find')\n+    expect(result.redirect?.url.search).toContain('q=test')\n+  })\n+})\n+\n+describe('Redirect priority and precedence', () => {\n+  it('should execute redirect in beforeMiddleware before other routes', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/test'),\n+      routes: {\n+        beforeMiddleware: [\n+          {\n+            sourceRegex: '^/test$',\n+            destination: '/early',\n+            status: 301,\n+            headers: {\n+              Location: '/early',\n+            },\n+          },\n+        ],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/test$',\n+            destination: '/late',\n+            status: 302,\n+            headers: {\n+              Location: '/late',\n+            },\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.redirect?.url.pathname).toBe('/early')\n+    expect(result.redirect?.status).toBe(301)\n+  })\n+\n+  it('should not process middleware if beforeMiddleware redirects', async () => {\n+    const middlewareMock = jest.fn().mockResolvedValue({})\n+\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/redirect-early'),\n+      routes: {\n+        beforeMiddleware: [\n+          {\n+            sourceRegex: '^/redirect-early$',\n+            destination: '/redirected',\n+            status: 301,\n+            headers: {\n+              Location: '/redirected',\n+            },\n+          },\n+        ],\n+        beforeFiles: [],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      invokeMiddleware: middlewareMock,\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.redirect).toBeDefined()\n+    expect(middlewareMock).not.toHaveBeenCalled()\n+  })\n+})"
        },
        {
            "sha": "a62e2c92ebe395fd896629ff06db48fece28049a",
            "filename": "packages/next-routing/src/__tests__/resolve-routes.test.ts",
            "status": "added",
            "additions": 660,
            "deletions": 0,
            "changes": 660,
            "blob_url": "https://github.com/vercel/next.js/blob/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext-routing%2Fsrc%2F__tests__%2Fresolve-routes.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext-routing%2Fsrc%2F__tests__%2Fresolve-routes.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext-routing%2Fsrc%2F__tests__%2Fresolve-routes.test.ts?ref=840643f2078cb3fbf5e0689d1e7948b711b9de62",
            "patch": "@@ -0,0 +1,660 @@\n+import { resolveRoutes } from '../resolve-routes'\n+import type { ResolveRoutesParams } from '../types'\n+\n+// Helper to create a ReadableStream\n+function createReadableStream(): ReadableStream {\n+  return new ReadableStream({\n+    start(controller) {\n+      controller.close()\n+    },\n+  })\n+}\n+\n+// Helper to create base params\n+function createBaseParams(\n+  overrides: Partial<ResolveRoutesParams> = {}\n+): ResolveRoutesParams {\n+  return {\n+    url: new URL('https://example.com/'),\n+    buildId: 'BUILD_ID',\n+    basePath: '',\n+    requestBody: createReadableStream(),\n+    headers: new Headers(),\n+    pathnames: [],\n+    routes: {\n+      beforeMiddleware: [],\n+      beforeFiles: [],\n+      afterFiles: [],\n+      dynamicRoutes: [],\n+      onMatch: [],\n+      fallback: [],\n+    },\n+    invokeMiddleware: async () => ({}),\n+    ...overrides,\n+  }\n+}\n+\n+describe('resolveRoutes - beforeMiddleware', () => {\n+  it('should process beforeMiddleware routes and rewrite internally', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/old-path'),\n+      routes: {\n+        beforeMiddleware: [\n+          {\n+            sourceRegex: '^/old-path$',\n+            destination: '/new-path',\n+          },\n+        ],\n+        beforeFiles: [],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/new-path'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/new-path')\n+    expect(result.resolvedHeaders).toBeDefined()\n+  })\n+\n+  it('should handle redirect in beforeMiddleware with Location header', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/old'),\n+      routes: {\n+        beforeMiddleware: [\n+          {\n+            sourceRegex: '^/old$',\n+            destination: '/new',\n+            status: 301,\n+            headers: {\n+              Location: '/new',\n+            },\n+          },\n+        ],\n+        beforeFiles: [],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.redirect).toBeDefined()\n+    expect(result.redirect?.status).toBe(301)\n+    expect(result.redirect?.url.pathname).toBe('/new')\n+  })\n+\n+  it('should handle external rewrite in beforeMiddleware', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/proxy'),\n+      routes: {\n+        beforeMiddleware: [\n+          {\n+            sourceRegex: '^/proxy$',\n+            destination: 'https://external.com/api',\n+          },\n+        ],\n+        beforeFiles: [],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.externalRewrite).toBeDefined()\n+    expect(result.externalRewrite?.toString()).toBe('https://external.com/api')\n+  })\n+\n+  it('should handle chained rewrites in beforeMiddleware', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/first'),\n+      routes: {\n+        beforeMiddleware: [\n+          {\n+            sourceRegex: '^/first$',\n+            destination: '/second',\n+          },\n+          {\n+            sourceRegex: '^/second$',\n+            destination: '/third',\n+          },\n+        ],\n+        beforeFiles: [],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/third'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/third')\n+  })\n+})\n+\n+describe('resolveRoutes - invokeMiddleware', () => {\n+  it('should call invokeMiddleware with current URL and headers', async () => {\n+    const middlewareMock = jest.fn().mockResolvedValue({})\n+\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/test'),\n+      invokeMiddleware: middlewareMock,\n+    })\n+\n+    await resolveRoutes(params)\n+\n+    expect(middlewareMock).toHaveBeenCalledWith(\n+      expect.objectContaining({\n+        url: expect.any(URL),\n+        headers: expect.any(Headers),\n+        requestBody: expect.any(ReadableStream),\n+      })\n+    )\n+  })\n+\n+  it('should stop routing when middleware returns bodySent', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/test'),\n+      invokeMiddleware: async () => ({ bodySent: true }),\n+      pathnames: ['/test'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.middlewareResponded).toBe(true)\n+    expect(result.matchedPathname).toBeUndefined()\n+  })\n+\n+  it('should handle middleware redirect', async () => {\n+    const redirectUrl = new URL('https://example.com/redirected')\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/test'),\n+      invokeMiddleware: async () => ({\n+        redirect: {\n+          url: redirectUrl,\n+          status: 302,\n+        },\n+      }),\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.status).toBe(302)\n+    expect(result.resolvedHeaders?.get('Location')).toBe(\n+      'https://example.com/redirected'\n+    )\n+  })\n+\n+  it('should handle middleware rewrite (internal)', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/test'),\n+      invokeMiddleware: async () => ({\n+        rewrite: new URL('https://example.com/rewritten'),\n+      }),\n+      pathnames: ['/rewritten'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/rewritten')\n+  })\n+\n+  it('should handle middleware external rewrite', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/test'),\n+      invokeMiddleware: async () => ({\n+        rewrite: new URL('https://external.com/api'),\n+      }),\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.externalRewrite).toBeDefined()\n+    expect(result.externalRewrite?.toString()).toBe('https://external.com/api')\n+  })\n+\n+  it('should apply requestHeaders from middleware', async () => {\n+    const newHeaders = new Headers({\n+      'x-custom-header': 'middleware-value',\n+    })\n+\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/test'),\n+      invokeMiddleware: async () => ({\n+        requestHeaders: newHeaders,\n+      }),\n+      pathnames: ['/test'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.resolvedHeaders?.get('x-custom-header')).toBe(\n+      'middleware-value'\n+    )\n+  })\n+})\n+\n+describe('resolveRoutes - beforeFiles', () => {\n+  it('should process beforeFiles routes after middleware', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/api/users'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/api/users$',\n+            destination: '/internal-api/users',\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/internal-api/users'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/internal-api/users')\n+  })\n+\n+  it('should handle redirect in beforeFiles', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/api/old'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/api/old$',\n+            destination: '/api/new',\n+            status: 308,\n+            headers: {\n+              Location: '/api/new',\n+            },\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.redirect).toBeDefined()\n+    expect(result.redirect?.status).toBe(308)\n+    expect(result.redirect?.url.pathname).toBe('/api/new')\n+  })\n+\n+  it('should handle external rewrite in beforeFiles', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/external'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/external$',\n+            destination: 'https://api.external.com/data',\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.externalRewrite).toBeDefined()\n+    expect(result.externalRewrite?.toString()).toBe(\n+      'https://api.external.com/data'\n+    )\n+  })\n+\n+  it('should chain rewrites in beforeFiles', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/step1'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/step1$',\n+            destination: '/step2',\n+          },\n+          {\n+            sourceRegex: '^/step2$',\n+            destination: '/step3',\n+          },\n+          {\n+            sourceRegex: '^/step3$',\n+            destination: '/final',\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/final'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/final')\n+  })\n+})\n+\n+describe('resolveRoutes - afterFiles', () => {\n+  it('should process afterFiles routes when no pathname matches', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/not-found'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [],\n+        afterFiles: [\n+          {\n+            sourceRegex: '^/not-found$',\n+            destination: '/404',\n+          },\n+        ],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/404'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/404')\n+  })\n+\n+  it('should handle redirect in afterFiles', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/moved'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [],\n+        afterFiles: [\n+          {\n+            sourceRegex: '^/moved$',\n+            destination: 'https://newdomain.com/page',\n+            status: 301,\n+            headers: {\n+              Location: 'https://newdomain.com/page',\n+            },\n+          },\n+        ],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.redirect).toBeDefined()\n+    expect(result.redirect?.status).toBe(301)\n+    expect(result.redirect?.url.toString()).toBe('https://newdomain.com/page')\n+  })\n+\n+  it('should handle external rewrite in afterFiles', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/proxy-after'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [],\n+        afterFiles: [\n+          {\n+            sourceRegex: '^/proxy-after$',\n+            destination: 'https://backend.com/api',\n+          },\n+        ],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.externalRewrite).toBeDefined()\n+    expect(result.externalRewrite?.toString()).toBe('https://backend.com/api')\n+  })\n+\n+  it('should check pathnames after each afterFiles rewrite', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/start'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [],\n+        afterFiles: [\n+          {\n+            sourceRegex: '^/start$',\n+            destination: '/middle',\n+          },\n+        ],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/middle'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/middle')\n+  })\n+})\n+\n+describe('resolveRoutes - fallback', () => {\n+  it('should process fallback routes when nothing else matches', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/unknown'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [\n+          {\n+            sourceRegex: '^/unknown$',\n+            destination: '/default',\n+          },\n+        ],\n+      },\n+      pathnames: ['/default'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/default')\n+  })\n+\n+  it('should handle redirect in fallback', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/catch-all'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [\n+          {\n+            sourceRegex: '^/catch-all$',\n+            destination: '/home',\n+            status: 302,\n+            headers: {\n+              Location: '/home',\n+            },\n+          },\n+        ],\n+      },\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.redirect).toBeDefined()\n+    expect(result.redirect?.status).toBe(302)\n+    expect(result.redirect?.url.pathname).toBe('/home')\n+  })\n+\n+  it('should handle external rewrite in fallback', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/fallback-external'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [\n+          {\n+            sourceRegex: '^/fallback-external$',\n+            destination: 'https://cdn.example.com/asset',\n+          },\n+        ],\n+      },\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.externalRewrite).toBeDefined()\n+    expect(result.externalRewrite?.toString()).toBe(\n+      'https://cdn.example.com/asset'\n+    )\n+  })\n+\n+  it('should chain rewrites in fallback', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/fallback-chain'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [\n+          {\n+            sourceRegex: '^/fallback-chain$',\n+            destination: '/fallback-intermediate',\n+          },\n+          {\n+            sourceRegex: '^/fallback-intermediate$',\n+            destination: '/fallback-final',\n+          },\n+        ],\n+      },\n+      pathnames: ['/fallback-final'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/fallback-final')\n+  })\n+})\n+\n+describe('resolveRoutes - routes without destination', () => {\n+  it('should process routes with headers only', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/headers-only'),\n+      routes: {\n+        beforeMiddleware: [\n+          {\n+            sourceRegex: '^/headers-only$',\n+            headers: {\n+              'x-custom-header': 'value',\n+            },\n+          },\n+        ],\n+        beforeFiles: [],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/headers-only'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.resolvedHeaders?.get('x-custom-header')).toBe('value')\n+    expect(result.matchedPathname).toBe('/headers-only')\n+  })\n+\n+  it('should process routes with status only', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/status-only'),\n+      routes: {\n+        beforeMiddleware: [\n+          {\n+            sourceRegex: '^/status-only$',\n+            status: 418,\n+          },\n+        ],\n+        beforeFiles: [],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/status-only'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.status).toBe(418)\n+    expect(result.matchedPathname).toBe('/status-only')\n+  })\n+\n+  it('should process multiple routes without destination in sequence', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/multi'),\n+      routes: {\n+        beforeMiddleware: [\n+          {\n+            sourceRegex: '^/multi$',\n+            headers: {\n+              'x-header-1': '1',\n+            },\n+          },\n+          {\n+            sourceRegex: '^/multi$',\n+            headers: {\n+              'x-header-2': '2',\n+            },\n+            status: 200,\n+          },\n+        ],\n+        beforeFiles: [],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/multi'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.resolvedHeaders?.get('x-header-1')).toBe('1')\n+    expect(result.resolvedHeaders?.get('x-header-2')).toBe('2')\n+    expect(result.status).toBe(200)\n+    expect(result.matchedPathname).toBe('/multi')\n+  })\n+})"
        },
        {
            "sha": "e5cfa58bba6d36e9940201bb341a93b674690368",
            "filename": "packages/next-routing/src/__tests__/rewrites.test.ts",
            "status": "added",
            "additions": 576,
            "deletions": 0,
            "changes": 576,
            "blob_url": "https://github.com/vercel/next.js/blob/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext-routing%2Fsrc%2F__tests__%2Frewrites.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext-routing%2Fsrc%2F__tests__%2Frewrites.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext-routing%2Fsrc%2F__tests__%2Frewrites.test.ts?ref=840643f2078cb3fbf5e0689d1e7948b711b9de62",
            "patch": "@@ -0,0 +1,576 @@\n+import { resolveRoutes } from '../resolve-routes'\n+import type { ResolveRoutesParams } from '../types'\n+\n+function createReadableStream(): ReadableStream {\n+  return new ReadableStream({\n+    start(controller) {\n+      controller.close()\n+    },\n+  })\n+}\n+\n+function createBaseParams(\n+  overrides: Partial<ResolveRoutesParams> = {}\n+): ResolveRoutesParams {\n+  return {\n+    url: new URL('https://example.com/'),\n+    buildId: 'BUILD_ID',\n+    basePath: '',\n+    requestBody: createReadableStream(),\n+    headers: new Headers(),\n+    pathnames: [],\n+    routes: {\n+      beforeMiddleware: [],\n+      beforeFiles: [],\n+      afterFiles: [],\n+      dynamicRoutes: [],\n+      onMatch: [],\n+      fallback: [],\n+    },\n+    invokeMiddleware: async () => ({}),\n+    ...overrides,\n+  }\n+}\n+\n+describe('Internal Rewrites', () => {\n+  it('should perform simple internal rewrite', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/blog'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/blog$',\n+            destination: '/posts',\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/posts'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/posts')\n+    expect(result.externalRewrite).toBeUndefined()\n+  })\n+\n+  it('should handle internal rewrite with query parameters', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/search?q=test'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/search$',\n+            destination: '/api/search?source=web',\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/api/search'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/api/search')\n+  })\n+\n+  it('should preserve original query params during internal rewrite', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/page?id=123'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/page$',\n+            destination: '/internal/page',\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/internal/page'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/internal/page')\n+  })\n+\n+  it('should handle regex captures in internal rewrite', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/users/john'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/users/([^/]+)$',\n+            destination: '/profile/$1',\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/profile/john'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/profile/john')\n+  })\n+\n+  it('should handle named captures in internal rewrite', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/products/electronics/123'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/products/(?<category>[^/]+)/(?<id>[^/]+)$',\n+            destination: '/api/product?category=$category&id=$id',\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/api/product'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/api/product')\n+  })\n+})\n+\n+describe('External Rewrites', () => {\n+  it('should handle external rewrite with http', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/external'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/external$',\n+            destination: 'http://external.com/api',\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.externalRewrite).toBeDefined()\n+    expect(result.externalRewrite?.toString()).toBe('http://external.com/api')\n+    expect(result.matchedPathname).toBeUndefined()\n+  })\n+\n+  it('should handle external rewrite with https', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/cdn'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/cdn$',\n+            destination: 'https://cdn.example.com/assets',\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.externalRewrite).toBeDefined()\n+    expect(result.externalRewrite?.toString()).toBe(\n+      'https://cdn.example.com/assets'\n+    )\n+  })\n+\n+  it('should handle external rewrite with captures', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/api/v1/users'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/api/v1/(.+)$',\n+            destination: 'https://backend.com/v1/$1',\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.externalRewrite).toBeDefined()\n+    expect(result.externalRewrite?.toString()).toBe(\n+      'https://backend.com/v1/users'\n+    )\n+  })\n+\n+  it('should detect external rewrite when origin changes', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/rewrite'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/rewrite$',\n+            destination: '/external',\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+    })\n+\n+    // Mock the applyDestination to return different origin\n+    const result = await resolveRoutes(params)\n+\n+    // Since we're rewriting to same origin, should match pathname\n+    expect(result.externalRewrite).toBeUndefined()\n+  })\n+\n+  it('should handle external rewrite in all route phases', async () => {\n+    // Test beforeMiddleware\n+    const beforeMiddlewareResult = await resolveRoutes(\n+      createBaseParams({\n+        url: new URL('https://example.com/test1'),\n+        routes: {\n+          beforeMiddleware: [\n+            {\n+              sourceRegex: '^/test1$',\n+              destination: 'https://ext.com/1',\n+            },\n+          ],\n+          beforeFiles: [],\n+          afterFiles: [],\n+          dynamicRoutes: [],\n+          onMatch: [],\n+          fallback: [],\n+        },\n+      })\n+    )\n+    expect(beforeMiddlewareResult.externalRewrite?.toString()).toBe(\n+      'https://ext.com/1'\n+    )\n+\n+    // Test beforeFiles\n+    const beforeFilesResult = await resolveRoutes(\n+      createBaseParams({\n+        url: new URL('https://example.com/test2'),\n+        routes: {\n+          beforeMiddleware: [],\n+          beforeFiles: [\n+            {\n+              sourceRegex: '^/test2$',\n+              destination: 'https://ext.com/2',\n+            },\n+          ],\n+          afterFiles: [],\n+          dynamicRoutes: [],\n+          onMatch: [],\n+          fallback: [],\n+        },\n+      })\n+    )\n+    expect(beforeFilesResult.externalRewrite?.toString()).toBe(\n+      'https://ext.com/2'\n+    )\n+\n+    // Test afterFiles\n+    const afterFilesResult = await resolveRoutes(\n+      createBaseParams({\n+        url: new URL('https://example.com/test3'),\n+        routes: {\n+          beforeMiddleware: [],\n+          beforeFiles: [],\n+          afterFiles: [\n+            {\n+              sourceRegex: '^/test3$',\n+              destination: 'https://ext.com/3',\n+            },\n+          ],\n+          dynamicRoutes: [],\n+          onMatch: [],\n+          fallback: [],\n+        },\n+      })\n+    )\n+    expect(afterFilesResult.externalRewrite?.toString()).toBe(\n+      'https://ext.com/3'\n+    )\n+\n+    // Test fallback\n+    const fallbackResult = await resolveRoutes(\n+      createBaseParams({\n+        url: new URL('https://example.com/test4'),\n+        routes: {\n+          beforeMiddleware: [],\n+          beforeFiles: [],\n+          afterFiles: [],\n+          dynamicRoutes: [],\n+          onMatch: [],\n+          fallback: [\n+            {\n+              sourceRegex: '^/test4$',\n+              destination: 'https://ext.com/4',\n+            },\n+          ],\n+        },\n+      })\n+    )\n+    expect(fallbackResult.externalRewrite?.toString()).toBe('https://ext.com/4')\n+  })\n+})\n+\n+describe('Chained Internal Rewrites', () => {\n+  it('should chain multiple rewrites across same phase', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/a'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/a$',\n+            destination: '/b',\n+          },\n+          {\n+            sourceRegex: '^/b$',\n+            destination: '/c',\n+          },\n+          {\n+            sourceRegex: '^/c$',\n+            destination: '/d',\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/d'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/d')\n+  })\n+\n+  it('should chain rewrites across different phases', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/start'),\n+      routes: {\n+        beforeMiddleware: [\n+          {\n+            sourceRegex: '^/start$',\n+            destination: '/step1',\n+          },\n+        ],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/step1$',\n+            destination: '/step2',\n+          },\n+        ],\n+        afterFiles: [\n+          {\n+            sourceRegex: '^/step2$',\n+            destination: '/final',\n+          },\n+        ],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/final'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/final')\n+  })\n+\n+  it('should complete chaining then check pathname match', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/path1'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/path1$',\n+            destination: '/path2',\n+          },\n+          {\n+            sourceRegex: '^/path2$',\n+            destination: '/path3',\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/path3'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    // Should chain through all routes, then match pathname\n+    expect(result.matchedPathname).toBe('/path3')\n+  })\n+\n+  it('should chain with regex captures preserved', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/user/alice/posts/123'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/user/([^/]+)/posts/([^/]+)$',\n+            destination: '/users/$1/content/$2',\n+          },\n+          {\n+            sourceRegex: '^/users/([^/]+)/content/([^/]+)$',\n+            destination: '/api/user-content?user=$1&post=$2',\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/api/user-content'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/api/user-content')\n+  })\n+\n+  it('should stop chaining on external rewrite', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/chain-start'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/chain-start$',\n+            destination: '/chain-middle',\n+          },\n+          {\n+            sourceRegex: '^/chain-middle$',\n+            destination: 'https://external.com/api',\n+          },\n+          {\n+            sourceRegex: '^/should-not-reach$',\n+            destination: '/never',\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.externalRewrite?.toString()).toBe('https://external.com/api')\n+    expect(result.matchedPathname).toBeUndefined()\n+  })\n+\n+  it('should stop chaining on redirect', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/redirect-chain'),\n+      routes: {\n+        beforeMiddleware: [],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/redirect-chain$',\n+            destination: '/redirect-target',\n+          },\n+          {\n+            sourceRegex: '^/redirect-target$',\n+            destination: '/final-destination',\n+            status: 301,\n+            headers: {\n+              Location: '/final-destination',\n+            },\n+          },\n+          {\n+            sourceRegex: '^/final-destination$',\n+            destination: '/should-not-reach',\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.redirect).toBeDefined()\n+    expect(result.redirect?.status).toBe(301)\n+    expect(result.redirect?.url.pathname).toBe('/final-destination')\n+    expect(result.matchedPathname).toBeUndefined()\n+  })\n+\n+  it('should handle complex chaining scenario', async () => {\n+    const params = createBaseParams({\n+      url: new URL('https://example.com/blog/2024/post-title'),\n+      routes: {\n+        beforeMiddleware: [\n+          {\n+            sourceRegex: '^/blog/([^/]+)/([^/]+)$',\n+            destination: '/posts/$1/$2',\n+          },\n+        ],\n+        beforeFiles: [\n+          {\n+            sourceRegex: '^/posts/([^/]+)/([^/]+)$',\n+            destination: '/api/posts?year=$1&slug=$2',\n+          },\n+        ],\n+        afterFiles: [],\n+        dynamicRoutes: [],\n+        onMatch: [],\n+        fallback: [],\n+      },\n+      pathnames: ['/api/posts'],\n+    })\n+\n+    const result = await resolveRoutes(params)\n+\n+    expect(result.matchedPathname).toBe('/api/posts')\n+  })\n+})"
        },
        {
            "sha": "177c0e0aac3af0210e84f271e9830a0ef4b5a7de",
            "filename": "packages/next-routing/src/destination.ts",
            "status": "added",
            "additions": 88,
            "deletions": 0,
            "changes": 88,
            "blob_url": "https://github.com/vercel/next.js/blob/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext-routing%2Fsrc%2Fdestination.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext-routing%2Fsrc%2Fdestination.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext-routing%2Fsrc%2Fdestination.ts?ref=840643f2078cb3fbf5e0689d1e7948b711b9de62",
            "patch": "@@ -0,0 +1,88 @@\n+/**\n+ * Replaces $1, $2, etc. and $name placeholders in the destination string\n+ * with matches from the regex and has conditions\n+ */\n+export function replaceDestination(\n+  destination: string,\n+  regexMatches: RegExpMatchArray | null,\n+  hasCaptures: Record<string, string>\n+): string {\n+  let result = destination\n+\n+  // Replace numbered captures from regex ($1, $2, etc.)\n+  if (regexMatches) {\n+    // Replace numbered groups (skip index 0 which is the full match)\n+    for (let i = 1; i < regexMatches.length; i++) {\n+      const value = regexMatches[i]\n+      if (value !== undefined) {\n+        result = result.replace(new RegExp(`\\\\$${i}`, 'g'), value)\n+      }\n+    }\n+\n+    // Replace named groups ($name)\n+    if (regexMatches.groups) {\n+      for (const [name, value] of Object.entries(regexMatches.groups)) {\n+        if (value !== undefined) {\n+          result = result.replace(new RegExp(`\\\\$${name}`, 'g'), value)\n+        }\n+      }\n+    }\n+  }\n+\n+  // Replace named captures from has conditions\n+  for (const [name, value] of Object.entries(hasCaptures)) {\n+    result = result.replace(new RegExp(`\\\\$${name}`, 'g'), value)\n+  }\n+\n+  return result\n+}\n+\n+/**\n+ * Checks if a destination is an external rewrite (starts with http/https)\n+ */\n+export function isExternalDestination(destination: string): boolean {\n+  return destination.startsWith('http://') || destination.startsWith('https://')\n+}\n+\n+/**\n+ * Applies a destination to a URL, updating the pathname or creating a new URL\n+ * if it's external\n+ */\n+export function applyDestination(currentUrl: URL, destination: string): URL {\n+  if (isExternalDestination(destination)) {\n+    return new URL(destination)\n+  }\n+\n+  // Create a new URL with the updated pathname\n+  const newUrl = new URL(currentUrl.toString())\n+\n+  // Handle destinations with query strings\n+  const [pathname, search] = destination.split('?')\n+  newUrl.pathname = pathname\n+\n+  if (search) {\n+    // Merge query parameters\n+    const newParams = new URLSearchParams(search)\n+    for (const [key, value] of newParams.entries()) {\n+      newUrl.searchParams.set(key, value)\n+    }\n+  }\n+\n+  return newUrl\n+}\n+\n+/**\n+ * Checks if a status code is a redirect status code\n+ */\n+export function isRedirectStatus(status: number | undefined): boolean {\n+  if (!status) return false\n+  return status >= 300 && status < 400\n+}\n+\n+/**\n+ * Checks if headers contain redirect headers (Location or Refresh)\n+ */\n+export function hasRedirectHeaders(headers: Record<string, string>): boolean {\n+  const lowerCaseKeys = Object.keys(headers).map((k) => k.toLowerCase())\n+  return lowerCaseKeys.includes('location') || lowerCaseKeys.includes('refresh')\n+}"
        },
        {
            "sha": "93862d9f97c81158412c764e8672672b618fb64b",
            "filename": "packages/next-routing/src/i18n.ts",
            "status": "added",
            "additions": 269,
            "deletions": 0,
            "changes": 269,
            "blob_url": "https://github.com/vercel/next.js/blob/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext-routing%2Fsrc%2Fi18n.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext-routing%2Fsrc%2Fi18n.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext-routing%2Fsrc%2Fi18n.ts?ref=840643f2078cb3fbf5e0689d1e7948b711b9de62",
            "patch": "@@ -0,0 +1,269 @@\n+/**\n+ * i18n utilities for locale detection and handling\n+ */\n+\n+export interface I18nDomain {\n+  defaultLocale: string\n+  domain: string\n+  http?: true\n+  locales?: string[]\n+}\n+\n+export interface I18nConfig {\n+  defaultLocale: string\n+  domains?: I18nDomain[]\n+  localeDetection?: false\n+  locales: string[]\n+}\n+\n+/**\n+ * Detects the domain locale based on hostname or detected locale\n+ */\n+export function detectDomainLocale(\n+  domains: I18nDomain[] | undefined,\n+  hostname: string | undefined,\n+  detectedLocale?: string\n+): I18nDomain | undefined {\n+  if (!domains) return undefined\n+\n+  const normalizedHostname = hostname?.toLowerCase()\n+  const normalizedLocale = detectedLocale?.toLowerCase()\n+\n+  for (const domain of domains) {\n+    // Remove port if present\n+    const domainHostname = domain.domain.split(':', 1)[0].toLowerCase()\n+\n+    if (\n+      normalizedHostname === domainHostname ||\n+      normalizedLocale === domain.defaultLocale.toLowerCase() ||\n+      domain.locales?.some(\n+        (locale) => locale.toLowerCase() === normalizedLocale\n+      )\n+    ) {\n+      return domain\n+    }\n+  }\n+\n+  return undefined\n+}\n+\n+/**\n+ * Normalizes a pathname by removing the locale prefix if present\n+ */\n+export function normalizeLocalePath(\n+  pathname: string,\n+  locales: string[]\n+): {\n+  pathname: string\n+  detectedLocale?: string\n+} {\n+  if (!locales || locales.length === 0) {\n+    return { pathname }\n+  }\n+\n+  // The first segment will be empty, because it has a leading `/`\n+  const segments = pathname.split('/', 2)\n+\n+  // If there's no second segment, there's no locale\n+  if (!segments[1]) {\n+    return { pathname }\n+  }\n+\n+  // The second segment will contain the locale part if any\n+  const segment = segments[1].toLowerCase()\n+\n+  // Create lowercase lookup for performance\n+  const lowercaseLocales = locales.map((locale) => locale.toLowerCase())\n+  const index = lowercaseLocales.indexOf(segment)\n+\n+  if (index < 0) {\n+    return { pathname }\n+  }\n+\n+  // Return the case-sensitive locale\n+  const detectedLocale = locales[index]\n+\n+  // Remove the `/${locale}` part of the pathname\n+  const newPathname = pathname.slice(detectedLocale.length + 1) || '/'\n+\n+  return { pathname: newPathname, detectedLocale }\n+}\n+\n+/**\n+ * Parses the Accept-Language header and returns the best matching locale\n+ */\n+export function getAcceptLanguageLocale(\n+  acceptLanguageHeader: string,\n+  locales: string[]\n+): string | undefined {\n+  if (!acceptLanguageHeader || !locales.length) {\n+    return undefined\n+  }\n+\n+  try {\n+    // Parse accept-language header\n+    const languages = acceptLanguageHeader\n+      .split(',')\n+      .map((lang) => {\n+        const parts = lang.trim().split(';')\n+        const locale = parts[0]\n+        let quality = 1\n+\n+        if (parts[1]) {\n+          const qMatch = parts[1].match(/q=([0-9.]+)/)\n+          if (qMatch && qMatch[1]) {\n+            quality = parseFloat(qMatch[1])\n+          }\n+        }\n+\n+        return { locale, quality }\n+      })\n+      .filter((lang) => lang.quality > 0)\n+      .sort((a, b) => b.quality - a.quality)\n+\n+    // Create lowercase lookup for locales\n+    const localeLookup = new Map<string, string>()\n+    for (const locale of locales) {\n+      localeLookup.set(locale.toLowerCase(), locale)\n+    }\n+\n+    // Try to find exact match first\n+    for (const { locale } of languages) {\n+      const normalized = locale.toLowerCase()\n+      if (localeLookup.has(normalized)) {\n+        return localeLookup.get(normalized)\n+      }\n+    }\n+\n+    // Try prefix matching (e.g., \"en-US\" matches \"en\")\n+    for (const { locale } of languages) {\n+      const prefix = locale.toLowerCase().split('-')[0]\n+      if (localeLookup.has(prefix)) {\n+        return localeLookup.get(prefix)\n+      }\n+\n+      // Also check if any configured locale starts with this prefix\n+      for (const [key, value] of localeLookup) {\n+        if (key.startsWith(prefix + '-')) {\n+          return value\n+        }\n+      }\n+    }\n+\n+    return undefined\n+  } catch (err) {\n+    return undefined\n+  }\n+}\n+\n+/**\n+ * Gets the locale from the NEXT_LOCALE cookie\n+ */\n+export function getCookieLocale(\n+  cookieHeader: string | undefined,\n+  locales: string[]\n+): string | undefined {\n+  if (!cookieHeader || !locales.length) {\n+    return undefined\n+  }\n+\n+  try {\n+    const cookies = cookieHeader.split(';').reduce(\n+      (acc, cookie) => {\n+        const [key, ...valueParts] = cookie.trim().split('=')\n+        if (key && valueParts.length > 0) {\n+          acc[key] = decodeURIComponent(valueParts.join('='))\n+        }\n+        return acc\n+      },\n+      {} as Record<string, string>\n+    )\n+\n+    const nextLocale = cookies.NEXT_LOCALE?.toLowerCase()\n+    if (!nextLocale) {\n+      return undefined\n+    }\n+\n+    return locales.find((locale) => locale.toLowerCase() === nextLocale)\n+  } catch (err) {\n+    return undefined\n+  }\n+}\n+\n+/**\n+ * Detects the appropriate locale based on path, domain, cookie, and accept-language\n+ */\n+export function detectLocale(params: {\n+  pathname: string\n+  hostname: string | undefined\n+  cookieHeader: string | undefined\n+  acceptLanguageHeader: string | undefined\n+  i18n: I18nConfig\n+}): {\n+  locale: string\n+  pathnameWithoutLocale: string\n+  localeInPath: boolean\n+} {\n+  const { pathname, hostname, cookieHeader, acceptLanguageHeader, i18n } =\n+    params\n+\n+  // 1. Check if locale is in the pathname\n+  const pathLocaleResult = normalizeLocalePath(pathname, i18n.locales)\n+  if (pathLocaleResult.detectedLocale) {\n+    return {\n+      locale: pathLocaleResult.detectedLocale,\n+      pathnameWithoutLocale: pathLocaleResult.pathname,\n+      localeInPath: true,\n+    }\n+  }\n+\n+  // If locale detection is disabled, use domain locale or default locale\n+  if (i18n.localeDetection === false) {\n+    const domainLocale = detectDomainLocale(i18n.domains, hostname)\n+    return {\n+      locale: domainLocale?.defaultLocale || i18n.defaultLocale,\n+      pathnameWithoutLocale: pathname,\n+      localeInPath: false,\n+    }\n+  }\n+\n+  // 2. Check cookie (priority over domain when locale detection is enabled)\n+  const cookieLocale = getCookieLocale(cookieHeader, i18n.locales)\n+  if (cookieLocale) {\n+    return {\n+      locale: cookieLocale,\n+      pathnameWithoutLocale: pathname,\n+      localeInPath: false,\n+    }\n+  }\n+\n+  // 3. Check accept-language header (priority over domain when locale detection is enabled)\n+  const acceptLocale = getAcceptLanguageLocale(\n+    acceptLanguageHeader || '',\n+    i18n.locales\n+  )\n+  if (acceptLocale) {\n+    return {\n+      locale: acceptLocale,\n+      pathnameWithoutLocale: pathname,\n+      localeInPath: false,\n+    }\n+  }\n+\n+  // 4. Check domain locale\n+  const domainLocale = detectDomainLocale(i18n.domains, hostname)\n+  if (domainLocale) {\n+    return {\n+      locale: domainLocale.defaultLocale,\n+      pathnameWithoutLocale: pathname,\n+      localeInPath: false,\n+    }\n+  }\n+\n+  // 5. Fallback to default locale\n+  return {\n+    locale: i18n.defaultLocale,\n+    pathnameWithoutLocale: pathname,\n+    localeInPath: false,\n+  }\n+}"
        },
        {
            "sha": "f8db6c5d2f17aae8f5790d7fde96d225771e26c1",
            "filename": "packages/next-routing/src/index.ts",
            "status": "added",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext-routing%2Fsrc%2Findex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext-routing%2Fsrc%2Findex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext-routing%2Fsrc%2Findex.ts?ref=840643f2078cb3fbf5e0689d1e7948b711b9de62",
            "patch": "@@ -0,0 +1,18 @@\n+export { resolveRoutes } from './resolve-routes'\n+export type {\n+  RouteHas,\n+  Route,\n+  MiddlewareContext,\n+  MiddlewareResult,\n+  ResolveRoutesParams,\n+  ResolveRoutesResult,\n+} from './types'\n+export type { I18nConfig, I18nDomain } from './i18n'\n+export {\n+  detectLocale,\n+  detectDomainLocale,\n+  normalizeLocalePath,\n+  getAcceptLanguageLocale,\n+  getCookieLocale,\n+} from './i18n'\n+export { responseToMiddlewareResult } from './middleware'"
        },
        {
            "sha": "90bd023c481c27530d82150a64a322d1811cf220",
            "filename": "packages/next-routing/src/matchers.ts",
            "status": "added",
            "additions": 140,
            "deletions": 0,
            "changes": 140,
            "blob_url": "https://github.com/vercel/next.js/blob/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext-routing%2Fsrc%2Fmatchers.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext-routing%2Fsrc%2Fmatchers.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext-routing%2Fsrc%2Fmatchers.ts?ref=840643f2078cb3fbf5e0689d1e7948b711b9de62",
            "patch": "@@ -0,0 +1,140 @@\n+import type { RouteHas } from './types'\n+\n+/**\n+ * Checks if a value matches the condition.\n+ * If conditionValue is undefined, returns the key's value if it exists.\n+ * If conditionValue is defined, it can be a regex string or a direct match.\n+ */\n+function matchesCondition(\n+  actualValue: string | undefined,\n+  conditionValue: string | undefined\n+): { matched: boolean; capturedValue?: string } {\n+  if (actualValue === undefined) {\n+    return { matched: false }\n+  }\n+\n+  // If no value condition is specified, match if key exists and return its value\n+  if (conditionValue === undefined) {\n+    return { matched: true, capturedValue: actualValue }\n+  }\n+\n+  // Try to match as regex first\n+  try {\n+    const regex = new RegExp(conditionValue)\n+    const match = actualValue.match(regex)\n+    if (match) {\n+      return { matched: true, capturedValue: match[0] }\n+    }\n+  } catch (e) {\n+    // Not a valid regex, fall through to direct match\n+  }\n+\n+  // Direct string match\n+  if (actualValue === conditionValue) {\n+    return { matched: true, capturedValue: actualValue }\n+  }\n+\n+  return { matched: false }\n+}\n+\n+/**\n+ * Extracts the value for a RouteHas condition from the request context\n+ */\n+function getConditionValue(\n+  condition: RouteHas,\n+  url: URL,\n+  headers: Headers\n+): string | undefined {\n+  switch (condition.type) {\n+    case 'header':\n+      return headers.get(condition.key) || undefined\n+    case 'cookie': {\n+      const cookieHeader = headers.get('cookie')\n+      if (!cookieHeader) return undefined\n+\n+      // Parse cookies\n+      const cookies = cookieHeader.split(';').reduce(\n+        (acc, cookie) => {\n+          const [key, ...valueParts] = cookie.trim().split('=')\n+          if (key) {\n+            acc[key] = valueParts.join('=')\n+          }\n+          return acc\n+        },\n+        {} as Record<string, string>\n+      )\n+\n+      return cookies[condition.key]\n+    }\n+    case 'query':\n+      return url.searchParams.get(condition.key) || undefined\n+    case 'host':\n+      return url.hostname\n+    default:\n+      return ''\n+  }\n+}\n+\n+/**\n+ * Normalizes a capture key to only contain a-zA-Z characters\n+ */\n+function normalizeCaptureKey(key: string): string {\n+  return key.replace(/[^a-zA-Z]/g, '')\n+}\n+\n+/**\n+ * Checks if all \"has\" conditions are satisfied\n+ */\n+export function checkHasConditions(\n+  has: RouteHas[] | undefined,\n+  url: URL,\n+  headers: Headers\n+): { matched: boolean; captures: Record<string, string> } {\n+  if (!has || has.length === 0) {\n+    return { matched: true, captures: {} }\n+  }\n+\n+  const captures: Record<string, string> = {}\n+\n+  for (const condition of has) {\n+    const actualValue = getConditionValue(condition, url, headers)\n+    const result = matchesCondition(actualValue, condition.value)\n+\n+    if (!result.matched) {\n+      return { matched: false, captures: {} }\n+    }\n+\n+    // Store captured value with normalized key name for named replacements\n+    if (result.capturedValue !== undefined && condition.type !== 'host') {\n+      const normalizedKey = normalizeCaptureKey(condition.key)\n+      captures[normalizedKey] = result.capturedValue\n+    }\n+  }\n+\n+  return { matched: true, captures }\n+}\n+\n+/**\n+ * Checks if all \"missing\" conditions are satisfied (i.e., none of them match)\n+ */\n+export function checkMissingConditions(\n+  missing: RouteHas[] | undefined,\n+  url: URL,\n+  headers: Headers\n+): boolean {\n+  if (!missing || missing.length === 0) {\n+    return true\n+  }\n+\n+  for (const condition of missing) {\n+    const actualValue = getConditionValue(condition, url, headers)\n+    const result = matchesCondition(actualValue, condition.value)\n+\n+    // If any missing condition matches, the check fails\n+    if (result.matched) {\n+      return false\n+    }\n+  }\n+\n+  return true\n+}"
        },
        {
            "sha": "5bd8ed361410ebeb897b7ab82aad5ad8745a714a",
            "filename": "packages/next-routing/src/middleware.ts",
            "status": "added",
            "additions": 232,
            "deletions": 0,
            "changes": 232,
            "blob_url": "https://github.com/vercel/next.js/blob/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext-routing%2Fsrc%2Fmiddleware.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext-routing%2Fsrc%2Fmiddleware.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext-routing%2Fsrc%2Fmiddleware.ts?ref=840643f2078cb3fbf5e0689d1e7948b711b9de62",
            "patch": "@@ -0,0 +1,232 @@\n+import type { MiddlewareResult } from './types'\n+\n+/**\n+ * Converts a middleware Response object to a MiddlewareResult.\n+ * This function processes middleware response headers and applies transformations\n+ * such as header overrides, rewrites, redirects, and refresh signals.\n+ *\n+ * @param response - The Response object returned from middleware\n+ * @param requestHeaders - The request Headers object to be mutated\n+ * @param url - The original request URL\n+ * @returns A MiddlewareResult object with processed headers and routing information\n+ */\n+export function responseToMiddlewareResult(\n+  response: Response,\n+  requestHeaders: Headers,\n+  url: URL\n+): MiddlewareResult {\n+  const result: MiddlewareResult = {}\n+\n+  // Convert response headers to a mutable record\n+  const middlewareHeaders: Record<string, string | string[] | undefined> = {}\n+  response.headers.forEach((value, key) => {\n+    if (middlewareHeaders[key]) {\n+      // If header already exists, convert to array\n+      const existing = middlewareHeaders[key]\n+      if (Array.isArray(existing)) {\n+        existing.push(value)\n+      } else {\n+        middlewareHeaders[key] = [existing as string, value]\n+      }\n+    } else {\n+      middlewareHeaders[key] = value\n+    }\n+  })\n+\n+  // Handle x-middleware-override-headers\n+  // This special header contains a comma-separated list of header keys that should be overridden\n+  if (middlewareHeaders['x-middleware-override-headers']) {\n+    const overriddenHeaders: Set<string> = new Set()\n+    let overrideHeaders: string | string[] =\n+      middlewareHeaders['x-middleware-override-headers']\n+\n+    if (typeof overrideHeaders === 'string') {\n+      overrideHeaders = overrideHeaders.split(',')\n+    }\n+\n+    for (const key of overrideHeaders) {\n+      overriddenHeaders.add(key.trim())\n+    }\n+    delete middlewareHeaders['x-middleware-override-headers']\n+\n+    // Delete headers not in the override list\n+    const headersToDelete: string[] = []\n+    requestHeaders.forEach((_, key) => {\n+      if (!overriddenHeaders.has(key)) {\n+        headersToDelete.push(key)\n+      }\n+    })\n+    for (const key of headersToDelete) {\n+      requestHeaders.delete(key)\n+    }\n+\n+    // Update or add headers from the override list\n+    for (const key of overriddenHeaders.keys()) {\n+      const valueKey = 'x-middleware-request-' + key\n+      const newValue = middlewareHeaders[valueKey]\n+\n+      if (newValue === undefined || newValue === null) {\n+        // If no value provided, delete the header\n+        requestHeaders.delete(key)\n+      } else if (Array.isArray(newValue)) {\n+        // Set the first value, then append the rest\n+        requestHeaders.set(key, newValue[0])\n+        for (let i = 1; i < newValue.length; i++) {\n+          requestHeaders.append(key, newValue[i])\n+        }\n+      } else {\n+        requestHeaders.set(key, newValue)\n+      }\n+      delete middlewareHeaders[valueKey]\n+    }\n+  }\n+\n+  // If there's no rewrite, next, or location header, set refresh\n+  if (\n+    !middlewareHeaders['x-middleware-rewrite'] &&\n+    !middlewareHeaders['x-middleware-next'] &&\n+    !middlewareHeaders['location']\n+  ) {\n+    middlewareHeaders['x-middleware-refresh'] = '1'\n+  }\n+  delete middlewareHeaders['x-middleware-next']\n+\n+  // Prepare response headers\n+  const responseHeaders = new Headers()\n+\n+  for (const [key, value] of Object.entries(middlewareHeaders)) {\n+    // Skip internal headers that shouldn't be in response\n+    if (\n+      [\n+        'content-length',\n+        'x-middleware-rewrite',\n+        'x-middleware-redirect',\n+        'x-middleware-refresh',\n+      ].includes(key)\n+    ) {\n+      continue\n+    }\n+\n+    // x-middleware-set-cookie is only for the request\n+    if (key === 'x-middleware-set-cookie') {\n+      if (value !== undefined) {\n+        if (Array.isArray(value)) {\n+          for (const v of value) {\n+            requestHeaders.append(key, v)\n+          }\n+        } else {\n+          requestHeaders.set(key, value)\n+        }\n+      }\n+      continue\n+    }\n+\n+    // Add to both response and request headers\n+    if (value !== undefined) {\n+      if (Array.isArray(value)) {\n+        for (const v of value) {\n+          responseHeaders.append(key, v)\n+          requestHeaders.append(key, v)\n+        }\n+      } else {\n+        responseHeaders.set(key, value)\n+        requestHeaders.set(key, value)\n+      }\n+    }\n+  }\n+\n+  result.responseHeaders = responseHeaders\n+  result.requestHeaders = requestHeaders\n+\n+  // Handle x-middleware-rewrite\n+  if (middlewareHeaders['x-middleware-rewrite']) {\n+    const value = middlewareHeaders['x-middleware-rewrite'] as string\n+    const destination = getRelativeURL(value, url.toString())\n+    responseHeaders.set('x-middleware-rewrite', destination)\n+\n+    try {\n+      const rewriteUrl = new URL(destination, url)\n+\n+      // If the URL has a different origin (external rewrite), mark it\n+      if (rewriteUrl.origin !== url.origin) {\n+        result.rewrite = rewriteUrl\n+        return result\n+      }\n+\n+      result.rewrite = rewriteUrl\n+    } catch {\n+      // If URL parsing fails, treat as relative path\n+      result.rewrite = new URL(destination, url)\n+    }\n+  }\n+\n+  // Handle location header (redirects)\n+  if (middlewareHeaders['location']) {\n+    const value = middlewareHeaders['location'] as string\n+\n+    // Only process Location header as a redirect if it has a proper redirect status\n+    const isRedirectStatus = allowedStatusCodes.has(response.status)\n+\n+    if (isRedirectStatus) {\n+      // Process as redirect: convert to relative URL\n+      const rel = getRelativeURL(value, url.toString())\n+      responseHeaders.set('location', rel)\n+\n+      try {\n+        const redirectUrl = new URL(rel, url)\n+        result.redirect = {\n+          url: redirectUrl,\n+          status: response.status,\n+        }\n+        return result\n+      } catch {\n+        // If URL parsing fails, treat as relative\n+        result.redirect = {\n+          url: new URL(rel, url),\n+          status: response.status,\n+        }\n+        return result\n+      }\n+    } else {\n+      // Not a redirect: just pass through the Location header\n+      responseHeaders.set('location', value)\n+      return result\n+    }\n+  }\n+\n+  // Handle x-middleware-refresh\n+  if (middlewareHeaders['x-middleware-refresh']) {\n+    result.bodySent = true\n+    return result\n+  }\n+\n+  return result\n+}\n+\n+/**\n+ * Helper function to convert an absolute URL to a relative URL.\n+ * If the URL has the same origin as the base, returns a relative path.\n+ * Otherwise, returns the full URL.\n+ */\n+function getRelativeURL(destination: string, base: string): string {\n+  try {\n+    const destUrl = new URL(destination, base)\n+    const baseUrl = new URL(base)\n+\n+    // If same origin, return relative path\n+    if (destUrl.origin === baseUrl.origin) {\n+      return destUrl.pathname + destUrl.search + destUrl.hash\n+    }\n+\n+    // Different origin, return full URL\n+    return destUrl.toString()\n+  } catch {\n+    // If parsing fails, return as-is\n+    return destination\n+  }\n+}\n+\n+/**\n+ * Set of allowed redirect status codes\n+ */\n+const allowedStatusCodes = new Set([301, 302, 303, 307, 308])"
        },
        {
            "sha": "05f4fd2454c7fe87e1c1f58001198897ff225a15",
            "filename": "packages/next-routing/src/next-data.ts",
            "status": "added",
            "additions": 59,
            "deletions": 0,
            "changes": 59,
            "blob_url": "https://github.com/vercel/next.js/blob/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext-routing%2Fsrc%2Fnext-data.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext-routing%2Fsrc%2Fnext-data.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext-routing%2Fsrc%2Fnext-data.ts?ref=840643f2078cb3fbf5e0689d1e7948b711b9de62",
            "patch": "@@ -0,0 +1,59 @@\n+/**\n+ * Normalizes Next.js data URL by removing /_next/data/{buildId}/ prefix and .json extension\n+ * ${basePath}/_next/data/$buildId/$path.json -> ${basePath}/$path\n+ */\n+export function normalizeNextDataUrl(\n+  url: URL,\n+  basePath: string,\n+  buildId: string\n+): URL {\n+  const newUrl = new URL(url.toString())\n+  let pathname = newUrl.pathname\n+\n+  // Pattern: ${basePath}/_next/data/${buildId}/${path}.json\n+  const dataPrefix = `${basePath}/_next/data/${buildId}/`\n+\n+  if (pathname.startsWith(dataPrefix)) {\n+    // Remove the /_next/data/${buildId}/ part, keeping what comes after\n+    let pathAfterData = pathname.slice(dataPrefix.length)\n+\n+    // Remove .json extension if present\n+    if (pathAfterData.endsWith('.json')) {\n+      pathAfterData = pathAfterData.slice(0, -5)\n+    }\n+\n+    pathname = basePath ? `${basePath}/${pathAfterData}` : `/${pathAfterData}`\n+    newUrl.pathname = pathname\n+  }\n+\n+  return newUrl\n+}\n+\n+/**\n+ * Denormalizes URL by adding /_next/data/{buildId}/ prefix and .json extension\n+ * ${basePath}/$path -> ${basePath}/_next/data/$buildId/$path.json\n+ */\n+export function denormalizeNextDataUrl(\n+  url: URL,\n+  basePath: string,\n+  buildId: string\n+): URL {\n+  const newUrl = new URL(url.toString())\n+  let pathname = newUrl.pathname\n+\n+  // Only denormalize if it's not already a data URL\n+  const dataPrefix = `${basePath}/_next/data/${buildId}/`\n+  if (!pathname.startsWith(dataPrefix)) {\n+    // Remove basePath if present\n+    let pathWithoutBase = pathname\n+    if (basePath && pathname.startsWith(basePath)) {\n+      pathWithoutBase = pathname.slice(basePath.length)\n+    }\n+\n+    // Add the /_next/data/${buildId}/ prefix and .json extension\n+    pathname = `${basePath}/_next/data/${buildId}${pathWithoutBase}.json`\n+    newUrl.pathname = pathname\n+  }\n+\n+  return newUrl\n+}"
        },
        {
            "sha": "0d33a9ac21acb7b3af8d87a46e7434a991131a8f",
            "filename": "packages/next-routing/src/resolve-routes.ts",
            "status": "added",
            "additions": 805,
            "deletions": 0,
            "changes": 805,
            "blob_url": "https://github.com/vercel/next.js/blob/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext-routing%2Fsrc%2Fresolve-routes.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext-routing%2Fsrc%2Fresolve-routes.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext-routing%2Fsrc%2Fresolve-routes.ts?ref=840643f2078cb3fbf5e0689d1e7948b711b9de62",
            "patch": "@@ -0,0 +1,805 @@\n+import type { Route, ResolveRoutesParams, ResolveRoutesResult } from './types'\n+import { checkHasConditions, checkMissingConditions } from './matchers'\n+import {\n+  replaceDestination,\n+  isExternalDestination,\n+  applyDestination,\n+  isRedirectStatus,\n+  hasRedirectHeaders,\n+} from './destination'\n+import { normalizeNextDataUrl, denormalizeNextDataUrl } from './next-data'\n+import { detectLocale, detectDomainLocale, normalizeLocalePath } from './i18n'\n+\n+/**\n+ * Attempts to match a route against the current URL and conditions\n+ */\n+function matchRoute(\n+  route: Route,\n+  url: URL,\n+  headers: Headers\n+): {\n+  matched: boolean\n+  destination?: string\n+  regexMatches?: RegExpMatchArray\n+  hasCaptures?: Record<string, string>\n+} {\n+  // Check if source regex matches the pathname\n+  const regex = new RegExp(route.sourceRegex)\n+  const regexMatches = url.pathname.match(regex)\n+\n+  if (!regexMatches) {\n+    return { matched: false }\n+  }\n+\n+  // Check has conditions\n+  const hasResult = checkHasConditions(route.has, url, headers)\n+  if (!hasResult.matched) {\n+    return { matched: false }\n+  }\n+\n+  // Check missing conditions\n+  const missingMatched = checkMissingConditions(route.missing, url, headers)\n+  if (!missingMatched) {\n+    return { matched: false }\n+  }\n+\n+  // Replace placeholders in destination\n+  const destination = route.destination\n+    ? replaceDestination(route.destination, regexMatches, hasResult.captures)\n+    : undefined\n+\n+  return {\n+    matched: true,\n+    destination,\n+    regexMatches,\n+    hasCaptures: hasResult.captures,\n+  }\n+}\n+\n+/**\n+ * Processes a list of routes and updates the URL if any match\n+ */\n+function processRoutes(\n+  routes: Route[],\n+  url: URL,\n+  headers: Headers,\n+  initialOrigin: string\n+): {\n+  url: URL\n+  externalRewrite?: URL\n+  redirect?: {\n+    url: URL\n+    status: number\n+  }\n+  stopped: boolean\n+  status?: number\n+} {\n+  let currentUrl = url\n+  let currentStatus: number | undefined\n+\n+  for (const route of routes) {\n+    const match = matchRoute(route, currentUrl, headers)\n+\n+    if (match.matched) {\n+      if (route.headers) {\n+        for (const [key, value] of Object.entries(route.headers)) {\n+          headers.set(key, value)\n+        }\n+      }\n+\n+      if (route.status) {\n+        currentStatus = route.status\n+      }\n+\n+      if (match.destination) {\n+        // Check if route has redirect status and Location/Refresh header\n+        if (\n+          isRedirectStatus(route.status) &&\n+          route.headers &&\n+          hasRedirectHeaders(route.headers)\n+        ) {\n+          const redirectUrl = isExternalDestination(match.destination)\n+            ? new URL(match.destination)\n+            : applyDestination(currentUrl, match.destination)\n+\n+          return {\n+            url: currentUrl,\n+            redirect: {\n+              url: redirectUrl,\n+              status: route.status!,\n+            },\n+            stopped: true,\n+            status: currentStatus,\n+          }\n+        }\n+\n+        // Check if it's an external rewrite\n+        if (isExternalDestination(match.destination)) {\n+          return {\n+            url: currentUrl,\n+            externalRewrite: new URL(match.destination),\n+            stopped: true,\n+            status: currentStatus,\n+          }\n+        }\n+\n+        // Apply the destination to update the URL\n+        currentUrl = applyDestination(currentUrl, match.destination)\n+\n+        // Check if origin changed (external rewrite)\n+        if (currentUrl.origin !== initialOrigin) {\n+          return {\n+            url: currentUrl,\n+            externalRewrite: currentUrl,\n+            stopped: true,\n+            status: currentStatus,\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  return { url: currentUrl, stopped: false, status: currentStatus }\n+}\n+\n+/**\n+ * Checks if the current pathname matches any of the provided pathnames\n+ */\n+function matchesPathname(\n+  pathname: string,\n+  pathnames: string[]\n+): string | undefined {\n+  for (const candidate of pathnames) {\n+    if (pathname === candidate) {\n+      return candidate\n+    }\n+  }\n+  return undefined\n+}\n+\n+/**\n+ * Matches dynamic routes and extracts route parameters\n+ */\n+function matchDynamicRoute(\n+  pathname: string,\n+  route: Route\n+): { matched: boolean; params?: Record<string, string> } {\n+  const regex = new RegExp(route.sourceRegex)\n+  const match = pathname.match(regex)\n+\n+  if (!match) {\n+    return { matched: false }\n+  }\n+\n+  const params: Record<string, string> = {}\n+\n+  // Add numbered matches\n+  for (let i = 1; i < match.length; i++) {\n+    if (match[i] !== undefined) {\n+      params[String(i)] = match[i]\n+    }\n+  }\n+\n+  // Add named matches\n+  if (match.groups) {\n+    Object.assign(params, match.groups)\n+  }\n+\n+  return { matched: true, params }\n+}\n+\n+/**\n+ * Applies headers from onMatch routes\n+ */\n+function applyOnMatchHeaders(routes: Route[], headers: Headers): Headers {\n+  const newHeaders = new Headers(headers)\n+\n+  for (const route of routes) {\n+    if (route.headers) {\n+      for (const [key, value] of Object.entries(route.headers)) {\n+        newHeaders.set(key, value)\n+      }\n+    }\n+  }\n+\n+  return newHeaders\n+}\n+\n+/**\n+ * Checks dynamic routes for a match and returns result if found\n+ */\n+function checkDynamicRoutes(\n+  dynamicRoutes: Route[],\n+  url: URL,\n+  pathnames: string[],\n+  headers: Headers,\n+  onMatchRoutes: Route[],\n+  basePath: string,\n+  buildId: string,\n+  shouldNormalizeNextData?: boolean,\n+  isDataUrl?: boolean\n+): {\n+  matched: boolean\n+  result?: ResolveRoutesResult\n+  resetUrl?: URL\n+} {\n+  // Denormalize before checking dynamic routes if this was originally a data URL\n+  let checkUrl = url\n+  if (isDataUrl && shouldNormalizeNextData) {\n+    checkUrl = denormalizeNextDataUrl(url, basePath, buildId)\n+  }\n+\n+  for (const route of dynamicRoutes) {\n+    const match = matchDynamicRoute(checkUrl.pathname, route)\n+\n+    if (match.matched) {\n+      // Check has/missing conditions\n+      const hasResult = checkHasConditions(route.has, checkUrl, headers)\n+      const missingMatched = checkMissingConditions(\n+        route.missing,\n+        checkUrl,\n+        headers\n+      )\n+\n+      if (hasResult.matched && missingMatched) {\n+        // Check if the current pathname is in the provided pathnames list\n+        const matchedPath = matchesPathname(checkUrl.pathname, pathnames)\n+        if (matchedPath) {\n+          const finalHeaders = applyOnMatchHeaders(onMatchRoutes, headers)\n+          return {\n+            matched: true,\n+            result: {\n+              matchedPathname: matchedPath,\n+              routeMatches: match.params,\n+              resolvedHeaders: finalHeaders,\n+            },\n+            resetUrl: checkUrl, // Return the denormalized URL to reset to\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  return { matched: false }\n+}\n+\n+export async function resolveRoutes(\n+  params: ResolveRoutesParams\n+): Promise<ResolveRoutesResult> {\n+  const {\n+    url: initialUrl,\n+    basePath,\n+    requestBody,\n+    headers: initialHeaders,\n+    pathnames,\n+    routes,\n+    invokeMiddleware,\n+    buildId,\n+    i18n,\n+  } = params\n+\n+  const { shouldNormalizeNextData } = routes\n+\n+  let currentUrl = new URL(initialUrl.toString())\n+  let currentHeaders = new Headers(initialHeaders)\n+  let currentStatus: number | undefined\n+  const initialOrigin = initialUrl.origin\n+\n+  // Check if the original URL is a data URL and normalize if so\n+  let isDataUrl = false\n+  if (shouldNormalizeNextData) {\n+    const dataPrefix = `${basePath}/_next/data/${buildId}/`\n+    isDataUrl = initialUrl.pathname.startsWith(dataPrefix)\n+\n+    if (isDataUrl) {\n+      currentUrl = normalizeNextDataUrl(currentUrl, basePath, buildId)\n+    }\n+  }\n+\n+  // Handle i18n locale detection and redirects\n+  if (i18n && !isDataUrl) {\n+    const pathname = currentUrl.pathname.startsWith(basePath)\n+      ? currentUrl.pathname.slice(basePath.length) || '/'\n+      : currentUrl.pathname\n+\n+    // Skip locale handling for _next routes\n+    if (!pathname.startsWith('/_next/')) {\n+      const hostname = currentUrl.hostname\n+      const cookieHeader = currentHeaders.get('cookie') || undefined\n+      const acceptLanguageHeader =\n+        currentHeaders.get('accept-language') || undefined\n+\n+      // Detect locale from path first\n+      const pathLocaleResult = normalizeLocalePath(pathname, i18n.locales)\n+      const localeInPath = !!pathLocaleResult.detectedLocale\n+\n+      // Detect domain locale\n+      const domainLocale = detectDomainLocale(i18n.domains, hostname)\n+      const defaultLocale = domainLocale?.defaultLocale || i18n.defaultLocale\n+\n+      // Determine target locale if locale detection is enabled\n+      let targetLocale = pathLocaleResult.detectedLocale || defaultLocale\n+\n+      if (i18n.localeDetection !== false && !localeInPath) {\n+        // Full locale detection when no locale in path\n+        const detectedResult = detectLocale({\n+          pathname,\n+          hostname,\n+          cookieHeader,\n+          acceptLanguageHeader,\n+          i18n,\n+        })\n+\n+        targetLocale = detectedResult.locale\n+\n+        // Check if we need to redirect based on domain or locale mismatch\n+        if (targetLocale !== defaultLocale) {\n+          const targetDomain = detectDomainLocale(\n+            i18n.domains,\n+            undefined,\n+            targetLocale\n+          )\n+\n+          // Redirect to different domain if target locale has a different configured domain\n+          if (targetDomain && targetDomain.domain !== hostname) {\n+            const scheme = targetDomain.http ? 'http' : 'https'\n+            const localePrefix =\n+              targetLocale === targetDomain.defaultLocale\n+                ? ''\n+                : `/${targetLocale}`\n+            const redirectUrl = new URL(\n+              `${scheme}://${targetDomain.domain}${basePath}${localePrefix}${pathname}${currentUrl.search}`\n+            )\n+\n+            return {\n+              redirect: {\n+                url: redirectUrl,\n+                status: 307,\n+              },\n+              resolvedHeaders: currentHeaders,\n+            }\n+          }\n+\n+          // If no dedicated domain for target locale, or we're already on the right domain,\n+          // redirect to add locale prefix on same domain\n+          if (\n+            !targetDomain ||\n+            (targetDomain && targetDomain.domain === hostname)\n+          ) {\n+            const redirectUrl = new URL(currentUrl.toString())\n+            redirectUrl.pathname = `${basePath}/${targetLocale}${pathname}`\n+\n+            return {\n+              redirect: {\n+                url: redirectUrl,\n+                status: 307,\n+              },\n+              resolvedHeaders: currentHeaders,\n+            }\n+          }\n+        }\n+      }\n+\n+      // Prefix the locale internally for route resolution (without redirecting)\n+      if (!localeInPath) {\n+        const localeToPrefix =\n+          targetLocale || domainLocale?.defaultLocale || i18n.defaultLocale\n+        currentUrl.pathname = `${basePath}/${localeToPrefix}${pathname}`\n+      }\n+    }\n+  }\n+\n+  // Process beforeMiddleware routes\n+  const beforeMiddlewareResult = processRoutes(\n+    routes.beforeMiddleware,\n+    currentUrl,\n+    currentHeaders,\n+    initialOrigin\n+  )\n+\n+  if (beforeMiddlewareResult.status) {\n+    currentStatus = beforeMiddlewareResult.status\n+  }\n+\n+  if (beforeMiddlewareResult.redirect) {\n+    return {\n+      redirect: beforeMiddlewareResult.redirect,\n+      resolvedHeaders: currentHeaders,\n+      status: currentStatus,\n+    }\n+  }\n+\n+  if (beforeMiddlewareResult.externalRewrite) {\n+    return {\n+      externalRewrite: beforeMiddlewareResult.externalRewrite,\n+      resolvedHeaders: currentHeaders,\n+      status: currentStatus,\n+    }\n+  }\n+\n+  currentUrl = beforeMiddlewareResult.url\n+\n+  // Denormalize before invoking middleware if this was originally a data URL\n+  if (isDataUrl && shouldNormalizeNextData) {\n+    currentUrl = denormalizeNextDataUrl(currentUrl, basePath, buildId)\n+  }\n+\n+  // Invoke middleware\n+  const middlewareResult = await invokeMiddleware({\n+    url: currentUrl,\n+    headers: currentHeaders,\n+    requestBody,\n+  })\n+\n+  // Check if middleware sent the response body\n+  if (middlewareResult.bodySent) {\n+    return { middlewareResponded: true }\n+  }\n+\n+  // Apply request headers from middleware\n+  if (middlewareResult.requestHeaders) {\n+    currentHeaders = new Headers(middlewareResult.requestHeaders)\n+  }\n+\n+  // Handle middleware redirect\n+  if (middlewareResult.redirect) {\n+    currentHeaders.set('Location', middlewareResult.redirect.url.toString())\n+    return {\n+      resolvedHeaders: currentHeaders,\n+      status: middlewareResult.redirect.status,\n+    }\n+  }\n+\n+  // Handle middleware rewrite\n+  if (middlewareResult.rewrite) {\n+    currentUrl = middlewareResult.rewrite\n+\n+    // Check if it's an external rewrite\n+    if (currentUrl.origin !== initialOrigin) {\n+      return {\n+        externalRewrite: currentUrl,\n+        resolvedHeaders: currentHeaders,\n+        status: currentStatus,\n+      }\n+    }\n+  }\n+\n+  // Normalize again after middleware if this was originally a data URL\n+  if (isDataUrl && shouldNormalizeNextData) {\n+    currentUrl = normalizeNextDataUrl(currentUrl, basePath, buildId)\n+  }\n+\n+  // Process beforeFiles routes\n+  const beforeFilesResult = processRoutes(\n+    routes.beforeFiles,\n+    currentUrl,\n+    currentHeaders,\n+    initialOrigin\n+  )\n+\n+  if (beforeFilesResult.status) {\n+    currentStatus = beforeFilesResult.status\n+  }\n+\n+  if (beforeFilesResult.redirect) {\n+    return {\n+      redirect: beforeFilesResult.redirect,\n+      resolvedHeaders: currentHeaders,\n+      status: currentStatus,\n+    }\n+  }\n+\n+  if (beforeFilesResult.externalRewrite) {\n+    return {\n+      externalRewrite: beforeFilesResult.externalRewrite,\n+      resolvedHeaders: currentHeaders,\n+      status: currentStatus,\n+    }\n+  }\n+\n+  currentUrl = beforeFilesResult.url\n+\n+  // Denormalize before checking pathnames if this was originally a data URL\n+  if (isDataUrl && shouldNormalizeNextData) {\n+    currentUrl = denormalizeNextDataUrl(currentUrl, basePath, buildId)\n+  }\n+\n+  // Check if pathname matches any provided pathnames (pathnames are in denormalized form)\n+  let matchedPath = matchesPathname(currentUrl.pathname, pathnames)\n+  if (matchedPath) {\n+    // Check if any dynamic route also matches to extract parameters\n+    for (const route of routes.dynamicRoutes) {\n+      const match = matchDynamicRoute(currentUrl.pathname, route)\n+\n+      if (match.matched) {\n+        // Check has/missing conditions\n+        const hasResult = checkHasConditions(\n+          route.has,\n+          currentUrl,\n+          currentHeaders\n+        )\n+        const missingMatched = checkMissingConditions(\n+          route.missing,\n+          currentUrl,\n+          currentHeaders\n+        )\n+\n+        if (hasResult.matched && missingMatched) {\n+          const finalHeaders = applyOnMatchHeaders(\n+            routes.onMatch,\n+            currentHeaders\n+          )\n+          return {\n+            matchedPathname: matchedPath,\n+            routeMatches: match.params,\n+            resolvedHeaders: finalHeaders,\n+            status: currentStatus,\n+          }\n+        }\n+      }\n+    }\n+\n+    // No dynamic route matched, return without route matches\n+    const finalHeaders = applyOnMatchHeaders(routes.onMatch, currentHeaders)\n+    return {\n+      matchedPathname: matchedPath,\n+      resolvedHeaders: finalHeaders,\n+      status: currentStatus,\n+    }\n+  }\n+\n+  // Normalize again before processing afterFiles if this was originally a data URL\n+  if (isDataUrl && shouldNormalizeNextData) {\n+    currentUrl = normalizeNextDataUrl(currentUrl, basePath, buildId)\n+  }\n+\n+  // Process afterFiles routes\n+  for (const route of routes.afterFiles) {\n+    const match = matchRoute(route, currentUrl, currentHeaders)\n+\n+    if (match.matched) {\n+      if (route.headers) {\n+        for (const [key, value] of Object.entries(route.headers)) {\n+          currentHeaders.set(key, value)\n+        }\n+      }\n+\n+      if (route.status) {\n+        currentStatus = route.status\n+      }\n+\n+      if (match.destination) {\n+        // Check if route has redirect status and Location/Refresh header\n+        if (\n+          isRedirectStatus(route.status) &&\n+          route.headers &&\n+          hasRedirectHeaders(route.headers)\n+        ) {\n+          const redirectUrl = isExternalDestination(match.destination)\n+            ? new URL(match.destination)\n+            : applyDestination(currentUrl, match.destination)\n+\n+          return {\n+            redirect: {\n+              url: redirectUrl,\n+              status: route.status!,\n+            },\n+            resolvedHeaders: currentHeaders,\n+            status: currentStatus,\n+          }\n+        }\n+\n+        // Check if it's an external rewrite\n+        if (isExternalDestination(match.destination)) {\n+          return {\n+            externalRewrite: new URL(match.destination),\n+            resolvedHeaders: currentHeaders,\n+            status: currentStatus,\n+          }\n+        }\n+\n+        // Apply destination\n+        currentUrl = applyDestination(currentUrl, match.destination)\n+\n+        // Check if origin changed\n+        if (currentUrl.origin !== initialOrigin) {\n+          return {\n+            externalRewrite: currentUrl,\n+            resolvedHeaders: currentHeaders,\n+            status: currentStatus,\n+          }\n+        }\n+\n+        // First check dynamic routes to extract route matches\n+        const dynamicResult = checkDynamicRoutes(\n+          routes.dynamicRoutes,\n+          currentUrl,\n+          pathnames,\n+          currentHeaders,\n+          routes.onMatch,\n+          basePath,\n+          buildId,\n+          shouldNormalizeNextData,\n+          isDataUrl\n+        )\n+        if (dynamicResult.matched && dynamicResult.result) {\n+          // Reset URL to the denormalized version if it matched\n+          if (dynamicResult.resetUrl) {\n+            currentUrl = dynamicResult.resetUrl\n+          }\n+          return { ...dynamicResult.result, status: currentStatus }\n+        }\n+\n+        // If no dynamic route matched, check static pathname\n+        // Denormalize before checking if this was originally a data URL\n+        let pathnameCheckUrl = currentUrl\n+        if (isDataUrl && shouldNormalizeNextData) {\n+          pathnameCheckUrl = denormalizeNextDataUrl(\n+            currentUrl,\n+            basePath,\n+            buildId\n+          )\n+        }\n+\n+        matchedPath = matchesPathname(pathnameCheckUrl.pathname, pathnames)\n+        if (matchedPath) {\n+          const finalHeaders = applyOnMatchHeaders(\n+            routes.onMatch,\n+            currentHeaders\n+          )\n+          return {\n+            matchedPathname: matchedPath,\n+            resolvedHeaders: finalHeaders,\n+            status: currentStatus,\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  // Check dynamic routes\n+  for (const route of routes.dynamicRoutes) {\n+    const match = matchDynamicRoute(currentUrl.pathname, route)\n+\n+    if (match.matched) {\n+      // Check has/missing conditions\n+      const hasResult = checkHasConditions(\n+        route.has,\n+        currentUrl,\n+        currentHeaders\n+      )\n+      const missingMatched = checkMissingConditions(\n+        route.missing,\n+        currentUrl,\n+        currentHeaders\n+      )\n+\n+      if (hasResult.matched && missingMatched) {\n+        // Check if the current pathname is in the provided pathnames list\n+        matchedPath = matchesPathname(currentUrl.pathname, pathnames)\n+        if (matchedPath) {\n+          const finalHeaders = applyOnMatchHeaders(\n+            routes.onMatch,\n+            currentHeaders\n+          )\n+          return {\n+            matchedPathname: matchedPath,\n+            routeMatches: match.params,\n+            resolvedHeaders: finalHeaders,\n+            status: currentStatus,\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  // Process fallback routes\n+  for (const route of routes.fallback) {\n+    const match = matchRoute(route, currentUrl, currentHeaders)\n+\n+    if (match.matched) {\n+      if (route.headers) {\n+        for (const [key, value] of Object.entries(route.headers)) {\n+          currentHeaders.set(key, value)\n+        }\n+      }\n+\n+      if (route.status) {\n+        currentStatus = route.status\n+      }\n+\n+      if (match.destination) {\n+        // Check if route has redirect status and Location/Refresh header\n+        if (\n+          isRedirectStatus(route.status) &&\n+          route.headers &&\n+          hasRedirectHeaders(route.headers)\n+        ) {\n+          const redirectUrl = isExternalDestination(match.destination)\n+            ? new URL(match.destination)\n+            : applyDestination(currentUrl, match.destination)\n+\n+          return {\n+            redirect: {\n+              url: redirectUrl,\n+              status: route.status!,\n+            },\n+            resolvedHeaders: currentHeaders,\n+            status: currentStatus,\n+          }\n+        }\n+\n+        // Check if it's an external rewrite\n+        if (isExternalDestination(match.destination)) {\n+          return {\n+            externalRewrite: new URL(match.destination),\n+            resolvedHeaders: currentHeaders,\n+            status: currentStatus,\n+          }\n+        }\n+\n+        // Apply destination\n+        currentUrl = applyDestination(currentUrl, match.destination)\n+\n+        // Check if origin changed\n+        if (currentUrl.origin !== initialOrigin) {\n+          return {\n+            externalRewrite: currentUrl,\n+            resolvedHeaders: currentHeaders,\n+            status: currentStatus,\n+          }\n+        }\n+\n+        // First check dynamic routes to extract route matches\n+        const dynamicResult = checkDynamicRoutes(\n+          routes.dynamicRoutes,\n+          currentUrl,\n+          pathnames,\n+          currentHeaders,\n+          routes.onMatch,\n+          basePath,\n+          buildId,\n+          shouldNormalizeNextData,\n+          isDataUrl\n+        )\n+        if (dynamicResult.matched && dynamicResult.result) {\n+          // Reset URL to the denormalized version if it matched\n+          if (dynamicResult.resetUrl) {\n+            currentUrl = dynamicResult.resetUrl\n+          }\n+          return { ...dynamicResult.result, status: currentStatus }\n+        }\n+\n+        // If no dynamic route matched, check static pathname\n+        // Denormalize before checking if this was originally a data URL\n+        let pathnameCheckUrl = currentUrl\n+        if (isDataUrl && shouldNormalizeNextData) {\n+          pathnameCheckUrl = denormalizeNextDataUrl(\n+            currentUrl,\n+            basePath,\n+            buildId\n+          )\n+        }\n+\n+        matchedPath = matchesPathname(pathnameCheckUrl.pathname, pathnames)\n+        if (matchedPath) {\n+          const finalHeaders = applyOnMatchHeaders(\n+            routes.onMatch,\n+            currentHeaders\n+          )\n+          return {\n+            matchedPathname: matchedPath,\n+            resolvedHeaders: finalHeaders,\n+            status: currentStatus,\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  // No match found\n+  return {\n+    resolvedHeaders: currentHeaders,\n+    status: currentStatus,\n+  }\n+}"
        },
        {
            "sha": "709f2971eb0bcf478bc94111a68003c19410d806",
            "filename": "packages/next-routing/src/types.ts",
            "status": "added",
            "additions": 83,
            "deletions": 0,
            "changes": 83,
            "blob_url": "https://github.com/vercel/next.js/blob/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext-routing%2Fsrc%2Ftypes.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext-routing%2Fsrc%2Ftypes.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext-routing%2Fsrc%2Ftypes.ts?ref=840643f2078cb3fbf5e0689d1e7948b711b9de62",
            "patch": "@@ -0,0 +1,83 @@\n+export type RouteHas =\n+  | {\n+      type: 'header' | 'cookie' | 'query'\n+      key: string\n+      value?: string\n+    }\n+  | {\n+      type: 'host'\n+      key?: undefined\n+      value: string\n+    }\n+\n+export type Route = {\n+  // regex as string can have named or un-named matches\n+  sourceRegex: string\n+  // destination can have matches to replace in destination\n+  // keyed by $1 for un-named and $name for named\n+  destination?: string\n+  headers?: Record<string, string>\n+  has?: RouteHas[]\n+  missing?: RouteHas[]\n+  status?: number\n+}\n+\n+export type MiddlewareContext = {\n+  url: URL\n+  headers: Headers\n+  requestBody: ReadableStream\n+}\n+\n+export type MiddlewareResult = {\n+  bodySent?: boolean\n+  requestHeaders?: Headers\n+  responseHeaders?: Headers\n+  redirect?: {\n+    url: URL\n+    status: number\n+  }\n+  rewrite?: URL\n+}\n+\n+export type ResolveRoutesParams = {\n+  url: URL\n+  buildId: string\n+  basePath: string\n+  requestBody: ReadableStream\n+  headers: Headers\n+  pathnames: string[]\n+  i18n?: {\n+    defaultLocale: string\n+    domains?: Array<{\n+      defaultLocale: string\n+      domain: string\n+      http?: true\n+      locales?: string[]\n+    }>\n+    localeDetection?: false\n+    locales: string[]\n+  }\n+  routes: {\n+    beforeMiddleware: Array<Route>\n+    beforeFiles: Array<Route>\n+    afterFiles: Array<Route>\n+    dynamicRoutes: Array<Route>\n+    onMatch: Array<Route>\n+    fallback: Array<Route>\n+    shouldNormalizeNextData?: boolean\n+  }\n+  invokeMiddleware: (ctx: MiddlewareContext) => Promise<MiddlewareResult>\n+}\n+\n+export type ResolveRoutesResult = {\n+  middlewareResponded?: boolean\n+  externalRewrite?: URL\n+  redirect?: {\n+    url: URL\n+    status: number\n+  }\n+  matchedPathname?: string\n+  resolvedHeaders?: Headers\n+  status?: number\n+  routeMatches?: Record<string, string>\n+}"
        },
        {
            "sha": "18523d96783da02edfb0fbf9a8393d93bca131ff",
            "filename": "packages/next-routing/tsconfig.json",
            "status": "added",
            "additions": 13,
            "deletions": 0,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext-routing%2Ftsconfig.json",
            "raw_url": "https://github.com/vercel/next.js/raw/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext-routing%2Ftsconfig.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext-routing%2Ftsconfig.json?ref=840643f2078cb3fbf5e0689d1e7948b711b9de62",
            "patch": "@@ -0,0 +1,13 @@\n+{\n+  \"compilerOptions\": {\n+    \"target\": \"es2022\",\n+    \"moduleResolution\": \"node\",\n+    \"strict\": true,\n+    \"resolveJsonModule\": true,\n+    \"esModuleInterop\": true,\n+    \"skipLibCheck\": false,\n+    \"lib\": [\"es2022\", \"dom\"]\n+  },\n+  \"include\": [\"src/**/*.ts\"],\n+  \"exclude\": [\"node_modules\", \"dist\"]\n+}"
        },
        {
            "sha": "bd795fff9849e893d7b5e90e05e2ff5cd3818322",
            "filename": "packages/next/src/build/adapter/build-complete.ts",
            "status": "modified",
            "additions": 90,
            "deletions": 65,
            "changes": 155,
            "blob_url": "https://github.com/vercel/next.js/blob/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext%2Fsrc%2Fbuild%2Fadapter%2Fbuild-complete.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/840643f2078cb3fbf5e0689d1e7948b711b9de62/packages%2Fnext%2Fsrc%2Fbuild%2Fadapter%2Fbuild-complete.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fadapter%2Fbuild-complete.ts?ref=840643f2078cb3fbf5e0689d1e7948b711b9de62",
            "patch": "@@ -33,6 +33,7 @@ import type {\n } from '..'\n \n import {\n+  CACHE_ONE_YEAR,\n   HTML_CONTENT_TYPE_HEADER,\n   JSON_CONTENT_TYPE_HEADER,\n   NEXT_RESUME_HEADER,\n@@ -298,6 +299,20 @@ type DynamicRouteItem = {\n   missing: RouteHas[] | undefined\n }\n \n+type Route = {\n+  // regex as string can have named or un-named matches\n+  source?: string\n+  sourceRegex: string\n+  // destination can have matches to replace in destination\n+  // keyed by $1 for un-named and $name for named\n+  destination?: string\n+  headers?: Record<string, string>\n+  has?: RouteHas[]\n+  missing?: RouteHas[]\n+  status?: number\n+  priority?: boolean\n+}\n+\n export interface NextAdapter {\n   name: string\n   /**\n@@ -314,30 +329,20 @@ export interface NextAdapter {\n     }\n   ) => Promise<NextConfigComplete> | NextConfigComplete\n   onBuildComplete?: (ctx: {\n-    routes: {\n-      headers: Array<{\n-        source: string\n-        sourceRegex: string\n-        headers: Record<string, string>\n-        has: RouteHas[] | undefined\n-        missing: RouteHas[] | undefined\n-        priority?: boolean\n-      }>\n-      redirects: Array<{\n-        source: string\n-        sourceRegex: string\n-        destination: string\n-        statusCode: number\n-        has: RouteHas[] | undefined\n-        missing: RouteHas[] | undefined\n-        priority?: boolean\n-      }>\n-      rewrites: {\n-        beforeFiles: RewriteItem[]\n-        afterFiles: RewriteItem[]\n-        fallback: RewriteItem[]\n-      }\n-      dynamicRoutes: Array<DynamicRouteItem>\n+    routing: {\n+      beforeMiddleware: Array<Route>\n+      beforeFiles: Array<Route>\n+      afterFiles: Array<Route>\n+      dynamicRoutes: Array<Route>\n+      onMatch: Array<Route>\n+      fallback: Array<Route>\n+      /**\n+       * shouldNormalizeNextData indicates whether Next.js data URLs\n+       * (e.g., /_next/data/BUILD_ID/page.json) should be normalized\n+       * during route resolution. This is true when middleware is present\n+       * and there are pages router items to resolve.\n+       */\n+      shouldNormalizeNextData: boolean\n     }\n     outputs: AdapterOutputs\n     /**\n@@ -1649,53 +1654,73 @@ export async function handleBuildComplete({\n         destination: converted.dest || route.destination,\n         has: route.has,\n         missing: route.missing,\n-      }\n+      } satisfies Route\n     }\n \n     try {\n       Log.info(`Running onBuildComplete from ${adapterMod.name}`)\n+\n+      const combinedDynamicRoutes = [\n+        ...dynamicDataRoutes,\n+        ...dynamicSegmentRoutes,\n+        ...dynamicRoutes,\n+      ] satisfies Route[]\n+\n+      const rewrites = {\n+        beforeFiles: routesManifest.rewrites.beforeFiles.map(buildRewriteItem),\n+        afterFiles: routesManifest.rewrites.afterFiles.map(buildRewriteItem),\n+        fallback: routesManifest.rewrites.fallback.map(buildRewriteItem),\n+      }\n+\n+      const redirects = routesManifest.redirects.map((route) => {\n+        const converted = convertRedirects([route], 307)[0]\n+        const regex = converted.src || route.regex\n+\n+        return {\n+          source: route.source,\n+          sourceRegex: route.internal ? regex : modifyRouteRegex(regex),\n+          headers: 'headers' in converted ? converted.headers || {} : {},\n+          status: converted.status || getRedirectStatus(route),\n+          has: route.has,\n+          missing: route.missing,\n+          priority: route.internal || undefined,\n+        } satisfies Route\n+      })\n+\n+      const headers = routesManifest.headers.map((route) => {\n+        const converted = convertHeaders([route])[0]\n+        const regex = converted.src || route.regex\n+\n+        return {\n+          source: route.source,\n+          sourceRegex: route.internal ? regex : modifyRouteRegex(regex),\n+          headers: 'headers' in converted ? converted.headers || {} : {},\n+          has: route.has,\n+          missing: route.missing,\n+          priority: route.internal || undefined,\n+        } satisfies Route\n+      })\n+\n       await adapterMod.onBuildComplete({\n-        routes: {\n-          dynamicRoutes: [\n-            ...dynamicDataRoutes,\n-            ...dynamicSegmentRoutes,\n-            ...dynamicRoutes,\n+        routing: {\n+          beforeMiddleware: [...headers, ...redirects],\n+          beforeFiles: rewrites.beforeFiles,\n+          afterFiles: rewrites.afterFiles,\n+          dynamicRoutes: combinedDynamicRoutes,\n+          onMatch: [\n+            {\n+              // This ensures we only match known emitted-by-Next.js files and not\n+              // user-emitted files which may be missing a hash in their filename.\n+              sourceRegex: `^/${escapeStringRegexp(buildId)}/_next/static/(?:[^/]+/pages|pages|chunks|runtime|css|image|media|${escapeStringRegexp(buildId)})/.+`,\n+              // Next.js assets contain a hash or entropy in their filenames, so they\n+              // are guaranteed to be unique and cacheable indefinitely.\n+              headers: {\n+                'cache-control': `public,max-age=${CACHE_ONE_YEAR},immutable`,\n+              },\n+            },\n           ],\n-          rewrites: {\n-            beforeFiles:\n-              routesManifest.rewrites.beforeFiles.map(buildRewriteItem),\n-            afterFiles:\n-              routesManifest.rewrites.afterFiles.map(buildRewriteItem),\n-            fallback: routesManifest.rewrites.fallback.map(buildRewriteItem),\n-          },\n-          redirects: routesManifest.redirects.map((route) => {\n-            const converted = convertRedirects([route], 307)[0]\n-            let dest = 'headers' in converted && converted.headers?.Location\n-            const regex = converted.src || route.regex\n-\n-            return {\n-              source: route.source,\n-              sourceRegex: route.internal ? regex : modifyRouteRegex(regex),\n-              destination: dest || route.destination,\n-              statusCode: converted.status || getRedirectStatus(route),\n-              has: route.has,\n-              missing: route.missing,\n-              priority: route.internal || undefined,\n-            }\n-          }),\n-          headers: routesManifest.headers.map((route) => {\n-            const converted = convertHeaders([route])[0]\n-            const regex = converted.src || route.regex\n-\n-            return {\n-              source: route.source,\n-              sourceRegex: route.internal ? regex : modifyRouteRegex(regex),\n-              headers: 'headers' in converted ? converted.headers || {} : {},\n-              has: route.has,\n-              missing: route.missing,\n-              priority: route.internal || undefined,\n-            }\n-          }),\n+          fallback: rewrites.fallback,\n+          shouldNormalizeNextData: !!needsMiddlewareResolveRoutes,\n         },\n         outputs,\n "
        },
        {
            "sha": "ef5670f1c55b3bf57f9440fbec0161c03db448a1",
            "filename": "pnpm-lock.yaml",
            "status": "modified",
            "additions": 102,
            "deletions": 0,
            "changes": 102,
            "blob_url": "https://github.com/vercel/next.js/blob/840643f2078cb3fbf5e0689d1e7948b711b9de62/pnpm-lock.yaml",
            "raw_url": "https://github.com/vercel/next.js/raw/840643f2078cb3fbf5e0689d1e7948b711b9de62/pnpm-lock.yaml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/pnpm-lock.yaml?ref=840643f2078cb3fbf5e0689d1e7948b711b9de62",
            "patch": "@@ -1888,6 +1888,21 @@ importers:\n         specifier: 3.0.0\n         version: 3.0.0\n \n+  packages/next-routing:\n+    devDependencies:\n+      '@types/jest':\n+        specifier: ^29.5.0\n+        version: 29.5.5\n+      '@vercel/ncc':\n+        specifier: 0.34.0\n+        version: 0.34.0\n+      jest:\n+        specifier: ^29.5.0\n+        version: 29.7.0(@types/node@20.17.6(patch_hash=rvl3vkomen3tospgr67bzubfyu))(babel-plugin-macros@3.1.0)\n+      ts-jest:\n+        specifier: ^29.1.0\n+        version: 29.4.5(@babel/core@7.26.10)(@jest/transform@29.7.0)(@jest/types@29.6.3)(babel-jest@29.7.0(@babel/core@7.26.10))(jest-util@29.7.0)(jest@29.7.0(@types/node@20.17.6(patch_hash=rvl3vkomen3tospgr67bzubfyu))(babel-plugin-macros@3.1.0))(typescript@5.9.2)\n+\n   packages/next-rspack:\n     dependencies:\n       '@next/rspack-core':\n@@ -7783,6 +7798,10 @@ packages:\n     engines: {node: ^6 || ^7 || ^8 || ^9 || ^10 || ^11 || ^12 || >=13.7}\n     hasBin: true\n \n+  bs-logger@0.2.6:\n+    resolution: {integrity: sha512-pd8DCoxmbgc7hyPKOvxtqNcjYoOsABPQdcCUjGp3d42VR2CX1ORhk2A87oqqu5R1kk+76nsxZupkmyd+MVtCog==}\n+    engines: {node: '>= 6'}\n+\n   bser@2.1.1:\n     resolution: {integrity: sha512-gQxTNE/GAfIIrmHLUE3oJyp5FO6HRBfhjnw4/wMmA63ZGDJnWBmgY/lyQBpnDUkGmAhbSe39tx2d/iTOAfglwQ==}\n \n@@ -10907,6 +10926,11 @@ packages:\n     engines: {node: '>=0.4.7'}\n     hasBin: true\n \n+  handlebars@4.7.8:\n+    resolution: {integrity: sha512-vafaFqs8MZkRrSX7sFVUdo3ap/eNiLnb4IakshzvP56X5Nr1iGKAIqdX6tMlm6HcNRIkr6AxO5jFEoJzzpT8aQ==}\n+    engines: {node: '>=0.4.7'}\n+    hasBin: true\n+\n   har-schema@2.0.0:\n     resolution: {integrity: sha512-Oqluz6zhGX8cyRaTQlFMPw80bSJVG2x/cFb8ZPhUILGgHka9SsokCCOQgpveePerqidZOrT14ipqfJb7ILcW5Q==}\n     engines: {node: '>=4'}\n@@ -12955,6 +12979,9 @@ packages:\n     resolution: {integrity: sha512-hXdUTZYIVOt1Ex//jAQi+wTZZpUpwBj/0QsOzqegb3rGMMeJiSEu5xLHnYfBrRV4RH2+OCSOO95Is/7x1WJ4bw==}\n     engines: {node: '>=10'}\n \n+  make-error@1.3.6:\n+    resolution: {integrity: sha512-s8UhlNe7vPKomQhC1qFelMokr/Sc3AgNbso3n74mVPA5LTZwkB9NlXf4XPamLxJE8h0gh73rM94xvwRT2CVInw==}\n+\n   make-fetch-happen@14.0.3:\n     resolution: {integrity: sha512-QMjGbFTP0blj97EeidG5hk/QhKQ3T4ICckQGLgz38QF7Vgbk6e6FTARN8KhKxyBbWn8R0HU+bnw8aSoFPD4qtQ==}\n     engines: {node: ^18.17.0 || >=20.5.0}\n@@ -16499,6 +16526,11 @@ packages:\n     engines: {node: '>=10'}\n     hasBin: true\n \n+  semver@7.7.3:\n+    resolution: {integrity: sha512-SdsKMrI9TdgjdweUSR9MweHA4EJ8YxHn8DFaDisvhVlUOe4BF1tLD7GAj0lIqWVl+dPb/rExr0Btby5loQm20Q==}\n+    engines: {node: '>=10'}\n+    hasBin: true\n+\n   send@0.17.1:\n     resolution: {integrity: sha512-BsVKsiGcQMFwT8UxypobUKyv7irCNRHk1T0G680vk88yf6LBByGcZJOTJCrTP2xVN6yI+XjPJcNuE3V4fT9sAg==}\n     engines: {node: '>= 0.8.0'}\n@@ -17514,6 +17546,33 @@ packages:\n     resolution: {integrity: sha512-q5W7tVM71e2xjHZTlgfTDoPF/SmqKG5hddq9SzR49CH2hayqRKJtQ4mtRlSxKaJlR/+9rEM+mnBHf7I2/BQcpQ==}\n     engines: {node: '>=6.10'}\n \n+  ts-jest@29.4.5:\n+    resolution: {integrity: sha512-HO3GyiWn2qvTQA4kTgjDcXiMwYQt68a1Y8+JuLRVpdIzm+UOLSHgl/XqR4c6nzJkq5rOkjc02O2I7P7l/Yof0Q==}\n+    engines: {node: ^14.15.0 || ^16.10.0 || ^18.0.0 || >=20.0.0}\n+    hasBin: true\n+    peerDependencies:\n+      '@babel/core': 7.26.10\n+      '@jest/transform': ^29.0.0 || ^30.0.0\n+      '@jest/types': ^29.0.0 || ^30.0.0\n+      babel-jest: ^29.0.0 || ^30.0.0\n+      esbuild: '*'\n+      jest: ^29.0.0 || ^30.0.0\n+      jest-util: ^29.0.0 || ^30.0.0\n+      typescript: '>=4.3 <6'\n+    peerDependenciesMeta:\n+      '@babel/core':\n+        optional: true\n+      '@jest/transform':\n+        optional: true\n+      '@jest/types':\n+        optional: true\n+      babel-jest:\n+        optional: true\n+      esbuild:\n+        optional: true\n+      jest-util:\n+        optional: true\n+\n   tsconfig-paths@3.15.0:\n     resolution: {integrity: sha512-2Ac2RgzDe/cn48GvOe3M+o82pEFewD3UPbyoUHHdKasHwJKjds4fLXWf/Ux5kATBKN20oaFGu+jbElp1pos0mg==}\n \n@@ -17667,6 +17726,10 @@ packages:\n     resolution: {integrity: sha512-Q08/0IrpvM+NMY9PA2rti9Jb+JejTddwmwmVQGskAlhtcrw1wsRzoR6ode6mR+OAabNa75w/dxedSUY2mlphaQ==}\n     engines: {node: '>=16'}\n \n+  type-fest@4.41.0:\n+    resolution: {integrity: sha512-TeTSQ6H5YHvpqVwBRcnLDCBnDOHWYu7IvGbHT6N8AOymcr9PJGjc1GTtiWZTYg0NCgYwvnYWEkVChQAr9bjfwA==}\n+    engines: {node: '>=16'}\n+\n   type-is@1.6.18:\n     resolution: {integrity: sha512-TkRKr9sUTxEH8MdfuCSP7VizJyzRNMjj2J2do2Jr3Kym598JVdEksuzPQCnlFPW4ky9Q+iA+ma9BGm06XQBy8g==}\n     engines: {node: '>= 0.6'}\n@@ -25297,6 +25360,10 @@ snapshots:\n       node-releases: 2.0.27\n       update-browserslist-db: 1.1.4(browserslist@4.28.0)\n \n+  bs-logger@0.2.6:\n+    dependencies:\n+      fast-json-stable-stringify: 2.1.0\n+\n   bser@2.1.1:\n     dependencies:\n       node-int64: 0.4.0\n@@ -29289,6 +29356,15 @@ snapshots:\n     optionalDependencies:\n       uglify-js: 3.17.4\n \n+  handlebars@4.7.8:\n+    dependencies:\n+      minimist: 1.2.8\n+      neo-async: 2.6.2\n+      source-map: 0.6.1\n+      wordwrap: 1.0.0\n+    optionalDependencies:\n+      uglify-js: 3.17.4\n+\n   har-schema@2.0.0: {}\n \n   har-validator@5.1.3:\n@@ -31834,6 +31910,8 @@ snapshots:\n     dependencies:\n       semver: 7.6.3\n \n+  make-error@1.3.6: {}\n+\n   make-fetch-happen@14.0.3:\n     dependencies:\n       '@npmcli/agent': 3.0.0\n@@ -36405,6 +36483,8 @@ snapshots:\n \n   semver@7.7.2: {}\n \n+  semver@7.7.3: {}\n+\n   send@0.17.1:\n     dependencies:\n       debug: 2.6.9\n@@ -37670,6 +37750,26 @@ snapshots:\n \n   ts-dedent@2.2.0: {}\n \n+  ts-jest@29.4.5(@babel/core@7.26.10)(@jest/transform@29.7.0)(@jest/types@29.6.3)(babel-jest@29.7.0(@babel/core@7.26.10))(jest-util@29.7.0)(jest@29.7.0(@types/node@20.17.6(patch_hash=rvl3vkomen3tospgr67bzubfyu))(babel-plugin-macros@3.1.0))(typescript@5.9.2):\n+    dependencies:\n+      bs-logger: 0.2.6\n+      fast-json-stable-stringify: 2.1.0\n+      handlebars: 4.7.8\n+      jest: 29.7.0(@types/node@20.17.6(patch_hash=rvl3vkomen3tospgr67bzubfyu))(babel-plugin-macros@3.1.0)\n+      json5: 2.2.3\n+      lodash.memoize: 4.1.2\n+      make-error: 1.3.6\n+      semver: 7.7.3\n+      type-fest: 4.41.0\n+      typescript: 5.9.2\n+      yargs-parser: 21.1.1\n+    optionalDependencies:\n+      '@babel/core': 7.26.10\n+      '@jest/transform': 29.7.0\n+      '@jest/types': 29.6.3\n+      babel-jest: 29.7.0(@babel/core@7.26.10)\n+      jest-util: 29.7.0\n+\n   tsconfig-paths@3.15.0:\n     dependencies:\n       '@types/json5': 0.0.29\n@@ -37793,6 +37893,8 @@ snapshots:\n \n   type-fest@4.18.3: {}\n \n+  type-fest@4.41.0: {}\n+\n   type-is@1.6.18:\n     dependencies:\n       media-typer: 0.3.0"
        },
        {
            "sha": "6f4ce499921483ac5921dd8263ed6f9dd374bc91",
            "filename": "test/production/adapter-config/adapter-config-export.test.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 5,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/840643f2078cb3fbf5e0689d1e7948b711b9de62/test%2Fproduction%2Fadapter-config%2Fadapter-config-export.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/840643f2078cb3fbf5e0689d1e7948b711b9de62/test%2Fproduction%2Fadapter-config%2Fadapter-config-export.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fadapter-config%2Fadapter-config-export.test.ts?ref=840643f2078cb3fbf5e0689d1e7948b711b9de62",
            "patch": "@@ -37,7 +37,7 @@ describe('adapter-config export', () => {\n \n     const {\n       outputs,\n-      routes,\n+      routing,\n       config,\n       ...ctx\n     }: Parameters<NextAdapter['onBuildComplete']>[0] = await next.readJSON(\n@@ -80,11 +80,14 @@ describe('adapter-config export', () => {\n       expect(stats.isFile()).toBe(true)\n     }\n \n-    expect(routes).toEqual({\n+    expect(routing).toEqual({\n+      beforeMiddleware: expect.toBeArray(),\n+      beforeFiles: expect.toBeArray(),\n+      afterFiles: expect.toBeArray(),\n       dynamicRoutes: expect.toBeArray(),\n-      rewrites: expect.toBeObject(),\n-      redirects: expect.toBeArray(),\n-      headers: expect.toBeArray(),\n+      onMatch: expect.toBeArray(),\n+      fallback: expect.toBeArray(),\n+      shouldNormalizeNextData: expect.toBeBoolean(),\n     })\n   })\n })"
        },
        {
            "sha": "814baf797ee442ce514d37df8f9fdd00019faffa",
            "filename": "test/production/adapter-config/adapter-config.test.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 5,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/840643f2078cb3fbf5e0689d1e7948b711b9de62/test%2Fproduction%2Fadapter-config%2Fadapter-config.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/840643f2078cb3fbf5e0689d1e7948b711b9de62/test%2Fproduction%2Fadapter-config%2Fadapter-config.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fadapter-config%2Fadapter-config.test.ts?ref=840643f2078cb3fbf5e0689d1e7948b711b9de62",
            "patch": "@@ -25,7 +25,7 @@ describe('adapter-config', () => {\n \n     const {\n       outputs,\n-      routes,\n+      routing,\n       config,\n       ...ctx\n     }: Parameters<NextAdapter['onBuildComplete']>[0] = await next.readJSON(\n@@ -204,11 +204,14 @@ describe('adapter-config', () => {\n       }\n     }\n \n-    expect(routes).toEqual({\n+    expect(routing).toEqual({\n+      beforeMiddleware: expect.toBeArray(),\n+      beforeFiles: expect.toBeArray(),\n+      afterFiles: expect.toBeArray(),\n       dynamicRoutes: expect.toBeArray(),\n-      rewrites: expect.toBeObject(),\n-      redirects: expect.toBeArray(),\n-      headers: expect.toBeArray(),\n+      onMatch: expect.toBeArray(),\n+      fallback: expect.toBeArray(),\n+      shouldNormalizeNextData: expect.toBeBoolean(),\n     })\n   })\n })"
        }
    ],
    "stats": {
        "total": 7918,
        "additions": 7843,
        "deletions": 75
    }
}