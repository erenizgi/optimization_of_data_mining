{
    "author": "wyattjoh",
    "message": "[ppr] Route Cardinality Updates (#78476)\n\nThis enables a new set of cardinality changes for pages with PPR and\nDynamic IO enabled on it. When a set of more specific routes are\ngenerated, we no longer error when the static shell is empty and instead\ninfer that as a sign that the user doesn't want to provide a route\nfallback. If the user does in fact place suspense boundaries above\nparams access, the fallback shell will not be empty and will be used.\n\nGiven the following application structure:\n```\n/[lang]/layout.tsx\n/[lang]/[teamSlug]/page.tsx\n```\n\nWhere we have the following returned for `generateStaticProps`: `[{\nlang: \"en\", teamSlug: \"nextjs\"}]`, we'd have the following rendered:\n\n```\n/[lang]/[teamSlug] <- empty shell won't cause error\n/en/[teamSlug] <- empty shell won't cause error\n/en/nextjs <- empty shell will cause error\n```\n\nIf `/[lang]/[teamSlug]` generated an empty shell, then a request to\n`/fr/nextjs` wouldn't use the `/[lang]/[teamSlug]` fallback shell and\nwould instead generate a new blocking route shell. Otherwise if it\ndidn't generate an empty shell, it would use the fallback shell that's\noutputted.\n\nIf `/en/[teamSlug]` generated an empty shell, then a request to\n`/en/react` wouldn't use the `/en/[teamSlug]` fallback shell and would\ninstead generate a new blocking route shell. Otherwise if it didn't\ngenerate an empty shell, it would use the fallback shell that's\noutputted.",
    "sha": "f0d81f1468e882edd48270b3f4989e15560f65dc",
    "files": [
        {
            "sha": "e1f11e713e6653d2c8eabfd625a8d02afeaf184d",
            "filename": "packages/next/src/build/index.ts",
            "status": "modified",
            "additions": 49,
            "deletions": 18,
            "changes": 67,
            "blob_url": "https://github.com/vercel/next.js/blob/f0d81f1468e882edd48270b3f4989e15560f65dc/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f0d81f1468e882edd48270b3f4989e15560f65dc/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts?ref=f0d81f1468e882edd48270b3f4989e15560f65dc",
            "patch": "@@ -444,7 +444,7 @@ export type RoutesManifest = {\n   }\n }\n \n-function pageToRoute(page: string) {\n+function pageToRoute(page: string): ManifestRoute {\n   const routeRegex = getNamedRouteRegex(page, {\n     prefixRouteKeys: true,\n   })\n@@ -1303,8 +1303,8 @@ export default async function build(\n             ...pageKeys.pages,\n             ...(pageKeys.app ?? []),\n           ])\n-          const dynamicRoutes: Array<ReturnType<typeof pageToRoute>> = []\n-          const staticRoutes: typeof dynamicRoutes = []\n+          const dynamicRoutes: Array<ManifestRoute> = []\n+          const staticRoutes: Array<ManifestRoute> = []\n \n           for (const route of sortedRoutes) {\n             if (isDynamicRoute(route)) {\n@@ -2025,12 +2025,14 @@ export default async function build(\n                             if (!isDynamic) {\n                               staticPaths.set(originalAppPath, [\n                                 {\n+                                  params: {},\n                                   pathname: page,\n                                   encodedPathname: page,\n-                                  fallbackRouteParams: undefined,\n+                                  fallbackRouteParams: [],\n                                   fallbackMode:\n                                     workerResult.prerenderFallbackMode,\n-                                  fallbackRootParams: undefined,\n+                                  fallbackRootParams: [],\n+                                  throwOnEmptyStaticShell: true,\n                                 },\n                               ])\n                               isStatic = true\n@@ -2061,8 +2063,6 @@ export default async function build(\n                               `\"getStaticProps\" is not yet supported fully with \"experimental-edge\", detected on ${page}`\n                             )\n                           }\n-                          // TODO: add handling for statically rendering edge\n-                          // pages and allow edge with Prerender outputs\n                           workerResult.isStatic = false\n                           workerResult.hasStaticProps = false\n                         }\n@@ -2188,7 +2188,7 @@ export default async function build(\n                   runtime: pageRuntime,\n                   pageDuration: undefined,\n                   ssgPageDurations: undefined,\n-                  hasEmptyPrelude: undefined,\n+                  hasEmptyStaticShell: undefined,\n                 })\n               })\n             })\n@@ -2607,6 +2607,7 @@ export default async function build(\n               )\n             )\n           )\n+\n           const exportApp = require('../export')\n             .default as typeof import('../export').default\n \n@@ -2678,9 +2679,9 @@ export default async function build(\n                 const appConfig = appDefaultConfigs.get(originalAppPath)\n                 const isDynamicError = appConfig?.dynamic === 'error'\n \n-                const isRoutePPREnabled = appConfig\n+                const isRoutePPREnabled: boolean = appConfig\n                   ? checkIsRoutePPREnabled(config.experimental.ppr, appConfig)\n-                  : undefined\n+                  : false\n \n                 routes.forEach((route) => {\n                   // If the route has any dynamic root segments, we need to skip\n@@ -2700,6 +2701,8 @@ export default async function build(\n                     _isDynamicError: isDynamicError,\n                     _isAppDir: true,\n                     _isRoutePPREnabled: isRoutePPREnabled,\n+                    _doNotThrowOnEmptyStaticShell:\n+                      !route.throwOnEmptyStaticShell,\n                   }\n                 })\n               })\n@@ -2780,6 +2783,31 @@ export default async function build(\n           // If there was no result, there's nothing more to do.\n           if (!exportResult) return\n \n+          const getFallbackMode = (route: PrerenderedRoute) => {\n+            const hasEmptyStaticShell = exportResult.byPath.get(\n+              route.pathname\n+            )?.hasEmptyStaticShell\n+\n+            // If the route has an empty static shell and is not configured to\n+            // throw on empty static shell, then we should use the blocking\n+            // static render mode.\n+            if (\n+              hasEmptyStaticShell &&\n+              !route.throwOnEmptyStaticShell &&\n+              route.fallbackMode === FallbackMode.PRERENDER\n+            ) {\n+              return FallbackMode.BLOCKING_STATIC_RENDER\n+            }\n+\n+            // If the route has no fallback mode, then we should use the\n+            // `NOT_FOUND` fallback mode.\n+            if (!route.fallbackMode) {\n+              return FallbackMode.NOT_FOUND\n+            }\n+\n+            return route.fallbackMode\n+          }\n+\n           const getCacheControl = (\n             exportPath: string,\n             defaultRevalidate: Revalidate = false\n@@ -2953,7 +2981,7 @@ export default async function build(\n \n               const {\n                 metadata = {},\n-                hasEmptyPrelude,\n+                hasEmptyStaticShell,\n                 hasPostponed,\n               } = exportResult.byPath.get(route.pathname) ?? {}\n \n@@ -2965,15 +2993,15 @@ export default async function build(\n               pageInfos.set(route.pathname, {\n                 ...(pageInfos.get(route.pathname) as PageInfo),\n                 hasPostponed,\n-                hasEmptyPrelude,\n+                hasEmptyStaticShell,\n                 initialCacheControl: cacheControl,\n               })\n \n               // update the page (eg /blog/[slug]) to also have the postpone metadata\n               pageInfos.set(page, {\n                 ...(pageInfos.get(page) as PageInfo),\n                 hasPostponed,\n-                hasEmptyPrelude,\n+                hasEmptyStaticShell,\n                 initialCacheControl: cacheControl,\n               })\n \n@@ -3035,13 +3063,15 @@ export default async function build(\n               // prerendered routes.\n               if (!isRoutePPREnabled) {\n                 dynamicRoutes.push({\n+                  params: {},\n                   pathname: page,\n                   encodedPathname: page,\n-                  fallbackRouteParams: undefined,\n+                  fallbackRouteParams: [],\n                   fallbackMode:\n                     fallbackModes.get(originalAppPath) ??\n                     FallbackMode.NOT_FOUND,\n-                  fallbackRootParams: undefined,\n+                  fallbackRootParams: [],\n+                  throwOnEmptyStaticShell: true,\n                 })\n               }\n \n@@ -3090,8 +3120,7 @@ export default async function build(\n                   hasPostponed: isRoutePPREnabled,\n                 })\n \n-                const fallbackMode =\n-                  route.fallbackMode ?? FallbackMode.NOT_FOUND\n+                const fallbackMode = getFallbackMode(route)\n \n                 // When the route is configured to serve a prerender, we should\n                 // use the cache control from the export result. If it can't be\n@@ -3133,7 +3162,9 @@ export default async function build(\n                   fallbackExpire: fallbackCacheControl?.expire,\n                   fallbackStatus: meta.status,\n                   fallbackHeaders: meta.headers,\n-                  fallbackRootParams: route.fallbackRootParams,\n+                  fallbackRootParams: fallback\n+                    ? route.fallbackRootParams\n+                    : undefined,\n                   fallbackSourceRoute: route.fallbackRouteParams?.length\n                     ? page\n                     : undefined,"
        },
        {
            "sha": "703c5ac05d6381b15b8526b1eceb7ef4944d48c3",
            "filename": "packages/next/src/build/static-paths/app.test.ts",
            "status": "added",
            "additions": 157,
            "deletions": 0,
            "changes": 157,
            "blob_url": "https://github.com/vercel/next.js/blob/f0d81f1468e882edd48270b3f4989e15560f65dc/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f0d81f1468e882edd48270b3f4989e15560f65dc/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp.test.ts?ref=f0d81f1468e882edd48270b3f4989e15560f65dc",
            "patch": "@@ -0,0 +1,157 @@\n+import { FallbackMode } from '../../lib/fallback'\n+import {\n+  assignErrorIfEmpty,\n+  filterUniqueRootParamsCombinations,\n+  filterUniqueParams,\n+} from './app'\n+import type { PrerenderedRoute } from './types'\n+\n+describe('assignErrorIfEmpty', () => {\n+  it('should assign throwOnEmptyStaticShell false for a static route', () => {\n+    const prerenderedRoutes: PrerenderedRoute[] = [\n+      {\n+        params: {},\n+        pathname: '/',\n+        encodedPathname: '/',\n+        fallbackRouteParams: [],\n+        fallbackMode: FallbackMode.NOT_FOUND,\n+        fallbackRootParams: [],\n+        throwOnEmptyStaticShell: true,\n+      },\n+    ]\n+\n+    assignErrorIfEmpty(prerenderedRoutes, [])\n+\n+    expect(prerenderedRoutes[0].throwOnEmptyStaticShell).toBe(true)\n+  })\n+\n+  it('should assign throwOnEmptyStaticShell to the prerendered routes', () => {\n+    const prerenderedRoutes: PrerenderedRoute[] = [\n+      {\n+        params: {},\n+        pathname: '/[id]',\n+        encodedPathname: '/[id]',\n+        fallbackRouteParams: ['id'],\n+        fallbackMode: FallbackMode.NOT_FOUND,\n+        fallbackRootParams: [],\n+        throwOnEmptyStaticShell: true,\n+      },\n+      {\n+        params: { id: '1' },\n+        pathname: '/1',\n+        encodedPathname: '/1',\n+        fallbackRouteParams: [],\n+        fallbackMode: FallbackMode.NOT_FOUND,\n+        fallbackRootParams: [],\n+        throwOnEmptyStaticShell: true,\n+      },\n+    ]\n+\n+    assignErrorIfEmpty(prerenderedRoutes, ['id'])\n+\n+    expect(prerenderedRoutes[0].throwOnEmptyStaticShell).toBe(false)\n+    expect(prerenderedRoutes[1].throwOnEmptyStaticShell).toBe(true)\n+  })\n+\n+  it('should handle more complex routes', () => {\n+    const prerenderedRoutes: PrerenderedRoute[] = [\n+      {\n+        params: {},\n+        pathname: '/[id]/[name]',\n+        encodedPathname: '/[id]/[name]',\n+        fallbackRouteParams: ['id', 'name'],\n+        fallbackMode: FallbackMode.NOT_FOUND,\n+        fallbackRootParams: [],\n+        throwOnEmptyStaticShell: true,\n+      },\n+      {\n+        params: { id: '1' },\n+        pathname: '/1/[name]',\n+        encodedPathname: '/1/[name]',\n+        fallbackRouteParams: ['name'],\n+        fallbackMode: FallbackMode.NOT_FOUND,\n+        fallbackRootParams: [],\n+        throwOnEmptyStaticShell: true,\n+      },\n+      {\n+        params: { id: '1', name: 'test' },\n+        pathname: '/1/test',\n+        encodedPathname: '/1/test',\n+        fallbackRouteParams: [],\n+        fallbackMode: FallbackMode.NOT_FOUND,\n+        fallbackRootParams: [],\n+        throwOnEmptyStaticShell: true,\n+      },\n+      {\n+        params: { id: '2', name: 'test' },\n+        pathname: '/2/test',\n+        encodedPathname: '/2/test',\n+        fallbackRouteParams: [],\n+        fallbackMode: FallbackMode.NOT_FOUND,\n+        fallbackRootParams: [],\n+        throwOnEmptyStaticShell: true,\n+      },\n+      {\n+        params: { id: '2' },\n+        pathname: '/2/[name]',\n+        encodedPathname: '/2/[name]',\n+        fallbackRouteParams: ['name'],\n+        fallbackMode: FallbackMode.NOT_FOUND,\n+        fallbackRootParams: [],\n+        throwOnEmptyStaticShell: true,\n+      },\n+    ]\n+\n+    assignErrorIfEmpty(prerenderedRoutes, ['id', 'name'])\n+\n+    expect(prerenderedRoutes[0].throwOnEmptyStaticShell).toBe(false)\n+    expect(prerenderedRoutes[1].throwOnEmptyStaticShell).toBe(false)\n+    expect(prerenderedRoutes[2].throwOnEmptyStaticShell).toBe(true)\n+    expect(prerenderedRoutes[3].throwOnEmptyStaticShell).toBe(true)\n+    expect(prerenderedRoutes[4].throwOnEmptyStaticShell).toBe(false)\n+  })\n+})\n+\n+describe('filterUniqueParams', () => {\n+  it('should filter out duplicate parameters', () => {\n+    const params = [\n+      { id: '1', name: 'test' },\n+      { id: '1', name: 'test' },\n+      { id: '2' },\n+    ]\n+\n+    const unique = filterUniqueParams(['id', 'name'], params)\n+\n+    expect(unique).toEqual([{ id: '1', name: 'test' }, { id: '2' }])\n+  })\n+\n+  it('should handle more complex routes', () => {\n+    const params = [\n+      { id: '1', name: 'test', age: '10' },\n+      { id: '1', name: 'test', age: '20' },\n+      { id: '2', name: 'test', age: '10' },\n+    ]\n+\n+    const unique = filterUniqueParams(['id', 'name', 'age'], params)\n+\n+    expect(unique).toEqual([\n+      { id: '1', name: 'test', age: '10' },\n+      { id: '1', name: 'test', age: '20' },\n+      { id: '2', name: 'test', age: '10' },\n+    ])\n+  })\n+})\n+\n+describe('filterUniqueRootParamsCombinations', () => {\n+  it('should return only the root parameters', () => {\n+    const params = [\n+      { id: '1', name: 'test' },\n+      { id: '1', name: 'test' },\n+      { id: '2', name: 'test' },\n+    ]\n+\n+    const unique = filterUniqueRootParamsCombinations(['id'], params)\n+\n+    expect(unique).toEqual([{ id: '1' }, { id: '2' }])\n+  })\n+})"
        },
        {
            "sha": "d1021f635046680dc9b7a2adddbdc264bd1ed1f3",
            "filename": "packages/next/src/build/static-paths/app.ts",
            "status": "modified",
            "additions": 75,
            "deletions": 40,
            "changes": 115,
            "blob_url": "https://github.com/vercel/next.js/blob/f0d81f1468e882edd48270b3f4989e15560f65dc/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f0d81f1468e882edd48270b3f4989e15560f65dc/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp.ts?ref=f0d81f1468e882edd48270b3f4989e15560f65dc",
            "patch": "@@ -1,9 +1,9 @@\n import type { ParamValue, Params } from '../../server/request/params'\n import type { AppPageModule } from '../../server/route-modules/app-page/module'\n import type { AppSegment } from '../segment-config/app/app-segments'\n-import type { StaticPathsResult } from './types'\n+import type { PrerenderedRoute, StaticPathsResult } from './types'\n \n-import path from 'path'\n+import path from 'node:path'\n import { AfterRunner } from '../../server/after/run-with-after'\n import { createWorkStore } from '../../server/async-storage/work-store'\n import { FallbackMode } from '../../lib/fallback'\n@@ -52,39 +52,26 @@ function areParamValuesEqual(a: ParamValue, b: ParamValue) {\n  * @param routeParams - The list of parameters to filter.\n  * @returns The list of unique parameters.\n  */\n-function filterUniqueParams(\n+export function filterUniqueParams(\n   routeParamKeys: readonly string[],\n   routeParams: readonly Params[]\n ): Params[] {\n   const unique: Params[] = []\n \n-  for (const params of routeParams) {\n-    let i = 0\n-    for (; i < unique.length; i++) {\n-      const item = unique[i]\n-      let j = 0\n-      for (; j < routeParamKeys.length; j++) {\n-        const key = routeParamKeys[j]\n-\n-        // If the param is not the same, then we need to break out of the loop.\n+  paramsLoop: for (const params of routeParams) {\n+    uniqueLoop: for (const item of unique) {\n+      for (const key of routeParamKeys) {\n+        // If the param is not the same, then we need to check the next item\n         if (!areParamValuesEqual(item[key], params[key])) {\n-          break\n+          continue uniqueLoop\n         }\n       }\n \n-      // If we got to the end of the paramKeys array, then it means that we\n-      // found a duplicate. Skip it.\n-      if (j === routeParamKeys.length) {\n-        break\n-      }\n-    }\n-\n-    // If we didn't get to the end of the unique array, then it means that we\n-    // found a duplicate. Skip it.\n-    if (i < unique.length) {\n-      continue\n+      // If we got here, then all params matched and we found a duplicate\n+      continue paramsLoop\n     }\n \n+    // If we got here, then we checked all items and found no duplicates\n     unique.push(params)\n   }\n \n@@ -117,36 +104,29 @@ function filterUniqueParams(\n  * @param routeParams - The list of parameters to filter.\n  * @returns The list of combinations of root params.\n  */\n-function filterRootParamsCombinations(\n+export function filterUniqueRootParamsCombinations(\n   rootParamKeys: readonly string[],\n   routeParams: readonly Params[]\n ): Params[] {\n   const combinations: Params[] = []\n \n-  for (const params of routeParams) {\n+  paramsLoop: for (const params of routeParams) {\n     const combination: Params = {}\n \n     // Collect all root params. As soon as we don't find a root param, break.\n-    let i = 0\n-    for (; i < rootParamKeys.length; i++) {\n-      const key = rootParamKeys[i]\n+    for (const key of rootParamKeys) {\n       if (params[key]) {\n         combination[key] = params[key]\n       } else {\n-        break\n+        // Skip this combination if we don't have all root params\n+        continue paramsLoop\n       }\n     }\n \n-    // If we didn't find all root params, skip this combination. We only want to\n-    // generate combinations that have all root params.\n-    if (i < rootParamKeys.length) {\n-      continue\n-    }\n-\n     combinations.push(combination)\n   }\n \n-  return combinations\n+  return filterUniqueParams(rootParamKeys, combinations)\n }\n \n /**\n@@ -243,6 +223,50 @@ function validateParams(\n   return valid\n }\n \n+/**\n+ * Assigns the throwOnEmptyStaticShell property to each of the prerendered routes.\n+ *\n+ * @param prerenderedRoutes - The prerendered routes.\n+ * @param routeParamKeys - The keys of the route parameters.\n+ */\n+export function assignErrorIfEmpty(\n+  prerenderedRoutes: readonly PrerenderedRoute[],\n+  routeParamKeys: readonly string[]\n+) {\n+  // If we're rendering a more specific route, then we don't need to error\n+  // if the route is empty.\n+  for (const prerenderedRoute of prerenderedRoutes) {\n+    let throwOnEmptyStaticShell: boolean = true\n+\n+    // If the route has fallbackRouteParams, then we need to check if the\n+    // route is a more specific route.\n+    const { fallbackRouteParams, params } = prerenderedRoute\n+    if (fallbackRouteParams && fallbackRouteParams.length > 0) {\n+      siblingLoop: for (const other of prerenderedRoutes) {\n+        // Skip the current route.\n+        if (other === prerenderedRoute) continue\n+\n+        for (const key of routeParamKeys) {\n+          // If the key is a fallback route param, then we can skip it, because\n+          // it always matches.\n+          if (fallbackRouteParams.includes(key)) {\n+            throwOnEmptyStaticShell = false\n+            break siblingLoop\n+          }\n+\n+          // If the param value is not equal, then we can break out of the loop\n+          // because the route is not a more specific route.\n+          if (!areParamValuesEqual(params[key], other.params[key])) {\n+            continue siblingLoop\n+          }\n+        }\n+      }\n+    }\n+\n+    prerenderedRoute.throwOnEmptyStaticShell = throwOnEmptyStaticShell\n+  }\n+}\n+\n /**\n  * Builds the static paths for an app using `generateStaticParams`.\n  *\n@@ -396,6 +420,8 @@ export async function buildAppStaticPaths({\n     }\n   )\n \n+  await afterRunner.executeAfter()\n+\n   let lastDynamicSegmentHadGenerateStaticParams = false\n   for (const segment of segments) {\n     // Check to see if there are any missing params for segments that have\n@@ -470,11 +496,12 @@ export async function buildAppStaticPaths({\n       // Discover all unique combinations of the rootParams so we can generate\n       // shells for each of them if they're available.\n       routeParams.unshift(\n-        ...filterRootParamsCombinations(rootParamKeys, routeParams)\n+        ...filterUniqueRootParamsCombinations(rootParamKeys, routeParams)\n       )\n \n       result.prerenderedRoutes ??= []\n       result.prerenderedRoutes.push({\n+        params: {},\n         pathname: page,\n         encodedPathname: page,\n         fallbackRouteParams: routeParamKeys,\n@@ -486,6 +513,8 @@ export async function buildAppStaticPaths({\n             : fallbackMode\n           : FallbackMode.NOT_FOUND,\n         fallbackRootParams: rootParamKeys,\n+        // This is set later after all the routes have been processed.\n+        throwOnEmptyStaticShell: true,\n       })\n     }\n \n@@ -503,7 +532,7 @@ export async function buildAppStaticPaths({\n       let pathname: string = page\n       let encodedPathname: string = page\n \n-      const fallbackRouteParams: string[] = []\n+      let fallbackRouteParams: string[] = []\n \n       for (const key of routeParamKeys) {\n         if (fallbackRouteParams.length > 0) {\n@@ -550,6 +579,7 @@ export async function buildAppStaticPaths({\n \n       result.prerenderedRoutes ??= []\n       result.prerenderedRoutes.push({\n+        params,\n         pathname: normalizePathname(pathname),\n         encodedPathname: normalizePathname(encodedPathname),\n         fallbackRouteParams,\n@@ -561,11 +591,16 @@ export async function buildAppStaticPaths({\n             : fallbackMode\n           : FallbackMode.NOT_FOUND,\n         fallbackRootParams,\n+        // This is set later after all the routes have been processed.\n+        throwOnEmptyStaticShell: true,\n       })\n     })\n   }\n \n-  await afterRunner.executeAfter()\n+  // Now we have to set the throwOnEmptyStaticShell for each of the routes.\n+  if (result.prerenderedRoutes && dynamicIO) {\n+    assignErrorIfEmpty(result.prerenderedRoutes, routeParamKeys)\n+  }\n \n   return result\n }"
        },
        {
            "sha": "810292d58a4efd2ead0078a6a747d4cc5ecad842",
            "filename": "packages/next/src/build/static-paths/pages.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 2,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/f0d81f1468e882edd48270b3f4989e15560f65dc/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fpages.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f0d81f1468e882edd48270b3f4989e15560f65dc/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fpages.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fpages.ts?ref=f0d81f1468e882edd48270b3f4989e15560f65dc",
            "patch": "@@ -98,8 +98,8 @@ export async function buildPagesStaticPaths({\n         entry = `/${defaultLocale}${entry}`\n       }\n \n-      const result = _routeMatcher(cleanedEntry)\n-      if (!result) {\n+      const params = _routeMatcher(cleanedEntry)\n+      if (!params) {\n         throw new Error(\n           `The provided path \\`${cleanedEntry}\\` does not match the page: \\`${page}\\`.`\n         )\n@@ -109,6 +109,7 @@ export async function buildPagesStaticPaths({\n       // encoded so we decode the segments ensuring we only escape path\n       // delimiters\n       prerenderedRoutes.push({\n+        params,\n         pathname: entry\n           .split('/')\n           .map((segment) =>\n@@ -119,6 +120,7 @@ export async function buildPagesStaticPaths({\n         fallbackRouteParams: undefined,\n         fallbackMode: parseStaticPathsResult(staticPathsResult.fallback),\n         fallbackRootParams: undefined,\n+        throwOnEmptyStaticShell: undefined,\n       })\n     }\n     // For the object-provided path, we must make sure it specifies all\n@@ -196,6 +198,7 @@ export async function buildPagesStaticPaths({\n       const curLocale = entry.locale || defaultLocale || ''\n \n       prerenderedRoutes.push({\n+        params,\n         pathname: normalizePathname(\n           `${curLocale ? `/${curLocale}` : ''}${\n             curLocale && builtPage === '/' ? '' : builtPage\n@@ -209,6 +212,7 @@ export async function buildPagesStaticPaths({\n         fallbackRouteParams: undefined,\n         fallbackMode: parseStaticPathsResult(staticPathsResult.fallback),\n         fallbackRootParams: undefined,\n+        throwOnEmptyStaticShell: undefined,\n       })\n     }\n   })"
        },
        {
            "sha": "e316237d71ae9d38c50e1434d55344d368c145b4",
            "filename": "packages/next/src/build/static-paths/types.ts",
            "status": "modified",
            "additions": 25,
            "deletions": 10,
            "changes": 35,
            "blob_url": "https://github.com/vercel/next.js/blob/f0d81f1468e882edd48270b3f4989e15560f65dc/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Ftypes.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f0d81f1468e882edd48270b3f4989e15560f65dc/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Ftypes.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Ftypes.ts?ref=f0d81f1468e882edd48270b3f4989e15560f65dc",
            "patch": "@@ -1,19 +1,34 @@\n import type { FallbackMode } from '../../lib/fallback'\n+import type { Params } from '../../server/request/params'\n \n type StaticPrerenderedRoute = {\n-  pathname: string\n-  encodedPathname: string\n-  fallbackRouteParams: undefined\n-  fallbackMode: FallbackMode | undefined\n-  fallbackRootParams: undefined\n+  readonly params: Params\n+  readonly pathname: string\n+  readonly encodedPathname: string\n+  readonly fallbackRouteParams: undefined\n+  readonly fallbackMode: FallbackMode | undefined\n+  readonly fallbackRootParams: undefined\n+\n+  /**\n+   * When enabled, the route will be rendered with diagnostics enabled which\n+   * will error the build if the route that is generated is empty.\n+   */\n+  throwOnEmptyStaticShell: undefined\n }\n \n type FallbackPrerenderedRoute = {\n-  pathname: string\n-  encodedPathname: string\n-  fallbackRouteParams: readonly string[]\n-  fallbackMode: FallbackMode | undefined\n-  fallbackRootParams: readonly string[]\n+  readonly params: Params\n+  readonly pathname: string\n+  readonly encodedPathname: string\n+  readonly fallbackRouteParams: readonly string[]\n+  readonly fallbackMode: FallbackMode | undefined\n+  readonly fallbackRootParams: readonly string[]\n+\n+  /**\n+   * When enabled, the route will be rendered with diagnostics enabled which\n+   * will error the build if the route that is generated is empty.\n+   */\n+  throwOnEmptyStaticShell: boolean\n }\n \n export type PrerenderedRoute = StaticPrerenderedRoute | FallbackPrerenderedRoute"
        },
        {
            "sha": "88c60214297287ddefc9a87101b776e67bc6e039",
            "filename": "packages/next/src/build/utils.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/f0d81f1468e882edd48270b3f4989e15560f65dc/packages%2Fnext%2Fsrc%2Fbuild%2Futils.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f0d81f1468e882edd48270b3f4989e15560f65dc/packages%2Fnext%2Fsrc%2Fbuild%2Futils.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Futils.ts?ref=f0d81f1468e882edd48270b3f4989e15560f65dc",
            "patch": "@@ -353,7 +353,7 @@ export interface PageInfo {\n   pageDuration: number | undefined\n   ssgPageDurations: number[] | undefined\n   runtime: ServerRuntime\n-  hasEmptyPrelude?: boolean\n+  hasEmptyStaticShell?: boolean\n   hasPostponed?: boolean\n   isDynamicAppRoute?: boolean\n }\n@@ -528,8 +528,9 @@ export async function printTreeView(\n         symbol = 'Æ’'\n       } else if (pageInfo?.isRoutePPREnabled) {\n         if (\n-          // If the page has an empty prelude, then it's equivalent to a dynamic page\n-          pageInfo?.hasEmptyPrelude ||\n+          // If the page has an empty static shell, then it's equivalent to a\n+          // dynamic page\n+          pageInfo?.hasEmptyStaticShell ||\n           // ensure we don't mark dynamic paths that postponed as being dynamic\n           // since in this case we're able to partially prerender it\n           (pageInfo.isDynamicAppRoute && !pageInfo.hasPostponed)"
        },
        {
            "sha": "ce72dba788105ed2a649b57c0a1e6513b3b785ef",
            "filename": "packages/next/src/export/index.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/f0d81f1468e882edd48270b3f4989e15560f65dc/packages%2Fnext%2Fsrc%2Fexport%2Findex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f0d81f1468e882edd48270b3f4989e15560f65dc/packages%2Fnext%2Fsrc%2Fexport%2Findex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fexport%2Findex.ts?ref=f0d81f1468e882edd48270b3f4989e15560f65dc",
            "patch": "@@ -652,8 +652,8 @@ async function exportAppImpl(\n         info.metadata = result.metadata\n       }\n \n-      if (typeof result.hasEmptyPrelude !== 'undefined') {\n-        info.hasEmptyPrelude = result.hasEmptyPrelude\n+      if (typeof result.hasEmptyStaticShell !== 'undefined') {\n+        info.hasEmptyStaticShell = result.hasEmptyStaticShell\n       }\n \n       if (typeof result.hasPostponed !== 'undefined') {"
        },
        {
            "sha": "7d896b57b5029002195c9f0674cf2ccae02b996e",
            "filename": "packages/next/src/export/routes/app-page.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/f0d81f1468e882edd48270b3f4989e15560f65dc/packages%2Fnext%2Fsrc%2Fexport%2Froutes%2Fapp-page.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f0d81f1468e882edd48270b3f4989e15560f65dc/packages%2Fnext%2Fsrc%2Fexport%2Froutes%2Fapp-page.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fexport%2Froutes%2Fapp-page.ts?ref=f0d81f1468e882edd48270b3f4989e15560f65dc",
            "patch": "@@ -232,7 +232,7 @@ export async function exportAppPage(\n     }\n \n     // Writing static HTML to a file.\n-    fileWriter.append(htmlFilepath, html ?? '')\n+    fileWriter.append(htmlFilepath, html)\n \n     const isParallelRoute = /\\/@\\w+/.test(page)\n     const isNonSuccessfulStatusCode = res.statusCode > 300\n@@ -268,7 +268,7 @@ export async function exportAppPage(\n     return {\n       // Only include the metadata if the environment has next support.\n       metadata: hasNextSupport ? meta : undefined,\n-      hasEmptyPrelude: Boolean(postponed) && html === '',\n+      hasEmptyStaticShell: Boolean(postponed) && html === '',\n       hasPostponed: Boolean(postponed),\n       cacheControl,\n       fetchMetrics,"
        },
        {
            "sha": "58c682976bf36a6d296be636d3090a7ce302179d",
            "filename": "packages/next/src/export/types.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/f0d81f1468e882edd48270b3f4989e15560f65dc/packages%2Fnext%2Fsrc%2Fexport%2Ftypes.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f0d81f1468e882edd48270b3f4989e15560f65dc/packages%2Fnext%2Fsrc%2Fexport%2Ftypes.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fexport%2Ftypes.ts?ref=f0d81f1468e882edd48270b3f4989e15560f65dc",
            "patch": "@@ -70,7 +70,7 @@ export type ExportRouteResult =\n       cacheControl: CacheControl\n       metadata?: Partial<RouteMetadata>\n       ssgNotFound?: boolean\n-      hasEmptyPrelude?: boolean\n+      hasEmptyStaticShell?: boolean\n       hasPostponed?: boolean\n       fetchMetrics?: FetchMetrics\n     }\n@@ -135,9 +135,9 @@ export type ExportAppResult = {\n        */\n       metadata?: Partial<RouteMetadata>\n       /**\n-       * If the page has an empty prelude when using PPR.\n+       * If the page has an empty static shell when using PPR.\n        */\n-      hasEmptyPrelude?: boolean\n+      hasEmptyStaticShell?: boolean\n       /**\n        * If the page has postponed when using PPR.\n        */"
        },
        {
            "sha": "5358b5d7de140d33903ba3c1b5b9212590dc1dd8",
            "filename": "packages/next/src/export/worker.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 1,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/f0d81f1468e882edd48270b3f4989e15560f65dc/packages%2Fnext%2Fsrc%2Fexport%2Fworker.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f0d81f1468e882edd48270b3f4989e15560f65dc/packages%2Fnext%2Fsrc%2Fexport%2Fworker.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fexport%2Fworker.ts?ref=f0d81f1468e882edd48270b3f4989e15560f65dc",
            "patch": "@@ -109,6 +109,10 @@ async function exportPageImpl(\n     // result, we just want to use it to error the build if there's a problem.\n     _isProspectiveRender: isProspectiveRender = false,\n \n+    // Configure the rendering of the page not to throw if an empty static shell\n+    // is generated while rendering using PPR.\n+    _doNotThrowOnEmptyStaticShell: doNotThrowOnEmptyStaticShell = false,\n+\n     // Pull the original query out.\n     query: originalQuery = {},\n   } = pathMap\n@@ -267,6 +271,7 @@ async function exportPageImpl(\n     // If it's static, then it won't affect anything.\n     // If it's dynamic, then it can be handled when request hits the route.\n     serveStreamingMetadata: true,\n+    doNotThrowOnEmptyStaticShell,\n     experimental: {\n       ...input.renderOpts.experimental,\n       isRoutePPREnabled,\n@@ -590,7 +595,7 @@ async function exportPage(\n     cacheControl: result.cacheControl,\n     metadata: result.metadata,\n     ssgNotFound: result.ssgNotFound,\n-    hasEmptyPrelude: result.hasEmptyPrelude,\n+    hasEmptyStaticShell: result.hasEmptyStaticShell,\n     hasPostponed: result.hasPostponed,\n     turborepoAccessTraceResult: turborepoAccessTraceResult.serialize(),\n     fetchMetrics: result.fetchMetrics,"
        },
        {
            "sha": "67325a6803c80eb6086284b0bab2d50b9e1904f7",
            "filename": "packages/next/src/server/app-render/app-render.tsx",
            "status": "modified",
            "additions": 16,
            "deletions": 7,
            "changes": 23,
            "blob_url": "https://github.com/vercel/next.js/blob/f0d81f1468e882edd48270b3f4989e15560f65dc/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/f0d81f1468e882edd48270b3f4989e15560f65dc/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx?ref=f0d81f1468e882edd48270b3f4989e15560f65dc",
            "patch": "@@ -132,7 +132,7 @@ import {\n   createDynamicValidationState,\n   getFirstDynamicReason,\n   trackAllowedDynamicAccess,\n-  throwIfDisallowedEmptyShell,\n+  throwIfDisallowedEmptyStaticShell,\n   consumeDynamicAccess,\n   type DynamicAccess,\n } from './dynamic-rendering'\n@@ -2550,8 +2550,11 @@ async function spawnDynamicValidationInDev(\n \n   function LogDynamicValidation() {\n     try {\n-      if (preludeIsEmpty) {\n-        throwIfDisallowedEmptyShell(\n+      // If we've disabled throwing on empty static shell, then we don't need to\n+      // track any dynamic access that occurs above the suspense boundary because\n+      // we'll do so in the route shell.\n+      if (preludeIsEmpty && !ctx.renderOpts.doNotThrowOnEmptyStaticShell) {\n+        throwIfDisallowedEmptyStaticShell(\n           route,\n           dynamicValidation,\n           serverDynamicTracking,\n@@ -3085,8 +3088,11 @@ async function prerenderToStream(\n         const { prelude, preludeIsEmpty } =\n           await processPrelude(unprocessedPrelude)\n \n-        if (preludeIsEmpty) {\n-          throwIfDisallowedEmptyShell(\n+        // If we've disabled throwing on empty static shell, then we don't need to\n+        // track any dynamic access that occurs above the suspense boundary because\n+        // we'll do so in the route shell.\n+        if (preludeIsEmpty && !ctx.renderOpts.doNotThrowOnEmptyStaticShell) {\n+          throwIfDisallowedEmptyStaticShell(\n             workStore.route,\n             dynamicValidation,\n             serverDynamicTracking,\n@@ -3568,9 +3574,12 @@ async function prerenderToStream(\n           }\n         }\n \n-        if (preludeIsEmpty) {\n+        // If we've disabled throwing on empty static shell, then we don't need to\n+        // track any dynamic access that occurs above the suspense boundary because\n+        // we'll do so in the route shell.\n+        if (preludeIsEmpty && !ctx.renderOpts.doNotThrowOnEmptyStaticShell) {\n           // We don't have a shell because the root errored when we aborted.\n-          throwIfDisallowedEmptyShell(\n+          throwIfDisallowedEmptyStaticShell(\n             workStore.route,\n             dynamicValidation,\n             serverDynamicTracking,"
        },
        {
            "sha": "79c87748e771e91c1d208d8db7e7c6ce5e075ff2",
            "filename": "packages/next/src/server/app-render/dynamic-rendering.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/f0d81f1468e882edd48270b3f4989e15560f65dc/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fdynamic-rendering.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f0d81f1468e882edd48270b3f4989e15560f65dc/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fdynamic-rendering.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fdynamic-rendering.ts?ref=f0d81f1468e882edd48270b3f4989e15560f65dc",
            "patch": "@@ -647,7 +647,7 @@ function createErrorWithComponentStack(\n   return error\n }\n \n-export function throwIfDisallowedEmptyShell(\n+export function throwIfDisallowedEmptyStaticShell(\n   route: string,\n   dynamicValidation: DynamicValidationState,\n   serverDynamic: DynamicTrackingState,\n@@ -688,7 +688,7 @@ export function throwIfDisallowedEmptyShell(\n   // blocked the root. We would have captured these during the prerender\n   // and can log them here and then terminate the build/validating render\n   const dynamicErrors = dynamicValidation.dynamicErrors\n-  if (dynamicErrors.length) {\n+  if (dynamicErrors.length > 0) {\n     for (let i = 0; i < dynamicErrors.length; i++) {\n       console.error(dynamicErrors[i])\n     }"
        },
        {
            "sha": "7b3edfcaab04868ae0236e0069b07dedb38b2428",
            "filename": "packages/next/src/server/app-render/types.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/f0d81f1468e882edd48270b3f4989e15560f65dc/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Ftypes.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f0d81f1468e882edd48270b3f4989e15560f65dc/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Ftypes.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Ftypes.ts?ref=f0d81f1468e882edd48270b3f4989e15560f65dc",
            "patch": "@@ -262,6 +262,13 @@ export interface RenderOptsPartial {\n   reactMaxHeadersLength: number | undefined\n \n   isStaticGeneration?: boolean\n+\n+  /**\n+   * When true, the page will be rendered using the static rendering to detect\n+   * any dynamic API's that would have stopped the page from being fully\n+   * statically generated.\n+   */\n+  doNotThrowOnEmptyStaticShell?: boolean\n }\n \n export type RenderOpts = LoadComponentsReturnType<AppPageModule> &"
        },
        {
            "sha": "95dfed2621a52c6dc8a4fee6684b3b18564c302e",
            "filename": "packages/next/src/server/config-schema.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/f0d81f1468e882edd48270b3f4989e15560f65dc/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-schema.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f0d81f1468e882edd48270b3f4989e15560f65dc/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-schema.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-schema.ts?ref=f0d81f1468e882edd48270b3f4989e15560f65dc",
            "patch": "@@ -41,6 +41,7 @@ const zExportMap: zod.ZodType<ExportPathMap> = z.record(\n     _isDynamicError: z.boolean().optional(),\n     _isRoutePPREnabled: z.boolean().optional(),\n     _isProspectiveRender: z.boolean().optional(),\n+    _doNotThrowOnEmptyStaticShell: z.boolean().optional(),\n   })\n )\n "
        },
        {
            "sha": "5338af57cbf21b455a6dd132f9b7e964cd63edce",
            "filename": "packages/next/src/server/config-shared.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/f0d81f1468e882edd48270b3f4989e15560f65dc/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f0d81f1468e882edd48270b3f4989e15560f65dc/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts?ref=f0d81f1468e882edd48270b3f4989e15560f65dc",
            "patch": "@@ -719,6 +719,15 @@ export type ExportPathMap = {\n      * @internal\n      */\n     _isProspectiveRender?: boolean\n+\n+    /**\n+     * When true, it indicates that the diagnostic render for this page is\n+     * disabled. This is only used when the app has `experimental.ppr` and\n+     * `experimental.dynamicIO` enabled.\n+     *\n+     * @internal\n+     */\n+    _doNotThrowOnEmptyStaticShell?: boolean\n   }\n }\n "
        },
        {
            "sha": "aa74c6b2a1926a2bc77ce0b50d1fd79f9aed98e8",
            "filename": "test/e2e/app-dir/empty-fallback-shells/app/[slug]/page.jsx",
            "status": "added",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/f0d81f1468e882edd48270b3f4989e15560f65dc/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2F%5Bslug%5D%2Fpage.jsx",
            "raw_url": "https://github.com/vercel/next.js/raw/f0d81f1468e882edd48270b3f4989e15560f65dc/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2F%5Bslug%5D%2Fpage.jsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2F%5Bslug%5D%2Fpage.jsx?ref=f0d81f1468e882edd48270b3f4989e15560f65dc",
            "patch": "@@ -0,0 +1,8 @@\n+export default async function Page({ params }) {\n+  const { slug } = await params\n+  return <div data-testid={`hello-${slug}`}>Hello /{slug}</div>\n+}\n+\n+export async function generateStaticParams() {\n+  return [{ slug: 'foo' }]\n+}"
        },
        {
            "sha": "b2e098a76134eae53c547420ae93aca2644e2da3",
            "filename": "test/e2e/app-dir/empty-fallback-shells/app/layout.jsx",
            "status": "added",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/f0d81f1468e882edd48270b3f4989e15560f65dc/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Flayout.jsx",
            "raw_url": "https://github.com/vercel/next.js/raw/f0d81f1468e882edd48270b3f4989e15560f65dc/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Flayout.jsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Flayout.jsx?ref=f0d81f1468e882edd48270b3f4989e15560f65dc",
            "patch": "@@ -0,0 +1,11 @@\n+import { Suspense } from 'react'\n+\n+export default function Layout({ children }) {\n+  return (\n+    <html>\n+      <Suspense>\n+        <body>{children}</body>\n+      </Suspense>\n+    </html>\n+  )\n+}"
        },
        {
            "sha": "04089778ea269aa0e656937d8c6ac7f1674dd834",
            "filename": "test/e2e/app-dir/empty-fallback-shells/empty-fallback-shells.test.ts",
            "status": "added",
            "additions": 21,
            "deletions": 0,
            "changes": 21,
            "blob_url": "https://github.com/vercel/next.js/blob/f0d81f1468e882edd48270b3f4989e15560f65dc/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fempty-fallback-shells.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f0d81f1468e882edd48270b3f4989e15560f65dc/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fempty-fallback-shells.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fempty-fallback-shells.test.ts?ref=f0d81f1468e882edd48270b3f4989e15560f65dc",
            "patch": "@@ -0,0 +1,21 @@\n+import { nextTestSetup } from 'e2e-utils'\n+\n+describe('empty-fallback-shells', () => {\n+  const { next, isNextDeploy } = nextTestSetup({\n+    files: __dirname,\n+  })\n+\n+  it('should start and not postpone the response', async () => {\n+    const res = await next.fetch('/world')\n+    const html = await res.text()\n+    expect(html).toContain('hello-world')\n+\n+    if (isNextDeploy) {\n+      expect(res.headers.get('x-matched-path')).toBe('/[slug]')\n+    }\n+\n+    // If we didn't use the fallback shell, then we didn't postpone the response\n+    // and therefore shouldn't have sent the postponed header.\n+    expect(res.headers.get('x-nextjs-postponed')).not.toBe('1')\n+  })\n+})"
        },
        {
            "sha": "b0b2ad8d2353113aff6d470986e1d9fdf7e55556",
            "filename": "test/e2e/app-dir/empty-fallback-shells/next.config.js",
            "status": "added",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/f0d81f1468e882edd48270b3f4989e15560f65dc/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fnext.config.js",
            "raw_url": "https://github.com/vercel/next.js/raw/f0d81f1468e882edd48270b3f4989e15560f65dc/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fnext.config.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fnext.config.js?ref=f0d81f1468e882edd48270b3f4989e15560f65dc",
            "patch": "@@ -0,0 +1,11 @@\n+/**\n+ * @type {import('next').NextConfig}\n+ */\n+const nextConfig = {\n+  experimental: {\n+    dynamicIO: true,\n+    ppr: true,\n+  },\n+}\n+\n+module.exports = nextConfig"
        }
    ],
    "stats": {
        "total": 505,
        "additions": 415,
        "deletions": 90
    }
}