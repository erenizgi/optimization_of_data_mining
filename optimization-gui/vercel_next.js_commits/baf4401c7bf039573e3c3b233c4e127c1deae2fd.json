{
    "author": "mischnic",
    "message": "Turbopack: fix client reference order for shared references (#84760)\n\nAt first, we performed one naive traversal per page to collect all client references. That had the problem that references used by multiple layout segments were attributed only to the first layout segment (e.g. only on `not-found` and not on `page`). Because the traversal doesn't revisit nodes.\r\n\r\nThat particular problem was fixed by https://github.com/vercel/next.js/pull/81704. But it didn't consider the fact that the order of client references isn't correctly modelled by having a `client reference -> vec<server components>` mapping to fixup whatever the graph traversal missed.\r\n\r\nIn this particular case, layout segment B had a unique client reference and one shared with layout segment A. So the fixup from above would then make B have `unique reference, shared reference` (because they were just added at the end), even though the real order (according to the graph is the reverse).\r\n\r\nInstead, traverse once per layout segment, which doesn't have this problem.",
    "sha": "baf4401c7bf039573e3c3b233c4e127c1deae2fd",
    "files": [
        {
            "sha": "0a4a8ac0c4c698f521d043e98d8d5aff293c6311",
            "filename": "crates/next-api/src/client_references.rs",
            "status": "modified",
            "additions": 7,
            "deletions": 134,
            "changes": 141,
            "blob_url": "https://github.com/vercel/next.js/blob/baf4401c7bf039573e3c3b233c4e127c1deae2fd/crates%2Fnext-api%2Fsrc%2Fclient_references.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/baf4401c7bf039573e3c3b233c4e127c1deae2fd/crates%2Fnext-api%2Fsrc%2Fclient_references.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fclient_references.rs?ref=baf4401c7bf039573e3c3b233c4e127c1deae2fd",
            "patch": "@@ -3,21 +3,13 @@ use next_core::{\n     next_client_reference::{CssClientReferenceModule, EcmascriptClientReferenceModule},\n     next_server_component::server_component_module::NextServerComponentModule,\n };\n-use roaring::RoaringBitmap;\n use rustc_hash::FxHashMap;\n use serde::{Deserialize, Serialize};\n use turbo_tasks::{\n-    FxIndexSet, NonLocalValue, ResolvedVc, TryFlatJoinIterExt, Vc, debug::ValueDebugFormat,\n-    trace::TraceRawVcs,\n+    NonLocalValue, ResolvedVc, TryFlatJoinIterExt, Vc, debug::ValueDebugFormat, trace::TraceRawVcs,\n };\n use turbopack::css::chunk::CssChunkPlaceable;\n-use turbopack_core::{\n-    module::Module,\n-    module_graph::{\n-        GraphTraversalAction, SingleModuleGraph, SingleModuleGraphModuleNode,\n-        chunk_group_info::RoaringBitmapWrapper,\n-    },\n-};\n+use turbopack_core::{module::Module, module_graph::SingleModuleGraph};\n \n #[derive(\n     Copy, Clone, Serialize, Deserialize, Eq, PartialEq, TraceRawVcs, ValueDebugFormat, NonLocalValue,\n@@ -31,42 +23,14 @@ pub enum ClientManifestEntryType {\n     ServerComponent(ResolvedVc<NextServerComponentModule>),\n }\n \n-/// Tracks information about all the css and js client references in the graph as well as how server\n-/// components depend on them.\n-#[turbo_tasks::value]\n-pub struct ClientReferenceManifest {\n-    pub manifest: FxHashMap<ResolvedVc<Box<dyn Module>>, ClientManifestEntryType>,\n-    // All the server components in the graph.\n-    server_components: FxIndexSet<ResolvedVc<NextServerComponentModule>>,\n-    // All the server components that depend on each module\n-    // This only includes mappings for modules with client references and the bitmaps reference\n-    // indices into `[server_components]`\n-    server_components_for_client_references:\n-        FxHashMap<ResolvedVc<Box<dyn Module>>, RoaringBitmapWrapper>,\n-}\n-\n-impl ClientReferenceManifest {\n-    /// Returns all the server components that depend on the given client reference\n-    pub fn server_components_for_client_reference(\n-        &self,\n-        module: ResolvedVc<Box<dyn Module>>,\n-    ) -> impl Iterator<Item = ResolvedVc<NextServerComponentModule>> {\n-        let bitmap = &self\n-            .server_components_for_client_references\n-            .get(&module)\n-            .expect(\"Module should be a client reference module\")\n-            .0;\n-\n-        bitmap\n-            .iter()\n-            .map(|index| *self.server_components.get_index(index as usize).unwrap())\n-    }\n-}\n+/// Tracks information about all the css and js client references in the graph.\n+#[turbo_tasks::value(transparent)]\n+pub struct ClientReferenceData(FxHashMap<ResolvedVc<Box<dyn Module>>, ClientManifestEntryType>);\n \n #[turbo_tasks::function]\n pub async fn map_client_references(\n     graph: Vc<SingleModuleGraph>,\n-) -> Result<Vc<ClientReferenceManifest>> {\n+) -> Result<Vc<ClientReferenceData>> {\n     let graph = graph.await?;\n     let manifest = graph\n         .iter_nodes()\n@@ -108,96 +72,5 @@ pub async fn map_client_references(\n         .into_iter()\n         .collect::<FxHashMap<_, _>>();\n \n-    let mut server_components = FxIndexSet::default();\n-    let mut module_to_server_component_bits = FxHashMap::default();\n-    if !manifest.is_empty() {\n-        graph.traverse_edges_from_entries_fixed_point(\n-            graph.entry_modules(),\n-            |parent_info, node| {\n-                let module = node.module();\n-                let module_type = manifest.get(&module);\n-                let mut should_visit_children = match module_to_server_component_bits.entry(module)\n-                {\n-                    std::collections::hash_map::Entry::Occupied(_) => false,\n-                    std::collections::hash_map::Entry::Vacant(vacant_entry) => {\n-                        // only do this the first time we visit the node.\n-                        let bits = vacant_entry.insert(RoaringBitmap::new());\n-                        if let Some(ClientManifestEntryType::ServerComponent(\n-                            server_component_module,\n-                        )) = module_type\n-                        {\n-                            let index = server_components.insert_full(*server_component_module).0;\n-\n-                            bits.insert(index.try_into().unwrap());\n-                        }\n-                        true\n-                    }\n-                };\n-                if let Some((SingleModuleGraphModuleNode{module: parent_module}, _)) = parent_info\n-                    // Skip self cycles such as in\n-                    // test/e2e/app-dir/dynamic-import/app/page.tsx where a very-dynamic import induces a\n-                    // self cycle. They don't introduce new bits anyway.\n-                    && module != *parent_module\n-                {\n-                    // Copy parent bits down.  `traverse_edges_from_entries_fixed_point` always\n-                    // visits parents before children so we can simply assert\n-                    // that the parent it set.\n-                    let [Some(current), Some(parent)] =\n-                        module_to_server_component_bits.get_disjoint_mut([&module, parent_module])\n-                    else {\n-                        unreachable!()\n-                    };\n-                    // Check if we are adding new bits and thus need to revisit children unless we\n-                    // are already planning to because this is a new node.\n-                    if !should_visit_children {\n-                        let len = current.len();\n-                        *current |= &*parent;\n-                        // did we find new bits? If so visit the children again\n-                        should_visit_children = len != current.len();\n-                    } else {\n-                        *current |= &*parent;\n-                    }\n-                }\n-\n-                Ok(match module_type {\n-                    Some(\n-                        ClientManifestEntryType::EcmascriptClientReference { .. }\n-                        | ClientManifestEntryType::CssClientReference { .. },\n-                    ) => {\n-                        // No need to explore these subgraphs ever, these are the leaves in the\n-                        // server component graph\n-                        GraphTraversalAction::Skip\n-                    }\n-                    // Continue on server components and through graphs of non-ClientReference\n-                    // modules, but only if our set of parent components has changed.\n-                    _ => {\n-                        if should_visit_children {\n-                            GraphTraversalAction::Continue\n-                        } else {\n-                            GraphTraversalAction::Skip\n-                        }\n-                    }\n-                })\n-            },\n-        )?;\n-    }\n-\n-    // Filter down to just the client reference modules to reduce datastructure size\n-    let server_components_for_client_references = module_to_server_component_bits\n-        .into_iter()\n-        .filter_map(|(k, v)| match manifest.get(&k) {\n-            Some(\n-                ClientManifestEntryType::CssClientReference(_)\n-                | ClientManifestEntryType::EcmascriptClientReference { .. },\n-            ) => Some((k, RoaringBitmapWrapper(v))),\n-            _ => None,\n-        })\n-        .collect();\n-\n-    Ok(ClientReferenceManifest {\n-        manifest,\n-        server_components,\n-        server_components_for_client_references,\n-    }\n-    .cell())\n+    Ok(Vc::cell(manifest))\n }"
        },
        {
            "sha": "4409a1d7d8b5478ed63613387e0228fcaf58246c",
            "filename": "crates/next-api/src/module_graph.rs",
            "status": "modified",
            "additions": 81,
            "deletions": 94,
            "changes": 175,
            "blob_url": "https://github.com/vercel/next.js/blob/baf4401c7bf039573e3c3b233c4e127c1deae2fd/crates%2Fnext-api%2Fsrc%2Fmodule_graph.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/baf4401c7bf039573e3c3b233c4e127c1deae2fd/crates%2Fnext-api%2Fsrc%2Fmodule_graph.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fmodule_graph.rs?ref=baf4401c7bf039573e3c3b233c4e127c1deae2fd",
            "patch": "@@ -1,4 +1,4 @@\n-use std::{borrow::Cow, collections::hash_map::Entry};\n+use std::borrow::Cow;\n \n use anyhow::{Ok, Result};\n use either::Either;\n@@ -28,7 +28,7 @@ use turbopack_core::{\n };\n \n use crate::{\n-    client_references::{ClientManifestEntryType, ClientReferenceManifest, map_client_references},\n+    client_references::{ClientManifestEntryType, ClientReferenceData, map_client_references},\n     dynamic_imports::{DynamicImportEntries, DynamicImportEntriesMapType, map_next_dynamic},\n     server_actions::{AllActions, AllModuleActions, map_server_actions, to_rsc_context},\n };\n@@ -244,7 +244,7 @@ pub struct ClientReferencesGraph {\n     is_single_page: bool,\n     graph: ResolvedVc<SingleModuleGraph>,\n     /// List of client references (modules that entries into the client graph)\n-    data: ResolvedVc<ClientReferenceManifest>,\n+    data: ResolvedVc<ClientReferenceData>,\n }\n \n #[turbo_tasks::value_impl]\n@@ -289,129 +289,116 @@ impl ClientReferencesGraph {\n             // Because we care about 'evaluation order' we need to collect client references in the\n             // post_order callbacks which is the same as evaluation order\n             let mut client_references = Vec::new();\n-            let mut client_reference_modules = Vec::new();\n-            let mut server_components = FxIndexSet::default();\n             let mut server_utils = FxIndexSet::default();\n \n-            // Track how we reached each client reference.  This way if a client reference is\n-            // referenced by the root and by a server component we don't only associate it with the\n-            // server component.\n-            #[derive(PartialEq, Eq, Copy, Clone)]\n-            enum ParentType {\n-                ServerComponent,\n-                Page,\n-                Both,\n-            }\n-            impl ParentType {\n-                fn merge(left: Self, right: Self) -> Self {\n-                    if left == right {\n-                        left\n-                    } else {\n-                        // One is Both or one is ServerComponent and the other is Page, which means\n-                        // Both\n-                        Self::Both\n-                    }\n-                }\n-            }\n-            // Perform a DFS traversal to collect all client references and the set of server\n-            // components for each module.\n-            graph.traverse_edges_from_entries_dfs(\n-                entries,\n-                // state_map is `module -> ParentType` to track whether the module is reachable\n-                // directly from an entry point.\n-                &mut FxHashMap::default(),\n-                |parent_info, node, state_map| {\n-                    let module = node.module();\n-                    let module_type = data.manifest.get(&module);\n-\n-                    let parent_type =\n-                        if let Some(ClientManifestEntryType::ServerComponent(_)) = module_type {\n-                            ParentType::ServerComponent\n-                        } else if let Some((parent_node, _)) = parent_info {\n-                            *state_map.get(&parent_node.module).unwrap()\n-                        } else {\n-                            // a root node\n-                            ParentType::Page\n-                        };\n-\n-                    match state_map.entry(module) {\n-                        Entry::Occupied(mut occupied_entry) => {\n-                            let current = occupied_entry.get_mut();\n-                            let merged = ParentType::merge(*current, parent_type);\n-                            if merged != parent_type {\n-                                *current = merged;\n-                            }\n-                        }\n-                        Entry::Vacant(vacant_entry) => {\n-                            vacant_entry.insert(parent_type);\n-                        }\n-                    }\n+            let mut server_components = FxIndexSet::default();\n \n+            // Perform a DFS traversal to find all server components included by this page.\n+            graph.traverse_nodes_from_entries(\n+                entries,\n+                &mut (),\n+                |node, _| {\n+                    let module_type = data.get(&node.module);\n                     Ok(match module_type {\n                         Some(\n                             ClientManifestEntryType::EcmascriptClientReference { .. }\n-                            | ClientManifestEntryType::CssClientReference { .. },\n+                            | ClientManifestEntryType::CssClientReference { .. }\n+                            | ClientManifestEntryType::ServerComponent { .. },\n                         ) => GraphTraversalAction::Skip,\n-                        _ => GraphTraversalAction::Continue,\n+                        None => GraphTraversalAction::Continue,\n                     })\n                 },\n-                |_, node, state_map| {\n-                    let module = node.module();\n+                |node, _| {\n                     if let Some(server_util_module) =\n-                        ResolvedVc::try_downcast_type::<NextServerUtilityModule>(module)\n+                        ResolvedVc::try_downcast_type::<NextServerUtilityModule>(node.module)\n                     {\n+                        // Server utility used by the template, not a server component\n                         server_utils.insert(server_util_module);\n+                        return Ok(());\n                     }\n \n-                    let Some(module_type) = data.manifest.get(&module) else {\n-                        return Ok(());\n-                    };\n+                    let module_type = data.get(&node.module);\n \n                     let ty = match module_type {\n-                        ClientManifestEntryType::EcmascriptClientReference {\n+                        Some(ClientManifestEntryType::EcmascriptClientReference {\n                             module,\n                             ssr_module: _,\n-                        } => ClientReferenceType::EcmascriptClientReference(*module),\n-                        ClientManifestEntryType::CssClientReference(module) => {\n+                        }) => ClientReferenceType::EcmascriptClientReference(*module),\n+                        Some(ClientManifestEntryType::CssClientReference(module)) => {\n                             ClientReferenceType::CssClientReference(*module)\n                         }\n-                        ClientManifestEntryType::ServerComponent(sc) => {\n+                        Some(ClientManifestEntryType::ServerComponent(sc)) => {\n                             server_components.insert(*sc);\n                             return Ok(());\n                         }\n+                        None => {\n+                            return Ok(());\n+                        }\n                     };\n \n-                    if *state_map.get(&module).unwrap() == ParentType::ServerComponent {\n-                        // This is only reachable through server components, we need to wait to\n-                        // compute the client references until we have seen all server components\n-                        // reachable by this entrypoint, then we can intersect that with the set of\n-                        // server components that depend on this client reference\n-                        client_reference_modules.push((module, ty));\n-                    } else {\n-                        // Otherwise there is some path from the root directly to the reference,\n-                        // just associate it with the root.\n-                        client_references.push(ClientReference {\n-                            server_component: None,\n-                            ty,\n-                        })\n-                    }\n+                    // Client reference used by the template, not a server component\n+                    client_references.push(ClientReference {\n+                        server_component: None,\n+                        ty,\n+                    });\n \n                     Ok(())\n                 },\n             )?;\n \n-            // Now compute all the parent components for each client reference module reachable from\n-            // server components\n-            client_references.extend(client_reference_modules.into_iter().flat_map(\n-                |(module, ty)| {\n-                    data.server_components_for_client_reference(module)\n-                        .filter(|sc| server_components.contains(sc))\n-                        .map(move |sc| ClientReference {\n+            // Traverse each server component separately. Because not all server components are\n+            // necessarily rendered at the same time (not-found, or parallel routes), we need to\n+            // determine the order of client references individually for each server component.\n+            for sc in server_components.iter().copied() {\n+                graph.traverse_nodes_from_entries(\n+                    std::iter::once(ResolvedVc::upcast(sc)),\n+                    &mut (),\n+                    |node, _| {\n+                        let module = node.module;\n+                        let module_type = data.get(&module);\n+\n+                        Ok(match module_type {\n+                            Some(\n+                                ClientManifestEntryType::EcmascriptClientReference { .. }\n+                                | ClientManifestEntryType::CssClientReference { .. },\n+                            ) => GraphTraversalAction::Skip,\n+                            _ => GraphTraversalAction::Continue,\n+                        })\n+                    },\n+                    |node, _| {\n+                        let module = node.module;\n+                        if let Some(server_util_module) =\n+                            ResolvedVc::try_downcast_type::<NextServerUtilityModule>(module)\n+                        {\n+                            server_utils.insert(server_util_module);\n+                        }\n+\n+                        let Some(module_type) = data.get(&module) else {\n+                            return Ok(());\n+                        };\n+\n+                        let ty = match module_type {\n+                            ClientManifestEntryType::EcmascriptClientReference {\n+                                module,\n+                                ssr_module: _,\n+                            } => ClientReferenceType::EcmascriptClientReference(*module),\n+                            ClientManifestEntryType::CssClientReference(module) => {\n+                                ClientReferenceType::CssClientReference(*module)\n+                            }\n+                            ClientManifestEntryType::ServerComponent(_) => {\n+                                return Ok(());\n+                            }\n+                        };\n+\n+                        client_references.push(ClientReference {\n                             server_component: Some(sc),\n                             ty,\n-                        })\n-                },\n-            ));\n+                        });\n+\n+                        Ok(())\n+                    },\n+                )?;\n+            }\n \n             Ok(ClientReferenceGraphResult {\n                 client_references: client_references.into_iter().collect(),"
        },
        {
            "sha": "6b3be600ef0307279f4df682fe8348f09fa1ee17",
            "filename": "crates/next-core/src/next_client_reference/visit_client_reference.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/baf4401c7bf039573e3c3b233c4e127c1deae2fd/crates%2Fnext-core%2Fsrc%2Fnext_client_reference%2Fvisit_client_reference.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/baf4401c7bf039573e3c3b233c4e127c1deae2fd/crates%2Fnext-core%2Fsrc%2Fnext_client_reference%2Fvisit_client_reference.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_client_reference%2Fvisit_client_reference.rs?ref=baf4401c7bf039573e3c3b233c4e127c1deae2fd",
            "patch": "@@ -53,6 +53,9 @@ impl ClientReference {\n     }\n }\n \n+#[turbo_tasks::value(transparent)]\n+pub struct ClientReferences(Vec<ClientReference>);\n+\n #[derive(\n     Copy,\n     Clone,"
        },
        {
            "sha": "0a7068bd3723393c896f1878601837db9a9e4b01",
            "filename": "test/e2e/app-dir/initial-css-order/app/global-not-found.tsx",
            "status": "added",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/baf4401c7bf039573e3c3b233c4e127c1deae2fd/test%2Fe2e%2Fapp-dir%2Finitial-css-order%2Fapp%2Fglobal-not-found.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/baf4401c7bf039573e3c3b233c4e127c1deae2fd/test%2Fe2e%2Fapp-dir%2Finitial-css-order%2Fapp%2Fglobal-not-found.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Finitial-css-order%2Fapp%2Fglobal-not-found.tsx?ref=baf4401c7bf039573e3c3b233c4e127c1deae2fd",
            "patch": "@@ -0,0 +1,11 @@\n+import './red.css'\n+\n+export default function GlobalNotFound() {\n+  return (\n+    <html lang=\"en\" suppressHydrationWarning>\n+      <body>\n+        <span>not found</span>\n+      </body>\n+    </html>\n+  )\n+}"
        },
        {
            "sha": "9d9d772fb468756d1a90f72325f89cd372f812ef",
            "filename": "test/e2e/app-dir/initial-css-order/app/green.css",
            "status": "added",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/baf4401c7bf039573e3c3b233c4e127c1deae2fd/test%2Fe2e%2Fapp-dir%2Finitial-css-order%2Fapp%2Fgreen.css",
            "raw_url": "https://github.com/vercel/next.js/raw/baf4401c7bf039573e3c3b233c4e127c1deae2fd/test%2Fe2e%2Fapp-dir%2Finitial-css-order%2Fapp%2Fgreen.css",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Finitial-css-order%2Fapp%2Fgreen.css?ref=baf4401c7bf039573e3c3b233c4e127c1deae2fd",
            "patch": "@@ -0,0 +1,3 @@\n+body {\n+  background-color: green;\n+}"
        },
        {
            "sha": "9e1584722bed7a15156a9dca4ec6289412d7484b",
            "filename": "test/e2e/app-dir/initial-css-order/app/layout.tsx",
            "status": "added",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/baf4401c7bf039573e3c3b233c4e127c1deae2fd/test%2Fe2e%2Fapp-dir%2Finitial-css-order%2Fapp%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/baf4401c7bf039573e3c3b233c4e127c1deae2fd/test%2Fe2e%2Fapp-dir%2Finitial-css-order%2Fapp%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Finitial-css-order%2Fapp%2Flayout.tsx?ref=baf4401c7bf039573e3c3b233c4e127c1deae2fd",
            "patch": "@@ -0,0 +1,14 @@\n+import './red.css'\n+import './green.css'\n+\n+export default async function RootLayout({\n+  children,\n+}: Readonly<{\n+  children: React.ReactNode\n+}>) {\n+  return (\n+    <html lang=\"en\">\n+      <body style={{ fontFamily: 'var(--font-sans)' }}>{children}</body>\n+    </html>\n+  )\n+}"
        },
        {
            "sha": "35f00755dc5a1b30f443a7f2bcd7873ebabbf101",
            "filename": "test/e2e/app-dir/initial-css-order/app/page.ts",
            "status": "added",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/baf4401c7bf039573e3c3b233c4e127c1deae2fd/test%2Fe2e%2Fapp-dir%2Finitial-css-order%2Fapp%2Fpage.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/baf4401c7bf039573e3c3b233c4e127c1deae2fd/test%2Fe2e%2Fapp-dir%2Finitial-css-order%2Fapp%2Fpage.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Finitial-css-order%2Fapp%2Fpage.ts?ref=baf4401c7bf039573e3c3b233c4e127c1deae2fd",
            "patch": "@@ -0,0 +1,3 @@\n+export default function Page() {\n+  return 'abc'\n+}"
        },
        {
            "sha": "aa1634c255034b34ae9be86a6a28b50d6e7d2af2",
            "filename": "test/e2e/app-dir/initial-css-order/app/red.css",
            "status": "added",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/baf4401c7bf039573e3c3b233c4e127c1deae2fd/test%2Fe2e%2Fapp-dir%2Finitial-css-order%2Fapp%2Fred.css",
            "raw_url": "https://github.com/vercel/next.js/raw/baf4401c7bf039573e3c3b233c4e127c1deae2fd/test%2Fe2e%2Fapp-dir%2Finitial-css-order%2Fapp%2Fred.css",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Finitial-css-order%2Fapp%2Fred.css?ref=baf4401c7bf039573e3c3b233c4e127c1deae2fd",
            "patch": "@@ -0,0 +1,3 @@\n+body {\n+  background-color: red;\n+}"
        },
        {
            "sha": "ca69a2efbc52dbedcb9f33c4528b1cf0e32fae5a",
            "filename": "test/e2e/app-dir/initial-css-order/initial-css-order.test.ts",
            "status": "added",
            "additions": 27,
            "deletions": 0,
            "changes": 27,
            "blob_url": "https://github.com/vercel/next.js/blob/baf4401c7bf039573e3c3b233c4e127c1deae2fd/test%2Fe2e%2Fapp-dir%2Finitial-css-order%2Finitial-css-order.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/baf4401c7bf039573e3c3b233c4e127c1deae2fd/test%2Fe2e%2Fapp-dir%2Finitial-css-order%2Finitial-css-order.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Finitial-css-order%2Finitial-css-order.test.ts?ref=baf4401c7bf039573e3c3b233c4e127c1deae2fd",
            "patch": "@@ -0,0 +1,27 @@\n+import { nextTestSetup } from 'e2e-utils'\n+\n+describe('initial-css-order', () => {\n+  const { next } = nextTestSetup({\n+    files: __dirname,\n+  })\n+\n+  it('should serve styles in the correct order for the page', async () => {\n+    const browser = await next.browser('/')\n+\n+    expect(\n+      await browser.eval(\n+        `window.getComputedStyle(document.querySelector('body')).backgroundColor`\n+      )\n+    ).toBe('rgb(0, 128, 0)')\n+  })\n+\n+  it('should serve styles in the correct order for global-not-found', async () => {\n+    const browser = await next.browser('/404')\n+\n+    expect(\n+      await browser.eval(\n+        `window.getComputedStyle(document.querySelector('body')).backgroundColor`\n+      )\n+    ).toBe('rgb(255, 0, 0)')\n+  })\n+})"
        },
        {
            "sha": "a198cf5a769a106aef77008e1dd3fc2e332aa98e",
            "filename": "test/e2e/app-dir/initial-css-order/next.config.js",
            "status": "added",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/baf4401c7bf039573e3c3b233c4e127c1deae2fd/test%2Fe2e%2Fapp-dir%2Finitial-css-order%2Fnext.config.js",
            "raw_url": "https://github.com/vercel/next.js/raw/baf4401c7bf039573e3c3b233c4e127c1deae2fd/test%2Fe2e%2Fapp-dir%2Finitial-css-order%2Fnext.config.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Finitial-css-order%2Fnext.config.js?ref=baf4401c7bf039573e3c3b233c4e127c1deae2fd",
            "patch": "@@ -0,0 +1,10 @@\n+/**\n+ * @type {import('next').NextConfig}\n+ */\n+const nextConfig = {\n+  experimental: {\n+    globalNotFound: true,\n+  },\n+}\n+\n+module.exports = nextConfig"
        },
        {
            "sha": "a0cb4960a87797304052ca8dcd1002723b0e8ecf",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/mod.rs",
            "status": "modified",
            "additions": 52,
            "deletions": 0,
            "changes": 52,
            "blob_url": "https://github.com/vercel/next.js/blob/baf4401c7bf039573e3c3b233c4e127c1deae2fd/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/baf4401c7bf039573e3c3b233c4e127c1deae2fd/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs?ref=baf4401c7bf039573e3c3b233c4e127c1deae2fd",
            "patch": "@@ -443,6 +443,58 @@ impl SingleModuleGraph {\n         Ok(())\n     }\n \n+    /// Traverses all reachable nodes once\n+    pub fn traverse_nodes_from_entries<'a, S>(\n+        &'a self,\n+        entries: impl IntoIterator<Item = ResolvedVc<Box<dyn Module>>>,\n+        state: &mut S,\n+        visit_preorder: impl Fn(&'a SingleModuleGraphModuleNode, &mut S) -> Result<GraphTraversalAction>,\n+        mut visit_postorder: impl FnMut(&'a SingleModuleGraphModuleNode, &mut S) -> Result<()>,\n+    ) -> Result<()> {\n+        let graph = &self.graph;\n+        let entries = entries.into_iter().map(|e| self.get_module(e).unwrap());\n+\n+        enum Pass {\n+            Visit,\n+            ExpandAndVisit,\n+        }\n+\n+        let mut stack: Vec<(Pass, NodeIndex)> =\n+            entries.map(|e| (Pass::ExpandAndVisit, e)).collect();\n+        let mut expanded = FxHashSet::default();\n+        while let Some((pass, current)) = stack.pop() {\n+            match pass {\n+                Pass::Visit => {\n+                    if let SingleModuleGraphNode::Module(current_node) =\n+                        graph.node_weight(current).unwrap()\n+                    {\n+                        visit_postorder(current_node, state)?;\n+                    }\n+                }\n+                Pass::ExpandAndVisit => {\n+                    if expanded.insert(current)\n+                        && let SingleModuleGraphNode::Module(current_node) =\n+                            graph.node_weight(current).unwrap()\n+                    {\n+                        let action = visit_preorder(current_node, state)?;\n+                        if action == GraphTraversalAction::Exclude {\n+                            continue;\n+                        }\n+                        stack.push((Pass::Visit, current));\n+                        if action == GraphTraversalAction::Continue {\n+                            stack.extend(\n+                                iter_neighbors_rev(graph, current)\n+                                    .map(|(_, child)| (Pass::ExpandAndVisit, child)),\n+                            );\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n     /// Traverses all reachable edges exactly once and calls the visitor with the edge source and\n     /// target.\n     ///"
        }
    ],
    "stats": {
        "total": 442,
        "additions": 214,
        "deletions": 228
    }
}