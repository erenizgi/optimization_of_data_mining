{
    "author": "wyattjoh",
    "message": "feat(build): optimize filterUniqueParamsCombinations to generate sub-combinations (#81321)\n\n### What?\n\nOptimizes the `generateParamPrefixCombinations` function (previously\n`filterUniqueRootParamsCombinations`) to generate all unique\nsub-combinations of route parameters while ensuring partial shells\ninclude complete sets of root parameters.\n\n### Why?\n\nThe previous implementation only generated combinations at the root\nparameter level, which was insufficient for PPR (Partial Prerendering)\nshells. PPR needs all possible prefix combinations of route parameters\nto create effective shells for nested routes. For example, for a route\n`/[lang]/[region]/[slug]`, we need shells for:\n- `/[lang]/[region]` (complete root params)\n- `/[lang]/[region]/[slug]` (full route)\n\nWithout proper sub-combinations, nested routes couldn't benefit from PPR\nshell optimization, leading to performance degradation.\n\n### How?\n\n- Renamed `filterUniqueRootParamsCombinations` to\n`generateParamPrefixCombinations` to better reflect its expanded\nfunctionality\n- Added logic to generate all prefix combinations of route parameters,\nnot just root-level combinations\n- Implemented root parameter validation to ensure partial shells only\ninclude complete sets of root parameters\n- Added comprehensive test coverage for edge cases including undefined\nparameters, missing keys, and parameter collisions\n- Optimized the algorithm to skip invalid combinations early when root\nparameters are incomplete\n\nThe function now generates prefix combinations systematically while\nmaintaining backward compatibility and preventing invalid partial\nroutes.\n\nNAR-159\n\n---------\n\nCo-authored-by: Hendrik Liebau <mail@hendrik-liebau.de>",
    "sha": "d884398da6c55f662115cd1b3ff19e72fb6bb8d5",
    "files": [
        {
            "sha": "f0a4a2d92f6cfc7de04be62aef19c1bd4e292d72",
            "filename": "packages/next/errors.json",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/d884398da6c55f662115cd1b3ff19e72fb6bb8d5/packages%2Fnext%2Ferrors.json",
            "raw_url": "https://github.com/vercel/next.js/raw/d884398da6c55f662115cd1b3ff19e72fb6bb8d5/packages%2Fnext%2Ferrors.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Ferrors.json?ref=d884398da6c55f662115cd1b3ff19e72fb6bb8d5",
            "patch": "@@ -719,5 +719,6 @@\n   \"718\": \"Invariant: projectDir is required for node runtime\",\n   \"719\": \"Failed to get source map for '%s'. This is a bug in Next.js\",\n   \"720\": \"A client prerender store should not be used for a route handler.\",\n-  \"721\": \"Render in Browser\"\n+  \"721\": \"Render in Browser\",\n+  \"722\": \"Unable to match pathname to a dynamic route\"\n }"
        },
        {
            "sha": "c203498fa7824d100fe675dc3ff4575cfc9eb590",
            "filename": "packages/next/src/build/index.ts",
            "status": "modified",
            "additions": 45,
            "deletions": 6,
            "changes": 51,
            "blob_url": "https://github.com/vercel/next.js/blob/d884398da6c55f662115cd1b3ff19e72fb6bb8d5/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d884398da6c55f662115cd1b3ff19e72fb6bb8d5/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts?ref=d884398da6c55f662115cd1b3ff19e72fb6bb8d5",
            "patch": "@@ -402,6 +402,13 @@ export type ManifestRoute = ManifestBuiltRoute & {\n   namedRegex?: string\n   routeKeys?: { [key: string]: string }\n   prefetchSegmentDataRoutes?: PrefetchSegmentDataRoute[]\n+\n+  /**\n+   * If true, this indicates that the route should not be considered for routing\n+   * for the internal router, and instead has been added to support external\n+   * routers.\n+   */\n+  skipInternalRouting?: boolean\n }\n \n type ManifestDataRoute = {\n@@ -3096,18 +3103,44 @@ export default async function build(\n                 }\n \n                 let prefetchDataRoute: string | undefined\n+                let dynamicRoute = routesManifest.dynamicRoutes.find(\n+                  (r) => r.page === route.pathname\n+                )\n                 if (!isAppRouteHandler && isAppPPREnabled) {\n                   prefetchDataRoute = path.posix.join(\n                     `${normalizedRoute}${RSC_PREFETCH_SUFFIX}`\n                   )\n+\n+                  // If the dynamic route wasn't found, then we need to create\n+                  // it. This ensures that for each fallback shell there's an\n+                  // entry in the app routes manifest which enables routing for\n+                  // this fallback shell.\n+                  if (!dynamicRoute) {\n+                    dynamicRoute = pageToRoute(route.pathname)\n+\n+                    // This route is not for the internal router, but instead\n+                    // for external routers.\n+                    dynamicRoute.skipInternalRouting = true\n+\n+                    // Push this to the end of the array. The dynamic routes are\n+                    // sorted by page later.\n+                    routesManifest.dynamicRoutes.push(dynamicRoute)\n+                  }\n                 }\n \n                 if (!isAppRouteHandler && metadata?.segmentPaths) {\n-                  const dynamicRoute = routesManifest.dynamicRoutes.find(\n-                    (r) => r.page === page\n-                  )\n+                  // If PPR isn't enabled, then we might not find the dynamic\n+                  // route by pathname. If that's the case, we need to find the\n+                  // route by page.\n                   if (!dynamicRoute) {\n-                    throw new Error('Dynamic route not found')\n+                    dynamicRoute = routesManifest.dynamicRoutes.find(\n+                      (r) => r.page === page\n+                    )\n+\n+                    // If it can't be found by page, we must throw an error.\n+                    if (!dynamicRoute) {\n+                      throw new InvariantError('Dynamic route not found')\n+                    }\n                   }\n \n                   dynamicRoute.prefetchSegmentDataRoutes ??= []\n@@ -3566,8 +3599,14 @@ export default async function build(\n           }\n         })\n \n-        // We need to write the manifest with rewrites after build as it might\n-        // have been modified.\n+        // As we may have modified the routesManifest.dynamicRoutes, we need to\n+        // sort the dynamic routes by page.\n+        routesManifest.dynamicRoutes = getSortedRouteObjects(\n+          routesManifest.dynamicRoutes,\n+          (route) => route.page\n+        )\n+\n+        // Now write the routes manifest out.\n         await nextBuildSpan\n           .traceChild('write-routes-manifest')\n           .traceAsyncFn(() => writeManifest(routesManifestPath, routesManifest))"
        },
        {
            "sha": "40da5dfa07a974d68bf3b934c9736ec43f0cef34",
            "filename": "packages/next/src/build/static-paths/app.test.ts",
            "status": "modified",
            "additions": 658,
            "deletions": 15,
            "changes": 673,
            "blob_url": "https://github.com/vercel/next.js/blob/d884398da6c55f662115cd1b3ff19e72fb6bb8d5/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d884398da6c55f662115cd1b3ff19e72fb6bb8d5/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp.test.ts?ref=d884398da6c55f662115cd1b3ff19e72fb6bb8d5",
            "patch": "@@ -1,10 +1,14 @@\n import { FallbackMode } from '../../lib/fallback'\n+import type { Params } from '../../server/request/params'\n import {\n   assignErrorIfEmpty,\n-  filterUniqueRootParamsCombinations,\n+  generateParamPrefixCombinations,\n   filterUniqueParams,\n+  generateRouteStaticParams,\n } from './app'\n import type { PrerenderedRoute } from './types'\n+import type { WorkStore } from '../../server/app-render/work-async-storage.external'\n+import type { AppSegment } from '../segment-config/app/app-segments'\n \n describe('assignErrorIfEmpty', () => {\n   it('should assign throwOnEmptyStaticShell true for a static route with no children', () => {\n@@ -111,14 +115,6 @@ describe('assignErrorIfEmpty', () => {\n     expect(prerenderedRoutes[4].throwOnEmptyStaticShell).toBe(false)\n   })\n \n-  it('should handle parameter value collisions', () => {\n-    const params = [{ slug: ['foo', 'bar'] }, { slug: 'foo,bar' }]\n-\n-    const unique = filterUniqueRootParamsCombinations(['slug'], params)\n-\n-    expect(unique).toEqual([{ slug: ['foo', 'bar'] }, { slug: 'foo,bar' }])\n-  })\n-\n   it('should handle multiple routes at the same trie node', () => {\n     const prerenderedRoutes: PrerenderedRoute[] = [\n       {\n@@ -352,35 +348,682 @@ describe('filterUniqueParams', () => {\n   })\n })\n \n-describe('filterUniqueRootParamsCombinations', () => {\n-  it('should return only the root parameters', () => {\n+describe('generateParamPrefixCombinations', () => {\n+  it('should return only the route parameters', () => {\n     const params = [\n       { id: '1', name: 'test' },\n       { id: '1', name: 'test' },\n       { id: '2', name: 'test' },\n     ]\n \n-    const unique = filterUniqueRootParamsCombinations(['id'], params)\n+    const unique = generateParamPrefixCombinations(['id'], params, [])\n \n     expect(unique).toEqual([{ id: '1' }, { id: '2' }])\n   })\n \n-  it('should handle multiple root parameters', () => {\n+  it('should handle multiple route parameters', () => {\n     const params = [\n       { lang: 'en', region: 'US', page: 'home' },\n       { lang: 'en', region: 'US', page: 'about' },\n       { lang: 'fr', region: 'CA', page: 'home' },\n       { lang: 'fr', region: 'CA', page: 'about' },\n     ]\n \n-    const unique = filterUniqueRootParamsCombinations(\n+    const unique = generateParamPrefixCombinations(\n       ['lang', 'region'],\n-      params\n+      params,\n+      []\n     )\n \n     expect(unique).toEqual([\n+      { lang: 'en' },\n       { lang: 'en', region: 'US' },\n+      { lang: 'fr' },\n       { lang: 'fr', region: 'CA' },\n     ])\n   })\n+\n+  it('should handle parameter value collisions', () => {\n+    const params = [{ slug: ['foo', 'bar'] }, { slug: 'foo,bar' }]\n+\n+    const unique = generateParamPrefixCombinations(['slug'], params, [])\n+\n+    expect(unique).toEqual([{ slug: ['foo', 'bar'] }, { slug: 'foo,bar' }])\n+  })\n+\n+  it('should handle empty inputs', () => {\n+    // Empty routeParamKeys\n+    expect(generateParamPrefixCombinations([], [{ id: '1' }], [])).toEqual([])\n+\n+    // Empty routeParams\n+    expect(generateParamPrefixCombinations(['id'], [], [])).toEqual([])\n+\n+    // Both empty\n+    expect(generateParamPrefixCombinations([], [], [])).toEqual([])\n+  })\n+\n+  it('should handle undefined parameters', () => {\n+    const params = [\n+      { id: '1', name: 'test' },\n+      { id: '2', name: undefined },\n+      { id: '3' }, // missing name key\n+    ]\n+\n+    const unique = generateParamPrefixCombinations(['id', 'name'], params, [])\n+\n+    expect(unique).toEqual([\n+      { id: '1' },\n+      { id: '1', name: 'test' },\n+      { id: '2' },\n+      { id: '3' },\n+    ])\n+  })\n+\n+  it('should handle missing parameter keys in objects', () => {\n+    const params = [\n+      { lang: 'en', region: 'US', category: 'tech' },\n+      { lang: 'en', region: 'US' }, // missing category\n+      { lang: 'fr' }, // missing region and category\n+    ]\n+\n+    const unique = generateParamPrefixCombinations(\n+      ['lang', 'region', 'category'],\n+      params,\n+      []\n+    )\n+\n+    expect(unique).toEqual([\n+      { lang: 'en' },\n+      { lang: 'en', region: 'US' },\n+      { lang: 'en', region: 'US', category: 'tech' },\n+      { lang: 'fr' },\n+    ])\n+  })\n+\n+  it('should prevent collisions with special characters', () => {\n+    const params = [\n+      { slug: ['foo', 'bar'] }, // Array: A:foo,bar\n+      { slug: 'foo,bar' }, // String: S:foo,bar\n+      { slug: 'A:foo,bar' }, // String that looks like array prefix\n+      { slug: ['A:foo', 'bar'] }, // Array with A: prefix in element\n+      { slug: undefined }, // Undefined: U:undefined\n+      { slug: 'U:undefined' }, // String that looks like undefined prefix\n+    ]\n+\n+    const unique = generateParamPrefixCombinations(['slug'], params, [])\n+\n+    expect(unique).toEqual([\n+      { slug: ['foo', 'bar'] },\n+      { slug: 'foo,bar' },\n+      { slug: 'A:foo,bar' },\n+      { slug: ['A:foo', 'bar'] },\n+      { slug: undefined },\n+      { slug: 'U:undefined' },\n+    ])\n+  })\n+\n+  it('should handle parameters with pipe characters', () => {\n+    const params = [\n+      { slug: 'foo|bar' }, // String with pipe\n+      { slug: ['foo', 'bar|baz'] }, // Array with pipe in element\n+    ]\n+\n+    const unique = generateParamPrefixCombinations(['slug'], params, [])\n+\n+    expect(unique).toEqual([{ slug: 'foo|bar' }, { slug: ['foo', 'bar|baz'] }])\n+  })\n+\n+  it('should handle deep parameter hierarchies', () => {\n+    const params = [\n+      { a: '1', b: '2', c: '3', d: '4', e: '5' },\n+      { a: '1', b: '2', c: '3', d: '4', e: '6' },\n+      { a: '1', b: '2', c: '3', d: '7' },\n+    ]\n+\n+    const unique = generateParamPrefixCombinations(\n+      ['a', 'b', 'c', 'd', 'e'],\n+      params,\n+      []\n+    )\n+\n+    // Should contain all the unique prefix combinations\n+    expect(unique).toEqual([\n+      { a: '1' },\n+      { a: '1', b: '2' },\n+      { a: '1', b: '2', c: '3' },\n+      { a: '1', b: '2', c: '3', d: '4' },\n+      { a: '1', b: '2', c: '3', d: '4', e: '5' },\n+      { a: '1', b: '2', c: '3', d: '4', e: '6' },\n+      { a: '1', b: '2', c: '3', d: '7' },\n+    ])\n+  })\n+\n+  it('should only generate combinations with complete root params', () => {\n+    const params = [\n+      { lang: 'en', region: 'US', slug: 'home' },\n+      { lang: 'en', region: 'US', slug: 'about' },\n+      { lang: 'fr', region: 'CA', slug: 'about' },\n+    ]\n+\n+    const unique = generateParamPrefixCombinations(\n+      ['lang', 'region', 'slug'],\n+      params,\n+      ['lang', 'region'] // Root params\n+    )\n+\n+    // Should NOT include partial combinations like { lang: 'en' }\n+    // Should only include combinations with complete root params\n+    expect(unique).toEqual([\n+      { lang: 'en', region: 'US' }, // Complete root params\n+      { lang: 'en', region: 'US', slug: 'home' },\n+      { lang: 'en', region: 'US', slug: 'about' },\n+      { lang: 'fr', region: 'CA' }, // Complete root params\n+      { lang: 'fr', region: 'CA', slug: 'about' },\n+    ])\n+  })\n+\n+  it('should handle routes without root params normally', () => {\n+    const params = [\n+      { category: 'tech', slug: 'news' },\n+      { category: 'tech', slug: 'reviews' },\n+      { category: 'sports', slug: 'news' },\n+    ]\n+\n+    const unique = generateParamPrefixCombinations(\n+      ['category', 'slug'],\n+      params,\n+      [] // No root params\n+    )\n+\n+    // Should generate all sub-combinations as before\n+    expect(unique).toEqual([\n+      { category: 'tech' },\n+      { category: 'tech', slug: 'news' },\n+      { category: 'tech', slug: 'reviews' },\n+      { category: 'sports' },\n+      { category: 'sports', slug: 'news' },\n+    ])\n+  })\n+\n+  it('should handle single root param', () => {\n+    const params = [\n+      { lang: 'en', page: 'home' },\n+      { lang: 'en', page: 'about' },\n+      { lang: 'fr', page: 'home' },\n+    ]\n+\n+    const unique = generateParamPrefixCombinations(\n+      ['lang', 'page'],\n+      params,\n+      ['lang'] // Single root param\n+    )\n+\n+    // Should include combinations starting from the root param\n+    expect(unique).toEqual([\n+      { lang: 'en' },\n+      { lang: 'en', page: 'home' },\n+      { lang: 'en', page: 'about' },\n+      { lang: 'fr' },\n+      { lang: 'fr', page: 'home' },\n+    ])\n+  })\n+\n+  it('should handle missing root params gracefully', () => {\n+    const params = [\n+      { lang: 'en', page: 'home' },\n+      { lang: 'en', page: 'about' },\n+      { page: 'contact' }, // Missing lang root param\n+    ]\n+\n+    const unique = generateParamPrefixCombinations(\n+      ['lang', 'page'],\n+      params,\n+      ['lang'] // Root param\n+    )\n+\n+    // Should only include combinations that have the root param\n+    expect(unique).toEqual([\n+      { lang: 'en' },\n+      { lang: 'en', page: 'home' },\n+      { lang: 'en', page: 'about' },\n+      // { page: 'contact' } should be excluded because it lacks the root param\n+    ])\n+  })\n+\n+  it('should handle root params not in route params', () => {\n+    const params = [\n+      { category: 'tech', slug: 'news' },\n+      { category: 'sports', slug: 'news' },\n+    ]\n+\n+    const unique = generateParamPrefixCombinations(\n+      ['category', 'slug'],\n+      params,\n+      ['lang', 'region'] // Root params not in route params\n+    )\n+\n+    // Should fall back to normal behavior when root params are not found\n+    expect(unique).toEqual([\n+      { category: 'tech' },\n+      { category: 'tech', slug: 'news' },\n+      { category: 'sports' },\n+      { category: 'sports', slug: 'news' },\n+    ])\n+  })\n+\n+  it('should handle test case scenario: route with extra param but missing value', () => {\n+    // This simulates the failing test scenario:\n+    // Route: /[lang]/[locale]/other/[slug]\n+    // generateStaticParams only provides: { lang: 'en', locale: 'us' }\n+    // Missing: slug parameter\n+    const params = [\n+      { lang: 'en', locale: 'us' }, // Missing slug parameter\n+    ]\n+\n+    const unique = generateParamPrefixCombinations(\n+      ['lang', 'locale', 'slug'], // All route params\n+      params,\n+      ['lang', 'locale'] // Root params\n+    )\n+\n+    // Should generate only the combination with complete root params\n+    // but not try to include the missing slug param\n+    expect(unique).toEqual([\n+      { lang: 'en', locale: 'us' }, // Complete root params, slug omitted\n+    ])\n+  })\n+\n+  it('should handle empty routeParams with root params', () => {\n+    // This might be what's happening for the [slug] route\n+    const params: Params[] = [] // No generateStaticParams results\n+\n+    const unique = generateParamPrefixCombinations(\n+      ['lang', 'locale', 'slug'], // All route params\n+      params,\n+      ['lang', 'locale'] // Root params\n+    )\n+\n+    // Should return empty array when there are no route params to work with\n+    expect(unique).toEqual([])\n+  })\n+})\n+\n+type TestAppSegment = Pick<AppSegment, 'config' | 'generateStaticParams'>\n+\n+// Mock WorkStore for testing\n+const createMockWorkStore = (fetchCache?: WorkStore['fetchCache']) => ({\n+  fetchCache,\n+})\n+\n+// Helper to create mock segments\n+const createMockSegment = (\n+  generateStaticParams?: (options: { params?: Params }) => Promise<Params[]>,\n+  config?: TestAppSegment['config']\n+): TestAppSegment => ({\n+  config,\n+  generateStaticParams,\n+})\n+\n+describe('generateRouteStaticParams', () => {\n+  describe('Basic functionality', () => {\n+    it('should return empty array for empty segments', async () => {\n+      const store = createMockWorkStore()\n+      const result = await generateRouteStaticParams([], store)\n+      expect(result).toEqual([])\n+    })\n+\n+    it('should return empty array for segments without generateStaticParams', async () => {\n+      const segments: TestAppSegment[] = [\n+        createMockSegment(),\n+        createMockSegment(),\n+      ]\n+      const store = createMockWorkStore()\n+      const result = await generateRouteStaticParams(segments, store)\n+      expect(result).toEqual([])\n+    })\n+\n+    it('should process single segment with generateStaticParams', async () => {\n+      const segments: TestAppSegment[] = [\n+        createMockSegment(async () => [{ id: '1' }, { id: '2' }]),\n+      ]\n+      const store = createMockWorkStore()\n+      const result = await generateRouteStaticParams(segments, store)\n+      expect(result).toEqual([{ id: '1' }, { id: '2' }])\n+    })\n+\n+    it('should process multiple segments with generateStaticParams', async () => {\n+      const segments: TestAppSegment[] = [\n+        createMockSegment(async () => [\n+          { category: 'tech' },\n+          { category: 'sports' },\n+        ]),\n+        createMockSegment(async ({ params }) => [\n+          { slug: `${params?.category}-post-1` },\n+          { slug: `${params?.category}-post-2` },\n+        ]),\n+      ]\n+      const store = createMockWorkStore()\n+      const result = await generateRouteStaticParams(segments, store)\n+      expect(result).toEqual([\n+        { category: 'tech', slug: 'tech-post-1' },\n+        { category: 'tech', slug: 'tech-post-2' },\n+        { category: 'sports', slug: 'sports-post-1' },\n+        { category: 'sports', slug: 'sports-post-2' },\n+      ])\n+    })\n+  })\n+\n+  describe('Parameter inheritance', () => {\n+    it('should inherit parent parameters', async () => {\n+      const segments: TestAppSegment[] = [\n+        createMockSegment(async () => [{ lang: 'en' }, { lang: 'fr' }]),\n+        createMockSegment(async ({ params }) => [\n+          { category: `${params?.lang}-tech` },\n+        ]),\n+      ]\n+      const store = createMockWorkStore()\n+      const result = await generateRouteStaticParams(segments, store)\n+      expect(result).toEqual([\n+        { lang: 'en', category: 'en-tech' },\n+        { lang: 'fr', category: 'fr-tech' },\n+      ])\n+    })\n+\n+    it('should handle mixed segments (some with generateStaticParams, some without)', async () => {\n+      const segments: TestAppSegment[] = [\n+        createMockSegment(async () => [{ lang: 'en' }]),\n+        createMockSegment(), // No generateStaticParams\n+        createMockSegment(async ({ params }) => [\n+          { slug: `${params?.lang}-slug` },\n+        ]),\n+      ]\n+      const store = createMockWorkStore()\n+      const result = await generateRouteStaticParams(segments, store)\n+      expect(result).toEqual([{ lang: 'en', slug: 'en-slug' }])\n+    })\n+  })\n+\n+  describe('Empty and undefined handling', () => {\n+    it('should handle empty generateStaticParams results', async () => {\n+      const segments: TestAppSegment[] = [createMockSegment(async () => [])]\n+      const store = createMockWorkStore()\n+      const result = await generateRouteStaticParams(segments, store)\n+      expect(result).toEqual([])\n+    })\n+\n+    it('should handle generateStaticParams returning empty array with parent params', async () => {\n+      const segments: TestAppSegment[] = [\n+        createMockSegment(async () => [{ lang: 'en' }]),\n+        createMockSegment(async () => []), // Empty result\n+      ]\n+      const store = createMockWorkStore()\n+      const result = await generateRouteStaticParams(segments, store)\n+      expect(result).toEqual([{ lang: 'en' }])\n+    })\n+\n+    it('should handle missing parameters in parent params', async () => {\n+      const segments: TestAppSegment[] = [\n+        createMockSegment(async () => [{ lang: 'en' }, {}]),\n+        createMockSegment(async ({ params }) => [\n+          { category: `${params?.lang || 'default'}-tech` },\n+        ]),\n+      ]\n+      const store = createMockWorkStore()\n+      const result = await generateRouteStaticParams(segments, store)\n+      expect(result).toEqual([\n+        { lang: 'en', category: 'en-tech' },\n+        { category: 'default-tech' },\n+      ])\n+    })\n+  })\n+\n+  describe('FetchCache configuration', () => {\n+    it('should set fetchCache on store when segment has fetchCache config', async () => {\n+      const segments: TestAppSegment[] = [\n+        createMockSegment(async () => [{ id: '1' }], {\n+          fetchCache: 'force-cache',\n+        }),\n+      ]\n+      const store = createMockWorkStore()\n+      await generateRouteStaticParams(segments, store)\n+      expect(store.fetchCache).toBe('force-cache')\n+    })\n+\n+    it('should not modify fetchCache when segment has no fetchCache config', async () => {\n+      const segments: TestAppSegment[] = [\n+        createMockSegment(async () => [{ id: '1' }]),\n+      ]\n+      const store = createMockWorkStore('force-cache')\n+      await generateRouteStaticParams(segments, store)\n+      expect(store.fetchCache).toBe('force-cache')\n+    })\n+\n+    it('should update fetchCache for multiple segments', async () => {\n+      const segments: TestAppSegment[] = [\n+        createMockSegment(async () => [{ category: 'tech' }], {\n+          fetchCache: 'force-cache',\n+        }),\n+        createMockSegment(async () => [{ slug: 'post' }], {\n+          fetchCache: 'default-cache',\n+        }),\n+      ]\n+      const store = createMockWorkStore()\n+      await generateRouteStaticParams(segments, store)\n+      // Should have the last fetchCache value\n+      expect(store.fetchCache).toBe('default-cache')\n+    })\n+  })\n+\n+  describe('Array parameter values', () => {\n+    it('should handle array parameter values', async () => {\n+      const segments: TestAppSegment[] = [\n+        createMockSegment(async () => [\n+          { slug: ['a', 'b'] },\n+          { slug: ['c', 'd', 'e'] },\n+        ]),\n+      ]\n+      const store = createMockWorkStore()\n+      const result = await generateRouteStaticParams(segments, store)\n+      expect(result).toEqual([{ slug: ['a', 'b'] }, { slug: ['c', 'd', 'e'] }])\n+    })\n+\n+    it('should handle mixed array and string parameters', async () => {\n+      const segments: TestAppSegment[] = [\n+        createMockSegment(async () => [{ lang: 'en' }]),\n+        createMockSegment(async ({ params }) => [\n+          { slug: [`${params?.lang}`, 'post'] },\n+        ]),\n+      ]\n+      const store = createMockWorkStore()\n+      const result = await generateRouteStaticParams(segments, store)\n+      expect(result).toEqual([{ lang: 'en', slug: ['en', 'post'] }])\n+    })\n+  })\n+\n+  describe('Deep nesting scenarios', () => {\n+    it('should handle deeply nested segments', async () => {\n+      const segments: TestAppSegment[] = [\n+        createMockSegment(async () => [{ a: '1' }]),\n+        createMockSegment(async ({ params }) => [{ b: `${params?.a}-2` }]),\n+        createMockSegment(async ({ params }) => [{ c: `${params?.b}-3` }]),\n+        createMockSegment(async ({ params }) => [{ d: `${params?.c}-4` }]),\n+      ]\n+      const store = createMockWorkStore()\n+      const result = await generateRouteStaticParams(segments, store)\n+      expect(result).toEqual([{ a: '1', b: '1-2', c: '1-2-3', d: '1-2-3-4' }])\n+    })\n+\n+    it('should handle many parameter combinations', async () => {\n+      const segments: TestAppSegment[] = [\n+        createMockSegment(async () => [{ x: '1' }, { x: '2' }]),\n+        createMockSegment(async () => [{ y: 'a' }, { y: 'b' }]),\n+        createMockSegment(async () => [{ z: 'i' }, { z: 'ii' }]),\n+      ]\n+      const store = createMockWorkStore()\n+      const result = await generateRouteStaticParams(segments, store)\n+      expect(result).toEqual([\n+        { x: '1', y: 'a', z: 'i' },\n+        { x: '1', y: 'a', z: 'ii' },\n+        { x: '1', y: 'b', z: 'i' },\n+        { x: '1', y: 'b', z: 'ii' },\n+        { x: '2', y: 'a', z: 'i' },\n+        { x: '2', y: 'a', z: 'ii' },\n+        { x: '2', y: 'b', z: 'i' },\n+        { x: '2', y: 'b', z: 'ii' },\n+      ])\n+    })\n+  })\n+\n+  describe('Error handling', () => {\n+    it('should handle generateStaticParams throwing an error', async () => {\n+      const segments: TestAppSegment[] = [\n+        createMockSegment(async () => {\n+          throw new Error('Test error')\n+        }),\n+      ]\n+      const store = createMockWorkStore()\n+      await expect(generateRouteStaticParams(segments, store)).rejects.toThrow(\n+        'Test error'\n+      )\n+    })\n+\n+    it('should handle generateStaticParams returning a rejected promise', async () => {\n+      const segments: TestAppSegment[] = [\n+        createMockSegment(async () => {\n+          return Promise.reject(new Error('Async error'))\n+        }),\n+      ]\n+      const store = createMockWorkStore()\n+      await expect(generateRouteStaticParams(segments, store)).rejects.toThrow(\n+        'Async error'\n+      )\n+    })\n+\n+    it('should handle partially failing generateStaticParams', async () => {\n+      const segments: TestAppSegment[] = [\n+        createMockSegment(async () => [{ category: 'tech' }]),\n+        createMockSegment(async ({ params }) => {\n+          if (params?.category === 'tech') {\n+            throw new Error('Tech not allowed')\n+          }\n+          return [{ slug: 'post' }]\n+        }),\n+      ]\n+      const store = createMockWorkStore()\n+      await expect(generateRouteStaticParams(segments, store)).rejects.toThrow(\n+        'Tech not allowed'\n+      )\n+    })\n+  })\n+\n+  describe('Complex real-world scenarios', () => {\n+    it('should handle i18n routing pattern', async () => {\n+      const segments: TestAppSegment[] = [\n+        createMockSegment(async () => [\n+          { lang: 'en' },\n+          { lang: 'fr' },\n+          { lang: 'es' },\n+        ]),\n+        createMockSegment(async ({ params: _params }) => [\n+          { category: 'tech' },\n+          { category: 'sports' },\n+        ]),\n+        createMockSegment(async ({ params }) => [\n+          { slug: `${params?.lang}-${params?.category}-post-1` },\n+          { slug: `${params?.lang}-${params?.category}-post-2` },\n+        ]),\n+      ]\n+      const store = createMockWorkStore()\n+      const result = await generateRouteStaticParams(segments, store)\n+      expect(result).toHaveLength(12) // 3 langs × 2 categories × 2 slugs\n+      expect(result).toContainEqual({\n+        lang: 'en',\n+        category: 'tech',\n+        slug: 'en-tech-post-1',\n+      })\n+      expect(result).toContainEqual({\n+        lang: 'fr',\n+        category: 'sports',\n+        slug: 'fr-sports-post-2',\n+      })\n+    })\n+\n+    it('should handle e-commerce routing pattern', async () => {\n+      const segments: TestAppSegment[] = [\n+        createMockSegment(), // Static segment\n+        createMockSegment(async () => [\n+          { category: 'electronics' },\n+          { category: 'clothing' },\n+        ]),\n+        createMockSegment(async ({ params }) => {\n+          if (params?.category === 'electronics') {\n+            return [{ subcategory: 'phones' }, { subcategory: 'laptops' }]\n+          }\n+          return [{ subcategory: 'shirts' }, { subcategory: 'pants' }]\n+        }),\n+        createMockSegment(async ({ params }) => [\n+          { product: `${params?.subcategory}-item-1` },\n+        ]),\n+      ]\n+      const store = createMockWorkStore()\n+      const result = await generateRouteStaticParams(segments, store)\n+      expect(result).toEqual([\n+        {\n+          category: 'electronics',\n+          subcategory: 'phones',\n+          product: 'phones-item-1',\n+        },\n+        {\n+          category: 'electronics',\n+          subcategory: 'laptops',\n+          product: 'laptops-item-1',\n+        },\n+        {\n+          category: 'clothing',\n+          subcategory: 'shirts',\n+          product: 'shirts-item-1',\n+        },\n+        { category: 'clothing', subcategory: 'pants', product: 'pants-item-1' },\n+      ])\n+    })\n+\n+    it('should handle blog with optional catch-all', async () => {\n+      const segments: TestAppSegment[] = [\n+        createMockSegment(), // Static segment\n+        createMockSegment(async () => [{ year: '2023' }, { year: '2024' }]),\n+        createMockSegment(async ({ params: _params }) => [\n+          { month: '01' },\n+          { month: '02' },\n+        ]),\n+        createMockSegment(async ({ params }) => [\n+          { slug: [`${params?.year}-${params?.month}-post`] },\n+          { slug: [] }, // Empty for optional catch-all\n+        ]),\n+      ]\n+      const store = createMockWorkStore()\n+      const result = await generateRouteStaticParams(segments, store)\n+      expect(result).toHaveLength(8) // 2 years × 2 months × 2 slug variations\n+      expect(result).toContainEqual({\n+        year: '2023',\n+        month: '01',\n+        slug: ['2023-01-post'],\n+      })\n+      expect(result).toContainEqual({ year: '2024', month: '02', slug: [] })\n+    })\n+  })\n+\n+  describe('Performance considerations', () => {\n+    it('should handle recursive calls without stack overflow', async () => {\n+      const segments: TestAppSegment[] = []\n+      for (let i = 0; i < 5000; i++) {\n+        segments.push(\n+          createMockSegment(async () => [{ [`param${i}`]: `value${i}` }])\n+        )\n+      }\n+      const store = createMockWorkStore()\n+      const result = await generateRouteStaticParams(segments, store)\n+      expect(result).toHaveLength(1)\n+      expect(Object.keys(result[0])).toHaveLength(5000)\n+    })\n+  })\n })"
        },
        {
            "sha": "70d41f4d9f27010ac583c41188bd17ad8c14ea7e",
            "filename": "packages/next/src/build/static-paths/app.ts",
            "status": "modified",
            "additions": 240,
            "deletions": 100,
            "changes": 340,
            "blob_url": "https://github.com/vercel/next.js/blob/d884398da6c55f662115cd1b3ff19e72fb6bb8d5/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d884398da6c55f662115cd1b3ff19e72fb6bb8d5/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp.ts?ref=d884398da6c55f662115cd1b3ff19e72fb6bb8d5",
            "patch": "@@ -17,6 +17,7 @@ import { normalizePathname, encodeParam } from './utils'\n import escapePathDelimiters from '../../shared/lib/router/utils/escape-path-delimiters'\n import { createIncrementalCache } from '../../export/helpers/create-incremental-cache'\n import type { NextConfigComplete } from '../../server/config-shared'\n+import type { WorkStore } from '../../server/app-render/work-async-storage.external'\n \n /**\n  * Filters out duplicate parameters from a list of parameters.\n@@ -75,12 +76,17 @@ export function filterUniqueParams(\n }\n \n /**\n- * Filters out all combinations of root params from a list of parameters.\n- * This function extracts only the root parameters from each parameter object\n- * and then filters out duplicate combinations using a Map for efficiency.\n+ * Generates all unique sub-combinations of route params from a list of parameters.\n+ * This function creates all possible prefixes of the route parameters, which is\n+ * useful for generating partial routes that can serve as shells for more specific routes.\n  *\n- * Given the following root param ('lang'), and the following routeParams:\n+ * When rootParamKeys are provided, the function ensures that partial shells only\n+ * include complete sets of root params. This prevents generating invalid partial\n+ * routes that are missing required root parameters.\n  *\n+ * Example with root params ('lang', 'region') and route params ('lang', 'region', 'slug'):\n+ *\n+ * Given the following routeParams:\n  * ```\n  * [\n  *   { lang: 'en', region: 'US', slug: ['home'] },\n@@ -90,65 +96,166 @@ export function filterUniqueParams(\n  * ```\n  *\n  * The result will be:\n- *\n  * ```\n  * [\n- *   { lang: 'en', region: 'US' },\n- *   { lang: 'fr', region: 'CA' },\n+ *   { lang: 'en', region: 'US' },  // Complete root params\n+ *   { lang: 'en', region: 'US', slug: ['home'] },\n+ *   { lang: 'en', region: 'US', slug: ['about'] },\n+ *   { lang: 'fr', region: 'CA' },  // Complete root params\n+ *   { lang: 'fr', region: 'CA', slug: ['about'] },\n  * ]\n  * ```\n  *\n- * @param rootParamKeys - The keys of the root params. These should be sorted\n+ * Note that partial combinations like `{ lang: 'en' }` are NOT generated because\n+ * they don't include the complete set of root params.\n+ *\n+ * For routes without root params (e.g., `/[slug]`), all sub-combinations are generated\n+ * as before.\n+ *\n+ * @param routeParamKeys - The keys of the route params. These should be sorted\n  *   to ensure consistent key generation for the internal Map.\n  * @param routeParams - The list of parameter objects to filter.\n- * @returns A new array containing only the unique combinations of root params.\n+ * @param rootParamKeys - The keys of the root params. When provided, ensures partial\n+ *   shells include all root params.\n+ * @returns A new array containing all unique sub-combinations of route params.\n  */\n-export function filterUniqueRootParamsCombinations(\n-  rootParamKeys: readonly string[],\n-  routeParams: readonly Params[]\n+export function generateParamPrefixCombinations(\n+  routeParamKeys: readonly string[],\n+  routeParams: readonly Params[],\n+  rootParamKeys: readonly string[]\n ): Params[] {\n-  // A Map is used to store unique combinations of root parameters.\n-  // The key of the Map is a string representation of the root parameter\n+  // A Map is used to store unique combinations of route parameters.\n+  // The key of the Map is a string representation of the route parameter\n   // combination, and the value is the `Params` object containing only\n-  // the root parameters.\n+  // the route parameters.\n   const combinations = new Map<string, Params>()\n \n+  // Determine the minimum index where all root params are included.\n+  // This optimization ensures we only generate combinations that include\n+  // a complete set of root parameters, preventing invalid partial shells.\n+  //\n+  // For example, if rootParamKeys = ['lang', 'region'] and routeParamKeys = ['lang', 'region', 'slug']:\n+  // - 'lang' is at index 0, 'region' is at index 1\n+  // - minIndexForCompleteRootParams = max(0, 1) = 1\n+  // - We'll only generate combinations starting from index 1 (which includes both lang and region)\n+  let minIndexForCompleteRootParams = -1\n+  if (rootParamKeys.length > 0) {\n+    // Find the index of the last root param in routeParamKeys.\n+    // This tells us the minimum combination length needed to include all root params.\n+    for (const rootParamKey of rootParamKeys) {\n+      const index = routeParamKeys.indexOf(rootParamKey)\n+      if (index === -1) {\n+        // Root param not found in route params - this shouldn't happen in normal cases\n+        // but we handle it gracefully by treating it as if there are no root params.\n+        // This allows the function to fall back to generating all sub-combinations.\n+        minIndexForCompleteRootParams = -1\n+        break\n+      }\n+      // Track the highest index among all root params.\n+      // This ensures all root params are included in any generated combination.\n+      minIndexForCompleteRootParams = Math.max(\n+        minIndexForCompleteRootParams,\n+        index\n+      )\n+    }\n+  }\n+\n   // Iterate over each parameter object in the input array.\n+  // Each params object represents one potential route combination (e.g., { lang: 'en', region: 'US', slug: 'home' })\n   for (const params of routeParams) {\n-    const combination: Params = {} // Initialize an object to hold only the root parameters.\n-    let key = '' // Initialize an empty string to build the unique key for the current root parameter combination.\n+    // Generate all possible prefix combinations for this parameter set.\n+    // For routeParamKeys = ['lang', 'region', 'slug'], we'll generate combinations at:\n+    // - i=0: { lang: 'en' }\n+    // - i=1: { lang: 'en', region: 'US' }\n+    // - i=2: { lang: 'en', region: 'US', slug: 'home' }\n+    //\n+    // The iteration order is crucial for generating stable and unique keys\n+    // for each route parameter combination.\n+    for (let i = 0; i < routeParamKeys.length; i++) {\n+      // Skip generating combinations that don't include all root params.\n+      // This prevents creating invalid partial shells that are missing required root parameters.\n+      //\n+      // For example, if root params are ['lang', 'region'] and minIndexForCompleteRootParams = 1:\n+      // - Skip i=0 (would only include 'lang', missing 'region')\n+      // - Process i=1 and higher (includes both 'lang' and 'region')\n+      if (\n+        minIndexForCompleteRootParams >= 0 &&\n+        i < minIndexForCompleteRootParams\n+      ) {\n+        continue\n+      }\n \n-    // Iterate through the `rootParamKeys` (which are assumed to be sorted).\n-    // This consistent order is crucial for generating a stable and unique key\n-    // for each root parameter combination.\n-    for (const rootKey of rootParamKeys) {\n-      const value = params[rootKey]\n-      combination[rootKey] = value // Add the root parameter and its value to the combination object.\n+      // Initialize data structures for building this specific combination\n+      const combination: Params = {}\n+      const keyParts: string[] = []\n+      let hasAllRootParams = true\n+\n+      // Build the sub-combination with parameters from index 0 to i (inclusive).\n+      // This creates a prefix of the full parameter set, building up combinations incrementally.\n+      //\n+      // For example, if routeParamKeys = ['lang', 'region', 'slug'] and i = 1:\n+      // - j=0: Add 'lang' parameter\n+      // - j=1: Add 'region' parameter\n+      // Result: { lang: 'en', region: 'US' }\n+      for (let j = 0; j <= i; j++) {\n+        const routeKey = routeParamKeys[j]\n+\n+        // Check if the parameter exists in the original params object and has a defined value.\n+        // This handles cases where generateStaticParams doesn't provide all possible parameters,\n+        // or where some parameters are optional/undefined.\n+        if (\n+          !params.hasOwnProperty(routeKey) ||\n+          params[routeKey] === undefined\n+        ) {\n+          // If this missing parameter is a root param, mark the combination as invalid.\n+          // Root params are required for PPR shells, so we can't generate partial combinations without them.\n+          if (rootParamKeys.includes(routeKey)) {\n+            hasAllRootParams = false\n+          }\n+          // Stop building this combination since we've hit a missing parameter.\n+          // This ensures we only generate valid prefix combinations with consecutive parameters.\n+          break\n+        }\n \n-      // Construct a part of the key using the root parameter key and its value.\n-      // A type prefix (`A:` for Array, `S:` for String, `U:` for undefined) is added to the value\n-      // to prevent collisions. This ensures that different types with the same\n-      // string representation are treated as distinct.\n-      let valuePart: string\n-      if (Array.isArray(value)) {\n-        valuePart = `A:${value.join(',')}`\n-      } else if (value === undefined) {\n-        valuePart = `U:undefined`\n-      } else {\n-        valuePart = `S:${value}`\n+        const value = params[routeKey]\n+        combination[routeKey] = value\n+\n+        // Construct a unique key part for this parameter to enable deduplication.\n+        // We use type prefixes to prevent collisions between different value types\n+        // that might have the same string representation.\n+        //\n+        // Examples:\n+        // - Array ['foo', 'bar'] becomes \"A:foo,bar\"\n+        // - String \"foo,bar\" becomes \"S:foo,bar\"\n+        // - This prevents collisions between ['foo', 'bar'] and \"foo,bar\"\n+        let valuePart: string\n+        if (Array.isArray(value)) {\n+          valuePart = `A:${value.join(',')}`\n+        } else {\n+          valuePart = `S:${value}`\n+        }\n+        keyParts.push(`${routeKey}:${valuePart}`)\n       }\n-      key += `${rootKey}:${valuePart}|`\n-    }\n \n-    // If the generated key is not already in the `combinations` Map, it means\n-    // this root parameter combination is unique so far. Add it to the Map.\n-    if (!combinations.has(key)) {\n-      combinations.set(key, combination)\n+      // Build the final unique key by joining all parameter parts.\n+      // This key is used for deduplication in the combinations Map.\n+      // Format: \"lang:S:en|region:S:US|slug:A:home,about\"\n+      const currentKey = keyParts.join('|')\n+\n+      // Only add the combination if it meets our criteria:\n+      // 1. hasAllRequiredParams: Contains all required root parameters\n+      // 2. !combinations.has(currentKey): Is not a duplicate of an existing combination\n+      //\n+      // This ensures we only generate valid, unique parameter combinations for PPR shells.\n+      if (hasAllRootParams && !combinations.has(currentKey)) {\n+        combinations.set(currentKey, combination)\n+      }\n     }\n   }\n \n-  // Convert the Map's values (the unique root parameter `Params` objects)\n-  // back into an array and return it.\n+  // Convert the Map's values back into an array and return the final result.\n+  // The Map ensures all combinations are unique, and we return only the\n+  // parameter objects themselves, discarding the internal deduplication keys.\n   return Array.from(combinations.values())\n }\n \n@@ -401,6 +508,87 @@ export function assignErrorIfEmpty(\n   }\n }\n \n+/**\n+ * Processes app directory segments to build route parameters from generateStaticParams functions.\n+ * This function walks through the segments array and calls generateStaticParams for each segment that has it,\n+ * combining parent parameters with child parameters to build the complete parameter combinations.\n+ * Uses iterative processing instead of recursion for better performance.\n+ *\n+ * @param segments - Array of app directory segments to process\n+ * @param store - Work store for tracking fetch cache configuration\n+ * @returns Promise that resolves to an array of all parameter combinations\n+ */\n+export async function generateRouteStaticParams(\n+  segments: Pick<AppSegment, 'config' | 'generateStaticParams'>[],\n+  store: Pick<WorkStore, 'fetchCache'>\n+): Promise<Params[]> {\n+  // Early return if no segments to process\n+  if (segments.length === 0) return []\n+\n+  // Use iterative processing with a work queue to avoid recursion overhead\n+  interface WorkItem {\n+    segmentIndex: number\n+    params: Params[]\n+  }\n+\n+  const queue: WorkItem[] = [{ segmentIndex: 0, params: [] }]\n+  let currentParams: Params[] = []\n+\n+  while (queue.length > 0) {\n+    const { segmentIndex, params } = queue.shift()!\n+\n+    // If we've processed all segments, this is our final result\n+    if (segmentIndex >= segments.length) {\n+      currentParams = params\n+      break\n+    }\n+\n+    const current = segments[segmentIndex]\n+\n+    // Skip segments without generateStaticParams and continue to next\n+    if (typeof current.generateStaticParams !== 'function') {\n+      queue.push({ segmentIndex: segmentIndex + 1, params })\n+      continue\n+    }\n+\n+    // Configure fetchCache if specified\n+    if (current.config?.fetchCache !== undefined) {\n+      store.fetchCache = current.config.fetchCache\n+    }\n+\n+    const nextParams: Params[] = []\n+\n+    // If there are parent params, we need to process them.\n+    if (params.length > 0) {\n+      // Process each parent parameter combination\n+      for (const parentParams of params) {\n+        const result = await current.generateStaticParams({\n+          params: parentParams,\n+        })\n+\n+        if (result.length > 0) {\n+          // Merge parent params with each result item\n+          for (const item of result) {\n+            nextParams.push({ ...parentParams, ...item })\n+          }\n+        } else {\n+          // No results, just pass through parent params\n+          nextParams.push(parentParams)\n+        }\n+      }\n+    } else {\n+      // No parent params, call generateStaticParams with empty object\n+      const result = await current.generateStaticParams({ params: {} })\n+      nextParams.push(...result)\n+    }\n+\n+    // Add next segment to work queue\n+    queue.push({ segmentIndex: segmentIndex + 1, params: nextParams })\n+  }\n+\n+  return currentParams\n+}\n+\n /**\n  * Builds the static paths for an app using `generateStaticParams`.\n  *\n@@ -497,61 +685,8 @@ export async function buildAppStaticPaths({\n     previouslyRevalidatedTags: [],\n   })\n \n-  const routeParams = await ComponentMod.workAsyncStorage.run(\n-    store,\n-    async () => {\n-      async function builtRouteParams(\n-        parentsParams: Params[] = [],\n-        idx = 0\n-      ): Promise<Params[]> {\n-        // If we don't have any more to process, then we're done.\n-        if (idx === segments.length) return parentsParams\n-\n-        const current = segments[idx]\n-\n-        if (\n-          typeof current.generateStaticParams !== 'function' &&\n-          idx < segments.length\n-        ) {\n-          return builtRouteParams(parentsParams, idx + 1)\n-        }\n-\n-        const params: Params[] = []\n-\n-        if (current.generateStaticParams) {\n-          // fetchCache can be used to inform the fetch() defaults used inside\n-          // of generateStaticParams. revalidate and dynamic options don't come into\n-          // play within generateStaticParams.\n-          if (typeof current.config?.fetchCache !== 'undefined') {\n-            store.fetchCache = current.config.fetchCache\n-          }\n-\n-          if (parentsParams.length > 0) {\n-            for (const parentParams of parentsParams) {\n-              const result = await current.generateStaticParams({\n-                params: parentParams,\n-              })\n-\n-              for (const item of result) {\n-                params.push({ ...parentParams, ...item })\n-              }\n-            }\n-          } else {\n-            const result = await current.generateStaticParams({ params: {} })\n-\n-            params.push(...result)\n-          }\n-        }\n-\n-        if (idx < segments.length) {\n-          return builtRouteParams(params, idx + 1)\n-        }\n-\n-        return params\n-      }\n-\n-      return builtRouteParams()\n-    }\n+  const routeParams = await ComponentMod.workAsyncStorage.run(store, () =>\n+    generateRouteStaticParams(segments, store)\n   )\n \n   await afterRunner.executeAfter()\n@@ -622,10 +757,15 @@ export async function buildAppStaticPaths({\n \n   if (hadAllParamsGenerated || isRoutePPREnabled) {\n     if (isRoutePPREnabled) {\n-      // Discover all unique combinations of the rootParams so we can generate\n-      // routes that won't throw on empty static shell for each of them if they're available.\n+      // Discover all unique combinations of the routeParams so we can generate\n+      // routes that won't throw on empty static shell for each of them if\n+      // they're available.\n       routeParams.unshift(\n-        ...filterUniqueRootParamsCombinations(rootParamKeys, routeParams)\n+        ...generateParamPrefixCombinations(\n+          routeParamKeys,\n+          routeParams,\n+          rootParamKeys\n+        )\n       )\n \n       prerenderedRoutesByPathname.set(page, {"
        },
        {
            "sha": "df8755ad85717f314b6bcac8f58e88536a69bc5a",
            "filename": "packages/next/src/build/templates/app-page.ts",
            "status": "modified",
            "additions": 10,
            "deletions": 3,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/d884398da6c55f662115cd1b3ff19e72fb6bb8d5/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fapp-page.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d884398da6c55f662115cd1b3ff19e72fb6bb8d5/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fapp-page.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fapp-page.ts?ref=d884398da6c55f662115cd1b3ff19e72fb6bb8d5",
            "patch": "@@ -166,8 +166,8 @@ export async function handler(\n \n   let { isOnDemandRevalidate } = prepareResult\n \n-  const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage]\n-  const isPrerendered = prerenderManifest.routes[resolvedPathname]\n+  const prerenderInfo = routeModule.match(pathname, prerenderManifest)\n+  const isPrerendered = !!prerenderManifest.routes[resolvedPathname]\n \n   let isSSG = Boolean(\n     prerenderInfo ||\n@@ -663,10 +663,17 @@ export async function handler(\n         let fallbackResponse: ResponseCacheEntry | null | undefined\n \n         if (isRoutePPREnabled && !isRSCRequest) {\n+          const cacheKey =\n+            typeof prerenderInfo?.fallback === 'string'\n+              ? prerenderInfo.fallback\n+              : isProduction\n+                ? normalizedSrcPage\n+                : null\n+\n           // We use the response cache here to handle the revalidation and\n           // management of the fallback shell.\n           fallbackResponse = await routeModule.handleResponse({\n-            cacheKey: isProduction ? normalizedSrcPage : null,\n+            cacheKey,\n             req,\n             nextConfig,\n             routeKind: RouteKind.APP_PAGE,"
        },
        {
            "sha": "a9421f86f10874b91523d0f31a7e92558eb7cd86",
            "filename": "packages/next/src/server/dev/next-dev-server.ts",
            "status": "modified",
            "additions": 16,
            "deletions": 1,
            "changes": 17,
            "blob_url": "https://github.com/vercel/next.js/blob/d884398da6c55f662115cd1b3ff19e72fb6bb8d5/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fnext-dev-server.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d884398da6c55f662115cd1b3ff19e72fb6bb8d5/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fnext-dev-server.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fnext-dev-server.ts?ref=d884398da6c55f662115cd1b3ff19e72fb6bb8d5",
            "patch": "@@ -75,6 +75,7 @@ import {\n   getInstrumentationModule,\n } from '../lib/router-utils/instrumentation-globals.external'\n import type { PrerenderManifest } from '../../build'\n+import { getRouteRegex } from '../../shared/lib/router/utils/route-regex'\n \n // Load ReactDevOverlay only when needed\n let PagesDevOverlayBridgeImpl: PagesDevOverlayBridgeType\n@@ -887,8 +888,22 @@ export default class DevServer extends Server {\n             existingManifest.routes[staticPath] = {} as any\n           }\n           existingManifest.dynamicRoutes[pathname] = {\n+            dataRoute: null,\n+            dataRouteRegex: null,\n             fallback: fallbackModeToFallbackField(res.value.fallbackMode, page),\n-          } as any\n+            fallbackRevalidate: false,\n+            fallbackExpire: undefined,\n+            fallbackHeaders: undefined,\n+            fallbackStatus: undefined,\n+            fallbackRootParams: undefined,\n+            fallbackSourceRoute: pathname,\n+            prefetchDataRoute: undefined,\n+            prefetchDataRouteRegex: undefined,\n+            routeRegex: getRouteRegex(pathname).re.source,\n+            experimentalPPR: undefined,\n+            renderingMode: undefined,\n+            allowHeader: [],\n+          }\n \n           const updatedManifest = JSON.stringify(existingManifest)\n "
        },
        {
            "sha": "3160ac8ffa23ee9d82db899c92b926972b51f800",
            "filename": "packages/next/src/server/lib/router-utils/filesystem.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/d884398da6c55f662115cd1b3ff19e72fb6bb8d5/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Ffilesystem.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d884398da6c55f662115cd1b3ff19e72fb6bb8d5/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Ffilesystem.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Ffilesystem.ts?ref=d884398da6c55f662115cd1b3ff19e72fb6bb8d5",
            "patch": "@@ -281,6 +281,12 @@ export async function setupFsCheck(opts: {\n     }\n \n     for (const route of routesManifest.dynamicRoutes) {\n+      // If a route is marked as skipInternalRouting, it's not for the internal\n+      // router, and instead has been added to support external routers.\n+      if (route.skipInternalRouting) {\n+        continue\n+      }\n+\n       dynamicRoutes.push({\n         ...route,\n         match: getRouteMatcher(getRouteRegex(route.page)),"
        },
        {
            "sha": "e17f12d081c4be67a7c8323ede28c00b0d597668",
            "filename": "packages/next/src/server/route-modules/app-page/helpers/prerender-manifest-matcher.test.ts",
            "status": "added",
            "additions": 134,
            "deletions": 0,
            "changes": 134,
            "blob_url": "https://github.com/vercel/next.js/blob/d884398da6c55f662115cd1b3ff19e72fb6bb8d5/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Fapp-page%2Fhelpers%2Fprerender-manifest-matcher.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d884398da6c55f662115cd1b3ff19e72fb6bb8d5/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Fapp-page%2Fhelpers%2Fprerender-manifest-matcher.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Fapp-page%2Fhelpers%2Fprerender-manifest-matcher.test.ts?ref=d884398da6c55f662115cd1b3ff19e72fb6bb8d5",
            "patch": "@@ -0,0 +1,134 @@\n+import { PrerenderManifestMatcher } from './prerender-manifest-matcher'\n+import type {\n+  PrerenderManifest,\n+  DynamicPrerenderManifestRoute,\n+} from '../../../../build'\n+import { RenderingMode } from '../../../../build/rendering-mode'\n+\n+// Helper function to create a mock PrerenderManifest\n+function createMockPrerenderManifest(\n+  dynamicRoutes: Record<string, DynamicPrerenderManifestRoute> = {}\n+): PrerenderManifest {\n+  return {\n+    version: 4,\n+    routes: {},\n+    dynamicRoutes,\n+    notFoundRoutes: [],\n+    preview: {\n+      previewModeId: 'test-preview-id',\n+      previewModeEncryptionKey: 'test-encryption-key',\n+      previewModeSigningKey: 'test-signing-key',\n+    },\n+  }\n+}\n+\n+// Helper function to create a mock DynamicPrerenderManifestRoute\n+function createMockDynamicRoute(\n+  overrides: Partial<DynamicPrerenderManifestRoute> = {}\n+): DynamicPrerenderManifestRoute {\n+  return {\n+    dataRoute: null,\n+    dataRouteRegex: null,\n+    fallback: null,\n+    fallbackRevalidate: false,\n+    fallbackExpire: undefined,\n+    fallbackHeaders: undefined,\n+    fallbackStatus: undefined,\n+    fallbackRootParams: undefined,\n+    fallbackSourceRoute: undefined,\n+    prefetchDataRoute: undefined,\n+    prefetchDataRouteRegex: undefined,\n+    routeRegex: '^/[^/]+(?:/[^/]+)?/?$',\n+    experimentalPPR: undefined,\n+    renderingMode: RenderingMode.STATIC,\n+    allowHeader: ['host'],\n+    ...overrides,\n+  }\n+}\n+\n+describe('PrerenderManifestMatcher', () => {\n+  describe('match', () => {\n+    describe('successful matches', () => {\n+      it('should respect route specificity order', () => {\n+        const specificRoute = createMockDynamicRoute({\n+          fallbackSourceRoute: '/[category]/[id]',\n+        })\n+\n+        const catchAllRoute = createMockDynamicRoute({\n+          fallbackSourceRoute: '/[category]/[id]',\n+        })\n+\n+        // Order matters - more specific routes should come first\n+        const manifest = createMockPrerenderManifest({\n+          '/products/[id]': specificRoute,\n+          '/[category]/[id]': catchAllRoute,\n+        })\n+\n+        const matcher = new PrerenderManifestMatcher(\n+          '/[category]/[id]',\n+          manifest\n+        )\n+\n+        const result = matcher.match('/products/123')\n+\n+        expect(result).toBe(specificRoute)\n+      })\n+\n+      it('should handle when the fallbackSourceRoute is not set', () => {\n+        const route = createMockDynamicRoute({\n+          fallbackSourceRoute: undefined,\n+        })\n+\n+        const manifest = createMockPrerenderManifest({\n+          '/products/[id]': route,\n+        })\n+\n+        const matcher = new PrerenderManifestMatcher('/products/[id]', manifest)\n+\n+        const result = matcher.match('/products/123')\n+\n+        expect(result).toBe(route)\n+      })\n+    })\n+\n+    describe('no match scenarios', () => {\n+      it('should return null when no matching route is found', () => {\n+        const route = createMockDynamicRoute({\n+          fallbackSourceRoute: '/[category]/[id]',\n+        })\n+\n+        const manifest = createMockPrerenderManifest({\n+          '/products/[id]': route,\n+        })\n+\n+        const matcher = new PrerenderManifestMatcher(\n+          '/[category]/[id]',\n+          manifest\n+        )\n+\n+        const result = matcher.match('/non-matching-path')\n+\n+        expect(result).toBe(null)\n+      })\n+\n+      it('should return null when no routes match the fallback source route', () => {\n+        const route = createMockDynamicRoute({\n+          fallbackSourceRoute: '/products/[id]',\n+        })\n+\n+        const manifest = createMockPrerenderManifest({\n+          '/products/[id]': route,\n+        })\n+\n+        const matcher = new PrerenderManifestMatcher(\n+          '/[category]/[id]',\n+          manifest\n+        )\n+\n+        const result = matcher.match('/products/123')\n+\n+        expect(result).toBe(null)\n+      })\n+    })\n+  })\n+})"
        },
        {
            "sha": "3ba42deae3b6b4dd1b38445b87454d0911843c1d",
            "filename": "packages/next/src/server/route-modules/app-page/helpers/prerender-manifest-matcher.ts",
            "status": "added",
            "additions": 80,
            "deletions": 0,
            "changes": 80,
            "blob_url": "https://github.com/vercel/next.js/blob/d884398da6c55f662115cd1b3ff19e72fb6bb8d5/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Fapp-page%2Fhelpers%2Fprerender-manifest-matcher.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d884398da6c55f662115cd1b3ff19e72fb6bb8d5/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Fapp-page%2Fhelpers%2Fprerender-manifest-matcher.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Fapp-page%2Fhelpers%2Fprerender-manifest-matcher.ts?ref=d884398da6c55f662115cd1b3ff19e72fb6bb8d5",
            "patch": "@@ -0,0 +1,80 @@\n+import type {\n+  DynamicPrerenderManifestRoute,\n+  PrerenderManifest,\n+} from '../../../../build'\n+import type { DeepReadonly } from '../../../../shared/lib/deep-readonly'\n+import {\n+  getRouteMatcher,\n+  type RouteMatchFn,\n+} from '../../../../shared/lib/router/utils/route-matcher'\n+import { getRouteRegex } from '../../../../shared/lib/router/utils/route-regex'\n+\n+/**\n+ * A matcher for a dynamic route.\n+ */\n+type Matcher = {\n+  /**\n+   * The matcher for the dynamic route. This is lazily created when the matcher\n+   * is first used.\n+   */\n+  matcher?: RouteMatchFn\n+\n+  /**\n+   * The source of the dynamic route.\n+   */\n+  source: string\n+\n+  /**\n+   * The route that matches the source.\n+   */\n+  route: DeepReadonly<DynamicPrerenderManifestRoute>\n+}\n+\n+/**\n+ * A matcher for the prerender manifest.\n+ *\n+ * This class is used to match the pathname to the dynamic route.\n+ */\n+export class PrerenderManifestMatcher {\n+  private readonly matchers: Array<Matcher>\n+  constructor(\n+    pathname: string,\n+    prerenderManifest: DeepReadonly<PrerenderManifest>\n+  ) {\n+    this.matchers = Object.entries(prerenderManifest.dynamicRoutes)\n+      .filter(([source, route]) => {\n+        // If the pathname is a fallback source route, or the source route is\n+        // the same as the pathname, then we should include it in the matchers.\n+        return route.fallbackSourceRoute === pathname || source === pathname\n+      })\n+      .map(([source, route]) => ({ source, route }))\n+  }\n+\n+  /**\n+   * Match the pathname to the dynamic route. If no match is found, an error is\n+   * thrown.\n+   *\n+   * @param pathname - The pathname to match.\n+   * @returns The dynamic route that matches the pathname.\n+   */\n+  public match(\n+    pathname: string\n+  ): DeepReadonly<DynamicPrerenderManifestRoute> | null {\n+    // Iterate over the matchers. They're already in the correct order of\n+    // specificity as they were inserted into the prerender manifest that way\n+    // and iterating over them with Object.entries guarantees that.\n+    for (const matcher of this.matchers) {\n+      // Lazily create the matcher, this is only done once per matcher.\n+      if (!matcher.matcher) {\n+        matcher.matcher = getRouteMatcher(getRouteRegex(matcher.source))\n+      }\n+\n+      const match = matcher.matcher(pathname)\n+      if (match) {\n+        return matcher.route\n+      }\n+    }\n+\n+    return null\n+  }\n+}"
        },
        {
            "sha": "beb4137912a63cc2e998628af84da522f6186744",
            "filename": "packages/next/src/server/route-modules/app-page/module.ts",
            "status": "modified",
            "additions": 25,
            "deletions": 0,
            "changes": 25,
            "blob_url": "https://github.com/vercel/next.js/blob/d884398da6c55f662115cd1b3ff19e72fb6bb8d5/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Fapp-page%2Fmodule.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d884398da6c55f662115cd1b3ff19e72fb6bb8d5/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Fapp-page%2Fmodule.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Fapp-page%2Fmodule.ts?ref=d884398da6c55f662115cd1b3ff19e72fb6bb8d5",
            "patch": "@@ -3,6 +3,7 @@ import type RenderResult from '../../render-result'\n import type { RenderOpts } from '../../app-render/types'\n import type { NextParsedUrlQuery } from '../../request-meta'\n import type { LoaderTree } from '../../lib/app-dir-module'\n+import type { PrerenderManifest } from '../../../build'\n \n import {\n   renderToHTMLOrFlight,\n@@ -17,6 +18,8 @@ import * as vendoredContexts from './vendored/contexts/entrypoints'\n import type { BaseNextRequest, BaseNextResponse } from '../../base-http'\n import type { ServerComponentsHmrCache } from '../../response-cache'\n import type { FallbackRouteParams } from '../../request/fallback-params'\n+import { PrerenderManifestMatcher } from './helpers/prerender-manifest-matcher'\n+import type { DeepReadonly } from '../../../shared/lib/deep-readonly'\n \n let vendoredReactRSC\n let vendoredReactSSR\n@@ -67,6 +70,28 @@ export class AppPageRouteModule extends RouteModule<\n     this.isAppRouter = true\n   }\n \n+  private matchers = new WeakMap<\n+    DeepReadonly<PrerenderManifest>,\n+    PrerenderManifestMatcher\n+  >()\n+  public match(\n+    pathname: string,\n+    prerenderManifest: DeepReadonly<PrerenderManifest>\n+  ) {\n+    // Lazily create the matcher based on the provided prerender manifest.\n+    let matcher = this.matchers.get(prerenderManifest)\n+    if (!matcher) {\n+      matcher = new PrerenderManifestMatcher(\n+        this.definition.pathname,\n+        prerenderManifest\n+      )\n+      this.matchers.set(prerenderManifest, matcher)\n+    }\n+\n+    // Match the pathname to the dynamic route.\n+    return matcher.match(pathname)\n+  }\n+\n   public render(\n     req: BaseNextRequest,\n     res: BaseNextResponse,"
        },
        {
            "sha": "4ef0cf2804ae17c835e96a9a3566b719a7c4a159",
            "filename": "test/e2e/app-dir/sub-shell-generation/app/[lang]/[slug]/page.tsx",
            "status": "added",
            "additions": 20,
            "deletions": 0,
            "changes": 20,
            "blob_url": "https://github.com/vercel/next.js/blob/d884398da6c55f662115cd1b3ff19e72fb6bb8d5/test%2Fe2e%2Fapp-dir%2Fsub-shell-generation%2Fapp%2F%5Blang%5D%2F%5Bslug%5D%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/d884398da6c55f662115cd1b3ff19e72fb6bb8d5/test%2Fe2e%2Fapp-dir%2Fsub-shell-generation%2Fapp%2F%5Blang%5D%2F%5Bslug%5D%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsub-shell-generation%2Fapp%2F%5Blang%5D%2F%5Bslug%5D%2Fpage.tsx?ref=d884398da6c55f662115cd1b3ff19e72fb6bb8d5",
            "patch": "@@ -0,0 +1,20 @@\n+import { getSentinelValue } from '../../sentinel'\n+\n+export default async function Page({\n+  params,\n+}: {\n+  params: Promise<{ lang: string; slug: string }>\n+}) {\n+  const { slug } = await params\n+\n+  return (\n+    <>\n+      <p id=\"page\">Page: ({getSentinelValue()})</p>\n+      <p>slug: {slug}</p>\n+    </>\n+  )\n+}\n+\n+export function generateStaticParams({ params }: { params: { lang: string } }) {\n+  return params.lang === 'fr' ? [{ slug: '1' }] : []\n+}"
        },
        {
            "sha": "25d39143e2a169b6e76e4393cb58489b2e3ccc04",
            "filename": "test/e2e/app-dir/sub-shell-generation/app/[lang]/layout.tsx",
            "status": "added",
            "additions": 28,
            "deletions": 0,
            "changes": 28,
            "blob_url": "https://github.com/vercel/next.js/blob/d884398da6c55f662115cd1b3ff19e72fb6bb8d5/test%2Fe2e%2Fapp-dir%2Fsub-shell-generation%2Fapp%2F%5Blang%5D%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/d884398da6c55f662115cd1b3ff19e72fb6bb8d5/test%2Fe2e%2Fapp-dir%2Fsub-shell-generation%2Fapp%2F%5Blang%5D%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsub-shell-generation%2Fapp%2F%5Blang%5D%2Flayout.tsx?ref=d884398da6c55f662115cd1b3ff19e72fb6bb8d5",
            "patch": "@@ -0,0 +1,28 @@\n+import { ReactNode, Suspense } from 'react'\n+import { getSentinelValue } from '../sentinel'\n+\n+export default async function LangLayout({\n+  children,\n+  params,\n+}: {\n+  children: ReactNode\n+  params: Promise<{ lang: string }>\n+}) {\n+  const { lang } = await params\n+\n+  return (\n+    <>\n+      <div id=\"lang-layout\">Lang Layout: ({getSentinelValue()})</div>\n+      <h1>lang: {lang}</h1>\n+      <main>\n+        <Suspense fallback={<p id=\"loading\">Loading...</p>}>\n+          {children}\n+        </Suspense>\n+      </main>\n+    </>\n+  )\n+}\n+\n+export function generateStaticParams() {\n+  return [{ lang: 'en' }, { lang: 'fr' }]\n+}"
        },
        {
            "sha": "28616f35725b4703c1581aa611eaef9ea1660af2",
            "filename": "test/e2e/app-dir/sub-shell-generation/app/layout.tsx",
            "status": "added",
            "additions": 17,
            "deletions": 0,
            "changes": 17,
            "blob_url": "https://github.com/vercel/next.js/blob/d884398da6c55f662115cd1b3ff19e72fb6bb8d5/test%2Fe2e%2Fapp-dir%2Fsub-shell-generation%2Fapp%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/d884398da6c55f662115cd1b3ff19e72fb6bb8d5/test%2Fe2e%2Fapp-dir%2Fsub-shell-generation%2Fapp%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsub-shell-generation%2Fapp%2Flayout.tsx?ref=d884398da6c55f662115cd1b3ff19e72fb6bb8d5",
            "patch": "@@ -0,0 +1,17 @@\n+'use cache'\n+\n+import { ReactNode, Suspense } from 'react'\n+import { getSentinelValue } from './sentinel'\n+\n+export default async function Root({ children }: { children: ReactNode }) {\n+  return (\n+    <html>\n+      <body>\n+        <div id=\"root-layout\">Root Layout: ({getSentinelValue()})</div>\n+        <Suspense fallback={<p id=\"loading\">Loading...</p>}>\n+          {children}\n+        </Suspense>\n+      </body>\n+    </html>\n+  )\n+}"
        },
        {
            "sha": "4571ba8f47bb8f0b9754bc789cfce6c305160536",
            "filename": "test/e2e/app-dir/sub-shell-generation/app/sentinel.ts",
            "status": "added",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/d884398da6c55f662115cd1b3ff19e72fb6bb8d5/test%2Fe2e%2Fapp-dir%2Fsub-shell-generation%2Fapp%2Fsentinel.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d884398da6c55f662115cd1b3ff19e72fb6bb8d5/test%2Fe2e%2Fapp-dir%2Fsub-shell-generation%2Fapp%2Fsentinel.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsub-shell-generation%2Fapp%2Fsentinel.ts?ref=d884398da6c55f662115cd1b3ff19e72fb6bb8d5",
            "patch": "@@ -0,0 +1,7 @@\n+const { PHASE_PRODUCTION_BUILD } = require('next/constants')\n+\n+export function getSentinelValue() {\n+  return process.env.NEXT_PHASE === PHASE_PRODUCTION_BUILD\n+    ? 'buildtime'\n+    : 'runtime'\n+}"
        },
        {
            "sha": "ac4afcf432196896657dae6577717292a9b9e15e",
            "filename": "test/e2e/app-dir/sub-shell-generation/next.config.js",
            "status": "added",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/d884398da6c55f662115cd1b3ff19e72fb6bb8d5/test%2Fe2e%2Fapp-dir%2Fsub-shell-generation%2Fnext.config.js",
            "raw_url": "https://github.com/vercel/next.js/raw/d884398da6c55f662115cd1b3ff19e72fb6bb8d5/test%2Fe2e%2Fapp-dir%2Fsub-shell-generation%2Fnext.config.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsub-shell-generation%2Fnext.config.js?ref=d884398da6c55f662115cd1b3ff19e72fb6bb8d5",
            "patch": "@@ -0,0 +1,10 @@\n+/**\n+ * @type {import('next').NextConfig}\n+ */\n+const nextConfig = {\n+  experimental: {\n+    dynamicIO: true,\n+  },\n+}\n+\n+module.exports = nextConfig"
        },
        {
            "sha": "4c02303e4a14943fc26024d42ccdf69fdc07d54f",
            "filename": "test/e2e/app-dir/sub-shell-generation/sub-shell-generation.test.ts",
            "status": "added",
            "additions": 84,
            "deletions": 0,
            "changes": 84,
            "blob_url": "https://github.com/vercel/next.js/blob/d884398da6c55f662115cd1b3ff19e72fb6bb8d5/test%2Fe2e%2Fapp-dir%2Fsub-shell-generation%2Fsub-shell-generation.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d884398da6c55f662115cd1b3ff19e72fb6bb8d5/test%2Fe2e%2Fapp-dir%2Fsub-shell-generation%2Fsub-shell-generation.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsub-shell-generation%2Fsub-shell-generation.test.ts?ref=d884398da6c55f662115cd1b3ff19e72fb6bb8d5",
            "patch": "@@ -0,0 +1,84 @@\n+import { nextTestSetup } from 'e2e-utils'\n+import * as cheerio from 'cheerio'\n+\n+describe('sub-shell-generation', () => {\n+  const { next, isNextDev, isNextDeploy } = nextTestSetup({\n+    files: __dirname,\n+  })\n+\n+  if (isNextDev) {\n+    it.skip('skipping dev test', () => {})\n+    return\n+  }\n+\n+  describe('should serve the correct shell', () => {\n+    describe.each([\n+      [\n+        '/[lang]/[slug]',\n+        {\n+          page: 'Page: (runtime)',\n+          langLayout: 'Lang Layout: (runtime)',\n+          rootLayout: 'Root Layout: (buildtime)',\n+        },\n+        ['/es/1', '/es/2'],\n+        true,\n+      ],\n+      [\n+        '/en/[slug]',\n+        {\n+          page: 'Page: (runtime)',\n+          langLayout: 'Lang Layout: (buildtime)',\n+          rootLayout: 'Root Layout: (buildtime)',\n+        },\n+        ['/en/1', '/en/2'],\n+        true,\n+      ],\n+      [\n+        '/fr/[slug]',\n+        {\n+          page: 'Page: (runtime)',\n+          langLayout: 'Lang Layout: (buildtime)',\n+          rootLayout: 'Root Layout: (buildtime)',\n+        },\n+        ['/fr/2', '/fr/3'],\n+        true,\n+      ],\n+      [\n+        '/fr/1',\n+        {\n+          page: 'Page: (buildtime)',\n+          langLayout: 'Lang Layout: (buildtime)',\n+          rootLayout: 'Root Layout: (buildtime)',\n+        },\n+        ['/fr/1'],\n+        false,\n+      ],\n+    ])('%s', (shell, { page, langLayout, rootLayout }, paths, isPostponed) => {\n+      it.each(paths)('should serve the correct shell for %s', async (path) => {\n+        const res = await next.fetch(path)\n+        expect(res.status).toBe(200)\n+\n+        if (isNextDeploy) {\n+          expect(res.headers.get('x-matched-path')).toBe(shell)\n+        } else {\n+          expect(res.headers.get('x-nextjs-postponed')).toBe(\n+            isPostponed ? '1' : null\n+          )\n+        }\n+\n+        const html = await res.text()\n+        const $ = cheerio.load(html)\n+\n+        expect({\n+          page: $('#page').text(),\n+          langLayout: $('#lang-layout').text(),\n+          rootLayout: $('#root-layout').text(),\n+        }).toEqual({\n+          page,\n+          langLayout,\n+          rootLayout,\n+        })\n+      })\n+    })\n+  })\n+})"
        }
    ],
    "stats": {
        "total": 1508,
        "additions": 1382,
        "deletions": 126
    }
}