{
    "author": "unstubbable",
    "message": "Use `onPostpone` to determine if segment prefetch is partial (#79299)\n\nWhen dynamicIO is enabled, missing data is encoded to an infinitely hanging promise, the absence of which we use to determine if a segment is fully static or partially static. However, when dynamicIO is not enabled, this trick doesn't work.\r\n\r\nPreviously, if PPR is enabled, and dynamicIO is not, we were conservative and assumed that all segments are partial. That doesn't need to be the case, though. We can use the `onPostpone` callback of the `prerender` function to determine if a given RSC node is partial.\r\n\r\nTo make sure that this works as expected, we're disabling `dynamicIO` in `test/e2e/app-dir/segment-cache/incremental-opt-in`.\r\n\r\nWithout this change, the following tests would fail because additional requests for the PPR-enabled routes are triggered when `dynamicIO` is disabled:\r\n\r\n- `when a link is prefetched with <Link prefetch=true>, no dynamic request is made on navigation`\r\n- `when prefetching with prefetch=true, refetches cache entries that only contain partial data`\r\n- `when prefetching with prefetch=true, refetches partial cache entries even if there's already a pending PPR request`\r\n\r\nIn addition, we're also disabling `dynamicIO` in `test/e2e/app-dir/segment-cache/client-only-opt-in` as well as\r\n`test/e2e/app-dir/segment-cache/export`, to prepare for an upcoming change where `ppr` will be enabled automatically when `dynamicIO` is enabled. Those three tests are then not compatible with `dynamicIO` because they either rely on the `'incremental'` PPR config, or on `output: 'export'`.",
    "sha": "e2837fb3b485bde391f1dfb1d6fdb87f4bd71d1e",
    "files": [
        {
            "sha": "4cd6e97ad2275a2ba675fd5e729b0476dd4ff60b",
            "filename": ".changeset/shaggy-pears-tell.md",
            "status": "added",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/e2837fb3b485bde391f1dfb1d6fdb87f4bd71d1e/.changeset%2Fshaggy-pears-tell.md",
            "raw_url": "https://github.com/vercel/next.js/raw/e2837fb3b485bde391f1dfb1d6fdb87f4bd71d1e/.changeset%2Fshaggy-pears-tell.md",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/.changeset%2Fshaggy-pears-tell.md?ref=e2837fb3b485bde391f1dfb1d6fdb87f4bd71d1e",
            "patch": "@@ -0,0 +1,5 @@\n+---\n+\"next\": patch\n+---\n+\n+Use `onPostpone` to determine if segment prefetch is partial"
        },
        {
            "sha": "3f127d1763dd29c6bc19a5782a079ff567ba5561",
            "filename": "packages/next/src/server/app-render/app-render.tsx",
            "status": "modified",
            "additions": 0,
            "deletions": 19,
            "changes": 19,
            "blob_url": "https://github.com/vercel/next.js/blob/e2837fb3b485bde391f1dfb1d6fdb87f4bd71d1e/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/e2837fb3b485bde391f1dfb1d6fdb87f4bd71d1e/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx?ref=e2837fb3b485bde391f1dfb1d6fdb87f4bd71d1e",
            "patch": "@@ -4258,27 +4258,8 @@ async function collectSegmentData(\n     serverModuleMap: null,\n   }\n \n-  // When dynamicIO is enabled, missing data is encoded to an infinitely hanging\n-  // promise, the absence of which we use to determine if a segment is fully\n-  // static or partially static. However, when dynamicIO is not enabled, this\n-  // trick doesn't work.\n-  //\n-  // So if PPR is enabled, and dynamicIO is not, we have to be conservative and\n-  // assume all segments are partial.\n-  //\n-  // TODO: When PPR is on, we can at least optimize the case where the entire\n-  // page is static. Either by passing that as an argument to this function, or\n-  // by setting a header on the response like the we do for full page RSC\n-  // prefetches today. The latter approach might be simpler since it requires\n-  // less plumbing, and the client has to check the header regardless to see if\n-  // PPR is enabled.\n-  const shouldAssumePartialData =\n-    renderOpts.experimental.isRoutePPREnabled === true && // PPR is enabled\n-    !renderOpts.experimental.dynamicIO // dynamicIO is disabled\n-\n   const staleTime = prerenderStore.stale\n   return await ComponentMod.collectSegmentData(\n-    shouldAssumePartialData,\n     fullPageDataBuffer,\n     staleTime,\n     clientReferenceManifest.clientModules as ManifestNode,"
        },
        {
            "sha": "d595b4d8799adce27d4fd43a5c3fd7180664fdc2",
            "filename": "packages/next/src/server/app-render/collect-segment-data.tsx",
            "status": "modified",
            "additions": 8,
            "deletions": 19,
            "changes": 27,
            "blob_url": "https://github.com/vercel/next.js/blob/e2837fb3b485bde391f1dfb1d6fdb87f4bd71d1e/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcollect-segment-data.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/e2837fb3b485bde391f1dfb1d6fdb87f4bd71d1e/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcollect-segment-data.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcollect-segment-data.tsx?ref=e2837fb3b485bde391f1dfb1d6fdb87f4bd71d1e",
            "patch": "@@ -74,7 +74,6 @@ function onSegmentPrerenderError(error: unknown) {\n }\n \n export async function collectSegmentData(\n-  shouldAssumePartialData: boolean,\n   fullPageDataBuffer: Buffer,\n   staleTime: number,\n   clientModules: ManifestNode,\n@@ -119,7 +118,6 @@ export async function collectSegmentData(\n     // inside of it, the side effects are transferred to the new stream.\n     // @ts-expect-error\n     <PrefetchTreeData\n-      shouldAssumePartialData={shouldAssumePartialData}\n       fullPageDataBuffer={fullPageDataBuffer}\n       fallbackRouteParams={fallbackRouteParams}\n       serverConsumerManifest={serverConsumerManifest}\n@@ -150,7 +148,6 @@ export async function collectSegmentData(\n }\n \n async function PrefetchTreeData({\n-  shouldAssumePartialData,\n   fullPageDataBuffer,\n   fallbackRouteParams,\n   serverConsumerManifest,\n@@ -159,7 +156,6 @@ async function PrefetchTreeData({\n   segmentTasks,\n   onCompletedProcessingRouteTree,\n }: {\n-  shouldAssumePartialData: boolean\n   fullPageDataBuffer: Buffer\n   serverConsumerManifest: any\n   fallbackRouteParams: FallbackRouteParams | null\n@@ -199,7 +195,6 @@ async function PrefetchTreeData({\n   // walk the tree, we will also spawn a task to produce a prefetch response for\n   // each segment.\n   const tree = collectSegmentDataImpl(\n-    shouldAssumePartialData,\n     flightRouterState,\n     buildId,\n     seedData,\n@@ -211,8 +206,7 @@ async function PrefetchTreeData({\n     segmentTasks\n   )\n \n-  const isHeadPartial =\n-    shouldAssumePartialData || (await isPartialRSCData(head, clientModules))\n+  const isHeadPartial = await isPartialRSCData(head, clientModules)\n \n   // Notify the abort controller that we're done processing the route tree.\n   // Anything async that happens after this point must be due to hanging\n@@ -231,7 +225,6 @@ async function PrefetchTreeData({\n }\n \n function collectSegmentDataImpl(\n-  shouldAssumePartialData: boolean,\n   route: FlightRouterState,\n   buildId: string,\n   seedData: CacheNodeSeedData | null,\n@@ -265,7 +258,6 @@ function collectSegmentDataImpl(\n         : encodeSegment(childSegment)\n     )\n     const childTree = collectSegmentDataImpl(\n-      shouldAssumePartialData,\n       childRoute,\n       buildId,\n       childSeedData,\n@@ -288,13 +280,7 @@ function collectSegmentDataImpl(\n       // Since we're already in the middle of a render, wait until after the\n       // current task to escape the current rendering context.\n       waitAtLeastOneReactRenderTask().then(() =>\n-        renderSegmentPrefetch(\n-          shouldAssumePartialData,\n-          buildId,\n-          seedData,\n-          key,\n-          clientModules\n-        )\n+        renderSegmentPrefetch(buildId, seedData, key, clientModules)\n       )\n     )\n   } else {\n@@ -344,7 +330,6 @@ function encodeSegmentWithPossibleFallbackParam(\n }\n \n async function renderSegmentPrefetch(\n-  shouldAssumePartialData: boolean,\n   buildId: string,\n   seedData: CacheNodeSeedData,\n   key: string,\n@@ -359,8 +344,7 @@ async function renderSegmentPrefetch(\n     buildId,\n     rsc,\n     loading,\n-    isPartial:\n-      shouldAssumePartialData || (await isPartialRSCData(rsc, clientModules)),\n+    isPartial: await isPartialRSCData(rsc, clientModules),\n   }\n   // Since all we're doing is decoding and re-encoding a cached prerender, if\n   // it takes longer than a microtask, it must because of hanging promises\n@@ -403,6 +387,11 @@ async function isPartialRSCData(\n   await prerender(rsc, clientModules, {\n     signal: abortController.signal,\n     onError() {},\n+    onPostpone() {\n+      // If something postponed, i.e. when Dynamic IO is not enabled, we can\n+      // infer that the RSC data is partial.\n+      isPartial = true\n+    },\n   })\n   return isPartial\n }"
        },
        {
            "sha": "209191815e9e486137f805dc6f333ca424baa018",
            "filename": "test/e2e/app-dir/segment-cache/client-only-opt-in/next.config.js",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/e2837fb3b485bde391f1dfb1d6fdb87f4bd71d1e/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fclient-only-opt-in%2Fnext.config.js",
            "raw_url": "https://github.com/vercel/next.js/raw/e2837fb3b485bde391f1dfb1d6fdb87f4bd71d1e/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fclient-only-opt-in%2Fnext.config.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fclient-only-opt-in%2Fnext.config.js?ref=e2837fb3b485bde391f1dfb1d6fdb87f4bd71d1e",
            "patch": "@@ -4,7 +4,6 @@\n const nextConfig = {\n   experimental: {\n     ppr: 'incremental',\n-    dynamicIO: true,\n     clientSegmentCache: 'client-only',\n   },\n }"
        },
        {
            "sha": "62ddfa93abf32bfda2a02dd69c610ffa08f782cb",
            "filename": "test/e2e/app-dir/segment-cache/export/next.config.js",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/e2837fb3b485bde391f1dfb1d6fdb87f4bd71d1e/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fexport%2Fnext.config.js",
            "raw_url": "https://github.com/vercel/next.js/raw/e2837fb3b485bde391f1dfb1d6fdb87f4bd71d1e/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fexport%2Fnext.config.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fexport%2Fnext.config.js?ref=e2837fb3b485bde391f1dfb1d6fdb87f4bd71d1e",
            "patch": "@@ -4,8 +4,6 @@\n const nextConfig = {\n   output: 'export',\n   experimental: {\n-    ppr: false,\n-    dynamicIO: true,\n     clientSegmentCache: true,\n   },\n }"
        },
        {
            "sha": "1fb210a73ee9e6f11234061e02479b5ad42f5da8",
            "filename": "test/e2e/app-dir/segment-cache/incremental-opt-in/next.config.js",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/e2837fb3b485bde391f1dfb1d6fdb87f4bd71d1e/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fincremental-opt-in%2Fnext.config.js",
            "raw_url": "https://github.com/vercel/next.js/raw/e2837fb3b485bde391f1dfb1d6fdb87f4bd71d1e/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fincremental-opt-in%2Fnext.config.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fincremental-opt-in%2Fnext.config.js?ref=e2837fb3b485bde391f1dfb1d6fdb87f4bd71d1e",
            "patch": "@@ -4,7 +4,6 @@\n const nextConfig = {\n   experimental: {\n     ppr: 'incremental',\n-    dynamicIO: true,\n     clientSegmentCache: true,\n   },\n }"
        },
        {
            "sha": "9a6cd1ab2df31d3c6804abe935aef5f6568dc1e3",
            "filename": "test/ppr-tests-manifest.json",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/e2837fb3b485bde391f1dfb1d6fdb87f4bd71d1e/test%2Fppr-tests-manifest.json",
            "raw_url": "https://github.com/vercel/next.js/raw/e2837fb3b485bde391f1dfb1d6fdb87f4bd71d1e/test%2Fppr-tests-manifest.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fppr-tests-manifest.json?ref=e2837fb3b485bde391f1dfb1d6fdb87f4bd71d1e",
            "patch": "@@ -97,6 +97,7 @@\n       \"test/e2e/app-dir/static-shell-debugging/static-shell-debugging.test.ts\",\n       \"test/e2e/app-dir/dynamic-io-errors/dynamic-io-errors.prospective-fallback.test.ts\",\n       \"test/e2e/app-dir/segment-cache/basic/segment-cache-basic.test.ts\",\n+      \"test/e2e/app-dir/segment-cache/export/segment-cache-output-export.test.ts\",\n       \"test/e2e/app-dir/segment-cache/incremental-opt-in/segment-cache-incremental-opt-in.test.ts\",\n       \"test/e2e/app-dir/segment-cache/memory-pressure/segment-cache-memory-pressure.test.ts\",\n       \"test/e2e/app-dir/segment-cache/prefetch-scheduling/prefetch-scheduling.test.ts\","
        }
    ],
    "stats": {
        "total": 56,
        "additions": 14,
        "deletions": 42
    }
}