{
    "author": "acdlite",
    "message": "Create initial tree using same function as navigations (#87147)\n\nBased on:\n\n- #87128 \n\n---\n\nSmall refactor. During the initial render to hydrate the page, we create\nthe CacheNode tree using the same function that is used to create new\ntrees during soft navigation.\n\nUnlike during a soft navigation, we intentionally don't check if any\ndata needs to be fetched from the server. We assume the initial\nhydration payload is sufficient to render the page.\n\nThe completeness of the initial data is an important property that we\nrely on as a last-ditch mechanism for recovering the app; we must always\nbe able to reload a fresh HTML document to get to a consistent state.\n\nThis was one of the last remaining places where\nfillLazyItemsTillLeafWithHead was used.",
    "sha": "ed3b127191a1ad5ef7b0a1b5d9e46a45153fa676",
    "files": [
        {
            "sha": "a314fa32904fe0b045e9d8c24bc658c2d822daa1",
            "filename": "packages/next/src/client/app-index.tsx",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/ed3b127191a1ad5ef7b0a1b5d9e46a45153fa676/packages%2Fnext%2Fsrc%2Fclient%2Fapp-index.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/ed3b127191a1ad5ef7b0a1b5d9e46a45153fa676/packages%2Fnext%2Fsrc%2Fclient%2Fapp-index.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fapp-index.tsx?ref=ed3b127191a1ad5ef7b0a1b5d9e46a45153fa676",
            "patch": "@@ -318,7 +318,6 @@ export async function hydrate(\n       initialFlightData: initialRSCPayload.f,\n       initialCanonicalUrlParts: initialRSCPayload.c,\n       initialRenderedSearch: initialRSCPayload.q,\n-      initialParallelRoutes: new Map(),\n       location: window.location,\n     }),\n     instrumentationHooks"
        },
        {
            "sha": "ab39896e860c2f9a45a83b8118958f0bb9aea7b7",
            "filename": "packages/next/src/client/components/router-reducer/create-initial-router-state.test.tsx",
            "status": "removed",
            "additions": 0,
            "deletions": 128,
            "changes": 128,
            "blob_url": "https://github.com/vercel/next.js/blob/6270c09c20a0c6c66e40f69c47e783be017506e7/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fcreate-initial-router-state.test.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/6270c09c20a0c6c66e40f69c47e783be017506e7/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fcreate-initial-router-state.test.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fcreate-initial-router-state.test.tsx?ref=6270c09c20a0c6c66e40f69c47e783be017506e7",
            "patch": "@@ -1,128 +0,0 @@\n-import React from 'react'\n-import type {\n-  FlightRouterState,\n-  CacheNode,\n-} from '../../../shared/lib/app-router-types'\n-import { createInitialRouterState } from './create-initial-router-state'\n-\n-const getInitialRouterStateTree = (): FlightRouterState => [\n-  '',\n-  {\n-    children: [\n-      'linking',\n-      {\n-        children: ['', {}],\n-      },\n-    ],\n-  },\n-  undefined,\n-  undefined,\n-  true,\n-]\n-\n-const navigatedAt = Date.now()\n-\n-describe('createInitialRouterState', () => {\n-  it('should return the correct initial router state', () => {\n-    const initialTree = getInitialRouterStateTree()\n-    const initialCanonicalUrl = '/linking'\n-    const children = (\n-      <html>\n-        <head></head>\n-        <body>Root layout</body>\n-      </html>\n-    )\n-    const initialParallelRoutes: CacheNode['parallelRoutes'] = new Map()\n-\n-    const state = createInitialRouterState({\n-      navigatedAt,\n-      initialFlightData: [[initialTree, [children, {}, null]]],\n-      initialCanonicalUrlParts: initialCanonicalUrl.split('/'),\n-      initialRenderedSearch: '',\n-      initialParallelRoutes,\n-      location: new URL('/linking', 'https://localhost') as any,\n-    })\n-\n-    const state2 = createInitialRouterState({\n-      navigatedAt,\n-      initialFlightData: [[initialTree, [children, {}, null]]],\n-      initialCanonicalUrlParts: initialCanonicalUrl.split('/'),\n-      initialRenderedSearch: '',\n-      initialParallelRoutes,\n-      location: new URL('/linking', 'https://localhost') as any,\n-    })\n-\n-    const expectedCache: CacheNode = {\n-      navigatedAt,\n-      lazyData: null,\n-      rsc: children,\n-      prefetchRsc: null,\n-      head: null,\n-      prefetchHead: null,\n-      loading: null,\n-      parallelRoutes: new Map([\n-        [\n-          'children',\n-          new Map([\n-            [\n-              'linking',\n-              {\n-                navigatedAt,\n-                parallelRoutes: new Map([\n-                  [\n-                    'children',\n-                    new Map([\n-                      [\n-                        '',\n-                        {\n-                          navigatedAt,\n-                          lazyData: null,\n-                          rsc: null,\n-                          prefetchRsc: null,\n-                          parallelRoutes: new Map(),\n-                          loading: null,\n-                          head: null,\n-                          prefetchHead: null,\n-                        },\n-                      ],\n-                    ]),\n-                  ],\n-                ]),\n-                lazyData: null,\n-                rsc: null,\n-                prefetchRsc: null,\n-                head: null,\n-                prefetchHead: null,\n-                loading: null,\n-              },\n-            ],\n-          ]),\n-        ],\n-      ]),\n-    }\n-\n-    const expected: ReturnType<typeof createInitialRouterState> = {\n-      tree: initialTree,\n-      canonicalUrl: initialCanonicalUrl,\n-      renderedSearch: '',\n-      pushRef: {\n-        pendingPush: false,\n-        mpaNavigation: false,\n-        preserveCustomHistoryState: true,\n-      },\n-      focusAndScrollRef: {\n-        apply: false,\n-        onlyHashChange: false,\n-        hashFragment: null,\n-        segmentPaths: [],\n-      },\n-      cache: expectedCache,\n-      nextUrl: '/linking',\n-      previousNextUrl: null,\n-      debugInfo: null,\n-    }\n-\n-    expect(state).toMatchObject(expected)\n-    expect(state2).toMatchObject(expected)\n-  })\n-})"
        },
        {
            "sha": "23c2dbd1b947c6b0453da5b6caee8863c757a44a",
            "filename": "packages/next/src/client/components/router-reducer/create-initial-router-state.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 32,
            "changes": 38,
            "blob_url": "https://github.com/vercel/next.js/blob/ed3b127191a1ad5ef7b0a1b5d9e46a45153fa676/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fcreate-initial-router-state.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/ed3b127191a1ad5ef7b0a1b5d9e46a45153fa676/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fcreate-initial-router-state.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fcreate-initial-router-state.ts?ref=ed3b127191a1ad5ef7b0a1b5d9e46a45153fa676",
            "patch": "@@ -1,20 +1,16 @@\n-import type {\n-  CacheNode,\n-  FlightDataPath,\n-} from '../../../shared/lib/app-router-types'\n+import type { FlightDataPath } from '../../../shared/lib/app-router-types'\n \n import { createHrefFromUrl } from './create-href-from-url'\n-import { fillLazyItemsTillLeafWithHead } from './fill-lazy-items-till-leaf-with-head'\n import { extractPathFromFlightRouterState } from './compute-changed-path'\n \n import type { AppRouterState } from './router-reducer-types'\n import { getFlightDataPartsFromPath } from '../../flight-data-helpers'\n+import { createInitialCacheNodeForHydration } from './ppr-navigations'\n \n export interface InitialRouterStateParameters {\n   navigatedAt: number\n   initialCanonicalUrlParts: string[]\n   initialRenderedSearch: string\n-  initialParallelRoutes: CacheNode['parallelRoutes']\n   initialFlightData: FlightDataPath[]\n   location: Location | null\n }\n@@ -24,7 +20,6 @@ export function createInitialRouterState({\n   initialFlightData,\n   initialCanonicalUrlParts,\n   initialRenderedSearch,\n-  initialParallelRoutes,\n   location,\n }: InitialRouterStateParameters): AppRouterState {\n   // When initialized on the server, the canonical URL is provided as an array of parts.\n@@ -40,20 +35,6 @@ export function createInitialRouterState({\n   } = normalizedFlightData\n   // For the SSR render, seed data should always be available (we only send back a `null` response\n   // in the case of a `loading` segment, pre-PPR.)\n-  const rsc = initialSeedData?.[0]\n-  const loading = initialSeedData?.[2] ?? null\n-\n-  const cache: CacheNode = {\n-    lazyData: null,\n-    rsc,\n-    prefetchRsc: null,\n-    head: null,\n-    prefetchHead: null,\n-    // The cache gets seeded during the first render. `initialParallelRoutes` ensures the cache from the first render is there during the second render.\n-    parallelRoutes: initialParallelRoutes,\n-    loading,\n-    navigatedAt,\n-  }\n \n   const canonicalUrl =\n     // location.href is read as the initial value for canonicalUrl in the browser\n@@ -63,21 +44,14 @@ export function createInitialRouterState({\n         createHrefFromUrl(location)\n       : initialCanonicalUrl\n \n-  // When the cache hasn't been seeded yet we fill the cache with the head.\n-  if (initialParallelRoutes === null || initialParallelRoutes.size === 0) {\n-    fillLazyItemsTillLeafWithHead(\n+  const initialState = {\n+    tree: initialTree,\n+    cache: createInitialCacheNodeForHydration(\n       navigatedAt,\n-      cache,\n-      undefined,\n       initialTree,\n       initialSeedData,\n       initialHead\n-    )\n-  }\n-\n-  const initialState = {\n-    tree: initialTree,\n-    cache,\n+    ),\n     pushRef: {\n       pendingPush: false,\n       mpaNavigation: false,"
        },
        {
            "sha": "83c452df57b0cd9f393709ba175879853578fc1b",
            "filename": "packages/next/src/client/components/router-reducer/ppr-navigations.ts",
            "status": "modified",
            "additions": 142,
            "deletions": 33,
            "changes": 175,
            "blob_url": "https://github.com/vercel/next.js/blob/ed3b127191a1ad5ef7b0a1b5d9e46a45153fa676/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fppr-navigations.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/ed3b127191a1ad5ef7b0a1b5d9e46a45153fa676/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fppr-navigations.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fppr-navigations.ts?ref=ed3b127191a1ad5ef7b0a1b5d9e46a45153fa676",
            "patch": "@@ -52,6 +52,7 @@ export type NavigationTask = {\n \n export const enum FreshnessPolicy {\n   Default,\n+  Hydration,\n   HistoryTraversal,\n   RefreshAll,\n }\n@@ -61,6 +62,52 @@ export type NavigationRequestAccumulation = {\n   separateRefreshUrls: Set<string> | null\n }\n \n+export function createInitialCacheNodeForHydration(\n+  navigatedAt: number,\n+  initialTree: FlightRouterState,\n+  seedData: CacheNodeSeedData | null,\n+  seedHead: HeadData\n+): CacheNode {\n+  // Create the initial cache node tree, using the data embedded into the\n+  // HTML document.\n+  const accumulation: NavigationRequestAccumulation = {\n+    scrollableSegments: null,\n+    separateRefreshUrls: null,\n+  }\n+  const task = createCacheNodeOnNavigation(\n+    navigatedAt,\n+    initialTree,\n+    undefined,\n+    FreshnessPolicy.Hydration,\n+    seedData,\n+    seedHead,\n+    null,\n+    null,\n+    false,\n+    null,\n+    null,\n+    false,\n+    accumulation\n+  )\n+\n+  // NOTE: We intentionally don't check if any data needs to be fetched from the\n+  // server. We assume the initial hydration payload is sufficient to render\n+  // the page.\n+  //\n+  // The completeness of the initial data is an important property that we rely\n+  // on as a last-ditch mechanism for recovering the app; we must always be able\n+  // to reload a fresh HTML document to get to a consistent state.\n+  //\n+  // In the future, there may be cases where the server intentionally sends\n+  // partial data and expects the client to fill in the rest, in which case this\n+  // logic may change. (There already is a similar case where the server sends\n+  // _no_ hydration data in the HTML document at all, and the client fetches it\n+  // separately, but that's different because we still end up hydrating with a\n+  // complete tree.)\n+\n+  return task.node\n+}\n+\n // Creates a new Cache Node tree (i.e. copy-on-write) that represents the\n // optimistic result of a navigation, using both the current Cache Node tree and\n // data that was prefetched prior to navigation.\n@@ -258,6 +305,7 @@ function updateCacheNodeOnNavigation(\n   switch (freshness) {\n     case FreshnessPolicy.Default:\n     case FreshnessPolicy.HistoryTraversal:\n+    case FreshnessPolicy.Hydration: // <- shouldn't happen during client nav\n       // We should never drop dynamic data in shared layouts, except during\n       // a refresh.\n       shouldDropSiblingCaches = false\n@@ -346,7 +394,8 @@ function updateCacheNodeOnNavigation(\n     newCacheNode = spawnNewCacheNode(\n       newParallelRoutes,\n       isLeafSegment,\n-      navigatedAt\n+      navigatedAt,\n+      freshness\n     )\n     needsDynamicRequest = true\n   }\n@@ -429,7 +478,12 @@ function updateCacheNodeOnNavigation(\n     let seedHeadChild = seedHead\n     let prefetchHeadChild = prefetchHead\n     let isPrefetchHeadPartialChild = isPrefetchHeadPartial\n-    if (newSegmentChild === DEFAULT_SEGMENT_KEY) {\n+    if (\n+      // Skip this branch during a history traversal. We restore the tree that\n+      // was stashed in the history entry as-is.\n+      freshness !== FreshnessPolicy.HistoryTraversal &&\n+      newSegmentChild === DEFAULT_SEGMENT_KEY\n+    ) {\n       // This is a \"default\" segment. These are never sent by the server during\n       // a soft navigation; instead, the client reuses whatever segment was\n       // already active in that slot on the previous route.\n@@ -546,8 +600,8 @@ function createCacheNodeOnNavigation(\n   prefetchData: CacheNodeSeedData | null,\n   prefetchHead: HeadData | null,\n   isPrefetchHeadPartial: boolean,\n-  parentSegmentPath: FlightSegmentPath,\n-  parentParallelRouteKey: string,\n+  parentSegmentPath: FlightSegmentPath | null,\n+  parentParallelRouteKey: string | null,\n   parentNeedsDynamicRequest: boolean,\n   accumulation: NavigationRequestAccumulation\n ): NavigationTask {\n@@ -562,10 +616,11 @@ function createCacheNodeOnNavigation(\n   // diverges, which is why we keep them separate.\n \n   const newSegment = newRouterState[0]\n-  const segmentPath = parentSegmentPath.concat([\n-    parentParallelRouteKey,\n-    newSegment,\n-  ])\n+  const segmentPath =\n+    parentParallelRouteKey !== null && parentSegmentPath !== null\n+      ? parentSegmentPath.concat([parentParallelRouteKey, newSegment])\n+      : // NOTE: The root segment is intentionally omitted from the segment path\n+        []\n \n   const newRouterStateChildren = newRouterState[1]\n   const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null\n@@ -592,6 +647,13 @@ function createCacheNodeOnNavigation(\n         oldCacheNode === undefined ||\n         navigatedAt - oldCacheNode.navigatedAt >= DYNAMIC_STALETIME_MS\n \n+      dropPrefetchRsc = false\n+      break\n+    case FreshnessPolicy.Hydration:\n+      // During hydration, we assume the data sent by the server is both\n+      // consistent and complete.\n+      shouldRefreshDynamicData = false\n+      shouldDropSiblingCaches = false\n       dropPrefetchRsc = false\n       break\n     case FreshnessPolicy.HistoryTraversal:\n@@ -671,7 +733,8 @@ function createCacheNodeOnNavigation(\n     const seedRsc = seedData[0]\n     const seedLoading = seedData[2]\n     const isSeedRscPartial = false\n-    const isSeedHeadPartial = seedHead === null\n+    const isSeedHeadPartial =\n+      seedHead === null && freshness !== FreshnessPolicy.Hydration\n     newCacheNode = readCacheNodeFromSeedData(\n       seedRsc,\n       seedLoading,\n@@ -683,7 +746,31 @@ function createCacheNodeOnNavigation(\n       navigatedAt\n     )\n     needsDynamicRequest = isLeafSegment && isSeedHeadPartial\n-  } else if (prefetchData !== null) {\n+  } else if (\n+    freshness === FreshnessPolicy.Hydration &&\n+    isLeafSegment &&\n+    seedHead !== null\n+  ) {\n+    // This is another weird case related to \"not found\" pages and hydration.\n+    // There will be a head sent by the server, but no page seed data.\n+    // TODO: We really should get rid of all these \"not found\" specific quirks\n+    // and make sure the tree is always consistent.\n+    const seedRsc = null\n+    const seedLoading = null\n+    const isSeedRscPartial = false\n+    const isSeedHeadPartial = false\n+    newCacheNode = readCacheNodeFromSeedData(\n+      seedRsc,\n+      seedLoading,\n+      isSeedRscPartial,\n+      seedHead,\n+      isSeedHeadPartial,\n+      isLeafSegment,\n+      newParallelRoutes,\n+      navigatedAt\n+    )\n+    needsDynamicRequest = false\n+  } else if (freshness !== FreshnessPolicy.Hydration && prefetchData !== null) {\n     // Consult the prefetch cache.\n     const prefetchRsc = prefetchData[0]\n     const prefetchLoading = prefetchData[2]\n@@ -705,7 +792,8 @@ function createCacheNodeOnNavigation(\n     newCacheNode = spawnNewCacheNode(\n       newParallelRoutes,\n       isLeafSegment,\n-      navigatedAt\n+      navigatedAt,\n+      freshness\n     )\n     needsDynamicRequest = true\n   }\n@@ -940,11 +1028,11 @@ function reuseDynamicCacheNode(\n }\n \n function readCacheNodeFromSeedData(\n-  prefetchRsc: React.ReactNode,\n-  prefetchLoading: LoadingModuleData | Promise<LoadingModuleData>,\n-  isPrefetchRSCPartial: boolean,\n-  prefetchHead: HeadData | null,\n-  isPrefetchHeadPartial: boolean,\n+  seedRsc: React.ReactNode,\n+  seedLoading: LoadingModuleData | Promise<LoadingModuleData>,\n+  isSeedRscPartial: boolean,\n+  seedHead: HeadData | null,\n+  isSeedHeadPartial: boolean,\n   isPageSegment: boolean,\n   parallelRoutes: Map<string, ChildSegmentMap>,\n   navigatedAt: number\n@@ -954,40 +1042,44 @@ function readCacheNodeFromSeedData(\n   // the Segment Cache. See readRenderSnapshotFromCache.\n \n   let rsc: React.ReactNode\n-  if (isPrefetchRSCPartial) {\n+  let prefetchRsc: React.ReactNode\n+  if (isSeedRscPartial) {\n     // The prefetched data contains dynamic holes. Create a pending promise that\n     // will be fulfilled when the dynamic data is received from the server.\n+    prefetchRsc = seedRsc\n     rsc = createDeferredRsc()\n   } else {\n     // The prefetched data is complete. Use it directly.\n-    rsc = prefetchRsc\n+    prefetchRsc = null\n+    rsc = seedRsc\n   }\n \n   // If this is a page segment, also read the head.\n-  let resolvedPrefetchHead: HeadData | null\n-  let resolvedHead: HeadData | null\n+  let prefetchHead: HeadData | null\n+  let head: HeadData | null\n   if (isPageSegment) {\n-    resolvedPrefetchHead = prefetchHead\n-    if (isPrefetchHeadPartial) {\n-      resolvedHead = createDeferredRsc()\n+    if (isSeedHeadPartial) {\n+      prefetchHead = seedHead\n+      head = createDeferredRsc()\n     } else {\n-      resolvedHead = prefetchHead\n+      prefetchHead = null\n+      head = seedHead\n     }\n   } else {\n-    resolvedPrefetchHead = null\n-    resolvedHead = null\n+    prefetchHead = null\n+    head = null\n   }\n \n   const cacheNode: ReadyCacheNode = {\n     lazyData: null,\n     rsc,\n     prefetchRsc,\n-    head: resolvedHead,\n-    prefetchHead: resolvedPrefetchHead,\n+    head,\n+    prefetchHead,\n     // TODO: Technically, a loading boundary could contain dynamic data. We\n     // should have separate `loading` and `prefetchLoading` fields to handle\n     // this, like we do for the segment data and head.\n-    loading: prefetchLoading,\n+    loading: seedLoading,\n     parallelRoutes,\n     navigatedAt,\n   }\n@@ -998,15 +1090,32 @@ function readCacheNodeFromSeedData(\n function spawnNewCacheNode(\n   parallelRoutes: Map<string, ChildSegmentMap>,\n   isLeafSegment: boolean,\n-  navigatedAt: number\n+  navigatedAt: number,\n+  freshness: FreshnessPolicy\n ): ReadyCacheNode {\n+  // We should never spawn network requests during hydration. We must treat the\n+  // initial payload as authoritative, because the initial page load is used\n+  // as a last-ditch mechanism for recovering the app.\n+  //\n+  // This is also an important safety check because if this leaks into the\n+  // server rendering path (which theoretically it never should because\n+  // the server payload should be consistent), the server would hang because\n+  // these promises would never resolve.\n+  //\n+  // TODO: There is an existing case where the global \"not found\" boundary\n+  // triggers this path. But it does render correctly despite that. That's an\n+  // unusual render path so it's not surprising, but we should look into\n+  // modeling it in a more consistent way. See also the /_notFound special\n+  // case in updateCacheNodeOnNavigation.\n+  const isHydration = freshness === FreshnessPolicy.Hydration\n+\n   const cacheNode: ReadyCacheNode = {\n     lazyData: null,\n-    rsc: createDeferredRsc(),\n+    rsc: !isHydration ? createDeferredRsc() : null,\n     prefetchRsc: null,\n-    head: isLeafSegment ? createDeferredRsc() : null,\n+    head: !isHydration && isLeafSegment ? createDeferredRsc() : null,\n     prefetchHead: null,\n-    loading: createDeferredRsc<LoadingModuleData>(),\n+    loading: !isHydration ? createDeferredRsc<LoadingModuleData>() : null,\n     parallelRoutes,\n     navigatedAt,\n   }"
        },
        {
            "sha": "9651f8699ac653060a84452d6f5cb8d055d3d6f4",
            "filename": "packages/next/src/client/components/segment-cache/navigation.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/ed3b127191a1ad5ef7b0a1b5d9e46a45153fa676/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fnavigation.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/ed3b127191a1ad5ef7b0a1b5d9e46a45153fa676/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fnavigation.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fnavigation.ts?ref=ed3b127191a1ad5ef7b0a1b5d9e46a45153fa676",
            "patch": "@@ -536,6 +536,7 @@ async function navigateDynamicallyWithNoPrefetch(\n     case FreshnessPolicy.HistoryTraversal:\n       dynamicRequestTree = currentFlightRouterState\n       break\n+    case FreshnessPolicy.Hydration: // <- shouldn't happen during client nav\n     case FreshnessPolicy.RefreshAll:\n       dynamicRequestTree = DynamicRequestTreeForEntireRoute\n       break"
        },
        {
            "sha": "b14ca29966228f0d919dcbcb602cab93b807a30f",
            "filename": "packages/next/src/server/app-render/app-render.tsx",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/ed3b127191a1ad5ef7b0a1b5d9e46a45153fa676/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/ed3b127191a1ad5ef7b0a1b5d9e46a45153fa676/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx?ref=ed3b127191a1ad5ef7b0a1b5d9e46a45153fa676",
            "patch": "@@ -1710,7 +1710,6 @@ function App<T>({\n     initialFlightData: response.f,\n     initialCanonicalUrlParts: response.c,\n     initialRenderedSearch: response.q,\n-    initialParallelRoutes: new Map(),\n     // location is not initialized in the SSR render\n     // it's set to window.location during hydration\n     location: null,\n@@ -1774,7 +1773,6 @@ function ErrorApp<T>({\n     initialFlightData: response.f,\n     initialCanonicalUrlParts: response.c,\n     initialRenderedSearch: response.q,\n-    initialParallelRoutes: new Map(),\n     // location is not initialized in the SSR render\n     // it's set to window.location during hydration\n     location: null,"
        }
    ],
    "stats": {
        "total": 345,
        "additions": 149,
        "deletions": 196
    }
}