{
    "author": "bgw",
    "message": "fix(turbo-tasks-fs): Handle filesystem watcher rescan events (#78045)\n\nThe notify crate requires handling rescan events with the event queue overflows.\n\nContext on this issue in the notify crate:\n- https://github.com/notify-rs/notify/issues/412\n- https://github.com/notify-rs/notify/issues/434\n- https://github.com/notify-rs/notify/pull/435\n\nIn our case, that means we should invalidate every file we've read in `turbo-tasks-fs`.\n\nWe should also attempt to re-add filesystem watchers for every path, since some of those paths could've been removed and re-added.\n\nTested this on Linux by lowering the inotify queue to something tiny to trigger frequent rescan events:\n\n```\necho 3 | sudo tee /proc/sys/fs/inotify/max_queued_events\nrm -rf /tmp/fuzz && RUST_BACKTRACE=1 cargo run -p turbo-tasks-fuzz -- fs-watcher --fs-root /tmp/fuzz --notify-timeout-ms 100 --directory-modifications 0\necho 16384 | sudo tee /proc/sys/fs/inotify/max_queued_events  # restore back to default\n```\n\nAs a sanity check, I also tried running the fuzzer on macos, though it doesn't seem like there's as easy of a way to trigger rescan events on that platform (?).",
    "sha": "e9982de2af9cbaa273bd8c73f07b6f9eb1d7cf68",
    "files": [
        {
            "sha": "b9965b974ad9fabedcfbb340c783aa21f7bf5cb5",
            "filename": "crates/next-api/src/project.rs",
            "status": "modified",
            "additions": 13,
            "deletions": 5,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/e9982de2af9cbaa273bd8c73f07b6f9eb1d7cf68/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e9982de2af9cbaa273bd8c73f07b6f9eb1d7cf68/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fproject.rs?ref=e9982de2af9cbaa273bd8c73f07b6f9eb1d7cf68",
            "patch": "@@ -33,7 +33,7 @@ use turbo_tasks::{\n     ReadRef, ResolvedVc, State, TaskInput, TransientInstance, TryFlatJoinIterExt, Value, Vc,\n };\n use turbo_tasks_env::{EnvMap, ProcessEnv};\n-use turbo_tasks_fs::{DiskFileSystem, FileSystem, FileSystemPath, VirtualFileSystem};\n+use turbo_tasks_fs::{invalidation, DiskFileSystem, FileSystem, FileSystemPath, VirtualFileSystem};\n use turbopack::{\n     evaluate_context::node_build_environment, global_module_ids::get_global_module_id_strategy,\n     transition::TransitionOptions, ModuleAssetContext,\n@@ -308,12 +308,16 @@ impl ProjectContainer {\n                 .start_watching_with_invalidation_reason(watch.poll_interval)\n                 .await?;\n         } else {\n-            project_fs.invalidate_with_reason();\n+            project_fs.invalidate_with_reason(|path| invalidation::Initialize {\n+                path: RcStr::from(path),\n+            });\n         }\n         let output_fs = output_fs_operation(project)\n             .read_strongly_consistent()\n             .await?;\n-        output_fs.invalidate_with_reason();\n+        output_fs.invalidate_with_reason(|path| invalidation::Initialize {\n+            path: RcStr::from(path),\n+        });\n         Ok(())\n     }\n \n@@ -402,11 +406,15 @@ impl ProjectContainer {\n                     .start_watching_with_invalidation_reason(watch.poll_interval)\n                     .await?;\n             } else {\n-                project_fs.invalidate_with_reason();\n+                project_fs.invalidate_with_reason(|path| invalidation::Initialize {\n+                    path: RcStr::from(path),\n+                });\n             }\n         }\n         if !ReadRef::ptr_eq(&prev_output_fs, &output_fs) {\n-            prev_output_fs.invalidate_with_reason();\n+            prev_output_fs.invalidate_with_reason(|path| invalidation::Initialize {\n+                path: RcStr::from(path),\n+            });\n         }\n \n         Ok(())"
        },
        {
            "sha": "7961b093461645ca494f320bd827409642fb5587",
            "filename": "turbopack/crates/turbo-tasks-fs/src/invalidation.rs",
            "status": "modified",
            "additions": 36,
            "deletions": 35,
            "changes": 71,
            "blob_url": "https://github.com/vercel/next.js/blob/e9982de2af9cbaa273bd8c73f07b6f9eb1d7cf68/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Finvalidation.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e9982de2af9cbaa273bd8c73f07b6f9eb1d7cf68/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Finvalidation.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Finvalidation.rs?ref=e9982de2af9cbaa273bd8c73f07b6f9eb1d7cf68",
            "patch": "@@ -8,7 +8,7 @@ use turbo_tasks::{util::StaticOrArc, FxIndexSet, InvalidationReason, Invalidatio\n \n /// Invalidation was caused by a file change detected by the file watcher\n #[derive(PartialEq, Eq, Hash)]\n-pub struct WatchChange {\n+pub(crate) struct WatchChange {\n     pub path: String,\n }\n \n@@ -52,7 +52,7 @@ impl InvalidationReasonKind for WatchChangeKind {\n /// Invalidation was caused by a directory starting to watch from which was read\n /// before.\n #[derive(PartialEq, Eq, Hash, Clone)]\n-pub struct WatchStart {\n+pub(crate) struct WatchStart {\n     pub name: RcStr,\n     pub path: RcStr,\n }\n@@ -84,92 +84,93 @@ impl InvalidationReasonKind for WatchStartKind {\n         let example = reasons[0].as_any().downcast_ref::<WatchStart>().unwrap();\n         write!(\n             f,\n-            \"{} items started watching (e. g. {} in {})\",\n+            \"{} items started watching (e.g. {} in {})\",\n             reasons.len(),\n             example.path,\n             example.name\n         )\n     }\n }\n \n-/// Invalidation was caused by a write operation on the filesystem\n-#[derive(PartialEq, Eq, Hash)]\n-pub struct Write {\n-    pub path: String,\n+/// Invalidation was caused by initialization of a project or filesystem.\n+#[derive(PartialEq, Eq, Hash, Clone)]\n+pub struct Initialize {\n+    pub path: RcStr,\n }\n \n-impl InvalidationReason for Write {\n+impl InvalidationReason for Initialize {\n     fn kind(&self) -> Option<StaticOrArc<dyn InvalidationReasonKind>> {\n-        Some(StaticOrArc::Static(&WRITE_KIND))\n+        Some(StaticOrArc::Static(&INITIALIZE_KIND))\n     }\n }\n \n-impl Display for Write {\n+impl Display for Initialize {\n     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\n-        write!(f, \"{} written\", self.path)\n+        write!(\n+            f,\n+            \"initialized project or filesystem with path {}\",\n+            self.path\n+        )\n     }\n }\n \n-/// Invalidation kind for [Write]\n+/// [Invalidation kind][InvalidationReasonKind] for [`Initialize`].\n #[derive(PartialEq, Eq, Hash)]\n-struct WriteKind;\n+struct InitializeKind;\n \n-static WRITE_KIND: WriteKind = WriteKind;\n+static INITIALIZE_KIND: InitializeKind = InitializeKind;\n \n-impl InvalidationReasonKind for WriteKind {\n+impl InvalidationReasonKind for InitializeKind {\n     fn fmt(\n         &self,\n         reasons: &FxIndexSet<StaticOrArc<dyn InvalidationReason>>,\n         f: &mut Formatter<'_>,\n     ) -> std::fmt::Result {\n+        let example = reasons[0].as_any().downcast_ref::<Initialize>().unwrap();\n         write!(\n             f,\n-            \"{} files written ({}, ...)\",\n+            \"{} items invalidated as part of project or filesystem initialization ({}, ...)\",\n             reasons.len(),\n-            reasons[0].as_any().downcast_ref::<Write>().unwrap().path\n+            example.path,\n         )\n     }\n }\n \n-/// Invalidation was caused by a invalidate operation on the filesystem\n-#[derive(Clone, PartialEq, Eq, Hash)]\n-pub struct InvalidateFilesystem {\n-    pub path: RcStr,\n+/// Invalidation was caused by a write operation on the filesystem\n+#[derive(PartialEq, Eq, Hash)]\n+pub(crate) struct Write {\n+    pub path: String,\n }\n \n-impl InvalidationReason for InvalidateFilesystem {\n+impl InvalidationReason for Write {\n     fn kind(&self) -> Option<StaticOrArc<dyn InvalidationReasonKind>> {\n-        Some(StaticOrArc::Static(&INVALIDATE_FILESYSTEM_KIND))\n+        Some(StaticOrArc::Static(&WRITE_KIND))\n     }\n }\n \n-impl Display for InvalidateFilesystem {\n+impl Display for Write {\n     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\n-        write!(f, \"{} in filesystem invalidated\", self.path)\n+        write!(f, \"{} written\", self.path)\n     }\n }\n \n-/// Invalidation kind for [InvalidateFilesystem]\n+/// Invalidation kind for [Write]\n #[derive(PartialEq, Eq, Hash)]\n-struct InvalidateFilesystemKind;\n+struct WriteKind;\n \n-static INVALIDATE_FILESYSTEM_KIND: InvalidateFilesystemKind = InvalidateFilesystemKind;\n+static WRITE_KIND: WriteKind = WriteKind;\n \n-impl InvalidationReasonKind for InvalidateFilesystemKind {\n+impl InvalidationReasonKind for WriteKind {\n     fn fmt(\n         &self,\n         reasons: &FxIndexSet<StaticOrArc<dyn InvalidationReason>>,\n         f: &mut Formatter<'_>,\n     ) -> std::fmt::Result {\n         write!(\n             f,\n-            \"{} items in filesystem invalidated ({}, ...)\",\n+            \"{} files written ({}, ...)\",\n             reasons.len(),\n-            reasons[0]\n-                .as_any()\n-                .downcast_ref::<InvalidateFilesystem>()\n-                .unwrap()\n-                .path\n+            reasons[0].as_any().downcast_ref::<Write>().unwrap().path\n         )\n     }\n }"
        },
        {
            "sha": "32673484edb0826752fedcf7793505243d57aa8d",
            "filename": "turbopack/crates/turbo-tasks-fs/src/invalidator_map.rs",
            "status": "modified",
            "additions": 10,
            "deletions": 2,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/e9982de2af9cbaa273bd8c73f07b6f9eb1d7cf68/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Finvalidator_map.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e9982de2af9cbaa273bd8c73f07b6f9eb1d7cf68/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Finvalidator_map.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Finvalidator_map.rs?ref=e9982de2af9cbaa273bd8c73f07b6f9eb1d7cf68",
            "patch": "@@ -42,14 +42,22 @@ impl InvalidatorMap {\n         Ok(guard)\n     }\n \n-    #[allow(unused_must_use)]\n     pub fn insert(\n         &self,\n         key: String,\n         invalidator: Invalidator,\n         write_content: Option<WriteContent>,\n     ) {\n-        self.queue.push((key, invalidator, write_content));\n+        self.queue\n+            .push((key, invalidator, write_content))\n+            .unwrap_or_else(|err| {\n+                let (key, ..) = err.into_inner();\n+                // PushError<T> is not Debug\n+                panic!(\n+                    \"failed to push {key:?} queue push should never fail, queue is unbounded and \\\n+                     never closed\"\n+                )\n+            });\n     }\n }\n "
        },
        {
            "sha": "9617a5cee2ca435eae08c0c6b3599aadfbd90ffa",
            "filename": "turbopack/crates/turbo-tasks-fs/src/lib.rs",
            "status": "modified",
            "additions": 17,
            "deletions": 8,
            "changes": 25,
            "blob_url": "https://github.com/vercel/next.js/blob/e9982de2af9cbaa273bd8c73f07b6f9eb1d7cf68/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e9982de2af9cbaa273bd8c73f07b6f9eb1d7cf68/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs?ref=e9982de2af9cbaa273bd8c73f07b6f9eb1d7cf68",
            "patch": "@@ -11,7 +11,7 @@\n pub mod attach;\n pub mod embed;\n pub mod glob;\n-mod invalidation;\n+pub mod invalidation;\n mod invalidator_map;\n pub mod json;\n mod mutex_map;\n@@ -42,7 +42,6 @@ use bitflags::bitflags;\n use dunce::simplified;\n use glob::Glob;\n use indexmap::IndexSet;\n-use invalidation::InvalidateFilesystem;\n use invalidator_map::InvalidatorMap;\n use jsonc_parser::{parse_to_serde_value, ParseOptions};\n use mime::Mime;\n@@ -60,7 +59,8 @@ use tracing::Instrument;\n use turbo_rcstr::RcStr;\n use turbo_tasks::{\n     debug::ValueDebugFormat, effect, mark_session_dependent, mark_stateful, trace::TraceRawVcs,\n-    Completion, Invalidator, NonLocalValue, ReadRef, ResolvedVc, ValueToString, Vc,\n+    Completion, InvalidationReason, Invalidator, NonLocalValue, ReadRef, ResolvedVc, ValueToString,\n+    Vc,\n };\n use turbo_tasks_hash::{\n     hash_xxh3_hash128, hash_xxh3_hash64, DeterministicHash, DeterministicHasher,\n@@ -318,7 +318,13 @@ impl DiskFileSystemInner {\n         });\n     }\n \n-    fn invalidate_with_reason(&self) {\n+    /// Invalidates every tracked file in the filesystem.\n+    ///\n+    /// Calls the given\n+    fn invalidate_with_reason<R: InvalidationReason + Clone>(\n+        &self,\n+        reason: impl Fn(String) -> R + Sync,\n+    ) {\n         let _span = tracing::info_span!(\"invalidate filesystem\", path = &*self.root).entered();\n         let span = tracing::Span::current();\n         let handle = tokio::runtime::Handle::current();\n@@ -329,10 +335,10 @@ impl DiskFileSystemInner {\n             .chain(dir_invalidator_map.into_par_iter())\n             .flat_map(|(path, invalidators)| {\n                 let _span = span.clone().entered();\n-                let reason = InvalidateFilesystem { path: path.into() };\n+                let reason_for_path = reason(path);\n                 invalidators\n                     .into_par_iter()\n-                    .map(move |i| (reason.clone(), i))\n+                    .map(move |i| (reason_for_path.clone(), i))\n             });\n         iter.for_each(|(reason, (invalidator, _))| {\n             let _span = span.clone().entered();\n@@ -408,8 +414,11 @@ impl DiskFileSystem {\n         self.inner.invalidate();\n     }\n \n-    pub fn invalidate_with_reason(&self) {\n-        self.inner.invalidate_with_reason();\n+    pub fn invalidate_with_reason<R: InvalidationReason + Clone>(\n+        &self,\n+        reason: impl Fn(String) -> R + Sync,\n+    ) {\n+        self.inner.invalidate_with_reason(reason);\n     }\n \n     pub async fn start_watching(&self, poll_interval: Option<Duration>) -> Result<()> {"
        },
        {
            "sha": "0362052019710de37a07d7f42748b1184d56d1b4",
            "filename": "turbopack/crates/turbo-tasks-fs/src/watcher.rs",
            "status": "modified",
            "additions": 168,
            "deletions": 30,
            "changes": 198,
            "blob_url": "https://github.com/vercel/next.js/blob/e9982de2af9cbaa273bd8c73f07b6f9eb1d7cf68/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fwatcher.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e9982de2af9cbaa273bd8c73f07b6f9eb1d7cf68/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fwatcher.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fwatcher.rs?ref=e9982de2af9cbaa273bd8c73f07b6f9eb1d7cf68",
            "patch": "@@ -1,4 +1,5 @@\n use std::{\n+    fmt,\n     mem::take,\n     path::{Path, PathBuf},\n     sync::{\n@@ -8,7 +9,7 @@ use std::{\n     time::Duration,\n };\n \n-use anyhow::Result;\n+use anyhow::{Context, Result};\n use notify::{\n     event::{MetadataKind, ModifyKind, RenameMode},\n     Config, EventKind, PollWatcher, RecommendedWatcher, RecursiveMode, Watcher,\n@@ -17,7 +18,11 @@ use rayon::iter::{IntoParallelIterator, ParallelIterator};\n use rustc_hash::{FxHashMap, FxHashSet};\n use serde::{Deserialize, Serialize};\n use tracing::instrument;\n-use turbo_tasks::{spawn_thread, Invalidator};\n+use turbo_rcstr::RcStr;\n+use turbo_tasks::{\n+    spawn_thread, util::StaticOrArc, FxIndexSet, InvalidationReason, InvalidationReasonKind,\n+    Invalidator,\n+};\n \n use crate::{\n     format_absolute_fs_path,\n@@ -66,10 +71,22 @@ impl DiskWatcher {\n         }\n     }\n \n+    /// Called after a rescan in case a previously watched-but-deleted directory was recreated.\n+    #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n+    pub(crate) fn restore_all_watching(&self, root_path: &Path) {\n+        let mut watcher = self.watcher.lock().unwrap();\n+        for dir_path in self.watching.iter() {\n+            // TODO: Report diagnostics if this error happens\n+            let _ = self.start_watching_dir(&mut watcher, &dir_path, root_path);\n+        }\n+    }\n+\n+    /// Called when a new directory is found in a parent directory we're watching.\n     #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n     pub(crate) fn restore_if_watching(&self, dir_path: &Path, root_path: &Path) -> Result<()> {\n         if self.watching.contains(dir_path) {\n             let mut watcher = self.watcher.lock().unwrap();\n+            // TODO: Also restore any watchers for children of this directory\n             self.start_watching_dir(&mut watcher, dir_path, root_path)?;\n         }\n         Ok(())\n@@ -87,33 +104,64 @@ impl DiskWatcher {\n         Ok(())\n     }\n \n+    /// Private helper, assumes that the path has already been added to `self.watching`.\n     #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n     fn start_watching_dir(\n         &self,\n         watcher: &mut std::sync::MutexGuard<Option<DiskWatcherInternal>>,\n         dir_path: &Path,\n         root_path: &Path,\n     ) -> Result<()> {\n-        use anyhow::Context;\n+        // HACK: Rewrite NotFound io errors to PathNotFound\n+        // This shouldn't ever happen (notify should transform this for us), but even after\n+        // https://github.com/notify-rs/notify/pull/611, it seems like there's still some case where\n+        // it can occur with inotify on Linux.\n+        fn map_notify_err(mut err: notify::Error) -> notify::Error {\n+            if let notify::ErrorKind::Io(io_err) = &err.kind {\n+                if io_err.kind() == std::io::ErrorKind::NotFound {\n+                    err.kind = notify::ErrorKind::PathNotFound;\n+                }\n+            }\n+            err\n+        }\n \n         if let Some(watcher) = watcher.as_mut() {\n             let mut path = dir_path;\n-            while let Err(err) = watcher.watch(path, RecursiveMode::NonRecursive) {\n-                if path == root_path {\n-                    return Err(err).context(format!(\n-                        \"Unable to watch {} (tried up to {})\",\n-                        dir_path.display(),\n-                        path.display()\n-                    ));\n+            let err_with_context = |err| {\n+                return Err(err).context(format!(\n+                    \"Unable to watch {} (tried up to {})\",\n+                    dir_path.display(),\n+                    path.display()\n+                ));\n+            };\n+            while let Err(err) = watcher\n+                .watch(path, RecursiveMode::NonRecursive)\n+                .map_err(map_notify_err)\n+            {\n+                match err {\n+                    notify::Error {\n+                        kind: notify::ErrorKind::PathNotFound,\n+                        ..\n+                    } => {\n+                        // The path was probably deleted before we could process the event. That's\n+                        // okay, just make sure we're watching the parent directory, so we can know\n+                        // if it gets recreated.\n+                        let Some(parent_path) = path.parent() else {\n+                            // this should never happen as we break before we reach the root path\n+                            return err_with_context(err);\n+                        };\n+                        if parent_path == root_path {\n+                            // assume there's already a root watcher\n+                            break;\n+                        }\n+                        if !self.watching.insert(parent_path.to_owned()) {\n+                            // we're already watching the parent path!\n+                            break;\n+                        }\n+                        path = parent_path;\n+                    }\n+                    _ => return err_with_context(err),\n                 }\n-                let Some(parent_path) = path.parent() else {\n-                    return Err(err).context(format!(\n-                        \"Unable to watch {} (tried up to {})\",\n-                        dir_path.display(),\n-                        path.display()\n-                    ));\n-                };\n-                path = parent_path;\n             }\n         }\n         Ok(())\n@@ -161,8 +209,8 @@ impl DiskWatcher {\n             DiskWatcherInternal::Recommended(RecommendedWatcher::new(tx, Config::default())?)\n         };\n \n-        // Add a path to be watched. All files and directories at that path and\n-        // below will be monitored for changes.\n+        // Macos and Windows provide efficient recursive directory watchers. On other platforms, we\n+        // only track the directories we need: https://github.com/vercel/turborepo/pull/4100\n         #[cfg(any(target_os = \"macos\", target_os = \"windows\"))]\n         {\n             watcher.watch(inner.root_path(), RecursiveMode::Recursive)?;\n@@ -252,11 +300,52 @@ impl DiskWatcher {\n         let mut batched_new_paths = FxHashSet::default();\n \n         'outer: loop {\n-            let mut event = rx.recv().or(Err(TryRecvError::Disconnected));\n+            let mut event_result = rx.recv().or(Err(TryRecvError::Disconnected));\n+            // this inner loop batches events using `try_recv`\n             loop {\n-                match event {\n-                    Ok(Ok(notify::Event { kind, paths, .. })) => {\n-                        let paths: Vec<PathBuf> = paths\n+                match event_result {\n+                    Ok(Ok(event)) => {\n+                        // TODO: We might benefit from some user-facing diagnostics if it rescans\n+                        // occur frequently (i.e. more than X times in Y minutes)\n+                        //\n+                        // You can test rescans on Linux by reducing the inotify queue to something\n+                        // really small:\n+                        //\n+                        // ```\n+                        // echo 3 | sudo tee /proc/sys/fs/inotify/max_queued_events\n+                        // ```\n+                        if event.need_rescan() {\n+                            let _lock = inner.invalidation_lock.blocking_write();\n+\n+                            #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n+                            {\n+                                // we can't narrow this down to a smaller set of paths: Rescan\n+                                // events (at least when tested on Linux) come with no `paths`, and\n+                                // we use only one global `notify::Watcher` instance.\n+                                self.restore_all_watching(inner.root_path());\n+                                batched_new_paths.clear();\n+                            }\n+\n+                            if report_invalidation_reason {\n+                                inner.invalidate_with_reason(|path| InvalidateRescan {\n+                                    path: RcStr::from(path),\n+                                });\n+                            } else {\n+                                inner.invalidate();\n+                            }\n+\n+                            // no need to process the rest of the batch as we just\n+                            // invalidated everything\n+                            batched_invalidate_path.clear();\n+                            batched_invalidate_path_dir.clear();\n+                            batched_invalidate_path_and_children.clear();\n+                            batched_invalidate_path_and_children_dir.clear();\n+\n+                            break;\n+                        }\n+\n+                        let paths: Vec<PathBuf> = event\n+                            .paths\n                             .iter()\n                             .filter(|p| {\n                                 !self\n@@ -268,13 +357,15 @@ impl DiskWatcher {\n                             .collect();\n \n                         if paths.is_empty() {\n-                            return;\n+                            // this event isn't useful, but keep trying to process the batch\n+                            event_result = rx.try_recv();\n+                            continue;\n                         }\n \n                         // [NOTE] there is attrs in the `Event` struct, which contains few\n                         // more metadata like process_id who triggered the event,\n                         // or the source we may able to utilize later.\n-                        match kind {\n+                        match event.kind {\n                             // [NOTE] Observing `ModifyKind::Metadata(MetadataKind::Any)` is\n                             // not a mistake, fix for PACK-2437.\n                             // In here explicitly subscribes to the `ModifyKind::Data` which\n@@ -291,7 +382,7 @@ impl DiskWatcher {\n                             EventKind::Modify(\n                                 ModifyKind::Data(_) | ModifyKind::Metadata(MetadataKind::Any),\n                             ) => {\n-                                batched_invalidate_path.extend(paths.clone());\n+                                batched_invalidate_path.extend(paths);\n                             }\n                             EventKind::Create(_) => {\n                                 batched_invalidate_path_and_children.extend(paths.clone());\n@@ -390,20 +481,23 @@ impl DiskWatcher {\n                         let delay = Duration::from_millis(1);\n                         match rx.recv_timeout(delay) {\n                             Ok(result) => {\n-                                event = Ok(result);\n+                                event_result = Ok(result);\n                                 continue;\n                             }\n                             Err(_) => break,\n                         }\n                     }\n                 }\n-                event = rx.try_recv();\n+                event_result = rx.try_recv();\n             }\n \n-            // We need to start watching first before invalidating the changed paths\n+            // We need to start watching first before invalidating the changed paths...\n+            // This is only needed on platforms we don't do recursive watching on:\n+            // https://github.com/vercel/turborepo/pull/4100\n             #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n             {\n                 for path in batched_new_paths.drain() {\n+                    // TODO: Report diagnostics if this error happens\n                     let _ = self.restore_if_watching(&path, inner.root_path());\n                 }\n             }\n@@ -490,3 +584,47 @@ fn invalidate_path_and_children_execute(\n         }\n     }\n }\n+\n+/// Invalidation was caused by a watcher rescan event. This will likely invalidate *every* watched\n+/// file.\n+#[derive(Clone, PartialEq, Eq, Hash)]\n+pub struct InvalidateRescan {\n+    path: RcStr,\n+}\n+\n+impl InvalidationReason for InvalidateRescan {\n+    fn kind(&self) -> Option<StaticOrArc<dyn InvalidationReasonKind>> {\n+        Some(StaticOrArc::Static(&INVALIDATE_RESCAN_KIND))\n+    }\n+}\n+\n+impl fmt::Display for InvalidateRescan {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{} in filesystem invalidated\", self.path)\n+    }\n+}\n+\n+/// [Invalidation kind][InvalidationReasonKind] for [`InvalidateRescan`].\n+#[derive(PartialEq, Eq, Hash)]\n+struct InvalidateRescanKind;\n+\n+static INVALIDATE_RESCAN_KIND: InvalidateRescanKind = InvalidateRescanKind;\n+\n+impl InvalidationReasonKind for InvalidateRescanKind {\n+    fn fmt(\n+        &self,\n+        reasons: &FxIndexSet<StaticOrArc<dyn InvalidationReason>>,\n+        f: &mut fmt::Formatter<'_>,\n+    ) -> fmt::Result {\n+        write!(\n+            f,\n+            \"{} items in filesystem invalidated due to notify::Watcher rescan event ({}, ...)\",\n+            reasons.len(),\n+            reasons[0]\n+                .as_any()\n+                .downcast_ref::<InvalidateRescan>()\n+                .unwrap()\n+                .path\n+        )\n+    }\n+}"
        }
    ],
    "stats": {
        "total": 324,
        "additions": 244,
        "deletions": 80
    }
}