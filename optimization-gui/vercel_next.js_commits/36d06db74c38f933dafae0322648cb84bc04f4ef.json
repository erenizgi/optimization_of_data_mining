{
    "author": "sokra",
    "message": "Turbopack: remove Backend TaskState (#83846)\n\n### What?\n\nBackend TaskState is no longer used with the new backend.",
    "sha": "36d06db74c38f933dafae0322648cb84bc04f4ef",
    "files": [
        {
            "sha": "530b7b0b7fb7fba1f07a4dd38abf835a53cb10f5",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 3,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/36d06db74c38f933dafae0322648cb84bc04f4ef/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/36d06db74c38f933dafae0322648cb84bc04f4ef/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=36d06db74c38f933dafae0322648cb84bc04f4ef",
            "patch": "@@ -2873,9 +2873,6 @@ impl<B: BackingStorage> Backend for TurboTasksBackend<B> {\n         self.0.get_task_description(task)\n     }\n \n-    type TaskState = ();\n-    fn new_task_state(&self, _task: TaskId) -> Self::TaskState {}\n-\n     fn task_execution_canceled(&self, task: TaskId, turbo_tasks: &dyn TurboTasksBackendApi<Self>) {\n         self.0.task_execution_canceled(task, turbo_tasks)\n     }"
        },
        {
            "sha": "7e17ca3dca374e858a667061d857bbc5aa749f72",
            "filename": "turbopack/crates/turbo-tasks/src/backend.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 23,
            "changes": 23,
            "blob_url": "https://github.com/vercel/next.js/blob/36d06db74c38f933dafae0322648cb84bc04f4ef/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fbackend.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/36d06db74c38f933dafae0322648cb84bc04f4ef/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fbackend.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fbackend.rs?ref=36d06db74c38f933dafae0322648cb84bc04f4ef",
            "patch": "@@ -530,29 +530,6 @@ pub trait Backend: Sync + Send {\n \n     fn get_task_description(&self, task: TaskId) -> String;\n \n-    /// Task-local state that stored inside of [`TurboTasksBackendApi`]. Constructed with\n-    /// [`Self::new_task_state`].\n-    ///\n-    /// This value that can later be written to or read from using\n-    /// [`crate::TurboTasksBackendApiExt::write_task_state`] or\n-    /// [`crate::TurboTasksBackendApiExt::read_task_state`]\n-    ///\n-    /// This data may be shared across multiple threads (must be `Sync`) in order to support\n-    /// detached futures ([`crate::TurboTasksApi::detached_for_testing`]) and [pseudo-tasks using\n-    /// `local` execution][crate::function]. A [`RwLock`][std::sync::RwLock] is used to provide\n-    /// concurrent access.\n-    type TaskState: Send + Sync + 'static;\n-\n-    /// Constructs a new task-local [`Self::TaskState`] for the given `task_id`.\n-    ///\n-    /// If a task is re-executed (e.g. because it is invalidated), this function will be called\n-    /// again with the same [`TaskId`].\n-    ///\n-    /// This value can be written to or read from using\n-    /// [`crate::TurboTasksBackendApiExt::write_task_state`] and\n-    /// [`crate::TurboTasksBackendApiExt::read_task_state`]\n-    fn new_task_state(&self, task: TaskId) -> Self::TaskState;\n-\n     fn try_start_task_execution<'a>(\n         &'a self,\n         task: TaskId,"
        },
        {
            "sha": "7c4313a3042f776e8fe320704b6ba6e0b4028c16",
            "filename": "turbopack/crates/turbo-tasks/src/lib.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/36d06db74c38f933dafae0322648cb84bc04f4ef/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/36d06db74c38f933dafae0322648cb84bc04f4ef/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs?ref=36d06db74c38f933dafae0322648cb84bc04f4ef",
            "patch": "@@ -109,9 +109,9 @@ pub use key_value_pair::KeyValuePair;\n pub use magic_any::MagicAny;\n pub use manager::{\n     CurrentCellRef, ReadConsistency, TaskPersistence, TurboTasks, TurboTasksApi,\n-    TurboTasksBackendApi, TurboTasksBackendApiExt, TurboTasksCallApi, Unused, UpdateInfo,\n-    dynamic_call, emit, mark_finished, mark_root, mark_session_dependent, mark_stateful,\n-    prevent_gc, run_once, run_once_with_reason, trait_call, turbo_tasks, turbo_tasks_scope,\n+    TurboTasksBackendApi, TurboTasksCallApi, Unused, UpdateInfo, dynamic_call, emit, mark_finished,\n+    mark_root, mark_session_dependent, mark_stateful, prevent_gc, run_once, run_once_with_reason,\n+    trait_call, turbo_tasks, turbo_tasks_scope,\n };\n pub use output::OutputContent;\n pub use raw_vc::{CellId, RawVc, ReadRawVcFuture, ResolveTypeError};"
        },
        {
            "sha": "bad7772f2223f4b7b070a1dac63efb113b2834a3",
            "filename": "turbopack/crates/turbo-tasks/src/manager.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 67,
            "changes": 70,
            "blob_url": "https://github.com/vercel/next.js/blob/36d06db74c38f933dafae0322648cb84bc04f4ef/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/36d06db74c38f933dafae0322648cb84bc04f4ef/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs?ref=36d06db74c38f933dafae0322648cb84bc04f4ef",
            "patch": "@@ -1,5 +1,4 @@\n use std::{\n-    any::Any,\n     future::Future,\n     hash::BuildHasherDefault,\n     mem::take,\n@@ -262,54 +261,13 @@ pub trait TurboTasksBackendApi<B: Backend + 'static>: TurboTasksCallApi + Sync +\n     /// Returns the duration from the start of the program to the given instant.\n     fn program_duration_until(&self, instant: Instant) -> Duration;\n \n-    /// An untyped object-safe version of [`TurboTasksBackendApiExt::read_task_state`]. Callers\n-    /// should prefer the extension trait's version of this method.\n-    fn read_task_state_dyn(&self, func: &mut dyn FnMut(&B::TaskState));\n-\n-    /// An untyped object-safe version of [`TurboTasksBackendApiExt::write_task_state`]. Callers\n-    /// should prefer the extension trait's version of this method.\n-    fn write_task_state_dyn(&self, func: &mut dyn FnMut(&mut B::TaskState));\n-\n     /// Returns true if the system is idle.\n     fn is_idle(&self) -> bool;\n \n     /// Returns a reference to the backend.\n     fn backend(&self) -> &B;\n }\n \n-/// An extension trait for methods of [`TurboTasksBackendApi`] that are not object-safe. This is\n-/// automatically implemented for all [`TurboTasksBackendApi`]s using a blanket impl.\n-pub trait TurboTasksBackendApiExt<B: Backend + 'static>: TurboTasksBackendApi<B> {\n-    /// Allows modification of the [`Backend::TaskState`].\n-    ///\n-    /// This function holds open a non-exclusive read lock that blocks writes, so `func` is expected\n-    /// to execute quickly in order to release the lock.\n-    fn read_task_state<T>(&self, func: impl FnOnce(&B::TaskState) -> T) -> T {\n-        let mut func = Some(func);\n-        let mut out = None;\n-        self.read_task_state_dyn(&mut |ts| out = Some((func.take().unwrap())(ts)));\n-        out.expect(\"read_task_state_dyn must call `func`\")\n-    }\n-\n-    /// Allows modification of the [`Backend::TaskState`].\n-    ///\n-    /// This function holds open a write lock, so `func` is expected to execute quickly in order to\n-    /// release the lock.\n-    fn write_task_state<T>(&self, func: impl FnOnce(&mut B::TaskState) -> T) -> T {\n-        let mut func = Some(func);\n-        let mut out = None;\n-        self.write_task_state_dyn(&mut |ts| out = Some((func.take().unwrap())(ts)));\n-        out.expect(\"write_task_state_dyn must call `func`\")\n-    }\n-}\n-\n-impl<TT, B> TurboTasksBackendApiExt<B> for TT\n-where\n-    TT: TurboTasksBackendApi<B> + ?Sized,\n-    B: Backend + 'static,\n-{\n-}\n-\n #[allow(clippy::manual_non_exhaustive)]\n pub struct UpdateInfo {\n     pub duration: Duration,\n@@ -408,16 +366,10 @@ struct CurrentTaskState {\n     /// Tracks currently running local tasks, and defers cleanup of the global task until those\n     /// complete. Also used by `detached_for_testing`.\n     local_task_tracker: TaskTracker,\n-\n-    backend_state: Box<dyn Any + Send + Sync>,\n }\n \n impl CurrentTaskState {\n-    fn new(\n-        task_id: TaskId,\n-        execution_id: ExecutionId,\n-        backend_state: Box<dyn Any + Send + Sync>,\n-    ) -> Self {\n+    fn new(task_id: TaskId, execution_id: ExecutionId) -> Self {\n         Self {\n             task_id,\n             execution_id,\n@@ -426,7 +378,6 @@ impl CurrentTaskState {\n             cell_counters: Some(AutoMap::default()),\n             local_tasks: Vec::new(),\n             local_task_tracker: TaskTracker::new(),\n-            backend_state,\n         }\n     }\n \n@@ -688,14 +639,10 @@ impl<B: Backend + 'static> TurboTasks<B> {\n         let future = async move {\n             let mut schedule_again = true;\n             while schedule_again {\n-                let backend_state = this.backend.new_task_state(task_id);\n                 // it's okay for execution ids to overflow and wrap, they're just used for an assert\n                 let execution_id = this.execution_id_factory.wrapping_get();\n-                let current_task_state = Arc::new(RwLock::new(CurrentTaskState::new(\n-                    task_id,\n-                    execution_id,\n-                    Box::new(backend_state),\n-                )));\n+                let current_task_state =\n+                    Arc::new(RwLock::new(CurrentTaskState::new(task_id, execution_id)));\n                 let single_execution_future = async {\n                     if this.stopped.load(Ordering::Acquire) {\n                         this.backend.task_execution_canceled(task_id, &*this);\n@@ -1461,16 +1408,6 @@ impl<B: Backend + 'static> TurboTasksBackendApi<B> for TurboTasks<B> {\n         unsafe { self.transient_task_id_factory.reuse(id.into()) }\n     }\n \n-    fn read_task_state_dyn(&self, func: &mut dyn FnMut(&B::TaskState)) {\n-        CURRENT_TASK_STATE\n-            .with(move |ts| func(ts.read().unwrap().backend_state.downcast_ref().unwrap()))\n-    }\n-\n-    fn write_task_state_dyn(&self, func: &mut dyn FnMut(&mut B::TaskState)) {\n-        CURRENT_TASK_STATE\n-            .with(move |ts| func(ts.write().unwrap().backend_state.downcast_mut().unwrap()))\n-    }\n-\n     fn is_idle(&self) -> bool {\n         self.currently_scheduled_foreground_jobs\n             .load(Ordering::Acquire)\n@@ -1588,7 +1525,6 @@ pub fn with_turbo_tasks_for_testing<T>(\n             Arc::new(RwLock::new(CurrentTaskState::new(\n                 current_task,\n                 execution_id,\n-                Box::new(()),\n             ))),\n             f,\n         ),"
        }
    ],
    "stats": {
        "total": 102,
        "additions": 6,
        "deletions": 96
    }
}