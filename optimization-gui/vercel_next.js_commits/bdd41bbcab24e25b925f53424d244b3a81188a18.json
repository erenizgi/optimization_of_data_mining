{
    "author": "MichalMoravik",
    "message": "Docs: Updating guides on PPR and ISR (#81307)\n\nThe PR fixes issues in two different guides. \n\n### PPR\nIn PPR, the code for jsx and tsx versions should use the language\nswitcher. Currently, these are displayed below each other in the guide\nwhich seems unintentional.\n\n### ISR\nThis change fixes multiple issues:\n\n**fixes in the example:**\nthe example currently does not match the text below (_Here's how this\nexample works:_). It says:\n> If /blog/26 is requested, Next.js will generate and cache this page\non-demand\n\nthat is of course not correct because there are only 25 blog posts\nreturned from the API. No blog post data is returned for `/blog/26`,\nmaking this example wrong and confusing.\n\nBy slicing the posts and supplying only 24 of 25 blog posts for static\ngeneration during the build process, the guide becomes much more\nexplicit - the 25th blog post can be used for inspecting the workings of\nthe on-the-fly generation and caching. Turning `dynamicParams` to\n`false` or `true`, one can now truly test this behaviour with the 25th\nblog.\n\nSecond, the same example in Pages Router docs includes:\n> return { paths, fallback: false }\n\nIn this case, again, this part below:\n\n> If /blog/26 is requested, Next.js will generate and cache this page\non-demand\n\nis incorrect. When setting `fallback` to `false`, the page is never\ngenerated on-demand and returns 404 instead as there is no 26th blog\npost in the fetched data. So the fix changes the value of `fallback` to\n`blocking`, to mirror the App Router's `dynamicParams` value in the\nguide. This makes is more consistent and, more importantly, reproducible\nexample.\n\n**clarifying the on-demand section:**\nThe sections dedicated to **on-demand revalidation** do not currently\nmention that revalidation works differently from the time-based one. One\nmay assume the first request after on-demand revalidation returns stale\ndata (just like time-based).\n\nBut that's not true, the next request after on-demand revalidation (with\nServer Actions for example) generates the content on-the-fly and returns\nfresh data right away. It wasn't clear to me so I tested it myself and\nwas surprised (and happy) that it is this smart. I think it's very\nimportant to clarify this distinction in the guide.\n\n-----\n\nI hope this makes sense. I'm quite responsive these days and will change\nit based on your feedback (if any). Thanks!\n\n<!-- Thanks for opening a PR! Your contribution is much appreciated.\nTo make sure your PR is handled as smoothly as possible we request that\nyou follow the checklist sections below.\nChoose the right checklist for the change(s) that you're making:\n\n## For Contributors\n\n### Improving Documentation\n\n- Run `pnpm prettier-fix` to fix formatting issues before opening the\nPR.\n- Read the Docs Contribution Guide to ensure your contribution follows\nthe docs guidelines:\nhttps://nextjs.org/docs/community/contribution-guide\n\n### Adding or Updating Examples\n\n- The \"examples guidelines\" are followed from our contributing doc\nhttps://github.com/vercel/next.js/blob/canary/contributing/examples/adding-examples.md\n- Make sure the linting passes by running `pnpm build && pnpm lint`. See\nhttps://github.com/vercel/next.js/blob/canary/contributing/repository/linting.md\n\n### Fixing a bug\n\n- Related issues linked using `fixes #number`\n- Tests added. See:\nhttps://github.com/vercel/next.js/blob/canary/contributing/core/testing.md#writing-tests-for-nextjs\n- Errors have a helpful link attached, see\nhttps://github.com/vercel/next.js/blob/canary/contributing.md\n\n### Adding a feature\n\n- Implements an existing feature request or RFC. Make sure the feature\nrequest has been accepted for implementation before opening a PR. (A\ndiscussion must be opened, see\nhttps://github.com/vercel/next.js/discussions/new?category=ideas)\n- Related issues/discussions are linked using `fixes #number`\n- e2e tests added\n(https://github.com/vercel/next.js/blob/canary/contributing/core/testing.md#writing-tests-for-nextjs)\n- Documentation added\n- Telemetry added. In case of a feature if it's used or not.\n- Errors have a helpful link attached, see\nhttps://github.com/vercel/next.js/blob/canary/contributing.md\n\n\n## For Maintainers\n\n- Minimal description (aim for explaining to someone not on the team to\nunderstand the PR)\n- When linking to a Slack thread, you might want to share details of the\nconclusion\n- Link both the Linear (Fixes NEXT-xxx) and the GitHub issues\n- Add review comments if necessary to explain to the reviewer the logic\nbehind a change\n\n### What?\n\n### Why?\n\n### How?\n\nCloses NEXT-\nFixes #\n\n-->\n\n---------\n\nCo-authored-by: Joseph <joseph.chamochumbi@vercel.com>",
    "sha": "bdd41bbcab24e25b925f53424d244b3a81188a18",
    "files": [
        {
            "sha": "8d4b776330b47fcee82ec64120ddd615786eb11d",
            "filename": "docs/01-app/01-getting-started/06-partial-prerendering.mdx",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/bdd41bbcab24e25b925f53424d244b3a81188a18/docs%2F01-app%2F01-getting-started%2F06-partial-prerendering.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/bdd41bbcab24e25b925f53424d244b3a81188a18/docs%2F01-app%2F01-getting-started%2F06-partial-prerendering.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F01-getting-started%2F06-partial-prerendering.mdx?ref=bdd41bbcab24e25b925f53424d244b3a81188a18",
            "patch": "@@ -142,7 +142,7 @@ export default function Layout({ children }: { children: React.ReactNode }) {\n }\n ```\n \n-```jsx filename=\"/app/dashboard/layout.js\" switcher\n+```jsx filename=\"/app/dashboard/layout.jsx\" switcher\n export const experimental_ppr = true\n \n export default function Layout({ children }) {"
        },
        {
            "sha": "bca3d8859a7ef04e44dfff1ad0ca0bc7aa023789",
            "filename": "docs/01-app/02-guides/incremental-static-regeneration.mdx",
            "status": "modified",
            "additions": 20,
            "deletions": 26,
            "changes": 46,
            "blob_url": "https://github.com/vercel/next.js/blob/bdd41bbcab24e25b925f53424d244b3a81188a18/docs%2F01-app%2F02-guides%2Fincremental-static-regeneration.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/bdd41bbcab24e25b925f53424d244b3a81188a18/docs%2F01-app%2F02-guides%2Fincremental-static-regeneration.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F02-guides%2Fincremental-static-regeneration.mdx?ref=bdd41bbcab24e25b925f53424d244b3a81188a18",
            "patch": "@@ -35,11 +35,6 @@ interface Post {\n // request comes in, at most once every 60 seconds.\n export const revalidate = 60\n \n-// We'll prerender only the params from `generateStaticParams` at build time.\n-// If a request comes in for a path that hasn't been generated,\n-// Next.js will server-render the page on-demand.\n-export const dynamicParams = true // or false, to 404 on unknown paths\n-\n export async function generateStaticParams() {\n   const posts: Post[] = await fetch('https://api.vercel.app/blog').then((res) =>\n     res.json()\n@@ -67,16 +62,11 @@ export default async function Page({\n }\n ```\n \n-```jsx filename=\"app/blog/[id]/page.js\" switcher\n+```jsx filename=\"app/blog/[id]/page.jsx\" switcher\n // Next.js will invalidate the cache when a\n // request comes in, at most once every 60 seconds.\n export const revalidate = 60\n \n-// We'll prerender only the params from `generateStaticParams` at build time.\n-// If a request comes in for a path that hasn't been generated,\n-// Next.js will server-render the page on-demand.\n-export const dynamicParams = true // or false, to 404 on unknown paths\n-\n export async function generateStaticParams() {\n   const posts = await fetch('https://api.vercel.app/blog').then((res) =>\n     res.json()\n@@ -100,6 +90,15 @@ export default async function Page({ params }) {\n }\n ```\n \n+Here's how this example works:\n+\n+1. During `next build`, all known blog posts are generated\n+2. All requests made to these pages (e.g. `/blog/1`) are cached and instantaneous\n+3. After 60 seconds has passed, the next request will still return the cached (now stale) page\n+4. The cache is invalidated and a new version of the page begins generating in the background\n+5. Once generated successfully, the next request will return the updated page and cache it for subsequent requests\n+6. If `/blog/26` is requested, and it exists, the page will be generated on-demand. This behavior can be changed by using a different [dynamicParams](https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config#dynamicparams) value. However, if the post does not exist, then 404 is returned.\n+\n </AppOnly>\n \n <PagesOnly>\n@@ -125,10 +124,7 @@ export const getStaticPaths: GetStaticPaths = async () => {\n     params: { id: String(post.id) },\n   }))\n \n-  // We'll prerender only these paths at build time.\n-  // { fallback: 'blocking' } will server-render pages\n-  // on-demand if the path doesn't exist.\n-  return { paths, fallback: false }\n+  return { paths, fallback: 'blocking' }\n }\n \n export const getStaticProps: GetStaticProps<Props> = async ({\n@@ -167,9 +163,7 @@ export async function getStaticPaths() {\n     params: { id: post.id },\n   }))\n \n-  // We'll prerender only these paths at build time.\n-  // { fallback: false } means other routes should 404.\n-  return { paths, fallback: false }\n+  return { paths, fallback: 'blocking' }\n }\n \n export async function getStaticProps({ params }) {\n@@ -195,16 +189,16 @@ export default function Page({ post }) {\n }\n ```\n \n-</PagesOnly>\n-\n Here's how this example works:\n \n-1. During `next build`, all known blog posts are generated (there are 25 in this example)\n+1. During `next build`, all known blog posts are generated\n 2. All requests made to these pages (e.g. `/blog/1`) are cached and instantaneous\n-3. After 60 seconds has passed, the next request will still show the cached (stale) page\n+3. After 60 seconds has passed, the next request will still return the cached (now stale) page\n 4. The cache is invalidated and a new version of the page begins generating in the background\n-5. Once generated successfully, Next.js will display and cache the updated page\n-6. If `/blog/26` is requested, Next.js will generate and cache this page on-demand\n+5. Once generated successfully, the next request will return the updated page and cache it for subsequent requests\n+6. If `/blog/26` is requested, and it exists, the page will be generated on-demand. This behavior can be changed by using a different [fallback](https://nextjs.org/docs/pages/api-reference/functions/get-static-paths#fallback-false) value. However, if the post does not exist, then 404 is returned.\n+\n+</PagesOnly>\n \n ## Reference\n \n@@ -237,7 +231,7 @@ Here's how this example works:\n \n ### Time-based revalidation\n \n-This fetches and displays a list of blog posts on `/blog`. After an hour, the cache for this page is invalidated on the next visit to the page. Then, in the background, a new version of the page is generated with the latest blog posts.\n+This fetches and displays a list of blog posts on /blog. After an hour has passed, the next visitor will still receive the cached (stale) version of the page immediately for a fast response. Simultaneously, Next.js triggers regeneration of a fresh version in the background. Once the new version is successfully generated, it replaces the cached version, and subsequent visitors will receive the updated content.\n \n ```tsx filename=\"app/blog/page.tsx\" switcher\n interface Post {\n@@ -289,7 +283,7 @@ We recommend setting a high revalidation time. For instance, 1 hour instead of 1\n \n For a more precise method of revalidation, invalidate pages on-demand with the `revalidatePath` function.\n \n-For example, this Server Action would get called after adding a new post. Regardless of how you retrieve your data in your Server Component, either using `fetch` or connecting to a database, this will clear the cache for the entire route and allow the Server Component to fetch fresh data.\n+For example, this Server Action would get called after adding a new post. Regardless of how you retrieve your data in your Server Component, either using `fetch` or connecting to a database, this will immediately clear the cache for the entire route. Unlike time-based revalidation, the next request after on-demand revalidation won't return stale data but will serve the updated version right away and cache it for subsequent requests.\n \n ```ts filename=\"app/actions.ts\" switcher\n 'use server'"
        }
    ],
    "stats": {
        "total": 48,
        "additions": 21,
        "deletions": 27
    }
}