{
    "author": "kdy1",
    "message": "refactor(turbopack): Prepare removal of fake AST in tree-shaking (#78172)\n\n### What?\n\nRefactor `references` of `EcmascriptModulePartAsset`.\n\n### Why?\n\nI'll remove the fake AST with another PR on the graphite stack.",
    "sha": "2a91953e663ed5f2c583ef6ac604a6c1a753391b",
    "files": [
        {
            "sha": "fa52abc75e709a4173786a9df46034079776390d",
            "filename": "turbopack/crates/turbopack-ecmascript/src/tree_shake/asset.rs",
            "status": "modified",
            "additions": 27,
            "deletions": 27,
            "changes": 54,
            "blob_url": "https://github.com/vercel/next.js/blob/2a91953e663ed5f2c583ef6ac604a6c1a753391b/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fasset.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2a91953e663ed5f2c583ef6ac604a6c1a753391b/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fasset.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fasset.rs?ref=2a91953e663ed5f2c583ef6ac604a6c1a753391b",
            "patch": "@@ -9,7 +9,7 @@ use turbopack_core::{\n     ident::AssetIdent,\n     module::Module,\n     module_graph::ModuleGraph,\n-    reference::{ModuleReference, ModuleReferences, SingleModuleReference},\n+    reference::{ModuleReference, ModuleReferences},\n     resolve::{origin::ResolveOrigin, ModulePart},\n };\n \n@@ -24,7 +24,9 @@ use crate::{\n         analyse_ecmascript_module, esm::FoundExportType, follow_reexports, FollowExportsResult,\n     },\n     side_effect_optimization::facade::module::EcmascriptModuleFacadeModule,\n-    tree_shake::{side_effect_module::SideEffectsModule, Key},\n+    tree_shake::{\n+        reference::EcmascriptModulePartReference, side_effect_module::SideEffectsModule, Key,\n+    },\n     AnalyzeEcmascriptModuleResult, EcmascriptAnalyzable, EcmascriptModuleAsset,\n     EcmascriptModuleAssetType, EcmascriptModuleContent, EcmascriptParsable,\n };\n@@ -289,40 +291,34 @@ impl Module for EcmascriptModulePartAsset {\n \n     #[turbo_tasks::function]\n     async fn references(&self) -> Result<Vc<ModuleReferences>> {\n-        let split_data = split_module(*self.full_module).await?;\n-\n-        let analyze = analyze(*self.full_module, self.part.clone());\n-\n-        let deps = match &*split_data {\n-            SplitResult::Ok { deps, .. } => deps,\n-            SplitResult::Failed { .. } => return Ok(analyze.references()),\n-        };\n-\n         let part_dep = |part: ModulePart| -> Vc<Box<dyn ModuleReference>> {\n-            Vc::upcast(SingleModuleReference::new(\n-                Vc::upcast(EcmascriptModulePartAsset::new(*self.full_module, part)),\n-                Vc::cell(\"ecmascript module part\".into()),\n-            ))\n+            Vc::upcast(EcmascriptModulePartReference::new(*self.full_module, part))\n         };\n \n-        let mut references = analyze.references().owned().await?;\n-\n-        // Facade depends on evaluation and re-exports\n-        if self.part == ModulePart::Facade {\n+        if let ModulePart::Facade = self.part {\n+            // Facade depends on evaluation and re-exports\n+            let mut references = vec![];\n             references.push(part_dep(ModulePart::evaluation()).to_resolved().await?);\n             references.push(part_dep(ModulePart::exports()).to_resolved().await?);\n             return Ok(Vc::cell(references));\n         }\n \n-        let deps = {\n-            let part_id = get_part_id(&split_data, &self.part)\n-                .await\n-                .with_context(|| format!(\"part {:?} is not found in the module\", self.part))?;\n+        let split_data = split_module(*self.full_module).await?;\n \n-            match deps.get(&part_id) {\n-                Some(v) => &**v,\n-                None => &[],\n-            }\n+        let SplitResult::Ok { deps, .. } = &*split_data else {\n+            // If the module is not split, we don't need to add any references\n+            return Ok(Vc::cell(vec![]));\n+        };\n+\n+        let mut references = vec![];\n+\n+        let part_id = get_part_id(&split_data, &self.part)\n+            .await\n+            .with_context(|| format!(\"part {:?} is not found in the module\", self.part))?;\n+\n+        let deps = match deps.get(&part_id) {\n+            Some(v) => &**v,\n+            None => &[],\n         };\n \n         references.extend(\n@@ -346,6 +342,10 @@ impl Module for EcmascriptModulePartAsset {\n                 .await?,\n         );\n \n+        let analyze = analyze(*self.full_module, self.part.clone());\n+\n+        references.extend(analyze.references().owned().await?);\n+\n         Ok(Vc::cell(references))\n     }\n }"
        },
        {
            "sha": "4310e45fc8fca40c0d5c91e9d8b81ff794698150",
            "filename": "turbopack/crates/turbopack-ecmascript/src/tree_shake/mod.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/2a91953e663ed5f2c583ef6ac604a6c1a753391b/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2a91953e663ed5f2c583ef6ac604a6c1a753391b/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fmod.rs?ref=2a91953e663ed5f2c583ef6ac604a6c1a753391b",
            "patch": "@@ -27,6 +27,7 @@ pub mod chunk_item;\n mod graph;\n pub mod merge;\n mod optimizations;\n+pub mod reference;\n pub mod side_effect_module;\n #[cfg(test)]\n mod tests;"
        },
        {
            "sha": "198a9e9839902e5b27608474078b9e07bcc7f910",
            "filename": "turbopack/crates/turbopack-ecmascript/src/tree_shake/reference.rs",
            "status": "added",
            "additions": 54,
            "deletions": 0,
            "changes": 54,
            "blob_url": "https://github.com/vercel/next.js/blob/2a91953e663ed5f2c583ef6ac604a6c1a753391b/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Freference.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2a91953e663ed5f2c583ef6ac604a6c1a753391b/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Freference.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Freference.rs?ref=2a91953e663ed5f2c583ef6ac604a6c1a753391b",
            "patch": "@@ -0,0 +1,54 @@\n+use anyhow::Result;\n+use turbo_rcstr::RcStr;\n+use turbo_tasks::{ResolvedVc, ValueToString, Vc};\n+use turbopack_core::{\n+    chunk::{ChunkableModuleReference, ChunkingType, ChunkingTypeOption},\n+    reference::ModuleReference,\n+    resolve::{ModulePart, ModuleResolveResult},\n+};\n+\n+use crate::{tree_shake::asset::EcmascriptModulePartAsset, EcmascriptModuleAsset};\n+\n+/// A reference to the [EcmascriptModuleLocalsModule] variant of an original\n+/// module.\n+#[turbo_tasks::value]\n+pub struct EcmascriptModulePartReference {\n+    pub module: ResolvedVc<EcmascriptModuleAsset>,\n+    pub part: ModulePart,\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl EcmascriptModulePartReference {\n+    #[turbo_tasks::function]\n+    pub fn new(module: ResolvedVc<EcmascriptModuleAsset>, part: ModulePart) -> Vc<Self> {\n+        EcmascriptModulePartReference { module, part }.cell()\n+    }\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl ValueToString for EcmascriptModulePartReference {\n+    #[turbo_tasks::function]\n+    async fn to_string(&self) -> Result<Vc<RcStr>> {\n+        Ok(Vc::cell(self.part.to_string().into()))\n+    }\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl ModuleReference for EcmascriptModulePartReference {\n+    #[turbo_tasks::function]\n+    async fn resolve_reference(&self) -> Result<Vc<ModuleResolveResult>> {\n+        let module = EcmascriptModulePartAsset::new(*self.module, self.part.clone())\n+            .to_resolved()\n+            .await?;\n+\n+        Ok(*ModuleResolveResult::module(ResolvedVc::upcast(module)))\n+    }\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl ChunkableModuleReference for EcmascriptModulePartReference {\n+    #[turbo_tasks::function]\n+    fn chunking_type(self: Vc<Self>) -> Vc<ChunkingTypeOption> {\n+        Vc::cell(Some(ChunkingType::ParallelInheritAsync))\n+    }\n+}"
        }
    ],
    "stats": {
        "total": 109,
        "additions": 82,
        "deletions": 27
    }
}