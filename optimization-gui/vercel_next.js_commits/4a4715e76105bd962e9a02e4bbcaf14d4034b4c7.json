{
    "author": "bgw",
    "message": "feat(turbopack): Print a warning about performance when starting with an invalidated cache (#80631)\n\nWe want to show a warning to the user when we start up with an invalidated cache, letting them know why `next dev` might be a little slower than usual.\n\nThis is done by writing a JSON-encoded `reason_code` value to the invalidation marker file that's then read when starting back up.\n\nI'm using @Cy-Tek's compilation event logging to log this from the JS side, so that log styling matches other Next.js warnings. This is a little tricky because of a chicken-and-egg dependency on turbo-tasks. We must invalidate the cache before constructing the turbo-tasks backend, and then emit the event after turbo-tasks is constructed.\n\n## Testing\n\nReset the cache using the web UI:\n\n<img src=\"https://graphite-user-uploaded-assets-prod.s3.amazonaws.com/HAZVitxRNnZz8QMiPn4a/ac47b80d-d09c-48a8-bdcf-6f6f1bfd8288.png\" width=\"500\">\n\nAnd see a warning logged to the terminal:\n\n<img src=\"https://graphite-user-uploaded-assets-prod.s3.amazonaws.com/HAZVitxRNnZz8QMiPn4a/e1860d1a-defd-46c2-9a85-a0c64e26f634.png\" width=\"700\">\n\nThis user-requested use-case is a bit contrived, we mostly care about automatic invalidation upon panic, as those are the ones that may be surprising to the user.",
    "sha": "4a4715e76105bd962e9a02e4bbcaf14d4034b4c7",
    "files": [
        {
            "sha": "bcc35273255424a8ff876d6b4af232fb25fd435b",
            "filename": "crates/napi/src/next_api/project.rs",
            "status": "modified",
            "additions": 10,
            "deletions": 3,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/4a4715e76105bd962e9a02e4bbcaf14d4034b4c7/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4a4715e76105bd962e9a02e4bbcaf14d4034b4c7/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs?ref=4a4715e76105bd962e9a02e4bbcaf14d4034b4c7",
            "patch": "@@ -35,6 +35,7 @@ use turbo_tasks::{\n     message_queue::{CompilationEvent, Severity, TimingEvent},\n     trace::TraceRawVcs,\n };\n+use turbo_tasks_backend::db_invalidation::invalidation_reasons;\n use turbo_tasks_fs::{\n     DiskFileSystem, FileContent, FileSystem, FileSystemPath, get_relative_path_to,\n     util::uri_from_file,\n@@ -571,9 +572,15 @@ pub async fn project_update(\n pub async fn project_invalidate_persistent_cache(\n     #[napi(ts_arg_type = \"{ __napiType: \\\"Project\\\" }\")] project: External<ProjectInstance>,\n ) -> napi::Result<()> {\n-    tokio::task::spawn_blocking(move || project.turbo_tasks.invalidate_persistent_cache())\n-        .await\n-        .context(\"panicked while invalidating persistent cache\")??;\n+    tokio::task::spawn_blocking(move || {\n+        // TODO: Let the JS caller specify a reason? We need to limit the reasons to ones we know\n+        // how to generate a message for on the Rust side of the FFI.\n+        project\n+            .turbo_tasks\n+            .invalidate_persistent_cache(invalidation_reasons::USER_REQUEST)\n+    })\n+    .await\n+    .context(\"panicked while invalidating persistent cache\")??;\n     Ok(())\n }\n "
        },
        {
            "sha": "9d9bed88cd946597689dd9e9f909b7c983bed2aa",
            "filename": "crates/napi/src/next_api/utils.rs",
            "status": "modified",
            "additions": 62,
            "deletions": 26,
            "changes": 88,
            "blob_url": "https://github.com/vercel/next.js/blob/4a4715e76105bd962e9a02e4bbcaf14d4034b4c7/crates%2Fnapi%2Fsrc%2Fnext_api%2Futils.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4a4715e76105bd962e9a02e4bbcaf14d4034b4c7/crates%2Fnapi%2Fsrc%2Fnext_api%2Futils.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnapi%2Fsrc%2Fnext_api%2Futils.rs?ref=4a4715e76105bd962e9a02e4bbcaf14d4034b4c7",
            "patch": "@@ -11,12 +11,14 @@ use serde::Serialize;\n use tokio::sync::mpsc::Receiver;\n use turbo_tasks::{\n     Effects, OperationVc, ReadRef, TaskId, TryJoinIterExt, TurboTasks, TurboTasksApi, UpdateInfo,\n-    Vc, VcValueType, get_effects, message_queue::CompilationEvent,\n-    task_statistics::TaskStatisticsApi, trace::TraceRawVcs,\n+    Vc, VcValueType, get_effects,\n+    message_queue::{CompilationEvent, Severity},\n+    task_statistics::TaskStatisticsApi,\n+    trace::TraceRawVcs,\n };\n use turbo_tasks_backend::{\n-    DefaultBackingStorage, GitVersionInfo, NoopBackingStorage, default_backing_storage,\n-    noop_backing_storage,\n+    BackingStorage, DefaultBackingStorage, GitVersionInfo, NoopBackingStorage, StartupCacheState,\n+    db_invalidation::invalidation_reasons, default_backing_storage, noop_backing_storage,\n };\n use turbo_tasks_fs::FileContent;\n use turbopack_core::{\n@@ -150,17 +152,51 @@ impl NextTurboTasks {\n         }\n     }\n \n-    pub fn invalidate_persistent_cache(&self) -> Result<()> {\n+    pub fn invalidate_persistent_cache(&self, reason_code: &str) -> Result<()> {\n         match self {\n             NextTurboTasks::Memory(_) => {}\n-            NextTurboTasks::PersistentCaching(turbo_tasks) => {\n-                turbo_tasks.backend().invalidate_storage()?\n-            }\n+            NextTurboTasks::PersistentCaching(turbo_tasks) => turbo_tasks\n+                .backend()\n+                .backing_storage()\n+                .invalidate(reason_code)?,\n         }\n         Ok(())\n     }\n }\n \n+#[derive(Serialize)]\n+struct StartupCacheInvalidationEvent {\n+    reason_code: Option<String>,\n+}\n+\n+impl CompilationEvent for StartupCacheInvalidationEvent {\n+    fn type_name(&self) -> &'static str {\n+        \"StartupCacheInvalidationEvent\"\n+    }\n+\n+    fn severity(&self) -> Severity {\n+        Severity::Warning\n+    }\n+\n+    fn message(&self) -> String {\n+        let reason_msg = match self.reason_code.as_deref() {\n+            Some(invalidation_reasons::PANIC) => {\n+                \" because we previously detected an internal error in Turbopack\"\n+            }\n+            Some(invalidation_reasons::USER_REQUEST) => \" as the result of a user request\",\n+            _ => \"\", // ignore unknown reasons\n+        };\n+        format!(\n+            \"Turbopack's persistent cache has been deleted{reason_msg}. Builds or page loads may \\\n+             be slower as a result.\"\n+        )\n+    }\n+\n+    fn to_json(&self) -> String {\n+        serde_json::to_string(self).unwrap()\n+    }\n+}\n+\n pub fn create_turbo_tasks(\n     output_path: PathBuf,\n     persistent_caching: bool,\n@@ -174,24 +210,24 @@ pub fn create_turbo_tasks(\n             dirty: option_env!(\"CI\").is_none_or(|value| value.is_empty())\n                 && env!(\"VERGEN_GIT_DIRTY\") == \"true\",\n         };\n-        NextTurboTasks::PersistentCaching(TurboTasks::new(\n-            turbo_tasks_backend::TurboTasksBackend::new(\n-                turbo_tasks_backend::BackendOptions {\n-                    storage_mode: Some(if std::env::var(\"TURBO_ENGINE_READ_ONLY\").is_ok() {\n-                        turbo_tasks_backend::StorageMode::ReadOnly\n-                    } else {\n-                        turbo_tasks_backend::StorageMode::ReadWrite\n-                    }),\n-                    dependency_tracking,\n-                    ..Default::default()\n-                },\n-                default_backing_storage(\n-                    &output_path.join(\"cache/turbopack\"),\n-                    &version_info,\n-                    is_ci,\n-                )?,\n-            ),\n-        ))\n+        let (backing_storage, cache_state) =\n+            default_backing_storage(&output_path.join(\"cache/turbopack\"), &version_info, is_ci)?;\n+        let tt = TurboTasks::new(turbo_tasks_backend::TurboTasksBackend::new(\n+            turbo_tasks_backend::BackendOptions {\n+                storage_mode: Some(if std::env::var(\"TURBO_ENGINE_READ_ONLY\").is_ok() {\n+                    turbo_tasks_backend::StorageMode::ReadOnly\n+                } else {\n+                    turbo_tasks_backend::StorageMode::ReadWrite\n+                }),\n+                dependency_tracking,\n+                ..Default::default()\n+            },\n+            backing_storage,\n+        ));\n+        if let StartupCacheState::Invalidated { reason_code } = cache_state {\n+            tt.send_compilation_event(Arc::new(StartupCacheInvalidationEvent { reason_code }));\n+        }\n+        NextTurboTasks::PersistentCaching(tt)\n     } else {\n         NextTurboTasks::Memory(TurboTasks::new(\n             turbo_tasks_backend::TurboTasksBackend::new("
        },
        {
            "sha": "310502e543afcd59880cf9db53762930affff1c7",
            "filename": "packages/next/src/build/swc/index.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/4a4715e76105bd962e9a02e4bbcaf14d4034b4c7/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Findex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/4a4715e76105bd962e9a02e4bbcaf14d4034b4c7/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Findex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Findex.ts?ref=4a4715e76105bd962e9a02e4bbcaf14d4034b4c7",
            "patch": "@@ -731,13 +731,14 @@ function bindingToApi(\n       )\n     }\n \n-    compilationEventsSubscribe() {\n+    compilationEventsSubscribe(eventTypes?: string[]) {\n       return subscribe<TurbopackResult<CompilationEvent>>(\n         true,\n         async (callback) => {\n           binding.projectCompilationEventsSubscribe(\n             this._nativeProject,\n-            callback\n+            callback,\n+            eventTypes\n           )\n         }\n       )"
        },
        {
            "sha": "613b8c4e564a3a92cd45725a49c2eb99f9b26915",
            "filename": "packages/next/src/build/swc/types.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/4a4715e76105bd962e9a02e4bbcaf14d4034b4c7/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Ftypes.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/4a4715e76105bd962e9a02e4bbcaf14d4034b4c7/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Ftypes.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Ftypes.ts?ref=4a4715e76105bd962e9a02e4bbcaf14d4034b4c7",
            "patch": "@@ -238,9 +238,9 @@ export interface Project {\n     aggregationMs: number\n   ): AsyncIterableIterator<TurbopackResult<UpdateMessage>>\n \n-  compilationEventsSubscribe(): AsyncIterableIterator<\n-    TurbopackResult<CompilationEvent>\n-  >\n+  compilationEventsSubscribe(\n+    eventTypes?: string[]\n+  ): AsyncIterableIterator<TurbopackResult<CompilationEvent>>\n \n   invalidatePersistentCache(): Promise<void>\n "
        },
        {
            "sha": "45529f6fbd66df6bfc2c54bb0c5a5273657de52e",
            "filename": "packages/next/src/build/turbopack-build/impl.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 27,
            "changes": 29,
            "blob_url": "https://github.com/vercel/next.js/blob/4a4715e76105bd962e9a02e4bbcaf14d4034b4c7/packages%2Fnext%2Fsrc%2Fbuild%2Fturbopack-build%2Fimpl.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/4a4715e76105bd962e9a02e4bbcaf14d4034b4c7/packages%2Fnext%2Fsrc%2Fbuild%2Fturbopack-build%2Fimpl.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fturbopack-build%2Fimpl.ts?ref=4a4715e76105bd962e9a02e4bbcaf14d4034b4c7",
            "patch": "@@ -19,8 +19,8 @@ import loadConfig from '../../server/config'\n import { hasCustomExportOutput } from '../../export/utils'\n import { Telemetry } from '../../telemetry/storage'\n import { setGlobal } from '../../trace'\n-import * as Log from '../output/log'\n import { isCI } from '../../server/ci-info'\n+import { backgroundLogCompilationEvents } from '../../shared/lib/turbopack/compilation-events'\n \n export async function turbopackBuild(): Promise<{\n   duration: number\n@@ -91,32 +91,7 @@ export async function turbopackBuild(): Promise<{\n     }\n   )\n   try {\n-    ;(async function logCompilationEvents() {\n-      for await (const event of project.compilationEventsSubscribe()) {\n-        switch (event.severity) {\n-          case 'EVENT':\n-            Log.event(event.message)\n-            break\n-          case 'TRACE':\n-            Log.trace(event.message)\n-            break\n-          case 'INFO':\n-            Log.info(event.message)\n-            break\n-          case 'WARNING':\n-            Log.warn(event.message)\n-            break\n-          case 'ERROR':\n-            Log.error(event.message)\n-            break\n-          case 'FATAL':\n-            Log.error(event.message)\n-            break\n-          default:\n-            break\n-        }\n-      }\n-    })()\n+    backgroundLogCompilationEvents(project)\n \n     // Write an empty file in a known location to signal this was built with Turbopack\n     await fs.writeFile(path.join(distDir, 'turbopack'), '')"
        },
        {
            "sha": "4ac8b85b5440bea06f5323e44ab6b10cd5284498",
            "filename": "packages/next/src/server/dev/hot-reloader-turbopack.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/4a4715e76105bd962e9a02e4bbcaf14d4034b4c7/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fhot-reloader-turbopack.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/4a4715e76105bd962e9a02e4bbcaf14d4034b4c7/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fhot-reloader-turbopack.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fhot-reloader-turbopack.ts?ref=4a4715e76105bd962e9a02e4bbcaf14d4034b4c7",
            "patch": "@@ -98,6 +98,7 @@ import { getDevOverlayFontMiddleware } from '../../next-devtools/server/font/get\n import { devIndicatorServerState } from './dev-indicator-server-state'\n import { getDisableDevIndicatorMiddleware } from '../../next-devtools/server/dev-indicator-middleware'\n import { getRestartDevServerMiddleware } from '../../next-devtools/server/restart-dev-server-middleware'\n+import { backgroundLogCompilationEvents } from '../../shared/lib/turbopack/compilation-events'\n // import { getSupportedBrowsers } from '../../build/utils'\n \n const wsServer = new ws.Server({ noServer: true })\n@@ -248,6 +249,9 @@ export async function createHotReloaderTurbopack(\n       memoryLimit: opts.nextConfig.experimental?.turbopackMemoryLimit,\n     }\n   )\n+  backgroundLogCompilationEvents(project, {\n+    eventTypes: ['StartupCacheInvalidationEvent'],\n+  })\n   setBundlerFindSourceMapImplementation(\n     getSourceMapFromTurbopack.bind(null, project, projectPath)\n   )"
        },
        {
            "sha": "e12520d8e3d17ea6bb794e6eb1e8a248d7a8f7e5",
            "filename": "packages/next/src/shared/lib/turbopack/compilation-events.ts",
            "status": "added",
            "additions": 44,
            "deletions": 0,
            "changes": 44,
            "blob_url": "https://github.com/vercel/next.js/blob/4a4715e76105bd962e9a02e4bbcaf14d4034b4c7/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fturbopack%2Fcompilation-events.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/4a4715e76105bd962e9a02e4bbcaf14d4034b4c7/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fturbopack%2Fcompilation-events.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fturbopack%2Fcompilation-events.ts?ref=4a4715e76105bd962e9a02e4bbcaf14d4034b4c7",
            "patch": "@@ -0,0 +1,44 @@\n+import type { Project } from '../../../build/swc/types'\n+import * as Log from '../../../build/output/log'\n+\n+/**\n+ * Subscribes to compilation events for `project` and prints them using the\n+ * `Log` library.\n+ *\n+ * The `signal` argument is partially implemented. The abort may not happen until the next\n+ * compilation event arrives.\n+ */\n+export function backgroundLogCompilationEvents(\n+  project: Project,\n+  { eventTypes, signal }: { eventTypes?: string[]; signal?: AbortSignal } = {}\n+) {\n+  ;(async function () {\n+    for await (const event of project.compilationEventsSubscribe(eventTypes)) {\n+      if (signal?.aborted) {\n+        return\n+      }\n+      switch (event.severity) {\n+        case 'EVENT':\n+          Log.event(event.message)\n+          break\n+        case 'TRACE':\n+          Log.trace(event.message)\n+          break\n+        case 'INFO':\n+          Log.info(event.message)\n+          break\n+        case 'WARNING':\n+          Log.warn(event.message)\n+          break\n+        case 'ERROR':\n+          Log.error(event.message)\n+          break\n+        case 'FATAL':\n+          Log.error(event.message)\n+          break\n+        default:\n+          break\n+      }\n+    }\n+  })()\n+}"
        },
        {
            "sha": "421b4dbd6ab5e483199b01de07e2c57ebbe7a942",
            "filename": "turbopack/crates/turbo-tasks-backend/Cargo.toml",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/4a4715e76105bd962e9a02e4bbcaf14d4034b4c7/turbopack%2Fcrates%2Fturbo-tasks-backend%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/4a4715e76105bd962e9a02e4bbcaf14d4034b4c7/turbopack%2Fcrates%2Fturbo-tasks-backend%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2FCargo.toml?ref=4a4715e76105bd962e9a02e4bbcaf14d4034b4c7",
            "patch": "@@ -41,6 +41,7 @@ rand = { workspace = true }\n rayon = { workspace = true }\n rustc-hash = { workspace = true }\n serde = { workspace = true }\n+serde_json = { workspace = true }\n serde_path_to_error = { workspace = true }\n smallvec = { workspace = true }\n tokio = { workspace = true }\n@@ -54,7 +55,6 @@ turbo-tasks-testing = { workspace = true }\n [dev-dependencies]\n criterion = { workspace = true, features = [\"async_tokio\"] }\n regex = { workspace = true }\n-serde_json = { workspace = true }\n tempfile = { workspace = true }\n rstest = { workspace = true }\n "
        },
        {
            "sha": "cac70a5482303f19af26f6f1588f47de91ef15f8",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/4a4715e76105bd962e9a02e4bbcaf14d4034b4c7/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4a4715e76105bd962e9a02e4bbcaf14d4034b4c7/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=4a4715e76105bd962e9a02e4bbcaf14d4034b4c7",
            "patch": "@@ -210,8 +210,8 @@ impl<B: BackingStorage> TurboTasksBackend<B> {\n         )))\n     }\n \n-    pub fn invalidate_storage(&self) -> Result<()> {\n-        self.0.backing_storage.invalidate()\n+    pub fn backing_storage(&self) -> &B {\n+        &self.0.backing_storage\n     }\n }\n "
        },
        {
            "sha": "cf33d978e364dcba4e0dd62ef2138e30ff4bb371",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backing_storage.rs",
            "status": "modified",
            "additions": 30,
            "deletions": 11,
            "changes": 41,
            "blob_url": "https://github.com/vercel/next.js/blob/4a4715e76105bd962e9a02e4bbcaf14d4034b4c7/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbacking_storage.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4a4715e76105bd962e9a02e4bbcaf14d4034b4c7/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbacking_storage.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbacking_storage.rs?ref=4a4715e76105bd962e9a02e4bbcaf14d4034b4c7",
            "patch": "@@ -10,7 +10,36 @@ use crate::{\n     utils::chunked_vec::ChunkedVec,\n };\n \n-pub trait BackingStorage: 'static + Send + Sync {\n+/// Represents types accepted by [`TurboTasksBackend::new`]. Typically this is the value returned by\n+/// [`default_backing_storage`] or [`noop_backing_storage`].\n+///\n+/// This trait is [sealed]. External crates are not allowed to implement it.\n+///\n+/// [`default_backing_storage`]: crate::default_backing_storage\n+/// [`noop_backing_storage`]: crate::noop_backing_storage\n+/// [`TurboTasksBackend::new`]: crate::TurboTasksBackend::new\n+/// [sealed]: https://predr.ag/blog/definitive-guide-to-sealed-traits-in-rust/\n+pub trait BackingStorage: BackingStorageSealed {\n+    /// Called when the database should be invalidated upon re-initialization.\n+    ///\n+    /// This typically means that we'll restart the process or `turbo-tasks` soon with a fresh\n+    /// database. If this happens, there's no point in writing anything else to disk, or flushing\n+    /// during [`KeyValueDatabase::shutdown`].\n+    ///\n+    /// This can be implemented by calling [`invalidate_db`] with\n+    /// the database's non-versioned base path.\n+    ///\n+    /// [`KeyValueDatabase::shutdown`]: crate::database::key_value_database::KeyValueDatabase::shutdown\n+    /// [`invalidate_db`]: crate::database::db_invalidation::invalidate_db\n+    fn invalidate(&self, reason_code: &str) -> Result<()>;\n+}\n+\n+/// Private methods used by [`BackingStorage`]. This trait is `pub` (because of the sealed-trait\n+/// pattern), but should not be exported outside of the crate.\n+///\n+/// [`BackingStorage`] is exported for documentation reasons and to expose the public\n+/// [`BackingStorage::invalidate`] method.\n+pub trait BackingStorageSealed: 'static + Send + Sync {\n     type ReadTransaction<'l>;\n     fn lower_read_transaction<'l: 'i + 'r, 'i: 'r, 'r>(\n         tx: &'r Self::ReadTransaction<'l>,\n@@ -63,16 +92,6 @@ pub trait BackingStorage: 'static + Send + Sync {\n         category: TaskDataCategory,\n     ) -> Result<Vec<CachedDataItem>>;\n \n-    /// Called when the database should be invalidated upon re-initialization.\n-    ///\n-    /// This typically means that we'll restart the process or `turbo-tasks` soon with a fresh\n-    /// database. If this happens, there's no point in writing anything else to disk, or flushing\n-    /// during [`KeyValueDatabase::shutdown`].\n-    ///\n-    /// This can be implemented by calling [`crate::database::db_invalidation::invalidate_db`] with\n-    /// the database's non-versioned base path.\n-    fn invalidate(&self) -> Result<()>;\n-\n     fn shutdown(&self) -> Result<()> {\n         Ok(())\n     }"
        },
        {
            "sha": "7a801cc3e6bc5245e4173b4f8143c0500fba6953",
            "filename": "turbopack/crates/turbo-tasks-backend/src/database/db_invalidation.rs",
            "status": "modified",
            "additions": 117,
            "deletions": 14,
            "changes": 131,
            "blob_url": "https://github.com/vercel/next.js/blob/4a4715e76105bd962e9a02e4bbcaf14d4034b4c7/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdatabase%2Fdb_invalidation.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4a4715e76105bd962e9a02e4bbcaf14d4034b4c7/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdatabase%2Fdb_invalidation.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdatabase%2Fdb_invalidation.rs?ref=4a4715e76105bd962e9a02e4bbcaf14d4034b4c7",
            "patch": "@@ -1,14 +1,73 @@\n use std::{\n-    fs::{self, read_dir},\n-    io::{self, ErrorKind},\n+    borrow::Cow,\n+    fs::{self, File, read_dir},\n+    io::{self, BufReader, BufWriter, ErrorKind, Write},\n     path::Path,\n };\n \n use anyhow::Context;\n+use serde::{Deserialize, Serialize};\n \n const INVALIDATION_MARKER: &str = \"__turbo_tasks_invalidated_db\";\n \n-/// Atomically write an invalidation marker.\n+const EXPLANATION: &str = \"The cache database has been invalidated. The existence of this file \\\n+                           will cause the cache directory to be cleaned up the next time \\\n+                           Turbopack starts up.\";\n+const EASTER_EGG: &str =\n+    \"you just wrote me, and this is crazy, but if you see me, delete everything maybe?\";\n+\n+/// The data written to the file at [`INVALIDATION_MARKER`].\n+#[derive(Serialize, Deserialize)]\n+struct InvalidationFile<'a> {\n+    #[serde(skip_deserializing)]\n+    _explanation: Option<&'static str>,\n+    #[serde(skip_deserializing)]\n+    _easter_egg: Option<&'static str>,\n+    /// See [`StartupCacheState::Invalidated::reason_code`].\n+    reason_code: Cow<'a, str>,\n+}\n+\n+/// Information about if there's was a pre-existing cache or if the cache was detected as\n+/// invalidated during startup.\n+///\n+/// If the cache was invalidated, the application may choose to show a warning to the user or log it\n+/// to telemetry.\n+///\n+/// This value is returned by [`crate::turbo_backing_storage`] and\n+/// [`crate::default_backing_storage`].\n+pub enum StartupCacheState {\n+    NoCache,\n+    Cached,\n+    Invalidated {\n+        /// A short code passed to [`BackingStorage::invalidate`]. This value is\n+        /// application-specific.\n+        ///\n+        /// If the value is `None` or doesn't match an expected value, the application should just\n+        /// treat this reason as unknown. The invalidation file may have been corrupted or\n+        /// modified by an external tool.\n+        ///\n+        /// See [`invalidation_reasons`] for some common reason codes.\n+        ///\n+        /// [`BackingStorage::invalidate`]: crate::BackingStorage::invalidate\n+        reason_code: Option<String>,\n+    },\n+}\n+\n+/// Common invalidation reason codes. The application or libraries it uses may choose to use these\n+/// reasons, or it may define it's own reasons.\n+pub mod invalidation_reasons {\n+    /// This invalidation reason is used by [`crate::turbo_backing_storage`] when the database was\n+    /// invalidated by a panic.\n+    pub const PANIC: &str = concat!(module_path!(), \"::PANIC\");\n+    /// Indicates that the user explicitly clicked a button or ran a command that invalidates the\n+    /// cache.\n+    pub const USER_REQUEST: &str = concat!(module_path!(), \"::USER_REQUEST\");\n+}\n+\n+/// Atomically create an invalidation marker.\n+///\n+/// Makes a best-effort attempt to write `reason_code` to the file, but ignores any failure with\n+/// writing to the file.\n ///\n /// Because attempting to delete currently open database files could cause issues, actual deletion\n /// of files is deferred until the next start-up (in [`check_db_invalidation_and_cleanup`]).\n@@ -18,9 +77,29 @@ const INVALIDATION_MARKER: &str = \"__turbo_tasks_invalidated_db\";\n ///\n /// This should be run with the base (non-versioned) path, as that likely aligns closest with user\n /// expectations (e.g. if they're clearing the cache for disk space reasons).\n-pub fn invalidate_db(base_path: &Path) -> anyhow::Result<()> {\n-    match fs::write(base_path.join(INVALIDATION_MARKER), [0u8; 0]) {\n-        Ok(_) => Ok(()),\n+///\n+/// In most cases, you should prefer a higher-level API like [`crate::BackingStorage::invalidate`]\n+/// to this one.\n+pub(crate) fn invalidate_db(base_path: &Path, reason_code: &str) -> anyhow::Result<()> {\n+    match File::create_new(base_path.join(INVALIDATION_MARKER)) {\n+        Ok(file) => {\n+            let mut writer = BufWriter::new(file);\n+            // ignore errors: We've already successfully invalidated the cache just by creating the\n+            // marker file, writing the reason_code is best-effort.\n+            let _ = serde_json::to_writer_pretty(\n+                &mut writer,\n+                &InvalidationFile {\n+                    _explanation: Some(EXPLANATION),\n+                    _easter_egg: Some(EASTER_EGG),\n+                    reason_code: Cow::Borrowed(reason_code),\n+                },\n+            );\n+            let _ = writer.flush();\n+            Ok(())\n+        }\n+        // the database was already invalidated, avoid overwriting that reason or risking concurrent\n+        // writes to the same file.\n+        Err(err) if err.kind() == ErrorKind::AlreadyExists => Ok(()),\n         // just ignore if the cache directory doesn't exist at all\n         Err(err) if err.kind() == ErrorKind::NotFound => Ok(()),\n         Err(err) => Err(err).context(\"Failed to invalidate database\"),\n@@ -31,21 +110,45 @@ pub fn invalidate_db(base_path: &Path) -> anyhow::Result<()> {\n /// delete any invalidated database files.\n ///\n /// This should be run with the base (non-versioned) path.\n-pub fn check_db_invalidation_and_cleanup(base_path: &Path) -> anyhow::Result<()> {\n-    if fs::exists(base_path.join(INVALIDATION_MARKER))? {\n-        // if this cleanup fails, we might try to open an invalid database later, so it's best to\n-        // just propagate the error here.\n-        cleanup_db(base_path)?;\n-    };\n-    Ok(())\n+///\n+/// In most cases, you should prefer a higher-level API like\n+/// [`crate::KeyValueDatabaseBackingStorage::open_versioned_on_disk`] to this one.\n+pub(crate) fn check_db_invalidation_and_cleanup(\n+    base_path: &Path,\n+) -> anyhow::Result<StartupCacheState> {\n+    match File::open(base_path.join(INVALIDATION_MARKER)) {\n+        Ok(file) => {\n+            // Best-effort: Try to read the reason_code from the file, if the file format is\n+            // corrupted (or anything else) just use `None`.\n+            let reason_code = serde_json::from_reader::<_, InvalidationFile>(BufReader::new(file))\n+                .ok()\n+                .map(|contents| contents.reason_code.into_owned());\n+            // `file` is dropped at this point: That's important for Windows where we can't delete\n+            // open files.\n+\n+            // if this cleanup fails, we might try to open an invalid database later, so it's best\n+            // to just propagate the error here.\n+            cleanup_db(base_path)?;\n+            Ok(StartupCacheState::Invalidated { reason_code })\n+        }\n+        Err(err) if err.kind() == ErrorKind::NotFound => {\n+            if fs::exists(base_path)? {\n+                Ok(StartupCacheState::Cached)\n+            } else {\n+                Ok(StartupCacheState::NoCache)\n+            }\n+        }\n+        Err(err) => Err(err)\n+            .with_context(|| format!(\"Failed to check for {INVALIDATION_MARKER} in {base_path:?}\")),\n+    }\n }\n \n /// Helper for [`check_db_invalidation_and_cleanup`]. You can call this to explicitly clean up a\n /// database after running [`invalidate_db`] when turbo-tasks is not running.\n ///\n /// You should not run this if the database has not yet been invalidated, as this operation is not\n /// atomic and could result in a partially-deleted and corrupted database.\n-pub fn cleanup_db(base_path: &Path) -> anyhow::Result<()> {\n+pub(crate) fn cleanup_db(base_path: &Path) -> anyhow::Result<()> {\n     cleanup_db_inner(base_path).with_context(|| {\n         format!(\n             \"Unable to remove invalid database. If this issue persists you can work around by \\"
        },
        {
            "sha": "915f3570a12b30af9d495cd5a806f4b8bb0726ab",
            "filename": "turbopack/crates/turbo-tasks-backend/src/kv_backing_storage.rs",
            "status": "modified",
            "additions": 38,
            "deletions": 15,
            "changes": 53,
            "blob_url": "https://github.com/vercel/next.js/blob/4a4715e76105bd962e9a02e4bbcaf14d4034b4c7/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fkv_backing_storage.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4a4715e76105bd962e9a02e4bbcaf14d4034b4c7/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fkv_backing_storage.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fkv_backing_storage.rs?ref=4a4715e76105bd962e9a02e4bbcaf14d4034b4c7",
            "patch": "@@ -21,17 +21,18 @@ use turbo_tasks::{\n use crate::{\n     GitVersionInfo,\n     backend::{AnyOperation, TaskDataCategory},\n-    backing_storage::BackingStorage,\n+    backing_storage::{BackingStorage, BackingStorageSealed},\n     data::CachedDataItem,\n     database::{\n-        db_invalidation::{check_db_invalidation_and_cleanup, invalidate_db},\n+        db_invalidation::{StartupCacheState, check_db_invalidation_and_cleanup, invalidate_db},\n         db_versioning::handle_db_versioning,\n         key_value_database::{KeySpace, KeyValueDatabase},\n         write_batch::{\n             BaseWriteBatch, ConcurrentWriteBatch, SerialWriteBatch, WriteBatch, WriteBatchRef,\n             WriteBuffer,\n         },\n     },\n+    db_invalidation::invalidation_reasons,\n     utils::chunked_vec::ChunkedVec,\n };\n \n@@ -120,15 +121,21 @@ pub struct KeyValueDatabaseBackingStorageInner<T: KeyValueDatabase> {\n     base_path: Option<PathBuf>,\n     /// Used to skip calling [`invalidate_db`] when the database has already been invalidated.\n     invalidated: Mutex<bool>,\n+    /// We configure a panic hook to invalidate the cache. This guard cleans up our panic hook upon\n+    /// drop.\n     _panic_hook_guard: Option<PanicHookGuard>,\n }\n \n pub struct KeyValueDatabaseBackingStorage<T: KeyValueDatabase> {\n+    // wrapped so that `register_panic_hook` can hold a weak reference to `inner`.\n     inner: Arc<KeyValueDatabaseBackingStorageInner<T>>,\n }\n \n+/// A wrapper type used by [`crate::turbo_backing_storage`] and [`crate::noop_backing_storage`].\n+///\n+/// Wraps a low-level key-value database into a higher-level [`BackingStorage`] type.\n impl<T: KeyValueDatabase> KeyValueDatabaseBackingStorage<T> {\n-    pub fn new_in_memory(database: T) -> Self {\n+    pub(crate) fn new_in_memory(database: T) -> Self {\n         Self {\n             inner: Arc::new(KeyValueDatabaseBackingStorageInner {\n                 database,\n@@ -139,19 +146,30 @@ impl<T: KeyValueDatabase> KeyValueDatabaseBackingStorage<T> {\n         }\n     }\n \n-    pub fn open_versioned_on_disk(\n+    /// Handles boilerplate logic for an on-disk persisted database with versioning.\n+    ///\n+    /// - Creates a directory per version, with a maximum number of old versions and performs\n+    ///   automatic cleanup of old versions.\n+    /// - Checks for a database invalidation marker file, and cleans up the database as needed.\n+    /// - [Registers a dynamic panic hook][turbo_tasks::panic_hooks] to invalidate the database upon\n+    ///   a panic. This invalidates the database using [`invalidation_reasons::PANIC`].\n+    ///\n+    /// Along with returning a [`KeyValueDatabaseBackingStorage`], this returns a\n+    /// [`StartupCacheState`], which can be used by the application for logging information to the\n+    /// user or telemetry about the cache.\n+    pub(crate) fn open_versioned_on_disk(\n         base_path: PathBuf,\n         version_info: &GitVersionInfo,\n         is_ci: bool,\n         database: impl FnOnce(PathBuf) -> Result<T>,\n-    ) -> Result<Self>\n+    ) -> Result<(Self, StartupCacheState)>\n     where\n         T: Send + Sync + 'static,\n     {\n-        check_db_invalidation_and_cleanup(&base_path)?;\n+        let startup_cache_state = check_db_invalidation_and_cleanup(&base_path)?;\n         let versioned_path = handle_db_versioning(&base_path, version_info, is_ci)?;\n         let database = (database)(versioned_path)?;\n-        Ok(Self {\n+        let backing_storage = Self {\n             inner: Arc::new_cyclic(\n                 move |weak_inner: &Weak<KeyValueDatabaseBackingStorageInner<T>>| {\n                     let panic_hook_guard = if should_invalidate_on_panic() {\n@@ -164,7 +182,7 @@ impl<T: KeyValueDatabase> KeyValueDatabaseBackingStorage<T> {\n                             // or turbo-tasks failed, and it may be hard to recover. We don't want\n                             // the cache to stick around, as that may persist bugs. Make a\n                             // best-effort attempt to invalidate the database (ignoring failures).\n-                            let _ = inner.invalidate();\n+                            let _ = inner.invalidate(invalidation_reasons::PANIC);\n                         })))\n                     } else {\n                         None\n@@ -177,7 +195,8 @@ impl<T: KeyValueDatabase> KeyValueDatabaseBackingStorage<T> {\n                     }\n                 },\n             ),\n-        })\n+        };\n+        Ok((backing_storage, startup_cache_state))\n     }\n }\n \n@@ -197,7 +216,7 @@ impl<T: KeyValueDatabase> KeyValueDatabaseBackingStorageInner<T> {\n         }\n     }\n \n-    fn invalidate(&self) -> Result<()> {\n+    fn invalidate(&self, reason_code: &str) -> Result<()> {\n         // `base_path` can be `None` for a `NoopKvDb`\n         if let Some(base_path) = &self.base_path {\n             // Invalidation could happen frequently if there's a bunch of panics. We only need to\n@@ -212,7 +231,7 @@ impl<T: KeyValueDatabase> KeyValueDatabaseBackingStorageInner<T> {\n             // Invalidate first, as it's a very fast atomic operation. `prevent_writes` is allowed\n             // to be slower (e.g. wait for a lock) and is allowed to corrupt the database with\n             // partial writes.\n-            invalidate_db(base_path)?;\n+            invalidate_db(base_path, reason_code)?;\n             self.database.prevent_writes();\n             // Avoid redundant invalidations from future panics\n             *invalidated_guard = true;\n@@ -232,6 +251,14 @@ impl<T: KeyValueDatabase> KeyValueDatabaseBackingStorageInner<T> {\n \n impl<T: KeyValueDatabase + Send + Sync + 'static> BackingStorage\n     for KeyValueDatabaseBackingStorage<T>\n+{\n+    fn invalidate(&self, reason_code: &str) -> Result<()> {\n+        self.inner.invalidate(reason_code)\n+    }\n+}\n+\n+impl<T: KeyValueDatabase + Send + Sync + 'static> BackingStorageSealed\n+    for KeyValueDatabaseBackingStorage<T>\n {\n     type ReadTransaction<'l> = T::ReadTransaction<'l>;\n \n@@ -567,10 +594,6 @@ impl<T: KeyValueDatabase + Send + Sync + 'static> BackingStorage\n             .with_context(|| format!(\"Looking up data for {task_id} from database failed\"))\n     }\n \n-    fn invalidate(&self) -> Result<()> {\n-        self.inner.invalidate()\n-    }\n-\n     fn shutdown(&self) -> Result<()> {\n         self.inner.database.shutdown()\n     }"
        },
        {
            "sha": "c900c3a2b86a8b4637fa385f69104453f3ec7e2a",
            "filename": "turbopack/crates/turbo-tasks-backend/src/lib.rs",
            "status": "modified",
            "additions": 32,
            "deletions": 15,
            "changes": 47,
            "blob_url": "https://github.com/vercel/next.js/blob/4a4715e76105bd962e9a02e4bbcaf14d4034b4c7/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4a4715e76105bd962e9a02e4bbcaf14d4034b4c7/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Flib.rs?ref=4a4715e76105bd962e9a02e4bbcaf14d4034b4c7",
            "patch": "@@ -18,7 +18,10 @@ use anyhow::Result;\n use crate::database::{noop_kv::NoopKvDb, turbo::TurboKeyValueDatabase};\n pub use crate::{\n     backend::{BackendOptions, StorageMode, TurboTasksBackend},\n-    database::db_versioning::GitVersionInfo,\n+    backing_storage::BackingStorage,\n+    database::{\n+        db_invalidation, db_invalidation::StartupCacheState, db_versioning::GitVersionInfo,\n+    },\n     kv_backing_storage::KeyValueDatabaseBackingStorage,\n };\n \n@@ -33,12 +36,20 @@ pub type LmdbBackingStorage = KeyValueDatabaseBackingStorage<\n     >,\n >;\n \n+/// Creates an [`lmdb`]-based `BackingStorage` to be passed to [`TurboTasksBackend::new`].\n+///\n+/// Information about the state of the on-disk cache is returned using [`StartupCacheState`].\n+///\n+/// This is backend is slower than [`turbo_backing_storage`], but it's a known-good database that\n+/// can be used when reproducing user-reported issues to isolate bugs.\n+///\n+/// When the `lmdb` cargo feature is enabled, [`default_backing_storage`] will return this value.\n #[cfg(feature = \"lmdb\")]\n pub fn lmdb_backing_storage(\n     base_path: &Path,\n     version_info: &GitVersionInfo,\n     is_ci: bool,\n-) -> Result<LmdbBackingStorage> {\n+) -> Result<(LmdbBackingStorage, StartupCacheState)> {\n     use crate::database::{\n         fresh_db_optimization::{FreshDbOptimization, is_fresh},\n         read_transaction_cache::ReadTransactionCache,\n@@ -62,11 +73,17 @@ pub fn lmdb_backing_storage(\n \n pub type TurboBackingStorage = KeyValueDatabaseBackingStorage<TurboKeyValueDatabase>;\n \n+/// Creates a `BackingStorage` to be passed to [`TurboTasksBackend::new`].\n+///\n+/// Information about the state of the on-disk cache is returned using [`StartupCacheState`].\n+///\n+/// This is the fastest most-tested implementation of `BackingStorage`, and is normally returned by\n+/// [`default_backing_storage`].\n pub fn turbo_backing_storage(\n     base_path: &Path,\n     version_info: &GitVersionInfo,\n     is_ci: bool,\n-) -> Result<TurboBackingStorage> {\n+) -> Result<(TurboBackingStorage, StartupCacheState)> {\n     KeyValueDatabaseBackingStorage::open_versioned_on_disk(\n         base_path.to_owned(),\n         version_info,\n@@ -77,30 +94,30 @@ pub fn turbo_backing_storage(\n \n pub type NoopBackingStorage = KeyValueDatabaseBackingStorage<NoopKvDb>;\n \n+/// Creates an no-op in-memory `BackingStorage` to be passed to [`TurboTasksBackend::new`].\n pub fn noop_backing_storage() -> NoopBackingStorage {\n     KeyValueDatabaseBackingStorage::new_in_memory(NoopKvDb)\n }\n \n #[cfg(feature = \"lmdb\")]\n pub type DefaultBackingStorage = LmdbBackingStorage;\n \n-#[cfg(feature = \"lmdb\")]\n-pub fn default_backing_storage(\n-    path: &Path,\n-    version_info: &GitVersionInfo,\n-    is_ci: bool,\n-) -> Result<DefaultBackingStorage> {\n-    lmdb_backing_storage(path, version_info, is_ci)\n-}\n-\n #[cfg(not(feature = \"lmdb\"))]\n pub type DefaultBackingStorage = TurboBackingStorage;\n \n-#[cfg(not(feature = \"lmdb\"))]\n+/// Calls [`turbo_backing_storage`] (recommended) or `lmdb_backing_storage`, depending on if the\n+/// `lmdb` cargo feature is enabled.\n pub fn default_backing_storage(\n     path: &Path,\n     version_info: &GitVersionInfo,\n     is_ci: bool,\n-) -> Result<DefaultBackingStorage> {\n-    turbo_backing_storage(path, version_info, is_ci)\n+) -> Result<(DefaultBackingStorage, StartupCacheState)> {\n+    #[cfg(feature = \"lmdb\")]\n+    {\n+        lmdb_backing_storage(path, version_info, is_ci)\n+    }\n+    #[cfg(not(feature = \"lmdb\"))]\n+    {\n+        turbo_backing_storage(path, version_info, is_ci)\n+    }\n }"
        },
        {
            "sha": "0d86992333cdb393e6fce9b3e3e2bdb3281ef9fc",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/test_config.trs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/4a4715e76105bd962e9a02e4bbcaf14d4034b4c7/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftest_config.trs",
            "raw_url": "https://github.com/vercel/next.js/raw/4a4715e76105bd962e9a02e4bbcaf14d4034b4c7/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftest_config.trs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftest_config.trs?ref=4a4715e76105bd962e9a02e4bbcaf14d4034b4c7",
            "patch": "@@ -17,7 +17,7 @@\n           dirty: false,\n         },\n         false\n-      ).unwrap()\n+      ).unwrap().0\n     )\n   )\n }"
        },
        {
            "sha": "0d86992333cdb393e6fce9b3e3e2bdb3281ef9fc",
            "filename": "turbopack/crates/turbo-tasks-fetch/tests/test_config.trs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/4a4715e76105bd962e9a02e4bbcaf14d4034b4c7/turbopack%2Fcrates%2Fturbo-tasks-fetch%2Ftests%2Ftest_config.trs",
            "raw_url": "https://github.com/vercel/next.js/raw/4a4715e76105bd962e9a02e4bbcaf14d4034b4c7/turbopack%2Fcrates%2Fturbo-tasks-fetch%2Ftests%2Ftest_config.trs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fetch%2Ftests%2Ftest_config.trs?ref=4a4715e76105bd962e9a02e4bbcaf14d4034b4c7",
            "patch": "@@ -17,7 +17,7 @@\n           dirty: false,\n         },\n         false\n-      ).unwrap()\n+      ).unwrap().0\n     )\n   )\n }"
        },
        {
            "sha": "72753820b679a8d004c09a421ce9191253f022cb",
            "filename": "turbopack/crates/turbopack/tests/node-file-trace.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/4a4715e76105bd962e9a02e4bbcaf14d4034b4c7/turbopack%2Fcrates%2Fturbopack%2Ftests%2Fnode-file-trace.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4a4715e76105bd962e9a02e4bbcaf14d4034b4c7/turbopack%2Fcrates%2Fturbopack%2Ftests%2Fnode-file-trace.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack%2Ftests%2Fnode-file-trace.rs?ref=4a4715e76105bd962e9a02e4bbcaf14d4034b4c7",
            "patch": "@@ -284,7 +284,8 @@ fn node_file_trace_persistent(#[case] input: CaseInput) {\n                 },\n                 false,\n             )\n-            .unwrap(),\n+            .unwrap()\n+            .0,\n         ))\n     });\n }"
        }
    ],
    "stats": {
        "total": 474,
        "additions": 352,
        "deletions": 122
    }
}