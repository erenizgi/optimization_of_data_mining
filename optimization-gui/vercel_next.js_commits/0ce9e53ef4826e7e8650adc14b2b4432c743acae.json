{
    "author": "wbinnssmith",
    "message": "Production builds: write endpoints all at once (#75304)\n\nThis implements a new napi binding, `project.writeAllEndpointsToDisk`\nwhich writes chunks for all endpoints.\n\nThis avoids iterating over each endpoint and calling individual napi\nbindings, each resulting in a call to `emit()`. While iterating entry\npoints now occurs in Rust, `OutputAssets` are collected in an `IndexSet`\nto prevent unnecessary `emit()` calls. This also significantly reduces\nunnecessary calls to the manifest loader from JS.\n\nTest Plan: CI\n\nCommit before removing merge commits:\nhttps://github.com/vercel/next.js/pull/75304/commits/189743dd261a682c5cb0a46e69f27861c612e9c2\n\n---------\n\nCo-authored-by: Tobias Koppers <tobias.koppers@googlemail.com>\nCo-authored-by: Tim Neutkens <tim@timneutkens.nl>",
    "sha": "0ce9e53ef4826e7e8650adc14b2b4432c743acae",
    "files": [
        {
            "sha": "74712fa5858932faa45247d5f9a45b6683c73271",
            "filename": "crates/napi/src/next_api/endpoint.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 32,
            "changes": 36,
            "blob_url": "https://github.com/vercel/next.js/blob/0ce9e53ef4826e7e8650adc14b2b4432c743acae/crates%2Fnapi%2Fsrc%2Fnext_api%2Fendpoint.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0ce9e53ef4826e7e8650adc14b2b4432c743acae/crates%2Fnapi%2Fsrc%2Fnext_api%2Fendpoint.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnapi%2Fsrc%2Fnext_api%2Fendpoint.rs?ref=0ce9e53ef4826e7e8650adc14b2b4432c743acae",
            "patch": "@@ -10,16 +10,12 @@ use next_api::{\n     },\n };\n use tracing::Instrument;\n-use turbo_tasks::{get_effects, Completion, Effects, OperationVc, ReadRef, Vc, VcValueType};\n-use turbopack_core::{\n-    diagnostics::PlainDiagnostic,\n-    error::PrettyPrintError,\n-    issue::{IssueSeverity, PlainIssue},\n-};\n+use turbo_tasks::{Completion, Effects, OperationVc, ReadRef, Vc};\n+use turbopack_core::{diagnostics::PlainDiagnostic, error::PrettyPrintError, issue::PlainIssue};\n \n use super::utils::{\n-    get_diagnostics, get_issues, subscribe, NapiDiagnostic, NapiIssue, RootTask, TurbopackResult,\n-    VcArc,\n+    strongly_consistent_catch_collectables, subscribe, NapiDiagnostic, NapiIssue, RootTask,\n+    TurbopackResult, VcArc,\n };\n \n #[napi(object)]\n@@ -99,30 +95,6 @@ impl Deref for ExternalEndpoint {\n     }\n }\n \n-// Await the source and return fatal issues if there are any, otherwise\n-// propagate any actual error results.\n-async fn strongly_consistent_catch_collectables<R: VcValueType + Send>(\n-    source_op: OperationVc<R>,\n-) -> Result<(\n-    Option<ReadRef<R>>,\n-    Arc<Vec<ReadRef<PlainIssue>>>,\n-    Arc<Vec<ReadRef<PlainDiagnostic>>>,\n-    Arc<Effects>,\n-)> {\n-    let result = source_op.read_strongly_consistent().await;\n-    let issues = get_issues(source_op).await?;\n-    let diagnostics = get_diagnostics(source_op).await?;\n-    let effects = Arc::new(get_effects(source_op).await?);\n-\n-    let result = if result.is_err() && issues.iter().any(|i| i.severity <= IssueSeverity::Error) {\n-        None\n-    } else {\n-        Some(result?)\n-    };\n-\n-    Ok((result, issues, diagnostics, effects))\n-}\n-\n #[turbo_tasks::value(serialization = \"none\")]\n struct WrittenEndpointWithIssues {\n     written: Option<ReadRef<EndpointOutputPaths>>,"
        },
        {
            "sha": "bcbd44e60bebcd809f0a1caa023914b6b2b0124a",
            "filename": "crates/napi/src/next_api/project.rs",
            "status": "modified",
            "additions": 153,
            "deletions": 42,
            "changes": 195,
            "blob_url": "https://github.com/vercel/next.js/blob/0ce9e53ef4826e7e8650adc14b2b4432c743acae/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0ce9e53ef4826e7e8650adc14b2b4432c743acae/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs?ref=0ce9e53ef4826e7e8650adc14b2b4432c743acae",
            "patch": "@@ -28,8 +28,8 @@ use tracing::Instrument;\n use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt, Registry};\n use turbo_rcstr::RcStr;\n use turbo_tasks::{\n-    get_effects, Completion, Effects, OperationVc, ReadRef, ResolvedVc, TransientInstance,\n-    UpdateInfo, Vc,\n+    get_effects, Completion, Effects, FxIndexSet, OperationVc, ReadRef, ResolvedVc,\n+    TransientInstance, TryJoinIterExt, UpdateInfo, Vc,\n };\n use turbo_tasks_fs::{\n     get_relative_path_to, util::uri_from_file, DiskFileSystem, FileContent, FileSystem,\n@@ -39,6 +39,7 @@ use turbopack_core::{\n     diagnostics::PlainDiagnostic,\n     error::PrettyPrintError,\n     issue::PlainIssue,\n+    output::{OutputAsset, OutputAssets},\n     source_map::{OptionSourceMap, OptionStringifiedSourceMap, SourceMap, Token},\n     version::{PartialUpdate, TotalUpdate, Update, VersionState},\n     PROJECT_FILESYSTEM_NAME, SOURCE_URL_PROTOCOL,\n@@ -549,7 +550,7 @@ pub async fn project_shutdown(\n \n #[napi(object)]\n #[derive(Default)]\n-struct AppPageNapiRoute {\n+pub struct AppPageNapiRoute {\n     /// The relative path from project_path to the route file\n     pub original_name: Option<String>,\n \n@@ -559,7 +560,7 @@ struct AppPageNapiRoute {\n \n #[napi(object)]\n #[derive(Default)]\n-struct NapiRoute {\n+pub struct NapiRoute {\n     /// The router path\n     pub pathname: String,\n     /// The relative path from project_path to the route file\n@@ -637,7 +638,7 @@ impl NapiRoute {\n }\n \n #[napi(object)]\n-struct NapiMiddleware {\n+pub struct NapiMiddleware {\n     pub endpoint: External<ExternalEndpoint>,\n }\n \n@@ -653,7 +654,7 @@ impl NapiMiddleware {\n }\n \n #[napi(object)]\n-struct NapiInstrumentation {\n+pub struct NapiInstrumentation {\n     pub node_js: External<ExternalEndpoint>,\n     pub edge: External<ExternalEndpoint>,\n }\n@@ -677,7 +678,7 @@ impl NapiInstrumentation {\n }\n \n #[napi(object)]\n-struct NapiEntrypoints {\n+pub struct NapiEntrypoints {\n     pub routes: Vec<NapiRoute>,\n     pub middleware: Option<NapiMiddleware>,\n     pub instrumentation: Option<NapiInstrumentation>,\n@@ -686,6 +687,49 @@ struct NapiEntrypoints {\n     pub pages_error_endpoint: External<ExternalEndpoint>,\n }\n \n+impl NapiEntrypoints {\n+    fn from_entrypoints_op(\n+        entrypoints: &EntrypointsOperation,\n+        turbo_tasks: &NextTurboTasks,\n+    ) -> Result<Self> {\n+        let routes = entrypoints\n+            .routes\n+            .iter()\n+            .map(|(k, v)| NapiRoute::from_route(k.to_string(), v.clone(), turbo_tasks))\n+            .collect();\n+        let middleware = entrypoints\n+            .middleware\n+            .as_ref()\n+            .map(|m| NapiMiddleware::from_middleware(m, turbo_tasks))\n+            .transpose()?;\n+        let instrumentation = entrypoints\n+            .instrumentation\n+            .as_ref()\n+            .map(|i| NapiInstrumentation::from_instrumentation(i, turbo_tasks))\n+            .transpose()?;\n+        let pages_document_endpoint = External::new(ExternalEndpoint(VcArc::new(\n+            turbo_tasks.clone(),\n+            entrypoints.pages_document_endpoint,\n+        )));\n+        let pages_app_endpoint = External::new(ExternalEndpoint(VcArc::new(\n+            turbo_tasks.clone(),\n+            entrypoints.pages_app_endpoint,\n+        )));\n+        let pages_error_endpoint = External::new(ExternalEndpoint(VcArc::new(\n+            turbo_tasks.clone(),\n+            entrypoints.pages_error_endpoint,\n+        )));\n+        Ok(NapiEntrypoints {\n+            routes,\n+            middleware,\n+            instrumentation,\n+            pages_document_endpoint,\n+            pages_app_endpoint,\n+            pages_error_endpoint,\n+        })\n+    }\n+}\n+\n #[turbo_tasks::value(serialization = \"none\")]\n struct EntrypointsWithIssues {\n     entrypoints: ReadRef<EntrypointsOperation>,\n@@ -722,6 +766,107 @@ fn project_container_entrypoints_operation(\n     container.entrypoints()\n }\n \n+#[turbo_tasks::value(serialization = \"none\")]\n+struct AllWrittenEntrypointsWithIssues {\n+    entrypoints: Option<ReadRef<Entrypoints>>,\n+    issues: Arc<Vec<ReadRef<PlainIssue>>>,\n+    diagnostics: Arc<Vec<ReadRef<PlainDiagnostic>>>,\n+    effects: Arc<Effects>,\n+}\n+\n+#[napi]\n+pub async fn project_write_all_entrypoints_to_disk(\n+    #[napi(ts_arg_type = \"{ __napiType: \\\"Project\\\" }\")] project: External<ProjectInstance>,\n+    app_dir_only: bool,\n+) -> napi::Result<TurbopackResult<NapiEntrypoints>> {\n+    let turbo_tasks = project.turbo_tasks.clone();\n+    let (entrypoints, issues, diags) = turbo_tasks\n+        .run_once(async move {\n+            let entrypoints_with_issues_op = get_all_written_entrypoints_with_issues_operation(\n+                project.container.to_resolved().await?,\n+                app_dir_only,\n+            );\n+\n+            let EntrypointsWithIssues {\n+                entrypoints,\n+                issues,\n+                diagnostics,\n+                effects,\n+            } = &*entrypoints_with_issues_op\n+                .read_strongly_consistent()\n+                .await?;\n+            effects.apply().await?;\n+\n+            Ok((entrypoints.clone(), issues.clone(), diagnostics.clone()))\n+        })\n+        .await\n+        .map_err(|e| napi::Error::from_reason(PrettyPrintError(&e).to_string()))?;\n+\n+    Ok(TurbopackResult {\n+        result: NapiEntrypoints::from_entrypoints_op(&entrypoints, &turbo_tasks)?,\n+        issues: issues.iter().map(|i| NapiIssue::from(&**i)).collect(),\n+        diagnostics: diags.iter().map(|d| NapiDiagnostic::from(d)).collect(),\n+    })\n+}\n+\n+#[turbo_tasks::function(operation)]\n+async fn get_all_written_entrypoints_with_issues_operation(\n+    container: ResolvedVc<ProjectContainer>,\n+    app_dir_only: bool,\n+) -> Result<Vc<EntrypointsWithIssues>> {\n+    let entrypoints_operation = EntrypointsOperation::new(all_entrypoints_write_to_disk_operation(\n+        container,\n+        app_dir_only,\n+    ));\n+    let entrypoints = entrypoints_operation.read_strongly_consistent().await?;\n+    let issues = get_issues(entrypoints_operation).await?;\n+    let diagnostics = get_diagnostics(entrypoints_operation).await?;\n+    let effects = Arc::new(get_effects(entrypoints_operation).await?);\n+    Ok(EntrypointsWithIssues {\n+        entrypoints,\n+        issues,\n+        diagnostics,\n+        effects,\n+    }\n+    .cell())\n+}\n+\n+#[turbo_tasks::function(operation)]\n+pub async fn all_entrypoints_write_to_disk_operation(\n+    project: ResolvedVc<ProjectContainer>,\n+    app_dir_only: bool,\n+) -> Result<Vc<Entrypoints>> {\n+    let _ = project\n+        .project()\n+        .emit_all_output_assets(output_assets_operation(project, app_dir_only))\n+        .resolve()\n+        .await?;\n+\n+    Ok(project.entrypoints())\n+}\n+\n+#[turbo_tasks::function(operation)]\n+async fn output_assets_operation(\n+    container: ResolvedVc<ProjectContainer>,\n+    app_dir_only: bool,\n+) -> Result<Vc<OutputAssets>> {\n+    let endpoint_assets = container\n+        .project()\n+        .get_all_endpoints(app_dir_only)\n+        .await?\n+        .iter()\n+        .map(|endpoint| async move { endpoint.output().await?.output_assets.await })\n+        .try_join()\n+        .await?;\n+\n+    let mut output_assets: FxIndexSet<ResolvedVc<Box<dyn OutputAsset>>> = FxIndexSet::default();\n+    for assets in endpoint_assets {\n+        output_assets.extend(assets.iter());\n+    }\n+\n+    Ok(Vc::cell(output_assets.into_iter().collect()))\n+}\n+\n #[napi(ts_return_type = \"{ __napiType: \\\"RootTask\\\" }\")]\n pub fn project_entrypoints_subscribe(\n     #[napi(ts_arg_type = \"{ __napiType: \\\"Project\\\" }\")] project: External<ProjectInstance>,\n@@ -753,41 +898,7 @@ pub fn project_entrypoints_subscribe(\n             let (entrypoints, issues, diags) = ctx.value;\n \n             Ok(vec![TurbopackResult {\n-                result: NapiEntrypoints {\n-                    routes: entrypoints\n-                        .routes\n-                        .iter()\n-                        .map(|(pathname, route)| {\n-                            NapiRoute::from_route(\n-                                pathname.clone().into(),\n-                                route.clone(),\n-                                &turbo_tasks,\n-                            )\n-                        })\n-                        .collect::<Vec<_>>(),\n-                    middleware: entrypoints\n-                        .middleware\n-                        .as_ref()\n-                        .map(|m| NapiMiddleware::from_middleware(m, &turbo_tasks))\n-                        .transpose()?,\n-                    instrumentation: entrypoints\n-                        .instrumentation\n-                        .as_ref()\n-                        .map(|m| NapiInstrumentation::from_instrumentation(m, &turbo_tasks))\n-                        .transpose()?,\n-                    pages_document_endpoint: External::new(ExternalEndpoint(VcArc::new(\n-                        turbo_tasks.clone(),\n-                        entrypoints.pages_document_endpoint,\n-                    ))),\n-                    pages_app_endpoint: External::new(ExternalEndpoint(VcArc::new(\n-                        turbo_tasks.clone(),\n-                        entrypoints.pages_app_endpoint,\n-                    ))),\n-                    pages_error_endpoint: External::new(ExternalEndpoint(VcArc::new(\n-                        turbo_tasks.clone(),\n-                        entrypoints.pages_error_endpoint,\n-                    ))),\n-                },\n+                result: NapiEntrypoints::from_entrypoints_op(&entrypoints, &turbo_tasks)?,\n                 issues: issues\n                     .iter()\n                     .map(|issue| NapiIssue::from(&**issue))"
        },
        {
            "sha": "2f66c2c7e9c1f6e7da7251494f7dafdc922be2ac",
            "filename": "crates/napi/src/next_api/utils.rs",
            "status": "modified",
            "additions": 29,
            "deletions": 3,
            "changes": 32,
            "blob_url": "https://github.com/vercel/next.js/blob/0ce9e53ef4826e7e8650adc14b2b4432c743acae/crates%2Fnapi%2Fsrc%2Fnext_api%2Futils.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0ce9e53ef4826e7e8650adc14b2b4432c743acae/crates%2Fnapi%2Fsrc%2Fnext_api%2Futils.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnapi%2Fsrc%2Fnext_api%2Futils.rs?ref=0ce9e53ef4826e7e8650adc14b2b4432c743acae",
            "patch": "@@ -9,8 +9,8 @@ use napi::{\n use rustc_hash::FxHashMap;\n use serde::Serialize;\n use turbo_tasks::{\n-    task_statistics::TaskStatisticsApi, trace::TraceRawVcs, OperationVc, ReadRef, TaskId,\n-    TryJoinIterExt, TurboTasks, TurboTasksApi, UpdateInfo, Vc,\n+    get_effects, task_statistics::TaskStatisticsApi, trace::TraceRawVcs, Effects, OperationVc,\n+    ReadRef, TaskId, TryJoinIterExt, TurboTasks, TurboTasksApi, UpdateInfo, Vc, VcValueType,\n };\n use turbo_tasks_backend::{\n     default_backing_storage, noop_backing_storage, DefaultBackingStorage, GitVersionInfo,\n@@ -20,7 +20,9 @@ use turbo_tasks_fs::FileContent;\n use turbopack_core::{\n     diagnostics::{Diagnostic, DiagnosticContextExt, PlainDiagnostic},\n     error::PrettyPrintError,\n-    issue::{IssueDescriptionExt, PlainIssue, PlainIssueSource, PlainSource, StyledString},\n+    issue::{\n+        IssueDescriptionExt, IssueSeverity, PlainIssue, PlainIssueSource, PlainSource, StyledString,\n+    },\n     source_pos::SourcePos,\n };\n \n@@ -481,3 +483,27 @@ pub fn subscribe<T: 'static + Send + Sync, F: Future<Output = Result<T>> + Send,\n         task_id: Some(task_id),\n     }))\n }\n+\n+// Await the source and return fatal issues if there are any, otherwise\n+// propagate any actual error results.\n+pub async fn strongly_consistent_catch_collectables<R: VcValueType + Send>(\n+    source_op: OperationVc<R>,\n+) -> Result<(\n+    Option<ReadRef<R>>,\n+    Arc<Vec<ReadRef<PlainIssue>>>,\n+    Arc<Vec<ReadRef<PlainDiagnostic>>>,\n+    Arc<Effects>,\n+)> {\n+    let result = source_op.read_strongly_consistent().await;\n+    let issues = get_issues(source_op).await?;\n+    let diagnostics = get_diagnostics(source_op).await?;\n+    let effects = Arc::new(get_effects(source_op).await?);\n+\n+    let result = if result.is_err() && issues.iter().any(|i| i.severity <= IssueSeverity::Error) {\n+        None\n+    } else {\n+        Some(result?)\n+    };\n+\n+    Ok((result, issues, diagnostics, effects))\n+}"
        },
        {
            "sha": "db04f0928a696f5d1a8457f2931f21fef511d46f",
            "filename": "crates/next-api/src/operation.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 7,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/0ce9e53ef4826e7e8650adc14b2b4432c743acae/crates%2Fnext-api%2Fsrc%2Foperation.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0ce9e53ef4826e7e8650adc14b2b4432c743acae/crates%2Fnext-api%2Fsrc%2Foperation.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Foperation.rs?ref=0ce9e53ef4826e7e8650adc14b2b4432c743acae",
            "patch": "@@ -30,19 +30,13 @@ pub struct EntrypointsOperation {\n     pub pages_error_endpoint: OperationVc<Box<dyn Endpoint>>,\n }\n \n-/// HACK: Wraps an `OperationVc<Entrypoints>` inside of a second `OperationVc`.\n-#[turbo_tasks::function(operation)]\n-fn entrypoints_wrapper(entrypoints: OperationVc<Entrypoints>) -> Vc<Entrypoints> {\n-    entrypoints.connect()\n-}\n-\n /// Removes diagnostics, issues, and effects from the top-level `entrypoints` operation so that\n /// they're not duplicated across many different individual entrypoints or routes.\n #[turbo_tasks::function(operation)]\n async fn entrypoints_without_collectibles_operation(\n     entrypoints: OperationVc<Entrypoints>,\n ) -> Result<Vc<Entrypoints>> {\n-    let entrypoints = entrypoints_wrapper(entrypoints);\n+    let _ = entrypoints.resolve_strongly_consistent().await?;\n     let _ = entrypoints.take_collectibles::<Box<dyn Diagnostic>>();\n     let _ = entrypoints.take_issues_with_path().await?;\n     let _ = get_effects(entrypoints).await?;"
        },
        {
            "sha": "06a607c0ec186f0e63219222529f622d4b990c87",
            "filename": "crates/next-api/src/project.rs",
            "status": "modified",
            "additions": 11,
            "deletions": 5,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/0ce9e53ef4826e7e8650adc14b2b4432c743acae/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0ce9e53ef4826e7e8650adc14b2b4432c743acae/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fproject.rs?ref=0ce9e53ef4826e7e8650adc14b2b4432c743acae",
            "patch": "@@ -791,11 +791,13 @@ impl Project {\n     }\n \n     #[turbo_tasks::function]\n-    pub async fn get_all_endpoints(self: Vc<Self>) -> Result<Vc<Endpoints>> {\n+    pub async fn get_all_endpoints(self: Vc<Self>, app_dir_only: bool) -> Result<Vc<Endpoints>> {\n         let mut endpoints = Vec::new();\n \n         let entrypoints = self.entrypoints().await?;\n \n+        // Always include these basic pages endpoints regardless of `app_dir_only`. The user's\n+        // page routes themselves are excluded below.\n         endpoints.push(entrypoints.pages_error_endpoint);\n         endpoints.push(entrypoints.pages_app_endpoint);\n         endpoints.push(entrypoints.pages_document_endpoint);\n@@ -815,10 +817,14 @@ impl Project {\n                     html_endpoint,\n                     data_endpoint: _,\n                 } => {\n-                    endpoints.push(*html_endpoint);\n+                    if !app_dir_only {\n+                        endpoints.push(*html_endpoint);\n+                    }\n                 }\n                 Route::PageApi { endpoint } => {\n-                    endpoints.push(*endpoint);\n+                    if !app_dir_only {\n+                        endpoints.push(*endpoint);\n+                    }\n                 }\n                 Route::AppPage(page_routes) => {\n                     for AppPageRoute {\n@@ -848,7 +854,7 @@ impl Project {\n     #[turbo_tasks::function]\n     pub async fn get_all_entries(self: Vc<Self>) -> Result<Vc<GraphEntries>> {\n         let mut modules = self\n-            .get_all_endpoints()\n+            .get_all_endpoints(false)\n             .await?\n             .iter()\n             .map(async |endpoint| Ok(endpoint.entries().owned().await?))\n@@ -864,7 +870,7 @@ impl Project {\n         graphs: Vc<ModuleGraph>,\n     ) -> Result<Vc<GraphEntries>> {\n         let modules = self\n-            .get_all_endpoints()\n+            .get_all_endpoints(false)\n             .await?\n             .iter()\n             .map(async |endpoint| Ok(endpoint.additional_entries(graphs).owned().await?))"
        },
        {
            "sha": "250784d1081190365f5818ee41d6fdd6d7c77ace",
            "filename": "packages/next/src/build/handle-entrypoints.ts",
            "status": "modified",
            "additions": 35,
            "deletions": 230,
            "changes": 265,
            "blob_url": "https://github.com/vercel/next.js/blob/0ce9e53ef4826e7e8650adc14b2b4432c743acae/packages%2Fnext%2Fsrc%2Fbuild%2Fhandle-entrypoints.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/0ce9e53ef4826e7e8650adc14b2b4432c743acae/packages%2Fnext%2Fsrc%2Fbuild%2Fhandle-entrypoints.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fhandle-entrypoints.ts?ref=0ce9e53ef4826e7e8650adc14b2b4432c743acae",
            "patch": "@@ -1,60 +1,36 @@\n-import type { CustomRoutes } from '../lib/load-custom-routes'\n import type { TurbopackManifestLoader } from '../shared/lib/turbopack/manifest-loader'\n import type {\n-  TurbopackResult,\n-  RawEntrypoints,\n   Entrypoints,\n   PageRoute,\n   AppRoute,\n+  RawEntrypoints,\n } from './swc/types'\n-import * as Log from './output/log'\n import { getEntryKey } from '../shared/lib/turbopack/entry-key'\n-import {\n-  processIssues,\n-  type EntryIssuesMap,\n-} from '../shared/lib/turbopack/utils'\n-\n-export async function handleEntrypoints({\n-  entrypoints,\n-  currentEntrypoints,\n-  currentEntryIssues,\n-  manifestLoader,\n-  productionRewrites,\n-  logErrors,\n-}: {\n-  entrypoints: TurbopackResult<RawEntrypoints>\n-  currentEntrypoints: Entrypoints\n-  currentEntryIssues: EntryIssuesMap\n-  manifestLoader: TurbopackManifestLoader\n-  productionRewrites: CustomRoutes['rewrites'] | undefined\n-  logErrors: boolean\n-}) {\n-  currentEntrypoints.global.app = entrypoints.pagesAppEndpoint\n-  currentEntrypoints.global.document = entrypoints.pagesDocumentEndpoint\n-  currentEntrypoints.global.error = entrypoints.pagesErrorEndpoint\n-\n-  currentEntrypoints.global.instrumentation = entrypoints.instrumentation\n+import * as Log from './output/log'\n \n-  currentEntrypoints.page.clear()\n-  currentEntrypoints.app.clear()\n+export async function rawEntrypointsToEntrypoints(\n+  entrypointsOp: RawEntrypoints\n+): Promise<Entrypoints> {\n+  const page = new Map()\n+  const app = new Map()\n \n-  for (const [pathname, route] of entrypoints.routes) {\n+  for (const [pathname, route] of entrypointsOp.routes) {\n     switch (route.type) {\n       case 'page':\n       case 'page-api':\n-        currentEntrypoints.page.set(pathname, route)\n+        page.set(pathname, route)\n         break\n       case 'app-page': {\n-        route.pages.forEach((page) => {\n-          currentEntrypoints.app.set(page.originalName, {\n+        for (const p of route.pages) {\n+          app.set(p.originalName, {\n             type: 'app-page',\n-            ...page,\n+            ...p,\n           })\n-        })\n+        }\n         break\n       }\n       case 'app-route': {\n-        currentEntrypoints.app.set(route.originalName, route)\n+        app.set(route.originalName, route)\n         break\n       }\n       default:\n@@ -63,225 +39,70 @@ export async function handleEntrypoints({\n     }\n   }\n \n-  const { middleware, instrumentation } = entrypoints\n-\n-  // We check for explicit true/false, since it's initialized to\n-  // undefined during the first loop (middlewareChanges event is\n-  // unnecessary during the first serve)\n-  if (currentEntrypoints.global.middleware && !middleware) {\n-    const key = getEntryKey('root', 'server', 'middleware')\n-    // Went from middleware to no middleware\n-    currentEntryIssues.delete(key)\n-  }\n-\n-  currentEntrypoints.global.middleware = middleware\n-\n-  if (instrumentation) {\n-    const processInstrumentation = async (\n-      name: string,\n-      prop: 'nodeJs' | 'edge'\n-    ) => {\n-      const key = getEntryKey('root', 'server', name)\n-\n-      const writtenEndpoint = await instrumentation[prop].writeToDisk()\n-      processIssues(currentEntryIssues, key, writtenEndpoint, false, logErrors)\n-    }\n-    await processInstrumentation('instrumentation.nodeJs', 'nodeJs')\n-    await processInstrumentation('instrumentation.edge', 'edge')\n-    await manifestLoader.loadMiddlewareManifest(\n-      'instrumentation',\n-      'instrumentation'\n-    )\n-    await manifestLoader.writeManifests({\n-      devRewrites: undefined,\n-      productionRewrites,\n-      entrypoints: currentEntrypoints,\n-    })\n-  }\n-\n-  if (middleware) {\n-    const key = getEntryKey('root', 'server', 'middleware')\n-\n-    const endpoint = middleware.endpoint\n-\n-    async function processMiddleware() {\n-      const writtenEndpoint = await endpoint.writeToDisk()\n-      processIssues(currentEntryIssues, key, writtenEndpoint, false, logErrors)\n-      await manifestLoader.loadMiddlewareManifest('middleware', 'middleware')\n-    }\n-    await processMiddleware()\n-  } else {\n-    manifestLoader.deleteMiddlewareManifest(\n-      getEntryKey('root', 'server', 'middleware')\n-    )\n+  return {\n+    global: {\n+      app: entrypointsOp.pagesAppEndpoint,\n+      document: entrypointsOp.pagesDocumentEndpoint,\n+      error: entrypointsOp.pagesErrorEndpoint,\n+      instrumentation: entrypointsOp.instrumentation,\n+      middleware: entrypointsOp.middleware,\n+    },\n+    page,\n+    app,\n   }\n }\n \n-export async function handlePagesErrorRoute({\n-  currentEntryIssues,\n-  entrypoints,\n-  manifestLoader,\n-  productionRewrites,\n-  logErrors,\n-}: {\n-  currentEntryIssues: EntryIssuesMap\n-  entrypoints: Entrypoints\n-  manifestLoader: TurbopackManifestLoader\n-  productionRewrites: CustomRoutes['rewrites'] | undefined\n-  logErrors: boolean\n-}) {\n-  if (entrypoints.global.app) {\n-    const key = getEntryKey('pages', 'server', '_app')\n-    const writtenEndpoint = await entrypoints.global.app.writeToDisk()\n-    processIssues(currentEntryIssues, key, writtenEndpoint, false, logErrors)\n-  }\n-  await manifestLoader.loadBuildManifest('_app')\n-  await manifestLoader.loadPagesManifest('_app')\n-  await manifestLoader.loadFontManifest('_app')\n-\n-  if (entrypoints.global.document) {\n-    const key = getEntryKey('pages', 'server', '_document')\n-    const writtenEndpoint = await entrypoints.global.document.writeToDisk()\n-    processIssues(currentEntryIssues, key, writtenEndpoint, false, logErrors)\n-  }\n-  await manifestLoader.loadPagesManifest('_document')\n-\n-  if (entrypoints.global.error) {\n-    const key = getEntryKey('pages', 'server', '_error')\n-    const writtenEndpoint = await entrypoints.global.error.writeToDisk()\n-    processIssues(currentEntryIssues, key, writtenEndpoint, false, logErrors)\n-  }\n-\n-  await manifestLoader.loadBuildManifest('_error')\n-  await manifestLoader.loadPagesManifest('_error')\n-  await manifestLoader.loadFontManifest('_error')\n-\n-  await manifestLoader.writeManifests({\n-    devRewrites: undefined,\n-    productionRewrites,\n-    entrypoints,\n-  })\n-}\n-\n export async function handleRouteType({\n   page,\n   route,\n-  currentEntryIssues,\n-  entrypoints,\n   manifestLoader,\n-  productionRewrites,\n-  logErrors,\n }: {\n   page: string\n   route: PageRoute | AppRoute\n-\n-  currentEntryIssues: EntryIssuesMap\n-  entrypoints: Entrypoints\n   manifestLoader: TurbopackManifestLoader\n-  productionRewrites: CustomRoutes['rewrites'] | undefined\n-  logErrors: boolean\n }) {\n   const shouldCreateWebpackStats = process.env.TURBOPACK_STATS != null\n \n   switch (route.type) {\n     case 'page': {\n       const serverKey = getEntryKey('pages', 'server', page)\n \n-      if (entrypoints.global.app) {\n-        const key = getEntryKey('pages', 'server', '_app')\n-\n-        const writtenEndpoint = await entrypoints.global.app.writeToDisk()\n-        processIssues(\n-          currentEntryIssues,\n-          key,\n-          writtenEndpoint,\n-          false,\n-          logErrors\n-        )\n-      }\n-      await manifestLoader.loadBuildManifest('_app')\n-      await manifestLoader.loadPagesManifest('_app')\n-\n-      if (entrypoints.global.document) {\n-        const key = getEntryKey('pages', 'server', '_document')\n-\n-        const writtenEndpoint = await entrypoints.global.document.writeToDisk()\n-        processIssues(\n-          currentEntryIssues,\n-          key,\n-          writtenEndpoint,\n-          false,\n-          logErrors\n-        )\n-      }\n-      await manifestLoader.loadPagesManifest('_document')\n-\n-      const writtenEndpoint = await route.htmlEndpoint.writeToDisk()\n-\n-      const type = writtenEndpoint?.type\n-\n       await manifestLoader.loadBuildManifest(page)\n       await manifestLoader.loadPagesManifest(page)\n-      if (type === 'edge') {\n+\n+      const middlewareManifestWritten =\n         await manifestLoader.loadMiddlewareManifest(page, 'pages')\n-      } else {\n+      if (!middlewareManifestWritten) {\n         manifestLoader.deleteMiddlewareManifest(serverKey)\n       }\n+\n       await manifestLoader.loadFontManifest('/_app', 'pages')\n       await manifestLoader.loadFontManifest(page, 'pages')\n \n       if (shouldCreateWebpackStats) {\n         await manifestLoader.loadWebpackStats(page, 'pages')\n       }\n \n-      await manifestLoader.writeManifests({\n-        devRewrites: undefined,\n-        productionRewrites,\n-        entrypoints,\n-      })\n-\n-      processIssues(\n-        currentEntryIssues,\n-        serverKey,\n-        writtenEndpoint,\n-        false,\n-        logErrors\n-      )\n-\n       break\n     }\n     case 'page-api': {\n       const key = getEntryKey('pages', 'server', page)\n \n-      const writtenEndpoint = await route.endpoint.writeToDisk()\n-\n-      const type = writtenEndpoint.type\n-\n       await manifestLoader.loadPagesManifest(page)\n-      if (type === 'edge') {\n+      const middlewareManifestWritten =\n         await manifestLoader.loadMiddlewareManifest(page, 'pages')\n-      } else {\n+      if (!middlewareManifestWritten) {\n         manifestLoader.deleteMiddlewareManifest(key)\n       }\n \n-      await manifestLoader.writeManifests({\n-        devRewrites: undefined,\n-        productionRewrites,\n-        entrypoints,\n-      })\n-\n-      processIssues(currentEntryIssues, key, writtenEndpoint, true, logErrors)\n-\n       break\n     }\n     case 'app-page': {\n       const key = getEntryKey('app', 'server', page)\n-      const writtenEndpoint = await route.htmlEndpoint.writeToDisk()\n-      const type = writtenEndpoint.type\n \n-      if (type === 'edge') {\n+      const middlewareManifestWritten =\n         await manifestLoader.loadMiddlewareManifest(page, 'app')\n-      } else {\n+      if (!middlewareManifestWritten) {\n         manifestLoader.deleteMiddlewareManifest(key)\n       }\n \n@@ -295,36 +116,20 @@ export async function handleRouteType({\n         await manifestLoader.loadWebpackStats(page, 'app')\n       }\n \n-      await manifestLoader.writeManifests({\n-        devRewrites: undefined,\n-        productionRewrites,\n-        entrypoints,\n-      })\n-\n-      processIssues(currentEntryIssues, key, writtenEndpoint, false, logErrors)\n-\n       break\n     }\n     case 'app-route': {\n       const key = getEntryKey('app', 'server', page)\n-      const writtenEndpoint = await route.endpoint.writeToDisk()\n-      const type = writtenEndpoint.type\n \n       await manifestLoader.loadAppPathsManifest(page)\n \n-      if (type === 'edge') {\n+      const middlewareManifestWritten =\n         await manifestLoader.loadMiddlewareManifest(page, 'app')\n-      } else {\n+\n+      if (!middlewareManifestWritten) {\n         manifestLoader.deleteMiddlewareManifest(key)\n       }\n \n-      await manifestLoader.writeManifests({\n-        devRewrites: undefined,\n-        productionRewrites,\n-        entrypoints,\n-      })\n-      processIssues(currentEntryIssues, key, writtenEndpoint, true, logErrors)\n-\n       break\n     }\n     default: {"
        },
        {
            "sha": "868414ce74b47d1cfe9f65b93e722a6ce163fd7d",
            "filename": "packages/next/src/build/swc/generated-native.d.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/0ce9e53ef4826e7e8650adc14b2b4432c743acae/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Fgenerated-native.d.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/0ce9e53ef4826e7e8650adc14b2b4432c743acae/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Fgenerated-native.d.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Fgenerated-native.d.ts?ref=0ce9e53ef4826e7e8650adc14b2b4432c743acae",
            "patch": "@@ -254,6 +254,10 @@ export interface NapiEntrypoints {\n   pagesAppEndpoint: ExternalObject<ExternalEndpoint>\n   pagesErrorEndpoint: ExternalObject<ExternalEndpoint>\n }\n+export declare function projectWriteAllEntrypointsToDisk(\n+  project: { __napiType: 'Project' },\n+  appDirOnly: boolean\n+): Promise<TurbopackResult>\n export declare function projectEntrypointsSubscribe(\n   project: { __napiType: 'Project' },\n   func: (...args: any[]) => any"
        },
        {
            "sha": "a6e476d44dbf17d07de39cda4eedb3d1e944be0a",
            "filename": "packages/next/src/build/swc/index.ts",
            "status": "modified",
            "additions": 150,
            "deletions": 131,
            "changes": 281,
            "blob_url": "https://github.com/vercel/next.js/blob/0ce9e53ef4826e7e8650adc14b2b4432c743acae/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Findex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/0ce9e53ef4826e7e8650adc14b2b4432c743acae/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Findex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Findex.ts?ref=0ce9e53ef4826e7e8650adc14b2b4432c743acae",
            "patch": "@@ -32,6 +32,7 @@ import type {\n   HmrIdentifiers,\n   Project,\n   ProjectOptions,\n+  RawEntrypoints,\n   Route,\n   TurboEngineOptions,\n   TurbopackResult,\n@@ -440,6 +441,58 @@ function bindingToApi(\n     callback: (err: Error, value: T) => void\n   ) => Promise<{ __napiType: 'RootTask' }>\n \n+  type NapiEndpoint = { __napiType: 'Endpoint' }\n+\n+  type NapiEntrypoints = {\n+    routes: NapiRoute[]\n+    middleware?: NapiMiddleware\n+    instrumentation?: NapiInstrumentation\n+    pagesDocumentEndpoint: NapiEndpoint\n+    pagesAppEndpoint: NapiEndpoint\n+    pagesErrorEndpoint: NapiEndpoint\n+  }\n+\n+  type NapiMiddleware = {\n+    endpoint: NapiEndpoint\n+    runtime: 'nodejs' | 'edge'\n+    matcher?: string[]\n+  }\n+\n+  type NapiInstrumentation = {\n+    nodeJs: NapiEndpoint\n+    edge: NapiEndpoint\n+  }\n+\n+  type NapiRoute = {\n+    pathname: string\n+  } & (\n+    | {\n+        type: 'page'\n+        htmlEndpoint: NapiEndpoint\n+        dataEndpoint: NapiEndpoint\n+      }\n+    | {\n+        type: 'page-api'\n+        endpoint: NapiEndpoint\n+      }\n+    | {\n+        type: 'app-page'\n+        pages: {\n+          originalName: string\n+          htmlEndpoint: NapiEndpoint\n+          rscEndpoint: NapiEndpoint\n+        }[]\n+      }\n+    | {\n+        type: 'app-route'\n+        originalName: string\n+        endpoint: NapiEndpoint\n+      }\n+    | {\n+        type: 'conflict'\n+      }\n+  )\n+\n   const cancel = new (class Cancel extends Error {})()\n \n   /**\n@@ -586,146 +639,28 @@ function bindingToApi(\n       )\n     }\n \n-    entrypointsSubscribe() {\n-      type NapiEndpoint = { __napiType: 'Endpoint' }\n-\n-      type NapiEntrypoints = {\n-        routes: NapiRoute[]\n-        middleware?: NapiMiddleware\n-        instrumentation?: NapiInstrumentation\n-        pagesDocumentEndpoint: NapiEndpoint\n-        pagesAppEndpoint: NapiEndpoint\n-        pagesErrorEndpoint: NapiEndpoint\n-      }\n-\n-      type NapiMiddleware = {\n-        endpoint: NapiEndpoint\n-        runtime: 'nodejs' | 'edge'\n-        matcher?: string[]\n-      }\n-\n-      type NapiInstrumentation = {\n-        nodeJs: NapiEndpoint\n-        edge: NapiEndpoint\n-      }\n+    async writeAllEntrypointsToDisk(\n+      appDirOnly: boolean\n+    ): Promise<TurbopackResult<RawEntrypoints>> {\n+      return await withErrorCause(async () => {\n+        const napiEndpoints = (await binding.projectWriteAllEntrypointsToDisk(\n+          this._nativeProject,\n+          appDirOnly\n+        )) as TurbopackResult<NapiEntrypoints>\n \n-      type NapiRoute = {\n-        pathname: string\n-      } & (\n-        | {\n-            type: 'page'\n-            htmlEndpoint: NapiEndpoint\n-            dataEndpoint: NapiEndpoint\n-          }\n-        | {\n-            type: 'page-api'\n-            endpoint: NapiEndpoint\n-          }\n-        | {\n-            type: 'app-page'\n-            pages: {\n-              originalName: string\n-              htmlEndpoint: NapiEndpoint\n-              rscEndpoint: NapiEndpoint\n-            }[]\n-          }\n-        | {\n-            type: 'app-route'\n-            originalName: string\n-            endpoint: NapiEndpoint\n-          }\n-        | {\n-            type: 'conflict'\n-          }\n-      )\n+        return napiEntrypointsToRawEntrypoints(napiEndpoints)\n+      })\n+    }\n \n+    entrypointsSubscribe() {\n       const subscription = subscribe<TurbopackResult<NapiEntrypoints>>(\n         false,\n         async (callback) =>\n           binding.projectEntrypointsSubscribe(this._nativeProject, callback)\n       )\n       return (async function* () {\n         for await (const entrypoints of subscription) {\n-          const routes = new Map()\n-          for (const { pathname, ...nativeRoute } of entrypoints.routes) {\n-            let route: Route\n-            const routeType = nativeRoute.type\n-            switch (routeType) {\n-              case 'page':\n-                route = {\n-                  type: 'page',\n-                  htmlEndpoint: new EndpointImpl(nativeRoute.htmlEndpoint),\n-                  dataEndpoint: new EndpointImpl(nativeRoute.dataEndpoint),\n-                }\n-                break\n-              case 'page-api':\n-                route = {\n-                  type: 'page-api',\n-                  endpoint: new EndpointImpl(nativeRoute.endpoint),\n-                }\n-                break\n-              case 'app-page':\n-                route = {\n-                  type: 'app-page',\n-                  pages: nativeRoute.pages.map((page) => ({\n-                    originalName: page.originalName,\n-                    htmlEndpoint: new EndpointImpl(page.htmlEndpoint),\n-                    rscEndpoint: new EndpointImpl(page.rscEndpoint),\n-                  })),\n-                }\n-                break\n-              case 'app-route':\n-                route = {\n-                  type: 'app-route',\n-                  originalName: nativeRoute.originalName,\n-                  endpoint: new EndpointImpl(nativeRoute.endpoint),\n-                }\n-                break\n-              case 'conflict':\n-                route = {\n-                  type: 'conflict',\n-                }\n-                break\n-              default:\n-                const _exhaustiveCheck: never = routeType\n-                invariant(\n-                  nativeRoute,\n-                  () => `Unknown route type: ${_exhaustiveCheck}`\n-                )\n-            }\n-            routes.set(pathname, route)\n-          }\n-          const napiMiddlewareToMiddleware = (middleware: NapiMiddleware) => ({\n-            endpoint: new EndpointImpl(middleware.endpoint),\n-            runtime: middleware.runtime,\n-            matcher: middleware.matcher,\n-          })\n-          const middleware = entrypoints.middleware\n-            ? napiMiddlewareToMiddleware(entrypoints.middleware)\n-            : undefined\n-          const napiInstrumentationToInstrumentation = (\n-            instrumentation: NapiInstrumentation\n-          ) => ({\n-            nodeJs: new EndpointImpl(instrumentation.nodeJs),\n-            edge: new EndpointImpl(instrumentation.edge),\n-          })\n-          const instrumentation = entrypoints.instrumentation\n-            ? napiInstrumentationToInstrumentation(entrypoints.instrumentation)\n-            : undefined\n-          yield {\n-            routes,\n-            middleware,\n-            instrumentation,\n-            pagesDocumentEndpoint: new EndpointImpl(\n-              entrypoints.pagesDocumentEndpoint\n-            ),\n-            pagesAppEndpoint: new EndpointImpl(entrypoints.pagesAppEndpoint),\n-            pagesErrorEndpoint: new EndpointImpl(\n-              entrypoints.pagesErrorEndpoint\n-            ),\n-            issues: entrypoints.issues,\n-            diagnostics: entrypoints.diagnostics,\n-          }\n+          yield napiEntrypointsToRawEntrypoints(entrypoints)\n         }\n       })()\n     }\n@@ -981,6 +916,90 @@ function bindingToApi(\n     }\n   }\n \n+  function napiEntrypointsToRawEntrypoints(\n+    entrypoints: TurbopackResult<NapiEntrypoints>\n+  ): TurbopackResult<RawEntrypoints> {\n+    const routes = new Map()\n+    for (const { pathname, ...nativeRoute } of entrypoints.routes) {\n+      let route: Route\n+      const routeType = nativeRoute.type\n+      switch (routeType) {\n+        case 'page':\n+          route = {\n+            type: 'page',\n+            htmlEndpoint: new EndpointImpl(nativeRoute.htmlEndpoint),\n+            dataEndpoint: new EndpointImpl(nativeRoute.dataEndpoint),\n+          }\n+          break\n+        case 'page-api':\n+          route = {\n+            type: 'page-api',\n+            endpoint: new EndpointImpl(nativeRoute.endpoint),\n+          }\n+          break\n+        case 'app-page':\n+          route = {\n+            type: 'app-page',\n+            pages: nativeRoute.pages.map((page) => ({\n+              originalName: page.originalName,\n+              htmlEndpoint: new EndpointImpl(page.htmlEndpoint),\n+              rscEndpoint: new EndpointImpl(page.rscEndpoint),\n+            })),\n+          }\n+          break\n+        case 'app-route':\n+          route = {\n+            type: 'app-route',\n+            originalName: nativeRoute.originalName,\n+            endpoint: new EndpointImpl(nativeRoute.endpoint),\n+          }\n+          break\n+        case 'conflict':\n+          route = {\n+            type: 'conflict',\n+          }\n+          break\n+        default:\n+          const _exhaustiveCheck: never = routeType\n+          invariant(\n+            nativeRoute,\n+            () => `Unknown route type: ${_exhaustiveCheck}`\n+          )\n+      }\n+      routes.set(pathname, route)\n+    }\n+    const napiMiddlewareToMiddleware = (middleware: NapiMiddleware) => ({\n+      endpoint: new EndpointImpl(middleware.endpoint),\n+      runtime: middleware.runtime,\n+      matcher: middleware.matcher,\n+    })\n+    const middleware = entrypoints.middleware\n+      ? napiMiddlewareToMiddleware(entrypoints.middleware)\n+      : undefined\n+    const napiInstrumentationToInstrumentation = (\n+      instrumentation: NapiInstrumentation\n+    ) => ({\n+      nodeJs: new EndpointImpl(instrumentation.nodeJs),\n+      edge: new EndpointImpl(instrumentation.edge),\n+    })\n+    const instrumentation = entrypoints.instrumentation\n+      ? napiInstrumentationToInstrumentation(entrypoints.instrumentation)\n+      : undefined\n+\n+    return {\n+      routes,\n+      middleware,\n+      instrumentation,\n+      pagesDocumentEndpoint: new EndpointImpl(\n+        entrypoints.pagesDocumentEndpoint\n+      ),\n+      pagesAppEndpoint: new EndpointImpl(entrypoints.pagesAppEndpoint),\n+      pagesErrorEndpoint: new EndpointImpl(entrypoints.pagesErrorEndpoint),\n+      issues: entrypoints.issues,\n+      diagnostics: entrypoints.diagnostics,\n+    }\n+  }\n+\n   return async function createProject(\n     options: ProjectOptions,\n     turboEngineOptions"
        },
        {
            "sha": "c0accfbe57d2337c82c22e4b9e00e5f7daf7d845",
            "filename": "packages/next/src/build/swc/types.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/0ce9e53ef4826e7e8650adc14b2b4432c743acae/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Ftypes.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/0ce9e53ef4826e7e8650adc14b2b4432c743acae/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Ftypes.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Ftypes.ts?ref=0ce9e53ef4826e7e8650adc14b2b4432c743acae",
            "patch": "@@ -186,6 +186,10 @@ export interface UpdateInfo {\n export interface Project {\n   update(options: Partial<ProjectOptions>): Promise<void>\n \n+  writeAllEntrypointsToDisk(\n+    appDirOnly: boolean\n+  ): Promise<TurbopackResult<RawEntrypoints>>\n+\n   entrypointsSubscribe(): AsyncIterableIterator<TurbopackResult<RawEntrypoints>>\n \n   hmrEvents(identifier: string): AsyncIterableIterator<TurbopackResult<Update>>"
        },
        {
            "sha": "8e23a9341d91c0e9b693f4b746330716c2ca8103",
            "filename": "packages/next/src/build/turbopack-build/impl.ts",
            "status": "modified",
            "additions": 37,
            "deletions": 140,
            "changes": 177,
            "blob_url": "https://github.com/vercel/next.js/blob/0ce9e53ef4826e7e8650adc14b2b4432c743acae/packages%2Fnext%2Fsrc%2Fbuild%2Fturbopack-build%2Fimpl.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/0ce9e53ef4826e7e8650adc14b2b4432c743acae/packages%2Fnext%2Fsrc%2Fbuild%2Fturbopack-build%2Fimpl.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fturbopack-build%2Fimpl.ts?ref=0ce9e53ef4826e7e8650adc14b2b4432c743acae",
            "patch": "@@ -5,20 +5,14 @@ import {\n   getTurbopackJsConfig,\n   isPersistentCachingEnabled,\n   isRelevantWarning,\n-  type EntryIssuesMap,\n } from '../../shared/lib/turbopack/utils'\n import { NextBuildContext } from '../build-context'\n import { createDefineEnv, loadBindings } from '../swc'\n-import { Sema } from 'next/dist/compiled/async-sema'\n import {\n-  handleEntrypoints,\n-  handlePagesErrorRoute,\n+  rawEntrypointsToEntrypoints,\n   handleRouteType,\n } from '../handle-entrypoints'\n-import type { Entrypoints } from '../swc/types'\n import { TurbopackManifestLoader } from '../../shared/lib/turbopack/manifest-loader'\n-import { createProgress } from '../progress'\n-import * as Log from '../output/log'\n import { promises as fs } from 'fs'\n import { PHASE_PRODUCTION_BUILD } from '../../shared/lib/constants'\n import loadConfig from '../../server/config'\n@@ -116,190 +110,93 @@ export async function turbopackBuild(): Promise<{\n   )\n \n   // eslint-disable-next-line @typescript-eslint/no-unused-vars\n-  const entrypointsSubscription = project.entrypointsSubscribe()\n-  const currentEntrypoints: Entrypoints = {\n-    global: {\n-      app: undefined,\n-      document: undefined,\n-      error: undefined,\n-\n-      middleware: undefined,\n-      instrumentation: undefined,\n-    },\n-\n-    app: new Map(),\n-    page: new Map(),\n-  }\n-\n-  const currentEntryIssues: EntryIssuesMap = new Map()\n+  const entrypoints = await project.writeAllEntrypointsToDisk(appDirOnly)\n \n   const manifestLoader = new TurbopackManifestLoader({\n     buildId,\n     distDir,\n     encryptionKey,\n   })\n \n-  const entrypointsResult = await entrypointsSubscription.next()\n-  if (entrypointsResult.done) {\n-    throw new Error('Turbopack did not return any entrypoints')\n+  const topLevelErrors = []\n+  const topLevelWarnings = []\n+  for (const issue of entrypoints.issues) {\n+    if (issue.severity === 'error' || issue.severity === 'fatal') {\n+      topLevelErrors.push(formatIssue(issue))\n+    } else if (isRelevantWarning(issue)) {\n+      topLevelWarnings.push(formatIssue(issue))\n+    }\n   }\n-  entrypointsSubscription.return?.().catch(() => {})\n \n-  const entrypoints = entrypointsResult.value\n-\n-  const topLevelErrors: {\n-    message: string\n-  }[] = []\n-  for (const issue of entrypoints.issues) {\n-    topLevelErrors.push({\n-      message: formatIssue(issue),\n-    })\n+  if (topLevelWarnings.length > 0) {\n+    console.warn(\n+      `Turbopack build encountered ${\n+        topLevelWarnings.length\n+      } warnings:\\n${topLevelWarnings.join('\\n')}`\n+    )\n   }\n \n   if (topLevelErrors.length > 0) {\n     throw new Error(\n       `Turbopack build failed with ${\n         topLevelErrors.length\n-      } issues:\\n${topLevelErrors.map((e) => e.message).join('\\n')}`\n+      } errors:\\n${topLevelErrors.join('\\n')}`\n     )\n   }\n \n-  await handleEntrypoints({\n-    entrypoints,\n-    currentEntrypoints,\n-    currentEntryIssues,\n-    manifestLoader,\n-    productionRewrites: rewrites,\n-    logErrors: false,\n-  })\n+  const currentEntrypoints = await rawEntrypointsToEntrypoints(entrypoints)\n \n-  const progress = createProgress(\n-    currentEntrypoints.page.size + currentEntrypoints.app.size + 1,\n-    'Building'\n-  )\n   const promises: Promise<any>[] = []\n \n-  // Concurrency will start at INITIAL_CONCURRENCY and\n-  // slowly ramp up to CONCURRENCY by increasing the\n-  // concurrency by 1 every time a task is completed.\n-  const INITIAL_CONCURRENCY = 5\n-  const CONCURRENCY = 10\n-\n-  const sema = new Sema(INITIAL_CONCURRENCY)\n-  let remainingRampup = CONCURRENCY - INITIAL_CONCURRENCY\n-  const enqueue = (fn: () => Promise<void>) => {\n-    promises.push(\n-      (async () => {\n-        await sema.acquire()\n-        try {\n-          await fn()\n-        } finally {\n-          sema.release()\n-          if (remainingRampup > 0) {\n-            remainingRampup--\n-            sema.release()\n-          }\n-          progress.run()\n-        }\n-      })()\n-    )\n-  }\n-\n   if (!appDirOnly) {\n     for (const [page, route] of currentEntrypoints.page) {\n-      enqueue(() =>\n+      promises.push(\n         handleRouteType({\n           page,\n           route,\n-          currentEntryIssues,\n-          entrypoints: currentEntrypoints,\n           manifestLoader,\n-          productionRewrites: rewrites,\n-          logErrors: false,\n         })\n       )\n     }\n   }\n \n   for (const [page, route] of currentEntrypoints.app) {\n-    enqueue(() =>\n+    promises.push(\n       handleRouteType({\n         page,\n         route,\n-        currentEntryIssues,\n-        entrypoints: currentEntrypoints,\n         manifestLoader,\n-        productionRewrites: rewrites,\n-        logErrors: false,\n       })\n     )\n   }\n \n-  enqueue(() =>\n-    handlePagesErrorRoute({\n-      currentEntryIssues,\n-      entrypoints: currentEntrypoints,\n-      manifestLoader,\n-      productionRewrites: rewrites,\n-      logErrors: false,\n-    })\n-  )\n   await Promise.all(promises)\n \n+  await Promise.all([\n+    manifestLoader.loadBuildManifest('_app'),\n+    manifestLoader.loadPagesManifest('_app'),\n+    manifestLoader.loadFontManifest('_app'),\n+    manifestLoader.loadPagesManifest('_document'),\n+    manifestLoader.loadBuildManifest('_error'),\n+    manifestLoader.loadPagesManifest('_error'),\n+    manifestLoader.loadFontManifest('_error'),\n+    entrypoints.instrumentation &&\n+      manifestLoader.loadMiddlewareManifest(\n+        'instrumentation',\n+        'instrumentation'\n+      ),\n+    entrypoints.middleware &&\n+      (await manifestLoader.loadMiddlewareManifest('middleware', 'middleware')),\n+  ])\n+\n   await manifestLoader.writeManifests({\n     devRewrites: undefined,\n     productionRewrites: rewrites,\n     entrypoints: currentEntrypoints,\n   })\n \n-  const errors: {\n-    page: string\n-    message: string\n-  }[] = []\n-  const warnings: {\n-    page: string\n-    message: string\n-  }[] = []\n-  for (const [page, entryIssues] of currentEntryIssues) {\n-    for (const issue of entryIssues.values()) {\n-      if (issue.severity !== 'warning') {\n-        errors.push({\n-          page,\n-          message: formatIssue(issue),\n-        })\n-      } else {\n-        if (isRelevantWarning(issue)) {\n-          warnings.push({\n-            page,\n-            message: formatIssue(issue),\n-          })\n-        }\n-      }\n-    }\n-  }\n-\n   const shutdownPromise = project.shutdown()\n \n-  if (warnings.length > 0) {\n-    Log.warn(\n-      `Turbopack build collected ${warnings.length} warnings:\\n${warnings\n-        .map((e) => {\n-          return 'Page: ' + e.page + '\\n' + e.message\n-        })\n-        .join('\\n')}`\n-    )\n-  }\n-\n-  if (errors.length > 0) {\n-    throw new Error(\n-      `Turbopack build failed with ${errors.length} errors:\\n${errors\n-        .map((e) => {\n-          return 'Page: ' + e.page + '\\n' + e.message\n-        })\n-        .join('\\n')}`\n-    )\n-  }\n-\n   const time = process.hrtime(startTime)\n   return {\n     duration: time[0] + time[1] / 1e9,"
        },
        {
            "sha": "d3ddb48b3736b2a9720c7bd3d4857ba230b5c50b",
            "filename": "packages/next/src/shared/lib/turbopack/manifest-loader.ts",
            "status": "modified",
            "additions": 58,
            "deletions": 33,
            "changes": 91,
            "blob_url": "https://github.com/vercel/next.js/blob/0ce9e53ef4826e7e8650adc14b2b4432c743acae/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fturbopack%2Fmanifest-loader.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/0ce9e53ef4826e7e8650adc14b2b4432c743acae/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fturbopack%2Fmanifest-loader.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fturbopack%2Fmanifest-loader.ts?ref=0ce9e53ef4826e7e8650adc14b2b4432c743acae",
            "patch": "@@ -63,11 +63,23 @@ type TurbopackMiddlewareManifest = MiddlewareManifest & {\n   instrumentation?: InstrumentationDefinition\n }\n \n+type ManifestName =\n+  | typeof MIDDLEWARE_MANIFEST\n+  | typeof BUILD_MANIFEST\n+  | typeof APP_BUILD_MANIFEST\n+  | typeof PAGES_MANIFEST\n+  | typeof WEBPACK_STATS\n+  | typeof APP_PATHS_MANIFEST\n+  | `${typeof SERVER_REFERENCE_MANIFEST}.json`\n+  | `${typeof NEXT_FONT_MANIFEST}.json`\n+  | typeof REACT_LOADABLE_MANIFEST\n+\n const getManifestPath = (\n   page: string,\n   distDir: string,\n-  name: string,\n-  type: string\n+  name: ManifestName,\n+  type: string,\n+  firstCall: boolean\n ) => {\n   let manifestPath = posix.join(\n     distDir,\n@@ -80,45 +92,40 @@ const getManifestPath = (\n         : getAssetPathFromRoute(page),\n     name\n   )\n+\n+  if (firstCall) {\n+    const isSitemapRoute = /[\\\\/]sitemap(.xml)?\\/route$/.test(page)\n+    // Check the ambiguity of /sitemap and /sitemap.xml\n+    if (isSitemapRoute && !existsSync(manifestPath)) {\n+      manifestPath = getManifestPath(\n+        page.replace(/\\/sitemap\\/route$/, '/sitemap.xml/route'),\n+        distDir,\n+        name,\n+        type,\n+        false\n+      )\n+    }\n+    // existsSync is faster than using the async version\n+    if (!existsSync(manifestPath) && page.endsWith('/route')) {\n+      // TODO: Improve implementation of metadata routes, currently it requires this extra check for the variants of the files that can be written.\n+      let metadataPage = addRouteSuffix(\n+        addMetadataIdToRoute(removeRouteSuffix(page))\n+      )\n+      manifestPath = getManifestPath(metadataPage, distDir, name, type, false)\n+    }\n+  }\n+\n   return manifestPath\n }\n \n async function readPartialManifest<T>(\n   distDir: string,\n-  name:\n-    | typeof MIDDLEWARE_MANIFEST\n-    | typeof BUILD_MANIFEST\n-    | typeof APP_BUILD_MANIFEST\n-    | typeof PAGES_MANIFEST\n-    | typeof WEBPACK_STATS\n-    | typeof APP_PATHS_MANIFEST\n-    | `${typeof SERVER_REFERENCE_MANIFEST}.json`\n-    | `${typeof NEXT_FONT_MANIFEST}.json`\n-    | typeof REACT_LOADABLE_MANIFEST,\n+  name: ManifestName,\n   pageName: string,\n   type: 'pages' | 'app' | 'middleware' | 'instrumentation' = 'pages'\n ): Promise<T> {\n   const page = pageName\n-  const isSitemapRoute = /[\\\\/]sitemap(.xml)?\\/route$/.test(page)\n-  let manifestPath = getManifestPath(page, distDir, name, type)\n-\n-  // Check the ambiguity of /sitemap and /sitemap.xml\n-  if (isSitemapRoute && !existsSync(manifestPath)) {\n-    manifestPath = getManifestPath(\n-      pageName.replace(/\\/sitemap\\/route$/, '/sitemap.xml/route'),\n-      distDir,\n-      name,\n-      type\n-    )\n-  }\n-  // existsSync is faster than using the async version\n-  if (!existsSync(manifestPath) && page.endsWith('/route')) {\n-    // TODO: Improve implementation of metadata routes, currently it requires this extra check for the variants of the files that can be written.\n-    let metadataPage = addRouteSuffix(\n-      addMetadataIdToRoute(removeRouteSuffix(page))\n-    )\n-    manifestPath = getManifestPath(metadataPage, distDir, name, type)\n-  }\n+  const manifestPath = getManifestPath(page, distDir, name, type, true)\n   return JSON.parse(await readFile(posix.join(manifestPath), 'utf-8')) as T\n }\n \n@@ -590,10 +597,26 @@ export class TurbopackManifestLoader {\n     )\n   }\n \n+  /**\n+   * @returns If the manifest was written or not\n+   */\n   async loadMiddlewareManifest(\n     pageName: string,\n     type: 'pages' | 'app' | 'middleware' | 'instrumentation'\n-  ): Promise<void> {\n+  ): Promise<boolean> {\n+    const middlewareManifestPath = getManifestPath(\n+      pageName,\n+      this.distDir,\n+      MIDDLEWARE_MANIFEST,\n+      type,\n+      true\n+    )\n+\n+    // middlewareManifest is actually \"edge manifest\" and not all routes are edge runtime. If it is not written we skip it.\n+    if (!existsSync(middlewareManifestPath)) {\n+      return false\n+    }\n+\n     this.middlewareManifests.set(\n       getEntryKey(\n         type === 'middleware' || type === 'instrumentation' ? 'root' : type,\n@@ -607,6 +630,8 @@ export class TurbopackManifestLoader {\n         type\n       )\n     )\n+\n+    return true\n   }\n \n   getMiddlewareManifest(key: EntryKey) {"
        },
        {
            "sha": "219be98cf5944fb1aa29951174b3d4bf2c73053e",
            "filename": "test/e2e/app-dir/dynamic-io-segment-configs/dynamic-io-segment-configs.test.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/0ce9e53ef4826e7e8650adc14b2b4432c743acae/test%2Fe2e%2Fapp-dir%2Fdynamic-io-segment-configs%2Fdynamic-io-segment-configs.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/0ce9e53ef4826e7e8650adc14b2b4432c743acae/test%2Fe2e%2Fapp-dir%2Fdynamic-io-segment-configs%2Fdynamic-io-segment-configs.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fdynamic-io-segment-configs%2Fdynamic-io-segment-configs.test.ts?ref=0ce9e53ef4826e7e8650adc14b2b4432c743acae",
            "patch": "@@ -114,7 +114,6 @@ describe('dynamic-io-segment-configs', () => {\n             // the stack trace is different between turbopack/webpack\n             if (isTurbopack) {\n               expectLinesToAppearTogether(next.cliOutput, [\n-                `Page: {\"type\":\"app\",\"side\":\"server\",\"page\":\"/fetch-cache/page\"}`,\n                 './app/layout.tsx:2:24',\n               ])\n             } else {"
        },
        {
            "sha": "37c250c05f82a464e65408f799690f321c47076f",
            "filename": "test/e2e/app-dir/use-cache-segment-configs/use-cache-segment-configs.test.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/0ce9e53ef4826e7e8650adc14b2b4432c743acae/test%2Fe2e%2Fapp-dir%2Fuse-cache-segment-configs%2Fuse-cache-segment-configs.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/0ce9e53ef4826e7e8650adc14b2b4432c743acae/test%2Fe2e%2Fapp-dir%2Fuse-cache-segment-configs%2Fuse-cache-segment-configs.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache-segment-configs%2Fuse-cache-segment-configs.test.ts?ref=0ce9e53ef4826e7e8650adc14b2b4432c743acae",
            "patch": "@@ -56,7 +56,6 @@ describe('use-cache-segment-configs', () => {\n       if (isTurbopack) {\n         expect(buildOutput).toMatchInlineSnapshot(`\n          \"Error: Turbopack build failed with 1 errors:\n-         Page: {\"type\":\"app\",\"side\":\"server\",\"page\":\"/runtime/page\"}\n          ./app/runtime/page.tsx:1:14\n          Ecmascript file had an error\n          > 1 | export const runtime = 'edge'"
        },
        {
            "sha": "0d7c2c71471321e673f5344978e32f746d975355",
            "filename": "test/e2e/app-dir/use-cache-unknown-cache-kind/use-cache-unknown-cache-kind.test.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 12,
            "changes": 23,
            "blob_url": "https://github.com/vercel/next.js/blob/0ce9e53ef4826e7e8650adc14b2b4432c743acae/test%2Fe2e%2Fapp-dir%2Fuse-cache-unknown-cache-kind%2Fuse-cache-unknown-cache-kind.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/0ce9e53ef4826e7e8650adc14b2b4432c743acae/test%2Fe2e%2Fapp-dir%2Fuse-cache-unknown-cache-kind%2Fuse-cache-unknown-cache-kind.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache-unknown-cache-kind%2Fuse-cache-unknown-cache-kind.test.ts?ref=0ce9e53ef4826e7e8650adc14b2b4432c743acae",
            "patch": "@@ -42,22 +42,21 @@ describe('use-cache-unknown-cache-kind', () => {\n \n       if (isTurbopack) {\n         expect(buildOutput).toMatchInlineSnapshot(`\n-          \"Error: Turbopack build failed with 1 errors:\n-          Page: {\"type\":\"app\",\"side\":\"server\",\"page\":\"/page\"}\n-          ./app/page.tsx:1:1\n-          Ecmascript file had an error\n-          > 1 | 'use cache: custom'\n-              | ^^^^^^^^^^^^^^^^^^^\n-            2 |\n-            3 | export default async function Page() {\n-            4 |   return <p>hello world</p>\n+         \"Error: Turbopack build failed with 1 errors:\n+         ./app/page.tsx:1:1\n+         Ecmascript file had an error\n+         > 1 | 'use cache: custom'\n+             | ^^^^^^^^^^^^^^^^^^^\n+           2 |\n+           3 | export default async function Page() {\n+           4 |   return <p>hello world</p>\n \n-          Unknown cache kind \"custom\". Please configure a cache handler for this kind in the \"experimental.cacheHandlers\" object in your Next.js config.\n+         Unknown cache kind \"custom\". Please configure a cache handler for this kind in the \"experimental.cacheHandlers\" object in your Next.js config.\n \n \n \n-              at <unknown> (./app/page.tsx:1:1)\n-          \"\n+             at <unknown> (./app/page.tsx:1:1)\n+         \"\n         `)\n       } else if (isRspack) {\n         expect(buildOutput).toMatchInlineSnapshot(`"
        },
        {
            "sha": "0a799c2bf8323bb15f4265cbb9a1bc175398896b",
            "filename": "test/e2e/app-dir/use-cache-without-experimental-flag/use-cache-without-experimental-flag.test.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/0ce9e53ef4826e7e8650adc14b2b4432c743acae/test%2Fe2e%2Fapp-dir%2Fuse-cache-without-experimental-flag%2Fuse-cache-without-experimental-flag.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/0ce9e53ef4826e7e8650adc14b2b4432c743acae/test%2Fe2e%2Fapp-dir%2Fuse-cache-without-experimental-flag%2Fuse-cache-without-experimental-flag.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache-without-experimental-flag%2Fuse-cache-without-experimental-flag.test.ts?ref=0ce9e53ef4826e7e8650adc14b2b4432c743acae",
            "patch": "@@ -32,7 +32,6 @@ describe('use-cache-without-experimental-flag', () => {\n       if (isTurbopack) {\n         expect(buildOutput).toMatchInlineSnapshot(`\n          \"Error: Turbopack build failed with 1 errors:\n-         Page: {\"type\":\"app\",\"side\":\"server\",\"page\":\"/page\"}\n          ./app/page.tsx:1:1\n          Ecmascript file had an error\n          > 1 | 'use cache'"
        }
    ],
    "stats": {
        "total": 1135,
        "additions": 497,
        "deletions": 638
    }
}