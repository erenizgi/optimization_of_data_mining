{
    "author": "icyJoseph",
    "message": "docs: dynamic routes w/ gsP (#86402)",
    "sha": "6cc51a3b8a3030d456965a24a85f094842c2fac1",
    "files": [
        {
            "sha": "242ed78003bb7b5623d44ec3a890b04323f3c374",
            "filename": "docs/01-app/01-getting-started/06-cache-components.mdx",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/6cc51a3b8a3030d456965a24a85f094842c2fac1/docs%2F01-app%2F01-getting-started%2F06-cache-components.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/6cc51a3b8a3030d456965a24a85f094842c2fac1/docs%2F01-app%2F01-getting-started%2F06-cache-components.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F01-getting-started%2F06-cache-components.mdx?ref=6cc51a3b8a3030d456965a24a85f094842c2fac1",
            "patch": "@@ -158,7 +158,7 @@ A specific type of dynamic data that requires request context, only available wh\n - [`cookies()`](/docs/app/api-reference/functions/cookies) - User's cookie data\n - [`headers()`](/docs/app/api-reference/functions/headers) - Request headers\n - [`searchParams`](/docs/app/api-reference/file-conventions/page#searchparams-optional) - URL query parameters\n-- [`params`](/docs/app/api-reference/file-conventions/page#params-optional) - Dynamic route parameters (unless at least one sample is provided via [`generateStaticParams`](/docs/app/api-reference/functions/generate-static-params))\n+- [`params`](/docs/app/api-reference/file-conventions/page#params-optional) - Dynamic route parameters (unless at least one sample is provided via [`generateStaticParams`](/docs/app/api-reference/functions/generate-static-params)). See [Dynamic Routes with Cache Components](/docs/app/api-reference/file-conventions/dynamic-routes#with-cache-components) for detailed patterns.\n \n ```tsx filename=\"page.tsx\"\n import { cookies, headers } from 'next/headers'"
        },
        {
            "sha": "c6efb2a8dd0938b258ee94e611eb194d077e6a72",
            "filename": "docs/01-app/03-api-reference/03-file-conventions/dynamic-routes.mdx",
            "status": "modified",
            "additions": 202,
            "deletions": 1,
            "changes": 203,
            "blob_url": "https://github.com/vercel/next.js/blob/6cc51a3b8a3030d456965a24a85f094842c2fac1/docs%2F01-app%2F03-api-reference%2F03-file-conventions%2Fdynamic-routes.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/6cc51a3b8a3030d456965a24a85f094842c2fac1/docs%2F01-app%2F03-api-reference%2F03-file-conventions%2Fdynamic-routes.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-api-reference%2F03-file-conventions%2Fdynamic-routes.mdx?ref=6cc51a3b8a3030d456965a24a85f094842c2fac1",
            "patch": "@@ -67,7 +67,6 @@ export default function BlogPostPage({\n ```jsx filename=\"app/blog/[slug]/page.js\" switcher\n 'use client'\n import { use } from 'react'\n-import { useParams } from 'next/navigation'\n \n export default function BlogPostPage({ params }) {\n   const { slug } = use(params)\n@@ -145,6 +144,151 @@ export default async function Page(props: PageProps<'/[locale]'>) {\n - Since the `params` prop is a promise. You must use `async`/`await` or React's use function to access the values.\n   - In version 14 and earlier, `params` was a synchronous prop. To help with backwards compatibility, you can still access it synchronously in Next.js 15, but this behavior will be deprecated in the future.\n \n+### With Cache Components\n+\n+When using [Cache Components](/docs/app/getting-started/cache-components) with dynamic route segments, how you handle params depends on whether you use [`generateStaticParams`](/docs/app/api-reference/functions/generate-static-params).\n+\n+Without `generateStaticParams`, param values are unknown during prerendering, making params runtime data. You must wrap param access in `<Suspense>` boundaries to provide fallback UI.\n+\n+With `generateStaticParams`, you provide sample param values that can be used at build time. The build process validates that dynamic content and other runtime APIs are correctly handled, then generates static HTML files for the samples. Pages rendered with runtime params are saved to disk after a successful first request.\n+\n+The sections below demonstrate both patterns.\n+\n+#### Without `generateStaticParams`\n+\n+All params are runtime data. Param access must be wrapped by Suspense fallback UI. Next.js generates a static shell at build time, and content loads on each request.\n+\n+> **Good to know**: You can also use [`loading.tsx`](/docs/app/api-reference/file-conventions/loading) for page-level fallback UI.\n+\n+```tsx filename=\"app/blog/[slug]/page.tsx\"\n+import { Suspense } from 'react'\n+\n+export default function Page({ params }: PageProps<'/blog/[slug]'>) {\n+  return (\n+    <div>\n+      <h1>Blog Post</h1>\n+      <Suspense fallback={<div>Loading...</div>}>\n+        {params.then(({ slug }) => (\n+          <Content slug={slug} />\n+        ))}\n+      </Suspense>\n+    </div>\n+  )\n+}\n+\n+async function Content({ slug }: { slug: string }) {\n+  const res = await fetch(`https://api.vercel.app/blog/${slug}`)\n+  const post = await res.json()\n+\n+  return (\n+    <article>\n+      <h2>{post.title}</h2>\n+      <p>{post.content}</p>\n+    </article>\n+  )\n+}\n+```\n+\n+#### With `generateStaticParams`\n+\n+Provide params ahead of time to prerender pages at build time. You can prerender all routes or a subset depending on your needs.\n+\n+During the build process, the route is executed with each sample param to collect the HTML result. If dynamic content or runtime data are accessed incorrectly, the build will fail.\n+\n+```tsx filename=\"app/blog/[slug]/page.tsx\" highlight={5-7,10,22,24}\n+import { Suspense } from 'react'\n+\n+export async function generateStaticParams() {\n+  return [{ slug: '1' }, { slug: '2' }, { slug: '3' }]\n+}\n+\n+export default async function Page({ params }: PageProps<'/blog/[slug]'>) {\n+  const { slug } = await params\n+\n+  return (\n+    <div>\n+      <h1>Blog Post</h1>\n+      <Content slug={slug} />\n+    </div>\n+  )\n+}\n+\n+async function Content({ slug }: { slug: string }) {\n+  const post = await getPost(slug)\n+  return (\n+    <article>\n+      <h2>{post.title}</h2>\n+      <p>{post.content}</p>\n+    </article>\n+  )\n+}\n+\n+async function getPost(slug: string) {\n+  'use cache'\n+  const res = await fetch(`https://api.vercel.app/blog/${slug}`)\n+  return res.json()\n+}\n+```\n+\n+Build-time validation only covers code paths that execute with the sample params. If your route has conditional logic that accesses runtime APIs for certain param values not in your samples, those branches won't be validated at build time:\n+\n+```tsx filename=\"app/blog/[slug]/page.tsx\"\n+import { cookies } from 'next/headers'\n+\n+export async function generateStaticParams() {\n+  return [{ slug: 'public-post' }, { slug: 'hello-world' }]\n+}\n+\n+export default async function Page({ params }: PageProps<'/blog/[slug]'>) {\n+  const { slug } = await params\n+\n+  if (slug.startsWith('private-')) {\n+    // This branch is never executed at build time\n+    // Runtime requests for 'private-*' slugs will error\n+    return <PrivatePost slug={slug} />\n+  }\n+\n+  return <PublicPost slug={slug} />\n+}\n+\n+async function PrivatePost({ slug }: { slug: string }) {\n+  const token = (await cookies()).get('token')\n+  // ... fetch and render private post using token for auth\n+}\n+```\n+\n+For runtime params not returned by `generateStaticParams`, validation occurs during the first request. In the example above, requests for slugs starting with `private-` will fail because `PrivatePost` accesses `cookies()` without a Suspense boundary. Other runtime params that don't hit the conditional branch will render successfully and be saved to disk for subsequent requests.\n+\n+To fix this, wrap `PrivatePost` with Suspense:\n+\n+```tsx filename=\"app/blog/[slug]/page.tsx\" highlight={13-15}\n+import { Suspense } from 'react'\n+import { cookies } from 'next/headers'\n+\n+export async function generateStaticParams() {\n+  return [{ slug: 'public-post' }, { slug: 'hello-world' }]\n+}\n+\n+export default async function Page({ params }: PageProps<'/blog/[slug]'>) {\n+  const { slug } = await params\n+\n+  if (slug.startsWith('private-')) {\n+    return (\n+      <Suspense fallback={<div>Loading...</div>}>\n+        <PrivatePost slug={slug} />\n+      </Suspense>\n+    )\n+  }\n+\n+  return <PublicPost slug={slug} />\n+}\n+\n+async function PrivatePost({ slug }: { slug: string }) {\n+  const token = (await cookies()).get('token')\n+  // ... fetch and render private post using token for auth\n+}\n+```\n+\n ## Examples\n \n ### With `generateStaticParams`\n@@ -172,3 +316,60 @@ export async function generateStaticParams() {\n ```\n \n When using `fetch` inside the `generateStaticParams` function, the requests are [automatically deduplicated](/docs/app/guides/caching#request-memoization). This avoids multiple network calls for the same data Layouts, Pages, and other `generateStaticParams` functions, speeding up build time.\n+\n+### Dynamic GET Route Handlers with `generateStaticParams`\n+\n+`generateStaticParams` also works with dynamic [Route Handlers](/docs/app/api-reference/file-conventions/route) to statically generate API responses at build time:\n+\n+```ts filename=\"app/api/posts/[id]/route.ts\" switcher\n+export async function generateStaticParams() {\n+  const posts: { id: number }[] = await fetch(\n+    'https://api.vercel.app/blog'\n+  ).then((res) => res.json())\n+\n+  return posts.map((post) => ({\n+    id: `${post.id}`,\n+  }))\n+}\n+\n+export async function GET(\n+  request: Request,\n+  { params }: RouteContext<'/api/posts/[id]'>\n+) {\n+  const { id } = await params\n+  const res = await fetch(`https://api.vercel.app/blog/${id}`)\n+\n+  if (!res.ok) {\n+    return Response.json({ error: 'Post not found' }, { status: 404 })\n+  }\n+\n+  const post = await res.json()\n+  return Response.json(post)\n+}\n+```\n+\n+```js filename=\"app/api/posts/[id]/route.js\" switcher\n+export async function generateStaticParams() {\n+  const posts = await fetch('https://api.vercel.app/blog').then((res) =>\n+    res.json()\n+  )\n+\n+  return posts.map((post) => ({\n+    id: `${post.id}`,\n+  }))\n+}\n+\n+export async function GET(request, { params }) {\n+  const { id } = await params\n+  const res = await fetch(`https://api.vercel.app/blog/${id}`)\n+\n+  if (!res.ok) {\n+    return Response.json({ error: 'Post not found' }, { status: 404 })\n+  }\n+\n+  const post = await res.json()\n+  return Response.json(post)\n+}\n+```\n+\n+In this example, route handlers for all blog post IDs returned by `generateStaticParams` will be statically generated at build time. Requests to other IDs will be handled dynamically at request time."
        },
        {
            "sha": "c1f513a1d4ea544873cbf178b5ec18416b6d89f9",
            "filename": "docs/01-app/03-api-reference/03-file-conventions/route.mdx",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/6cc51a3b8a3030d456965a24a85f094842c2fac1/docs%2F01-app%2F03-api-reference%2F03-file-conventions%2Froute.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/6cc51a3b8a3030d456965a24a85f094842c2fac1/docs%2F01-app%2F03-api-reference%2F03-file-conventions%2Froute.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-api-reference%2F03-file-conventions%2Froute.mdx?ref=6cc51a3b8a3030d456965a24a85f094842c2fac1",
            "patch": "@@ -334,6 +334,14 @@ export async function GET(request, { params }) {\n | `app/items/[slug]/route.js` | `/items/b`  | `Promise<{ slug: 'b' }>` |\n | `app/items/[slug]/route.js` | `/items/c`  | `Promise<{ slug: 'c' }>` |\n \n+#### Static Generation with `generateStaticParams`\n+\n+You can use [`generateStaticParams`](/docs/app/api-reference/functions/generate-static-params) with dynamic Route Handlers to statically generate responses at build time for specified params, while handling other params dynamically at request time.\n+\n+When using [Cache Components](/docs/app/getting-started/cache-components), you can combine `generateStaticParams` with `use cache` to enable data caching for both prerendered and runtime params.\n+\n+See the [generateStaticParams with Route Handlers](/docs/app/api-reference/functions/generate-static-params#with-route-handlers) documentation for examples and details.\n+\n ### URL Query Parameters\n \n The request object passed to the Route Handler is a `NextRequest` instance, which includes [some additional convenience methods](/docs/app/api-reference/functions/next-request#nexturl), such as those for more easily handling query parameters."
        },
        {
            "sha": "23e84232b270ad2e671d4bb45473d0c7c8b2ca50",
            "filename": "docs/01-app/03-api-reference/04-functions/generate-static-params.mdx",
            "status": "modified",
            "additions": 75,
            "deletions": 1,
            "changes": 76,
            "blob_url": "https://github.com/vercel/next.js/blob/6cc51a3b8a3030d456965a24a85f094842c2fac1/docs%2F01-app%2F03-api-reference%2F04-functions%2Fgenerate-static-params.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/6cc51a3b8a3030d456965a24a85f094842c2fac1/docs%2F01-app%2F03-api-reference%2F04-functions%2Fgenerate-static-params.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-api-reference%2F04-functions%2Fgenerate-static-params.mdx?ref=6cc51a3b8a3030d456965a24a85f094842c2fac1",
            "patch": "@@ -5,6 +5,12 @@ description: API reference for the generateStaticParams function.\n \n The `generateStaticParams` function can be used in combination with [dynamic route segments](/docs/app/api-reference/file-conventions/dynamic-routes) to [**statically generate**](/docs/app/guides/caching#static-rendering) routes at build time instead of on-demand at request time.\n \n+`generateStaticParams` can be used with:\n+\n+- [Pages](/docs/app/api-reference/file-conventions/page) (`page.tsx`/`page.js`)\n+- [Layouts](/docs/app/api-reference/file-conventions/layout) (`layout.tsx`/`layout.js`)\n+- [Route Handlers](/docs/app/api-reference/file-conventions/route) (`route.ts`/`route.js`)\n+\n ```tsx filename=\"app/blog/[slug]/page.tsx\" switcher\n // Return a list of `params` to populate the [slug] dynamic segment\n export async function generateStaticParams() {\n@@ -291,12 +297,80 @@ export async function generateStaticParams() {\n }\n ```\n \n-> **Good to know:** You must always return an array from `generateStaticParams`, even if it's empty. Otherwise, the route will be dynamically rendered.\n+> **Good to know:**\n+>\n+> - You must always return an array from `generateStaticParams`, even if it's empty. Otherwise, the route will be dynamically rendered.\n \n ```jsx filename=\"app/changelog/[slug]/page.js\"\n export const dynamic = 'force-static'\n ```\n \n+#### With Cache Components\n+\n+When using [Cache Components](/docs/app/getting-started/cache-components) with dynamic routes, `generateStaticParams` must return **at least one param**. Empty arrays cause a [build error](/docs/messages/empty-generate-static-params). This allows Cache Components to validate your route doesn't incorrectly access `cookies()`, `headers()`, or `searchParams` at runtime.\n+\n+> **Good to know**: If you don't know the actual param values at build time, you can return a placeholder param (e.g., `[{ slug: '__placeholder__' }]`) for validation, then handle it in your page with `notFound()`. However, this prevents build time validation from working effectively and may cause runtime errors.\n+\n+See the [dynamic routes section](/docs/app/api-reference/file-conventions/dynamic-routes#with-cache-components) for detailed walkthroughs.\n+\n+### With Route Handlers\n+\n+You can use `generateStaticParams` with [Route Handlers](/docs/app/api-reference/file-conventions/route) to statically generate API responses at build time:\n+\n+```ts filename=\"app/api/posts/[id]/route.ts\" switcher\n+export async function generateStaticParams() {\n+  return [{ id: '1' }, { id: '2' }, { id: '3' }]\n+}\n+\n+export async function GET(\n+  request: Request,\n+  { params }: RouteContext<'/api/posts/[id]'>\n+) {\n+  const { id } = await params\n+  // This will be statically generated for IDs 1, 2, and 3\n+  return Response.json({ id, title: `Post ${id}` })\n+}\n+```\n+\n+```js filename=\"app/api/posts/[id]/route.js\" switcher\n+export async function generateStaticParams() {\n+  return [{ id: '1' }, { id: '2' }, { id: '3' }]\n+}\n+\n+export async function GET(request, { params }) {\n+  const { id } = await params\n+  // This will be statically generated for IDs 1, 2, and 3\n+  return Response.json({ id, title: `Post ${id}` })\n+}\n+```\n+\n+### Route Handlers with Cache Components\n+\n+When using [Cache Components](/docs/app/getting-started/cache-components), combine with `use cache` for optimal caching:\n+\n+```ts filename=\"app/api/posts/[id]/route.ts\"\n+export async function generateStaticParams() {\n+  return [{ id: '1' }, { id: '2' }, { id: '3' }]\n+}\n+\n+async function getPost(id: Promise<string>) {\n+  'use cache'\n+  const resolvedId = await id\n+  const response = await fetch(`https://api.example.com/posts/${resolvedId}`)\n+  return response.json()\n+}\n+\n+export async function GET(\n+  request: Request,\n+  { params }: RouteContext<'/api/posts/[id]'>\n+) {\n+  const post = await getPost(params.then((p) => p.id))\n+  return Response.json(post)\n+}\n+```\n+\n+See the [Route Handlers documentation](/docs/app/api-reference/file-conventions/route#static-generation-with-generatestaticparams) for more details.\n+\n ### Disable rendering for unspecified paths\n \n To prevent unspecified paths from being statically rendered at runtime, add the `export const dynamicParams = false` option in a route segment. When this config option is used, only paths provided by `generateStaticParams` will be served, and unspecified routes will 404 or match (in the case of [catch-all routes](/docs/app/api-reference/file-conventions/dynamic-routes#catch-all-segments))."
        },
        {
            "sha": "d0437bb6a9180730774380b91e356ee0960891f0",
            "filename": "errors/blocking-route.mdx",
            "status": "modified",
            "additions": 17,
            "deletions": 0,
            "changes": 17,
            "blob_url": "https://github.com/vercel/next.js/blob/6cc51a3b8a3030d456965a24a85f094842c2fac1/errors%2Fblocking-route.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/6cc51a3b8a3030d456965a24a85f094842c2fac1/errors%2Fblocking-route.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/errors%2Fblocking-route.mdx?ref=6cc51a3b8a3030d456965a24a85f094842c2fac1",
            "patch": "@@ -212,6 +212,23 @@ export default async function Page({ searchParams }) {\n \n Alternatively you can add a Suspense boundary above the component that is accessing `params` or `searchParams` so Next.js understands what UI should be used when while waiting for this request data to be accessed.\n \n+#### `generateStaticParams`\n+\n+For Layout and Page `params`, you can use [`generateStaticParams`](/docs/app/api-reference/functions/generate-static-params) to provide sample values for build-time validation, which allows you to await params directly without Suspense.\n+\n+```jsx filename=\"app/blog/[slug]/page.js\"\n+export async function generateStaticParams() {\n+  return [{ slug: 'hello-world' }]\n+}\n+\n+export default async function Page({ params }) {\n+  const { slug } = await params //  Valid with generateStaticParams\n+  return <div>Blog post: {slug}</div>\n+}\n+```\n+\n+Note that validation is path-dependent. Runtime parameters may trigger conditional branches accessing runtime APIs without Suspense, or dynamic content without Suspense or `use cache`, resulting in errors. See [Dynamic Routes with Cache Components](/docs/app/api-reference/file-conventions/dynamic-routes#with-cache-components).\n+\n ### Short-lived Caches\n \n `\"use cache\"` allows you to describe a [`cacheLife()`](/docs/app/api-reference/functions/cacheLife) that might be too short to be practical to prerender. The utility of doing this is that it can still describe a non-zero caching time for the client router cache to reuse the cache entry in the browser and it can also be useful for protecting upstream APIs while experiencing high request traffic."
        },
        {
            "sha": "e9f1be7f2d69383b565e1b60d8ab627353aa7859",
            "filename": "errors/empty-generate-static-params.mdx",
            "status": "modified",
            "additions": 19,
            "deletions": 10,
            "changes": 29,
            "blob_url": "https://github.com/vercel/next.js/blob/6cc51a3b8a3030d456965a24a85f094842c2fac1/errors%2Fempty-generate-static-params.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/6cc51a3b8a3030d456965a24a85f094842c2fac1/errors%2Fempty-generate-static-params.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/errors%2Fempty-generate-static-params.mdx?ref=6cc51a3b8a3030d456965a24a85f094842c2fac1",
            "patch": "@@ -4,7 +4,7 @@ title: Empty generateStaticParams with Cache Components\n \n ## Why This Error Occurred\n \n-You're using [Cache Components](https://nextjs.org/docs/beta/app/api-reference/config/next-config-js/cacheComponents) in your Next.js application, and one of your `generateStaticParams` functions returned an empty array, which causes a build error.\n+You're using [Cache Components](https://nextjs.org/docs/app/getting-started/cache-components) in your Next.js application, and one of your `generateStaticParams` functions returned an empty array, which causes a build error.\n \n When Cache Components is enabled, Next.js performs build-time validation to ensure your routes can be properly prerendered without runtime dynamic access errors. If `generateStaticParams` returns an empty array, Next.js cannot validate that your route won't access dynamic values (like `await cookies()`, `await headers()`, or `await searchParams`) at runtime, which would cause errors.\n \n@@ -21,27 +21,31 @@ This strict requirement ensures:\n Modify your `generateStaticParams` function to return at least one set of parameters. This is the most common fix and allows build-time validation to work properly.\n \n ```tsx filename=\"app/blog/[slug]/page.tsx\"\n-// ❌ This will cause an error with Cache Components\n+// This will cause an error with Cache Components\n export async function generateStaticParams() {\n   return [] // Empty array not allowed\n }\n \n-// ✅ Return at least one param\n+// Return at least one sample param\n export async function generateStaticParams() {\n   return [{ slug: 'hello-world' }, { slug: 'getting-started' }]\n }\n ```\n \n-### Option 2: Use a placeholder param for validation\n+These samples serve dual purposes:\n \n-If you don't know the actual values at build time but still want Cache Components, you can return a placeholder param for build-time validation:\n+1. **Build-time validation**: Verify your route structure is safe\n+2. **Prerendering**: Generate instant-loading pages for popular routes\n \n-> This is not recommended and should only be used if you absolutely need to as it prevents build-time validation from working which will likely cause runtime errors.\n+The build process only validates code paths that execute with your sample params. If runtime parameters trigger conditional logic that renders branches accessing runtime APIs (like `cookies()`) without Suspense, or dynamic content without Suspense or `use cache`, those will cause runtime errors.\n+\n+### Option 2: Use a placeholder param\n+\n+If you don't know actual values at build time, you can use a placeholder for validation. However, this defeats the purpose of build-time validation and should be avoided:\n \n ```tsx filename=\"app/blog/[slug]/page.tsx\"\n export async function generateStaticParams() {\n-  // Return a placeholder for build-time validation\n-  // Real params will be generated at runtime via ISR\n+  // Placeholder only validates one code path\n   return [{ slug: '__placeholder__' }]\n }\n \n@@ -57,13 +61,18 @@ export default async function Page({\n     notFound()\n   }\n \n-  // Your actual page logic\n+  // Real params may trigger code paths\n+  // that access dynamic APIs incorrectly, causing\n+  // runtime errors that cannot be caught by error boundaries\n   const post = await getPost(slug)\n   return <div>{post.title}</div>\n }\n ```\n \n+Using placeholders provides minimal build-time validation and increases the risk of runtime errors for actual parameter values.\n+\n ## Useful Links\n \n-- [Cache Components Documentation](https://nextjs.org/docs/beta/app/api-reference/config/next-config-js/cacheComponents)\n+- [Cache Components Documentation](https://nextjs.org/docs/app/getting-started/cache-components)\n - [generateStaticParams API Reference](https://nextjs.org/docs/app/api-reference/functions/generate-static-params)\n+- [Dynamic Routes with Cache Components](/docs/app/api-reference/file-conventions/dynamic-routes#with-cache-components)"
        }
    ],
    "stats": {
        "total": 335,
        "additions": 322,
        "deletions": 13
    }
}