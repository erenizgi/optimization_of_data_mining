{
    "author": "lukesandberg",
    "message": "[turbopack] optimize the TurboMalloc threadlocals (#80265)\n\nImprove memory tracking in turbo-tasks-malloc\n\n### What?\n\nMade the thread_local initializer `const` compatible.  This skips per-thread lazy initialization of the threadlocal datastructure which allows us to skip a small amount of bootstrapping logic.\n\nAdditionally, this allows us to access the native llvm implementation of threadlocals which can improve performance.  See https://matklad.github.io/2020/10/03/fast-thread-locals-in-rust.html\n\n### Performance\n\nConfusingly, the benchmarks are not positive, but vercel-site appears to be.  Perhaps the 'small' benchmarks are just too small/\n\n![image.png](https://graphite-user-uploaded-assets-prod.s3.amazonaws.com/AwJ29EfoPcPdLSwCZxAz/51a29e9b-d653-4ba1-8e18-063b6a60c3a9.png)",
    "sha": "0bb13fa677c05107ccfeb544788eac82fe027480",
    "files": [
        {
            "sha": "d5faff91bafa2cf2f1c4af7b350d5290f5d6ca74",
            "filename": "turbopack/crates/turbo-tasks-malloc/src/counter.rs",
            "status": "modified",
            "additions": 11,
            "deletions": 1,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/0bb13fa677c05107ccfeb544788eac82fe027480/turbopack%2Fcrates%2Fturbo-tasks-malloc%2Fsrc%2Fcounter.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0bb13fa677c05107ccfeb544788eac82fe027480/turbopack%2Fcrates%2Fturbo-tasks-malloc%2Fsrc%2Fcounter.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-malloc%2Fsrc%2Fcounter.rs?ref=0bb13fa677c05107ccfeb544788eac82fe027480",
            "patch": "@@ -6,6 +6,10 @@ use std::{\n \n use crate::AllocationCounters;\n \n+/// Tracks the current total amount of memory allocated through all the [ThreadLocalCounter]\n+/// instances.  This is an overestimate as individual threads 'preallocate' a [TARGET_BUFFER] bytes\n+/// to reduce the number of global synchronizations.  This means at any given time this might\n+/// overcount by up to [MAX_BUFFER] bytes for each thread.\n static ALLOCATED: AtomicUsize = AtomicUsize::new(0);\n const KB: usize = 1024;\n /// When global counter is updates we will keep a thread-local buffer of this\n@@ -26,6 +30,12 @@ struct ThreadLocalCounter {\n }\n \n impl ThreadLocalCounter {\n+    const fn new() -> Self {\n+        Self {\n+            buffer: 0,\n+            allocation_counters: AllocationCounters::new(),\n+        }\n+    }\n     fn add(&mut self, size: usize) {\n         self.allocation_counters.allocations += size;\n         self.allocation_counters.allocation_count += 1;\n@@ -88,7 +98,7 @@ impl ThreadLocalCounter {\n }\n \n thread_local! {\n-  static LOCAL_COUNTER: UnsafeCell<ThreadLocalCounter> = UnsafeCell::new(ThreadLocalCounter::default());\n+  static LOCAL_COUNTER: UnsafeCell<ThreadLocalCounter> = const {UnsafeCell::new(ThreadLocalCounter::new())};\n }\n \n pub fn get() -> usize {"
        },
        {
            "sha": "4d001d345a1784f8bdb12977f853aeb53af6c269",
            "filename": "turbopack/crates/turbo-tasks-malloc/src/lib.rs",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/0bb13fa677c05107ccfeb544788eac82fe027480/turbopack%2Fcrates%2Fturbo-tasks-malloc%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0bb13fa677c05107ccfeb544788eac82fe027480/turbopack%2Fcrates%2Fturbo-tasks-malloc%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-malloc%2Fsrc%2Flib.rs?ref=0bb13fa677c05107ccfeb544788eac82fe027480",
            "patch": "@@ -34,6 +34,15 @@ pub struct AllocationCounters {\n }\n \n impl AllocationCounters {\n+    const fn new() -> Self {\n+        Self {\n+            allocation_count: 0,\n+            deallocation_count: 0,\n+            allocations: 0,\n+            deallocations: 0,\n+            _not_send: PhantomData {},\n+        }\n+    }\n     pub fn until_now(&self) -> AllocationInfo {\n         let new = TurboMalloc::allocation_counters();\n         AllocationInfo {\n@@ -50,6 +59,7 @@ impl AllocationCounters {\n pub struct TurboMalloc;\n \n impl TurboMalloc {\n+    // Returns the current amount of memory\n     pub fn memory_usage() -> usize {\n         get()\n     }"
        }
    ],
    "stats": {
        "total": 22,
        "additions": 21,
        "deletions": 1
    }
}