{
    "author": "sokra",
    "message": "Turbopack: arrange empty space in trace viewer correctly (#86612)\n\n### What?\r\n\r\nPosition single spans correctly in the empty space (self time)\r\n\r\nBefore:\r\n\r\n![Screenshot 2025-11-28 at 14.26.24.png](https://app.graphite.com/user-attachments/assets/fc412ac2-7ffe-477f-9f1c-fe01c1dae05e.png)\r\n\r\nAfter:\r\n\r\n![Screenshot 2025-11-28 at 14.23.58.png](https://app.graphite.com/user-attachments/assets/b801ec16-0dee-4cdd-b2a3-c967120f41f5.png)",
    "sha": "2374ee16b44c0ef27a137d03c75a958f7255916f",
    "files": [
        {
            "sha": "eb1fe620625c93138b06978e707b21b584882d33",
            "filename": "turbopack/crates/turbopack-trace-server/src/span_ref.rs",
            "status": "modified",
            "additions": 47,
            "deletions": 4,
            "changes": 51,
            "blob_url": "https://github.com/vercel/next.js/blob/2374ee16b44c0ef27a137d03c75a958f7255916f/turbopack%2Fcrates%2Fturbopack-trace-server%2Fsrc%2Fspan_ref.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2374ee16b44c0ef27a137d03c75a958f7255916f/turbopack%2Fcrates%2Fturbopack-trace-server%2Fsrc%2Fspan_ref.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-trace-server%2Fsrc%2Fspan_ref.rs?ref=2374ee16b44c0ef27a137d03c75a958f7255916f",
            "patch": "@@ -184,9 +184,13 @@ impl<'a> SpanRef<'a> {\n \n     // TODO(sokra) use events instead of children for visualizing span graphs\n     #[allow(dead_code)]\n-    pub fn events(&self) -> impl Iterator<Item = SpanEventRef<'a>> {\n+    pub fn events(&self) -> impl DoubleEndedIterator<Item = SpanEventRef<'a>> {\n         self.span.events.iter().map(|event| match event {\n-            &SpanEvent::SelfTime { start, end } => SpanEventRef::SelfTime { start, end },\n+            &SpanEvent::SelfTime { start, end } => SpanEventRef::SelfTime {\n+                store: self.store,\n+                start,\n+                end,\n+            },\n             SpanEvent::Child { index } => SpanEventRef::Child {\n                 span: SpanRef {\n                     span: &self.store.spans[index.get()],\n@@ -545,6 +549,45 @@ impl Debug for SpanRef<'_> {\n #[allow(dead_code)]\n #[derive(Copy, Clone)]\n pub enum SpanEventRef<'a> {\n-    SelfTime { start: Timestamp, end: Timestamp },\n-    Child { span: SpanRef<'a> },\n+    SelfTime {\n+        store: &'a Store,\n+        start: Timestamp,\n+        end: Timestamp,\n+    },\n+    Child {\n+        span: SpanRef<'a>,\n+    },\n+}\n+\n+impl SpanEventRef<'_> {\n+    pub fn start(&self) -> Timestamp {\n+        match self {\n+            SpanEventRef::SelfTime { start, .. } => *start,\n+            SpanEventRef::Child { span } => span.start(),\n+        }\n+    }\n+\n+    pub fn total_time(&self) -> Timestamp {\n+        match self {\n+            SpanEventRef::SelfTime { start, end, .. } => end.saturating_sub(*start),\n+            SpanEventRef::Child { span } => span.total_time(),\n+        }\n+    }\n+\n+    pub fn corrected_self_time(&self) -> Timestamp {\n+        match self {\n+            SpanEventRef::SelfTime { store, start, end } => {\n+                let duration = *end - *start;\n+                if !duration.is_zero() {\n+                    store.set_max_self_time_lookup(*end);\n+                    store.self_time_tree.as_ref().map_or(duration, |tree| {\n+                        tree.lookup_range_corrected_time(*start, *end)\n+                    })\n+                } else {\n+                    Timestamp::ZERO\n+                }\n+            }\n+            SpanEventRef::Child { span } => span.corrected_self_time(),\n+        }\n+    }\n }"
        },
        {
            "sha": "5bc1e25bc4ac9a6e91f711c18bc4a0bad1ecc88b",
            "filename": "turbopack/crates/turbopack-trace-server/src/viewer.rs",
            "status": "modified",
            "additions": 33,
            "deletions": 15,
            "changes": 48,
            "blob_url": "https://github.com/vercel/next.js/blob/2374ee16b44c0ef27a137d03c75a958f7255916f/turbopack%2Fcrates%2Fturbopack-trace-server%2Fsrc%2Fviewer.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2374ee16b44c0ef27a137d03c75a958f7255916f/turbopack%2Fcrates%2Fturbopack-trace-server%2Fsrc%2Fviewer.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-trace-server%2Fsrc%2Fviewer.rs?ref=2374ee16b44c0ef27a137d03c75a958f7255916f",
            "patch": "@@ -10,7 +10,7 @@ use crate::{\n     server::ViewRect,\n     span_bottom_up_ref::SpanBottomUpRef,\n     span_graph_ref::{SpanGraphEventRef, SpanGraphRef},\n-    span_ref::SpanRef,\n+    span_ref::{SpanEventRef, SpanRef},\n     store::{SpanId, Store},\n     timestamp::Timestamp,\n     u64_empty_string,\n@@ -76,6 +76,17 @@ impl ValueMode {\n         }\n     }\n \n+    fn value_from_event(&self, event: &SpanEventRef<'_>) -> u64 {\n+        match self {\n+            ValueMode::Duration => *event.corrected_self_time(),\n+            ValueMode::Cpu => *event.total_time(),\n+            _ => match event {\n+                SpanEventRef::Child { span } => self.value_from_span(span),\n+                SpanEventRef::SelfTime { .. } => 0,\n+            },\n+        }\n+    }\n+\n     fn value_from_graph(&self, graph: &SpanGraphRef<'_>) -> u64 {\n         match self {\n             ValueMode::Duration => *graph.corrected_total_time(),\n@@ -651,24 +662,31 @@ impl Viewer {\n                         }\n                     } else if !selected_view_mode.aggregate_children() {\n                         let spans = if selected_view_mode.sort_children() {\n-                            Either::Left(span.children().sorted_by_cached_key(|child| {\n-                                Reverse(value_mode.value_from_span(child))\n+                            Either::Left(span.events().sorted_by_cached_key(|child| {\n+                                Reverse(value_mode.value_from_event(child))\n                             }))\n                         } else {\n-                            Either::Right(span.children().sorted_by_key(|child| child.start()))\n+                            Either::Right(span.events().sorted_by_key(|child| child.start()))\n                         };\n                         for child in spans {\n-                            let filtered = get_filter_mode(child.id());\n-                            add_child_item(\n-                                &mut children,\n-                                &mut current,\n-                                view_rect,\n-                                child_line_index,\n-                                view_mode,\n-                                value_mode,\n-                                QueueItem::Span(child),\n-                                filtered,\n-                            );\n+                            match child {\n+                                SpanEventRef::SelfTime { .. } => {\n+                                    current += value_mode.value_from_event(&child);\n+                                }\n+                                SpanEventRef::Child { span: child } => {\n+                                    let filtered = get_filter_mode(child.id());\n+                                    add_child_item(\n+                                        &mut children,\n+                                        &mut current,\n+                                        view_rect,\n+                                        child_line_index,\n+                                        view_mode,\n+                                        value_mode,\n+                                        QueueItem::Span(child),\n+                                        filtered,\n+                                    );\n+                                }\n+                            }\n                         }\n                     } else {\n                         let events = if selected_view_mode.sort_children() {"
        }
    ],
    "stats": {
        "total": 99,
        "additions": 80,
        "deletions": 19
    }
}