{
    "author": "bgw",
    "message": "Turbopack: Replace `current_value` set/restore mutation pattern with a safer `with_pat_value` helper (#81696)\n\nThe previous pattern of\n\n```\nself.current_value = Some(...);\n// visit children\nself.current_value = None;\n```\n\nfelt very dangerous to me, because it's too easy to not restore `current_value` (or accidentally clear it instead of restoring it), which could lead to really subtle bugs.\n\nThis wraps it with a helper method (`with_pat_value`) that stores the previous value and restores it after exit. It uses an inner module with private struct fields to prevent accidental direct mutation of the `pat_value`.\n\n### Renaming `current_value` to `pat_value`\n\nI decided to rename it to `pat_value`, as that's a little more specific to how it's used than `current_value`. It's still not a perfect name though because simple assignments are arguably not patterns.\n\n### Other places that could use this pattern\n\nThere are other fields that use this set/restore pattern (e.g. `early_return_stack`), so if accepted, I'll make more PRs to migrate those to this pattern as well.\n\n### Why not use a guard object?\n\nA guard object would need access to `&mut Analyzer` in order to reset the state upon drop. The guard object needs to be held across visiting children, which also requires `&mut Analyzer`. So we'd need two simultaneous mutable references.\n\nThis could be done with a `Rc<RefCell<...>>`, but that's not worth it.\n\n### Performance considerations\n\nThe analyzer is a hot codepath.\n\nThis may clear `pat_value` in a few more places than needed, e.g. inside of loops where we know the `pat_value` will immediately be overwritten anyways by the next iteration of the loop. But this shouldn't be a significant difference, and might get compiled away in some cases.\n\nI'm running the full benchmark suite just in case.",
    "sha": "f76e1dc7056b4d0a8d325ff51cf70f52779a8146",
    "files": [
        {
            "sha": "c6a03d9c8bf03a1d5de31348d19b7b48393ce5dc",
            "filename": "turbopack/crates/turbopack-ecmascript/src/analyzer/graph.rs",
            "status": "modified",
            "additions": 142,
            "deletions": 124,
            "changes": 266,
            "blob_url": "https://github.com/vercel/next.js/blob/f76e1dc7056b4d0a8d325ff51cf70f52779a8146/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fanalyzer%2Fgraph.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f76e1dc7056b4d0a8d325ff51cf70f52779a8146/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fanalyzer%2Fgraph.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fanalyzer%2Fgraph.rs?ref=f76e1dc7056b4d0a8d325ff51cf70f52779a8146",
            "patch": "@@ -280,12 +280,12 @@ pub fn create_graph(m: &Program, eval_context: &EvalContext) -> VarGraph {\n     m.visit_with_ast_path(\n         &mut Analyzer {\n             data: &mut graph,\n+            state: analyzer_state::AnalyzerState::new(),\n             eval_context,\n             effects: Default::default(),\n             hoisted_effects: Default::default(),\n             early_return_stack: Default::default(),\n             var_decl_kind: Default::default(),\n-            current_value: Default::default(),\n             cur_fn_return_values: Default::default(),\n             cur_fn_ident: Default::default(),\n         },\n@@ -756,6 +756,7 @@ pub fn as_parent_path_skip(\n \n struct Analyzer<'a> {\n     data: &'a mut VarGraph,\n+    state: analyzer_state::AnalyzerState,\n \n     effects: Vec<Effect>,\n     hoisted_effects: Vec<Effect>,\n@@ -765,10 +766,6 @@ struct Analyzer<'a> {\n \n     var_decl_kind: Option<VarDeclKind>,\n \n-    /// The RHS (or some part of it) of a pattern assignment, read by the individual parts of the\n-    /// pattern assignment.\n-    current_value: Option<JsValue>,\n-\n     /// Return values of the current function.\n     ///\n     /// This is configured to [Some] by function handlers and filled by the\n@@ -778,6 +775,48 @@ struct Analyzer<'a> {\n     cur_fn_ident: u32,\n }\n \n+mod analyzer_state {\n+    use super::*;\n+\n+    /// Contains fields of `Analyzer` that should only be modified using helper methods. These are\n+    /// intentionally private to the rest of the `Analyzer` implementation.\n+    pub struct AnalyzerState {\n+        pat_value: Option<JsValue>,\n+    }\n+\n+    impl AnalyzerState {\n+        pub fn new() -> AnalyzerState {\n+            AnalyzerState { pat_value: None }\n+        }\n+    }\n+\n+    impl Analyzer<'_> {\n+        /// The RHS (or some part of it) of an pattern or assignment (e.g. `PatAssignTarget`,\n+        /// `SimpleAssignTarget`, function arguments, etc.), read by the individual parts of LHS\n+        /// (target).\n+        ///\n+        /// Consumes the value, setting it to `None`, and returning the previous value. This avoids\n+        /// extra clones.\n+        pub(super) fn take_pat_value(&mut self) -> Option<JsValue> {\n+            self.state.pat_value.take()\n+        }\n+\n+        // Runs `func` (usually something that visits children) with the given\n+        // [`Analyzer::take_pat_value`], restoring the value back to the previous value (usually\n+        // `None`) afterwards.\n+        pub(super) fn with_pat_value<T>(\n+            &mut self,\n+            value: Option<JsValue>,\n+            func: impl FnOnce(&mut Self) -> T,\n+        ) -> T {\n+            let prev_value = replace(&mut self.state.pat_value, value);\n+            let out = func(self);\n+            self.state.pat_value = prev_value;\n+            out\n+        }\n+    }\n+}\n+\n pub fn as_parent_path(ast_path: &AstNodePath<AstParentNodeRef<'_>>) -> Vec<AstParentKind> {\n     ast_path.iter().map(|n| n.kind()).collect()\n }\n@@ -965,13 +1004,8 @@ impl Analyzer<'_> {\n                 arrow_expr,\n                 ArrowExprField::Params(i),\n             ));\n-            if let Some(arg) = iter.next() {\n-                self.current_value = Some(self.eval_context.eval(&arg.expr));\n-                self.visit_pat(param, &mut ast_path);\n-                self.current_value = None;\n-            } else {\n-                self.visit_pat(param, &mut ast_path);\n-            }\n+            let pat_value = iter.next().map(|arg| self.eval_context.eval(&arg.expr));\n+            self.with_pat_value(pat_value, |this| this.visit_pat(param, &mut ast_path));\n         }\n         {\n             let mut ast_path = ast_path.with_guard(AstParentNodeRef::ArrowExpr(\n@@ -1022,9 +1056,9 @@ impl Analyzer<'_> {\n                 FunctionField::Params(i),\n             ));\n             if let Some(arg) = iter.next() {\n-                self.current_value = Some(self.eval_context.eval(&arg.expr));\n-                self.visit_param(param, &mut ast_path);\n-                self.current_value = None;\n+                self.with_pat_value(Some(self.eval_context.eval(&arg.expr)), |this| {\n+                    this.visit_param(param, &mut ast_path)\n+                });\n             } else {\n                 self.visit_param(param, &mut ast_path);\n             }\n@@ -1326,47 +1360,30 @@ impl VisitAstPath for Analyzer<'_> {\n         n: &'ast AssignExpr,\n         ast_path: &mut AstNodePath<AstParentNodeRef<'r>>,\n     ) {\n+        // LHS\n         {\n             let mut ast_path =\n                 ast_path.with_guard(AstParentNodeRef::AssignExpr(n, AssignExprField::Left));\n \n-            match n.op {\n-                AssignOp::Assign => {\n-                    self.current_value = Some(self.eval_context.eval(&n.right));\n-                    n.left.visit_children_with_ast_path(self, &mut ast_path);\n-                    self.current_value = None;\n+            let pat_value = match (n.op, n.left.as_ident()) {\n+                (AssignOp::Assign, _) => self.eval_context.eval(&n.right),\n+                (AssignOp::AndAssign | AssignOp::OrAssign | AssignOp::NullishAssign, Some(_)) => {\n+                    // We can handle the right value as alternative to the existing value\n+                    self.eval_context.eval(&n.right)\n                 }\n-\n-                _ => {\n-                    if let Some(key) = n.left.as_ident() {\n-                        let value = match n.op {\n-                            AssignOp::AndAssign | AssignOp::OrAssign | AssignOp::NullishAssign => {\n-                                // We can handle the right value as alternative to the existing\n-                                // value\n-                                self.eval_context.eval(&n.right)\n-                            }\n-                            AssignOp::AddAssign => {\n-                                let left = self.eval_context.eval(&Expr::Ident(key.clone().into()));\n-\n-                                let right = self.eval_context.eval(&n.right);\n-\n-                                JsValue::add(vec![left, right])\n-                            }\n-                            _ => JsValue::unknown_empty(true, \"unsupported assign operation\"),\n-                        };\n-                        // We should visit this to handle `+=` like\n-                        //\n-                        // clientComponentLoadTimes += performance.now() - startTime\n-                        self.current_value = Some(value);\n-                        n.left.visit_children_with_ast_path(self, &mut ast_path);\n-                        self.current_value = None;\n-                    } else {\n-                        n.left.visit_children_with_ast_path(self, &mut ast_path);\n-                    }\n+                (AssignOp::AddAssign, Some(key)) => {\n+                    let left = self.eval_context.eval(&Expr::Ident(key.clone().into()));\n+                    let right = self.eval_context.eval(&n.right);\n+                    JsValue::add(vec![left, right])\n                 }\n-            }\n+                _ => JsValue::unknown_empty(true, \"unsupported assign operation\"),\n+            };\n+            self.with_pat_value(Some(pat_value), |this| {\n+                n.left.visit_children_with_ast_path(this, &mut ast_path)\n+            });\n         }\n \n+        // RHS\n         {\n             let mut ast_path =\n                 ast_path.with_guard(AstParentNodeRef::AssignExpr(n, AssignExprField::Right));\n@@ -1480,13 +1497,12 @@ impl VisitAstPath for Analyzer<'_> {\n         n: &'ast [Param],\n         ast_path: &mut AstNodePath<AstParentNodeRef<'r>>,\n     ) {\n-        let value = self.current_value.take();\n         for (index, p) in n.iter().enumerate() {\n-            self.current_value = Some(JsValue::Argument(self.cur_fn_ident, index));\n-            let mut ast_path = ast_path.with_index_guard(index);\n-            p.visit_with_ast_path(self, &mut ast_path);\n+            self.with_pat_value(Some(JsValue::Argument(self.cur_fn_ident, index)), |this| {\n+                let mut ast_path = ast_path.with_index_guard(index);\n+                p.visit_with_ast_path(this, &mut ast_path);\n+            });\n         }\n-        self.current_value = value;\n     }\n \n     fn visit_param<'ast: 'r, 'r>(\n@@ -1501,20 +1517,17 @@ impl VisitAstPath for Analyzer<'_> {\n             span: _,\n         } = n;\n         self.var_decl_kind = None;\n-        let value = self.current_value.take();\n-        {\n+        self.with_pat_value(None, |this| {\n             let mut ast_path = ast_path.with_guard(AstParentNodeRef::Param(\n                 n,\n                 ParamField::Decorators(usize::MAX),\n             ));\n-            self.visit_decorators(decorators, &mut ast_path);\n-        }\n-        self.current_value = value;\n+            this.visit_decorators(decorators, &mut ast_path);\n+        });\n         {\n             let mut ast_path = ast_path.with_guard(AstParentNodeRef::Param(n, ParamField::Pat));\n             self.visit_pat(pat, &mut ast_path);\n         }\n-        self.current_value = None;\n         self.var_decl_kind = old;\n     }\n \n@@ -1587,16 +1600,15 @@ impl VisitAstPath for Analyzer<'_> {\n         let old_ident = self.cur_fn_ident;\n         self.cur_fn_ident = expr.span.lo.0;\n \n-        let value = self.current_value.take();\n         for (index, p) in expr.params.iter().enumerate() {\n-            self.current_value = Some(JsValue::Argument(self.cur_fn_ident, index));\n-            let mut ast_path = ast_path.with_guard(AstParentNodeRef::ArrowExpr(\n-                expr,\n-                ArrowExprField::Params(index),\n-            ));\n-            p.visit_with_ast_path(self, &mut ast_path);\n+            self.with_pat_value(Some(JsValue::Argument(self.cur_fn_ident, index)), |this| {\n+                let mut ast_path = ast_path.with_guard(AstParentNodeRef::ArrowExpr(\n+                    expr,\n+                    ArrowExprField::Params(index),\n+                ));\n+                p.visit_with_ast_path(this, &mut ast_path);\n+            });\n         }\n-        self.current_value = value;\n \n         {\n             let mut ast_path =\n@@ -1653,38 +1665,47 @@ impl VisitAstPath for Analyzer<'_> {\n         n: &'ast VarDeclarator,\n         ast_path: &mut AstNodePath<AstParentNodeRef<'r>>,\n     ) {\n-        if self.var_decl_kind.is_some()\n-            && let Some(init) = &n.init\n-        {\n-            // For case like\n-            //\n-            // if (shouldRun()) {\n-            //   var x = true;\n-            // }\n-            // if (x) {\n-            // }\n-            //\n-            // The variable `x` is undefined\n-\n-            let should_include_undefined = matches!(self.var_decl_kind, Some(VarDeclKind::Var))\n-                && is_lexically_block_scope(ast_path);\n-            let init_value = self.eval_context.eval(init);\n-            self.current_value = Some(if should_include_undefined {\n-                JsValue::alternatives(vec![\n-                    init_value,\n-                    JsValue::Constant(ConstantValue::Undefined),\n-                ])\n-            } else {\n-                init_value\n-            });\n-        }\n+        // LHS\n         {\n             let mut ast_path =\n                 ast_path.with_guard(AstParentNodeRef::VarDeclarator(n, VarDeclaratorField::Name));\n \n-            self.visit_pat(&n.name, &mut ast_path);\n+            if self.var_decl_kind.is_some()\n+                && let Some(init) = &n.init\n+            {\n+                // For case like\n+                //\n+                // if (shouldRun()) {\n+                //   var x = true;\n+                // }\n+                // if (x) {\n+                // }\n+                //\n+                // The variable `x` is undefined\n+\n+                let should_include_undefined = matches!(self.var_decl_kind, Some(VarDeclKind::Var))\n+                    && is_lexically_block_scope(&mut ast_path);\n+                let init_value = self.eval_context.eval(init);\n+                let pat_value = Some(if should_include_undefined {\n+                    JsValue::alternatives(vec![\n+                        init_value,\n+                        JsValue::Constant(ConstantValue::Undefined),\n+                    ])\n+                } else {\n+                    init_value\n+                });\n+                self.with_pat_value(pat_value, |this| {\n+                    this.visit_pat(&n.name, &mut ast_path);\n+                });\n+            } else {\n+                // Don't use `with_pat_value(None, ...)` here. A `VarDecl` can occur inside of a\n+                // `ForOfStmt` with no `init` field, but still have a `pat_value` set that we want\n+                // to inherit.\n+                self.visit_pat(&n.name, &mut ast_path);\n+            }\n         }\n-        self.current_value = None;\n+\n+        // RHS\n         {\n             let mut ast_path =\n                 ast_path.with_guard(AstParentNodeRef::VarDeclarator(n, VarDeclaratorField::Init));\n@@ -1701,18 +1722,16 @@ impl VisitAstPath for Analyzer<'_> {\n         {\n             let mut ast_path =\n                 ast_path.with_guard(AstParentNodeRef::ForOfStmt(n, ForOfStmtField::Right));\n-            self.current_value = None;\n             self.visit_expr(&n.right, &mut ast_path);\n         }\n \n         let array = self.eval_context.eval(&n.right);\n \n-        {\n+        self.with_pat_value(Some(JsValue::iterated(Box::new(array))), |this| {\n             let mut ast_path =\n                 ast_path.with_guard(AstParentNodeRef::ForOfStmt(n, ForOfStmtField::Left));\n-            self.current_value = Some(JsValue::iterated(Box::new(array)));\n-            self.visit_for_head(&n.left, &mut ast_path);\n-        }\n+            this.visit_for_head(&n.left, &mut ast_path);\n+        });\n \n         let mut ast_path =\n             ast_path.with_guard(AstParentNodeRef::ForOfStmt(n, ForOfStmtField::Body));\n@@ -1725,7 +1744,7 @@ impl VisitAstPath for Analyzer<'_> {\n         n: &'ast SimpleAssignTarget,\n         ast_path: &mut swc_core::ecma::visit::AstNodePath<'r>,\n     ) {\n-        let value = self.current_value.take();\n+        let value = self.take_pat_value();\n         if let SimpleAssignTarget::Ident(i) = n {\n             n.visit_children_with_ast_path(self, ast_path);\n \n@@ -1747,8 +1766,7 @@ impl VisitAstPath for Analyzer<'_> {\n         ast_path: &mut AstNodePath<AstParentNodeRef<'r>>,\n     ) {\n         let value = self\n-            .current_value\n-            .take()\n+            .take_pat_value()\n             .unwrap_or_else(|| JsValue::unknown_empty(false, \"pattern without value\"));\n         match pat {\n             AssignTargetPat::Array(arr) => {\n@@ -1774,7 +1792,7 @@ impl VisitAstPath for Analyzer<'_> {\n         pat: &'ast Pat,\n         ast_path: &mut AstNodePath<AstParentNodeRef<'r>>,\n     ) {\n-        let value = self.current_value.take();\n+        let value = self.take_pat_value();\n         match pat {\n             Pat::Ident(i) => {\n                 self.add_value(\n@@ -2362,10 +2380,10 @@ impl Analyzer<'_> {\n     fn handle_array_pat_with_value<'ast: 'r, 'r>(\n         &mut self,\n         arr: &'ast ArrayPat,\n-        current_value: JsValue,\n+        pat_value: JsValue,\n         ast_path: &mut AstNodePath<AstParentNodeRef<'r>>,\n     ) {\n-        match current_value {\n+        match pat_value {\n             JsValue::Array { items, .. } => {\n                 for (idx, (elem_pat, value_item)) in arr\n                     .elems\n@@ -2375,23 +2393,26 @@ impl Analyzer<'_> {\n                     .zip(items.into_iter().map(Some).chain(iter::repeat(None)))\n                     .enumerate()\n                 {\n-                    self.current_value = value_item;\n-                    let mut ast_path = ast_path\n-                        .with_guard(AstParentNodeRef::ArrayPat(arr, ArrayPatField::Elems(idx)));\n-                    elem_pat.visit_with_ast_path(self, &mut ast_path);\n+                    self.with_pat_value(value_item, |this| {\n+                        let mut ast_path = ast_path\n+                            .with_guard(AstParentNodeRef::ArrayPat(arr, ArrayPatField::Elems(idx)));\n+                        elem_pat.visit_with_ast_path(this, &mut ast_path);\n+                    });\n                 }\n             }\n             value => {\n                 for (idx, elem) in arr.elems.iter().enumerate() {\n-                    self.current_value = Some(JsValue::member(\n+                    let pat_value = Some(JsValue::member(\n                         Box::new(value.clone()),\n                         Box::new(JsValue::Constant(ConstantValue::Num(ConstantNumber(\n                             idx as f64,\n                         )))),\n                     ));\n-                    let mut ast_path = ast_path\n-                        .with_guard(AstParentNodeRef::ArrayPat(arr, ArrayPatField::Elems(idx)));\n-                    elem.visit_with_ast_path(self, &mut ast_path);\n+                    self.with_pat_value(pat_value, |this| {\n+                        let mut ast_path = ast_path\n+                            .with_guard(AstParentNodeRef::ArrayPat(arr, ArrayPatField::Elems(idx)));\n+                        elem.visit_with_ast_path(this, &mut ast_path);\n+                    });\n                 }\n             }\n         }\n@@ -2400,7 +2421,7 @@ impl Analyzer<'_> {\n     fn handle_object_pat_with_value<'ast: 'r, 'r>(\n         &mut self,\n         obj: &'ast ObjectPat,\n-        current_value: JsValue,\n+        pat_value: JsValue,\n         ast_path: &mut AstNodePath<AstParentNodeRef<'r>>,\n     ) {\n         for (i, prop) in obj.props.iter().enumerate() {\n@@ -2421,17 +2442,17 @@ impl Analyzer<'_> {\n                         ));\n                         key.visit_with_ast_path(self, &mut ast_path);\n                     }\n-                    self.current_value = Some(JsValue::member(\n-                        Box::new(current_value.clone()),\n+                    let pat_value = Some(JsValue::member(\n+                        Box::new(pat_value.clone()),\n                         Box::new(key_value),\n                     ));\n-                    {\n+                    self.with_pat_value(pat_value, |this| {\n                         let mut ast_path = ast_path.with_guard(AstParentNodeRef::KeyValuePatProp(\n                             kv,\n                             KeyValuePatPropField::Value,\n                         ));\n-                        value.visit_with_ast_path(self, &mut ast_path);\n-                    }\n+                        value.visit_with_ast_path(this, &mut ast_path);\n+                    });\n                 }\n                 ObjectPatProp::Assign(assign) => {\n                     let mut ast_path = ast_path.with_guard(AstParentNodeRef::ObjectPatProp(\n@@ -2452,14 +2473,11 @@ impl Analyzer<'_> {\n                         if let Some(box value) = value {\n                             let value = self.eval_context.eval(value);\n                             JsValue::alternatives(vec![\n-                                JsValue::member(\n-                                    Box::new(current_value.clone()),\n-                                    Box::new(key_value),\n-                                ),\n+                                JsValue::member(Box::new(pat_value.clone()), Box::new(key_value)),\n                                 value,\n                             ])\n                         } else {\n-                            JsValue::member(Box::new(current_value.clone()), Box::new(key_value))\n+                            JsValue::member(Box::new(pat_value.clone()), Box::new(key_value))\n                         },\n                     );\n                     {"
        }
    ],
    "stats": {
        "total": 266,
        "additions": 142,
        "deletions": 124
    }
}