{
    "author": "lukesandberg",
    "message": "[turbopack] Remove unused no_move_vec code (#81141)\n\nA `pub use` statement was obscuring that half the code is dead.",
    "sha": "f5c9910881a1547074ef035dfc41d40667975c71",
    "files": [
        {
            "sha": "f16b4d38a1a97251ffb53e2acbebc988d73e2cb8",
            "filename": "turbopack/crates/turbo-tasks/src/no_move_vec.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 107,
            "changes": 107,
            "blob_url": "https://github.com/vercel/next.js/blob/f5c9910881a1547074ef035dfc41d40667975c71/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fno_move_vec.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f5c9910881a1547074ef035dfc41d40667975c71/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fno_move_vec.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fno_move_vec.rs?ref=f5c9910881a1547074ef035dfc41d40667975c71",
            "patch": "@@ -46,25 +46,6 @@ impl<T> COption<T> {\n             COption::Some(t) => Some(t),\n         }\n     }\n-\n-    /// Takes the value out of the option, leaving a `None` in its place.\n-    fn take(&mut self) -> Option<T> {\n-        match std::mem::take(self) {\n-            COption::None => None,\n-            COption::Some(t) => Some(t),\n-        }\n-    }\n-}\n-\n-impl<T: Default> COption<T> {\n-    /// Returns a slice of the given size filled with the `Some` variant and\n-    /// filled with default values.\n-    fn new_default_slice(size: usize) -> Box<[Self]> {\n-        (0..size)\n-            .map(|_| COption::Some(Default::default()))\n-            .collect::<Vec<_>>()\n-            .into_boxed_slice()\n-    }\n }\n \n pub struct NoMoveVec<T, const INITIAL_CAPACITY_BITS: u32 = 6> {\n@@ -98,15 +79,6 @@ fn allocate_bucket<const INITIAL_CAPACITY_BITS: u32, T>(bucket_index: u32) -> *m\n     Box::into_raw(slice) as *mut COption<T>\n }\n \n-/// Allocates a new bucket of `COption<T>`s, all initialized to `None`.\n-fn allocate_default_bucket<const INITIAL_CAPACITY_BITS: u32, T: Default>(\n-    bucket_index: u32,\n-) -> *mut COption<T> {\n-    let size = get_bucket_size::<INITIAL_CAPACITY_BITS>(bucket_index);\n-    let slice = COption::<T>::new_default_slice(size);\n-    Box::into_raw(slice) as *mut COption<T>\n-}\n-\n impl<T, const INITIAL_CAPACITY_BITS: u32> Default for NoMoveVec<T, INITIAL_CAPACITY_BITS> {\n     fn default() -> Self {\n         Self::new()\n@@ -133,23 +105,6 @@ impl<T, const INITIAL_CAPACITY_BITS: u32> NoMoveVec<T, INITIAL_CAPACITY_BITS> {\n         unsafe { &*bucket_ptr.add(index) }.as_option_ref()\n     }\n \n-    /// # Safety\n-    /// There must not be a concurrent operation to this idx\n-    pub unsafe fn take(&self, idx: usize) -> Option<T> {\n-        let bucket_idx = get_bucket_index::<INITIAL_CAPACITY_BITS>(idx);\n-        let bucket = unsafe { self.buckets.get_unchecked(bucket_idx as usize) };\n-        let bucket_ptr = bucket.0.load(Ordering::Acquire);\n-        if bucket_ptr.is_null() {\n-            return None;\n-        }\n-        let index = get_index_in_bucket::<INITIAL_CAPACITY_BITS>(idx, bucket_idx);\n-        let item = unsafe { &mut *bucket_ptr.add(index) };\n-        let item = item.take();\n-        // To sync with any acquire load of the bucket ptr\n-        bucket.0.store(bucket_ptr, Ordering::Release);\n-        item\n-    }\n-\n     /// # Safety\n     /// There must not be a concurrent operation to this idx\n     pub unsafe fn insert(&self, idx: usize, value: T) -> &T {\n@@ -190,68 +145,6 @@ impl<T, const INITIAL_CAPACITY_BITS: u32> NoMoveVec<T, INITIAL_CAPACITY_BITS> {\n         bucket.0.store(bucket_ptr, Ordering::Release);\n         item.as_option_ref().unwrap()\n     }\n-\n-    /// # Safety\n-    /// There must not be a concurrent operation to this idx\n-    pub unsafe fn remove(&self, idx: usize) {\n-        let bucket_idx = get_bucket_index::<INITIAL_CAPACITY_BITS>(idx);\n-        let bucket = unsafe { self.buckets.get_unchecked(bucket_idx as usize) };\n-        let bucket_ptr = bucket.0.load(Ordering::Acquire);\n-        if bucket_ptr.is_null() {\n-            return;\n-        }\n-        let index = get_index_in_bucket::<INITIAL_CAPACITY_BITS>(idx, bucket_idx);\n-        let item = unsafe { &mut *bucket_ptr.add(index) };\n-        *item = COption::None;\n-        // To sync with any acquire load of the bucket ptr\n-        bucket.0.store(bucket_ptr, Ordering::Release);\n-    }\n-}\n-\n-impl<T: Default, const INITIAL_CAPACITY_BITS: u32> NoMoveVec<T, INITIAL_CAPACITY_BITS> {\n-    pub fn new_init_default() -> Self {\n-        let mut buckets = [null_mut(); BUCKETS];\n-        buckets[0] = allocate_default_bucket::<INITIAL_CAPACITY_BITS, T>(0);\n-        let buckets = buckets.map(|p| (AtomicPtr::new(p), Mutex::new(())));\n-        NoMoveVec { buckets }\n-    }\n-\n-    pub fn get_init_default(&self, idx: usize) -> &T {\n-        let bucket_idx = get_bucket_index::<INITIAL_CAPACITY_BITS>(idx);\n-        let bucket = unsafe { self.buckets.get_unchecked(bucket_idx as usize) };\n-        // SAFETY: This is safe to be relaxed as the bucket will never become null\n-        // again. We perform a acquire load when it's null.\n-        let mut bucket_ptr = bucket.0.load(Ordering::Relaxed);\n-        if bucket_ptr.is_null() {\n-            bucket_ptr = bucket.0.load(Ordering::Acquire);\n-            if bucket_ptr.is_null() {\n-                let lock = bucket.1.lock();\n-                let guarded_bucket_ptr = bucket.0.load(Ordering::Acquire);\n-                if guarded_bucket_ptr.is_null() {\n-                    let new_bucket =\n-                        allocate_default_bucket::<INITIAL_CAPACITY_BITS, T>(bucket_idx);\n-                    bucket_ptr = match bucket.0.compare_exchange(\n-                        null_mut(),\n-                        new_bucket,\n-                        Ordering::AcqRel,\n-                        Ordering::Relaxed,\n-                    ) {\n-                        Ok(_) => new_bucket,\n-                        Err(current_bucket) => {\n-                            drop(unsafe { Box::from_raw(new_bucket) });\n-                            current_bucket\n-                        }\n-                    };\n-                    drop(lock);\n-                } else {\n-                    bucket_ptr = guarded_bucket_ptr;\n-                }\n-            }\n-        }\n-        let index = get_index_in_bucket::<INITIAL_CAPACITY_BITS>(idx, bucket_idx);\n-        let value = unsafe { &*bucket_ptr.add(index) }.as_option_ref();\n-        value.expect(\"get_init_default must not be combined with normal insert\")\n-    }\n }\n \n impl<T, const INITIAL_CAPACITY_BITS: u32> Drop for NoMoveVec<T, INITIAL_CAPACITY_BITS> {"
        },
        {
            "sha": "bb39dff895224536707b0d102112288283d05fd1",
            "filename": "turbopack/crates/turbo-tasks/src/util.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/f5c9910881a1547074ef035dfc41d40667975c71/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Futil.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f5c9910881a1547074ef035dfc41d40667975c71/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Futil.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Futil.rs?ref=f5c9910881a1547074ef035dfc41d40667975c71",
            "patch": "@@ -16,7 +16,6 @@ use serde::{Deserialize, Deserializer, Serialize, Serializer};\n \n pub use super::{\n     id_factory::{IdFactory, IdFactoryWithReuse},\n-    no_move_vec::NoMoveVec,\n     once_map::*,\n };\n "
        }
    ],
    "stats": {
        "total": 108,
        "additions": 0,
        "deletions": 108
    }
}