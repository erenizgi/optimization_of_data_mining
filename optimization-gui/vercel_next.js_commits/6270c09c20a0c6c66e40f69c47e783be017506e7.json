{
    "author": "acdlite",
    "message": "Refactor: Unify history traversal with other nav types (#87128)\n\nThis merges the logic inside updateCacheNodeOnPopstateRestoration into\nthe function used for all other navigation types.\n\nThe main difference between history traversal navigations and other\nnavigation types is our treatment of dynamic data. History traversal\noperations are allowed to reuse dynamic data regardless of its freshness\nor staleness. So I've updated the `shouldRefreshDynamicData` argument to\nbe an enum that accounts for our various freshness policies. As of now,\nthere are three: Default, HistoryTraversal, and RefreshAll.\n\nThis is part of an ongoing series of refactors to unify all navigation\ntypes into a single flow, both to simplify the implementation, and to\nensure the behavior is consistent.",
    "sha": "6270c09c20a0c6c66e40f69c47e783be017506e7",
    "files": [
        {
            "sha": "40107bd346705fce1bd8680be4403740125dc922",
            "filename": "packages/next/src/client/components/router-reducer/ppr-navigations.ts",
            "status": "modified",
            "additions": 108,
            "deletions": 97,
            "changes": 205,
            "blob_url": "https://github.com/vercel/next.js/blob/6270c09c20a0c6c66e40f69c47e783be017506e7/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fppr-navigations.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/6270c09c20a0c6c66e40f69c47e783be017506e7/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fppr-navigations.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fppr-navigations.ts?ref=6270c09c20a0c6c66e40f69c47e783be017506e7",
            "patch": "@@ -50,6 +50,12 @@ export type NavigationTask = {\n   children: Map<string, NavigationTask> | null\n }\n \n+export const enum FreshnessPolicy {\n+  Default,\n+  HistoryTraversal,\n+  RefreshAll,\n+}\n+\n export type NavigationRequestAccumulation = {\n   scrollableSegments: Array<FlightSegmentPath> | null\n   separateRefreshUrls: Set<string> | null\n@@ -90,7 +96,7 @@ export function startPPRNavigation(\n   oldCacheNode: CacheNode | null,\n   oldRouterState: FlightRouterState,\n   newRouterState: FlightRouterState,\n-  shouldRefreshDynamicData: boolean,\n+  freshness: FreshnessPolicy,\n   seedData: CacheNodeSeedData | null,\n   seedHead: HeadData | null,\n   prefetchData: CacheNodeSeedData | null,\n@@ -108,7 +114,7 @@ export function startPPRNavigation(\n     oldCacheNode !== null ? oldCacheNode : undefined,\n     oldRouterState,\n     newRouterState,\n-    shouldRefreshDynamicData,\n+    freshness,\n     didFindRootLayout,\n     seedData,\n     seedHead,\n@@ -130,7 +136,7 @@ function updateCacheNodeOnNavigation(\n   oldCacheNode: CacheNode | void,\n   oldRouterState: FlightRouterState,\n   newRouterState: FlightRouterState,\n-  shouldRefreshDynamicData: boolean,\n+  freshness: FreshnessPolicy,\n   didFindRootLayout: boolean,\n   seedData: CacheNodeSeedData | null,\n   seedHead: HeadData | null,\n@@ -198,7 +204,7 @@ function updateCacheNodeOnNavigation(\n       navigatedAt,\n       newRouterState,\n       oldCacheNode,\n-      shouldRefreshDynamicData,\n+      freshness,\n       seedData,\n       seedHead,\n       prefetchData,\n@@ -247,8 +253,26 @@ function updateCacheNodeOnNavigation(\n   // leak. We should figure out a better model for the lifetime of inactive\n   // segments, so we can maintain instant back/forward navigations without\n   // leaking memory indefinitely.\n+  let shouldDropSiblingCaches: boolean = false\n+  let shouldRefreshDynamicData: boolean = false\n+  switch (freshness) {\n+    case FreshnessPolicy.Default:\n+    case FreshnessPolicy.HistoryTraversal:\n+      // We should never drop dynamic data in shared layouts, except during\n+      // a refresh.\n+      shouldDropSiblingCaches = false\n+      shouldRefreshDynamicData = false\n+      break\n+    case FreshnessPolicy.RefreshAll:\n+      shouldDropSiblingCaches = true\n+      shouldRefreshDynamicData = true\n+      break\n+    default:\n+      freshness satisfies never\n+      break\n+  }\n   const newParallelRoutes = new Map(\n-    shouldRefreshDynamicData ? undefined : oldParallelRoutes\n+    shouldDropSiblingCaches ? undefined : oldParallelRoutes\n   )\n \n   // TODO: We're not consistent about how we do this check. Some places\n@@ -271,7 +295,12 @@ function updateCacheNodeOnNavigation(\n     !(isLeafSegment && isSamePageNavigation)\n   ) {\n     // Reuse the existing CacheNode\n-    newCacheNode = reuseDynamicCacheNode(oldCacheNode, newParallelRoutes)\n+    const dropPrefetchRsc = false\n+    newCacheNode = reuseDynamicCacheNode(\n+      dropPrefetchRsc,\n+      oldCacheNode,\n+      newParallelRoutes\n+    )\n     needsDynamicRequest = false\n   } else if (seedData !== null) {\n     // If this navigation was the result of an action, then check if the\n@@ -431,7 +460,7 @@ function updateCacheNodeOnNavigation(\n       oldCacheNodeChild,\n       oldRouterStateChild,\n       newRouterStateChild,\n-      shouldRefreshDynamicData,\n+      freshness,\n       childDidFindRootLayout,\n       seedDataChild ?? null,\n       seedHeadChild,\n@@ -461,7 +490,7 @@ function updateCacheNodeOnNavigation(\n     const newCacheNodeChild = taskChild.node\n     if (newCacheNodeChild !== null) {\n       const newSegmentMapChild: ChildSegmentMap = new Map(\n-        shouldRefreshDynamicData ? undefined : oldSegmentMapChild\n+        shouldDropSiblingCaches ? undefined : oldSegmentMapChild\n       )\n       newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild)\n       newParallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n@@ -511,7 +540,7 @@ function createCacheNodeOnNavigation(\n   navigatedAt: number,\n   newRouterState: FlightRouterState,\n   oldCacheNode: CacheNode | void,\n-  shouldRefreshDynamicData: boolean,\n+  freshness: FreshnessPolicy,\n   seedData: CacheNodeSeedData | null,\n   seedHead: HeadData | null,\n   prefetchData: CacheNodeSeedData | null,\n@@ -543,8 +572,66 @@ function createCacheNodeOnNavigation(\n   const seedDataChildren = seedData !== null ? seedData[1] : null\n   const oldParallelRoutes =\n     oldCacheNode !== undefined ? oldCacheNode.parallelRoutes : undefined\n+\n+  let shouldDropSiblingCaches: boolean = false\n+  let shouldRefreshDynamicData: boolean = false\n+  let dropPrefetchRsc: boolean = false\n+  switch (freshness) {\n+    case FreshnessPolicy.Default:\n+      // We should never drop dynamic data in sibling caches except during\n+      // a refresh.\n+      shouldDropSiblingCaches = false\n+\n+      // Only reuse the dynamic data if experimental.staleTimes.dynamic config\n+      // is set, and the data is not stale. (This is not a recommended API with\n+      // Cache Components, but it's supported for backwards compatibility. Use\n+      // cacheLife instead.)\n+      //\n+      // DYNAMIC_STALETIME_MS defaults to 0, but it can be increased.\n+      shouldRefreshDynamicData =\n+        oldCacheNode === undefined ||\n+        navigatedAt - oldCacheNode.navigatedAt >= DYNAMIC_STALETIME_MS\n+\n+      dropPrefetchRsc = false\n+      break\n+    case FreshnessPolicy.HistoryTraversal:\n+      // During back/forward navigations, we reuse the dynamic data regardless\n+      // of how stale it may be.\n+      shouldRefreshDynamicData = false\n+      shouldRefreshDynamicData = false\n+\n+      // Only show prefetched data if the dynamic data is still pending. This\n+      // avoids a flash back to the prefetch state in a case where it's highly\n+      // likely to have already streamed in.\n+      //\n+      // Tehnically, what we're actually checking is whether the dynamic network\n+      // response was received. But since it's a streaming response, this does\n+      // not mean that all the dynamic data has fully streamed in. It just means\n+      // that _some_ of the dynamic data was received. But as a heuristic, we\n+      // assume that the rest dynamic data will stream in quickly, so it's still\n+      // better to skip the prefetch state.\n+      if (oldCacheNode !== undefined) {\n+        const oldRsc = oldCacheNode.rsc\n+        const oldRscDidResolve =\n+          !isDeferredRsc(oldRsc) || oldRsc.status !== 'pending'\n+        dropPrefetchRsc = oldRscDidResolve\n+      } else {\n+        dropPrefetchRsc = false\n+      }\n+      break\n+    case FreshnessPolicy.RefreshAll:\n+      // Drop all dynamic data.\n+      shouldRefreshDynamicData = true\n+      shouldDropSiblingCaches = true\n+      dropPrefetchRsc = false\n+      break\n+    default:\n+      freshness satisfies never\n+      break\n+  }\n+\n   const newParallelRoutes = new Map(\n-    shouldRefreshDynamicData ? undefined : oldParallelRoutes\n+    shouldDropSiblingCaches ? undefined : oldParallelRoutes\n   )\n   const isLeafSegment = Object.keys(newRouterStateChildren).length === 0\n \n@@ -566,20 +653,13 @@ function createCacheNodeOnNavigation(\n \n   let newCacheNode: ReadyCacheNode\n   let needsDynamicRequest: boolean\n-  if (\n-    !shouldRefreshDynamicData &&\n-    oldCacheNode !== undefined &&\n-    // DYNAMIC_STALETIME_MS defaults to 0, but it can be increased using\n-    // the experimental.staleTimes.dynamic config. When set, we'll avoid\n-    // refetching dynamic data if it was fetched within the given threshold.\n-    // TODO: We should use this same logic for popstate navigations, replacing\n-    // the `updateCacheNodeOnPopstateRestoration` function. That way we can\n-    // handle the case where the data is missing here, like we would for a\n-    // normal navigation, rather than rely on the lazy fetch in LazyRouter.\n-    oldCacheNode.navigatedAt + DYNAMIC_STALETIME_MS > navigatedAt\n-  ) {\n+  if (!shouldRefreshDynamicData && oldCacheNode !== undefined) {\n     // Reuse the existing CacheNode\n-    newCacheNode = reuseDynamicCacheNode(oldCacheNode, newParallelRoutes)\n+    newCacheNode = reuseDynamicCacheNode(\n+      dropPrefetchRsc,\n+      oldCacheNode,\n+      newParallelRoutes\n+    )\n     needsDynamicRequest = false\n   } else if (seedData !== null) {\n     // If this navigation was the result of an action, then check if the\n@@ -666,7 +746,7 @@ function createCacheNodeOnNavigation(\n       navigatedAt,\n       newRouterStateChild,\n       oldCacheNodeChild,\n-      shouldRefreshDynamicData,\n+      freshness,\n       seedDataChild ?? null,\n       seedHead,\n       prefetchDataChild ?? null,\n@@ -685,7 +765,7 @@ function createCacheNodeOnNavigation(\n     const newCacheNodeChild = taskChild.node\n     if (newCacheNodeChild !== null) {\n       const newSegmentMapChild: ChildSegmentMap = new Map(\n-        shouldRefreshDynamicData ? undefined : oldSegmentMapChild\n+        shouldDropSiblingCaches ? undefined : oldSegmentMapChild\n       )\n       newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild)\n       newParallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n@@ -837,16 +917,17 @@ function reuseActiveSegmentInDefaultSlot(\n }\n \n function reuseDynamicCacheNode(\n+  dropPrefetchRsc: boolean,\n   existingCacheNode: CacheNode,\n   parallelRoutes: Map<string, ChildSegmentMap>\n ): ReadyCacheNode {\n   // Clone an existing CacheNode's data, with (possibly) new children.\n   const cacheNode: ReadyCacheNode = {\n     lazyData: null,\n     rsc: existingCacheNode.rsc,\n-    prefetchRsc: existingCacheNode.prefetchRsc,\n+    prefetchRsc: dropPrefetchRsc ? null : existingCacheNode.prefetchRsc,\n     head: existingCacheNode.head,\n-    prefetchHead: existingCacheNode.prefetchHead,\n+    prefetchHead: dropPrefetchRsc ? null : existingCacheNode.prefetchHead,\n     loading: existingCacheNode.loading,\n \n     parallelRoutes,\n@@ -1399,76 +1480,6 @@ function abortPendingCacheNode(\n   }\n }\n \n-export function updateCacheNodeOnPopstateRestoration(\n-  oldCacheNode: CacheNode,\n-  routerState: FlightRouterState\n-): ReadyCacheNode {\n-  // A popstate navigation reads data from the local cache. It does not issue\n-  // new network requests (unless the cache entries have been evicted). So, we\n-  // update the cache to drop the prefetch data for any segment whose dynamic\n-  // data was already received. This prevents an unnecessary flash back to PPR\n-  // state during a back/forward navigation.\n-  //\n-  // This function clones the entire cache node tree and sets the `prefetchRsc`\n-  // field to `null` to prevent it from being rendered. We can't mutate the node\n-  // in place because this is a concurrent data structure.\n-  //\n-  // TODO: Delete this function and instead move the logic into the normal\n-  // navigation path (updateCacheNodeOnNavigation) to ensure we handle all the\n-  // same cases. The only difference is that whenever a segment is missing, we\n-  // should always check for existing dynamic data rather than spawning a new\n-  // request. We can handle this using the same branch that handles stale\n-  // dynamic data (see createCacheNodeOnNavigation).\n-  const routerStateChildren = routerState[1]\n-  const oldParallelRoutes = oldCacheNode.parallelRoutes\n-  const newParallelRoutes = new Map(oldParallelRoutes)\n-  for (let parallelRouteKey in routerStateChildren) {\n-    const routerStateChild: FlightRouterState =\n-      routerStateChildren[parallelRouteKey]\n-    const segmentChild = routerStateChild[0]\n-    const segmentKeyChild = createRouterCacheKey(segmentChild)\n-    const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey)\n-    if (oldSegmentMapChild !== undefined) {\n-      const oldCacheNodeChild = oldSegmentMapChild.get(segmentKeyChild)\n-      if (oldCacheNodeChild !== undefined) {\n-        const newCacheNodeChild = updateCacheNodeOnPopstateRestoration(\n-          oldCacheNodeChild,\n-          routerStateChild\n-        )\n-        const newSegmentMapChild = new Map(oldSegmentMapChild)\n-        newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild)\n-        newParallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n-      }\n-    }\n-  }\n-\n-  // Only show prefetched data if the dynamic data is still pending.\n-  //\n-  // Tehnically, what we're actually checking is whether the dynamic network\n-  // response was received. But since it's a streaming response, this does not\n-  // mean that all the dynamic data has fully streamed in. It just means that\n-  // _some_ of the dynamic data was received. But as a heuristic, we assume that\n-  // the rest dynamic data will stream in quickly, so it's still better to skip\n-  // the prefetch state.\n-  const rsc = oldCacheNode.rsc\n-  const shouldUsePrefetch = isDeferredRsc(rsc) && rsc.status === 'pending'\n-\n-  return {\n-    lazyData: null,\n-    rsc,\n-    head: oldCacheNode.head,\n-\n-    prefetchHead: shouldUsePrefetch ? oldCacheNode.prefetchHead : [null, null],\n-    prefetchRsc: shouldUsePrefetch ? oldCacheNode.prefetchRsc : null,\n-    loading: oldCacheNode.loading,\n-\n-    // These are the cloned children we computed above\n-    parallelRoutes: newParallelRoutes,\n-\n-    navigatedAt: oldCacheNode.navigatedAt,\n-  }\n-}\n-\n const DEFERRED = Symbol()\n \n type PendingDeferredRsc<T> = Promise<T> & {"
        },
        {
            "sha": "9484c7702df10348201508d174b8883cb7b77ca7",
            "filename": "packages/next/src/client/components/router-reducer/reducers/navigate-reducer.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/6270c09c20a0c6c66e40f69c47e783be017506e7/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fnavigate-reducer.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/6270c09c20a0c6c66e40f69c47e783be017506e7/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fnavigate-reducer.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fnavigate-reducer.ts?ref=6270c09c20a0c6c66e40f69c47e783be017506e7",
            "patch": "@@ -17,6 +17,7 @@ import {\n } from '../../segment-cache/navigation'\n import { NavigationResultTag } from '../../segment-cache/types'\n import { getStaleTimeMs } from '../../segment-cache/cache'\n+import { FreshnessPolicy } from '../ppr-navigations'\n \n // These values are set by `define-env-plugin` (based on `nextConfig.experimental.staleTimes`)\n // and default to 5 minutes (static) / 0 seconds (dynamic)\n@@ -161,14 +162,13 @@ export function navigateReducer(\n   // implementation. Eventually we'll rewrite the router reducer to a\n   // state machine.\n   const currentUrl = new URL(state.canonicalUrl, location.origin)\n-  const shouldRefreshDynamicData = false\n   const result = navigateUsingSegmentCache(\n     url,\n     currentUrl,\n     state.cache,\n     state.tree,\n     state.nextUrl,\n-    shouldRefreshDynamicData,\n+    FreshnessPolicy.Default,\n     shouldScroll,\n     mutable\n   )"
        },
        {
            "sha": "620a31540241034ed11a6beca669021ca9d8da8c",
            "filename": "packages/next/src/client/components/router-reducer/reducers/refresh-reducer.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/6270c09c20a0c6c66e40f69c47e783be017506e7/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Frefresh-reducer.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/6270c09c20a0c6c66e40f69c47e783be017506e7/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Frefresh-reducer.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Frefresh-reducer.ts?ref=6270c09c20a0c6c66e40f69c47e783be017506e7",
            "patch": "@@ -8,6 +8,7 @@ import { handleNavigationResult } from './navigate-reducer'\n import { navigateToSeededRoute } from '../../segment-cache/navigation'\n import { revalidateEntireCache } from '../../segment-cache/cache'\n import { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'\n+import { FreshnessPolicy } from '../ppr-navigations'\n \n export function refreshReducer(\n   state: ReadonlyReducerState,\n@@ -33,7 +34,6 @@ export function refreshReducer(\n   const url = currentUrl\n   const currentFlightRouterState = state.tree\n   const shouldScroll = true\n-  const shouldRefreshDynamicData = true\n \n   const seedFlightRouterState = state.tree\n   const seedRenderedSearch = state.renderedSearch\n@@ -49,7 +49,7 @@ export function refreshReducer(\n     seedRenderedSearch,\n     seedData,\n     seedHead,\n-    shouldRefreshDynamicData,\n+    FreshnessPolicy.RefreshAll,\n     nextUrlForRefresh,\n     shouldScroll\n   )"
        },
        {
            "sha": "8bffb3c4ce88797f6e09f8a1a5ce1347dacc7780",
            "filename": "packages/next/src/client/components/router-reducer/reducers/restore-reducer.ts",
            "status": "modified",
            "additions": 60,
            "deletions": 14,
            "changes": 74,
            "blob_url": "https://github.com/vercel/next.js/blob/6270c09c20a0c6c66e40f69c47e783be017506e7/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Frestore-reducer.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/6270c09c20a0c6c66e40f69c47e783be017506e7/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Frestore-reducer.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Frestore-reducer.ts?ref=6270c09c20a0c6c66e40f69c47e783be017506e7",
            "patch": "@@ -5,15 +5,20 @@ import type {\n   RestoreAction,\n } from '../router-reducer-types'\n import { extractPathFromFlightRouterState } from '../compute-changed-path'\n-import { updateCacheNodeOnPopstateRestoration } from '../ppr-navigations'\n+import {\n+  FreshnessPolicy,\n+  listenForDynamicRequest,\n+  startPPRNavigation,\n+  type NavigationRequestAccumulation,\n+} from '../ppr-navigations'\n import type { FlightRouterState } from '../../../../shared/lib/app-router-types'\n+import { handleExternalUrl } from './navigate-reducer'\n+import type { Mutable } from '../router-reducer-types'\n \n export function restoreReducer(\n   state: ReadonlyReducerState,\n   action: RestoreAction\n ): ReducerState {\n-  const { url, historyState } = action\n-  const href = createHrefFromUrl(url)\n   // This action is used to restore the router state from the history state.\n   // However, it's possible that the history state no longer contains the `FlightRouterState`.\n   // We will copy over the internal state on pushState/replaceState events, but if a history entry\n@@ -22,6 +27,7 @@ export function restoreReducer(\n   // In this case, we'll continue to use the existing tree so the router doesn't get into an invalid state.\n   let treeToRestore: FlightRouterState | undefined\n   let renderedSearch: string | undefined\n+  const historyState = action.historyState\n   if (historyState) {\n     treeToRestore = historyState.tree\n     renderedSearch = historyState.renderedSearch\n@@ -30,18 +36,54 @@ export function restoreReducer(\n     renderedSearch = state.renderedSearch\n   }\n \n-  const oldCache = state.cache\n-  const newCache = process.env.__NEXT_PPR\n-    ? // When PPR is enabled, we update the cache to drop the prefetch\n-      // data for any segment whose dynamic data was already received. This\n-      // prevents an unnecessary flash back to PPR state during a\n-      // back/forward navigation.\n-      updateCacheNodeOnPopstateRestoration(oldCache, treeToRestore)\n-    : oldCache\n+  const currentUrl = new URL(state.canonicalUrl, location.origin)\n+  const restoredUrl = action.url\n+  const restoredCanonicalUrl = createHrefFromUrl(restoredUrl)\n+  const restoredNextUrl =\n+    extractPathFromFlightRouterState(treeToRestore) ?? restoredUrl.pathname\n+\n+  const now = Date.now()\n+  const accumulation: NavigationRequestAccumulation = {\n+    scrollableSegments: null,\n+    separateRefreshUrls: null,\n+  }\n+  const task = startPPRNavigation(\n+    now,\n+    currentUrl,\n+    state.cache,\n+    state.tree,\n+    treeToRestore,\n+    FreshnessPolicy.HistoryTraversal,\n+    null,\n+    null,\n+    null,\n+    null,\n+    false,\n+    false,\n+    accumulation\n+  )\n+\n+  if (task === null) {\n+    const mutable: Mutable = {\n+      preserveCustomHistoryState: true,\n+    }\n+    return handleExternalUrl(state, mutable, restoredCanonicalUrl, false)\n+  }\n+\n+  if (task.dynamicRequestTree !== null) {\n+    listenForDynamicRequest(\n+      restoredUrl,\n+      restoredNextUrl,\n+      task,\n+      task.dynamicRequestTree,\n+      null,\n+      accumulation\n+    )\n+  }\n \n   return {\n     // Set canonical url\n-    canonicalUrl: href,\n+    canonicalUrl: restoredCanonicalUrl,\n     renderedSearch,\n     pushRef: {\n       pendingPush: false,\n@@ -50,10 +92,14 @@ export function restoreReducer(\n       preserveCustomHistoryState: true,\n     },\n     focusAndScrollRef: state.focusAndScrollRef,\n-    cache: newCache,\n+    cache: task.node,\n     // Restore provided tree\n     tree: treeToRestore,\n-    nextUrl: extractPathFromFlightRouterState(treeToRestore) ?? url.pathname,\n+\n+    nextUrl: restoredNextUrl,\n+    // TODO: We need to restore previousNextUrl, too, which represents the\n+    // Next-Url that was used to fetch the data. Anywhere we fetch using the\n+    // canonical URL, there should be a corresponding Next-Url.\n     previousNextUrl: null,\n     debugInfo: null,\n   }"
        },
        {
            "sha": "79db217a5cb0b04e7f86d2ac98436c9d208ecf21",
            "filename": "packages/next/src/client/components/router-reducer/reducers/server-action-reducer.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 4,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/6270c09c20a0c6c66e40f69c47e783be017506e7/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fserver-action-reducer.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/6270c09c20a0c6c66e40f69c47e783be017506e7/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fserver-action-reducer.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fserver-action-reducer.ts?ref=6270c09c20a0c6c66e40f69c47e783be017506e7",
            "patch": "@@ -61,6 +61,7 @@ import {\n   type ActionRevalidationKind,\n } from '../../../../shared/lib/action-revalidation-kind'\n import { isExternalURL } from '../../app-router-utils'\n+import { FreshnessPolicy } from '../ppr-navigations'\n \n const createFromFetch =\n   createFromFetchBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromFetch']\n@@ -388,8 +389,10 @@ export function serverActionReducer(\n \n       // If the action triggered a revalidation of the cache, we should also\n       // refresh all the dynamic data.\n-      const shouldRefreshDynamicData =\n-        revalidationKind !== ActionDidNotRevalidate\n+      const freshnessPolicy =\n+        revalidationKind === ActionDidNotRevalidate\n+          ? FreshnessPolicy.Default\n+          : FreshnessPolicy.RefreshAll\n \n       // The server may have sent back new data. If so, we will perform a\n       // \"seeded\" navigation that uses the data from the response.\n@@ -421,7 +424,7 @@ export function serverActionReducer(\n             seedRenderedSearch,\n             seedData,\n             seedHead,\n-            shouldRefreshDynamicData,\n+            freshnessPolicy,\n             nextUrl,\n             shouldScroll\n           )\n@@ -443,7 +446,7 @@ export function serverActionReducer(\n         state.cache,\n         currentFlightRouterState,\n         nextUrl,\n-        shouldRefreshDynamicData,\n+        freshnessPolicy,\n         shouldScroll,\n         mutable\n       )"
        },
        {
            "sha": "bb012a7cde374eb705d84410bbdbb33b16327bae",
            "filename": "packages/next/src/client/components/segment-cache/navigation.ts",
            "status": "modified",
            "additions": 27,
            "deletions": 13,
            "changes": 40,
            "blob_url": "https://github.com/vercel/next.js/blob/6270c09c20a0c6c66e40f69c47e783be017506e7/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fnavigation.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/6270c09c20a0c6c66e40f69c47e783be017506e7/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fnavigation.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fnavigation.ts?ref=6270c09c20a0c6c66e40f69c47e783be017506e7",
            "patch": "@@ -13,6 +13,7 @@ import { fetchServerResponse } from '../router-reducer/fetch-server-response'\n import {\n   startPPRNavigation,\n   listenForDynamicRequest,\n+  FreshnessPolicy,\n   type NavigationTask,\n   type NavigationRequestAccumulation,\n } from '../router-reducer/ppr-navigations'\n@@ -72,7 +73,7 @@ export function navigate(\n   currentCacheNode: CacheNode | null,\n   currentFlightRouterState: FlightRouterState,\n   nextUrl: string | null,\n-  shouldRefreshDynamicData: boolean,\n+  freshnessPolicy: FreshnessPolicy,\n   shouldScroll: boolean,\n   accumulation: { collectedDebugInfo?: Array<unknown> }\n ): NavigationResult {\n@@ -131,7 +132,7 @@ export function navigate(\n       isPrefetchHeadPartial,\n       newCanonicalUrl,\n       renderedSearch,\n-      shouldRefreshDynamicData,\n+      freshnessPolicy,\n       shouldScroll,\n       url.hash\n     )\n@@ -176,7 +177,7 @@ export function navigate(\n         isPrefetchHeadPartial,\n         newCanonicalUrl,\n         newRenderedSearch,\n-        shouldRefreshDynamicData,\n+        freshnessPolicy,\n         shouldScroll,\n         url.hash\n       )\n@@ -198,7 +199,7 @@ export function navigate(\n       isSamePageNavigation,\n       currentCacheNode,\n       currentFlightRouterState,\n-      shouldRefreshDynamicData,\n+      freshnessPolicy,\n       shouldScroll,\n       url.hash,\n       collectedDebugInfo\n@@ -215,7 +216,7 @@ export function navigateToSeededRoute(\n   seedRenderedSearch: string,\n   seedData: CacheNodeSeedData | null,\n   seedHead: HeadData | null,\n-  shouldRefreshDynamicData: boolean,\n+  freshnessPolicy: FreshnessPolicy,\n   nextUrl: string | null,\n   shouldScroll: boolean\n ): SuccessfulNavigationResult | MPANavigationResult {\n@@ -234,7 +235,7 @@ export function navigateToSeededRoute(\n     currentCacheNode,\n     currentFlightRouterState,\n     seedFlightRouterState,\n-    shouldRefreshDynamicData,\n+    freshnessPolicy,\n     seedData,\n     seedHead,\n     null,\n@@ -284,7 +285,7 @@ function navigateUsingPrefetchedRouteTree(\n   isPrefetchHeadPartial: boolean,\n   canonicalUrl: string,\n   renderedSearch: string,\n-  shouldRefreshDynamicData: boolean,\n+  freshnessPolicy: FreshnessPolicy,\n   shouldScroll: boolean,\n   hash: string\n ): SuccessfulNavigationResult | MPANavigationResult {\n@@ -306,7 +307,7 @@ function navigateUsingPrefetchedRouteTree(\n     currentCacheNode,\n     currentFlightRouterState,\n     prefetchFlightRouterState,\n-    shouldRefreshDynamicData,\n+    freshnessPolicy,\n     seedData,\n     seedHead,\n     prefetchSeedData,\n@@ -512,7 +513,7 @@ async function navigateDynamicallyWithNoPrefetch(\n   isSamePageNavigation: boolean,\n   currentCacheNode: CacheNode | null,\n   currentFlightRouterState: FlightRouterState,\n-  shouldRefreshDynamicData: boolean,\n+  freshnessPolicy: FreshnessPolicy,\n   shouldScroll: boolean,\n   hash: string,\n   collectedDebugInfo: Array<unknown>\n@@ -529,10 +530,23 @@ async function navigateDynamicallyWithNoPrefetch(\n   // tree. So it's the same flow as the \"happy path\" (prefetch, then\n   // navigation), except we use a single server response for both stages.\n \n+  let dynamicRequestTree: FlightRouterState\n+  switch (freshnessPolicy) {\n+    case FreshnessPolicy.Default:\n+    case FreshnessPolicy.HistoryTraversal:\n+      dynamicRequestTree = currentFlightRouterState\n+      break\n+    case FreshnessPolicy.RefreshAll:\n+      dynamicRequestTree = DynamicRequestTreeForEntireRoute\n+      break\n+    default:\n+      freshnessPolicy satisfies never\n+      dynamicRequestTree = currentFlightRouterState\n+      break\n+  }\n+\n   const promiseForDynamicServerResponse = fetchServerResponse(url, {\n-    flightRouterState: shouldRefreshDynamicData\n-      ? DynamicRequestTreeForEntireRoute\n-      : currentFlightRouterState,\n+    flightRouterState: dynamicRequestTree,\n     nextUrl,\n   })\n   const result = await promiseForDynamicServerResponse\n@@ -582,7 +596,7 @@ async function navigateDynamicallyWithNoPrefetch(\n     currentCacheNode,\n     currentFlightRouterState,\n     prefetchFlightRouterState,\n-    shouldRefreshDynamicData,\n+    freshnessPolicy,\n     seedData,\n     seedHead,\n     prefetchData,"
        }
    ],
    "stats": {
        "total": 338,
        "additions": 206,
        "deletions": 132
    }
}