{
    "author": "ztanner",
    "message": "[tests]: fix failing searchparams test (#81013)\n\n- Adds a more reliable heuristic for when the test should start\nnavigating (after prefetches are initiated) as `waitForIdleNetwork` is\ndiscouraged\n- Normalizes RSC request keys to ignore the redirect value from the\nmiddleware case",
    "sha": "a9fac70b261a4b80e40810a9647825d475d6b7b5",
    "files": [
        {
            "sha": "9d69854e83bd4daa273d2b46b25b07dfdc757f44",
            "filename": "test/e2e/app-dir/searchparams-reuse-loading/searchparams-reuse-loading.test.ts",
            "status": "modified",
            "additions": 40,
            "deletions": 17,
            "changes": 57,
            "blob_url": "https://github.com/vercel/next.js/blob/a9fac70b261a4b80e40810a9647825d475d6b7b5/test%2Fe2e%2Fapp-dir%2Fsearchparams-reuse-loading%2Fsearchparams-reuse-loading.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/a9fac70b261a4b80e40810a9647825d475d6b7b5/test%2Fe2e%2Fapp-dir%2Fsearchparams-reuse-loading%2Fsearchparams-reuse-loading.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsearchparams-reuse-loading%2Fsearchparams-reuse-loading.test.ts?ref=a9fac70b261a4b80e40810a9647825d475d6b7b5",
            "patch": "@@ -178,6 +178,16 @@ describe('searchparams-reuse-loading', () => {\n           { resolve: () => Promise<void> }\n         >()\n \n+        // Track prefetch requests to know when initial prefetching is done\n+        const prefetchRequests = new Set<string>()\n+        let prefetchResolve: (() => void) | undefined\n+        let prefetchDelayStarted = false\n+        const prefetchPromise = new Promise<void>((resolve) => {\n+          prefetchResolve = resolve\n+          // Fallback timeout to prevent hanging\n+          setTimeout(() => resolve(), 5000)\n+        })\n+\n         let interceptRequests = false\n         const browser = await next.browser(path, {\n           beforePageLoad(page) {\n@@ -186,15 +196,33 @@ describe('searchparams-reuse-loading', () => {\n                 return url.pathname.includes('search-params')\n               },\n               async (route) => {\n-                if (!interceptRequests) {\n-                  return route.continue()\n-                }\n-\n                 const request = route.request()\n                 const headers = await request.allHeaders()\n                 const url = new URL(request.url())\n+\n+                // Track prefetch requests during initial load\n+                if (headers['next-router-prefetch'] && !interceptRequests) {\n+                  const prefetchKey = url.pathname + url.search\n+                  prefetchRequests.add(prefetchKey)\n+                  await route.continue()\n+\n+                  // Wait for initial prefetch burst to complete\n+                  // Add small delay after seeing prefetches to let any redirects complete\n+                  if (prefetchRequests.size >= 2 && !prefetchDelayStarted) {\n+                    prefetchDelayStarted = true\n+                    setTimeout(() => prefetchResolve?.(), 500)\n+                  }\n+                  return\n+                }\n+\n+                // Normalize path to ignore differences between middleware and non-middleware cases\n+                const normalizedPath = url.pathname.replace(/\\/someValue$/, '')\n                 const promiseKey =\n-                  url.pathname + '?id=' + url.searchParams.get('id')\n+                  normalizedPath + '?id=' + url.searchParams.get('id')\n+\n+                if (!interceptRequests) {\n+                  return route.continue()\n+                }\n \n                 if (\n                   headers['rsc'] === '1' &&\n@@ -231,12 +259,9 @@ describe('searchparams-reuse-loading', () => {\n \n         const basePath = path === '/' ? '' : path\n         const searchParamsPagePath = `${basePath}/search-params`\n-        const canonicalSearchParamsPagePath =\n-          path === '/with-middleware'\n-            ? `${searchParamsPagePath}/someValue`\n-            : searchParamsPagePath\n \n-        await browser.waitForIdleNetwork()\n+        // Wait for all expected prefetch requests to complete\n+        await prefetchPromise\n         interceptRequests = true\n         // The first link we click is \"auto\" prefetched.\n         await browser\n@@ -248,7 +273,7 @@ describe('searchparams-reuse-loading', () => {\n         // We only resolve the dynamic request after we've confirmed loading exists,\n         // to avoid a race where the dynamic request handles the loading state instead.\n         let dynamicRequest = rscRequestPromise.get(\n-          `${canonicalSearchParamsPagePath}?id=1`\n+          `${searchParamsPagePath}?id=1`\n         )\n \n         expect(dynamicRequest).toBeDefined()\n@@ -269,9 +294,7 @@ describe('searchparams-reuse-loading', () => {\n           .elementByCss(`[href=\"${searchParamsPagePath}?id=2\"]`)\n           .click()\n         expect(await browser.elementById('loading').text()).toBe('Loading...')\n-        dynamicRequest = rscRequestPromise.get(\n-          `${canonicalSearchParamsPagePath}?id=2`\n-        )\n+        dynamicRequest = rscRequestPromise.get(`${searchParamsPagePath}?id=2`)\n         expect(dynamicRequest).toBeDefined()\n \n         // resolve the promise\n@@ -287,9 +310,9 @@ describe('searchparams-reuse-loading', () => {\n         await browser\n           .elementByCss(`[href=\"${searchParamsPagePath}?id=3\"]`)\n           .click()\n-        expect(\n-          rscRequestPromise.has(`${canonicalSearchParamsPagePath}?id=3`)\n-        ).toBe(false)\n+        expect(rscRequestPromise.has(`${searchParamsPagePath}?id=3`)).toBe(\n+          false\n+        )\n         // no need to resolve any dynamic requests, as this is a full prefetch\n         const params3 = await browser.waitForElementByCss('#params').text()\n         expect(params3).toBe('{\"id\":\"3\"}')"
        }
    ],
    "stats": {
        "total": 57,
        "additions": 40,
        "deletions": 17
    }
}