{
    "author": "devjiwonchoi",
    "message": "[Breaking] Remove deprecated sync access to Dynamic APIs (#84179)\n\nThis PR removes the deprecated sync access to Dynamic APIs.\n\n- Removed UnsafeUnwrapped* types.\n- Replaced `as unknown as UnsafeUnwrapped ` type casts to `as any` for\ndev warning.\n- Removed tests that expected sync access to not error.\n- Removed `UntrackedExotic` functions.\n- Modified tests that were accidentally doing sync access.\n- Updated warnings to emphasize that it is a Promise and must be\nawaited.\n- Removed paragraph that states access is allowed from\n`errors/sync-dynamic-apis.mdx`.\n\n---------\n\nCo-authored-by: Josh Story <story@hey.com>",
    "sha": "1dda5b668bc57fdad6c4cf840c2083e6c66ad9db",
    "files": [
        {
            "sha": "c377f828bcb6bec0efa4403be4198d516f3fa311",
            "filename": "errors/sync-dynamic-apis.mdx",
            "status": "modified",
            "additions": 0,
            "deletions": 3,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/errors%2Fsync-dynamic-apis.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/errors%2Fsync-dynamic-apis.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/errors%2Fsync-dynamic-apis.mdx?ref=1dda5b668bc57fdad6c4cf840c2083e6c66ad9db",
            "patch": "@@ -26,9 +26,6 @@ function Page({ params }) {\n This also includes enumerating (e.g. `{...params}`, or `Object.keys(params)`) or iterating over the return\n value of these APIs (e.g. `[...headers()]` or `for (const cookie of cookies())`, or explicitly with `cookies()[Symbol.iterator]()`).\n \n-In the version of Next.js that issued this warning, access to these properties is still possible directly but will warn.\n-In future versions, these APIs will be async and direct access will not work as expected.\n-\n ## Possible Ways to Fix It\n \n The [`next-async-request-api` codemod](/docs/app/guides/upgrading/codemods#next-async-request-api) can fix many of these cases automatically:"
        },
        {
            "sha": "d08ebc67b673ab133bec33d055a780af86937c77",
            "filename": "packages/next/errors.json",
            "status": "modified",
            "additions": 24,
            "deletions": 1,
            "changes": 25,
            "blob_url": "https://github.com/vercel/next.js/blob/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/packages%2Fnext%2Ferrors.json",
            "raw_url": "https://github.com/vercel/next.js/raw/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/packages%2Fnext%2Ferrors.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Ferrors.json?ref=1dda5b668bc57fdad6c4cf840c2083e6c66ad9db",
            "patch": "@@ -824,5 +824,28 @@\n   \"823\": \"Timeout waiting for error state from frontend. The browser may not be responding to HMR messages.\",\n   \"824\": \"URL is required in MCP browser response. This is a bug in Next.js.\",\n   \"825\": \"Timeout waiting for response from frontend. The browser may not be responding to HMR messages.\",\n-  \"826\": \"unknown bundler: %s\"\n+  \"826\": \"unknown bundler: %s\",\n+  \"827\": \"Route %s used \\\\`connection()\\\\` inside \\\\`after()\\\\`. The \\\\`connection()\\\\` function is used to indicate the subsequent code must only run when there is an actual Request, but \\\\`after()\\\\` executes after the request, so this function is not allowed in this scope. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after\",\n+  \"828\": \"Route %s with \\\\`dynamic = \\\"error\\\"\\\\` couldn't be rendered statically because it used \\\\`headers()\\\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering\",\n+  \"829\": \"Route %s used \\\"%s\\\" inside \\\"use cache\\\". The enabled status of \\\\`draftMode()\\\\` can be read in caches but you must not enable or disable \\\\`draftMode()\\\\` inside a cache. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\",\n+  \"830\": \"%sused %s. \\\\`cookies()\\\\` returns a Promise and must be unwrapped with \\\\`await\\\\` or \\\\`React.use()\\\\` before accessing its properties. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis\",\n+  \"831\": \"Route %s used \\\\`cookies()\\\\` inside \\\"use cache\\\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \\\\`cookies()\\\\` outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\",\n+  \"832\": \"%s must not be used within a Client Component. Next.js should be preventing %s from being included in Client Components statically, but did not in this case.\",\n+  \"833\": \"Route %s used \\\\`headers()\\\\` inside \\\"use cache\\\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \\\\`headers()\\\\` outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\",\n+  \"834\": \"%sused %s. \\\\`params\\\\` is a Promise and must be unwrapped with \\\\`await\\\\` or \\\\`React.use()\\\\` before accessing its properties. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis\",\n+  \"835\": \"%sused %s. \\\\`draftMode()\\\\` returns a Promise and must be unwrapped with \\\\`await\\\\` or \\\\`React.use()\\\\` before accessing its properties. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis\",\n+  \"836\": \"%sused %s. \\\\`headers()\\\\` returns a Promise and must be unwrapped with \\\\`await\\\\` or \\\\`React.use()\\\\` before accessing its properties. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis\",\n+  \"837\": \"Route %s used \\\\`connection()\\\\` inside \\\"use cache: private\\\". The \\\\`connection()\\\\` function is used to indicate the subsequent code must only run when there is an actual navigation request, but caches must be able to be produced before a navigation request, so this function is not allowed in this scope. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\",\n+  \"838\": \"Route %s used \\\\`headers()\\\\` inside a function cached with \\\\`unstable_cache()\\\\`. Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \\\\`headers()\\\\` outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache\",\n+  \"839\": \"Route %s used \\\\`headers()\\\\` inside \\\\`after()\\\\`. This is not supported. If you need this data inside an \\\\`after()\\\\` callback, use \\\\`headers()\\\\` outside of the callback. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after\",\n+  \"840\": \"Route %s used \\\\`connection()\\\\` inside a function cached with \\\\`unstable_cache()\\\\`. The \\\\`connection()\\\\` function is used to indicate the subsequent code must only run when there is an actual Request, but caches must be able to be produced before a Request so this function is not allowed in this scope. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache\",\n+  \"841\": \"Route %s used \\\\`connection()\\\\` inside \\\"use cache\\\". The \\\\`connection()\\\\` function is used to indicate the subsequent code must only run when there is an actual request, but caches must be able to be produced before a request, so this function is not allowed in this scope. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\",\n+  \"842\": \"Route %s used \\\\`searchParams\\\\` inside \\\"use cache\\\". Accessing dynamic request data inside a cache scope is not supported. If you need some search params inside a cached function await \\\\`searchParams\\\\` outside of the cached function and pass only the required search params as arguments to the cached function. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\",\n+  \"843\": \"Route %s used \\\\`cookies()\\\\` inside \\\\`after()\\\\`. This is not supported. If you need this data inside an \\\\`after()\\\\` callback, use \\\\`cookies()\\\\` outside of the callback. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after\",\n+  \"844\": \"Route %s used \\\"%s\\\" inside a function cached with \\\\`unstable_cache()\\\\`. The enabled status of \\\\`draftMode()\\\\` can be read in caches but you must not enable or disable \\\\`draftMode()\\\\` inside a cache. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache\",\n+  \"845\": \"Route %s used \\\"%s\\\" inside \\\\`after()\\\\`. The enabled status of \\\\`draftMode()\\\\` can be read inside \\\\`after()\\\\` but you cannot enable or disable \\\\`draftMode()\\\\`. See more info here: https://nextjs.org/docs/app/api-reference/functions/after\",\n+  \"846\": \"Route %s used \\\\`cookies()\\\\` inside a function cached with \\\\`unstable_cache()\\\\`. Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \\\\`cookies()\\\\` outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache\",\n+  \"847\": \"Route %s with \\\\`dynamic = \\\"error\\\"\\\\` couldn't be rendered statically because it used \\\\`connection()\\\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering\",\n+  \"848\": \"%sused %s. \\\\`searchParams\\\\` is a Promise and must be unwrapped with \\\\`await\\\\` or \\\\`React.use()\\\\` before accessing its properties. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis\",\n+  \"849\": \"Route %s with \\\\`dynamic = \\\"error\\\"\\\\` couldn't be rendered statically because it used \\\\`cookies()\\\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering\"\n }"
        },
        {
            "sha": "a8a4567b498cd6d90872c2ef1380cd6b094d47c5",
            "filename": "packages/next/server.d.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/packages%2Fnext%2Fserver.d.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/packages%2Fnext%2Fserver.d.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fserver.d.ts?ref=1dda5b668bc57fdad6c4cf840c2083e6c66ad9db",
            "patch": "@@ -16,5 +16,3 @@ export type { ImageResponseOptions } from 'next/dist/compiled/@vercel/og/types'\n export { after } from 'next/dist/server/after'\n export { unstable_rootParams } from 'next/dist/server/request/root-params'\n export { connection } from 'next/dist/server/request/connection'\n-export type { UnsafeUnwrappedSearchParams } from 'next/dist/server/request/search-params'\n-export type { UnsafeUnwrappedParams } from 'next/dist/server/request/params'"
        },
        {
            "sha": "1b7ed9e73f98bc5ba6e425824c93bbde468ba67e",
            "filename": "packages/next/src/build/webpack/plugins/next-types-plugin/index.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack%2Fplugins%2Fnext-types-plugin%2Findex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack%2Fplugins%2Fnext-types-plugin%2Findex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack%2Fplugins%2Fnext-types-plugin%2Findex.ts?ref=1dda5b668bc57fdad6c4cf840c2083e6c66ad9db",
            "patch": "@@ -423,8 +423,6 @@ function createServerDefinitions(\n     export type { ImageResponseOptions } from 'next/dist/compiled/@vercel/og/types'\n     export { after } from 'next/dist/server/after'\n     export { connection } from 'next/dist/server/request/connection'\n-    export type { UnsafeUnwrappedSearchParams } from 'next/dist/server/request/search-params'\n-    export type { UnsafeUnwrappedParams } from 'next/dist/server/request/params'\n     export function unstable_rootParams(): Promise<{ ${rootParams\n       .map(\n         ({ param, optional }) =>"
        },
        {
            "sha": "c7e6048524d450bbe09bba0c4bed72c9c92975bd",
            "filename": "packages/next/src/client/request/params.browser.dev.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 103,
            "changes": 114,
            "blob_url": "https://github.com/vercel/next.js/blob/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/packages%2Fnext%2Fsrc%2Fclient%2Frequest%2Fparams.browser.dev.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/packages%2Fnext%2Fsrc%2Fclient%2Frequest%2Fparams.browser.dev.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Frequest%2Fparams.browser.dev.ts?ref=1dda5b668bc57fdad6c4cf840c2083e6c66ad9db",
            "patch": "@@ -1,7 +1,6 @@\n import type { Params } from '../../server/request/params'\n \n import { ReflectAdapter } from '../../server/web/spec-extension/adapters/reflect'\n-import { InvariantError } from '../../shared/lib/invariant-error'\n import {\n   describeStringPropertyAccess,\n   wellKnownProperties,\n@@ -10,63 +9,6 @@ import {\n interface CacheLifetime {}\n const CachedParams = new WeakMap<CacheLifetime, Promise<Params>>()\n \n-function makeDynamicallyTrackedExoticParamsWithDevWarnings(\n-  underlyingParams: Params\n-): Promise<Params> {\n-  const cachedParams = CachedParams.get(underlyingParams)\n-  if (cachedParams) {\n-    return cachedParams\n-  }\n-\n-  // We don't use makeResolvedReactPromise here because params\n-  // supports copying with spread and we don't want to unnecessarily\n-  // instrument the promise with spreadable properties of ReactPromise.\n-  const promise = Promise.resolve(underlyingParams)\n-\n-  const proxiedProperties = new Set<string>()\n-  const unproxiedProperties: Array<string> = []\n-\n-  Object.keys(underlyingParams).forEach((prop) => {\n-    if (wellKnownProperties.has(prop)) {\n-      // These properties cannot be shadowed because they need to be the\n-      // true underlying value for Promises to work correctly at runtime\n-    } else {\n-      proxiedProperties.add(prop)\n-      ;(promise as any)[prop] = underlyingParams[prop]\n-    }\n-  })\n-\n-  const proxiedPromise = new Proxy(promise, {\n-    get(target, prop, receiver) {\n-      if (typeof prop === 'string') {\n-        if (\n-          // We are accessing a property that was proxied to the promise instance\n-          proxiedProperties.has(prop)\n-        ) {\n-          const expression = describeStringPropertyAccess('params', prop)\n-          warnForSyncAccess(expression)\n-        }\n-      }\n-      return ReflectAdapter.get(target, prop, receiver)\n-    },\n-    set(target, prop, value, receiver) {\n-      if (typeof prop === 'string') {\n-        proxiedProperties.delete(prop)\n-      }\n-      return ReflectAdapter.set(target, prop, value, receiver)\n-    },\n-    ownKeys(target) {\n-      warnForEnumeration(unproxiedProperties)\n-      return Reflect.ownKeys(target)\n-    },\n-  })\n-\n-  CachedParams.set(underlyingParams, proxiedPromise)\n-  return proxiedPromise\n-}\n-\n-// Similar to `makeDynamicallyTrackedExoticParamsWithDevWarnings`, but just\n-// logging the sync access without actually defining the params on the promise.\n function makeDynamicallyTrackedParamsWithDevWarnings(\n   underlyingParams: Params\n ): Promise<Params> {\n@@ -81,7 +23,6 @@ function makeDynamicallyTrackedParamsWithDevWarnings(\n   const promise = Promise.resolve(underlyingParams)\n \n   const proxiedProperties = new Set<string>()\n-  const unproxiedProperties: Array<string> = []\n \n   Object.keys(underlyingParams).forEach((prop) => {\n     if (wellKnownProperties.has(prop)) {\n@@ -112,7 +53,7 @@ function makeDynamicallyTrackedParamsWithDevWarnings(\n       return ReflectAdapter.set(target, prop, value, receiver)\n     },\n     ownKeys(target) {\n-      warnForEnumeration(unproxiedProperties)\n+      warnForEnumeration()\n       return Reflect.ownKeys(target)\n     },\n   })\n@@ -123,55 +64,22 @@ function makeDynamicallyTrackedParamsWithDevWarnings(\n \n function warnForSyncAccess(expression: string) {\n   console.error(\n-    `A param property was accessed directly with ${expression}. \\`params\\` is now a Promise and should be unwrapped with \\`React.use()\\` before accessing properties of the underlying params object. In this version of Next.js direct access to param properties is still supported to facilitate migration but in a future version you will be required to unwrap \\`params\\` with \\`React.use()\\`.`\n+    `A param property was accessed directly with ${expression}. ` +\n+      `\\`params\\` is a Promise and must be unwrapped with \\`React.use()\\` before accessing its properties. ` +\n+      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n   )\n }\n \n-function warnForEnumeration(missingProperties: Array<string>) {\n-  if (missingProperties.length) {\n-    const describedMissingProperties =\n-      describeListOfPropertyNames(missingProperties)\n-    console.error(\n-      `params are being enumerated incompletely missing these properties: ${describedMissingProperties}. ` +\n-        `\\`params\\` should be unwrapped with \\`React.use()\\` before using its value. ` +\n-        `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n-    )\n-  } else {\n-    console.error(\n-      `params are being enumerated. ` +\n-        `\\`params\\` should be unwrapped with \\`React.use()\\` before using its value. ` +\n-        `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n-    )\n-  }\n-}\n-\n-function describeListOfPropertyNames(properties: Array<string>) {\n-  switch (properties.length) {\n-    case 0:\n-      throw new InvariantError(\n-        'Expected describeListOfPropertyNames to be called with a non-empty list of strings.'\n-      )\n-    case 1:\n-      return `\\`${properties[0]}\\``\n-    case 2:\n-      return `\\`${properties[0]}\\` and \\`${properties[1]}\\``\n-    default: {\n-      let description = ''\n-      for (let i = 0; i < properties.length - 1; i++) {\n-        description += `\\`${properties[i]}\\`, `\n-      }\n-      description += `, and \\`${properties[properties.length - 1]}\\``\n-      return description\n-    }\n-  }\n+function warnForEnumeration() {\n+  console.error(\n+    `params are being enumerated. ` +\n+      `\\`params\\` is a Promise and must be unwrapped with \\`React.use()\\` before accessing its properties. ` +\n+      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n+  )\n }\n \n export function createRenderParamsFromClient(\n   clientParams: Params\n ): Promise<Params> {\n-  if (process.env.__NEXT_CACHE_COMPONENTS) {\n-    return makeDynamicallyTrackedParamsWithDevWarnings(clientParams)\n-  }\n-\n-  return makeDynamicallyTrackedExoticParamsWithDevWarnings(clientParams)\n+  return makeDynamicallyTrackedParamsWithDevWarnings(clientParams)\n }"
        },
        {
            "sha": "54605d89316cac06bfc103d6a0b7a8a4d62aed20",
            "filename": "packages/next/src/client/request/params.browser.prod.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 27,
            "changes": 28,
            "blob_url": "https://github.com/vercel/next.js/blob/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/packages%2Fnext%2Fsrc%2Fclient%2Frequest%2Fparams.browser.prod.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/packages%2Fnext%2Fsrc%2Fclient%2Frequest%2Fparams.browser.prod.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Frequest%2Fparams.browser.prod.ts?ref=1dda5b668bc57fdad6c4cf840c2083e6c66ad9db",
            "patch": "@@ -1,30 +1,8 @@\n import type { Params } from '../../server/request/params'\n-import { wellKnownProperties } from '../../shared/lib/utils/reflect-utils'\n \n interface CacheLifetime {}\n const CachedParams = new WeakMap<CacheLifetime, Promise<Params>>()\n \n-function makeUntrackedExoticParams(underlyingParams: Params): Promise<Params> {\n-  const cachedParams = CachedParams.get(underlyingParams)\n-  if (cachedParams) {\n-    return cachedParams\n-  }\n-\n-  const promise = Promise.resolve(underlyingParams)\n-  CachedParams.set(underlyingParams, promise)\n-\n-  Object.keys(underlyingParams).forEach((prop) => {\n-    if (wellKnownProperties.has(prop)) {\n-      // These properties cannot be shadowed because they need to be the\n-      // true underlying value for Promises to work correctly at runtime\n-    } else {\n-      ;(promise as any)[prop] = underlyingParams[prop]\n-    }\n-  })\n-\n-  return promise\n-}\n-\n function makeUntrackedParams(underlyingParams: Params): Promise<Params> {\n   const cachedParams = CachedParams.get(underlyingParams)\n   if (cachedParams) {\n@@ -40,9 +18,5 @@ function makeUntrackedParams(underlyingParams: Params): Promise<Params> {\n export function createRenderParamsFromClient(\n   clientParams: Params\n ): Promise<Params> {\n-  if (process.env.__NEXT_CACHE_COMPONENTS) {\n-    return makeUntrackedParams(clientParams)\n-  }\n-\n-  return makeUntrackedExoticParams(clientParams)\n+  return makeUntrackedParams(clientParams)\n }"
        },
        {
            "sha": "ded9abe24b6533aed1fcff19de3f4f9badc5dcbc",
            "filename": "packages/next/src/client/request/search-params.browser.dev.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 85,
            "changes": 88,
            "blob_url": "https://github.com/vercel/next.js/blob/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/packages%2Fnext%2Fsrc%2Fclient%2Frequest%2Fsearch-params.browser.dev.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/packages%2Fnext%2Fsrc%2Fclient%2Frequest%2Fsearch-params.browser.dev.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Frequest%2Fsearch-params.browser.dev.ts?ref=1dda5b668bc57fdad6c4cf840c2083e6c66ad9db",
            "patch": "@@ -10,82 +10,6 @@ import {\n interface CacheLifetime {}\n const CachedSearchParams = new WeakMap<CacheLifetime, Promise<SearchParams>>()\n \n-function makeUntrackedExoticSearchParamsWithDevWarnings(\n-  underlyingSearchParams: SearchParams\n-): Promise<SearchParams> {\n-  const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams)\n-  if (cachedSearchParams) {\n-    return cachedSearchParams\n-  }\n-\n-  const proxiedProperties = new Set<string>()\n-  const unproxiedProperties: Array<string> = []\n-\n-  const promise = Promise.resolve(underlyingSearchParams)\n-\n-  Object.keys(underlyingSearchParams).forEach((prop) => {\n-    if (wellKnownProperties.has(prop)) {\n-      // These properties cannot be shadowed because they need to be the\n-      // true underlying value for Promises to work correctly at runtime\n-      unproxiedProperties.push(prop)\n-    } else {\n-      proxiedProperties.add(prop)\n-      ;(promise as any)[prop] = underlyingSearchParams[prop]\n-    }\n-  })\n-\n-  const proxiedPromise = new Proxy(promise, {\n-    get(target, prop, receiver) {\n-      if (typeof prop === 'string') {\n-        if (\n-          !wellKnownProperties.has(prop) &&\n-          (proxiedProperties.has(prop) ||\n-            // We are accessing a property that doesn't exist on the promise nor\n-            // the underlying searchParams.\n-            Reflect.has(target, prop) === false)\n-        ) {\n-          const expression = describeStringPropertyAccess('searchParams', prop)\n-          warnForSyncAccess(expression)\n-        }\n-      }\n-      return ReflectAdapter.get(target, prop, receiver)\n-    },\n-    set(target, prop, value, receiver) {\n-      if (typeof prop === 'string') {\n-        proxiedProperties.delete(prop)\n-      }\n-      return Reflect.set(target, prop, value, receiver)\n-    },\n-    has(target, prop) {\n-      if (typeof prop === 'string') {\n-        if (\n-          !wellKnownProperties.has(prop) &&\n-          (proxiedProperties.has(prop) ||\n-            // We are accessing a property that doesn't exist on the promise nor\n-            // the underlying searchParams.\n-            Reflect.has(target, prop) === false)\n-        ) {\n-          const expression = describeHasCheckingStringProperty(\n-            'searchParams',\n-            prop\n-          )\n-          warnForSyncAccess(expression)\n-        }\n-      }\n-      return Reflect.has(target, prop)\n-    },\n-    ownKeys(target) {\n-      warnForSyncSpread()\n-      return Reflect.ownKeys(target)\n-    },\n-  })\n-\n-  CachedSearchParams.set(underlyingSearchParams, proxiedPromise)\n-  return proxiedPromise\n-}\n-\n-// Similar to `makeUntrackedExoticSearchParamsWithDevWarnings`, but just logging\n-// the sync access without actually defining the search params on the promise.\n function makeUntrackedSearchParamsWithDevWarnings(\n   underlyingSearchParams: SearchParams\n ): Promise<SearchParams> {\n@@ -95,14 +19,12 @@ function makeUntrackedSearchParamsWithDevWarnings(\n   }\n \n   const proxiedProperties = new Set<string>()\n-  const unproxiedProperties: Array<string> = []\n   const promise = Promise.resolve(underlyingSearchParams)\n \n   Object.keys(underlyingSearchParams).forEach((prop) => {\n     if (wellKnownProperties.has(prop)) {\n       // These properties cannot be shadowed because they need to be the\n       // true underlying value for Promises to work correctly at runtime\n-      unproxiedProperties.push(prop)\n     } else {\n       proxiedProperties.add(prop)\n     }\n@@ -161,25 +83,21 @@ function makeUntrackedSearchParamsWithDevWarnings(\n function warnForSyncAccess(expression: string) {\n   console.error(\n     `A searchParam property was accessed directly with ${expression}. ` +\n-      `\\`searchParams\\` should be unwrapped with \\`React.use()\\` before accessing its properties. ` +\n+      `\\`searchParams\\` is a Promise and must be unwrapped with \\`React.use()\\` before accessing its properties. ` +\n       `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n   )\n }\n \n function warnForSyncSpread() {\n   console.error(\n     `The keys of \\`searchParams\\` were accessed directly. ` +\n-      `\\`searchParams\\` should be unwrapped with \\`React.use()\\` before accessing its properties. ` +\n+      `\\`searchParams\\` is a Promise and must be unwrapped with \\`React.use()\\` before accessing its properties. ` +\n       `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n   )\n }\n \n export function createRenderSearchParamsFromClient(\n   underlyingSearchParams: SearchParams\n ): Promise<SearchParams> {\n-  if (process.env.__NEXT_CACHE_COMPONENTS) {\n-    return makeUntrackedSearchParamsWithDevWarnings(underlyingSearchParams)\n-  }\n-\n-  return makeUntrackedExoticSearchParamsWithDevWarnings(underlyingSearchParams)\n+  return makeUntrackedSearchParamsWithDevWarnings(underlyingSearchParams)\n }"
        },
        {
            "sha": "21b7c91de608c3b6a32fa320218c889ce8c9edba",
            "filename": "packages/next/src/client/request/search-params.browser.prod.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 33,
            "changes": 34,
            "blob_url": "https://github.com/vercel/next.js/blob/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/packages%2Fnext%2Fsrc%2Fclient%2Frequest%2Fsearch-params.browser.prod.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/packages%2Fnext%2Fsrc%2Fclient%2Frequest%2Fsearch-params.browser.prod.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Frequest%2Fsearch-params.browser.prod.ts?ref=1dda5b668bc57fdad6c4cf840c2083e6c66ad9db",
            "patch": "@@ -1,36 +1,8 @@\n import type { SearchParams } from '../../server/request/search-params'\n \n-import { wellKnownProperties } from '../../shared/lib/utils/reflect-utils'\n-\n interface CacheLifetime {}\n const CachedSearchParams = new WeakMap<CacheLifetime, Promise<SearchParams>>()\n \n-function makeUntrackedExoticSearchParams(\n-  underlyingSearchParams: SearchParams\n-): Promise<SearchParams> {\n-  const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams)\n-  if (cachedSearchParams) {\n-    return cachedSearchParams\n-  }\n-\n-  // We don't use makeResolvedReactPromise here because searchParams\n-  // supports copying with spread and we don't want to unnecessarily\n-  // instrument the promise with spreadable properties of ReactPromise.\n-  const promise = Promise.resolve(underlyingSearchParams)\n-  CachedSearchParams.set(underlyingSearchParams, promise)\n-\n-  Object.keys(underlyingSearchParams).forEach((prop) => {\n-    if (wellKnownProperties.has(prop)) {\n-      // These properties cannot be shadowed because they need to be the\n-      // true underlying value for Promises to work correctly at runtime\n-    } else {\n-      ;(promise as any)[prop] = underlyingSearchParams[prop]\n-    }\n-  })\n-\n-  return promise\n-}\n-\n function makeUntrackedSearchParams(\n   underlyingSearchParams: SearchParams\n ): Promise<SearchParams> {\n@@ -48,9 +20,5 @@ function makeUntrackedSearchParams(\n export function createRenderSearchParamsFromClient(\n   underlyingSearchParams: SearchParams\n ): Promise<SearchParams> {\n-  if (process.env.__NEXT_CACHE_COMPONENTS) {\n-    return makeUntrackedSearchParams(underlyingSearchParams)\n-  }\n-\n-  return makeUntrackedExoticSearchParams(underlyingSearchParams)\n+  return makeUntrackedSearchParams(underlyingSearchParams)\n }"
        },
        {
            "sha": "a675c0f85a797482d1ce99bd3391eb3556376f04",
            "filename": "packages/next/src/server/app-render/dynamic-rendering.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 4,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fdynamic-rendering.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fdynamic-rendering.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fdynamic-rendering.ts?ref=1dda5b668bc57fdad6c4cf840c2083e6c66ad9db",
            "patch": "@@ -342,10 +342,6 @@ export function abortAndThrowOnSynchronousRequestDataAccess(\n   )\n }\n \n-// For now these implementations are the same so we just reexport\n-export const trackSynchronousRequestDataAccessInDev =\n-  trackSynchronousPlatformIOAccessInDev\n-\n /**\n  * This component will call `React.postpone` that throws the postponed error.\n  */"
        },
        {
            "sha": "1ef8f185e9d0c1af4eaaaef482866246d9a16fb6",
            "filename": "packages/next/src/server/request/connection.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fconnection.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fconnection.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fconnection.ts?ref=1dda5b668bc57fdad6c4cf840c2083e6c66ad9db",
            "patch": "@@ -32,7 +32,7 @@ export function connection(): Promise<void> {\n       !isRequestAPICallableInsideAfter()\n     ) {\n       throw new Error(\n-        `Route ${workStore.route} used \"connection\" inside \"after(...)\". The \\`connection()\\` function is used to indicate the subsequent code must only run when there is an actual Request, but \"after(...)\" executes after the request, so this function is not allowed in this scope. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after`\n+        `Route ${workStore.route} used \\`connection()\\` inside \\`after()\\`. The \\`connection()\\` function is used to indicate the subsequent code must only run when there is an actual Request, but \\`after()\\` executes after the request, so this function is not allowed in this scope. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after`\n       )\n     }\n \n@@ -44,15 +44,15 @@ export function connection(): Promise<void> {\n \n     if (workStore.dynamicShouldError) {\n       throw new StaticGenBailoutError(\n-        `Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`connection\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n+        `Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`connection()\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n       )\n     }\n \n     if (workUnitStore) {\n       switch (workUnitStore.type) {\n         case 'cache': {\n           const error = new Error(\n-            `Route ${workStore.route} used \"connection\" inside \"use cache\". The \\`connection()\\` function is used to indicate the subsequent code must only run when there is an actual request, but caches must be able to be produced before a request, so this function is not allowed in this scope. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n+            `Route ${workStore.route} used \\`connection()\\` inside \"use cache\". The \\`connection()\\` function is used to indicate the subsequent code must only run when there is an actual request, but caches must be able to be produced before a request, so this function is not allowed in this scope. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n           )\n           Error.captureStackTrace(error, connection)\n           workStore.invalidDynamicUsageError ??= error\n@@ -63,15 +63,15 @@ export function connection(): Promise<void> {\n           // we don't consider runtime prefetches as \"actual requests\" (in the\n           // navigation sense), despite allowing them to read cookies.\n           const error = new Error(\n-            `Route ${workStore.route} used \"connection\" inside \"use cache: private\". The \\`connection()\\` function is used to indicate the subsequent code must only run when there is an actual navigation request, but caches must be able to be produced before a navigation request, so this function is not allowed in this scope. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n+            `Route ${workStore.route} used \\`connection()\\` inside \"use cache: private\". The \\`connection()\\` function is used to indicate the subsequent code must only run when there is an actual navigation request, but caches must be able to be produced before a navigation request, so this function is not allowed in this scope. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n           )\n           Error.captureStackTrace(error, connection)\n           workStore.invalidDynamicUsageError ??= error\n           throw error\n         }\n         case 'unstable-cache':\n           throw new Error(\n-            `Route ${workStore.route} used \"connection\" inside a function cached with \"unstable_cache(...)\". The \\`connection()\\` function is used to indicate the subsequent code must only run when there is an actual Request, but caches must be able to be produced before a Request so this function is not allowed in this scope. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n+            `Route ${workStore.route} used \\`connection()\\` inside a function cached with \\`unstable_cache()\\`. The \\`connection()\\` function is used to indicate the subsequent code must only run when there is an actual Request, but caches must be able to be produced before a Request so this function is not allowed in this scope. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n           )\n         case 'prerender':\n         case 'prerender-client':"
        },
        {
            "sha": "6b5100b4d762a4c847041bd97123b3ae6dd0830b",
            "filename": "packages/next/src/server/request/cookies.ts",
            "status": "modified",
            "additions": 10,
            "deletions": 325,
            "changes": 335,
            "blob_url": "https://github.com/vercel/next.js/blob/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fcookies.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fcookies.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fcookies.ts?ref=1dda5b668bc57fdad6c4cf840c2083e6c66ad9db",
            "patch": "@@ -1,6 +1,5 @@\n import {\n   type ReadonlyRequestCookies,\n-  type ResponseCookies,\n   areCookiesMutableInCurrentPhase,\n   RequestCookiesAdapter,\n } from '../web/spec-extension/adapters/request-cookies'\n@@ -19,7 +18,6 @@ import {\n   postponeWithTracking,\n   throwToInterruptStaticGeneration,\n   trackDynamicDataInDynamicRender,\n-  trackSynchronousRequestDataAccessInDev,\n } from '../app-render/dynamic-rendering'\n import { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\n import {\n@@ -31,29 +29,6 @@ import { isRequestAPICallableInsideAfter } from './utils'\n import { InvariantError } from '../../shared/lib/invariant-error'\n import { ReflectAdapter } from '../web/spec-extension/adapters/reflect'\n \n-/**\n- * In this version of Next.js `cookies()` returns a Promise however you can still reference the properties of the underlying cookies object\n- * synchronously to facilitate migration. The `UnsafeUnwrappedCookies` type is added to your code by a codemod that attempts to automatically\n- * updates callsites to reflect the new Promise return type. There are some cases where `cookies()` cannot be automatically converted, namely\n- * when it is used inside a synchronous function and we can't be sure the function can be made async automatically. In these cases we add an\n- * explicit type case to `UnsafeUnwrappedCookies` to enable typescript to allow for the synchronous usage only where it is actually necessary.\n- *\n- * You should should update these callsites to either be async functions where the `cookies()` value can be awaited or you should call `cookies()`\n- * from outside and await the return value before passing it into this function.\n- *\n- * You can find instances that require manual migration by searching for `UnsafeUnwrappedCookies` in your codebase or by search for a comment that\n- * starts with `@next-codemod-error`.\n- *\n- * In a future version of Next.js `cookies()` will only return a Promise and you will not be able to access the underlying cookies object directly\n- * without awaiting the return value first. When this change happens the type `UnsafeUnwrappedCookies` will be updated to reflect that is it no longer\n- * usable.\n- *\n- * This type is marked deprecated to help identify it as target for refactoring away.\n- *\n- * @deprecated\n- */\n-export type UnsafeUnwrappedCookies = ReadonlyRequestCookies\n-\n export function cookies(): Promise<ReadonlyRequestCookies> {\n   const callingExpression = 'cookies'\n   const workStore = workAsyncStorage.getStore()\n@@ -67,42 +42,42 @@ export function cookies(): Promise<ReadonlyRequestCookies> {\n     ) {\n       throw new Error(\n         // TODO(after): clarify that this only applies to pages?\n-        `Route ${workStore.route} used \"cookies\" inside \"after(...)\". This is not supported. If you need this data inside an \"after\" callback, use \"cookies\" outside of the callback. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after`\n+        `Route ${workStore.route} used \\`cookies()\\` inside \\`after()\\`. This is not supported. If you need this data inside an \\`after()\\` callback, use \\`cookies()\\` outside of the callback. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after`\n       )\n     }\n \n     if (workStore.forceStatic) {\n       // When using forceStatic we override all other logic and always just return an empty\n       // cookies object without tracking\n       const underlyingCookies = createEmptyCookies()\n-      return makeUntrackedExoticCookies(underlyingCookies)\n+      return makeUntrackedCookies(underlyingCookies)\n     }\n \n     if (workStore.dynamicShouldError) {\n       throw new StaticGenBailoutError(\n-        `Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`cookies\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n+        `Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`cookies()\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n       )\n     }\n \n     if (workUnitStore) {\n       switch (workUnitStore.type) {\n         case 'cache':\n           const error = new Error(\n-            `Route ${workStore.route} used \"cookies\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"cookies\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n+            `Route ${workStore.route} used \\`cookies()\\` inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \\`cookies()\\` outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n           )\n           Error.captureStackTrace(error, cookies)\n           workStore.invalidDynamicUsageError ??= error\n           throw error\n         case 'unstable-cache':\n           throw new Error(\n-            `Route ${workStore.route} used \"cookies\" inside a function cached with \"unstable_cache(...)\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"cookies\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n+            `Route ${workStore.route} used \\`cookies()\\` inside a function cached with \\`unstable_cache()\\`. Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \\`cookies()\\` outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n           )\n         case 'prerender':\n           return makeHangingCookies(workStore, workUnitStore)\n         case 'prerender-client':\n           const exportName = '`cookies`'\n           throw new InvariantError(\n-            `${exportName} must not be used within a client component. Next.js should be preventing ${exportName} from being included in client components statically, but did not in this case.`\n+            `${exportName} must not be used within a Client Component. Next.js should be preventing ${exportName} from being included in Client Components statically, but did not in this case.`\n           )\n         case 'prerender-ppr':\n           // We need track dynamic access here eagerly to keep continuity with\n@@ -128,10 +103,7 @@ export function cookies(): Promise<ReadonlyRequestCookies> {\n         case 'private-cache':\n           // Private caches are delayed until the runtime stage in use-cache-wrapper,\n           // so we don't need an additional delay here.\n-          if (process.env.__NEXT_CACHE_COMPONENTS) {\n-            return makeUntrackedCookies(workUnitStore.cookies)\n-          }\n-          return makeUntrackedExoticCookies(workUnitStore.cookies)\n+          return makeUntrackedCookies(workUnitStore.cookies)\n         case 'request':\n           trackDynamicDataInDynamicRender(workUnitStore)\n \n@@ -150,23 +122,12 @@ export function cookies(): Promise<ReadonlyRequestCookies> {\n             // Semantically we only need the dev tracking when running in `next dev`\n             // but since you would never use next dev with production NODE_ENV we use this\n             // as a proxy so we can statically exclude this code from production builds.\n-            if (process.env.__NEXT_CACHE_COMPONENTS) {\n-              return makeUntrackedCookiesWithDevWarnings(\n-                underlyingCookies,\n-                workStore?.route\n-              )\n-            }\n-\n-            return makeUntrackedExoticCookiesWithDevWarnings(\n+            return makeUntrackedCookiesWithDevWarnings(\n               underlyingCookies,\n               workStore?.route\n             )\n           } else {\n-            if (process.env.__NEXT_CACHE_COMPONENTS) {\n-              return makeUntrackedCookies(underlyingCookies)\n-            }\n-\n-            return makeUntrackedExoticCookies(underlyingCookies)\n+            return makeUntrackedCookies(underlyingCookies)\n           }\n         default:\n           workUnitStore satisfies never\n@@ -221,220 +182,6 @@ function makeUntrackedCookies(\n   return promise\n }\n \n-function makeUntrackedExoticCookies(\n-  underlyingCookies: ReadonlyRequestCookies\n-): Promise<ReadonlyRequestCookies> {\n-  const cachedCookies = CachedCookies.get(underlyingCookies)\n-  if (cachedCookies) {\n-    return cachedCookies\n-  }\n-\n-  const promise = Promise.resolve(underlyingCookies)\n-  CachedCookies.set(underlyingCookies, promise)\n-\n-  Object.defineProperties(promise, {\n-    [Symbol.iterator]: {\n-      value: underlyingCookies[Symbol.iterator]\n-        ? underlyingCookies[Symbol.iterator].bind(underlyingCookies)\n-        : // TODO this is a polyfill for when the underlying type is ResponseCookies\n-          // We should remove this and unify our cookies types. We could just let this continue to throw lazily\n-          // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with\n-          // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it\n-          // has extra properties not available on RequestCookie instances.\n-          polyfilledResponseCookiesIterator.bind(underlyingCookies),\n-    },\n-    size: {\n-      get(): number {\n-        return underlyingCookies.size\n-      },\n-    },\n-    get: {\n-      value: underlyingCookies.get.bind(underlyingCookies),\n-    },\n-    getAll: {\n-      value: underlyingCookies.getAll.bind(underlyingCookies),\n-    },\n-    has: {\n-      value: underlyingCookies.has.bind(underlyingCookies),\n-    },\n-    set: {\n-      value: underlyingCookies.set.bind(underlyingCookies),\n-    },\n-    delete: {\n-      value: underlyingCookies.delete.bind(underlyingCookies),\n-    },\n-    clear: {\n-      value:\n-        // @ts-expect-error clear is defined in RequestCookies implementation but not in the type\n-        typeof underlyingCookies.clear === 'function'\n-          ? // @ts-expect-error clear is defined in RequestCookies implementation but not in the type\n-            underlyingCookies.clear.bind(underlyingCookies)\n-          : // TODO this is a polyfill for when the underlying type is ResponseCookies\n-            // We should remove this and unify our cookies types. We could just let this continue to throw lazily\n-            // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with\n-            // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it\n-            // has extra properties not available on RequestCookie instances.\n-            polyfilledResponseCookiesClear.bind(underlyingCookies, promise),\n-    },\n-    toString: {\n-      value: underlyingCookies.toString.bind(underlyingCookies),\n-    },\n-  } satisfies CookieExtensions)\n-\n-  return promise\n-}\n-\n-function makeUntrackedExoticCookiesWithDevWarnings(\n-  underlyingCookies: ReadonlyRequestCookies,\n-  route?: string\n-): Promise<ReadonlyRequestCookies> {\n-  const cachedCookies = CachedCookies.get(underlyingCookies)\n-  if (cachedCookies) {\n-    return cachedCookies\n-  }\n-\n-  const promise = makeDevtoolsIOAwarePromise(underlyingCookies)\n-  CachedCookies.set(underlyingCookies, promise)\n-\n-  Object.defineProperties(promise, {\n-    [Symbol.iterator]: {\n-      value: function () {\n-        const expression = '`...cookies()` or similar iteration'\n-        syncIODev(route, expression)\n-        return underlyingCookies[Symbol.iterator]\n-          ? underlyingCookies[Symbol.iterator].apply(\n-              underlyingCookies,\n-              arguments as any\n-            )\n-          : // TODO this is a polyfill for when the underlying type is ResponseCookies\n-            // We should remove this and unify our cookies types. We could just let this continue to throw lazily\n-            // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with\n-            // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it\n-            // has extra properties not available on RequestCookie instances.\n-            polyfilledResponseCookiesIterator.call(underlyingCookies)\n-      },\n-      writable: false,\n-    },\n-    size: {\n-      get(): number {\n-        const expression = '`cookies().size`'\n-        syncIODev(route, expression)\n-        return underlyingCookies.size\n-      },\n-    },\n-    get: {\n-      value: function get() {\n-        let expression: string\n-        if (arguments.length === 0) {\n-          expression = '`cookies().get()`'\n-        } else {\n-          expression = `\\`cookies().get(${describeNameArg(arguments[0])})\\``\n-        }\n-        syncIODev(route, expression)\n-        return underlyingCookies.get.apply(underlyingCookies, arguments as any)\n-      },\n-      writable: false,\n-    },\n-    getAll: {\n-      value: function getAll() {\n-        let expression: string\n-        if (arguments.length === 0) {\n-          expression = '`cookies().getAll()`'\n-        } else {\n-          expression = `\\`cookies().getAll(${describeNameArg(arguments[0])})\\``\n-        }\n-        syncIODev(route, expression)\n-        return underlyingCookies.getAll.apply(\n-          underlyingCookies,\n-          arguments as any\n-        )\n-      },\n-      writable: false,\n-    },\n-    has: {\n-      value: function get() {\n-        let expression: string\n-        if (arguments.length === 0) {\n-          expression = '`cookies().has()`'\n-        } else {\n-          expression = `\\`cookies().has(${describeNameArg(arguments[0])})\\``\n-        }\n-        syncIODev(route, expression)\n-        return underlyingCookies.has.apply(underlyingCookies, arguments as any)\n-      },\n-      writable: false,\n-    },\n-    set: {\n-      value: function set() {\n-        let expression: string\n-        if (arguments.length === 0) {\n-          expression = '`cookies().set()`'\n-        } else {\n-          const arg = arguments[0]\n-          if (arg) {\n-            expression = `\\`cookies().set(${describeNameArg(arg)}, ...)\\``\n-          } else {\n-            expression = '`cookies().set(...)`'\n-          }\n-        }\n-        syncIODev(route, expression)\n-        return underlyingCookies.set.apply(underlyingCookies, arguments as any)\n-      },\n-      writable: false,\n-    },\n-    delete: {\n-      value: function () {\n-        let expression: string\n-        if (arguments.length === 0) {\n-          expression = '`cookies().delete()`'\n-        } else if (arguments.length === 1) {\n-          expression = `\\`cookies().delete(${describeNameArg(arguments[0])})\\``\n-        } else {\n-          expression = `\\`cookies().delete(${describeNameArg(arguments[0])}, ...)\\``\n-        }\n-        syncIODev(route, expression)\n-        return underlyingCookies.delete.apply(\n-          underlyingCookies,\n-          arguments as any\n-        )\n-      },\n-      writable: false,\n-    },\n-    clear: {\n-      value: function clear() {\n-        const expression = '`cookies().clear()`'\n-        syncIODev(route, expression)\n-        // @ts-ignore clear is defined in RequestCookies implementation but not in the type\n-        return typeof underlyingCookies.clear === 'function'\n-          ? // @ts-ignore clear is defined in RequestCookies implementation but not in the type\n-            underlyingCookies.clear.apply(underlyingCookies, arguments)\n-          : // TODO this is a polyfill for when the underlying type is ResponseCookies\n-            // We should remove this and unify our cookies types. We could just let this continue to throw lazily\n-            // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with\n-            // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it\n-            // has extra properties not available on RequestCookie instances.\n-            polyfilledResponseCookiesClear.call(underlyingCookies, promise)\n-      },\n-      writable: false,\n-    },\n-    toString: {\n-      value: function toString() {\n-        const expression = '`cookies().toString()` or implicit casting'\n-        syncIODev(route, expression)\n-        return underlyingCookies.toString.apply(\n-          underlyingCookies,\n-          arguments as any\n-        )\n-      },\n-      writable: false,\n-    },\n-  } satisfies CookieExtensions)\n-\n-  return promise\n-}\n-\n-// Similar to `makeUntrackedExoticCookiesWithDevWarnings`, but just logging the\n-// sync access without actually defining the cookies properties on the promise.\n function makeUntrackedCookiesWithDevWarnings(\n   underlyingCookies: ReadonlyRequestCookies,\n   route?: string\n@@ -478,46 +225,6 @@ function makeUntrackedCookiesWithDevWarnings(\n   return proxiedPromise\n }\n \n-function describeNameArg(arg: unknown) {\n-  return typeof arg === 'object' &&\n-    arg !== null &&\n-    typeof (arg as any).name === 'string'\n-    ? `'${(arg as any).name}'`\n-    : typeof arg === 'string'\n-      ? `'${arg}'`\n-      : '...'\n-}\n-\n-function syncIODev(route: string | undefined, expression: string) {\n-  const workUnitStore = workUnitAsyncStorage.getStore()\n-\n-  if (workUnitStore) {\n-    switch (workUnitStore.type) {\n-      case 'request':\n-        if (workUnitStore.prerenderPhase === true) {\n-          // When we're rendering dynamically in dev, we need to advance out of\n-          // the Prerender environment when we read Request data synchronously.\n-          trackSynchronousRequestDataAccessInDev(workUnitStore)\n-        }\n-        break\n-      case 'prerender':\n-      case 'prerender-client':\n-      case 'prerender-runtime':\n-      case 'prerender-ppr':\n-      case 'prerender-legacy':\n-      case 'cache':\n-      case 'private-cache':\n-      case 'unstable-cache':\n-        break\n-      default:\n-        workUnitStore satisfies never\n-    }\n-  }\n-\n-  // In all cases we warn normally\n-  warnForSyncAccess(route, expression)\n-}\n-\n const warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n   createCookiesAccessError\n )\n@@ -529,29 +236,7 @@ function createCookiesAccessError(\n   const prefix = route ? `Route \"${route}\" ` : 'This route '\n   return new Error(\n     `${prefix}used ${expression}. ` +\n-      `\\`cookies()\\` should be awaited before using its value. ` +\n+      `\\`cookies()\\` returns a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. ` +\n       `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n   )\n }\n-\n-function polyfilledResponseCookiesIterator(\n-  this: ResponseCookies\n-): ReturnType<ReadonlyRequestCookies[typeof Symbol.iterator]> {\n-  return this.getAll()\n-    .map((c) => [c.name, c] as [string, any])\n-    .values()\n-}\n-\n-function polyfilledResponseCookiesClear(\n-  this: ResponseCookies,\n-  returnable: Promise<ReadonlyRequestCookies>\n-): typeof returnable {\n-  for (const cookie of this.getAll()) {\n-    this.delete(cookie.name)\n-  }\n-  return returnable\n-}\n-\n-type CookieExtensions = {\n-  [K in keyof ReadonlyRequestCookies | 'clear']: unknown\n-}"
        },
        {
            "sha": "0dbeaa5c2378276b1f58a5c3c538fdb3b101725b",
            "filename": "packages/next/src/server/request/draft-mode.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 134,
            "changes": 141,
            "blob_url": "https://github.com/vercel/next.js/blob/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fdraft-mode.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fdraft-mode.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fdraft-mode.ts?ref=1dda5b668bc57fdad6c4cf840c2083e6c66ad9db",
            "patch": "@@ -15,37 +15,13 @@ import {\n   delayUntilRuntimeStage,\n   postponeWithTracking,\n   trackDynamicDataInDynamicRender,\n-  trackSynchronousRequestDataAccessInDev,\n } from '../app-render/dynamic-rendering'\n import { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\n import { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\n import { DynamicServerError } from '../../client/components/hooks-server-context'\n import { InvariantError } from '../../shared/lib/invariant-error'\n import { ReflectAdapter } from '../web/spec-extension/adapters/reflect'\n \n-/**\n- * In this version of Next.js `draftMode()` returns a Promise however you can still reference the properties of the underlying draftMode object\n- * synchronously to facilitate migration. The `UnsafeUnwrappedDraftMode` type is added to your code by a codemod that attempts to automatically\n- * updates callsites to reflect the new Promise return type. There are some cases where `draftMode()` cannot be automatically converted, namely\n- * when it is used inside a synchronous function and we can't be sure the function can be made async automatically. In these cases we add an\n- * explicit type case to `UnsafeUnwrappedDraftMode` to enable typescript to allow for the synchronous usage only where it is actually necessary.\n- *\n- * You should should update these callsites to either be async functions where the `draftMode()` value can be awaited or you should call `draftMode()`\n- * from outside and await the return value before passing it into this function.\n- *\n- * You can find instances that require manual migration by searching for `UnsafeUnwrappedDraftMode` in your codebase or by search for a comment that\n- * starts with `@next-codemod-error`.\n- *\n- * In a future version of Next.js `draftMode()` will only return a Promise and you will not be able to access the underlying draftMode object directly\n- * without awaiting the return value first. When this change happens the type `UnsafeUnwrappedDraftMode` will be updated to reflect that is it no longer\n- * usable.\n- *\n- * This type is marked deprecated to help identify it as target for refactoring away.\n- *\n- * @deprecated\n- */\n-export type UnsafeUnwrappedDraftMode = DraftMode\n-\n export function draftMode(): Promise<DraftMode> {\n   const callingExpression = 'draftMode'\n   const workStore = workAsyncStorage.getStore()\n@@ -105,90 +81,18 @@ function createOrGetCachedDraftMode(\n     return cachedDraftMode\n   }\n \n-  let promise: Promise<DraftMode>\n-\n   if (process.env.NODE_ENV === 'development' && !workStore?.isPrefetchRequest) {\n     const route = workStore?.route\n-\n-    if (process.env.__NEXT_CACHE_COMPONENTS) {\n-      return createDraftModeWithDevWarnings(draftModeProvider, route)\n-    }\n-\n-    promise = createExoticDraftModeWithDevWarnings(draftModeProvider, route)\n+    return createDraftModeWithDevWarnings(draftModeProvider, route)\n   } else {\n-    if (process.env.__NEXT_CACHE_COMPONENTS) {\n-      return Promise.resolve(new DraftMode(draftModeProvider))\n-    }\n-\n-    promise = createExoticDraftMode(draftModeProvider)\n+    return Promise.resolve(new DraftMode(draftModeProvider))\n   }\n-\n-  CachedDraftModes.set(cacheKey, promise)\n-\n-  return promise\n }\n \n interface CacheLifetime {}\n const NullDraftMode = {}\n const CachedDraftModes = new WeakMap<CacheLifetime, Promise<DraftMode>>()\n \n-function createExoticDraftMode(\n-  underlyingProvider: null | DraftModeProvider\n-): Promise<DraftMode> {\n-  const instance = new DraftMode(underlyingProvider)\n-  const promise = Promise.resolve(instance)\n-\n-  Object.defineProperty(promise, 'isEnabled', {\n-    get() {\n-      return instance.isEnabled\n-    },\n-    enumerable: true,\n-    configurable: true,\n-  })\n-  ;(promise as any).enable = instance.enable.bind(instance)\n-  ;(promise as any).disable = instance.disable.bind(instance)\n-\n-  return promise\n-}\n-\n-function createExoticDraftModeWithDevWarnings(\n-  underlyingProvider: null | DraftModeProvider,\n-  route: undefined | string\n-): Promise<DraftMode> {\n-  const instance = new DraftMode(underlyingProvider)\n-  const promise = Promise.resolve(instance)\n-\n-  Object.defineProperty(promise, 'isEnabled', {\n-    get() {\n-      const expression = '`draftMode().isEnabled`'\n-      syncIODev(route, expression)\n-      return instance.isEnabled\n-    },\n-    enumerable: true,\n-    configurable: true,\n-  })\n-\n-  Object.defineProperty(promise, 'enable', {\n-    value: function get() {\n-      const expression = '`draftMode().enable()`'\n-      syncIODev(route, expression)\n-      return instance.enable.apply(instance, arguments as any)\n-    },\n-  })\n-\n-  Object.defineProperty(promise, 'disable', {\n-    value: function get() {\n-      const expression = '`draftMode().disable()`'\n-      syncIODev(route, expression)\n-      return instance.disable.apply(instance, arguments as any)\n-    },\n-  })\n-\n-  return promise\n-}\n-\n-// Similar to `createExoticDraftModeWithDevWarnings`, but just logging the sync\n-// access without actually defining the draftMode properties on the promise.\n function createDraftModeWithDevWarnings(\n   underlyingProvider: null | DraftModeProvider,\n   route: undefined | string\n@@ -249,37 +153,6 @@ class DraftMode {\n     }\n   }\n }\n-\n-function syncIODev(route: string | undefined, expression: string) {\n-  const workUnitStore = workUnitAsyncStorage.getStore()\n-\n-  if (workUnitStore) {\n-    switch (workUnitStore.type) {\n-      case 'request':\n-        if (workUnitStore.prerenderPhase === true) {\n-          // When we're rendering dynamically in dev, we need to advance out of\n-          // the Prerender environment when we read Request data synchronously.\n-          trackSynchronousRequestDataAccessInDev(workUnitStore)\n-        }\n-        break\n-      case 'prerender':\n-      case 'prerender-client':\n-      case 'prerender-runtime':\n-      case 'prerender-ppr':\n-      case 'prerender-legacy':\n-      case 'cache':\n-      case 'private-cache':\n-      case 'unstable-cache':\n-        break\n-      default:\n-        workUnitStore satisfies never\n-    }\n-  }\n-\n-  // In all cases we warn normally\n-  warnForSyncAccess(route, expression)\n-}\n-\n const warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n   createDraftModeAccessError\n )\n@@ -291,7 +164,7 @@ function createDraftModeAccessError(\n   const prefix = route ? `Route \"${route}\" ` : 'This route '\n   return new Error(\n     `${prefix}used ${expression}. ` +\n-      `\\`draftMode()\\` should be awaited before using its value. ` +\n+      `\\`draftMode()\\` returns a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. ` +\n       `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n   )\n }\n@@ -305,7 +178,7 @@ function trackDynamicDraftMode(expression: string, constructorOpt: Function) {\n     // don't statically generate routes that manipulate draft mode.\n     if (workUnitStore?.phase === 'after') {\n       throw new Error(\n-        `Route ${workStore.route} used \"${expression}\" inside \\`after\\`. The enabled status of draftMode can be read inside \\`after\\` but you cannot enable or disable draftMode. See more info here: https://nextjs.org/docs/app/api-reference/functions/after`\n+        `Route ${workStore.route} used \"${expression}\" inside \\`after()\\`. The enabled status of \\`draftMode()\\` can be read inside \\`after()\\` but you cannot enable or disable \\`draftMode()\\`. See more info here: https://nextjs.org/docs/app/api-reference/functions/after`\n       )\n     }\n \n@@ -320,15 +193,15 @@ function trackDynamicDraftMode(expression: string, constructorOpt: Function) {\n         case 'cache':\n         case 'private-cache': {\n           const error = new Error(\n-            `Route ${workStore.route} used \"${expression}\" inside \"use cache\". The enabled status of draftMode can be read in caches but you must not enable or disable draftMode inside a cache. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n+            `Route ${workStore.route} used \"${expression}\" inside \"use cache\". The enabled status of \\`draftMode()\\` can be read in caches but you must not enable or disable \\`draftMode()\\` inside a cache. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n           )\n           Error.captureStackTrace(error, constructorOpt)\n           workStore.invalidDynamicUsageError ??= error\n           throw error\n         }\n         case 'unstable-cache':\n           throw new Error(\n-            `Route ${workStore.route} used \"${expression}\" inside a function cached with \"unstable_cache(...)\". The enabled status of draftMode can be read in caches but you must not enable or disable draftMode inside a cache. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n+            `Route ${workStore.route} used \"${expression}\" inside a function cached with \\`unstable_cache()\\`. The enabled status of \\`draftMode()\\` can be read in caches but you must not enable or disable \\`draftMode()\\` inside a cache. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n           )\n \n         case 'prerender':\n@@ -346,7 +219,7 @@ function trackDynamicDraftMode(expression: string, constructorOpt: Function) {\n         case 'prerender-client':\n           const exportName = '`draftMode`'\n           throw new InvariantError(\n-            `${exportName} must not be used within a client component. Next.js should be preventing ${exportName} from being included in client components statically, but did not in this case.`\n+            `${exportName} must not be used within a Client Component. Next.js should be preventing ${exportName} from being included in Client Components statically, but did not in this case.`\n           )\n         case 'prerender-ppr':\n           return postponeWithTracking("
        },
        {
            "sha": "48e99793ee21ced1a5719834b493aa9e26f890fa",
            "filename": "packages/next/src/server/request/headers.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 254,
            "changes": 263,
            "blob_url": "https://github.com/vercel/next.js/blob/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fheaders.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fheaders.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fheaders.ts?ref=1dda5b668bc57fdad6c4cf840c2083e6c66ad9db",
            "patch": "@@ -16,7 +16,6 @@ import {\n   postponeWithTracking,\n   throwToInterruptStaticGeneration,\n   trackDynamicDataInDynamicRender,\n-  trackSynchronousRequestDataAccessInDev,\n } from '../app-render/dynamic-rendering'\n import { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\n import {\n@@ -28,29 +27,6 @@ import { isRequestAPICallableInsideAfter } from './utils'\n import { InvariantError } from '../../shared/lib/invariant-error'\n import { ReflectAdapter } from '../web/spec-extension/adapters/reflect'\n \n-/**\n- * In this version of Next.js `headers()` returns a Promise however you can still reference the properties of the underlying Headers instance\n- * synchronously to facilitate migration. The `UnsafeUnwrappedHeaders` type is added to your code by a codemod that attempts to automatically\n- * updates callsites to reflect the new Promise return type. There are some cases where `headers()` cannot be automatically converted, namely\n- * when it is used inside a synchronous function and we can't be sure the function can be made async automatically. In these cases we add an\n- * explicit type case to `UnsafeUnwrappedHeaders` to enable typescript to allow for the synchronous usage only where it is actually necessary.\n- *\n- * You should should update these callsites to either be async functions where the `headers()` value can be awaited or you should call `headers()`\n- * from outside and await the return value before passing it into this function.\n- *\n- * You can find instances that require manual migration by searching for `UnsafeUnwrappedHeaders` in your codebase or by search for a comment that\n- * starts with `@next-codemod-error`.\n- *\n- * In a future version of Next.js `headers()` will only return a Promise and you will not be able to access the underlying Headers instance\n- * without awaiting the return value first. When this change happens the type `UnsafeUnwrappedHeaders` will be updated to reflect that is it no longer\n- * usable.\n- *\n- * This type is marked deprecated to help identify it as target for refactoring away.\n- *\n- * @deprecated\n- */\n-export type UnsafeUnwrappedHeaders = ReadonlyHeaders\n-\n /**\n  * This function allows you to read the HTTP incoming request headers in\n  * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n@@ -72,30 +48,30 @@ export function headers(): Promise<ReadonlyHeaders> {\n       !isRequestAPICallableInsideAfter()\n     ) {\n       throw new Error(\n-        `Route ${workStore.route} used \"headers\" inside \"after(...)\". This is not supported. If you need this data inside an \"after\" callback, use \"headers\" outside of the callback. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after`\n+        `Route ${workStore.route} used \\`headers()\\` inside \\`after()\\`. This is not supported. If you need this data inside an \\`after()\\` callback, use \\`headers()\\` outside of the callback. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after`\n       )\n     }\n \n     if (workStore.forceStatic) {\n       // When using forceStatic we override all other logic and always just return an empty\n       // headers object without tracking\n       const underlyingHeaders = HeadersAdapter.seal(new Headers({}))\n-      return makeUntrackedExoticHeaders(underlyingHeaders)\n+      return makeUntrackedHeaders(underlyingHeaders)\n     }\n \n     if (workUnitStore) {\n       switch (workUnitStore.type) {\n         case 'cache': {\n           const error = new Error(\n-            `Route ${workStore.route} used \"headers\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"headers\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n+            `Route ${workStore.route} used \\`headers()\\` inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \\`headers()\\` outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n           )\n           Error.captureStackTrace(error, headers)\n           workStore.invalidDynamicUsageError ??= error\n           throw error\n         }\n         case 'unstable-cache':\n           throw new Error(\n-            `Route ${workStore.route} used \"headers\" inside a function cached with \"unstable_cache(...)\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"headers\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n+            `Route ${workStore.route} used \\`headers()\\` inside a function cached with \\`unstable_cache()\\`. Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \\`headers()\\` outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n           )\n         case 'prerender':\n         case 'prerender-client':\n@@ -112,7 +88,7 @@ export function headers(): Promise<ReadonlyHeaders> {\n \n     if (workStore.dynamicShouldError) {\n       throw new StaticGenBailoutError(\n-        `Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`headers\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n+        `Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`headers()\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n       )\n     }\n \n@@ -153,34 +129,20 @@ export function headers(): Promise<ReadonlyHeaders> {\n         case 'private-cache':\n           // Private caches are delayed until the runtime stage in use-cache-wrapper,\n           // so we don't need an additional delay here.\n-          if (process.env.__NEXT_CACHE_COMPONENTS) {\n-            return makeUntrackedHeaders(workUnitStore.headers)\n-          }\n-          return makeUntrackedExoticHeaders(workUnitStore.headers)\n+          return makeUntrackedHeaders(workUnitStore.headers)\n         case 'request':\n           trackDynamicDataInDynamicRender(workUnitStore)\n \n           if (process.env.NODE_ENV === 'development') {\n             // Semantically we only need the dev tracking when running in `next dev`\n             // but since you would never use next dev with production NODE_ENV we use this\n             // as a proxy so we can statically exclude this code from production builds.\n-            if (process.env.__NEXT_CACHE_COMPONENTS) {\n-              return makeUntrackedHeadersWithDevWarnings(\n-                workUnitStore.headers,\n-                workStore?.route\n-              )\n-            }\n-\n-            return makeUntrackedExoticHeadersWithDevWarnings(\n+            return makeUntrackedHeadersWithDevWarnings(\n               workUnitStore.headers,\n               workStore?.route\n             )\n           } else {\n-            if (process.env.__NEXT_CACHE_COMPONENTS) {\n-              return makeUntrackedHeaders(workUnitStore.headers)\n-            }\n-\n-            return makeUntrackedExoticHeaders(workUnitStore.headers)\n+            return makeUntrackedHeaders(workUnitStore.headers)\n           }\n           break\n         default:\n@@ -229,175 +191,6 @@ function makeUntrackedHeaders(\n   return promise\n }\n \n-function makeUntrackedExoticHeaders(\n-  underlyingHeaders: ReadonlyHeaders\n-): Promise<ReadonlyHeaders> {\n-  const cachedHeaders = CachedHeaders.get(underlyingHeaders)\n-  if (cachedHeaders) {\n-    return cachedHeaders\n-  }\n-\n-  const promise = Promise.resolve(underlyingHeaders)\n-  CachedHeaders.set(underlyingHeaders, promise)\n-\n-  Object.defineProperties(promise, {\n-    append: {\n-      value: underlyingHeaders.append.bind(underlyingHeaders),\n-    },\n-    delete: {\n-      value: underlyingHeaders.delete.bind(underlyingHeaders),\n-    },\n-    get: {\n-      value: underlyingHeaders.get.bind(underlyingHeaders),\n-    },\n-    has: {\n-      value: underlyingHeaders.has.bind(underlyingHeaders),\n-    },\n-    set: {\n-      value: underlyingHeaders.set.bind(underlyingHeaders),\n-    },\n-    getSetCookie: {\n-      value: underlyingHeaders.getSetCookie.bind(underlyingHeaders),\n-    },\n-    forEach: {\n-      value: underlyingHeaders.forEach.bind(underlyingHeaders),\n-    },\n-    keys: {\n-      value: underlyingHeaders.keys.bind(underlyingHeaders),\n-    },\n-    values: {\n-      value: underlyingHeaders.values.bind(underlyingHeaders),\n-    },\n-    entries: {\n-      value: underlyingHeaders.entries.bind(underlyingHeaders),\n-    },\n-    [Symbol.iterator]: {\n-      value: underlyingHeaders[Symbol.iterator].bind(underlyingHeaders),\n-    },\n-  } satisfies HeadersExtensions)\n-\n-  return promise\n-}\n-\n-function makeUntrackedExoticHeadersWithDevWarnings(\n-  underlyingHeaders: ReadonlyHeaders,\n-  route?: string\n-): Promise<ReadonlyHeaders> {\n-  const cachedHeaders = CachedHeaders.get(underlyingHeaders)\n-  if (cachedHeaders) {\n-    return cachedHeaders\n-  }\n-\n-  const promise = makeDevtoolsIOAwarePromise(underlyingHeaders)\n-\n-  CachedHeaders.set(underlyingHeaders, promise)\n-\n-  Object.defineProperties(promise, {\n-    append: {\n-      value: function append() {\n-        const expression = `\\`headers().append(${describeNameArg(arguments[0])}, ...)\\``\n-        syncIODev(route, expression)\n-        return underlyingHeaders.append.apply(\n-          underlyingHeaders,\n-          arguments as any\n-        )\n-      },\n-    },\n-    delete: {\n-      value: function _delete() {\n-        const expression = `\\`headers().delete(${describeNameArg(arguments[0])})\\``\n-        syncIODev(route, expression)\n-        return underlyingHeaders.delete.apply(\n-          underlyingHeaders,\n-          arguments as any\n-        )\n-      },\n-    },\n-    get: {\n-      value: function get() {\n-        const expression = `\\`headers().get(${describeNameArg(arguments[0])})\\``\n-        syncIODev(route, expression)\n-        return underlyingHeaders.get.apply(underlyingHeaders, arguments as any)\n-      },\n-    },\n-    has: {\n-      value: function has() {\n-        const expression = `\\`headers().has(${describeNameArg(arguments[0])})\\``\n-        syncIODev(route, expression)\n-        return underlyingHeaders.has.apply(underlyingHeaders, arguments as any)\n-      },\n-    },\n-    set: {\n-      value: function set() {\n-        const expression = `\\`headers().set(${describeNameArg(arguments[0])}, ...)\\``\n-        syncIODev(route, expression)\n-        return underlyingHeaders.set.apply(underlyingHeaders, arguments as any)\n-      },\n-    },\n-    getSetCookie: {\n-      value: function getSetCookie() {\n-        const expression = '`headers().getSetCookie()`'\n-        syncIODev(route, expression)\n-        return underlyingHeaders.getSetCookie.apply(\n-          underlyingHeaders,\n-          arguments as any\n-        )\n-      },\n-    },\n-    forEach: {\n-      value: function forEach() {\n-        const expression = '`headers().forEach(...)`'\n-        syncIODev(route, expression)\n-        return underlyingHeaders.forEach.apply(\n-          underlyingHeaders,\n-          arguments as any\n-        )\n-      },\n-    },\n-    keys: {\n-      value: function keys() {\n-        const expression = '`headers().keys()`'\n-        syncIODev(route, expression)\n-        return underlyingHeaders.keys.apply(underlyingHeaders, arguments as any)\n-      },\n-    },\n-    values: {\n-      value: function values() {\n-        const expression = '`headers().values()`'\n-        syncIODev(route, expression)\n-        return underlyingHeaders.values.apply(\n-          underlyingHeaders,\n-          arguments as any\n-        )\n-      },\n-    },\n-    entries: {\n-      value: function entries() {\n-        const expression = '`headers().entries()`'\n-        syncIODev(route, expression)\n-        return underlyingHeaders.entries.apply(\n-          underlyingHeaders,\n-          arguments as any\n-        )\n-      },\n-    },\n-    [Symbol.iterator]: {\n-      value: function () {\n-        const expression = '`...headers()` or similar iteration'\n-        syncIODev(route, expression)\n-        return underlyingHeaders[Symbol.iterator].apply(\n-          underlyingHeaders,\n-          arguments as any\n-        )\n-      },\n-    },\n-  } satisfies HeadersExtensions)\n-\n-  return promise\n-}\n-\n-// Similar to `makeUntrackedExoticHeadersWithDevWarnings`, but just logging the\n-// sync access without actually defining the headers properties on the promise.\n function makeUntrackedHeadersWithDevWarnings(\n   underlyingHeaders: ReadonlyHeaders,\n   route?: string\n@@ -443,40 +236,6 @@ function makeUntrackedHeadersWithDevWarnings(\n   return proxiedPromise\n }\n \n-function describeNameArg(arg: unknown) {\n-  return typeof arg === 'string' ? `'${arg}'` : '...'\n-}\n-\n-function syncIODev(route: string | undefined, expression: string) {\n-  const workUnitStore = workUnitAsyncStorage.getStore()\n-\n-  if (workUnitStore) {\n-    switch (workUnitStore.type) {\n-      case 'request':\n-        if (workUnitStore.prerenderPhase === true) {\n-          // When we're rendering dynamically in dev, we need to advance out of\n-          // the Prerender environment when we read Request data synchronously.\n-          trackSynchronousRequestDataAccessInDev(workUnitStore)\n-        }\n-        break\n-      case 'prerender':\n-      case 'prerender-client':\n-      case 'prerender-runtime':\n-      case 'prerender-ppr':\n-      case 'prerender-legacy':\n-      case 'cache':\n-      case 'private-cache':\n-      case 'unstable-cache':\n-        break\n-      default:\n-        workUnitStore satisfies never\n-    }\n-  }\n-\n-  // In all cases we warn normally\n-  warnForSyncAccess(route, expression)\n-}\n-\n const warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n   createHeadersAccessError\n )\n@@ -488,11 +247,7 @@ function createHeadersAccessError(\n   const prefix = route ? `Route \"${route}\" ` : 'This route '\n   return new Error(\n     `${prefix}used ${expression}. ` +\n-      `\\`headers()\\` should be awaited before using its value. ` +\n+      `\\`headers()\\` returns a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. ` +\n       `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n   )\n }\n-\n-type HeadersExtensions = {\n-  [K in keyof ReadonlyHeaders]: unknown\n-}"
        },
        {
            "sha": "2e0485b0538d4f2461e8586bf1e6e214454e292a",
            "filename": "packages/next/src/server/request/params.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 257,
            "changes": 266,
            "blob_url": "https://github.com/vercel/next.js/blob/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fparams.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fparams.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fparams.ts?ref=1dda5b668bc57fdad6c4cf840c2083e6c66ad9db",
            "patch": "@@ -8,7 +8,6 @@ import { ReflectAdapter } from '../web/spec-extension/adapters/reflect'\n import {\n   throwToInterruptStaticGeneration,\n   postponeWithTracking,\n-  trackSynchronousRequestDataAccessInDev,\n   delayUntilRuntimeStage,\n } from '../app-render/dynamic-rendering'\n \n@@ -36,34 +35,6 @@ import { dynamicAccessAsyncStorage } from '../app-render/dynamic-access-async-st\n export type ParamValue = string | Array<string> | undefined\n export type Params = Record<string, ParamValue>\n \n-/**\n- * In this version of Next.js the `params` prop passed to Layouts, Pages, and other Segments is a Promise.\n- * However to facilitate migration to this new Promise type you can currently still access params directly on the Promise instance passed to these Segments.\n- * The `UnsafeUnwrappedParams` type is available if you need to temporarily access the underlying params without first awaiting or `use`ing the Promise.\n- *\n- * In a future version of Next.js the `params` prop will be a plain Promise and this type will be removed.\n- *\n- * Typically instances of `params` can be updated automatically to be treated as a Promise by a codemod published alongside this Next.js version however if you\n- * have not yet run the codemod of the codemod cannot detect certain instances of `params` usage you should first try to refactor your code to await `params`.\n- *\n- * If refactoring is not possible but you still want to be able to access params directly without typescript errors you can cast the params Promise to this type\n- *\n- * ```tsx\n- * type Props = { params: Promise<{ id: string }>}\n- *\n- * export default async function Layout(props: Props) {\n- *  const directParams = (props.params as unknown as UnsafeUnwrappedParams<typeof props.params>)\n- *  return ...\n- * }\n- * ```\n- *\n- * This type is marked deprecated to help identify it as target for refactoring away.\n- *\n- * @deprecated\n- */\n-export type UnsafeUnwrappedParams<P> =\n-  P extends Promise<infer U> ? Omit<U, 'then' | 'status' | 'value'> : never\n-\n export function createParamsFromClient(\n   underlyingParams: Params,\n   workStore: WorkStore\n@@ -290,7 +261,7 @@ function createStaticPrerenderParams(\n       if (fallbackParams) {\n         for (const key in underlyingParams) {\n           if (fallbackParams.has(key)) {\n-            return makeErroringExoticParams(\n+            return makeErroringParams(\n               underlyingParams,\n               fallbackParams,\n               workStore,\n@@ -307,11 +278,7 @@ function createStaticPrerenderParams(\n       prerenderStore satisfies never\n   }\n \n-  if (process.env.__NEXT_CACHE_COMPONENTS) {\n-    return makeUntrackedParams(underlyingParams)\n-  } else {\n-    return makeUntrackedExoticParams(underlyingParams)\n-  }\n+  return makeUntrackedParams(underlyingParams)\n }\n \n function createRuntimePrerenderParams(\n@@ -320,18 +287,12 @@ function createRuntimePrerenderParams(\n ): Promise<Params> {\n   return delayUntilRuntimeStage(\n     workUnitStore,\n-    process.env.__NEXT_CACHE_COMPONENTS\n-      ? makeUntrackedParams(underlyingParams)\n-      : makeUntrackedExoticParams(underlyingParams)\n+    makeUntrackedParams(underlyingParams)\n   )\n }\n \n function createRenderParamsInProd(underlyingParams: Params): Promise<Params> {\n-  if (process.env.__NEXT_CACHE_COMPONENTS) {\n-    return makeUntrackedParams(underlyingParams)\n-  }\n-\n-  return makeUntrackedExoticParams(underlyingParams)\n+  return makeUntrackedParams(underlyingParams)\n }\n \n function createRenderParamsInDev(\n@@ -348,15 +309,8 @@ function createRenderParamsInDev(\n       }\n     }\n   }\n-  if (process.env.__NEXT_CACHE_COMPONENTS) {\n-    return makeDynamicallyTrackedParamsWithDevWarnings(\n-      underlyingParams,\n-      hasFallbackParams,\n-      workStore\n-    )\n-  }\n \n-  return makeDynamicallyTrackedExoticParamsWithDevWarnings(\n+  return makeDynamicallyTrackedParamsWithDevWarnings(\n     underlyingParams,\n     hasFallbackParams,\n     workStore\n@@ -417,7 +371,7 @@ function makeHangingParams(\n   return promise\n }\n \n-function makeErroringExoticParams(\n+function makeErroringParams(\n   underlyingParams: Params,\n   fallbackParams: OpaqueFallbackRouteParams,\n   workStore: WorkStore,\n@@ -469,74 +423,13 @@ function makeErroringExoticParams(\n           },\n           enumerable: true,\n         })\n-        Object.defineProperty(promise, prop, {\n-          get() {\n-            const expression = describeStringPropertyAccess('params', prop)\n-            // In most dynamic APIs we also throw if `dynamic = \"error\"` however\n-            // for params is only dynamic when we're generating a fallback shell\n-            // and even when `dynamic = \"error\"` we still support generating dynamic\n-            // fallback shells\n-            // TODO remove this comment when cacheComponents is the default since there\n-            // will be no `dynamic = \"error\"`\n-            if (prerenderStore.type === 'prerender-ppr') {\n-              // PPR Prerender (no cacheComponents)\n-              postponeWithTracking(\n-                workStore.route,\n-                expression,\n-                prerenderStore.dynamicTracking\n-              )\n-            } else {\n-              // Legacy Prerender\n-              throwToInterruptStaticGeneration(\n-                expression,\n-                workStore,\n-                prerenderStore\n-              )\n-            }\n-          },\n-          set(newValue) {\n-            Object.defineProperty(promise, prop, {\n-              value: newValue,\n-              writable: true,\n-              enumerable: true,\n-            })\n-          },\n-          enumerable: true,\n-          configurable: true,\n-        })\n-      } else {\n-        ;(promise as any)[prop] = underlyingParams[prop]\n       }\n     }\n   })\n \n   return promise\n }\n \n-function makeUntrackedExoticParams(underlyingParams: Params): Promise<Params> {\n-  const cachedParams = CachedParams.get(underlyingParams)\n-  if (cachedParams) {\n-    return cachedParams\n-  }\n-\n-  // We don't use makeResolvedReactPromise here because params\n-  // supports copying with spread and we don't want to unnecessarily\n-  // instrument the promise with spreadable properties of ReactPromise.\n-  const promise = Promise.resolve(underlyingParams)\n-  CachedParams.set(underlyingParams, promise)\n-\n-  Object.keys(underlyingParams).forEach((prop) => {\n-    if (wellKnownProperties.has(prop)) {\n-      // These properties cannot be shadowed because they need to be the\n-      // true underlying value for Promises to work correctly at runtime\n-    } else {\n-      ;(promise as any)[prop] = underlyingParams[prop]\n-    }\n-  })\n-\n-  return promise\n-}\n-\n function makeUntrackedParams(underlyingParams: Params): Promise<Params> {\n   const cachedParams = CachedParams.get(underlyingParams)\n   if (cachedParams) {\n@@ -549,70 +442,6 @@ function makeUntrackedParams(underlyingParams: Params): Promise<Params> {\n   return promise\n }\n \n-function makeDynamicallyTrackedExoticParamsWithDevWarnings(\n-  underlyingParams: Params,\n-  hasFallbackParams: boolean,\n-  store: WorkStore\n-): Promise<Params> {\n-  const cachedParams = CachedParams.get(underlyingParams)\n-  if (cachedParams) {\n-    return cachedParams\n-  }\n-\n-  // We don't use makeResolvedReactPromise here because params\n-  // supports copying with spread and we don't want to unnecessarily\n-  // instrument the promise with spreadable properties of ReactPromise.\n-  const promise = hasFallbackParams\n-    ? makeDevtoolsIOAwarePromise(underlyingParams)\n-    : // We don't want to force an environment transition when this params is not part of the fallback params set\n-      Promise.resolve(underlyingParams)\n-\n-  const proxiedProperties = new Set<string>()\n-  const unproxiedProperties: Array<string> = []\n-\n-  Object.keys(underlyingParams).forEach((prop) => {\n-    if (wellKnownProperties.has(prop)) {\n-      // These properties cannot be shadowed because they need to be the\n-      // true underlying value for Promises to work correctly at runtime\n-      unproxiedProperties.push(prop)\n-    } else {\n-      proxiedProperties.add(prop)\n-      ;(promise as any)[prop] = underlyingParams[prop]\n-    }\n-  })\n-\n-  const proxiedPromise = new Proxy(promise, {\n-    get(target, prop, receiver) {\n-      if (typeof prop === 'string') {\n-        if (\n-          // We are accessing a property that was proxied to the promise instance\n-          proxiedProperties.has(prop)\n-        ) {\n-          const expression = describeStringPropertyAccess('params', prop)\n-          syncIODev(store.route, expression)\n-        }\n-      }\n-      return ReflectAdapter.get(target, prop, receiver)\n-    },\n-    set(target, prop, value, receiver) {\n-      if (typeof prop === 'string') {\n-        proxiedProperties.delete(prop)\n-      }\n-      return ReflectAdapter.set(target, prop, value, receiver)\n-    },\n-    ownKeys(target) {\n-      const expression = '`...params` or similar expression'\n-      syncIODev(store.route, expression, unproxiedProperties)\n-      return Reflect.ownKeys(target)\n-    },\n-  })\n-\n-  CachedParams.set(underlyingParams, proxiedPromise)\n-  return proxiedPromise\n-}\n-\n-// Similar to `makeDynamicallyTrackedExoticParamsWithDevWarnings`, but just\n-// logging the sync access without actually defining the params on the promise.\n function makeDynamicallyTrackedParamsWithDevWarnings(\n   underlyingParams: Params,\n   hasFallbackParams: boolean,\n@@ -631,14 +460,13 @@ function makeDynamicallyTrackedParamsWithDevWarnings(\n     : // We don't want to force an environment transition when this params is not part of the fallback params set\n       Promise.resolve(underlyingParams)\n \n+  // Track which properties we should warn for.\n   const proxiedProperties = new Set<string>()\n-  const unproxiedProperties: Array<string> = []\n \n   Object.keys(underlyingParams).forEach((prop) => {\n     if (wellKnownProperties.has(prop)) {\n       // These properties cannot be shadowed because they need to be the\n       // true underlying value for Promises to work correctly at runtime\n-      unproxiedProperties.push(prop)\n     } else {\n       proxiedProperties.add(prop)\n     }\n@@ -665,7 +493,7 @@ function makeDynamicallyTrackedParamsWithDevWarnings(\n     },\n     ownKeys(target) {\n       const expression = '`...params` or similar expression'\n-      warnForIncompleteEnumeration(store.route, expression, unproxiedProperties)\n+      warnForSyncAccess(store.route, expression)\n       return Reflect.ownKeys(target)\n     },\n   })\n@@ -674,94 +502,18 @@ function makeDynamicallyTrackedParamsWithDevWarnings(\n   return proxiedPromise\n }\n \n-function syncIODev(\n-  route: string | undefined,\n-  expression: string,\n-  missingProperties?: Array<string>\n-) {\n-  const workUnitStore = workUnitAsyncStorage.getStore()\n-  if (workUnitStore) {\n-    switch (workUnitStore.type) {\n-      case 'request':\n-        if (workUnitStore.prerenderPhase === true) {\n-          // When we're rendering dynamically in dev, we need to advance out of\n-          // the Prerender environment when we read Request data synchronously.\n-          trackSynchronousRequestDataAccessInDev(workUnitStore)\n-        }\n-        break\n-      case 'prerender':\n-      case 'prerender-client':\n-      case 'prerender-runtime':\n-      case 'prerender-ppr':\n-      case 'prerender-legacy':\n-      case 'cache':\n-      case 'private-cache':\n-      case 'unstable-cache':\n-        break\n-      default:\n-        workUnitStore satisfies never\n-    }\n-  }\n-  // In all cases we warn normally\n-  if (missingProperties && missingProperties.length > 0) {\n-    warnForIncompleteEnumeration(route, expression, missingProperties)\n-  } else {\n-    warnForSyncAccess(route, expression)\n-  }\n-}\n-\n const warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n   createParamsAccessError\n )\n \n-const warnForIncompleteEnumeration =\n-  createDedupedByCallsiteServerErrorLoggerDev(createIncompleteEnumerationError)\n-\n function createParamsAccessError(\n   route: string | undefined,\n   expression: string\n ) {\n   const prefix = route ? `Route \"${route}\" ` : 'This route '\n   return new Error(\n     `${prefix}used ${expression}. ` +\n-      `\\`params\\` should be awaited before using its properties. ` +\n-      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n-  )\n-}\n-\n-function createIncompleteEnumerationError(\n-  route: string | undefined,\n-  expression: string,\n-  missingProperties: Array<string>\n-) {\n-  const prefix = route ? `Route \"${route}\" ` : 'This route '\n-  return new Error(\n-    `${prefix}used ${expression}. ` +\n-      `\\`params\\` should be awaited before using its properties. ` +\n-      `The following properties were not available through enumeration ` +\n-      `because they conflict with builtin property names: ` +\n-      `${describeListOfPropertyNames(missingProperties)}. ` +\n+      `\\`params\\` is a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. ` +\n       `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n   )\n }\n-\n-function describeListOfPropertyNames(properties: Array<string>) {\n-  switch (properties.length) {\n-    case 0:\n-      throw new InvariantError(\n-        'Expected describeListOfPropertyNames to be called with a non-empty list of strings.'\n-      )\n-    case 1:\n-      return `\\`${properties[0]}\\``\n-    case 2:\n-      return `\\`${properties[0]}\\` and \\`${properties[1]}\\``\n-    default: {\n-      let description = ''\n-      for (let i = 0; i < properties.length - 1; i++) {\n-        description += `\\`${properties[i]}\\`, `\n-      }\n-      description += `, and \\`${properties[properties.length - 1]}\\``\n-      return description\n-    }\n-  }\n-}"
        },
        {
            "sha": "65718648d86e7d1c367c2a304b75a95ce07bb09b",
            "filename": "packages/next/src/server/request/search-params.ts",
            "status": "modified",
            "additions": 15,
            "deletions": 398,
            "changes": 413,
            "blob_url": "https://github.com/vercel/next.js/blob/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fsearch-params.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fsearch-params.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fsearch-params.ts?ref=1dda5b668bc57fdad6c4cf840c2083e6c66ad9db",
            "patch": "@@ -4,9 +4,7 @@ import { ReflectAdapter } from '../web/spec-extension/adapters/reflect'\n import {\n   throwToInterruptStaticGeneration,\n   postponeWithTracking,\n-  trackDynamicDataInDynamicRender,\n   annotateDynamicAccess,\n-  trackSynchronousRequestDataAccessInDev,\n   delayUntilRuntimeStage,\n } from '../app-render/dynamic-rendering'\n \n@@ -37,34 +35,6 @@ import {\n \n export type SearchParams = { [key: string]: string | string[] | undefined }\n \n-/**\n- * In this version of Next.js the `params` prop passed to Layouts, Pages, and other Segments is a Promise.\n- * However to facilitate migration to this new Promise type you can currently still access params directly on the Promise instance passed to these Segments.\n- * The `UnsafeUnwrappedSearchParams` type is available if you need to temporarily access the underlying params without first awaiting or `use`ing the Promise.\n- *\n- * In a future version of Next.js the `params` prop will be a plain Promise and this type will be removed.\n- *\n- * Typically instances of `params` can be updated automatically to be treated as a Promise by a codemod published alongside this Next.js version however if you\n- * have not yet run the codemod of the codemod cannot detect certain instances of `params` usage you should first try to refactor your code to await `params`.\n- *\n- * If refactoring is not possible but you still want to be able to access params directly without typescript errors you can cast the params Promise to this type\n- *\n- * ```tsx\n- * type Props = { searchParams: Promise<{ foo: string }> }\n- *\n- * export default async function Page(props: Props) {\n- *  const { searchParams } = (props.searchParams as unknown as UnsafeUnwrappedSearchParams<typeof props.searchParams>)\n- *  return ...\n- * }\n- * ```\n- *\n- * This type is marked deprecated to help identify it as target for refactoring away.\n- *\n- * @deprecated\n- */\n-export type UnsafeUnwrappedSearchParams<P> =\n-  P extends Promise<infer U> ? Omit<U, 'then' | 'status' | 'value'> : never\n-\n export function createSearchParamsFromClient(\n   underlyingSearchParams: SearchParams,\n   workStore: WorkStore\n@@ -193,7 +163,7 @@ function createStaticPrerenderSearchParams(\n     case 'prerender-legacy':\n       // We are in a legacy static generation and need to interrupt the\n       // prerender when search params are accessed.\n-      return makeErroringExoticSearchParams(workStore, prerenderStore)\n+      return makeErroringSearchParams(workStore, prerenderStore)\n     default:\n       return prerenderStore satisfies never\n   }\n@@ -205,9 +175,7 @@ function createRuntimePrerenderSearchParams(\n ): Promise<SearchParams> {\n   return delayUntilRuntimeStage(\n     workUnitStore,\n-    process.env.__NEXT_CACHE_COMPONENTS\n-      ? makeUntrackedSearchParams(underlyingSearchParams)\n-      : makeUntrackedExoticSearchParams(underlyingSearchParams)\n+    makeUntrackedSearchParams(underlyingSearchParams)\n   )\n }\n \n@@ -224,23 +192,12 @@ function createRenderSearchParams(\n       // Semantically we only need the dev tracking when running in `next dev`\n       // but since you would never use next dev with production NODE_ENV we use this\n       // as a proxy so we can statically exclude this code from production builds.\n-      if (process.env.__NEXT_CACHE_COMPONENTS) {\n-        return makeUntrackedSearchParamsWithDevWarnings(\n-          underlyingSearchParams,\n-          workStore\n-        )\n-      }\n-\n-      return makeDynamicallyTrackedExoticSearchParamsWithDevWarnings(\n+      return makeUntrackedSearchParamsWithDevWarnings(\n         underlyingSearchParams,\n         workStore\n       )\n     } else {\n-      if (process.env.__NEXT_CACHE_COMPONENTS) {\n-        return makeUntrackedSearchParams(underlyingSearchParams)\n-      }\n-\n-      return makeUntrackedExoticSearchParams(underlyingSearchParams)\n+      return makeUntrackedSearchParams(underlyingSearchParams)\n     }\n   }\n }\n@@ -302,7 +259,7 @@ function makeHangingSearchParams(\n   return proxiedPromise\n }\n \n-function makeErroringExoticSearchParams(\n+function makeErroringSearchParams(\n   workStore: WorkStore,\n   prerenderStore: PrerenderStoreLegacy | PrerenderStorePPR\n ): Promise<SearchParams> {\n@@ -326,98 +283,9 @@ function makeErroringExoticSearchParams(\n         return ReflectAdapter.get(target, prop, receiver)\n       }\n \n-      switch (prop) {\n-        case 'then': {\n-          const expression =\n-            '`await searchParams`, `searchParams.then`, or similar'\n-          if (workStore.dynamicShouldError) {\n-            throwWithStaticGenerationBailoutErrorWithDynamicError(\n-              workStore.route,\n-              expression\n-            )\n-          } else if (prerenderStore.type === 'prerender-ppr') {\n-            // PPR Prerender (no cacheComponents)\n-            postponeWithTracking(\n-              workStore.route,\n-              expression,\n-              prerenderStore.dynamicTracking\n-            )\n-          } else {\n-            // Legacy Prerender\n-            throwToInterruptStaticGeneration(\n-              expression,\n-              workStore,\n-              prerenderStore\n-            )\n-          }\n-          return\n-        }\n-        case 'status': {\n-          const expression =\n-            '`use(searchParams)`, `searchParams.status`, or similar'\n-          if (workStore.dynamicShouldError) {\n-            throwWithStaticGenerationBailoutErrorWithDynamicError(\n-              workStore.route,\n-              expression\n-            )\n-          } else if (prerenderStore.type === 'prerender-ppr') {\n-            // PPR Prerender (no cacheComponents)\n-            postponeWithTracking(\n-              workStore.route,\n-              expression,\n-              prerenderStore.dynamicTracking\n-            )\n-          } else {\n-            // Legacy Prerender\n-            throwToInterruptStaticGeneration(\n-              expression,\n-              workStore,\n-              prerenderStore\n-            )\n-          }\n-          return\n-        }\n-        default: {\n-          if (typeof prop === 'string' && !wellKnownProperties.has(prop)) {\n-            const expression = describeStringPropertyAccess(\n-              'searchParams',\n-              prop\n-            )\n-            if (workStore.dynamicShouldError) {\n-              throwWithStaticGenerationBailoutErrorWithDynamicError(\n-                workStore.route,\n-                expression\n-              )\n-            } else if (prerenderStore.type === 'prerender-ppr') {\n-              // PPR Prerender (no cacheComponents)\n-              postponeWithTracking(\n-                workStore.route,\n-                expression,\n-                prerenderStore.dynamicTracking\n-              )\n-            } else {\n-              // Legacy Prerender\n-              throwToInterruptStaticGeneration(\n-                expression,\n-                workStore,\n-                prerenderStore\n-              )\n-            }\n-          }\n-          return ReflectAdapter.get(target, prop, receiver)\n-        }\n-      }\n-    },\n-    has(target, prop) {\n-      // We don't expect key checking to be used except for testing the existence of\n-      // searchParams so we make all has tests trigger dynamic. this means that `promise.then`\n-      // can resolve to the then function on the Promise prototype but 'then' in promise will assume\n-      // you are testing whether the searchParams has a 'then' property.\n-      if (typeof prop === 'string') {\n-        const expression = describeHasCheckingStringProperty(\n-          'searchParams',\n-          prop\n-        )\n+      if (typeof prop === 'string' && prop === 'then') {\n+        const expression =\n+          '`await searchParams`, `searchParams.then`, or similar'\n         if (workStore.dynamicShouldError) {\n           throwWithStaticGenerationBailoutErrorWithDynamicError(\n             workStore.route,\n@@ -438,29 +306,8 @@ function makeErroringExoticSearchParams(\n             prerenderStore\n           )\n         }\n-        return false\n-      }\n-      return ReflectAdapter.has(target, prop)\n-    },\n-    ownKeys() {\n-      const expression =\n-        '`{...searchParams}`, `Object.keys(searchParams)`, or similar'\n-      if (workStore.dynamicShouldError) {\n-        throwWithStaticGenerationBailoutErrorWithDynamicError(\n-          workStore.route,\n-          expression\n-        )\n-      } else if (prerenderStore.type === 'prerender-ppr') {\n-        // PPR Prerender (no cacheComponents)\n-        postponeWithTracking(\n-          workStore.route,\n-          expression,\n-          prerenderStore.dynamicTracking\n-        )\n-      } else {\n-        // Legacy Prerender\n-        throwToInterruptStaticGeneration(expression, workStore, prerenderStore)\n       }\n+      return ReflectAdapter.get(target, prop, receiver)\n     },\n   })\n \n@@ -469,7 +316,7 @@ function makeErroringExoticSearchParams(\n }\n \n /**\n- * This is a variation of `makeErroringExoticSearchParams` that always throws an\n+ * This is a variation of `makeErroringSearchParams` that always throws an\n  * error on access, because accessing searchParams inside of `\"use cache\"` is\n  * not allowed.\n  */\n@@ -502,69 +349,12 @@ export function makeErroringSearchParamsForUseCache(\n \n       return ReflectAdapter.get(target, prop, receiver)\n     },\n-    has: function has(target, prop) {\n-      // We don't expect key checking to be used except for testing the existence of\n-      // searchParams so we make all has tests throw an error. this means that `promise.then`\n-      // can resolve to the then function on the Promise prototype but 'then' in promise will assume\n-      // you are testing whether the searchParams has a 'then' property.\n-      if (\n-        typeof prop === 'string' &&\n-        (prop === 'then' || !wellKnownProperties.has(prop))\n-      ) {\n-        throwForSearchParamsAccessInUseCache(workStore, has)\n-      }\n-\n-      return ReflectAdapter.has(target, prop)\n-    },\n-    ownKeys: function ownKeys() {\n-      throwForSearchParamsAccessInUseCache(workStore, ownKeys)\n-    },\n   })\n \n   CachedSearchParamsForUseCache.set(workStore, proxiedPromise)\n   return proxiedPromise\n }\n \n-function makeUntrackedExoticSearchParams(\n-  underlyingSearchParams: SearchParams\n-): Promise<SearchParams> {\n-  const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams)\n-  if (cachedSearchParams) {\n-    return cachedSearchParams\n-  }\n-\n-  // We don't use makeResolvedReactPromise here because searchParams\n-  // supports copying with spread and we don't want to unnecessarily\n-  // instrument the promise with spreadable properties of ReactPromise.\n-  const promise = Promise.resolve(underlyingSearchParams)\n-  CachedSearchParams.set(underlyingSearchParams, promise)\n-\n-  Object.keys(underlyingSearchParams).forEach((prop) => {\n-    if (!wellKnownProperties.has(prop)) {\n-      Object.defineProperty(promise, prop, {\n-        get() {\n-          const workUnitStore = workUnitAsyncStorage.getStore()\n-          if (workUnitStore) {\n-            trackDynamicDataInDynamicRender(workUnitStore)\n-          }\n-          return underlyingSearchParams[prop]\n-        },\n-        set(value) {\n-          Object.defineProperty(promise, prop, {\n-            value,\n-            writable: true,\n-            enumerable: true,\n-          })\n-        },\n-        enumerable: true,\n-        configurable: true,\n-      })\n-    }\n-  })\n-\n-  return promise\n-}\n-\n function makeUntrackedSearchParams(\n   underlyingSearchParams: SearchParams\n ): Promise<SearchParams> {\n@@ -579,7 +369,7 @@ function makeUntrackedSearchParams(\n   return promise\n }\n \n-function makeDynamicallyTrackedExoticSearchParamsWithDevWarnings(\n+function makeUntrackedSearchParamsWithDevWarnings(\n   underlyingSearchParams: SearchParams,\n   store: WorkStore\n ): Promise<SearchParams> {\n@@ -588,8 +378,8 @@ function makeDynamicallyTrackedExoticSearchParamsWithDevWarnings(\n     return cachedSearchParams\n   }\n \n+  // Track which properties we should warn for.\n   const proxiedProperties = new Set<string>()\n-  const unproxiedProperties: Array<string> = []\n \n   // We have an unfortunate sequence of events that requires this initialization logic. We want to instrument the underlying\n   // searchParams object to detect if you are accessing values in dev. This is used for warnings and for things like the static prerender\n@@ -608,10 +398,6 @@ function makeDynamicallyTrackedExoticSearchParamsWithDevWarnings(\n             expression\n           )\n         }\n-        const workUnitStore = workUnitAsyncStorage.getStore()\n-        if (workUnitStore) {\n-          trackDynamicDataInDynamicRender(workUnitStore)\n-        }\n       }\n       return ReflectAdapter.get(target, prop, receiver)\n     },\n@@ -646,7 +432,7 @@ function makeDynamicallyTrackedExoticSearchParamsWithDevWarnings(\n   // We don't use makeResolvedReactPromise here because searchParams\n   // supports copying with spread and we don't want to unnecessarily\n   // instrument the promise with spreadable properties of ReactPromise.\n-  const promise = makeDevtoolsIOAwarePromise(underlyingSearchParams)\n+  const promise = makeDevtoolsIOAwarePromise(proxiedUnderlying)\n   promise.then(() => {\n     promiseInitialized = true\n   })\n@@ -655,23 +441,8 @@ function makeDynamicallyTrackedExoticSearchParamsWithDevWarnings(\n     if (wellKnownProperties.has(prop)) {\n       // These properties cannot be shadowed because they need to be the\n       // true underlying value for Promises to work correctly at runtime\n-      unproxiedProperties.push(prop)\n     } else {\n       proxiedProperties.add(prop)\n-      Object.defineProperty(promise, prop, {\n-        get() {\n-          return proxiedUnderlying[prop]\n-        },\n-        set(newValue) {\n-          Object.defineProperty(promise, prop, {\n-            value: newValue,\n-            writable: true,\n-            enumerable: true,\n-          })\n-        },\n-        enumerable: true,\n-        configurable: true,\n-      })\n     }\n   })\n \n@@ -684,83 +455,6 @@ function makeDynamicallyTrackedExoticSearchParamsWithDevWarnings(\n           expression\n         )\n       }\n-      if (typeof prop === 'string') {\n-        if (\n-          !wellKnownProperties.has(prop) &&\n-          (proxiedProperties.has(prop) ||\n-            // We are accessing a property that doesn't exist on the promise nor\n-            // the underlying searchParams.\n-            Reflect.has(target, prop) === false)\n-        ) {\n-          const expression = describeStringPropertyAccess('searchParams', prop)\n-          syncIODev(store.route, expression)\n-        }\n-      }\n-      return ReflectAdapter.get(target, prop, receiver)\n-    },\n-    set(target, prop, value, receiver) {\n-      if (typeof prop === 'string') {\n-        proxiedProperties.delete(prop)\n-      }\n-      return Reflect.set(target, prop, value, receiver)\n-    },\n-    has(target, prop) {\n-      if (typeof prop === 'string') {\n-        if (\n-          !wellKnownProperties.has(prop) &&\n-          (proxiedProperties.has(prop) ||\n-            // We are accessing a property that doesn't exist on the promise nor\n-            // the underlying searchParams.\n-            Reflect.has(target, prop) === false)\n-        ) {\n-          const expression = describeHasCheckingStringProperty(\n-            'searchParams',\n-            prop\n-          )\n-          syncIODev(store.route, expression)\n-        }\n-      }\n-      return Reflect.has(target, prop)\n-    },\n-    ownKeys(target) {\n-      const expression = '`Object.keys(searchParams)` or similar'\n-      syncIODev(store.route, expression, unproxiedProperties)\n-      return Reflect.ownKeys(target)\n-    },\n-  })\n-\n-  CachedSearchParams.set(underlyingSearchParams, proxiedPromise)\n-  return proxiedPromise\n-}\n-\n-// Similar to `makeDynamicallyTrackedExoticSearchParamsWithDevWarnings`, but\n-// just logging the sync access without actually defining the search params on\n-// the promise.\n-function makeUntrackedSearchParamsWithDevWarnings(\n-  underlyingSearchParams: SearchParams,\n-  store: WorkStore\n-): Promise<SearchParams> {\n-  const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams)\n-  if (cachedSearchParams) {\n-    return cachedSearchParams\n-  }\n-\n-  const proxiedProperties = new Set<string>()\n-  const unproxiedProperties: Array<string> = []\n-  const promise = makeDevtoolsIOAwarePromise(underlyingSearchParams)\n-\n-  Object.keys(underlyingSearchParams).forEach((prop) => {\n-    if (wellKnownProperties.has(prop)) {\n-      // These properties cannot be shadowed because they need to be the\n-      // true underlying value for Promises to work correctly at runtime\n-      unproxiedProperties.push(prop)\n-    } else {\n-      proxiedProperties.add(prop)\n-    }\n-  })\n-\n-  const proxiedPromise = new Proxy(promise, {\n-    get(target, prop, receiver) {\n       if (typeof prop === 'string') {\n         if (\n           !wellKnownProperties.has(prop) &&\n@@ -801,7 +495,7 @@ function makeUntrackedSearchParamsWithDevWarnings(\n     },\n     ownKeys(target) {\n       const expression = '`Object.keys(searchParams)` or similar'\n-      warnForIncompleteEnumeration(store.route, expression, unproxiedProperties)\n+      warnForSyncAccess(store.route, expression)\n       return Reflect.ownKeys(target)\n     },\n   })\n@@ -810,95 +504,18 @@ function makeUntrackedSearchParamsWithDevWarnings(\n   return proxiedPromise\n }\n \n-function syncIODev(\n-  route: string | undefined,\n-  expression: string,\n-  missingProperties?: Array<string>\n-) {\n-  // In all cases we warn normally\n-  if (missingProperties && missingProperties.length > 0) {\n-    warnForIncompleteEnumeration(route, expression, missingProperties)\n-  } else {\n-    warnForSyncAccess(route, expression)\n-  }\n-\n-  const workUnitStore = workUnitAsyncStorage.getStore()\n-  if (workUnitStore) {\n-    switch (workUnitStore.type) {\n-      case 'request':\n-        if (workUnitStore.prerenderPhase === true) {\n-          // When we're rendering dynamically in dev, we need to advance out of\n-          // the Prerender environment when we read Request data synchronously.\n-          trackSynchronousRequestDataAccessInDev(workUnitStore)\n-        }\n-        break\n-      case 'prerender':\n-      case 'prerender-client':\n-      case 'prerender-runtime':\n-      case 'prerender-ppr':\n-      case 'prerender-legacy':\n-      case 'cache':\n-      case 'private-cache':\n-      case 'unstable-cache':\n-        break\n-      default:\n-        workUnitStore satisfies never\n-    }\n-  }\n-}\n-\n const warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n   createSearchAccessError\n )\n \n-const warnForIncompleteEnumeration =\n-  createDedupedByCallsiteServerErrorLoggerDev(createIncompleteEnumerationError)\n-\n function createSearchAccessError(\n   route: string | undefined,\n   expression: string\n ) {\n   const prefix = route ? `Route \"${route}\" ` : 'This route '\n   return new Error(\n     `${prefix}used ${expression}. ` +\n-      `\\`searchParams\\` should be awaited before using its properties. ` +\n+      `\\`searchParams\\` is a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. ` +\n       `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n   )\n }\n-\n-function createIncompleteEnumerationError(\n-  route: string | undefined,\n-  expression: string,\n-  missingProperties: Array<string>\n-) {\n-  const prefix = route ? `Route \"${route}\" ` : 'This route '\n-  return new Error(\n-    `${prefix}used ${expression}. ` +\n-      `\\`searchParams\\` should be awaited before using its properties. ` +\n-      `The following properties were not available through enumeration ` +\n-      `because they conflict with builtin or well-known property names: ` +\n-      `${describeListOfPropertyNames(missingProperties)}. ` +\n-      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n-  )\n-}\n-\n-function describeListOfPropertyNames(properties: Array<string>) {\n-  switch (properties.length) {\n-    case 0:\n-      throw new InvariantError(\n-        'Expected describeListOfPropertyNames to be called with a non-empty list of strings.'\n-      )\n-    case 1:\n-      return `\\`${properties[0]}\\``\n-    case 2:\n-      return `\\`${properties[0]}\\` and \\`${properties[1]}\\``\n-    default: {\n-      let description = ''\n-      for (let i = 0; i < properties.length - 1; i++) {\n-        description += `\\`${properties[i]}\\`, `\n-      }\n-      description += `, and \\`${properties[properties.length - 1]}\\``\n-      return description\n-    }\n-  }\n-}"
        },
        {
            "sha": "5053fb00452cd685b61a70773b163a7ec203726f",
            "filename": "packages/next/src/server/request/utils.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 10,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Futils.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Futils.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Futils.ts?ref=1dda5b668bc57fdad6c4cf840c2083e6c66ad9db",
            "patch": "@@ -2,15 +2,6 @@ import { StaticGenBailoutError } from '../../client/components/static-generation\n import { afterTaskAsyncStorage } from '../app-render/after-task-async-storage.external'\n import type { WorkStore } from '../app-render/work-async-storage.external'\n \n-export function throwWithStaticGenerationBailoutError(\n-  route: string,\n-  expression: string\n-): never {\n-  throw new StaticGenBailoutError(\n-    `Route ${route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n-  )\n-}\n-\n export function throwWithStaticGenerationBailoutErrorWithDynamicError(\n   route: string,\n   expression: string\n@@ -25,7 +16,7 @@ export function throwForSearchParamsAccessInUseCache(\n   constructorOpt: Function\n ): never {\n   const error = new Error(\n-    `Route ${workStore.route} used \"searchParams\" inside \"use cache\". Accessing dynamic request data inside a cache scope is not supported. If you need some search params inside a cached function await \"searchParams\" outside of the cached function and pass only the required search params as arguments to the cached function. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n+    `Route ${workStore.route} used \\`searchParams\\` inside \"use cache\". Accessing dynamic request data inside a cache scope is not supported. If you need some search params inside a cached function await \\`searchParams\\` outside of the cached function and pass only the required search params as arguments to the cached function. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n   )\n \n   Error.captureStackTrace(error, constructorOpt)"
        },
        {
            "sha": "752522c23dd884f5e3316627b12e590a8a0da10b",
            "filename": "test/development/app-dir/async-request-warnings/app/request/cookies/page.tsx",
            "status": "modified",
            "additions": 6,
            "deletions": 5,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fdevelopment%2Fapp-dir%2Fasync-request-warnings%2Fapp%2Frequest%2Fcookies%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fdevelopment%2Fapp-dir%2Fasync-request-warnings%2Fapp%2Frequest%2Fcookies%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Fapp-dir%2Fasync-request-warnings%2Fapp%2Frequest%2Fcookies%2Fpage.tsx?ref=1dda5b668bc57fdad6c4cf840c2083e6c66ad9db",
            "patch": "@@ -1,15 +1,16 @@\n-import { cookies, type UnsafeUnwrappedCookies } from 'next/headers'\n+import { cookies } from 'next/headers'\n \n function Component() {\n-  ;(cookies() as unknown as UnsafeUnwrappedCookies).get('component')\n-  ;(cookies() as unknown as UnsafeUnwrappedCookies).has('component')\n+  // Cast to any as we removed UnsafeUnwrapped types, but still need to test with the sync access\n+  ;(cookies() as any).get('component')\n+  ;(cookies() as any).has('component')\n \n-  const allCookies = [...(cookies() as unknown as UnsafeUnwrappedCookies)]\n+  const allCookies = [...(cookies() as any)]\n   return <pre>{JSON.stringify(allCookies, null, 2)}</pre>\n }\n \n export default function Page() {\n-  ;(cookies() as unknown as UnsafeUnwrappedCookies).get('page')\n+  ;(cookies() as any).get('page')\n   return (\n     <>\n       <Component />"
        },
        {
            "sha": "78bb23a90f8add3a7706a9e7341cce27a3cbb4e0",
            "filename": "test/development/app-dir/async-request-warnings/app/request/draftMode/page.tsx",
            "status": "modified",
            "additions": 6,
            "deletions": 7,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fdevelopment%2Fapp-dir%2Fasync-request-warnings%2Fapp%2Frequest%2FdraftMode%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fdevelopment%2Fapp-dir%2Fasync-request-warnings%2Fapp%2Frequest%2FdraftMode%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Fapp-dir%2Fasync-request-warnings%2Fapp%2Frequest%2FdraftMode%2Fpage.tsx?ref=1dda5b668bc57fdad6c4cf840c2083e6c66ad9db",
            "patch": "@@ -1,19 +1,18 @@\n-import { draftMode, type UnsafeUnwrappedDraftMode } from 'next/headers'\n+import { draftMode } from 'next/headers'\n \n function Component() {\n-  const isEnabled = (draftMode() as unknown as UnsafeUnwrappedDraftMode)\n-    .isEnabled\n-  ;(draftMode() as unknown as UnsafeUnwrappedDraftMode).enable()\n+  // Cast to any as we removed UnsafeUnwrapped types, but still need to test with the sync access\n+  const isEnabled = (draftMode() as any).isEnabled\n+  ;(draftMode() as any).enable()\n \n   const clonedDraftMode = {\n-    ...(draftMode() as unknown as UnsafeUnwrappedDraftMode),\n+    ...(draftMode() as any),\n   }\n   return <pre>{JSON.stringify({ clonedDraftMode, isEnabled }, null, 2)}</pre>\n }\n \n export default function Page() {\n-  const isEnabled = (draftMode() as unknown as UnsafeUnwrappedDraftMode)\n-    .isEnabled\n+  const isEnabled = (draftMode() as any).isEnabled\n   return (\n     <>\n       <pre>{JSON.stringify({ isEnabled }, null, 2)}</pre>"
        },
        {
            "sha": "dbb63ce8e90e01561a4b064406195f5882401eca",
            "filename": "test/development/app-dir/async-request-warnings/app/request/headers/page.tsx",
            "status": "modified",
            "additions": 6,
            "deletions": 5,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fdevelopment%2Fapp-dir%2Fasync-request-warnings%2Fapp%2Frequest%2Fheaders%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fdevelopment%2Fapp-dir%2Fasync-request-warnings%2Fapp%2Frequest%2Fheaders%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Fapp-dir%2Fasync-request-warnings%2Fapp%2Frequest%2Fheaders%2Fpage.tsx?ref=1dda5b668bc57fdad6c4cf840c2083e6c66ad9db",
            "patch": "@@ -1,15 +1,16 @@\n-import { headers, type UnsafeUnwrappedHeaders } from 'next/headers'\n+import { headers } from 'next/headers'\n \n function Component() {\n-  ;(headers() as unknown as UnsafeUnwrappedHeaders).get('component')\n-  ;(headers() as unknown as UnsafeUnwrappedHeaders).has('component')\n+  // Cast to any as we removed UnsafeUnwrapped types, but still need to test with the sync access\n+  ;(headers() as any).get('component')\n+  ;(headers() as any).has('component')\n \n-  const allHeaders = [...(headers() as unknown as UnsafeUnwrappedHeaders)]\n+  const allHeaders = [...(headers() as any)]\n   return <pre>{JSON.stringify(allHeaders, null, 2)}</pre>\n }\n \n export default function Page() {\n-  ;(headers() as unknown as UnsafeUnwrappedHeaders).get('page')\n+  ;(headers() as any).get('page')\n   return (\n     <>\n       <Component />"
        },
        {
            "sha": "df2b21988f4ecc4147e869a8430ecd00b1db670e",
            "filename": "test/development/app-dir/async-request-warnings/async-request-warnings.test.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 54,
            "changes": 62,
            "blob_url": "https://github.com/vercel/next.js/blob/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fdevelopment%2Fapp-dir%2Fasync-request-warnings%2Fasync-request-warnings.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fdevelopment%2Fapp-dir%2Fasync-request-warnings%2Fasync-request-warnings.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Fapp-dir%2Fasync-request-warnings%2Fasync-request-warnings.test.ts?ref=1dda5b668bc57fdad6c4cf840c2083e6c66ad9db",
            "patch": "@@ -19,18 +19,8 @@ describe('dynamic-requests warnings', () => {\n       return line.includes('Route \"/request/cookies')\n     })\n     expect({ browserConsoleWarnings, terminalCookieErrors }).toEqual({\n-      browserConsoleWarnings: [\n-        expect.stringContaining(\"`cookies().get('page')`.\"),\n-        expect.stringContaining(\"`cookies().get('component')`.\"),\n-        expect.stringContaining(\"`cookies().has('component')`.\"),\n-        expect.stringContaining('`...cookies()` or similar iteration'),\n-      ],\n-      terminalCookieErrors: [\n-        expect.stringContaining(\"`cookies().get('page')`.\"),\n-        expect.stringContaining(\"`cookies().get('component')`.\"),\n-        expect.stringContaining(\"`cookies().has('component')`.\"),\n-        expect.stringContaining('`...cookies()` or similar iteration'),\n-      ],\n+      browserConsoleWarnings: [expect.stringContaining('`cookies().get`.')],\n+      terminalCookieErrors: [expect.stringContaining('`cookies().get`.')],\n     })\n   })\n \n@@ -50,15 +40,9 @@ describe('dynamic-requests warnings', () => {\n     expect({ browserConsoleWarnings, terminalCookieErrors }).toEqual({\n       browserConsoleWarnings: [\n         expect.stringContaining('`draftMode().isEnabled`.'),\n-        expect.stringContaining('`draftMode().isEnabled`.'),\n-        expect.stringContaining('`draftMode().enable()`.'),\n-        expect.stringContaining('`draftMode().isEnabled`.'),\n       ],\n       terminalCookieErrors: [\n         expect.stringContaining('`draftMode().isEnabled`.'),\n-        expect.stringContaining('`draftMode().isEnabled`.'),\n-        expect.stringContaining('`draftMode().enable()`.'),\n-        expect.stringContaining('`draftMode().isEnabled`.'),\n       ],\n     })\n   })\n@@ -77,18 +61,8 @@ describe('dynamic-requests warnings', () => {\n       return line.includes('Route \"/request/headers')\n     })\n     expect({ browserConsoleWarnings, terminalCookieErrors }).toEqual({\n-      browserConsoleWarnings: [\n-        expect.stringContaining(\"`headers().get('page')`.\"),\n-        expect.stringContaining(\"`headers().get('component')`.\"),\n-        expect.stringContaining(\"`headers().has('component')`.\"),\n-        expect.stringContaining('`...headers()` or similar iteration'),\n-      ],\n-      terminalCookieErrors: [\n-        expect.stringContaining(\"`headers().get('page')`.\"),\n-        expect.stringContaining(\"`headers().get('component')`.\"),\n-        expect.stringContaining(\"`headers().has('component')`.\"),\n-        expect.stringContaining('`...headers()` or similar iteration'),\n-      ],\n+      browserConsoleWarnings: [expect.stringContaining('`headers().get`.')],\n+      terminalCookieErrors: [expect.stringContaining('`headers().get`.')],\n     })\n   })\n \n@@ -106,18 +80,8 @@ describe('dynamic-requests warnings', () => {\n       return line.includes('Route \"/request/params/[slug]')\n     })\n     expect({ browserConsoleWarnings, terminalCookieErrors }).toEqual({\n-      browserConsoleWarnings: [\n-        expect.stringContaining('`params.slug`.'),\n-        expect.stringContaining('`params.slug`.'),\n-        expect.stringContaining('`params.slug`.'),\n-        expect.stringContaining('`...params` or similar expression'),\n-      ],\n-      terminalCookieErrors: [\n-        expect.stringContaining('`params.slug`.'),\n-        expect.stringContaining('`params.slug`.'),\n-        expect.stringContaining('`params.slug`.'),\n-        expect.stringContaining('`...params` or similar expression'),\n-      ],\n+      browserConsoleWarnings: [expect.stringContaining('`params.slug`.')],\n+      terminalCookieErrors: [expect.stringContaining('`params.slug`.')],\n     })\n   })\n \n@@ -135,18 +99,8 @@ describe('dynamic-requests warnings', () => {\n       return line.includes('Route \"/request/searchParams')\n     })\n     expect({ browserConsoleWarnings, terminalCookieErrors }).toEqual({\n-      browserConsoleWarnings: [\n-        expect.stringContaining('`searchParams.slug`.'),\n-        expect.stringContaining('`searchParams.slug`.'),\n-        expect.stringContaining('`searchParams.slug`.'),\n-        expect.stringContaining('`Object.keys(searchParams)` or similar'),\n-      ],\n-      terminalCookieErrors: [\n-        expect.stringContaining('`searchParams.slug`.'),\n-        expect.stringContaining('`searchParams.slug`.'),\n-        expect.stringContaining('`searchParams.slug`.'),\n-        expect.stringContaining('`Object.keys(searchParams)` or similar'),\n-      ],\n+      browserConsoleWarnings: [expect.stringContaining('`searchParams.slug`.')],\n+      terminalCookieErrors: [expect.stringContaining('`searchParams.slug`.')],\n     })\n   })\n "
        },
        {
            "sha": "efe3824cd303ce2a76786963aba140a68568615d",
            "filename": "test/development/app-dir/dynamic-error-trace/index.test.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fdevelopment%2Fapp-dir%2Fdynamic-error-trace%2Findex.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fdevelopment%2Fapp-dir%2Fdynamic-error-trace%2Findex.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Fapp-dir%2Fdynamic-error-trace%2Findex.test.ts?ref=1dda5b668bc57fdad6c4cf840c2083e6c66ad9db",
            "patch": "@@ -13,7 +13,7 @@ describe('app dir - dynamic error trace', () => {\n     // TODO(veil): Where is the stackframe for app/page.js?\n     await expect(browser).toDisplayRedbox(`\n      {\n-       \"description\": \"Route / with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`headers\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering\",\n+       \"description\": \"Route / with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`headers()\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering\",\n        \"environmentLabel\": \"Server\",\n        \"label\": \"Runtime Error\",\n        \"source\": \"app/lib.js (4:13) @ Foo"
        },
        {
            "sha": "1d3b6f6719ae79bfed43cdf8a1ad1b22990dd423",
            "filename": "test/development/error-overlay/index.test.tsx",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fdevelopment%2Ferror-overlay%2Findex.test.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fdevelopment%2Ferror-overlay%2Findex.test.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Ferror-overlay%2Findex.test.tsx?ref=1dda5b668bc57fdad6c4cf840c2083e6c66ad9db",
            "patch": "@@ -14,7 +14,7 @@ describe('DevErrorOverlay', () => {\n \n     const errorCode = await browser.elementByCss('[data-nextjs-error-code]')\n     const code = await errorCode.getAttribute('data-nextjs-error-code')\n-    expect(code).toBe('E127')\n+    expect(code).toBe('E838')\n   })\n \n   it('sends feedback when clicking helpful button', async () => {"
        },
        {
            "sha": "73b476ce6bb70b6268e537ffea5e142e44d3a11a",
            "filename": "test/e2e/app-dir/app/app/dashboard/deployments/[id]/page.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fe2e%2Fapp-dir%2Fapp%2Fapp%2Fdashboard%2Fdeployments%2F%5Bid%5D%2Fpage.js",
            "raw_url": "https://github.com/vercel/next.js/raw/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fe2e%2Fapp-dir%2Fapp%2Fapp%2Fdashboard%2Fdeployments%2F%5Bid%5D%2Fpage.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fapp%2Fapp%2Fdashboard%2Fdeployments%2F%5Bid%5D%2Fpage.js?ref=1dda5b668bc57fdad6c4cf840c2083e6c66ad9db",
            "patch": "@@ -11,7 +11,7 @@ async function getData({ params }) {\n   console.log('data.json', data)\n \n   return {\n-    id: params.id,\n+    id: (await params).id,\n   }\n }\n "
        },
        {
            "sha": "1b3de92ef9ed85672e778878b63d1946aa96b888",
            "filename": "test/e2e/app-dir/cache-components-errors/cache-components-errors.test.ts",
            "status": "modified",
            "additions": 252,
            "deletions": 371,
            "changes": 623,
            "blob_url": "https://github.com/vercel/next.js/blob/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Fcache-components-errors.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Fcache-components-errors.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Fcache-components-errors.test.ts?ref=1dda5b668bc57fdad6c4cf840c2083e6c66ad9db",
            "patch": "@@ -1,9 +1,6 @@\n import { isNextDev, nextTestSetup } from 'e2e-utils'\n-import { assertNoErrorToast, retry } from 'next-test-utils'\n-import {\n-  convertModuleFunctionSequenceExpression,\n-  getPrerenderOutput,\n-} from './utils'\n+import { assertNoErrorToast } from 'next-test-utils'\n+import { getPrerenderOutput } from './utils'\n \n describe('Cache Components Errors', () => {\n   const { next, isTurbopack, isNextStart, skipped } = nextTestSetup({\n@@ -1102,34 +1099,19 @@ describe('Cache Components Errors', () => {\n             const browser = await next.browser(`${pathname}?foo=test`)\n \n             await expect(browser).toDisplayCollapsedRedbox(`\n-                        {\n-                          \"description\": \"A searchParam property was accessed directly with \\`searchParams.foo\\`. \\`searchParams\\` should be unwrapped with \\`React.use()\\` before accessing its properties. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis\",\n-                          \"environmentLabel\": null,\n-                          \"label\": \"Console Error\",\n-                          \"source\": \"app/sync-client-search/page.tsx (26:5) @ SearchParamsReadingComponent\n-                        > 26 |   ).foo\n-                             |     ^\",\n-                          \"stack\": [\n-                            \"SearchParamsReadingComponent app/sync-client-search/page.tsx (26:5)\",\n-                            \"Page app/sync-client-search/page.tsx (14:7)\",\n-                          ],\n-                        }\n-                      `)\n-          })\n-        } else {\n-          it('should not error the build when synchronously reading `searchParams.foo`', async () => {\n-            try {\n-              await prerender(pathname)\n-            } catch (error) {\n-              throw new Error('expected build not to fail', { cause: error })\n-            }\n-\n-            expect(next.cliOutput).toContain(` ${pathname}`)\n-            await next.start({ skipBuild: true })\n-            const browser = await next.browser(`${pathname}?foo=test`)\n-            expect(await browser.elementById('foo-param').text()).toBe(\n-              'undefined'\n-            )\n+             {\n+               \"description\": \"A searchParam property was accessed directly with \\`searchParams.foo\\`. \\`searchParams\\` is a Promise and must be unwrapped with \\`React.use()\\` before accessing its properties. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis\",\n+               \"environmentLabel\": null,\n+               \"label\": \"Console Error\",\n+               \"source\": \"app/sync-client-search/page.tsx (23:42) @ SearchParamsReadingComponent\n+             > 23 |   const fooParam = (searchParams as any).foo\n+                  |                                          ^\",\n+               \"stack\": [\n+                 \"SearchParamsReadingComponent app/sync-client-search/page.tsx (23:42)\",\n+                 \"Page app/sync-client-search/page.tsx (12:7)\",\n+               ],\n+             }\n+            `)\n           })\n         }\n       })\n@@ -1154,34 +1136,19 @@ describe('Cache Components Errors', () => {\n             const browser = await next.browser(`${pathname}?foo=test`)\n \n             await expect(browser).toDisplayCollapsedRedbox(`\n-                        {\n-                          \"description\": \"Route \"/sync-server-search\" used \\`searchParams.foo\\`. \\`searchParams\\` should be awaited before using its properties. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis\",\n-                          \"environmentLabel\": \"Prerender\",\n-                          \"label\": \"Console Error\",\n-                          \"source\": \"app/sync-server-search/page.tsx (30:5) @ SearchParamsReadingComponent\n-                        > 30 |   ).foo\n-                             |     ^\",\n-                          \"stack\": [\n-                            \"SearchParamsReadingComponent app/sync-server-search/page.tsx (30:5)\",\n-                            \"Page app/sync-server-search/page.tsx (15:7)\",\n-                          ],\n-                        }\n-                      `)\n-          })\n-        } else {\n-          it('should not error the build when synchronously reading `searchParams.foo`', async () => {\n-            try {\n-              await prerender(pathname)\n-            } catch (error) {\n-              throw new Error('expected build not to fail', { cause: error })\n-            }\n-\n-            expect(next.cliOutput).toContain(` ${pathname}`)\n-            await next.start({ skipBuild: true })\n-            const browser = await next.browser(`${pathname}?foo=test`)\n-            expect(await browser.elementById('foo-param').text()).toBe(\n-              'undefined'\n-            )\n+             {\n+               \"description\": \"Route \"/sync-server-search\" used \\`searchParams.foo\\`. \\`searchParams\\` is a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis\",\n+               \"environmentLabel\": \"Prerender\",\n+               \"label\": \"Console Error\",\n+               \"source\": \"app/sync-server-search/page.tsx (29:42) @ SearchParamsReadingComponent\n+             > 29 |   const fooParam = (searchParams as any).foo\n+                  |                                          ^\",\n+               \"stack\": [\n+                 \"SearchParamsReadingComponent app/sync-server-search/page.tsx (29:42)\",\n+                 \"Page app/sync-server-search/page.tsx (15:7)\",\n+               ],\n+             }\n+            `)\n           })\n         }\n       })\n@@ -1201,26 +1168,26 @@ describe('Cache Components Errors', () => {\n               await expect(browser).toDisplayRedbox(`\n                [\n                  {\n-                   \"description\": \"Route \"/sync-cookies\" used \\`cookies().get\\`. \\`cookies()\\` should be awaited before using its value. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis\",\n+                   \"description\": \"Route \"/sync-cookies\" used \\`cookies().get\\`. \\`cookies()\\` returns a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis\",\n                    \"environmentLabel\": \"Prerender\",\n                    \"label\": \"Console Error\",\n-                   \"source\": \"app/sync-cookies/page.tsx (17:25) @ CookiesReadingComponent\n-               > 17 |   const token = (cookies() as unknown as UnsafeUnwrappedCookies).get('token')\n+                   \"source\": \"app/sync-cookies/page.tsx (18:25) @ CookiesReadingComponent\n+               > 18 |   const token = (cookies() as any).get('token')\n                     |                         ^\",\n                    \"stack\": [\n-                     \"CookiesReadingComponent app/sync-cookies/page.tsx (17:25)\",\n+                     \"CookiesReadingComponent app/sync-cookies/page.tsx (18:25)\",\n                      \"Page app/sync-cookies/page.tsx (11:7)\",\n                    ],\n                  },\n                  {\n                    \"description\": \"(0 , <turbopack-module-id>.cookies)(...).get is not a function\",\n                    \"environmentLabel\": \"Prerender\",\n                    \"label\": \"Runtime TypeError\",\n-                   \"source\": \"app/sync-cookies/page.tsx (17:66) @ CookiesReadingComponent\n-               > 17 |   const token = (cookies() as unknown as UnsafeUnwrappedCookies).get('token')\n-                    |                                                                  ^\",\n+                   \"source\": \"app/sync-cookies/page.tsx (18:36) @ CookiesReadingComponent\n+               > 18 |   const token = (cookies() as any).get('token')\n+                    |                                    ^\",\n                    \"stack\": [\n-                     \"CookiesReadingComponent app/sync-cookies/page.tsx (17:66)\",\n+                     \"CookiesReadingComponent app/sync-cookies/page.tsx (18:36)\",\n                    ],\n                  },\n                ]\n@@ -1229,11 +1196,11 @@ describe('Cache Components Errors', () => {\n               await expect(browser).toDisplayRedbox(`\n                [\n                  {\n-                   \"description\": \"Route \"/sync-cookies\" used \\`cookies().get\\`. \\`cookies()\\` should be awaited before using its value. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis\",\n+                   \"description\": \"Route \"/sync-cookies\" used \\`cookies().get\\`. \\`cookies()\\` returns a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis\",\n                    \"environmentLabel\": \"Prerender\",\n                    \"label\": \"Console Error\",\n                    \"source\": \"app/sync-cookies/page.tsx (17:25) @ CookiesReadingComponent\n-               > 17 |   const token = (cookies() as unknown as UnsafeUnwrappedCookies).get('token')\n+               > 17 |   const token = (cookies() as any).get('token')\n                     |                         ^\",\n                    \"stack\": [\n                      \"CookiesReadingComponent app/sync-cookies/page.tsx (17:25)\",\n@@ -1244,11 +1211,11 @@ describe('Cache Components Errors', () => {\n                    \"description\": \"(0 , <webpack-module-id>.cookies)(...).get is not a function\",\n                    \"environmentLabel\": \"Prerender\",\n                    \"label\": \"Runtime TypeError\",\n-                   \"source\": \"app/sync-cookies/page.tsx (17:66) @ CookiesReadingComponent\n-               > 17 |   const token = (cookies() as unknown as UnsafeUnwrappedCookies).get('token')\n-                    |                                                                  ^\",\n+                   \"source\": \"app/sync-cookies/page.tsx (17:36) @ CookiesReadingComponent\n+               > 17 |   const token = (cookies() as any).get('token')\n+                    |                                    ^\",\n                    \"stack\": [\n-                     \"CookiesReadingComponent app/sync-cookies/page.tsx (17:66)\",\n+                     \"CookiesReadingComponent app/sync-cookies/page.tsx (17:36)\",\n                    ],\n                  },\n                ]\n@@ -1257,26 +1224,26 @@ describe('Cache Components Errors', () => {\n               await expect(browser).toDisplayRedbox(`\n                [\n                  {\n-                   \"description\": \"Route \"/sync-cookies\" used \\`cookies().get\\`. \\`cookies()\\` should be awaited before using its value. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis\",\n+                   \"description\": \"Route \"/sync-cookies\" used \\`cookies().get\\`. \\`cookies()\\` returns a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis\",\n                    \"environmentLabel\": \"Prerender\",\n                    \"label\": \"Console Error\",\n-                   \"source\": \"app/sync-cookies/page.tsx (17:17) @ CookiesReadingComponent\n-               > 17 |   const token = (cookies() as unknown as UnsafeUnwrappedCookies).get('token')\n+                   \"source\": \"app/sync-cookies/page.tsx (18:17) @ CookiesReadingComponent\n+               > 18 |   const token = (cookies() as any).get('token')\n                     |                 ^\",\n                    \"stack\": [\n-                     \"CookiesReadingComponent app/sync-cookies/page.tsx (17:17)\",\n+                     \"CookiesReadingComponent app/sync-cookies/page.tsx (18:17)\",\n                      \"Page app/sync-cookies/page.tsx (11:7)\",\n                    ],\n                  },\n                  {\n                    \"description\": \"(0 , <webpack-module-id>.cookies)(...).get is not a function\",\n                    \"environmentLabel\": \"Prerender\",\n                    \"label\": \"Runtime TypeError\",\n-                   \"source\": \"app/sync-cookies/page.tsx (17:66) @ CookiesReadingComponent\n-               > 17 |   const token = (cookies() as unknown as UnsafeUnwrappedCookies).get('token')\n-                    |                                                                  ^\",\n+                   \"source\": \"app/sync-cookies/page.tsx (18:36) @ CookiesReadingComponent\n+               > 18 |   const token = (cookies() as any).get('token')\n+                    |                                    ^\",\n                    \"stack\": [\n-                     \"CookiesReadingComponent app/sync-cookies/page.tsx (17:66)\",\n+                     \"CookiesReadingComponent app/sync-cookies/page.tsx (18:36)\",\n                    ],\n                  },\n                ]\n@@ -1301,15 +1268,15 @@ describe('Cache Components Errors', () => {\n                 expect(output).toMatchInlineSnapshot(`\n                  \"Error occurred prerendering page \"/sync-cookies\". Read more: https://nextjs.org/docs/messages/prerender-error\n                  TypeError: <module-function>().get is not a function\n-                     at CookiesReadingComponent (bundler:///app/sync-cookies/page.tsx:17:66)\n+                     at CookiesReadingComponent (bundler:///app/sync-cookies/page.tsx:18:36)\n                      at stringify (<anonymous>)\n-                   15 |\n                    16 | async function CookiesReadingComponent() {\n-                 > 17 |   const token = (cookies() as unknown as UnsafeUnwrappedCookies).get('token')\n-                      |                                                                  ^\n-                   18 |\n-                   19 |   return (\n-                   20 |     <div> {\n+                   17 |   // Cast to any as we removed UnsafeUnwrapped types, but still need to test with the sync access\n+                 > 18 |   const token = (cookies() as any).get('token')\n+                      |                                    ^\n+                   19 |\n+                   20 |   return (\n+                   21 |     <div> {\n                    digest: '<error-digest>'\n                  }\n \n@@ -1320,15 +1287,15 @@ describe('Cache Components Errors', () => {\n                 expect(output).toMatchInlineSnapshot(`\n                  \"Error occurred prerendering page \"/sync-cookies\". Read more: https://nextjs.org/docs/messages/prerender-error\n                  TypeError: <module-function>().get is not a function\n-                     at a (bundler:///app/sync-cookies/page.tsx:17:66)\n+                     at a (bundler:///app/sync-cookies/page.tsx:18:36)\n                      at b (<anonymous>)\n-                   15 |\n                    16 | async function CookiesReadingComponent() {\n-                 > 17 |   const token = (cookies() as unknown as UnsafeUnwrappedCookies).get('token')\n-                      |                                                                  ^\n-                   18 |\n-                   19 |   return (\n-                   20 |     <div> {\n+                   17 |   // Cast to any as we removed UnsafeUnwrapped types, but still need to test with the sync access\n+                 > 18 |   const token = (cookies() as any).get('token')\n+                      |                                    ^\n+                   19 |\n+                   20 |   return (\n+                   21 |     <div> {\n                    digest: '<error-digest>'\n                  }\n                  Export encountered an error on /sync-cookies/page: /sync-cookies, exiting the build.\"\n@@ -1339,15 +1306,15 @@ describe('Cache Components Errors', () => {\n                 expect(output).toMatchInlineSnapshot(`\n                  \"Error occurred prerendering page \"/sync-cookies\". Read more: https://nextjs.org/docs/messages/prerender-error\n                  TypeError: <module-function>().get is not a function\n-                     at CookiesReadingComponent (bundler:///app/sync-cookies/page.tsx:17:66)\n+                     at CookiesReadingComponent (bundler:///app/sync-cookies/page.tsx:18:36)\n                      at stringify (<anonymous>)\n-                   15 |\n                    16 | async function CookiesReadingComponent() {\n-                 > 17 |   const token = (cookies() as unknown as UnsafeUnwrappedCookies).get('token')\n-                      |                                                                  ^\n-                   18 |\n-                   19 |   return (\n-                   20 |     <div> {\n+                   17 |   // Cast to any as we removed UnsafeUnwrapped types, but still need to test with the sync access\n+                 > 18 |   const token = (cookies() as any).get('token')\n+                      |                                    ^\n+                   19 |\n+                   20 |   return (\n+                   21 |     <div> {\n                    digest: '<error-digest>'\n                  }\n \n@@ -1383,11 +1350,11 @@ describe('Cache Components Errors', () => {\n               await expect(browser).toDisplayRedbox(`\n                [\n                  {\n-                   \"description\": \"Route \"/sync-cookies-runtime\" used \\`cookies().get\\`. \\`cookies()\\` should be awaited before using its value. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis\",\n+                   \"description\": \"Route \"/sync-cookies-runtime\" used \\`cookies().get\\`. \\`cookies()\\` returns a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis\",\n                    \"environmentLabel\": \"Server\",\n                    \"label\": \"Console Error\",\n                    \"source\": \"app/sync-cookies-runtime/page.tsx (24:25) @ CookiesReadingComponent\n-               > 24 |   const token = (cookies() as unknown as UnsafeUnwrappedCookies).get('token')\n+               > 24 |   const token = (cookies() as any).get('token')\n                     |                         ^\",\n                    \"stack\": [\n                      \"CookiesReadingComponent app/sync-cookies-runtime/page.tsx (24:25)\",\n@@ -1398,11 +1365,11 @@ describe('Cache Components Errors', () => {\n                    \"description\": \"(0 , <turbopack-module-id>.cookies)(...).get is not a function\",\n                    \"environmentLabel\": \"Server\",\n                    \"label\": \"Runtime TypeError\",\n-                   \"source\": \"app/sync-cookies-runtime/page.tsx (24:66) @ CookiesReadingComponent\n-               > 24 |   const token = (cookies() as unknown as UnsafeUnwrappedCookies).get('token')\n-                    |                                                                  ^\",\n+                   \"source\": \"app/sync-cookies-runtime/page.tsx (24:36) @ CookiesReadingComponent\n+               > 24 |   const token = (cookies() as any).get('token')\n+                    |                                    ^\",\n                    \"stack\": [\n-                     \"CookiesReadingComponent app/sync-cookies-runtime/page.tsx (24:66)\",\n+                     \"CookiesReadingComponent app/sync-cookies-runtime/page.tsx (24:36)\",\n                    ],\n                  },\n                ]\n@@ -1411,11 +1378,11 @@ describe('Cache Components Errors', () => {\n               await expect(browser).toDisplayRedbox(`\n                [\n                  {\n-                   \"description\": \"Route \"/sync-cookies-runtime\" used \\`cookies().get\\`. \\`cookies()\\` should be awaited before using its value. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis\",\n+                   \"description\": \"Route \"/sync-cookies-runtime\" used \\`cookies().get\\`. \\`cookies()\\` returns a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis\",\n                    \"environmentLabel\": \"Server\",\n                    \"label\": \"Console Error\",\n                    \"source\": \"app/sync-cookies-runtime/page.tsx (24:25) @ CookiesReadingComponent\n-               > 24 |   const token = (cookies() as unknown as UnsafeUnwrappedCookies).get('token')\n+               > 24 |   const token = (cookies() as any).get('token')\n                     |                         ^\",\n                    \"stack\": [\n                      \"CookiesReadingComponent app/sync-cookies-runtime/page.tsx (24:25)\",\n@@ -1427,7 +1394,7 @@ describe('Cache Components Errors', () => {\n                    \"environmentLabel\": \"Server\",\n                    \"label\": \"Runtime TypeError\",\n                    \"source\": \"app/sync-cookies-runtime/page.tsx (24:66) @ CookiesReadingComponent\n-               > 24 |   const token = (cookies() as unknown as UnsafeUnwrappedCookies).get('token')\n+               > 24 |   const token = (cookies() as any).get('token')\n                     |                                                                  ^\",\n                    \"stack\": [\n                      \"CookiesReadingComponent app/sync-cookies-runtime/page.tsx (24:66)\",\n@@ -1439,11 +1406,11 @@ describe('Cache Components Errors', () => {\n               await expect(browser).toDisplayRedbox(`\n                [\n                  {\n-                   \"description\": \"Route \"/sync-cookies-runtime\" used \\`cookies().get\\`. \\`cookies()\\` should be awaited before using its value. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis\",\n+                   \"description\": \"Route \"/sync-cookies-runtime\" used \\`cookies().get\\`. \\`cookies()\\` returns a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis\",\n                    \"environmentLabel\": \"Server\",\n                    \"label\": \"Console Error\",\n                    \"source\": \"app/sync-cookies-runtime/page.tsx (24:17) @ CookiesReadingComponent\n-               > 24 |   const token = (cookies() as unknown as UnsafeUnwrappedCookies).get('token')\n+               > 24 |   const token = (cookies() as any).get('token')\n                     |                 ^\",\n                    \"stack\": [\n                      \"CookiesReadingComponent app/sync-cookies-runtime/page.tsx (24:17)\",\n@@ -1454,39 +1421,17 @@ describe('Cache Components Errors', () => {\n                    \"description\": \"(0 , <webpack-module-id>.cookies)(...).get is not a function\",\n                    \"environmentLabel\": \"Server\",\n                    \"label\": \"Runtime TypeError\",\n-                   \"source\": \"app/sync-cookies-runtime/page.tsx (24:66) @ CookiesReadingComponent\n-               > 24 |   const token = (cookies() as unknown as UnsafeUnwrappedCookies).get('token')\n-                    |                                                                  ^\",\n+                   \"source\": \"app/sync-cookies-runtime/page.tsx (24:36) @ CookiesReadingComponent\n+               > 24 |   const token = (cookies() as any).get('token')\n+                    |                                    ^\",\n                    \"stack\": [\n-                     \"CookiesReadingComponent app/sync-cookies-runtime/page.tsx (24:66)\",\n+                     \"CookiesReadingComponent app/sync-cookies-runtime/page.tsx (24:36)\",\n                    ],\n                  },\n                ]\n               `)\n             }\n           })\n-        } else {\n-          it('should not error the build, but fail at runtime', async () => {\n-            try {\n-              await prerender('/sync-cookies-runtime')\n-            } catch (error) {\n-              throw new Error('expected build not to fail', { cause: error })\n-            }\n-\n-            expect(next.cliOutput).toContain(' /sync-cookies-runtime')\n-            await next.start({ skipBuild: true })\n-            cliOutputLength = next.cliOutput.length\n-            await next.fetch('/sync-cookies-runtime')\n-\n-            await retry(() => {\n-              const output = convertModuleFunctionSequenceExpression(\n-                next.cliOutput.slice(cliOutputLength)\n-              )\n-              expect(output).toInclude(\n-                'TypeError: <module-function>().get is not a function'\n-              )\n-            })\n-          })\n         }\n       })\n \n@@ -1511,27 +1456,27 @@ describe('Cache Components Errors', () => {\n \n             if (isTurbopack) {\n               await expect(browser).toDisplayCollapsedRedbox(`\n-                            {\n-                              \"description\": \"Route \"/sync-draft-mode\" used \\`draftMode().isEnabled\\`. \\`draftMode()\\` should be awaited before using its value. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis\",\n-                              \"environmentLabel\": \"Prerender\",\n-                              \"label\": \"Console Error\",\n-                              \"source\": \"app/sync-draft-mode/page.tsx (23:31) @ DraftModeReadingComponent\n-                            > 23 |   const isEnabled = (draftMode() as unknown as UnsafeUnwrappedDraftMode)\n-                                 |                               ^\",\n-                              \"stack\": [\n-                                \"DraftModeReadingComponent app/sync-draft-mode/page.tsx (23:31)\",\n-                                \"Page app/sync-draft-mode/page.tsx (13:7)\",\n-                              ],\n-                            }\n-                          `)\n+               {\n+                 \"description\": \"Route \"/sync-draft-mode\" used \\`draftMode().isEnabled\\`. \\`draftMode()\\` returns a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis\",\n+                 \"environmentLabel\": \"Prerender\",\n+                 \"label\": \"Console Error\",\n+                 \"source\": \"app/sync-draft-mode/page.tsx (24:31) @ DraftModeReadingComponent\n+               > 24 |   const isEnabled = (draftMode() as any).isEnabled\n+                    |                               ^\",\n+                 \"stack\": [\n+                   \"DraftModeReadingComponent app/sync-draft-mode/page.tsx (24:31)\",\n+                   \"Page app/sync-draft-mode/page.tsx (13:7)\",\n+                 ],\n+               }\n+              `)\n             } else if (isRspack) {\n               await expect(browser).toDisplayCollapsedRedbox(`\n                {\n-                 \"description\": \"Route \"/sync-draft-mode\" used \\`draftMode().isEnabled\\`. \\`draftMode()\\` should be awaited before using its value. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis\",\n+                 \"description\": \"Route \"/sync-draft-mode\" used \\`draftMode().isEnabled\\`. \\`draftMode()\\` returns a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis\",\n                  \"environmentLabel\": \"Prerender\",\n                  \"label\": \"Console Error\",\n                  \"source\": \"app/sync-draft-mode/page.tsx (23:31) @ DraftModeReadingComponent\n-               > 23 |   const isEnabled = (draftMode() as unknown as UnsafeUnwrappedDraftMode)\n+               > 23 |   const isEnabled = (draftMode() as any)\n                     |                               ^\",\n                  \"stack\": [\n                    \"DraftModeReadingComponent app/sync-draft-mode/page.tsx (23:31)\",\n@@ -1541,35 +1486,20 @@ describe('Cache Components Errors', () => {\n               `)\n             } else {\n               await expect(browser).toDisplayCollapsedRedbox(`\n-                            {\n-                              \"description\": \"Route \"/sync-draft-mode\" used \\`draftMode().isEnabled\\`. \\`draftMode()\\` should be awaited before using its value. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis\",\n-                              \"environmentLabel\": \"Prerender\",\n-                              \"label\": \"Console Error\",\n-                              \"source\": \"app/sync-draft-mode/page.tsx (23:21) @ DraftModeReadingComponent\n-                            > 23 |   const isEnabled = (draftMode() as unknown as UnsafeUnwrappedDraftMode)\n-                                 |                     ^\",\n-                              \"stack\": [\n-                                \"DraftModeReadingComponent app/sync-draft-mode/page.tsx (23:21)\",\n-                                \"Page app/sync-draft-mode/page.tsx (13:7)\",\n-                              ],\n-                            }\n-                          `)\n-            }\n-          })\n-        } else {\n-          it('should not error the build when synchronously reading `draftMode().isEnabled`', async () => {\n-            try {\n-              await prerender(pathname)\n-            } catch (error) {\n-              throw new Error('expected build not to fail', { cause: error })\n+               {\n+                 \"description\": \"Route \"/sync-draft-mode\" used \\`draftMode().isEnabled\\`. \\`draftMode()\\` returns a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis\",\n+                 \"environmentLabel\": \"Prerender\",\n+                 \"label\": \"Console Error\",\n+                 \"source\": \"app/sync-draft-mode/page.tsx (24:21) @ DraftModeReadingComponent\n+               > 24 |   const isEnabled = (draftMode() as any).isEnabled\n+                    |                     ^\",\n+                 \"stack\": [\n+                   \"DraftModeReadingComponent app/sync-draft-mode/page.tsx (24:21)\",\n+                   \"Page app/sync-draft-mode/page.tsx (13:7)\",\n+                 ],\n+               }\n+              `)\n             }\n-\n-            expect(next.cliOutput).toContain(` ${pathname}`)\n-            await next.start({ skipBuild: true })\n-            const browser = await next.browser(`${pathname}`)\n-            expect(await browser.elementById('draft-mode').text()).toBe(\n-              'undefined'\n-            )\n           })\n         }\n       })\n@@ -1587,41 +1517,41 @@ describe('Cache Components Errors', () => {\n \n             if (isTurbopack) {\n               await expect(browser).toDisplayRedbox(`\n-                            [\n-                              {\n-                                \"description\": \"Route \"/sync-headers\" used \\`headers().get\\`. \\`headers()\\` should be awaited before using its value. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis\",\n-                                \"environmentLabel\": \"Prerender\",\n-                                \"label\": \"Console Error\",\n-                                \"source\": \"app/sync-headers/page.tsx (17:29) @ HeadersReadingComponent\n-                            > 17 |   const userAgent = (headers() as unknown as UnsafeUnwrappedHeaders).get(\n-                                 |                             ^\",\n-                                \"stack\": [\n-                                  \"HeadersReadingComponent app/sync-headers/page.tsx (17:29)\",\n-                                  \"Page app/sync-headers/page.tsx (11:7)\",\n-                                ],\n-                              },\n-                              {\n-                                \"description\": \"(0 , <turbopack-module-id>.headers)(...).get is not a function\",\n-                                \"environmentLabel\": \"Prerender\",\n-                                \"label\": \"Runtime TypeError\",\n-                                \"source\": \"app/sync-headers/page.tsx (17:70) @ HeadersReadingComponent\n-                            > 17 |   const userAgent = (headers() as unknown as UnsafeUnwrappedHeaders).get(\n-                                 |                                                                      ^\",\n-                                \"stack\": [\n-                                  \"HeadersReadingComponent app/sync-headers/page.tsx (17:70)\",\n-                                ],\n-                              },\n-                            ]\n-                          `)\n+               [\n+                 {\n+                   \"description\": \"Route \"/sync-headers\" used \\`headers().get\\`. \\`headers()\\` returns a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis\",\n+                   \"environmentLabel\": \"Prerender\",\n+                   \"label\": \"Console Error\",\n+                   \"source\": \"app/sync-headers/page.tsx (18:29) @ HeadersReadingComponent\n+               > 18 |   const userAgent = (headers() as any).get('user-agent')\n+                    |                             ^\",\n+                   \"stack\": [\n+                     \"HeadersReadingComponent app/sync-headers/page.tsx (18:29)\",\n+                     \"Page app/sync-headers/page.tsx (11:7)\",\n+                   ],\n+                 },\n+                 {\n+                   \"description\": \"(0 , <turbopack-module-id>.headers)(...).get is not a function\",\n+                   \"environmentLabel\": \"Prerender\",\n+                   \"label\": \"Runtime TypeError\",\n+                   \"source\": \"app/sync-headers/page.tsx (18:40) @ HeadersReadingComponent\n+               > 18 |   const userAgent = (headers() as any).get('user-agent')\n+                    |                                        ^\",\n+                   \"stack\": [\n+                     \"HeadersReadingComponent app/sync-headers/page.tsx (18:40)\",\n+                   ],\n+                 },\n+               ]\n+              `)\n             } else if (isRspack) {\n               await expect(browser).toDisplayRedbox(`\n                [\n                  {\n-                   \"description\": \"Route \"/sync-headers\" used \\`headers().get\\`. \\`headers()\\` should be awaited before using its value. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis\",\n+                   \"description\": \"Route \"/sync-headers\" used \\`headers().get\\`. \\`headers()\\` returns a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis\",\n                    \"environmentLabel\": \"Prerender\",\n                    \"label\": \"Console Error\",\n                    \"source\": \"app/sync-headers/page.tsx (17:29) @ HeadersReadingComponent\n-               > 17 |   const userAgent = (headers() as unknown as UnsafeUnwrappedHeaders).get(\n+               > 17 |   const userAgent = (headers() as any).get(\n                     |                             ^\",\n                    \"stack\": [\n                      \"HeadersReadingComponent app/sync-headers/page.tsx (17:29)\",\n@@ -1633,7 +1563,7 @@ describe('Cache Components Errors', () => {\n                    \"environmentLabel\": \"Prerender\",\n                    \"label\": \"Runtime TypeError\",\n                    \"source\": \"app/sync-headers/page.tsx (17:70) @ HeadersReadingComponent\n-               > 17 |   const userAgent = (headers() as unknown as UnsafeUnwrappedHeaders).get(\n+               > 17 |   const userAgent = (headers() as any).get(\n                     |                                                                      ^\",\n                    \"stack\": [\n                      \"HeadersReadingComponent app/sync-headers/page.tsx (17:70)\",\n@@ -1643,32 +1573,32 @@ describe('Cache Components Errors', () => {\n               `)\n             } else {\n               await expect(browser).toDisplayRedbox(`\n-                            [\n-                              {\n-                                \"description\": \"Route \"/sync-headers\" used \\`headers().get\\`. \\`headers()\\` should be awaited before using its value. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis\",\n-                                \"environmentLabel\": \"Prerender\",\n-                                \"label\": \"Console Error\",\n-                                \"source\": \"app/sync-headers/page.tsx (17:21) @ HeadersReadingComponent\n-                            > 17 |   const userAgent = (headers() as unknown as UnsafeUnwrappedHeaders).get(\n-                                 |                     ^\",\n-                                \"stack\": [\n-                                  \"HeadersReadingComponent app/sync-headers/page.tsx (17:21)\",\n-                                  \"Page app/sync-headers/page.tsx (11:7)\",\n-                                ],\n-                              },\n-                              {\n-                                \"description\": \"(0 , <webpack-module-id>.headers)(...).get is not a function\",\n-                                \"environmentLabel\": \"Prerender\",\n-                                \"label\": \"Runtime TypeError\",\n-                                \"source\": \"app/sync-headers/page.tsx (17:70) @ HeadersReadingComponent\n-                            > 17 |   const userAgent = (headers() as unknown as UnsafeUnwrappedHeaders).get(\n-                                 |                                                                      ^\",\n-                                \"stack\": [\n-                                  \"HeadersReadingComponent app/sync-headers/page.tsx (17:70)\",\n-                                ],\n-                              },\n-                            ]\n-                          `)\n+               [\n+                 {\n+                   \"description\": \"Route \"/sync-headers\" used \\`headers().get\\`. \\`headers()\\` returns a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis\",\n+                   \"environmentLabel\": \"Prerender\",\n+                   \"label\": \"Console Error\",\n+                   \"source\": \"app/sync-headers/page.tsx (18:21) @ HeadersReadingComponent\n+               > 18 |   const userAgent = (headers() as any).get('user-agent')\n+                    |                     ^\",\n+                   \"stack\": [\n+                     \"HeadersReadingComponent app/sync-headers/page.tsx (18:21)\",\n+                     \"Page app/sync-headers/page.tsx (11:7)\",\n+                   ],\n+                 },\n+                 {\n+                   \"description\": \"(0 , <webpack-module-id>.headers)(...).get is not a function\",\n+                   \"environmentLabel\": \"Prerender\",\n+                   \"label\": \"Runtime TypeError\",\n+                   \"source\": \"app/sync-headers/page.tsx (18:40) @ HeadersReadingComponent\n+               > 18 |   const userAgent = (headers() as any).get('user-agent')\n+                    |                                        ^\",\n+                   \"stack\": [\n+                     \"HeadersReadingComponent app/sync-headers/page.tsx (18:40)\",\n+                   ],\n+                 },\n+               ]\n+              `)\n             }\n           })\n         } else {\n@@ -1689,15 +1619,15 @@ describe('Cache Components Errors', () => {\n                 expect(output).toMatchInlineSnapshot(`\n                  \"Error occurred prerendering page \"/sync-headers\". Read more: https://nextjs.org/docs/messages/prerender-error\n                  TypeError: <module-function>().get is not a function\n-                     at HeadersReadingComponent (bundler:///app/sync-headers/page.tsx:17:70)\n+                     at HeadersReadingComponent (bundler:///app/sync-headers/page.tsx:18:40)\n                      at stringify (<anonymous>)\n-                   15 |\n                    16 | async function HeadersReadingComponent() {\n-                 > 17 |   const userAgent = (headers() as unknown as UnsafeUnwrappedHeaders).get(\n-                      |                                                                      ^\n-                   18 |     'user-agent'\n-                   19 |   )\n-                   20 |   return ( {\n+                   17 |   // Cast to any as we removed UnsafeUnwrapped types, but still need to test with the sync access\n+                 > 18 |   const userAgent = (headers() as any).get('user-agent')\n+                      |                                        ^\n+                   19 |   return (\n+                   20 |     <div>\n+                   21 |       this component reads the \\`user-agent\\` header synchronously: {userAgent} {\n                    digest: '<error-digest>'\n                  }\n \n@@ -1708,15 +1638,15 @@ describe('Cache Components Errors', () => {\n                 expect(output).toMatchInlineSnapshot(`\n                  \"Error occurred prerendering page \"/sync-headers\". Read more: https://nextjs.org/docs/messages/prerender-error\n                  TypeError: <module-function>().get is not a function\n-                     at a (bundler:///app/sync-headers/page.tsx:17:70)\n+                     at a (bundler:///app/sync-headers/page.tsx:18:40)\n                      at b (<anonymous>)\n-                   15 |\n                    16 | async function HeadersReadingComponent() {\n-                 > 17 |   const userAgent = (headers() as unknown as UnsafeUnwrappedHeaders).get(\n-                      |                                                                      ^\n-                   18 |     'user-agent'\n-                   19 |   )\n-                   20 |   return ( {\n+                   17 |   // Cast to any as we removed UnsafeUnwrapped types, but still need to test with the sync access\n+                 > 18 |   const userAgent = (headers() as any).get('user-agent')\n+                      |                                        ^\n+                   19 |   return (\n+                   20 |     <div>\n+                   21 |       this component reads the \\`user-agent\\` header synchronously: {userAgent} {\n                    digest: '<error-digest>'\n                  }\n                  Export encountered an error on /sync-headers/page: /sync-headers, exiting the build.\"\n@@ -1727,15 +1657,15 @@ describe('Cache Components Errors', () => {\n                 expect(output).toMatchInlineSnapshot(`\n                  \"Error occurred prerendering page \"/sync-headers\". Read more: https://nextjs.org/docs/messages/prerender-error\n                  TypeError: <module-function>().get is not a function\n-                     at HeadersReadingComponent (bundler:///app/sync-headers/page.tsx:17:70)\n+                     at HeadersReadingComponent (bundler:///app/sync-headers/page.tsx:18:40)\n                      at stringify (<anonymous>)\n-                   15 |\n                    16 | async function HeadersReadingComponent() {\n-                 > 17 |   const userAgent = (headers() as unknown as UnsafeUnwrappedHeaders).get(\n-                      |                                                                      ^\n-                   18 |     'user-agent'\n-                   19 |   )\n-                   20 |   return ( {\n+                   17 |   // Cast to any as we removed UnsafeUnwrapped types, but still need to test with the sync access\n+                 > 18 |   const userAgent = (headers() as any).get('user-agent')\n+                      |                                        ^\n+                   19 |   return (\n+                   20 |     <div>\n+                   21 |       this component reads the \\`user-agent\\` header synchronously: {userAgent} {\n                    digest: '<error-digest>'\n                  }\n \n@@ -1771,11 +1701,11 @@ describe('Cache Components Errors', () => {\n               await expect(browser).toDisplayRedbox(`\n                [\n                  {\n-                   \"description\": \"Route \"/sync-headers-runtime\" used \\`headers().get\\`. \\`headers()\\` should be awaited before using its value. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis\",\n+                   \"description\": \"Route \"/sync-headers-runtime\" used \\`headers().get\\`. \\`headers()\\` returns a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis\",\n                    \"environmentLabel\": \"Server\",\n                    \"label\": \"Console Error\",\n                    \"source\": \"app/sync-headers-runtime/page.tsx (24:29) @ HeadersReadingComponent\n-               > 24 |   const userAgent = (headers() as unknown as UnsafeUnwrappedHeaders).get(\n+               > 24 |   const userAgent = (headers() as any).get('user-agent')\n                     |                             ^\",\n                    \"stack\": [\n                      \"HeadersReadingComponent app/sync-headers-runtime/page.tsx (24:29)\",\n@@ -1786,11 +1716,11 @@ describe('Cache Components Errors', () => {\n                    \"description\": \"(0 , <turbopack-module-id>.headers)(...).get is not a function\",\n                    \"environmentLabel\": \"Server\",\n                    \"label\": \"Runtime TypeError\",\n-                   \"source\": \"app/sync-headers-runtime/page.tsx (24:70) @ HeadersReadingComponent\n-               > 24 |   const userAgent = (headers() as unknown as UnsafeUnwrappedHeaders).get(\n-                    |                                                                      ^\",\n+                   \"source\": \"app/sync-headers-runtime/page.tsx (24:40) @ HeadersReadingComponent\n+               > 24 |   const userAgent = (headers() as any).get('user-agent')\n+                    |                                        ^\",\n                    \"stack\": [\n-                     \"HeadersReadingComponent app/sync-headers-runtime/page.tsx (24:70)\",\n+                     \"HeadersReadingComponent app/sync-headers-runtime/page.tsx (24:40)\",\n                    ],\n                  },\n                ]\n@@ -1799,11 +1729,11 @@ describe('Cache Components Errors', () => {\n               await expect(browser).toDisplayRedbox(`\n                [\n                  {\n-                   \"description\": \"Route \"/sync-headers-runtime\" used \\`headers().get\\`. \\`headers()\\` should be awaited before using its value. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis\",\n+                   \"description\": \"Route \"/sync-headers-runtime\" used \\`headers().get\\`. \\`headers()\\` returns a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis\",\n                    \"environmentLabel\": \"Server\",\n                    \"label\": \"Console Error\",\n                    \"source\": \"app/sync-headers-runtime/page.tsx (24:29) @ HeadersReadingComponent\n-               > 24 |   const userAgent = (headers() as unknown as UnsafeUnwrappedHeaders).get(\n+               > 24 |   const userAgent = (headers() as any).get(\n                     |                             ^\",\n                    \"stack\": [\n                      \"HeadersReadingComponent app/sync-headers-runtime/page.tsx (24:29)\",\n@@ -1815,7 +1745,7 @@ describe('Cache Components Errors', () => {\n                    \"environmentLabel\": \"Server\",\n                    \"label\": \"Runtime TypeError\",\n                    \"source\": \"app/sync-headers-runtime/page.tsx (24:70) @ HeadersReadingComponent\n-               > 24 |   const userAgent = (headers() as unknown as UnsafeUnwrappedHeaders).get(\n+               > 24 |   const userAgent = (headers() as any).get(\n                     |                                                                      ^\",\n                    \"stack\": [\n                      \"HeadersReadingComponent app/sync-headers-runtime/page.tsx (24:70)\",\n@@ -1827,11 +1757,11 @@ describe('Cache Components Errors', () => {\n               await expect(browser).toDisplayRedbox(`\n                [\n                  {\n-                   \"description\": \"Route \"/sync-headers-runtime\" used \\`headers().get\\`. \\`headers()\\` should be awaited before using its value. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis\",\n+                   \"description\": \"Route \"/sync-headers-runtime\" used \\`headers().get\\`. \\`headers()\\` returns a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis\",\n                    \"environmentLabel\": \"Server\",\n                    \"label\": \"Console Error\",\n                    \"source\": \"app/sync-headers-runtime/page.tsx (24:21) @ HeadersReadingComponent\n-               > 24 |   const userAgent = (headers() as unknown as UnsafeUnwrappedHeaders).get(\n+               > 24 |   const userAgent = (headers() as any).get('user-agent')\n                     |                     ^\",\n                    \"stack\": [\n                      \"HeadersReadingComponent app/sync-headers-runtime/page.tsx (24:21)\",\n@@ -1842,40 +1772,17 @@ describe('Cache Components Errors', () => {\n                    \"description\": \"(0 , <webpack-module-id>.headers)(...).get is not a function\",\n                    \"environmentLabel\": \"Server\",\n                    \"label\": \"Runtime TypeError\",\n-                   \"source\": \"app/sync-headers-runtime/page.tsx (24:70) @ HeadersReadingComponent\n-               > 24 |   const userAgent = (headers() as unknown as UnsafeUnwrappedHeaders).get(\n-                    |                                                                      ^\",\n+                   \"source\": \"app/sync-headers-runtime/page.tsx (24:40) @ HeadersReadingComponent\n+               > 24 |   const userAgent = (headers() as any).get('user-agent')\n+                    |                                        ^\",\n                    \"stack\": [\n-                     \"HeadersReadingComponent app/sync-headers-runtime/page.tsx (24:70)\",\n+                     \"HeadersReadingComponent app/sync-headers-runtime/page.tsx (24:40)\",\n                    ],\n                  },\n                ]\n               `)\n             }\n           })\n-        } else {\n-          it('should not error the build, but fail at runtime', async () => {\n-            try {\n-              await prerender('/sync-headers-runtime')\n-            } catch (error) {\n-              throw new Error('expected build not to fail', { cause: error })\n-            }\n-\n-            expect(next.cliOutput).toContain(' /sync-headers-runtime')\n-            await next.start({ skipBuild: true })\n-            cliOutputLength = next.cliOutput.length\n-            await next.fetch('/sync-headers-runtime')\n-\n-            await retry(() => {\n-              const output = convertModuleFunctionSequenceExpression(\n-                next.cliOutput.slice(cliOutputLength)\n-              )\n-\n-              expect(output).toInclude(\n-                'TypeError: <module-function>().get is not a function'\n-              )\n-            })\n-          })\n         }\n       })\n \n@@ -1898,48 +1805,35 @@ describe('Cache Components Errors', () => {\n \n             if (isTurbopack) {\n               await expect(browser).toDisplayCollapsedRedbox(`\n-                            {\n-                              \"description\": \"A param property was accessed directly with \\`params.slug\\`. \\`params\\` is now a Promise and should be unwrapped with \\`React.use()\\` before accessing properties of the underlying params object. In this version of Next.js direct access to param properties is still supported to facilitate migration but in a future version you will be required to unwrap \\`params\\` with \\`React.use()\\`.\",\n-                              \"environmentLabel\": null,\n-                              \"label\": \"Console Error\",\n-                              \"source\": \"app/sync-client-params/[slug]/page.tsx (20:39) @ ParamsReadingComponent\n-                            > 20 |       <span id=\"param\">{String(params.slug)}</span>\n-                                 |                                       ^\",\n-                              \"stack\": [\n-                                \"ParamsReadingComponent app/sync-client-params/[slug]/page.tsx (20:39)\",\n-                                \"Page app/sync-client-params/[slug]/page.tsx (11:7)\",\n-                              ],\n-                            }\n-                          `)\n+               {\n+                 \"description\": \"A param property was accessed directly with \\`params.slug\\`. \\`params\\` is a Promise and must be unwrapped with \\`React.use()\\` before accessing its properties. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis\",\n+                 \"environmentLabel\": null,\n+                 \"label\": \"Console Error\",\n+                 \"source\": \"app/sync-client-params/[slug]/page.tsx (20:39) @ ParamsReadingComponent\n+               > 20 |       <span id=\"param\">{String(params.slug)}</span>\n+                    |                                       ^\",\n+                 \"stack\": [\n+                   \"ParamsReadingComponent app/sync-client-params/[slug]/page.tsx (20:39)\",\n+                   \"Page app/sync-client-params/[slug]/page.tsx (11:7)\",\n+                 ],\n+               }\n+              `)\n             } else {\n               await expect(browser).toDisplayCollapsedRedbox(`\n-                            {\n-                              \"description\": \"A param property was accessed directly with \\`params.slug\\`. \\`params\\` is now a Promise and should be unwrapped with \\`React.use()\\` before accessing properties of the underlying params object. In this version of Next.js direct access to param properties is still supported to facilitate migration but in a future version you will be required to unwrap \\`params\\` with \\`React.use()\\`.\",\n-                              \"environmentLabel\": null,\n-                              \"label\": \"Console Error\",\n-                              \"source\": \"app/sync-client-params/[slug]/page.tsx (20:39) @ ParamsReadingComponent\n-                            > 20 |       <span id=\"param\">{String(params.slug)}</span>\n-                                 |                                       ^\",\n-                              \"stack\": [\n-                                \"ParamsReadingComponent app/sync-client-params/[slug]/page.tsx (20:39)\",\n-                                \"Page app/sync-client-params/[slug]/page.tsx (11:7)\",\n-                              ],\n-                            }\n-                          `)\n-            }\n-          })\n-        } else {\n-          it('should not error the build when synchronously reading `params.slug`', async () => {\n-            try {\n-              await prerender(`${pathname}/[slug]`)\n-            } catch (error) {\n-              throw new Error('expected build not to fail', { cause: error })\n+               {\n+                 \"description\": \"A param property was accessed directly with \\`params.slug\\`. \\`params\\` is a Promise and must be unwrapped with \\`React.use()\\` before accessing its properties. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis\",\n+                 \"environmentLabel\": null,\n+                 \"label\": \"Console Error\",\n+                 \"source\": \"app/sync-client-params/[slug]/page.tsx (20:39) @ ParamsReadingComponent\n+               > 20 |       <span id=\"param\">{String(params.slug)}</span>\n+                    |                                       ^\",\n+                 \"stack\": [\n+                   \"ParamsReadingComponent app/sync-client-params/[slug]/page.tsx (20:39)\",\n+                   \"Page app/sync-client-params/[slug]/page.tsx (11:7)\",\n+                 ],\n+               }\n+              `)\n             }\n-\n-            expect(next.cliOutput).toContain(` ${pathname}/[slug]`)\n-            await next.start({ skipBuild: true })\n-            const browser = await next.browser(`${pathname}/test`)\n-            expect(await browser.elementById('param').text()).toBe('undefined')\n           })\n         }\n       })\n@@ -1963,7 +1857,7 @@ describe('Cache Components Errors', () => {\n \n             await expect(browser).toDisplayCollapsedRedbox(`\n              {\n-               \"description\": \"Route \"/sync-server-params/[slug]\" used \\`params.slug\\`. \\`params\\` should be awaited before using its properties. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis\",\n+               \"description\": \"Route \"/sync-server-params/[slug]\" used \\`params.slug\\`. \\`params\\` is a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis\",\n                \"environmentLabel\": \"Prerender\",\n                \"label\": \"Console Error\",\n                \"source\": \"app/sync-server-params/[slug]/page.tsx (24:39) @ ParamsReadingComponent\n@@ -1976,19 +1870,6 @@ describe('Cache Components Errors', () => {\n              }\n             `)\n           })\n-        } else {\n-          it('should not error the build when synchronously reading `params.slug`', async () => {\n-            try {\n-              await prerender(`${pathname}/[slug]`)\n-            } catch (error) {\n-              throw new Error('expected build not to fail', { cause: error })\n-            }\n-\n-            expect(next.cliOutput).toContain(` ${pathname}/[slug]`)\n-            await next.start({ skipBuild: true })\n-            const browser = await next.browser(`${pathname}/test`)\n-            expect(await browser.elementById('param').text()).toBe('undefined')\n-          })\n         }\n       })\n     })\n@@ -2450,7 +2331,7 @@ describe('Cache Components Errors', () => {\n             if (isTurbopack) {\n               await expect(browser).toDisplayRedbox(`\n                {\n-                 \"description\": \"Route /use-cache-cookies used \"cookies\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"cookies\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\",\n+                 \"description\": \"Route /use-cache-cookies used \\`cookies()\\` inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \\`cookies()\\` outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\",\n                  \"environmentLabel\": null,\n                  \"label\": \"Runtime Error\",\n                  \"source\": \"app/use-cache-cookies/page.tsx (22:18) @ CookiesReadingComponent\n@@ -2464,7 +2345,7 @@ describe('Cache Components Errors', () => {\n             } else {\n               await expect(browser).toDisplayRedbox(`\n                {\n-                 \"description\": \"Route /use-cache-cookies used \"cookies\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"cookies\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\",\n+                 \"description\": \"Route /use-cache-cookies used \\`cookies()\\` inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \\`cookies()\\` outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\",\n                  \"environmentLabel\": null,\n                  \"label\": \"Runtime Error\",\n                  \"source\": \"app/use-cache-cookies/page.tsx (22:18) @ CookiesReadingComponent\n@@ -2493,7 +2374,7 @@ describe('Cache Components Errors', () => {\n             if (isTurbopack) {\n               if (isDebugPrerender) {\n                 expect(output).toMatchInlineSnapshot(`\n-                 \"Error: Route /use-cache-cookies used \"cookies\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"cookies\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\n+                 \"Error: Route /use-cache-cookies used \\`cookies()\\` inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \\`cookies()\\` outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\n                      at CookiesReadingComponent (bundler:///app/use-cache-cookies/page.tsx:22:18)\n                    20 |   // in userland.\n                    21 |   try {\n@@ -2510,7 +2391,7 @@ describe('Cache Components Errors', () => {\n                 `)\n               } else {\n                 expect(output).toMatchInlineSnapshot(`\n-                 \"Error: Route /use-cache-cookies used \"cookies\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"cookies\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\n+                 \"Error: Route /use-cache-cookies used \\`cookies()\\` inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \\`cookies()\\` outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\n                      at <unknown> (bundler:///app/use-cache-cookies/page.tsx:22:11)\n                    20 |   // in userland.\n                    21 |   try {\n@@ -2529,7 +2410,7 @@ describe('Cache Components Errors', () => {\n             } else {\n               if (isDebugPrerender) {\n                 expect(output).toMatchInlineSnapshot(`\n-                 \"Error: Route /use-cache-cookies used \"cookies\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"cookies\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\n+                 \"Error: Route /use-cache-cookies used \\`cookies()\\` inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \\`cookies()\\` outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\n                      at CookiesReadingComponent (bundler:///app/use-cache-cookies/page.tsx:22:18)\n                      at <unknown> (bundler:///<next-src>)\n                    20 |   // in userland.\n@@ -2547,7 +2428,7 @@ describe('Cache Components Errors', () => {\n                 `)\n               } else {\n                 expect(output).toMatchInlineSnapshot(`\n-                 \"Error: Route /use-cache-cookies used \"cookies\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"cookies\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\n+                 \"Error: Route /use-cache-cookies used \\`cookies()\\` inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \\`cookies()\\` outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\n                      at a (<next-dist-dir>)\n                      at b (<next-dist-dir>)\n                      at c (<next-dist-dir>)\n@@ -2573,7 +2454,7 @@ describe('Cache Components Errors', () => {\n             if (isTurbopack) {\n               await expect(browser).toDisplayRedbox(`\n                {\n-                 \"description\": \"Route /use-cache-draft-mode used \"draftMode().enable()\" inside \"use cache\". The enabled status of draftMode can be read in caches but you must not enable or disable draftMode inside a cache. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\",\n+                 \"description\": \"Route /use-cache-draft-mode used \"draftMode().enable()\" inside \"use cache\". The enabled status of \\`draftMode()\\` can be read in caches but you must not enable or disable \\`draftMode()\\` inside a cache. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\",\n                  \"environmentLabel\": null,\n                  \"label\": \"Runtime Error\",\n                  \"source\": \"app/use-cache-draft-mode/page.tsx (20:26) @ DraftModeEnablingComponent\n@@ -2587,7 +2468,7 @@ describe('Cache Components Errors', () => {\n             } else {\n               await expect(browser).toDisplayRedbox(`\n                {\n-                 \"description\": \"Route /use-cache-draft-mode used \"draftMode().enable()\" inside \"use cache\". The enabled status of draftMode can be read in caches but you must not enable or disable draftMode inside a cache. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\",\n+                 \"description\": \"Route /use-cache-draft-mode used \"draftMode().enable()\" inside \"use cache\". The enabled status of \\`draftMode()\\` can be read in caches but you must not enable or disable \\`draftMode()\\` inside a cache. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\",\n                  \"environmentLabel\": null,\n                  \"label\": \"Runtime Error\",\n                  \"source\": \"app/use-cache-draft-mode/page.tsx (20:26) @ DraftModeEnablingComponent\n@@ -2616,7 +2497,7 @@ describe('Cache Components Errors', () => {\n             if (isTurbopack) {\n               if (isDebugPrerender) {\n                 expect(output).toMatchInlineSnapshot(`\n-                 \"Error: Route /use-cache-draft-mode used \"draftMode().enable()\" inside \"use cache\". The enabled status of draftMode can be read in caches but you must not enable or disable draftMode inside a cache. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\n+                 \"Error: Route /use-cache-draft-mode used \"draftMode().enable()\" inside \"use cache\". The enabled status of \\`draftMode()\\` can be read in caches but you must not enable or disable \\`draftMode()\\` inside a cache. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\n                      at DraftModeEnablingComponent (bundler:///app/use-cache-draft-mode/page.tsx:20:26)\n                    18 |   // here to ensure that this error is shown even when it's caught in userland.\n                    19 |   try {\n@@ -2633,7 +2514,7 @@ describe('Cache Components Errors', () => {\n                 `)\n               } else {\n                 expect(output).toMatchInlineSnapshot(`\n-                 \"Error: Route /use-cache-draft-mode used \"draftMode().enable()\" inside \"use cache\". The enabled status of draftMode can be read in caches but you must not enable or disable draftMode inside a cache. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\n+                 \"Error: Route /use-cache-draft-mode used \"draftMode().enable()\" inside \"use cache\". The enabled status of \\`draftMode()\\` can be read in caches but you must not enable or disable \\`draftMode()\\` inside a cache. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\n                      at <unknown> (bundler:///app/use-cache-draft-mode/page.tsx:20:26)\n                    18 |   // here to ensure that this error is shown even when it's caught in userland.\n                    19 |   try {\n@@ -2652,7 +2533,7 @@ describe('Cache Components Errors', () => {\n             } else {\n               if (isDebugPrerender) {\n                 expect(output).toMatchInlineSnapshot(`\n-                 \"Error: Route /use-cache-draft-mode used \"draftMode().enable()\" inside \"use cache\". The enabled status of draftMode can be read in caches but you must not enable or disable draftMode inside a cache. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\n+                 \"Error: Route /use-cache-draft-mode used \"draftMode().enable()\" inside \"use cache\". The enabled status of \\`draftMode()\\` can be read in caches but you must not enable or disable \\`draftMode()\\` inside a cache. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\n                      at DraftModeEnablingComponent (bundler:///app/use-cache-draft-mode/page.tsx:20:26)\n                    18 |   // here to ensure that this error is shown even when it's caught in userland.\n                    19 |   try {\n@@ -2669,7 +2550,7 @@ describe('Cache Components Errors', () => {\n                 `)\n               } else {\n                 expect(output).toMatchInlineSnapshot(`\n-                 \"Error: Route /use-cache-draft-mode used \"draftMode().enable()\" inside \"use cache\". The enabled status of draftMode can be read in caches but you must not enable or disable draftMode inside a cache. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\n+                 \"Error: Route /use-cache-draft-mode used \"draftMode().enable()\" inside \"use cache\". The enabled status of \\`draftMode()\\` can be read in caches but you must not enable or disable \\`draftMode()\\` inside a cache. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\n                      at a (<next-dist-dir>)\n                  To get a more detailed stack trace and pinpoint the issue, try one of the following:\n                    - Start the app in development mode by running \\`next dev\\`, then open \"/use-cache-draft-mode\" in your browser to investigate the error.\n@@ -2693,7 +2574,7 @@ describe('Cache Components Errors', () => {\n             if (isTurbopack) {\n               await expect(browser).toDisplayRedbox(`\n                {\n-                 \"description\": \"Route /use-cache-headers used \"headers\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"headers\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\",\n+                 \"description\": \"Route /use-cache-headers used \\`headers()\\` inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \\`headers()\\` outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\",\n                  \"environmentLabel\": null,\n                  \"label\": \"Runtime Error\",\n                  \"source\": \"app/use-cache-headers/page.tsx (21:18) @ HeadersReadingComponent\n@@ -2707,7 +2588,7 @@ describe('Cache Components Errors', () => {\n             } else {\n               await expect(browser).toDisplayRedbox(`\n                {\n-                 \"description\": \"Route /use-cache-headers used \"headers\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"headers\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\",\n+                 \"description\": \"Route /use-cache-headers used \\`headers()\\` inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \\`headers()\\` outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\",\n                  \"environmentLabel\": null,\n                  \"label\": \"Runtime Error\",\n                  \"source\": \"app/use-cache-headers/page.tsx (21:18) @ HeadersReadingComponent\n@@ -2736,7 +2617,7 @@ describe('Cache Components Errors', () => {\n             if (isTurbopack) {\n               if (isDebugPrerender) {\n                 expect(output).toMatchInlineSnapshot(`\n-                 \"Error: Route /use-cache-headers used \"headers\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"headers\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\n+                 \"Error: Route /use-cache-headers used \\`headers()\\` inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \\`headers()\\` outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\n                      at HeadersReadingComponent (bundler:///app/use-cache-headers/page.tsx:21:18)\n                    19 |   // to ensure that this error is shown even when it's caught in userland.\n                    20 |   try {\n@@ -2753,7 +2634,7 @@ describe('Cache Components Errors', () => {\n                 `)\n               } else {\n                 expect(output).toMatchInlineSnapshot(`\n-                 \"Error: Route /use-cache-headers used \"headers\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"headers\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\n+                 \"Error: Route /use-cache-headers used \\`headers()\\` inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \\`headers()\\` outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\n                      at <unknown> (bundler:///app/use-cache-headers/page.tsx:21:11)\n                    19 |   // to ensure that this error is shown even when it's caught in userland.\n                    20 |   try {\n@@ -2772,7 +2653,7 @@ describe('Cache Components Errors', () => {\n             } else {\n               if (isDebugPrerender) {\n                 expect(output).toMatchInlineSnapshot(`\n-                 \"Error: Route /use-cache-headers used \"headers\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"headers\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\n+                 \"Error: Route /use-cache-headers used \\`headers()\\` inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \\`headers()\\` outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\n                      at HeadersReadingComponent (bundler:///app/use-cache-headers/page.tsx:21:18)\n                      at <unknown> (bundler:///<next-src>)\n                    19 |   // to ensure that this error is shown even when it's caught in userland.\n@@ -2790,7 +2671,7 @@ describe('Cache Components Errors', () => {\n                 `)\n               } else {\n                 expect(output).toMatchInlineSnapshot(`\n-                 \"Error: Route /use-cache-headers used \"headers\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"headers\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\n+                 \"Error: Route /use-cache-headers used \\`headers()\\` inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \\`headers()\\` outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\n                      at a (<next-dist-dir>)\n                      at b (<next-dist-dir>)\n                      at c (<next-dist-dir>)\n@@ -3361,7 +3242,7 @@ describe('Cache Components Errors', () => {\n             if (isTurbopack) {\n               await expect(browser).toDisplayRedbox(`\n                {\n-                 \"description\": \"Route /use-cache-private-connection used \"connection\" inside \"use cache: private\". The \\`connection()\\` function is used to indicate the subsequent code must only run when there is an actual navigation request, but caches must be able to be produced before a navigation request, so this function is not allowed in this scope. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\",\n+                 \"description\": \"Route /use-cache-private-connection used \\`connection()\\` inside \"use cache: private\". The \\`connection()\\` function is used to indicate the subsequent code must only run when there is an actual navigation request, but caches must be able to be produced before a navigation request, so this function is not allowed in this scope. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\",\n                  \"environmentLabel\": null,\n                  \"label\": \"Runtime Error\",\n                  \"source\": \"app/use-cache-private-connection/page.tsx (25:21) @ Private\n@@ -3375,7 +3256,7 @@ describe('Cache Components Errors', () => {\n             } else {\n               await expect(browser).toDisplayRedbox(`\n                {\n-                 \"description\": \"Route /use-cache-private-connection used \"connection\" inside \"use cache: private\". The \\`connection()\\` function is used to indicate the subsequent code must only run when there is an actual navigation request, but caches must be able to be produced before a navigation request, so this function is not allowed in this scope. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\",\n+                 \"description\": \"Route /use-cache-private-connection used \\`connection()\\` inside \"use cache: private\". The \\`connection()\\` function is used to indicate the subsequent code must only run when there is an actual navigation request, but caches must be able to be produced before a navigation request, so this function is not allowed in this scope. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\",\n                  \"environmentLabel\": null,\n                  \"label\": \"Runtime Error\",\n                  \"source\": \"app/use-cache-private-connection/page.tsx (25:21) @ Private"
        },
        {
            "sha": "f2c6b8a7b236a52a0adeb4f849804b29286245ac",
            "filename": "test/e2e/app-dir/cache-components-errors/fixtures/default/app/sync-client-search/page.tsx",
            "status": "modified",
            "additions": 2,
            "deletions": 5,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Ffixtures%2Fdefault%2Fapp%2Fsync-client-search%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Ffixtures%2Fdefault%2Fapp%2Fsync-client-search%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Ffixtures%2Fdefault%2Fapp%2Fsync-client-search%2Fpage.tsx?ref=1dda5b668bc57fdad6c4cf840c2083e6c66ad9db",
            "patch": "@@ -1,7 +1,5 @@\n 'use client'\n \n-import { type UnsafeUnwrappedSearchParams } from 'next/server'\n-\n type SearchParams = { foo: string | string[] | undefined }\n export default function Page(props: { searchParams: Promise<SearchParams> }) {\n   return (\n@@ -21,9 +19,8 @@ function SearchParamsReadingComponent({\n }: {\n   searchParams: Promise<SearchParams>\n }) {\n-  const fooParam = (\n-    searchParams as unknown as UnsafeUnwrappedSearchParams<typeof searchParams>\n-  ).foo\n+  // Cast to any as we removed UnsafeUnwrapped types, but still need to test with the sync access\n+  const fooParam = (searchParams as any).foo\n   return (\n     <div>\n       this component reads the `foo` search param:{' '}"
        },
        {
            "sha": "2d0bb26bbd018d1c1a928986ca9eedac9ce3dbd9",
            "filename": "test/e2e/app-dir/cache-components-errors/fixtures/default/app/sync-cookies-runtime/page.tsx",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Ffixtures%2Fdefault%2Fapp%2Fsync-cookies-runtime%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Ffixtures%2Fdefault%2Fapp%2Fsync-cookies-runtime%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Ffixtures%2Fdefault%2Fapp%2Fsync-cookies-runtime%2Fpage.tsx?ref=1dda5b668bc57fdad6c4cf840c2083e6c66ad9db",
            "patch": "@@ -1,4 +1,4 @@\n-import { cookies, type UnsafeUnwrappedCookies } from 'next/headers'\n+import { cookies } from 'next/headers'\n import { connection } from 'next/server'\n import { Suspense } from 'react'\n \n@@ -20,8 +20,8 @@ export default async function Page() {\n async function CookiesReadingComponent() {\n   // Await a connection to test the subsequent sync cookies access at runtime.\n   await connection()\n-\n-  const token = (cookies() as unknown as UnsafeUnwrappedCookies).get('token')\n+  // Cast to any as we removed UnsafeUnwrapped types, but still need to test with the sync access\n+  const token = (cookies() as any).get('token')\n \n   return (\n     <div>"
        },
        {
            "sha": "f8282241d0a70dbf2f8d74a4e52f1b9a6c2e3970",
            "filename": "test/e2e/app-dir/cache-components-errors/fixtures/default/app/sync-cookies/page.tsx",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Ffixtures%2Fdefault%2Fapp%2Fsync-cookies%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Ffixtures%2Fdefault%2Fapp%2Fsync-cookies%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Ffixtures%2Fdefault%2Fapp%2Fsync-cookies%2Fpage.tsx?ref=1dda5b668bc57fdad6c4cf840c2083e6c66ad9db",
            "patch": "@@ -1,4 +1,4 @@\n-import { cookies, type UnsafeUnwrappedCookies } from 'next/headers'\n+import { cookies } from 'next/headers'\n \n export default async function Page() {\n   return (\n@@ -14,7 +14,8 @@ export default async function Page() {\n }\n \n async function CookiesReadingComponent() {\n-  const token = (cookies() as unknown as UnsafeUnwrappedCookies).get('token')\n+  // Cast to any as we removed UnsafeUnwrapped types, but still need to test with the sync access\n+  const token = (cookies() as any).get('token')\n \n   return (\n     <div>"
        },
        {
            "sha": "81fb9fa1a66d1176472185c37415831b0aa9dc91",
            "filename": "test/e2e/app-dir/cache-components-errors/fixtures/default/app/sync-draft-mode/page.tsx",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Ffixtures%2Fdefault%2Fapp%2Fsync-draft-mode%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Ffixtures%2Fdefault%2Fapp%2Fsync-draft-mode%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Ffixtures%2Fdefault%2Fapp%2Fsync-draft-mode%2Fpage.tsx?ref=1dda5b668bc57fdad6c4cf840c2083e6c66ad9db",
            "patch": "@@ -1,4 +1,4 @@\n-import { draftMode, UnsafeUnwrappedDraftMode } from 'next/headers'\n+import { draftMode } from 'next/headers'\n import { connection } from 'next/server'\n import { Suspense } from 'react'\n \n@@ -20,8 +20,8 @@ export default async function Page() {\n \n async function DraftModeReadingComponent() {\n   await new Promise((r) => process.nextTick(r))\n-  const isEnabled = (draftMode() as unknown as UnsafeUnwrappedDraftMode)\n-    .isEnabled\n+  // Cast to any as we removed UnsafeUnwrapped types, but still need to test with the sync access\n+  const isEnabled = (draftMode() as any).isEnabled\n   return (\n     <div>\n       this component read the draftMode isEnabled status synchronously:{' '}"
        },
        {
            "sha": "79289968dfb05c511c0fe55ee346c450e4ce452b",
            "filename": "test/e2e/app-dir/cache-components-errors/fixtures/default/app/sync-headers-runtime/page.tsx",
            "status": "modified",
            "additions": 3,
            "deletions": 5,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Ffixtures%2Fdefault%2Fapp%2Fsync-headers-runtime%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Ffixtures%2Fdefault%2Fapp%2Fsync-headers-runtime%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Ffixtures%2Fdefault%2Fapp%2Fsync-headers-runtime%2Fpage.tsx?ref=1dda5b668bc57fdad6c4cf840c2083e6c66ad9db",
            "patch": "@@ -1,4 +1,4 @@\n-import { headers, type UnsafeUnwrappedHeaders } from 'next/headers'\n+import { headers } from 'next/headers'\n import { connection } from 'next/server'\n import { Suspense } from 'react'\n \n@@ -20,10 +20,8 @@ export default async function Page() {\n async function HeadersReadingComponent() {\n   // Await a connection to test the subsequent sync headers access at runtime.\n   await connection()\n-\n-  const userAgent = (headers() as unknown as UnsafeUnwrappedHeaders).get(\n-    'user-agent'\n-  )\n+  // Cast to any as we removed UnsafeUnwrapped types, but still need to test with the sync access\n+  const userAgent = (headers() as any).get('user-agent')\n   return (\n     <div>\n       this component reads the `user-agent` header synchronously: {userAgent}"
        },
        {
            "sha": "a5c1132d8aa6ea54492bc660d0014ab41c3bcb96",
            "filename": "test/e2e/app-dir/cache-components-errors/fixtures/default/app/sync-headers/page.tsx",
            "status": "modified",
            "additions": 3,
            "deletions": 4,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Ffixtures%2Fdefault%2Fapp%2Fsync-headers%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Ffixtures%2Fdefault%2Fapp%2Fsync-headers%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Ffixtures%2Fdefault%2Fapp%2Fsync-headers%2Fpage.tsx?ref=1dda5b668bc57fdad6c4cf840c2083e6c66ad9db",
            "patch": "@@ -1,4 +1,4 @@\n-import { headers, type UnsafeUnwrappedHeaders } from 'next/headers'\n+import { headers } from 'next/headers'\n \n export default async function Page() {\n   return (\n@@ -14,9 +14,8 @@ export default async function Page() {\n }\n \n async function HeadersReadingComponent() {\n-  const userAgent = (headers() as unknown as UnsafeUnwrappedHeaders).get(\n-    'user-agent'\n-  )\n+  // Cast to any as we removed UnsafeUnwrapped types, but still need to test with the sync access\n+  const userAgent = (headers() as any).get('user-agent')\n   return (\n     <div>\n       this component reads the `user-agent` header synchronously: {userAgent}"
        },
        {
            "sha": "b17c07381a707cc391f3cfd24af078bacfbe3d8f",
            "filename": "test/e2e/app-dir/cache-components-errors/fixtures/default/app/sync-server-search/page.tsx",
            "status": "modified",
            "additions": 3,
            "deletions": 4,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Ffixtures%2Fdefault%2Fapp%2Fsync-server-search%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Ffixtures%2Fdefault%2Fapp%2Fsync-server-search%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Ffixtures%2Fdefault%2Fapp%2Fsync-server-search%2Fpage.tsx?ref=1dda5b668bc57fdad6c4cf840c2083e6c66ad9db",
            "patch": "@@ -1,4 +1,4 @@\n-import { connection, type UnsafeUnwrappedSearchParams } from 'next/server'\n+import { connection } from 'next/server'\n import { Suspense } from 'react'\n \n type SearchParams = { foo: string | string[] | undefined }\n@@ -25,9 +25,8 @@ async function SearchParamsReadingComponent({\n }: {\n   searchParams: Promise<SearchParams>\n }) {\n-  const fooParam = (\n-    searchParams as unknown as UnsafeUnwrappedSearchParams<typeof searchParams>\n-  ).foo\n+  // Cast to any as we removed UnsafeUnwrapped types, but still need to test with the sync access\n+  const fooParam = (searchParams as any).foo\n   return (\n     <div>\n       this component reads the `foo` search param:{' '}"
        },
        {
            "sha": "1cb48facd632d499976e26976ba126c6067173b7",
            "filename": "test/e2e/app-dir/cache-components/app/cookies/exercise/components.tsx",
            "status": "modified",
            "additions": 2,
            "deletions": 3,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fe2e%2Fapp-dir%2Fcache-components%2Fapp%2Fcookies%2Fexercise%2Fcomponents.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fe2e%2Fapp-dir%2Fcache-components%2Fapp%2Fcookies%2Fexercise%2Fcomponents.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fcache-components%2Fapp%2Fcookies%2Fexercise%2Fcomponents.tsx?ref=1dda5b668bc57fdad6c4cf840c2083e6c66ad9db",
            "patch": "@@ -1,7 +1,6 @@\n-import { UnsafeUnwrappedCookies } from 'next/headers'\n+import type { cookies } from 'next/headers'\n \n-// We don't export this type (why) but we can exfiltrate it through our exported typecase type\n-type ReadonlyRequestCookies = UnsafeUnwrappedCookies\n+type ReadonlyRequestCookies = Awaited<ReturnType<typeof cookies>>\n \n export function AllComponents({\n   cookies,"
        },
        {
            "sha": "e121434847fc3086b6f2697fcb52ebbd778df353",
            "filename": "test/e2e/app-dir/dynamic-data/dynamic-data.test.ts",
            "status": "modified",
            "additions": 12,
            "deletions": 12,
            "changes": 24,
            "blob_url": "https://github.com/vercel/next.js/blob/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fe2e%2Fapp-dir%2Fdynamic-data%2Fdynamic-data.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fe2e%2Fapp-dir%2Fdynamic-data%2Fdynamic-data.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fdynamic-data%2Fdynamic-data.test.ts?ref=1dda5b668bc57fdad6c4cf840c2083e6c66ad9db",
            "patch": "@@ -178,7 +178,7 @@ describe('dynamic-data with dynamic = \"error\"', () => {\n       try {\n         await expect(browser).toDisplayRedbox(`\n          {\n-           \"description\": \"Route /cookies with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`cookies\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering\",\n+           \"description\": \"Route /cookies with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`cookies()\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering\",\n            \"environmentLabel\": \"Server\",\n            \"label\": \"Runtime Error\",\n            \"source\": \"app/cookies/page.js (14:24) @ Page\n@@ -197,7 +197,7 @@ describe('dynamic-data with dynamic = \"error\"', () => {\n       try {\n         await expect(browser).toDisplayRedbox(`\n          {\n-           \"description\": \"Route /connection with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`connection\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering\",\n+           \"description\": \"Route /connection with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`connection()\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering\",\n            \"environmentLabel\": \"Server\",\n            \"label\": \"Runtime Error\",\n            \"source\": \"app/connection/page.js (6:19) @ Page\n@@ -216,7 +216,7 @@ describe('dynamic-data with dynamic = \"error\"', () => {\n       try {\n         await expect(browser).toDisplayRedbox(`\n          {\n-           \"description\": \"Route /headers with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`headers\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering\",\n+           \"description\": \"Route /headers with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`headers()\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering\",\n            \"environmentLabel\": \"Server\",\n            \"label\": \"Runtime Error\",\n            \"source\": \"app/headers/page.js (14:35) @ Page\n@@ -259,13 +259,13 @@ describe('dynamic-data with dynamic = \"error\"', () => {\n       }\n       // Error: Page with `dynamic = \"error\"` couldn't be rendered statically because it used `headers`\n       expect(next.cliOutput).toMatch(\n-        'Error: Route /cookies with `dynamic = \"error\"` couldn\\'t be rendered statically because it used `cookies`'\n+        'Error: Route /cookies with `dynamic = \"error\"` couldn\\'t be rendered statically because it used `cookies()`'\n       )\n       expect(next.cliOutput).toMatch(\n-        'Error: Route /connection with `dynamic = \"error\"` couldn\\'t be rendered statically because it used `connection`'\n+        'Error: Route /connection with `dynamic = \"error\"` couldn\\'t be rendered statically because it used `connection()`'\n       )\n       expect(next.cliOutput).toMatch(\n-        'Error: Route /headers with `dynamic = \"error\"` couldn\\'t be rendered statically because it used `headers`'\n+        'Error: Route /headers with `dynamic = \"error\"` couldn\\'t be rendered statically because it used `headers()`'\n       )\n       expect(next.cliOutput).toMatch(\n         'Error: Route /search with `dynamic = \"error\"` couldn\\'t be rendered statically because it used `await searchParams`, `searchParams.then`, or similar'\n@@ -307,7 +307,7 @@ describe('dynamic-data inside cache scope', () => {\n       try {\n         await expect(browser).toDisplayRedbox(`\n          {\n-           \"description\": \"Route /cookies used \"cookies\" inside a function cached with \"unstable_cache(...)\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"cookies\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache\",\n+           \"description\": \"Route /cookies used \\`cookies()\\` inside a function cached with \\`unstable_cache()\\`. Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \\`cookies()\\` outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache\",\n            \"environmentLabel\": \"Server\",\n            \"label\": \"Runtime Error\",\n            \"source\": \"app/cookies/page.js (4:40) @ ${isTurbopack ? '<anonymous>' : 'eval'}\n@@ -327,7 +327,7 @@ describe('dynamic-data inside cache scope', () => {\n       try {\n         await expect(browser).toDisplayRedbox(`\n          {\n-           \"description\": \"Route /connection used \"connection\" inside a function cached with \"unstable_cache(...)\". The \\`connection()\\` function is used to indicate the subsequent code must only run when there is an actual Request, but caches must be able to be produced before a Request so this function is not allowed in this scope. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache\",\n+           \"description\": \"Route /connection used \\`connection()\\` inside a function cached with \\`unstable_cache()\\`. The \\`connection()\\` function is used to indicate the subsequent code must only run when there is an actual Request, but caches must be able to be produced before a Request so this function is not allowed in this scope. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache\",\n            \"environmentLabel\": \"Server\",\n            \"label\": \"Runtime Error\",\n            \"source\": \"app/connection/page.js (4:54) @ ${isTurbopack ? '<anonymous>' : 'eval'}\n@@ -347,7 +347,7 @@ describe('dynamic-data inside cache scope', () => {\n       try {\n         await expect(browser).toDisplayRedbox(`\n          {\n-           \"description\": \"Route /headers used \"headers\" inside a function cached with \"unstable_cache(...)\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"headers\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache\",\n+           \"description\": \"Route /headers used \\`headers()\\` inside a function cached with \\`unstable_cache()\\`. Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \\`headers()\\` outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache\",\n            \"environmentLabel\": \"Server\",\n            \"label\": \"Runtime Error\",\n            \"source\": \"app/headers/page.js (4:40) @ ${isTurbopack ? '<anonymous>' : 'eval'}\n@@ -371,13 +371,13 @@ describe('dynamic-data inside cache scope', () => {\n         // We expect this to fail\n       }\n       expect(next.cliOutput).toMatch(\n-        'Error: Route /cookies used \"cookies\" inside a function cached with \"unstable_cache(...)\".'\n+        'Error: Route /cookies used `cookies()` inside a function cached with `unstable_cache()`.'\n       )\n       expect(next.cliOutput).toMatch(\n-        'Error: Route /connection used \"connection\" inside a function cached with \"unstable_cache(...)\".'\n+        'Error: Route /connection used `connection()` inside a function cached with `unstable_cache()`.'\n       )\n       expect(next.cliOutput).toMatch(\n-        'Error: Route /headers used \"headers\" inside a function cached with \"unstable_cache(...)\".'\n+        'Error: Route /headers used `headers()` inside a function cached with `unstable_cache()`.'\n       )\n     })\n   }"
        },
        {
            "sha": "95daa25c3b6fe450d894b9717373153ef1aa4a58",
            "filename": "test/e2e/app-dir/next-after-app-api-usage/index.test.ts",
            "status": "modified",
            "additions": 22,
            "deletions": 22,
            "changes": 44,
            "blob_url": "https://github.com/vercel/next.js/blob/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fe2e%2Fapp-dir%2Fnext-after-app-api-usage%2Findex.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fe2e%2Fapp-dir%2Fnext-after-app-api-usage%2Findex.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fnext-after-app-api-usage%2Findex.test.ts?ref=1dda5b668bc57fdad6c4cf840c2083e6c66ad9db",
            "patch": "@@ -55,32 +55,32 @@ describe('nextjs APIs in after()', () => {\n \n         expect(logs).not.toContain(`[${path}] headers(): ok`)\n         expect(logs).toContain(\n-          `[${path}] headers(): error: Error: Route ${path} used \"headers\" inside \"after(...)\". This is not supported.`\n+          `[${path}] headers(): error: Error: Route ${path} used \\`headers()\\` inside \\`after()\\`. This is not supported.`\n         )\n \n         expect(logs).not.toContain(`[${path}] nested headers(): ok`)\n         expect(logs).toContain(\n-          `[${path}] nested headers(): error: Error: Route ${path} used \"headers\" inside \"after(...)\". This is not supported.`\n+          `[${path}] nested headers(): error: Error: Route ${path} used \\`headers()\\` inside \\`after()\\`. This is not supported.`\n         )\n \n         expect(logs).not.toContain(`[${path}] cookies(): ok`)\n         expect(logs).toContain(\n-          `[${path}] cookies(): error: Error: Route ${path} used \"cookies\" inside \"after(...)\". This is not supported.`\n+          `[${path}] cookies(): error: Error: Route ${path} used \\`cookies()\\` inside \\`after()\\`. This is not supported.`\n         )\n \n         expect(logs).not.toContain(`[${path}] nested cookies(): ok`)\n         expect(logs).toContain(\n-          `[${path}] nested cookies(): error: Error: Route ${path} used \"cookies\" inside \"after(...)\". This is not supported.`\n+          `[${path}] nested cookies(): error: Error: Route ${path} used \\`cookies()\\` inside \\`after()\\`. This is not supported.`\n         )\n \n         expect(logs).not.toContain(`[${path}] connection(): ok`)\n         expect(logs).toContain(\n-          `[${path}] connection(): error: Error: Route ${path} used \"connection\" inside \"after(...)\".`\n+          `[${path}] connection(): error: Error: Route ${path} used \\`connection()\\` inside \\`after()\\`.`\n         )\n \n         expect(logs).not.toContain(`[${path}] nested connection(): ok`)\n         expect(logs).toContain(\n-          `[${path}] nested connection(): error: Error: Route ${path} used \"connection\" inside \"after(...)\".`\n+          `[${path}] nested connection(): error: Error: Route ${path} used \\`connection()\\` inside \\`after()\\`.`\n         )\n       })\n     })\n@@ -102,32 +102,32 @@ describe('nextjs APIs in after()', () => {\n \n           expect(logs).not.toContain(`[${path}] headers(): ok`)\n           expect(logs).toContain(\n-            `[${path}] headers(): error: Error: Route ${path} used \"headers\" inside \"after(...)\". This is not supported.`\n+            `[${path}] headers(): error: Error: Route ${path} used \\`headers()\\` inside \\`after()\\`. This is not supported.`\n           )\n \n           expect(logs).not.toContain(`[${path}] nested headers(): ok`)\n           expect(logs).toContain(\n-            `[${path}] nested headers(): error: Error: Route ${path} used \"headers\" inside \"after(...)\". This is not supported.`\n+            `[${path}] nested headers(): error: Error: Route ${path} used \\`headers()\\` inside \\`after()\\`. This is not supported.`\n           )\n \n           expect(logs).not.toContain(`[${path}] cookies(): ok`)\n           expect(logs).toContain(\n-            `[${path}] cookies(): error: Error: Route ${path} used \"cookies\" inside \"after(...)\". This is not supported.`\n+            `[${path}] cookies(): error: Error: Route ${path} used \\`cookies()\\` inside \\`after()\\`. This is not supported.`\n           )\n \n           expect(logs).not.toContain(`[${path}] nested cookies(): ok`)\n           expect(logs).toContain(\n-            `[${path}] nested cookies(): error: Error: Route ${path} used \"cookies\" inside \"after(...)\". This is not supported.`\n+            `[${path}] nested cookies(): error: Error: Route ${path} used \\`cookies()\\` inside \\`after()\\`. This is not supported.`\n           )\n \n           expect(logs).not.toContain(`[${path}] connection(): ok`)\n           expect(logs).toContain(\n-            `[${path}] connection(): error: Error: Route ${path} used \"connection\" inside \"after(...)\".`\n+            `[${path}] connection(): error: Error: Route ${path} used \\`connection()\\` inside \\`after()\\`.`\n           )\n \n           expect(logs).not.toContain(`[${path}] nested connection(): ok`)\n           expect(logs).toContain(\n-            `[${path}] nested connection(): error: Error: Route ${path} used \"connection\" inside \"after(...)\".`\n+            `[${path}] nested connection(): error: Error: Route ${path} used \\`connection()\\` inside \\`after()\\`.`\n           )\n         })\n       })\n@@ -190,32 +190,32 @@ describe('nextjs APIs in after()', () => {\n \n         expect(logs).not.toContain(`[${path}] headers(): ok`)\n         expect(logs).toContain(\n-          `[${path}] headers(): error: Error: Route ${path} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`headers\\`.`\n+          `[${path}] headers(): error: Error: Route ${path} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`headers()\\`.`\n         )\n \n         expect(logs).not.toContain(`[${path}] nested headers(): ok`)\n         expect(logs).toContain(\n-          `[${path}] nested headers(): error: Error: Route ${path} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`headers\\`.`\n+          `[${path}] nested headers(): error: Error: Route ${path} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`headers()\\`.`\n         )\n \n         expect(logs).not.toContain(`[${path}] cookies(): ok`)\n         expect(logs).toContain(\n-          `[${path}] cookies(): error: Error: Route ${path} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`cookies\\`.`\n+          `[${path}] cookies(): error: Error: Route ${path} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`cookies()\\`.`\n         )\n \n         expect(logs).not.toContain(`[${path}] nested cookies(): ok`)\n         expect(logs).toContain(\n-          `[${path}] nested cookies(): error: Error: Route ${path} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`cookies\\`.`\n+          `[${path}] nested cookies(): error: Error: Route ${path} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`cookies()\\`.`\n         )\n \n         expect(logs).not.toContain(`[${path}] connection(): ok`)\n         expect(logs).toContain(\n-          `[${path}] connection(): error: Error: Route ${path} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`connection\\`.`\n+          `[${path}] connection(): error: Error: Route ${path} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`connection()\\`.`\n         )\n \n         expect(logs).not.toContain(`[${path}] nested connection(): ok`)\n         expect(logs).toContain(\n-          `[${path}] nested connection(): error: Error: Route ${path} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`connection\\`.`\n+          `[${path}] nested connection(): error: Error: Route ${path} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`connection()\\`.`\n         )\n       })\n     })\n@@ -250,10 +250,10 @@ describe('nextjs APIs in after()', () => {\n         const logs = isDynamic || isNextDev ? getLogs() : buildLogs\n         expect(logs).toContain(`[${path}] draft.isEnabled: false`)\n         expect(logs).toContain(\n-          `Route ${path} used \"draftMode().enable()\" inside \\`after\\``\n+          `Route ${path} used \"draftMode().enable()\" inside \\`after()\\``\n         )\n         expect(logs).toContain(\n-          `Route ${path} used \"draftMode().disable()\" inside \\`after\\``\n+          `Route ${path} used \"draftMode().disable()\" inside \\`after()\\``\n         )\n       })\n     })\n@@ -266,10 +266,10 @@ describe('nextjs APIs in after()', () => {\n         const logs = getLogs()\n         expect(logs).toContain(`[${path}] draft.isEnabled: false`)\n         expect(logs).toContain(\n-          `Route ${path} used \"draftMode().enable()\" inside \\`after\\``\n+          `Route ${path} used \"draftMode().enable()\" inside \\`after()\\``\n         )\n         expect(logs).toContain(\n-          `Route ${path} used \"draftMode().disable()\" inside \\`after\\``\n+          `Route ${path} used \"draftMode().disable()\" inside \\`after()\\``\n         )\n       })\n     })"
        },
        {
            "sha": "72a95f2f44c9f8d11f08736319b1abd5903caeb2",
            "filename": "test/e2e/app-dir/ppr-full/components/dynamic.jsx",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fe2e%2Fapp-dir%2Fppr-full%2Fcomponents%2Fdynamic.jsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fe2e%2Fapp-dir%2Fppr-full%2Fcomponents%2Fdynamic.jsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fppr-full%2Fcomponents%2Fdynamic.jsx?ref=1dda5b668bc57fdad6c4cf840c2083e6c66ad9db",
            "patch": "@@ -1,12 +1,12 @@\n import React from 'react'\n import * as next from 'next/headers'\n \n-export const Dynamic = ({ pathname, fallback = null, params = null }) => {\n+export const Dynamic = async ({ pathname, fallback = null, params = null }) => {\n   if (fallback) {\n     return <div data-fallback>Dynamic Loading...</div>\n   }\n \n-  const headers = next.headers()\n+  const headers = await next.headers()\n   const messages = []\n   for (const name of ['x-test-input', 'user-agent']) {\n     messages.push({ name, value: headers.get(name) })"
        },
        {
            "sha": "a71c12e02099e8bcf4f205fd1ed6f7b8c7216ee0",
            "filename": "test/e2e/app-dir/use-cache-search-params/use-cache-search-params.test.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fe2e%2Fapp-dir%2Fuse-cache-search-params%2Fuse-cache-search-params.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fe2e%2Fapp-dir%2Fuse-cache-search-params%2Fuse-cache-search-params.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache-search-params%2Fuse-cache-search-params.test.ts?ref=1dda5b668bc57fdad6c4cf840c2083e6c66ad9db",
            "patch": "@@ -9,7 +9,7 @@ import {\n import stripAnsi from 'strip-ansi'\n \n const getExpectedErrorMessage = (route: string) =>\n-  `Route ${route} used \"searchParams\" inside \"use cache\". Accessing dynamic request data inside a cache scope is not supported. If you need some search params inside a cached function await \"searchParams\" outside of the cached function and pass only the required search params as arguments to the cached function. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n+  `Route ${route} used \\`searchParams\\` inside \"use cache\". Accessing dynamic request data inside a cache scope is not supported. If you need some search params inside a cached function await \\`searchParams\\` outside of the cached function and pass only the required search params as arguments to the cached function. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n \n describe('use-cache-search-params', () => {\n   const { next, isNextDev, skipped } = nextTestSetup({"
        },
        {
            "sha": "c35ff4ca57549a76678b56856a20b06aa2c765aa",
            "filename": "test/e2e/app-dir/use-cache/use-cache.test.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fuse-cache.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fuse-cache.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fuse-cache.test.ts?ref=1dda5b668bc57fdad6c4cf840c2083e6c66ad9db",
            "patch": "@@ -886,7 +886,7 @@ describe('use-cache', () => {\n           const expectedErrorMessage = disableJavaScript\n             ? 'Failed to load resource: the server responded with a status of 500 (Internal Server Error)'\n             : isNextDev\n-              ? 'Route /draft-mode/[mode] used \"cookies\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"cookies\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache'\n+              ? 'Route /draft-mode/[mode] used `cookies()` inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use `cookies()` outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache'\n               : GENERIC_RSC_ERROR\n \n           expect(logs).toMatchObject("
        },
        {
            "sha": "8632bdec81d402877224abb1efc5d7e1dff64460",
            "filename": "test/production/app-dir/build-output/index.test.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 19,
            "changes": 19,
            "blob_url": "https://github.com/vercel/next.js/blob/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fproduction%2Fapp-dir%2Fbuild-output%2Findex.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fproduction%2Fapp-dir%2Fbuild-output%2Findex.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fapp-dir%2Fbuild-output%2Findex.test.ts?ref=1dda5b668bc57fdad6c4cf840c2083e6c66ad9db",
            "patch": "@@ -85,25 +85,6 @@ describe('production - app dir - build output', () => {\n     expect(cliOutput).toContain('Next.js build worker exited with code: 78')\n   })\n \n-  it('should fail the build if you use a dynamic API outside of a render context - searchParams', async () => {\n-    await next.stop()\n-    await next.patchFile(\n-      'app/out-of-band-dynamic-api/page.tsx',\n-      outdent`\n-        export default async function Page({ searchParams }) {\n-          setTimeout(() => {\n-            searchParams.foo\n-          }, 0)\n-          return <div>Hello World</div>\n-        }          \n-        `\n-    )\n-    const { cliOutput } = await next.build()\n-    await next.deleteFile('app/out-of-band-dynamic-api/page.tsx')\n-\n-    expect(cliOutput).toContain('Next.js build worker exited with code: 78')\n-  })\n-\n   it('should fail the build if you use a dynamic API outside of a render context - redirect', async () => {\n     await next.stop()\n     await next.patchFile("
        },
        {
            "sha": "babe11f49cd3b57a4aaed5640df82fe354dad61f",
            "filename": "test/production/app-dir/symbolic-file-links/somewhere-else/src/i18n.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 5,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fproduction%2Fapp-dir%2Fsymbolic-file-links%2Fsomewhere-else%2Fsrc%2Fi18n.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fproduction%2Fapp-dir%2Fsymbolic-file-links%2Fsomewhere-else%2Fsrc%2Fi18n.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fapp-dir%2Fsymbolic-file-links%2Fsomewhere-else%2Fsrc%2Fi18n.ts?ref=1dda5b668bc57fdad6c4cf840c2083e6c66ad9db",
            "patch": "@@ -1,11 +1,9 @@\n-import { cookies, type UnsafeUnwrappedCookies } from 'next/headers'\n+import { cookies } from 'next/headers'\n \n // The purpose of this file is to demonstrate that without proper symbolic file checking\n // next accidentally marks files in the root of the project as client files.\n-export default function () {\n-  const locale =\n-    (cookies() as unknown as UnsafeUnwrappedCookies).get('locale')?.value ??\n-    'en'\n+export default async function () {\n+  const locale = (await cookies()).get('locale')?.value ?? 'en'\n \n   return {\n     locale,"
        },
        {
            "sha": "6854eb9a1bcbe8d1d0cef6e5798bb3416337e348",
            "filename": "test/production/standalone-mode/required-server-files/app/rewrite/[slug]/page.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fproduction%2Fstandalone-mode%2Frequired-server-files%2Fapp%2Frewrite%2F%5Bslug%5D%2Fpage.js",
            "raw_url": "https://github.com/vercel/next.js/raw/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fproduction%2Fstandalone-mode%2Frequired-server-files%2Fapp%2Frewrite%2F%5Bslug%5D%2Fpage.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fstandalone-mode%2Frequired-server-files%2Fapp%2Frewrite%2F%5Bslug%5D%2Fpage.js?ref=1dda5b668bc57fdad6c4cf840c2083e6c66ad9db",
            "patch": "@@ -22,7 +22,7 @@ export default async function Page({ params }) {\n       <Suspense>\n         <Postpone>\n           <p id=\"page\">/rewrite/[slug]</p>\n-          <p id=\"params\">{JSON.stringify(params)}</p>\n+          <p id=\"params\">{JSON.stringify(await params)}</p>\n           <p id=\"now\">{Date.now()}</p>\n         </Postpone>\n       </Suspense>"
        },
        {
            "sha": "19e4555284a06e6e62a886d95964630fad54988c",
            "filename": "test/production/standalone-mode/required-server-files/app/search/[key]/page.jsx",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fproduction%2Fstandalone-mode%2Frequired-server-files%2Fapp%2Fsearch%2F%5Bkey%5D%2Fpage.jsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1dda5b668bc57fdad6c4cf840c2083e6c66ad9db/test%2Fproduction%2Fstandalone-mode%2Frequired-server-files%2Fapp%2Fsearch%2F%5Bkey%5D%2Fpage.jsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fstandalone-mode%2Frequired-server-files%2Fapp%2Fsearch%2F%5Bkey%5D%2Fpage.jsx?ref=1dda5b668bc57fdad6c4cf840c2083e6c66ad9db",
            "patch": "@@ -1,10 +1,10 @@\n-export default function Page({ searchParams, params }) {\n+export default async function Page({ searchParams, params }) {\n   return (\n     <dl>\n       <dt>params.key</dt>\n-      <dd data-params>{params.key}</dd>\n+      <dd data-params>{(await params).key}</dd>\n       <dt>searchParams.key</dt>\n-      <dd data-searchParams>{searchParams.key}</dd>\n+      <dd data-searchParams>{(await searchParams).key}</dd>\n     </dl>\n   )\n }"
        }
    ],
    "stats": {
        "total": 2627,
        "additions": 444,
        "deletions": 2183
    }
}