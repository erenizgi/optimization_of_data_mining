{
    "author": "mischnic",
    "message": "Generate required-server-files before prerendering (#86830)\n\nThis will be read by edge functions in a followup, so needs to be written before prerendering.",
    "sha": "c112f8a28340c2b8f89774e8b8f0f8e2efdd6077",
    "files": [
        {
            "sha": "be9d2b1b7c806ba8ce4714287437a39c916a31bc",
            "filename": "packages/next/src/build/index.ts",
            "status": "modified",
            "additions": 171,
            "deletions": 169,
            "changes": 340,
            "blob_url": "https://github.com/vercel/next.js/blob/c112f8a28340c2b8f89774e8b8f0f8e2efdd6077/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/c112f8a28340c2b8f89774e8b8f0f8e2efdd6077/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts?ref=c112f8a28340c2b8f89774e8b8f0f8e2efdd6077",
            "patch": "@@ -1827,6 +1827,177 @@ export default async function build(\n         traceMemoryUsage('Finished type checking', nextBuildSpan)\n       }\n \n+      const requiredServerFilesManifest = await nextBuildSpan\n+        .traceChild('generate-required-server-files')\n+        .traceAsyncFn(async () => {\n+          let runtimeConfig = getNextConfigRuntime(config)\n+\n+          const normalizedCacheHandlers: Record<string, string> = {}\n+          for (const [key, value] of Object.entries(\n+            runtimeConfig.cacheHandlers || {}\n+          )) {\n+            if (key && value) {\n+              normalizedCacheHandlers[key] = path.relative(distDir, value)\n+            }\n+          }\n+\n+          const serverFilesManifest: RequiredServerFilesManifest = {\n+            version: 1,\n+            config: {\n+              ...runtimeConfig,\n+\n+              ...(ciEnvironment.hasNextSupport\n+                ? {\n+                    compress: false,\n+                  }\n+                : {}),\n+              cacheHandler: runtimeConfig.cacheHandler\n+                ? path.relative(distDir, runtimeConfig.cacheHandler)\n+                : runtimeConfig.cacheHandler,\n+              cacheHandlers: normalizedCacheHandlers,\n+              experimental: {\n+                ...runtimeConfig.experimental,\n+                trustHostHeader: ciEnvironment.hasNextSupport,\n+                isExperimentalCompile: isCompileMode,\n+              },\n+            },\n+            appDir: dir,\n+            relativeAppDir: path.relative(outputFileTracingRoot, dir),\n+            files: [\n+              ROUTES_MANIFEST,\n+              path.relative(distDir, pagesManifestPath),\n+              BUILD_MANIFEST,\n+              PRERENDER_MANIFEST,\n+              path.join(SERVER_DIRECTORY, FUNCTIONS_CONFIG_MANIFEST),\n+              path.join(SERVER_DIRECTORY, MIDDLEWARE_MANIFEST),\n+              path.join(SERVER_DIRECTORY, MIDDLEWARE_BUILD_MANIFEST + '.js'),\n+              ...(bundler !== Bundler.Turbopack\n+                ? [\n+                    path.join(\n+                      SERVER_DIRECTORY,\n+                      MIDDLEWARE_REACT_LOADABLE_MANIFEST + '.js'\n+                    ),\n+                    REACT_LOADABLE_MANIFEST,\n+                  ]\n+                : []),\n+              ...(appDir\n+                ? [\n+                    ...(config.experimental.sri\n+                      ? [\n+                          path.join(\n+                            SERVER_DIRECTORY,\n+                            SUBRESOURCE_INTEGRITY_MANIFEST + '.js'\n+                          ),\n+                          path.join(\n+                            SERVER_DIRECTORY,\n+                            SUBRESOURCE_INTEGRITY_MANIFEST + '.json'\n+                          ),\n+                        ]\n+                      : []),\n+                    path.join(SERVER_DIRECTORY, APP_PATHS_MANIFEST),\n+                    path.join(APP_PATH_ROUTES_MANIFEST),\n+                    path.join(\n+                      SERVER_DIRECTORY,\n+                      SERVER_REFERENCE_MANIFEST + '.js'\n+                    ),\n+                    path.join(\n+                      SERVER_DIRECTORY,\n+                      SERVER_REFERENCE_MANIFEST + '.json'\n+                    ),\n+                  ]\n+                : []),\n+              ...(pagesDir && bundler !== Bundler.Turbopack\n+                ? [\n+                    DYNAMIC_CSS_MANIFEST + '.json',\n+                    path.join(SERVER_DIRECTORY, DYNAMIC_CSS_MANIFEST + '.js'),\n+                  ]\n+                : []),\n+              BUILD_ID_FILE,\n+              path.join(SERVER_DIRECTORY, NEXT_FONT_MANIFEST + '.js'),\n+              path.join(SERVER_DIRECTORY, NEXT_FONT_MANIFEST + '.json'),\n+              SERVER_FILES_MANIFEST,\n+            ]\n+              .filter(nonNullable)\n+              .map((file) => path.join(config.distDir, file)),\n+            ignore: [] as string[],\n+          }\n+\n+          if (hasInstrumentationHook) {\n+            serverFilesManifest.files.push(\n+              path.join(SERVER_DIRECTORY, `${INSTRUMENTATION_HOOK_FILENAME}.js`)\n+            )\n+            // If there are edge routes, append the edge instrumentation hook\n+            // Turbopack generates this chunk with a hashed name and references it in middleware-manifest.\n+            let edgeInstrumentationHook = path.join(\n+              SERVER_DIRECTORY,\n+              `edge-${INSTRUMENTATION_HOOK_FILENAME}.js`\n+            )\n+            if (\n+              bundler !== Bundler.Turbopack &&\n+              existsSync(path.join(distDir, edgeInstrumentationHook))\n+            ) {\n+              serverFilesManifest.files.push(edgeInstrumentationHook)\n+            }\n+          }\n+\n+          if (config.experimental.optimizeCss) {\n+            const globOrig =\n+              require('next/dist/compiled/glob') as typeof import('next/dist/compiled/glob')\n+\n+            const cssFilePaths = await new Promise<string[]>(\n+              (resolve, reject) => {\n+                globOrig(\n+                  '**/*.css',\n+                  { cwd: path.join(distDir, 'static') },\n+                  (err, files) => {\n+                    if (err) {\n+                      return reject(err)\n+                    }\n+                    resolve(files)\n+                  }\n+                )\n+              }\n+            )\n+\n+            serverFilesManifest.files.push(\n+              ...cssFilePaths.map((filePath) =>\n+                path.join(config.distDir, 'static', filePath)\n+              )\n+            )\n+          }\n+\n+          // Under standalone mode, we need to ensure that the cache entry debug\n+          // handler is copied so that it can be used in the test. This is required\n+          // for the turbopack test to run as it's more strict about the build\n+          // directories. This is only used for testing and is not used in\n+          // production.\n+          if (\n+            process.env.__NEXT_TEST_MODE &&\n+            process.env.NEXT_PRIVATE_DEBUG_CACHE_ENTRY_HANDLERS\n+          ) {\n+            serverFilesManifest.files.push(\n+              path.relative(\n+                dir,\n+                path.isAbsolute(\n+                  process.env.NEXT_PRIVATE_DEBUG_CACHE_ENTRY_HANDLERS\n+                )\n+                  ? process.env.NEXT_PRIVATE_DEBUG_CACHE_ENTRY_HANDLERS\n+                  : path.join(\n+                      dir,\n+                      process.env.NEXT_PRIVATE_DEBUG_CACHE_ENTRY_HANDLERS\n+                    )\n+              )\n+            )\n+          }\n+\n+          return serverFilesManifest\n+        })\n+\n+      await writeRequiredServerFilesManifest(\n+        distDir,\n+        requiredServerFilesManifest\n+      )\n+\n       const numberOfWorkers = getNumberOfWorkers(config)\n       const collectingPageDataStart = process.hrtime()\n       const postCompileSpinner = createSpinner(\n@@ -2416,124 +2587,6 @@ export default async function build(\n         )\n       }\n \n-      const instrumentationHookEntryFiles: string[] = []\n-      if (hasInstrumentationHook) {\n-        instrumentationHookEntryFiles.push(\n-          path.join(SERVER_DIRECTORY, `${INSTRUMENTATION_HOOK_FILENAME}.js`)\n-        )\n-        // If there's edge routes, append the edge instrumentation hook\n-        // Turbopack generates this chunk with a hashed name and references it in middleware-manifest.\n-        if (\n-          bundler !== Bundler.Turbopack &&\n-          (edgeRuntimeAppCount || edgeRuntimePagesCount)\n-        ) {\n-          instrumentationHookEntryFiles.push(\n-            path.join(\n-              SERVER_DIRECTORY,\n-              `edge-${INSTRUMENTATION_HOOK_FILENAME}.js`\n-            )\n-          )\n-        }\n-      }\n-\n-      const requiredServerFilesManifest = nextBuildSpan\n-        .traceChild('generate-required-server-files')\n-        .traceFn(() => {\n-          let runtimeConfig = getNextConfigRuntime(config)\n-\n-          const normalizedCacheHandlers: Record<string, string> = {}\n-          for (const [key, value] of Object.entries(\n-            runtimeConfig.cacheHandlers || {}\n-          )) {\n-            if (key && value) {\n-              normalizedCacheHandlers[key] = path.relative(distDir, value)\n-            }\n-          }\n-\n-          const serverFilesManifest: RequiredServerFilesManifest = {\n-            version: 1,\n-            config: {\n-              ...runtimeConfig,\n-              ...(ciEnvironment.hasNextSupport\n-                ? {\n-                    compress: false,\n-                  }\n-                : {}),\n-              cacheHandler: runtimeConfig.cacheHandler\n-                ? path.relative(distDir, runtimeConfig.cacheHandler)\n-                : runtimeConfig.cacheHandler,\n-              cacheHandlers: normalizedCacheHandlers,\n-              experimental: {\n-                ...runtimeConfig.experimental,\n-                trustHostHeader: ciEnvironment.hasNextSupport,\n-                isExperimentalCompile: isCompileMode,\n-              },\n-            },\n-            appDir: dir,\n-            relativeAppDir: path.relative(outputFileTracingRoot, dir),\n-            files: [\n-              ROUTES_MANIFEST,\n-              path.relative(distDir, pagesManifestPath),\n-              BUILD_MANIFEST,\n-              PRERENDER_MANIFEST,\n-              path.join(SERVER_DIRECTORY, FUNCTIONS_CONFIG_MANIFEST),\n-              path.join(SERVER_DIRECTORY, MIDDLEWARE_MANIFEST),\n-              path.join(SERVER_DIRECTORY, MIDDLEWARE_BUILD_MANIFEST + '.js'),\n-              ...(bundler !== Bundler.Turbopack\n-                ? [\n-                    path.join(\n-                      SERVER_DIRECTORY,\n-                      MIDDLEWARE_REACT_LOADABLE_MANIFEST + '.js'\n-                    ),\n-                    REACT_LOADABLE_MANIFEST,\n-                  ]\n-                : []),\n-              ...(appDir\n-                ? [\n-                    ...(config.experimental.sri\n-                      ? [\n-                          path.join(\n-                            SERVER_DIRECTORY,\n-                            SUBRESOURCE_INTEGRITY_MANIFEST + '.js'\n-                          ),\n-                          path.join(\n-                            SERVER_DIRECTORY,\n-                            SUBRESOURCE_INTEGRITY_MANIFEST + '.json'\n-                          ),\n-                        ]\n-                      : []),\n-                    path.join(SERVER_DIRECTORY, APP_PATHS_MANIFEST),\n-                    path.join(APP_PATH_ROUTES_MANIFEST),\n-                    path.join(\n-                      SERVER_DIRECTORY,\n-                      SERVER_REFERENCE_MANIFEST + '.js'\n-                    ),\n-                    path.join(\n-                      SERVER_DIRECTORY,\n-                      SERVER_REFERENCE_MANIFEST + '.json'\n-                    ),\n-                  ]\n-                : []),\n-              ...(pagesDir && bundler !== Bundler.Turbopack\n-                ? [\n-                    DYNAMIC_CSS_MANIFEST + '.json',\n-                    path.join(SERVER_DIRECTORY, DYNAMIC_CSS_MANIFEST + '.js'),\n-                  ]\n-                : []),\n-              BUILD_ID_FILE,\n-              path.join(SERVER_DIRECTORY, NEXT_FONT_MANIFEST + '.js'),\n-              path.join(SERVER_DIRECTORY, NEXT_FONT_MANIFEST + '.json'),\n-              SERVER_FILES_MANIFEST,\n-              ...instrumentationHookEntryFiles,\n-            ]\n-              .filter(nonNullable)\n-              .map((file) => path.join(config.distDir, file)),\n-            ignore: [] as string[],\n-          }\n-\n-          return serverFilesManifest\n-        })\n-\n       const middlewareFile = normalizePathSep(\n         proxyFilePath || middlewareFilePath || ''\n       )\n@@ -2648,52 +2701,6 @@ export default async function build(\n \n       await writeBuildId(distDir, buildId)\n \n-      if (config.experimental.optimizeCss) {\n-        const globOrig =\n-          require('next/dist/compiled/glob') as typeof import('next/dist/compiled/glob')\n-\n-        const cssFilePaths = await new Promise<string[]>((resolve, reject) => {\n-          globOrig(\n-            '**/*.css',\n-            { cwd: path.join(distDir, 'static') },\n-            (err, files) => {\n-              if (err) {\n-                return reject(err)\n-              }\n-              resolve(files)\n-            }\n-          )\n-        })\n-\n-        requiredServerFilesManifest.files.push(\n-          ...cssFilePaths.map((filePath) =>\n-            path.join(config.distDir, 'static', filePath)\n-          )\n-        )\n-      }\n-\n-      // Under standalone mode, we need to ensure that the cache entry debug\n-      // handler is copied so that it can be used in the test. This is required\n-      // for the turbopack test to run as it's more strict about the build\n-      // directories. This is only used for testing and is not used in\n-      // production.\n-      if (\n-        process.env.__NEXT_TEST_MODE &&\n-        process.env.NEXT_PRIVATE_DEBUG_CACHE_ENTRY_HANDLERS\n-      ) {\n-        requiredServerFilesManifest.files.push(\n-          path.relative(\n-            dir,\n-            path.isAbsolute(process.env.NEXT_PRIVATE_DEBUG_CACHE_ENTRY_HANDLERS)\n-              ? process.env.NEXT_PRIVATE_DEBUG_CACHE_ENTRY_HANDLERS\n-              : path.join(\n-                  dir,\n-                  process.env.NEXT_PRIVATE_DEBUG_CACHE_ENTRY_HANDLERS\n-                )\n-          )\n-        )\n-      }\n-\n       const features: EventBuildFeatureUsage[] = [\n         {\n           featureName: 'experimental/cacheComponents',\n@@ -2729,11 +2736,6 @@ export default async function build(\n         })\n       )\n \n-      await writeRequiredServerFilesManifest(\n-        distDir,\n-        requiredServerFilesManifest\n-      )\n-\n       // we don't need to inline for turbopack build as\n       // it will handle it's own caching separate of compile\n       if (isGenerateMode && bundler !== Bundler.Turbopack) {"
        }
    ],
    "stats": {
        "total": 340,
        "additions": 171,
        "deletions": 169
    }
}