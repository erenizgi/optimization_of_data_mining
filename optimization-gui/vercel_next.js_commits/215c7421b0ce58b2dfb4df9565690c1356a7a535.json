{
    "author": "timneutkens",
    "message": "Turbopack: hash next/font filename to shorten it (#79089)",
    "sha": "215c7421b0ce58b2dfb4df9565690c1356a7a535",
    "files": [
        {
            "sha": "0384948e2c3f13e0af2640072355b1f9a94bb619",
            "filename": "crates/next-core/src/next_font/google/mod.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/215c7421b0ce58b2dfb4df9565690c1356a7a535/crates%2Fnext-core%2Fsrc%2Fnext_font%2Fgoogle%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/215c7421b0ce58b2dfb4df9565690c1356a7a535/crates%2Fnext-core%2Fsrc%2Fnext_font%2Fgoogle%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_font%2Fgoogle%2Fmod.rs?ref=215c7421b0ce58b2dfb4df9565690c1356a7a535",
            "patch": "@@ -14,6 +14,7 @@ use turbo_tasks_fs::{\n     json::parse_json_with_source_context, DiskFileSystem, File, FileContent, FileSystem,\n     FileSystemPath,\n };\n+use turbo_tasks_hash::hash_xxh3_hash64;\n use turbopack::evaluate_context::node_evaluate_asset_context;\n use turbopack_core::{\n     asset::AssetContent,\n@@ -358,7 +359,7 @@ impl ImportMappingReplacement for NextFontGoogleFontFileReplacer {\n         let ext = ext.with_context(|| format!(\"font url {} is missing an extension\", &url))?;\n \n         // remove dashes and dots as they might be used for the markers below.\n-        let mut name = filename.replace(['-', '.'], \"_\");\n+        let mut name = format!(\"{:016x}\", hash_xxh3_hash64(filename.as_bytes()));\n         if size_adjust {\n             name.push_str(\"-s\")\n         }\n@@ -367,8 +368,7 @@ impl ImportMappingReplacement for NextFontGoogleFontFileReplacer {\n         }\n \n         let font_virtual_path = next_js_file_path(\"internal/font/google\".into())\n-            .join(format!(\"/{}.{}\", name, ext).into())\n-            .truncate_file_name_with_hash_vc();\n+            .join(format!(\"/{}.{}\", name, ext).into());\n \n         // doesn't seem ideal to download the font into a string, but probably doesn't\n         // really matter either."
        },
        {
            "sha": "ebab4e0906bb6133a5d06956afa49a7be34ca7d3",
            "filename": "test/e2e/next-font/index.test.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/215c7421b0ce58b2dfb4df9565690c1356a7a535/test%2Fe2e%2Fnext-font%2Findex.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/215c7421b0ce58b2dfb4df9565690c1356a7a535/test%2Fe2e%2Fnext-font%2Findex.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fnext-font%2Findex.test.ts?ref=215c7421b0ce58b2dfb4df9565690c1356a7a535",
            "patch": "@@ -410,6 +410,10 @@ describe('next/font', () => {\n         .sort()\n \n       for (const href of hrefs) {\n+        // Check that font file path is not too long for Windows systems.\n+        // Windows allows up to 256 characters but we check for 100 here\n+        // because if it's over 100 it's already way too much.\n+        expect(href.length).toBeLessThan(100)\n         hrefMatchesFontWithSizeAdjust(href)\n       }\n "
        },
        {
            "sha": "8c112d97da182f2c81d77399d8e904280712eb8b",
            "filename": "turbopack/crates/turbo-tasks-fs/src/lib.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 115,
            "changes": 117,
            "blob_url": "https://github.com/vercel/next.js/blob/215c7421b0ce58b2dfb4df9565690c1356a7a535/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/215c7421b0ce58b2dfb4df9565690c1356a7a535/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs?ref=215c7421b0ce58b2dfb4df9565690c1356a7a535",
            "patch": "@@ -26,7 +26,7 @@ mod watcher;\n use std::{\n     borrow::Cow,\n     cmp::{min, Ordering},\n-    fmt::{self, Debug, Display, Formatter, Write as _},\n+    fmt::{self, Debug, Display, Formatter},\n     fs::FileType,\n     future::Future,\n     io::{self, BufRead, ErrorKind},\n@@ -63,9 +63,7 @@ use turbo_tasks::{\n     ApplyEffectsContext, Completion, InvalidationReason, Invalidator, NonLocalValue, ReadRef,\n     ResolvedVc, ValueToString, Vc,\n };\n-use turbo_tasks_hash::{\n-    hash_xxh3_hash128, hash_xxh3_hash64, DeterministicHash, DeterministicHasher,\n-};\n+use turbo_tasks_hash::{hash_xxh3_hash64, DeterministicHash, DeterministicHasher};\n use util::{extract_disk_access, join_path, normalize_path, sys_to_unix, unix_to_sys};\n pub use virtual_fs::VirtualFileSystem;\n use watcher::DiskWatcher;\n@@ -1138,65 +1136,6 @@ impl FileSystemPath {\n             (None, path_before_extension, extension)\n         }\n     }\n-\n-    /// Ensure the given filename (just the name, not the full path) is less than\n-    /// [`MAX_SAFE_FILE_NAME_LENGTH`], truncating and suffixing with a hash as needed.\n-    ///\n-    /// If given a file extension, we will attempt to preserve that extension, failing with an error\n-    /// if the extension is too long.\n-    ///\n-    /// A high-quality non-cryptographic 128-bit hash is used, which guarantees that there are no\n-    /// collisions in the absence of malicious input. Given two unique input file paths, we\n-    /// guarantee two unique output file paths.\n-    ///\n-    /// Note: We are hashing the _file name stem_, not the _contents_.\n-    ///\n-    /// If you have a [`Vc<FileSystemPath>`], call\n-    /// [`FileSystemPath::truncate_file_name_with_hash_vc`] instead.\n-    pub fn truncate_file_name_with_hash(&self) -> Result<Cow<'_, FileSystemPath>> {\n-        let (parent, stem, extension) = self.split_file_stem_extension();\n-        // length of the extension plus the dot ('.')\n-        let extension_with_dot_len = extension.map(|ext| ext.len() + 1).unwrap_or(0);\n-\n-        // common case: file name is a safe length\n-        if (stem.len() + extension_with_dot_len) <= MAX_SAFE_FILE_NAME_LENGTH {\n-            return Ok(Cow::Borrowed(self));\n-        }\n-\n-        // generate a 32-character hex-encoded hash\n-        let hash = hash_xxh3_hash128(stem);\n-        let hash_str = format!(\"{:01$x}\", hash, std::mem::size_of::<u128>() * 2);\n-\n-        let remaining_len = MAX_SAFE_FILE_NAME_LENGTH\n-            .checked_sub(\n-                // +1 byte here for the underscore ('_') separator\n-                hash_str.len() + extension_with_dot_len + 1,\n-            )\n-            .with_context(|| {\n-                format!(\n-                    \"Unable to truncate {} because the file extension exceeds {} bytes\",\n-                    self.path,\n-                    MAX_SAFE_FILE_NAME_LENGTH - 2\n-                )\n-            })?;\n-\n-        let mut path_str = String::with_capacity(\n-            parent.map(|p| p.len() + 1).unwrap_or(0) + MAX_SAFE_FILE_NAME_LENGTH,\n-        );\n-        if let Some(parent) = parent {\n-            // unwrap: write!() on a string should never fail\n-            write!(path_str, \"{parent}/\").unwrap();\n-        }\n-        write!(path_str, \"{}_{}\", &stem[..remaining_len], hash_str).unwrap();\n-        if let Some(extension) = extension {\n-            write!(path_str, \".{extension}\").unwrap();\n-        }\n-\n-        Ok(Cow::Owned(FileSystemPath {\n-            fs: self.fs,\n-            path: RcStr::from(path_str),\n-        }))\n-    }\n }\n \n #[turbo_tasks::value(transparent)]\n@@ -1399,16 +1338,6 @@ impl FileSystemPath {\n         }\n         Vc::cell(Some(file_stem.into()))\n     }\n-\n-    /// See [`truncate_file_name_with_hash`]. Preserves the input [`Vc`] if no truncation was\n-    /// performed.\n-    #[turbo_tasks::function]\n-    pub async fn truncate_file_name_with_hash_vc(self: Vc<Self>) -> Result<Vc<FileSystemPath>> {\n-        Ok(match self.await?.truncate_file_name_with_hash()? {\n-            Cow::Borrowed(_) => self,\n-            Cow::Owned(path) => path.cell(),\n-        })\n-    }\n }\n \n impl Display for FileSystemPath {\n@@ -2592,46 +2521,4 @@ mod tests {\n         .await\n         .unwrap()\n     }\n-\n-    #[tokio::test]\n-    async fn test_truncate_file_name_with_hash() {\n-        crate::register();\n-\n-        turbo_tasks_testing::VcStorage::with(async {\n-            let fs = Vc::upcast::<Box<dyn FileSystem>>(VirtualFileSystem::new());\n-\n-            let mut long_str = String::new();\n-            for _i in 0..1000 {\n-                long_str.push_str(\"long\")\n-            }\n-\n-            // does not change the path (returns exact same Vc) if the file name is short\n-            let path = FileSystemPath::new_normalized(fs, format!(\"{long_str}/short.ext\").into())\n-                .resolve()\n-                .await?;\n-            assert_eq!(\n-                path.truncate_file_name_with_hash_vc().resolve().await?,\n-                path,\n-            );\n-\n-            // truncates and adds hash so that the file name length equals MAX_SAFE_FILE_NAME_LENGTH\n-            let path = FileSystemPath::new_normalized(fs, format!(\"path/{long_str}.ext\").into());\n-            let truncated_path = path.truncate_file_name_with_hash_vc().await?;\n-            assert_eq!(\n-                truncated_path.path,\n-                \"path/longlonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglong\\\n-                longlonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglong\\\n-                longlon_235b5eceeef9efad5b37fd5057ab8317.ext\",\n-            );\n-            assert_eq!(truncated_path.file_name().len(), MAX_SAFE_FILE_NAME_LENGTH);\n-\n-            // an extension that's too long should fail\n-            let path = FileSystemPath::new_normalized(fs, format!(\"path/foo.{long_str}\").into());\n-            assert!(path.truncate_file_name_with_hash_vc().await.is_err());\n-\n-            anyhow::Ok(())\n-        })\n-        .await\n-        .unwrap()\n-    }\n }"
        }
    ],
    "stats": {
        "total": 127,
        "additions": 9,
        "deletions": 118
    }
}