{
    "author": "timneutkens",
    "message": "Optimize isMetadataRoute function (#84409)\n\n## What?\n\nHad Claude-4-Sonnet do a pass on optimizing this function. Let's see if\nthe tests pass.",
    "sha": "0014161c94d623aad7c9aa7ec9e53e19899ad68e",
    "files": [
        {
            "sha": "4cc1056d5019f19d4e8b8fb6bb0b1acea77f9112",
            "filename": "packages/next/src/lib/metadata/is-metadata-route.ts",
            "status": "modified",
            "additions": 111,
            "deletions": 40,
            "changes": 151,
            "blob_url": "https://github.com/vercel/next.js/blob/0014161c94d623aad7c9aa7ec9e53e19899ad68e/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Fis-metadata-route.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/0014161c94d623aad7c9aa7ec9e53e19899ad68e/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Fis-metadata-route.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Fis-metadata-route.ts?ref=0014161c94d623aad7c9aa7ec9e53e19899ad68e",
            "patch": "@@ -32,16 +32,19 @@ export const DEFAULT_METADATA_ROUTE_EXTENSIONS = ['js', 'jsx', 'ts', 'tsx']\n \n // Match the file extension with the dynamic multi-routes extensions\n // e.g. ([xml, js], null) -> can match `/sitemap.xml/route`, `sitemap.js/route`\n-// e.g. ([png], [ts]) -> can match `/opengrapg-image.png`, `/opengraph-image.ts`\n+// e.g. ([png], [ts]) -> can match `/opengraph-image.png`, `/opengraph-image.ts`\n export const getExtensionRegexString = (\n   staticExtensions: readonly string[],\n   dynamicExtensions: readonly string[] | null\n ) => {\n+  let result: string\n   // If there's no possible multi dynamic routes, will not match any <name>[].<ext> files\n   if (!dynamicExtensions || dynamicExtensions.length === 0) {\n-    return `(\\\\.(?:${staticExtensions.join('|')}))`\n+    result = `(\\\\.(?:${staticExtensions.join('|')}))`\n+  } else {\n+    result = `(?:\\\\.(${staticExtensions.join('|')})|(\\\\.(${dynamicExtensions.join('|')})))`\n   }\n-  return `(?:\\\\.(${staticExtensions.join('|')})|(\\\\.(${dynamicExtensions.join('|')})))`\n+  return result\n }\n \n /**\n@@ -53,79 +56,147 @@ export function isStaticMetadataFile(appDirRelativePath: string) {\n   return isMetadataRouteFile(appDirRelativePath, [], true)\n }\n \n-/**\n- * Determine if the file is a metadata route file entry\n- * @param appDirRelativePath the relative file path to app/\n- * @param pageExtensions the js extensions, such as ['js', 'jsx', 'ts', 'tsx']\n- * @param strictlyMatchExtensions if it's true, match the file with page extension, otherwise match the file with default corresponding extension\n- * @returns if the file is a metadata route file\n- */\n-export function isMetadataRouteFile(\n-  appDirRelativePath: string,\n+// Pre-compiled static regexes for common cases\n+const FAVICON_REGEX = /^[\\\\/]favicon\\.ico$/\n+const ROBOTS_TXT_REGEX = /^[\\\\/]robots\\.txt$/\n+const MANIFEST_JSON_REGEX = /^[\\\\/]manifest\\.json$/\n+const MANIFEST_WEBMANIFEST_REGEX = /^[\\\\/]manifest\\.webmanifest$/\n+const SITEMAP_XML_REGEX = /[\\\\/]sitemap\\.xml$/\n+\n+// Cache for compiled regex patterns based on parameters\n+const compiledRegexCache = new Map<string, RegExp[]>()\n+\n+// Fast path checks for common metadata files\n+function fastPathCheck(normalizedPath: string): boolean | null {\n+  // Check favicon.ico first (most common)\n+  if (FAVICON_REGEX.test(normalizedPath)) return true\n+\n+  // Check other common static files\n+  if (ROBOTS_TXT_REGEX.test(normalizedPath)) return true\n+  if (MANIFEST_JSON_REGEX.test(normalizedPath)) return true\n+  if (MANIFEST_WEBMANIFEST_REGEX.test(normalizedPath)) return true\n+  if (SITEMAP_XML_REGEX.test(normalizedPath)) return true\n+\n+  // Quick negative check - if it doesn't contain any metadata keywords, skip\n+  if (\n+    !normalizedPath.includes('robots') &&\n+    !normalizedPath.includes('manifest') &&\n+    !normalizedPath.includes('sitemap') &&\n+    !normalizedPath.includes('icon') &&\n+    !normalizedPath.includes('apple-icon') &&\n+    !normalizedPath.includes('opengraph-image') &&\n+    !normalizedPath.includes('twitter-image') &&\n+    !normalizedPath.includes('favicon')\n+  ) {\n+    return false\n+  }\n+\n+  return null // Continue with full regex matching\n+}\n+\n+function getCompiledRegexes(\n   pageExtensions: PageExtensions,\n   strictlyMatchExtensions: boolean\n-) {\n-  // End with the extension or optional to have the extension\n-  // When strictlyMatchExtensions is true, it's used for match file path;\n-  // When strictlyMatchExtensions, the dynamic extension is skipped but\n-  // static extension is kept, which is usually used for matching route path.\n-  const trailingMatcher = (strictlyMatchExtensions ? '' : '?') + '$'\n-  // Match the optional variants like /opengraph-image2, /icon-a102f4.png, etc.\n+): RegExp[] {\n+  // Create cache key\n+  const cacheKey = `${pageExtensions.join(',')}|${strictlyMatchExtensions}`\n+\n+  const cached = compiledRegexCache.get(cacheKey)\n+  if (cached) {\n+    return cached\n+  }\n+\n+  // Pre-compute common strings\n+  const trailingMatcher = strictlyMatchExtensions ? '$' : '?$'\n   const variantsMatcher = '\\\\d?'\n-  // The -\\w{6} is the suffix that normalized from group routes;\n   const groupSuffix = strictlyMatchExtensions ? '' : '(-\\\\w{6})?'\n+  const suffixMatcher = variantsMatcher + groupSuffix\n \n-  const suffixMatcher = `${variantsMatcher}${groupSuffix}`\n+  // Pre-compute extension arrays to avoid repeated concatenation\n+  const robotsExts =\n+    pageExtensions.length > 0 ? [...pageExtensions, 'txt'] : ['txt']\n+  const manifestExts =\n+    pageExtensions.length > 0\n+      ? [...pageExtensions, 'webmanifest', 'json']\n+      : ['webmanifest', 'json']\n \n-  const metadataRouteFilesRegex = [\n+  const regexes = [\n     new RegExp(\n-      `^[\\\\\\\\/]robots${getExtensionRegexString(\n-        pageExtensions.concat('txt'),\n-        null\n-      )}${trailingMatcher}`\n+      `^[\\\\\\\\/]robots${getExtensionRegexString(robotsExts, null)}${trailingMatcher}`\n     ),\n     new RegExp(\n-      `^[\\\\\\\\/]manifest${getExtensionRegexString(\n-        pageExtensions.concat('webmanifest', 'json'),\n-        null\n-      )}${trailingMatcher}`\n+      `^[\\\\\\\\/]manifest${getExtensionRegexString(manifestExts, null)}${trailingMatcher}`\n     ),\n-    new RegExp(`^[\\\\\\\\/]favicon\\\\.ico$`),\n+    // FAVICON_REGEX removed - already handled in fastPathCheck\n     new RegExp(\n       `[\\\\\\\\/]sitemap${getExtensionRegexString(['xml'], pageExtensions)}${trailingMatcher}`\n     ),\n     new RegExp(\n-      `[\\\\\\\\/]${STATIC_METADATA_IMAGES.icon.filename}${suffixMatcher}${getExtensionRegexString(\n+      `[\\\\\\\\/]icon${suffixMatcher}${getExtensionRegexString(\n         STATIC_METADATA_IMAGES.icon.extensions,\n         pageExtensions\n       )}${trailingMatcher}`\n     ),\n     new RegExp(\n-      `[\\\\\\\\/]${STATIC_METADATA_IMAGES.apple.filename}${suffixMatcher}${getExtensionRegexString(\n+      `[\\\\\\\\/]apple-icon${suffixMatcher}${getExtensionRegexString(\n         STATIC_METADATA_IMAGES.apple.extensions,\n         pageExtensions\n       )}${trailingMatcher}`\n     ),\n     new RegExp(\n-      `[\\\\\\\\/]${STATIC_METADATA_IMAGES.openGraph.filename}${suffixMatcher}${getExtensionRegexString(\n+      `[\\\\\\\\/]opengraph-image${suffixMatcher}${getExtensionRegexString(\n         STATIC_METADATA_IMAGES.openGraph.extensions,\n         pageExtensions\n       )}${trailingMatcher}`\n     ),\n     new RegExp(\n-      `[\\\\\\\\/]${STATIC_METADATA_IMAGES.twitter.filename}${suffixMatcher}${getExtensionRegexString(\n+      `[\\\\\\\\/]twitter-image${suffixMatcher}${getExtensionRegexString(\n         STATIC_METADATA_IMAGES.twitter.extensions,\n         pageExtensions\n       )}${trailingMatcher}`\n     ),\n   ]\n \n-  const normalizedAppDirRelativePath = normalizePathSep(appDirRelativePath)\n-  const matched = metadataRouteFilesRegex.some((r) =>\n-    r.test(normalizedAppDirRelativePath)\n-  )\n+  compiledRegexCache.set(cacheKey, regexes)\n+  return regexes\n+}\n \n-  return matched\n+/**\n+ * Determine if the file is a metadata route file entry\n+ * @param appDirRelativePath the relative file path to app/\n+ * @param pageExtensions the js extensions, such as ['js', 'jsx', 'ts', 'tsx']\n+ * @param strictlyMatchExtensions if it's true, match the file with page extension, otherwise match the file with default corresponding extension\n+ * @returns if the file is a metadata route file\n+ */\n+export function isMetadataRouteFile(\n+  appDirRelativePath: string,\n+  pageExtensions: PageExtensions,\n+  strictlyMatchExtensions: boolean\n+): boolean {\n+  // Early exit for empty or obviously non-metadata paths\n+  if (!appDirRelativePath || appDirRelativePath.length < 2) {\n+    return false\n+  }\n+\n+  const normalizedPath = normalizePathSep(appDirRelativePath)\n+\n+  // Fast path check for common cases\n+  const fastResult = fastPathCheck(normalizedPath)\n+  if (fastResult !== null) {\n+    return fastResult\n+  }\n+\n+  // Get compiled regexes from cache\n+  const regexes = getCompiledRegexes(pageExtensions, strictlyMatchExtensions)\n+\n+  // Use for loop instead of .some() for better performance\n+  for (let i = 0; i < regexes.length; i++) {\n+    if (regexes[i].test(normalizedPath)) {\n+      return true\n+    }\n+  }\n+\n+  return false\n }\n \n // Check if the route is a static metadata route, with /route suffix"
        }
    ],
    "stats": {
        "total": 151,
        "additions": 111,
        "deletions": 40
    }
}