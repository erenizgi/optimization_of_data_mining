{
    "author": "sokra",
    "message": "Turbopack: Fix IO concurrency for MacOS (#85861)\n\n### What?\n\nThe previous default of 256 parallel write operations caused a serious performance problem. For a bigger application this change improves write performance by 5.8x (12.8s -> 2.2s) on MacOS.",
    "sha": "2342c9008b2f497829f82976819d18f1af159863",
    "files": [
        {
            "sha": "c54a6286ceab8eb93513436407f13182df105256",
            "filename": "turbopack/crates/turbo-tasks-fs/src/lib.rs",
            "status": "modified",
            "additions": 46,
            "deletions": 26,
            "changes": 72,
            "blob_url": "https://github.com/vercel/next.js/blob/2342c9008b2f497829f82976819d18f1af159863/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2342c9008b2f497829f82976819d18f1af159863/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs?ref=2342c9008b2f497829f82976819d18f1af159863",
            "patch": "@@ -193,21 +193,36 @@ where\n     }\n }\n \n-fn create_semaphore() -> tokio::sync::Semaphore {\n+fn number_env_var(name: &'static str) -> Option<usize> {\n+    env::var(name)\n+        .ok()\n+        .filter(|val| !val.is_empty())\n+        .map(|val| match val.parse() {\n+            Ok(n) => n,\n+            Err(err) => panic!(\"{name} must be a valid integer: {err}\"),\n+        })\n+        .filter(|val| *val != 0)\n+}\n+\n+fn create_read_semaphore() -> tokio::sync::Semaphore {\n     // the semaphore isn't serialized, and we assume the environment variable doesn't change during\n     // runtime, so it's okay to access it in this untracked way.\n-    static NEXT_TURBOPACK_IO_CONCURRENCY: LazyLock<usize> = LazyLock::new(|| {\n-        env::var(\"NEXT_TURBOPACK_IO_CONCURRENCY\")\n-            .ok()\n-            .filter(|val| !val.is_empty())\n-            .map(|val| {\n-                val.parse()\n-                    .expect(\"NEXT_TURBOPACK_IO_CONCURRENCY must be a valid integer\")\n-            })\n-            .filter(|val| *val != 0)\n-            .unwrap_or(256)\n+    static TURBO_ENGINE_READ_CONCURRENCY: LazyLock<usize> =\n+        LazyLock::new(|| number_env_var(\"TURBO_ENGINE_READ_CONCURRENCY\").unwrap_or(64));\n+    tokio::sync::Semaphore::new(*TURBO_ENGINE_READ_CONCURRENCY)\n+}\n+\n+fn create_write_semaphore() -> tokio::sync::Semaphore {\n+    // the semaphore isn't serialized, and we assume the environment variable doesn't change during\n+    // runtime, so it's okay to access it in this untracked way.\n+    static TURBO_ENGINE_WRITE_CONCURRENCY: LazyLock<usize> = LazyLock::new(|| {\n+        number_env_var(\"TURBO_ENGINE_WRITE_CONCURRENCY\").unwrap_or(\n+            // We write a lot of smallish files where high concurrency will cause metadata\n+            // thrashing. So 4 threads is a safe cross platform suitable value.\n+            4,\n+        )\n     });\n-    tokio::sync::Semaphore::new(*NEXT_TURBOPACK_IO_CONCURRENCY)\n+    tokio::sync::Semaphore::new(*TURBO_ENGINE_WRITE_CONCURRENCY)\n }\n \n #[turbo_tasks::value_trait]\n@@ -257,8 +272,12 @@ struct DiskFileSystemInner {\n     invalidation_lock: RwLock<()>,\n     /// Semaphore to limit the maximum number of concurrent file operations.\n     #[turbo_tasks(debug_ignore, trace_ignore)]\n-    #[serde(skip, default = \"create_semaphore\")]\n-    semaphore: tokio::sync::Semaphore,\n+    #[serde(skip, default = \"create_read_semaphore\")]\n+    read_semaphore: tokio::sync::Semaphore,\n+    /// Semaphore to limit the maximum number of concurrent file operations.\n+    #[turbo_tasks(debug_ignore, trace_ignore)]\n+    #[serde(skip, default = \"create_write_semaphore\")]\n+    write_semaphore: tokio::sync::Semaphore,\n \n     #[turbo_tasks(debug_ignore, trace_ignore)]\n     watcher: DiskWatcher,\n@@ -427,7 +446,7 @@ impl DiskFileSystemInner {\n \n             std::fs::create_dir_all(path)\n         })\n-        .concurrency_limited(&self.semaphore)\n+        .concurrency_limited(&self.write_semaphore)\n         .await?;\n \n         self.watcher\n@@ -444,7 +463,7 @@ impl DiskFileSystemInner {\n         if !already_created {\n             let func = |p: &Path| std::fs::create_dir_all(p);\n             retry_blocking(directory.to_path_buf(), func)\n-                .concurrency_limited(&self.semaphore)\n+                .concurrency_limited(&self.write_semaphore)\n                 .instrument(tracing::info_span!(\n                     \"create directory\",\n                     name = display(directory.display())\n@@ -624,7 +643,8 @@ impl DiskFileSystem {\n                 invalidation_lock: Default::default(),\n                 invalidator_map: InvalidatorMap::new(),\n                 dir_invalidator_map: InvalidatorMap::new(),\n-                semaphore: create_semaphore(),\n+                read_semaphore: create_read_semaphore(),\n+                write_semaphore: create_write_semaphore(),\n                 watcher: DiskWatcher::new(),\n                 denied_path,\n             }),\n@@ -656,7 +676,7 @@ impl FileSystem for DiskFileSystem {\n \n         let _lock = self.inner.lock_path(&full_path).await;\n         let content = match retry_blocking(full_path.clone(), |path: &Path| File::from_path(path))\n-            .concurrency_limited(&self.inner.semaphore)\n+            .concurrency_limited(&self.inner.read_semaphore)\n             .instrument(tracing::info_span!(\n                 \"read file\",\n                 name = display(full_path.display())\n@@ -693,7 +713,7 @@ impl FileSystem for DiskFileSystem {\n                 tracing::info_span!(\"read directory\", name = display(path.display())).entered();\n             std::fs::read_dir(path)\n         })\n-        .concurrency_limited(&self.inner.semaphore)\n+        .concurrency_limited(&self.inner.read_semaphore)\n         .await\n         {\n             Ok(dir) => dir,\n@@ -782,7 +802,7 @@ impl FileSystem for DiskFileSystem {\n         let _lock = self.inner.lock_path(&full_path).await;\n         let link_path =\n             match retry_blocking(full_path.clone(), |path: &Path| std::fs::read_link(path))\n-                .concurrency_limited(&self.inner.semaphore)\n+                .concurrency_limited(&self.inner.read_semaphore)\n                 .instrument(tracing::info_span!(\n                     \"read symlink\",\n                     name = display(full_path.display())\n@@ -904,7 +924,7 @@ impl FileSystem for DiskFileSystem {\n             // not wasting cycles.\n             let compare = content\n                 .streaming_compare(&full_path)\n-                .concurrency_limited(&inner.semaphore)\n+                .concurrency_limited(&inner.read_semaphore)\n                 .instrument(tracing::info_span!(\n                     \"read file before write\",\n                     name = display(full_path.display())\n@@ -972,7 +992,7 @@ impl FileSystem for DiskFileSystem {\n                         }\n                         Ok::<(), io::Error>(())\n                     })\n-                    .concurrency_limited(&inner.semaphore)\n+                    .concurrency_limited(&inner.write_semaphore)\n                     .instrument(tracing::info_span!(\n                         \"write file\",\n                         name = display(full_path.display())\n@@ -984,7 +1004,7 @@ impl FileSystem for DiskFileSystem {\n                     retry_blocking(full_path.clone().into_owned(), |path| {\n                         std::fs::remove_file(path)\n                     })\n-                    .concurrency_limited(&inner.semaphore)\n+                    .concurrency_limited(&inner.write_semaphore)\n                     .instrument(tracing::info_span!(\n                         \"remove file\",\n                         name = display(full_path.display())\n@@ -1049,7 +1069,7 @@ impl FileSystem for DiskFileSystem {\n             let old_content = match retry_blocking(full_path.clone().into_owned(), |path| {\n                 std::fs::read_link(path)\n             })\n-            .concurrency_limited(&inner.semaphore)\n+            .concurrency_limited(&inner.read_semaphore)\n             .instrument(tracing::info_span!(\n                 \"read symlink before write\",\n                 name = display(full_path.display())\n@@ -1131,7 +1151,7 @@ impl FileSystem for DiskFileSystem {\n                     retry_blocking(full_path.clone().into_owned(), |path| {\n                         std::fs::remove_file(path)\n                     })\n-                    .concurrency_limited(&inner.semaphore)\n+                    .concurrency_limited(&inner.write_semaphore)\n                     .await\n                     .or_else(|err| {\n                         if err.kind() == ErrorKind::NotFound {\n@@ -1166,7 +1186,7 @@ impl FileSystem for DiskFileSystem {\n \n         let _lock = self.inner.lock_path(&full_path).await;\n         let meta = retry_blocking(full_path.clone(), |path| std::fs::metadata(path))\n-            .concurrency_limited(&self.inner.semaphore)\n+            .concurrency_limited(&self.inner.read_semaphore)\n             .instrument(tracing::info_span!(\n                 \"read metadata\",\n                 name = display(full_path.display())"
        }
    ],
    "stats": {
        "total": 72,
        "additions": 46,
        "deletions": 26
    }
}