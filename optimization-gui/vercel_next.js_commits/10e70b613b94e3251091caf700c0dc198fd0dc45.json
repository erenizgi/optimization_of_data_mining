{
    "author": "bgw",
    "message": "Turbopack: Implement `TaskInput` for `ReadRef`, use a `ReadRef` input for `AssetIdent::new` (#83356)\n\n@lukesandberg and I noticed this opportunity.\n\n### Hypothesis\n\n`AssetIdent::new` is a dummy constructor function used for caching value with unique `Vc`s. It is called frequently. The `AssetIdent` struct is large and contains three different `Vec`s, so it's likely non-trivial to clone.\n\n- When an uncached turbo task function is called, its argument is boxed and cloned once to be used as cache key. There's two copies of the argument at this point: A cache key, and a local copy for the about-to-be-executed function.\n- This function immediately constructs a cell, which moves its local copy of the argument into a `triomphe::Arc`, preserving it.\n\nSo we end up with two persistent copies of the task input. This doesn't matter when the struct is small and cheap to clone, but it does matter here.\n\nThe solution is to wrap `AssetIdent` in a `ReadRef` before passing it to a `turbo_tasks::function`. `ReadRef` does not impact equality (defers to inner value), it's cheap to clone, and `ReadRef::cell` provides a fast-path that re-uses the inner `triomphe::Arc` for the newly constructed cell:\n\nhttps://github.com/vercel/next.js/blob/5cf762235a1e9f02443f45a69a7afd1880317f77/turbopack/crates/turbo-tasks/src/read_ref.rs#L247-L262\n\n### Tradeoffs\n\nIf there's a cache hit, this approach constructs and throws away a temporary `Arc`, that the original implementation wouldn't. So in cases where there's a very high cache hit rate, or where the `Clone` would've been very cheap, this may come with a CPU time tradeoff. That doesn't seem to be the case here (cache hits are about 30%).\n\n### Rough Benchmark\n\nDoes not save a measurable amount of memory\n\n```\ncargo run --release -p next-build-test -- generate ~/shadcn-ui/apps/v4/ > ~/shadcn-ui/apps/v4/project_options.json\ncd ~/shadcn-ui/apps/v4/\npnpm i\ncommand time -v ~/next.js/target/release/next-build-test run sequential 1 1 '/sink'\n```\n\nmaxrss (kbytes) before (5 runs):\n```\n2355284\n2325432\n2320960\n2281920\n2385740\n```\n\nmaxrss (kbytes) after (5 runs):\n```\n2361084\n2323468\n2364040\n2353300\n2388904\n```\n\nThis shows it's slightly worse, but only 1%, so it's easily within margin-of-error:\n\n<img src=\"https://app.graphite.dev/user-attachments/assets/a1a7e1c8-bc05-4262-91d8-c3590f5a1253.png\" width=500>",
    "sha": "10e70b613b94e3251091caf700c0dc198fd0dc45",
    "files": [
        {
            "sha": "f01a8edb1de3f953b791dfec76d074545ff28ca2",
            "filename": "turbopack/crates/turbo-tasks-macros/src/value_macro.rs",
            "status": "modified",
            "additions": 26,
            "deletions": 19,
            "changes": 45,
            "blob_url": "https://github.com/vercel/next.js/blob/10e70b613b94e3251091caf700c0dc198fd0dc45/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_macro.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/10e70b613b94e3251091caf700c0dc198fd0dc45/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_macro.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_macro.rs?ref=10e70b613b94e3251091caf700c0dc198fd0dc45",
            "patch": "@@ -207,7 +207,7 @@ impl Parse for ValueArguments {\n }\n \n pub fn value(args: TokenStream, input: TokenStream) -> TokenStream {\n-    let mut item = parse_macro_input!(input as Item);\n+    let item = parse_macro_input!(input as Item);\n     let ValueArguments {\n         serialization_mode,\n         into_mode,\n@@ -217,13 +217,21 @@ pub fn value(args: TokenStream, input: TokenStream) -> TokenStream {\n         operation,\n     } = parse_macro_input!(args as ValueArguments);\n \n+    let mut struct_attributes = vec![quote! {\n+        #[derive(\n+            turbo_tasks::ShrinkToFit,\n+            turbo_tasks::trace::TraceRawVcs,\n+            turbo_tasks::NonLocalValue,\n+        )]\n+        #[shrink_to_fit(crate = \"turbo_tasks::macro_helpers::shrink_to_fit\")]\n+    }];\n+\n     let mut inner_type = None;\n     if transparent {\n         if let Item::Struct(ItemStruct {\n-            attrs,\n             fields: Fields::Unnamed(FieldsUnnamed { unnamed, .. }),\n             ..\n-        }) = &mut item\n+        }) = &item\n             && unnamed.len() == 1\n         {\n             let field = unnamed.iter().next().unwrap();\n@@ -251,7 +259,7 @@ pub fn value(args: TokenStream, input: TokenStream) -> TokenStream {\n                  [`{inner_type_string}`].\",\n             );\n \n-            attrs.push(parse_quote! {\n+            struct_attributes.push(parse_quote! {\n                 #[doc = #doc_str]\n             });\n         }\n@@ -343,22 +351,21 @@ pub fn value(args: TokenStream, input: TokenStream) -> TokenStream {\n         quote! {}\n     };\n \n-    let mut struct_attributes = vec![quote! {\n-        #[derive(\n-            turbo_tasks::ShrinkToFit,\n-            turbo_tasks::trace::TraceRawVcs,\n-            turbo_tasks::NonLocalValue,\n-        )]\n-        #[shrink_to_fit(crate = \"turbo_tasks::macro_helpers::shrink_to_fit\")]\n-    }];\n     match serialization_mode {\n-        SerializationMode::Auto => struct_attributes.push(quote! {\n-            #[derive(\n-                turbo_tasks::macro_helpers::serde::Serialize,\n-                turbo_tasks::macro_helpers::serde::Deserialize,\n-            )]\n-            #[serde(crate = \"turbo_tasks::macro_helpers::serde\")]\n-        }),\n+        SerializationMode::Auto => {\n+            struct_attributes.push(quote! {\n+                #[derive(\n+                    turbo_tasks::macro_helpers::serde::Serialize,\n+                    turbo_tasks::macro_helpers::serde::Deserialize,\n+                )]\n+                #[serde(crate = \"turbo_tasks::macro_helpers::serde\")]\n+            });\n+            if transparent {\n+                struct_attributes.push(quote! {\n+                    #[serde(transparent)]\n+                });\n+            }\n+        }\n         SerializationMode::None | SerializationMode::Custom => {}\n     };\n     if inner_type.is_some() {"
        },
        {
            "sha": "76571dc6276f05ac2098c9ecb9d4d7e16b54cee0",
            "filename": "turbopack/crates/turbo-tasks/src/read_ref.rs",
            "status": "modified",
            "additions": 31,
            "deletions": 35,
            "changes": 66,
            "blob_url": "https://github.com/vercel/next.js/blob/10e70b613b94e3251091caf700c0dc198fd0dc45/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fread_ref.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/10e70b613b94e3251091caf700c0dc198fd0dc45/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fread_ref.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fread_ref.rs?ref=10e70b613b94e3251091caf700c0dc198fd0dc45",
            "patch": "@@ -1,8 +1,10 @@\n use std::{\n-    fmt::{Debug, Display},\n-    hash::Hash,\n+    cmp::Ordering,\n+    fmt::{self, Debug, Display},\n+    hash::{Hash, Hasher},\n     marker::PhantomData,\n     mem::transmute_copy,\n+    ops::Deref,\n };\n \n use serde::{Deserialize, Serialize};\n@@ -31,7 +33,7 @@ impl<T> Clone for ReadRef<T> {\n     }\n }\n \n-impl<T> std::ops::Deref for ReadRef<T>\n+impl<T> Deref for ReadRef<T>\n where\n     T: VcValueType,\n {\n@@ -47,28 +49,26 @@ where\n     T: VcValueType,\n     VcReadTarget<T>: Display,\n {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         Display::fmt(&**self, f)\n     }\n }\n \n impl<T> Debug for ReadRef<T>\n where\n-    T: VcValueType,\n-    VcReadTarget<T>: Debug,\n+    T: Debug,\n {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        Debug::fmt(&**self, f)\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        Self::as_raw_ref(self).fmt(f)\n     }\n }\n \n impl<T> TraceRawVcs for ReadRef<T>\n where\n-    T: VcValueType,\n-    VcReadTarget<T>: TraceRawVcs,\n+    T: TraceRawVcs,\n {\n     fn trace_raw_vcs(&self, trace_context: &mut TraceRawVcsContext) {\n-        (**self).trace_raw_vcs(trace_context);\n+        Self::as_raw_ref(self).trace_raw_vcs(trace_context);\n     }\n }\n \n@@ -85,48 +85,39 @@ where\n \n impl<T> PartialEq for ReadRef<T>\n where\n-    T: VcValueType,\n-    VcReadTarget<T>: PartialEq,\n+    T: PartialEq,\n {\n     fn eq(&self, other: &Self) -> bool {\n-        PartialEq::eq(&**self, &**other)\n+        Self::as_raw_ref(self).eq(Self::as_raw_ref(other))\n     }\n }\n \n-impl<T> Eq for ReadRef<T>\n-where\n-    T: VcValueType,\n-    VcReadTarget<T>: Eq,\n-{\n-}\n+impl<T> Eq for ReadRef<T> where T: Eq {}\n \n impl<T> PartialOrd for ReadRef<T>\n where\n-    T: VcValueType,\n-    VcReadTarget<T>: PartialOrd,\n+    T: PartialOrd,\n {\n-    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n-        PartialOrd::partial_cmp(&**self, &**other)\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        Self::as_raw_ref(self).partial_cmp(Self::as_raw_ref(other))\n     }\n }\n \n impl<T> Ord for ReadRef<T>\n where\n-    T: VcValueType,\n-    VcReadTarget<T>: Ord,\n+    T: Ord,\n {\n-    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n-        Ord::cmp(&**self, &**other)\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        Self::as_raw_ref(self).cmp(Self::as_raw_ref(other))\n     }\n }\n \n impl<T> Hash for ReadRef<T>\n where\n-    T: VcValueType,\n-    VcReadTarget<T>: Hash,\n+    T: Hash,\n {\n-    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {\n-        Hash::hash(&**self, state)\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        Self::as_raw_ref(self).hash(state)\n     }\n }\n \n@@ -198,14 +189,13 @@ where\n \n impl<T> Serialize for ReadRef<T>\n where\n-    T: VcValueType,\n-    VcReadTarget<T>: Serialize,\n+    T: Serialize,\n {\n     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n     where\n         S: serde::Serializer,\n     {\n-        (**self).serialize(serializer)\n+        Self::as_raw_ref(self).serialize(serializer)\n     }\n }\n \n@@ -231,6 +221,12 @@ impl<T> ReadRef<T> {\n         Self(arc)\n     }\n \n+    /// Returns the reference to `&T`, rather than `<<T as VcValueType>::Read as VcRead<T>>::Target`\n+    /// (the behavior of [`Deref`]).\n+    pub fn as_raw_ref(this: &ReadRef<T>) -> &T {\n+        &this.0\n+    }\n+\n     pub fn ptr_eq(&self, other: &ReadRef<T>) -> bool {\n         triomphe::Arc::ptr_eq(&self.0, &other.0)\n     }"
        },
        {
            "sha": "a491e70fd625ed9467548cd3b7909bafa5975607",
            "filename": "turbopack/crates/turbo-tasks/src/task/task_input.rs",
            "status": "modified",
            "additions": 20,
            "deletions": 1,
            "changes": 21,
            "blob_url": "https://github.com/vercel/next.js/blob/10e70b613b94e3251091caf700c0dc198fd0dc45/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask%2Ftask_input.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/10e70b613b94e3251091caf700c0dc198fd0dc45/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask%2Ftask_input.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask%2Ftask_input.rs?ref=10e70b613b94e3251091caf700c0dc198fd0dc45",
            "patch": "@@ -13,7 +13,7 @@ use serde::{Deserialize, Serialize};\n use turbo_rcstr::RcStr;\n \n use crate::{\n-    MagicAny, ResolvedVc, TaskId, TransientInstance, TransientValue, ValueTypeId, Vc,\n+    MagicAny, ReadRef, ResolvedVc, TaskId, TransientInstance, TransientValue, ValueTypeId, Vc,\n     trace::TraceRawVcs,\n };\n \n@@ -112,6 +112,25 @@ where\n     }\n }\n \n+impl<T> TaskInput for ReadRef<T>\n+where\n+    T: TaskInput,\n+{\n+    fn is_resolved(&self) -> bool {\n+        Self::as_raw_ref(self).is_resolved()\n+    }\n+\n+    fn is_transient(&self) -> bool {\n+        Self::as_raw_ref(self).is_transient()\n+    }\n+\n+    async fn resolve_input(&self) -> Result<Self> {\n+        Ok(ReadRef::new_owned(\n+            Box::pin(Self::as_raw_ref(self).resolve_input()).await?,\n+        ))\n+    }\n+}\n+\n impl<T> TaskInput for Option<T>\n where\n     T: TaskInput,"
        },
        {
            "sha": "360c6d4a76eb7eef223e5d340fa37b0792a78d50",
            "filename": "turbopack/crates/turbopack-core/src/ident.rs",
            "status": "modified",
            "additions": 71,
            "deletions": 65,
            "changes": 136,
            "blob_url": "https://github.com/vercel/next.js/blob/10e70b613b94e3251091caf700c0dc198fd0dc45/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fident.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/10e70b613b94e3251091caf700c0dc198fd0dc45/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fident.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fident.rs?ref=10e70b613b94e3251091caf700c0dc198fd0dc45",
            "patch": "@@ -5,7 +5,9 @@ use once_cell::sync::Lazy;\n use regex::Regex;\n use serde::{Deserialize, Serialize};\n use turbo_rcstr::RcStr;\n-use turbo_tasks::{NonLocalValue, ResolvedVc, TaskInput, ValueToString, Vc, trace::TraceRawVcs};\n+use turbo_tasks::{\n+    NonLocalValue, ReadRef, ResolvedVc, TaskInput, ValueToString, Vc, trace::TraceRawVcs,\n+};\n use turbo_tasks_fs::FileSystemPath;\n use turbo_tasks_hash::{DeterministicHash, Xxh3Hash64Hasher, encode_hex, hash_xxh3_hash64};\n \n@@ -81,6 +83,10 @@ pub struct AssetIdent {\n }\n \n impl AssetIdent {\n+    pub fn new(ident: AssetIdent) -> Vc<Self> {\n+        AssetIdent::new_inner(ReadRef::new_owned(ident))\n+    }\n+\n     pub fn add_modifier(&mut self, modifier: RcStr) {\n         debug_assert!(!modifier.is_empty(), \"modifiers cannot be empty.\");\n         self.modifiers.push(modifier);\n@@ -98,72 +104,10 @@ impl AssetIdent {\n     }\n }\n \n-#[turbo_tasks::value_impl]\n-impl ValueToString for AssetIdent {\n-    #[turbo_tasks::function]\n-    async fn to_string(&self) -> Result<Vc<RcStr>> {\n-        let mut s = self.path.value_to_string().owned().await?.into_owned();\n-\n-        // The query string is either empty or non-empty starting with `?` so we can just concat\n-        s.push_str(&self.query);\n-        // ditto for fragment\n-        s.push_str(&self.fragment);\n-\n-        if !self.assets.is_empty() {\n-            s.push_str(\" {\");\n-\n-            for (i, (key, asset)) in self.assets.iter().enumerate() {\n-                if i > 0 {\n-                    s.push(',');\n-                }\n-\n-                let asset_str = asset.to_string().await?;\n-                write!(s, \" {key} => {asset_str:?}\")?;\n-            }\n-\n-            s.push_str(\" }\");\n-        }\n-\n-        if let Some(layer) = &self.layer {\n-            write!(s, \" [{}]\", layer.name)?;\n-        }\n-\n-        if !self.modifiers.is_empty() {\n-            s.push_str(\" (\");\n-\n-            for (i, modifier) in self.modifiers.iter().enumerate() {\n-                if i > 0 {\n-                    s.push_str(\", \");\n-                }\n-\n-                s.push_str(modifier);\n-            }\n-\n-            s.push(')');\n-        }\n-\n-        if let Some(content_type) = &self.content_type {\n-            write!(s, \" <{content_type}>\")?;\n-        }\n-\n-        if !self.parts.is_empty() {\n-            for part in self.parts.iter() {\n-                if !matches!(part, ModulePart::Facade) {\n-                    // facade is not included in ident as switching between facade and non-facade\n-                    // shouldn't change the ident\n-                    write!(s, \" <{part}>\")?;\n-                }\n-            }\n-        }\n-\n-        Ok(Vc::cell(s.into()))\n-    }\n-}\n-\n #[turbo_tasks::value_impl]\n impl AssetIdent {\n     #[turbo_tasks::function]\n-    pub fn new(ident: AssetIdent) -> Vc<Self> {\n+    fn new_inner(ident: ReadRef<AssetIdent>) -> Vc<Self> {\n         debug_assert!(\n             ident.query.is_empty() || ident.query.starts_with(\"?\"),\n             \"query should be empty or start with a `?`\"\n@@ -172,7 +116,7 @@ impl AssetIdent {\n             ident.fragment.is_empty() || ident.fragment.starts_with(\"#\"),\n             \"query should be empty or start with a `?`\"\n         );\n-        ident.cell()\n+        ReadRef::cell(ident)\n     }\n \n     /// Creates an [AssetIdent] from a [FileSystemPath]\n@@ -427,6 +371,68 @@ impl AssetIdent {\n     }\n }\n \n+#[turbo_tasks::value_impl]\n+impl ValueToString for AssetIdent {\n+    #[turbo_tasks::function]\n+    async fn to_string(&self) -> Result<Vc<RcStr>> {\n+        let mut s = self.path.value_to_string().owned().await?.into_owned();\n+\n+        // The query string is either empty or non-empty starting with `?` so we can just concat\n+        s.push_str(&self.query);\n+        // ditto for fragment\n+        s.push_str(&self.fragment);\n+\n+        if !self.assets.is_empty() {\n+            s.push_str(\" {\");\n+\n+            for (i, (key, asset)) in self.assets.iter().enumerate() {\n+                if i > 0 {\n+                    s.push(',');\n+                }\n+\n+                let asset_str = asset.to_string().await?;\n+                write!(s, \" {key} => {asset_str:?}\")?;\n+            }\n+\n+            s.push_str(\" }\");\n+        }\n+\n+        if let Some(layer) = &self.layer {\n+            write!(s, \" [{}]\", layer.name)?;\n+        }\n+\n+        if !self.modifiers.is_empty() {\n+            s.push_str(\" (\");\n+\n+            for (i, modifier) in self.modifiers.iter().enumerate() {\n+                if i > 0 {\n+                    s.push_str(\", \");\n+                }\n+\n+                s.push_str(modifier);\n+            }\n+\n+            s.push(')');\n+        }\n+\n+        if let Some(content_type) = &self.content_type {\n+            write!(s, \" <{content_type}>\")?;\n+        }\n+\n+        if !self.parts.is_empty() {\n+            for part in self.parts.iter() {\n+                if !matches!(part, ModulePart::Facade) {\n+                    // facade is not included in ident as switching between facade and non-facade\n+                    // shouldn't change the ident\n+                    write!(s, \" <{part}>\")?;\n+                }\n+            }\n+        }\n+\n+        Ok(Vc::cell(s.into()))\n+    }\n+}\n+\n fn clean_separators(s: &str) -> String {\n     static SEPARATOR_REGEX: Lazy<Regex> = Lazy::new(|| Regex::new(r\"[/#?]\").unwrap());\n     SEPARATOR_REGEX.replace_all(s, \"_\").to_string()"
        }
    ],
    "stats": {
        "total": 268,
        "additions": 148,
        "deletions": 120
    }
}