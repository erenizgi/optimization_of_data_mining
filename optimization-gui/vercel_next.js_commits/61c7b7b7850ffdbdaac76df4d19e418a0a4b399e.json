{
    "author": "bgw",
    "message": "docs(turbo-tasks): Lots of minor fixes, tweaks, and updates to the docs (#78329)\n\nAfter this PR `cargo doc -p turbo-tasks` builds cleanly (though the rest of turbopack almost certainly doesn't).\n\nRendered docs for `Vc`:\n\n![Screenshot 2025-04-18 at 17-30-11 Vc in turbo_tasks - Rust.png](https://graphite-user-uploaded-assets-prod.s3.amazonaws.com/HAZVitxRNnZz8QMiPn4a/187685ba-e9b5-4f27-848d-8c1f14e3f2a3.png)",
    "sha": "61c7b7b7850ffdbdaac76df4d19e418a0a4b399e",
    "files": [
        {
            "sha": "592dea8c2f550334fb7aa6a70e3130cfb33393b1",
            "filename": "turbopack/crates/turbo-rcstr/src/lib.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 2,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/61c7b7b7850ffdbdaac76df4d19e418a0a4b399e/turbopack%2Fcrates%2Fturbo-rcstr%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/61c7b7b7850ffdbdaac76df4d19e418a0a4b399e/turbopack%2Fcrates%2Fturbo-rcstr%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-rcstr%2Fsrc%2Flib.rs?ref=61c7b7b7850ffdbdaac76df4d19e418a0a4b399e",
            "patch": "@@ -22,13 +22,16 @@ mod tagged_value;\n \n /// An immutable reference counted [`String`], similar to [`Arc<String>`][std::sync::Arc].\n ///\n-/// This is the preferred immutable string type for [`turbo_task::function`][macro@crate::function]\n-/// arguments and inside of [`turbo_task::value`][macro@crate::value].\n+/// This is the preferred immutable string type for [`turbo_tasks::function`][func] arguments and\n+/// inside of [`turbo_tasks::value`][value].\n ///\n /// As turbo-tasks must store copies of function arguments to enable caching, non-reference counted\n /// [`String`]s would incur frequent cloning. Reference counting typically decreases memory\n /// consumption and CPU time in these cases.\n ///\n+/// [func]: https://turbopack-rust-docs.vercel.sh/rustdoc/turbo_tasks/attr.function.html\n+/// [value]: https://turbopack-rust-docs.vercel.sh/rustdoc/turbo_tasks/attr.value.html\n+///\n /// ## Conversion\n ///\n /// Converting a `String` or `&str` to an `RcStr` can be perfomed using `.into()` or"
        },
        {
            "sha": "c33c5f96f3fe3c263e3722e52598b2a2da6246ce",
            "filename": "turbopack/crates/turbo-tasks-hash/src/deterministic_hash.rs",
            "status": "modified",
            "additions": 11,
            "deletions": 11,
            "changes": 22,
            "blob_url": "https://github.com/vercel/next.js/blob/61c7b7b7850ffdbdaac76df4d19e418a0a4b399e/turbopack%2Fcrates%2Fturbo-tasks-hash%2Fsrc%2Fdeterministic_hash.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/61c7b7b7850ffdbdaac76df4d19e418a0a4b399e/turbopack%2Fcrates%2Fturbo-tasks-hash%2Fsrc%2Fdeterministic_hash.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-hash%2Fsrc%2Fdeterministic_hash.rs?ref=61c7b7b7850ffdbdaac76df4d19e418a0a4b399e",
            "patch": "@@ -24,24 +24,24 @@ macro_rules! impl_write_number {\n     )*}\n }\n \n-/// DeterministicHash is a custom trait that signals the implementor can safely\n-/// be hashed in a replicatable way across platforms and process runs.\n+/// Signals the implementor can safely be hashed in a replicatable way across platforms and process\n+/// runs.\n ///\n-/// Note that the default Hash trait used by Rust is not deterministic for our purposes.\n+/// Note that the default [`std::hash::Hash`] trait used by Rust allows for hashing that differs\n+/// across process runs, so it is not suitable for persistent caching with turbo-tasks.\n ///\n-/// It's very important that Vcs never implement this, since they cannot be\n-/// deterministic. The value that they wrap, however, can implement the trait.\n+/// It's very important that `Vc`s never implement this, since they cannot be deterministic. The\n+/// value that they wrap, however, can implement the trait.\n pub trait DeterministicHash {\n-    /// Adds self's bytes to the [Hasher] state, in a way that is replicatable\n-    /// on any platform or process run.\n+    /// Adds `self`'s bytes to the [`DeterministicHasher`]'s state, in a way that is replicatable on\n+    /// any platform or process run.\n     fn deterministic_hash<H: DeterministicHasher>(&self, state: &mut H);\n }\n \n-/// A custom trait that signals the implementor can safely hash in a replicatable way across\n-/// platforms and process runs.\n+/// Signals the implementor can safely hash in a replicatable way across platforms and process runs.\n ///\n-/// Note that the default Hasher trait used by Rust allows for non-deterministic\n-/// hashing, so it is not suitable for our purposes.\n+/// Note that the default [`std::hash::Hash`] trait used by Rust allows for hashing that differs\n+/// across process runs, so it is not suitable for persistent caching with turbo-tasks.\n pub trait DeterministicHasher {\n     fn finish(&self) -> u64;\n     fn write_bytes(&mut self, bytes: &[u8]);"
        },
        {
            "sha": "3e1618a525a6e9d48d2fb823a8557e646dd65704",
            "filename": "turbopack/crates/turbo-tasks-macros-shared/src/expand.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/61c7b7b7850ffdbdaac76df4d19e418a0a4b399e/turbopack%2Fcrates%2Fturbo-tasks-macros-shared%2Fsrc%2Fexpand.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/61c7b7b7850ffdbdaac76df4d19e418a0a4b399e/turbopack%2Fcrates%2Fturbo-tasks-macros-shared%2Fsrc%2Fexpand.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros-shared%2Fsrc%2Fexpand.rs?ref=61c7b7b7850ffdbdaac76df4d19e418a0a4b399e",
            "patch": "@@ -10,11 +10,11 @@ use syn::{\n ///\n /// Requires several Fn helpers which perform expand different structures:\n ///\n-/// - [expand_named] handles the expansion of a struct or enum variant with named fields (e.g.\n+/// - `expand_named` handles the expansion of a struct or enum variant with named fields (e.g.\n ///   `struct Foo { bar: u32 }`, `Foo::Bar { baz: u32 }`).\n-/// - [expand_unnamed] handles the expansion of a struct or enum variant with unnamed fields (e.g.\n+/// - `expand_unnamed` handles the expansion of a struct or enum variant with unnamed fields (e.g.\n ///   `struct Foo(u32)`, `Foo::Bar(u32)`).\n-/// - [expand_unit] handles the expansion of a unit struct or enum (e.g. `struct Foo;`, `Foo::Bar`).\n+/// - `expand_unit` handles the expansion of a unit struct or enum (e.g. `struct Foo;`, `Foo::Bar`).\n ///\n /// These helpers should themselves call [generate_destructuring] to generate\n /// the destructure necessary to access the fields of the value."
        },
        {
            "sha": "85e8d09215e7a4c478409def38f9229b87d98ea1",
            "filename": "turbopack/crates/turbo-tasks-macros/src/lib.rs",
            "status": "modified",
            "additions": 12,
            "deletions": 24,
            "changes": 36,
            "blob_url": "https://github.com/vercel/next.js/blob/61c7b7b7850ffdbdaac76df4d19e418a0a4b399e/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/61c7b7b7850ffdbdaac76df4d19e418a0a4b399e/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Flib.rs?ref=61c7b7b7850ffdbdaac76df4d19e418a0a4b399e",
            "patch": "@@ -53,42 +53,30 @@ pub fn derive_task_input(input: TokenStream) -> TokenStream {\n     derive::derive_task_input(input)\n }\n \n-/// Derives the `turbo_tasks::KeyValuePair` trait for a enum. Each variant need to have a `value`\n-/// field which becomes part of the value enum and all remaining fields become part of the key.\n-///\n-/// Assuming the enum is called `Abc` it exposes `AbcKey` and `AbcValue` types for it too. The key\n-/// enum will have `Debug, Clone, PartialEq, Eq, Hash` derived and the value enum will have `Debug,\n-/// Clone` derived. It's expected that all fields implement these traits.\n+/// <!--\n+/// Documentation for this macro is available on the re-export:\n+/// <https://turbopack-rust-docs.vercel.sh/rustdoc/turbo_tasks/derive.KeyValuePair.html>\n+/// -->\n #[proc_macro_derive(KeyValuePair)]\n pub fn derive_key_value_pair(input: TokenStream) -> TokenStream {\n     derive::derive_key_value_pair(input)\n }\n \n+/// <!--\n+/// Documentation for this macro is available on the re-export:\n+/// <https://turbopack-rust-docs.vercel.sh/rustdoc/turbo_tasks/attr.value.html>\n+/// -->\n #[allow_internal_unstable(min_specialization, into_future, trivial_bounds)]\n #[proc_macro_error]\n #[proc_macro_attribute]\n pub fn value(args: TokenStream, input: TokenStream) -> TokenStream {\n     value_macro::value(args, input)\n }\n \n-/// Allows this trait to be used as part of a trait object inside of a value\n-/// cell, in the form of `Vc<dyn MyTrait>`.\n-///\n-/// ## Arguments\n-///\n-/// Example: `#[turbo_tasks::value_trait(no_debug, resolved)]`\n-///\n-/// ### 'no_debug`\n-///\n-/// Disables the automatic implementation of [`turbo_tasks::debug::ValueDebug`].\n-///\n-/// Example: `#[turbo_tasks::value_trait(no_debug)]`\n-///\n-/// ### 'resolved`\n-///\n-/// Adds [`turbo_tasks::NonLocalValue`] as a supertrait of this trait.\n-///\n-/// Example: `#[turbo_tasks::value_trait(resolved)]`\n+/// <!--\n+/// Documentation for this macro is available on the re-export:\n+/// <https://turbopack-rust-docs.vercel.sh/rustdoc/turbo_tasks/attr.value_trait.html>\n+/// -->\n #[allow_internal_unstable(min_specialization, into_future, trivial_bounds)]\n #[proc_macro_error]\n #[proc_macro_attribute]"
        },
        {
            "sha": "7cd49a9e5d51935430803cf7cdb352cadf3271fd",
            "filename": "turbopack/crates/turbo-tasks/src/backend.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/61c7b7b7850ffdbdaac76df4d19e418a0a4b399e/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fbackend.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/61c7b7b7850ffdbdaac76df4d19e418a0a4b399e/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fbackend.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fbackend.rs?ref=61c7b7b7850ffdbdaac76df4d19e418a0a4b399e",
            "patch": "@@ -69,7 +69,7 @@ pub struct CachedTaskType {\n \n impl CachedTaskType {\n     /// Get the name of the function from the registry. Equivalent to the\n-    /// [`fmt::Display::to_string`] implementation, but does not allocate a `String`.\n+    /// [`Display`]/[`ToString::to_string`] implementation, but does not allocate a [`String`].\n     pub fn get_name(&self) -> &'static str {\n         &registry::get_function(self.fn_type).name\n     }\n@@ -94,7 +94,7 @@ impl Hash for CachedTaskType {\n     }\n }\n \n-impl fmt::Display for CachedTaskType {\n+impl Display for CachedTaskType {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.write_str(self.get_name())\n     }\n@@ -578,8 +578,8 @@ pub trait Backend: Sync + Send {\n         turbo_tasks: &dyn TurboTasksBackendApi<Self>,\n     ) -> TaskId;\n \n-    /// For persistent tasks with associated [`NativeFunction`][turbo_tasks::NativeFunction]s,\n-    /// return the [`FunctionId`].\n+    /// For persistent tasks with associated\n+    /// [`NativeFunction`][crate::native_function::NativeFunction]s, return the [`FunctionId`].\n     fn try_get_function_id(&self, task_id: TaskId) -> Option<FunctionId>;\n \n     fn connect_task("
        },
        {
            "sha": "c11fe971163a34cd0152ba4a741a8163b567699a",
            "filename": "turbopack/crates/turbo-tasks/src/completion.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 7,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/61c7b7b7850ffdbdaac76df4d19e418a0a4b399e/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fcompletion.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/61c7b7b7850ffdbdaac76df4d19e418a0a4b399e/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fcompletion.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fcompletion.rs?ref=61c7b7b7850ffdbdaac76df4d19e418a0a4b399e",
            "patch": "@@ -1,16 +1,15 @@\n use anyhow::Result;\n \n use crate::{self as turbo_tasks, RawVc, ResolvedVc, TryJoinIterExt, Vc};\n+\n /// Just an empty type, but it's never equal to itself.\n ///\n-/// [`Vc<Completion>`] can be used as return value instead of `()`\n-/// to have a concrete reference that can be awaited.\n-/// It will invalidate the awaiting task everytime the referenced\n-/// task has been executed.\n+/// [`Vc<Completion>`] can be used as return value instead of `()` to have a concrete reference that\n+/// can be awaited. It will invalidate the awaiting task everytime the referenced task has been\n+/// executed.\n ///\n-/// Note: [`PartialEq`] is not implemented since it doesn't make sense to\n-/// compare `Completion` this way. You probably want to use [`ReadRef::ptr_eq`]\n-/// instead.\n+/// Note: [`PartialEq`] is not implemented since it doesn't make sense to compare `Completion` this\n+/// way. You probably want to use [`ReadRef::ptr_eq`][crate::ReadRef::ptr_eq] instead.\n #[turbo_tasks::value(cell = \"new\", eq = \"manual\")]\n #[derive(Debug)]\n pub struct Completion;"
        },
        {
            "sha": "61750c2c64508fdeb8c99dfd6ecd201f34d355aa",
            "filename": "turbopack/crates/turbo-tasks/src/key_value_pair.rs",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/61c7b7b7850ffdbdaac76df4d19e418a0a4b399e/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fkey_value_pair.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/61c7b7b7850ffdbdaac76df4d19e418a0a4b399e/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fkey_value_pair.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fkey_value_pair.rs?ref=61c7b7b7850ffdbdaac76df4d19e418a0a4b399e",
            "patch": "@@ -19,3 +19,13 @@ pub trait KeyValuePair {\n     fn from_key_and_value_ref(key: Self::Key, value_ref: Self::ValueRef<'_>) -> Self;\n     fn into_key_and_value(self) -> (Self::Key, Self::Value);\n }\n+\n+/// Derives the [`KeyValuePair`][trait@KeyValuePair] trait for a enum. Each variant need to\n+/// have a `value` field which becomes part of the value enum and all remaining fields become\n+/// part of the key.\n+///\n+/// Assuming the enum is called `Abc` it exposes `AbcKey` and `AbcValue` types for it too. The\n+/// key enum will have [`Debug`], [`Clone`], [`PartialEq`], [`Eq`], and [`Hash`] derived. The\n+/// value enum will have [`Debug`] and [`Clone`] derived. It's expected that all fields\n+/// implement these traits.\n+pub use turbo_tasks_macros::KeyValuePair;"
        },
        {
            "sha": "637f82fa7280078cd1d380fe42af309c43646d18",
            "filename": "turbopack/crates/turbo-tasks/src/lib.rs",
            "status": "modified",
            "additions": 22,
            "deletions": 1,
            "changes": 23,
            "blob_url": "https://github.com/vercel/next.js/blob/61c7b7b7850ffdbdaac76df4d19e418a0a4b399e/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/61c7b7b7850ffdbdaac76df4d19e418a0a4b399e/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs?ref=61c7b7b7850ffdbdaac76df4d19e418a0a4b399e",
            "patch": "@@ -118,7 +118,7 @@ pub use shrink_to_fit::ShrinkToFit;\n pub use state::{State, TransientState};\n pub use task::{task_input::TaskInput, SharedReference, TypedSharedReference};\n pub use trait_ref::{IntoTraitRef, TraitRef};\n-pub use turbo_tasks_macros::{function, value_impl, value_trait, KeyValuePair, TaskInput};\n+pub use turbo_tasks_macros::{function, value_impl, TaskInput};\n pub use value::{TransientInstance, TransientValue, Value};\n pub use value_type::{TraitMethod, TraitType, ValueType};\n pub use vc::{\n@@ -275,6 +275,27 @@ macro_rules! fxindexset {\n #[rustfmt::skip]\n pub use turbo_tasks_macros::value;\n \n+/// Allows this trait to be used as part of a trait object inside of a value\n+/// cell, in the form of `Vc<dyn MyTrait>`.\n+///\n+/// ## Arguments\n+///\n+/// Example: `#[turbo_tasks::value_trait(no_debug, resolved)]`\n+///\n+/// ### 'no_debug`\n+///\n+/// Disables the automatic implementation of [`ValueDebug`][crate::debug::ValueDebug].\n+///\n+/// Example: `#[turbo_tasks::value_trait(no_debug)]`\n+///\n+/// ### 'resolved`\n+///\n+/// Adds [`NonLocalValue`] as a supertrait of this trait.\n+///\n+/// Example: `#[turbo_tasks::value_trait(resolved)]`\n+#[rustfmt::skip]\n+pub use turbo_tasks_macros::value_trait;\n+\n pub type TaskIdSet = AutoSet<TaskId, BuildHasherDefault<FxHasher>, 2>;\n \n pub mod test_helpers {"
        },
        {
            "sha": "79f1481e05dd01c7861ff16be451c349600c5f6a",
            "filename": "turbopack/crates/turbo-tasks/src/manager.rs",
            "status": "modified",
            "additions": 12,
            "deletions": 16,
            "changes": 28,
            "blob_url": "https://github.com/vercel/next.js/blob/61c7b7b7850ffdbdaac76df4d19e418a0a4b399e/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/61c7b7b7850ffdbdaac76df4d19e418a0a4b399e/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs?ref=61c7b7b7850ffdbdaac76df4d19e418a0a4b399e",
            "patch": "@@ -880,8 +880,8 @@ impl<B: Backend + 'static> TurboTasks<B> {\n     /// Waits for the given task to finish executing. This works by performing an untracked read,\n     /// and discarding the value of the task output.\n     ///\n-    /// [`ReadConsistency::Weak`] means that this will return after the task executes, but before\n-    /// all dependencies have completely settled.\n+    /// [`ReadConsistency::Eventual`] means that this will return after the task executes, but\n+    /// before all dependencies have completely settled.\n     ///\n     /// [`ReadConsistency::Strong`] means that this will also wait for the task and all dependencies\n     /// to fully settle before returning.\n@@ -1826,14 +1826,12 @@ impl CurrentCellRef {\n         }\n     }\n \n-    /// Replace the current cell's content with `new_value` if the current\n-    /// content is not equal by value with the existing content.\n+    /// Replace the current cell's content with `new_value` if the current content is not equal by\n+    /// value with the existing content.\n     ///\n-    /// The comparison happens using the value itself, not the\n-    /// [`VcRead::Target`] of that value.\n+    /// The comparison happens using the value itself, not the [`VcRead::Target`] of that value.\n     ///\n-    /// Take this example of a custom equality implementation on a transparent\n-    /// wrapper type:\n+    /// Take this example of a custom equality implementation on a transparent wrapper type:\n     ///\n     /// ```\n     /// #[turbo_tasks::value(transparent, eq = \"manual\")]\n@@ -1852,17 +1850,15 @@ impl CurrentCellRef {\n     /// impl Eq for Wrapper {}\n     /// ```\n     ///\n-    /// Comparisons of `Vc<Wrapper>` used when updating the cell will use\n-    /// `Wrapper`'s custom equality implementation, rather than the one\n-    /// provided by the target (`Vec<u32>`) type.\n+    /// Comparisons of [`Vc<Wrapper>`] used when updating the cell will use `Wrapper`'s custom\n+    /// equality implementation, rather than the one provided by the target ([`Vec<u32>`]) type.\n     ///\n-    /// However, in most cases, the default derived implementation of\n-    /// `PartialEq` is used which just forwards to the inner value's\n-    /// `PartialEq`.\n+    /// However, in most cases, the default derived implementation of [`PartialEq`] is used which\n+    /// just forwards to the inner value's [`PartialEq`].\n     ///\n     /// If you already have a `SharedReference`, consider calling\n-    /// [`compare_and_update_with_shared_reference`] which can re-use the\n-    /// `SharedReference` object.\n+    /// [`Self::compare_and_update_with_shared_reference`] which can re-use the [`SharedReference`]\n+    /// object.\n     pub fn compare_and_update<T>(&self, new_value: T)\n     where\n         T: PartialEq + VcValueType,"
        },
        {
            "sha": "3a2ed8114db556df6e441cb9416c454badb2f65a",
            "filename": "turbopack/crates/turbo-tasks/src/raw_vc.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/61c7b7b7850ffdbdaac76df4d19e418a0a4b399e/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fraw_vc.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/61c7b7b7850ffdbdaac76df4d19e418a0a4b399e/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fraw_vc.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fraw_vc.rs?ref=61c7b7b7850ffdbdaac76df4d19e418a0a4b399e",
            "patch": "@@ -61,15 +61,15 @@ pub enum RawVc {\n }\n \n impl RawVc {\n-    pub(crate) fn is_resolved(&self) -> bool {\n+    pub fn is_resolved(&self) -> bool {\n         match self {\n             RawVc::TaskOutput(_) => false,\n             RawVc::TaskCell(_, _) => true,\n             RawVc::LocalOutput(_, _) => false,\n         }\n     }\n \n-    pub(crate) fn is_local(&self) -> bool {\n+    pub fn is_local(&self) -> bool {\n         match self {\n             RawVc::TaskOutput(_) => false,\n             RawVc::TaskCell(_, _) => false,"
        },
        {
            "sha": "45bc846a942e4c0ffdb917928864276d6240efad",
            "filename": "turbopack/crates/turbo-tasks/src/state.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/61c7b7b7850ffdbdaac76df4d19e418a0a4b399e/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fstate.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/61c7b7b7850ffdbdaac76df4d19e418a0a4b399e/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fstate.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fstate.rs?ref=61c7b7b7850ffdbdaac76df4d19e418a0a4b399e",
            "patch": "@@ -96,6 +96,10 @@ impl<T> Drop for StateRef<'_, T> {\n     }\n }\n \n+/// **This API violates core assumption of turbo-tasks, is believed to be unsound, and there's no\n+/// plan fix it.** You should prefer to use [collectibles][crate::CollectiblesSource] instead of\n+/// state where at all possible. This API may be removed in the future.\n+///\n /// An [internally-mutable] type, similar to [`RefCell`][std::cell::RefCell] or [`Mutex`] that can\n /// be stored inside a [`VcValueType`].\n ///\n@@ -112,7 +116,7 @@ impl<T> Drop for StateRef<'_, T> {\n ///\n /// [internally-mutable]: https://doc.rust-lang.org/book/ch15-05-interior-mutability.html\n /// [`VcValueType`]: crate::VcValueType\n-/// [strong consistency]: crate::Vc::strongly_consistent\n+/// [strong consistency]: crate::OperationVc::read_strongly_consistent\n /// [`OperationVc`]: crate::OperationVc\n /// [`OperationValue`]: crate::OperationValue\n #[derive(Serialize, Deserialize)]"
        },
        {
            "sha": "87bb526fd7e5fdf5c5f7c8f32fc11e6f4f1d0227",
            "filename": "turbopack/crates/turbo-tasks/src/task/task_input.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/61c7b7b7850ffdbdaac76df4d19e418a0a4b399e/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask%2Ftask_input.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/61c7b7b7850ffdbdaac76df4d19e418a0a4b399e/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask%2Ftask_input.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask%2Ftask_input.rs?ref=61c7b7b7850ffdbdaac76df4d19e418a0a4b399e",
            "patch": "@@ -12,8 +12,6 @@ use crate::{\n \n /// Trait to implement in order for a type to be accepted as a\n /// [`#[turbo_tasks::function]`][crate::function] argument.\n-///\n-/// See also [`ConcreteTaskInput`].\n pub trait TaskInput: Send + Sync + Clone + Debug + PartialEq + Eq + Hash + TraceRawVcs {\n     fn resolve_input(&self) -> impl Future<Output = Result<Self>> + Send + '_ {\n         async { Ok(self.clone()) }"
        },
        {
            "sha": "4acf18b73ccb70ff51606ac9d93ee42fa212e82a",
            "filename": "turbopack/crates/turbo-tasks/src/vc/mod.rs",
            "status": "modified",
            "additions": 52,
            "deletions": 55,
            "changes": 107,
            "blob_url": "https://github.com/vercel/next.js/blob/61c7b7b7850ffdbdaac76df4d19e418a0a4b399e/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fvc%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/61c7b7b7850ffdbdaac76df4d19e418a0a4b399e/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fvc%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fvc%2Fmod.rs?ref=61c7b7b7850ffdbdaac76df4d19e418a0a4b399e",
            "patch": "@@ -75,61 +75,46 @@ type VcReadTarget<T> = <<T as VcValueType>::Read as VcRead<T>>::Target;\n ///\n /// ## Subtypes\n ///\n-/// There are a couple of \"subtypes\" of `Vc`. These can both be cheaply converted back into a `Vc`.\n+/// There are a couple of explicit \"subtypes\" of `Vc`. These can both be cheaply converted back into\n+/// a `Vc`.\n ///\n-/// - **[`ResolvedVc`]:** A reference to a cell constructed within a task, as part of a [`Vc::cell`]\n-///   or `value_type.cell()` constructor. As the cell has been constructed at least once, the\n-///   concrete type of the cell is known (allowing [downcasting][ResolvedVc::try_downcast]). This is\n-///   stored as a combination of a task id, a type id, and a cell id.\n+/// - **[`ResolvedVc`]:** *(aka [`RawVc::TaskCell`])* A reference to a cell constructed within a\n+///   task, as part of a [`Vc::cell`] or `value_type.cell()` constructor. As the cell has been\n+///   constructed at least once, the concrete type of the cell is known (allowing\n+///   [downcasting][ResolvedVc::try_downcast]). This is stored as a combination of a task id, a type\n+///   id, and a cell id.\n ///\n-/// - **[`OperationVc`]:** The synchronous return value of a [`turbo_tasks::function`]. Internally,\n-///   this is stored using a task id. Exact type information of trait types (i.e. `Vc<Box<dyn\n-///   Trait>>`) is not known because the function may not have finished execution yet. Operations\n-///   must first be [`connected`][OperationVc::connect]ed before being read.\n+/// - **[`OperationVc`]:** *(aka [`RawVc::TaskOutput`])* The synchronous return value of a\n+///   [`turbo_tasks::function`]. Internally, this is stored using a task id. Exact type information\n+///   of trait types (i.e. `Vc<Box<dyn Trait>>`) is not known because the function may not have\n+///   finished execution yet. [`OperationVc`]s must first be [`connect`][OperationVc::connect]ed\n+///   before being read.\n ///\n /// [`ResolvedVc`] is almost always preferred over the more awkward [`OperationVc`] API, but\n-/// [`OperationVc`] can be useful inside of [`State`] or when dealing with [collectibles].\n-///\n-/// In addition to these potentially-explicit representations of a `Vc`, there's another internal\n-/// representation of a `Vc`, known as a \"Local `Vc`\".\n-///\n-/// - **Local Operation or Cell:** Same as [`ResolvedVc`] or [`OperationVc`], but these values are\n-///   stored in task-local state that is freed after their parent non-local task exits. These values\n-///   are sometimes created when calling a [`turbo_tasks::function`] as an optimization. [Converting\n-///   a local `Vc` to a `ResolvedVc`][Vc::to_resolved] will construct a new\n-///   [non-local][NonLocalValue] cell.\n+/// [`OperationVc`] can be useful when dealing with [collectibles], when you need to [read the\n+/// result of a function with strong consistency][OperationVc::read_strongly_consistent], or with\n+/// [`State`].\n ///\n /// These many representations are stored internally using a type-erased [`RawVc`]. Type erasure\n /// reduces the [monomorphization] (and therefore binary size and compilation time) required to\n /// support `Vc` and its subtypes.\n ///\n-/// <div class=\"warning\">\n-/// <p>\n-/// Local <code>Vc</code>s are not valid outside of their parent task, so they must be implicitly\n-/// (e.g. as an argument or return type) or explicitly (e.g. via <a\n-/// href=\"#method.to_resolved\"><code>Vc::to_resolved</code></a>) be converted to a non-local <a\n-/// href=\"struct.ResolvedVc.html\"><code>ResolvedVc</code></a> or <a\n-/// href=\"struct.VcOperation.html\"><code>VcOperation</code></a> before crossing task boundaries.\n-/// </p>\n-/// <p>\n-/// For this reason, <code>Vc</code> types (which are potentially local) will be disallowed as\n-/// fields in <a href=\"attr.value.html\"><code>turbo_tasks::value</code></a>s in the future.\n-/// </p>\n-/// </div>\n-///\n-/// |                 | Representation?             | [Non-Local?] | Equality?               | Can be Downcast?           |\n-/// |-----------------|-----------------------------|--------------|-------------------------|----------------------------|\n-/// | [`Vc`]          | One of many                 | ⚠️  Maybe     | ❌ Not recommended      | ⚠️  After resolution        |\n-/// | [`ResolvedVc`]  | Task Id + Type Id + Cell Id | ✅ Yes       | ✅ Yes, [see docs][rvc] | ✅ [Yes, cheaply][resolve] |\n-/// | [`OperationVc`] | Task Id                     | ✅ Yes       | ✅ Yes, [see docs][ovc] | ⚠️  After resolution        |\n+/// |                 | Representation                     | Equality        | Downcasting                | Strong Consistency     | Collectibles      | [Non-Local]  |\n+/// |-----------------|------------------------------------|-----------------|----------------------------|------------------------|-------------------|--------------|\n+/// | [`Vc`]          | [One of many][RawVc]               | ❌ [Broken][eq] | ⚠️  After resolution        | ❌ Eventual            | ❌ No             | ❌ [No][loc] |\n+/// | [`ResolvedVc`]  | [Task Id + Type Id + Cell Id][rtc] | ✅ Yes\\*        | ✅ [Yes, cheaply][resolve] | ❌ Eventual            | ❌ No             | ✅ Yes       |\n+/// | [`OperationVc`] | [Task Id][rto]                     | ✅ Yes\\*        | ⚠️  After resolution        | ✅ [Supported][strong] | ✅ [Yes][collect] | ✅ Yes       |\n+///\n+/// *\\* see the type's documentation for details*\n ///\n /// [Non-Local]: NonLocalValue\n-/// [rvc]: ResolvedVc\n-/// [ovc]: ResolvedVc\n+/// [rtc]: RawVc::TaskCell\n+/// [rto]: RawVc::TaskOutput\n+/// [loc]: #optimization-local-outputs\n+/// [eq]: #equality--hashing\n /// [resolve]: ResolvedVc::try_downcast\n-///\n-/// See the documentation for [`ResolvedVc`] and [`OperationVc`] for more details about these\n-/// subtypes.\n+/// [strong]: OperationVc::read_strongly_consistent\n+/// [collect]: crate::CollectiblesSource\n ///\n ///\n /// ## Execution Model\n@@ -153,13 +138,28 @@ type VcReadTarget<T> = <<T as VcValueType>::Read as VcRead<T>>::Target;\n /// [`Hash`].\n ///\n ///\n+/// ## Optimization: Local Outputs\n+///\n+/// In addition to the potentially-explicit \"resolved\" and \"operation\" representations of a `Vc`,\n+/// there's another internal representation of a `Vc`, known as a \"Local `Vc`\", or\n+/// [`RawVc::LocalOutput`].\n+///\n+/// This is a special case of the synchronous return value of a [`turbo_tasks::function`] when some\n+/// of its arguments have not yet been resolved. These are stored in task-local state that is freed\n+/// after their parent non-local task exits.\n+///\n+/// We prevent potentially-local `Vc`s from escaping the lifetime of a function using the\n+/// [`NonLocalValue`] marker trait alongside some fallback runtime checks. We do this to avoid some\n+/// ergonomic challenges that would come from using lifetime annotations with `Vc`.\n+///\n+///\n /// [tracing]: crate::trace::TraceRawVcs\n /// [`ReadRef`]: crate::ReadRef\n /// [`turbo_tasks::function`]: crate::function\n /// [monomorphization]: https://doc.rust-lang.org/book/ch10-01-syntax.html#performance-of-code-using-generics\n /// [`State`]: crate::State\n /// [book-cells]: https://turbopack-rust-docs.vercel.sh/turbo-engine/cells.html\n-/// [collectibles]: CollectiblesSource\n+/// [collectibles]: crate::CollectiblesSource\n #[must_use]\n #[derive(Serialize, Deserialize)]\n #[serde(transparent, bound = \"\")]\n@@ -421,15 +421,8 @@ where\n         }\n     }\n \n-    /// Resolve the reference until it points to a cell directly.\n-    ///\n-    /// Resolving will wait for task execution to be finished, so that the\n-    /// returned `Vc` points to a cell that stores a value.\n-    ///\n-    /// Resolving is necessary to compare identities of `Vc`s.\n-    ///\n-    /// This is async and will rethrow any fatal error that happened during task\n-    /// execution.\n+    /// Do not use this: Use [`Vc::to_resolved`] instead. If you must have a resolved [`Vc`] type\n+    /// and not a [`ResolvedVc`] type, simply deref the result of [`Vc::to_resolved`].\n     pub async fn resolve(self) -> Result<Vc<T>> {\n         Ok(Self {\n             node: self.node.resolve().await?,\n@@ -446,9 +439,13 @@ where\n         })\n     }\n \n-    /// Returns `true` if the reference is resolved.\n+    /// Returns `true` if the reference is resolved, meaning the underlying [`RawVc`] uses the\n+    /// [`RawVc::TaskCell`] representation.\n+    ///\n+    /// If you need resolved [`Vc`] value, it's typically better to use the [`ResolvedVc`] type to\n+    /// enforce your requirements statically instead of dynamically at runtime.\n     ///\n-    /// See also [`Vc::resolve`].\n+    /// See also [`ResolvedVc::to_resolved`] and [`RawVc::is_resolved`].\n     pub fn is_resolved(self) -> bool {\n         self.node.is_resolved()\n     }"
        }
    ],
    "stats": {
        "total": 272,
        "additions": 144,
        "deletions": 128
    }
}