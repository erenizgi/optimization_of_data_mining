{
    "author": "delbaoliveira",
    "message": "Docs IA 2.0: Create Forms guide (#79288)\n\nCloses: https://linear.app/vercel/issue/DOC-4671/forms\nNo redirects needed yet as no pages were deleted.",
    "sha": "b89caa422a16223795d294f035c87007013333b6",
    "files": [
        {
            "sha": "7f3350787dedef7d90a774e30a2dc8f3536c115d",
            "filename": "docs/01-app/01-getting-started/10-error-handling.mdx",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/b89caa422a16223795d294f035c87007013333b6/docs%2F01-app%2F01-getting-started%2F10-error-handling.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/b89caa422a16223795d294f035c87007013333b6/docs%2F01-app%2F01-getting-started%2F10-error-handling.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F01-getting-started%2F10-error-handling.mdx?ref=b89caa422a16223795d294f035c87007013333b6",
            "patch": "@@ -16,7 +16,7 @@ Errors can be divided into two categories: [expected errors](#handling-expected-\n \n ## Handling expected errors\n \n-Expected errors are those that can occur during the normal operation of the application, such as those from [server-side form validation](/docs/app/building-your-application/data-fetching/server-actions-and-mutations#server-side-form-validation) or failed requests. These errors should be handled explicitly and returned to the client.\n+Expected errors are those that can occur during the normal operation of the application, such as those from [server-side form validation](/docs/app/guides/forms) or failed requests. These errors should be handled explicitly and returned to the client.\n \n ### Server Functions\n "
        },
        {
            "sha": "82209a285cafbf6feda4077ec4afc0ca8fd31253",
            "filename": "docs/01-app/02-guides/forms.mdx",
            "status": "added",
            "additions": 491,
            "deletions": 0,
            "changes": 491,
            "blob_url": "https://github.com/vercel/next.js/blob/b89caa422a16223795d294f035c87007013333b6/docs%2F01-app%2F02-guides%2Fforms.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/b89caa422a16223795d294f035c87007013333b6/docs%2F01-app%2F02-guides%2Fforms.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F02-guides%2Fforms.mdx?ref=b89caa422a16223795d294f035c87007013333b6",
            "patch": "@@ -0,0 +1,491 @@\n+---\n+title: How to create forms with Server Actions\n+nav_title: Forms\n+description: Learn how to create forms in Next.js with React Server Actions.\n+---\n+\n+React Server Actions are [Server Functions](https://react.dev/reference/rsc/server-functions) that execute on the server. They can be called in Server and Client Components to handle form submissions. This guide will walk you through how to create forms in Next.js with Server Actions.\n+\n+## How it works\n+\n+React extends the HTML [`<form>`](https://developer.mozilla.org/docs/Web/HTML/Element/form) element to allow Server Actions to be invoked with the [`action`](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/form#action) attribute.\n+\n+When used in a form, the function automatically receives the [`FormData`](https://developer.mozilla.org/docs/Web/API/FormData/FormData) object. You can then extract the data using the native [`FormData` methods](https://developer.mozilla.org/en-US/docs/Web/API/FormData#instance_methods):\n+\n+```tsx filename=\"app/invoices/page.tsx\" switcher\n+export default function Page() {\n+  async function createInvoice(formData: FormData) {\n+    'use server'\n+\n+    const rawFormData = {\n+      customerId: formData.get('customerId'),\n+      amount: formData.get('amount'),\n+      status: formData.get('status'),\n+    }\n+\n+    // mutate data\n+    // revalidate the cache\n+  }\n+\n+  return <form action={createInvoice}>...</form>\n+}\n+```\n+\n+```jsx filename=\"app/invoices/page.js\" switcher\n+export default function Page() {\n+  async function createInvoice(formData) {\n+    'use server'\n+\n+    const rawFormData = {\n+      customerId: formData.get('customerId'),\n+      amount: formData.get('amount'),\n+      status: formData.get('status'),\n+    }\n+\n+    // mutate data\n+    // revalidate the cache\n+  }\n+\n+  return <form action={createInvoice}>...</form>\n+}\n+```\n+\n+> **Good to know:** When working with forms that have multiple fields, you can use the [`entries()`](https://developer.mozilla.org/en-US/docs/Web/API/FormData/entries) method with JavaScript's [`Object.fromEntries()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries). For example: `const rawFormData = Object.fromEntries(formData)`.\n+\n+## Passing additional arguments\n+\n+Outside of form fields, you can pass additional arguments to a Server Function using the JavaScript [`bind`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind) method. For example, to pass the `userId` argument to the `updateUser` Server Function:\n+\n+```tsx filename=\"app/client-component.tsx\" highlight={6} switcher\n+'use client'\n+\n+import { updateUser } from './actions'\n+\n+export function UserProfile({ userId }: { userId: string }) {\n+  const updateUserWithId = updateUser.bind(null, userId)\n+\n+  return (\n+    <form action={updateUserWithId}>\n+      <input type=\"text\" name=\"name\" />\n+      <button type=\"submit\">Update User Name</button>\n+    </form>\n+  )\n+}\n+```\n+\n+```jsx filename=\"app/client-component.js\" highlight={6} switcher\n+'use client'\n+\n+import { updateUser } from './actions'\n+\n+export function UserProfile({ userId }) {\n+  const updateUserWithId = updateUser.bind(null, userId)\n+\n+  return (\n+    <form action={updateUserWithId}>\n+      <input type=\"text\" name=\"name\" />\n+      <button type=\"submit\">Update User Name</button>\n+    </form>\n+  )\n+}\n+```\n+\n+The Server Function will receive the `userId` as an additional argument:\n+\n+```ts filename=\"app/actions.ts\" switcher\n+'use server'\n+\n+export async function updateUser(userId: string, formData: FormData) {}\n+```\n+\n+```js filename=\"app/actions.js\" switcher\n+'use server'\n+\n+export async function updateUser(userId, formData) {}\n+```\n+\n+> **Good to know**:\n+>\n+> - An alternative is to pass arguments as hidden input fields in the form (e.g. `<input type=\"hidden\" name=\"userId\" value={userId} />`). However, the value will be part of the rendered HTML and will not be encoded.\n+> - `bind` works in both Server and Client Components and supports progressive enhancement.\n+\n+## Form validation\n+\n+Forms can be validate on the client or server.\n+\n+- For **client-side validation**, you can use the HTML attributes like `required` and `type=\"email\"` for basic validation.\n+- For **server-side validation**, you can use a library like [zod](https://zod.dev/) to validate the form fields. For example:\n+\n+```tsx filename=\"app/actions.ts\" switcher\n+'use server'\n+\n+import { z } from 'zod'\n+\n+const schema = z.object({\n+  email: z.string({\n+    invalid_type_error: 'Invalid Email',\n+  }),\n+})\n+\n+export default async function createUser(formData: FormData) {\n+  const validatedFields = schema.safeParse({\n+    email: formData.get('email'),\n+  })\n+\n+  // Return early if the form data is invalid\n+  if (!validatedFields.success) {\n+    return {\n+      errors: validatedFields.error.flatten().fieldErrors,\n+    }\n+  }\n+\n+  // Mutate data\n+}\n+```\n+\n+```jsx filename=\"app/actions.js\" switcher\n+'use server'\n+\n+import { z } from 'zod'\n+\n+const schema = z.object({\n+  email: z.string({\n+    invalid_type_error: 'Invalid Email',\n+  }),\n+})\n+\n+export default async function createsUser(formData) {\n+  const validatedFields = schema.safeParse({\n+    email: formData.get('email'),\n+  })\n+\n+  // Return early if the form data is invalid\n+  if (!validatedFields.success) {\n+    return {\n+      errors: validatedFields.error.flatten().fieldErrors,\n+    }\n+  }\n+\n+  // Mutate data\n+}\n+```\n+\n+## Validation errors\n+\n+To display validation errors or messages, turn the component that defines the `<form>` into a Client Component and use React [`useActionState`](https://react.dev/reference/react/useActionState).\n+\n+When using `useActionState`, the Server function signature will change to receive a new `prevState` or `initialState` parameter as its first argument.\n+\n+```tsx filename=\"app/actions.ts\" highlight={4} switcher\n+'use server'\n+\n+import { z } from 'zod'\n+\n+export async function createUser(initialState: any, formData: FormData) {\n+  const validatedFields = schema.safeParse({\n+    email: formData.get('email'),\n+  })\n+  // ...\n+}\n+```\n+\n+```jsx filename=\"app/actions.ts\" highlight={4} switcher\n+'use server'\n+\n+import { z } from 'zod'\n+\n+// ...\n+\n+export async function createUser(initialState, formData) {\n+  const validatedFields = schema.safeParse({\n+    email: formData.get('email'),\n+  })\n+  // ...\n+}\n+```\n+\n+You can then conditionally render the error message based on the `state` object.\n+\n+```tsx filename=\"app/ui/signup.tsx\" highlight={11,18-20} switcher\n+'use client'\n+\n+import { useActionState } from 'react'\n+import { createUser } from '@/app/actions'\n+\n+const initialState = {\n+  message: '',\n+}\n+\n+export function Signup() {\n+  const [state, formAction, pending] = useActionState(createUser, initialState)\n+\n+  return (\n+    <form action={formAction}>\n+      <label htmlFor=\"email\">Email</label>\n+      <input type=\"text\" id=\"email\" name=\"email\" required />\n+      {/* ... */}\n+      <p aria-live=\"polite\">{state?.message}</p>\n+      <button disabled={pending}>Sign up</button>\n+    </form>\n+  )\n+}\n+```\n+\n+```jsx filename=\"app/ui/signup.js\" highlight={11,18-20} switcher\n+'use client'\n+\n+import { useActionState } from 'react'\n+import { createUser } from '@/app/actions'\n+\n+const initialState = {\n+  message: '',\n+}\n+\n+export function Signup() {\n+  const [state, formAction, pending] = useActionState(createUser, initialState)\n+\n+  return (\n+    <form action={formAction}>\n+      <label htmlFor=\"email\">Email</label>\n+      <input type=\"text\" id=\"email\" name=\"email\" required />\n+      {/* ... */}\n+      <p aria-live=\"polite\">{state?.message}</p>\n+      <button disabled={pending}>Sign up</button>\n+    </form>\n+  )\n+}\n+```\n+\n+## Pending states\n+\n+The [`useActionState`](https://react.dev/reference/react/useActionState) hook exposes a `pending` boolean that can be used to show a loading indicator or disable the submit button while the action is being executed.\n+\n+```tsx filename=\"app/ui/signup.tsx\" highlight={7,12} switcher\n+'use client'\n+\n+import { useActionState } from 'react'\n+import { createUser } from '@/app/actions'\n+\n+export function Signup() {\n+  const [state, formAction, pending] = useActionState(createUser, initialState)\n+\n+  return (\n+    <form action={formAction}>\n+      {/* Other form elements */}\n+      <button disabled={pending}>Sign up</button>\n+    </form>\n+  )\n+}\n+```\n+\n+```jsx filename=\"app/ui/signup.js\" highlight={7,12} switcher\n+'use client'\n+\n+import { useActionState } from 'react'\n+import { createUser } from '@/app/actions'\n+\n+export function Signup() {\n+  const [state, formAction, pending] = useActionState(createUser, initialState)\n+\n+  return (\n+    <form action={formAction}>\n+      {/* Other form elements */}\n+      <button disabled={pending}>Sign up</button>\n+    </form>\n+  )\n+}\n+```\n+\n+Alternatively, you can use the [`useFormStatus`](https://react.dev/reference/react-dom/hooks/useFormStatus) hook to show a loading indicator while the action is being executed. When using this hook, you'll need to create a separate component to render the loading indicator. For example, to disable the button when the action is pending:\n+\n+```tsx filename=\"app/ui/button.tsx\" highlight={6} switcher\n+'use client'\n+\n+import { useFormStatus } from 'react-dom'\n+\n+export function SubmitButton() {\n+  const { pending } = useFormStatus()\n+\n+  return (\n+    <button disabled={pending} type=\"submit\">\n+      Sign Up\n+    </button>\n+  )\n+}\n+```\n+\n+```jsx filename=\"app/ui/button.js\" highlight={6} switcher\n+'use client'\n+\n+import { useFormStatus } from 'react-dom'\n+\n+export function SubmitButton() {\n+  const { pending } = useFormStatus()\n+\n+  return (\n+    <button disabled={pending} type=\"submit\">\n+      Sign Up\n+    </button>\n+  )\n+}\n+```\n+\n+You can then nest the `SubmitButton` component inside the form:\n+\n+```tsx filename=\"app/ui/signup.tsx\" switcher\n+import { SubmitButton } from './button'\n+import { createUser } from '@/app/actions'\n+\n+export function Signup() {\n+  return (\n+    <form action={createUser}>\n+      {/* Other form elements */}\n+      <SubmitButton />\n+    </form>\n+  )\n+}\n+```\n+\n+```jsx filename=\"app/ui/signup.js\" switcher\n+import { SubmitButton } from './button'\n+import { createUser } from '@/app/actions'\n+\n+export function Signup() {\n+  return (\n+    <form action={createUser}>\n+      {/* Other form elements */}\n+      <SubmitButton />\n+    </form>\n+  )\n+}\n+```\n+\n+> **Good to know:** In React 19, `useFormStatus` includes additional keys on the returned object, like data, method, and action. If you are not using React 19, only the `pending` key is available.\n+\n+## Optimistic updates\n+\n+You can use the React [`useOptimistic`](https://react.dev/reference/react/useOptimistic) hook to optimistically update the UI before the Server Function finishes executing, rather than waiting for the response:\n+\n+```tsx filename=\"app/page.tsx\" switcher\n+'use client'\n+\n+import { useOptimistic } from 'react'\n+import { send } from './actions'\n+\n+type Message = {\n+  message: string\n+}\n+\n+export function Thread({ messages }: { messages: Message[] }) {\n+  const [optimisticMessages, addOptimisticMessage] = useOptimistic<\n+    Message[],\n+    string\n+  >(messages, (state, newMessage) => [...state, { message: newMessage }])\n+\n+  const formAction = async (formData: FormData) => {\n+    const message = formData.get('message') as string\n+    addOptimisticMessage(message)\n+    await send(message)\n+  }\n+\n+  return (\n+    <div>\n+      {optimisticMessages.map((m, i) => (\n+        <div key={i}>{m.message}</div>\n+      ))}\n+      <form action={formAction}>\n+        <input type=\"text\" name=\"message\" />\n+        <button type=\"submit\">Send</button>\n+      </form>\n+    </div>\n+  )\n+}\n+```\n+\n+```jsx filename=\"app/page.js\" switcher\n+'use client'\n+\n+import { useOptimistic } from 'react'\n+import { send } from './actions'\n+\n+export function Thread({ messages }) {\n+  const [optimisticMessages, addOptimisticMessage] = useOptimistic(\n+    messages,\n+    (state, newMessage) => [...state, { message: newMessage }]\n+  )\n+\n+  const formAction = async (formData) => {\n+    const message = formData.get('message')\n+    addOptimisticMessage(message)\n+    await send(message)\n+  }\n+\n+  return (\n+    <div>\n+      {optimisticMessages.map((m) => (\n+        <div>{m.message}</div>\n+      ))}\n+      <form action={formAction}>\n+        <input type=\"text\" name=\"message\" />\n+        <button type=\"submit\">Send</button>\n+      </form>\n+    </div>\n+  )\n+}\n+```\n+\n+## Nested form elements\n+\n+You can call Server Actions in elements nested inside `<form>` such as `<button>`, `<input type=\"submit\">`, and `<input type=\"image\">`. These elements accept the `formAction` prop or event handlers.\n+\n+This is useful in cases where you want to call multiple Server Actions within a form. For example, you can create a specific `<button>` element for saving a post draft in addition to publishing it. See the [React `<form>` docs](https://react.dev/reference/react-dom/components/form#handling-multiple-submission-types) for more information.\n+\n+## Programmatic form submission\n+\n+You can trigger a form submission programmatically using the [`requestSubmit()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement/requestSubmit) method. For example, when the user submits a form using the `⌘` + `Enter` keyboard shortcut, you can listen for the `onKeyDown` event:\n+\n+```tsx filename=\"app/entry.tsx\" switcher\n+'use client'\n+\n+export function Entry() {\n+  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {\n+    if (\n+      (e.ctrlKey || e.metaKey) &&\n+      (e.key === 'Enter' || e.key === 'NumpadEnter')\n+    ) {\n+      e.preventDefault()\n+      e.currentTarget.form?.requestSubmit()\n+    }\n+  }\n+\n+  return (\n+    <div>\n+      <textarea name=\"entry\" rows={20} required onKeyDown={handleKeyDown} />\n+    </div>\n+  )\n+}\n+```\n+\n+```jsx filename=\"app/entry.js\" switcher\n+'use client'\n+\n+export function Entry() {\n+  const handleKeyDown = (e) => {\n+    if (\n+      (e.ctrlKey || e.metaKey) &&\n+      (e.key === 'Enter' || e.key === 'NumpadEnter')\n+    ) {\n+      e.preventDefault()\n+      e.currentTarget.form?.requestSubmit()\n+    }\n+  }\n+\n+  return (\n+    <div>\n+      <textarea name=\"entry\" rows={20} required onKeyDown={handleKeyDown} />\n+    </div>\n+  )\n+}\n+```\n+\n+This will trigger the submission of the nearest `<form>` ancestor, which will invoke the Server Function."
        },
        {
            "sha": "b44f166fde68c13ce59b1972506ca322c83d0ad1",
            "filename": "docs/01-app/02-guides/index.mdx",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/b89caa422a16223795d294f035c87007013333b6/docs%2F01-app%2F02-guides%2Findex.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/b89caa422a16223795d294f035c87007013333b6/docs%2F01-app%2F02-guides%2Findex.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F02-guides%2Findex.mdx?ref=b89caa422a16223795d294f035c87007013333b6",
            "patch": "@@ -17,16 +17,16 @@ description: Learn how to implement common UI patterns and use cases using Next.\n \n ### Forms\n \n-- [Showing a pending state while submitting a form](/docs/app/building-your-application/data-fetching/server-actions-and-mutations#pending-states)\n-- [Server-side form validation](/docs/app/building-your-application/data-fetching/server-actions-and-mutations#server-side-form-validation)\n+- [Showing a pending state while submitting a form](/docs/app/guides/forms)\n+- [Server-side form validation](/docs/app/guides/forms)\n - [Handling expected errors](/docs/app/building-your-application/routing/error-handling#handling-expected-errors-from-server-actions)\n - [Handling unexpected exceptions](/docs/app/building-your-application/routing/error-handling#uncaught-exceptions)\n-- [Showing optimistic UI updates](/docs/app/building-your-application/data-fetching/server-actions-and-mutations#optimistic-updates)\n-- [Programmatic form submission](/docs/app/building-your-application/data-fetching/server-actions-and-mutations#programmatic-form-submission)\n+- [Showing optimistic UI updates](/docs/app/guides/forms#optimistic-updates)\n+- [Programmatic form submission](/docs/app/guides/forms#programmatic-form-submission)\n \n ### Server Actions\n \n-- [Passing additional values](/docs/app/building-your-application/data-fetching/server-actions-and-mutations#passing-additional-arguments)\n+- [Passing additional values](/docs/app/guides/forms)\n - [Revalidating data](/docs/app/building-your-application/data-fetching/server-actions-and-mutations#revalidating-data)\n - [Redirecting](/docs/app/building-your-application/data-fetching/server-actions-and-mutations#redirecting)\n - [Setting cookies](/docs/app/api-reference/functions/cookies#setting-a-cookie)"
        },
        {
            "sha": "c5c94fa501c08a74adb708f40c75e6c4838f93ad",
            "filename": "docs/01-app/02-guides/production-checklist.mdx",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/b89caa422a16223795d294f035c87007013333b6/docs%2F01-app%2F02-guides%2Fproduction-checklist.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/b89caa422a16223795d294f035c87007013333b6/docs%2F01-app%2F02-guides%2Fproduction-checklist.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F02-guides%2Fproduction-checklist.mdx?ref=b89caa422a16223795d294f035c87007013333b6",
            "patch": "@@ -83,7 +83,7 @@ While building your application, we recommend using the following features to en\n \n <AppOnly>\n \n-- **[Forms and Validation](/docs/app/building-your-application/data-fetching/server-actions-and-mutations#forms):** Use Server Actions to handle form submissions, server-side validation, and handle errors.\n+- **[Forms and Validation](/docs/app/guides/forms):** Use Server Actions to handle form submissions, server-side validation, and handle errors.\n \n </AppOnly>\n "
        },
        {
            "sha": "76d8730ae508fcf3fefe69fbbfc3875e2a9ea724",
            "filename": "docs/01-app/03-building-your-application/01-routing/05-error-handling.mdx",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/b89caa422a16223795d294f035c87007013333b6/docs%2F01-app%2F03-building-your-application%2F01-routing%2F05-error-handling.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/b89caa422a16223795d294f035c87007013333b6/docs%2F01-app%2F03-building-your-application%2F01-routing%2F05-error-handling.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-building-your-application%2F01-routing%2F05-error-handling.mdx?ref=b89caa422a16223795d294f035c87007013333b6",
            "patch": "@@ -13,7 +13,7 @@ Errors can be divided into two categories: **expected errors** and **uncaught ex\n \n ## Handling Expected Errors\n \n-Expected errors are those that can occur during the normal operation of the application, such as those from [server-side form validation](/docs/app/building-your-application/data-fetching/server-actions-and-mutations#server-side-form-validation) or failed requests. These errors should be handled explicitly and returned to the client.\n+Expected errors are those that can occur during the normal operation of the application, such as those from [server-side form validation](/docs/app/guides/forms) or failed requests. These errors should be handled explicitly and returned to the client.\n \n ### Handling Expected Errors from Server Actions\n "
        },
        {
            "sha": "67aebcbe515f2da14e2a962d3c19ce2854e39747",
            "filename": "docs/01-app/03-building-your-application/01-routing/11-parallel-routes.mdx",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/b89caa422a16223795d294f035c87007013333b6/docs%2F01-app%2F03-building-your-application%2F01-routing%2F11-parallel-routes.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/b89caa422a16223795d294f035c87007013333b6/docs%2F01-app%2F03-building-your-application%2F01-routing%2F11-parallel-routes.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-building-your-application%2F01-routing%2F11-parallel-routes.mdx?ref=b89caa422a16223795d294f035c87007013333b6",
            "patch": "@@ -305,7 +305,7 @@ export default function Page() {\n > **Good to know:**\n >\n > - The convention used to intercept the route, e.g. `(.)`, depends on your file-system structure. See [Intercepting Routes convention](/docs/app/building-your-application/routing/intercepting-routes#convention).\n-> - By separating the `<Modal>` functionality from the modal content (`<Login>`), you can ensure any content inside the modal, e.g. [forms](/docs/app/building-your-application/data-fetching/server-actions-and-mutations#forms), are Server Components. See [Interleaving Client and Server Components](/docs/app/getting-started/server-and-client-components#examples#supported-pattern-passing-server-components-to-client-components-as-props) for more information.\n+> - By separating the `<Modal>` functionality from the modal content (`<Login>`), you can ensure any content inside the modal, e.g. [forms](/docs/app/guides/forms), are Server Components. See [Interleaving Client and Server Components](/docs/app/getting-started/server-and-client-components#examples#supported-pattern-passing-server-components-to-client-components-as-props) for more information.\n \n #### Opening the modal\n "
        },
        {
            "sha": "21d1523337bcf4419c2e0678b2dcfc1ae0740cc9",
            "filename": "docs/01-app/03-building-your-application/02-data-fetching/03-server-actions-and-mutations.mdx",
            "status": "modified",
            "additions": 2,
            "deletions": 458,
            "changes": 460,
            "blob_url": "https://github.com/vercel/next.js/blob/b89caa422a16223795d294f035c87007013333b6/docs%2F01-app%2F03-building-your-application%2F02-data-fetching%2F03-server-actions-and-mutations.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/b89caa422a16223795d294f035c87007013333b6/docs%2F01-app%2F03-building-your-application%2F02-data-fetching%2F03-server-actions-and-mutations.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-building-your-application%2F02-data-fetching%2F03-server-actions-and-mutations.mdx?ref=b89caa422a16223795d294f035c87007013333b6",
            "patch": "@@ -115,7 +115,7 @@ Runtime type-checking will still ensure you don't accidentally pass a function t\n \n ## Behavior\n \n-- Server actions can be invoked using the `action` attribute in a [`<form>` element](#forms):\n+- Server actions can be invoked using the `action` attribute in a `<form>` element.\n   - Server Components support progressive enhancement by default, meaning the form will be submitted even if JavaScript hasn't loaded yet or is disabled.\n   - In Client Components, forms invoking Server Actions will queue submissions if JavaScript isn't loaded yet, prioritizing client hydration.\n   - After hydration, the browser does not refresh on form submission.\n@@ -129,462 +129,6 @@ Runtime type-checking will still ensure you don't accidentally pass a function t\n \n ## Examples\n \n-### Forms\n-\n-React extends the HTML [`<form>`](https://developer.mozilla.org/docs/Web/HTML/Element/form) element to allow Server Actions to be invoked with the `action` prop.\n-\n-When invoked in a form, the action automatically receives the [`FormData`](https://developer.mozilla.org/docs/Web/API/FormData/FormData) object. You don't need to use React `useState` to manage fields, instead, you can extract the data using the native [`FormData` methods](https://developer.mozilla.org/en-US/docs/Web/API/FormData#instance_methods):\n-\n-```tsx filename=\"app/invoices/page.tsx\" switcher\n-export default function Page() {\n-  async function createInvoice(formData: FormData) {\n-    'use server'\n-\n-    const rawFormData = {\n-      customerId: formData.get('customerId'),\n-      amount: formData.get('amount'),\n-      status: formData.get('status'),\n-    }\n-\n-    // mutate data\n-    // revalidate cache\n-  }\n-\n-  return <form action={createInvoice}>...</form>\n-}\n-```\n-\n-```jsx filename=\"app/invoices/page.js\" switcher\n-export default function Page() {\n-  async function createInvoice(formData) {\n-    'use server'\n-\n-    const rawFormData = {\n-      customerId: formData.get('customerId'),\n-      amount: formData.get('amount'),\n-      status: formData.get('status'),\n-    }\n-\n-    // mutate data\n-    // revalidate cache\n-  }\n-\n-  return <form action={createInvoice}>...</form>\n-}\n-```\n-\n-> **Good to know:**\n->\n-> - Example: [Form with Loading & Error States](https://github.com/vercel/next.js/tree/canary/examples/next-forms)\n-> - When working with forms that have many fields, you may want to consider using the [`entries()`](https://developer.mozilla.org/en-US/docs/Web/API/FormData/entries) method with JavaScript's [`Object.fromEntries()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries). For example: `const rawFormData = Object.fromEntries(formData)`. One thing to note is that the `formData` will include additional `$ACTION_` properties.\n-> - See [React `<form>` documentation](https://react.dev/reference/react-dom/components/form#handle-form-submission-with-a-server-action) to learn more.\n-\n-### Passing additional arguments\n-\n-You can pass additional arguments to a Server Action using the JavaScript `bind` method.\n-\n-```tsx filename=\"app/client-component.tsx\" highlight={6} switcher\n-'use client'\n-\n-import { updateUser } from './actions'\n-\n-export function UserProfile({ userId }: { userId: string }) {\n-  const updateUserWithId = updateUser.bind(null, userId)\n-\n-  return (\n-    <form action={updateUserWithId}>\n-      <input type=\"text\" name=\"name\" />\n-      <button type=\"submit\">Update User Name</button>\n-    </form>\n-  )\n-}\n-```\n-\n-```jsx filename=\"app/client-component.js\" highlight={6} switcher\n-'use client'\n-\n-import { updateUser } from './actions'\n-\n-export function UserProfile({ userId }) {\n-  const updateUserWithId = updateUser.bind(null, userId)\n-\n-  return (\n-    <form action={updateUserWithId}>\n-      <input type=\"text\" name=\"name\" />\n-      <button type=\"submit\">Update User Name</button>\n-    </form>\n-  )\n-}\n-```\n-\n-The Server Action will receive the `userId` argument, in addition to the form data:\n-\n-```ts filename=\"app/actions.ts\" switcher\n-'use server'\n-\n-export async function updateUser(userId: string, formData: FormData) {}\n-```\n-\n-```js filename=\"app/actions.js\" switcher\n-'use server'\n-\n-export async function updateUser(userId, formData) {}\n-```\n-\n-> **Good to know**:\n->\n-> - An alternative is to pass arguments as hidden input fields in the form (e.g. `<input type=\"hidden\" name=\"userId\" value={userId} />`). However, the value will be part of the rendered HTML and will not be encoded.\n-> - `.bind` works in both Server and Client Components. It also supports progressive enhancement.\n-\n-### Nested form elements\n-\n-You can also invoke a Server Action in elements nested inside `<form>` such as `<button>`, `<input type=\"submit\">`, and `<input type=\"image\">`. These elements accept the `formAction` prop or [event handlers](#event-handlers).\n-\n-This is useful in cases where you want to call multiple server actions within a form. For example, you can create a specific `<button>` element for saving a post draft in addition to publishing it. See the [React `<form>` docs](https://react.dev/reference/react-dom/components/form#handling-multiple-submission-types) for more information.\n-\n-### Programmatic form submission\n-\n-You can trigger a form submission programmatically using the [`requestSubmit()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement/requestSubmit) method. For example, when the user submits a form using the `⌘` + `Enter` keyboard shortcut, you can listen for the `onKeyDown` event:\n-\n-```tsx filename=\"app/entry.tsx\" switcher\n-'use client'\n-\n-export function Entry() {\n-  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {\n-    if (\n-      (e.ctrlKey || e.metaKey) &&\n-      (e.key === 'Enter' || e.key === 'NumpadEnter')\n-    ) {\n-      e.preventDefault()\n-      e.currentTarget.form?.requestSubmit()\n-    }\n-  }\n-\n-  return (\n-    <div>\n-      <textarea name=\"entry\" rows={20} required onKeyDown={handleKeyDown} />\n-    </div>\n-  )\n-}\n-```\n-\n-```jsx filename=\"app/entry.js\" switcher\n-'use client'\n-\n-export function Entry() {\n-  const handleKeyDown = (e) => {\n-    if (\n-      (e.ctrlKey || e.metaKey) &&\n-      (e.key === 'Enter' || e.key === 'NumpadEnter')\n-    ) {\n-      e.preventDefault()\n-      e.currentTarget.form?.requestSubmit()\n-    }\n-  }\n-\n-  return (\n-    <div>\n-      <textarea name=\"entry\" rows={20} required onKeyDown={handleKeyDown} />\n-    </div>\n-  )\n-}\n-```\n-\n-This will trigger the submission of the nearest `<form>` ancestor, which will invoke the Server Action.\n-\n-### Server-side form validation\n-\n-You can use the HTML attributes like `required` and `type=\"email\"` for basic client-side form validation.\n-\n-For more advanced server-side validation, you can use a library like [zod](https://zod.dev/) to validate the form fields before mutating the data:\n-\n-```tsx filename=\"app/actions.ts\" switcher\n-'use server'\n-\n-import { z } from 'zod'\n-\n-const schema = z.object({\n-  email: z.string({\n-    invalid_type_error: 'Invalid Email',\n-  }),\n-})\n-\n-export default async function createUser(formData: FormData) {\n-  const validatedFields = schema.safeParse({\n-    email: formData.get('email'),\n-  })\n-\n-  // Return early if the form data is invalid\n-  if (!validatedFields.success) {\n-    return {\n-      errors: validatedFields.error.flatten().fieldErrors,\n-    }\n-  }\n-\n-  // Mutate data\n-}\n-```\n-\n-```jsx filename=\"app/actions.js\" switcher\n-'use server'\n-\n-import { z } from 'zod'\n-\n-const schema = z.object({\n-  email: z.string({\n-    invalid_type_error: 'Invalid Email',\n-  }),\n-})\n-\n-export default async function createsUser(formData) {\n-  const validatedFields = schema.safeParse({\n-    email: formData.get('email'),\n-  })\n-\n-  // Return early if the form data is invalid\n-  if (!validatedFields.success) {\n-    return {\n-      errors: validatedFields.error.flatten().fieldErrors,\n-    }\n-  }\n-\n-  // Mutate data\n-}\n-```\n-\n-Once the fields have been validated on the server, you can return a serializable object in your action and use the React `useActionState` hook to show a message to the user.\n-\n-- By passing the action to `useActionState`, the action's function signature changes to receive a new `prevState` or `initialState` parameter as its first argument.\n-- `useActionState` is a React Hook and therefore must be used in a Client Component.\n-\n-```tsx filename=\"app/actions.ts\" switcher\n-'use server'\n-\n-import { redirect } from 'next/navigation'\n-\n-export async function createUser(prevState: any, formData: FormData) {\n-  const res = await fetch('https://...')\n-  const json = await res.json()\n-\n-  if (!res.ok) {\n-    return { message: 'Please enter a valid email' }\n-  }\n-\n-  redirect('/dashboard')\n-}\n-```\n-\n-```jsx filename=\"app/actions.js\" switcher\n-'use server'\n-\n-import { redirect } from 'next/navigation'\n-\n-export async function createUser(prevState, formData) {\n-  const res = await fetch('https://...')\n-  const json = await res.json()\n-\n-  if (!res.ok) {\n-    return { message: 'Please enter a valid email' }\n-  }\n-\n-  redirect('/dashboard')\n-}\n-```\n-\n-Then, you can pass your action to the `useActionState` hook and use the returned `state` to display an error message.\n-\n-```tsx filename=\"app/ui/signup.tsx\" highlight={11,18-20} switcher\n-'use client'\n-\n-import { useActionState } from 'react'\n-import { createUser } from '@/app/actions'\n-\n-const initialState = {\n-  message: '',\n-}\n-\n-export function Signup() {\n-  const [state, formAction, pending] = useActionState(createUser, initialState)\n-\n-  return (\n-    <form action={formAction}>\n-      <label htmlFor=\"email\">Email</label>\n-      <input type=\"text\" id=\"email\" name=\"email\" required />\n-      {/* ... */}\n-      <p aria-live=\"polite\">{state?.message}</p>\n-      <button disabled={pending}>Sign up</button>\n-    </form>\n-  )\n-}\n-```\n-\n-```jsx filename=\"app/ui/signup.js\" highlight={11,18-20} switcher\n-'use client'\n-\n-import { useActionState } from 'react'\n-import { createUser } from '@/app/actions'\n-\n-const initialState = {\n-  message: '',\n-}\n-\n-export function Signup() {\n-  const [state, formAction, pending] = useActionState(createUser, initialState)\n-\n-  return (\n-    <form action={formAction}>\n-      <label htmlFor=\"email\">Email</label>\n-      <input type=\"text\" id=\"email\" name=\"email\" required />\n-      {/* ... */}\n-      <p aria-live=\"polite\">{state?.message}</p>\n-      <button disabled={pending}>Sign up</button>\n-    </form>\n-  )\n-}\n-```\n-\n-### Pending states\n-\n-The [`useActionState`](https://react.dev/reference/react/useActionState) hook exposes a `pending` boolean that can be used to show a loading indicator while the action is being executed.\n-\n-Alternatively, you can use the [`useFormStatus`](https://react.dev/reference/react-dom/hooks/useFormStatus) hook to show a loading indicator while the action is being executed. When using this hook, you'll need to create a separate component to render the loading indicator. For example, to disable the button when the action is pending:\n-\n-```tsx filename=\"app/ui/button.tsx\" highlight={6} switcher\n-'use client'\n-\n-import { useFormStatus } from 'react-dom'\n-\n-export function SubmitButton() {\n-  const { pending } = useFormStatus()\n-\n-  return (\n-    <button disabled={pending} type=\"submit\">\n-      Sign Up\n-    </button>\n-  )\n-}\n-```\n-\n-```jsx filename=\"app/ui/button.js\" highlight={6} switcher\n-'use client'\n-\n-import { useFormStatus } from 'react-dom'\n-\n-export function SubmitButton() {\n-  const { pending } = useFormStatus()\n-\n-  return (\n-    <button disabled={pending} type=\"submit\">\n-      Sign Up\n-    </button>\n-  )\n-}\n-```\n-\n-You can then nest the `SubmitButton` component inside the form:\n-\n-```tsx filename=\"app/ui/signup.tsx\" switcher\n-import { SubmitButton } from './button'\n-import { createUser } from '@/app/actions'\n-\n-export function Signup() {\n-  return (\n-    <form action={createUser}>\n-      {/* Other form elements */}\n-      <SubmitButton />\n-    </form>\n-  )\n-}\n-```\n-\n-```jsx filename=\"app/ui/signup.js\" switcher\n-import { SubmitButton } from './button'\n-import { createUser } from '@/app/actions'\n-\n-export function Signup() {\n-  return (\n-    <form action={createUser}>\n-      {/* Other form elements */}\n-      <SubmitButton />\n-    </form>\n-  )\n-}\n-```\n-\n-> **Good to know:** In React 19, `useFormStatus` includes additional keys on the returned object, like data, method, and action. If you are not using React 19, only the `pending` key is available.\n-\n-### Optimistic updates\n-\n-You can use the React [`useOptimistic`](https://react.dev/reference/react/useOptimistic) hook to optimistically update the UI before the Server Action finishes executing, rather than waiting for the response:\n-\n-```tsx filename=\"app/page.tsx\" switcher\n-'use client'\n-\n-import { useOptimistic } from 'react'\n-import { send } from './actions'\n-\n-type Message = {\n-  message: string\n-}\n-\n-export function Thread({ messages }: { messages: Message[] }) {\n-  const [optimisticMessages, addOptimisticMessage] = useOptimistic<\n-    Message[],\n-    string\n-  >(messages, (state, newMessage) => [...state, { message: newMessage }])\n-\n-  const formAction = async (formData: FormData) => {\n-    const message = formData.get('message') as string\n-    addOptimisticMessage(message)\n-    await send(message)\n-  }\n-\n-  return (\n-    <div>\n-      {optimisticMessages.map((m, i) => (\n-        <div key={i}>{m.message}</div>\n-      ))}\n-      <form action={formAction}>\n-        <input type=\"text\" name=\"message\" />\n-        <button type=\"submit\">Send</button>\n-      </form>\n-    </div>\n-  )\n-}\n-```\n-\n-```jsx filename=\"app/page.js\" switcher\n-'use client'\n-\n-import { useOptimistic } from 'react'\n-import { send } from './actions'\n-\n-export function Thread({ messages }) {\n-  const [optimisticMessages, addOptimisticMessage] = useOptimistic(\n-    messages,\n-    (state, newMessage) => [...state, { message: newMessage }]\n-  )\n-\n-  const formAction = async (formData) => {\n-    const message = formData.get('message')\n-    addOptimisticMessage(message)\n-    await send(message)\n-  }\n-\n-  return (\n-    <div>\n-      {optimisticMessages.map((m) => (\n-        <div>{m.message}</div>\n-      ))}\n-      <form action={formAction}>\n-        <input type=\"text\" name=\"message\" />\n-        <button type=\"submit\">Send</button>\n-      </form>\n-    </div>\n-  )\n-}\n-```\n-\n ### Event handlers\n \n While it's common to use Server Actions within `<form>` elements, they can also be invoked with event handlers such as `onClick`. For example, to increment a like count:\n@@ -719,7 +263,7 @@ When an error is thrown, it'll be caught by the nearest `error.js` or `<Suspense\n \n > **Good to know:**\n >\n-> - Aside from throwing the error, you can also return an object to be handled by `useActionState`. See [Server-side validation and error handling](#server-side-form-validation).\n+> - Aside from throwing the error, you can also return an object to be handled by `useActionState`.\n \n ### Revalidating data\n "
        },
        {
            "sha": "84e08d32244396b0646fe2953a254c86e4be465f",
            "filename": "docs/02-pages/02-guides/forms.mdx",
            "status": "added",
            "additions": 336,
            "deletions": 0,
            "changes": 336,
            "blob_url": "https://github.com/vercel/next.js/blob/b89caa422a16223795d294f035c87007013333b6/docs%2F02-pages%2F02-guides%2Fforms.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/b89caa422a16223795d294f035c87007013333b6/docs%2F02-pages%2F02-guides%2Fforms.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F02-pages%2F02-guides%2Fforms.mdx?ref=b89caa422a16223795d294f035c87007013333b6",
            "patch": "@@ -0,0 +1,336 @@\n+---\n+title: How to create forms with API Routes\n+nav_title: Forms\n+description: Learn how to handle form submissions and data mutations with Next.js.\n+---\n+\n+Forms enable you to create and update data in web applications. Next.js provides a powerful way to handle data mutations using **API Routes**. This guide will walk you through how to handle form submission on the server.\n+\n+## Server Forms\n+\n+To handle form submissions on the server, create an API endpoint securely mutate data.\n+\n+```ts filename=\"pages/api/submit.ts\" switcher\n+import type { NextApiRequest, NextApiResponse } from 'next'\n+\n+export default async function handler(\n+  req: NextApiRequest,\n+  res: NextApiResponse\n+) {\n+  const data = req.body\n+  const id = await createItem(data)\n+  res.status(200).json({ id })\n+}\n+```\n+\n+```js filename=\"pages/api/submit.js\" switcher\n+export default function handler(req, res) {\n+  const data = req.body\n+  // call your database, etc.\n+  // const id = await createItem(data)\n+  // ...\n+  res.status(200).json({ data })\n+}\n+```\n+\n+Then, call the API Route from the client with an event handler:\n+\n+```tsx filename=\"pages/index.tsx\" switcher\n+import { FormEvent } from 'react'\n+\n+export default function Page() {\n+  async function onSubmit(event: FormEvent<HTMLFormElement>) {\n+    event.preventDefault()\n+\n+    const formData = new FormData(event.currentTarget)\n+    const response = await fetch('/api/submit', {\n+      method: 'POST',\n+      body: formData,\n+    })\n+\n+    // Handle response if necessary\n+    const data = await response.json()\n+    // ...\n+  }\n+\n+  return (\n+    <form onSubmit={onSubmit}>\n+      <input type=\"text\" name=\"name\" />\n+      <button type=\"submit\">Submit</button>\n+    </form>\n+  )\n+}\n+```\n+\n+```jsx filename=\"pages/index.jsx\" switcher\n+export default function Page() {\n+  async function onSubmit(event) {\n+    event.preventDefault()\n+\n+    const formData = new FormData(event.target)\n+    const response = await fetch('/api/submit', {\n+      method: 'POST',\n+      body: formData,\n+    })\n+\n+    // Handle response if necessary\n+    const data = await response.json()\n+    // ...\n+  }\n+\n+  return (\n+    <form onSubmit={onSubmit}>\n+      <input type=\"text\" name=\"name\" />\n+      <button type=\"submit\">Submit</button>\n+    </form>\n+  )\n+}\n+```\n+\n+> **Good to know:**\n+>\n+> - API Routes [do not specify CORS headers](https://developer.mozilla.org/docs/Web/HTTP/CORS), meaning they are same-origin only by default.\n+> - Since API Routes run on the server, we're able to use sensitive values (like API keys) through [Environment Variables](/docs/pages/guides/environment-variables) without exposing them to the client. This is critical for the security of your application.\n+\n+## Form validation\n+\n+We recommend using HTML validation like `required` and `type=\"email\"` for basic client-side form validation.\n+\n+For more advanced server-side validation, you can use a schema validation library like [zod](https://zod.dev/) to validate the form fields before mutating the data:\n+\n+```ts filename=\"pages/api/submit.ts\" switcher\n+import type { NextApiRequest, NextApiResponse } from 'next'\n+import { z } from 'zod'\n+\n+const schema = z.object({\n+  // ...\n+})\n+\n+export default async function handler(\n+  req: NextApiRequest,\n+  res: NextApiResponse\n+) {\n+  const parsed = schema.parse(req.body)\n+  // ...\n+}\n+```\n+\n+```js filename=\"pages/api/submit.js\" switcher\n+import { z } from 'zod'\n+\n+const schema = z.object({\n+  // ...\n+})\n+\n+export default async function handler(req, res) {\n+  const parsed = schema.parse(req.body)\n+  // ...\n+}\n+```\n+\n+### Error handling\n+\n+You can use React state to show an error message when a form submission fails:\n+\n+```tsx filename=\"pages/index.tsx\" switcher\n+import React, { useState, FormEvent } from 'react'\n+\n+export default function Page() {\n+  const [isLoading, setIsLoading] = useState<boolean>(false)\n+  const [error, setError] = useState<string | null>(null)\n+\n+  async function onSubmit(event: FormEvent<HTMLFormElement>) {\n+    event.preventDefault()\n+    setIsLoading(true)\n+    setError(null) // Clear previous errors when a new request starts\n+\n+    try {\n+      const formData = new FormData(event.currentTarget)\n+      const response = await fetch('/api/submit', {\n+        method: 'POST',\n+        body: formData,\n+      })\n+\n+      if (!response.ok) {\n+        throw new Error('Failed to submit the data. Please try again.')\n+      }\n+\n+      // Handle response if necessary\n+      const data = await response.json()\n+      // ...\n+    } catch (error) {\n+      // Capture the error message to display to the user\n+      setError(error.message)\n+      console.error(error)\n+    } finally {\n+      setIsLoading(false)\n+    }\n+  }\n+\n+  return (\n+    <div>\n+      {error && <div style={{ color: 'red' }}>{error}</div>}\n+      <form onSubmit={onSubmit}>\n+        <input type=\"text\" name=\"name\" />\n+        <button type=\"submit\" disabled={isLoading}>\n+          {isLoading ? 'Loading...' : 'Submit'}\n+        </button>\n+      </form>\n+    </div>\n+  )\n+}\n+```\n+\n+```jsx filename=\"pages/index.jsx\" switcher\n+import React, { useState } from 'react'\n+\n+export default function Page() {\n+  const [isLoading, setIsLoading] = useState(false)\n+  const [error, setError] = useState(null)\n+\n+  async function onSubmit(event) {\n+    event.preventDefault()\n+    setIsLoading(true)\n+    setError(null) // Clear previous errors when a new request starts\n+\n+    try {\n+      const formData = new FormData(event.currentTarget)\n+      const response = await fetch('/api/submit', {\n+        method: 'POST',\n+        body: formData,\n+      })\n+\n+      if (!response.ok) {\n+        throw new Error('Failed to submit the data. Please try again.')\n+      }\n+\n+      // Handle response if necessary\n+      const data = await response.json()\n+      // ...\n+    } catch (error) {\n+      // Capture the error message to display to the user\n+      setError(error.message)\n+      console.error(error)\n+    } finally {\n+      setIsLoading(false)\n+    }\n+  }\n+\n+  return (\n+    <div>\n+      {error && <div style={{ color: 'red' }}>{error}</div>}\n+      <form onSubmit={onSubmit}>\n+        <input type=\"text\" name=\"name\" />\n+        <button type=\"submit\" disabled={isLoading}>\n+          {isLoading ? 'Loading...' : 'Submit'}\n+        </button>\n+      </form>\n+    </div>\n+  )\n+}\n+```\n+\n+## Displaying loading state\n+\n+You can use React state to show a loading state when a form is submitting on the server:\n+\n+```tsx filename=\"pages/index.tsx\" switcher\n+import React, { useState, FormEvent } from 'react'\n+\n+export default function Page() {\n+  const [isLoading, setIsLoading] = useState<boolean>(false)\n+\n+  async function onSubmit(event: FormEvent<HTMLFormElement>) {\n+    event.preventDefault()\n+    setIsLoading(true) // Set loading to true when the request starts\n+\n+    try {\n+      const formData = new FormData(event.currentTarget)\n+      const response = await fetch('/api/submit', {\n+        method: 'POST',\n+        body: formData,\n+      })\n+\n+      // Handle response if necessary\n+      const data = await response.json()\n+      // ...\n+    } catch (error) {\n+      // Handle error if necessary\n+      console.error(error)\n+    } finally {\n+      setIsLoading(false) // Set loading to false when the request completes\n+    }\n+  }\n+\n+  return (\n+    <form onSubmit={onSubmit}>\n+      <input type=\"text\" name=\"name\" />\n+      <button type=\"submit\" disabled={isLoading}>\n+        {isLoading ? 'Loading...' : 'Submit'}\n+      </button>\n+    </form>\n+  )\n+}\n+```\n+\n+```jsx filename=\"pages/index.jsx\" switcher\n+import React, { useState } from 'react'\n+\n+export default function Page() {\n+  const [isLoading, setIsLoading] = useState(false)\n+\n+  async function onSubmit(event) {\n+    event.preventDefault()\n+    setIsLoading(true) // Set loading to true when the request starts\n+\n+    try {\n+      const formData = new FormData(event.currentTarget)\n+      const response = await fetch('/api/submit', {\n+        method: 'POST',\n+        body: formData,\n+      })\n+\n+      // Handle response if necessary\n+      const data = await response.json()\n+      // ...\n+    } catch (error) {\n+      // Handle error if necessary\n+      console.error(error)\n+    } finally {\n+      setIsLoading(false) // Set loading to false when the request completes\n+    }\n+  }\n+\n+  return (\n+    <form onSubmit={onSubmit}>\n+      <input type=\"text\" name=\"name\" />\n+      <button type=\"submit\" disabled={isLoading}>\n+        {isLoading ? 'Loading...' : 'Submit'}\n+      </button>\n+    </form>\n+  )\n+}\n+```\n+\n+### Redirecting\n+\n+If you would like to redirect the user to a different route after a mutation, you can [`redirect`](/docs/pages/building-your-application/routing/api-routes#response-helpers) to any absolute or relative URL:\n+\n+```ts filename=\"pages/api/submit.ts\" switcher\n+import type { NextApiRequest, NextApiResponse } from 'next'\n+\n+export default async function handler(\n+  req: NextApiRequest,\n+  res: NextApiResponse\n+) {\n+  const id = await addPost()\n+  res.redirect(307, `/post/${id}`)\n+}\n+```\n+\n+```js filename=\"pages/api/submit.js\" switcher\n+export default async function handler(req, res) {\n+  const id = await addPost()\n+  res.redirect(307, `/post/${id}`)\n+}\n+```"
        },
        {
            "sha": "c9468f2b20e09f400516215e9088829992ddcb3b",
            "filename": "docs/02-pages/03-building-your-application/03-data-fetching/03-forms-and-mutations.mdx",
            "status": "modified",
            "additions": 0,
            "deletions": 301,
            "changes": 301,
            "blob_url": "https://github.com/vercel/next.js/blob/b89caa422a16223795d294f035c87007013333b6/docs%2F02-pages%2F03-building-your-application%2F03-data-fetching%2F03-forms-and-mutations.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/b89caa422a16223795d294f035c87007013333b6/docs%2F02-pages%2F03-building-your-application%2F03-data-fetching%2F03-forms-and-mutations.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F02-pages%2F03-building-your-application%2F03-data-fetching%2F03-forms-and-mutations.mdx?ref=b89caa422a16223795d294f035c87007013333b6",
            "patch": "@@ -14,307 +14,6 @@ Forms enable you to create and update data in web applications. Next.js provides\n \n ## Examples\n \n-### Server-only form\n-\n-With the Pages Router, you need to manually create API endpoints to handle securely mutating data on the server.\n-\n-```ts filename=\"pages/api/submit.ts\" switcher\n-import type { NextApiRequest, NextApiResponse } from 'next'\n-\n-export default async function handler(\n-  req: NextApiRequest,\n-  res: NextApiResponse\n-) {\n-  const data = req.body\n-  const id = await createItem(data)\n-  res.status(200).json({ id })\n-}\n-```\n-\n-```js filename=\"pages/api/submit.js\" switcher\n-export default function handler(req, res) {\n-  const data = req.body\n-  // call your database, etc.\n-  // const id = await createItem(data)\n-  // ...\n-  res.status(200).json({ data })\n-}\n-```\n-\n-Then, call the API Route from the client with an event handler:\n-\n-```tsx filename=\"pages/index.tsx\" switcher\n-import { FormEvent } from 'react'\n-\n-export default function Page() {\n-  async function onSubmit(event: FormEvent<HTMLFormElement>) {\n-    event.preventDefault()\n-\n-    const formData = new FormData(event.currentTarget)\n-    const response = await fetch('/api/submit', {\n-      method: 'POST',\n-      body: formData,\n-    })\n-\n-    // Handle response if necessary\n-    const data = await response.json()\n-    // ...\n-  }\n-\n-  return (\n-    <form onSubmit={onSubmit}>\n-      <input type=\"text\" name=\"name\" />\n-      <button type=\"submit\">Submit</button>\n-    </form>\n-  )\n-}\n-```\n-\n-```jsx filename=\"pages/index.jsx\" switcher\n-export default function Page() {\n-  async function onSubmit(event) {\n-    event.preventDefault()\n-\n-    const formData = new FormData(event.target)\n-    const response = await fetch('/api/submit', {\n-      method: 'POST',\n-      body: formData,\n-    })\n-\n-    // Handle response if necessary\n-    const data = await response.json()\n-    // ...\n-  }\n-\n-  return (\n-    <form onSubmit={onSubmit}>\n-      <input type=\"text\" name=\"name\" />\n-      <button type=\"submit\">Submit</button>\n-    </form>\n-  )\n-}\n-```\n-\n-## Form validation\n-\n-We recommend using HTML validation like `required` and `type=\"email\"` for basic client-side form validation.\n-\n-For more advanced server-side validation, you can use a schema validation library like [zod](https://zod.dev/) to validate the form fields before mutating the data:\n-\n-```ts filename=\"pages/api/submit.ts\" switcher\n-import type { NextApiRequest, NextApiResponse } from 'next'\n-import { z } from 'zod'\n-\n-const schema = z.object({\n-  // ...\n-})\n-\n-export default async function handler(\n-  req: NextApiRequest,\n-  res: NextApiResponse\n-) {\n-  const parsed = schema.parse(req.body)\n-  // ...\n-}\n-```\n-\n-```js filename=\"pages/api/submit.js\" switcher\n-import { z } from 'zod'\n-\n-const schema = z.object({\n-  // ...\n-})\n-\n-export default async function handler(req, res) {\n-  const parsed = schema.parse(req.body)\n-  // ...\n-}\n-```\n-\n-### Error handling\n-\n-You can use React state to show an error message when a form submission fails:\n-\n-```tsx filename=\"pages/index.tsx\" switcher\n-import React, { useState, FormEvent } from 'react'\n-\n-export default function Page() {\n-  const [isLoading, setIsLoading] = useState<boolean>(false)\n-  const [error, setError] = useState<string | null>(null)\n-\n-  async function onSubmit(event: FormEvent<HTMLFormElement>) {\n-    event.preventDefault()\n-    setIsLoading(true)\n-    setError(null) // Clear previous errors when a new request starts\n-\n-    try {\n-      const formData = new FormData(event.currentTarget)\n-      const response = await fetch('/api/submit', {\n-        method: 'POST',\n-        body: formData,\n-      })\n-\n-      if (!response.ok) {\n-        throw new Error('Failed to submit the data. Please try again.')\n-      }\n-\n-      // Handle response if necessary\n-      const data = await response.json()\n-      // ...\n-    } catch (error) {\n-      // Capture the error message to display to the user\n-      setError(error.message)\n-      console.error(error)\n-    } finally {\n-      setIsLoading(false)\n-    }\n-  }\n-\n-  return (\n-    <div>\n-      {error && <div style={{ color: 'red' }}>{error}</div>}\n-      <form onSubmit={onSubmit}>\n-        <input type=\"text\" name=\"name\" />\n-        <button type=\"submit\" disabled={isLoading}>\n-          {isLoading ? 'Loading...' : 'Submit'}\n-        </button>\n-      </form>\n-    </div>\n-  )\n-}\n-```\n-\n-```jsx filename=\"pages/index.jsx\" switcher\n-import React, { useState } from 'react'\n-\n-export default function Page() {\n-  const [isLoading, setIsLoading] = useState(false)\n-  const [error, setError] = useState(null)\n-\n-  async function onSubmit(event) {\n-    event.preventDefault()\n-    setIsLoading(true)\n-    setError(null) // Clear previous errors when a new request starts\n-\n-    try {\n-      const formData = new FormData(event.currentTarget)\n-      const response = await fetch('/api/submit', {\n-        method: 'POST',\n-        body: formData,\n-      })\n-\n-      if (!response.ok) {\n-        throw new Error('Failed to submit the data. Please try again.')\n-      }\n-\n-      // Handle response if necessary\n-      const data = await response.json()\n-      // ...\n-    } catch (error) {\n-      // Capture the error message to display to the user\n-      setError(error.message)\n-      console.error(error)\n-    } finally {\n-      setIsLoading(false)\n-    }\n-  }\n-\n-  return (\n-    <div>\n-      {error && <div style={{ color: 'red' }}>{error}</div>}\n-      <form onSubmit={onSubmit}>\n-        <input type=\"text\" name=\"name\" />\n-        <button type=\"submit\" disabled={isLoading}>\n-          {isLoading ? 'Loading...' : 'Submit'}\n-        </button>\n-      </form>\n-    </div>\n-  )\n-}\n-```\n-\n-## Displaying loading state\n-\n-You can use React state to show a loading state when a form is submitting on the server:\n-\n-```tsx filename=\"pages/index.tsx\" switcher\n-import React, { useState, FormEvent } from 'react'\n-\n-export default function Page() {\n-  const [isLoading, setIsLoading] = useState<boolean>(false)\n-\n-  async function onSubmit(event: FormEvent<HTMLFormElement>) {\n-    event.preventDefault()\n-    setIsLoading(true) // Set loading to true when the request starts\n-\n-    try {\n-      const formData = new FormData(event.currentTarget)\n-      const response = await fetch('/api/submit', {\n-        method: 'POST',\n-        body: formData,\n-      })\n-\n-      // Handle response if necessary\n-      const data = await response.json()\n-      // ...\n-    } catch (error) {\n-      // Handle error if necessary\n-      console.error(error)\n-    } finally {\n-      setIsLoading(false) // Set loading to false when the request completes\n-    }\n-  }\n-\n-  return (\n-    <form onSubmit={onSubmit}>\n-      <input type=\"text\" name=\"name\" />\n-      <button type=\"submit\" disabled={isLoading}>\n-        {isLoading ? 'Loading...' : 'Submit'}\n-      </button>\n-    </form>\n-  )\n-}\n-```\n-\n-```jsx filename=\"pages/index.jsx\" switcher\n-import React, { useState } from 'react'\n-\n-export default function Page() {\n-  const [isLoading, setIsLoading] = useState(false)\n-\n-  async function onSubmit(event) {\n-    event.preventDefault()\n-    setIsLoading(true) // Set loading to true when the request starts\n-\n-    try {\n-      const formData = new FormData(event.currentTarget)\n-      const response = await fetch('/api/submit', {\n-        method: 'POST',\n-        body: formData,\n-      })\n-\n-      // Handle response if necessary\n-      const data = await response.json()\n-      // ...\n-    } catch (error) {\n-      // Handle error if necessary\n-      console.error(error)\n-    } finally {\n-      setIsLoading(false) // Set loading to false when the request completes\n-    }\n-  }\n-\n-  return (\n-    <form onSubmit={onSubmit}>\n-      <input type=\"text\" name=\"name\" />\n-      <button type=\"submit\" disabled={isLoading}>\n-        {isLoading ? 'Loading...' : 'Submit'}\n-      </button>\n-    </form>\n-  )\n-}\n-```\n-\n ### Redirecting\n \n If you would like to redirect the user to a different route after a mutation, you can [`redirect`](/docs/pages/building-your-application/routing/api-routes#response-helpers) to any absolute or relative URL:"
        }
    ],
    "stats": {
        "total": 1606,
        "additions": 838,
        "deletions": 768
    }
}