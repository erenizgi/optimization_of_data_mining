{
    "author": "bgw",
    "message": "Turbopack: bincode: Add traits for types that require `TurboBincodeEncoder` or `TurboBincodeDecoder` (#86633)\n\n**Example usage:** See `CachedTaskType`​ in `turbopack/crates/turbo-tasks/src/backend.rs`​ on https://github.com/vercel/next.js/pull/86631 for an example of how this is used. That needs to call the encoder/decoder function pointer stored on `native_fn.arg_meta.bincode` with a concrete `TurboBincodeEncoder`/`TurboBincodeDecoder`, so it uses this trait.\n\n---\n\nFor `SharedReference` (value cell contents) and `TaskInput`s, we need to generate function pointers to functions that can encode/decode the type.\n\nThose generated functions cannot contain generics, so they require `TurboBincodeEncoder` or `TurboBincodeDecoder<()>` as arguments. That's okay because we don't want to use multiple encoders/decoders anyways, because that would be really bad for binary size and compilation time.\n\nHowever, `SharedReference` and `TaskInput`s are wrapped in other container types that need to be encoded/decoded (e.g. `TypedSharedReference`. In these cases, the wrapper types need to be able to implement `Encode`/`Decode`, but can't because of the fixed `Encoder`/`Decoder` implementations. So this provides a way to do that, by panicking at runtime if the type doesn't match.\n\nThis uses the `unty` crate which is part of the bincode project: https://github.com/bincode-org/unty",
    "sha": "3a323194341a6554147d832cf6bca26e7140bd49",
    "files": [
        {
            "sha": "0cd2def5d6f121bd49407f411d1ed087225b0dee",
            "filename": "Cargo.lock",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/3a323194341a6554147d832cf6bca26e7140bd49/Cargo.lock",
            "raw_url": "https://github.com/vercel/next.js/raw/3a323194341a6554147d832cf6bca26e7140bd49/Cargo.lock",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/Cargo.lock?ref=3a323194341a6554147d832cf6bca26e7140bd49",
            "patch": "@@ -9096,6 +9096,7 @@ dependencies = [\n  \"serde\",\n  \"serde_json\",\n  \"smallvec\",\n+ \"unty\",\n ]\n \n [[package]]"
        },
        {
            "sha": "23b98dc2f67149082daed00b509a376b9f3be4c7",
            "filename": "Cargo.toml",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/3a323194341a6554147d832cf6bca26e7140bd49/Cargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/3a323194341a6554147d832cf6bca26e7140bd49/Cargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/Cargo.toml?ref=3a323194341a6554147d832cf6bca26e7140bd49",
            "patch": "@@ -470,6 +470,7 @@ tracing = \"0.1.37\"\n tracing-subscriber = \"0.3.16\"\n triomphe = { git = \"https://github.com/sokra/triomphe\", branch = \"sokra/unstable\" }\n unsize = \"1.1.0\"\n+unty = \"0.0.4\"\n url = \"2.2.2\"\n urlencoding = \"2.1.2\"\n uuid = \"1.18.1\""
        },
        {
            "sha": "30ebc25e0a6101f3f3d27366c2028c173636e5b6",
            "filename": "turbopack/crates/turbo-bincode/Cargo.toml",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/3a323194341a6554147d832cf6bca26e7140bd49/turbopack%2Fcrates%2Fturbo-bincode%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/3a323194341a6554147d832cf6bca26e7140bd49/turbopack%2Fcrates%2Fturbo-bincode%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-bincode%2FCargo.toml?ref=3a323194341a6554147d832cf6bca26e7140bd49",
            "patch": "@@ -19,3 +19,4 @@ ringmap = { workspace = true }\n serde = { workspace = true }\n serde_json = { workspace = true }\n smallvec = { workspace = true }\n+unty = { workspace = true }"
        },
        {
            "sha": "e9e9a2544db45468762c14b288424d99cccf1b19",
            "filename": "turbopack/crates/turbo-bincode/src/lib.rs",
            "status": "modified",
            "additions": 54,
            "deletions": 0,
            "changes": 54,
            "blob_url": "https://github.com/vercel/next.js/blob/3a323194341a6554147d832cf6bca26e7140bd49/turbopack%2Fcrates%2Fturbo-bincode%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3a323194341a6554147d832cf6bca26e7140bd49/turbopack%2Fcrates%2Fturbo-bincode%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-bincode%2Fsrc%2Flib.rs?ref=3a323194341a6554147d832cf6bca26e7140bd49",
            "patch": "@@ -1,3 +1,6 @@\n+#[doc(hidden)]\n+pub mod macro_helpers;\n+\n use std::ptr::copy_nonoverlapping;\n \n use ::smallvec::SmallVec;\n@@ -115,6 +118,57 @@ impl Reader for TurboBincodeReader<'_> {\n     }\n }\n \n+/// Represents a type that can only be encoded with a [`TurboBincodeEncoder`].\n+///\n+/// All traits implementing this must also implement the more generic [`Encode`] trait, but they\n+/// should panic if any other encoder is used.\n+///\n+/// Use [`impl_encode_for_turbo_bincode_encode`] to automatically implement the [`Encode`] trait\n+/// from this one.\n+pub trait TurboBincodeEncode: Encode {\n+    fn encode(&self, encoder: &mut TurboBincodeEncoder) -> Result<(), EncodeError>;\n+}\n+\n+/// Represents a type that can only be decoded with a [`TurboBincodeDecoder`] and an empty `()`\n+/// context.\n+///\n+/// All traits implementing this must also implement the more generic [`Decode`] trait, but they\n+/// should panic if any other encoder is used.\n+///\n+/// Use [`impl_decode_for_turbo_bincode_decode`] to automatically implement the [`Decode`] trait\n+/// from this one.\n+pub trait TurboBincodeDecode<Context>: Decode<Context> {\n+    fn decode(decoder: &mut TurboBincodeDecoder) -> Result<Self, DecodeError>;\n+}\n+\n+#[macro_export]\n+macro_rules! impl_encode_for_turbo_bincode_encode {\n+    ($ty:ty) => {\n+        impl $crate::macro_helpers::bincode::Encode for $ty {\n+            fn encode<'a, E: $crate::macro_helpers::bincode::enc::Encoder>(\n+                &self,\n+                encoder: &'a mut E,\n+            ) -> ::std::result::Result<(), $crate::macro_helpers::bincode::error::EncodeError> {\n+                $crate::macro_helpers::encode_for_turbo_bincode_encode_impl(self, encoder)\n+            }\n+        }\n+    };\n+}\n+\n+#[macro_export]\n+macro_rules! impl_decode_for_turbo_bincode_decode {\n+    ($ty:ty) => {\n+        impl<Context> $crate::macro_helpers::bincode::Decode<Context> for $ty {\n+            fn decode<D: $crate::macro_helpers::bincode::de::Decoder<Context = Context>>(\n+                decoder: &mut D,\n+            ) -> ::std::result::Result<Self, $crate::macro_helpers::bincode::error::DecodeError>\n+            {\n+                $crate::macro_helpers::decode_for_turbo_bincode_decode_impl(decoder)\n+            }\n+        }\n+    };\n+}\n+\n pub mod indexmap {\n     use std::hash::{BuildHasher, Hash};\n "
        },
        {
            "sha": "ad0c624f7e66ec5749f7b80df910906f67ada6f7",
            "filename": "turbopack/crates/turbo-bincode/src/macro_helpers.rs",
            "status": "added",
            "additions": 62,
            "deletions": 0,
            "changes": 62,
            "blob_url": "https://github.com/vercel/next.js/blob/3a323194341a6554147d832cf6bca26e7140bd49/turbopack%2Fcrates%2Fturbo-bincode%2Fsrc%2Fmacro_helpers.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3a323194341a6554147d832cf6bca26e7140bd49/turbopack%2Fcrates%2Fturbo-bincode%2Fsrc%2Fmacro_helpers.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-bincode%2Fsrc%2Fmacro_helpers.rs?ref=3a323194341a6554147d832cf6bca26e7140bd49",
            "patch": "@@ -0,0 +1,62 @@\n+use std::{any::type_name, mem::transmute};\n+\n+pub use bincode;\n+use bincode::{\n+    de::Decoder,\n+    enc::Encoder,\n+    error::{DecodeError, EncodeError},\n+};\n+\n+use crate::{TurboBincodeDecode, TurboBincodeDecoder, TurboBincodeEncode, TurboBincodeEncoder};\n+\n+#[track_caller]\n+pub fn encode_for_turbo_bincode_encode_impl<'a, T: TurboBincodeEncode, E: Encoder>(\n+    value: &T,\n+    encoder: &'a mut E,\n+) -> Result<(), EncodeError> {\n+    let encoder = if unty::type_equal::<E, TurboBincodeEncoder>() {\n+        // SAFETY: Transmute is safe because `&mut E` is `&mut TurboBincodeEncoder`:\n+        // - `unty::type_equal::<E, TurboBincodeEncoder>()` does not check lifetimes, but does check\n+        //   the type and layout, so we know those are correct.\n+        // - The transmuted encoder cannot escape this function, and we know that the lifetime of\n+        //   `'a` is at least as long as the function.\n+        // - Lifetimes don't change layout. This is not strictly guaranteed, but if this assumption\n+        //   is broken, we'd have a different type id (type ids are derived from layout\n+        //   information), `type_equal` would return `false`, and we'd panic instead of violating\n+        //   memory safety.\n+        // - Two mutable references have the same layout and alignment when they reference exactly\n+        //   the same type.\n+        // - The explicit lifetime ('a) avoids creating an implitly unbounded lifetime.\n+        unsafe { transmute::<&'a mut E, &'a mut TurboBincodeEncoder>(encoder) }\n+    } else {\n+        unreachable!(\n+            \"{} implements TurboBincodeEncode, but was called with a {} encoder implementation\",\n+            type_name::<T>(),\n+            type_name::<E>(),\n+        )\n+    };\n+    TurboBincodeEncode::encode(value, encoder)\n+}\n+\n+#[track_caller]\n+pub fn decode_for_turbo_bincode_decode_impl<\n+    'a,\n+    Context,\n+    T: TurboBincodeDecode<Context>,\n+    D: Decoder<Context = Context>,\n+>(\n+    decoder: &'a mut D,\n+) -> Result<T, DecodeError> {\n+    let decoder = if unty::type_equal::<D, TurboBincodeDecoder>() {\n+        // SAFETY: See notes on the `Encode::encode` implementation on\n+        // `encode_for_turbo_bincode_encode_impl`.\n+        unsafe { transmute::<&'a mut D, &'a mut TurboBincodeDecoder<'a>>(decoder) }\n+    } else {\n+        unreachable!(\n+            \"{} implements TurboBincodeDecode, but was called with a {} decoder implementation\",\n+            type_name::<T>(),\n+            type_name::<D>(),\n+        )\n+    };\n+    TurboBincodeDecode::decode(decoder)\n+}"
        }
    ],
    "stats": {
        "total": 119,
        "additions": 119,
        "deletions": 0
    }
}