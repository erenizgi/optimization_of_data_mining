{
    "author": "kdy1",
    "message": "refactor(turbopack): Use `FileSystemPath` instead of `Vc<T>` (#80634)\n\n### What?\n\nMake `FileSystemPath` usable without `Vc<T>`.\n\n### Why?\n\nString concatenation does not require caching.\n\n### How?\nCloses PACK-4468",
    "sha": "b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
    "files": [
        {
            "sha": "2557bd7b639cd0757d7e8e7311968badcc040deb",
            "filename": "crates/napi/src/next_api/project.rs",
            "status": "modified",
            "additions": 19,
            "deletions": 9,
            "changes": 28,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -441,9 +441,12 @@ pub async fn project_new(\n \n     let tasks_ref = turbo_tasks.clone();\n     turbo_tasks.spawn_once_task(async move {\n-        benchmark_file_io(tasks_ref, container.project().node_root())\n-            .await\n-            .inspect_err(|err| tracing::warn!(%err, \"failed to benchmark file IO\"))\n+        benchmark_file_io(\n+            tasks_ref,\n+            container.project().node_root().await?.clone_value(),\n+        )\n+        .await\n+        .inspect_err(|err| tracing::warn!(%err, \"failed to benchmark file IO\"))\n     });\n     Ok(External::new_with_size_hint(\n         ProjectInstance {\n@@ -494,7 +497,7 @@ impl CompilationEvent for SlowFilesystemEvent {\n #[tracing::instrument(skip(turbo_tasks))]\n async fn benchmark_file_io(\n     turbo_tasks: NextTurboTasks,\n-    directory: Vc<FileSystemPath>,\n+    directory: FileSystemPath,\n ) -> Result<Vc<Completion>> {\n     // try to get the real file path on disk so that we can use it with tokio\n     let fs = Vc::try_resolve_downcast_type::<DiskFileSystem>(directory.fs())\n@@ -1403,12 +1406,13 @@ pub async fn get_source_map_rope(\n         return Ok(OptionStringifiedSourceMap::none());\n     };\n \n-    let server_path = container.project().node_root().join(chunk_base.into());\n+    let server_path = container.project().node_root().await?.join(chunk_base)?;\n \n     let client_path = container\n         .project()\n         .client_relative_path()\n-        .join(chunk_base.into());\n+        .await?\n+        .join(chunk_base)?;\n \n     let mut map = container.get_source_map(server_path, module.clone());\n \n@@ -1476,8 +1480,12 @@ pub async fn project_trace_source_operation(\n         }\n     };\n \n-    let project_root_uri =\n-        uri_from_file(container.project().project_root_path(), None).await? + \"/\";\n+    let project_root_uri = uri_from_file(\n+        container.project().project_root_path().await?.clone_value(),\n+        None,\n+    )\n+    .await?\n+        + \"/\";\n     let (file, original_file, is_internal) =\n         if let Some(source_file) = original_file.strip_prefix(&project_root_uri) {\n             // Client code uses file://\n@@ -1563,9 +1571,11 @@ pub async fn project_get_source_for_asset(\n                 .container\n                 .project()\n                 .project_path()\n+                .await?\n                 .fs()\n                 .root()\n-                .join(file_path.clone())\n+                .await?\n+                .join(&file_path)?\n                 .read()\n                 .await?;\n "
        },
        {
            "sha": "2a996d7ed6130d2a2f3f5901172f76bf92019eaa",
            "filename": "crates/next-api/src/app.rs",
            "status": "modified",
            "additions": 137,
            "deletions": 115,
            "changes": 252,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-api%2Fsrc%2Fapp.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-api%2Fsrc%2Fapp.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fapp.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -91,7 +91,7 @@ use crate::{\n #[turbo_tasks::value]\n pub struct AppProject {\n     project: ResolvedVc<Project>,\n-    app_dir: ResolvedVc<FileSystemPath>,\n+    app_dir: FileSystemPath,\n }\n \n #[turbo_tasks::value(transparent)]\n@@ -138,7 +138,7 @@ impl AppProject {\n #[turbo_tasks::value_impl]\n impl AppProject {\n     #[turbo_tasks::function]\n-    pub fn new(project: ResolvedVc<Project>, app_dir: ResolvedVc<FileSystemPath>) -> Vc<Self> {\n+    pub fn new(project: ResolvedVc<Project>, app_dir: FileSystemPath) -> Vc<Self> {\n         AppProject { project, app_dir }.cell()\n     }\n \n@@ -149,13 +149,13 @@ impl AppProject {\n \n     #[turbo_tasks::function]\n     fn app_dir(&self) -> Vc<FileSystemPath> {\n-        *self.app_dir\n+        self.app_dir.clone().cell()\n     }\n \n     #[turbo_tasks::function]\n     fn client_ty(&self) -> Vc<ClientContextType> {\n         ClientContextType::App {\n-            app_dir: self.app_dir,\n+            app_dir: self.app_dir.clone(),\n         }\n         .cell()\n     }\n@@ -164,7 +164,7 @@ impl AppProject {\n     async fn rsc_ty(self: Vc<Self>) -> Result<Vc<ServerContextType>> {\n         let this = self.await?;\n         Ok(ServerContextType::AppRSC {\n-            app_dir: this.app_dir,\n+            app_dir: this.app_dir.clone(),\n             client_transition: Some(ResolvedVc::upcast(\n                 self.client_transition().to_resolved().await?,\n             )),\n@@ -177,7 +177,7 @@ impl AppProject {\n     async fn route_ty(self: Vc<Self>) -> Result<Vc<ServerContextType>> {\n         let this = self.await?;\n         Ok(ServerContextType::AppRoute {\n-            app_dir: this.app_dir,\n+            app_dir: this.app_dir.clone(),\n             ecmascript_client_reference_transition_name: Some(Self::client_transition_name()),\n         }\n         .cell())\n@@ -186,7 +186,7 @@ impl AppProject {\n     #[turbo_tasks::function]\n     fn ssr_ty(&self) -> Vc<ServerContextType> {\n         ServerContextType::AppSSR {\n-            app_dir: self.app_dir,\n+            app_dir: self.app_dir.clone(),\n         }\n         .cell()\n     }\n@@ -195,7 +195,7 @@ impl AppProject {\n     fn app_entrypoints(&self) -> Vc<AppEntrypoints> {\n         let conf = self.project.next_config();\n         get_entrypoints(\n-            *self.app_dir,\n+            self.app_dir.clone(),\n             conf.page_extensions(),\n             conf.is_global_not_found_enabled(),\n         )\n@@ -204,7 +204,7 @@ impl AppProject {\n     #[turbo_tasks::function]\n     async fn client_module_options_context(self: Vc<Self>) -> Result<Vc<ModuleOptionsContext>> {\n         Ok(get_client_module_options_context(\n-            self.project().project_path(),\n+            self.project().project_path().await?.clone_value(),\n             self.project().execution_context(),\n             self.project().client_compile_time_info().environment(),\n             self.client_ty().owned().await?,\n@@ -218,7 +218,7 @@ impl AppProject {\n     #[turbo_tasks::function]\n     async fn client_resolve_options_context(self: Vc<Self>) -> Result<Vc<ResolveOptionsContext>> {\n         Ok(get_client_resolve_options_context(\n-            self.project().project_path(),\n+            self.project().project_path().await?.clone_value(),\n             self.client_ty().owned().await?,\n             self.project().next_mode(),\n             self.project().next_config(),\n@@ -235,7 +235,7 @@ impl AppProject {\n     #[turbo_tasks::function]\n     async fn rsc_module_options_context(self: Vc<Self>) -> Result<Vc<ModuleOptionsContext>> {\n         Ok(get_server_module_options_context(\n-            self.project().project_path(),\n+            self.project().project_path().await?.clone_value(),\n             self.project().execution_context(),\n             self.rsc_ty().owned().await?,\n             self.project().next_mode(),\n@@ -249,7 +249,7 @@ impl AppProject {\n     #[turbo_tasks::function]\n     async fn edge_rsc_module_options_context(self: Vc<Self>) -> Result<Vc<ModuleOptionsContext>> {\n         Ok(get_server_module_options_context(\n-            self.project().project_path(),\n+            self.project().project_path().await?.clone_value(),\n             self.project().execution_context(),\n             self.rsc_ty().owned().await?,\n             self.project().next_mode(),\n@@ -263,7 +263,7 @@ impl AppProject {\n     #[turbo_tasks::function]\n     async fn route_module_options_context(self: Vc<Self>) -> Result<Vc<ModuleOptionsContext>> {\n         Ok(get_server_module_options_context(\n-            self.project().project_path(),\n+            self.project().project_path().await?.clone_value(),\n             self.project().execution_context(),\n             self.route_ty().owned().await?,\n             self.project().next_mode(),\n@@ -277,7 +277,7 @@ impl AppProject {\n     #[turbo_tasks::function]\n     async fn edge_route_module_options_context(self: Vc<Self>) -> Result<Vc<ModuleOptionsContext>> {\n         Ok(get_server_module_options_context(\n-            self.project().project_path(),\n+            self.project().project_path().await?.clone_value(),\n             self.project().execution_context(),\n             self.route_ty().owned().await?,\n             self.project().next_mode(),\n@@ -291,7 +291,7 @@ impl AppProject {\n     #[turbo_tasks::function]\n     async fn rsc_resolve_options_context(self: Vc<Self>) -> Result<Vc<ResolveOptionsContext>> {\n         Ok(get_server_resolve_options_context(\n-            self.project().project_path(),\n+            self.project().project_path().await?.clone_value(),\n             self.rsc_ty().owned().await?,\n             self.project().next_mode(),\n             self.project().next_config(),\n@@ -302,7 +302,7 @@ impl AppProject {\n     #[turbo_tasks::function]\n     async fn edge_rsc_resolve_options_context(self: Vc<Self>) -> Result<Vc<ResolveOptionsContext>> {\n         Ok(get_edge_resolve_options_context(\n-            self.project().project_path(),\n+            self.project().project_path().await?.clone_value(),\n             self.rsc_ty().owned().await?,\n             self.project().next_mode(),\n             self.project().next_config(),\n@@ -313,7 +313,7 @@ impl AppProject {\n     #[turbo_tasks::function]\n     async fn route_resolve_options_context(self: Vc<Self>) -> Result<Vc<ResolveOptionsContext>> {\n         Ok(get_server_resolve_options_context(\n-            self.project().project_path(),\n+            self.project().project_path().await?.clone_value(),\n             self.route_ty().owned().await?,\n             self.project().next_mode(),\n             self.project().next_config(),\n@@ -326,7 +326,7 @@ impl AppProject {\n         self: Vc<Self>,\n     ) -> Result<Vc<ResolveOptionsContext>> {\n         Ok(get_edge_resolve_options_context(\n-            self.project().project_path(),\n+            self.project().project_path().await?.clone_value(),\n             self.route_ty().owned().await?,\n             self.project().next_mode(),\n             self.project().next_config(),\n@@ -595,7 +595,7 @@ impl AppProject {\n     #[turbo_tasks::function]\n     async fn ssr_module_options_context(self: Vc<Self>) -> Result<Vc<ModuleOptionsContext>> {\n         Ok(get_server_module_options_context(\n-            self.project().project_path(),\n+            self.project().project_path().await?.clone_value(),\n             self.project().execution_context(),\n             self.ssr_ty().owned().await?,\n             self.project().next_mode(),\n@@ -609,7 +609,7 @@ impl AppProject {\n     #[turbo_tasks::function]\n     async fn edge_ssr_module_options_context(self: Vc<Self>) -> Result<Vc<ModuleOptionsContext>> {\n         Ok(get_server_module_options_context(\n-            self.project().project_path(),\n+            self.project().project_path().await?.clone_value(),\n             self.project().execution_context(),\n             self.ssr_ty().owned().await?,\n             self.project().next_mode(),\n@@ -623,7 +623,7 @@ impl AppProject {\n     #[turbo_tasks::function]\n     async fn ssr_resolve_options_context(self: Vc<Self>) -> Result<Vc<ResolveOptionsContext>> {\n         Ok(get_server_resolve_options_context(\n-            self.project().project_path(),\n+            self.project().project_path().await?.clone_value(),\n             self.ssr_ty().owned().await?,\n             self.project().next_mode(),\n             self.project().next_config(),\n@@ -634,7 +634,7 @@ impl AppProject {\n     #[turbo_tasks::function]\n     async fn edge_ssr_resolve_options_context(self: Vc<Self>) -> Result<Vc<ResolveOptionsContext>> {\n         Ok(get_edge_resolve_options_context(\n-            self.project().project_path(),\n+            self.project().project_path().await?.clone_value(),\n             self.ssr_ty().owned().await?,\n             self.project().next_mode(),\n             self.project().next_config(),\n@@ -798,7 +798,7 @@ impl AppProject {\n     #[turbo_tasks::function]\n     async fn client_runtime_entries(self: Vc<Self>) -> Result<Vc<EvaluatableAssets>> {\n         Ok(get_client_runtime_entries(\n-            self.project().project_path(),\n+            self.project().project_path().await?.clone_value(),\n             self.client_ty().owned().await?,\n             self.project().next_mode(),\n             self.project().next_config(),\n@@ -836,7 +836,7 @@ impl AppProject {\n         let client_main_module = cjs_resolve(\n             Vc::upcast(PlainResolveOrigin::new(\n                 client_module_context,\n-                self.project().project_path().join(rcstr!(\"_\")),\n+                self.project().project_path().await?.join(\"_\")?,\n             )),\n             Request::parse(Pattern::Constant(rcstr!(\n                 \"next/dist/client/app-next-turbopack.js\"\n@@ -916,8 +916,7 @@ impl AppProject {\n                             should_trace,\n                         );\n                         graphs.push(graph);\n-                        let is_layout =\n-                            module.server_path().file_stem().await?.as_deref() == Some(\"layout\");\n+                        let is_layout = module.server_path().await?.file_stem() == Some(\"layout\");\n                         visited_modules = if is_layout {\n                             // Only propagate the visited_modules of the parent layout(s), not\n                             // across siblings such as loading.js and\n@@ -1048,14 +1047,14 @@ enum AppPageEndpointType {\n     Rsc,\n }\n \n-#[derive(Copy, Clone, Serialize, Deserialize, PartialEq, Eq, Debug, TraceRawVcs, NonLocalValue)]\n+#[derive(Clone, Serialize, Deserialize, PartialEq, Eq, Debug, TraceRawVcs, NonLocalValue)]\n enum AppEndpointType {\n     Page {\n         ty: AppPageEndpointType,\n         loader_tree: ResolvedVc<AppPageLoaderTree>,\n     },\n     Route {\n-        path: ResolvedVc<FileSystemPath>,\n+        path: FileSystemPath,\n         root_layouts: ResolvedVc<FileSystemPathVec>,\n     },\n     Metadata {\n@@ -1073,21 +1072,25 @@ struct AppEndpoint {\n #[turbo_tasks::value_impl]\n impl AppEndpoint {\n     #[turbo_tasks::function]\n-    fn app_page_entry(&self, loader_tree: Vc<AppPageLoaderTree>) -> Vc<AppEntry> {\n-        get_app_page_entry(\n+    async fn app_page_entry(&self, loader_tree: Vc<AppPageLoaderTree>) -> Result<Vc<AppEntry>> {\n+        Ok(get_app_page_entry(\n             self.app_project.rsc_module_context(),\n             self.app_project.edge_rsc_module_context(),\n             loader_tree,\n             self.page.clone(),\n-            self.app_project.project().project_path(),\n+            self.app_project\n+                .project()\n+                .project_path()\n+                .await?\n+                .clone_value(),\n             self.app_project.project().next_config(),\n-        )\n+        ))\n     }\n \n     #[turbo_tasks::function]\n     async fn app_route_entry(\n         &self,\n-        path: Vc<FileSystemPath>,\n+        path: FileSystemPath,\n         root_layouts: Vc<FileSystemPathVec>,\n         next_config: Vc<NextConfig>,\n     ) -> Result<Vc<AppEntry>> {\n@@ -1098,7 +1101,7 @@ impl AppEndpoint {\n             let mut config = NextSegmentConfig::default();\n \n             for layout in root_layouts.iter().rev() {\n-                let source = Vc::upcast(FileSource::new(**layout));\n+                let source = Vc::upcast(FileSource::new(layout.clone()));\n                 let layout_config = parse_segment_config_from_source(source);\n                 config.apply_parent_config(&*layout_config.await?);\n             }\n@@ -1111,7 +1114,11 @@ impl AppEndpoint {\n             self.app_project.edge_route_module_context(),\n             Vc::upcast(FileSource::new(path)),\n             self.page.clone(),\n-            self.app_project.project().project_path(),\n+            self.app_project\n+                .project()\n+                .project_path()\n+                .await?\n+                .clone_value(),\n             config,\n             next_config,\n         ))\n@@ -1126,7 +1133,11 @@ impl AppEndpoint {\n         Ok(get_app_metadata_route_entry(\n             self.app_project.rsc_module_context(),\n             self.app_project.edge_rsc_module_context(),\n-            self.app_project.project().project_path(),\n+            self.app_project\n+                .project()\n+                .project_path()\n+                .await?\n+                .clone_value(),\n             self.page.clone(),\n             *self.app_project.project().next_mode().await?,\n             metadata,\n@@ -1139,13 +1150,13 @@ impl AppEndpoint {\n         let this = self.await?;\n \n         let next_config = self.await?.app_project.project().next_config();\n-        let app_entry = match this.ty {\n-            AppEndpointType::Page { loader_tree, .. } => self.app_page_entry(*loader_tree),\n+        let app_entry = match &this.ty {\n+            AppEndpointType::Page { loader_tree, .. } => self.app_page_entry(**loader_tree),\n             AppEndpointType::Route { path, root_layouts } => {\n-                self.app_route_entry(*path, *root_layouts, next_config)\n+                self.app_route_entry(path.clone(), **root_layouts, next_config)\n             }\n             AppEndpointType::Metadata { metadata } => {\n-                self.app_metadata_entry(metadata, next_config)\n+                self.app_metadata_entry(metadata.clone(), next_config)\n             }\n         };\n \n@@ -1168,7 +1179,7 @@ impl AppEndpoint {\n             /// All manifests: `Minimal` plus client-references, next-dynamic, ...\n             Full,\n         }\n-        let (process_client_assets, process_ssr, emit_manifests) = match this.ty {\n+        let (process_client_assets, process_ssr, emit_manifests) = match &this.ty {\n             AppEndpointType::Page { ty, .. } => (\n                 true,\n                 matches!(ty, AppPageEndpointType::Html),\n@@ -1190,9 +1201,9 @@ impl AppEndpoint {\n             ),\n         };\n \n-        let node_root = project.node_root().to_resolved().await?;\n-        let client_relative_path = project.client_relative_path().to_resolved().await?;\n-        let server_path = node_root.join(rcstr!(\"server\"));\n+        let node_root = project.node_root().await?.clone_value();\n+        let client_relative_path = project.client_relative_path().await?.clone_value();\n+        let server_path = node_root.join(\"server\")?;\n \n         let mut server_assets = fxindexset![];\n         let mut client_assets = fxindexset![];\n@@ -1231,7 +1242,7 @@ impl AppEndpoint {\n         };\n \n         let client_shared_chunk_group = get_app_client_shared_chunk_group(\n-            AssetIdent::from_path(project.project_path())\n+            AssetIdent::from_path(project.project_path().await?.clone_value())\n                 .with_modifier(rcstr!(\"client-shared-chunks\")),\n             this.app_project.client_runtime_entries(),\n             *module_graphs.full,\n@@ -1317,10 +1328,10 @@ impl AppEndpoint {\n             };\n             let app_build_manifest_output = app_build_manifest\n                 .build_output(\n-                    node_root.join(\n-                        format!(\"server/app{manifest_path_prefix}/app-build-manifest.json\",).into(),\n-                    ),\n-                    *client_relative_path,\n+                    node_root.join(&format!(\n+                        \"server/app{manifest_path_prefix}/app-build-manifest.json\",\n+                    ))?,\n+                    client_relative_path.clone(),\n                 )\n                 .await?\n                 .to_resolved()\n@@ -1331,14 +1342,19 @@ impl AppEndpoint {\n \n         // polyfill-nomodule.js is a pre-compiled asset distributed as part of next,\n         // load it as a RawModule.\n-        let next_package = get_next_package(project.project_path());\n+        let next_package = get_next_package(project.project_path().await?.clone_value())\n+            .await?\n+            .clone_value();\n         let polyfill_source =\n-            FileSource::new(next_package.join(rcstr!(\"dist/build/polyfills/polyfill-nomodule.js\")));\n-        let polyfill_output_path = client_chunking_context.chunk_path(\n-            Some(Vc::upcast(polyfill_source)),\n-            polyfill_source.ident(),\n-            rcstr!(\".js\"),\n-        );\n+            FileSource::new(next_package.join(\"dist/build/polyfills/polyfill-nomodule.js\")?);\n+        let polyfill_output_path = client_chunking_context\n+            .chunk_path(\n+                Some(Vc::upcast(polyfill_source)),\n+                polyfill_source.ident(),\n+                rcstr!(\".js\"),\n+            )\n+            .await?\n+            .clone_value();\n         let polyfill_output_asset = ResolvedVc::upcast(\n             RawOutput::new(polyfill_output_path, Vc::upcast(polyfill_source))\n                 .to_resolved()\n@@ -1356,9 +1372,9 @@ impl AppEndpoint {\n                 let webpack_stats =\n                     generate_webpack_stats(app_entry.original_name.clone(), &client_assets).await?;\n                 let stats_output = VirtualOutputAsset::new(\n-                    node_root.join(\n-                        format!(\"server/app{manifest_path_prefix}/webpack-stats.json\",).into(),\n-                    ),\n+                    node_root.join(&format!(\n+                        \"server/app{manifest_path_prefix}/webpack-stats.json\",\n+                    ))?,\n                     AssetContent::file(\n                         File::from(serde_json::to_string_pretty(&webpack_stats)?).into(),\n                     ),\n@@ -1376,10 +1392,10 @@ impl AppEndpoint {\n             let build_manifest_output = ResolvedVc::upcast(\n                 build_manifest\n                     .build_output(\n-                        node_root.join(\n-                            format!(\"server/app{manifest_path_prefix}/build-manifest.json\",).into(),\n-                        ),\n-                        *client_relative_path,\n+                        node_root.join(&format!(\n+                            \"server/app{manifest_path_prefix}/build-manifest.json\",\n+                        ))?,\n+                        client_relative_path.clone(),\n                     )\n                     .await?\n                     .to_resolved()\n@@ -1413,8 +1429,8 @@ impl AppEndpoint {\n \n         let server_action_manifest = create_server_actions_manifest(\n             actions,\n-            project.project_path(),\n-            *node_root,\n+            project.project_path().await?.clone_value(),\n+            node_root.clone(),\n             app_entry.original_name.clone(),\n             runtime,\n             match runtime {\n@@ -1437,7 +1453,7 @@ impl AppEndpoint {\n             .app_entry_chunks(\n                 *client_references,\n                 *server_action_manifest_loader,\n-                server_path,\n+                server_path.clone(),\n                 process_client_assets,\n                 *module_graphs.full,\n             )\n@@ -1456,8 +1472,8 @@ impl AppEndpoint {\n         if emit_manifests == EmitManifests::Full {\n             let entry_manifest =\n                 ClientReferenceManifest::build_output(ClientReferenceManifestOptions {\n-                    node_root,\n-                    client_relative_path,\n+                    node_root: node_root.clone(),\n+                    client_relative_path: client_relative_path.clone(),\n                     entry_name: app_entry.original_name.clone(),\n                     client_references,\n                     client_references_chunks,\n@@ -1477,9 +1493,9 @@ impl AppEndpoint {\n             client_reference_manifest = Some(entry_manifest);\n \n             let next_font_manifest_output = create_font_manifest(\n-                project.client_root(),\n-                *node_root,\n-                this.app_project.app_dir(),\n+                project.client_root().await?.clone_value(),\n+                node_root.clone(),\n+                this.app_project.app_dir().await?.clone_value(),\n                 &app_entry.original_name,\n                 &app_entry.original_name,\n                 &app_entry.original_name,\n@@ -1504,7 +1520,7 @@ impl AppEndpoint {\n                 ];\n                 let mut wasm_paths_from_root = fxindexset![];\n \n-                let node_root_value = node_root.await?;\n+                let node_root_value = node_root.clone();\n \n                 file_paths_from_root\n                     .extend(get_js_paths_from_root(&node_root_value, &middleware_assets).await?);\n@@ -1536,14 +1552,11 @@ impl AppEndpoint {\n \n                     let loadable_manifest_output = create_react_loadable_manifest(\n                         *dynamic_import_entries,\n-                        *client_relative_path,\n-                        node_root.join(\n-                            format!(\n-                                \"server/app{}/react-loadable-manifest\",\n-                                &app_entry.original_name\n-                            )\n-                            .into(),\n-                        ),\n+                        client_relative_path.clone(),\n+                        node_root.join(&format!(\n+                            \"server/app{}/react-loadable-manifest\",\n+                            &app_entry.original_name\n+                        ))?,\n                         NextRuntime::Edge,\n                     )\n                     .await?;\n@@ -1585,12 +1598,9 @@ impl AppEndpoint {\n                     let manifest_path_prefix = &app_entry.original_name;\n                     let middleware_manifest_v2 = ResolvedVc::upcast(\n                         VirtualOutputAsset::new(\n-                            node_root.join(\n-                                format!(\n-                                    \"server/app{manifest_path_prefix}/middleware-manifest.json\",\n-                                )\n-                                .into(),\n-                            ),\n+                            node_root.join(&format!(\n+                                \"server/app{manifest_path_prefix}/middleware-manifest.json\",\n+                            ))?,\n                             AssetContent::file(\n                                 FileContent::Content(File::from(serde_json::to_string_pretty(\n                                     &middleware_manifest_v2,\n@@ -1605,9 +1615,12 @@ impl AppEndpoint {\n                 }\n                 if emit_manifests != EmitManifests::None {\n                     // create app paths manifest\n-                    let app_paths_manifest_output =\n-                        create_app_paths_manifest(*node_root, &app_entry.original_name, entry_file)\n-                            .await?;\n+                    let app_paths_manifest_output = create_app_paths_manifest(\n+                        node_root.clone(),\n+                        &app_entry.original_name,\n+                        entry_file,\n+                    )\n+                    .await?;\n                     server_assets.insert(app_paths_manifest_output);\n                 }\n \n@@ -1626,10 +1639,9 @@ impl AppEndpoint {\n                 if emit_manifests != EmitManifests::None {\n                     // create app paths manifest\n                     let app_paths_manifest_output = create_app_paths_manifest(\n-                        *node_root,\n+                        node_root.clone(),\n                         &app_entry.original_name,\n                         server_path\n-                            .await?\n                             .get_path_to(&*rsc_chunk.path().await?)\n                             .context(\n                                 \"RSC chunk path should be within app paths manifest directory\",\n@@ -1654,14 +1666,11 @@ impl AppEndpoint {\n \n                     let loadable_manifest_output = create_react_loadable_manifest(\n                         *dynamic_import_entries,\n-                        *client_relative_path,\n-                        node_root.join(\n-                            format!(\n-                                \"server/app{}/react-loadable-manifest\",\n-                                &app_entry.original_name\n-                            )\n-                            .into(),\n-                        ),\n+                        client_relative_path.clone(),\n+                        node_root.join(&format!(\n+                            \"server/app{}/react-loadable-manifest\",\n+                            &app_entry.original_name\n+                        ))?,\n                         NextRuntime::NodeJs,\n                     )\n                     .await?;\n@@ -1716,7 +1725,7 @@ impl AppEndpoint {\n         self: Vc<Self>,\n         client_references: Vc<ClientReferenceGraphResult>,\n         server_action_manifest_loader: ResolvedVc<Box<dyn EvaluatableAsset>>,\n-        server_path: Vc<FileSystemPath>,\n+        server_path: FileSystemPath,\n         process_client_assets: bool,\n         module_graph: Vc<ModuleGraph>,\n     ) -> Result<Vc<OutputAssets>> {\n@@ -1788,8 +1797,14 @@ impl AppEndpoint {\n                             .await?;\n                         let chunk_group = chunking_context\n                             .chunk_group(\n-                                AssetIdent::from_path(this.app_project.project().project_path())\n-                                    .with_modifier(rcstr!(\"server-utils\")),\n+                                AssetIdent::from_path(\n+                                    this.app_project\n+                                        .project()\n+                                        .project_path()\n+                                        .await?\n+                                        .clone_value(),\n+                                )\n+                                .with_modifier(rcstr!(\"server-utils\")),\n                                 // TODO this should be ChunkGroup::Shared\n                                 ChunkGroup::Entry(server_utils),\n                                 module_graph,\n@@ -1850,13 +1865,10 @@ impl AppEndpoint {\n                     anyhow::Ok(Vc::cell(vec![\n                         chunking_context\n                             .entry_chunk_group_asset(\n-                                server_path.join(\n-                                    format!(\n-                                        \"app{original_name}.js\",\n-                                        original_name = app_entry.original_name\n-                                    )\n-                                    .into(),\n-                                ),\n+                                server_path.join(&format!(\n+                                    \"app{original_name}.js\",\n+                                    original_name = app_entry.original_name\n+                                ))?,\n                                 Vc::cell(evaluatable_assets),\n                                 module_graph,\n                                 current_chunks,\n@@ -1874,13 +1886,14 @@ impl AppEndpoint {\n }\n \n async fn create_app_paths_manifest(\n-    node_root: Vc<FileSystemPath>,\n+    node_root: FileSystemPath,\n     original_name: &str,\n     filename: RcStr,\n ) -> Result<ResolvedVc<Box<dyn OutputAsset>>> {\n     let manifest_path_prefix = original_name;\n-    let path =\n-        node_root.join(format!(\"server/app{manifest_path_prefix}/app-paths-manifest.json\",).into());\n+    let path = node_root.join(&format!(\n+        \"server/app{manifest_path_prefix}/app-paths-manifest.json\",\n+    ))?;\n     let app_paths_manifest = AppPathsManifest {\n         node_server_app_paths: PagesManifest {\n             pages: [(original_name.into(), filename)].into_iter().collect(),\n@@ -1939,10 +1952,15 @@ impl Endpoint for AppEndpoint {\n                 .await?\n                 .is_development()\n             {\n-                let node_root = this.app_project.project().node_root();\n+                let node_root = this.app_project.project().node_root().await?.clone_value();\n                 let server_paths = all_server_paths(output_assets, node_root).owned().await?;\n \n-                let client_relative_root = this.app_project.project().client_relative_path();\n+                let client_relative_root = this\n+                    .app_project\n+                    .project()\n+                    .client_relative_path()\n+                    .await?\n+                    .clone_value();\n                 let client_paths = all_paths_in_root(output_assets, client_relative_root)\n                     .owned()\n                     .instrument(tracing::info_span!(\"client_paths\"))\n@@ -2040,7 +2058,11 @@ impl Endpoint for AppEndpoint {\n \n         let server_actions_loader = ResolvedVc::upcast(\n             build_server_actions_loader(\n-                this.app_project.project().project_path(),\n+                this.app_project\n+                    .project()\n+                    .project_path()\n+                    .await?\n+                    .clone_value(),\n                 app_entry.original_name.clone(),\n                 actions,\n                 match runtime {"
        },
        {
            "sha": "cb7a0b34577c3b15929e3054268179d53ea7abe1",
            "filename": "crates/next-api/src/font.rs",
            "status": "modified",
            "additions": 16,
            "deletions": 13,
            "changes": 29,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-api%2Fsrc%2Ffont.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-api%2Fsrc%2Ffont.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Ffont.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -1,7 +1,7 @@\n use anyhow::Result;\n use next_core::{all_assets_from_entries, next_manifests::NextFontManifest};\n use turbo_rcstr::RcStr;\n-use turbo_tasks::{ResolvedVc, ValueToString, Vc};\n+use turbo_tasks::{ResolvedVc, Vc};\n use turbo_tasks_fs::{File, FileSystemPath};\n use turbopack_core::{\n     asset::AssetContent,\n@@ -12,9 +12,9 @@ use turbopack_core::{\n use crate::paths::get_font_paths_from_root;\n \n pub(crate) async fn create_font_manifest(\n-    client_root: Vc<FileSystemPath>,\n-    node_root: Vc<FileSystemPath>,\n-    dir: Vc<FileSystemPath>,\n+    client_root: FileSystemPath,\n+    node_root: FileSystemPath,\n+    dir: FileSystemPath,\n     original_name: &str,\n     manifest_path_prefix: &str,\n     pathname: &str,\n@@ -25,17 +25,20 @@ pub(crate) async fn create_font_manifest(\n \n     // `_next` gets added again later, so we \"strip\" it here via\n     // `get_font_paths_from_root`.\n-    let font_paths: Vec<String> =\n-        get_font_paths_from_root(&*client_root.await?, &all_client_output_assets)\n-            .await?\n-            .iter()\n-            .filter_map(|p| p.split(\"_next/\").last().map(|f| f.to_string()))\n-            .collect();\n+    let font_paths: Vec<String> = get_font_paths_from_root(&client_root, &all_client_output_assets)\n+        .await?\n+        .iter()\n+        .filter_map(|p| p.split(\"_next/\").last().map(|f| f.to_string()))\n+        .collect();\n \n     let path = if app_dir {\n-        node_root.join(format!(\"server/app{manifest_path_prefix}/next-font-manifest.json\",).into())\n+        node_root.join(&format!(\n+            \"server/app{manifest_path_prefix}/next-font-manifest.json\",\n+        ))?\n     } else {\n-        node_root.join(format!(\"server/pages{manifest_path_prefix}/next-font-manifest.json\").into())\n+        node_root.join(&format!(\n+            \"server/pages{manifest_path_prefix}/next-font-manifest.json\",\n+        ))?\n     };\n \n     let has_fonts = !font_paths.is_empty();\n@@ -50,7 +53,7 @@ pub(crate) async fn create_font_manifest(\n     let next_font_manifest = if !has_fonts {\n         Default::default()\n     } else if app_dir {\n-        let dir_str = dir.to_string().await?;\n+        let dir_str = dir.value_to_string().await?;\n         let page_path = format!(\"{dir_str}{original_name}\").into();\n \n         NextFontManifest {"
        },
        {
            "sha": "d90e013102aef8c412198560d1579289ba4d45d4",
            "filename": "crates/next-api/src/instrumentation.rs",
            "status": "modified",
            "additions": 11,
            "deletions": 10,
            "changes": 21,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-api%2Fsrc%2Finstrumentation.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-api%2Fsrc%2Finstrumentation.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Finstrumentation.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -43,7 +43,7 @@ pub struct InstrumentationEndpoint {\n     source: ResolvedVc<Box<dyn Source>>,\n     is_edge: bool,\n \n-    app_dir: Option<ResolvedVc<FileSystemPath>>,\n+    app_dir: Option<FileSystemPath>,\n     ecmascript_client_reference_transition_name: Option<RcStr>,\n }\n \n@@ -55,7 +55,7 @@ impl InstrumentationEndpoint {\n         asset_context: ResolvedVc<Box<dyn AssetContext>>,\n         source: ResolvedVc<Box<dyn Source>>,\n         is_edge: bool,\n-        app_dir: Option<ResolvedVc<FileSystemPath>>,\n+        app_dir: Option<FileSystemPath>,\n         ecmascript_client_reference_transition_name: Option<RcStr>,\n     ) -> Vc<Self> {\n         Self {\n@@ -83,7 +83,7 @@ impl InstrumentationEndpoint {\n \n         let edge_entry_module = wrap_edge_entry(\n             *self.asset_context,\n-            self.project.project_path(),\n+            self.project.project_path().await?.clone_value(),\n             *userland_module,\n             rcstr!(\"instrumentation\"),\n         )\n@@ -106,7 +106,7 @@ impl InstrumentationEndpoint {\n \n         let evaluatable_assets = get_server_runtime_entries(\n             ServerContextType::Instrumentation {\n-                app_dir: this.app_dir,\n+                app_dir: this.app_dir.clone(),\n                 ecmascript_client_reference_transition_name: this\n                     .ecmascript_client_reference_transition_name\n                     .clone(),\n@@ -148,10 +148,11 @@ impl InstrumentationEndpoint {\n             .entry_chunk_group(\n                 this.project\n                     .node_root()\n-                    .join(rcstr!(\"server/instrumentation.js\")),\n+                    .await?\n+                    .join(\"server/instrumentation.js\")?,\n                 get_server_runtime_entries(\n                     ServerContextType::Instrumentation {\n-                        app_dir: this.app_dir,\n+                        app_dir: this.app_dir.clone(),\n                         ecmascript_client_reference_transition_name: this\n                             .ecmascript_client_reference_transition_name\n                             .clone(),\n@@ -176,8 +177,8 @@ impl InstrumentationEndpoint {\n             let edge_files = self.edge_files();\n             let mut output_assets = edge_files.owned().await?;\n \n-            let node_root = this.project.node_root();\n-            let node_root_value = node_root.await?;\n+            let node_root = this.project.node_root().await?.clone_value();\n+            let node_root_value = node_root.clone();\n \n             let file_paths_from_root =\n                 get_js_paths_from_root(&node_root_value, &output_assets).await?;\n@@ -198,7 +199,7 @@ impl InstrumentationEndpoint {\n                 ..Default::default()\n             };\n             let middleware_manifest_v2 = VirtualOutputAsset::new(\n-                node_root.join(rcstr!(\"server/instrumentation/middleware-manifest.json\")),\n+                node_root.join(\"server/instrumentation/middleware-manifest.json\")?,\n                 AssetContent::file(\n                     FileContent::Content(File::from(serde_json::to_string_pretty(\n                         &middleware_manifest_v2,\n@@ -242,7 +243,7 @@ impl Endpoint for InstrumentationEndpoint {\n             let output_assets = self.output_assets();\n \n             let server_paths = if this.project.next_mode().await?.is_development() {\n-                let node_root = this.project.node_root();\n+                let node_root = this.project.node_root().await?.clone_value();\n                 all_server_paths(output_assets, node_root).owned().await?\n             } else {\n                 vec![]"
        },
        {
            "sha": "cbf51d331a1c949502b57e79d2a229323c5883e1",
            "filename": "crates/next-api/src/loadable_manifest.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-api%2Fsrc%2Floadable_manifest.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-api%2Fsrc%2Floadable_manifest.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Floadable_manifest.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -15,8 +15,8 @@ use crate::dynamic_imports::DynamicImportedChunks;\n #[turbo_tasks::function]\n pub async fn create_react_loadable_manifest(\n     dynamic_import_entries: Vc<DynamicImportedChunks>,\n-    client_relative_path: Vc<FileSystemPath>,\n-    output_path: Vc<FileSystemPath>,\n+    client_relative_path: FileSystemPath,\n+    output_path: FileSystemPath,\n     runtime: NextRuntime,\n ) -> Result<Vc<OutputAssets>> {\n     let dynamic_import_entries = &*dynamic_import_entries.await?;\n@@ -28,7 +28,7 @@ pub async fn create_react_loadable_manifest(\n \n         let id = &*module_id.await?;\n \n-        let client_relative_path_value = client_relative_path.await?;\n+        let client_relative_path_value = client_relative_path.clone();\n         let files = chunk_output\n             .iter()\n             .map(move |&file| {\n@@ -55,7 +55,7 @@ pub async fn create_react_loadable_manifest(\n     Ok(Vc::cell(match runtime {\n         NextRuntime::NodeJs => vec![ResolvedVc::upcast(\n             VirtualOutputAsset::new(\n-                output_path.with_extension(\"json\".into()),\n+                output_path.with_extension(\"json\"),\n                 AssetContent::file(FileContent::Content(File::from(manifest_json)).cell()),\n             )\n             .to_resolved()\n@@ -64,7 +64,7 @@ pub async fn create_react_loadable_manifest(\n         NextRuntime::Edge => vec![\n             ResolvedVc::upcast(\n                 VirtualOutputAsset::new(\n-                    output_path.with_extension(\"js\".into()),\n+                    output_path.with_extension(\"js\"),\n                     AssetContent::file(\n                         FileContent::Content(File::from(format!(\n                             \"self.__REACT_LOADABLE_MANIFEST={};\",\n@@ -78,7 +78,7 @@ pub async fn create_react_loadable_manifest(\n             ),\n             ResolvedVc::upcast(\n                 VirtualOutputAsset::new(\n-                    output_path.with_extension(\"json\".into()),\n+                    output_path.with_extension(\"json\"),\n                     AssetContent::file(FileContent::Content(File::from(manifest_json)).cell()),\n                 )\n                 .to_resolved()"
        },
        {
            "sha": "3271d8638ee03a35f22f3f2289b715a2ee4456f4",
            "filename": "crates/next-api/src/middleware.rs",
            "status": "modified",
            "additions": 15,
            "deletions": 13,
            "changes": 28,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-api%2Fsrc%2Fmiddleware.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-api%2Fsrc%2Fmiddleware.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fmiddleware.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -46,7 +46,7 @@ pub struct MiddlewareEndpoint {\n     project: ResolvedVc<Project>,\n     asset_context: ResolvedVc<Box<dyn AssetContext>>,\n     source: ResolvedVc<Box<dyn Source>>,\n-    app_dir: Option<ResolvedVc<FileSystemPath>>,\n+    app_dir: Option<FileSystemPath>,\n     ecmascript_client_reference_transition_name: Option<RcStr>,\n }\n \n@@ -57,7 +57,7 @@ impl MiddlewareEndpoint {\n         project: ResolvedVc<Project>,\n         asset_context: ResolvedVc<Box<dyn AssetContext>>,\n         source: ResolvedVc<Box<dyn Source>>,\n-        app_dir: Option<ResolvedVc<FileSystemPath>>,\n+        app_dir: Option<FileSystemPath>,\n         ecmascript_client_reference_transition_name: Option<RcStr>,\n     ) -> Vc<Self> {\n         Self {\n@@ -82,7 +82,7 @@ impl MiddlewareEndpoint {\n \n         let module = get_middleware_module(\n             *self.asset_context,\n-            self.project.project_path(),\n+            self.project.project_path().await?.clone_value(),\n             userland_module,\n         );\n \n@@ -93,7 +93,7 @@ impl MiddlewareEndpoint {\n         }\n         Ok(wrap_edge_entry(\n             *self.asset_context,\n-            self.project.project_path(),\n+            self.project.project_path().await?.clone_value(),\n             module,\n             rcstr!(\"middleware\"),\n         ))\n@@ -108,7 +108,7 @@ impl MiddlewareEndpoint {\n \n         let evaluatable_assets = get_server_runtime_entries(\n             ServerContextType::Middleware {\n-                app_dir: this.app_dir,\n+                app_dir: this.app_dir.clone(),\n                 ecmascript_client_reference_transition_name: this\n                     .ecmascript_client_reference_transition_name\n                     .clone(),\n@@ -149,10 +149,11 @@ impl MiddlewareEndpoint {\n             .entry_chunk_group(\n                 this.project\n                     .node_root()\n-                    .join(rcstr!(\"server/middleware.js\")),\n+                    .await?\n+                    .join(\"server/middleware.js\")?,\n                 get_server_runtime_entries(\n                     ServerContextType::Middleware {\n-                        app_dir: this.app_dir,\n+                        app_dir: this.app_dir.clone(),\n                         ecmascript_client_reference_transition_name: this\n                             .ecmascript_client_reference_transition_name\n                             .clone(),\n@@ -260,7 +261,8 @@ impl MiddlewareEndpoint {\n             let middleware_manifest_v2 = VirtualOutputAsset::new(\n                 this.project\n                     .node_root()\n-                    .join(rcstr!(\"server/middleware/middleware-manifest.json\")),\n+                    .await?\n+                    .join(\"server/middleware/middleware-manifest.json\")?,\n                 AssetContent::file(\n                     FileContent::Content(File::from(serde_json::to_string_pretty(\n                         &middleware_manifest_v2,\n@@ -277,8 +279,8 @@ impl MiddlewareEndpoint {\n             let edge_files = self.edge_files();\n             let mut output_assets = edge_files.owned().await?;\n \n-            let node_root = this.project.node_root();\n-            let node_root_value = node_root.await?;\n+            let node_root = this.project.node_root().await?.clone_value();\n+            let node_root_value = node_root.clone();\n \n             let file_paths_from_root =\n                 get_js_paths_from_root(&node_root_value, &output_assets).await?;\n@@ -320,7 +322,7 @@ impl MiddlewareEndpoint {\n                 ..Default::default()\n             };\n             let middleware_manifest_v2 = VirtualOutputAsset::new(\n-                node_root.join(rcstr!(\"server/middleware/middleware-manifest.json\")),\n+                node_root.join(\"server/middleware/middleware-manifest.json\")?,\n                 AssetContent::file(\n                     FileContent::Content(File::from(serde_json::to_string_pretty(\n                         &middleware_manifest_v2,\n@@ -357,11 +359,11 @@ impl Endpoint for MiddlewareEndpoint {\n             let output_assets = self.output_assets();\n \n             let (server_paths, client_paths) = if this.project.next_mode().await?.is_development() {\n-                let node_root = this.project.node_root();\n+                let node_root = this.project.node_root().await?.clone_value();\n                 let server_paths = all_server_paths(output_assets, node_root).owned().await?;\n \n                 // Middleware could in theory have a client path (e.g. `new URL`).\n-                let client_relative_root = this.project.client_relative_path();\n+                let client_relative_root = this.project.client_relative_path().await?.clone_value();\n                 let client_paths = all_paths_in_root(output_assets, client_relative_root)\n                     .into_future()\n                     .owned()"
        },
        {
            "sha": "7b040b78f78512c3c195b5a4d8b7b4ba93eb94b0",
            "filename": "crates/next-api/src/module_graph.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 7,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-api%2Fsrc%2Fmodule_graph.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-api%2Fsrc%2Fmodule_graph.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fmodule_graph.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -440,14 +440,13 @@ impl Issue for CssGlobalImportIssue {\n \n     #[turbo_tasks::function]\n     async fn description(&self) -> Result<Vc<OptionStyledString>> {\n-        let parent_path = &self.parent_module.ident().path();\n-        let module_path = &self.module.ident().path();\n-        let relative_import_location = parent_path.parent().await?;\n+        let parent_path = self.parent_module.ident().path().await?.clone_value();\n+        let module_path = self.module.ident().path().await?.clone_value();\n+        let relative_import_location = parent_path.parent();\n \n-        let import_path = match relative_import_location.get_relative_path_to(&*module_path.await?)\n-        {\n+        let import_path = match relative_import_location.get_relative_path_to(&module_path) {\n             Some(path) => path,\n-            None => module_path.await?.path.clone(),\n+            None => module_path.path.clone(),\n         };\n         let cleaned_import_path =\n             if import_path.ends_with(\".scss.css\") || import_path.ends_with(\".sass.css\") {\n@@ -458,7 +457,7 @@ impl Issue for CssGlobalImportIssue {\n \n         Ok(Vc::cell(Some(\n             StyledString::Stack(vec![\n-                StyledString::Text(format!(\"Location: {}\", parent_path.await?.path).into()),\n+                StyledString::Text(format!(\"Location: {}\", parent_path.path).into()),\n                 StyledString::Text(format!(\"Import path: {cleaned_import_path}\",).into()),\n             ])\n             .resolved_cell(),"
        },
        {
            "sha": "e8bcaa221b2c14fe77b1f1f47068bd54644e119d",
            "filename": "crates/next-api/src/nft_json.rs",
            "status": "modified",
            "additions": 11,
            "deletions": 10,
            "changes": 21,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-api%2Fsrc%2Fnft_json.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-api%2Fsrc%2Fnft_json.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fnft_json.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -60,7 +60,9 @@ impl OutputAsset for NftJsonAsset {\n         Ok(path\n             .fs\n             .root()\n-            .join(format!(\"{}.nft.json\", path.path).into()))\n+            .await?\n+            .join(&format!(\"{}.nft.json\", path.path))?\n+            .cell())\n     }\n }\n \n@@ -100,7 +102,7 @@ fn get_output_specifier(\n \n /// Apply outputFileTracingIncludes patterns to find additional files\n async fn apply_includes(\n-    project_root_path: Vc<FileSystemPath>,\n+    project_root_path: FileSystemPath,\n     glob: Vc<Glob>,\n     ident_folder: &FileSystemPath,\n ) -> Result<BTreeSet<RcStr>> {\n@@ -118,9 +120,9 @@ async fn apply_includes(\n                 continue;\n             };\n \n-            let file_path_ref = file_path.await?;\n+            let file_path_ref = file_path;\n             // Convert to relative path from ident_folder to the file\n-            if let Some(relative_path) = ident_folder.get_relative_path_to(&file_path_ref) {\n+            if let Some(relative_path) = ident_folder.get_relative_path_to(file_path_ref) {\n                 result.insert(relative_path);\n             }\n         }\n@@ -150,14 +152,13 @@ impl Asset for NftJsonAsset {\n \n         let client_root = this.project.client_fs().root();\n         let client_root_ref = client_root.await?;\n-        let project_root_path = this.project.project_root_path(); // Example: [project]\n+        let project_root_path = this.project.project_root_path().await?.clone_value(); // Example: [project]\n \n         // Example: [output]/apps/my-website/.next/server/app -- without the `.nft.json`\n-        let ident_folder = self.path().parent().await?;\n+        let ident_folder = self.path().await?.parent();\n         // Example: [project]/apps/my-website/.next/server/app -- without the `.nft.json`\n-        let ident_folder_in_project_fs = project_root_path\n-            .join(ident_folder.path.clone()) // apps/my-website/.next/server/app\n-            .await?;\n+        // apps/my-website/.next/server/app\n+        let ident_folder_in_project_fs = project_root_path.join(&ident_folder.path)?;\n \n         let chunk = this.chunk;\n         let entries = this\n@@ -244,7 +245,7 @@ impl Asset for NftJsonAsset {\n         // Apply outputFileTracingIncludes and outputFileTracingExcludes\n         // Extract route from chunk path for pattern matching\n         if let Some(route) = &this.page_name {\n-            let project_path = this.project.project_path();\n+            let project_path = this.project.project_path().await?.clone_value();\n             let mut combined_includes = BTreeSet::new();\n \n             // Process includes"
        },
        {
            "sha": "b93490666d10fbe2f793c3750f7a9492a9af2528",
            "filename": "crates/next-api/src/pages.rs",
            "status": "modified",
            "additions": 154,
            "deletions": 85,
            "changes": 239,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-api%2Fsrc%2Fpages.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-api%2Fsrc%2Fpages.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fpages.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -119,9 +119,9 @@ impl PagesProject {\n                 next_router_path,\n                 original_path,\n                 ..\n-            } = *page.await?;\n-            let pathname: RcStr = format!(\"/{}\", next_router_path.await?.path).into();\n-            let original_name = format!(\"/{}\", original_path.await?.path).into();\n+            } = &*page.await?;\n+            let pathname: RcStr = format!(\"/{}\", next_router_path.path).into();\n+            let original_name = format!(\"/{}\", original_path.path).into();\n             let route = make_route(pathname.clone(), original_name, page).await?;\n             routes.insert(pathname, route);\n             Ok(())\n@@ -224,9 +224,9 @@ impl PagesProject {\n             next_router_path,\n             original_path,\n             ..\n-        } = *item.await?;\n-        let pathname: RcStr = format!(\"/{}\", next_router_path.await?.path).into();\n-        let original_name = format!(\"/{}\", original_path.await?.path).into();\n+        } = &*item.await?;\n+        let pathname: RcStr = format!(\"/{}\", next_router_path.path).into();\n+        let original_name = format!(\"/{}\", original_path.path).into();\n         let endpoint = Vc::upcast(PageEndpoint::new(\n             ty,\n             self,\n@@ -262,22 +262,22 @@ impl PagesProject {\n     }\n \n     #[turbo_tasks::function]\n-    fn pages_structure(&self) -> Vc<PagesStructure> {\n+    async fn pages_structure(&self) -> Result<Vc<PagesStructure>> {\n         let next_router_fs = Vc::upcast::<Box<dyn FileSystem>>(VirtualFileSystem::new());\n-        let next_router_root = next_router_fs.root();\n-        find_pages_structure(\n-            self.project.project_path(),\n+        let next_router_root = next_router_fs.root().await?.clone_value();\n+        Ok(find_pages_structure(\n+            self.project.project_path().await?.clone_value(),\n             next_router_root,\n             self.project.next_config().page_extensions(),\n-        )\n+        ))\n     }\n \n     #[turbo_tasks::function]\n     async fn pages_dir(self: Vc<Self>) -> Result<Vc<FileSystemPath>> {\n         Ok(if let Some(pages) = self.pages_structure().await?.pages {\n             pages.project_path()\n         } else {\n-            self.project().project_path().join(rcstr!(\"pages\"))\n+            self.project().project_path().await?.join(\"pages\")?.cell()\n         })\n     }\n \n@@ -333,11 +333,11 @@ impl PagesProject {\n     #[turbo_tasks::function]\n     async fn client_module_options_context(self: Vc<Self>) -> Result<Vc<ModuleOptionsContext>> {\n         Ok(get_client_module_options_context(\n-            self.project().project_path(),\n+            self.project().project_path().await?.clone_value(),\n             self.project().execution_context(),\n             self.project().client_compile_time_info().environment(),\n             ClientContextType::Pages {\n-                pages_dir: self.pages_dir().to_resolved().await?,\n+                pages_dir: self.pages_dir().await?.clone_value(),\n             },\n             self.project().next_mode(),\n             self.project().next_config(),\n@@ -349,9 +349,9 @@ impl PagesProject {\n     #[turbo_tasks::function]\n     async fn client_resolve_options_context(self: Vc<Self>) -> Result<Vc<ResolveOptionsContext>> {\n         Ok(get_client_resolve_options_context(\n-            self.project().project_path(),\n+            self.project().project_path().await?.clone_value(),\n             ClientContextType::Pages {\n-                pages_dir: self.pages_dir().to_resolved().await?,\n+                pages_dir: self.pages_dir().await?.clone_value(),\n             },\n             self.project().next_mode(),\n             self.project().next_config(),\n@@ -441,10 +441,10 @@ impl PagesProject {\n     #[turbo_tasks::function]\n     async fn ssr_module_options_context(self: Vc<Self>) -> Result<Vc<ModuleOptionsContext>> {\n         Ok(get_server_module_options_context(\n-            self.project().project_path(),\n+            self.project().project_path().await?.clone_value(),\n             self.project().execution_context(),\n             ServerContextType::Pages {\n-                pages_dir: self.pages_dir().to_resolved().await?,\n+                pages_dir: self.pages_dir().await?.clone_value(),\n             },\n             self.project().next_mode(),\n             self.project().next_config(),\n@@ -457,10 +457,10 @@ impl PagesProject {\n     #[turbo_tasks::function]\n     async fn edge_ssr_module_options_context(self: Vc<Self>) -> Result<Vc<ModuleOptionsContext>> {\n         Ok(get_server_module_options_context(\n-            self.project().project_path(),\n+            self.project().project_path().await?.clone_value(),\n             self.project().execution_context(),\n             ServerContextType::Pages {\n-                pages_dir: self.pages_dir().to_resolved().await?,\n+                pages_dir: self.pages_dir().await?.clone_value(),\n             },\n             self.project().next_mode(),\n             self.project().next_config(),\n@@ -473,10 +473,10 @@ impl PagesProject {\n     #[turbo_tasks::function]\n     async fn api_module_options_context(self: Vc<Self>) -> Result<Vc<ModuleOptionsContext>> {\n         Ok(get_server_module_options_context(\n-            self.project().project_path(),\n+            self.project().project_path().await?.clone_value(),\n             self.project().execution_context(),\n             ServerContextType::PagesApi {\n-                pages_dir: self.pages_dir().to_resolved().await?,\n+                pages_dir: self.pages_dir().await?.clone_value(),\n             },\n             self.project().next_mode(),\n             self.project().next_config(),\n@@ -489,10 +489,10 @@ impl PagesProject {\n     #[turbo_tasks::function]\n     async fn edge_api_module_options_context(self: Vc<Self>) -> Result<Vc<ModuleOptionsContext>> {\n         Ok(get_server_module_options_context(\n-            self.project().project_path(),\n+            self.project().project_path().await?.clone_value(),\n             self.project().execution_context(),\n             ServerContextType::PagesApi {\n-                pages_dir: self.pages_dir().to_resolved().await?,\n+                pages_dir: self.pages_dir().await?.clone_value(),\n             },\n             self.project().next_mode(),\n             self.project().next_config(),\n@@ -505,10 +505,10 @@ impl PagesProject {\n     #[turbo_tasks::function]\n     async fn ssr_data_module_options_context(self: Vc<Self>) -> Result<Vc<ModuleOptionsContext>> {\n         Ok(get_server_module_options_context(\n-            self.project().project_path(),\n+            self.project().project_path().await?.clone_value(),\n             self.project().execution_context(),\n             ServerContextType::PagesData {\n-                pages_dir: self.pages_dir().to_resolved().await?,\n+                pages_dir: self.pages_dir().await?.clone_value(),\n             },\n             self.project().next_mode(),\n             self.project().next_config(),\n@@ -523,10 +523,10 @@ impl PagesProject {\n         self: Vc<Self>,\n     ) -> Result<Vc<ModuleOptionsContext>> {\n         Ok(get_server_module_options_context(\n-            self.project().project_path(),\n+            self.project().project_path().await?.clone_value(),\n             self.project().execution_context(),\n             ServerContextType::PagesData {\n-                pages_dir: self.pages_dir().to_resolved().await?,\n+                pages_dir: self.pages_dir().await?.clone_value(),\n             },\n             self.project().next_mode(),\n             self.project().next_config(),\n@@ -539,12 +539,12 @@ impl PagesProject {\n     #[turbo_tasks::function]\n     async fn ssr_resolve_options_context(self: Vc<Self>) -> Result<Vc<ResolveOptionsContext>> {\n         Ok(get_server_resolve_options_context(\n-            self.project().project_path(),\n+            self.project().project_path().await?.clone_value(),\n             // NOTE(alexkirsz) This could be `PagesData` for the data endpoint, but it doesn't\n             // matter (for now at least) because `get_server_resolve_options_context` doesn't\n             // differentiate between the two.\n             ServerContextType::Pages {\n-                pages_dir: self.pages_dir().to_resolved().await?,\n+                pages_dir: self.pages_dir().await?.clone_value(),\n             },\n             self.project().next_mode(),\n             self.project().next_config(),\n@@ -555,12 +555,12 @@ impl PagesProject {\n     #[turbo_tasks::function]\n     async fn edge_ssr_resolve_options_context(self: Vc<Self>) -> Result<Vc<ResolveOptionsContext>> {\n         Ok(get_edge_resolve_options_context(\n-            self.project().project_path(),\n+            self.project().project_path().await?.clone_value(),\n             // NOTE(alexkirsz) This could be `PagesData` for the data endpoint, but it doesn't\n             // matter (for now at least) because `get_server_resolve_options_context` doesn't\n             // differentiate between the two.\n             ServerContextType::Pages {\n-                pages_dir: self.pages_dir().to_resolved().await?,\n+                pages_dir: self.pages_dir().await?.clone_value(),\n             },\n             self.project().next_mode(),\n             self.project().next_config(),\n@@ -571,9 +571,9 @@ impl PagesProject {\n     #[turbo_tasks::function]\n     async fn client_runtime_entries(self: Vc<Self>) -> Result<Vc<EvaluatableAssets>> {\n         let client_runtime_entries = get_client_runtime_entries(\n-            self.project().project_path(),\n+            self.project().project_path().await?.clone_value(),\n             ClientContextType::Pages {\n-                pages_dir: self.pages_dir().to_resolved().await?,\n+                pages_dir: self.pages_dir().await?.clone_value(),\n             },\n             self.project().next_mode(),\n             self.project().next_config(),\n@@ -586,7 +586,7 @@ impl PagesProject {\n     async fn runtime_entries(self: Vc<Self>) -> Result<Vc<RuntimeEntries>> {\n         Ok(get_server_runtime_entries(\n             ServerContextType::Pages {\n-                pages_dir: self.pages_dir().to_resolved().await?,\n+                pages_dir: self.pages_dir().await?.clone_value(),\n             },\n             self.project().next_mode(),\n         ))\n@@ -596,7 +596,7 @@ impl PagesProject {\n     async fn data_runtime_entries(self: Vc<Self>) -> Result<Vc<RuntimeEntries>> {\n         Ok(get_server_runtime_entries(\n             ServerContextType::PagesData {\n-                pages_dir: self.pages_dir().to_resolved().await?,\n+                pages_dir: self.pages_dir().await?.clone_value(),\n             },\n             self.project().next_mode(),\n         ))\n@@ -633,7 +633,7 @@ impl PagesProject {\n         let client_main_module = esm_resolve(\n             Vc::upcast(PlainResolveOrigin::new(\n                 client_module_context,\n-                self.project().project_path().join(rcstr!(\"_\")),\n+                self.project().project_path().await?.join(\"_\")?,\n             )),\n             Request::parse(Pattern::Constant(\n                 match *self.project().next_mode().await? {\n@@ -726,8 +726,10 @@ impl PageEndpoint {\n     }\n \n     #[turbo_tasks::function]\n-    fn source(&self) -> Vc<Box<dyn Source>> {\n-        Vc::upcast(FileSource::new(self.page.file_path()))\n+    async fn source(&self) -> Result<Vc<Box<dyn Source>>> {\n+        Ok(Vc::upcast(FileSource::new(\n+            self.page.file_path().await?.clone_value(),\n+        )))\n     }\n \n     #[turbo_tasks::function]\n@@ -744,7 +746,7 @@ impl PageEndpoint {\n         ) && let Some(chunkable) = Vc::try_resolve_downcast(page_loader).await?\n         {\n             return Ok(Vc::upcast(HmrEntryModule::new(\n-                AssetIdent::from_path(*this.page.await?.base_path),\n+                AssetIdent::from_path(this.page.await?.base_path.clone()),\n                 chunkable,\n             )));\n         }\n@@ -844,7 +846,7 @@ impl PageEndpoint {\n                 .map(|m| ResolvedVc::upcast(*m))\n                 .collect();\n             let client_chunk_group = client_chunking_context.evaluated_chunk_group(\n-                AssetIdent::from_path(*this.page.await?.base_path),\n+                AssetIdent::from_path(this.page.await?.base_path.clone()),\n                 ChunkGroup::Entry(evaluatable_assets),\n                 module_graph,\n                 AvailabilityInfo::Root,\n@@ -863,7 +865,7 @@ impl PageEndpoint {\n     ) -> Result<Vc<Box<dyn OutputAsset>>> {\n         let this = self.await?;\n         let project = this.pages_project.project();\n-        let node_root = project.client_root();\n+        let node_root = project.client_root().await?.clone_value();\n         let client_relative_path = self.client_relative_path();\n         let page_loader = PageLoaderAsset::new(\n             node_root,\n@@ -881,19 +883,31 @@ impl PageEndpoint {\n         let (reference_type, project_root, module_context, edge_module_context) = match this.ty {\n             PageEndpointType::Html | PageEndpointType::SsrOnly => (\n                 ReferenceType::Entry(EntryReferenceSubType::Page),\n-                this.pages_project.project().project_path(),\n+                this.pages_project\n+                    .project()\n+                    .project_path()\n+                    .await?\n+                    .clone_value(),\n                 this.pages_project.ssr_module_context(),\n                 this.pages_project.edge_ssr_module_context(),\n             ),\n             PageEndpointType::Data => (\n                 ReferenceType::Entry(EntryReferenceSubType::Page),\n-                this.pages_project.project().project_path(),\n+                this.pages_project\n+                    .project()\n+                    .project_path()\n+                    .await?\n+                    .clone_value(),\n                 this.pages_project.ssr_data_module_context(),\n                 this.pages_project.edge_ssr_data_module_context(),\n             ),\n             PageEndpointType::Api => (\n                 ReferenceType::Entry(EntryReferenceSubType::PagesApi),\n-                this.pages_project.project().project_path(),\n+                this.pages_project\n+                    .project()\n+                    .project_path()\n+                    .await?\n+                    .clone_value(),\n                 this.pages_project.api_module_context(),\n                 this.pages_project.edge_api_module_context(),\n             ),\n@@ -969,7 +983,7 @@ impl PageEndpoint {\n     async fn internal_ssr_chunk(\n         self: Vc<Self>,\n         ty: SsrChunkType,\n-        node_path: Vc<FileSystemPath>,\n+        node_path: FileSystemPath,\n         node_chunking_context: Vc<NodeJsChunkingContext>,\n         edge_chunking_context: Vc<Box<dyn ChunkingContext>>,\n         runtime_entries: Vc<EvaluatableAssets>,\n@@ -1015,7 +1029,12 @@ impl PageEndpoint {\n                         .client_module_context()\n                         .process(\n                             Vc::upcast(FileSource::new(\n-                                this.pages_structure.await?.app.file_path(),\n+                                this.pages_structure\n+                                    .await?\n+                                    .app\n+                                    .file_path()\n+                                    .await?\n+                                    .clone_value(),\n                             )),\n                             ReferenceType::Entry(EntryReferenceSubType::Page),\n                         )\n@@ -1114,8 +1133,8 @@ impl PageEndpoint {\n \n                 let asset_path = get_asset_path_from_pathname(pathname, \".js\");\n \n-                let ssr_entry_chunk_path_string: RcStr = format!(\"pages{asset_path}\").into();\n-                let ssr_entry_chunk_path = node_path.join(ssr_entry_chunk_path_string);\n+                let ssr_entry_chunk_path_string = format!(\"pages{asset_path}\");\n+                let ssr_entry_chunk_path = node_path.join(&ssr_entry_chunk_path_string)?;\n                 let ssr_entry_chunk = node_chunking_context\n                     .entry_chunk_group_asset(\n                         ssr_entry_chunk_path,\n@@ -1180,7 +1199,8 @@ impl PageEndpoint {\n             this.pages_project\n                 .project()\n                 .node_root()\n-                .join(rcstr!(\"server\")),\n+                .await?\n+                .join(\"server\")?,\n             project.server_chunking_context(true),\n             project.edge_chunking_context(true),\n             this.pages_project.ssr_runtime_entries(),\n@@ -1196,7 +1216,8 @@ impl PageEndpoint {\n             this.pages_project\n                 .project()\n                 .node_root()\n-                .join(rcstr!(\"server/data\")),\n+                .await?\n+                .join(\"server/data\")?,\n             this.pages_project.project().server_chunking_context(true),\n             this.pages_project.project().edge_chunking_context(true),\n             this.pages_project.ssr_data_runtime_entries(),\n@@ -1212,7 +1233,8 @@ impl PageEndpoint {\n             this.pages_project\n                 .project()\n                 .node_root()\n-                .join(rcstr!(\"server\")),\n+                .await?\n+                .join(\"server\")?,\n             this.pages_project.project().server_chunking_context(false),\n             this.pages_project.project().edge_chunking_context(false),\n             this.pages_project.ssr_runtime_entries(),\n@@ -1225,12 +1247,11 @@ impl PageEndpoint {\n         &self,\n         entry_chunk: Vc<Box<dyn OutputAsset>>,\n     ) -> Result<Vc<Box<dyn OutputAsset>>> {\n-        let node_root = self.pages_project.project().node_root();\n+        let node_root = self.pages_project.project().node_root().await?;\n         let chunk_path = entry_chunk.path().await?;\n \n         let asset_path = node_root\n-            .join(rcstr!(\"server\"))\n-            .await?\n+            .join(\"server\")?\n             .get_path_to(&chunk_path)\n             .context(\"ssr chunk entry path must be inside the node root\")?;\n \n@@ -1241,27 +1262,39 @@ impl PageEndpoint {\n         };\n         let manifest_path_prefix = get_asset_prefix_from_pathname(&self.pathname);\n         let asset = Vc::upcast(VirtualOutputAsset::new(\n-            node_root\n-                .join(format!(\"server/pages{manifest_path_prefix}/pages-manifest.json\",).into()),\n+            node_root.join(&format!(\n+                \"server/pages{manifest_path_prefix}/pages-manifest.json\",\n+            ))?,\n             AssetContent::file(File::from(serde_json::to_string_pretty(&pages_manifest)?).into()),\n         ));\n         Ok(asset)\n     }\n \n     #[turbo_tasks::function]\n-    fn react_loadable_manifest(\n+    async fn react_loadable_manifest(\n         &self,\n         dynamic_import_entries: Vc<DynamicImportedChunks>,\n         runtime: NextRuntime,\n     ) -> Result<Vc<OutputAssets>> {\n-        let node_root = self.pages_project.project().node_root();\n-        let client_relative_path = self.pages_project.project().client_relative_path();\n+        let node_root = self\n+            .pages_project\n+            .project()\n+            .node_root()\n+            .await?\n+            .clone_value();\n+        let client_relative_path = self\n+            .pages_project\n+            .project()\n+            .client_relative_path()\n+            .await?\n+            .clone_value();\n         let loadable_path_prefix = get_asset_prefix_from_pathname(&self.pathname);\n         Ok(create_react_loadable_manifest(\n             dynamic_import_entries,\n             client_relative_path,\n-            node_root\n-                .join(format!(\"server/pages{loadable_path_prefix}/react-loadable-manifest\").into()),\n+            node_root.join(&format!(\n+                \"server/pages{loadable_path_prefix}/react-loadable-manifest\",\n+            ))?,\n             runtime,\n         ))\n     }\n@@ -1271,8 +1304,18 @@ impl PageEndpoint {\n         &self,\n         client_chunks: ResolvedVc<OutputAssets>,\n     ) -> Result<Vc<Box<dyn OutputAsset>>> {\n-        let node_root = self.pages_project.project().node_root();\n-        let client_relative_path = self.pages_project.project().client_relative_path();\n+        let node_root = self\n+            .pages_project\n+            .project()\n+            .node_root()\n+            .await?\n+            .clone_value();\n+        let client_relative_path = self\n+            .pages_project\n+            .project()\n+            .client_relative_path()\n+            .await?\n+            .clone_value();\n         let build_manifest = BuildManifest {\n             pages: fxindexmap!(self.pathname.clone() => client_chunks),\n             ..Default::default()\n@@ -1281,9 +1324,9 @@ impl PageEndpoint {\n         Ok(Vc::upcast(\n             build_manifest\n                 .build_output(\n-                    node_root.join(\n-                        format!(\"server/pages{manifest_path_prefix}/build-manifest.json\",).into(),\n-                    ),\n+                    node_root.join(&format!(\n+                        \"server/pages{manifest_path_prefix}/build-manifest.json\",\n+                    ))?,\n                     client_relative_path,\n                 )\n                 .await?,\n@@ -1319,11 +1362,20 @@ impl PageEndpoint {\n         let client_assets = OutputAssets::new(client_assets).to_resolved().await?;\n \n         let manifest_path_prefix = get_asset_prefix_from_pathname(pathname);\n-        let node_root = this.pages_project.project().node_root();\n+        let node_root = this\n+            .pages_project\n+            .project()\n+            .node_root()\n+            .await?\n+            .clone_value();\n         let next_font_manifest_output = create_font_manifest(\n-            this.pages_project.project().client_root(),\n-            node_root,\n-            this.pages_project.pages_dir(),\n+            this.pages_project\n+                .project()\n+                .client_root()\n+                .await?\n+                .clone_value(),\n+            node_root.clone(),\n+            this.pages_project.pages_dir().await?.clone_value(),\n             original_name,\n             &manifest_path_prefix,\n             pathname,\n@@ -1342,8 +1394,9 @@ impl PageEndpoint {\n             let webpack_stats =\n                 generate_webpack_stats(original_name.to_owned(), &client_assets.await?).await?;\n             let stats_output = VirtualOutputAsset::new(\n-                node_root\n-                    .join(format!(\"server/pages{manifest_path_prefix}/webpack-stats.json\",).into()),\n+                node_root.join(&format!(\n+                    \"server/pages{manifest_path_prefix}/webpack-stats.json\",\n+                ))?,\n                 AssetContent::file(\n                     File::from(serde_json::to_string_pretty(&webpack_stats)?).into(),\n                 ),\n@@ -1384,7 +1437,12 @@ impl PageEndpoint {\n                 dynamic_import_entries,\n                 ref regions,\n             } => {\n-                let node_root = this.pages_project.project().node_root();\n+                let node_root = this\n+                    .pages_project\n+                    .project()\n+                    .node_root()\n+                    .await?\n+                    .clone_value();\n                 if emit_manifests {\n                     let files_value = files.await?;\n                     if let Some(&file) = files_value.first() {\n@@ -1409,7 +1467,7 @@ impl PageEndpoint {\n                     ];\n                     let mut wasm_paths_from_root = fxindexset![];\n \n-                    let node_root_value = node_root.await?;\n+                    let node_root_value = node_root.clone();\n \n                     file_paths_from_root.extend(\n                         get_js_paths_from_root(&node_root_value, &loadable_manifest_output).await?,\n@@ -1464,10 +1522,9 @@ impl PageEndpoint {\n                     };\n                     let manifest_path_prefix = get_asset_prefix_from_pathname(&this.pathname);\n                     let middleware_manifest_v2 = VirtualOutputAsset::new(\n-                        node_root.join(\n-                            format!(\"server/pages{manifest_path_prefix}/middleware-manifest.json\")\n-                                .into(),\n-                        ),\n+                        node_root.join(&format!(\n+                            \"server/pages{manifest_path_prefix}/middleware-manifest.json\",\n+                        ))?,\n                         AssetContent::file(\n                             FileContent::Content(File::from(serde_json::to_string_pretty(\n                                 &middleware_manifest_v2,\n@@ -1497,8 +1554,8 @@ impl PageEndpoint {\n             self.pages_project\n                 .project()\n                 .client_relative_path()\n-                .to_resolved()\n-                .await?,\n+                .await?\n+                .clone_value(),\n         )))\n     }\n }\n@@ -1538,7 +1595,12 @@ impl Endpoint for PageEndpoint {\n             let output = self.output().await?;\n             let output_assets = self.output().output_assets();\n \n-            let node_root = this.pages_project.project().node_root();\n+            let node_root = this\n+                .pages_project\n+                .project()\n+                .node_root()\n+                .await?\n+                .clone_value();\n \n             let (server_paths, client_paths) = if this\n                 .pages_project\n@@ -1547,9 +1609,16 @@ impl Endpoint for PageEndpoint {\n                 .await?\n                 .is_development()\n             {\n-                let server_paths = all_server_paths(output_assets, node_root).owned().await?;\n+                let server_paths = all_server_paths(output_assets, node_root.clone())\n+                    .owned()\n+                    .await?;\n \n-                let client_relative_root = this.pages_project.project().client_relative_path();\n+                let client_relative_root = this\n+                    .pages_project\n+                    .project()\n+                    .client_relative_path()\n+                    .await?\n+                    .clone_value();\n                 let client_paths = all_paths_in_root(output_assets, client_relative_root)\n                     .owned()\n                     .instrument(tracing::info_span!(\"client_paths\"))\n@@ -1559,7 +1628,7 @@ impl Endpoint for PageEndpoint {\n                 (vec![], vec![])\n             };\n \n-            let node_root = &node_root.await?;\n+            let node_root = node_root.clone();\n             let written_endpoint = match *output {\n                 PageEndpointOutput::NodeJs { entry_chunk, .. } => EndpointOutputPaths::NodeJs {\n                     server_entry_path: node_root"
        },
        {
            "sha": "57de70566d8eea1782f8671c1f0cf0d09f25261b",
            "filename": "crates/next-api/src/paths.rs",
            "status": "modified",
            "additions": 23,
            "deletions": 20,
            "changes": 43,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-api%2Fsrc%2Fpaths.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-api%2Fsrc%2Fpaths.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fpaths.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -31,30 +31,34 @@ pub struct ServerPaths(Vec<ServerPath>);\n #[turbo_tasks::function]\n pub async fn all_server_paths(\n     assets: Vc<OutputAssets>,\n-    node_root: Vc<FileSystemPath>,\n+    node_root: FileSystemPath,\n ) -> Result<Vc<ServerPaths>> {\n     let span = tracing::info_span!(\"all_server_paths\");\n     async move {\n         let all_assets = all_assets_from_entries(assets).await?;\n-        let node_root = &node_root.await?;\n+        let node_root = node_root.clone();\n         Ok(Vc::cell(\n             all_assets\n                 .iter()\n-                .map(|&asset| async move {\n-                    Ok(\n-                        if let Some(path) = node_root.get_path_to(&*asset.path().await?) {\n-                            let content_hash = match *asset.content().await? {\n-                                AssetContent::File(file) => *file.hash().await?,\n-                                AssetContent::Redirect { .. } => 0,\n-                            };\n-                            Some(ServerPath {\n-                                path: path.to_string(),\n-                                content_hash,\n-                            })\n-                        } else {\n-                            None\n-                        },\n-                    )\n+                .map(|&asset| {\n+                    let node_root = node_root.clone();\n+\n+                    async move {\n+                        Ok(\n+                            if let Some(path) = node_root.get_path_to(&*asset.path().await?) {\n+                                let content_hash = match *asset.content().await? {\n+                                    AssetContent::File(file) => *file.hash().await?,\n+                                    AssetContent::Redirect { .. } => 0,\n+                                };\n+                                Some(ServerPath {\n+                                    path: path.to_string(),\n+                                    content_hash,\n+                                })\n+                            } else {\n+                                None\n+                            },\n+                        )\n+                    }\n                 })\n                 .try_flat_join()\n                 .await?,\n@@ -69,13 +73,12 @@ pub async fn all_server_paths(\n #[turbo_tasks::function]\n pub async fn all_paths_in_root(\n     assets: Vc<OutputAssets>,\n-    root: Vc<FileSystemPath>,\n+    root: FileSystemPath,\n ) -> Result<Vc<Vec<RcStr>>> {\n     let all_assets = &*all_assets_from_entries(assets).await?;\n-    let root = &*root.await?;\n \n     Ok(Vc::cell(\n-        get_paths_from_root(root, all_assets, |_| true).await?,\n+        get_paths_from_root(&root, all_assets, |_| true).await?,\n     ))\n }\n "
        },
        {
            "sha": "7eb249585b4f2d3bbb2acc36563ac10a81e5f283",
            "filename": "crates/next-api/src/project.rs",
            "status": "modified",
            "additions": 110,
            "deletions": 102,
            "changes": 212,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fproject.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -521,7 +521,7 @@ impl ProjectContainer {\n     #[turbo_tasks::function]\n     pub fn get_source_map(\n         &self,\n-        file_path: Vc<FileSystemPath>,\n+        file_path: FileSystemPath,\n         section: Option<RcStr>,\n     ) -> Vc<OptionStringifiedSourceMap> {\n         if let Some(map) = self.versioned_content_map {\n@@ -608,7 +608,7 @@ impl ProjectDefineEnv {\n \n #[turbo_tasks::value(shared)]\n struct ConflictIssue {\n-    path: ResolvedVc<FileSystemPath>,\n+    path: FileSystemPath,\n     title: ResolvedVc<StyledString>,\n     description: ResolvedVc<StyledString>,\n     severity: IssueSeverity,\n@@ -627,7 +627,7 @@ impl Issue for ConflictIssue {\n \n     #[turbo_tasks::function]\n     fn file_path(&self) -> Vc<FileSystemPath> {\n-        *self.path\n+        self.path.clone().cell()\n     }\n \n     #[turbo_tasks::function]\n@@ -645,10 +645,12 @@ impl Issue for ConflictIssue {\n impl Project {\n     #[turbo_tasks::function]\n     pub async fn app_project(self: Vc<Self>) -> Result<Vc<OptionAppProject>> {\n-        let app_dir = find_app_dir(self.project_path()).await?;\n+        let app_dir = find_app_dir(self.project_path().await?.clone_value()).await?;\n \n-        Ok(match *app_dir {\n-            Some(app_dir) => Vc::cell(Some(AppProject::new(self, *app_dir).to_resolved().await?)),\n+        Ok(match &*app_dir {\n+            Some(app_dir) => Vc::cell(Some(\n+                AppProject::new(self, app_dir.clone()).to_resolved().await?,\n+            )),\n             None => Vc::cell(None),\n         })\n     }\n@@ -691,8 +693,10 @@ impl Project {\n         Ok(self\n             .output_fs()\n             .root()\n-            .join(relative_from_root_to_project_path.into())\n-            .join(this.dist_dir.clone()))\n+            .await?\n+            .join(&relative_from_root_to_project_path)?\n+            .join(&this.dist_dir.clone())?\n+            .cell())\n     }\n \n     #[turbo_tasks::function]\n@@ -708,22 +712,23 @@ impl Project {\n     #[turbo_tasks::function]\n     pub async fn client_relative_path(self: Vc<Self>) -> Result<Vc<FileSystemPath>> {\n         let next_config = self.next_config().await?;\n-        Ok(self.client_root().join(\n-            format!(\n+        Ok(self\n+            .client_root()\n+            .await?\n+            .join(&format!(\n                 \"{}/_next\",\n                 next_config.base_path.clone().unwrap_or_default(),\n-            )\n-            .into(),\n-        ))\n+            ))?\n+            .cell())\n     }\n \n     #[turbo_tasks::function]\n     pub async fn node_root_to_root_path(self: Vc<Self>) -> Result<Vc<RcStr>> {\n         let this = self.await?;\n         let output_root_to_root_path = self\n             .project_path()\n-            .join(this.dist_dir.clone())\n             .await?\n+            .join(&this.dist_dir.clone())?\n             .get_relative_path_to(&*self.project_root_path().await?)\n             .context(\"Project path need to be in root path\")?;\n         Ok(Vc::cell(output_root_to_root_path))\n@@ -732,13 +737,13 @@ impl Project {\n     #[turbo_tasks::function]\n     pub async fn project_path(self: Vc<Self>) -> Result<Vc<FileSystemPath>> {\n         let this = self.await?;\n-        let root = self.project_root_path();\n+        let root = self.project_root_path().await?;\n         let project_relative = this.project_path.strip_prefix(&*this.root_path).unwrap();\n         let project_relative = project_relative\n             .strip_prefix(MAIN_SEPARATOR)\n             .unwrap_or(project_relative)\n             .replace(MAIN_SEPARATOR, \"/\");\n-        Ok(root.join(project_relative.into()))\n+        Ok(root.join(&project_relative)?.cell())\n     }\n \n     #[turbo_tasks::function]\n@@ -795,17 +800,17 @@ impl Project {\n \n     #[turbo_tasks::function]\n     pub(super) async fn execution_context(self: Vc<Self>) -> Result<Vc<ExecutionContext>> {\n-        let node_root = self.node_root().to_resolved().await?;\n+        let node_root = self.node_root().await?.clone_value();\n         let next_mode = self.next_mode().await?;\n \n         let node_execution_chunking_context = Vc::upcast(\n             NodeJsChunkingContext::builder(\n-                self.project_root_path().to_resolved().await?,\n-                node_root,\n+                self.project_root_path().await?.clone_value(),\n+                node_root.clone(),\n                 self.node_root_to_root_path().owned().await?,\n-                node_root,\n-                node_root.join(rcstr!(\"build/chunks\")).to_resolved().await?,\n-                node_root.join(rcstr!(\"build/assets\")).to_resolved().await?,\n+                node_root.clone(),\n+                node_root.join(\"build/chunks\")?,\n+                node_root.join(\"build/assets\")?,\n                 node_build_environment().to_resolved().await?,\n                 next_mode.runtime_type(),\n             )\n@@ -818,7 +823,7 @@ impl Project {\n         );\n \n         Ok(ExecutionContext::new(\n-            self.project_path(),\n+            self.project_path().await?.clone_value(),\n             node_execution_chunking_context,\n             self.env(),\n         ))\n@@ -999,7 +1004,7 @@ impl Project {\n     pub(super) async fn edge_compile_time_info(self: Vc<Self>) -> Result<Vc<CompileTimeInfo>> {\n         let this = self.await?;\n         Ok(get_edge_compile_time_info(\n-            self.project_path(),\n+            self.project_path().await?.clone_value(),\n             this.define_env.edge(),\n             self.current_node_js_version(),\n         ))\n@@ -1022,8 +1027,8 @@ impl Project {\n         self: Vc<Self>,\n     ) -> Result<Vc<Box<dyn ChunkingContext>>> {\n         Ok(get_client_chunking_context(\n-            self.project_root_path(),\n-            self.client_relative_path(),\n+            self.project_root_path().await?.clone_value(),\n+            self.client_relative_path().await?.clone_value(),\n             rcstr!(\"/ROOT\"),\n             self.next_config().computed_asset_prefix(),\n             self.next_config().chunk_suffix_path(),\n@@ -1045,10 +1050,10 @@ impl Project {\n         Ok(if client_assets {\n             get_server_chunking_context_with_client_assets(\n                 self.next_mode(),\n-                self.project_root_path(),\n-                self.node_root(),\n+                self.project_root_path().await?.clone_value(),\n+                self.node_root().await?.clone_value(),\n                 self.node_root_to_root_path().owned().await?,\n-                self.client_relative_path(),\n+                self.client_relative_path().await?.clone_value(),\n                 self.next_config().computed_asset_prefix().owned().await?,\n                 self.server_compile_time_info().environment(),\n                 self.module_ids(),\n@@ -1060,8 +1065,8 @@ impl Project {\n         } else {\n             get_server_chunking_context(\n                 self.next_mode(),\n-                self.project_root_path(),\n-                self.node_root(),\n+                self.project_root_path().await?.clone_value(),\n+                self.node_root().await?.clone_value(),\n                 self.node_root_to_root_path().owned().await?,\n                 self.server_compile_time_info().environment(),\n                 self.module_ids(),\n@@ -1081,10 +1086,10 @@ impl Project {\n         Ok(if client_assets {\n             get_edge_chunking_context_with_client_assets(\n                 self.next_mode(),\n-                self.project_root_path(),\n-                self.node_root(),\n+                self.project_root_path().await?.clone_value(),\n+                self.node_root().await?.clone_value(),\n                 self.node_root_to_root_path(),\n-                self.client_relative_path(),\n+                self.client_relative_path().await?.clone_value(),\n                 self.next_config().computed_asset_prefix(),\n                 self.edge_compile_time_info().environment(),\n                 self.module_ids(),\n@@ -1096,8 +1101,8 @@ impl Project {\n         } else {\n             get_edge_chunking_context(\n                 self.next_mode(),\n-                self.project_root_path(),\n-                self.node_root(),\n+                self.project_root_path().await?.clone_value(),\n+                self.node_root().await?.clone_value(),\n                 self.node_root_to_root_path(),\n                 self.edge_compile_time_info().environment(),\n                 self.module_ids(),\n@@ -1225,7 +1230,7 @@ impl Project {\n             match routes.entry(pathname.clone()) {\n                 Entry::Occupied(mut entry) => {\n                     ConflictIssue {\n-                        path: self.project_path().to_resolved().await?,\n+                        path: self.project_path().await?.clone_value(),\n                         title: StyledString::Text(\n                             format!(\"App Router and Pages Router both match path: {pathname}\")\n                                 .into(),\n@@ -1292,7 +1297,7 @@ impl Project {\n     async fn edge_middleware_context(self: Vc<Self>) -> Result<Vc<Box<dyn AssetContext>>> {\n         let mut transitions = vec![];\n \n-        let app_dir = *find_app_dir(self.project_path()).await?;\n+        let app_dir = (*find_app_dir(self.project_path().await?.clone_value()).await?).clone();\n         let app_project = *self.app_project().await?;\n \n         let ecmascript_client_reference_transition_name =\n@@ -1316,10 +1321,10 @@ impl Project {\n             .cell(),\n             self.edge_compile_time_info(),\n             get_server_module_options_context(\n-                self.project_path(),\n+                self.project_path().await?.clone_value(),\n                 self.execution_context(),\n                 ServerContextType::Middleware {\n-                    app_dir,\n+                    app_dir: app_dir.clone(),\n                     ecmascript_client_reference_transition_name:\n                         ecmascript_client_reference_transition_name.clone(),\n                 },\n@@ -1330,9 +1335,9 @@ impl Project {\n                 self.edge_compile_time_info().environment(),\n             ),\n             get_edge_resolve_options_context(\n-                self.project_path(),\n+                self.project_path().await?.clone_value(),\n                 ServerContextType::Middleware {\n-                    app_dir,\n+                    app_dir: app_dir.clone(),\n                     ecmascript_client_reference_transition_name:\n                         ecmascript_client_reference_transition_name.clone(),\n                 },\n@@ -1351,7 +1356,7 @@ impl Project {\n     async fn node_middleware_context(self: Vc<Self>) -> Result<Vc<Box<dyn AssetContext>>> {\n         let mut transitions = vec![];\n \n-        let app_dir = *find_app_dir(self.project_path()).await?;\n+        let app_dir = (*find_app_dir(self.project_path().await?.clone_value()).await?).clone();\n         let app_project = *self.app_project().await?;\n \n         let ecmascript_client_reference_transition_name =\n@@ -1375,10 +1380,10 @@ impl Project {\n             .cell(),\n             self.server_compile_time_info(),\n             get_server_module_options_context(\n-                self.project_path(),\n+                self.project_path().await?.clone_value(),\n                 self.execution_context(),\n                 ServerContextType::Middleware {\n-                    app_dir,\n+                    app_dir: app_dir.clone(),\n                     ecmascript_client_reference_transition_name:\n                         ecmascript_client_reference_transition_name.clone(),\n                 },\n@@ -1389,9 +1394,9 @@ impl Project {\n                 self.server_compile_time_info().environment(),\n             ),\n             get_server_resolve_options_context(\n-                self.project_path(),\n+                self.project_path().await?.clone_value(),\n                 ServerContextType::Middleware {\n-                    app_dir,\n+                    app_dir: app_dir.clone(),\n                     ecmascript_client_reference_transition_name,\n                 },\n                 self.next_mode(),\n@@ -1407,10 +1412,10 @@ impl Project {\n         let edge_module_context = self.edge_middleware_context();\n \n         let middleware = self.find_middleware();\n-        let FindContextFileResult::Found(fs_path, _) = *middleware.await? else {\n+        let FindContextFileResult::Found(fs_path, _) = &*middleware.await? else {\n             return Ok(Vc::upcast(edge_module_context));\n         };\n-        let source = Vc::upcast(FileSource::new(*fs_path));\n+        let source = Vc::upcast(FileSource::new(fs_path.clone()));\n \n         let module = edge_module_context\n             .process(\n@@ -1429,21 +1434,21 @@ impl Project {\n     }\n \n     #[turbo_tasks::function]\n-    fn find_middleware(self: Vc<Self>) -> Vc<FindContextFileResult> {\n-        find_context_file(\n-            self.project_path(),\n+    async fn find_middleware(self: Vc<Self>) -> Result<Vc<FindContextFileResult>> {\n+        Ok(find_context_file(\n+            self.project_path().await?.clone_value(),\n             middleware_files(self.next_config().page_extensions()),\n-        )\n+        ))\n     }\n \n     #[turbo_tasks::function]\n     async fn middleware_endpoint(self: Vc<Self>) -> Result<Vc<Box<dyn Endpoint>>> {\n         let middleware = self.find_middleware();\n-        let FindContextFileResult::Found(fs_path, _) = *middleware.await? else {\n+        let FindContextFileResult::Found(fs_path, _) = &*middleware.await? else {\n             return Ok(Vc::upcast(EmptyEndpoint::new()));\n         };\n-        let source = Vc::upcast(FileSource::new(*fs_path));\n-        let app_dir = *find_app_dir(self.project_path()).await?;\n+        let source = Vc::upcast(FileSource::new(fs_path.clone()));\n+        let app_dir = (*find_app_dir(self.project_path().await?.clone_value()).await?).clone();\n         let ecmascript_client_reference_transition_name = (*self.app_project().await?)\n             .as_ref()\n             .map(|_| AppProject::client_transition_name());\n@@ -1454,7 +1459,7 @@ impl Project {\n             self,\n             middleware_asset_context,\n             source,\n-            app_dir.as_deref().copied(),\n+            app_dir.clone(),\n             ecmascript_client_reference_transition_name,\n         )))\n     }\n@@ -1463,7 +1468,7 @@ impl Project {\n     async fn node_instrumentation_context(self: Vc<Self>) -> Result<Vc<Box<dyn AssetContext>>> {\n         let mut transitions = vec![];\n \n-        let app_dir = *find_app_dir(self.project_path()).await?;\n+        let app_dir = (*find_app_dir(self.project_path().await?.clone_value()).await?).clone();\n         let app_project = &*self.app_project().await?;\n \n         let ecmascript_client_reference_transition_name = app_project\n@@ -1488,10 +1493,10 @@ impl Project {\n             .cell(),\n             self.server_compile_time_info(),\n             get_server_module_options_context(\n-                self.project_path(),\n+                self.project_path().await?.clone_value(),\n                 self.execution_context(),\n                 ServerContextType::Instrumentation {\n-                    app_dir,\n+                    app_dir: app_dir.clone(),\n                     ecmascript_client_reference_transition_name:\n                         ecmascript_client_reference_transition_name.clone(),\n                 },\n@@ -1502,9 +1507,9 @@ impl Project {\n                 self.server_compile_time_info().environment(),\n             ),\n             get_server_resolve_options_context(\n-                self.project_path(),\n+                self.project_path().await?.clone_value(),\n                 ServerContextType::Instrumentation {\n-                    app_dir,\n+                    app_dir: app_dir.clone(),\n                     ecmascript_client_reference_transition_name,\n                 },\n                 self.next_mode(),\n@@ -1522,7 +1527,7 @@ impl Project {\n     async fn edge_instrumentation_context(self: Vc<Self>) -> Result<Vc<Box<dyn AssetContext>>> {\n         let mut transitions = vec![];\n \n-        let app_dir = *find_app_dir(self.project_path()).await?;\n+        let app_dir = (*find_app_dir(self.project_path().await?.clone_value()).await?).clone();\n         let app_project = &*self.app_project().await?;\n \n         let ecmascript_client_reference_transition_name = app_project\n@@ -1547,10 +1552,10 @@ impl Project {\n             .cell(),\n             self.edge_compile_time_info(),\n             get_server_module_options_context(\n-                self.project_path(),\n+                self.project_path().await?.clone_value(),\n                 self.execution_context(),\n                 ServerContextType::Instrumentation {\n-                    app_dir,\n+                    app_dir: app_dir.clone(),\n                     ecmascript_client_reference_transition_name:\n                         ecmascript_client_reference_transition_name.clone(),\n                 },\n@@ -1561,9 +1566,9 @@ impl Project {\n                 self.edge_compile_time_info().environment(),\n             ),\n             get_edge_resolve_options_context(\n-                self.project_path(),\n+                self.project_path().await?.clone_value(),\n                 ServerContextType::Instrumentation {\n-                    app_dir,\n+                    app_dir: app_dir.clone(),\n                     ecmascript_client_reference_transition_name,\n                 },\n                 self.next_mode(),\n@@ -1578,11 +1583,11 @@ impl Project {\n     }\n \n     #[turbo_tasks::function]\n-    fn find_instrumentation(self: Vc<Self>) -> Vc<FindContextFileResult> {\n-        find_context_file(\n-            self.project_path(),\n+    async fn find_instrumentation(self: Vc<Self>) -> Result<Vc<FindContextFileResult>> {\n+        Ok(find_context_file(\n+            self.project_path().await?.clone_value(),\n             instrumentation_files(self.next_config().page_extensions()),\n-        )\n+        ))\n     }\n \n     #[turbo_tasks::function]\n@@ -1591,11 +1596,11 @@ impl Project {\n         is_edge: bool,\n     ) -> Result<Vc<Box<dyn Endpoint>>> {\n         let instrumentation = self.find_instrumentation();\n-        let FindContextFileResult::Found(fs_path, _) = *instrumentation.await? else {\n+        let FindContextFileResult::Found(fs_path, _) = &*instrumentation.await? else {\n             return Ok(Vc::upcast(EmptyEndpoint::new()));\n         };\n-        let source = Vc::upcast(FileSource::new(*fs_path));\n-        let app_dir = *find_app_dir(self.project_path()).await?;\n+        let source = Vc::upcast(FileSource::new(fs_path.clone()));\n+        let app_dir = (*find_app_dir(self.project_path().await?.clone_value()).await?).clone();\n         let ecmascript_client_reference_transition_name = (*self.app_project().await?)\n             .as_ref()\n             .map(|_| AppProject::client_transition_name());\n@@ -1611,7 +1616,7 @@ impl Project {\n             instrumentation_asset_context,\n             source,\n             is_edge,\n-            app_dir.as_deref().copied(),\n+            app_dir.clone(),\n             ecmascript_client_reference_transition_name,\n         )))\n     }\n@@ -1625,16 +1630,16 @@ impl Project {\n         async move {\n             let all_output_assets = all_assets_from_entries_operation(output_assets);\n \n-            let client_relative_path = self.client_relative_path();\n-            let node_root = self.node_root();\n+            let client_relative_path = self.client_relative_path().await?.clone_value();\n+            let node_root = self.node_root().await?.clone_value();\n \n             if let Some(map) = self.await?.versioned_content_map {\n                 let _ = map\n                     .insert_output_assets(\n                         all_output_assets,\n-                        node_root,\n-                        client_relative_path,\n-                        node_root,\n+                        node_root.clone(),\n+                        client_relative_path.clone(),\n+                        node_root.clone(),\n                     )\n                     .resolve()\n                     .await?;\n@@ -1643,9 +1648,9 @@ impl Project {\n             } else {\n                 let _ = emit_assets(\n                     all_output_assets.connect(),\n-                    node_root,\n-                    client_relative_path,\n-                    node_root,\n+                    node_root.clone(),\n+                    client_relative_path.clone(),\n+                    node_root.clone(),\n                 )\n                 .resolve()\n                 .await?;\n@@ -1660,7 +1665,7 @@ impl Project {\n     #[turbo_tasks::function]\n     async fn hmr_content(self: Vc<Self>, identifier: RcStr) -> Result<Vc<OptionVersionedContent>> {\n         if let Some(map) = self.await?.versioned_content_map {\n-            let content = map.get(self.client_relative_path().join(identifier.clone()));\n+            let content = map.get(self.client_relative_path().await?.join(&identifier)?);\n             Ok(content)\n         } else {\n             bail!(\"must be in dev mode to hmr\")\n@@ -1727,7 +1732,7 @@ impl Project {\n     #[turbo_tasks::function]\n     pub async fn hmr_identifiers(self: Vc<Self>) -> Result<Vc<Vec<RcStr>>> {\n         if let Some(map) = self.await?.versioned_content_map {\n-            Ok(map.keys_in_path(self.client_relative_path()))\n+            Ok(map.keys_in_path(self.client_relative_path().await?.clone_value()))\n         } else {\n             bail!(\"must be in dev mode to hmr\")\n         }\n@@ -1736,17 +1741,17 @@ impl Project {\n     /// Completion when server side changes are detected in output assets\n     /// referenced from the roots\n     #[turbo_tasks::function]\n-    pub fn server_changed(self: Vc<Self>, roots: Vc<OutputAssets>) -> Vc<Completion> {\n-        let path = self.node_root();\n-        any_output_changed(roots, path, true)\n+    pub async fn server_changed(self: Vc<Self>, roots: Vc<OutputAssets>) -> Result<Vc<Completion>> {\n+        let path = self.node_root().await?.clone_value();\n+        Ok(any_output_changed(roots, path, true))\n     }\n \n     /// Completion when client side changes are detected in output assets\n     /// referenced from the roots\n     #[turbo_tasks::function]\n-    pub fn client_changed(self: Vc<Self>, roots: Vc<OutputAssets>) -> Vc<Completion> {\n-        let path = self.client_root();\n-        any_output_changed(roots, path, false)\n+    pub async fn client_changed(self: Vc<Self>, roots: Vc<OutputAssets>) -> Result<Vc<Completion>> {\n+        let path = self.client_root().await?.clone_value();\n+        Ok(any_output_changed(roots, path, false))\n     }\n \n     #[turbo_tasks::function]\n@@ -1820,26 +1825,29 @@ pub struct ModuleGraphs {\n #[turbo_tasks::function]\n async fn any_output_changed(\n     roots: Vc<OutputAssets>,\n-    path: Vc<FileSystemPath>,\n+    path: FileSystemPath,\n     server: bool,\n ) -> Result<Vc<Completion>> {\n-    let path = &path.await?;\n     let completions = AdjacencyMap::new()\n         .skip_duplicates()\n         .visit(roots.await?.iter().copied(), get_referenced_output_assets)\n         .await\n         .completed()?\n         .into_inner()\n         .into_postorder_topological()\n-        .map(|m| async move {\n-            let asset_path = m.path().await?;\n-            if !asset_path.path.ends_with(\".map\")\n-                && (!server || !asset_path.path.ends_with(\".css\"))\n-                && asset_path.is_inside_ref(path)\n-            {\n-                anyhow::Ok(Some(content_changed(*ResolvedVc::upcast(m))))\n-            } else {\n-                Ok(None)\n+        .map(|m| {\n+            let path = path.clone();\n+\n+            async move {\n+                let asset_path = m.path().await?;\n+                if !asset_path.path.ends_with(\".map\")\n+                    && (!server || !asset_path.path.ends_with(\".css\"))\n+                    && asset_path.is_inside_ref(&path)\n+                {\n+                    anyhow::Ok(Some(content_changed(*ResolvedVc::upcast(m))))\n+                } else {\n+                    Ok(None)\n+                }\n             }\n         })\n         .map(|v| async move {"
        },
        {
            "sha": "1370c8ad2ef840a57b150aef7b4e41ba02a410cd",
            "filename": "crates/next-api/src/server_actions.rs",
            "status": "modified",
            "additions": 15,
            "deletions": 8,
            "changes": 23,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-api%2Fsrc%2Fserver_actions.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-api%2Fsrc%2Fserver_actions.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fserver_actions.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -59,8 +59,8 @@ pub(crate) struct ServerActionsManifest {\n #[turbo_tasks::function]\n pub(crate) async fn create_server_actions_manifest(\n     actions: Vc<AllActions>,\n-    project_path: Vc<FileSystemPath>,\n-    node_root: Vc<FileSystemPath>,\n+    project_path: FileSystemPath,\n+    node_root: FileSystemPath,\n     page_name: RcStr,\n     runtime: NextRuntime,\n     rsc_asset_context: Vc<Box<dyn AssetContext>>,\n@@ -100,7 +100,7 @@ pub(crate) async fn create_server_actions_manifest(\n /// client and present inside the paired manifest.\n #[turbo_tasks::function]\n pub(crate) async fn build_server_actions_loader(\n-    project_path: Vc<FileSystemPath>,\n+    project_path: FileSystemPath,\n     page_name: RcStr,\n     actions: Vc<AllActions>,\n     asset_context: Vc<Box<dyn AssetContext>>,\n@@ -124,7 +124,7 @@ pub(crate) async fn build_server_actions_loader(\n         )?;\n     }\n \n-    let path = project_path.join(format!(\".next-internal/server/app{page_name}/actions.js\").into());\n+    let path = project_path.join(&format!(\".next-internal/server/app{page_name}/actions.js\"))?;\n     let file = File::from(contents.build());\n     let source = VirtualSource::new_with_ident(\n         AssetIdent::from_path(path).with_modifier(rcstr!(\"server actions loader\")),\n@@ -150,16 +150,17 @@ pub(crate) async fn build_server_actions_loader(\n /// Builds a manifest containing every action's hashed id, with an internal\n /// module id which exports a function using that hashed name.\n async fn build_manifest(\n-    node_root: Vc<FileSystemPath>,\n+    node_root: FileSystemPath,\n     page_name: RcStr,\n     runtime: NextRuntime,\n     actions: Vc<AllActions>,\n     chunk_item: Vc<Box<dyn ChunkItem>>,\n     async_module_info: Vc<AsyncModulesInfo>,\n ) -> Result<ResolvedVc<Box<dyn OutputAsset>>> {\n     let manifest_path_prefix = &page_name;\n-    let manifest_path = node_root\n-        .join(format!(\"server/app{manifest_path_prefix}/server-reference-manifest.json\",).into());\n+    let manifest_path = node_root.join(&format!(\n+        \"server/app{manifest_path_prefix}/server-reference-manifest.json\",\n+    ))?;\n     let mut manifest = ServerReferenceManifest {\n         ..Default::default()\n     };\n@@ -207,7 +208,13 @@ pub async fn to_rsc_context(\n     // opposed to the following hack to construct the RSC module corresponding to this client\n     // module.\n     let source = FileSource::new_with_query(\n-        client_module.ident().path().root().join(entry_path.into()),\n+        client_module\n+            .ident()\n+            .path()\n+            .await?\n+            .root()\n+            .await?\n+            .join(entry_path)?,\n         entry_query.into(),\n     );\n     let module = asset_context"
        },
        {
            "sha": "50dc746242a5699cf43367a4569499ad602a67c5",
            "filename": "crates/next-api/src/versioned_content_map.rs",
            "status": "modified",
            "additions": 33,
            "deletions": 37,
            "changes": 70,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-api%2Fsrc%2Fversioned_content_map.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-api%2Fsrc%2Fversioned_content_map.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fversioned_content_map.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -5,7 +5,7 @@ use serde::{Deserialize, Serialize};\n use turbo_rcstr::RcStr;\n use turbo_tasks::{\n     FxIndexSet, NonLocalValue, OperationValue, OperationVc, ResolvedVc, State, TryFlatJoinIterExt,\n-    TryJoinIterExt, ValueDefault, ValueToString, Vc, debug::ValueDebugFormat, trace::TraceRawVcs,\n+    TryJoinIterExt, ValueDefault, Vc, debug::ValueDebugFormat, trace::TraceRawVcs,\n };\n use turbo_tasks_fs::FileSystemPath;\n use turbopack_core::{\n@@ -29,7 +29,7 @@ use turbopack_core::{\n struct MapEntry {\n     assets_operation: OperationVc<OutputAssets>,\n     /// Precomputed map for quick access to output asset by filepath\n-    path_to_asset: FxHashMap<ResolvedVc<FileSystemPath>, ResolvedVc<Box<dyn OutputAsset>>>,\n+    path_to_asset: FxHashMap<FileSystemPath, ResolvedVc<Box<dyn OutputAsset>>>,\n }\n \n // HACK: This is technically incorrect because `path_to_asset` contains `ResolvedVc`...\n@@ -47,7 +47,7 @@ pub struct PathToOutputOperation(\n     /// It may not be 100% correct for the key (`FileSystemPath`) to be in a `ResolvedVc` here, but\n     /// it's impractical to make it an `OperationVc`/`OperationValue`, and it's unlikely to\n     /// change/break?\n-    FxHashMap<ResolvedVc<FileSystemPath>, FxIndexSet<OperationVc<OutputAssets>>>,\n+    FxHashMap<FileSystemPath, FxIndexSet<OperationVc<OutputAssets>>>,\n );\n \n // HACK: This is technically incorrect because the map's key is a `ResolvedVc`...\n@@ -91,9 +91,9 @@ impl VersionedContentMap {\n         self: ResolvedVc<Self>,\n         // Output assets to emit\n         assets_operation: OperationVc<OutputAssets>,\n-        node_root: ResolvedVc<FileSystemPath>,\n-        client_relative_path: ResolvedVc<FileSystemPath>,\n-        client_output_path: ResolvedVc<FileSystemPath>,\n+        node_root: FileSystemPath,\n+        client_relative_path: FileSystemPath,\n+        client_output_path: FileSystemPath,\n     ) -> Result<()> {\n         let this = self.await?;\n         let compute_entry = compute_entry_operation(\n@@ -115,9 +115,9 @@ impl VersionedContentMap {\n     async fn compute_entry(\n         &self,\n         assets_operation: OperationVc<OutputAssets>,\n-        node_root: Vc<FileSystemPath>,\n-        client_relative_path: Vc<FileSystemPath>,\n-        client_output_path: Vc<FileSystemPath>,\n+        node_root: FileSystemPath,\n+        client_relative_path: FileSystemPath,\n+        client_output_path: FileSystemPath,\n     ) -> Result<Vc<OptionMapEntry>> {\n         let entries = get_entries(assets_operation)\n             .read_strongly_consistent()\n@@ -129,10 +129,10 @@ impl VersionedContentMap {\n             let mut changed = false;\n \n             // get current map's keys, subtract keys that don't exist in operation\n-            let mut stale_assets = map.0.keys().copied().collect::<FxHashSet<_>>();\n+            let mut stale_assets = map.0.keys().cloned().collect::<FxHashSet<_>>();\n \n             for (k, _) in entries.iter().flatten() {\n-                let res = map.0.entry(*k).or_default().insert(assets_operation);\n+                let res = map.0.entry(k.clone()).or_default().insert(assets_operation);\n                 stale_assets.remove(k);\n                 changed = changed || res;\n             }\n@@ -161,16 +161,13 @@ impl VersionedContentMap {\n         .await?;\n         let map_entry = Vc::cell(Some(MapEntry {\n             assets_operation,\n-            path_to_asset: entries.iter().flatten().copied().collect(),\n+            path_to_asset: entries.iter().flatten().cloned().collect(),\n         }));\n         Ok(map_entry)\n     }\n \n     #[turbo_tasks::function]\n-    pub async fn get(\n-        self: Vc<Self>,\n-        path: Vc<FileSystemPath>,\n-    ) -> Result<Vc<OptionVersionedContent>> {\n+    pub async fn get(self: Vc<Self>, path: FileSystemPath) -> Result<Vc<OptionVersionedContent>> {\n         Ok(Vc::cell(match *self.get_asset(path).await? {\n             Some(asset) => Some(asset.versioned_content().to_resolved().await?),\n             None => None,\n@@ -180,10 +177,10 @@ impl VersionedContentMap {\n     #[turbo_tasks::function]\n     pub async fn get_source_map(\n         self: Vc<Self>,\n-        path: Vc<FileSystemPath>,\n+        path: FileSystemPath,\n         section: Option<RcStr>,\n     ) -> Result<Vc<OptionStringifiedSourceMap>> {\n-        let Some(asset) = &*self.get_asset(path).await? else {\n+        let Some(asset) = &*self.get_asset(path.clone()).await? else {\n             return Ok(Vc::cell(None));\n         };\n \n@@ -196,17 +193,14 @@ impl VersionedContentMap {\n                 generate_source_map.generate_source_map()\n             })\n         } else {\n-            let path = path.to_string().await?;\n+            let path = path.value_to_string().await?;\n             bail!(\"no source map for path {}\", path);\n         }\n     }\n \n     #[turbo_tasks::function]\n-    pub async fn get_asset(\n-        self: Vc<Self>,\n-        path: ResolvedVc<FileSystemPath>,\n-    ) -> Result<Vc<OptionOutputAsset>> {\n-        let result = self.raw_get(*path).await?;\n+    pub async fn get_asset(self: Vc<Self>, path: FileSystemPath) -> Result<Vc<OptionOutputAsset>> {\n+        let result = self.raw_get(path.clone()).await?;\n         if let Some(MapEntry {\n             assets_operation: _,\n             path_to_asset,\n@@ -220,22 +214,24 @@ impl VersionedContentMap {\n     }\n \n     #[turbo_tasks::function(invalidator)]\n-    pub async fn keys_in_path(&self, root: Vc<FileSystemPath>) -> Result<Vc<Vec<RcStr>>> {\n+    pub async fn keys_in_path(&self, root: FileSystemPath) -> Result<Vc<Vec<RcStr>>> {\n         let keys = {\n             let map = &self.map_path_to_op.get().0;\n-            map.keys().copied().collect::<Vec<_>>()\n+            map.keys().cloned().collect::<Vec<_>>()\n         };\n-        let root = &root.await?;\n         let keys = keys\n             .into_iter()\n-            .map(|path| async move { Ok(root.get_path_to(&*path.await?).map(RcStr::from)) })\n+            .map(|path| {\n+                let root = root.clone();\n+                async move { Ok(root.get_path_to(&path).map(RcStr::from)) }\n+            })\n             .try_flat_join()\n             .await?;\n         Ok(Vc::cell(keys))\n     }\n \n     #[turbo_tasks::function(invalidator)]\n-    fn raw_get(&self, path: ResolvedVc<FileSystemPath>) -> Vc<OptionMapEntry> {\n+    fn raw_get(&self, path: FileSystemPath) -> Vc<OptionMapEntry> {\n         let assets = {\n             let map = &self.map_path_to_op.get().0;\n             map.get(&path).and_then(|m| m.iter().next().copied())\n@@ -257,7 +253,7 @@ impl VersionedContentMap {\n     }\n }\n \n-type GetEntriesResultT = Vec<(ResolvedVc<FileSystemPath>, ResolvedVc<Box<dyn OutputAsset>>)>;\n+type GetEntriesResultT = Vec<(FileSystemPath, ResolvedVc<Box<dyn OutputAsset>>)>;\n \n #[turbo_tasks::value(transparent)]\n struct GetEntriesResult(GetEntriesResultT);\n@@ -268,7 +264,7 @@ async fn get_entries(assets: OperationVc<OutputAssets>) -> Result<Vc<GetEntriesR\n     let entries = assets_ref\n         .iter()\n         .map(|&asset| async move {\n-            let path = asset.path().to_resolved().await?;\n+            let path = asset.path().await?.clone_value();\n             Ok((path, asset))\n         })\n         .try_join()\n@@ -280,14 +276,14 @@ async fn get_entries(assets: OperationVc<OutputAssets>) -> Result<Vc<GetEntriesR\n fn compute_entry_operation(\n     map: ResolvedVc<VersionedContentMap>,\n     assets_operation: OperationVc<OutputAssets>,\n-    node_root: ResolvedVc<FileSystemPath>,\n-    client_relative_path: ResolvedVc<FileSystemPath>,\n-    client_output_path: ResolvedVc<FileSystemPath>,\n+    node_root: FileSystemPath,\n+    client_relative_path: FileSystemPath,\n+    client_output_path: FileSystemPath,\n ) -> Vc<OptionMapEntry> {\n     map.compute_entry(\n         assets_operation,\n-        *node_root,\n-        *client_relative_path,\n-        *client_output_path,\n+        node_root,\n+        client_relative_path,\n+        client_output_path,\n     )\n }"
        },
        {
            "sha": "bf3515541a0809398bec9c21e2b36c85959dd6ce",
            "filename": "crates/next-api/src/webpack_stats.rs",
            "status": "modified",
            "additions": 7,
            "deletions": 1,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-api%2Fsrc%2Fwebpack_stats.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-api%2Fsrc%2Fwebpack_stats.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fwebpack_stats.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -55,7 +55,13 @@ where\n     }\n \n     for (chunk_item, chunks) in chunk_items {\n-        let size = *chunk_item.content_ident().path().read().len().await?;\n+        let size = *chunk_item\n+            .content_ident()\n+            .path()\n+            .await?\n+            .read()\n+            .len()\n+            .await?;\n         let path = chunk_item.asset_ident().path().await?.path.clone();\n         modules.push(WebpackStatsModule {\n             name: path.clone(),"
        },
        {
            "sha": "1f42d238e60f9bc3fb87ba25a4b3e9db6c94a880",
            "filename": "crates/next-core/src/app_page_loader_tree.rs",
            "status": "modified",
            "additions": 30,
            "deletions": 30,
            "changes": 60,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fapp_page_loader_tree.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fapp_page_loader_tree.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fapp_page_loader_tree.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -27,7 +27,7 @@ use crate::{\n pub struct AppPageLoaderTreeBuilder {\n     base: BaseLoaderTreeBuilder,\n     loader_tree_code: String,\n-    pages: Vec<ResolvedVc<FileSystemPath>>,\n+    pages: Vec<FileSystemPath>,\n     /// next.config.js' basePath option to construct og metadata.\n     base_path: Option<RcStr>,\n }\n@@ -49,11 +49,11 @@ impl AppPageLoaderTreeBuilder {\n     async fn write_modules_entry(\n         &mut self,\n         module_type: AppDirModuleType,\n-        path: Option<ResolvedVc<FileSystemPath>>,\n+        path: Option<FileSystemPath>,\n     ) -> Result<()> {\n         if let Some(path) = path {\n             if matches!(module_type, AppDirModuleType::Page) {\n-                self.pages.push(path);\n+                self.pages.push(path.clone());\n             }\n \n             let tuple_code = self\n@@ -96,7 +96,7 @@ impl AppPageLoaderTreeBuilder {\n \n         // naively convert metadataitem -> metadatawithaltitem to iterate along with\n         // other icon items\n-        let icon = if let Some(favicon) = global_metadata.and_then(|m| m.favicon) {\n+        let icon = if let Some(favicon) = global_metadata.and_then(|m| m.favicon.clone()) {\n             let item = match favicon {\n                 MetadataItem::Static { path } => MetadataWithAltItem::Static {\n                     path,\n@@ -105,7 +105,7 @@ impl AppPageLoaderTreeBuilder {\n                 MetadataItem::Dynamic { path } => MetadataWithAltItem::Dynamic { path },\n             };\n             let mut item = vec![item];\n-            item.extend(icon.iter());\n+            item.extend(icon.iter().cloned());\n             item\n         } else {\n             icon.clone()\n@@ -121,7 +121,7 @@ impl AppPageLoaderTreeBuilder {\n             .await?;\n \n         if let Some(global_metadata) = global_metadata {\n-            self.write_metadata_manifest(global_metadata.manifest)\n+            self.write_metadata_manifest(global_metadata.manifest.clone())\n                 .await?;\n         }\n         self.loader_tree_code += \"  },\";\n@@ -180,8 +180,8 @@ impl AppPageLoaderTreeBuilder {\n                     app_page,\n                     name,\n                     item,\n-                    **path,\n-                    alt_path.as_deref().copied(),\n+                    path.clone(),\n+                    alt_path.clone(),\n                 )\n                 .await?;\n             }\n@@ -196,7 +196,7 @@ impl AppPageLoaderTreeBuilder {\n \n                 let source = dynamic_image_metadata_source(\n                     *ResolvedVc::upcast(self.base.module_asset_context),\n-                    **path,\n+                    path.clone(),\n                     name.into(),\n                     app_page.clone(),\n                 );\n@@ -218,8 +218,8 @@ impl AppPageLoaderTreeBuilder {\n         app_page: &AppPage,\n         name: &str,\n         item: &MetadataWithAltItem,\n-        path: Vc<FileSystemPath>,\n-        alt_path: Option<Vc<FileSystemPath>>,\n+        path: FileSystemPath,\n+        alt_path: Option<FileSystemPath>,\n     ) -> Result<()> {\n         let i = self.base.unique_number();\n \n@@ -238,7 +238,7 @@ impl AppPageLoaderTreeBuilder {\n             .imports\n             .push(format!(\"import {identifier} from \\\"{inner_module_id}\\\";\").into());\n         let module = Vc::upcast(StructuredImageModuleType::create_module(\n-            Vc::upcast(FileSource::new(path)),\n+            Vc::upcast(FileSource::new(path.clone())),\n             BlurPlaceholderMode::None,\n             *self.base.module_asset_context,\n         ));\n@@ -254,7 +254,7 @@ impl AppPageLoaderTreeBuilder {\n         } else {\n             app_page.to_string()\n         };\n-        let metadata_route = &*get_metadata_route_name((*item).into()).await?;\n+        let metadata_route = &*get_metadata_route_name(item.clone().into()).await?;\n         writeln!(\n             self.loader_tree_code,\n             \"{s}  url: fillMetadataSegment({}, await props.params, {}) + \\\n@@ -268,7 +268,7 @@ impl AppPageLoaderTreeBuilder {\n             writeln!(self.loader_tree_code, \"{s}  width: {identifier}.width,\")?;\n             writeln!(self.loader_tree_code, \"{s}  height: {identifier}.height,\")?;\n         } else {\n-            let ext = &*path.extension().await?;\n+            let ext = path.extension();\n             // For SVGs, skip sizes and use \"any\" to let it scale automatically based on viewport,\n             // For the images doesn't provide the size properly, use \"any\" as well.\n             // If the size is presented, use the actual size for the image.\n@@ -356,27 +356,27 @@ impl AppPageLoaderTreeBuilder {\n         )\n         .await?;\n \n-        self.write_modules_entry(AppDirModuleType::Layout, *layout)\n+        self.write_modules_entry(AppDirModuleType::Layout, layout.clone())\n             .await?;\n-        self.write_modules_entry(AppDirModuleType::Error, *error)\n+        self.write_modules_entry(AppDirModuleType::Error, error.clone())\n             .await?;\n-        self.write_modules_entry(AppDirModuleType::Loading, *loading)\n+        self.write_modules_entry(AppDirModuleType::Loading, loading.clone())\n             .await?;\n-        self.write_modules_entry(AppDirModuleType::Template, *template)\n+        self.write_modules_entry(AppDirModuleType::Template, template.clone())\n             .await?;\n-        self.write_modules_entry(AppDirModuleType::NotFound, *not_found)\n+        self.write_modules_entry(AppDirModuleType::NotFound, not_found.clone())\n             .await?;\n-        self.write_modules_entry(AppDirModuleType::Forbidden, *forbidden)\n+        self.write_modules_entry(AppDirModuleType::Forbidden, forbidden.clone())\n             .await?;\n-        self.write_modules_entry(AppDirModuleType::Unauthorized, *unauthorized)\n+        self.write_modules_entry(AppDirModuleType::Unauthorized, unauthorized.clone())\n             .await?;\n-        self.write_modules_entry(AppDirModuleType::Page, *page)\n+        self.write_modules_entry(AppDirModuleType::Page, page.clone())\n             .await?;\n-        self.write_modules_entry(AppDirModuleType::DefaultPage, *default)\n+        self.write_modules_entry(AppDirModuleType::DefaultPage, default.clone())\n             .await?;\n-        self.write_modules_entry(AppDirModuleType::GlobalError, *global_error)\n+        self.write_modules_entry(AppDirModuleType::GlobalError, global_error.clone())\n             .await?;\n-        self.write_modules_entry(AppDirModuleType::GlobalNotFound, *global_not_found)\n+        self.write_modules_entry(AppDirModuleType::GlobalNotFound, global_not_found.clone())\n             .await?;\n \n         let modules_code = replace(&mut self.loader_tree_code, temp_loader_tree_code);\n@@ -403,19 +403,19 @@ impl AppPageLoaderTreeBuilder {\n \n         let modules = &loader_tree.modules;\n         // load global-error module\n-        if let Some(global_error) = modules.global_error {\n+        if let Some(global_error) = &modules.global_error {\n             let module = self\n                 .base\n-                .process_source(Vc::upcast(FileSource::new(*global_error)))\n+                .process_source(Vc::upcast(FileSource::new(global_error.clone())))\n                 .to_resolved()\n                 .await?;\n             self.base.inner_assets.insert(GLOBAL_ERROR.into(), module);\n         };\n         // load global-not-found module\n-        if let Some(global_not_found) = modules.global_not_found {\n+        if let Some(global_not_found) = &modules.global_not_found {\n             let module = self\n                 .base\n-                .process_source(Vc::upcast(FileSource::new(*global_not_found)))\n+                .process_source(Vc::upcast(FileSource::new(global_not_found.clone())))\n                 .to_resolved()\n                 .await?;\n             self.base\n@@ -437,7 +437,7 @@ pub struct AppPageLoaderTreeModule {\n     pub imports: Vec<RcStr>,\n     pub loader_tree_code: RcStr,\n     pub inner_assets: FxIndexMap<RcStr, ResolvedVc<Box<dyn Module>>>,\n-    pub pages: Vec<ResolvedVc<FileSystemPath>>,\n+    pub pages: Vec<FileSystemPath>,\n }\n \n impl AppPageLoaderTreeModule {"
        },
        {
            "sha": "824d7fa1fadb1bc3953098427607b505fcd94429",
            "filename": "crates/next-core/src/app_segment_config.rs",
            "status": "modified",
            "additions": 8,
            "deletions": 4,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fapp_segment_config.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fapp_segment_config.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fapp_segment_config.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -583,11 +583,15 @@ pub async fn parse_segment_config_from_loader_tree_internal(\n     }\n \n     let modules = &loader_tree.modules;\n-    for path in [modules.page, modules.default, modules.layout]\n-        .into_iter()\n-        .flatten()\n+    for path in [\n+        modules.page.clone(),\n+        modules.default.clone(),\n+        modules.layout.clone(),\n+    ]\n+    .into_iter()\n+    .flatten()\n     {\n-        let source = Vc::upcast(FileSource::new(*path));\n+        let source = Vc::upcast(FileSource::new(path.clone()));\n         config.apply_parent_config(&*parse_segment_config_from_source(source).await?);\n     }\n "
        },
        {
            "sha": "4a5ec24b5560419f77a259b291620d7f66b2a7aa",
            "filename": "crates/next-core/src/app_structure.rs",
            "status": "modified",
            "additions": 227,
            "deletions": 244,
            "changes": 471,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fapp_structure.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fapp_structure.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fapp_structure.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -7,8 +7,8 @@ use serde::{Deserialize, Serialize};\n use tracing::Instrument;\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{\n-    FxIndexMap, NonLocalValue, ResolvedVc, TaskInput, TryJoinIterExt, ValueDefault, ValueToString,\n-    Vc, debug::ValueDebugFormat, fxindexmap, trace::TraceRawVcs,\n+    FxIndexMap, NonLocalValue, ResolvedVc, TaskInput, TryJoinIterExt, ValueDefault, Vc,\n+    debug::ValueDebugFormat, fxindexmap, trace::TraceRawVcs,\n };\n use turbo_tasks_fs::{DirectoryContent, DirectoryEntry, FileSystemEntryType, FileSystemPath};\n use turbopack_core::issue::{\n@@ -37,29 +37,29 @@ fn normalize_underscore(string: &str) -> String {\n #[derive(Default, Debug, Clone)]\n pub struct AppDirModules {\n     #[serde(skip_serializing_if = \"Option::is_none\")]\n-    pub page: Option<ResolvedVc<FileSystemPath>>,\n+    pub page: Option<FileSystemPath>,\n     #[serde(skip_serializing_if = \"Option::is_none\")]\n-    pub layout: Option<ResolvedVc<FileSystemPath>>,\n+    pub layout: Option<FileSystemPath>,\n     #[serde(skip_serializing_if = \"Option::is_none\")]\n-    pub error: Option<ResolvedVc<FileSystemPath>>,\n+    pub error: Option<FileSystemPath>,\n     #[serde(skip_serializing_if = \"Option::is_none\")]\n-    pub global_error: Option<ResolvedVc<FileSystemPath>>,\n+    pub global_error: Option<FileSystemPath>,\n     #[serde(skip_serializing_if = \"Option::is_none\")]\n-    pub global_not_found: Option<ResolvedVc<FileSystemPath>>,\n+    pub global_not_found: Option<FileSystemPath>,\n     #[serde(skip_serializing_if = \"Option::is_none\")]\n-    pub loading: Option<ResolvedVc<FileSystemPath>>,\n+    pub loading: Option<FileSystemPath>,\n     #[serde(skip_serializing_if = \"Option::is_none\")]\n-    pub template: Option<ResolvedVc<FileSystemPath>>,\n+    pub template: Option<FileSystemPath>,\n     #[serde(skip_serializing_if = \"Option::is_none\")]\n-    pub forbidden: Option<ResolvedVc<FileSystemPath>>,\n+    pub forbidden: Option<FileSystemPath>,\n     #[serde(skip_serializing_if = \"Option::is_none\")]\n-    pub unauthorized: Option<ResolvedVc<FileSystemPath>>,\n+    pub unauthorized: Option<FileSystemPath>,\n     #[serde(skip_serializing_if = \"Option::is_none\")]\n-    pub not_found: Option<ResolvedVc<FileSystemPath>>,\n+    pub not_found: Option<FileSystemPath>,\n     #[serde(skip_serializing_if = \"Option::is_none\")]\n-    pub default: Option<ResolvedVc<FileSystemPath>>,\n+    pub default: Option<FileSystemPath>,\n     #[serde(skip_serializing_if = \"Option::is_none\")]\n-    pub route: Option<ResolvedVc<FileSystemPath>>,\n+    pub route: Option<FileSystemPath>,\n     #[serde(skip_serializing_if = \"Metadata::is_empty\", default)]\n     pub metadata: Metadata,\n }\n@@ -68,15 +68,15 @@ impl AppDirModules {\n     fn without_leafs(&self) -> Self {\n         Self {\n             page: None,\n-            layout: self.layout,\n-            error: self.error,\n-            global_error: self.global_error,\n-            global_not_found: self.global_not_found,\n-            loading: self.loading,\n-            template: self.template,\n-            not_found: self.not_found,\n-            forbidden: self.forbidden,\n-            unauthorized: self.unauthorized,\n+            layout: self.layout.clone(),\n+            error: self.error.clone(),\n+            global_error: self.global_error.clone(),\n+            global_not_found: self.global_not_found.clone(),\n+            loading: self.loading.clone(),\n+            template: self.template.clone(),\n+            not_found: self.not_found.clone(),\n+            forbidden: self.forbidden.clone(),\n+            unauthorized: self.unauthorized.clone(),\n             default: None,\n             route: None,\n             metadata: self.metadata.clone(),\n@@ -85,61 +85,48 @@ impl AppDirModules {\n }\n \n /// A single metadata file plus an optional \"alt\" text file.\n-#[derive(Copy, Clone, Debug, Serialize, Deserialize, PartialEq, Eq, TraceRawVcs, NonLocalValue)]\n+#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq, TraceRawVcs, NonLocalValue)]\n pub enum MetadataWithAltItem {\n     Static {\n-        path: ResolvedVc<FileSystemPath>,\n-        alt_path: Option<ResolvedVc<FileSystemPath>>,\n+        path: FileSystemPath,\n+        alt_path: Option<FileSystemPath>,\n     },\n     Dynamic {\n-        path: ResolvedVc<FileSystemPath>,\n+        path: FileSystemPath,\n     },\n }\n \n /// A single metadata file.\n #[derive(\n-    Copy,\n-    Clone,\n-    Debug,\n-    Hash,\n-    Serialize,\n-    Deserialize,\n-    PartialEq,\n-    Eq,\n-    TaskInput,\n-    TraceRawVcs,\n-    NonLocalValue,\n+    Clone, Debug, Hash, Serialize, Deserialize, PartialEq, Eq, TaskInput, TraceRawVcs, NonLocalValue,\n )]\n pub enum MetadataItem {\n-    Static { path: ResolvedVc<FileSystemPath> },\n-    Dynamic { path: ResolvedVc<FileSystemPath> },\n+    Static { path: FileSystemPath },\n+    Dynamic { path: FileSystemPath },\n }\n \n #[turbo_tasks::function]\n pub async fn get_metadata_route_name(meta: MetadataItem) -> Result<Vc<RcStr>> {\n     Ok(match meta {\n-        MetadataItem::Static { path } => {\n-            let path_value = path.await?;\n-            Vc::cell(path_value.file_name().into())\n-        }\n+        MetadataItem::Static { path } => Vc::cell(path.file_name().into()),\n         MetadataItem::Dynamic { path } => {\n-            let Some(stem) = &*path.file_stem().await? else {\n+            let Some(stem) = path.file_stem() else {\n                 bail!(\n                     \"unable to resolve file stem for metadata item at {}\",\n-                    path.to_string().await?\n+                    path.value_to_string().await?\n                 );\n             };\n \n-            match stem.as_str() {\n+            match stem {\n                 \"manifest\" => Vc::cell(rcstr!(\"manifest.webmanifest\")),\n-                _ => Vc::cell(stem.clone()),\n+                _ => Vc::cell(RcStr::from(stem)),\n             }\n         }\n     })\n }\n \n impl MetadataItem {\n-    pub fn into_path(self) -> ResolvedVc<FileSystemPath> {\n+    pub fn into_path(self) -> FileSystemPath {\n         match self {\n             MetadataItem::Static { path } => path,\n             MetadataItem::Dynamic { path } => path,\n@@ -258,33 +245,31 @@ impl DirectoryTree {\n }\n \n #[turbo_tasks::value(transparent)]\n-pub struct OptionAppDir(Option<ResolvedVc<FileSystemPath>>);\n+pub struct OptionAppDir(Option<FileSystemPath>);\n \n /// Finds and returns the [DirectoryTree] of the app directory if existing.\n #[turbo_tasks::function]\n-pub async fn find_app_dir(project_path: Vc<FileSystemPath>) -> Result<Vc<OptionAppDir>> {\n-    let app = project_path.join(rcstr!(\"app\"));\n-    let src_app = project_path.join(rcstr!(\"src/app\"));\n+pub async fn find_app_dir(project_path: FileSystemPath) -> Result<Vc<OptionAppDir>> {\n+    let app = project_path.join(\"app\")?;\n+    let src_app = project_path.join(\"src/app\")?;\n     let app_dir = if *app.get_type().await? == FileSystemEntryType::Directory {\n         app\n     } else if *src_app.get_type().await? == FileSystemEntryType::Directory {\n         src_app\n     } else {\n         return Ok(Vc::cell(None));\n-    }\n-    .to_resolved()\n-    .await?;\n+    };\n \n     Ok(Vc::cell(Some(app_dir)))\n }\n \n #[turbo_tasks::function]\n async fn get_directory_tree(\n-    dir: Vc<FileSystemPath>,\n+    dir: FileSystemPath,\n     page_extensions: Vc<Vec<RcStr>>,\n ) -> Result<Vc<DirectoryTree>> {\n     let span = {\n-        let dir = dir.to_string().await?.to_string();\n+        let dir = dir.value_to_string().await?.to_string();\n         tracing::info_span!(\"read app directory tree\", name = dir)\n     };\n     get_directory_tree_internal(dir, page_extensions)\n@@ -293,7 +278,7 @@ async fn get_directory_tree(\n }\n \n async fn get_directory_tree_internal(\n-    dir: Vc<FileSystemPath>,\n+    dir: FileSystemPath,\n     page_extensions: Vc<Vec<RcStr>>,\n ) -> Result<Vc<DirectoryTree>> {\n     let DirectoryContent::Entries(entries) = &*dir.read_dir().await? else {\n@@ -317,7 +302,7 @@ async fn get_directory_tree_internal(\n     let mut metadata_twitter = Vec::new();\n \n     for (basename, entry) in entries {\n-        let entry = entry.resolve_symlink().await?;\n+        let entry = entry.clone().resolve_symlink().await?;\n         match entry {\n             DirectoryEntry::File(file) => {\n                 // Do not process .d.ts files as routes\n@@ -328,18 +313,18 @@ async fn get_directory_tree_internal(\n                     && page_extensions_value.iter().any(|e| e == ext)\n                 {\n                     match stem {\n-                        \"page\" => modules.page = Some(file),\n-                        \"layout\" => modules.layout = Some(file),\n-                        \"error\" => modules.error = Some(file),\n-                        \"global-error\" => modules.global_error = Some(file),\n-                        \"global-not-found\" => modules.global_not_found = Some(file),\n-                        \"loading\" => modules.loading = Some(file),\n-                        \"template\" => modules.template = Some(file),\n-                        \"forbidden\" => modules.forbidden = Some(file),\n-                        \"unauthorized\" => modules.unauthorized = Some(file),\n-                        \"not-found\" => modules.not_found = Some(file),\n-                        \"default\" => modules.default = Some(file),\n-                        \"route\" => modules.route = Some(file),\n+                        \"page\" => modules.page = Some(file.clone()),\n+                        \"layout\" => modules.layout = Some(file.clone()),\n+                        \"error\" => modules.error = Some(file.clone()),\n+                        \"global-error\" => modules.global_error = Some(file.clone()),\n+                        \"global-not-found\" => modules.global_not_found = Some(file.clone()),\n+                        \"loading\" => modules.loading = Some(file.clone()),\n+                        \"template\" => modules.template = Some(file.clone()),\n+                        \"forbidden\" => modules.forbidden = Some(file.clone()),\n+                        \"unauthorized\" => modules.unauthorized = Some(file.clone()),\n+                        \"not-found\" => modules.not_found = Some(file.clone()),\n+                        \"default\" => modules.default = Some(file.clone()),\n+                        \"route\" => modules.route = Some(file.clone()),\n                         _ => {}\n                     }\n                 }\n@@ -374,16 +359,11 @@ async fn get_directory_tree_internal(\n                     continue;\n                 }\n \n-                let file_value = file.await?;\n-                let file_name = file_value.file_name();\n+                let file_name = file.file_name();\n                 let basename = file_name\n                     .rsplit_once('.')\n                     .map_or(file_name, |(basename, _)| basename);\n-                let alt_path = file\n-                    .parent()\n-                    .join(format!(\"{basename}.alt.txt\").into())\n-                    .to_resolved()\n-                    .await?;\n+                let alt_path = file.parent().join(&format!(\"{basename}.alt.txt\"))?;\n                 let alt_path = matches!(&*alt_path.get_type().await?, FileSystemEntryType::File)\n                     .then_some(alt_path);\n \n@@ -398,7 +378,7 @@ async fn get_directory_tree_internal(\n             DirectoryEntry::Directory(dir) => {\n                 // appDir ignores paths starting with an underscore\n                 if !basename.starts_with('_') {\n-                    let result = get_directory_tree(*dir, page_extensions)\n+                    let result = get_directory_tree(dir.clone(), page_extensions)\n                         .to_resolved()\n                         .await?;\n                     subdirectories.insert(basename.clone(), result);\n@@ -501,7 +481,7 @@ impl AppPageLoaderTree {\n }\n \n #[turbo_tasks::value(transparent)]\n-pub struct FileSystemPathVec(Vec<ResolvedVc<FileSystemPath>>);\n+pub struct FileSystemPathVec(Vec<FileSystemPath>);\n \n #[turbo_tasks::value_impl]\n impl ValueDefault for FileSystemPathVec {\n@@ -531,7 +511,7 @@ pub enum Entrypoint {\n     },\n     AppRoute {\n         page: AppPage,\n-        path: ResolvedVc<FileSystemPath>,\n+        path: FileSystemPath,\n         root_layouts: ResolvedVc<FileSystemPathVec>,\n     },\n     AppMetadata {\n@@ -566,7 +546,7 @@ fn match_parallel_route(name: &str) -> Option<&str> {\n }\n \n fn conflict_issue(\n-    app_dir: ResolvedVc<FileSystemPath>,\n+    app_dir: FileSystemPath,\n     e: &'_ OccupiedEntry<'_, AppPath, Entrypoint>,\n     a: &str,\n     b: &str,\n@@ -597,7 +577,7 @@ fn conflict_issue(\n }\n \n fn add_app_page(\n-    app_dir: ResolvedVc<FileSystemPath>,\n+    app_dir: FileSystemPath,\n     result: &mut FxIndexMap<AppPath, Entrypoint>,\n     page: AppPage,\n     loader_tree: ResolvedVc<AppPageLoaderTree>,\n@@ -656,10 +636,10 @@ fn add_app_page(\n }\n \n fn add_app_route(\n-    app_dir: ResolvedVc<FileSystemPath>,\n+    app_dir: FileSystemPath,\n     result: &mut FxIndexMap<AppPath, Entrypoint>,\n     page: AppPage,\n-    path: ResolvedVc<FileSystemPath>,\n+    path: FileSystemPath,\n     root_layouts: ResolvedVc<FileSystemPathVec>,\n ) {\n     let e = match result.entry(page.clone().into()) {\n@@ -699,7 +679,7 @@ fn add_app_route(\n }\n \n fn add_app_metadata_route(\n-    app_dir: ResolvedVc<FileSystemPath>,\n+    app_dir: FileSystemPath,\n     result: &mut FxIndexMap<AppPath, Entrypoint>,\n     page: AppPage,\n     metadata: MetadataItem,\n@@ -738,13 +718,13 @@ fn add_app_metadata_route(\n \n #[turbo_tasks::function]\n pub fn get_entrypoints(\n-    app_dir: Vc<FileSystemPath>,\n+    app_dir: FileSystemPath,\n     page_extensions: Vc<Vec<RcStr>>,\n     is_global_not_found_enabled: Vc<bool>,\n ) -> Vc<Entrypoints> {\n     directory_tree_to_entrypoints(\n-        app_dir,\n-        get_directory_tree(app_dir, page_extensions),\n+        app_dir.clone(),\n+        get_directory_tree(app_dir.clone(), page_extensions),\n         get_global_metadata(app_dir, page_extensions),\n         is_global_not_found_enabled,\n         Default::default(),\n@@ -753,7 +733,7 @@ pub fn get_entrypoints(\n \n #[turbo_tasks::function]\n fn directory_tree_to_entrypoints(\n-    app_dir: Vc<FileSystemPath>,\n+    app_dir: FileSystemPath,\n     directory_tree: Vc<DirectoryTree>,\n     global_metadata: Vc<GlobalMetadata>,\n     is_global_not_found_enabled: Vc<bool>,\n@@ -772,16 +752,16 @@ fn directory_tree_to_entrypoints(\n \n #[turbo_tasks::value]\n struct DuplicateParallelRouteIssue {\n-    app_dir: ResolvedVc<FileSystemPath>,\n+    app_dir: FileSystemPath,\n     previously_inserted_page: AppPage,\n     page: AppPage,\n }\n \n #[turbo_tasks::value_impl]\n impl Issue for DuplicateParallelRouteIssue {\n     #[turbo_tasks::function]\n-    fn file_path(&self) -> Vc<FileSystemPath> {\n-        self.app_dir.join(self.page.to_string().into())\n+    fn file_path(&self) -> Result<Vc<FileSystemPath>> {\n+        Ok(self.app_dir.join(&self.page.to_string())?.cell())\n     }\n \n     #[turbo_tasks::function]\n@@ -830,7 +810,7 @@ fn page_path_except_parallel(loader_tree: &AppPageLoaderTree) -> Option<AppPage>\n async fn check_duplicate(\n     duplicate: &mut FxHashMap<AppPath, AppPage>,\n     loader_tree: &AppPageLoaderTree,\n-    app_dir: Vc<FileSystemPath>,\n+    app_dir: FileSystemPath,\n ) -> Result<()> {\n     let page_path = page_path_except_parallel(loader_tree);\n \n@@ -839,7 +819,7 @@ async fn check_duplicate(\n         && prev != page_path\n     {\n         DuplicateParallelRouteIssue {\n-            app_dir: app_dir.to_resolved().await?,\n+            app_dir: app_dir.clone(),\n             previously_inserted_page: prev.clone(),\n             page: loader_tree.page.clone(),\n         }\n@@ -856,7 +836,7 @@ struct AppPageLoaderTreeOption(Option<ResolvedVc<AppPageLoaderTree>>);\n /// creates the loader tree for a specific route (pathname / [AppPath])\n #[turbo_tasks::function]\n async fn directory_tree_to_loader_tree(\n-    app_dir: Vc<FileSystemPath>,\n+    app_dir: FileSystemPath,\n     global_metadata: Vc<GlobalMetadata>,\n     directory_name: RcStr,\n     directory_tree: Vc<DirectoryTree>,\n@@ -880,7 +860,7 @@ async fn directory_tree_to_loader_tree(\n }\n \n async fn directory_tree_to_loader_tree_internal(\n-    app_dir: Vc<FileSystemPath>,\n+    app_dir: FileSystemPath,\n     global_metadata: Vc<GlobalMetadata>,\n     directory_name: RcStr,\n     directory_tree: &PlainDirectoryTree,\n@@ -909,34 +889,30 @@ async fn directory_tree_to_loader_tree_internal(\n     if is_root_directory || is_root_layout {\n         if modules.not_found.is_none() {\n             modules.not_found = Some(\n-                get_next_package(app_dir)\n-                    .join(rcstr!(\"dist/client/components/builtin/not-found.js\"))\n-                    .to_resolved()\n-                    .await?,\n+                get_next_package(app_dir.clone())\n+                    .await?\n+                    .join(\"dist/client/components/builtin/not-found.js\")?,\n             );\n         }\n         if modules.forbidden.is_none() {\n             modules.forbidden = Some(\n-                get_next_package(app_dir)\n-                    .join(rcstr!(\"dist/client/components/builtin/forbidden.js\"))\n-                    .to_resolved()\n-                    .await?,\n+                get_next_package(app_dir.clone())\n+                    .await?\n+                    .join(\"dist/client/components/builtin/forbidden.js\")?,\n             );\n         }\n         if modules.unauthorized.is_none() {\n             modules.unauthorized = Some(\n-                get_next_package(app_dir)\n-                    .join(rcstr!(\"dist/client/components/builtin/unauthorized.js\"))\n-                    .to_resolved()\n-                    .await?,\n+                get_next_package(app_dir.clone())\n+                    .await?\n+                    .join(\"dist/client/components/builtin/unauthorized.js\")?,\n             );\n         }\n         if modules.global_error.is_none() {\n             modules.global_error = Some(\n-                get_next_package(app_dir)\n-                    .join(rcstr!(\"dist/client/components/builtin/global-error.js\"))\n-                    .to_resolved()\n-                    .await?,\n+                get_next_package(app_dir.clone())\n+                    .await?\n+                    .join(\"dist/client/components/builtin/global-error.js\")?,\n             );\n         }\n     }\n@@ -995,7 +971,7 @@ async fn directory_tree_to_loader_tree_internal(\n         }\n \n         let subtree = Box::pin(directory_tree_to_loader_tree_internal(\n-            app_dir,\n+            app_dir.clone(),\n             global_metadata,\n             subdir_name.clone(),\n             subdirectory,\n@@ -1020,7 +996,7 @@ async fn directory_tree_to_loader_tree_internal(\n             }\n \n             if subtree.has_page() {\n-                check_duplicate(&mut duplicate, &subtree, app_dir).await?;\n+                check_duplicate(&mut duplicate, &subtree, app_dir.clone()).await?;\n             }\n \n             if let Some(current_tree) = tree.parallel_routes.get(\"children\") {\n@@ -1062,33 +1038,28 @@ async fn directory_tree_to_loader_tree_internal(\n             let subdir_name: RcStr = format!(\"@{key}\").into();\n \n             let default = if key == \"children\" {\n-                modules.default\n+                modules.default.clone()\n             } else if let Some(subdirectory) = directory_tree.subdirectories.get(&subdir_name) {\n-                subdirectory.modules.default\n+                subdirectory.modules.default.clone()\n             } else {\n                 None\n             };\n \n             tree.parallel_routes.insert(\n                 key,\n-                default_route_tree(\n-                    app_dir,\n-                    global_metadata,\n-                    app_page.clone(),\n-                    default.map(|v| *v),\n-                )\n-                .await?,\n+                default_route_tree(app_dir.clone(), global_metadata, app_page.clone(), default)\n+                    .await?,\n             );\n         }\n     }\n \n     if tree.parallel_routes.is_empty() {\n         if modules.default.is_some() || current_level_is_parallel_route {\n             tree = default_route_tree(\n-                app_dir,\n+                app_dir.clone(),\n                 global_metadata,\n                 app_page,\n-                modules.default.map(|v| *v),\n+                modules.default.clone(),\n             )\n             .await?;\n         } else {\n@@ -1098,10 +1069,10 @@ async fn directory_tree_to_loader_tree_internal(\n         tree.parallel_routes.insert(\n             rcstr!(\"children\"),\n             default_route_tree(\n-                app_dir,\n+                app_dir.clone(),\n                 global_metadata,\n                 app_page,\n-                modules.default.map(|v| *v),\n+                modules.default.clone(),\n             )\n             .await?,\n         );\n@@ -1119,28 +1090,27 @@ async fn directory_tree_to_loader_tree_internal(\n }\n \n async fn default_route_tree(\n-    app_dir: Vc<FileSystemPath>,\n+    app_dir: FileSystemPath,\n     global_metadata: Vc<GlobalMetadata>,\n     app_page: AppPage,\n-    default_component: Option<Vc<FileSystemPath>>,\n+    default_component: Option<FileSystemPath>,\n ) -> Result<AppPageLoaderTree> {\n     Ok(AppPageLoaderTree {\n         page: app_page.clone(),\n         segment: rcstr!(\"__DEFAULT__\"),\n         parallel_routes: FxIndexMap::default(),\n         modules: if let Some(default) = default_component {\n             AppDirModules {\n-                default: Some(default.to_resolved().await?),\n+                default: Some(default),\n                 ..Default::default()\n             }\n         } else {\n             // default fallback component\n             AppDirModules {\n                 default: Some(\n                     get_next_package(app_dir)\n-                        .join(rcstr!(\"dist/client/components/builtin/default.js\"))\n-                        .to_resolved()\n-                        .await?,\n+                        .await?\n+                        .join(\"dist/client/components/builtin/default.js\")?,\n                 ),\n                 ..Default::default()\n             }\n@@ -1151,8 +1121,8 @@ async fn default_route_tree(\n \n #[turbo_tasks::function]\n async fn directory_tree_to_entrypoints_internal(\n-    app_dir: ResolvedVc<FileSystemPath>,\n-    global_metadata: Vc<GlobalMetadata>,\n+    app_dir: FileSystemPath,\n+    global_metadata: ResolvedVc<GlobalMetadata>,\n     is_global_not_found_enabled: Vc<bool>,\n     directory_name: RcStr,\n     directory_tree: Vc<DirectoryTree>,\n@@ -1174,8 +1144,8 @@ async fn directory_tree_to_entrypoints_internal(\n }\n \n async fn directory_tree_to_entrypoints_internal_untraced(\n-    app_dir: ResolvedVc<FileSystemPath>,\n-    global_metadata: Vc<GlobalMetadata>,\n+    app_dir: FileSystemPath,\n+    global_metadata: ResolvedVc<GlobalMetadata>,\n     is_global_not_found_enabled: Vc<bool>,\n     directory_name: RcStr,\n     directory_tree: Vc<DirectoryTree>,\n@@ -1192,9 +1162,9 @@ async fn directory_tree_to_entrypoints_internal_untraced(\n     // Route can have its own segment config, also can inherit from the layout root\n     // segment config. https://nextjs.org/docs/app/building-your-application/rendering/edge-and-nodejs-runtimes#segment-runtime-option\n     // Pass down layouts from each tree to apply segment config when adding route.\n-    let root_layouts = if let Some(layout) = modules.layout {\n+    let root_layouts = if let Some(layout) = &modules.layout {\n         let mut layouts = root_layouts.owned().await?;\n-        layouts.push(layout);\n+        layouts.push(layout.clone());\n         ResolvedVc::cell(layouts)\n     } else {\n         root_layouts\n@@ -1204,8 +1174,8 @@ async fn directory_tree_to_entrypoints_internal_untraced(\n         let app_path = AppPath::from(app_page.clone());\n \n         let loader_tree = *directory_tree_to_loader_tree(\n-            *app_dir,\n-            global_metadata,\n+            app_dir.clone(),\n+            *global_metadata,\n             directory_name.clone(),\n             directory_tree_vc,\n             app_page.clone(),\n@@ -1214,19 +1184,19 @@ async fn directory_tree_to_entrypoints_internal_untraced(\n         .await?;\n \n         add_app_page(\n-            app_dir,\n+            app_dir.clone(),\n             &mut result,\n             app_page.complete(PageType::Page)?,\n             loader_tree.context(\"loader tree should be created for a page/default\")?,\n         );\n     }\n \n-    if let Some(route) = modules.route {\n+    if let Some(route) = &modules.route {\n         add_app_route(\n-            app_dir,\n+            app_dir.clone(),\n             &mut result,\n             app_page.complete(PageType::Route)?,\n-            route,\n+            route.clone(),\n             root_layouts,\n         );\n     }\n@@ -1242,16 +1212,16 @@ async fn directory_tree_to_entrypoints_internal_untraced(\n \n     for meta in sitemap\n         .iter()\n-        .copied()\n-        .chain(icon.iter().copied().map(MetadataItem::from))\n-        .chain(apple.iter().copied().map(MetadataItem::from))\n-        .chain(twitter.iter().copied().map(MetadataItem::from))\n-        .chain(open_graph.iter().copied().map(MetadataItem::from))\n+        .cloned()\n+        .chain(icon.iter().cloned().map(MetadataItem::from))\n+        .chain(apple.iter().cloned().map(MetadataItem::from))\n+        .chain(twitter.iter().cloned().map(MetadataItem::from))\n+        .chain(open_graph.iter().cloned().map(MetadataItem::from))\n     {\n-        let app_page = app_page.clone_push_str(&get_metadata_route_name(meta).await?)?;\n+        let app_page = app_page.clone_push_str(&get_metadata_route_name(meta.clone()).await?)?;\n \n         add_app_metadata_route(\n-            app_dir,\n+            app_dir.clone(),\n             &mut result,\n             normalize_metadata_route(app_page)?,\n             meta,\n@@ -1267,13 +1237,14 @@ async fn directory_tree_to_entrypoints_internal_untraced(\n         } = &*global_metadata.await?;\n \n         for meta in favicon.iter().chain(robots.iter()).chain(manifest.iter()) {\n-            let app_page = app_page.clone_push_str(&get_metadata_route_name(*meta).await?)?;\n+            let app_page =\n+                app_page.clone_push_str(&get_metadata_route_name(meta.clone()).await?)?;\n \n             add_app_metadata_route(\n-                app_dir,\n+                app_dir.clone(),\n                 &mut result,\n                 normalize_metadata_route(app_page)?,\n-                *meta,\n+                meta.clone(),\n             );\n         }\n \n@@ -1282,35 +1253,31 @@ async fn directory_tree_to_entrypoints_internal_untraced(\n         // fill in the default modules for the not-found entrypoint\n         if modules.layout.is_none() {\n             modules.layout = Some(\n-                get_next_package(*app_dir)\n-                    .join(rcstr!(\"dist/client/components/builtin/layout.js\"))\n-                    .to_resolved()\n-                    .await?,\n+                get_next_package(app_dir.clone())\n+                    .await?\n+                    .join(\"dist/client/components/builtin/layout.js\")?,\n             );\n         }\n \n         if modules.not_found.is_none() {\n             modules.not_found = Some(\n-                get_next_package(*app_dir)\n-                    .join(rcstr!(\"dist/client/components/builtin/not-found.js\"))\n-                    .to_resolved()\n-                    .await?,\n+                get_next_package(app_dir.clone())\n+                    .await?\n+                    .join(\"dist/client/components/builtin/not-found.js\")?,\n             );\n         }\n         if modules.forbidden.is_none() {\n             modules.forbidden = Some(\n-                get_next_package(*app_dir)\n-                    .join(rcstr!(\"dist/client/components/builtin/forbidden.js\"))\n-                    .to_resolved()\n-                    .await?,\n+                get_next_package(app_dir.clone())\n+                    .await?\n+                    .join(\"dist/client/components/builtin/forbidden.js\")?,\n             );\n         }\n         if modules.unauthorized.is_none() {\n             modules.unauthorized = Some(\n-                get_next_package(*app_dir)\n-                    .join(rcstr!(\"dist/client/components/builtin/unauthorized.js\"))\n-                    .to_resolved()\n-                    .await?,\n+                get_next_package(app_dir.clone())\n+                    .await?\n+                    .join(\"dist/client/components/builtin/unauthorized.js\")?,\n             );\n         }\n \n@@ -1342,10 +1309,10 @@ async fn directory_tree_to_entrypoints_internal_untraced(\n                                     layout: None,\n                                     page: match modules.global_not_found {\n                                         Some(v) => Some(v),\n-                                        None => Some(get_next_package(*app_dir)\n-                                            .join(rcstr!(\"dist/client/components/builtin/global-not-found.js\"))\n-                                            .to_resolved()\n-                                            .await?),\n+                                        None =>  Some(get_next_package(app_dir.clone())\n+                                            .await?\n+                                            .join(\"dist/client/components/builtin/global-not-found.js\")?,\n+                                        ),\n                                     },\n                                     ..Default::default()\n                                 }\n@@ -1355,35 +1322,36 @@ async fn directory_tree_to_entrypoints_internal_untraced(\n                                 AppDirModules {\n                                     page: match modules.not_found {\n                                         Some(v) => Some(v),\n-                                        None => Some(get_next_package(*app_dir)\n-                                            .join(rcstr!(\"dist/client/components/builtin/not-found.js\"))\n-                                            .to_resolved()\n-                                            .await?),\n+                                        None => Some(get_next_package(app_dir.clone())\n+                                            .await?\n+                                            .join(\"dist/client/components/builtin/not-found.js\")?,\n+                                        ),\n                                     },\n                                     ..Default::default()\n                                 }\n                             },\n-                            global_metadata: global_metadata.to_resolved().await?,\n+                            global_metadata,\n                         }\n                     },\n                     modules: AppDirModules {\n                         ..Default::default()\n                     },\n-                    global_metadata: global_metadata.to_resolved().await?,\n+                    global_metadata,\n                 },\n             },\n             modules: AppDirModules {\n                 // `global-not-found.js` does not need a layout since it's included.\n                 // Skip it if it's present.\n-                // Otherwise, we need to compose it with the root layout to compose with not-found.js boundary.\n+                // Otherwise, we need to compose it with the root layout to compose with\n+                // not-found.js boundary.\n                 layout: if use_global_not_found {\n                     None\n                 } else {\n                     modules.layout\n                 },\n                 ..not_found_root_modules\n             },\n-            global_metadata: global_metadata.to_resolved().await?,\n+            global_metadata,\n         }\n         .resolved_cell();\n \n@@ -1392,84 +1360,88 @@ async fn directory_tree_to_entrypoints_internal_untraced(\n                 .clone_push_str(\"_not-found\")?\n                 .complete(PageType::Page)?;\n \n-            add_app_page(app_dir, &mut result, app_page, not_found_tree);\n+            add_app_page(app_dir.clone(), &mut result, app_page, not_found_tree);\n         }\n     }\n \n     let app_page = &app_page;\n     let directory_name = &directory_name;\n     let subdirectories = subdirectories\n         .iter()\n-        .map(|(subdir_name, &subdirectory)| async move {\n-            let mut child_app_page = app_page.clone();\n-            let mut illegal_path = None;\n-\n-            // When constructing the app_page fails (e. g. due to limitations of the order),\n-            // we only want to emit the error when there are actual pages below that\n-            // directory.\n-            if let Err(e) = child_app_page.push_str(&normalize_underscore(subdir_name)) {\n-                illegal_path = Some(e);\n-            }\n-\n-            let map = directory_tree_to_entrypoints_internal(\n-                *app_dir,\n-                global_metadata,\n-                is_global_not_found_enabled,\n-                subdir_name.clone(),\n-                *subdirectory,\n-                child_app_page.clone(),\n-                *root_layouts,\n-            )\n-            .await?;\n-\n-            if let Some(illegal_path) = illegal_path\n-                && !map.is_empty()\n-            {\n-                return Err(illegal_path);\n-            }\n+        .map(|(subdir_name, &subdirectory)| {\n+            let app_dir = app_dir.clone();\n+\n+            async move {\n+                let mut child_app_page = app_page.clone();\n+                let mut illegal_path = None;\n+\n+                // When constructing the app_page fails (e. g. due to limitations of the order),\n+                // we only want to emit the error when there are actual pages below that\n+                // directory.\n+                if let Err(e) = child_app_page.push_str(&normalize_underscore(subdir_name)) {\n+                    illegal_path = Some(e);\n+                }\n \n-            let mut loader_trees = Vec::new();\n+                let map = directory_tree_to_entrypoints_internal(\n+                    app_dir.clone(),\n+                    *global_metadata,\n+                    is_global_not_found_enabled,\n+                    subdir_name.clone(),\n+                    *subdirectory,\n+                    child_app_page.clone(),\n+                    *root_layouts,\n+                )\n+                .await?;\n \n-            for (_, entrypoint) in map.iter() {\n-                if let Entrypoint::AppPage {\n-                    ref pages,\n-                    loader_tree: _,\n-                } = *entrypoint\n+                if let Some(illegal_path) = illegal_path\n+                    && !map.is_empty()\n                 {\n-                    for page in pages {\n-                        let app_path = AppPath::from(page.clone());\n+                    return Err(illegal_path);\n+                }\n \n-                        let loader_tree = directory_tree_to_loader_tree(\n-                            *app_dir,\n-                            global_metadata,\n-                            directory_name.clone(),\n-                            directory_tree_vc,\n-                            app_page.clone(),\n-                            app_path,\n-                        );\n-                        loader_trees.push(loader_tree);\n+                let mut loader_trees = Vec::new();\n+\n+                for (_, entrypoint) in map.iter() {\n+                    if let Entrypoint::AppPage {\n+                        ref pages,\n+                        loader_tree: _,\n+                    } = *entrypoint\n+                    {\n+                        for page in pages {\n+                            let app_path = AppPath::from(page.clone());\n+\n+                            let loader_tree = directory_tree_to_loader_tree(\n+                                app_dir.clone(),\n+                                *global_metadata,\n+                                directory_name.clone(),\n+                                directory_tree_vc,\n+                                app_page.clone(),\n+                                app_path,\n+                            );\n+                            loader_trees.push(loader_tree);\n+                        }\n                     }\n                 }\n+                Ok((map, loader_trees))\n             }\n-            Ok((map, loader_trees))\n         })\n         .try_join()\n         .await?;\n \n     for (map, loader_trees) in subdirectories.iter() {\n         let mut i = 0;\n         for (_, entrypoint) in map.iter() {\n-            match *entrypoint {\n+            match entrypoint {\n                 Entrypoint::AppPage {\n-                    ref pages,\n+                    pages,\n                     loader_tree: _,\n                 } => {\n                     for page in pages {\n                         let loader_tree = *loader_trees[i].await?;\n                         i += 1;\n \n                         add_app_page(\n-                            app_dir,\n+                            app_dir.clone(),\n                             &mut result,\n                             page.clone(),\n                             loader_tree\n@@ -1478,14 +1450,25 @@ async fn directory_tree_to_entrypoints_internal_untraced(\n                     }\n                 }\n                 Entrypoint::AppRoute {\n-                    ref page,\n+                    page,\n                     path,\n                     root_layouts,\n                 } => {\n-                    add_app_route(app_dir, &mut result, page.clone(), path, root_layouts);\n+                    add_app_route(\n+                        app_dir.clone(),\n+                        &mut result,\n+                        page.clone(),\n+                        path.clone(),\n+                        *root_layouts,\n+                    );\n                 }\n-                Entrypoint::AppMetadata { ref page, metadata } => {\n-                    add_app_metadata_route(app_dir, &mut result, page.clone(), metadata);\n+                Entrypoint::AppMetadata { page, metadata } => {\n+                    add_app_metadata_route(\n+                        app_dir.clone(),\n+                        &mut result,\n+                        page.clone(),\n+                        metadata.clone(),\n+                    );\n                 }\n             }\n         }\n@@ -1496,7 +1479,7 @@ async fn directory_tree_to_entrypoints_internal_untraced(\n /// Returns the global metadata for an app directory.\n #[turbo_tasks::function]\n pub async fn get_global_metadata(\n-    app_dir: Vc<FileSystemPath>,\n+    app_dir: FileSystemPath,\n     page_extensions: Vc<Vec<RcStr>>,\n ) -> Result<Vc<GlobalMetadata>> {\n     let DirectoryContent::Entries(entries) = &*app_dir.read_dir().await? else {\n@@ -1505,7 +1488,7 @@ pub async fn get_global_metadata(\n     let mut metadata = GlobalMetadata::default();\n \n     for (basename, entry) in entries {\n-        let DirectoryEntry::File(file) = *entry else {\n+        let DirectoryEntry::File(file) = entry else {\n             continue;\n         };\n \n@@ -1525,9 +1508,9 @@ pub async fn get_global_metadata(\n         };\n \n         if dynamic {\n-            *entry = Some(MetadataItem::Dynamic { path: file });\n+            *entry = Some(MetadataItem::Dynamic { path: file.clone() });\n         } else {\n-            *entry = Some(MetadataItem::Static { path: file });\n+            *entry = Some(MetadataItem::Static { path: file.clone() });\n         }\n         // TODO(WEB-952) handle symlinks in app dir\n     }\n@@ -1538,7 +1521,7 @@ pub async fn get_global_metadata(\n #[turbo_tasks::value(shared)]\n struct DirectoryTreeIssue {\n     pub severity: IssueSeverity,\n-    pub app_dir: ResolvedVc<FileSystemPath>,\n+    pub app_dir: FileSystemPath,\n     pub message: ResolvedVc<StyledString>,\n }\n \n@@ -1560,7 +1543,7 @@ impl Issue for DirectoryTreeIssue {\n \n     #[turbo_tasks::function]\n     fn file_path(&self) -> Vc<FileSystemPath> {\n-        *self.app_dir\n+        self.app_dir.clone().cell()\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "43ddd007e49bc635a8c5e6a3af17cdbb93371f2c",
            "filename": "crates/next-core/src/base_loader_tree.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fbase_loader_tree.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fbase_loader_tree.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fbase_loader_tree.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -90,7 +90,7 @@ impl BaseLoaderTreeBuilder {\n     pub async fn create_module_tuple_code(\n         &mut self,\n         module_type: AppDirModuleType,\n-        path: ResolvedVc<FileSystemPath>,\n+        path: FileSystemPath,\n     ) -> Result<String> {\n         let name = module_type.name();\n         let i = self.unique_number();\n@@ -108,7 +108,7 @@ impl BaseLoaderTreeBuilder {\n         );\n \n         let module = self\n-            .process_source(Vc::upcast(FileSource::new(*path)))\n+            .process_source(Vc::upcast(FileSource::new(path.clone())))\n             .to_resolved()\n             .await?;\n "
        },
        {
            "sha": "32a4f44e85dcf448e8912486e49d5e99069e4afa",
            "filename": "crates/next-core/src/bootstrap.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fbootstrap.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fbootstrap.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fbootstrap.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -16,7 +16,7 @@ use turbopack_ecmascript::utils::StringifyJs;\n pub fn route_bootstrap(\n     asset: Vc<Box<dyn Module>>,\n     asset_context: Vc<Box<dyn AssetContext>>,\n-    base_path: Vc<FileSystemPath>,\n+    base_path: FileSystemPath,\n     bootstrap_asset: Vc<Box<dyn Source>>,\n     config: Vc<BootstrapConfig>,\n ) -> Vc<Box<dyn EvaluatableAsset>> {\n@@ -45,17 +45,17 @@ impl BootstrapConfig {\n pub async fn bootstrap(\n     asset: ResolvedVc<Box<dyn Module>>,\n     asset_context: Vc<Box<dyn AssetContext>>,\n-    base_path: Vc<FileSystemPath>,\n+    base_path: FileSystemPath,\n     bootstrap_asset: Vc<Box<dyn Source>>,\n     inner_assets: Vc<InnerAssets>,\n     config: Vc<BootstrapConfig>,\n ) -> Result<Vc<Box<dyn EvaluatableAsset>>> {\n     let path = asset.ident().path().await?;\n-    let Some(path) = base_path.await?.get_path_to(&path) else {\n+    let Some(path) = base_path.get_path_to(&path) else {\n         bail!(\n             \"asset {} is not in base path {}\",\n             asset.ident().to_string().await?,\n-            base_path.to_string().await?\n+            base_path.value_to_string().await?\n         );\n     };\n     let path = if let Some((name, ext)) = path.rsplit_once('.') {\n@@ -73,7 +73,7 @@ pub async fn bootstrap(\n     let config_asset = asset_context\n         .process(\n             Vc::upcast(VirtualSource::new(\n-                asset.ident().path().join(\"bootstrap-config.ts\".into()),\n+                asset.ident().path().await?.join(\"bootstrap-config.ts\")?,\n                 AssetContent::file(\n                     File::from(\n                         config"
        },
        {
            "sha": "67e44e35b3b7c6b97150e8decffd135082eb8d49",
            "filename": "crates/next-core/src/embed_js.rs",
            "status": "modified",
            "additions": 9,
            "deletions": 6,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fembed_js.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fembed_js.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fembed_js.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -1,3 +1,4 @@\n+use anyhow::Result;\n use turbo_rcstr::RcStr;\n use turbo_tasks::Vc;\n use turbo_tasks_fs::{FileContent, FileSystem, FileSystemPath};\n@@ -12,16 +13,18 @@ pub(crate) fn next_js_fs() -> Vc<Box<dyn FileSystem>> {\n }\n \n #[turbo_tasks::function]\n-pub(crate) fn next_js_file(path: RcStr) -> Vc<FileContent> {\n-    next_js_fs().root().join(path).read()\n+pub(crate) async fn next_js_file(path: RcStr) -> Result<Vc<FileContent>> {\n+    Ok(next_js_fs().root().await?.join(&path)?.read())\n }\n \n #[turbo_tasks::function]\n-pub(crate) fn next_js_file_path(path: RcStr) -> Vc<FileSystemPath> {\n-    next_js_fs().root().join(path)\n+pub(crate) async fn next_js_file_path(path: RcStr) -> Result<Vc<FileSystemPath>> {\n+    Ok(next_js_fs().root().await?.join(&path)?.cell())\n }\n \n #[turbo_tasks::function]\n-pub(crate) fn next_asset(path: RcStr) -> Vc<Box<dyn Source>> {\n-    Vc::upcast(FileSource::new(next_js_file_path(path)))\n+pub(crate) async fn next_asset(path: RcStr) -> Result<Vc<Box<dyn Source>>> {\n+    Ok(Vc::upcast(FileSource::new(\n+        next_js_file_path(path).await?.clone_value(),\n+    )))\n }"
        },
        {
            "sha": "6a2383ac4ece5a511e91c91d593456ae60ec7002",
            "filename": "crates/next-core/src/emit.rs",
            "status": "modified",
            "additions": 43,
            "deletions": 37,
            "changes": 80,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Femit.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Femit.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Femit.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -1,7 +1,7 @@\n use anyhow::Result;\n use tracing::Instrument;\n use turbo_tasks::{\n-    FxIndexSet, ResolvedVc, TryFlatJoinIterExt, ValueToString, Vc,\n+    FxIndexSet, ResolvedVc, TryFlatJoinIterExt, Vc,\n     graph::{AdjacencyMap, GraphTraversal},\n };\n use turbo_tasks_fs::{FileSystemPath, rebase};\n@@ -18,9 +18,9 @@ use turbopack_core::{\n #[turbo_tasks::function]\n pub async fn emit_all_assets(\n     assets: Vc<OutputAssets>,\n-    node_root: Vc<FileSystemPath>,\n-    client_relative_path: Vc<FileSystemPath>,\n-    client_output_path: Vc<FileSystemPath>,\n+    node_root: FileSystemPath,\n+    client_relative_path: FileSystemPath,\n+    client_output_path: FileSystemPath,\n ) -> Result<()> {\n     let _ = emit_assets(\n         all_assets_from_entries(assets),\n@@ -41,36 +41,41 @@ pub async fn emit_all_assets(\n #[turbo_tasks::function]\n pub async fn emit_assets(\n     assets: Vc<OutputAssets>,\n-    node_root: Vc<FileSystemPath>,\n-    client_relative_path: Vc<FileSystemPath>,\n-    client_output_path: Vc<FileSystemPath>,\n+    node_root: FileSystemPath,\n+    client_relative_path: FileSystemPath,\n+    client_output_path: FileSystemPath,\n ) -> Result<()> {\n     let _: Vec<Vc<()>> = assets\n         .await?\n         .iter()\n         .copied()\n-        .map(|asset| async move {\n-            let path = asset.path();\n-            let span = tracing::info_span!(\"emit asset\", name = %path.to_string().await?);\n+        .map(|asset| {\n+            let node_root = node_root.clone();\n+            let client_relative_path = client_relative_path.clone();\n+            let client_output_path = client_output_path.clone();\n+\n             async move {\n-                let path = path.await?;\n-                Ok(if path.is_inside_ref(&*node_root.await?) {\n-                    Some(emit(*asset))\n-                } else if path.is_inside_ref(&*client_relative_path.await?) {\n-                    // Client assets are emitted to the client output path, which is prefixed\n-                    // with _next. We need to rebase them to remove that\n-                    // prefix.\n-                    Some(emit_rebase(\n-                        *asset,\n-                        client_relative_path,\n-                        client_output_path,\n-                    ))\n-                } else {\n-                    None\n-                })\n+                let path = asset.path().await?.clone_value();\n+                let span = tracing::info_span!(\"emit asset\", name = %path.value_to_string().await?);\n+                async move {\n+                    Ok(if path.is_inside_ref(&node_root) {\n+                        Some(emit(*asset))\n+                    } else if path.is_inside_ref(&client_relative_path) {\n+                        // Client assets are emitted to the client output path, which is prefixed\n+                        // with _next. We need to rebase them to remove that\n+                        // prefix.\n+                        Some(emit_rebase(\n+                            *asset,\n+                            client_relative_path,\n+                            client_output_path,\n+                        ))\n+                    } else {\n+                        None\n+                    })\n+                }\n+                .instrument(span)\n+                .await\n             }\n-            .instrument(span)\n-            .await\n         })\n         .try_flat_join()\n         .await?;\n@@ -79,24 +84,25 @@ pub async fn emit_assets(\n \n #[turbo_tasks::function]\n async fn emit(asset: Vc<Box<dyn OutputAsset>>) -> Result<()> {\n-    let _ = asset.content().write(asset.path()).resolve().await?;\n+    let _ = asset\n+        .content()\n+        .write(asset.path().await?.clone_value())\n+        .resolve()\n+        .await?;\n     Ok(())\n }\n \n #[turbo_tasks::function]\n async fn emit_rebase(\n     asset: Vc<Box<dyn OutputAsset>>,\n-    from: Vc<FileSystemPath>,\n-    to: Vc<FileSystemPath>,\n+    from: FileSystemPath,\n+    to: FileSystemPath,\n ) -> Result<()> {\n-    let path = rebase(asset.path(), from, to);\n-    let content = asset.content();\n-    let _ = content\n-        .resolve()\n+    let path = rebase(asset.path().await?.clone_value(), from, to)\n         .await?\n-        .write(path.resolve().await?)\n-        .resolve()\n-        .await?;\n+        .clone_value();\n+    let content = asset.content();\n+    let _ = content.resolve().await?.write(path).resolve().await?;\n     Ok(())\n }\n "
        },
        {
            "sha": "ec7153431393f8cb0289e945cc095a9c4afe9851",
            "filename": "crates/next-core/src/hmr_entry.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 4,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fhmr_entry.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fhmr_entry.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fhmr_entry.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -28,12 +28,13 @@ use turbopack_ecmascript::{\n /// Each entry point in the HMR system has an ident with a different nested asset.\n /// This produces the 'base' ident for the HMR entry point, which is then modified\n #[turbo_tasks::function]\n-fn hmr_entry_point_base_ident() -> Vc<AssetIdent> {\n-    AssetIdent::from_path(\n+async fn hmr_entry_point_base_ident() -> Result<Vc<AssetIdent>> {\n+    Ok(AssetIdent::from_path(\n         VirtualFileSystem::new_with_name(rcstr!(\"hmr-entry\"))\n             .root()\n-            .join(rcstr!(\"hmr-entry.js\")),\n-    )\n+            .await?\n+            .join(\"hmr-entry.js\")?,\n+    ))\n }\n \n #[turbo_tasks::value(shared)]"
        },
        {
            "sha": "02b324fc43a8f3f6ce1e54337a3ebebeaed9f70b",
            "filename": "crates/next-core/src/middleware.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fmiddleware.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fmiddleware.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fmiddleware.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -24,7 +24,7 @@ pub async fn middleware_files(page_extensions: Vc<Vec<RcStr>>) -> Result<Vc<Vec<\n #[turbo_tasks::function]\n pub async fn get_middleware_module(\n     asset_context: Vc<Box<dyn AssetContext>>,\n-    project_root: Vc<FileSystemPath>,\n+    project_root: FileSystemPath,\n     userland_module: ResolvedVc<Box<dyn Module>>,\n ) -> Result<Vc<Box<dyn Module>>> {\n     const INNER: &str = \"INNER_MIDDLEWARE_MODULE\";"
        },
        {
            "sha": "c186ed858274991cab4af8ee9efa5d8e18bda3f5",
            "filename": "crates/next-core/src/next_app/app_client_references_chunks.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fapp_client_references_chunks.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fapp_client_references_chunks.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fapp_client_references_chunks.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -1,7 +1,7 @@\n use anyhow::Result;\n use tracing::Instrument;\n use turbo_rcstr::rcstr;\n-use turbo_tasks::{FxIndexMap, ResolvedVc, TryFlatJoinIterExt, TryJoinIterExt, ValueToString, Vc};\n+use turbo_tasks::{FxIndexMap, ResolvedVc, TryFlatJoinIterExt, TryJoinIterExt, Vc};\n use turbopack_core::{\n     chunk::{ChunkingContext, availability_info::AvailabilityInfo},\n     module::Module,\n@@ -179,9 +179,9 @@ pub async fn get_app_client_references_chunks(\n \n                 let base_ident = server_component.ident();\n \n-                let server_path = server_component.server_path();\n-                let is_layout = server_path.file_stem().await?.as_deref() == Some(\"layout\");\n-                let server_component_path = server_path.to_string().await?;\n+                let server_path = server_component.server_path().await?.clone_value();\n+                let is_layout = server_path.file_stem() == Some(\"layout\");\n+                let server_component_path = server_path.value_to_string().await?;\n \n                 let ssr_modules = client_reference_types\n                     .iter()"
        },
        {
            "sha": "6bec9ba635f40c8280ebf00f5531dc4d2405320a",
            "filename": "crates/next-core/src/next_app/app_page_entry.rs",
            "status": "modified",
            "additions": 11,
            "deletions": 7,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fapp_page_entry.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fapp_page_entry.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fapp_page_entry.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -2,7 +2,7 @@ use std::io::Write;\n \n use anyhow::Result;\n use turbo_rcstr::RcStr;\n-use turbo_tasks::{ResolvedVc, TryJoinIterExt, ValueToString, Vc, fxindexmap};\n+use turbo_tasks::{ResolvedVc, TryJoinIterExt, Vc, fxindexmap};\n use turbo_tasks_fs::{self, File, FileSystemPath, rope::RopeBuilder};\n use turbopack::ModuleAssetContext;\n use turbopack_core::{\n@@ -37,7 +37,7 @@ pub async fn get_app_page_entry(\n     edge_context: ResolvedVc<ModuleAssetContext>,\n     loader_tree: Vc<AppPageLoaderTree>,\n     page: AppPage,\n-    project_root: Vc<FileSystemPath>,\n+    project_root: FileSystemPath,\n     next_config: Vc<NextConfig>,\n ) -> Result<Vc<AppEntry>> {\n     let config = parse_segment_config_from_loader_tree(loader_tree);\n@@ -73,15 +73,19 @@ pub async fn get_app_page_entry(\n         writeln!(result, \"{import}\")?;\n     }\n \n-    let pages = pages.iter().map(|page| page.to_string()).try_join().await?;\n+    let pages = pages\n+        .iter()\n+        .map(|page| page.value_to_string())\n+        .try_join()\n+        .await?;\n \n     let original_name: RcStr = page.to_string().into();\n     let pathname: RcStr = AppPath::from(page.clone()).to_string().into();\n \n     // Load the file from the next.js codebase.\n     let source = load_next_js_template(\n         \"app-page.js\",\n-        project_root,\n+        project_root.clone(),\n         fxindexmap! {\n             \"VAR_DEFINITION_PAGE\" => page.to_string().into(),\n             \"VAR_DEFINITION_PATHNAME\" => pathname.clone(),\n@@ -123,7 +127,7 @@ pub async fn get_app_page_entry(\n     if is_edge {\n         rsc_entry = wrap_edge_page(\n             *ResolvedVc::upcast(module_asset_context),\n-            project_root,\n+            project_root.clone(),\n             rsc_entry,\n             page,\n             next_config,\n@@ -142,7 +146,7 @@ pub async fn get_app_page_entry(\n #[turbo_tasks::function]\n async fn wrap_edge_page(\n     asset_context: Vc<Box<dyn AssetContext>>,\n-    project_root: Vc<FileSystemPath>,\n+    project_root: FileSystemPath,\n     entry: ResolvedVc<Box<dyn Module>>,\n     page: AppPage,\n     next_config: Vc<NextConfig>,\n@@ -169,7 +173,7 @@ async fn wrap_edge_page(\n \n     let source = load_next_js_template(\n         \"edge-ssr-app.js\",\n-        project_root,\n+        project_root.clone(),\n         fxindexmap! {\n             \"VAR_USERLAND\" => INNER.into(),\n             \"VAR_PAGE\" => page.to_string().into(),"
        },
        {
            "sha": "6310be542bc3a036ec91465f48d0db731dcca28e",
            "filename": "crates/next-core/src/next_app/app_route_entry.rs",
            "status": "modified",
            "additions": 9,
            "deletions": 9,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fapp_route_entry.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fapp_route_entry.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fapp_route_entry.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -1,6 +1,6 @@\n use anyhow::Result;\n use turbo_rcstr::RcStr;\n-use turbo_tasks::{ResolvedVc, ValueToString, Vc, fxindexmap};\n+use turbo_tasks::{ResolvedVc, Vc, fxindexmap};\n use turbo_tasks_fs::FileSystemPath;\n use turbopack::ModuleAssetContext;\n use turbopack_core::{\n@@ -32,7 +32,7 @@ pub async fn get_app_route_entry(\n     edge_context: Vc<ModuleAssetContext>,\n     source: Vc<Box<dyn Source>>,\n     page: AppPage,\n-    project_root: Vc<FileSystemPath>,\n+    project_root: FileSystemPath,\n     original_segment_config: Option<Vc<NextSegmentConfig>>,\n     next_config: Vc<NextConfig>,\n ) -> Result<Vc<AppEntry>> {\n@@ -55,7 +55,7 @@ pub async fn get_app_route_entry(\n     let original_name: RcStr = page.to_string().into();\n     let pathname: RcStr = AppPath::from(page.clone()).to_string().into();\n \n-    let path = source.ident().path();\n+    let path = source.ident().path().await?.clone_value();\n \n     const INNER: &str = \"INNER_APP_ROUTE\";\n \n@@ -73,14 +73,14 @@ pub async fn get_app_route_entry(\n     // Load the file from the next.js codebase.\n     let virtual_source = load_next_js_template(\n         \"app-route.js\",\n-        project_root,\n+        project_root.clone(),\n         fxindexmap! {\n             \"VAR_DEFINITION_PAGE\" => page.to_string().into(),\n             \"VAR_DEFINITION_PATHNAME\" => pathname.clone(),\n-            \"VAR_DEFINITION_FILENAME\" => path.file_stem().await?.as_ref().unwrap().as_str().into(),\n+            \"VAR_DEFINITION_FILENAME\" => path.file_stem().unwrap().into(),\n             // TODO(alexkirsz) Is this necessary?\n             \"VAR_DEFINITION_BUNDLE_PATH\" => \"\".to_string().into(),\n-            \"VAR_RESOLVED_PAGE_PATH\" => path.to_string().owned().await?,\n+            \"VAR_RESOLVED_PAGE_PATH\" => path.value_to_string().owned().await?,\n             \"VAR_USERLAND\" => INNER.into(),\n         },\n         fxindexmap! {\n@@ -132,7 +132,7 @@ pub async fn get_app_route_entry(\n #[turbo_tasks::function]\n async fn wrap_edge_route(\n     asset_context: Vc<Box<dyn AssetContext>>,\n-    project_root: Vc<FileSystemPath>,\n+    project_root: FileSystemPath,\n     entry: ResolvedVc<Box<dyn Module>>,\n     page: AppPage,\n     next_config: Vc<NextConfig>,\n@@ -143,7 +143,7 @@ async fn wrap_edge_route(\n \n     let source = load_next_js_template(\n         \"edge-app-route.js\",\n-        project_root,\n+        project_root.clone(),\n         fxindexmap! {\n             \"VAR_USERLAND\" => INNER.into(),\n             \"VAR_PAGE\" => page.to_string().into(),\n@@ -168,7 +168,7 @@ async fn wrap_edge_route(\n \n     Ok(wrap_edge_entry(\n         asset_context,\n-        project_root,\n+        project_root.clone(),\n         wrapped,\n         AppPath::from(page).to_string().into(),\n     ))"
        },
        {
            "sha": "74eb264d02d657ae2767bfe35b0b36d45e232304",
            "filename": "crates/next-core/src/next_app/metadata/image.rs",
            "status": "modified",
            "additions": 13,
            "deletions": 10,
            "changes": 23,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fmetadata%2Fimage.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fmetadata%2Fimage.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fmetadata%2Fimage.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -5,7 +5,7 @@\n use anyhow::{Result, bail};\n use indoc::formatdoc;\n use turbo_rcstr::RcStr;\n-use turbo_tasks::{ValueToString, Vc};\n+use turbo_tasks::Vc;\n use turbo_tasks_fs::{File, FileContent, FileSystemPath};\n use turbo_tasks_hash::hash_xxh3_hash64;\n use turbopack_core::{\n@@ -24,7 +24,7 @@ use turbopack_ecmascript::{\n \n use crate::next_app::AppPage;\n \n-async fn hash_file_content(path: Vc<FileSystemPath>) -> Result<u64> {\n+async fn hash_file_content(path: FileSystemPath) -> Result<u64> {\n     let original_file_content = path.read().await?;\n \n     Ok(match &*original_file_content {\n@@ -33,23 +33,26 @@ async fn hash_file_content(path: Vc<FileSystemPath>) -> Result<u64> {\n             hash_xxh3_hash64(&*content)\n         }\n         FileContent::NotFound => {\n-            bail!(\"metadata file not found: {}\", &path.to_string().await?);\n+            bail!(\n+                \"metadata file not found: {}\",\n+                &path.value_to_string().await?\n+            );\n         }\n     })\n }\n \n #[turbo_tasks::function]\n pub async fn dynamic_image_metadata_source(\n     asset_context: Vc<Box<dyn AssetContext>>,\n-    path: Vc<FileSystemPath>,\n+    path: FileSystemPath,\n     ty: RcStr,\n     page: AppPage,\n ) -> Result<Vc<Box<dyn Source>>> {\n-    let stem = path.file_stem().await?;\n-    let stem = stem.as_deref().unwrap_or_default();\n-    let ext = &*path.extension().await?;\n+    let stem = path.file_stem();\n+    let stem = stem.unwrap_or_default();\n+    let ext = path.extension();\n \n-    let hash_query = format!(\"?{:x}\", hash_file_content(path).await?);\n+    let hash_query = format!(\"?{:x}\", hash_file_content(path.clone()).await?);\n \n     let use_numeric_sizes = ty == \"twitter\" || ty == \"openGraph\";\n     let sizes = if use_numeric_sizes {\n@@ -71,7 +74,7 @@ pub async fn dynamic_image_metadata_source(\n         format!(\"data.sizes = `{sizes}`;\")\n     };\n \n-    let source = Vc::upcast(FileSource::new(path));\n+    let source = Vc::upcast(FileSource::new(path.clone()));\n     let module = asset_context\n         .process(\n             source,\n@@ -133,7 +136,7 @@ pub async fn dynamic_image_metadata_source(\n \n     let file = File::from(code);\n     let source = VirtualSource::new(\n-        path.parent().join(format!(\"{stem}--metadata.js\").into()),\n+        path.parent().join(&format!(\"{stem}--metadata.js\"))?,\n         AssetContent::file(file.into()),\n     );\n "
        },
        {
            "sha": "62a62812d7f95e3a14f0e5d658f445781c0b1de9",
            "filename": "crates/next-core/src/next_app/metadata/mod.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 6,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fmetadata%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fmetadata%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fmetadata%2Fmod.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -4,7 +4,6 @@ use anyhow::Result;\n use once_cell::sync::Lazy;\n use rustc_hash::FxHashMap;\n use turbo_rcstr::RcStr;\n-use turbo_tasks::Vc;\n use turbo_tasks_fs::FileSystemPath;\n \n use crate::next_app::{AppPage, PageSegment, PageType};\n@@ -83,12 +82,11 @@ fn match_metadata_file<'a>(\n     })\n }\n \n-pub(crate) async fn get_content_type(path: Vc<FileSystemPath>) -> Result<String> {\n-    let stem = &*path.file_stem().await?;\n-    let ext = &*path.extension().await?;\n+pub(crate) async fn get_content_type(path: FileSystemPath) -> Result<String> {\n+    let stem = path.file_stem();\n+    let mut ext = path.extension();\n \n-    let name = stem.as_deref().unwrap_or_default();\n-    let mut ext = ext.as_str();\n+    let name = stem.unwrap_or_default();\n     if ext == \"jpg\" {\n         ext = \"jpeg\"\n     }"
        },
        {
            "sha": "a0568ba9e347a3c03745e562a8c3c627a6d7ee08",
            "filename": "crates/next-core/src/next_app/metadata/route.rs",
            "status": "modified",
            "additions": 39,
            "deletions": 39,
            "changes": 78,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fmetadata%2Froute.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fmetadata%2Froute.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fmetadata%2Froute.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -5,7 +5,7 @@\n use anyhow::{Ok, Result, bail};\n use base64::{display::Base64Display, engine::general_purpose::STANDARD};\n use indoc::{formatdoc, indoc};\n-use turbo_tasks::{ValueToString, Vc};\n+use turbo_tasks::Vc;\n use turbo_tasks_fs::{self, File, FileContent, FileSystemPath};\n use turbopack::ModuleAssetContext;\n use turbopack_core::{\n@@ -32,17 +32,17 @@ pub async fn get_app_metadata_route_source(\n     is_multi_dynamic: bool,\n ) -> Result<Vc<Box<dyn Source>>> {\n     Ok(match metadata {\n-        MetadataItem::Static { path } => static_route_source(mode, *path),\n+        MetadataItem::Static { path } => static_route_source(mode, path),\n         MetadataItem::Dynamic { path } => {\n-            let stem = path.file_stem().await?;\n-            let stem = stem.as_deref().unwrap_or_default();\n+            let stem = path.file_stem();\n+            let stem = stem.unwrap_or_default();\n \n             if stem == \"robots\" || stem == \"manifest\" {\n-                dynamic_text_route_source(*path)\n+                dynamic_text_route_source(path)\n             } else if stem == \"sitemap\" {\n-                dynamic_site_map_route_source(mode, *path, is_multi_dynamic)\n+                dynamic_site_map_route_source(mode, path, is_multi_dynamic)\n             } else {\n-                dynamic_image_route_source(*path)\n+                dynamic_image_route_source(path)\n             }\n         }\n     })\n@@ -52,17 +52,17 @@ pub async fn get_app_metadata_route_source(\n pub async fn get_app_metadata_route_entry(\n     nodejs_context: Vc<ModuleAssetContext>,\n     edge_context: Vc<ModuleAssetContext>,\n-    project_root: Vc<FileSystemPath>,\n+    project_root: FileSystemPath,\n     mut page: AppPage,\n     mode: NextMode,\n     metadata: MetadataItem,\n     next_config: Vc<NextConfig>,\n ) -> Vc<AppEntry> {\n     // Read original source's segment config before replacing source into\n     // dynamic|static metadata route handler.\n-    let original_path = metadata.into_path();\n+    let original_path = metadata.clone().into_path();\n \n-    let source = Vc::upcast(FileSource::new(*original_path));\n+    let source = Vc::upcast(FileSource::new(original_path));\n     let segment_config = parse_segment_config_from_source(source);\n     let is_dynamic_metadata = matches!(metadata, MetadataItem::Dynamic { .. });\n     let is_multi_dynamic: bool = if Some(segment_config).is_some() {\n@@ -112,7 +112,7 @@ const CACHE_HEADER_NONE: &str = \"no-cache, no-store\";\n const CACHE_HEADER_LONG_CACHE: &str = \"public, immutable, no-transform, max-age=31536000\";\n const CACHE_HEADER_REVALIDATE: &str = \"public, max-age=0, must-revalidate\";\n \n-async fn get_base64_file_content(path: Vc<FileSystemPath>) -> Result<String> {\n+async fn get_base64_file_content(path: FileSystemPath) -> Result<String> {\n     let original_file_content = path.read().await?;\n \n     Ok(match &*original_file_content {\n@@ -121,20 +121,20 @@ async fn get_base64_file_content(path: Vc<FileSystemPath>) -> Result<String> {\n             Base64Display::new(&content, &STANDARD).to_string()\n         }\n         FileContent::NotFound => {\n-            bail!(\"metadata file not found: {}\", &path.to_string().await?);\n+            bail!(\n+                \"metadata file not found: {}\",\n+                &path.value_to_string().await?\n+            );\n         }\n     })\n }\n \n #[turbo_tasks::function]\n-async fn static_route_source(\n-    mode: NextMode,\n-    path: Vc<FileSystemPath>,\n-) -> Result<Vc<Box<dyn Source>>> {\n-    let stem = path.file_stem().await?;\n-    let stem = stem.as_deref().unwrap_or_default();\n+async fn static_route_source(mode: NextMode, path: FileSystemPath) -> Result<Vc<Box<dyn Source>>> {\n+    let stem = path.file_stem();\n+    let stem = stem.unwrap_or_default();\n \n-    let content_type = get_content_type(path).await?;\n+    let content_type = get_content_type(path.clone()).await?;\n \n     let cache_control = if stem == \"favicon\" {\n         CACHE_HEADER_REVALIDATE\n@@ -144,7 +144,7 @@ async fn static_route_source(\n         CACHE_HEADER_NONE\n     };\n \n-    let original_file_content_b64 = get_base64_file_content(path).await?;\n+    let original_file_content_b64 = get_base64_file_content(path.clone()).await?;\n \n     let is_twitter = stem == \"twitter-image\";\n     let is_open_graph = stem == \"opengraph-image\";\n@@ -191,25 +191,25 @@ async fn static_route_source(\n         is_open_graph = is_open_graph,\n         file_size_limit = file_size_limit,\n         img_name = img_name,\n-        path = StringifyJs(&path.to_string().await?),\n+        path = StringifyJs(&path.value_to_string().await?),\n     };\n \n     let file = File::from(code);\n     let source = VirtualSource::new(\n-        path.parent().join(format!(\"{stem}--route-entry.js\").into()),\n+        path.parent().join(&format!(\"{stem}--route-entry.js\"))?,\n         AssetContent::file(file.into()),\n     );\n \n     Ok(Vc::upcast(source))\n }\n \n #[turbo_tasks::function]\n-async fn dynamic_text_route_source(path: Vc<FileSystemPath>) -> Result<Vc<Box<dyn Source>>> {\n-    let stem = path.file_stem().await?;\n-    let stem = stem.as_deref().unwrap_or_default();\n-    let ext = &*path.extension().await?;\n+async fn dynamic_text_route_source(path: FileSystemPath) -> Result<Vc<Box<dyn Source>>> {\n+    let stem = path.file_stem();\n+    let stem = stem.unwrap_or_default();\n+    let ext = path.extension();\n \n-    let content_type = get_content_type(path).await?;\n+    let content_type = get_content_type(path.clone()).await?;\n \n     // refer https://github.com/vercel/next.js/blob/7b2b9823432fb1fa28ae0ac3878801d638d93311/packages/next/src/build/webpack/loaders/next-metadata-route-loader.ts#L84\n     // for the original template.\n@@ -250,7 +250,7 @@ async fn dynamic_text_route_source(path: Vc<FileSystemPath>) -> Result<Vc<Box<dy\n \n     let file = File::from(code);\n     let source = VirtualSource::new(\n-        path.parent().join(format!(\"{stem}--route-entry.js\").into()),\n+        path.parent().join(&format!(\"{stem}--route-entry.js\"))?,\n         AssetContent::file(file.into()),\n     );\n \n@@ -260,13 +260,13 @@ async fn dynamic_text_route_source(path: Vc<FileSystemPath>) -> Result<Vc<Box<dy\n #[turbo_tasks::function]\n async fn dynamic_site_map_route_source(\n     mode: NextMode,\n-    path: Vc<FileSystemPath>,\n+    path: FileSystemPath,\n     is_multi_dynamic: bool,\n ) -> Result<Vc<Box<dyn Source>>> {\n-    let stem = path.file_stem().await?;\n-    let stem = stem.as_deref().unwrap_or_default();\n-    let ext = &*path.extension().await?;\n-    let content_type = get_content_type(path).await?;\n+    let stem = path.file_stem();\n+    let stem = stem.unwrap_or_default();\n+    let ext = path.extension();\n+    let content_type = get_content_type(path.clone()).await?;\n     let mut static_generation_code = \"\";\n \n     if mode.is_production() && is_multi_dynamic {\n@@ -345,18 +345,18 @@ async fn dynamic_site_map_route_source(\n \n     let file = File::from(code);\n     let source = VirtualSource::new(\n-        path.parent().join(format!(\"{stem}--route-entry.js\").into()),\n+        path.parent().join(&format!(\"{stem}--route-entry.js\"))?,\n         AssetContent::file(file.into()),\n     );\n \n     Ok(Vc::upcast(source))\n }\n \n #[turbo_tasks::function]\n-async fn dynamic_image_route_source(path: Vc<FileSystemPath>) -> Result<Vc<Box<dyn Source>>> {\n-    let stem = path.file_stem().await?;\n-    let stem = stem.as_deref().unwrap_or_default();\n-    let ext = &*path.extension().await?;\n+async fn dynamic_image_route_source(path: FileSystemPath) -> Result<Vc<Box<dyn Source>>> {\n+    let stem = path.file_stem();\n+    let stem = stem.unwrap_or_default();\n+    let ext = path.extension();\n \n     let code = formatdoc! {\n         r#\"\n@@ -407,7 +407,7 @@ async fn dynamic_image_route_source(path: Vc<FileSystemPath>) -> Result<Vc<Box<d\n \n     let file = File::from(code);\n     let source = VirtualSource::new(\n-        path.parent().join(format!(\"{stem}--route-entry.js\").into()),\n+        path.parent().join(&format!(\"{stem}--route-entry.js\"))?,\n         AssetContent::file(file.into()),\n     );\n "
        },
        {
            "sha": "3c88cff9c384cc8d271e209a186cbca64a9190d7",
            "filename": "crates/next-core/src/next_build.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 4,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_build.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_build.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_build.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -1,21 +1,22 @@\n use anyhow::Result;\n use turbo_rcstr::RcStr;\n-use turbo_tasks::{ResolvedVc, Vc};\n+use turbo_tasks::Vc;\n use turbo_tasks_fs::FileSystemPath;\n use turbopack_core::resolve::{ExternalTraced, ExternalType, options::ImportMapping};\n \n use crate::next_import_map::get_next_package;\n \n #[turbo_tasks::function]\n pub async fn get_postcss_package_mapping(\n-    project_path: ResolvedVc<FileSystemPath>,\n+    project_path: FileSystemPath,\n ) -> Result<Vc<ImportMapping>> {\n     Ok(ImportMapping::Alternatives(vec![\n         // Prefer the local installed version over the next.js version\n-        ImportMapping::PrimaryAlternative(\"postcss\".into(), Some(project_path)).resolved_cell(),\n+        ImportMapping::PrimaryAlternative(\"postcss\".into(), Some(project_path.clone()))\n+            .resolved_cell(),\n         ImportMapping::PrimaryAlternative(\n             \"postcss\".into(),\n-            Some(get_next_package(*project_path).to_resolved().await?),\n+            Some(get_next_package(project_path.clone()).await?.clone_value()),\n         )\n         .resolved_cell(),\n     ])"
        },
        {
            "sha": "7429f42faefc61f37c8bc89362efbed31a5cc949",
            "filename": "crates/next-core/src/next_client/context.rs",
            "status": "modified",
            "additions": 60,
            "deletions": 57,
            "changes": 117,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_client%2Fcontext.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_client%2Fcontext.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_client%2Fcontext.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -2,7 +2,7 @@ use std::iter::once;\n \n use anyhow::Result;\n use turbo_rcstr::{RcStr, rcstr};\n-use turbo_tasks::{FxIndexMap, OptionVcExt, ResolvedVc, TaskInput, Vc};\n+use turbo_tasks::{FxIndexMap, ResolvedVc, TaskInput, Vc};\n use turbo_tasks_env::EnvMap;\n use turbo_tasks_fs::FileSystemPath;\n use turbopack::{\n@@ -140,40 +140,41 @@ pub async fn get_client_compile_time_info(\n }\n \n #[turbo_tasks::value(shared)]\n-#[derive(Debug, Copy, Clone, Hash, TaskInput)]\n+#[derive(Debug, Clone, Hash, TaskInput)]\n pub enum ClientContextType {\n-    Pages {\n-        pages_dir: ResolvedVc<FileSystemPath>,\n-    },\n-    App {\n-        app_dir: ResolvedVc<FileSystemPath>,\n-    },\n+    Pages { pages_dir: FileSystemPath },\n+    App { app_dir: FileSystemPath },\n     Fallback,\n     Other,\n }\n \n #[turbo_tasks::function]\n pub async fn get_client_resolve_options_context(\n-    project_path: ResolvedVc<FileSystemPath>,\n+    project_path: FileSystemPath,\n     ty: ClientContextType,\n     mode: Vc<NextMode>,\n     next_config: Vc<NextConfig>,\n     execution_context: Vc<ExecutionContext>,\n ) -> Result<Vc<ResolveOptionsContext>> {\n-    let next_client_import_map =\n-        get_next_client_import_map(*project_path, ty, next_config, mode, execution_context)\n-            .to_resolved()\n-            .await?;\n-    let next_client_fallback_import_map = get_next_client_fallback_import_map(ty)\n+    let next_client_import_map = get_next_client_import_map(\n+        project_path.clone(),\n+        ty.clone(),\n+        next_config,\n+        mode,\n+        execution_context,\n+    )\n+    .to_resolved()\n+    .await?;\n+    let next_client_fallback_import_map = get_next_client_fallback_import_map(ty.clone())\n         .to_resolved()\n         .await?;\n     let next_client_resolved_map =\n-        get_next_client_resolved_map(*project_path, project_path, *mode.await?)\n+        get_next_client_resolved_map(project_path.clone(), project_path.clone(), *mode.await?)\n             .to_resolved()\n             .await?;\n     let custom_conditions = vec![mode.await?.condition().into()];\n     let resolve_options_context = ResolveOptionsContext {\n-        enable_node_modules: Some(project_path.root().to_resolved().await?),\n+        enable_node_modules: Some(project_path.root().await?.clone_value()),\n         custom_conditions,\n         import_map: Some(next_client_import_map),\n         fallback_import_map: Some(next_client_fallback_import_map),\n@@ -182,23 +183,23 @@ pub async fn get_client_resolve_options_context(\n         module: true,\n         before_resolve_plugins: vec![\n             ResolvedVc::upcast(\n-                get_invalid_server_only_resolve_plugin(project_path)\n+                get_invalid_server_only_resolve_plugin(project_path.clone())\n                     .to_resolved()\n                     .await?,\n             ),\n             ResolvedVc::upcast(\n-                ModuleFeatureReportResolvePlugin::new(*project_path)\n+                ModuleFeatureReportResolvePlugin::new(project_path.clone())\n                     .to_resolved()\n                     .await?,\n             ),\n             ResolvedVc::upcast(\n-                NextFontLocalResolvePlugin::new(*project_path)\n+                NextFontLocalResolvePlugin::new(project_path.clone())\n                     .to_resolved()\n                     .await?,\n             ),\n         ],\n         after_resolve_plugins: vec![ResolvedVc::upcast(\n-            NextSharedRuntimeResolvePlugin::new(*project_path)\n+            NextSharedRuntimeResolvePlugin::new(project_path.clone())\n                 .to_resolved()\n                 .await?,\n         )],\n@@ -214,9 +215,8 @@ pub async fn get_client_resolve_options_context(\n             .typescript_tsconfig_path()\n             .await?\n             .as_ref()\n-            .map(|p| project_path.join(p.to_owned()))\n-            .to_resolved()\n-            .await?,\n+            .map(|p| project_path.join(p))\n+            .transpose()?,\n         rules: vec![(\n             foreign_code_context_condition(next_config, project_path).await?,\n             resolve_options_context.clone().resolved_cell(),\n@@ -228,7 +228,7 @@ pub async fn get_client_resolve_options_context(\n \n #[turbo_tasks::function]\n pub async fn get_client_module_options_context(\n-    project_path: ResolvedVc<FileSystemPath>,\n+    project_path: FileSystemPath,\n     execution_context: ResolvedVc<ExecutionContext>,\n     env: ResolvedVc<Environment>,\n     ty: ClientContextType,\n@@ -239,20 +239,20 @@ pub async fn get_client_module_options_context(\n ) -> Result<Vc<ModuleOptionsContext>> {\n     let next_mode = mode.await?;\n     let resolve_options_context = get_client_resolve_options_context(\n-        *project_path,\n-        ty,\n+        project_path.clone(),\n+        ty.clone(),\n         mode,\n         next_config,\n         *execution_context,\n     );\n \n-    let tsconfig = get_typescript_transform_options(*project_path)\n+    let tsconfig = get_typescript_transform_options(project_path.clone())\n         .to_resolved()\n         .await?;\n-    let decorators_options = get_decorators_transform_options(*project_path);\n+    let decorators_options = get_decorators_transform_options(project_path.clone());\n     let enable_mdx_rs = *next_config.mdx_rs().await?;\n     let jsx_runtime_options = get_jsx_transform_options(\n-        *project_path,\n+        project_path.clone(),\n         mode,\n         Some(resolve_options_context),\n         false,\n@@ -267,7 +267,7 @@ pub async fn get_client_module_options_context(\n     // does by default.\n     let conditions = vec![rcstr!(\"browser\"), mode.await?.condition().into()];\n     let foreign_enable_webpack_loaders = webpack_loader_options(\n-        project_path,\n+        project_path.clone(),\n         next_config,\n         true,\n         conditions\n@@ -280,7 +280,7 @@ pub async fn get_client_module_options_context(\n \n     // Now creates a webpack rules that applies to all codes.\n     let enable_webpack_loaders =\n-        webpack_loader_options(project_path, next_config, false, conditions).await?;\n+        webpack_loader_options(project_path.clone(), next_config, false, conditions).await?;\n \n     let tree_shaking_mode_for_user_code = *next_config\n         .tree_shaking_mode_for_user_code(next_mode.is_development())\n@@ -291,12 +291,14 @@ pub async fn get_client_module_options_context(\n     let target_browsers = env.runtime_versions();\n \n     let mut next_client_rules =\n-        get_next_client_transforms_rules(next_config, ty, mode, false, encryption_key).await?;\n+        get_next_client_transforms_rules(next_config, ty.clone(), mode, false, encryption_key)\n+            .await?;\n     let foreign_next_client_rules =\n-        get_next_client_transforms_rules(next_config, ty, mode, true, encryption_key).await?;\n+        get_next_client_transforms_rules(next_config, ty.clone(), mode, true, encryption_key)\n+            .await?;\n     let additional_rules: Vec<ModuleRule> = vec![\n-        get_swc_ecma_transform_plugin_rule(next_config, project_path).await?,\n-        get_relay_transform_rule(next_config, project_path).await?,\n+        get_swc_ecma_transform_plugin_rule(next_config, project_path.clone()).await?,\n+        get_relay_transform_rule(next_config, project_path.clone()).await?,\n         get_emotion_transform_rule(next_config).await?,\n         get_styled_components_transform_rule(next_config).await?,\n         get_styled_jsx_transform_rule(next_config, target_browsers).await?,\n@@ -311,7 +313,7 @@ pub async fn get_client_module_options_context(\n \n     let postcss_transform_options = PostCssTransformOptions {\n         postcss_package: Some(\n-            get_postcss_package_mapping(*project_path)\n+            get_postcss_package_mapping(project_path.clone())\n                 .to_resolved()\n                 .await?,\n         ),\n@@ -424,8 +426,8 @@ pub async fn get_client_module_options_context(\n \n #[turbo_tasks::function]\n pub async fn get_client_chunking_context(\n-    root_path: ResolvedVc<FileSystemPath>,\n-    client_root: ResolvedVc<FileSystemPath>,\n+    root_path: FileSystemPath,\n+    client_root: FileSystemPath,\n     client_root_to_root_path: RcStr,\n     asset_prefix: ResolvedVc<Option<RcStr>>,\n     chunk_suffix_path: ResolvedVc<Option<RcStr>>,\n@@ -442,14 +444,13 @@ pub async fn get_client_chunking_context(\n     let chunk_suffix_path = chunk_suffix_path.owned().await?;\n     let mut builder = BrowserChunkingContext::builder(\n         root_path,\n-        client_root,\n+        client_root.clone(),\n         client_root_to_root_path,\n-        client_root,\n-        client_root\n-            .join(rcstr!(\"static/chunks\"))\n-            .to_resolved()\n-            .await?,\n-        get_client_assets_path(*client_root).to_resolved().await?,\n+        client_root.clone(),\n+        client_root.join(\"static/chunks\")?,\n+        get_client_assets_path(client_root.clone())\n+            .await?\n+            .clone_value(),\n         environment,\n         next_mode.runtime_type(),\n     )\n@@ -499,25 +500,30 @@ pub async fn get_client_chunking_context(\n }\n \n #[turbo_tasks::function]\n-pub fn get_client_assets_path(client_root: Vc<FileSystemPath>) -> Vc<FileSystemPath> {\n-    client_root.join(rcstr!(\"static/media\"))\n+pub fn get_client_assets_path(client_root: FileSystemPath) -> Result<Vc<FileSystemPath>> {\n+    Ok(client_root.join(\"static/media\")?.cell())\n }\n \n #[turbo_tasks::function]\n pub async fn get_client_runtime_entries(\n-    project_root: Vc<FileSystemPath>,\n+    project_root: FileSystemPath,\n     ty: ClientContextType,\n     mode: Vc<NextMode>,\n     next_config: Vc<NextConfig>,\n     execution_context: Vc<ExecutionContext>,\n ) -> Result<Vc<RuntimeEntries>> {\n     let mut runtime_entries = vec![];\n-    let resolve_options_context =\n-        get_client_resolve_options_context(project_root, ty, mode, next_config, execution_context);\n+    let resolve_options_context = get_client_resolve_options_context(\n+        project_root.clone(),\n+        ty.clone(),\n+        mode,\n+        next_config,\n+        execution_context,\n+    );\n \n     if mode.await?.is_development() {\n         let enable_react_refresh =\n-            assert_can_resolve_react_refresh(project_root, resolve_options_context)\n+            assert_can_resolve_react_refresh(project_root.clone(), resolve_options_context)\n                 .await?\n                 .as_request();\n \n@@ -526,11 +532,8 @@ pub async fn get_client_runtime_entries(\n         // functions to be available.\n         if let Some(request) = enable_react_refresh {\n             runtime_entries.push(\n-                RuntimeEntry::Request(\n-                    request.to_resolved().await?,\n-                    project_root.join(rcstr!(\"_\")).to_resolved().await?,\n-                )\n-                .resolved_cell(),\n+                RuntimeEntry::Request(request.to_resolved().await?, project_root.join(\"_\")?)\n+                    .resolved_cell(),\n             )\n         };\n     }\n@@ -543,7 +546,7 @@ pub async fn get_client_runtime_entries(\n                 )))\n                 .to_resolved()\n                 .await?,\n-                project_root.join(rcstr!(\"_\")).to_resolved().await?,\n+                project_root.join(\"_\")?,\n             )\n             .resolved_cell(),\n         );"
        },
        {
            "sha": "7f16d089b9e3a598af2718982ce4a15d4d1f2e2c",
            "filename": "crates/next-core/src/next_client/runtime_entry.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_client%2Fruntime_entry.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_client%2Fruntime_entry.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_client%2Fruntime_entry.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -12,7 +12,7 @@ use turbopack_ecmascript::resolve::cjs_resolve;\n \n #[turbo_tasks::value(shared)]\n pub enum RuntimeEntry {\n-    Request(ResolvedVc<Request>, ResolvedVc<FileSystemPath>),\n+    Request(ResolvedVc<Request>, FileSystemPath),\n     Evaluatable(ResolvedVc<Box<dyn EvaluatableAsset>>),\n     Source(ResolvedVc<Box<dyn Source>>),\n }\n@@ -24,16 +24,16 @@ impl RuntimeEntry {\n         self: Vc<Self>,\n         asset_context: Vc<Box<dyn AssetContext>>,\n     ) -> Result<Vc<EvaluatableAssets>> {\n-        let (request, path) = match *self.await? {\n-            RuntimeEntry::Evaluatable(e) => return Ok(EvaluatableAssets::one(*e)),\n+        let (request, path) = match &*self.await? {\n+            RuntimeEntry::Evaluatable(e) => return Ok(EvaluatableAssets::one(**e)),\n             RuntimeEntry::Source(source) => {\n                 return Ok(EvaluatableAssets::one(source.to_evaluatable(asset_context)));\n             }\n-            RuntimeEntry::Request(r, path) => (r, path),\n+            RuntimeEntry::Request(r, path) => (*r, path.clone()),\n         };\n \n         let modules = cjs_resolve(\n-            Vc::upcast(PlainResolveOrigin::new(asset_context, *path)),\n+            Vc::upcast(PlainResolveOrigin::new(asset_context, path.clone())),\n             *request,\n             None,\n             false,"
        },
        {
            "sha": "1fa152e99b98baecf9f7fcd33fcdc4884e44e8ed",
            "filename": "crates/next-core/src/next_client/transforms.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_client%2Ftransforms.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_client%2Ftransforms.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_client%2Ftransforms.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -53,22 +53,22 @@ pub async fn get_next_client_transforms_rules(\n     let cache_kinds = next_config.cache_kinds().to_resolved().await?;\n     let mut is_app_dir = false;\n \n-    match context_ty {\n+    match &context_ty {\n         ClientContextType::Pages { pages_dir } => {\n             if !foreign_code {\n                 rules.push(\n                     get_next_pages_transforms_rule(\n-                        *pages_dir,\n+                        pages_dir.clone(),\n                         ExportFilter::StripDataExports,\n                         enable_mdx_rs,\n                     )\n                     .await?,\n                 );\n                 rules.push(get_next_disallow_export_all_in_page_rule(\n                     enable_mdx_rs,\n-                    pages_dir.await?,\n+                    pages_dir.clone(),\n                 ));\n-                rules.push(get_next_page_config_rule(enable_mdx_rs, pages_dir.await?));\n+                rules.push(get_next_page_config_rule(enable_mdx_rs, pages_dir.clone()));\n             }\n         }\n         ClientContextType::App { .. } => {"
        },
        {
            "sha": "4829d561da8f625a613582ce8c98d68d2d4b9dbc",
            "filename": "crates/next-core/src/next_client_reference/ecmascript_client_reference/ecmascript_client_reference_module.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_client_reference%2Fecmascript_client_reference%2Fecmascript_client_reference_module.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_client_reference%2Fecmascript_client_reference%2Fecmascript_client_reference_module.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_client_reference%2Fecmascript_client_reference%2Fecmascript_client_reference_module.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -148,13 +148,13 @@ impl EcmascriptClientReferenceModule {\n             AssetContent::file(File::from(code.source_code().clone()).into());\n \n         let proxy_source = VirtualSource::new(\n-            self.server_ident.path().join(\n+            self.server_ident.path().await?.join(\n                 // Depending on the original format, we call the file `proxy.mjs` or `proxy.cjs`.\n                 // This is because we're placing the virtual module next to the original code, so\n                 // its parsing will be affected by `type` fields in package.json --\n                 // a bare `proxy.js` may end up being unexpectedly parsed as the wrong format.\n-                format!(\"proxy.{}\", if is_esm { \"mjs\" } else { \"cjs\" }).into(),\n-            ),\n+                &format!(\"proxy.{}\", if is_esm { \"mjs\" } else { \"cjs\" }),\n+            )?,\n             proxy_module_content,\n         );\n "
        },
        {
            "sha": "7c32117841c7a2bbc53bec4bb511351b010ac4e2",
            "filename": "crates/next-core/src/next_client_reference/ecmascript_client_reference/ecmascript_client_reference_transition.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 7,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_client_reference%2Fecmascript_client_reference%2Fecmascript_client_reference_transition.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_client_reference%2Fecmascript_client_reference%2Fecmascript_client_reference_transition.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_client_reference%2Fecmascript_client_reference%2Fecmascript_client_reference_transition.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -57,14 +57,13 @@ impl Transition for NextEcmascriptClientReferenceTransition {\n             None => source.ident(),\n         };\n         let ident_ref = ident.await?;\n-        let ident_path = ident_ref.path.await?;\n+        let ident_path = ident_ref.path.clone();\n         let client_source = if ident_path.path.contains(\"next/dist/esm/\") {\n-            let path = ident_ref.path.root().join(\n-                ident_path\n-                    .path\n-                    .replace(\"next/dist/esm/\", \"next/dist/\")\n-                    .into(),\n-            );\n+            let path = ident_ref\n+                .path\n+                .root()\n+                .await?\n+                .join(&ident_path.path.replace(\"next/dist/esm/\", \"next/dist/\"))?;\n             Vc::upcast(FileSource::new_with_query_and_fragment(\n                 path,\n                 ident_ref.query.clone(),"
        },
        {
            "sha": "8e79d88a0d42b22ef49702370e930b824ec3c6cb",
            "filename": "crates/next-core/src/next_client_reference/visit_client_reference.rs",
            "status": "modified",
            "additions": 71,
            "deletions": 67,
            "changes": 138,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_client_reference%2Fvisit_client_reference.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_client_reference%2Fvisit_client_reference.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_client_reference%2Fvisit_client_reference.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -156,7 +156,7 @@ pub async fn find_server_entries(\n     include_traced: bool,\n ) -> Result<Vc<ServerEntries>> {\n     async move {\n-        let entry_path = entry.ident().path().to_resolved().await?;\n+        let entry_path = entry.ident().path().await?.clone_value();\n         let graph = AdjacencyMap::new()\n             .skip_duplicates()\n             .visit(\n@@ -227,7 +227,6 @@ struct VisitClientReferenceNode {\n \n #[derive(\n     Clone,\n-    Copy,\n     Eq,\n     PartialEq,\n     Hash,\n@@ -240,7 +239,7 @@ struct VisitClientReferenceNode {\n )]\n enum VisitClientReferenceNodeState {\n     Entry {\n-        entry_path: ResolvedVc<FileSystemPath>,\n+        entry_path: FileSystemPath,\n     },\n     InServerComponent {\n         server_component: ResolvedVc<NextServerComponentModule>,\n@@ -331,74 +330,79 @@ impl Visit<VisitClientReferenceNode> for VisitClientReference {\n                     _ => Some(modules.iter()),\n                 })\n                 .flatten()\n-                .map(|module| async move {\n-                    if let Some(client_reference_module) =\n-                        ResolvedVc::try_downcast_type::<EcmascriptClientReferenceModule>(*module)\n-                    {\n-                        return Ok(VisitClientReferenceNode {\n-                            state: node.state,\n-                            ty: VisitClientReferenceNodeType::ClientReference(\n-                                ClientReference {\n-                                    server_component: node.state.server_component(),\n-                                    ty: ClientReferenceType::EcmascriptClientReference(\n-                                        client_reference_module,\n-                                    ),\n-                                },\n-                                client_reference_module.ident().to_string().await?,\n-                            ),\n-                        });\n-                    }\n-\n-                    if let Some(client_reference_module) =\n-                        ResolvedVc::try_downcast_type::<CssClientReferenceModule>(*module)\n-                    {\n-                        return Ok(VisitClientReferenceNode {\n-                            state: node.state,\n-                            ty: VisitClientReferenceNodeType::ClientReference(\n-                                ClientReference {\n-                                    server_component: node.state.server_component(),\n-                                    ty: ClientReferenceType::CssClientReference(\n-                                        client_reference_module.await?.client_module,\n-                                    ),\n+                .map(|module| {\n+                    let node_state = node.state.clone();\n+\n+                    async move {\n+                        if let Some(client_reference_module) = ResolvedVc::try_downcast_type::<\n+                            EcmascriptClientReferenceModule,\n+                        >(*module)\n+                        {\n+                            return Ok(VisitClientReferenceNode {\n+                                state: node_state.clone(),\n+                                ty: VisitClientReferenceNodeType::ClientReference(\n+                                    ClientReference {\n+                                        server_component: node_state.clone().server_component(),\n+                                        ty: ClientReferenceType::EcmascriptClientReference(\n+                                            client_reference_module,\n+                                        ),\n+                                    },\n+                                    client_reference_module.ident().to_string().await?,\n+                                ),\n+                            });\n+                        }\n+\n+                        if let Some(client_reference_module) =\n+                            ResolvedVc::try_downcast_type::<CssClientReferenceModule>(*module)\n+                        {\n+                            return Ok(VisitClientReferenceNode {\n+                                state: node_state.clone(),\n+                                ty: VisitClientReferenceNodeType::ClientReference(\n+                                    ClientReference {\n+                                        server_component: node_state.clone().server_component(),\n+                                        ty: ClientReferenceType::CssClientReference(\n+                                            client_reference_module.await?.client_module,\n+                                        ),\n+                                    },\n+                                    client_reference_module.ident().to_string().await?,\n+                                ),\n+                            });\n+                        }\n+\n+                        if let Some(server_component_asset) =\n+                            ResolvedVc::try_downcast_type::<NextServerComponentModule>(*module)\n+                        {\n+                            return Ok(VisitClientReferenceNode {\n+                                state: VisitClientReferenceNodeState::InServerComponent {\n+                                    server_component: server_component_asset,\n                                 },\n-                                client_reference_module.ident().to_string().await?,\n-                            ),\n-                        });\n-                    }\n-\n-                    if let Some(server_component_asset) =\n-                        ResolvedVc::try_downcast_type::<NextServerComponentModule>(*module)\n-                    {\n-                        return Ok(VisitClientReferenceNode {\n-                            state: VisitClientReferenceNodeState::InServerComponent {\n-                                server_component: server_component_asset,\n-                            },\n-                            ty: VisitClientReferenceNodeType::ServerComponentEntry(\n-                                server_component_asset,\n-                                server_component_asset.ident().to_string().await?,\n-                            ),\n-                        });\n-                    }\n-\n-                    if let Some(server_util_module) =\n-                        ResolvedVc::try_downcast_type::<NextServerUtilityModule>(*module)\n-                    {\n-                        return Ok(VisitClientReferenceNode {\n-                            state: VisitClientReferenceNodeState::InServerUtil,\n-                            ty: VisitClientReferenceNodeType::ServerUtilEntry(\n-                                server_util_module,\n+                                ty: VisitClientReferenceNodeType::ServerComponentEntry(\n+                                    server_component_asset,\n+                                    server_component_asset.ident().to_string().await?,\n+                                ),\n+                            });\n+                        }\n+\n+                        if let Some(server_util_module) =\n+                            ResolvedVc::try_downcast_type::<NextServerUtilityModule>(*module)\n+                        {\n+                            return Ok(VisitClientReferenceNode {\n+                                state: VisitClientReferenceNodeState::InServerUtil,\n+                                ty: VisitClientReferenceNodeType::ServerUtilEntry(\n+                                    server_util_module,\n+                                    module.ident().to_string().await?,\n+                                ),\n+                            });\n+                        }\n+\n+                        Ok(VisitClientReferenceNode {\n+                            state: node_state,\n+                            ty: VisitClientReferenceNodeType::Internal(\n+                                *module,\n                                 module.ident().to_string().await?,\n                             ),\n-                        });\n+                        })\n                     }\n-\n-                    Ok(VisitClientReferenceNode {\n-                        state: node.state,\n-                        ty: VisitClientReferenceNodeType::Internal(\n-                            *module,\n-                            module.ident().to_string().await?,\n-                        ),\n-                    })\n                 });\n \n             let assets = referenced_modules.try_join().await?;"
        },
        {
            "sha": "a5497518358f26bacb6509e59547470b98fd954d",
            "filename": "crates/next-core/src/next_config.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_config.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_config.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_config.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -1671,7 +1671,7 @@ impl JsConfig {\n \n #[turbo_tasks::value]\n struct OutdatedConfigIssue {\n-    path: ResolvedVc<FileSystemPath>,\n+    path: FileSystemPath,\n     old_name: RcStr,\n     new_name: RcStr,\n     description: RcStr,\n@@ -1690,7 +1690,7 @@ impl Issue for OutdatedConfigIssue {\n \n     #[turbo_tasks::function]\n     fn file_path(&self) -> Vc<FileSystemPath> {\n-        *self.path\n+        self.path.clone().cell()\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "7f7e7260400f9baf2ff35454588bba93e25a49e8",
            "filename": "crates/next-core/src/next_edge/context.rs",
            "status": "modified",
            "additions": 28,
            "deletions": 32,
            "changes": 60,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_edge%2Fcontext.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_edge%2Fcontext.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_edge%2Fcontext.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -1,6 +1,6 @@\n use anyhow::Result;\n use turbo_rcstr::{RcStr, rcstr};\n-use turbo_tasks::{FxIndexMap, OptionVcExt, ResolvedVc, Vc};\n+use turbo_tasks::{FxIndexMap, ResolvedVc, Vc};\n use turbo_tasks_env::EnvMap;\n use turbo_tasks_fs::FileSystemPath;\n use turbopack::{css::chunk::CssChunkType, resolve_options_context::ResolveOptionsContext};\n@@ -65,7 +65,7 @@ async fn next_edge_defines(define_env: Vc<EnvMap>) -> Result<Vc<CompileTimeDefin\n /// See [here](https://github.com/vercel/next.js/blob/160bb99b06e9c049f88e25806fd995f07f4cc7e1/packages/next/src/build/webpack-config.ts#L1715-L1718) how webpack configures it.\n #[turbo_tasks::function]\n async fn next_edge_free_vars(\n-    project_path: ResolvedVc<FileSystemPath>,\n+    project_path: FileSystemPath,\n     define_env: Vc<EnvMap>,\n ) -> Result<Vc<FreeVarReferences>> {\n     Ok(free_var_references!(\n@@ -81,7 +81,7 @@ async fn next_edge_free_vars(\n \n #[turbo_tasks::function]\n pub async fn get_edge_compile_time_info(\n-    project_path: Vc<FileSystemPath>,\n+    project_path: FileSystemPath,\n     define_env: Vc<EnvMap>,\n     node_version: ResolvedVc<NodeJsVersion>,\n ) -> Result<Vc<CompileTimeInfo>> {\n@@ -104,14 +104,14 @@ pub async fn get_edge_compile_time_info(\n \n #[turbo_tasks::function]\n pub async fn get_edge_resolve_options_context(\n-    project_path: ResolvedVc<FileSystemPath>,\n+    project_path: FileSystemPath,\n     ty: ServerContextType,\n     mode: Vc<NextMode>,\n     next_config: Vc<NextConfig>,\n     execution_context: Vc<ExecutionContext>,\n ) -> Result<Vc<ResolveOptionsContext>> {\n     let next_edge_import_map = get_next_edge_import_map(\n-        *project_path,\n+        project_path.clone(),\n         ty.clone(),\n         next_config,\n         mode,\n@@ -121,7 +121,7 @@ pub async fn get_edge_resolve_options_context(\n     .await?;\n \n     let mut before_resolve_plugins = vec![ResolvedVc::upcast(\n-        ModuleFeatureReportResolvePlugin::new(*project_path)\n+        ModuleFeatureReportResolvePlugin::new(project_path.clone())\n             .to_resolved()\n             .await?,\n     )];\n@@ -132,7 +132,7 @@ pub async fn get_edge_resolve_options_context(\n             | ServerContextType::AppRSC { .. }\n     ) {\n         before_resolve_plugins.push(ResolvedVc::upcast(\n-            NextFontLocalResolvePlugin::new(*project_path)\n+            NextFontLocalResolvePlugin::new(project_path.clone())\n                 .to_resolved()\n                 .await?,\n         ));\n@@ -147,19 +147,19 @@ pub async fn get_edge_resolve_options_context(\n             | ServerContextType::Instrumentation { .. }\n     ) {\n         before_resolve_plugins.push(ResolvedVc::upcast(\n-            get_invalid_client_only_resolve_plugin(project_path)\n+            get_invalid_client_only_resolve_plugin(project_path.clone())\n                 .to_resolved()\n                 .await?,\n         ));\n         before_resolve_plugins.push(ResolvedVc::upcast(\n-            get_invalid_styled_jsx_resolve_plugin(project_path)\n+            get_invalid_styled_jsx_resolve_plugin(project_path.clone())\n                 .to_resolved()\n                 .await?,\n         ));\n     }\n \n     let after_resolve_plugins = vec![ResolvedVc::upcast(\n-        NextSharedRuntimeResolvePlugin::new(*project_path)\n+        NextSharedRuntimeResolvePlugin::new(project_path.clone())\n             .to_resolved()\n             .await?,\n     )];\n@@ -179,7 +179,7 @@ pub async fn get_edge_resolve_options_context(\n     };\n \n     let resolve_options_context = ResolveOptionsContext {\n-        enable_node_modules: Some(project_path.root().to_resolved().await?),\n+        enable_node_modules: Some(project_path.root().await?.clone_value()),\n         enable_edge_node_externals: true,\n         custom_conditions,\n         import_map: Some(next_edge_import_map),\n@@ -201,9 +201,8 @@ pub async fn get_edge_resolve_options_context(\n             .typescript_tsconfig_path()\n             .await?\n             .as_ref()\n-            .map(|p| project_path.join(p.to_owned()))\n-            .to_resolved()\n-            .await?,\n+            .map(|p| project_path.join(p))\n+            .transpose()?,\n         rules: vec![(\n             foreign_code_context_condition(next_config, project_path).await?,\n             resolve_options_context.clone().resolved_cell(),\n@@ -216,10 +215,10 @@ pub async fn get_edge_resolve_options_context(\n #[turbo_tasks::function]\n pub async fn get_edge_chunking_context_with_client_assets(\n     mode: Vc<NextMode>,\n-    root_path: ResolvedVc<FileSystemPath>,\n-    node_root: ResolvedVc<FileSystemPath>,\n+    root_path: FileSystemPath,\n+    node_root: FileSystemPath,\n     output_root_to_root_path: ResolvedVc<RcStr>,\n-    client_root: ResolvedVc<FileSystemPath>,\n+    client_root: FileSystemPath,\n     asset_prefix: ResolvedVc<Option<RcStr>>,\n     environment: ResolvedVc<Environment>,\n     module_id_strategy: ResolvedVc<Box<dyn ModuleIdStrategy>>,\n@@ -228,18 +227,15 @@ pub async fn get_edge_chunking_context_with_client_assets(\n     no_mangling: Vc<bool>,\n     scope_hoisting: Vc<bool>,\n ) -> Result<Vc<Box<dyn ChunkingContext>>> {\n-    let output_root = node_root.join(rcstr!(\"server/edge\")).to_resolved().await?;\n+    let output_root = node_root.join(\"server/edge\")?;\n     let next_mode = mode.await?;\n     let mut builder = BrowserChunkingContext::builder(\n         root_path,\n-        output_root,\n+        output_root.clone(),\n         output_root_to_root_path.owned().await?,\n-        client_root,\n-        output_root.join(rcstr!(\"chunks/ssr\")).to_resolved().await?,\n-        client_root\n-            .join(rcstr!(\"static/media\"))\n-            .to_resolved()\n-            .await?,\n+        client_root.clone(),\n+        output_root.join(\"chunks/ssr\")?,\n+        client_root.join(\"static/media\")?,\n         environment,\n         next_mode.runtime_type(),\n     )\n@@ -284,8 +280,8 @@ pub async fn get_edge_chunking_context_with_client_assets(\n #[turbo_tasks::function]\n pub async fn get_edge_chunking_context(\n     mode: Vc<NextMode>,\n-    root_path: ResolvedVc<FileSystemPath>,\n-    node_root: ResolvedVc<FileSystemPath>,\n+    root_path: FileSystemPath,\n+    node_root: FileSystemPath,\n     node_root_to_root_path: ResolvedVc<RcStr>,\n     environment: ResolvedVc<Environment>,\n     module_id_strategy: ResolvedVc<Box<dyn ModuleIdStrategy>>,\n@@ -294,15 +290,15 @@ pub async fn get_edge_chunking_context(\n     no_mangling: Vc<bool>,\n     scope_hoisting: Vc<bool>,\n ) -> Result<Vc<Box<dyn ChunkingContext>>> {\n-    let output_root = node_root.join(rcstr!(\"server/edge\")).to_resolved().await?;\n+    let output_root = node_root.join(\"server/edge\")?;\n     let next_mode = mode.await?;\n     let mut builder = BrowserChunkingContext::builder(\n         root_path,\n-        output_root,\n+        output_root.clone(),\n         node_root_to_root_path.owned().await?,\n-        output_root,\n-        output_root.join(rcstr!(\"chunks\")).to_resolved().await?,\n-        output_root.join(rcstr!(\"assets\")).to_resolved().await?,\n+        output_root.clone(),\n+        output_root.join(\"chunks\")?,\n+        output_root.join(\"assets\")?,\n         environment,\n         next_mode.runtime_type(),\n     )"
        },
        {
            "sha": "63299c83e71a8774db0d287118285093ce424e4a",
            "filename": "crates/next-core/src/next_edge/entry.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 5,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_edge%2Fentry.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_edge%2Fentry.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_edge%2Fentry.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -1,3 +1,4 @@\n+use anyhow::Result;\n use indoc::formatdoc;\n use turbo_rcstr::RcStr;\n use turbo_tasks::{ResolvedVc, Vc, fxindexmap};\n@@ -11,10 +12,10 @@ use turbopack_ecmascript::utils::StringifyJs;\n #[turbo_tasks::function]\n pub fn wrap_edge_entry(\n     asset_context: Vc<Box<dyn AssetContext>>,\n-    project_root: Vc<FileSystemPath>,\n+    project_root: FileSystemPath,\n     entry: ResolvedVc<Box<dyn Module>>,\n     pathname: RcStr,\n-) -> Vc<Box<dyn Module>> {\n+) -> Result<Vc<Box<dyn Module>>> {\n     // The wrapped module could be an async module, we handle that with the proxy\n     // here. The comma expression makes sure we don't call the function with the\n     // module as the \"this\" arg.\n@@ -45,18 +46,18 @@ pub fn wrap_edge_entry(\n \n     // TODO(alexkirsz) Figure out how to name this virtual asset.\n     let virtual_source = VirtualSource::new(\n-        project_root.join(\"edge-wrapper.js\".into()),\n+        project_root.join(\"edge-wrapper.js\")?,\n         AssetContent::file(file.into()),\n     );\n \n     let inner_assets = fxindexmap! {\n         \"MODULE\".into() => entry\n     };\n \n-    asset_context\n+    Ok(asset_context\n         .process(\n             Vc::upcast(virtual_source),\n             ReferenceType::Internal(ResolvedVc::cell(inner_assets)),\n         )\n-        .module()\n+        .module())\n }"
        },
        {
            "sha": "ca2cd14b7eb13c5d902406ff6fec609d05d34ce7",
            "filename": "crates/next-core/src/next_edge/unsupported.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 5,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_edge%2Funsupported.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_edge%2Funsupported.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_edge%2Funsupported.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -42,16 +42,17 @@ impl ImportMappingReplacement for NextEdgeUnsupportedModuleReplacer {\n     #[turbo_tasks::function]\n     async fn result(\n         &self,\n-        lookup_path: Vc<FileSystemPath>,\n+        lookup_path: FileSystemPath,\n         request: Vc<Request>,\n     ) -> Result<Vc<ImportMapResult>> {\n         let request = &*request.await?;\n         if let Request::Module { module, .. } = request {\n             // Call out to separate `unsupported_module_source` to only have a single Source cell\n             // for requests with different subpaths: `fs` and `fs/promises`.\n-            let source = unsupported_module_source(lookup_path.root(), module.clone())\n-                .to_resolved()\n-                .await?;\n+            let source =\n+                unsupported_module_source(lookup_path.root().await?.clone_value(), module.clone())\n+                    .to_resolved()\n+                    .await?;\n             Ok(ImportMapResult::Result(ResolveResult::source(ResolvedVc::upcast(source))).cell())\n         } else {\n             Ok(ImportMapResult::NoEntry.cell())\n@@ -60,7 +61,7 @@ impl ImportMappingReplacement for NextEdgeUnsupportedModuleReplacer {\n }\n \n #[turbo_tasks::function]\n-fn unsupported_module_source(root_path: Vc<FileSystemPath>, module: RcStr) -> Vc<VirtualSource> {\n+fn unsupported_module_source(root_path: FileSystemPath, module: RcStr) -> Vc<VirtualSource> {\n     // packages/next/src/server/web/globals.ts augments global with\n     // `__import_unsupported` and necessary functions.\n     let code = formatdoc! {"
        },
        {
            "sha": "304b5c8543903867c34466b048ea3d2d03fe7b43",
            "filename": "crates/next-core/src/next_font/google/font_fallback.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_font%2Fgoogle%2Ffont_fallback.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_font%2Fgoogle%2Ffont_fallback.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_font%2Fgoogle%2Ffont_fallback.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -4,7 +4,7 @@ use regex::Regex;\n use rustc_hash::FxHashMap;\n use serde::{Deserialize, Serialize};\n use turbo_rcstr::{RcStr, rcstr};\n-use turbo_tasks::{NonLocalValue, ResolvedVc, Vc, trace::TraceRawVcs};\n+use turbo_tasks::{NonLocalValue, Vc, trace::TraceRawVcs};\n use turbo_tasks_fs::FileSystemPath;\n use turbopack_core::issue::{IssueExt, IssueSeverity, StyledString};\n \n@@ -44,15 +44,15 @@ struct Fallback {\n \n #[turbo_tasks::function]\n pub(super) async fn get_font_fallback(\n-    lookup_path: ResolvedVc<FileSystemPath>,\n+    lookup_path: FileSystemPath,\n     options_vc: Vc<NextFontGoogleOptions>,\n ) -> Result<Vc<FontFallback>> {\n     let options = options_vc.await?;\n     Ok(match &options.fallback {\n         Some(fallback) => FontFallback::Manual(fallback.clone()).cell(),\n         None => {\n             let metrics_json = load_next_js_templateon(\n-                lookup_path,\n+                lookup_path.clone(),\n                 rcstr!(\"dist/server/capsize-font-metrics.json\"),\n             )\n             .await?;\n@@ -74,7 +74,7 @@ pub(super) async fn get_font_fallback(\n                 .cell(),\n                 Err(_) => {\n                     NextFontIssue {\n-                        path: lookup_path,\n+                        path: lookup_path.clone(),\n                         title: StyledString::Text(\n                             format!(\n                                 \"Failed to find font override values for font `{}`\","
        },
        {
            "sha": "0e963c3dbfa7e69f2efbdc1e6a340d6215a6f938",
            "filename": "crates/next-core/src/next_font/google/mod.rs",
            "status": "modified",
            "additions": 35,
            "deletions": 28,
            "changes": 63,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_font%2Fgoogle%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_font%2Fgoogle%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_font%2Fgoogle%2Fmod.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -75,13 +75,13 @@ struct FontData(FxIndexMap<RcStr, FontDataEntry>);\n \n #[turbo_tasks::value(shared)]\n pub(crate) struct NextFontGoogleReplacer {\n-    project_path: ResolvedVc<FileSystemPath>,\n+    project_path: FileSystemPath,\n }\n \n #[turbo_tasks::value_impl]\n impl NextFontGoogleReplacer {\n     #[turbo_tasks::function]\n-    pub fn new(project_path: ResolvedVc<FileSystemPath>) -> Vc<Self> {\n+    pub fn new(project_path: FileSystemPath) -> Vc<Self> {\n         Self::cell(NextFontGoogleReplacer { project_path })\n     }\n \n@@ -90,14 +90,15 @@ impl NextFontGoogleReplacer {\n         let request_hash = get_request_hash(&query);\n         let qstr = qstring::QString::from(query.as_str());\n \n-        let font_data = load_font_data(*self.project_path);\n+        let font_data = load_font_data(self.project_path.clone());\n         let options = font_options_from_query_map(query, font_data);\n \n-        let fallback = get_font_fallback(*self.project_path, options);\n+        let fallback = get_font_fallback(self.project_path.clone(), options);\n         let properties = get_font_css_properties(options, fallback).await?;\n         let js_asset = VirtualSource::new(\n             next_js_file_path(rcstr!(\"internal/font/google\"))\n-                .join(format!(\"{}.js\", get_request_id(options.font_family().await?, request_hash)).into()),\n+                .await?\n+                .join(&format!(\"{}.js\", get_request_id(options.font_family().await?, request_hash)))?,\n             AssetContent::file(FileContent::Content(\n                 formatdoc!(\n                     r#\"\n@@ -153,7 +154,7 @@ impl ImportMappingReplacement for NextFontGoogleReplacer {\n     #[turbo_tasks::function]\n     async fn result(\n         self: Vc<Self>,\n-        _context: Vc<FileSystemPath>,\n+        _context: FileSystemPath,\n         request: Vc<Request>,\n     ) -> Result<Vc<ImportMapResult>> {\n         let request = &*request.await?;\n@@ -168,7 +169,7 @@ impl ImportMappingReplacement for NextFontGoogleReplacer {\n         };\n \n         let this = &*self.await?;\n-        if can_use_next_font(*this.project_path, query).await? {\n+        if can_use_next_font(this.project_path.clone(), query).await? {\n             Ok(self.import_map_result(query.clone()))\n         } else {\n             Ok(ImportMapResult::NoEntry.into())\n@@ -178,7 +179,7 @@ impl ImportMappingReplacement for NextFontGoogleReplacer {\n \n #[turbo_tasks::value(shared)]\n pub struct NextFontGoogleCssModuleReplacer {\n-    project_path: ResolvedVc<FileSystemPath>,\n+    project_path: FileSystemPath,\n     execution_context: ResolvedVc<ExecutionContext>,\n     next_mode: ResolvedVc<NextMode>,\n }\n@@ -187,7 +188,7 @@ pub struct NextFontGoogleCssModuleReplacer {\n impl NextFontGoogleCssModuleReplacer {\n     #[turbo_tasks::function]\n     pub fn new(\n-        project_path: ResolvedVc<FileSystemPath>,\n+        project_path: FileSystemPath,\n         execution_context: ResolvedVc<ExecutionContext>,\n         next_mode: ResolvedVc<NextMode>,\n     ) -> Vc<Self> {\n@@ -201,7 +202,7 @@ impl NextFontGoogleCssModuleReplacer {\n     #[turbo_tasks::function]\n     async fn import_map_result(&self, query: RcStr) -> Result<Vc<ImportMapResult>> {\n         let request_hash = get_request_hash(&query);\n-        let font_data = load_font_data(*self.project_path);\n+        let font_data = load_font_data(self.project_path.clone());\n         let options = font_options_from_query_map(query, font_data);\n         let stylesheet_url = get_stylesheet_url_from_options(options, font_data)\n             .owned()\n@@ -210,7 +211,11 @@ impl NextFontGoogleCssModuleReplacer {\n         let scoped_font_family =\n             get_scoped_font_family(FontFamilyType::WebFont, font_family.clone());\n         let css_virtual_path = next_js_file_path(rcstr!(\"internal/font/google\"))\n-            .join(format!(\"/{}.module.css\", get_request_id(font_family, request_hash)).into());\n+            .await?\n+            .join(&format!(\n+                \"/{}.module.css\",\n+                get_request_id(font_family, request_hash)\n+            ))?;\n \n         // When running Next.js integration tests, use the mock data available in\n         // process.env.NEXT_FONT_GOOGLE_MOCKED_RESPONSES instead of making real\n@@ -223,12 +228,12 @@ impl NextFontGoogleCssModuleReplacer {\n         let stylesheet_str = mocked_responses_path\n             .as_ref()\n             .map_or_else(\n-                || fetch_real_stylesheet(stylesheet_url.clone(), css_virtual_path).boxed(),\n+                || fetch_real_stylesheet(stylesheet_url.clone(), css_virtual_path.clone()).boxed(),\n                 |p| get_mock_stylesheet(stylesheet_url.clone(), p, *self.execution_context).boxed(),\n             )\n             .await?;\n \n-        let font_fallback = get_font_fallback(*self.project_path, options);\n+        let font_fallback = get_font_fallback(self.project_path.clone(), options);\n         let stylesheet = match stylesheet_str {\n             Some(s) => Some(\n                 update_google_stylesheet(\n@@ -246,7 +251,7 @@ impl NextFontGoogleCssModuleReplacer {\n                     // rendering.\n                     NextMode::Build => {\n                         NextFontIssue {\n-                            path: css_virtual_path.to_resolved().await?,\n+                            path: css_virtual_path.clone(),\n                             title: StyledString::Line(vec![\n                                 StyledString::Code(rcstr!(\"next/font:\")),\n                                 StyledString::Text(rcstr!(\" error:\")),\n@@ -270,7 +275,7 @@ impl NextFontGoogleCssModuleReplacer {\n                     // renders during development.\n                     NextMode::Development => {\n                         NextFontIssue {\n-                            path: css_virtual_path.to_resolved().await?,\n+                            path: css_virtual_path.clone(),\n                             title: StyledString::Line(vec![\n                                 StyledString::Code(rcstr!(\"next/font:\")),\n                                 StyledString::Text(rcstr!(\" warning:\")),\n@@ -332,7 +337,7 @@ impl ImportMappingReplacement for NextFontGoogleCssModuleReplacer {\n     #[turbo_tasks::function]\n     async fn result(\n         self: Vc<Self>,\n-        _context: Vc<FileSystemPath>,\n+        _context: FileSystemPath,\n         request: Vc<Request>,\n     ) -> Result<Vc<ImportMapResult>> {\n         let request = &*request.await?;\n@@ -359,13 +364,13 @@ struct NextFontGoogleFontFileOptions {\n \n #[turbo_tasks::value(shared)]\n pub struct NextFontGoogleFontFileReplacer {\n-    project_path: ResolvedVc<FileSystemPath>,\n+    project_path: FileSystemPath,\n }\n \n #[turbo_tasks::value_impl]\n impl NextFontGoogleFontFileReplacer {\n     #[turbo_tasks::function]\n-    pub fn new(project_path: ResolvedVc<FileSystemPath>) -> Vc<Self> {\n+    pub fn new(project_path: FileSystemPath) -> Vc<Self> {\n         Self::cell(NextFontGoogleFontFileReplacer { project_path })\n     }\n }\n@@ -383,7 +388,7 @@ impl ImportMappingReplacement for NextFontGoogleFontFileReplacer {\n     #[turbo_tasks::function]\n     async fn result(\n         &self,\n-        _context: Vc<FileSystemPath>,\n+        _context: FileSystemPath,\n         request: Vc<Request>,\n     ) -> Result<Vc<ImportMapResult>> {\n         let request = &*request.await?;\n@@ -415,12 +420,14 @@ impl ImportMappingReplacement for NextFontGoogleFontFileReplacer {\n             name.push_str(\".p\")\n         }\n \n-        let font_virtual_path =\n-            next_js_file_path(rcstr!(\"internal/font/google\")).join(format!(\"/{name}.{ext}\").into());\n+        let font_virtual_path = next_js_file_path(rcstr!(\"internal/font/google\"))\n+            .await?\n+            .join(&format!(\"/{name}.{ext}\"))?;\n \n         // doesn't seem ideal to download the font into a string, but probably doesn't\n         // really matter either.\n-        let Some(font) = fetch_from_google_fonts(url.into(), font_virtual_path).await? else {\n+        let Some(font) = fetch_from_google_fonts(url.into(), font_virtual_path.clone()).await?\n+        else {\n             return Ok(ImportMapResult::Result(ResolveResult::unresolvable()).cell());\n         };\n \n@@ -436,7 +443,7 @@ impl ImportMappingReplacement for NextFontGoogleFontFileReplacer {\n }\n \n #[turbo_tasks::function]\n-async fn load_font_data(project_root: ResolvedVc<FileSystemPath>) -> Result<Vc<FontData>> {\n+async fn load_font_data(project_root: FileSystemPath) -> Result<Vc<FontData>> {\n     let data: FontData = load_next_js_templateon(\n         project_root,\n         rcstr!(\"dist/compiled/@next/font/dist/google/font-data.json\"),\n@@ -642,7 +649,7 @@ fn font_file_options_from_query_map(query: &RcStr) -> Result<NextFontGoogleFontF\n \n async fn fetch_real_stylesheet(\n     stylesheet_url: RcStr,\n-    css_virtual_path: Vc<FileSystemPath>,\n+    css_virtual_path: FileSystemPath,\n ) -> Result<Option<Vc<RcStr>>> {\n     let body = fetch_from_google_fonts(stylesheet_url, css_virtual_path).await?;\n \n@@ -651,7 +658,7 @@ async fn fetch_real_stylesheet(\n \n async fn fetch_from_google_fonts(\n     url: RcStr,\n-    virtual_path: Vc<FileSystemPath>,\n+    virtual_path: FileSystemPath,\n ) -> Result<Option<Vc<HttpResponseBody>>> {\n     let result = fetch(\n         url,\n@@ -702,11 +709,11 @@ async fn get_mock_stylesheet(\n         Layer::new(rcstr!(\"next_font\")),\n         false,\n     );\n-    let loader_path = mock_fs.root().join(rcstr!(\"loader.js\"));\n+    let loader_path = mock_fs.root().await?.join(\"loader.js\")?;\n     let mocked_response_asset = asset_context\n         .process(\n             Vc::upcast(VirtualSource::new(\n-                loader_path,\n+                loader_path.clone(),\n                 AssetContent::file(\n                     File::from(format!(\n                         \"import data from './{}'; export default function load() {{ return data; \\\n@@ -723,7 +730,7 @@ async fn get_mock_stylesheet(\n         )\n         .module();\n \n-    let root = mock_fs.root();\n+    let root = mock_fs.root().await?.clone_value();\n     let val = evaluate(\n         mocked_response_asset,\n         root,"
        },
        {
            "sha": "46389d04e23c202a07591c417825d42c9312cc4b",
            "filename": "crates/next-core/src/next_font/issue.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_font%2Fissue.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_font%2Fissue.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_font%2Fissue.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -4,7 +4,7 @@ use turbopack_core::issue::{Issue, IssueSeverity, IssueStage, OptionStyledString\n \n #[turbo_tasks::value(shared)]\n pub(crate) struct NextFontIssue {\n-    pub(crate) path: ResolvedVc<FileSystemPath>,\n+    pub(crate) path: FileSystemPath,\n     pub(crate) title: ResolvedVc<StyledString>,\n     pub(crate) description: ResolvedVc<StyledString>,\n     pub(crate) severity: IssueSeverity,\n@@ -23,7 +23,7 @@ impl Issue for NextFontIssue {\n \n     #[turbo_tasks::function]\n     fn file_path(&self) -> Vc<FileSystemPath> {\n-        *self.path\n+        self.path.clone().cell()\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "6f4a1ffe06eca68c016716f3504cffcecaaa3a9e",
            "filename": "crates/next-core/src/next_font/local/font_fallback.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 6,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_font%2Flocal%2Ffont_fallback.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_font%2Flocal%2Ffont_fallback.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_font%2Flocal%2Ffont_fallback.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -34,7 +34,7 @@ static BOLD_WEIGHT: f64 = 700.0;\n \n #[turbo_tasks::function]\n pub(super) async fn get_font_fallbacks(\n-    lookup_path: Vc<FileSystemPath>,\n+    lookup_path: FileSystemPath,\n     options_vc: Vc<NextFontLocalOptions>,\n ) -> Result<Vc<FontFallbackResult>> {\n     let options = &*options_vc.await?;\n@@ -90,16 +90,13 @@ pub(super) async fn get_font_fallbacks(\n }\n \n async fn get_font_adjustment(\n-    lookup_path: Vc<FileSystemPath>,\n+    lookup_path: FileSystemPath,\n     options: Vc<NextFontLocalOptions>,\n     fallback_font: &DefaultFallbackFont,\n ) -> Result<FontResult<FontAdjustment>> {\n     let options = &*options.await?;\n     let main_descriptor = pick_font_for_fallback_generation(&options.fonts)?;\n-    let font_file = &*lookup_path\n-        .join(main_descriptor.path.clone())\n-        .read()\n-        .await?;\n+    let font_file = &*lookup_path.join(&main_descriptor.path)?.read().await?;\n     let font_file_rope = match font_file {\n         FileContent::NotFound => {\n             return Ok(FontResult::FontFileNotFound(FontFileNotFound("
        },
        {
            "sha": "833c3b82423c4d3b84b0ffa08a2e47056eb4f845",
            "filename": "crates/next-core/src/next_font/local/mod.rs",
            "status": "modified",
            "additions": 20,
            "deletions": 27,
            "changes": 47,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_font%2Flocal%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_font%2Flocal%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_font%2Flocal%2Fmod.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -53,13 +53,13 @@ struct NextFontLocalFontFileOptions {\n \n #[turbo_tasks::value]\n pub(crate) struct NextFontLocalResolvePlugin {\n-    root: ResolvedVc<FileSystemPath>,\n+    root: FileSystemPath,\n }\n \n #[turbo_tasks::value_impl]\n impl NextFontLocalResolvePlugin {\n     #[turbo_tasks::function]\n-    pub fn new(root: ResolvedVc<FileSystemPath>) -> Vc<Self> {\n+    pub fn new(root: FileSystemPath) -> Vc<Self> {\n         NextFontLocalResolvePlugin { root }.cell()\n     }\n }\n@@ -76,7 +76,7 @@ impl BeforeResolvePlugin for NextFontLocalResolvePlugin {\n     #[turbo_tasks::function]\n     async fn before_resolve(\n         self: Vc<Self>,\n-        lookup_path: Vc<FileSystemPath>,\n+        lookup_path: FileSystemPath,\n         _reference_type: ReferenceType,\n         request_vc: Vc<Request>,\n     ) -> Result<Vc<ResolveResultOption>> {\n@@ -99,20 +99,19 @@ impl BeforeResolvePlugin for NextFontLocalResolvePlugin {\n \n         match request_key.as_str() {\n             \"next/font/local/target.css\" => {\n-                if !can_use_next_font(*this.root, query).await? {\n+                if !can_use_next_font(this.root.clone(), query).await? {\n                     return Ok(ResolveResultOption::none());\n                 }\n \n                 let request_hash = get_request_hash(query.as_str());\n                 let qstr = qstring::QString::from(query.as_str());\n                 let options_vc = font_options_from_query_map(query.clone());\n \n-                let font_fallbacks = &*get_font_fallbacks(lookup_path, options_vc).await?;\n-                let lookup_path = lookup_path.to_resolved().await?;\n+                let font_fallbacks = &*get_font_fallbacks(lookup_path.clone(), options_vc).await?;\n                 let font_fallbacks = match font_fallbacks {\n                     FontFallbackResult::FontFileNotFound(err) => {\n                         FontResolvingIssue {\n-                            origin_path: lookup_path,\n+                            origin_path: lookup_path.clone(),\n                             font_path: ResolvedVc::cell(err.0.clone()),\n                         }\n                         .resolved_cell()\n@@ -160,13 +159,10 @@ impl BeforeResolvePlugin for NextFontLocalResolvePlugin {\n                         .unwrap_or_else(|| \"\".to_owned()),\n                 );\n                 let js_asset = VirtualSource::new(\n-                    lookup_path.join(\n-                        format!(\n-                            \"{}.js\",\n-                            get_request_id(options_vc.font_family().await?, request_hash)\n-                        )\n-                        .into(),\n-                    ),\n+                    lookup_path.join(&format!(\n+                        \"{}.js\",\n+                        get_request_id(options_vc.font_family().await?, request_hash)\n+                    ))?,\n                     AssetContent::file(FileContent::Content(file_content.into()).into()),\n                 )\n                 .to_resolved()\n@@ -179,18 +175,15 @@ impl BeforeResolvePlugin for NextFontLocalResolvePlugin {\n             \"@vercel/turbopack-next/internal/font/local/cssmodule.module.css\" => {\n                 let request_hash = get_request_hash(query);\n                 let options = font_options_from_query_map(query.clone());\n-                let css_virtual_path = lookup_path.join(\n-                    format!(\n-                        \"/{}.module.css\",\n-                        get_request_id(options.font_family().await?, request_hash)\n-                    )\n-                    .into(),\n-                );\n-                let fallback = &*get_font_fallbacks(lookup_path, options).await?;\n+                let css_virtual_path = lookup_path.join(&format!(\n+                    \"/{}.module.css\",\n+                    get_request_id(options.font_family().await?, request_hash)\n+                ))?;\n+                let fallback = &*get_font_fallbacks(lookup_path.clone(), options).await?;\n                 let fallback = match fallback {\n                     FontFallbackResult::FontFileNotFound(err) => {\n                         FontResolvingIssue {\n-                            origin_path: lookup_path.to_resolved().await?,\n+                            origin_path: lookup_path.clone(),\n                             font_path: ResolvedVc::cell(err.0.clone()),\n                         }\n                         .resolved_cell()\n@@ -240,9 +233,9 @@ impl BeforeResolvePlugin for NextFontLocalResolvePlugin {\n                     name.push_str(\".p\")\n                 }\n \n-                let font_virtual_path = lookup_path.join(format!(\"/{name}.{ext}\").into());\n+                let font_virtual_path = lookup_path.join(&format!(\"/{name}.{ext}\"))?;\n \n-                let font_file = lookup_path.join(path.clone()).read();\n+                let font_file = lookup_path.join(&path)?.read();\n \n                 let font_source =\n                     VirtualSource::new(font_virtual_path, AssetContent::file(font_file))\n@@ -323,7 +316,7 @@ fn font_file_options_from_query_map(query: &RcStr) -> Result<NextFontLocalFontFi\n #[turbo_tasks::value(shared)]\n struct FontResolvingIssue {\n     font_path: ResolvedVc<RcStr>,\n-    origin_path: ResolvedVc<FileSystemPath>,\n+    origin_path: FileSystemPath,\n }\n \n #[turbo_tasks::value_impl]\n@@ -334,7 +327,7 @@ impl Issue for FontResolvingIssue {\n \n     #[turbo_tasks::function]\n     fn file_path(&self) -> Vc<FileSystemPath> {\n-        *self.origin_path\n+        self.origin_path.clone().cell()\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "ee32b0e78c077b7a1f29c3542b8cb96d7db4ecc0",
            "filename": "crates/next-core/src/next_font/util.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 7,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_font%2Futil.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_font%2Futil.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_font%2Futil.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -1,7 +1,7 @@\n use anyhow::{Context, Result};\n use serde::Deserialize;\n use turbo_rcstr::{RcStr, rcstr};\n-use turbo_tasks::{ResolvedVc, Vc};\n+use turbo_tasks::ResolvedVc;\n use turbo_tasks_fs::{FileSystemPath, json::parse_json_with_source_context};\n use turbo_tasks_hash::hash_xxh3_hash64;\n use turbopack_core::issue::{IssueExt, IssueSeverity, StyledString};\n@@ -68,10 +68,7 @@ struct HasPath {\n     path: RcStr,\n }\n \n-pub(crate) async fn can_use_next_font(\n-    project_path: Vc<FileSystemPath>,\n-    query: &RcStr,\n-) -> Result<bool> {\n+pub(crate) async fn can_use_next_font(project_path: FileSystemPath, query: &RcStr) -> Result<bool> {\n     let query_map = qstring::QString::from(query.as_str());\n     let request: HasPath = parse_json_with_source_context(\n         query_map\n@@ -82,11 +79,11 @@ pub(crate) async fn can_use_next_font(\n     )?;\n \n     let document_re = lazy_regex::regex!(\"^(src/)?_document\\\\.[^/]+$\");\n-    let path = project_path.join(request.path.clone());\n+    let path = project_path.join(&request.path)?;\n     let can_use = !document_re.is_match(&request.path);\n     if !can_use {\n         NextFontIssue {\n-            path: path.to_resolved().await?,\n+            path: path.clone(),\n             title: StyledString::Line(vec![\n                 StyledString::Code(rcstr!(\"next/font:\")),\n                 StyledString::Text(rcstr!(\" error:\")),"
        },
        {
            "sha": "49fb979fb2218a8436c1ddc36e8454263dd31691",
            "filename": "crates/next-core/src/next_import_map.rs",
            "status": "modified",
            "additions": 170,
            "deletions": 128,
            "changes": 298,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_import_map.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_import_map.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_import_map.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -90,7 +90,7 @@ const EDGE_UNSUPPORTED_NODE_INTERNALS: [&str; 44] = [\n /// Computes the Next-specific client import map.\n #[turbo_tasks::function]\n pub async fn get_next_client_import_map(\n-    project_path: ResolvedVc<FileSystemPath>,\n+    project_path: FileSystemPath,\n     ty: ClientContextType,\n     next_config: Vc<NextConfig>,\n     next_mode: Vc<NextMode>,\n@@ -100,25 +100,25 @@ pub async fn get_next_client_import_map(\n \n     insert_next_shared_aliases(\n         &mut import_map,\n-        project_path,\n+        project_path.clone(),\n         execution_context,\n         next_config,\n         next_mode,\n         false,\n     )\n     .await?;\n \n-    insert_optimized_module_aliases(&mut import_map, project_path).await?;\n+    insert_optimized_module_aliases(&mut import_map, project_path.clone()).await?;\n \n     insert_alias_option(\n         &mut import_map,\n-        project_path,\n+        project_path.clone(),\n         next_config.resolve_alias_options(),\n         [\"browser\"],\n     )\n     .await?;\n \n-    match ty {\n+    match &ty {\n         ClientContextType::Pages { .. } => {}\n         ClientContextType::App { app_dir } => {\n             let react_flavor = if *next_config.enable_ppr().await?\n@@ -134,90 +134,93 @@ pub async fn get_next_client_import_map(\n             import_map.insert_exact_alias(\n                 \"react\",\n                 request_to_import_mapping(\n-                    app_dir,\n+                    app_dir.clone(),\n                     &format!(\"next/dist/compiled/react{react_flavor}\"),\n                 ),\n             );\n             import_map.insert_wildcard_alias(\n                 \"react/\",\n                 request_to_import_mapping(\n-                    app_dir,\n+                    app_dir.clone(),\n                     &format!(\"next/dist/compiled/react{react_flavor}/*\"),\n                 ),\n             );\n             import_map.insert_exact_alias(\n                 \"react-dom\",\n                 request_to_import_mapping(\n-                    app_dir,\n+                    app_dir.clone(),\n                     &format!(\"next/dist/compiled/react-dom{react_flavor}\"),\n                 ),\n             );\n             import_map.insert_exact_alias(\n                 \"react-dom/static\",\n                 request_to_import_mapping(\n-                    app_dir,\n+                    app_dir.clone(),\n                     \"next/dist/compiled/react-dom-experimental/static\",\n                 ),\n             );\n             import_map.insert_exact_alias(\n                 \"react-dom/static.edge\",\n                 request_to_import_mapping(\n-                    app_dir,\n+                    app_dir.clone(),\n                     \"next/dist/compiled/react-dom-experimental/static.edge\",\n                 ),\n             );\n             import_map.insert_exact_alias(\n                 \"react-dom/static.browser\",\n                 request_to_import_mapping(\n-                    app_dir,\n+                    app_dir.clone(),\n                     \"next/dist/compiled/react-dom-experimental/static.browser\",\n                 ),\n             );\n             let react_client_package = get_react_client_package(next_config).await?;\n             import_map.insert_exact_alias(\n                 \"react-dom/client\",\n                 request_to_import_mapping(\n-                    app_dir,\n+                    app_dir.clone(),\n                     &format!(\"next/dist/compiled/react-dom{react_flavor}/{react_client_package}\"),\n                 ),\n             );\n             import_map.insert_wildcard_alias(\n                 \"react-dom/\",\n                 request_to_import_mapping(\n-                    app_dir,\n+                    app_dir.clone(),\n                     &format!(\"next/dist/compiled/react-dom{react_flavor}/*\"),\n                 ),\n             );\n             import_map.insert_wildcard_alias(\n                 \"react-server-dom-webpack/\",\n-                request_to_import_mapping(app_dir, \"react-server-dom-turbopack/*\"),\n+                request_to_import_mapping(app_dir.clone(), \"react-server-dom-turbopack/*\"),\n             );\n             import_map.insert_wildcard_alias(\n                 \"react-server-dom-turbopack/\",\n                 request_to_import_mapping(\n-                    app_dir,\n+                    app_dir.clone(),\n                     &format!(\"next/dist/compiled/react-server-dom-turbopack{react_flavor}/*\"),\n                 ),\n             );\n             insert_exact_alias_or_js(\n                 &mut import_map,\n                 \"next/head\",\n-                request_to_import_mapping(project_path, \"next/dist/client/components/noop-head\"),\n+                request_to_import_mapping(\n+                    project_path.clone(),\n+                    \"next/dist/client/components/noop-head\",\n+                ),\n             );\n             insert_exact_alias_or_js(\n                 &mut import_map,\n                 \"next/dynamic\",\n-                request_to_import_mapping(project_path, \"next/dist/shared/lib/app-dynamic\"),\n+                request_to_import_mapping(project_path.clone(), \"next/dist/shared/lib/app-dynamic\"),\n             );\n             insert_exact_alias_or_js(\n                 &mut import_map,\n                 \"next/link\",\n-                request_to_import_mapping(project_path, \"next/dist/client/app-dir/link\"),\n+                request_to_import_mapping(project_path.clone(), \"next/dist/client/app-dir/link\"),\n             );\n             insert_exact_alias_or_js(\n                 &mut import_map,\n                 \"next/form\",\n-                request_to_import_mapping(project_path, \"next/dist/client/app-dir/form\"),\n+                request_to_import_mapping(project_path.clone(), \"next/dist/client/app-dir/form\"),\n             );\n         }\n         ClientContextType::Fallback => {}\n@@ -227,7 +230,7 @@ pub async fn get_next_client_import_map(\n     // see https://github.com/vercel/next.js/blob/8013ef7372fc545d49dbd060461224ceb563b454/packages/next/src/build/webpack-config.ts#L1449-L1531\n     insert_exact_alias_map(\n         &mut import_map,\n-        project_path,\n+        project_path.clone(),\n         fxindexmap! {\n             \"server-only\" => \"next/dist/compiled/server-only/index\".to_string(),\n             \"client-only\" => \"next/dist/compiled/client-only/index\".to_string(),\n@@ -243,7 +246,7 @@ pub async fn get_next_client_import_map(\n             for (original, alias) in NEXT_ALIASES {\n                 import_map.insert_exact_alias(\n                     format!(\"node:{original}\"),\n-                    request_to_import_mapping(project_path, alias),\n+                    request_to_import_mapping(project_path.clone(), alias),\n                 );\n             }\n         }\n@@ -270,8 +273,10 @@ pub async fn get_next_client_fallback_import_map(ty: ClientContextType) -> Resul\n             app_dir: context_dir,\n         } => {\n             for (original, alias) in NEXT_ALIASES {\n-                import_map\n-                    .insert_exact_alias(original, request_to_import_mapping(context_dir, alias));\n+                import_map.insert_exact_alias(\n+                    original,\n+                    request_to_import_mapping(context_dir.clone(), alias),\n+                );\n             }\n         }\n         ClientContextType::Fallback => {}\n@@ -286,7 +291,7 @@ pub async fn get_next_client_fallback_import_map(ty: ClientContextType) -> Resul\n /// Computes the Next-specific server-side import map.\n #[turbo_tasks::function]\n pub async fn get_next_server_import_map(\n-    project_path: ResolvedVc<FileSystemPath>,\n+    project_path: FileSystemPath,\n     ty: ServerContextType,\n     next_config: Vc<NextConfig>,\n     next_mode: Vc<NextMode>,\n@@ -296,7 +301,7 @@ pub async fn get_next_server_import_map(\n \n     insert_next_shared_aliases(\n         &mut import_map,\n-        project_path,\n+        project_path.clone(),\n         execution_context,\n         next_config,\n         next_mode,\n@@ -306,7 +311,7 @@ pub async fn get_next_server_import_map(\n \n     insert_alias_option(\n         &mut import_map,\n-        project_path,\n+        project_path.clone(),\n         next_config.resolve_alias_options(),\n         [],\n     )\n@@ -345,30 +350,33 @@ pub async fn get_next_server_import_map(\n             insert_exact_alias_or_js(\n                 &mut import_map,\n                 \"next/head\",\n-                request_to_import_mapping(project_path, \"next/dist/client/components/noop-head\"),\n+                request_to_import_mapping(\n+                    project_path.clone(),\n+                    \"next/dist/client/components/noop-head\",\n+                ),\n             );\n             insert_exact_alias_or_js(\n                 &mut import_map,\n                 \"next/dynamic\",\n-                request_to_import_mapping(project_path, \"next/dist/shared/lib/app-dynamic\"),\n+                request_to_import_mapping(project_path.clone(), \"next/dist/shared/lib/app-dynamic\"),\n             );\n             insert_exact_alias_or_js(\n                 &mut import_map,\n                 \"next/link\",\n-                request_to_import_mapping(project_path, \"next/dist/client/app-dir/link\"),\n+                request_to_import_mapping(project_path.clone(), \"next/dist/client/app-dir/link\"),\n             );\n             insert_exact_alias_or_js(\n                 &mut import_map,\n                 \"next/form\",\n-                request_to_import_mapping(project_path, \"next/dist/client/app-dir/form\"),\n+                request_to_import_mapping(project_path.clone(), \"next/dist/client/app-dir/form\"),\n             );\n         }\n         ServerContextType::Middleware { .. } | ServerContextType::Instrumentation { .. } => {}\n     }\n \n     insert_next_server_special_aliases(\n         &mut import_map,\n-        project_path,\n+        project_path.clone(),\n         ty,\n         NextRuntime::NodeJs,\n         next_config,\n@@ -381,7 +389,7 @@ pub async fn get_next_server_import_map(\n /// Computes the Next-specific edge-side import map.\n #[turbo_tasks::function]\n pub async fn get_next_edge_import_map(\n-    project_path: ResolvedVc<FileSystemPath>,\n+    project_path: FileSystemPath,\n     ty: ServerContextType,\n     next_config: Vc<NextConfig>,\n     next_mode: Vc<NextMode>,\n@@ -394,7 +402,7 @@ pub async fn get_next_edge_import_map(\n     // Alias next/dist imports to next/dist/esm assets\n     insert_wildcard_alias_map(\n         &mut import_map,\n-        project_path,\n+        project_path.clone(),\n         fxindexmap! {\n             \"next/dist/build/\" => \"next/dist/esm/build/*\".to_string(),\n             \"next/dist/client/\" => \"next/dist/esm/client/*\".to_string(),\n@@ -409,7 +417,7 @@ pub async fn get_next_edge_import_map(\n     // Alias the usage of next public APIs\n     insert_exact_alias_map(\n         &mut import_map,\n-        project_path,\n+        project_path.clone(),\n         fxindexmap! {\n             \"next/app\" => \"next/dist/api/app\".to_string(),\n             \"next/document\" => \"next/dist/api/document\".to_string(),\n@@ -433,19 +441,19 @@ pub async fn get_next_edge_import_map(\n \n     insert_next_shared_aliases(\n         &mut import_map,\n-        project_path,\n+        project_path.clone(),\n         execution_context,\n         next_config,\n         next_mode,\n         true,\n     )\n     .await?;\n \n-    insert_optimized_module_aliases(&mut import_map, project_path).await?;\n+    insert_optimized_module_aliases(&mut import_map, project_path.clone()).await?;\n \n     insert_alias_option(\n         &mut import_map,\n-        project_path,\n+        project_path.clone(),\n         next_config.resolve_alias_options(),\n         [],\n     )\n@@ -463,24 +471,27 @@ pub async fn get_next_edge_import_map(\n             insert_exact_alias_or_js(\n                 &mut import_map,\n                 \"next/head\",\n-                request_to_import_mapping(project_path, \"next/dist/client/components/noop-head\"),\n+                request_to_import_mapping(\n+                    project_path.clone(),\n+                    \"next/dist/client/components/noop-head\",\n+                ),\n             );\n             insert_exact_alias_or_js(\n                 &mut import_map,\n                 \"next/dynamic\",\n-                request_to_import_mapping(project_path, \"next/dist/shared/lib/app-dynamic\"),\n+                request_to_import_mapping(project_path.clone(), \"next/dist/shared/lib/app-dynamic\"),\n             );\n             insert_exact_alias_or_js(\n                 &mut import_map,\n                 \"next/link\",\n-                request_to_import_mapping(project_path, \"next/dist/client/app-dir/link\"),\n+                request_to_import_mapping(project_path.clone(), \"next/dist/client/app-dir/link\"),\n             );\n         }\n     }\n \n     insert_next_server_special_aliases(\n         &mut import_map,\n-        project_path,\n+        project_path.clone(),\n         ty.clone(),\n         NextRuntime::Edge,\n         next_config,\n@@ -523,8 +534,8 @@ async fn insert_unsupported_node_internal_aliases(import_map: &mut ImportMap) ->\n }\n \n pub fn get_next_client_resolved_map(\n-    _context: Vc<FileSystemPath>,\n-    _root: ResolvedVc<FileSystemPath>,\n+    _context: FileSystemPath,\n+    _root: FileSystemPath,\n     _mode: NextMode,\n ) -> Vc<ResolvedMap> {\n     let glob_mappings = vec![];\n@@ -562,32 +573,33 @@ static NEXT_ALIASES: [(&str, &str); 23] = [\n \n async fn insert_next_server_special_aliases(\n     import_map: &mut ImportMap,\n-    project_path: ResolvedVc<FileSystemPath>,\n+    project_path: FileSystemPath,\n     ty: ServerContextType,\n     runtime: NextRuntime,\n     next_config: Vc<NextConfig>,\n ) -> Result<()> {\n-    let external_cjs_if_node =\n-        move |context_dir: ResolvedVc<FileSystemPath>, request: &str| match runtime {\n-            NextRuntime::Edge => request_to_import_mapping(context_dir, request),\n-            NextRuntime::NodeJs => external_request_to_cjs_import_mapping(context_dir, request),\n-        };\n-    let external_esm_if_node =\n-        move |context_dir: ResolvedVc<FileSystemPath>, request: &str| match runtime {\n-            NextRuntime::Edge => request_to_import_mapping(context_dir, request),\n-            NextRuntime::NodeJs => external_request_to_esm_import_mapping(context_dir, request),\n-        };\n+    let external_cjs_if_node = move |context_dir: FileSystemPath, request: &str| match runtime {\n+        NextRuntime::Edge => request_to_import_mapping(context_dir, request),\n+        NextRuntime::NodeJs => external_request_to_cjs_import_mapping(context_dir, request),\n+    };\n+    let external_esm_if_node = move |context_dir: FileSystemPath, request: &str| match runtime {\n+        NextRuntime::Edge => request_to_import_mapping(context_dir, request),\n+        NextRuntime::NodeJs => external_request_to_esm_import_mapping(context_dir, request),\n+    };\n \n     import_map.insert_exact_alias(\n         \"next/dist/compiled/@vercel/og/index.node.js\",\n-        external_esm_if_node(project_path, \"next/dist/compiled/@vercel/og/index.node.js\"),\n+        external_esm_if_node(\n+            project_path.clone(),\n+            \"next/dist/compiled/@vercel/og/index.node.js\",\n+        ),\n     );\n \n     import_map.insert_exact_alias(\n         \"next/dist/server/ReactDOMServerPages\",\n         ImportMapping::Alternatives(vec![\n-            request_to_import_mapping(project_path, \"react-dom/server.edge\"),\n-            request_to_import_mapping(project_path, \"react-dom/server.browser\"),\n+            request_to_import_mapping(project_path.clone(), \"react-dom/server.edge\"),\n+            request_to_import_mapping(project_path.clone(), \"react-dom/server.browser\"),\n         ])\n         .resolved_cell(),\n     );\n@@ -596,8 +608,11 @@ async fn insert_next_server_special_aliases(\n         \"@opentelemetry/api\",\n         // It needs to prefer the local version of @opentelemetry/api\n         ImportMapping::Alternatives(vec![\n-            external_cjs_if_node(project_path, \"@opentelemetry/api\"),\n-            external_cjs_if_node(project_path, \"next/dist/compiled/@opentelemetry/api\"),\n+            external_cjs_if_node(project_path.clone(), \"@opentelemetry/api\"),\n+            external_cjs_if_node(\n+                project_path.clone(),\n+                \"next/dist/compiled/@opentelemetry/api\",\n+            ),\n         ])\n         .resolved_cell(),\n     );\n@@ -609,20 +624,34 @@ async fn insert_next_server_special_aliases(\n         ServerContextType::AppSSR { app_dir }\n         | ServerContextType::AppRSC { app_dir, .. }\n         | ServerContextType::AppRoute { app_dir, .. } => {\n-            let next_package = get_next_package(**app_dir).to_resolved().await?;\n+            let next_package = get_next_package(app_dir.clone()).await?.clone_value();\n             import_map.insert_exact_alias(\n                 \"styled-jsx\",\n-                request_to_import_mapping(next_package, \"styled-jsx\"),\n+                request_to_import_mapping(next_package.clone(), \"styled-jsx\"),\n             );\n             import_map.insert_wildcard_alias(\n                 \"styled-jsx/\",\n-                request_to_import_mapping(next_package, \"styled-jsx/*\"),\n+                request_to_import_mapping(next_package.clone(), \"styled-jsx/*\"),\n             );\n \n-            rsc_aliases(import_map, project_path, ty.clone(), runtime, next_config).await?;\n+            rsc_aliases(\n+                import_map,\n+                project_path.clone(),\n+                ty.clone(),\n+                runtime,\n+                next_config,\n+            )\n+            .await?;\n         }\n         ServerContextType::Middleware { .. } | ServerContextType::Instrumentation { .. } => {\n-            rsc_aliases(import_map, project_path, ty.clone(), runtime, next_config).await?;\n+            rsc_aliases(\n+                import_map,\n+                project_path.clone(),\n+                ty.clone(),\n+                runtime,\n+                next_config,\n+            )\n+            .await?;\n         }\n     }\n \n@@ -635,7 +664,7 @@ async fn insert_next_server_special_aliases(\n         ServerContextType::Pages { .. } => {\n             insert_exact_alias_map(\n                 import_map,\n-                project_path,\n+                project_path.clone(),\n                 fxindexmap! {\n                     \"server-only\" => \"next/dist/compiled/server-only/empty\".to_string(),\n                     \"client-only\" => \"next/dist/compiled/client-only/index\".to_string(),\n@@ -652,7 +681,7 @@ async fn insert_next_server_special_aliases(\n         | ServerContextType::Instrumentation { .. } => {\n             insert_exact_alias_map(\n                 import_map,\n-                project_path,\n+                project_path.clone(),\n                 fxindexmap! {\n                     \"server-only\" => \"next/dist/compiled/server-only/empty\".to_string(),\n                     \"client-only\" => \"next/dist/compiled/client-only/error\".to_string(),\n@@ -664,7 +693,7 @@ async fn insert_next_server_special_aliases(\n         ServerContextType::AppSSR { .. } => {\n             insert_exact_alias_map(\n                 import_map,\n-                project_path,\n+                project_path.clone(),\n                 fxindexmap! {\n                     \"server-only\" => \"next/dist/compiled/server-only/index\".to_string(),\n                     \"client-only\" => \"next/dist/compiled/client-only/index\".to_string(),\n@@ -677,7 +706,7 @@ async fn insert_next_server_special_aliases(\n \n     import_map.insert_exact_alias(\n         \"@vercel/og\",\n-        external_cjs_if_node(project_path, \"next/dist/server/og/image-response\"),\n+        external_cjs_if_node(project_path.clone(), \"next/dist/server/og/image-response\"),\n     );\n \n     Ok(())\n@@ -696,7 +725,7 @@ async fn get_react_client_package(next_config: Vc<NextConfig>) -> Result<&'stati\n \n async fn rsc_aliases(\n     import_map: &mut ImportMap,\n-    project_path: ResolvedVc<FileSystemPath>,\n+    project_path: FileSystemPath,\n     ty: ServerContextType,\n     runtime: NextRuntime,\n     next_config: Vc<NextConfig>,\n@@ -806,7 +835,7 @@ async fn rsc_aliases(\n         })\n     }\n \n-    insert_exact_alias_map(import_map, project_path, alias);\n+    insert_exact_alias_map(import_map, project_path.clone(), alias);\n \n     Ok(())\n }\n@@ -819,7 +848,7 @@ pub fn mdx_import_source_file() -> RcStr {\n // Keep in sync with getOptimizedModuleAliases in webpack-config.ts\n async fn insert_optimized_module_aliases(\n     import_map: &mut ImportMap,\n-    project_path: ResolvedVc<FileSystemPath>,\n+    project_path: FileSystemPath,\n ) -> Result<()> {\n     insert_exact_alias_map(\n         import_map,\n@@ -843,22 +872,22 @@ async fn insert_optimized_module_aliases(\n // Make sure to not add any external requests here.\n async fn insert_next_shared_aliases(\n     import_map: &mut ImportMap,\n-    project_path: ResolvedVc<FileSystemPath>,\n+    project_path: FileSystemPath,\n     execution_context: Vc<ExecutionContext>,\n     next_config: Vc<NextConfig>,\n     next_mode: Vc<NextMode>,\n     is_runtime_edge: bool,\n ) -> Result<()> {\n-    let package_root = next_js_fs().root().to_resolved().await?;\n+    let package_root = next_js_fs().root().await?.clone_value();\n \n     insert_alias_to_alternatives(\n         import_map,\n         mdx_import_source_file(),\n         vec![\n-            request_to_import_mapping(project_path, \"./mdx-components\"),\n-            request_to_import_mapping(project_path, \"./src/mdx-components\"),\n-            request_to_import_mapping(project_path, \"@mdx-js/react\"),\n-            request_to_import_mapping(project_path, \"@next/mdx/mdx-components.js\"),\n+            request_to_import_mapping(project_path.clone(), \"./mdx-components\"),\n+            request_to_import_mapping(project_path.clone(), \"./src/mdx-components\"),\n+            request_to_import_mapping(project_path.clone(), \"@mdx-js/react\"),\n+            request_to_import_mapping(project_path.clone(), \"@next/mdx/mdx-components.js\"),\n         ],\n     );\n \n@@ -874,7 +903,7 @@ async fn insert_next_shared_aliases(\n     // TODO: Add BeforeResolve plugins for `@next/font/google`\n \n     let next_font_google_replacer_mapping = ImportMapping::Dynamic(ResolvedVc::upcast(\n-        NextFontGoogleReplacer::new(*project_path)\n+        NextFontGoogleReplacer::new(project_path.clone())\n             .to_resolved()\n             .await?,\n     ))\n@@ -895,33 +924,40 @@ async fn insert_next_shared_aliases(\n     import_map.insert_alias(\n         AliasPattern::exact(\"@vercel/turbopack-next/internal/font/google/cssmodule.module.css\"),\n         ImportMapping::Dynamic(ResolvedVc::upcast(\n-            NextFontGoogleCssModuleReplacer::new(*project_path, execution_context, next_mode)\n-                .to_resolved()\n-                .await?,\n+            NextFontGoogleCssModuleReplacer::new(\n+                project_path.clone(),\n+                execution_context,\n+                next_mode,\n+            )\n+            .to_resolved()\n+            .await?,\n         ))\n         .resolved_cell(),\n     );\n \n     import_map.insert_alias(\n         AliasPattern::exact(GOOGLE_FONTS_INTERNAL_PREFIX),\n         ImportMapping::Dynamic(ResolvedVc::upcast(\n-            NextFontGoogleFontFileReplacer::new(*project_path)\n+            NextFontGoogleFontFileReplacer::new(project_path.clone())\n                 .to_resolved()\n                 .await?,\n         ))\n         .resolved_cell(),\n     );\n \n-    let next_package = get_next_package(*project_path).to_resolved().await?;\n-    import_map.insert_singleton_alias(\"@swc/helpers\", next_package);\n-    import_map.insert_singleton_alias(\"styled-jsx\", next_package);\n-    import_map.insert_singleton_alias(\"next\", project_path);\n-    import_map.insert_singleton_alias(\"react\", project_path);\n-    import_map.insert_singleton_alias(\"react-dom\", project_path);\n+    let next_package = get_next_package(project_path.clone()).await?.clone_value();\n+    import_map.insert_singleton_alias(\"@swc/helpers\", next_package.clone());\n+    import_map.insert_singleton_alias(\"styled-jsx\", next_package.clone());\n+    import_map.insert_singleton_alias(\"next\", project_path.clone());\n+    import_map.insert_singleton_alias(\"react\", project_path.clone());\n+    import_map.insert_singleton_alias(\"react-dom\", project_path.clone());\n     let react_client_package = get_react_client_package(next_config).await?;\n     import_map.insert_exact_alias(\n         \"react-dom/client\",\n-        request_to_import_mapping(project_path, &format!(\"react-dom/{react_client_package}\")),\n+        request_to_import_mapping(\n+            project_path.clone(),\n+            &format!(\"react-dom/{react_client_package}\"),\n+        ),\n     );\n \n     import_map.insert_alias(\n@@ -934,45 +970,48 @@ async fn insert_next_shared_aliases(\n     //https://github.com/vercel/next.js/blob/f94d4f93e4802f951063cfa3351dd5a2325724b3/packages/next/src/build/webpack-config.ts#L1196\n     import_map.insert_exact_alias(\n         \"setimmediate\",\n-        request_to_import_mapping(project_path, \"next/dist/compiled/setimmediate\"),\n+        request_to_import_mapping(project_path.clone(), \"next/dist/compiled/setimmediate\"),\n     );\n \n     import_map.insert_exact_alias(\n         \"private-next-rsc-server-reference\",\n         request_to_import_mapping(\n-            project_path,\n+            project_path.clone(),\n             \"next/dist/build/webpack/loaders/next-flight-loader/server-reference\",\n         ),\n     );\n     import_map.insert_exact_alias(\n         \"private-next-rsc-action-client-wrapper\",\n         request_to_import_mapping(\n-            project_path,\n+            project_path.clone(),\n             \"next/dist/build/webpack/loaders/next-flight-loader/action-client-wrapper\",\n         ),\n     );\n     import_map.insert_exact_alias(\n         \"private-next-rsc-action-validate\",\n         request_to_import_mapping(\n-            project_path,\n+            project_path.clone(),\n             \"next/dist/build/webpack/loaders/next-flight-loader/action-validate\",\n         ),\n     );\n     import_map.insert_exact_alias(\n         \"private-next-rsc-action-encryption\",\n-        request_to_import_mapping(project_path, \"next/dist/server/app-render/encryption\"),\n+        request_to_import_mapping(\n+            project_path.clone(),\n+            \"next/dist/server/app-render/encryption\",\n+        ),\n     );\n     import_map.insert_exact_alias(\n         \"private-next-rsc-cache-wrapper\",\n         request_to_import_mapping(\n-            project_path,\n+            project_path.clone(),\n             \"next/dist/build/webpack/loaders/next-flight-loader/cache-wrapper\",\n         ),\n     );\n     import_map.insert_exact_alias(\n         \"private-next-rsc-track-dynamic-import\",\n         request_to_import_mapping(\n-            project_path,\n+            project_path.clone(),\n             \"next/dist/build/webpack/loaders/next-flight-loader/track-dynamic-import\",\n         ),\n     );\n@@ -983,21 +1022,21 @@ async fn insert_next_shared_aliases(\n         \"@vercel/turbopack-node/\",\n         turbopack_node::embed_js::embed_fs()\n             .root()\n-            .to_resolved()\n-            .await?,\n+            .await?\n+            .clone_value(),\n     );\n \n     let image_config = next_config.image_config().await?;\n     if let Some(loader_file) = image_config.loader_file.as_deref() {\n         import_map.insert_exact_alias(\n             \"next/dist/shared/lib/image-loader\",\n-            request_to_import_mapping(project_path, loader_file),\n+            request_to_import_mapping(project_path.clone(), loader_file),\n         );\n \n         if is_runtime_edge {\n             import_map.insert_exact_alias(\n                 \"next/dist/esm/shared/lib/image-loader\",\n-                request_to_import_mapping(project_path, loader_file),\n+                request_to_import_mapping(project_path.clone(), loader_file),\n             );\n         }\n     }\n@@ -1006,29 +1045,31 @@ async fn insert_next_shared_aliases(\n }\n \n #[turbo_tasks::function]\n-pub async fn get_next_package(context_directory: Vc<FileSystemPath>) -> Result<Vc<FileSystemPath>> {\n+pub async fn get_next_package(context_directory: FileSystemPath) -> Result<Vc<FileSystemPath>> {\n     let result = resolve(\n-        context_directory,\n+        context_directory.clone(),\n         ReferenceType::CommonJs(CommonJsReferenceSubType::Undefined),\n         Request::parse(Pattern::Constant(rcstr!(\"next/package.json\"))),\n-        node_cjs_resolve_options(context_directory.root()),\n+        node_cjs_resolve_options(context_directory.root().await?.clone_value()),\n     );\n     let source = result\n         .first_source()\n         .await?\n         .context(\"Next.js package not found\")?;\n-    Ok(source.ident().path().parent())\n+    Ok(source.ident().path().await?.parent().cell())\n }\n \n pub async fn insert_alias_option<const N: usize>(\n     import_map: &mut ImportMap,\n-    project_path: ResolvedVc<FileSystemPath>,\n+    project_path: FileSystemPath,\n     alias_options: Vc<ResolveAliasMap>,\n     conditions: [&'static str; N],\n ) -> Result<()> {\n     let conditions = BTreeMap::from(conditions.map(|c| (c.into(), ConditionValue::Set)));\n     for (alias, value) in &alias_options.await? {\n-        if let Some(mapping) = export_value_to_import_mapping(value, &conditions, project_path) {\n+        if let Some(mapping) =\n+            export_value_to_import_mapping(value, &conditions, project_path.clone())\n+        {\n             import_map.insert_alias(alias, mapping);\n         }\n     }\n@@ -1038,7 +1079,7 @@ pub async fn insert_alias_option<const N: usize>(\n fn export_value_to_import_mapping(\n     value: &SubpathValue,\n     conditions: &BTreeMap<RcStr, ConditionValue>,\n-    project_path: ResolvedVc<FileSystemPath>,\n+    project_path: FileSystemPath,\n ) -> Option<ResolvedVc<ImportMapping>> {\n     let mut result = Vec::new();\n     value.add_results(\n@@ -1058,7 +1099,7 @@ fn export_value_to_import_mapping(\n                 result\n                     .iter()\n                     .map(|(m, _)| {\n-                        ImportMapping::PrimaryAlternative((*m).into(), Some(project_path))\n+                        ImportMapping::PrimaryAlternative((*m).into(), Some(project_path.clone()))\n                             .resolved_cell()\n                     })\n                     .collect(),\n@@ -1070,22 +1111,27 @@ fn export_value_to_import_mapping(\n \n fn insert_exact_alias_map(\n     import_map: &mut ImportMap,\n-    project_path: ResolvedVc<FileSystemPath>,\n+    project_path: FileSystemPath,\n     map: FxIndexMap<&'static str, String>,\n ) {\n     for (pattern, request) in map {\n-        import_map.insert_exact_alias(pattern, request_to_import_mapping(project_path, &request));\n+        import_map.insert_exact_alias(\n+            pattern,\n+            request_to_import_mapping(project_path.clone(), &request),\n+        );\n     }\n }\n \n fn insert_wildcard_alias_map(\n     import_map: &mut ImportMap,\n-    project_path: ResolvedVc<FileSystemPath>,\n+    project_path: FileSystemPath,\n     map: FxIndexMap<&'static str, String>,\n ) {\n     for (pattern, request) in map {\n-        import_map\n-            .insert_wildcard_alias(pattern, request_to_import_mapping(project_path, &request));\n+        import_map.insert_wildcard_alias(\n+            pattern,\n+            request_to_import_mapping(project_path.clone(), &request),\n+        );\n     }\n }\n \n@@ -1102,11 +1148,7 @@ fn insert_alias_to_alternatives<'a>(\n }\n \n /// Inserts an alias to an import mapping into an import map.\n-fn insert_package_alias(\n-    import_map: &mut ImportMap,\n-    prefix: &str,\n-    package_root: ResolvedVc<FileSystemPath>,\n-) {\n+fn insert_package_alias(import_map: &mut ImportMap, prefix: &str, package_root: FileSystemPath) {\n     import_map.insert_wildcard_alias(\n         prefix,\n         ImportMapping::PrimaryAlternative(rcstr!(\"./*\"), Some(package_root)).resolved_cell(),\n@@ -1120,25 +1162,25 @@ async fn insert_turbopack_dev_alias(import_map: &mut ImportMap) -> Result<()> {\n         \"@vercel/turbopack-ecmascript-runtime/\",\n         turbopack_ecmascript_runtime::embed_fs()\n             .root()\n-            .to_resolved()\n-            .await?,\n+            .await?\n+            .clone_value(),\n     );\n     Ok(())\n }\n \n /// Handles instrumentation-client.ts bundling logic\n async fn insert_instrumentation_client_alias(\n     import_map: &mut ImportMap,\n-    project_path: ResolvedVc<FileSystemPath>,\n+    project_path: FileSystemPath,\n ) -> Result<()> {\n     insert_alias_to_alternatives(\n         import_map,\n         \"private-next-instrumentation-client\",\n         vec![\n-            request_to_import_mapping(project_path, \"./src/instrumentation-client\"),\n-            request_to_import_mapping(project_path, \"./src/instrumentation-client.ts\"),\n-            request_to_import_mapping(project_path, \"./instrumentation-client\"),\n-            request_to_import_mapping(project_path, \"./instrumentation-client.ts\"),\n+            request_to_import_mapping(project_path.clone(), \"./src/instrumentation-client\"),\n+            request_to_import_mapping(project_path.clone(), \"./src/instrumentation-client.ts\"),\n+            request_to_import_mapping(project_path.clone(), \"./instrumentation-client\"),\n+            request_to_import_mapping(project_path.clone(), \"./instrumentation-client.ts\"),\n             ImportMapping::Ignore.resolved_cell(),\n         ],\n     );\n@@ -1159,7 +1201,7 @@ fn insert_exact_alias_or_js(\n /// Creates a direct import mapping to the result of resolving a request\n /// in a context.\n fn request_to_import_mapping(\n-    context_path: ResolvedVc<FileSystemPath>,\n+    context_path: FileSystemPath,\n     request: &str,\n ) -> ResolvedVc<ImportMapping> {\n     ImportMapping::PrimaryAlternative(request.into(), Some(context_path)).resolved_cell()\n@@ -1168,7 +1210,7 @@ fn request_to_import_mapping(\n /// Creates a direct import mapping to the result of resolving an external\n /// request.\n fn external_request_to_cjs_import_mapping(\n-    context_dir: ResolvedVc<FileSystemPath>,\n+    context_dir: FileSystemPath,\n     request: &str,\n ) -> ResolvedVc<ImportMapping> {\n     ImportMapping::PrimaryAlternativeExternal {\n@@ -1183,7 +1225,7 @@ fn external_request_to_cjs_import_mapping(\n /// Creates a direct import mapping to the result of resolving an external\n /// request.\n fn external_request_to_esm_import_mapping(\n-    context_dir: ResolvedVc<FileSystemPath>,\n+    context_dir: FileSystemPath,\n     request: &str,\n ) -> ResolvedVc<ImportMapping> {\n     ImportMapping::PrimaryAlternativeExternal {"
        },
        {
            "sha": "a28a25fcfe9f782efead577ade225b973ea3dab1",
            "filename": "crates/next-core/src/next_manifests/client_reference_manifest.rs",
            "status": "modified",
            "additions": 18,
            "deletions": 19,
            "changes": 37,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_manifests%2Fclient_reference_manifest.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_manifests%2Fclient_reference_manifest.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_manifests%2Fclient_reference_manifest.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -7,8 +7,8 @@ use serde::{Deserialize, Serialize};\n use tracing::Instrument;\n use turbo_rcstr::RcStr;\n use turbo_tasks::{\n-    FxIndexSet, ReadRef, ResolvedVc, TaskInput, TryFlatJoinIterExt, TryJoinIterExt, ValueToString,\n-    Vc, trace::TraceRawVcs,\n+    FxIndexSet, ResolvedVc, TaskInput, TryFlatJoinIterExt, TryJoinIterExt, ValueToString, Vc,\n+    trace::TraceRawVcs,\n };\n use turbo_tasks_fs::{File, FileSystemPath};\n use turbopack_core::{\n@@ -32,8 +32,8 @@ use crate::{\n \n #[derive(TaskInput, Clone, Hash, Debug, PartialEq, Eq, Serialize, Deserialize, TraceRawVcs)]\n pub struct ClientReferenceManifestOptions {\n-    pub node_root: ResolvedVc<FileSystemPath>,\n-    pub client_relative_path: ResolvedVc<FileSystemPath>,\n+    pub node_root: FileSystemPath,\n+    pub client_relative_path: FileSystemPath,\n     pub entry_name: RcStr,\n     pub client_references: ResolvedVc<ClientReferenceGraphResult>,\n     pub client_references_chunks: ResolvedVc<ClientReferencesChunks>,\n@@ -96,8 +96,8 @@ impl ClientReferenceManifest {\n                 layout_segment_client_chunks,\n                 client_component_ssr_chunks,\n             } = &*client_references_chunks.await?;\n-            let client_relative_path = &*client_relative_path.await?;\n-            let node_root_ref = &*node_root.await?;\n+            let client_relative_path = client_relative_path.clone();\n+            let node_root_ref = node_root.clone();\n \n             let client_references_ecmascript = client_references\n                 .await?\n@@ -128,19 +128,18 @@ impl ClientReferenceManifest {\n                 .await?;\n \n             async fn cached_chunk_paths(\n-                cache: &mut FxHashMap<ResolvedVc<Box<dyn OutputAsset>>, ReadRef<FileSystemPath>>,\n+                cache: &mut FxHashMap<ResolvedVc<Box<dyn OutputAsset>>, FileSystemPath>,\n                 chunks: impl Iterator<Item = ResolvedVc<Box<dyn OutputAsset>>>,\n-            ) -> Result<\n-                impl Iterator<Item = (ResolvedVc<Box<dyn OutputAsset>>, ReadRef<FileSystemPath>)>,\n-            > {\n+            ) -> Result<impl Iterator<Item = (ResolvedVc<Box<dyn OutputAsset>>, FileSystemPath)>>\n+            {\n                 let results = chunks\n                     .into_iter()\n                     .map(|chunk| (chunk, cache.get(&chunk).cloned()))\n                     .map(async |(chunk, path)| {\n                         Ok(if let Some(path) = path {\n                             (chunk, Either::Left(path))\n                         } else {\n-                            (chunk, Either::Right(chunk.path().await?))\n+                            (chunk, Either::Right(chunk.path().await?.clone_value()))\n                         })\n                     })\n                     .try_join()\n@@ -158,11 +157,11 @@ impl ClientReferenceManifest {\n             }\n             let mut client_chunk_path_cache: FxHashMap<\n                 ResolvedVc<Box<dyn OutputAsset>>,\n-                ReadRef<FileSystemPath>,\n+                FileSystemPath,\n             > = FxHashMap::default();\n             let mut ssr_chunk_path_cache: FxHashMap<\n                 ResolvedVc<Box<dyn OutputAsset>>,\n-                ReadRef<FileSystemPath>,\n+                FileSystemPath,\n             > = FxHashMap::default();\n \n             for (client_reference_module, client_reference_module_ref) in\n@@ -327,8 +326,9 @@ impl ClientReferenceManifest {\n             for (server_component, client_chunks) in layout_segment_client_chunks.iter() {\n                 let server_component_name = server_component\n                     .server_path()\n-                    .with_extension(\"\".into())\n-                    .to_string()\n+                    .await?\n+                    .with_extension(\"\")\n+                    .value_to_string()\n                     .owned()\n                     .await?;\n                 let mut entry_css_files_with_chunk = Vec::new();\n@@ -396,10 +396,9 @@ impl ClientReferenceManifest {\n             // path still (same as webpack does)\n             let normalized_manifest_entry = entry_name.replace(\"%5F\", \"_\");\n             Ok(Vc::upcast(VirtualOutputAsset::new_with_references(\n-                node_root.join(\n-                    format!(\"server/app{normalized_manifest_entry}_client-reference-manifest.js\",)\n-                        .into(),\n-                ),\n+                node_root.join(&format!(\n+                    \"server/app{normalized_manifest_entry}_client-reference-manifest.js\",\n+                ))?,\n                 AssetContent::file(\n                     File::from(formatdoc! {\n                         r#\""
        },
        {
            "sha": "b4537409683c5a44a5ae0ce58bf21cf2758f20a0",
            "filename": "crates/next-core/src/next_manifests/mod.rs",
            "status": "modified",
            "additions": 81,
            "deletions": 52,
            "changes": 133,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_manifests%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_manifests%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_manifests%2Fmod.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -35,10 +35,10 @@ pub struct BuildManifest {\n impl BuildManifest {\n     pub async fn build_output(\n         self,\n-        output_path: Vc<FileSystemPath>,\n-        client_relative_path: Vc<FileSystemPath>,\n+        output_path: FileSystemPath,\n+        client_relative_path: FileSystemPath,\n     ) -> Result<Vc<Box<dyn OutputAsset>>> {\n-        let client_relative_path_ref = &*client_relative_path.await?;\n+        let client_relative_path_ref = client_relative_path.clone();\n \n         #[derive(Serialize, Default, Debug)]\n         #[serde(rename_all = \"camelCase\")]\n@@ -55,23 +55,33 @@ impl BuildManifest {\n         let pages: Vec<(RcStr, Vec<RcStr>)> = self\n             .pages\n             .iter()\n-            .map(|(k, chunks)| async move {\n-                Ok((\n-                    k.clone(),\n-                    chunks\n-                        .await?\n-                        .iter()\n-                        .copied()\n-                        .map(|chunk| async move {\n-                            let chunk_path = chunk.path().await?;\n-                            Ok(client_relative_path_ref\n-                                .get_path_to(&chunk_path)\n-                                .context(\"client chunk entry path must be inside the client root\")?\n-                                .into())\n-                        })\n-                        .try_join()\n-                        .await?,\n-                ))\n+            .map(|(k, chunks)| {\n+                let client_relative_path_ref = client_relative_path_ref.clone();\n+\n+                async move {\n+                    Ok((\n+                        k.clone(),\n+                        chunks\n+                            .await?\n+                            .iter()\n+                            .copied()\n+                            .map(|chunk| {\n+                                let client_relative_path_ref = client_relative_path_ref.clone();\n+                                async move {\n+                                    let chunk_path = chunk.path().await?;\n+                                    Ok(client_relative_path_ref\n+                                        .get_path_to(&chunk_path)\n+                                        .context(\n+                                            \"client chunk entry path must be inside the client \\\n+                                             root\",\n+                                        )?\n+                                        .into())\n+                                }\n+                            })\n+                            .try_join()\n+                            .await?,\n+                    ))\n+                }\n             })\n             .try_join()\n             .await?;\n@@ -80,12 +90,16 @@ impl BuildManifest {\n             .polyfill_files\n             .iter()\n             .copied()\n-            .map(|chunk| async move {\n-                let chunk_path = chunk.path().await?;\n-                Ok(client_relative_path_ref\n-                    .get_path_to(&chunk_path)\n-                    .context(\"failed to resolve client-relative path to polyfill\")?\n-                    .into())\n+            .map(|chunk| {\n+                let client_relative_path_ref = client_relative_path_ref.clone();\n+\n+                async move {\n+                    let chunk_path = chunk.path().await?;\n+                    Ok(client_relative_path_ref\n+                        .get_path_to(&chunk_path)\n+                        .context(\"failed to resolve client-relative path to polyfill\")?\n+                        .into())\n+                }\n             })\n             .try_join()\n             .await?;\n@@ -94,12 +108,16 @@ impl BuildManifest {\n             .root_main_files\n             .iter()\n             .copied()\n-            .map(|chunk| async move {\n-                let chunk_path = chunk.path().await?;\n-                Ok(client_relative_path_ref\n-                    .get_path_to(&chunk_path)\n-                    .context(\"failed to resolve client-relative path to root_main_file\")?\n-                    .into())\n+            .map(|chunk| {\n+                let client_relative_path_ref = client_relative_path_ref.clone();\n+\n+                async move {\n+                    let chunk_path = chunk.path().await?;\n+                    Ok(client_relative_path_ref\n+                        .get_path_to(&chunk_path)\n+                        .context(\"failed to resolve client-relative path to root_main_file\")?\n+                        .into())\n+                }\n             })\n             .try_join()\n             .await?;\n@@ -421,10 +439,10 @@ pub struct AppBuildManifest {\n impl AppBuildManifest {\n     pub async fn build_output(\n         self,\n-        output_path: Vc<FileSystemPath>,\n-        client_relative_path: Vc<FileSystemPath>,\n+        output_path: FileSystemPath,\n+        client_relative_path: FileSystemPath,\n     ) -> Result<Vc<Box<dyn OutputAsset>>> {\n-        let client_relative_path_ref = &*client_relative_path.await?;\n+        let client_relative_path_ref = client_relative_path.clone();\n \n         #[derive(Serialize)]\n         #[serde(rename_all = \"camelCase\")]\n@@ -435,23 +453,34 @@ impl AppBuildManifest {\n         let pages: Vec<(RcStr, Vec<RcStr>)> = self\n             .pages\n             .iter()\n-            .map(|(k, chunks)| async move {\n-                Ok((\n-                    k.clone(),\n-                    chunks\n-                        .await?\n-                        .iter()\n-                        .copied()\n-                        .map(|chunk| async move {\n-                            let chunk_path = chunk.path().await?;\n-                            Ok(client_relative_path_ref\n-                                .get_path_to(&chunk_path)\n-                                .context(\"client chunk entry path must be inside the client root\")?\n-                                .into())\n-                        })\n-                        .try_join()\n-                        .await?,\n-                ))\n+            .map(|(k, chunks)| {\n+                let client_relative_path_ref = client_relative_path_ref.clone();\n+\n+                async move {\n+                    Ok((\n+                        k.clone(),\n+                        chunks\n+                            .await?\n+                            .iter()\n+                            .copied()\n+                            .map(|chunk| {\n+                                let client_relative_path_ref = client_relative_path_ref.clone();\n+\n+                                async move {\n+                                    let chunk_path = chunk.path().await?;\n+                                    Ok(client_relative_path_ref\n+                                        .get_path_to(&chunk_path)\n+                                        .context(\n+                                            \"client chunk entry path must be inside the client \\\n+                                             root\",\n+                                        )?\n+                                        .into())\n+                                }\n+                            })\n+                            .try_join()\n+                            .await?,\n+                    ))\n+                }\n             })\n             .try_join()\n             .await?;"
        },
        {
            "sha": "ff89f343b8c6bffad6c4ac4a645ce75e6639e9ca",
            "filename": "crates/next-core/src/next_pages/page_entry.rs",
            "status": "modified",
            "additions": 9,
            "deletions": 9,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_pages%2Fpage_entry.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_pages%2Fpage_entry.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_pages%2Fpage_entry.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -34,7 +34,7 @@ pub struct PageSsrEntryModule {\n pub async fn create_page_ssr_entry_module(\n     pathname: RcStr,\n     reference_type: ReferenceType,\n-    project_root: Vc<FileSystemPath>,\n+    project_root: FileSystemPath,\n     ssr_module_context: Vc<Box<dyn AssetContext>>,\n     source: Vc<Box<dyn Source>>,\n     next_original_name: RcStr,\n@@ -86,7 +86,7 @@ pub async fn create_page_ssr_entry_module(\n     // Load the file from the next.js codebase.\n     let mut source = load_next_js_template(\n         template_file,\n-        project_root,\n+        project_root.clone(),\n         replacements,\n         FxIndexMap::default(),\n         FxIndexMap::default(),\n@@ -112,7 +112,7 @@ pub async fn create_page_ssr_entry_module(\n         let file = File::from(result.build());\n \n         source = Vc::upcast(VirtualSource::new(\n-            source.ident().path(),\n+            source.ident().path().await?.clone_value(),\n             AssetContent::file(file.into()),\n         ));\n     }\n@@ -184,19 +184,19 @@ pub async fn create_page_ssr_entry_module(\n }\n \n #[turbo_tasks::function]\n-fn process_global_item(\n+async fn process_global_item(\n     item: Vc<PagesStructureItem>,\n     reference_type: ReferenceType,\n     module_context: Vc<Box<dyn AssetContext>>,\n-) -> Vc<Box<dyn Module>> {\n-    let source = Vc::upcast(FileSource::new(item.file_path()));\n-    module_context.process(source, reference_type).module()\n+) -> Result<Vc<Box<dyn Module>>> {\n+    let source = Vc::upcast(FileSource::new(item.file_path().await?.clone_value()));\n+    Ok(module_context.process(source, reference_type).module())\n }\n \n #[turbo_tasks::function]\n async fn wrap_edge_page(\n     asset_context: Vc<Box<dyn AssetContext>>,\n-    project_root: Vc<FileSystemPath>,\n+    project_root: FileSystemPath,\n     entry: ResolvedVc<Box<dyn Module>>,\n     page: RcStr,\n     pathname: RcStr,\n@@ -226,7 +226,7 @@ async fn wrap_edge_page(\n \n     let source = load_next_js_template(\n         \"edge-ssr.js\",\n-        project_root,\n+        project_root.clone(),\n         fxindexmap! {\n             \"VAR_USERLAND\" => INNER.into(),\n             \"VAR_PAGE\" => pathname.clone(),"
        },
        {
            "sha": "850ae1bcfdfeb6db11ef1057f488f7a99b53561c",
            "filename": "crates/next-core/src/next_server/context.rs",
            "status": "modified",
            "additions": 58,
            "deletions": 69,
            "changes": 127,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_server%2Fcontext.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_server%2Fcontext.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_server%2Fcontext.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -2,7 +2,7 @@ use std::iter::once;\n \n use anyhow::{Result, bail};\n use turbo_rcstr::{RcStr, rcstr};\n-use turbo_tasks::{FxIndexMap, OptionVcExt, ResolvedVc, TaskInput, Vc};\n+use turbo_tasks::{FxIndexMap, ResolvedVc, TaskInput, Vc};\n use turbo_tasks_env::EnvMap;\n use turbo_tasks_fs::FileSystemPath;\n use turbopack::{\n@@ -82,32 +82,32 @@ use crate::{\n #[derive(Debug, Clone, Hash, TaskInput)]\n pub enum ServerContextType {\n     Pages {\n-        pages_dir: ResolvedVc<FileSystemPath>,\n+        pages_dir: FileSystemPath,\n     },\n     PagesApi {\n-        pages_dir: ResolvedVc<FileSystemPath>,\n+        pages_dir: FileSystemPath,\n     },\n     PagesData {\n-        pages_dir: ResolvedVc<FileSystemPath>,\n+        pages_dir: FileSystemPath,\n     },\n     AppSSR {\n-        app_dir: ResolvedVc<FileSystemPath>,\n+        app_dir: FileSystemPath,\n     },\n     AppRSC {\n-        app_dir: ResolvedVc<FileSystemPath>,\n+        app_dir: FileSystemPath,\n         ecmascript_client_reference_transition_name: Option<RcStr>,\n         client_transition: Option<ResolvedVc<Box<dyn Transition>>>,\n     },\n     AppRoute {\n-        app_dir: ResolvedVc<FileSystemPath>,\n+        app_dir: FileSystemPath,\n         ecmascript_client_reference_transition_name: Option<RcStr>,\n     },\n     Middleware {\n-        app_dir: Option<ResolvedVc<FileSystemPath>>,\n+        app_dir: Option<FileSystemPath>,\n         ecmascript_client_reference_transition_name: Option<RcStr>,\n     },\n     Instrumentation {\n-        app_dir: Option<ResolvedVc<FileSystemPath>>,\n+        app_dir: Option<FileSystemPath>,\n         ecmascript_client_reference_transition_name: Option<RcStr>,\n     },\n }\n@@ -127,14 +127,14 @@ impl ServerContextType {\n \n #[turbo_tasks::function]\n pub async fn get_server_resolve_options_context(\n-    project_path: ResolvedVc<FileSystemPath>,\n+    project_path: FileSystemPath,\n     ty: ServerContextType,\n     mode: Vc<NextMode>,\n     next_config: Vc<NextConfig>,\n     execution_context: Vc<ExecutionContext>,\n ) -> Result<Vc<ResolveOptionsContext>> {\n     let next_server_import_map = get_next_server_import_map(\n-        *project_path,\n+        project_path.clone(),\n         ty.clone(),\n         next_config,\n         mode,\n@@ -143,27 +143,29 @@ pub async fn get_server_resolve_options_context(\n     .to_resolved()\n     .await?;\n     let foreign_code_context_condition =\n-        foreign_code_context_condition(next_config, project_path).await?;\n-    let root_dir = project_path.root().to_resolved().await?;\n-    let module_feature_report_resolve_plugin = ModuleFeatureReportResolvePlugin::new(*project_path)\n-        .to_resolved()\n-        .await?;\n-    let invalid_client_only_resolve_plugin = get_invalid_client_only_resolve_plugin(project_path)\n-        .to_resolved()\n-        .await?;\n+        foreign_code_context_condition(next_config, project_path.clone()).await?;\n+    let root_dir = project_path.root().await?.clone_value();\n+    let module_feature_report_resolve_plugin =\n+        ModuleFeatureReportResolvePlugin::new(project_path.clone())\n+            .to_resolved()\n+            .await?;\n+    let invalid_client_only_resolve_plugin =\n+        get_invalid_client_only_resolve_plugin(project_path.clone())\n+            .to_resolved()\n+            .await?;\n     let invalid_styled_jsx_client_only_resolve_plugin =\n-        get_invalid_styled_jsx_resolve_plugin(project_path)\n+        get_invalid_styled_jsx_resolve_plugin(project_path.clone())\n             .to_resolved()\n             .await?;\n \n     // Always load these predefined packages as external.\n     let mut external_packages: Vec<RcStr> = load_next_js_templateon(\n-        project_path,\n+        project_path.clone(),\n         rcstr!(\"dist/lib/server-external-packages.json\"),\n     )\n     .await?;\n \n-    let mut transpiled_packages = get_transpiled_packages(next_config, *project_path)\n+    let mut transpiled_packages = get_transpiled_packages(next_config, project_path.clone())\n         .owned()\n         .await?;\n \n@@ -194,8 +196,8 @@ pub async fn get_server_resolve_options_context(\n     external_packages.retain(|item| !transpiled_packages.contains(item));\n \n     let server_external_packages_plugin = ExternalCjsModulesResolvePlugin::new(\n-        *project_path,\n-        project_path.root(),\n+        project_path.clone(),\n+        project_path.root().await?.clone_value(),\n         ExternalPredicate::Only(ResolvedVc::cell(external_packages)).cell(),\n         *next_config.import_externals().await?,\n     )\n@@ -219,20 +221,20 @@ pub async fn get_server_resolve_options_context(\n         server_external_packages_plugin\n     } else {\n         ExternalCjsModulesResolvePlugin::new(\n-            *project_path,\n-            project_path.root(),\n+            project_path.clone(),\n+            project_path.root().await?.clone_value(),\n             ExternalPredicate::AllExcept(ResolvedVc::cell(transpiled_packages)).cell(),\n             *next_config.import_externals().await?,\n         )\n         .to_resolved()\n         .await?\n     };\n \n-    let next_external_plugin = NextExternalResolvePlugin::new(*project_path)\n+    let next_external_plugin = NextExternalResolvePlugin::new(project_path.clone())\n         .to_resolved()\n         .await?;\n     let next_node_shared_runtime_plugin =\n-        NextNodeSharedRuntimeResolvePlugin::new(*project_path, ty.clone())\n+        NextNodeSharedRuntimeResolvePlugin::new(project_path.clone(), ty.clone())\n             .to_resolved()\n             .await?;\n \n@@ -242,7 +244,7 @@ pub async fn get_server_resolve_options_context(\n         | ServerContextType::AppRSC { .. } => {\n             vec![\n                 ResolvedVc::upcast(\n-                    NextFontLocalResolvePlugin::new(*project_path)\n+                    NextFontLocalResolvePlugin::new(project_path.clone())\n                         .to_resolved()\n                         .await?,\n                 ),\n@@ -314,7 +316,7 @@ pub async fn get_server_resolve_options_context(\n     }\n \n     let resolve_options_context = ResolveOptionsContext {\n-        enable_node_modules: Some(root_dir),\n+        enable_node_modules: Some(root_dir.clone()),\n         enable_node_externals: true,\n         enable_node_native_modules: true,\n         module: true,\n@@ -334,9 +336,8 @@ pub async fn get_server_resolve_options_context(\n             .typescript_tsconfig_path()\n             .await?\n             .as_ref()\n-            .map(|p| project_path.join(p.to_owned()))\n-            .to_resolved()\n-            .await?,\n+            .map(|p| project_path.join(p))\n+            .transpose()?,\n         rules: vec![(\n             foreign_code_context_condition,\n             resolve_options_context.clone().resolved_cell(),\n@@ -405,7 +406,7 @@ pub async fn get_server_compile_time_info(\n \n #[turbo_tasks::function]\n pub async fn get_server_module_options_context(\n-    project_path: ResolvedVc<FileSystemPath>,\n+    project_path: FileSystemPath,\n     execution_context: ResolvedVc<ExecutionContext>,\n     ty: ServerContextType,\n     mode: Vc<NextMode>,\n@@ -440,10 +441,10 @@ pub async fn get_server_module_options_context(\n     .await?;\n \n     let foreign_code_context_condition =\n-        foreign_code_context_condition(next_config, project_path).await?;\n+        foreign_code_context_condition(next_config, project_path.clone()).await?;\n     let postcss_transform_options = PostCssTransformOptions {\n         postcss_package: Some(\n-            get_postcss_package_mapping(*project_path)\n+            get_postcss_package_mapping(project_path.clone())\n                 .to_resolved()\n                 .await?,\n         ),\n@@ -474,7 +475,7 @@ pub async fn get_server_module_options_context(\n     // node_modules that requires webpack loaders, which next-dev implicitly\n     // does by default.\n     let foreign_enable_webpack_loaders = webpack_loader_options(\n-        project_path,\n+        project_path.clone(),\n         next_config,\n         true,\n         conditions\n@@ -487,7 +488,7 @@ pub async fn get_server_module_options_context(\n \n     // Now creates a webpack rules that applies to all codes.\n     let enable_webpack_loaders =\n-        webpack_loader_options(project_path, next_config, false, conditions).await?;\n+        webpack_loader_options(project_path.clone(), next_config, false, conditions).await?;\n \n     let tree_shaking_mode_for_user_code = *next_config\n         .tree_shaking_mode_for_user_code(next_mode.is_development())\n@@ -498,10 +499,10 @@ pub async fn get_server_module_options_context(\n     let versions = RuntimeVersions(Default::default()).cell();\n \n     // ModuleOptionsContext related options\n-    let tsconfig = get_typescript_transform_options(*project_path)\n+    let tsconfig = get_typescript_transform_options(project_path.clone())\n         .to_resolved()\n         .await?;\n-    let decorators_options = get_decorators_transform_options(*project_path);\n+    let decorators_options = get_decorators_transform_options(project_path.clone());\n     let enable_mdx_rs = *next_config.mdx_rs().await?;\n \n     // Get the jsx transform options for the `client` side.\n@@ -512,18 +513,18 @@ pub async fn get_server_module_options_context(\n     // This enables correct emotion transform and other hydration between server and\n     // client bundles. ref: https://github.com/vercel/next.js/blob/4bbf9b6c70d2aa4237defe2bebfa790cdb7e334e/packages/next/src/build/webpack-config.ts#L1421-L1426\n     let jsx_runtime_options =\n-        get_jsx_transform_options(*project_path, mode, None, false, next_config)\n+        get_jsx_transform_options(project_path.clone(), mode, None, false, next_config)\n             .to_resolved()\n             .await?;\n     let rsc_jsx_runtime_options =\n-        get_jsx_transform_options(*project_path, mode, None, true, next_config)\n+        get_jsx_transform_options(project_path.clone(), mode, None, true, next_config)\n             .to_resolved()\n             .await?;\n \n     // A set of custom ecma transform rules being applied to server context.\n     let source_transform_rules: Vec<ModuleRule> = vec![\n-        get_swc_ecma_transform_plugin_rule(next_config, project_path).await?,\n-        get_relay_transform_rule(next_config, project_path).await?,\n+        get_swc_ecma_transform_plugin_rule(next_config, project_path.clone()).await?,\n+        get_relay_transform_rule(next_config, project_path.clone()).await?,\n         get_emotion_transform_rule(next_config).await?,\n         get_react_remove_properties_transform_rule(next_config).await?,\n         get_remove_console_transform_rule(next_config).await?,\n@@ -986,10 +987,10 @@ pub fn get_server_runtime_entries(\n #[turbo_tasks::function]\n pub async fn get_server_chunking_context_with_client_assets(\n     mode: Vc<NextMode>,\n-    root_path: ResolvedVc<FileSystemPath>,\n-    node_root: ResolvedVc<FileSystemPath>,\n+    root_path: FileSystemPath,\n+    node_root: FileSystemPath,\n     node_root_to_root_path: RcStr,\n-    client_root: ResolvedVc<FileSystemPath>,\n+    client_root: FileSystemPath,\n     asset_prefix: Option<RcStr>,\n     environment: ResolvedVc<Environment>,\n     module_id_strategy: ResolvedVc<Box<dyn ModuleIdStrategy>>,\n@@ -1004,17 +1005,11 @@ pub async fn get_server_chunking_context_with_client_assets(\n     // support both production and development modes.\n     let mut builder = NodeJsChunkingContext::builder(\n         root_path,\n-        node_root,\n+        node_root.clone(),\n         node_root_to_root_path,\n-        client_root,\n-        node_root\n-            .join(rcstr!(\"server/chunks/ssr\"))\n-            .to_resolved()\n-            .await?,\n-        client_root\n-            .join(rcstr!(\"static/media\"))\n-            .to_resolved()\n-            .await?,\n+        client_root.clone(),\n+        node_root.join(\"server/chunks/ssr\")?,\n+        client_root.join(\"static/media\")?,\n         environment,\n         next_mode.runtime_type(),\n     )\n@@ -1064,8 +1059,8 @@ pub async fn get_server_chunking_context_with_client_assets(\n #[turbo_tasks::function]\n pub async fn get_server_chunking_context(\n     mode: Vc<NextMode>,\n-    root_path: ResolvedVc<FileSystemPath>,\n-    node_root: ResolvedVc<FileSystemPath>,\n+    root_path: FileSystemPath,\n+    node_root: FileSystemPath,\n     node_root_to_root_path: RcStr,\n     environment: ResolvedVc<Environment>,\n     module_id_strategy: ResolvedVc<Box<dyn ModuleIdStrategy>>,\n@@ -1080,17 +1075,11 @@ pub async fn get_server_chunking_context(\n     // support both production and development modes.\n     let mut builder = NodeJsChunkingContext::builder(\n         root_path,\n-        node_root,\n+        node_root.clone(),\n         node_root_to_root_path,\n-        node_root,\n-        node_root\n-            .join(rcstr!(\"server/chunks\"))\n-            .to_resolved()\n-            .await?,\n-        node_root\n-            .join(rcstr!(\"server/assets\"))\n-            .to_resolved()\n-            .await?,\n+        node_root.clone(),\n+        node_root.join(\"server/chunks\")?,\n+        node_root.join(\"server/assets\")?,\n         environment,\n         next_mode.runtime_type(),\n     )"
        },
        {
            "sha": "096dee9a8a85333ed89ae897af1c23b26367438e",
            "filename": "crates/next-core/src/next_server/resolve.rs",
            "status": "modified",
            "additions": 34,
            "deletions": 37,
            "changes": 71,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_server%2Fresolve.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_server%2Fresolve.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_server%2Fresolve.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -37,8 +37,8 @@ pub enum ExternalPredicate {\n /// possible to resolve them at runtime.\n #[turbo_tasks::value]\n pub(crate) struct ExternalCjsModulesResolvePlugin {\n-    project_path: ResolvedVc<FileSystemPath>,\n-    root: ResolvedVc<FileSystemPath>,\n+    project_path: FileSystemPath,\n+    root: FileSystemPath,\n     predicate: ResolvedVc<ExternalPredicate>,\n     import_externals: bool,\n }\n@@ -47,8 +47,8 @@ pub(crate) struct ExternalCjsModulesResolvePlugin {\n impl ExternalCjsModulesResolvePlugin {\n     #[turbo_tasks::function]\n     pub fn new(\n-        project_path: ResolvedVc<FileSystemPath>,\n-        root: ResolvedVc<FileSystemPath>,\n+        project_path: FileSystemPath,\n+        root: FileSystemPath,\n         predicate: ResolvedVc<ExternalPredicate>,\n         import_externals: bool,\n     ) -> Vc<Self> {\n@@ -63,22 +63,22 @@ impl ExternalCjsModulesResolvePlugin {\n }\n \n #[turbo_tasks::function]\n-fn condition(root: Vc<FileSystemPath>) -> Vc<AfterResolvePluginCondition> {\n+fn condition(root: FileSystemPath) -> Vc<AfterResolvePluginCondition> {\n     AfterResolvePluginCondition::new(root, Glob::new(\"**/node_modules/**\".into()))\n }\n \n #[turbo_tasks::value_impl]\n impl AfterResolvePlugin for ExternalCjsModulesResolvePlugin {\n     #[turbo_tasks::function]\n     fn after_resolve_condition(&self) -> Vc<AfterResolvePluginCondition> {\n-        condition(*self.root)\n+        condition(self.root.clone())\n     }\n \n     #[turbo_tasks::function]\n     async fn after_resolve(\n         &self,\n-        fs_path: ResolvedVc<FileSystemPath>,\n-        lookup_path: ResolvedVc<FileSystemPath>,\n+        fs_path: FileSystemPath,\n+        lookup_path: FileSystemPath,\n         reference_type: ReferenceType,\n         request: ResolvedVc<Request>,\n     ) -> Result<Vc<ResolveResultOption>> {\n@@ -103,12 +103,15 @@ impl AfterResolvePlugin for ExternalCjsModulesResolvePlugin {\n             return Ok(ResolveResultOption::none());\n         }\n \n-        let raw_fs_path = &*fs_path.await?;\n+        let raw_fs_path = fs_path.clone();\n \n         let predicate = self.predicate.await?;\n         let must_be_external = match &*predicate {\n             ExternalPredicate::AllExcept(exceptions) => {\n-                if *condition(*self.root).matches(*lookup_path).await? {\n+                if *condition(self.root.clone())\n+                    .matches(lookup_path.clone())\n+                    .await?\n+                {\n                     return Ok(ResolveResultOption::none());\n                 }\n \n@@ -161,7 +164,7 @@ impl AfterResolvePlugin for ExternalCjsModulesResolvePlugin {\n         }\n \n         async fn get_file_type(\n-            fs_path: Vc<FileSystemPath>,\n+            fs_path: FileSystemPath,\n             raw_fs_path: &FileSystemPath,\n         ) -> Result<FileType> {\n             // node.js only supports these file extensions\n@@ -177,7 +180,7 @@ impl AfterResolvePlugin for ExternalCjsModulesResolvePlugin {\n                 // for .js extension in cjs context, we need to check the actual module type via\n                 // package.json\n                 let FindContextFileResult::Found(package_json, _) =\n-                    *find_context_file(fs_path.parent(), package_json()).await?\n+                    &*find_context_file(fs_path.parent(), package_json()).await?\n                 else {\n                     // can't find package.json\n                     return Ok(FileType::CommonJs);\n@@ -200,7 +203,7 @@ impl AfterResolvePlugin for ExternalCjsModulesResolvePlugin {\n         let unable_to_externalize = |reason: Vec<StyledString>| {\n             if must_be_external {\n                 ExternalizeIssue {\n-                    file_path: lookup_path,\n+                    file_path: lookup_path.clone(),\n                     package: package.clone(),\n                     request_str: request_str.clone(),\n                     reason,\n@@ -215,13 +218,13 @@ impl AfterResolvePlugin for ExternalCjsModulesResolvePlugin {\n         let mut request_str = request_str.to_string();\n \n         let node_resolve_options = if is_esm {\n-            node_esm_resolve_options(lookup_path.root())\n+            node_esm_resolve_options(lookup_path.root().await?.clone_value())\n         } else {\n-            node_cjs_resolve_options(lookup_path.root())\n+            node_cjs_resolve_options(lookup_path.root().await?.clone_value())\n         };\n         let result_from_original_location = loop {\n             let node_resolved_from_original_location = resolve(\n-                *lookup_path,\n+                lookup_path.clone(),\n                 reference_type.clone(),\n                 request,\n                 node_resolve_options,\n@@ -254,7 +257,7 @@ impl AfterResolvePlugin for ExternalCjsModulesResolvePlugin {\n             break result_from_original_location;\n         };\n         let node_resolved = resolve(\n-            *self.project_path,\n+            self.project_path.clone(),\n             reference_type.clone(),\n             request,\n             node_resolve_options,\n@@ -276,20 +279,13 @@ impl AfterResolvePlugin for ExternalCjsModulesResolvePlugin {\n         };\n \n         if result_from_original_location != result {\n-            let package_json_file = find_context_file(\n-                result.ident().path().parent().resolve().await?,\n-                package_json(),\n-            );\n+            let package_json_file =\n+                find_context_file(result.ident().path().await?.parent(), package_json());\n             let package_json_from_original_location = find_context_file(\n-                result_from_original_location\n-                    .ident()\n-                    .path()\n-                    .parent()\n-                    .resolve()\n-                    .await?,\n+                result_from_original_location.ident().path().await?.parent(),\n                 package_json(),\n             );\n-            let FindContextFileResult::Found(package_json_file, _) = *package_json_file.await?\n+            let FindContextFileResult::Found(package_json_file, _) = &*package_json_file.await?\n             else {\n                 return unable_to_externalize(vec![StyledString::Text(\n                     \"The package.json of the package resolved from the project directory can't be \\\n@@ -298,7 +294,7 @@ impl AfterResolvePlugin for ExternalCjsModulesResolvePlugin {\n                 )]);\n             };\n             let FindContextFileResult::Found(package_json_from_original_location, _) =\n-                *package_json_from_original_location.await?\n+                &*package_json_from_original_location.await?\n             else {\n                 return unable_to_externalize(vec![StyledString::Text(\n                     \"The package.json of the package can't be found.\".into(),\n@@ -355,8 +351,8 @@ impl AfterResolvePlugin for ExternalCjsModulesResolvePlugin {\n                 )]);\n             }\n         }\n-        let path = result.ident().path().resolve().await?;\n-        let file_type = get_file_type(path, &*path.await?).await?;\n+        let path = result.ident().path().await?.clone_value();\n+        let file_type = get_file_type(path.clone(), &path).await?;\n \n         let external_type = match (file_type, is_esm) {\n             (FileType::UnsupportedExtension, _) => {\n@@ -376,16 +372,17 @@ impl AfterResolvePlugin for ExternalCjsModulesResolvePlugin {\n             (FileType::CommonJs, true) => {\n                 // It would be more efficient to use an CJS external instead of an ESM external,\n                 // but we need to verify if that would be correct (as in resolves to the same file).\n-                let node_resolve_options = node_cjs_resolve_options(lookup_path.root());\n+                let node_resolve_options =\n+                    node_cjs_resolve_options(lookup_path.root().await?.clone_value());\n                 let node_resolved = resolve(\n-                    *self.project_path,\n+                    self.project_path.clone(),\n                     reference_type.clone(),\n                     request,\n                     node_resolve_options,\n                 );\n                 let resolves_equal = if let Some(result) = *node_resolved.first_source().await? {\n-                    let cjs_path = result.ident().path();\n-                    cjs_path.resolve().await? == path\n+                    let cjs_path = result.ident().path().await?.clone_value();\n+                    cjs_path == path\n                 } else {\n                     false\n                 };\n@@ -451,7 +448,7 @@ async fn packages_glob(packages: Vc<Vec<RcStr>>) -> Result<Vc<OptionPackagesGlob\n \n #[turbo_tasks::value]\n struct ExternalizeIssue {\n-    file_path: ResolvedVc<FileSystemPath>,\n+    file_path: FileSystemPath,\n     package: RcStr,\n     request_str: RcStr,\n     reason: Vec<StyledString>,\n@@ -480,7 +477,7 @@ impl Issue for ExternalizeIssue {\n \n     #[turbo_tasks::function]\n     fn file_path(&self) -> Vc<FileSystemPath> {\n-        *self.file_path\n+        self.file_path.clone().cell()\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "5b645ec7ab272ccc66ad7afe107ce897578d1908",
            "filename": "crates/next-core/src/next_server/transforms.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_server%2Ftransforms.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_server%2Ftransforms.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_server%2Ftransforms.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -100,7 +100,7 @@ pub async fn get_next_server_transforms_rules(\n             if !foreign_code {\n                 rules.push(get_next_disallow_export_all_in_page_rule(\n                     mdx_rs,\n-                    pages_dir.await?,\n+                    pages_dir.clone(),\n                 ));\n             }\n             false\n@@ -109,15 +109,15 @@ pub async fn get_next_server_transforms_rules(\n             if !foreign_code {\n                 rules.push(\n                     get_next_pages_transforms_rule(\n-                        **pages_dir,\n+                        pages_dir.clone(),\n                         ExportFilter::StripDefaultExport,\n                         mdx_rs,\n                     )\n                     .await?,\n                 );\n                 rules.push(get_next_disallow_export_all_in_page_rule(\n                     mdx_rs,\n-                    pages_dir.await?,\n+                    pages_dir.clone(),\n                 ));\n             }\n             false"
        },
        {
            "sha": "abd83f6ef4fee7535459fcd867c1158413010a50",
            "filename": "crates/next-core/src/next_shared/resolve.rs",
            "status": "modified",
            "additions": 47,
            "deletions": 53,
            "changes": 100,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fresolve.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fresolve.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fresolve.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -45,7 +45,7 @@ static FEATURE_MODULES: LazyLock<FxHashMap<&'static str, Vec<&'static str>>> =\n \n #[turbo_tasks::value(shared)]\n pub struct InvalidImportModuleIssue {\n-    pub file_path: ResolvedVc<FileSystemPath>,\n+    pub file_path: FileSystemPath,\n     pub messages: Vec<RcStr>,\n     pub skip_context_message: bool,\n }\n@@ -68,12 +68,12 @@ impl Issue for InvalidImportModuleIssue {\n \n     #[turbo_tasks::function]\n     fn file_path(&self) -> Vc<FileSystemPath> {\n-        *self.file_path\n+        self.file_path.clone().cell()\n     }\n \n     #[turbo_tasks::function]\n     async fn description(&self) -> Result<Vc<OptionStyledString>> {\n-        let raw_context = &*self.file_path.await?;\n+        let raw_context = self.file_path.clone();\n \n         let mut messages = self.messages.clone();\n \n@@ -101,19 +101,15 @@ impl Issue for InvalidImportModuleIssue {\n /// configured when each context sets up its resolve options.\n #[turbo_tasks::value]\n pub(crate) struct InvalidImportResolvePlugin {\n-    root: ResolvedVc<FileSystemPath>,\n+    root: FileSystemPath,\n     invalid_import: RcStr,\n     message: Vec<RcStr>,\n }\n \n #[turbo_tasks::value_impl]\n impl InvalidImportResolvePlugin {\n     #[turbo_tasks::function]\n-    pub fn new(\n-        root: ResolvedVc<FileSystemPath>,\n-        invalid_import: RcStr,\n-        message: Vec<RcStr>,\n-    ) -> Vc<Self> {\n+    pub fn new(root: FileSystemPath, invalid_import: RcStr, message: Vec<RcStr>) -> Vc<Self> {\n         InvalidImportResolvePlugin {\n             root,\n             invalid_import,\n@@ -133,7 +129,7 @@ impl BeforeResolvePlugin for InvalidImportResolvePlugin {\n     #[turbo_tasks::function]\n     fn before_resolve(\n         &self,\n-        lookup_path: ResolvedVc<FileSystemPath>,\n+        lookup_path: FileSystemPath,\n         _reference_type: ReferenceType,\n         _request: Vc<Request>,\n     ) -> Vc<ResolveResultOption> {\n@@ -156,10 +152,10 @@ impl BeforeResolvePlugin for InvalidImportResolvePlugin {\n /// Only the contexts that alises `client-only` to\n /// `next/dist/compiled/client-only/error` should use this.\n pub(crate) fn get_invalid_client_only_resolve_plugin(\n-    root: ResolvedVc<FileSystemPath>,\n+    root: FileSystemPath,\n ) -> Vc<InvalidImportResolvePlugin> {\n     InvalidImportResolvePlugin::new(\n-        *root,\n+        root,\n         \"client-only\".into(),\n         vec![\n             \"'client-only' cannot be imported from a Server Component module. It should only be \\\n@@ -173,10 +169,10 @@ pub(crate) fn get_invalid_client_only_resolve_plugin(\n /// Only the contexts that alises `server-only` to\n /// `next/dist/compiled/server-only/index` should use this.\n pub(crate) fn get_invalid_server_only_resolve_plugin(\n-    root: ResolvedVc<FileSystemPath>,\n+    root: FileSystemPath,\n ) -> Vc<InvalidImportResolvePlugin> {\n     InvalidImportResolvePlugin::new(\n-        *root,\n+        root,\n         \"server-only\".into(),\n         vec![\n             \"'server-only' cannot be imported from a Client Component module. It should only be \\\n@@ -188,10 +184,10 @@ pub(crate) fn get_invalid_server_only_resolve_plugin(\n \n /// Returns a resolve plugin if context have imports to `styled-jsx`.\n pub(crate) fn get_invalid_styled_jsx_resolve_plugin(\n-    root: ResolvedVc<FileSystemPath>,\n+    root: FileSystemPath,\n ) -> Vc<InvalidImportResolvePlugin> {\n     InvalidImportResolvePlugin::new(\n-        *root,\n+        root,\n         \"styled-jsx\".into(),\n         vec![\n             \"'client-only' cannot be imported from a Server Component module. It should only be \\\n@@ -207,36 +203,36 @@ pub(crate) fn get_invalid_styled_jsx_resolve_plugin(\n \n #[turbo_tasks::value]\n pub(crate) struct NextExternalResolvePlugin {\n-    project_path: ResolvedVc<FileSystemPath>,\n+    project_path: FileSystemPath,\n }\n \n #[turbo_tasks::value_impl]\n impl NextExternalResolvePlugin {\n     #[turbo_tasks::function]\n-    pub fn new(project_path: ResolvedVc<FileSystemPath>) -> Vc<Self> {\n+    pub fn new(project_path: FileSystemPath) -> Vc<Self> {\n         NextExternalResolvePlugin { project_path }.cell()\n     }\n }\n \n #[turbo_tasks::value_impl]\n impl AfterResolvePlugin for NextExternalResolvePlugin {\n     #[turbo_tasks::function]\n-    fn after_resolve_condition(&self) -> Vc<AfterResolvePluginCondition> {\n-        AfterResolvePluginCondition::new(\n-            self.project_path.root(),\n+    async fn after_resolve_condition(&self) -> Result<Vc<AfterResolvePluginCondition>> {\n+        Ok(AfterResolvePluginCondition::new(\n+            self.project_path.root().await?.clone_value(),\n             Glob::new(\"**/next/dist/**/*.{external,runtime.dev,runtime.prod}.js\".into()),\n-        )\n+        ))\n     }\n \n     #[turbo_tasks::function]\n     async fn after_resolve(\n         &self,\n-        fs_path: Vc<FileSystemPath>,\n-        _lookup_path: Vc<FileSystemPath>,\n+        fs_path: FileSystemPath,\n+        _lookup_path: FileSystemPath,\n         _reference_type: ReferenceType,\n         _request: Vc<Request>,\n     ) -> Result<Vc<ResolveResultOption>> {\n-        let path = fs_path.await?.path.to_string();\n+        let path = fs_path.path.to_string();\n         // Find the starting index of 'next/dist' and slice from that point. It should\n         // always be found since the glob pattern above is specific enough.\n         let starting_index = path.find(\"next/dist\").unwrap();\n@@ -256,17 +252,14 @@ impl AfterResolvePlugin for NextExternalResolvePlugin {\n \n #[turbo_tasks::value]\n pub(crate) struct NextNodeSharedRuntimeResolvePlugin {\n-    root: ResolvedVc<FileSystemPath>,\n+    root: FileSystemPath,\n     server_context_type: ServerContextType,\n }\n \n #[turbo_tasks::value_impl]\n impl NextNodeSharedRuntimeResolvePlugin {\n     #[turbo_tasks::function]\n-    pub fn new(\n-        root: ResolvedVc<FileSystemPath>,\n-        server_context_type: ServerContextType,\n-    ) -> Vc<Self> {\n+    pub fn new(root: FileSystemPath, server_context_type: ServerContextType) -> Vc<Self> {\n         NextNodeSharedRuntimeResolvePlugin {\n             root,\n             server_context_type,\n@@ -278,23 +271,23 @@ impl NextNodeSharedRuntimeResolvePlugin {\n #[turbo_tasks::value_impl]\n impl AfterResolvePlugin for NextNodeSharedRuntimeResolvePlugin {\n     #[turbo_tasks::function]\n-    fn after_resolve_condition(&self) -> Vc<AfterResolvePluginCondition> {\n-        AfterResolvePluginCondition::new(\n-            self.root.root(),\n+    async fn after_resolve_condition(&self) -> Result<Vc<AfterResolvePluginCondition>> {\n+        Ok(AfterResolvePluginCondition::new(\n+            self.root.root().await?.clone_value(),\n             Glob::new(\"**/next/dist/**/*.shared-runtime.js\".into()),\n-        )\n+        ))\n     }\n \n     #[turbo_tasks::function]\n     async fn after_resolve(\n         &self,\n-        fs_path: Vc<FileSystemPath>,\n-        _lookup_path: Vc<FileSystemPath>,\n+        fs_path: FileSystemPath,\n+        _lookup_path: FileSystemPath,\n         _reference_type: ReferenceType,\n         _request: Vc<Request>,\n     ) -> Result<Vc<ResolveResultOption>> {\n-        let stem = fs_path.file_stem().await?;\n-        let stem = stem.as_deref().unwrap_or_default();\n+        let stem = fs_path.file_stem();\n+        let stem = stem.unwrap_or_default();\n         let stem = stem.replace(\".shared-runtime\", \"\");\n \n         let resource_request = format!(\n@@ -308,7 +301,7 @@ impl AfterResolvePlugin for NextNodeSharedRuntimeResolvePlugin {\n             stem\n         );\n \n-        let raw_fs_path = &*fs_path.await?;\n+        let raw_fs_path = fs_path.clone();\n         let path = raw_fs_path.path.to_string();\n \n         // Find the starting index of 'next/dist' and slice from that point. It should\n@@ -319,7 +312,8 @@ impl AfterResolvePlugin for NextNodeSharedRuntimeResolvePlugin {\n \n         let new_path = fs_path\n             .root()\n-            .join(format!(\"{base}/{resource_request}\").into());\n+            .await?\n+            .join(&format!(\"{base}/{resource_request}\"))?;\n \n         Ok(Vc::cell(Some(ResolveResult::source(ResolvedVc::upcast(\n             FileSource::new(new_path).to_resolved().await?,\n@@ -331,13 +325,13 @@ impl AfterResolvePlugin for NextNodeSharedRuntimeResolvePlugin {\n /// telemetry events if there is a match.\n #[turbo_tasks::value]\n pub(crate) struct ModuleFeatureReportResolvePlugin {\n-    root: ResolvedVc<FileSystemPath>,\n+    root: FileSystemPath,\n }\n \n #[turbo_tasks::value_impl]\n impl ModuleFeatureReportResolvePlugin {\n     #[turbo_tasks::function]\n-    pub fn new(root: ResolvedVc<FileSystemPath>) -> Vc<Self> {\n+    pub fn new(root: FileSystemPath) -> Vc<Self> {\n         ModuleFeatureReportResolvePlugin { root }.cell()\n     }\n }\n@@ -357,7 +351,7 @@ impl BeforeResolvePlugin for ModuleFeatureReportResolvePlugin {\n     #[turbo_tasks::function]\n     async fn before_resolve(\n         &self,\n-        _lookup_path: Vc<FileSystemPath>,\n+        _lookup_path: FileSystemPath,\n         _reference_type: ReferenceType,\n         request: Vc<Request>,\n     ) -> Result<Vc<ResolveResultOption>> {\n@@ -388,38 +382,38 @@ impl BeforeResolvePlugin for ModuleFeatureReportResolvePlugin {\n \n #[turbo_tasks::value]\n pub(crate) struct NextSharedRuntimeResolvePlugin {\n-    root: ResolvedVc<FileSystemPath>,\n+    root: FileSystemPath,\n }\n \n #[turbo_tasks::value_impl]\n impl NextSharedRuntimeResolvePlugin {\n     #[turbo_tasks::function]\n-    pub fn new(root: ResolvedVc<FileSystemPath>) -> Vc<Self> {\n+    pub fn new(root: FileSystemPath) -> Vc<Self> {\n         NextSharedRuntimeResolvePlugin { root }.cell()\n     }\n }\n \n #[turbo_tasks::value_impl]\n impl AfterResolvePlugin for NextSharedRuntimeResolvePlugin {\n     #[turbo_tasks::function]\n-    fn after_resolve_condition(&self) -> Vc<AfterResolvePluginCondition> {\n-        AfterResolvePluginCondition::new(\n-            self.root.root(),\n+    async fn after_resolve_condition(&self) -> Result<Vc<AfterResolvePluginCondition>> {\n+        Ok(AfterResolvePluginCondition::new(\n+            self.root.root().await?.clone_value(),\n             Glob::new(\"**/next/dist/esm/**/*.shared-runtime.js\".into()),\n-        )\n+        ))\n     }\n \n     #[turbo_tasks::function]\n     async fn after_resolve(\n         &self,\n-        fs_path: Vc<FileSystemPath>,\n-        _lookup_path: Vc<FileSystemPath>,\n+        fs_path: FileSystemPath,\n+        _lookup_path: FileSystemPath,\n         _reference_type: ReferenceType,\n         _request: Vc<Request>,\n     ) -> Result<Vc<ResolveResultOption>> {\n-        let raw_fs_path = &*fs_path.await?;\n+        let raw_fs_path = fs_path.clone();\n         let modified_path = raw_fs_path.path.replace(\"next/dist/esm/\", \"next/dist/\");\n-        let new_path = fs_path.root().join(modified_path.into());\n+        let new_path = fs_path.root().await?.join(&modified_path)?;\n         Ok(Vc::cell(Some(ResolveResult::source(ResolvedVc::upcast(\n             FileSource::new(new_path).to_resolved().await?,\n         )))))"
        },
        {
            "sha": "4491f6aa86b15ffae9ca08fd0a99f1ca9c49f0f0",
            "filename": "crates/next-core/src/next_shared/transforms/mod.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Ftransforms%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Ftransforms%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Ftransforms%2Fmod.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -33,7 +33,7 @@ pub use next_lint::get_next_lint_transform_rule;\n pub use next_strip_page_exports::get_next_pages_transforms_rule;\n pub use next_track_dynamic_imports::get_next_track_dynamic_imports_transform_rule;\n pub use server_actions::get_server_actions_transform_rule;\n-use turbo_tasks::{ReadRef, ResolvedVc};\n+use turbo_tasks::ResolvedVc;\n use turbo_tasks_fs::FileSystemPath;\n use turbopack::module_options::{ModuleRule, ModuleRuleEffect, ModuleType, RuleCondition};\n use turbopack_core::reference_type::{ReferenceType, UrlReferenceSubType};\n@@ -121,7 +121,7 @@ pub(crate) fn module_rule_match_js_no_url(enable_mdx_rs: bool) -> RuleCondition\n \n pub(crate) fn module_rule_match_pages_page_file(\n     enable_mdx_rs: bool,\n-    pages_directory: ReadRef<FileSystemPath>,\n+    pages_directory: FileSystemPath,\n ) -> RuleCondition {\n     let conditions = match_js_extension(enable_mdx_rs);\n "
        },
        {
            "sha": "855ae62c15061f7620a073195fa45f9a6b028b7e",
            "filename": "crates/next-core/src/next_shared/transforms/next_disallow_re_export_all_in_page.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Ftransforms%2Fnext_disallow_re_export_all_in_page.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Ftransforms%2Fnext_disallow_re_export_all_in_page.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Ftransforms%2Fnext_disallow_re_export_all_in_page.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -2,7 +2,7 @@ use anyhow::Result;\n use async_trait::async_trait;\n use next_custom_transforms::transforms::disallow_re_export_all_in_page::disallow_re_export_all_in_page;\n use swc_core::ecma::ast::*;\n-use turbo_tasks::{ReadRef, ResolvedVc};\n+use turbo_tasks::ResolvedVc;\n use turbo_tasks_fs::FileSystemPath;\n use turbopack::module_options::{ModuleRule, ModuleRuleEffect};\n use turbopack_ecmascript::{CustomTransformer, EcmascriptInputTransform, TransformContext};\n@@ -11,7 +11,7 @@ use super::module_rule_match_pages_page_file;\n \n pub fn get_next_disallow_export_all_in_page_rule(\n     enable_mdx_rs: bool,\n-    pages_dir: ReadRef<FileSystemPath>,\n+    pages_dir: FileSystemPath,\n ) -> ModuleRule {\n     let transformer = EcmascriptInputTransform::Plugin(ResolvedVc::cell(Box::new(\n         NextDisallowReExportAllInPage,"
        },
        {
            "sha": "c95fe13a92685420b14599ea9b6848bf4d294a58",
            "filename": "crates/next-core/src/next_shared/transforms/next_page_config.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 5,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Ftransforms%2Fnext_page_config.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Ftransforms%2Fnext_page_config.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Ftransforms%2Fnext_page_config.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -2,17 +2,14 @@ use anyhow::Result;\n use async_trait::async_trait;\n use next_custom_transforms::transforms::page_config::page_config;\n use swc_core::ecma::ast::*;\n-use turbo_tasks::{ReadRef, ResolvedVc};\n+use turbo_tasks::ResolvedVc;\n use turbo_tasks_fs::FileSystemPath;\n use turbopack::module_options::{ModuleRule, ModuleRuleEffect};\n use turbopack_ecmascript::{CustomTransformer, EcmascriptInputTransform, TransformContext};\n \n use super::module_rule_match_pages_page_file;\n \n-pub fn get_next_page_config_rule(\n-    enable_mdx_rs: bool,\n-    pages_dir: ReadRef<FileSystemPath>,\n-) -> ModuleRule {\n+pub fn get_next_page_config_rule(enable_mdx_rs: bool, pages_dir: FileSystemPath) -> ModuleRule {\n     let transformer = EcmascriptInputTransform::Plugin(ResolvedVc::cell(Box::new(NextPageConfig {\n         // [TODO]: update once turbopack build works\n         is_development: true,"
        },
        {
            "sha": "3240b6f1c7c83a2457aec2cf950e552df92c8b85",
            "filename": "crates/next-core/src/next_shared/transforms/next_page_static_info.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Ftransforms%2Fnext_page_static_info.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Ftransforms%2Fnext_page_static_info.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Ftransforms%2Fnext_page_static_info.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -82,7 +82,7 @@ impl CustomTransformer for NextPageStaticInfo {\n             if is_server_layer_page {\n                 for warning in collected_exports.warnings.iter() {\n                     PageStaticInfoIssue {\n-                        file_path: ctx.file_path,\n+                        file_path: ctx.file_path.clone(),\n                         messages: vec![\n                             format!(\n                                 \"Next.js can't recognize the exported `{}` field in \\\"{}\\\" as {}.\",\n@@ -117,7 +117,7 @@ impl CustomTransformer for NextPageStaticInfo {\n                 messages.push(\"Visit https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config for more information.\".to_string());\n \n                 PageStaticInfoIssue {\n-                    file_path: ctx.file_path,\n+                    file_path: ctx.file_path.clone(),\n                     messages,\n                     severity: IssueSeverity::Warning,\n                 }\n@@ -130,7 +130,7 @@ impl CustomTransformer for NextPageStaticInfo {\n                 && is_app_page\n             {\n                 PageStaticInfoIssue {\n-                    file_path: ctx.file_path,\n+                    file_path: ctx.file_path.clone(),\n                     messages: vec![format!(r#\"Page \"{}\" cannot use both \"use client\" and export function \"generateStaticParams()\".\"#, ctx.file_path_str)],\n                     severity: IssueSeverity::Error,\n                 }\n@@ -145,7 +145,7 @@ impl CustomTransformer for NextPageStaticInfo {\n \n #[turbo_tasks::value(shared)]\n pub struct PageStaticInfoIssue {\n-    pub file_path: ResolvedVc<FileSystemPath>,\n+    pub file_path: FileSystemPath,\n     pub messages: Vec<String>,\n     pub severity: IssueSeverity,\n }\n@@ -168,7 +168,7 @@ impl Issue for PageStaticInfoIssue {\n \n     #[turbo_tasks::function]\n     fn file_path(&self) -> Vc<FileSystemPath> {\n-        *self.file_path\n+        self.file_path.clone().cell()\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "c92eb460bcc9a62c039dbdfce4bc3ccb1ad2c6c2",
            "filename": "crates/next-core/src/next_shared/transforms/next_react_server_components.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 8,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Ftransforms%2Fnext_react_server_components.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Ftransforms%2Fnext_react_server_components.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Ftransforms%2Fnext_react_server_components.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -5,7 +5,7 @@ use swc_core::{\n     common::FileName,\n     ecma::{ast::Program, visit::VisitWith},\n };\n-use turbo_tasks::{ResolvedVc, Vc};\n+use turbo_tasks::Vc;\n use turbo_tasks_fs::FileSystemPath;\n use turbopack::module_options::ModuleRule;\n use turbopack_ecmascript::{CustomTransformer, TransformContext};\n@@ -31,7 +31,7 @@ use crate::next_config::NextConfig;\n pub async fn get_next_react_server_components_transform_rule(\n     next_config: Vc<NextConfig>,\n     is_react_server_layer: bool,\n-    app_dir: Option<ResolvedVc<FileSystemPath>>,\n+    app_dir: Option<FileSystemPath>,\n ) -> Result<ModuleRule> {\n     let enable_mdx_rs = next_config.mdx_rs().await?.is_some();\n     let dynamic_io_enabled = *next_config.enable_dynamic_io().await?;\n@@ -53,15 +53,15 @@ struct NextJsReactServerComponents {\n     is_react_server_layer: bool,\n     dynamic_io_enabled: bool,\n     use_cache_enabled: bool,\n-    app_dir: Option<ResolvedVc<FileSystemPath>>,\n+    app_dir: Option<FileSystemPath>,\n }\n \n impl NextJsReactServerComponents {\n     fn new(\n         is_react_server_layer: bool,\n         dynamic_io_enabled: bool,\n         use_cache_enabled: bool,\n-        app_dir: Option<ResolvedVc<FileSystemPath>>,\n+        app_dir: Option<FileSystemPath>,\n     ) -> Self {\n         Self {\n             is_react_server_layer,\n@@ -89,10 +89,7 @@ impl CustomTransformer for NextJsReactServerComponents {\n                 dynamic_io_enabled: self.dynamic_io_enabled,\n                 use_cache_enabled: self.use_cache_enabled,\n             }),\n-            match self.app_dir {\n-                None => None,\n-                Some(path) => Some(path.await?.path.clone().into()),\n-            },\n+            self.app_dir.as_ref().map(|path| path.path.clone().into()),\n         );\n \n         program.visit_with(&mut visitor);"
        },
        {
            "sha": "a7df0711325b32425b49c6f0508a68fcfd7dc6fb",
            "filename": "crates/next-core/src/next_shared/transforms/next_strip_page_exports.rs",
            "status": "modified",
            "additions": 8,
            "deletions": 12,
            "changes": 20,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Ftransforms%2Fnext_strip_page_exports.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Ftransforms%2Fnext_strip_page_exports.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Ftransforms%2Fnext_strip_page_exports.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -4,7 +4,7 @@ use next_custom_transforms::transforms::strip_page_exports::{\n     ExportFilter, next_transform_strip_page_exports,\n };\n use swc_core::ecma::ast::Program;\n-use turbo_tasks::{ResolvedVc, Vc};\n+use turbo_tasks::ResolvedVc;\n use turbo_tasks_fs::FileSystemPath;\n use turbopack::module_options::{ModuleRule, ModuleRuleEffect, RuleCondition};\n use turbopack_ecmascript::{CustomTransformer, EcmascriptInputTransform, TransformContext};\n@@ -13,7 +13,7 @@ use super::module_rule_match_js_no_url;\n \n /// Returns a rule which applies the Next.js page export stripping transform.\n pub async fn get_next_pages_transforms_rule(\n-    pages_dir: Vc<FileSystemPath>,\n+    pages_dir: FileSystemPath,\n     export_filter: ExportFilter,\n     enable_mdx_rs: bool,\n ) -> Result<ModuleRule> {\n@@ -25,20 +25,16 @@ pub async fn get_next_pages_transforms_rule(\n     Ok(ModuleRule::new(\n         RuleCondition::all(vec![\n             RuleCondition::all(vec![\n-                RuleCondition::ResourcePathInExactDirectory(pages_dir.await?),\n+                RuleCondition::ResourcePathInExactDirectory(pages_dir.clone()),\n                 RuleCondition::not(RuleCondition::ResourcePathInExactDirectory(\n-                    pages_dir.join(\"api\".into()).await?,\n+                    pages_dir.join(\"api\")?,\n                 )),\n                 RuleCondition::not(RuleCondition::any(vec![\n                     // TODO(alexkirsz): Possibly ignore _app as well?\n-                    RuleCondition::ResourcePathEquals(pages_dir.join(\"_document.js\".into()).await?),\n-                    RuleCondition::ResourcePathEquals(\n-                        pages_dir.join(\"_document.jsx\".into()).await?,\n-                    ),\n-                    RuleCondition::ResourcePathEquals(pages_dir.join(\"_document.ts\".into()).await?),\n-                    RuleCondition::ResourcePathEquals(\n-                        pages_dir.join(\"_document.tsx\".into()).await?,\n-                    ),\n+                    RuleCondition::ResourcePathEquals(pages_dir.join(\"_document.js\")?),\n+                    RuleCondition::ResourcePathEquals(pages_dir.join(\"_document.jsx\")?),\n+                    RuleCondition::ResourcePathEquals(pages_dir.join(\"_document.ts\")?),\n+                    RuleCondition::ResourcePathEquals(pages_dir.join(\"_document.tsx\")?),\n                 ])),\n             ]),\n             module_rule_match_js_no_url(enable_mdx_rs),"
        },
        {
            "sha": "6e2d9b27bb7deab8f4bf4d3246c8ab36787d9784",
            "filename": "crates/next-core/src/next_shared/transforms/relay.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 4,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Ftransforms%2Frelay.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Ftransforms%2Frelay.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Ftransforms%2Frelay.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -1,5 +1,5 @@\n use anyhow::Result;\n-use turbo_tasks::{ResolvedVc, Vc};\n+use turbo_tasks::Vc;\n use turbo_tasks_fs::FileSystemPath;\n use turbopack::module_options::ModuleRule;\n use turbopack_ecmascript_plugins::transform::relay::RelayTransformer;\n@@ -10,13 +10,12 @@ use crate::next_config::NextConfig;\n /// Returns a transform rule for the relay graphql transform.\n pub async fn get_relay_transform_rule(\n     next_config: Vc<NextConfig>,\n-    project_path: ResolvedVc<FileSystemPath>,\n+    project_path: FileSystemPath,\n ) -> Result<Option<ModuleRule>> {\n     let enable_mdx_rs = next_config.mdx_rs().await?.is_some();\n-    let project_path = &*project_path.await?;\n     let module_rule = next_config.compiler().await?.relay.as_ref().map(|config| {\n         get_ecma_transform_rule(\n-            Box::new(RelayTransformer::new(config, project_path)),\n+            Box::new(RelayTransformer::new(config, &project_path)),\n             enable_mdx_rs,\n             true,\n         )"
        },
        {
            "sha": "043bd0dbe2e8d9823c63590e1f6bf8cb66ac3fbb",
            "filename": "crates/next-core/src/next_shared/transforms/swc_ecma_transform_plugins.rs",
            "status": "modified",
            "additions": 52,
            "deletions": 47,
            "changes": 99,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Ftransforms%2Fswc_ecma_transform_plugins.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Ftransforms%2Fswc_ecma_transform_plugins.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Ftransforms%2Fswc_ecma_transform_plugins.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -1,15 +1,15 @@\n use anyhow::Result;\n #[allow(unused_imports)]\n use turbo_rcstr::RcStr;\n-use turbo_tasks::{ResolvedVc, Vc};\n+use turbo_tasks::Vc;\n use turbo_tasks_fs::FileSystemPath;\n use turbopack::module_options::ModuleRule;\n \n use crate::next_config::NextConfig;\n \n pub async fn get_swc_ecma_transform_plugin_rule(\n     next_config: Vc<NextConfig>,\n-    project_path: ResolvedVc<FileSystemPath>,\n+    project_path: FileSystemPath,\n ) -> Result<Option<ModuleRule>> {\n     let plugin_configs = next_config.experimental_swc_plugins().await?;\n     if !plugin_configs.is_empty() {\n@@ -31,7 +31,7 @@ pub async fn get_swc_ecma_transform_plugin_rule(\n \n #[cfg(feature = \"plugin\")]\n pub async fn get_swc_ecma_transform_rule_impl(\n-    project_path: ResolvedVc<FileSystemPath>,\n+    project_path: FileSystemPath,\n     plugin_configs: &[(RcStr, serde_json::Value)],\n     enable_mdx_rs: bool,\n ) -> Result<Option<ModuleRule>> {\n@@ -52,58 +52,63 @@ pub async fn get_swc_ecma_transform_rule_impl(\n \n     let plugins = plugin_configs\n         .iter()\n-        .map(|(name, config)| async move {\n-            // [TODO]: SWC's current experimental config supports\n-            // two forms of plugin path,\n-            // one for implicit package name resolves to node_modules,\n-            // and one for explicit path to a .wasm binary.\n-            // Current resolve will fail with latter.\n-            let request = Request::parse_string(name.clone());\n-            let resolve_options = resolve_options(\n-                *project_path,\n-                ResolveOptionsContext {\n-                    enable_node_modules: Some(project_path.root().to_resolved().await?),\n-                    enable_node_native_modules: true,\n-                    ..Default::default()\n-                }\n-                .cell(),\n-            );\n+        .map(|(name, config)| {\n+            let project_path = project_path.clone();\n \n-            let plugin_wasm_module_resolve_result = handle_resolve_error(\n-                resolve(\n-                    *project_path,\n+            async move {\n+                // [TODO]: SWC's current experimental config supports\n+                // two forms of plugin path,\n+                // one for implicit package name resolves to node_modules,\n+                // and one for explicit path to a .wasm binary.\n+                // Current resolve will fail with latter.\n+                let request = Request::parse_string(name.clone());\n+                let resolve_options = resolve_options(\n+                    project_path.clone(),\n+                    ResolveOptionsContext {\n+                        enable_node_modules: Some(project_path.root().await?.clone_value()),\n+                        enable_node_native_modules: true,\n+                        ..Default::default()\n+                    }\n+                    .cell(),\n+                );\n+\n+                let plugin_wasm_module_resolve_result = handle_resolve_error(\n+                    resolve(\n+                        project_path.clone(),\n+                        ReferenceType::CommonJs(CommonJsReferenceSubType::Undefined),\n+                        request,\n+                        resolve_options,\n+                    )\n+                    .as_raw_module_result(),\n                     ReferenceType::CommonJs(CommonJsReferenceSubType::Undefined),\n+                    // TODO proper error location\n+                    project_path.clone(),\n                     request,\n                     resolve_options,\n+                    false,\n+                    // TODO proper error location\n+                    None,\n                 )\n-                .as_raw_module_result(),\n-                ReferenceType::CommonJs(CommonJsReferenceSubType::Undefined),\n-                // TODO proper error location\n-                *project_path,\n-                request,\n-                resolve_options,\n-                false,\n-                // TODO proper error location\n-                None,\n-            )\n-            .await?;\n+                .await?;\n \n-            let Some(plugin_module) = &*plugin_wasm_module_resolve_result.first_module().await?\n-            else {\n-                // Ignore unresolveable plugin modules, handle_resolve_error has already emitted an\n-                // issue.\n-                return Ok(None);\n-            };\n+                let Some(plugin_module) =\n+                    &*plugin_wasm_module_resolve_result.first_module().await?\n+                else {\n+                    // Ignore unresolveable plugin modules, handle_resolve_error has already emitted\n+                    // an issue.\n+                    return Ok(None);\n+                };\n \n-            let content = &*plugin_module.content().file_content().await?;\n-            let FileContent::Content(file) = content else {\n-                bail!(\"Expected file content for plugin module\");\n-            };\n+                let content = &*plugin_module.content().file_content().await?;\n+                let FileContent::Content(file) = content else {\n+                    bail!(\"Expected file content for plugin module\");\n+                };\n \n-            Ok(Some((\n-                SwcPluginModule::new(name, file.content().to_bytes().to_vec()).resolved_cell(),\n-                config.clone(),\n-            )))\n+                Ok(Some((\n+                    SwcPluginModule::new(name, file.content().to_bytes().to_vec()).resolved_cell(),\n+                    config.clone(),\n+                )))\n+            }\n         })\n         .try_flat_join()\n         .await?;"
        },
        {
            "sha": "d15acfc773fd7de660c708756da5c1a497d67659",
            "filename": "crates/next-core/src/next_shared/webpack_rules/babel.rs",
            "status": "modified",
            "additions": 8,
            "deletions": 8,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fwebpack_rules%2Fbabel.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fwebpack_rules%2Fbabel.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fwebpack_rules%2Fbabel.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -27,13 +27,13 @@ const BABEL_CONFIG_FILES: &[&str] = &[\n /// webpack loader for each eligible file type if it doesn't already exist.\n #[turbo_tasks::function]\n pub async fn maybe_add_babel_loader(\n-    project_root: Vc<FileSystemPath>,\n+    project_root: FileSystemPath,\n     webpack_rules: Option<ResolvedVc<WebpackRules>>,\n ) -> Result<Vc<OptionWebpackRules>> {\n     let has_babel_config = {\n         let mut has_babel_config = false;\n         for &filename in BABEL_CONFIG_FILES {\n-            let filetype = *project_root.join(filename.into()).get_type().await?;\n+            let filetype = *project_root.join(filename)?.get_type().await?;\n             if matches!(filetype, FileSystemEntryType::File) {\n                 has_babel_config = true;\n                 break;\n@@ -63,10 +63,10 @@ pub async fn maybe_add_babel_loader(\n \n             if !has_babel_loader {\n                 if !has_emitted_babel_resolve_issue\n-                    && !*is_babel_loader_available(project_root).await?\n+                    && !*is_babel_loader_available(project_root.clone()).await?\n                 {\n                     BabelIssue {\n-                        path: project_root.to_resolved().await?,\n+                        path: project_root.clone(),\n                         title: StyledString::Text(rcstr!(\n                             \"Unable to resolve babel-loader, but a babel config is present\"\n                         ))\n@@ -112,9 +112,9 @@ pub async fn maybe_add_babel_loader(\n }\n \n #[turbo_tasks::function]\n-pub async fn is_babel_loader_available(project_path: Vc<FileSystemPath>) -> Result<Vc<bool>> {\n+pub async fn is_babel_loader_available(project_path: FileSystemPath) -> Result<Vc<bool>> {\n     let result = resolve(\n-        project_path,\n+        project_path.clone(),\n         ReferenceType::CommonJs(CommonJsReferenceSubType::Undefined),\n         Request::parse(Pattern::Constant(\"babel-loader/package.json\".into())),\n         node_cjs_resolve_options(project_path),\n@@ -125,7 +125,7 @@ pub async fn is_babel_loader_available(project_path: Vc<FileSystemPath>) -> Resu\n \n #[turbo_tasks::value]\n struct BabelIssue {\n-    path: ResolvedVc<FileSystemPath>,\n+    path: FileSystemPath,\n     title: ResolvedVc<StyledString>,\n     description: ResolvedVc<StyledString>,\n     severity: IssueSeverity,\n@@ -144,7 +144,7 @@ impl Issue for BabelIssue {\n \n     #[turbo_tasks::function]\n     fn file_path(&self) -> Vc<FileSystemPath> {\n-        *self.path\n+        self.path.clone().cell()\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "2d7fa95479e7c48add9df8f63f105cce52d2becf",
            "filename": "crates/next-core/src/next_shared/webpack_rules/mod.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fwebpack_rules%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fwebpack_rules%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fwebpack_rules%2Fmod.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -12,7 +12,7 @@ pub(crate) mod babel;\n pub(crate) mod sass;\n \n pub async fn webpack_loader_options(\n-    project_path: ResolvedVc<FileSystemPath>,\n+    project_path: FileSystemPath,\n     next_config: Vc<NextConfig>,\n     foreign: bool,\n     condition_strs: Vec<RcStr>,\n@@ -22,7 +22,7 @@ pub async fn webpack_loader_options(\n     let rules = if foreign {\n         rules\n     } else {\n-        *maybe_add_babel_loader(*project_path, rules.map(|v| *v)).await?\n+        *maybe_add_babel_loader(project_path.clone(), rules.map(|v| *v)).await?\n     };\n \n     let conditions = next_config.webpack_conditions().to_resolved().await?;"
        },
        {
            "sha": "f26a8b7490ae85c2c3db0fa15d1b9739d252bde9",
            "filename": "crates/next-core/src/page_loader.rs",
            "status": "modified",
            "additions": 30,
            "deletions": 19,
            "changes": 49,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fpage_loader.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fpage_loader.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fpage_loader.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -30,7 +30,9 @@ pub async fn create_page_loader_entry_module(\n     let mut result = RopeBuilder::default();\n     writeln!(result, \"const PAGE_PATH = {};\\n\", StringifyJs(&pathname))?;\n \n-    let page_loader_path = next_js_file_path(rcstr!(\"entry/page-loader.ts\"));\n+    let page_loader_path = next_js_file_path(rcstr!(\"entry/page-loader.ts\"))\n+        .await?\n+        .clone_value();\n     let base_code = page_loader_path.read();\n     if let FileContent::Content(base_file) = &*base_code.await? {\n         result += base_file.content()\n@@ -67,7 +69,7 @@ pub async fn create_page_loader_entry_module(\n \n #[turbo_tasks::value(shared)]\n pub struct PageLoaderAsset {\n-    pub server_root: ResolvedVc<FileSystemPath>,\n+    pub server_root: FileSystemPath,\n     pub pathname: RcStr,\n     pub rebase_prefix_path: ResolvedVc<FileSystemPathOption>,\n     pub page_chunks: ResolvedVc<OutputAssets>,\n@@ -77,7 +79,7 @@ pub struct PageLoaderAsset {\n impl PageLoaderAsset {\n     #[turbo_tasks::function]\n     pub fn new(\n-        server_root: ResolvedVc<FileSystemPath>,\n+        server_root: FileSystemPath,\n         pathname: RcStr,\n         rebase_prefix_path: ResolvedVc<FileSystemPathOption>,\n         page_chunks: ResolvedVc<OutputAssets>,\n@@ -101,41 +103,50 @@ impl PageLoaderAsset {\n         // If we are provided a prefix path, we need to rewrite our chunk paths to\n         // remove that prefix.\n         if let Some(rebase_path) = &*rebase_prefix_path.await? {\n-            let root_path = rebase_path.root();\n+            let root_path = rebase_path.root().await?.clone_value();\n             let rebased = chunks\n                 .await?\n                 .iter()\n                 .map(|&chunk| {\n-                    Vc::upcast::<Box<dyn OutputAsset>>(ProxiedAsset::new(\n-                        *chunk,\n-                        FileSystemPath::rebase(chunk.path(), **rebase_path, root_path),\n-                    ))\n-                    .to_resolved()\n+                    let root_path = root_path.clone();\n+\n+                    async move {\n+                        Vc::upcast::<Box<dyn OutputAsset>>(ProxiedAsset::new(\n+                            *chunk,\n+                            FileSystemPath::rebase(\n+                                chunk.path().await?.clone_value(),\n+                                rebase_path.clone(),\n+                                root_path.clone(),\n+                            )\n+                            .await?\n+                            .clone_value(),\n+                        ))\n+                        .to_resolved()\n+                        .await\n+                    }\n                 })\n                 .try_join()\n                 .await?;\n             chunks = ResolvedVc::cell(rebased);\n         };\n \n-        Ok(ChunkData::from_assets(*self.server_root, *chunks))\n+        Ok(ChunkData::from_assets(self.server_root.clone(), *chunks))\n     }\n }\n \n #[turbo_tasks::value_impl]\n impl OutputAsset for PageLoaderAsset {\n     #[turbo_tasks::function]\n     async fn path(&self) -> Result<Vc<FileSystemPath>> {\n-        let root = self\n-            .rebase_prefix_path\n-            .await?\n-            .map_or(*self.server_root, |path| *path);\n-        Ok(root.join(\n-            format!(\n+        let root = (*self.rebase_prefix_path.await?)\n+            .clone()\n+            .map_or(self.server_root.clone(), |path| path);\n+        Ok(root\n+            .join(&format!(\n                 \"static/chunks/pages{}\",\n                 get_asset_path_from_pathname(&self.pathname, \".js\")\n-            )\n-            .into(),\n-        ))\n+            ))?\n+            .cell())\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "d471ca94e3a20bfbec79059aade51667c1319e00",
            "filename": "crates/next-core/src/pages_structure.rs",
            "status": "modified",
            "additions": 87,
            "deletions": 75,
            "changes": 162,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fpages_structure.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Fpages_structure.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fpages_structure.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -1,7 +1,7 @@\n use anyhow::Result;\n use tracing::Instrument;\n use turbo_rcstr::RcStr;\n-use turbo_tasks::{OptionVcExt, ResolvedVc, TryJoinIterExt, ValueToString, Vc};\n+use turbo_tasks::{OptionVcExt, ResolvedVc, TryJoinIterExt, Vc};\n use turbo_tasks_fs::{\n     DirectoryContent, DirectoryEntry, FileSystemEntryType, FileSystemPath, FileSystemPathOption,\n };\n@@ -11,28 +11,28 @@ use crate::next_import_map::get_next_package;\n /// A final route in the pages directory.\n #[turbo_tasks::value]\n pub struct PagesStructureItem {\n-    pub base_path: ResolvedVc<FileSystemPath>,\n+    pub base_path: FileSystemPath,\n     pub extensions: ResolvedVc<Vec<RcStr>>,\n-    pub fallback_path: Option<ResolvedVc<FileSystemPath>>,\n+    pub fallback_path: Option<FileSystemPath>,\n \n     /// Pathname of this item in the Next.js router.\n-    pub next_router_path: ResolvedVc<FileSystemPath>,\n+    pub next_router_path: FileSystemPath,\n     /// Unique path corresponding to this item. This differs from\n     /// `next_router_path` in that it will include the trailing /index for index\n     /// routes, which allows for differentiating with potential /index\n     /// directories.\n-    pub original_path: ResolvedVc<FileSystemPath>,\n+    pub original_path: FileSystemPath,\n }\n \n #[turbo_tasks::value_impl]\n impl PagesStructureItem {\n     #[turbo_tasks::function]\n     fn new(\n-        base_path: ResolvedVc<FileSystemPath>,\n+        base_path: FileSystemPath,\n         extensions: ResolvedVc<Vec<RcStr>>,\n-        fallback_path: Option<ResolvedVc<FileSystemPath>>,\n-        next_router_path: ResolvedVc<FileSystemPath>,\n-        original_path: ResolvedVc<FileSystemPath>,\n+        fallback_path: Option<FileSystemPath>,\n+        next_router_path: FileSystemPath,\n+        original_path: FileSystemPath,\n     ) -> Vc<Self> {\n         PagesStructureItem {\n             base_path,\n@@ -49,19 +49,19 @@ impl PagesStructureItem {\n         // Check if the file path + extension exists in the filesystem, if so use that. If not fall\n         // back to the base path.\n         for ext in self.extensions.await?.into_iter() {\n-            let file_path: Vc<FileSystemPath> = self.base_path.append(format!(\".{ext}\").into());\n+            let file_path = self.base_path.append(&format!(\".{ext}\"))?;\n             let ty = *file_path.get_type().await?;\n             if matches!(ty, FileSystemEntryType::File | FileSystemEntryType::Symlink) {\n-                return Ok(file_path);\n+                return Ok(file_path.cell());\n             }\n         }\n-        if let Some(fallback_path) = self.fallback_path {\n-            Ok(*fallback_path)\n+        if let Some(fallback_path) = &self.fallback_path {\n+            Ok(fallback_path.clone().cell())\n         } else {\n             // If the file path that was passed in already has an extension, for example\n             // `pages/index.js` it won't match the extensions list above because it already had an\n             // extension and for example `.js.js` obviously won't match\n-            Ok(*self.base_path)\n+            Ok(self.base_path.clone().cell())\n         }\n     }\n }\n@@ -80,8 +80,8 @@ pub struct PagesStructure {\n \n #[turbo_tasks::value]\n pub struct PagesDirectoryStructure {\n-    pub project_path: ResolvedVc<FileSystemPath>,\n-    pub next_router_path: ResolvedVc<FileSystemPath>,\n+    pub project_path: FileSystemPath,\n+    pub next_router_path: FileSystemPath,\n     pub items: Vec<ResolvedVc<PagesStructureItem>>,\n     pub children: Vec<ResolvedVc<PagesDirectoryStructure>>,\n }\n@@ -92,30 +92,26 @@ impl PagesDirectoryStructure {\n     /// system.\n     #[turbo_tasks::function]\n     pub fn project_path(&self) -> Vc<FileSystemPath> {\n-        *self.project_path\n+        self.project_path.clone().cell()\n     }\n }\n \n /// Finds and returns the [PagesStructure] of the pages directory if existing.\n #[turbo_tasks::function]\n pub async fn find_pages_structure(\n-    project_root: Vc<FileSystemPath>,\n-    next_router_root: Vc<FileSystemPath>,\n+    project_root: FileSystemPath,\n+    next_router_root: FileSystemPath,\n     page_extensions: Vc<Vec<RcStr>>,\n ) -> Result<Vc<PagesStructure>> {\n-    let pages_root = project_root\n-        .join(\"pages\".into())\n-        .realpath()\n-        .to_resolved()\n-        .await?;\n+    let pages_root = project_root.join(\"pages\")?.realpath().await?.clone_value();\n     let pages_root = if *pages_root.get_type().await? == FileSystemEntryType::Directory {\n         Some(pages_root)\n     } else {\n         let src_pages_root = project_root\n-            .join(\"src/pages\".into())\n+            .join(\"src/pages\")?\n             .realpath()\n-            .to_resolved()\n-            .await?;\n+            .await?\n+            .clone_value();\n         if *src_pages_root.get_type().await? == FileSystemEntryType::Directory {\n             Some(src_pages_root)\n         } else {\n@@ -137,9 +133,9 @@ pub async fn find_pages_structure(\n /// Handles the root pages directory.\n #[turbo_tasks::function]\n async fn get_pages_structure_for_root_directory(\n-    project_root: Vc<FileSystemPath>,\n+    project_root: FileSystemPath,\n     project_path: Vc<FileSystemPathOption>,\n-    next_router_path: Vc<FileSystemPath>,\n+    next_router_path: FileSystemPath,\n     page_extensions: Vc<Vec<RcStr>>,\n ) -> Result<Vc<PagesStructure>> {\n     let page_extensions_raw = &*page_extensions.await?;\n@@ -155,7 +151,7 @@ async fn get_pages_structure_for_root_directory(\n         let dir_content = project_path.read_dir().await?;\n         if let DirectoryContent::Entries(entries) = &*dir_content {\n             for (name, entry) in entries.iter() {\n-                let entry = entry.resolve_symlink().await?;\n+                let entry = entry.clone().resolve_symlink().await?;\n                 match entry {\n                     DirectoryEntry::File(_) => {\n                         // Do not process .d.ts files as routes\n@@ -165,13 +161,15 @@ async fn get_pages_structure_for_root_directory(\n                         let Some(basename) = page_basename(name, page_extensions_raw) else {\n                             continue;\n                         };\n-                        let base_path = project_path.join(basename.into());\n+                        let base_path = project_path.join(basename)?;\n                         match basename {\n                             \"_app\" | \"_document\" | \"_error\" => {}\n                             \"500\" => {\n-                                let item_next_router_path =\n-                                    next_router_path_for_basename(next_router_path, basename);\n-                                let item_original_path = next_router_path.join(basename.into());\n+                                let item_next_router_path = next_router_path_for_basename(\n+                                    next_router_path.clone(),\n+                                    basename,\n+                                )?;\n+                                let item_original_path = next_router_path.join(basename)?;\n                                 let item = PagesStructureItem::new(\n                                     base_path,\n                                     page_extensions,\n@@ -186,9 +184,11 @@ async fn get_pages_structure_for_root_directory(\n                             }\n \n                             basename => {\n-                                let item_next_router_path =\n-                                    next_router_path_for_basename(next_router_path, basename);\n-                                let item_original_path = next_router_path.join(basename.into());\n+                                let item_next_router_path = next_router_path_for_basename(\n+                                    next_router_path.clone(),\n+                                    basename,\n+                                )?;\n+                                let item_original_path = next_router_path.join(basename)?;\n                                 items.push((\n                                     basename,\n                                     PagesStructureItem::new(\n@@ -206,8 +206,8 @@ async fn get_pages_structure_for_root_directory(\n                         \"api\" => {\n                             api_directory = Some(\n                                 get_pages_structure_for_directory(\n-                                    *dir_project_path,\n-                                    next_router_path.join(name.clone()),\n+                                    dir_project_path.clone(),\n+                                    next_router_path.join(name)?,\n                                     1,\n                                     page_extensions,\n                                 )\n@@ -219,8 +219,8 @@ async fn get_pages_structure_for_root_directory(\n                             children.push((\n                                 name,\n                                 get_pages_structure_for_directory(\n-                                    *dir_project_path,\n-                                    next_router_path.join(name.clone()),\n+                                    dir_project_path.clone(),\n+                                    next_router_path.join(name)?,\n                                     1,\n                                     page_extensions,\n                                 ),\n@@ -238,8 +238,8 @@ async fn get_pages_structure_for_root_directory(\n \n         Some(\n             PagesDirectoryStructure {\n-                project_path: *project_path,\n-                next_router_path: next_router_path.to_resolved().await?,\n+                project_path: project_path.clone(),\n+                next_router_path: next_router_path.clone(),\n                 items: items\n                     .into_iter()\n                     .map(|(_, v)| async move { v.to_resolved().await })\n@@ -257,41 +257,53 @@ async fn get_pages_structure_for_root_directory(\n         None\n     };\n \n-    let pages_path = if let Some(project_path) = *project_path {\n-        *project_path\n+    let pages_path = if let Some(project_path) = &*project_path {\n+        project_path.clone()\n     } else {\n-        project_root.join(\"pages\".into())\n+        project_root.join(\"pages\")?\n     };\n \n     let app_item = {\n-        let app_router_path = next_router_path.join(\"_app\".into());\n+        let app_router_path = next_router_path.join(\"_app\")?;\n         PagesStructureItem::new(\n-            pages_path.join(\"_app\".into()),\n+            pages_path.join(\"_app\")?,\n             page_extensions,\n-            Some(get_next_package(project_root).join(\"app.js\".into())),\n-            app_router_path,\n+            Some(\n+                get_next_package(project_root.clone())\n+                    .await?\n+                    .join(\"app.js\")?,\n+            ),\n+            app_router_path.clone(),\n             app_router_path,\n         )\n     };\n \n     let document_item = {\n-        let document_router_path = next_router_path.join(\"_document\".into());\n+        let document_router_path = next_router_path.join(\"_document\")?;\n         PagesStructureItem::new(\n-            pages_path.join(\"_document\".into()),\n+            pages_path.join(\"_document\")?,\n             page_extensions,\n-            Some(get_next_package(project_root).join(\"document.js\".into())),\n-            document_router_path,\n+            Some(\n+                get_next_package(project_root.clone())\n+                    .await?\n+                    .join(\"document.js\")?,\n+            ),\n+            document_router_path.clone(),\n             document_router_path,\n         )\n     };\n \n     let error_item = {\n-        let error_router_path = next_router_path.join(\"_error\".into());\n+        let error_router_path = next_router_path.join(\"_error\")?;\n         PagesStructureItem::new(\n-            pages_path.join(\"_error\".into()),\n+            pages_path.join(\"_error\")?,\n             page_extensions,\n-            Some(get_next_package(project_root).join(\"error.js\".into())),\n-            error_router_path,\n+            Some(\n+                get_next_package(project_root.clone())\n+                    .await?\n+                    .join(\"error.js\")?,\n+            ),\n+            error_router_path.clone(),\n             error_router_path,\n         )\n     };\n@@ -311,13 +323,13 @@ async fn get_pages_structure_for_root_directory(\n /// Calls itself recursively for sub directories.\n #[turbo_tasks::function]\n async fn get_pages_structure_for_directory(\n-    project_path: Vc<FileSystemPath>,\n-    next_router_path: Vc<FileSystemPath>,\n+    project_path: FileSystemPath,\n+    next_router_path: FileSystemPath,\n     position: u32,\n     page_extensions: Vc<Vec<RcStr>>,\n ) -> Result<Vc<PagesDirectoryStructure>> {\n     let span = {\n-        let path = project_path.to_string().await?.to_string();\n+        let path = project_path.value_to_string().await?.to_string();\n         tracing::info_span!(\"analyse pages structure\", name = path)\n     };\n     async move {\n@@ -334,11 +346,11 @@ async fn get_pages_structure_for_directory(\n                             continue;\n                         };\n                         let item_next_router_path = match basename {\n-                            \"index\" => next_router_path,\n-                            _ => next_router_path.join(basename.into()),\n+                            \"index\" => next_router_path.clone(),\n+                            _ => next_router_path.join(basename)?,\n                         };\n-                        let base_path = project_path.join(name.clone());\n-                        let item_original_name = next_router_path.join(basename.into());\n+                        let base_path = project_path.join(name)?;\n+                        let item_original_name = next_router_path.join(basename)?;\n                         items.push((\n                             basename,\n                             PagesStructureItem::new(\n@@ -354,8 +366,8 @@ async fn get_pages_structure_for_directory(\n                         children.push((\n                             name,\n                             get_pages_structure_for_directory(\n-                                **dir_project_path,\n-                                next_router_path.join(name.clone()),\n+                                dir_project_path.clone(),\n+                                next_router_path.join(name)?,\n                                 position + 1,\n                                 page_extensions,\n                             ),\n@@ -373,8 +385,8 @@ async fn get_pages_structure_for_directory(\n         children.sort_by_key(|(k, _)| *k);\n \n         Ok(PagesDirectoryStructure {\n-            project_path: project_path.to_resolved().await?,\n-            next_router_path: next_router_path.to_resolved().await?,\n+            project_path: project_path.clone(),\n+            next_router_path: next_router_path.clone(),\n             items: items\n                 .into_iter()\n                 .map(|(_, v)| v)\n@@ -401,12 +413,12 @@ fn page_basename<'a>(name: &'a str, page_extensions: &'a [RcStr]) -> Option<&'a\n }\n \n fn next_router_path_for_basename(\n-    next_router_path: Vc<FileSystemPath>,\n+    next_router_path: FileSystemPath,\n     basename: &str,\n-) -> Vc<FileSystemPath> {\n-    if basename == \"index\" {\n-        next_router_path\n+) -> Result<FileSystemPath> {\n+    Ok(if basename == \"index\" {\n+        next_router_path.clone()\n     } else {\n-        next_router_path.join(basename.into())\n-    }\n+        next_router_path.join(basename)?\n+    })\n }"
        },
        {
            "sha": "8eab3125791fbb1b1b9b4bcbb2c45c520853239d",
            "filename": "crates/next-core/src/transform_options.rs",
            "status": "modified",
            "additions": 8,
            "deletions": 8,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Ftransform_options.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Ftransform_options.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Ftransform_options.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -18,14 +18,14 @@ use turbopack_ecmascript::typescript::resolve::{read_from_tsconfigs, read_tsconf\n use crate::{mode::NextMode, next_config::NextConfig};\n \n async fn get_typescript_options(\n-    project_path: Vc<FileSystemPath>,\n+    project_path: FileSystemPath,\n ) -> Result<Option<Vec<(Vc<FileJsonContent>, ResolvedVc<Box<dyn Source>>)>>> {\n     let tsconfig = find_context_file(project_path, tsconfig());\n     Ok(match tsconfig.await.ok().as_deref() {\n         Some(FindContextFileResult::Found(path, _)) => read_tsconfigs(\n             path.read(),\n-            ResolvedVc::upcast(FileSource::new(**path).to_resolved().await?),\n-            node_cjs_resolve_options(path.root()),\n+            ResolvedVc::upcast(FileSource::new(path.clone()).to_resolved().await?),\n+            node_cjs_resolve_options(path.root().await?.clone_value()),\n         )\n         .await\n         .ok(),\n@@ -37,7 +37,7 @@ async fn get_typescript_options(\n /// outputs\n #[turbo_tasks::function]\n pub async fn get_typescript_transform_options(\n-    project_path: Vc<FileSystemPath>,\n+    project_path: FileSystemPath,\n ) -> Result<Vc<TypescriptTransformOptions>> {\n     let tsconfig = get_typescript_options(project_path).await?;\n \n@@ -62,7 +62,7 @@ pub async fn get_typescript_transform_options(\n /// **TODO** Currnently only typescript's legacy decorators are supported\n #[turbo_tasks::function]\n pub async fn get_decorators_transform_options(\n-    project_path: Vc<FileSystemPath>,\n+    project_path: FileSystemPath,\n ) -> Result<Vc<DecoratorsOptions>> {\n     let tsconfig = get_typescript_options(project_path).await?;\n \n@@ -129,18 +129,18 @@ pub async fn get_decorators_transform_options(\n \n #[turbo_tasks::function]\n pub async fn get_jsx_transform_options(\n-    project_path: Vc<FileSystemPath>,\n+    project_path: FileSystemPath,\n     mode: Vc<NextMode>,\n     resolve_options_context: Option<Vc<ResolveOptionsContext>>,\n     is_rsc_context: bool,\n     next_config: Vc<NextConfig>,\n ) -> Result<Vc<JsxTransformOptions>> {\n-    let tsconfig = get_typescript_options(project_path).await?;\n+    let tsconfig = get_typescript_options(project_path.clone()).await?;\n \n     let is_react_development = mode.await?.is_react_development();\n     let enable_react_refresh = if is_react_development {\n         if let Some(resolve_options_context) = resolve_options_context {\n-            assert_can_resolve_react_refresh(project_path, resolve_options_context)\n+            assert_can_resolve_react_refresh(project_path.clone(), resolve_options_context)\n                 .await?\n                 .is_found()\n         } else {"
        },
        {
            "sha": "a089050b891925f8e820d707e7673cd6f1000b57",
            "filename": "crates/next-core/src/util.rs",
            "status": "modified",
            "additions": 35,
            "deletions": 31,
            "changes": 66,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Futil.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/crates%2Fnext-core%2Fsrc%2Futil.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Futil.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -8,7 +8,7 @@ use swc_core::{\n };\n use turbo_rcstr::RcStr;\n use turbo_tasks::{\n-    FxIndexMap, FxIndexSet, NonLocalValue, ResolvedVc, TaskInput, ValueDefault, ValueToString, Vc,\n+    FxIndexMap, FxIndexSet, NonLocalValue, ResolvedVc, TaskInput, ValueDefault, Vc,\n     trace::TraceRawVcs, util::WrapFuture,\n };\n use turbo_tasks_fs::{\n@@ -52,18 +52,18 @@ pub enum PathType {\n /// Converts a filename within the server root into a next pathname.\n #[turbo_tasks::function]\n pub async fn pathname_for_path(\n-    server_root: Vc<FileSystemPath>,\n-    server_path: Vc<FileSystemPath>,\n+    server_root: FileSystemPath,\n+    server_path: FileSystemPath,\n     path_ty: PathType,\n ) -> Result<Vc<RcStr>> {\n-    let server_path_value = &*server_path.await?;\n-    let path = if let Some(path) = server_root.await?.get_path_to(server_path_value) {\n+    let server_path_value = server_path.clone();\n+    let path = if let Some(path) = server_root.get_path_to(&server_path_value) {\n         path\n     } else {\n         bail!(\n             \"server_path ({}) is not in server_root ({})\",\n-            server_path.to_string().await?,\n-            server_root.to_string().await?\n+            server_path.value_to_string().await?,\n+            server_root.value_to_string().await?\n         )\n     };\n     let path = match (path_ty, path) {\n@@ -98,7 +98,7 @@ pub fn get_asset_path_from_pathname(pathname: &str, ext: &str) -> String {\n #[turbo_tasks::function]\n pub async fn get_transpiled_packages(\n     next_config: Vc<NextConfig>,\n-    project_path: ResolvedVc<FileSystemPath>,\n+    project_path: FileSystemPath,\n ) -> Result<Vc<Vec<RcStr>>> {\n     let mut transpile_packages: Vec<RcStr> = next_config.transpile_packages().owned().await?;\n \n@@ -115,19 +115,18 @@ pub async fn get_transpiled_packages(\n \n pub async fn foreign_code_context_condition(\n     next_config: Vc<NextConfig>,\n-    project_path: ResolvedVc<FileSystemPath>,\n+    project_path: FileSystemPath,\n ) -> Result<ContextCondition> {\n-    let transpiled_packages = get_transpiled_packages(next_config, *project_path).await?;\n+    let transpiled_packages = get_transpiled_packages(next_config, project_path.clone()).await?;\n \n     // The next template files are allowed to import the user's code via import\n     // mapping, and imports must use the project-level [ResolveOptions] instead\n     // of the `node_modules` specific resolve options (the template files are\n     // technically node module files).\n     let not_next_template_dir = ContextCondition::not(ContextCondition::InPath(\n-        get_next_package(*project_path)\n-            .join(NEXT_TEMPLATE_PATH.into())\n-            .to_resolved()\n-            .await?,\n+        get_next_package(project_path.clone())\n+            .await?\n+            .join(NEXT_TEMPLATE_PATH)?,\n     ));\n \n     let result = ContextCondition::all(vec![\n@@ -151,18 +150,18 @@ pub async fn foreign_code_context_condition(\n // subject to Next.js's configuration even if it's embedded assets.\n pub async fn internal_assets_conditions() -> Result<ContextCondition> {\n     Ok(ContextCondition::any(vec![\n-        ContextCondition::InPath(next_js_fs().root().to_resolved().await?),\n+        ContextCondition::InPath(next_js_fs().root().await?.clone_value()),\n         ContextCondition::InPath(\n             turbopack_ecmascript_runtime::embed_fs()\n                 .root()\n-                .to_resolved()\n-                .await?,\n+                .await?\n+                .clone_value(),\n         ),\n         ContextCondition::InPath(\n             turbopack_node::embed_js::embed_fs()\n                 .root()\n-                .to_resolved()\n-                .await?,\n+                .await?\n+                .clone_value(),\n         ),\n     ]))\n }\n@@ -675,21 +674,21 @@ async fn parse_config_from_js_value(\n /// sure there are none left over.\n pub async fn load_next_js_template(\n     path: &str,\n-    project_path: Vc<FileSystemPath>,\n+    project_path: FileSystemPath,\n     replacements: FxIndexMap<&'static str, RcStr>,\n     injections: FxIndexMap<&'static str, RcStr>,\n     imports: FxIndexMap<&'static str, Option<RcStr>>,\n ) -> Result<Vc<Box<dyn Source>>> {\n-    let path = virtual_next_js_template_path(project_path, path.to_string());\n+    let path = virtual_next_js_template_path(project_path.clone(), path.to_string()).await?;\n \n     let content = &*file_content_rope(path.read()).await?;\n     let content = content.to_str()?.into_owned();\n \n     let parent_path = path.parent();\n-    let parent_path_value = &*parent_path.await?;\n+    let parent_path_value = parent_path.clone();\n \n-    let package_root = get_next_package(project_path).parent();\n-    let package_root_value = &*package_root.await?;\n+    let package_root = get_next_package(project_path).await?.parent();\n+    let package_root_value = package_root.clone();\n \n     /// See [regex::Regex::replace_all].\n     fn replace_all<E>(\n@@ -939,24 +938,29 @@ pub async fn file_content_rope(content: Vc<FileContent>) -> Result<Vc<Rope>> {\n     Ok(file.content().to_owned().cell())\n }\n \n-pub fn virtual_next_js_template_path(\n-    project_path: Vc<FileSystemPath>,\n+pub async fn virtual_next_js_template_path(\n+    project_path: FileSystemPath,\n     file: String,\n-) -> Vc<FileSystemPath> {\n+) -> Result<FileSystemPath> {\n     debug_assert!(!file.contains('/'));\n-    get_next_package(project_path).join(format!(\"{NEXT_TEMPLATE_PATH}/{file}\").into())\n+    get_next_package(project_path)\n+        .await?\n+        .join(&format!(\"{NEXT_TEMPLATE_PATH}/{file}\"))\n }\n \n pub async fn load_next_js_templateon<T: DeserializeOwned>(\n-    project_path: ResolvedVc<FileSystemPath>,\n+    project_path: FileSystemPath,\n     path: RcStr,\n ) -> Result<T> {\n-    let file_path = get_next_package(*project_path).join(path.clone());\n+    let file_path = get_next_package(project_path.clone()).await?.join(&path)?;\n \n     let content = &*file_path.read().await?;\n \n     let FileContent::Content(file) = content else {\n-        bail!(\"Expected file content at {}\", file_path.to_string().await?);\n+        bail!(\n+            \"Expected file content at {}\",\n+            file_path.value_to_string().await?\n+        );\n     };\n \n     let result: T = parse_json_rope_with_source_context(file.content())?;"
        },
        {
            "sha": "407f88b211f56ef3867cd7e7c6a23b3f8712ae74",
            "filename": "turbopack/crates/turbo-tasks-env/src/dotenv.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 7,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbo-tasks-env%2Fsrc%2Fdotenv.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbo-tasks-env%2Fsrc%2Fdotenv.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-env%2Fsrc%2Fdotenv.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -2,7 +2,7 @@ use std::{env, sync::MutexGuard};\n \n use anyhow::{Context, Result, anyhow};\n use turbo_rcstr::RcStr;\n-use turbo_tasks::{FxIndexMap, ReadRef, ResolvedVc, ValueToString, Vc};\n+use turbo_tasks::{FxIndexMap, ReadRef, ResolvedVc, Vc};\n use turbo_tasks_fs::{FileContent, FileSystemPath};\n \n use crate::{EnvMap, GLOBAL_ENV_LOCK, ProcessEnv, sorted_env_vars};\n@@ -13,16 +13,13 @@ use crate::{EnvMap, GLOBAL_ENV_LOCK, ProcessEnv, sorted_env_vars};\n #[turbo_tasks::value]\n pub struct DotenvProcessEnv {\n     prior: Option<ResolvedVc<Box<dyn ProcessEnv>>>,\n-    path: ResolvedVc<FileSystemPath>,\n+    path: FileSystemPath,\n }\n \n #[turbo_tasks::value_impl]\n impl DotenvProcessEnv {\n     #[turbo_tasks::function]\n-    pub fn new(\n-        prior: Option<ResolvedVc<Box<dyn ProcessEnv>>>,\n-        path: ResolvedVc<FileSystemPath>,\n-    ) -> Vc<Self> {\n+    pub fn new(prior: Option<ResolvedVc<Box<dyn ProcessEnv>>>, path: FileSystemPath) -> Vc<Self> {\n         DotenvProcessEnv { prior, path }.cell()\n     }\n \n@@ -65,7 +62,7 @@ impl DotenvProcessEnv {\n             if let Err(e) = res {\n                 return Err(e).context(anyhow!(\n                     \"unable to read {} for env vars\",\n-                    this.path.to_string().await?\n+                    this.path.value_to_string().await?\n                 ));\n             }\n "
        },
        {
            "sha": "6473a81cab98cae4dd11d0dd1a6ac6b17e41a3a6",
            "filename": "turbopack/crates/turbo-tasks-fetch/src/lib.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbo-tasks-fetch%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbo-tasks-fetch%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fetch%2Fsrc%2Flib.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -142,7 +142,7 @@ impl FetchError {\n     pub async fn to_issue(\n         self: Vc<Self>,\n         severity: IssueSeverity,\n-        issue_context: ResolvedVc<FileSystemPath>,\n+        issue_context: FileSystemPath,\n     ) -> Result<Vc<FetchIssue>> {\n         let this = &*self.await?;\n         Ok(FetchIssue {\n@@ -158,7 +158,7 @@ impl FetchError {\n \n #[turbo_tasks::value(shared)]\n pub struct FetchIssue {\n-    pub issue_context: ResolvedVc<FileSystemPath>,\n+    pub issue_context: FileSystemPath,\n     pub severity: IssueSeverity,\n     pub url: ResolvedVc<RcStr>,\n     pub kind: ResolvedVc<FetchErrorKind>,\n@@ -169,7 +169,7 @@ pub struct FetchIssue {\n impl Issue for FetchIssue {\n     #[turbo_tasks::function]\n     fn file_path(&self) -> Vc<FileSystemPath> {\n-        *self.issue_context\n+        self.issue_context.clone().cell()\n     }\n \n     fn severity(&self) -> IssueSeverity {"
        },
        {
            "sha": "fc1edfba4d0ac1ab16ca3ac796d2c2b842c2c445",
            "filename": "turbopack/crates/turbo-tasks-fetch/tests/fetch.rs",
            "status": "modified",
            "additions": 8,
            "deletions": 2,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbo-tasks-fetch%2Ftests%2Ffetch.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbo-tasks-fetch%2Ftests%2Ffetch.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fetch%2Ftests%2Ffetch.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -125,7 +125,10 @@ async fn errors_on_failed_connection() {\n         assert_eq!(*err.kind.await?, FetchErrorKind::Connect);\n         assert_eq!(*err.url.await?, url);\n \n-        let issue = err_vc.to_issue(IssueSeverity::Error, get_issue_context());\n+        let issue = err_vc.to_issue(\n+            IssueSeverity::Error,\n+            get_issue_context().await?.clone_value(),\n+        );\n         assert_eq!(issue.await?.severity(), IssueSeverity::Error);\n         assert_eq!(\n             *issue.description().await?.unwrap().await?,\n@@ -159,7 +162,10 @@ async fn errors_on_404() {\n         assert!(matches!(*err.kind.await?, FetchErrorKind::Status(404)));\n         assert_eq!(*err.url.await?, url);\n \n-        let issue = err_vc.to_issue(IssueSeverity::Error, get_issue_context());\n+        let issue = err_vc.to_issue(\n+            IssueSeverity::Error,\n+            get_issue_context().await?.clone_value(),\n+        );\n         assert_eq!(issue.await?.severity(), IssueSeverity::Error);\n         assert_eq!(\n             *issue.description().await?.unwrap().await?,"
        },
        {
            "sha": "0907e419cef632582adf81a6572e5ef7873193ba",
            "filename": "turbopack/crates/turbo-tasks-fs/examples/hash_directory.rs",
            "status": "modified",
            "additions": 11,
            "deletions": 11,
            "changes": 22,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fexamples%2Fhash_directory.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fexamples%2Fhash_directory.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fexamples%2Fhash_directory.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -40,7 +40,7 @@ async fn main() -> Result<()> {\n \n             // Smart Pointer cast\n             let fs: Vc<Box<dyn FileSystem>> = Vc::upcast(disk_fs);\n-            let input = fs.root().join(\"demo\".into());\n+            let input = fs.root().await?.join(\"demo\")?;\n             let dir_hash = hash_directory(input);\n             print_hash(dir_hash).await?;\n             Ok::<Vc<()>, _>(Default::default())\n@@ -67,33 +67,33 @@ async fn print_hash(dir_hash: Vc<RcStr>) -> Result<Vc<()>> {\n     Ok(Default::default())\n }\n \n-async fn filename(path: Vc<FileSystemPath>) -> Result<String> {\n-    Ok(path.await?.path.split('/').next_back().unwrap().to_string())\n+async fn filename(path: FileSystemPath) -> Result<String> {\n+    Ok(path.path.split('/').next_back().unwrap().to_string())\n }\n \n #[turbo_tasks::function]\n-async fn hash_directory(directory: Vc<FileSystemPath>) -> Result<Vc<RcStr>> {\n-    let dir_path = &directory.await?.path;\n+async fn hash_directory(directory: FileSystemPath) -> Result<Vc<RcStr>> {\n+    let dir_path = &directory.path;\n     let content = directory.read_dir();\n     let mut hashes = BTreeMap::new();\n     match &*content.await? {\n         DirectoryContent::Entries(entries) => {\n             for entry in entries.values() {\n                 match entry {\n                     DirectoryEntry::File(path) => {\n-                        let name = filename(**path).await?;\n-                        hashes.insert(name, hash_file(**path).owned().await?);\n+                        let name = filename(path.clone()).await?;\n+                        hashes.insert(name, hash_file(path.clone()).owned().await?);\n                     }\n                     DirectoryEntry::Directory(path) => {\n-                        let name = filename(**path).await?;\n-                        hashes.insert(name, hash_directory(**path).owned().await?);\n+                        let name = filename(path.clone()).await?;\n+                        hashes.insert(name, hash_directory(path.clone()).owned().await?);\n                     }\n                     _ => {}\n                 }\n             }\n         }\n         DirectoryContent::NotFound => {\n-            println!(\"{}: not found\", directory.await?.path);\n+            println!(\"{}: not found\", directory.path);\n         }\n     };\n     let hash = hash_content(\n@@ -108,7 +108,7 @@ async fn hash_directory(directory: Vc<FileSystemPath>) -> Result<Vc<RcStr>> {\n }\n \n #[turbo_tasks::function]\n-async fn hash_file(file_path: Vc<FileSystemPath>) -> Result<Vc<RcStr>> {\n+async fn hash_file(file_path: FileSystemPath) -> Result<Vc<RcStr>> {\n     let content = file_path.read().await?;\n     Ok(match &*content {\n         FileContent::Content(file) => hash_content(&mut file.read()),"
        },
        {
            "sha": "b38ecd3ac5a0bec46b64072be8e9f23c436e1f37",
            "filename": "turbopack/crates/turbo-tasks-fs/examples/hash_glob.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fexamples%2Fhash_glob.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fexamples%2Fhash_glob.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fexamples%2Fhash_glob.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -37,7 +37,7 @@ async fn main() -> Result<()> {\n \n             // Smart Pointer cast\n             let fs: Vc<Box<dyn FileSystem>> = Vc::upcast(disk_fs);\n-            let input = fs.root().join(\"crates\".into());\n+            let input = fs.root().await?.join(\"crates\")?;\n             let glob = Glob::new(\"**/*.rs\".into());\n             let glob_result = input.read_glob(glob);\n             let dir_hash = hash_glob_result(glob_result);\n@@ -77,7 +77,7 @@ async fn hash_glob_result(result: Vc<ReadGlobResult>) -> Result<Vc<RcStr>> {\n     let mut hashes = BTreeMap::new();\n     for (name, entry) in result.results.iter() {\n         if let DirectoryEntry::File(path) = entry {\n-            hashes.insert(name, hash_file(**path).owned().await?);\n+            hashes.insert(name, hash_file(path.clone()).owned().await?);\n         }\n     }\n     for (name, result) in result.inner.iter() {\n@@ -100,7 +100,7 @@ async fn hash_glob_result(result: Vc<ReadGlobResult>) -> Result<Vc<RcStr>> {\n }\n \n #[turbo_tasks::function]\n-async fn hash_file(file_path: Vc<FileSystemPath>) -> Result<Vc<RcStr>> {\n+async fn hash_file(file_path: FileSystemPath) -> Result<Vc<RcStr>> {\n     let content = file_path.read().await?;\n     Ok(match &*content {\n         FileContent::Content(file) => hash_content(&mut file.read()),"
        },
        {
            "sha": "e8f130cc470ac78a5f3cd61fc3b670d3eb697471",
            "filename": "turbopack/crates/turbo-tasks-fs/src/attach.rs",
            "status": "modified",
            "additions": 34,
            "deletions": 44,
            "changes": 78,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fattach.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fattach.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fattach.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -23,11 +23,9 @@ impl AttachedFileSystem {\n     /// an invisible subdirectory of the `child_path`\n     #[turbo_tasks::function]\n     pub async fn new(\n-        child_path: Vc<FileSystemPath>,\n+        child_path: FileSystemPath,\n         child_fs: ResolvedVc<Box<dyn FileSystem>>,\n     ) -> Result<Vc<Self>> {\n-        let child_path = child_path.await?;\n-\n         Ok(AttachedFileSystem {\n             root_fs: child_path.fs,\n             child_path: child_path.path.clone(),\n@@ -36,61 +34,49 @@ impl AttachedFileSystem {\n         .cell())\n     }\n \n-    /// Converts the given [Vc<FileSystemPath>] to a path in this [FileSystem].\n+    /// Converts the given [FileSystemPath] to a path in this [FileSystem].\n     ///\n     /// The given path has to be inside of the root [FileSystem], the child\n     /// [FileSystem] or this [AttachedFileSystem].\n     #[turbo_tasks::function]\n     pub async fn convert_path(\n         self: ResolvedVc<Self>,\n-        contained_path_vc: Vc<FileSystemPath>,\n+        contained_path: FileSystemPath,\n     ) -> Result<Vc<FileSystemPath>> {\n-        let contained_path = contained_path_vc.await?;\n         let self_fs: ResolvedVc<Box<dyn FileSystem>> = ResolvedVc::upcast(self);\n         let this = self.await?;\n \n         match contained_path.fs {\n             // already on this filesystem\n-            fs if fs == self_fs => Ok(contained_path_vc),\n+            fs if fs == self_fs => Ok(contained_path.cell()),\n             // in the root filesystem, just need to rebase on this filesystem\n-            fs if fs == this.root_fs => Ok(self\n-                .root()\n-                .resolve()\n-                .await?\n-                .join(contained_path.path.clone())),\n+            fs if fs == this.root_fs => Ok(self.root().await?.join(&contained_path.path)?.cell()),\n             // in the child filesystem, so we expand to the full path by appending to child_path\n-            fs if fs == this.child_fs => Ok(self\n-                .child_path()\n-                .resolve()\n-                .await?\n-                .join(contained_path.path.clone())),\n+            fs if fs == this.child_fs => {\n+                Ok(self.child_path().await?.join(&contained_path.path)?.cell())\n+            }\n             _ => bail!(\n                 \"path {} not part of self, the root fs or the child fs\",\n-                contained_path_vc.to_string().await?\n+                contained_path.value_to_string().await?\n             ),\n         }\n     }\n \n-    /// Constructs a [Vc<FileSystemPath>] of the attachment point referencing\n+    /// Constructs a [FileSystemPath] of the attachment point referencing\n     /// this [AttachedFileSystem]\n     #[turbo_tasks::function]\n     async fn child_path(self: Vc<Self>) -> Result<Vc<FileSystemPath>> {\n-        Ok(self\n-            .root()\n-            .resolve()\n-            .await?\n-            .join(self.await?.child_path.clone()))\n+        Ok(self.root().await?.join(&self.await?.child_path)?.cell())\n     }\n \n     /// Resolves the local path of the root or child filesystem from a path\n     /// on the [AttachedFileSystem]\n     #[turbo_tasks::function]\n     pub async fn get_inner_fs_path(\n         self: ResolvedVc<Self>,\n-        path: Vc<FileSystemPath>,\n+        path: FileSystemPath,\n     ) -> Result<Vc<FileSystemPath>> {\n         let this = self.await?;\n-        let path = path.await?;\n         let self_fs: ResolvedVc<Box<dyn FileSystem>> = ResolvedVc::upcast(self);\n \n         if path.fs != self_fs {\n@@ -105,47 +91,51 @@ impl AttachedFileSystem {\n \n         let child_path = self.child_path().await?;\n         Ok(if let Some(inner_path) = child_path.get_path_to(&path) {\n-            this.child_fs\n-                .root()\n-                .resolve()\n-                .await?\n-                .join(inner_path.into())\n+            this.child_fs.root().await?.join(inner_path)?.cell()\n         } else {\n-            this.root_fs.root().resolve().await?.join(path.path.clone())\n+            this.root_fs.root().await?.join(&path.path)?.cell()\n         })\n     }\n }\n \n #[turbo_tasks::value_impl]\n impl FileSystem for AttachedFileSystem {\n     #[turbo_tasks::function(fs)]\n-    fn read(self: Vc<Self>, path: Vc<FileSystemPath>) -> Vc<FileContent> {\n-        self.get_inner_fs_path(path).read()\n+    async fn read(self: Vc<Self>, path: FileSystemPath) -> Result<Vc<FileContent>> {\n+        Ok(self.get_inner_fs_path(path).await?.read())\n     }\n \n     #[turbo_tasks::function(fs)]\n-    fn read_link(self: Vc<Self>, path: Vc<FileSystemPath>) -> Vc<LinkContent> {\n-        self.get_inner_fs_path(path).read_link()\n+    async fn read_link(self: Vc<Self>, path: FileSystemPath) -> Result<Vc<LinkContent>> {\n+        Ok(self.get_inner_fs_path(path).await?.read_link())\n     }\n \n     #[turbo_tasks::function(fs)]\n-    fn raw_read_dir(self: Vc<Self>, path: Vc<FileSystemPath>) -> Vc<RawDirectoryContent> {\n-        self.get_inner_fs_path(path).raw_read_dir()\n+    async fn raw_read_dir(self: Vc<Self>, path: FileSystemPath) -> Result<Vc<RawDirectoryContent>> {\n+        Ok(self.get_inner_fs_path(path).await?.raw_read_dir())\n     }\n \n     #[turbo_tasks::function(fs)]\n-    fn write(self: Vc<Self>, path: Vc<FileSystemPath>, content: Vc<FileContent>) -> Vc<()> {\n-        self.get_inner_fs_path(path).write(content)\n+    async fn write(\n+        self: Vc<Self>,\n+        path: FileSystemPath,\n+        content: Vc<FileContent>,\n+    ) -> Result<Vc<()>> {\n+        Ok(self.get_inner_fs_path(path).await?.write(content))\n     }\n \n     #[turbo_tasks::function(fs)]\n-    fn write_link(self: Vc<Self>, path: Vc<FileSystemPath>, target: Vc<LinkContent>) -> Vc<()> {\n-        self.get_inner_fs_path(path).write_link(target)\n+    async fn write_link(\n+        self: Vc<Self>,\n+        path: FileSystemPath,\n+        target: Vc<LinkContent>,\n+    ) -> Result<Vc<()>> {\n+        Ok(self.get_inner_fs_path(path).await?.write_link(target))\n     }\n \n     #[turbo_tasks::function]\n-    fn metadata(self: Vc<Self>, path: Vc<FileSystemPath>) -> Vc<FileMeta> {\n-        self.get_inner_fs_path(path).metadata()\n+    async fn metadata(self: Vc<Self>, path: FileSystemPath) -> Result<Vc<FileMeta>> {\n+        Ok(self.get_inner_fs_path(path).await?.metadata())\n     }\n }\n "
        },
        {
            "sha": "fede1901887cbc3ff1c5e0aeb016551e2c4995a7",
            "filename": "turbopack/crates/turbo-tasks-fs/src/embed/file.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fembed%2Ffile.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fembed%2Ffile.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fembed%2Ffile.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -26,7 +26,7 @@ pub async fn content_from_relative_path(\n     );\n     disk_fs.await?.start_watching(None).await?;\n \n-    let fs_path = disk_fs.root().join(path.into());\n+    let fs_path = disk_fs.root().await?.join(path)?;\n     Ok(fs_path.read())\n }\n "
        },
        {
            "sha": "96488ef6b9826f2c99adba2eee31a73c1be8b1c3",
            "filename": "turbopack/crates/turbo-tasks-fs/src/embed/fs.rs",
            "status": "modified",
            "additions": 9,
            "deletions": 9,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fembed%2Ffs.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fembed%2Ffs.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fembed%2Ffs.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -25,8 +25,8 @@ impl EmbeddedFileSystem {\n #[turbo_tasks::value_impl]\n impl FileSystem for EmbeddedFileSystem {\n     #[turbo_tasks::function]\n-    async fn read(&self, path: Vc<FileSystemPath>) -> Result<Vc<FileContent>> {\n-        let file = match self.dir.get_file(&path.await?.path) {\n+    async fn read(&self, path: FileSystemPath) -> Result<Vc<FileContent>> {\n+        let file = match self.dir.get_file(&path.path) {\n             Some(file) => file,\n             None => return Ok(FileContent::NotFound.cell()),\n         };\n@@ -35,13 +35,13 @@ impl FileSystem for EmbeddedFileSystem {\n     }\n \n     #[turbo_tasks::function]\n-    fn read_link(&self, _path: Vc<FileSystemPath>) -> Vc<LinkContent> {\n+    fn read_link(&self, _path: FileSystemPath) -> Vc<LinkContent> {\n         LinkContent::NotFound.cell()\n     }\n \n     #[turbo_tasks::function]\n-    async fn raw_read_dir(&self, path: Vc<FileSystemPath>) -> Result<Vc<RawDirectoryContent>> {\n-        let path_str = &path.await?.path;\n+    async fn raw_read_dir(&self, path: FileSystemPath) -> Result<Vc<RawDirectoryContent>> {\n+        let path_str = &path.path;\n         let dir = match (path_str.as_str(), self.dir.get_dir(path_str)) {\n             (\"\", _) => self.dir,\n             (_, Some(dir)) => dir,\n@@ -70,18 +70,18 @@ impl FileSystem for EmbeddedFileSystem {\n     }\n \n     #[turbo_tasks::function]\n-    fn write(&self, _path: Vc<FileSystemPath>, _content: Vc<FileContent>) -> Result<Vc<()>> {\n+    fn write(&self, _path: FileSystemPath, _content: Vc<FileContent>) -> Result<Vc<()>> {\n         bail!(\"Writing is not possible to the embedded filesystem\")\n     }\n \n     #[turbo_tasks::function]\n-    fn write_link(&self, _path: Vc<FileSystemPath>, _target: Vc<LinkContent>) -> Result<Vc<()>> {\n+    fn write_link(&self, _path: FileSystemPath, _target: Vc<LinkContent>) -> Result<Vc<()>> {\n         bail!(\"Writing is not possible to the embedded filesystem\")\n     }\n \n     #[turbo_tasks::function]\n-    async fn metadata(&self, path: Vc<FileSystemPath>) -> Result<Vc<FileMeta>> {\n-        if self.dir.get_entry(&path.await?.path).is_none() {\n+    async fn metadata(&self, path: FileSystemPath) -> Result<Vc<FileMeta>> {\n+        if self.dir.get_entry(&path.path).is_none() {\n             bail!(\"path not found, can't read metadata\");\n         }\n "
        },
        {
            "sha": "aa3ad10772379ef70512c40ec29563a64b278c20",
            "filename": "turbopack/crates/turbo-tasks-fs/src/lib.rs",
            "status": "modified",
            "additions": 283,
            "deletions": 296,
            "changes": 579,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -56,8 +56,8 @@ use tracing::Instrument;\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{\n     ApplyEffectsContext, Completion, InvalidationReason, Invalidator, NonLocalValue, ReadRef,\n-    ResolvedVc, ValueToString, Vc, debug::ValueDebugFormat, effect, mark_session_dependent,\n-    mark_stateful, trace::TraceRawVcs,\n+    ResolvedVc, TaskInput, ValueToString, Vc, debug::ValueDebugFormat, effect,\n+    mark_session_dependent, mark_stateful, trace::TraceRawVcs,\n };\n use turbo_tasks_hash::{DeterministicHash, DeterministicHasher, hash_xxh3_hash64};\n use util::{extract_disk_access, join_path, normalize_path, sys_to_unix, unix_to_sys};\n@@ -193,21 +193,21 @@ fn create_semaphore() -> tokio::sync::Semaphore {\n pub trait FileSystem: ValueToString {\n     /// Returns the path to the root of the file system.\n     #[turbo_tasks::function]\n-    fn root(self: Vc<Self>) -> Vc<FileSystemPath> {\n-        FileSystemPath::new_normalized(self, RcStr::default())\n+    fn root(self: ResolvedVc<Self>) -> Vc<FileSystemPath> {\n+        FileSystemPath::new_normalized(self, RcStr::default()).cell()\n     }\n     #[turbo_tasks::function]\n-    fn read(self: Vc<Self>, fs_path: Vc<FileSystemPath>) -> Vc<FileContent>;\n+    fn read(self: Vc<Self>, fs_path: FileSystemPath) -> Vc<FileContent>;\n     #[turbo_tasks::function]\n-    fn read_link(self: Vc<Self>, fs_path: Vc<FileSystemPath>) -> Vc<LinkContent>;\n+    fn read_link(self: Vc<Self>, fs_path: FileSystemPath) -> Vc<LinkContent>;\n     #[turbo_tasks::function]\n-    fn raw_read_dir(self: Vc<Self>, fs_path: Vc<FileSystemPath>) -> Vc<RawDirectoryContent>;\n+    fn raw_read_dir(self: Vc<Self>, fs_path: FileSystemPath) -> Vc<RawDirectoryContent>;\n     #[turbo_tasks::function]\n-    fn write(self: Vc<Self>, fs_path: Vc<FileSystemPath>, content: Vc<FileContent>) -> Vc<()>;\n+    fn write(self: Vc<Self>, fs_path: FileSystemPath, content: Vc<FileContent>) -> Vc<()>;\n     #[turbo_tasks::function]\n-    fn write_link(self: Vc<Self>, fs_path: Vc<FileSystemPath>, target: Vc<LinkContent>) -> Vc<()>;\n+    fn write_link(self: Vc<Self>, fs_path: FileSystemPath, target: Vc<LinkContent>) -> Vc<()>;\n     #[turbo_tasks::function]\n-    fn metadata(self: Vc<Self>, fs_path: Vc<FileSystemPath>) -> Vc<FileMeta>;\n+    fn metadata(self: Vc<Self>, fs_path: FileSystemPath) -> Vc<FileMeta>;\n }\n \n #[derive(Default)]\n@@ -470,10 +470,9 @@ impl DiskFileSystem {\n         self.inner.watcher.stop_watching();\n     }\n \n-    pub async fn to_sys_path(&self, fs_path: Vc<FileSystemPath>) -> Result<PathBuf> {\n+    pub async fn to_sys_path(&self, fs_path: FileSystemPath) -> Result<PathBuf> {\n         // just in case there's a windows unc path prefix we remove it with `dunce`\n         let path = self.inner.root_path();\n-        let fs_path = fs_path.await?;\n         Ok(if fs_path.path.is_empty() {\n             path.to_path_buf()\n         } else {\n@@ -549,7 +548,7 @@ impl Debug for DiskFileSystem {\n #[turbo_tasks::value_impl]\n impl FileSystem for DiskFileSystem {\n     #[turbo_tasks::function(fs, invalidator)]\n-    async fn read(&self, fs_path: Vc<FileSystemPath>) -> Result<Vc<FileContent>> {\n+    async fn read(&self, fs_path: FileSystemPath) -> Result<Vc<FileContent>> {\n         mark_session_dependent();\n         let full_path = self.to_sys_path(fs_path).await?;\n         self.inner.register_read_invalidator(&full_path)?;\n@@ -575,7 +574,7 @@ impl FileSystem for DiskFileSystem {\n     }\n \n     #[turbo_tasks::function(fs, invalidator)]\n-    async fn raw_read_dir(&self, fs_path: Vc<FileSystemPath>) -> Result<Vc<RawDirectoryContent>> {\n+    async fn raw_read_dir(&self, fs_path: FileSystemPath) -> Result<Vc<RawDirectoryContent>> {\n         mark_session_dependent();\n         let full_path = self.to_sys_path(fs_path).await?;\n         self.inner.register_dir_invalidator(&full_path)?;\n@@ -630,9 +629,9 @@ impl FileSystem for DiskFileSystem {\n     }\n \n     #[turbo_tasks::function(fs, invalidator)]\n-    async fn read_link(&self, fs_path: Vc<FileSystemPath>) -> Result<Vc<LinkContent>> {\n+    async fn read_link(&self, fs_path: FileSystemPath) -> Result<Vc<LinkContent>> {\n         mark_session_dependent();\n-        let full_path = self.to_sys_path(fs_path).await?;\n+        let full_path = self.to_sys_path(fs_path.clone()).await?;\n         self.inner.register_read_invalidator(&full_path)?;\n \n         let _lock = self.inner.lock_path(&full_path).await;\n@@ -687,7 +686,7 @@ impl FileSystem for DiskFileSystem {\n             let target_string: RcStr = relative_to_root_path.to_string_lossy().into();\n             (\n                 target_string.clone(),\n-                FileSystemPath::new_normalized(fs_path.fs(), target_string)\n+                FileSystemPath::new_normalized(fs_path.fs().to_resolved().await?, target_string)\n                     .get_type()\n                     .await?,\n             )\n@@ -696,7 +695,7 @@ impl FileSystem for DiskFileSystem {\n             let link_path_unix: RcStr = sys_to_unix(&link_path_string_cow).into();\n             (\n                 link_path_unix.clone(),\n-                fs_path.parent().join(link_path_unix).get_type().await?,\n+                fs_path.parent().join(&link_path_unix)?.get_type().await?,\n             )\n         };\n \n@@ -717,7 +716,7 @@ impl FileSystem for DiskFileSystem {\n     }\n \n     #[turbo_tasks::function(fs, invalidator)]\n-    async fn write(&self, fs_path: Vc<FileSystemPath>, content: Vc<FileContent>) -> Result<()> {\n+    async fn write(&self, fs_path: FileSystemPath, content: Vc<FileContent>) -> Result<()> {\n         mark_session_dependent();\n         let full_path = self.to_sys_path(fs_path).await?;\n         let content = content.await?;\n@@ -844,7 +843,7 @@ impl FileSystem for DiskFileSystem {\n     }\n \n     #[turbo_tasks::function(fs, invalidator)]\n-    async fn write_link(&self, fs_path: Vc<FileSystemPath>, target: Vc<LinkContent>) -> Result<()> {\n+    async fn write_link(&self, fs_path: FileSystemPath, target: Vc<LinkContent>) -> Result<()> {\n         mark_session_dependent();\n         let full_path = self.to_sys_path(fs_path).await?;\n         let content = target.await?;\n@@ -967,7 +966,7 @@ impl FileSystem for DiskFileSystem {\n     }\n \n     #[turbo_tasks::function(fs, invalidator)]\n-    async fn metadata(&self, fs_path: Vc<FileSystemPath>) -> Result<Vc<FileMeta>> {\n+    async fn metadata(&self, fs_path: FileSystemPath) -> Result<Vc<FileMeta>> {\n         mark_session_dependent();\n         let full_path = self.to_sys_path(fs_path).await?;\n         self.inner.register_read_invalidator(&full_path)?;\n@@ -1026,13 +1025,27 @@ pub fn get_relative_path_to(path: &str, other_path: &str) -> String {\n     result.join(\"/\")\n }\n \n-#[turbo_tasks::value]\n-#[derive(Debug, Clone, Hash)]\n+#[turbo_tasks::value(shared)]\n+#[derive(Debug, Clone, Hash, TaskInput)]\n pub struct FileSystemPath {\n     pub fs: ResolvedVc<Box<dyn FileSystem>>,\n     pub path: RcStr,\n }\n \n+impl FileSystemPath {\n+    /// Mimics `ValueToString::to_string`.\n+    pub fn value_to_string(&self) -> Vc<RcStr> {\n+        value_to_string(self.clone())\n+    }\n+}\n+\n+#[turbo_tasks::function]\n+async fn value_to_string(path: FileSystemPath) -> Result<Vc<RcStr>> {\n+    Ok(Vc::cell(\n+        format!(\"[{}]/{}\", path.fs.to_string().await?, path.path).into(),\n+    ))\n+}\n+\n impl FileSystemPath {\n     pub fn is_inside_ref(&self, other: &FileSystemPath) -> bool {\n         if self.fs == other.fs && self.path.starts_with(&*other.path) {\n@@ -1148,7 +1161,7 @@ impl FileSystemPath {\n }\n \n #[turbo_tasks::value(transparent)]\n-pub struct FileSystemPathOption(Option<ResolvedVc<FileSystemPath>>);\n+pub struct FileSystemPathOption(Option<FileSystemPath>);\n \n #[turbo_tasks::value_impl]\n impl FileSystemPathOption {\n@@ -1158,13 +1171,11 @@ impl FileSystemPathOption {\n     }\n }\n \n-#[turbo_tasks::value_impl]\n impl FileSystemPath {\n-    /// Create a new Vc<FileSystemPath> from a path withing a FileSystem. The\n+    /// Create a new FileSystemPath from a path withing a FileSystem. The\n     /// /-separated path is expected to be already normalized (this is asserted\n     /// in dev mode).\n-    #[turbo_tasks::function]\n-    fn new_normalized(fs: ResolvedVc<Box<dyn FileSystem>>, path: RcStr) -> Vc<Self> {\n+    fn new_normalized(fs: ResolvedVc<Box<dyn FileSystem>>, path: RcStr) -> Self {\n         // On Windows, the path must be converted to a unix path before creating. But on\n         // Unix, backslashes are a valid char in file names, and the path can be\n         // provided by the user, so we allow it.\n@@ -1177,28 +1188,26 @@ impl FileSystemPath {\n             normalize_path(&path).as_deref() == Some(&*path),\n             \"path {path} must be normalized\",\n         );\n-        Self::cell(FileSystemPath { fs, path })\n+        FileSystemPath { fs, path }\n     }\n \n     /// Adds a subpath to the current path. The /-separate path argument might\n     /// contain \"..\" or \".\" seqments, but it must not leave the root of the\n     /// filesystem.\n-    #[turbo_tasks::function]\n-    pub fn join(&self, path: RcStr) -> Result<Vc<Self>> {\n-        if let Some(path) = join_path(&self.path, &path) {\n-            Ok(Self::new_normalized(*self.fs, path.into()))\n+    pub fn join(&self, path: &str) -> Result<Self> {\n+        if let Some(path) = join_path(&self.path, path) {\n+            Ok(Self::new_normalized(self.fs, path.into()))\n         } else {\n             bail!(\n-                \"Vc<FileSystemPath>(\\\"{}\\\").join(\\\"{}\\\") leaves the filesystem root\",\n+                \"FileSystemPath(\\\"{}\\\").join(\\\"{}\\\") leaves the filesystem root\",\n                 self.path,\n                 path\n             );\n         }\n     }\n \n     /// Adds a suffix to the filename. [path] must not contain `/`.\n-    #[turbo_tasks::function]\n-    pub fn append(&self, path: RcStr) -> Result<Vc<Self>> {\n+    pub fn append(&self, path: &str) -> Result<Self> {\n         if path.contains('/') {\n             bail!(\n                 \"FileSystemPath(\\\"{}\\\").append(\\\"{}\\\") must not append '/'\",\n@@ -1207,15 +1216,14 @@ impl FileSystemPath {\n             )\n         }\n         Ok(Self::new_normalized(\n-            *self.fs,\n+            self.fs,\n             format!(\"{}{}\", self.path, path).into(),\n         ))\n     }\n \n     /// Adds a suffix to the basename of the filename. [appending] must not\n     /// contain `/`. Extension will stay intact.\n-    #[turbo_tasks::function]\n-    pub fn append_to_stem(&self, appending: RcStr) -> Result<Vc<Self>> {\n+    pub fn append_to_stem(&self, appending: &str) -> Result<Self> {\n         if appending.contains('/') {\n             bail!(\n                 \"FileSystemPath(\\\"{}\\\").append_to_stem(\\\"{}\\\") must not append '/'\",\n@@ -1225,95 +1233,80 @@ impl FileSystemPath {\n         }\n         if let (path, Some(ext)) = self.split_extension() {\n             return Ok(Self::new_normalized(\n-                *self.fs,\n+                self.fs,\n                 format!(\"{path}{appending}.{ext}\").into(),\n             ));\n         }\n         Ok(Self::new_normalized(\n-            *self.fs,\n+            self.fs,\n             format!(\"{}{}\", self.path, appending).into(),\n         ))\n     }\n \n     /// Similar to [FileSystemPath::join], but returns an Option that will be\n     /// None when the joined path would leave the filesystem root.\n-    #[turbo_tasks::function]\n-    pub async fn try_join(&self, path: RcStr) -> Result<Vc<FileSystemPathOption>> {\n+    #[allow(clippy::needless_borrow)] // for windows build\n+    pub fn try_join(&self, path: &str) -> Result<Option<FileSystemPath>> {\n         // TODO(PACK-3279): Remove this once we do not produce invalid paths at the first place.\n         #[cfg(target_os = \"windows\")]\n         let path = path.replace('\\\\', \"/\");\n \n         if let Some(path) = join_path(&self.path, &path) {\n-            Ok(Vc::cell(Some(\n-                Self::new_normalized(*self.fs, path.into())\n-                    .to_resolved()\n-                    .await?,\n-            )))\n+            Ok(Some(Self::new_normalized(self.fs, path.into())))\n         } else {\n-            Ok(FileSystemPathOption::none())\n+            Ok(None)\n         }\n     }\n \n     /// Similar to [FileSystemPath::join], but returns an Option that will be\n     /// None when the joined path would leave the current path.\n-    #[turbo_tasks::function]\n-    pub async fn try_join_inside(&self, path: RcStr) -> Result<Vc<FileSystemPathOption>> {\n-        if let Some(path) = join_path(&self.path, &path)\n+    pub fn try_join_inside(&self, path: &str) -> Result<Option<FileSystemPath>> {\n+        if let Some(path) = join_path(&self.path, path)\n             && path.starts_with(&*self.path)\n         {\n-            return Ok(Vc::cell(Some(\n-                Self::new_normalized(*self.fs, path.into())\n-                    .to_resolved()\n-                    .await?,\n-            )));\n+            return Ok(Some(Self::new_normalized(self.fs, path.into())));\n         }\n-        Ok(FileSystemPathOption::none())\n+        Ok(None)\n     }\n \n-    #[turbo_tasks::function]\n-    pub async fn read_glob(self: Vc<Self>, glob: Vc<Glob>) -> Result<Vc<ReadGlobResult>> {\n-        read_glob(self, glob).await\n+    pub fn read_glob(&self, glob: Vc<Glob>) -> Vc<ReadGlobResult> {\n+        read_glob(self.clone(), glob)\n     }\n \n     // Tracks all files and directories matching the glob\n     // Follows symlinks as though they were part of the original hierarchy.\n-    #[turbo_tasks::function]\n-    pub fn track_glob(self: Vc<Self>, glob: Vc<Glob>, include_dot_files: bool) -> Vc<Completion> {\n-        track_glob(self, glob, include_dot_files)\n+    pub fn track_glob(&self, glob: Vc<Glob>, include_dot_files: bool) -> Vc<Completion> {\n+        track_glob(self.clone(), glob, include_dot_files)\n     }\n \n-    #[turbo_tasks::function]\n-    pub fn root(self: Vc<Self>) -> Vc<Self> {\n+    pub fn root(&self) -> Vc<Self> {\n         self.fs().root()\n     }\n+}\n \n-    #[turbo_tasks::function]\n+impl FileSystemPath {\n     pub fn fs(&self) -> Vc<Box<dyn FileSystem>> {\n         *self.fs\n     }\n \n-    #[turbo_tasks::function]\n-    pub fn extension(&self) -> Vc<RcStr> {\n-        Vc::cell(self.extension_ref().map(RcStr::from).unwrap_or_default())\n+    pub fn extension(&self) -> &str {\n+        self.extension_ref().unwrap_or_default()\n     }\n \n-    #[turbo_tasks::function]\n-    pub async fn is_inside(&self, other: Vc<FileSystemPath>) -> Result<Vc<bool>> {\n-        Ok(Vc::cell(self.is_inside_ref(&*other.await?)))\n+    pub fn is_inside(&self, other: &FileSystemPath) -> bool {\n+        self.is_inside_ref(other)\n     }\n \n-    #[turbo_tasks::function]\n-    pub async fn is_inside_or_equal(&self, other: Vc<FileSystemPath>) -> Result<Vc<bool>> {\n-        Ok(Vc::cell(self.is_inside_or_equal_ref(&*other.await?)))\n+    pub fn is_inside_or_equal(&self, other: &FileSystemPath) -> bool {\n+        self.is_inside_or_equal_ref(other)\n     }\n \n-    /// Creates a new [`Vc<FileSystemPath>`] like `self` but with the given\n+    /// Creates a new [`FileSystemPath`] like `self` but with the given\n     /// extension.\n-    #[turbo_tasks::function]\n-    pub fn with_extension(&self, extension: RcStr) -> Vc<FileSystemPath> {\n+    pub fn with_extension(&self, extension: &str) -> FileSystemPath {\n         let (path_without_extension, _) = self.split_extension();\n         Self::new_normalized(\n-            *self.fs,\n+            self.fs,\n             // Like `Path::with_extension` and `PathBuf::set_extension`, if the extension is empty,\n             // we remove the extension altogether.\n             match extension.is_empty() {\n@@ -1331,13 +1324,12 @@ impl FileSystemPath {\n     /// * The entire file name if there is no embedded `.`;\n     /// * The entire file name if the file name begins with `.` and has no other `.`s within;\n     /// * Otherwise, the portion of the file name before the final `.`\n-    #[turbo_tasks::function]\n-    pub fn file_stem(&self) -> Vc<Option<RcStr>> {\n+    pub fn file_stem(&self) -> Option<&str> {\n         let (_, file_stem, _) = self.split_file_stem_extension();\n         if file_stem.is_empty() {\n-            return Vc::cell(None);\n+            return None;\n         }\n-        Vc::cell(Some(file_stem.into()))\n+        Some(file_stem)\n     }\n }\n \n@@ -1349,13 +1341,10 @@ impl Display for FileSystemPath {\n \n #[turbo_tasks::function]\n pub async fn rebase(\n-    fs_path: Vc<FileSystemPath>,\n-    old_base: Vc<FileSystemPath>,\n-    new_base: Vc<FileSystemPath>,\n+    fs_path: FileSystemPath,\n+    old_base: FileSystemPath,\n+    new_base: FileSystemPath,\n ) -> Result<Vc<FileSystemPath>> {\n-    let fs_path = &*fs_path.await?;\n-    let old_base = &*old_base.await?;\n-    let new_base = &*new_base.await?;\n     let new_path;\n     if old_base.path.is_empty() {\n         if new_base.path.is_empty() {\n@@ -1381,115 +1370,81 @@ pub async fn rebase(\n                 .into();\n         }\n     }\n-    Ok(new_base.fs.root().join(new_path))\n+    Ok(new_base.fs.root().await?.join(&new_path)?.cell())\n }\n \n // Not turbo-tasks functions, only delegating\n impl FileSystemPath {\n-    pub fn read(self: Vc<Self>) -> Vc<FileContent> {\n-        self.fs().read(self)\n+    pub fn read(&self) -> Vc<FileContent> {\n+        self.fs().read(self.clone())\n     }\n \n-    pub fn read_link(self: Vc<Self>) -> Vc<LinkContent> {\n-        self.fs().read_link(self)\n+    pub fn read_link(&self) -> Vc<LinkContent> {\n+        self.fs().read_link(self.clone())\n     }\n \n-    pub fn read_json(self: Vc<Self>) -> Vc<FileJsonContent> {\n-        self.fs().read(self).parse_json()\n+    pub fn read_json(&self) -> Vc<FileJsonContent> {\n+        self.fs().read(self.clone()).parse_json()\n     }\n \n-    pub fn read_json5(self: Vc<Self>) -> Vc<FileJsonContent> {\n-        self.fs().read(self).parse_json5()\n+    pub fn read_json5(&self) -> Vc<FileJsonContent> {\n+        self.fs().read(self.clone()).parse_json5()\n     }\n \n     /// Reads content of a directory.\n     ///\n     /// DETERMINISM: Result is in random order. Either sort result or do not\n     /// depend on the order.\n-    pub fn raw_read_dir(self: Vc<Self>) -> Vc<RawDirectoryContent> {\n-        self.fs().raw_read_dir(self)\n+    pub fn raw_read_dir(&self) -> Vc<RawDirectoryContent> {\n+        self.fs().raw_read_dir(self.clone())\n     }\n \n-    pub fn write(self: Vc<Self>, content: Vc<FileContent>) -> Vc<()> {\n-        self.fs().write(self, content)\n+    pub fn write(&self, content: Vc<FileContent>) -> Vc<()> {\n+        self.fs().write(self.clone(), content)\n     }\n \n-    pub fn write_link(self: Vc<Self>, target: Vc<LinkContent>) -> Vc<()> {\n-        self.fs().write_link(self, target)\n+    pub fn write_link(&self, target: Vc<LinkContent>) -> Vc<()> {\n+        self.fs().write_link(self.clone(), target)\n     }\n \n-    pub fn metadata(self: Vc<Self>) -> Vc<FileMeta> {\n-        self.fs().metadata(self)\n+    pub fn metadata(&self) -> Vc<FileMeta> {\n+        self.fs().metadata(self.clone())\n     }\n \n-    pub fn realpath(self: Vc<Self>) -> Vc<FileSystemPath> {\n+    pub fn realpath(&self) -> Vc<FileSystemPath> {\n         self.realpath_with_links().path()\n     }\n \n     pub fn rebase(\n-        fs_path: Vc<FileSystemPath>,\n-        old_base: Vc<FileSystemPath>,\n-        new_base: Vc<FileSystemPath>,\n+        fs_path: FileSystemPath,\n+        old_base: FileSystemPath,\n+        new_base: FileSystemPath,\n     ) -> Vc<FileSystemPath> {\n         rebase(fs_path, old_base, new_base)\n     }\n }\n \n-#[turbo_tasks::value_impl]\n impl FileSystemPath {\n     /// Reads content of a directory.\n     ///\n     /// DETERMINISM: Result is in random order. Either sort result or do not\n     /// depend on the order.\n-    #[turbo_tasks::function]\n-    pub async fn read_dir(self: Vc<Self>) -> Result<Vc<DirectoryContent>> {\n-        let this = self.await?;\n-        let fs = this.fs;\n-        match &*fs.raw_read_dir(self).await? {\n-            RawDirectoryContent::NotFound => Ok(DirectoryContent::not_found()),\n-            RawDirectoryContent::Entries(entries) => {\n-                let mut normalized_entries = AutoMap::new();\n-                let dir_path = &this.path;\n-                for (name, entry) in entries {\n-                    // Construct the path directly instead of going through `join`.\n-                    // We do not need to normalize since the `name` is guaranteed to be a simple\n-                    // path segment.\n-                    let path = if dir_path.is_empty() {\n-                        name.clone()\n-                    } else {\n-                        RcStr::from(format!(\"{dir_path}/{name}\"))\n-                    };\n-\n-                    let entry_path = Self::new_normalized(*fs, path).to_resolved().await?;\n-                    let entry = match entry {\n-                        RawDirectoryEntry::File => DirectoryEntry::File(entry_path),\n-                        RawDirectoryEntry::Directory => DirectoryEntry::Directory(entry_path),\n-                        RawDirectoryEntry::Symlink => DirectoryEntry::Symlink(entry_path),\n-                        RawDirectoryEntry::Other => DirectoryEntry::Other(entry_path),\n-                        RawDirectoryEntry::Error => DirectoryEntry::Error,\n-                    };\n-                    normalized_entries.insert(name.clone(), entry);\n-                }\n-                Ok(DirectoryContent::new(normalized_entries))\n-            }\n-        }\n+    pub fn read_dir(&self) -> Vc<DirectoryContent> {\n+        read_dir(self.clone())\n     }\n \n-    #[turbo_tasks::function]\n-    pub async fn parent(self: Vc<Self>) -> Result<Vc<FileSystemPath>> {\n-        let this = self.await?;\n-        let path = &this.path;\n+    pub fn parent(&self) -> FileSystemPath {\n+        let path = &self.path;\n         if path.is_empty() {\n-            return Ok(self);\n+            return self.clone();\n         }\n         let p = match str::rfind(path, '/') {\n             Some(index) => path[..index].to_string(),\n             None => \"\".to_string(),\n         };\n-        Ok(FileSystemPath::new_normalized(*this.fs, p.into()))\n+        FileSystemPath::new_normalized(self.fs, p.into())\n     }\n \n-    #[turbo_tasks::function]\n     // It is important that get_type uses read_dir and not stat/metadata.\n     // - `get_type` is called very very often during resolving and stat would\n     // make it 1 syscall per call, whereas read_dir would make it 1 syscall per\n@@ -1498,109 +1453,12 @@ impl FileSystemPath {\n     // case-insenstive filesystems, while read_dir gives you the \"correct\"\n     // casing. We want to enforce \"correct\" casing to avoid broken builds on\n     // Vercel deployments (case-sensitive).\n-    pub async fn get_type(self: Vc<Self>) -> Result<Vc<FileSystemEntryType>> {\n-        let this = self.await?;\n-        if this.is_root() {\n-            return Ok(FileSystemEntryType::cell(FileSystemEntryType::Directory));\n-        }\n-        let parent = self.parent().resolve().await?;\n-        let dir_content = parent.raw_read_dir().await?;\n-        match &*dir_content {\n-            RawDirectoryContent::NotFound => {\n-                Ok(FileSystemEntryType::cell(FileSystemEntryType::NotFound))\n-            }\n-            RawDirectoryContent::Entries(entries) => {\n-                let (_, file_name) = this.split_file_name();\n-                if let Some(entry) = entries.get(file_name) {\n-                    Ok(FileSystemEntryType::cell(entry.into()))\n-                } else {\n-                    Ok(FileSystemEntryType::cell(FileSystemEntryType::NotFound))\n-                }\n-            }\n-        }\n+    pub fn get_type(&self) -> Vc<FileSystemEntryType> {\n+        get_type(self.clone())\n     }\n \n-    #[turbo_tasks::function]\n-    pub async fn realpath_with_links(self: ResolvedVc<Self>) -> Result<Vc<RealPathResult>> {\n-        let mut current_vc = self;\n-        let mut symlinks: IndexSet<ResolvedVc<FileSystemPath>> = IndexSet::new();\n-        let mut visited: AutoSet<RcStr> = AutoSet::new();\n-        // Pick some arbitrary symlink depth limit... similar to the ELOOP logic for realpath(3).\n-        // SYMLOOP_MAX is 40 for Linux: https://unix.stackexchange.com/q/721724\n-        for _i in 0..40 {\n-            let current = current_vc.await?;\n-            if current.is_root() {\n-                // fast path\n-                return Ok(RealPathResult {\n-                    path: self,\n-                    symlinks: symlinks.into_iter().collect(),\n-                }\n-                .cell());\n-            }\n-\n-            if !visited.insert(current.path.clone()) {\n-                break; // we detected a cycle\n-            }\n-\n-            // see if a parent segment of the path is a symlink and resolve that first\n-            let parent = self.parent().to_resolved().await?;\n-            let parent_result = parent.realpath_with_links().owned().await?;\n-            let basename = current\n-                .path\n-                .rsplit_once('/')\n-                .map_or(current.path.as_str(), |(_, name)| name);\n-            if parent_result.path != parent {\n-                current_vc = parent_result\n-                    .path\n-                    .join(basename.into())\n-                    .to_resolved()\n-                    .await?;\n-            }\n-            symlinks.extend(parent_result.symlinks);\n-\n-            // use `get_type` before trying `read_link`, as there's a good chance of a cache hit on\n-            // `get_type`, and `read_link` isn't the common codepath.\n-            if !matches!(*current_vc.get_type().await?, FileSystemEntryType::Symlink) {\n-                return Ok(RealPathResult {\n-                    path: current_vc,\n-                    symlinks: symlinks.into_iter().collect(), // convert set to vec\n-                }\n-                .cell());\n-            }\n-\n-            if let LinkContent::Link { target, link_type } = &*current_vc.read_link().await? {\n-                symlinks.insert(current_vc);\n-                current_vc = if link_type.contains(LinkType::ABSOLUTE) {\n-                    current_vc.root()\n-                } else {\n-                    *parent_result.path\n-                }\n-                .join(target.clone())\n-                .to_resolved()\n-                .await?;\n-            } else {\n-                // get_type() and read_link() might disagree temporarily due to turbo-tasks\n-                // eventual consistency or if the file gets invalidated before the directory does\n-                return Ok(RealPathResult {\n-                    path: current_vc,\n-                    symlinks: symlinks.into_iter().collect(), // convert set to vec\n-                }\n-                .cell());\n-            }\n-        }\n-\n-        // Too many attempts or detected a cycle, we bailed out!\n-        //\n-        // TODO: There's no proper way to indicate an non-turbo-tasks error here, so just return the\n-        // original path and all the symlinks we followed.\n-        //\n-        // Returning the followed symlinks is still important, even if there is an error! Otherwise\n-        // we may never notice if the symlink loop is fixed.\n-        Ok(RealPathResult {\n-            path: self,\n-            symlinks: symlinks.into_iter().collect(),\n-        }\n-        .cell())\n+    pub fn realpath_with_links(&self) -> Vc<RealPathResult> {\n+        realpath_with_links(self.clone())\n     }\n }\n \n@@ -1617,15 +1475,15 @@ impl ValueToString for FileSystemPath {\n #[derive(Clone, Debug)]\n #[turbo_tasks::value(shared)]\n pub struct RealPathResult {\n-    pub path: ResolvedVc<FileSystemPath>,\n-    pub symlinks: Vec<ResolvedVc<FileSystemPath>>,\n+    pub path: FileSystemPath,\n+    pub symlinks: Vec<FileSystemPath>,\n }\n \n #[turbo_tasks::value_impl]\n impl RealPathResult {\n     #[turbo_tasks::function]\n     pub fn path(&self) -> Vc<FileSystemPath> {\n-        *self.path\n+        self.path.clone().cell()\n     }\n }\n \n@@ -1787,7 +1645,7 @@ bitflags! {\n pub enum LinkContent {\n     // for the relative link, the target is raw value read from the link\n     // for the absolute link, the target is stripped of the root path while reading\n-    // We don't use the `Vc<FileSystemPath>` here for now, because the `FileSystemPath` is always\n+    // We don't use the `FileSystemPath` here for now, because the `FileSystemPath` is always\n     // normalized, which means in `fn write_link` we couldn't restore the raw value of the file\n     // link because there is only **dist** path in `fn write_link`, and we need the raw path if\n     // we want to restore the link value in `fn write_link`\n@@ -2248,14 +2106,12 @@ pub enum RawDirectoryEntry {\n     Error,\n }\n \n-#[derive(\n-    Hash, Clone, Copy, Debug, PartialEq, Eq, TraceRawVcs, Serialize, Deserialize, NonLocalValue,\n-)]\n+#[derive(Hash, Clone, Debug, PartialEq, Eq, TraceRawVcs, Serialize, Deserialize, NonLocalValue)]\n pub enum DirectoryEntry {\n-    File(ResolvedVc<FileSystemPath>),\n-    Directory(ResolvedVc<FileSystemPath>),\n-    Symlink(ResolvedVc<FileSystemPath>),\n-    Other(ResolvedVc<FileSystemPath>),\n+    File(FileSystemPath),\n+    Directory(FileSystemPath),\n+    Symlink(FileSystemPath),\n+    Other(FileSystemPath),\n     Error,\n }\n \n@@ -2264,8 +2120,8 @@ impl DirectoryEntry {\n     /// type and replacing it with `DirectoryEntry::File` or\n     /// `DirectoryEntry::Directory`.\n     pub async fn resolve_symlink(self) -> Result<Self> {\n-        if let DirectoryEntry::Symlink(symlink) = self {\n-            let real_path = symlink.realpath().to_resolved().await?;\n+        if let DirectoryEntry::Symlink(symlink) = &self {\n+            let real_path = (*symlink.realpath().await?).clone();\n             match *real_path.get_type().await? {\n                 FileSystemEntryType::Directory => Ok(DirectoryEntry::Directory(real_path)),\n                 FileSystemEntryType::File => Ok(DirectoryEntry::File(real_path)),\n@@ -2276,7 +2132,7 @@ impl DirectoryEntry {\n         }\n     }\n \n-    pub fn path(self) -> Option<ResolvedVc<FileSystemPath>> {\n+    pub fn path(self) -> Option<FileSystemPath> {\n         match self {\n             DirectoryEntry::File(path)\n             | DirectoryEntry::Directory(path)\n@@ -2387,32 +2243,32 @@ pub struct NullFileSystem;\n #[turbo_tasks::value_impl]\n impl FileSystem for NullFileSystem {\n     #[turbo_tasks::function]\n-    fn read(&self, _fs_path: Vc<FileSystemPath>) -> Vc<FileContent> {\n+    fn read(&self, _fs_path: FileSystemPath) -> Vc<FileContent> {\n         FileContent::NotFound.cell()\n     }\n \n     #[turbo_tasks::function]\n-    fn read_link(&self, _fs_path: Vc<FileSystemPath>) -> Vc<LinkContent> {\n+    fn read_link(&self, _fs_path: FileSystemPath) -> Vc<LinkContent> {\n         LinkContent::NotFound.into()\n     }\n \n     #[turbo_tasks::function]\n-    fn raw_read_dir(&self, _fs_path: Vc<FileSystemPath>) -> Vc<RawDirectoryContent> {\n+    fn raw_read_dir(&self, _fs_path: FileSystemPath) -> Vc<RawDirectoryContent> {\n         RawDirectoryContent::not_found()\n     }\n \n     #[turbo_tasks::function]\n-    fn write(&self, _fs_path: Vc<FileSystemPath>, _content: Vc<FileContent>) -> Vc<()> {\n+    fn write(&self, _fs_path: FileSystemPath, _content: Vc<FileContent>) -> Vc<()> {\n         Vc::default()\n     }\n \n     #[turbo_tasks::function]\n-    fn write_link(&self, _fs_path: Vc<FileSystemPath>, _target: Vc<LinkContent>) -> Vc<()> {\n+    fn write_link(&self, _fs_path: FileSystemPath, _target: Vc<LinkContent>) -> Vc<()> {\n         Vc::default()\n     }\n \n     #[turbo_tasks::function]\n-    fn metadata(&self, _fs_path: Vc<FileSystemPath>) -> Vc<FileMeta> {\n+    fn metadata(&self, _fs_path: FileSystemPath) -> Vc<FileMeta> {\n         FileMeta::default().cell()\n     }\n }\n@@ -2425,10 +2281,10 @@ impl ValueToString for NullFileSystem {\n     }\n }\n \n-pub async fn to_sys_path(mut path: Vc<FileSystemPath>) -> Result<Option<PathBuf>> {\n+pub async fn to_sys_path(mut path: FileSystemPath) -> Result<Option<PathBuf>> {\n     loop {\n         if let Some(fs) = Vc::try_resolve_downcast_type::<AttachedFileSystem>(path.fs()).await? {\n-            path = fs.get_inner_fs_path(path);\n+            path = (*fs.get_inner_fs_path(path).await?).clone();\n             continue;\n         }\n \n@@ -2441,6 +2297,136 @@ pub async fn to_sys_path(mut path: Vc<FileSystemPath>) -> Result<Option<PathBuf>\n     }\n }\n \n+#[turbo_tasks::function]\n+async fn read_dir(path: FileSystemPath) -> Result<Vc<DirectoryContent>> {\n+    let fs = path.fs().to_resolved().await?;\n+    match &*fs.raw_read_dir(path.clone()).await? {\n+        RawDirectoryContent::NotFound => Ok(DirectoryContent::not_found()),\n+        RawDirectoryContent::Entries(entries) => {\n+            let mut normalized_entries = AutoMap::new();\n+            let dir_path = &path.path;\n+            for (name, entry) in entries {\n+                // Construct the path directly instead of going through `join`.\n+                // We do not need to normalize since the `name` is guaranteed to be a simple\n+                // path segment.\n+                let path = if dir_path.is_empty() {\n+                    name.clone()\n+                } else {\n+                    RcStr::from(format!(\"{dir_path}/{name}\"))\n+                };\n+\n+                let entry_path = FileSystemPath::new_normalized(fs, path);\n+                let entry = match entry {\n+                    RawDirectoryEntry::File => DirectoryEntry::File(entry_path),\n+                    RawDirectoryEntry::Directory => DirectoryEntry::Directory(entry_path),\n+                    RawDirectoryEntry::Symlink => DirectoryEntry::Symlink(entry_path),\n+                    RawDirectoryEntry::Other => DirectoryEntry::Other(entry_path),\n+                    RawDirectoryEntry::Error => DirectoryEntry::Error,\n+                };\n+                normalized_entries.insert(name.clone(), entry);\n+            }\n+            Ok(DirectoryContent::new(normalized_entries))\n+        }\n+    }\n+}\n+\n+#[turbo_tasks::function]\n+async fn get_type(path: FileSystemPath) -> Result<Vc<FileSystemEntryType>> {\n+    if path.is_root() {\n+        return Ok(FileSystemEntryType::Directory.cell());\n+    }\n+    let parent = path.parent();\n+    let dir_content = parent.raw_read_dir().await?;\n+    match &*dir_content {\n+        RawDirectoryContent::NotFound => Ok(FileSystemEntryType::NotFound.cell()),\n+        RawDirectoryContent::Entries(entries) => {\n+            let (_, file_name) = path.split_file_name();\n+            if let Some(entry) = entries.get(file_name) {\n+                Ok(FileSystemEntryType::from(entry).cell())\n+            } else {\n+                Ok(FileSystemEntryType::NotFound.cell())\n+            }\n+        }\n+    }\n+}\n+\n+#[turbo_tasks::function]\n+async fn realpath_with_links(path: FileSystemPath) -> Result<Vc<RealPathResult>> {\n+    let mut current_vc = path.clone();\n+    let mut symlinks: IndexSet<FileSystemPath> = IndexSet::new();\n+    let mut visited: AutoSet<RcStr> = AutoSet::new();\n+    // Pick some arbitrary symlink depth limit... similar to the ELOOP logic for realpath(3).\n+    // SYMLOOP_MAX is 40 for Linux: https://unix.stackexchange.com/q/721724\n+    for _i in 0..40 {\n+        let current = current_vc.clone();\n+        if current.is_root() {\n+            // fast path\n+            return Ok(RealPathResult {\n+                path: current_vc,\n+                symlinks: symlinks.into_iter().collect(),\n+            }\n+            .cell());\n+        }\n+\n+        if !visited.insert(current.path.clone()) {\n+            break; // we detected a cycle\n+        }\n+\n+        // see if a parent segment of the path is a symlink and resolve that first\n+        let parent = current_vc.parent();\n+        let parent_result = parent.realpath_with_links().owned().await?;\n+        let basename = current\n+            .path\n+            .rsplit_once('/')\n+            .map_or(current.path.as_str(), |(_, name)| name);\n+        if parent_result.path != parent {\n+            current_vc = parent_result.path.join(basename)?;\n+        }\n+        symlinks.extend(parent_result.symlinks);\n+\n+        // use `get_type` before trying `read_link`, as there's a good chance of a cache hit on\n+        // `get_type`, and `read_link` isn't the common codepath.\n+        if !matches!(*current_vc.get_type().await?, FileSystemEntryType::Symlink) {\n+            return Ok(RealPathResult {\n+                path: current_vc,\n+                symlinks: symlinks.into_iter().collect(), // convert set to vec\n+            }\n+            .cell());\n+        }\n+\n+        if let LinkContent::Link { target, link_type } = &*current_vc.read_link().await? {\n+            symlinks.insert(current_vc.clone());\n+            current_vc = if link_type.contains(LinkType::ABSOLUTE) {\n+                (*current_vc.root().await?).clone()\n+            } else {\n+                parent_result.path\n+            }\n+            .join(target)?;\n+        } else {\n+            // get_type() and read_link() might disagree temporarily due to turbo-tasks\n+            // eventual consistency or if the file gets invalidated before the directory does\n+            return Ok(RealPathResult {\n+                path: current_vc,\n+                symlinks: symlinks.into_iter().collect(), // convert set to vec\n+            }\n+            .cell());\n+        }\n+    }\n+\n+    // Too many attempts or detected a cycle, we bailed out!\n+    //\n+    // TODO: There's no proper way to indicate an non-turbo-tasks error here, so just return the\n+    // original path and all the symlinks we followed.\n+    //\n+    // Returning the followed symlinks is still important, even if there is an error! Otherwise\n+    // we may never notice if the symlink loop is fixed.\n+    Ok(RealPathResult {\n+        path,\n+        symlinks: symlinks.into_iter().collect(),\n+    }\n+    .cell())\n+}\n+\n pub fn register() {\n     turbo_tasks::register();\n     include!(concat!(env!(\"OUT_DIR\"), \"/register.rs\"));\n@@ -2473,32 +2459,31 @@ mod tests {\n         crate::register();\n \n         turbo_tasks_testing::VcStorage::with(async {\n-            let fs = Vc::upcast(VirtualFileSystem::new());\n+            let fs = Vc::upcast::<Box<dyn FileSystem>>(VirtualFileSystem::new())\n+                .to_resolved()\n+                .await?;\n \n             let path_txt = FileSystemPath::new_normalized(fs, rcstr!(\"foo/bar.txt\"));\n \n-            let path_json = path_txt.with_extension(rcstr!(\"json\"));\n-            assert_eq!(&*path_json.await.unwrap().path, \"foo/bar.json\");\n+            let path_json = path_txt.with_extension(\"json\");\n+            assert_eq!(&*path_json.path, \"foo/bar.json\");\n \n-            let path_no_ext = path_txt.with_extension(rcstr!(\"\"));\n-            assert_eq!(&*path_no_ext.await.unwrap().path, \"foo/bar\");\n+            let path_no_ext = path_txt.with_extension(\"\");\n+            assert_eq!(&*path_no_ext.path, \"foo/bar\");\n \n-            let path_new_ext = path_no_ext.with_extension(rcstr!(\"json\"));\n-            assert_eq!(&*path_new_ext.await.unwrap().path, \"foo/bar.json\");\n+            let path_new_ext = path_no_ext.with_extension(\"json\");\n+            assert_eq!(&*path_new_ext.path, \"foo/bar.json\");\n \n             let path_no_slash_txt = FileSystemPath::new_normalized(fs, rcstr!(\"bar.txt\"));\n \n-            let path_no_slash_json = path_no_slash_txt.with_extension(rcstr!(\"json\"));\n-            assert_eq!(path_no_slash_json.await.unwrap().path.as_str(), \"bar.json\");\n+            let path_no_slash_json = path_no_slash_txt.with_extension(\"json\");\n+            assert_eq!(path_no_slash_json.path.as_str(), \"bar.json\");\n \n-            let path_no_slash_no_ext = path_no_slash_txt.with_extension(rcstr!(\"\"));\n-            assert_eq!(path_no_slash_no_ext.await.unwrap().path.as_str(), \"bar\");\n+            let path_no_slash_no_ext = path_no_slash_txt.with_extension(\"\");\n+            assert_eq!(path_no_slash_no_ext.path.as_str(), \"bar\");\n \n-            let path_no_slash_new_ext = path_no_slash_no_ext.with_extension(rcstr!(\"json\"));\n-            assert_eq!(\n-                path_no_slash_new_ext.await.unwrap().path.as_str(),\n-                \"bar.json\"\n-            );\n+            let path_no_slash_new_ext = path_no_slash_no_ext.with_extension(\"json\");\n+            assert_eq!(path_no_slash_new_ext.path.as_str(), \"bar.json\");\n \n             anyhow::Ok(())\n         })\n@@ -2511,22 +2496,24 @@ mod tests {\n         crate::register();\n \n         turbo_tasks_testing::VcStorage::with(async {\n-            let fs = Vc::upcast::<Box<dyn FileSystem>>(VirtualFileSystem::new());\n+            let fs = Vc::upcast::<Box<dyn FileSystem>>(VirtualFileSystem::new())\n+                .to_resolved()\n+                .await?;\n \n             let path = FileSystemPath::new_normalized(fs, rcstr!(\"\"));\n-            assert_eq!(path.file_stem().await.unwrap().as_deref(), None);\n+            assert_eq!(path.file_stem(), None);\n \n             let path = FileSystemPath::new_normalized(fs, rcstr!(\"foo/bar.txt\"));\n-            assert_eq!(path.file_stem().await.unwrap().as_deref(), Some(\"bar\"));\n+            assert_eq!(path.file_stem(), Some(\"bar\"));\n \n             let path = FileSystemPath::new_normalized(fs, rcstr!(\"bar.txt\"));\n-            assert_eq!(path.file_stem().await.unwrap().as_deref(), Some(\"bar\"));\n+            assert_eq!(path.file_stem(), Some(\"bar\"));\n \n             let path = FileSystemPath::new_normalized(fs, rcstr!(\"foo/bar\"));\n-            assert_eq!(path.file_stem().await.unwrap().as_deref(), Some(\"bar\"));\n+            assert_eq!(path.file_stem(), Some(\"bar\"));\n \n             let path = FileSystemPath::new_normalized(fs, rcstr!(\"foo/.bar\"));\n-            assert_eq!(path.file_stem().await.unwrap().as_deref(), Some(\".bar\"));\n+            assert_eq!(path.file_stem(), Some(\".bar\"));\n \n             anyhow::Ok(())\n         })"
        },
        {
            "sha": "89716aa7a7c5aeae663df6de0650f04ac37d06fa",
            "filename": "turbopack/crates/turbo-tasks-fs/src/read_glob.rs",
            "status": "modified",
            "additions": 61,
            "deletions": 62,
            "changes": 123,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fread_glob.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fread_glob.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fread_glob.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -17,17 +17,15 @@ pub struct ReadGlobResult {\n ///\n /// DETERMINISM: Result is in random order. Either sort result or do not depend\n /// on the order.\n-pub async fn read_glob(\n-    directory: Vc<FileSystemPath>,\n-    glob: Vc<Glob>,\n-) -> Result<Vc<ReadGlobResult>> {\n+#[turbo_tasks::function(fs)]\n+pub async fn read_glob(directory: FileSystemPath, glob: Vc<Glob>) -> Result<Vc<ReadGlobResult>> {\n     read_glob_internal(\"\", directory, glob).await\n }\n \n #[turbo_tasks::function(fs)]\n async fn read_glob_inner(\n     prefix: RcStr,\n-    directory: Vc<FileSystemPath>,\n+    directory: FileSystemPath,\n     glob: Vc<Glob>,\n ) -> Result<Vc<ReadGlobResult>> {\n     read_glob_internal(&prefix, directory, glob).await\n@@ -36,7 +34,7 @@ async fn read_glob_inner(\n // The `prefix` represents the relative directory path where symlinks are not resolve.\n async fn read_glob_internal(\n     prefix: &str,\n-    directory: Vc<FileSystemPath>,\n+    directory: FileSystemPath,\n     glob: Vc<Glob>,\n ) -> Result<Vc<ReadGlobResult>> {\n     let dir = directory.read_dir().await?;\n@@ -52,16 +50,16 @@ async fn read_glob_internal(\n                 } else {\n                     format!(\"{prefix}/{segment}\").into()\n                 };\n-                let entry = resolve_symlink_safely(entry).await?;\n+                let entry = resolve_symlink_safely(entry.clone()).await?;\n                 if glob_value.matches(&entry_path) {\n-                    result.results.insert(entry_path.to_string(), entry);\n+                    result.results.insert(entry_path.to_string(), entry.clone());\n                 }\n                 if let DirectoryEntry::Directory(path) = entry\n                     && glob_value.can_match_in_directory(&entry_path)\n                 {\n                     result.inner.insert(\n                         entry_path.to_string(),\n-                        read_glob_inner(entry_path, *path, glob)\n+                        read_glob_inner(entry_path, path.clone(), glob)\n                             .to_resolved()\n                             .await?,\n                     );\n@@ -74,9 +72,9 @@ async fn read_glob_internal(\n }\n \n // Resolve a symlink checking for recursion.\n-async fn resolve_symlink_safely(entry: &DirectoryEntry) -> Result<DirectoryEntry> {\n-    let resolved_entry = entry.resolve_symlink().await?;\n-    if resolved_entry != *entry && matches!(&resolved_entry, DirectoryEntry::Directory(_)) {\n+async fn resolve_symlink_safely(entry: DirectoryEntry) -> Result<DirectoryEntry> {\n+    let resolved_entry = entry.clone().resolve_symlink().await?;\n+    if resolved_entry != entry && matches!(&resolved_entry, DirectoryEntry::Directory(_)) {\n         // We followed a symlink to a directory\n         // To prevent an infinite loop, which in the case of turbo-tasks would simply\n         // exhaust RAM or go into an infinite loop with the GC we need to check for a\n@@ -86,13 +84,10 @@ async fn resolve_symlink_safely(entry: &DirectoryEntry) -> Result<DirectoryEntry\n         // ancestor of the current path, which can be detected via a simple prefix\n         // match.\n         let source_path = entry.path().unwrap();\n-        if *source_path\n-            .is_inside_or_equal(*resolved_entry.path().unwrap())\n-            .await?\n-        {\n+        if source_path.is_inside_or_equal(&resolved_entry.clone().path().unwrap()) {\n             bail!(\n                 \"'{}' is a symlink causes that causes an infinite loop!\",\n-                source_path.await?.path.to_string()\n+                source_path.path.to_string()\n             )\n         }\n     }\n@@ -106,7 +101,7 @@ async fn resolve_symlink_safely(entry: &DirectoryEntry) -> Result<DirectoryEntry\n ///  but unlike read_glob doesn't accumulate data.\n #[turbo_tasks::function(fs)]\n pub async fn track_glob(\n-    directory: Vc<FileSystemPath>,\n+    directory: FileSystemPath,\n     glob: Vc<Glob>,\n     include_dot_files: bool,\n ) -> Result<Vc<Completion>> {\n@@ -116,7 +111,7 @@ pub async fn track_glob(\n #[turbo_tasks::function(fs)]\n async fn track_glob_inner(\n     prefix: RcStr,\n-    directory: Vc<FileSystemPath>,\n+    directory: FileSystemPath,\n     glob: Vc<Glob>,\n     include_dot_files: bool,\n ) -> Result<Vc<Completion>> {\n@@ -125,7 +120,7 @@ async fn track_glob_inner(\n \n async fn track_glob_internal(\n     prefix: &str,\n-    directory: Vc<FileSystemPath>,\n+    directory: FileSystemPath,\n     glob: Vc<Glob>,\n     include_dot_files: bool,\n ) -> Result<Vc<Completion>> {\n@@ -149,28 +144,27 @@ async fn track_glob_internal(\n                     format!(\"{prefix}/{segment}\").into()\n                 };\n \n-                match resolve_symlink_safely(entry).await? {\n+                match resolve_symlink_safely(entry.clone()).await? {\n                     DirectoryEntry::Directory(path) => {\n                         if glob_value.can_match_in_directory(&entry_path) {\n                             completions.push(track_glob_inner(\n                                 entry_path,\n-                                *path,\n+                                path.clone(),\n                                 glob,\n                                 include_dot_files,\n                             ));\n                         }\n                     }\n                     DirectoryEntry::File(path) => {\n                         if glob_value.matches(&entry_path) {\n-                            reads.push(fs.read(*path))\n+                            reads.push(fs.read(path.clone()))\n                         }\n                     }\n                     DirectoryEntry::Symlink(symlink_path) => unreachable!(\n                         \"resolve_symlink_safely() should have resolved all symlinks, but found \\\n                          unresolved symlink at path: '{}'. Found path: '{}'. Please report this \\\n                          as a bug.\",\n-                        entry_path,\n-                        symlink_path.await?\n+                        entry_path, symlink_path\n                     ),\n                     DirectoryEntry::Other(path) => {\n                         if glob_value.matches(&entry_path) {\n@@ -200,7 +194,7 @@ pub mod tests {\n     };\n \n     use turbo_rcstr::RcStr;\n-    use turbo_tasks::{Completion, ReadRef, ResolvedVc, Vc, apply_effects};\n+    use turbo_tasks::{Completion, ReadRef, Vc, apply_effects};\n     use turbo_tasks_backend::{BackendOptions, TurboTasksBackend, noop_backing_storage};\n \n     use crate::{\n@@ -235,34 +229,34 @@ pub mod tests {\n                 path,\n                 Vec::new(),\n             ));\n-            let read_dir = fs.root().read_glob(Glob::new(\"**\".into())).await.unwrap();\n+            let read_dir = fs\n+                .root()\n+                .await?\n+                .read_glob(Glob::new(\"**\".into()))\n+                .await\n+                .unwrap();\n             assert_eq!(read_dir.results.len(), 2);\n             assert_eq!(\n                 read_dir.results.get(\"foo\"),\n-                Some(&DirectoryEntry::File(\n-                    fs.root().join(\"foo\".into()).to_resolved().await?\n-                ))\n+                Some(&DirectoryEntry::File(fs.root().await?.join(\"foo\")?))\n             );\n             assert_eq!(\n                 read_dir.results.get(\"sub\"),\n-                Some(&DirectoryEntry::Directory(\n-                    fs.root().join(\"sub\".into()).to_resolved().await?\n-                ))\n+                Some(&DirectoryEntry::Directory(fs.root().await?.join(\"sub\")?))\n             );\n             assert_eq!(read_dir.inner.len(), 1);\n             let inner = &*read_dir.inner.get(\"sub\").unwrap().await?;\n             assert_eq!(inner.results.len(), 1);\n             assert_eq!(\n                 inner.results.get(\"sub/bar\"),\n-                Some(&DirectoryEntry::File(\n-                    fs.root().join(\"sub/bar\".into()).to_resolved().await?\n-                ))\n+                Some(&DirectoryEntry::File(fs.root().await?.join(\"sub/bar\")?))\n             );\n             assert_eq!(inner.inner.len(), 0);\n \n             // Now with a more specific pattern\n             let read_dir = fs\n                 .root()\n+                .await?\n                 .read_glob(Glob::new(\"**/bar\".into()))\n                 .await\n                 .unwrap();\n@@ -272,9 +266,7 @@ pub mod tests {\n             assert_eq!(inner.results.len(), 1);\n             assert_eq!(\n                 inner.results.get(\"sub/bar\"),\n-                Some(&DirectoryEntry::File(\n-                    fs.root().join(\"sub/bar\".into()).to_resolved().await?\n-                ))\n+                Some(&DirectoryEntry::File(fs.root().await?.join(\"sub/bar\")?))\n             );\n             assert_eq!(inner.inner.len(), 0);\n \n@@ -311,13 +303,16 @@ pub mod tests {\n                 path,\n                 Vec::new(),\n             ));\n-            let read_dir = fs.root().read_glob(Glob::new(\"*.js\".into())).await.unwrap();\n+            let read_dir = fs\n+                .root()\n+                .await?\n+                .read_glob(Glob::new(\"*.js\".into()))\n+                .await\n+                .unwrap();\n             assert_eq!(read_dir.results.len(), 1);\n             assert_eq!(\n                 read_dir.results.get(\"link.js\"),\n-                Some(&DirectoryEntry::File(\n-                    fs.root().join(\"sub/foo.js\".into()).to_resolved().await?\n-                ))\n+                Some(&DirectoryEntry::File(fs.root().await?.join(\"sub/foo.js\")?))\n             );\n             assert_eq!(read_dir.inner.len(), 0);\n \n@@ -328,13 +323,13 @@ pub mod tests {\n     }\n \n     #[turbo_tasks::function(operation)]\n-    pub async fn delete(path: ResolvedVc<FileSystemPath>) -> anyhow::Result<()> {\n+    pub async fn delete(path: FileSystemPath) -> anyhow::Result<()> {\n         path.write(FileContent::NotFound.cell()).await?;\n         Ok(())\n     }\n \n     #[turbo_tasks::function(operation)]\n-    pub async fn write(path: ResolvedVc<FileSystemPath>, contents: RcStr) -> anyhow::Result<()> {\n+    pub async fn write(path: FileSystemPath, contents: RcStr) -> anyhow::Result<()> {\n         path.write(\n             FileContent::Content(crate::File::from_bytes(contents.to_string().into_bytes())).cell(),\n         )\n@@ -343,7 +338,7 @@ pub mod tests {\n     }\n \n     #[turbo_tasks::function(operation)]\n-    pub fn track_star_star_glob(path: ResolvedVc<FileSystemPath>) -> Vc<Completion> {\n+    pub fn track_star_star_glob(path: FileSystemPath) -> Vc<Completion> {\n         path.track_glob(Glob::new(\"**\".into()), false)\n     }\n \n@@ -393,42 +388,42 @@ pub mod tests {\n                 path,\n                 Vec::new(),\n             ));\n-            let dir = fs.root().join(\"dir\".into()).to_resolved().await?;\n-            let read_dir = track_star_star_glob(dir).read_strongly_consistent().await?;\n+            let dir = fs.root().await?.join(\"dir\")?;\n+            let read_dir = track_star_star_glob(dir.clone())\n+                .read_strongly_consistent()\n+                .await?;\n \n             // Delete a file that we shouldn't be tracking\n-            let delete_result = delete(\n-                fs.root()\n-                    .join(\"dir/sub/.vim/.gitignore\".into())\n-                    .to_resolved()\n-                    .await?,\n-            );\n+            let delete_result = delete(fs.root().await?.join(\"dir/sub/.vim/.gitignore\")?);\n             delete_result.read_strongly_consistent().await?;\n             apply_effects(delete_result).await?;\n \n-            let read_dir2 = track_star_star_glob(dir).read_strongly_consistent().await?;\n+            let read_dir2 = track_star_star_glob(dir.clone())\n+                .read_strongly_consistent()\n+                .await?;\n             assert!(ReadRef::ptr_eq(&read_dir, &read_dir2));\n \n             // Delete a file that we should be tracking\n-            let delete_result = delete(fs.root().join(\"dir/foo\".into()).to_resolved().await?);\n+            let delete_result = delete(fs.root().await?.join(\"dir/foo\")?);\n             delete_result.read_strongly_consistent().await?;\n             apply_effects(delete_result).await?;\n \n-            let read_dir2 = track_star_star_glob(dir).read_strongly_consistent().await?;\n+            let read_dir2 = track_star_star_glob(dir.clone())\n+                .read_strongly_consistent()\n+                .await?;\n \n             assert!(!ReadRef::ptr_eq(&read_dir, &read_dir2));\n \n             // Modify a symlink target file\n             let write_result = write(\n-                fs.root()\n-                    .join(\"link_target.js\".into())\n-                    .to_resolved()\n-                    .await?,\n+                fs.root().await?.join(\"link_target.js\")?,\n                 \"new_contents\".into(),\n             );\n             write_result.read_strongly_consistent().await?;\n             apply_effects(write_result).await?;\n-            let read_dir3 = track_star_star_glob(dir).read_strongly_consistent().await?;\n+            let read_dir3 = track_star_star_glob(dir.clone())\n+                .read_strongly_consistent()\n+                .await?;\n \n             assert!(!ReadRef::ptr_eq(&read_dir3, &read_dir2));\n \n@@ -469,6 +464,7 @@ pub mod tests {\n             ));\n             let err = fs\n                 .root()\n+                .await?\n                 .track_glob(Glob::new(\"**\".into()), false)\n                 .await\n                 .expect_err(\"Should have detected an infinite loop\");\n@@ -481,6 +477,7 @@ pub mod tests {\n             // Same when calling track glob\n             let err = fs\n                 .root()\n+                .await?\n                 .track_glob(Glob::new(\"**\".into()), false)\n                 .await\n                 .expect_err(\"Should have detected an infinite loop\");\n@@ -527,6 +524,7 @@ pub mod tests {\n             ));\n             let err = fs\n                 .root()\n+                .await?\n                 .read_glob(Glob::new(\"**\".into()))\n                 .await\n                 .expect_err(\"Should have detected an infinite loop\");\n@@ -539,6 +537,7 @@ pub mod tests {\n             // Same when calling track glob\n             let err = fs\n                 .root()\n+                .await?\n                 .track_glob(Glob::new(\"**\".into()), false)\n                 .await\n                 .expect_err(\"Should have detected an infinite loop\");"
        },
        {
            "sha": "c72853f6d099ead75da9a31efc5f7bfbd91db5d3",
            "filename": "turbopack/crates/turbo-tasks-fs/src/util.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Futil.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Futil.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Futil.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -138,7 +138,7 @@ pub fn extract_disk_access<T>(value: io::Result<T>, path: &Path) -> Result<Optio\n }\n \n #[cfg(not(target_os = \"windows\"))]\n-pub async fn uri_from_file(root: Vc<FileSystemPath>, path: Option<&str>) -> Result<String> {\n+pub async fn uri_from_file(root: FileSystemPath, path: Option<&str>) -> Result<String> {\n     let root_fs = root.fs();\n     let root_fs = &*Vc::try_resolve_downcast_type::<DiskFileSystem>(root_fs)\n         .await?\n@@ -150,7 +150,7 @@ pub async fn uri_from_file(root: Vc<FileSystemPath>, path: Option<&str>) -> Resu\n         &sys_to_unix(\n             &root_fs\n                 .to_sys_path(match path {\n-                    Some(path) => root.join(path.into()),\n+                    Some(path) => root.join(path)?,\n                     None => root,\n                 })\n                 .await?\n@@ -164,7 +164,7 @@ pub async fn uri_from_file(root: Vc<FileSystemPath>, path: Option<&str>) -> Resu\n }\n \n #[cfg(target_os = \"windows\")]\n-pub async fn uri_from_file(root: Vc<FileSystemPath>, path: Option<&str>) -> Result<String> {\n+pub async fn uri_from_file(root: FileSystemPath, path: Option<&str>) -> Result<String> {\n     let root_fs = root.fs();\n     let root_fs = &*Vc::try_resolve_downcast_type::<DiskFileSystem>(root_fs)\n         .await?\n@@ -173,7 +173,7 @@ pub async fn uri_from_file(root: Vc<FileSystemPath>, path: Option<&str>) -> Resu\n \n     let sys_path = root_fs\n         .to_sys_path(match path {\n-            Some(path) => root.join(path.into()),\n+            Some(path) => root.join(path.into())?,\n             None => root,\n         })\n         .await?;"
        },
        {
            "sha": "fa84c745472c43decb1550e0e109aaf4f1427b3a",
            "filename": "turbopack/crates/turbo-tasks-fs/src/virtual_fs.rs",
            "status": "modified",
            "additions": 10,
            "deletions": 10,
            "changes": 20,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fvirtual_fs.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fvirtual_fs.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fvirtual_fs.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -15,9 +15,9 @@ impl VirtualFileSystem {\n     ///\n     /// NOTE: This function is not a `turbo_tasks::function` to avoid instances\n     /// being equivalent identity-wise. This ensures that a\n-    /// [`Vc<FileSystemPath>`] created from this [`Vc<VirtualFileSystem>`]\n+    /// [`FileSystemPath`] created from this [`Vc<VirtualFileSystem>`]\n     /// will never be equivalent, nor be interoperable, with a\n-    /// [`Vc<FileSystemPath>`] created from another\n+    /// [`FileSystemPath`] created from another\n     /// [`Vc<VirtualFileSystem>`].\n     pub fn new() -> Vc<Self> {\n         Self::cell(VirtualFileSystem {\n@@ -29,9 +29,9 @@ impl VirtualFileSystem {\n     ///\n     /// NOTE: This function is not a `turbo_tasks::function` to avoid instances\n     /// being equivalent identity-wise. This ensures that a\n-    /// [`Vc<FileSystemPath>`] created from this [`Vc<VirtualFileSystem>`]\n+    /// [`FileSystemPath`] created from this [`Vc<VirtualFileSystem>`]\n     /// will never be equivalent, nor be interoperable, with a\n-    /// [`Vc<FileSystemPath>`] created from another\n+    /// [`FileSystemPath`] created from another\n     /// [`Vc<VirtualFileSystem>`].\n     pub fn new_with_name(name: RcStr) -> Vc<Self> {\n         Self::cell(VirtualFileSystem { name })\n@@ -47,32 +47,32 @@ impl ValueDefault for VirtualFileSystem {\n #[turbo_tasks::value_impl]\n impl FileSystem for VirtualFileSystem {\n     #[turbo_tasks::function]\n-    fn read(&self, _fs_path: Vc<FileSystemPath>) -> Result<Vc<FileContent>> {\n+    fn read(&self, _fs_path: FileSystemPath) -> Result<Vc<FileContent>> {\n         bail!(\"Reading is not possible on the virtual file system\")\n     }\n \n     #[turbo_tasks::function]\n-    fn read_link(&self, _fs_path: Vc<FileSystemPath>) -> Result<Vc<LinkContent>> {\n+    fn read_link(&self, _fs_path: FileSystemPath) -> Result<Vc<LinkContent>> {\n         bail!(\"Reading is not possible on the virtual file system\")\n     }\n \n     #[turbo_tasks::function]\n-    fn raw_read_dir(&self, _fs_path: Vc<FileSystemPath>) -> Result<Vc<RawDirectoryContent>> {\n+    fn raw_read_dir(&self, _fs_path: FileSystemPath) -> Result<Vc<RawDirectoryContent>> {\n         bail!(\"Reading is not possible on the virtual file system\")\n     }\n \n     #[turbo_tasks::function]\n-    fn write(&self, _fs_path: Vc<FileSystemPath>, _content: Vc<FileContent>) -> Result<Vc<()>> {\n+    fn write(&self, _fs_path: FileSystemPath, _content: Vc<FileContent>) -> Result<Vc<()>> {\n         bail!(\"Writing is not possible on the virtual file system\")\n     }\n \n     #[turbo_tasks::function]\n-    fn write_link(&self, _fs_path: Vc<FileSystemPath>, _target: Vc<LinkContent>) -> Result<Vc<()>> {\n+    fn write_link(&self, _fs_path: FileSystemPath, _target: Vc<LinkContent>) -> Result<Vc<()>> {\n         bail!(\"Writing is not possible on the virtual file system\")\n     }\n \n     #[turbo_tasks::function]\n-    fn metadata(&self, _fs_path: Vc<FileSystemPath>) -> Result<Vc<FileMeta>> {\n+    fn metadata(&self, _fs_path: FileSystemPath) -> Result<Vc<FileMeta>> {\n         bail!(\"Reading is not possible on the virtual file system\")\n     }\n }"
        },
        {
            "sha": "d23c7fe675b58e6a9a483ccfb3b93636ee242b63",
            "filename": "turbopack/crates/turbo-tasks-fuzz/src/main.rs",
            "status": "modified",
            "additions": 11,
            "deletions": 9,
            "changes": 20,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbo-tasks-fuzz%2Fsrc%2Fmain.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbo-tasks-fuzz%2Fsrc%2Fmain.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fuzz%2Fsrc%2Fmain.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -82,9 +82,11 @@ async fn fuzz_fs_watcher(args: FsWatcher) -> anyhow::Result<()> {\n         let project_fs = disk_file_system_operation(fs_root_rcstr.clone())\n             .resolve_strongly_consistent()\n             .await?;\n-        let project_root = disk_file_system_root_operation(project_fs)\n+        let project_root = (*disk_file_system_root_operation(project_fs)\n             .resolve_strongly_consistent()\n-            .await?;\n+            .await?\n+            .await?)\n+            .clone();\n         create_directory_tree(&mut FxHashSet::default(), &fs_root, args.depth, args.width)?;\n \n         project_fs.await?.start_watching(None).await?;\n@@ -153,9 +155,9 @@ fn disk_file_system_root_operation(fs: ResolvedVc<DiskFileSystem>) -> Vc<FileSys\n #[turbo_tasks::function]\n async fn read_path(\n     invalidations: TransientInstance<PathInvalidations>,\n-    path: ResolvedVc<FileSystemPath>,\n+    path: FileSystemPath,\n ) -> anyhow::Result<()> {\n-    let path_str = path.await?.path.clone();\n+    let path_str = path.path.clone();\n     invalidations.0.lock().unwrap().insert(path_str);\n     let _ = path.read().await?;\n     Ok(())\n@@ -164,21 +166,21 @@ async fn read_path(\n #[turbo_tasks::function(operation)]\n async fn read_all_paths_operation(\n     invalidations: TransientInstance<PathInvalidations>,\n-    root: ResolvedVc<FileSystemPath>,\n+    root: FileSystemPath,\n     depth: usize,\n     width: usize,\n ) -> anyhow::Result<()> {\n     async fn read_all_paths_inner(\n         invalidations: TransientInstance<PathInvalidations>,\n-        parent: ResolvedVc<FileSystemPath>,\n+        parent: FileSystemPath,\n         depth: usize,\n         width: usize,\n     ) -> anyhow::Result<()> {\n         for child_id in 0..width {\n-            let child_name = RcStr::from(child_id.to_string());\n-            let child_path = parent.join(child_name).to_resolved().await?;\n+            let child_name = child_id.to_string();\n+            let child_path = parent.join(&child_name)?;\n             if depth == 1 {\n-                read_path(invalidations.clone(), *child_path).await?;\n+                read_path(invalidations.clone(), child_path).await?;\n             } else {\n                 Box::pin(read_all_paths_inner(\n                     invalidations.clone(),"
        },
        {
            "sha": "7d89ef7dcad5592c67c8e112777dbe0c65d0a470",
            "filename": "turbopack/crates/turbo-tasks/src/read_ref.rs",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fread_ref.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fread_ref.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fread_ref.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -42,6 +42,15 @@ where\n     }\n }\n \n+impl<T> ReadRef<T>\n+where\n+    T: VcValueType + Clone,\n+{\n+    pub fn clone_value(&self) -> VcReadTarget<T> {\n+        T::Read::value_to_target((*self.0).clone())\n+    }\n+}\n+\n impl<T> Display for ReadRef<T>\n where\n     T: VcValueType,"
        },
        {
            "sha": "2408a80fb7f4bcb0c0c166f35d36b155f12ece7b",
            "filename": "turbopack/crates/turbopack-browser/src/chunking_context.rs",
            "status": "modified",
            "additions": 21,
            "deletions": 21,
            "changes": 42,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fchunking_context.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fchunking_context.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fchunking_context.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -181,19 +181,19 @@ impl BrowserChunkingContextBuilder {\n pub struct BrowserChunkingContext {\n     name: Option<RcStr>,\n     /// The root path of the project\n-    root_path: ResolvedVc<FileSystemPath>,\n+    root_path: FileSystemPath,\n     /// Whether to write file sources as file:// paths in source maps\n     should_use_file_source_map_uris: bool,\n     /// This path is used to compute the url to request chunks from\n-    output_root: ResolvedVc<FileSystemPath>,\n+    output_root: FileSystemPath,\n     /// The relative path from the output_root to the root_path.\n     output_root_to_root_path: RcStr,\n     /// This path is used to compute the url to request assets from\n-    client_root: ResolvedVc<FileSystemPath>,\n+    client_root: FileSystemPath,\n     /// Chunks are placed at this path\n-    chunk_root_path: ResolvedVc<FileSystemPath>,\n+    chunk_root_path: FileSystemPath,\n     /// Static assets are placed at this path\n-    asset_root_path: ResolvedVc<FileSystemPath>,\n+    asset_root_path: FileSystemPath,\n     /// Base path that will be prepended to all chunk URLs when loading them.\n     /// This path will not appear in chunk paths or chunk data.\n     chunk_base_path: Option<RcStr>,\n@@ -231,12 +231,12 @@ pub struct BrowserChunkingContext {\n \n impl BrowserChunkingContext {\n     pub fn builder(\n-        root_path: ResolvedVc<FileSystemPath>,\n-        output_root: ResolvedVc<FileSystemPath>,\n+        root_path: FileSystemPath,\n+        output_root: FileSystemPath,\n         output_root_to_root_path: RcStr,\n-        client_root: ResolvedVc<FileSystemPath>,\n-        chunk_root_path: ResolvedVc<FileSystemPath>,\n-        asset_root_path: ResolvedVc<FileSystemPath>,\n+        client_root: FileSystemPath,\n+        chunk_root_path: FileSystemPath,\n+        asset_root_path: FileSystemPath,\n         environment: ResolvedVc<Environment>,\n         runtime_type: RuntimeType,\n     ) -> BrowserChunkingContextBuilder {\n@@ -376,12 +376,12 @@ impl ChunkingContext for BrowserChunkingContext {\n \n     #[turbo_tasks::function]\n     fn root_path(&self) -> Vc<FileSystemPath> {\n-        *self.root_path\n+        self.root_path.clone().cell()\n     }\n \n     #[turbo_tasks::function]\n     fn output_root(&self) -> Vc<FileSystemPath> {\n-        *self.output_root\n+        self.output_root.clone().cell()\n     }\n \n     #[turbo_tasks::function]\n@@ -396,7 +396,7 @@ impl ChunkingContext for BrowserChunkingContext {\n \n     #[turbo_tasks::function]\n     fn chunk_root_path(&self) -> Vc<FileSystemPath> {\n-        *self.chunk_root_path\n+        self.chunk_root_path.clone().cell()\n     }\n \n     #[turbo_tasks::function]\n@@ -410,11 +410,11 @@ impl ChunkingContext for BrowserChunkingContext {\n             extension.starts_with(\".\"),\n             \"`extension` should include the leading '.', got '{extension}'\"\n         );\n-        let root_path = self.chunk_root_path;\n+        let root_path = self.chunk_root_path.clone();\n         let name = match self.content_hashing {\n             None => {\n                 ident\n-                    .output_name(*self.root_path, extension)\n+                    .output_name(self.root_path.clone(), extension)\n                     .owned()\n                     .await?\n             }\n@@ -435,14 +435,14 @@ impl ChunkingContext for BrowserChunkingContext {\n                 }\n             }\n         };\n-        Ok(root_path.join(name))\n+        Ok(root_path.join(&name)?.cell())\n     }\n \n     #[turbo_tasks::function]\n-    async fn asset_url(&self, ident: Vc<FileSystemPath>) -> Result<Vc<RcStr>> {\n-        let asset_path = ident.await?.to_string();\n+    async fn asset_url(&self, ident: FileSystemPath) -> Result<Vc<RcStr>> {\n+        let asset_path = ident.to_string();\n         let asset_path = asset_path\n-            .strip_prefix(&format!(\"{}/\", self.client_root.await?.path))\n+            .strip_prefix(&format!(\"{}/\", self.client_root.path))\n             .context(\"expected asset_path to contain client_root\")?;\n \n         Ok(Vc::cell(\n@@ -493,7 +493,7 @@ impl ChunkingContext for BrowserChunkingContext {\n                 content_hash = &content_hash[..8]\n             ),\n         };\n-        Ok(self.asset_root_path.join(asset_path.into()))\n+        Ok(self.asset_root_path.join(&asset_path)?.cell())\n     }\n \n     #[turbo_tasks::function]\n@@ -668,7 +668,7 @@ impl ChunkingContext for BrowserChunkingContext {\n     #[turbo_tasks::function]\n     fn entry_chunk_group(\n         self: Vc<Self>,\n-        _path: Vc<FileSystemPath>,\n+        _path: FileSystemPath,\n         _evaluatable_assets: Vc<EvaluatableAssets>,\n         _module_graph: Vc<ModuleGraph>,\n         _extra_chunks: Vc<OutputAssets>,"
        },
        {
            "sha": "d1137f3d39f97868aa4429185376063b21fc6eb3",
            "filename": "turbopack/crates/turbopack-browser/src/ecmascript/content.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fecmascript%2Fcontent.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fecmascript%2Fcontent.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fecmascript%2Fcontent.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -60,12 +60,12 @@ impl EcmascriptBrowserChunkContent {\n #[turbo_tasks::value_impl]\n impl EcmascriptBrowserChunkContent {\n     #[turbo_tasks::function]\n-    pub(crate) fn own_version(&self) -> Vc<EcmascriptBrowserChunkVersion> {\n-        EcmascriptBrowserChunkVersion::new(\n-            self.chunking_context.output_root(),\n-            self.chunk.path(),\n+    pub(crate) async fn own_version(&self) -> Result<Vc<EcmascriptBrowserChunkVersion>> {\n+        Ok(EcmascriptBrowserChunkVersion::new(\n+            self.chunking_context.output_root().await?.clone_value(),\n+            self.chunk.path().await?.clone_value(),\n             *self.content,\n-        )\n+        ))\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "f50c9094a81be75fd9fa749385f7b2543911759c",
            "filename": "turbopack/crates/turbopack-browser/src/ecmascript/evaluate/chunk.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 2,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fecmascript%2Fevaluate%2Fchunk.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fecmascript%2Fevaluate%2Fchunk.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fecmascript%2Fevaluate%2Fchunk.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -68,8 +68,11 @@ impl EcmascriptBrowserEvaluateChunk {\n     }\n \n     #[turbo_tasks::function]\n-    fn chunks_data(&self) -> Vc<ChunksData> {\n-        ChunkData::from_assets(self.chunking_context.output_root(), *self.other_chunks)\n+    async fn chunks_data(&self) -> Result<Vc<ChunksData>> {\n+        Ok(ChunkData::from_assets(\n+            self.chunking_context.output_root().await?.clone_value(),\n+            *self.other_chunks,\n+        ))\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "9c2ab8f0574f45a79ba76ba0601386fab2fdf7fa",
            "filename": "turbopack/crates/turbopack-browser/src/ecmascript/version.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fecmascript%2Fversion.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fecmascript%2Fversion.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fecmascript%2Fversion.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -18,12 +18,12 @@ pub(super) struct EcmascriptBrowserChunkVersion {\n impl EcmascriptBrowserChunkVersion {\n     #[turbo_tasks::function]\n     pub async fn new(\n-        output_root: Vc<FileSystemPath>,\n-        chunk_path: Vc<FileSystemPath>,\n+        output_root: FileSystemPath,\n+        chunk_path: FileSystemPath,\n         content: Vc<EcmascriptChunkContent>,\n     ) -> Result<Vc<Self>> {\n-        let output_root = output_root.await?;\n-        let chunk_path = chunk_path.await?;\n+        let output_root = output_root.clone();\n+        let chunk_path = chunk_path.clone();\n         let chunk_path = if let Some(path) = output_root.get_path_to(&chunk_path) {\n             path\n         } else {"
        },
        {
            "sha": "e28ff0b7c4e6bf17cae065c95fd2383493813287",
            "filename": "turbopack/crates/turbopack-browser/src/react_refresh.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Freact_refresh.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Freact_refresh.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Freact_refresh.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -48,16 +48,16 @@ impl ResolveReactRefreshResult {\n /// given path. Emits an issue if we can't.\n #[turbo_tasks::function]\n pub async fn assert_can_resolve_react_refresh(\n-    path: ResolvedVc<FileSystemPath>,\n+    path: FileSystemPath,\n     resolve_options_context: Vc<ResolveOptionsContext>,\n ) -> Result<Vc<ResolveReactRefreshResult>> {\n     let resolve_options = apply_cjs_specific_options(turbopack_resolve::resolve::resolve_options(\n-        *path,\n+        path.clone(),\n         resolve_options_context,\n     ));\n     for request in [react_refresh_request_in_next(), react_refresh_request()] {\n         let result = turbopack_core::resolve::resolve(\n-            *path,\n+            path.clone(),\n             ReferenceType::CommonJs(CommonJsReferenceSubType::Undefined),\n             request,\n             resolve_options,\n@@ -75,7 +75,7 @@ pub async fn assert_can_resolve_react_refresh(\n /// An issue that occurred while resolving the React Refresh runtime module.\n #[turbo_tasks::value(shared)]\n pub struct ReactRefreshResolvingIssue {\n-    path: ResolvedVc<FileSystemPath>,\n+    path: FileSystemPath,\n }\n \n #[turbo_tasks::value_impl]\n@@ -96,7 +96,7 @@ impl Issue for ReactRefreshResolvingIssue {\n \n     #[turbo_tasks::function]\n     fn file_path(&self) -> Vc<FileSystemPath> {\n-        *self.path\n+        self.path.clone().cell()\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "1b8149cb6e747adf2ba5581d3c7c9fa4d653ae3f",
            "filename": "turbopack/crates/turbopack-cli-utils/src/runtime_entry.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-cli-utils%2Fsrc%2Fruntime_entry.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-cli-utils%2Fsrc%2Fruntime_entry.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-cli-utils%2Fsrc%2Fruntime_entry.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -12,7 +12,7 @@ use turbopack_resolve::ecmascript::cjs_resolve;\n \n #[turbo_tasks::value(shared)]\n pub enum RuntimeEntry {\n-    Request(ResolvedVc<Request>, ResolvedVc<FileSystemPath>),\n+    Request(ResolvedVc<Request>, FileSystemPath),\n     Evaluatable(ResolvedVc<Box<dyn EvaluatableAsset>>),\n     Source(ResolvedVc<Box<dyn Source>>),\n }\n@@ -21,20 +21,20 @@ pub enum RuntimeEntry {\n impl RuntimeEntry {\n     #[turbo_tasks::function]\n     pub async fn resolve_entry(\n-        self: Vc<Self>,\n+        &self,\n         asset_context: Vc<Box<dyn AssetContext>>,\n     ) -> Result<Vc<EvaluatableAssets>> {\n-        let (request, path) = match *self.await? {\n-            RuntimeEntry::Evaluatable(e) => return Ok(EvaluatableAssets::one(*e)),\n+        let (request, path) = match self {\n+            RuntimeEntry::Evaluatable(e) => return Ok(EvaluatableAssets::one(**e)),\n             RuntimeEntry::Source(source) => {\n                 return Ok(EvaluatableAssets::one(source.to_evaluatable(asset_context)));\n             }\n             RuntimeEntry::Request(r, path) => (r, path),\n         };\n \n         let modules = cjs_resolve(\n-            Vc::upcast(PlainResolveOrigin::new(asset_context, *path)),\n-            *request,\n+            Vc::upcast(PlainResolveOrigin::new(asset_context, path.clone())),\n+            **request,\n             None,\n             false,\n         )"
        },
        {
            "sha": "dfee80d26eb7a7a0fac40461244df0a3873fde55",
            "filename": "turbopack/crates/turbopack-cli/src/build/mod.rs",
            "status": "modified",
            "additions": 81,
            "deletions": 82,
            "changes": 163,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fbuild%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fbuild%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fbuild%2Fmod.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -8,7 +8,7 @@ use std::{\n use anyhow::{Context, Result, bail};\n use rustc_hash::FxHashSet;\n use tracing::Instrument;\n-use turbo_rcstr::{RcStr, rcstr};\n+use turbo_rcstr::RcStr;\n use turbo_tasks::{\n     ReadConsistency, ResolvedVc, TransientInstance, TryJoinIterExt, TurboTasks, Vc, apply_effects,\n };\n@@ -205,16 +205,15 @@ async fn build_internal(\n         .unwrap_or(project_relative)\n         .replace(MAIN_SEPARATOR, \"/\")\n         .into();\n-    let root_path = project_fs.root().to_resolved().await?;\n-    let project_path = root_path.join(project_relative).to_resolved().await?;\n-    let build_output_root = output_fs.root().join(rcstr!(\"dist\")).to_resolved().await?;\n+    let root_path = project_fs.root().await?.clone_value();\n+    let project_path = root_path.join(&project_relative)?;\n+    let build_output_root = output_fs.root().await?.join(\"dist\")?;\n \n     let node_env = NodeEnv::Production.cell();\n \n     let build_output_root_to_root_path = project_path\n-        .join(rcstr!(\"dist\"))\n-        .await?\n-        .get_relative_path_to(&*root_path.await?)\n+        .join(\"dist\")?\n+        .get_relative_path_to(&root_path)\n         .context(\"Project path is in root path\")?;\n \n     let runtime_type = match *node_env.await? {\n@@ -224,15 +223,15 @@ async fn build_internal(\n \n     let compile_time_info = get_client_compile_time_info(browserslist_query.clone(), node_env);\n     let execution_context = ExecutionContext::new(\n-        *root_path,\n+        root_path.clone(),\n         Vc::upcast(\n             NodeJsChunkingContext::builder(\n-                project_path,\n-                build_output_root,\n+                project_path.clone(),\n+                build_output_root.clone(),\n                 build_output_root_to_root_path.clone(),\n-                build_output_root,\n-                build_output_root,\n-                build_output_root,\n+                build_output_root.clone(),\n+                build_output_root.clone(),\n+                build_output_root.clone(),\n                 Environment::new(ExecutionEnvironment::NodeJsLambda(\n                     NodeJsEnvironment::default().resolved_cell(),\n                 ))\n@@ -242,11 +241,11 @@ async fn build_internal(\n             )\n             .build(),\n         ),\n-        load_env(*root_path),\n+        load_env(root_path.clone()),\n     );\n \n     let asset_context = get_client_asset_context(\n-        *project_path,\n+        project_path.clone(),\n         execution_context,\n         compile_time_info,\n         node_env,\n@@ -275,7 +274,7 @@ async fn build_internal(\n         .await?)\n         .to_vec();\n \n-    let origin = PlainResolveOrigin::new(asset_context, project_fs.root().join(rcstr!(\"_\")));\n+    let origin = PlainResolveOrigin::new(asset_context, project_fs.root().await?.join(\"_\")?);\n     let project_dir = &project_dir;\n     let entries = async move {\n         entry_requests\n@@ -284,7 +283,7 @@ async fn build_internal(\n                 let ty = ReferenceType::Entry(EntryReferenceSubType::Undefined);\n                 let request = request_vc.await?;\n                 origin\n-                    .resolve_asset(request_vc, origin.resolve_options(ty.clone()), ty)\n+                    .resolve_asset(request_vc, origin.resolve_options(ty.clone()).await?, ty)\n                     .await?\n                     .first_module()\n                     .await?\n@@ -316,11 +315,11 @@ async fn build_internal(\n         Target::Browser => {\n             let mut builder = BrowserChunkingContext::builder(\n                 project_path,\n-                build_output_root,\n+                build_output_root.clone(),\n                 build_output_root_to_root_path,\n-                build_output_root,\n-                build_output_root,\n-                build_output_root,\n+                build_output_root.clone(),\n+                build_output_root.clone(),\n+                build_output_root.clone(),\n                 Environment::new(ExecutionEnvironment::Browser(\n                     BrowserEnvironment {\n                         dom: true,\n@@ -369,11 +368,11 @@ async fn build_internal(\n         Target::Node => {\n             let mut builder = NodeJsChunkingContext::builder(\n                 project_path,\n-                build_output_root,\n+                build_output_root.clone(),\n                 build_output_root_to_root_path,\n-                build_output_root,\n-                build_output_root,\n-                build_output_root,\n+                build_output_root.clone(),\n+                build_output_root.clone(),\n+                build_output_root.clone(),\n                 Environment::new(ExecutionEnvironment::NodeJsLambda(\n                     NodeJsEnvironment::default().resolved_cell(),\n                 ))\n@@ -415,69 +414,69 @@ async fn build_internal(\n \n     let entry_chunk_groups = entries\n         .into_iter()\n-        .map(|entry_module| async move {\n-            Ok(\n-                if let Some(ecmascript) =\n-                    ResolvedVc::try_sidecast::<Box<dyn EvaluatableAsset>>(entry_module)\n-                {\n-                    match target {\n-                        Target::Browser => {\n-                            chunking_context\n-                                .evaluated_chunk_group(\n-                                    AssetIdent::from_path(\n+        .map(|entry_module| {\n+            let build_output_root = build_output_root.clone();\n+\n+            async move {\n+                Ok(\n+                    if let Some(ecmascript) =\n+                        ResolvedVc::try_sidecast::<Box<dyn EvaluatableAsset>>(entry_module)\n+                    {\n+                        match target {\n+                            Target::Browser => {\n+                                chunking_context\n+                                    .evaluated_chunk_group(\n+                                        AssetIdent::from_path(\n+                                            build_output_root\n+                                                .join(\n+                                                    ecmascript\n+                                                        .ident()\n+                                                        .path()\n+                                                        .await?\n+                                                        .file_stem()\n+                                                        .unwrap(),\n+                                                )?\n+                                                .with_extension(\"entry.js\"),\n+                                        ),\n+                                        ChunkGroup::Entry(\n+                                            [ResolvedVc::upcast(ecmascript)].into_iter().collect(),\n+                                        ),\n+                                        module_graph,\n+                                        AvailabilityInfo::Root,\n+                                    )\n+                                    .await?\n+                                    .assets\n+                            }\n+                            Target::Node => ResolvedVc::cell(vec![\n+                                chunking_context\n+                                    .entry_chunk_group(\n                                         build_output_root\n                                             .join(\n                                                 ecmascript\n                                                     .ident()\n                                                     .path()\n-                                                    .file_stem()\n                                                     .await?\n-                                                    .as_deref()\n-                                                    .unwrap()\n-                                                    .into(),\n-                                            )\n-                                            .with_extension(rcstr!(\"entry.js\")),\n-                                    ),\n-                                    ChunkGroup::Entry(\n-                                        [ResolvedVc::upcast(ecmascript)].into_iter().collect(),\n-                                    ),\n-                                    module_graph,\n-                                    AvailabilityInfo::Root,\n-                                )\n-                                .await?\n-                                .assets\n+                                                    .file_stem()\n+                                                    .unwrap(),\n+                                            )?\n+                                            .with_extension(\"entry.js\"),\n+                                        EvaluatableAssets::one(*ResolvedVc::upcast(ecmascript)),\n+                                        module_graph,\n+                                        OutputAssets::empty(),\n+                                        AvailabilityInfo::Root,\n+                                    )\n+                                    .await?\n+                                    .asset,\n+                            ]),\n                         }\n-                        Target::Node => ResolvedVc::cell(vec![\n-                            chunking_context\n-                                .entry_chunk_group(\n-                                    build_output_root\n-                                        .join(\n-                                            ecmascript\n-                                                .ident()\n-                                                .path()\n-                                                .file_stem()\n-                                                .await?\n-                                                .as_deref()\n-                                                .unwrap()\n-                                                .into(),\n-                                        )\n-                                        .with_extension(rcstr!(\"entry.js\")),\n-                                    EvaluatableAssets::one(*ResolvedVc::upcast(ecmascript)),\n-                                    module_graph,\n-                                    OutputAssets::empty(),\n-                                    AvailabilityInfo::Root,\n-                                )\n-                                .await?\n-                                .asset,\n-                        ]),\n-                    }\n-                } else {\n-                    bail!(\n-                        \"Entry module is not chunkable, so it can't be used to bootstrap the \\\n-                         application\"\n-                    )\n-                },\n-            )\n+                    } else {\n+                        bail!(\n+                            \"Entry module is not chunkable, so it can't be used to bootstrap the \\\n+                             application\"\n+                        )\n+                    },\n+                )\n+            }\n         })\n         .try_join()\n         .await?;\n@@ -493,7 +492,7 @@ async fn build_internal(\n \n     chunks\n         .iter()\n-        .map(|c| c.content().write(c.path()))\n+        .map(|c| async move { c.content().write(c.path().await?.clone_value()).await })\n         .try_join()\n         .await?;\n "
        },
        {
            "sha": "d60448b57b52c64d51ab4d05e25e869320357c28",
            "filename": "turbopack/crates/turbopack-cli/src/contexts.rs",
            "status": "modified",
            "additions": 19,
            "deletions": 17,
            "changes": 36,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fcontexts.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fcontexts.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fcontexts.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -49,15 +49,13 @@ async fn foreign_code_context_condition() -> Result<ContextCondition> {\n }\n \n #[turbo_tasks::function]\n-pub async fn get_client_import_map(\n-    project_path: ResolvedVc<FileSystemPath>,\n-) -> Result<Vc<ImportMap>> {\n+pub async fn get_client_import_map(project_path: FileSystemPath) -> Result<Vc<ImportMap>> {\n     let mut import_map = ImportMap::empty();\n \n-    import_map.insert_singleton_alias(\"@swc/helpers\", project_path);\n-    import_map.insert_singleton_alias(\"styled-jsx\", project_path);\n-    import_map.insert_singleton_alias(\"react\", project_path);\n-    import_map.insert_singleton_alias(\"react-dom\", project_path);\n+    import_map.insert_singleton_alias(\"@swc/helpers\", project_path.clone());\n+    import_map.insert_singleton_alias(\"styled-jsx\", project_path.clone());\n+    import_map.insert_singleton_alias(\"react\", project_path.clone());\n+    import_map.insert_singleton_alias(\"react-dom\", project_path.clone());\n \n     import_map.insert_wildcard_alias(\n         \"@vercel/turbopack-ecmascript-runtime/\",\n@@ -66,8 +64,8 @@ pub async fn get_client_import_map(\n             Some(\n                 turbopack_ecmascript_runtime::embed_fs()\n                     .root()\n-                    .to_resolved()\n-                    .await?,\n+                    .await?\n+                    .clone_value(),\n             ),\n         )\n         .resolved_cell(),\n@@ -78,12 +76,14 @@ pub async fn get_client_import_map(\n \n #[turbo_tasks::function]\n pub async fn get_client_resolve_options_context(\n-    project_path: Vc<FileSystemPath>,\n+    project_path: FileSystemPath,\n     node_env: Vc<NodeEnv>,\n ) -> Result<Vc<ResolveOptionsContext>> {\n-    let next_client_import_map = get_client_import_map(project_path).to_resolved().await?;\n+    let next_client_import_map = get_client_import_map(project_path.clone())\n+        .to_resolved()\n+        .await?;\n     let module_options_context = ResolveOptionsContext {\n-        enable_node_modules: Some(project_path.root().to_resolved().await?),\n+        enable_node_modules: Some(project_path.root().await?.clone_value()),\n         custom_conditions: vec![node_env.await?.to_string().into(), \"browser\".into()],\n         import_map: Some(next_client_import_map),\n         browser: true,\n@@ -104,7 +104,7 @@ pub async fn get_client_resolve_options_context(\n \n #[turbo_tasks::function]\n async fn get_client_module_options_context(\n-    project_path: Vc<FileSystemPath>,\n+    project_path: FileSystemPath,\n     execution_context: ResolvedVc<ExecutionContext>,\n     env: ResolvedVc<Environment>,\n     node_env: Vc<NodeEnv>,\n@@ -119,10 +119,11 @@ async fn get_client_module_options_context(\n         ..Default::default()\n     };\n \n-    let resolve_options_context = get_client_resolve_options_context(project_path, node_env);\n+    let resolve_options_context =\n+        get_client_resolve_options_context(project_path.clone(), node_env);\n \n     let enable_react_refresh = is_dev\n-        && assert_can_resolve_react_refresh(project_path, resolve_options_context)\n+        && assert_can_resolve_react_refresh(project_path.clone(), resolve_options_context)\n             .await?\n             .is_found();\n \n@@ -173,13 +174,14 @@ async fn get_client_module_options_context(\n \n #[turbo_tasks::function]\n pub fn get_client_asset_context(\n-    project_path: Vc<FileSystemPath>,\n+    project_path: FileSystemPath,\n     execution_context: Vc<ExecutionContext>,\n     compile_time_info: Vc<CompileTimeInfo>,\n     node_env: Vc<NodeEnv>,\n     source_maps_type: SourceMapsType,\n ) -> Vc<Box<dyn AssetContext>> {\n-    let resolve_options_context = get_client_resolve_options_context(project_path, node_env);\n+    let resolve_options_context =\n+        get_client_resolve_options_context(project_path.clone(), node_env);\n     let module_options_context = get_client_module_options_context(\n         project_path,\n         execution_context,"
        },
        {
            "sha": "02517fe7c6277eb4037ecc9205a605fc3854cdd4",
            "filename": "turbopack/crates/turbopack-cli/src/dev/mod.rs",
            "status": "modified",
            "additions": 15,
            "deletions": 26,
            "changes": 41,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fdev%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fdev%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fdev%2Fmod.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -266,46 +266,35 @@ async fn source(\n \n     let output_fs = output_fs(project_dir);\n     let fs: Vc<Box<dyn FileSystem>> = project_fs(root_dir, /* watch= */ true);\n-    let root_path = fs.root().to_resolved().await?;\n-    let project_path = root_path.join(project_relative).to_resolved().await?;\n+    let root_path = fs.root().await?.clone_value();\n+    let project_path = root_path.join(&project_relative)?;\n \n-    let env = load_env(*root_path);\n-    let build_output_root = output_fs\n-        .root()\n-        .join(rcstr!(\".turbopack/build\"))\n-        .to_resolved()\n-        .await?;\n+    let env = load_env(root_path.clone());\n+    let build_output_root = output_fs.root().await?.join(\".turbopack/build\")?;\n \n     let build_output_root_to_root_path = project_path\n-        .join(rcstr!(\".turbopack/build\"))\n-        .await?\n-        .get_relative_path_to(&*root_path.await?)\n+        .join(\".turbopack/build\")?\n+        .get_relative_path_to(&root_path)\n         .context(\"Project path is in root path\")?;\n     let build_output_root_to_root_path = build_output_root_to_root_path;\n \n     let build_chunking_context = NodeJsChunkingContext::builder(\n-        root_path,\n-        build_output_root,\n+        root_path.clone(),\n+        build_output_root.clone(),\n         build_output_root_to_root_path,\n-        build_output_root,\n-        build_output_root\n-            .join(rcstr!(\"chunks\"))\n-            .to_resolved()\n-            .await?,\n-        build_output_root\n-            .join(rcstr!(\"assets\"))\n-            .to_resolved()\n-            .await?,\n+        build_output_root.clone(),\n+        build_output_root.join(\"chunks\")?,\n+        build_output_root.join(\"assets\")?,\n         node_build_environment().to_resolved().await?,\n         RuntimeType::Development,\n     )\n     .build();\n \n     let execution_context =\n-        ExecutionContext::new(*root_path, Vc::upcast(build_chunking_context), env);\n+        ExecutionContext::new(root_path.clone(), Vc::upcast(build_chunking_context), env);\n \n     let server_fs = Vc::upcast::<Box<dyn FileSystem>>(ServerFileSystem::new());\n-    let server_root = server_fs.root();\n+    let server_root = server_fs.root().await?.clone_value();\n     let entry_requests = entry_requests\n         .iter()\n         .map(|r| match r {\n@@ -325,7 +314,7 @@ async fn source(\n         .collect();\n \n     let web_source: ResolvedVc<Box<dyn ContentSource>> = create_web_entry_source(\n-        *root_path,\n+        root_path.clone(),\n         execution_context,\n         entry_requests,\n         server_root,\n@@ -339,7 +328,7 @@ async fn source(\n     .to_resolved()\n     .await?;\n     let static_source = ResolvedVc::upcast(\n-        StaticAssetsContentSource::new(Default::default(), project_path.join(rcstr!(\"public\")))\n+        StaticAssetsContentSource::new(Default::default(), project_path.join(\"public\")?)\n             .to_resolved()\n             .await?,\n     );"
        },
        {
            "sha": "0e93cb4d94ca99d66bfc70fc10d18e81bbbe7159",
            "filename": "turbopack/crates/turbopack-cli/src/dev/web_entry_source.rs",
            "status": "modified",
            "additions": 28,
            "deletions": 29,
            "changes": 57,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fdev%2Fweb_entry_source.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fdev%2Fweb_entry_source.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fdev%2Fweb_entry_source.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -34,19 +34,19 @@ use crate::{\n \n #[turbo_tasks::function]\n pub async fn get_client_chunking_context(\n-    root_path: ResolvedVc<FileSystemPath>,\n-    server_root: ResolvedVc<FileSystemPath>,\n+    root_path: FileSystemPath,\n+    server_root: FileSystemPath,\n     server_root_to_root_path: RcStr,\n     environment: ResolvedVc<Environment>,\n ) -> Result<Vc<Box<dyn ChunkingContext>>> {\n     Ok(Vc::upcast(\n         BrowserChunkingContext::builder(\n             root_path,\n-            server_root,\n+            server_root.clone(),\n             server_root_to_root_path,\n-            server_root,\n-            server_root.join(rcstr!(\"/_chunks\")).to_resolved().await?,\n-            server_root.join(rcstr!(\"/_assets\")).to_resolved().await?,\n+            server_root.clone(),\n+            server_root.join(\"/_chunks\")?,\n+            server_root.join(\"/_assets\")?,\n             environment,\n             RuntimeType::Development,\n         )\n@@ -58,35 +58,37 @@ pub async fn get_client_chunking_context(\n \n #[turbo_tasks::function]\n pub async fn get_client_runtime_entries(\n-    project_path: ResolvedVc<FileSystemPath>,\n+    project_path: FileSystemPath,\n     node_env: Vc<NodeEnv>,\n ) -> Result<Vc<RuntimeEntries>> {\n-    let resolve_options_context = get_client_resolve_options_context(*project_path, node_env);\n+    let resolve_options_context =\n+        get_client_resolve_options_context(project_path.clone(), node_env);\n \n     let mut runtime_entries = Vec::new();\n \n     let enable_react_refresh =\n-        assert_can_resolve_react_refresh(*project_path, resolve_options_context)\n+        assert_can_resolve_react_refresh(project_path.clone(), resolve_options_context)\n             .await?\n             .as_request();\n     // It's important that React Refresh come before the regular bootstrap file,\n     // because the bootstrap contains JSX which requires Refresh's global\n     // functions to be available.\n     if let Some(request) = enable_react_refresh {\n         runtime_entries.push(\n-            RuntimeEntry::Request(\n-                request.to_resolved().await?,\n-                project_path.join(rcstr!(\"_\")).to_resolved().await?,\n-            )\n-            .resolved_cell(),\n+            RuntimeEntry::Request(request.to_resolved().await?, project_path.join(\"_\")?)\n+                .resolved_cell(),\n         )\n     };\n \n     runtime_entries.push(\n         RuntimeEntry::Source(ResolvedVc::upcast(\n-            FileSource::new(embed_file_path(rcstr!(\"entry/bootstrap.ts\")))\n-                .to_resolved()\n-                .await?,\n+            FileSource::new(\n+                embed_file_path(rcstr!(\"entry/bootstrap.ts\"))\n+                    .await?\n+                    .clone_value(),\n+            )\n+            .to_resolved()\n+            .await?,\n         ))\n         .resolved_cell(),\n     );\n@@ -96,10 +98,10 @@ pub async fn get_client_runtime_entries(\n \n #[turbo_tasks::function]\n pub async fn create_web_entry_source(\n-    root_path: Vc<FileSystemPath>,\n+    root_path: FileSystemPath,\n     execution_context: Vc<ExecutionContext>,\n     entry_requests: Vec<Vc<Request>>,\n-    server_root: Vc<FileSystemPath>,\n+    server_root: FileSystemPath,\n     server_root_to_root_path: RcStr,\n     _env: Vc<Box<dyn ProcessEnv>>,\n     eager_compile: bool,\n@@ -109,31 +111,31 @@ pub async fn create_web_entry_source(\n ) -> Result<Vc<Box<dyn ContentSource>>> {\n     let compile_time_info = get_client_compile_time_info(browserslist_query, node_env);\n     let asset_context = get_client_asset_context(\n-        root_path,\n+        root_path.clone(),\n         execution_context,\n         compile_time_info,\n         node_env,\n         source_maps_type,\n     );\n     let chunking_context = get_client_chunking_context(\n-        root_path,\n-        server_root,\n+        root_path.clone(),\n+        server_root.clone(),\n         server_root_to_root_path,\n         compile_time_info.environment(),\n     )\n     .to_resolved()\n     .await?;\n-    let entries = get_client_runtime_entries(root_path, node_env);\n+    let entries = get_client_runtime_entries(root_path.clone(), node_env);\n \n     let runtime_entries = entries.resolve_entries(asset_context);\n \n-    let origin = PlainResolveOrigin::new(asset_context, root_path.join(rcstr!(\"_\")));\n+    let origin = PlainResolveOrigin::new(asset_context, root_path.join(\"_\")?);\n     let entries = entry_requests\n         .into_iter()\n         .map(|request| async move {\n             let ty = ReferenceType::Entry(EntryReferenceSubType::Web);\n             Ok(origin\n-                .resolve_asset(request, origin.resolve_options(ty.clone()), ty)\n+                .resolve_asset(request, origin.resolve_options(ty.clone()).await?, ty)\n                 .await?\n                 .resolve()\n                 .await?\n@@ -195,10 +197,7 @@ pub async fn create_web_entry_source(\n         .try_join()\n         .await?;\n \n-    let entry_asset = Vc::upcast(DevHtmlAsset::new(\n-        server_root.join(rcstr!(\"index.html\")).to_resolved().await?,\n-        entries,\n-    ));\n+    let entry_asset = Vc::upcast(DevHtmlAsset::new(server_root.join(\"index.html\")?, entries));\n \n     let graph = Vc::upcast(if eager_compile {\n         AssetGraphContentSource::new_eager(server_root, entry_asset)"
        },
        {
            "sha": "6cc11d7632fb7fb6418674532bd1b56d7c4aa200",
            "filename": "turbopack/crates/turbopack-cli/src/embed_js.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 4,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fembed_js.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fembed_js.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fembed_js.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -1,3 +1,4 @@\n+use anyhow::Result;\n use turbo_rcstr::RcStr;\n use turbo_tasks::Vc;\n use turbo_tasks_fs::{FileContent, FileSystem, FileSystemPath, embed_directory};\n@@ -8,11 +9,11 @@ fn embed_fs() -> Vc<Box<dyn FileSystem>> {\n }\n \n #[turbo_tasks::function]\n-pub(crate) fn embed_file(path: RcStr) -> Vc<FileContent> {\n-    embed_fs().root().join(path).read()\n+pub(crate) async fn embed_file(path: RcStr) -> Result<Vc<FileContent>> {\n+    Ok(embed_fs().root().await?.join(&path)?.read())\n }\n \n #[turbo_tasks::function]\n-pub(crate) fn embed_file_path(path: RcStr) -> Vc<FileSystemPath> {\n-    embed_fs().root().join(path)\n+pub(crate) async fn embed_file_path(path: RcStr) -> Result<Vc<FileSystemPath>> {\n+    Ok(embed_fs().root().await?.join(&path)?.cell())\n }"
        },
        {
            "sha": "24d4cb691d215df5f6b8284e15d1c3919eec75ed",
            "filename": "turbopack/crates/turbopack-core/src/asset.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fasset.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fasset.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fasset.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -88,7 +88,7 @@ impl AssetContent {\n     }\n \n     #[turbo_tasks::function]\n-    pub async fn write(self: Vc<Self>, path: Vc<FileSystemPath>) -> Result<()> {\n+    pub async fn write(self: Vc<Self>, path: FileSystemPath) -> Result<()> {\n         let this = self.await?;\n         match &*this {\n             AssetContent::File(file) => {"
        },
        {
            "sha": "54746b3e921ac397a1416632b91dcc862abc71c4",
            "filename": "turbopack/crates/turbopack-core/src/chunk/chunking_context.rs",
            "status": "modified",
            "additions": 9,
            "deletions": 9,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fchunking_context.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fchunking_context.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fchunking_context.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -192,7 +192,7 @@ pub trait ChunkingContext {\n     /// Returns a URL (relative or absolute, depending on the asset prefix) to\n     /// the static asset based on its `ident`.\n     #[turbo_tasks::function]\n-    fn asset_url(self: Vc<Self>, ident: Vc<FileSystemPath>) -> Result<Vc<RcStr>>;\n+    fn asset_url(self: Vc<Self>, ident: FileSystemPath) -> Result<Vc<RcStr>>;\n \n     #[turbo_tasks::function]\n     fn asset_path(\n@@ -271,7 +271,7 @@ pub trait ChunkingContext {\n     #[turbo_tasks::function]\n     fn entry_chunk_group(\n         self: Vc<Self>,\n-        path: Vc<FileSystemPath>,\n+        path: FileSystemPath,\n         evaluatable_assets: Vc<EvaluatableAssets>,\n         module_graph: Vc<ModuleGraph>,\n         extra_chunks: Vc<OutputAssets>,\n@@ -325,7 +325,7 @@ pub trait ChunkingContextExt {\n \n     fn entry_chunk_group_asset(\n         self: Vc<Self>,\n-        path: Vc<FileSystemPath>,\n+        path: FileSystemPath,\n         evaluatable_assets: Vc<EvaluatableAssets>,\n         module_graph: Vc<ModuleGraph>,\n         extra_chunks: Vc<OutputAssets>,\n@@ -336,7 +336,7 @@ pub trait ChunkingContextExt {\n \n     fn root_entry_chunk_group(\n         self: Vc<Self>,\n-        path: Vc<FileSystemPath>,\n+        path: FileSystemPath,\n         evaluatable_assets: Vc<EvaluatableAssets>,\n         module_graph: Vc<ModuleGraph>,\n         extra_chunks: Vc<OutputAssets>,\n@@ -346,7 +346,7 @@ pub trait ChunkingContextExt {\n \n     fn root_entry_chunk_group_asset(\n         self: Vc<Self>,\n-        path: Vc<FileSystemPath>,\n+        path: FileSystemPath,\n         evaluatable_assets: Vc<EvaluatableAssets>,\n         module_graph: Vc<ModuleGraph>,\n         extra_chunks: Vc<OutputAssets>,\n@@ -402,7 +402,7 @@ impl<T: ChunkingContext + Send + Upcast<Box<dyn ChunkingContext>>> ChunkingConte\n \n     fn entry_chunk_group_asset(\n         self: Vc<Self>,\n-        path: Vc<FileSystemPath>,\n+        path: FileSystemPath,\n         evaluatable_assets: Vc<EvaluatableAssets>,\n         module_graph: Vc<ModuleGraph>,\n         extra_chunks: Vc<OutputAssets>,\n@@ -420,7 +420,7 @@ impl<T: ChunkingContext + Send + Upcast<Box<dyn ChunkingContext>>> ChunkingConte\n \n     fn root_entry_chunk_group(\n         self: Vc<Self>,\n-        path: Vc<FileSystemPath>,\n+        path: FileSystemPath,\n         evaluatable_assets: Vc<EvaluatableAssets>,\n         module_graph: Vc<ModuleGraph>,\n         extra_chunks: Vc<OutputAssets>,\n@@ -436,7 +436,7 @@ impl<T: ChunkingContext + Send + Upcast<Box<dyn ChunkingContext>>> ChunkingConte\n \n     fn root_entry_chunk_group_asset(\n         self: Vc<Self>,\n-        path: Vc<FileSystemPath>,\n+        path: FileSystemPath,\n         evaluatable_assets: Vc<EvaluatableAssets>,\n         module_graph: Vc<ModuleGraph>,\n         extra_chunks: Vc<OutputAssets>,\n@@ -498,7 +498,7 @@ async fn evaluated_chunk_group_assets(\n #[turbo_tasks::function]\n async fn entry_chunk_group_asset(\n     chunking_context: Vc<Box<dyn ChunkingContext>>,\n-    path: Vc<FileSystemPath>,\n+    path: FileSystemPath,\n     evaluatable_assets: Vc<EvaluatableAssets>,\n     module_graph: Vc<ModuleGraph>,\n     extra_chunks: Vc<OutputAssets>,"
        },
        {
            "sha": "6a132bab18736449decf3c47508da573a9506b94",
            "filename": "turbopack/crates/turbopack-core/src/chunk/data.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 4,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fdata.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fdata.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fdata.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -63,10 +63,9 @@ impl ChunkData {\n \n     #[turbo_tasks::function]\n     pub async fn from_asset(\n-        output_root: Vc<FileSystemPath>,\n+        output_root: FileSystemPath,\n         chunk: Vc<Box<dyn OutputAsset>>,\n     ) -> Result<Vc<ChunkDataOption>> {\n-        let output_root = output_root.await?;\n         let path = chunk.path().await?;\n         // The \"path\" in this case is the chunk's path, not the chunk item's path.\n         // The difference is a chunk is a file served by the dev server, and an\n@@ -147,14 +146,14 @@ impl ChunkData {\n \n     #[turbo_tasks::function]\n     pub async fn from_assets(\n-        output_root: Vc<FileSystemPath>,\n+        output_root: FileSystemPath,\n         chunks: Vc<OutputAssets>,\n     ) -> Result<Vc<ChunksData>> {\n         Ok(Vc::cell(\n             chunks\n                 .await?\n                 .iter()\n-                .map(|&chunk| ChunkData::from_asset(output_root, *chunk))\n+                .map(|&chunk| ChunkData::from_asset(output_root.clone(), *chunk))\n                 .try_join()\n                 .await?\n                 .into_iter()"
        },
        {
            "sha": "c04fdcd6536ed1f7662354ed226e32019b49a99d",
            "filename": "turbopack/crates/turbopack-core/src/chunk/optimize.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Foptimize.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Foptimize.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Foptimize.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -4,17 +4,17 @@\n //! their size and eliminating duplicates between them.\n \n use anyhow::Result;\n-use turbo_tasks::{ResolvedVc, TryJoinIterExt, Vc};\n+use turbo_tasks::{TryJoinIterExt, Vc};\n use turbo_tasks_fs::{FileSystemPath, FileSystemPathOption};\n \n use crate::chunk::containment_tree::{ContainmentTree, ContainmentTreeKey};\n \n #[derive(Debug, Clone, Eq, PartialEq, Hash)]\n-struct FileSystemPathKey(ResolvedVc<FileSystemPath>);\n+struct FileSystemPathKey(FileSystemPath);\n \n impl FileSystemPathKey {\n-    async fn new(path: Vc<FileSystemPath>) -> Result<Self> {\n-        Ok(Self(path.to_resolved().await?))\n+    async fn new(path: FileSystemPath) -> Result<Self> {\n+        Ok(Self(path))\n     }\n }\n \n@@ -45,7 +45,7 @@ where\n \n                     Ok((\n                         if let Some(common_parent) = &*common_parent {\n-                            Some(FileSystemPathKey::new(**common_parent).await?)\n+                            Some(FileSystemPathKey::new(common_parent.clone()).await?)\n                         } else {\n                             None\n                         },"
        },
        {
            "sha": "a3bae79265f4cc61f50e7ec4123020cecb2c5c07",
            "filename": "turbopack/crates/turbopack-core/src/compile_time_info.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fcompile_time_info.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fcompile_time_info.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fcompile_time_info.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -215,7 +215,7 @@ pub enum InputRelativeConstant {\n pub enum FreeVarReference {\n     EcmaScriptModule {\n         request: RcStr,\n-        lookup_path: Option<ResolvedVc<FileSystemPath>>,\n+        lookup_path: Option<FileSystemPath>,\n         export: Option<RcStr>,\n     },\n     Ident(RcStr),"
        },
        {
            "sha": "53552fd1004b2baef60b54fdfd24cfed50b758f7",
            "filename": "turbopack/crates/turbopack-core/src/condition.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 5,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fcondition.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fcondition.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fcondition.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -1,7 +1,7 @@\n use anyhow::Result;\n use futures::{StreamExt, stream};\n use serde::{Deserialize, Serialize};\n-use turbo_tasks::{NonLocalValue, ResolvedVc, trace::TraceRawVcs};\n+use turbo_tasks::{NonLocalValue, trace::TraceRawVcs};\n use turbo_tasks_fs::FileSystemPath;\n \n #[derive(Debug, Clone, Serialize, Deserialize, TraceRawVcs, PartialEq, Eq, NonLocalValue)]\n@@ -10,7 +10,7 @@ pub enum ContextCondition {\n     Any(Vec<ContextCondition>),\n     Not(Box<ContextCondition>),\n     InDirectory(String),\n-    InPath(ResolvedVc<FileSystemPath>),\n+    InPath(FileSystemPath),\n }\n \n impl ContextCondition {\n@@ -52,9 +52,7 @@ impl ContextCondition {\n                     .await\n             }\n             ContextCondition::Not(condition) => Box::pin(condition.matches(path)).await.map(|b| !b),\n-            ContextCondition::InPath(other_path) => {\n-                Ok(path.is_inside_or_equal_ref(&*other_path.await?))\n-            }\n+            ContextCondition::InPath(other_path) => Ok(path.is_inside_or_equal_ref(other_path)),\n             ContextCondition::InDirectory(dir) => Ok(path.path.starts_with(&format!(\"{dir}/\"))\n                 || path.path.contains(&format!(\"/{dir}/\"))\n                 || path.path.ends_with(&format!(\"/{dir}\"))"
        },
        {
            "sha": "3c135b8fd3ff1328389c3407bbcf8912c3c6051e",
            "filename": "turbopack/crates/turbopack-core/src/context.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fcontext.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fcontext.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fcontext.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -71,15 +71,15 @@ pub trait AssetContext {\n     #[turbo_tasks::function]\n     fn resolve_options(\n         self: Vc<Self>,\n-        origin_path: Vc<FileSystemPath>,\n+        origin_path: FileSystemPath,\n         reference_type: ReferenceType,\n     ) -> Vc<ResolveOptions>;\n \n     /// Resolves an request to an [ModuleResolveResult].\n     #[turbo_tasks::function]\n     fn resolve_asset(\n         self: Vc<Self>,\n-        origin_path: Vc<FileSystemPath>,\n+        origin_path: FileSystemPath,\n         request: Vc<Request>,\n         resolve_options: Vc<ResolveOptions>,\n         reference_type: ReferenceType,"
        },
        {
            "sha": "fb07c67df0fc6bb41ef433acd4e459799c56486a",
            "filename": "turbopack/crates/turbopack-core/src/data_uri_source.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fdata_uri_source.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fdata_uri_source.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fdata_uri_source.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -17,7 +17,7 @@ pub struct DataUriSource {\n     media_type: RcStr,\n     encoding: RcStr,\n     data: ResolvedVc<RcStr>,\n-    lookup_path: ResolvedVc<FileSystemPath>,\n+    lookup_path: FileSystemPath,\n }\n \n #[turbo_tasks::value_impl]\n@@ -27,7 +27,7 @@ impl DataUriSource {\n         media_type: RcStr,\n         encoding: RcStr,\n         data: ResolvedVc<RcStr>,\n-        lookup_path: ResolvedVc<FileSystemPath>,\n+        lookup_path: FileSystemPath,\n     ) -> Vc<Self> {\n         Self::cell(DataUriSource {\n             media_type,\n@@ -52,7 +52,7 @@ impl Source for DataUriSource {\n             )))[0..6]\n         );\n         Ok(\n-            AssetIdent::from_path(self.lookup_path.join(filename.into()))\n+            AssetIdent::from_path(self.lookup_path.join(&filename)?)\n                 .with_content_type(content_type),\n         )\n     }"
        },
        {
            "sha": "9a7f0a1fd61759b22c8f5eee184204763774277e",
            "filename": "turbopack/crates/turbopack-core/src/file_source.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Ffile_source.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Ffile_source.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Ffile_source.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -1,6 +1,6 @@\n use anyhow::Result;\n use turbo_rcstr::RcStr;\n-use turbo_tasks::{ResolvedVc, Vc};\n+use turbo_tasks::Vc;\n use turbo_tasks_fs::{FileContent, FileSystemEntryType, FileSystemPath, LinkContent};\n \n use crate::{\n@@ -13,16 +13,16 @@ use crate::{\n /// references to other [Source]s.\n #[turbo_tasks::value]\n pub struct FileSource {\n-    path: ResolvedVc<FileSystemPath>,\n+    path: FileSystemPath,\n     query: RcStr,\n     fragment: RcStr,\n }\n \n impl FileSource {\n-    pub fn new(path: Vc<FileSystemPath>) -> Vc<Self> {\n+    pub fn new(path: FileSystemPath) -> Vc<Self> {\n         FileSource::new_with_query_and_fragment(path, RcStr::default(), RcStr::default())\n     }\n-    pub fn new_with_query(path: Vc<FileSystemPath>, query: RcStr) -> Vc<Self> {\n+    pub fn new_with_query(path: FileSystemPath, query: RcStr) -> Vc<Self> {\n         FileSource::new_with_query_and_fragment(path, query, RcStr::default())\n     }\n }\n@@ -31,7 +31,7 @@ impl FileSource {\n impl FileSource {\n     #[turbo_tasks::function]\n     pub fn new_with_query_and_fragment(\n-        path: ResolvedVc<FileSystemPath>,\n+        path: FileSystemPath,\n         query: RcStr,\n         fragment: RcStr,\n     ) -> Vc<Self> {\n@@ -47,7 +47,7 @@ impl FileSource {\n impl Source for FileSource {\n     #[turbo_tasks::function]\n     fn ident(&self) -> Vc<AssetIdent> {\n-        let mut ident = AssetIdent::from_path(*self.path);\n+        let mut ident = AssetIdent::from_path(self.path.clone());\n         if !self.query.is_empty() {\n             ident = ident.with_query(self.query.clone());\n         }"
        },
        {
            "sha": "c8f39f3a4b4b860c01d2b83c481fb520b21afd15",
            "filename": "turbopack/crates/turbopack-core/src/ident.rs",
            "status": "modified",
            "additions": 13,
            "deletions": 16,
            "changes": 29,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fident.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fident.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fident.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -61,7 +61,7 @@ impl Layer {\n #[derive(Clone, Debug, Hash, TaskInput)]\n pub struct AssetIdent {\n     /// The primary path of the asset\n-    pub path: ResolvedVc<FileSystemPath>,\n+    pub path: FileSystemPath,\n     /// The query string of the asset this is either the empty string or a query string that starts\n     /// with a `?` (e.g. `?foo=bar`)\n     pub query: RcStr,\n@@ -91,12 +91,9 @@ impl AssetIdent {\n     }\n \n     pub async fn rename_as_ref(&mut self, pattern: &str) -> Result<()> {\n-        let root = self.path.root();\n-        let path = self.path.await?;\n-        self.path = root\n-            .join(pattern.replace('*', &path.path).into())\n-            .to_resolved()\n-            .await?;\n+        let root = self.path.root().await?;\n+        let path = self.path.clone();\n+        self.path = root.join(&pattern.replace('*', &path.path))?;\n         Ok(())\n     }\n }\n@@ -105,7 +102,7 @@ impl AssetIdent {\n impl ValueToString for AssetIdent {\n     #[turbo_tasks::function]\n     async fn to_string(&self) -> Result<Vc<RcStr>> {\n-        let mut s = self.path.to_string().owned().await?.into_owned();\n+        let mut s = self.path.value_to_string().owned().await?.into_owned();\n \n         // The query string is either empty or non-empty starting with `?` so we can just concat\n         s.push_str(&self.query);\n@@ -178,9 +175,9 @@ impl AssetIdent {\n         ident.cell()\n     }\n \n-    /// Creates an [AssetIdent] from a [Vc<FileSystemPath>]\n+    /// Creates an [AssetIdent] from a [FileSystemPath]\n     #[turbo_tasks::function]\n-    pub fn from_path(path: ResolvedVc<FileSystemPath>) -> Vc<Self> {\n+    pub fn from_path(path: FileSystemPath) -> Vc<Self> {\n         Self::new(AssetIdent {\n             path,\n             query: RcStr::default(),\n@@ -222,7 +219,7 @@ impl AssetIdent {\n     }\n \n     #[turbo_tasks::function]\n-    pub fn with_path(&self, path: ResolvedVc<FileSystemPath>) -> Vc<Self> {\n+    pub fn with_path(&self, path: FileSystemPath) -> Vc<Self> {\n         let mut this = self.clone();\n         this.path = path;\n         Self::new(this)\n@@ -258,7 +255,7 @@ impl AssetIdent {\n \n     #[turbo_tasks::function]\n     pub fn path(&self) -> Vc<FileSystemPath> {\n-        *self.path\n+        self.path.clone().cell()\n     }\n \n     /// Computes a unique output asset name for the given asset identifier.\n@@ -268,7 +265,7 @@ impl AssetIdent {\n     #[turbo_tasks::function]\n     pub async fn output_name(\n         &self,\n-        context_path: Vc<FileSystemPath>,\n+        context_path: FileSystemPath,\n         expected_extension: RcStr,\n     ) -> Result<Vc<RcStr>> {\n         debug_assert!(\n@@ -279,11 +276,11 @@ impl AssetIdent {\n         // to be compatible with all operating systems + URLs.\n \n         // For clippy -- This explicit deref is necessary\n-        let path = &*self.path.await?;\n-        let mut name = if let Some(inner) = context_path.await?.get_path_to(path) {\n+        let path = &self.path;\n+        let mut name = if let Some(inner) = context_path.get_path_to(path) {\n             clean_separators(inner)\n         } else {\n-            clean_separators(&self.path.to_string().await?)\n+            clean_separators(&self.path.value_to_string().await?)\n         };\n         let removed_extension = name.ends_with(&*expected_extension);\n         if removed_extension {"
        },
        {
            "sha": "1bd4b36a5b81a99adc691e946452a87fc6f69efe",
            "filename": "turbopack/crates/turbopack-core/src/issue/code_gen.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fissue%2Fcode_gen.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fissue%2Fcode_gen.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fissue%2Fcode_gen.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -6,7 +6,7 @@ use super::{Issue, IssueSeverity, IssueStage, OptionStyledString, StyledString};\n #[turbo_tasks::value(shared)]\n pub struct CodeGenerationIssue {\n     pub severity: IssueSeverity,\n-    pub path: ResolvedVc<FileSystemPath>,\n+    pub path: FileSystemPath,\n     pub title: ResolvedVc<StyledString>,\n     pub message: ResolvedVc<StyledString>,\n }\n@@ -29,7 +29,7 @@ impl Issue for CodeGenerationIssue {\n \n     #[turbo_tasks::function]\n     fn file_path(&self) -> Vc<FileSystemPath> {\n-        *self.path\n+        self.path.clone().cell()\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "d681f4ab03bf2a99ad427bc90a15112eaba2f8c6",
            "filename": "turbopack/crates/turbopack-core/src/issue/mod.rs",
            "status": "modified",
            "additions": 22,
            "deletions": 22,
            "changes": 44,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fissue%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fissue%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fissue%2Fmod.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -161,7 +161,7 @@ pub trait Issue {\n #[turbo_tasks::value_trait]\n pub trait ImportTracer {\n     #[turbo_tasks::function]\n-    fn get_traces(self: Vc<Self>, path: ResolvedVc<FileSystemPath>) -> Vc<ImportTraces>;\n+    fn get_traces(self: Vc<Self>, path: FileSystemPath) -> Vc<ImportTraces>;\n }\n \n #[turbo_tasks::value(shared)]\n@@ -171,11 +171,11 @@ pub struct DelegatingImportTracer {\n }\n \n impl DelegatingImportTracer {\n-    async fn get_traces(&self, path: Vc<FileSystemPath>) -> Result<Vec<ImportTrace>> {\n+    async fn get_traces(&self, path: FileSystemPath) -> Result<Vec<ImportTrace>> {\n         Ok(self\n             .delegates\n             .iter()\n-            .map(|d| d.get_traces(path))\n+            .map(|d| d.get_traces(path.clone()))\n             .try_join()\n             .await?\n             .iter()\n@@ -208,18 +208,18 @@ trait IssueProcessingPath {\n \n #[turbo_tasks::value]\n pub struct IssueProcessingPathItem {\n-    pub file_path: Option<ResolvedVc<FileSystemPath>>,\n+    pub file_path: Option<FileSystemPath>,\n     pub description: ResolvedVc<RcStr>,\n }\n \n #[turbo_tasks::value_impl]\n impl ValueToString for IssueProcessingPathItem {\n     #[turbo_tasks::function]\n     async fn to_string(&self) -> Result<Vc<RcStr>> {\n-        if let Some(context) = self.file_path {\n+        if let Some(context) = &self.file_path {\n             let description_str = self.description.await?;\n             Ok(Vc::cell(\n-                format!(\"{} ({})\", context.to_string().await?, description_str).into(),\n+                format!(\"{} ({})\", context.value_to_string().await?, description_str).into(),\n             ))\n         } else {\n             Ok(*self.description)\n@@ -232,8 +232,8 @@ impl IssueProcessingPathItem {\n     #[turbo_tasks::function]\n     pub async fn into_plain(&self) -> Result<Vc<PlainIssueProcessingPathItem>> {\n         Ok(PlainIssueProcessingPathItem {\n-            file_path: if let Some(context) = self.file_path {\n-                Some(context.to_string().await?)\n+            file_path: if let Some(context) = &self.file_path {\n+                Some(context.value_to_string().await?)\n             } else {\n                 None\n             },\n@@ -647,7 +647,7 @@ impl PlainTraceItem {\n     async fn from_asset_ident(asset: ReadRef<AssetIdent>) -> Result<Self> {\n         // TODO(lukesandberg): How should we display paths? it would be good to display all paths\n         // relative to the cwd or the project root.\n-        let fs_path = asset.path.await?;\n+        let fs_path = asset.path.clone();\n         let fs_name = fs_path.fs.to_string().owned().await?;\n         let root_path = fs_path.fs.root().await?.path.clone();\n         let path = fs_path.path.clone();\n@@ -881,7 +881,13 @@ impl PlainIssue {\n             processing_path: processing_path.into_plain().await?,\n             import_traces: match import_tracer {\n                 Some(tracer) => {\n-                    into_plain_trace(tracer.await?.get_traces(issue.file_path()).await?).await?\n+                    into_plain_trace(\n+                        tracer\n+                            .await?\n+                            .get_traces(issue.file_path().await?.clone_value())\n+                            .await?,\n+                    )\n+                    .await?\n                 }\n                 None => vec![],\n             },\n@@ -988,7 +994,7 @@ where\n     #[allow(unused_variables, reason = \"behind feature flag\")]\n     async fn attach_file_path(\n         self,\n-        file_path: impl Into<Option<Vc<FileSystemPath>>> + Send,\n+        file_path: impl Into<Option<FileSystemPath>> + Send,\n         description: impl Into<String> + Send,\n     ) -> Result<Self>;\n \n@@ -997,7 +1003,7 @@ where\n \n     async fn issue_file_path(\n         self,\n-        file_path: impl Into<Option<Vc<FileSystemPath>>> + Send,\n+        file_path: impl Into<Option<FileSystemPath>> + Send,\n         description: impl Into<String> + Send,\n     ) -> Result<Self>;\n     async fn issue_description(self, description: impl Into<String> + Send) -> Result<Self>;\n@@ -1021,7 +1027,7 @@ where\n     #[allow(unused_variables, reason = \"behind feature flag\")]\n     async fn attach_file_path(\n         self,\n-        file_path: impl Into<Option<Vc<FileSystemPath>>> + Send,\n+        file_path: impl Into<Option<FileSystemPath>> + Send,\n         description: impl Into<String> + Send,\n     ) -> Result<Self> {\n         #[cfg(feature = \"issue_path\")]\n@@ -1032,10 +1038,7 @@ where\n                     ItemIssueProcessingPath::resolved_cell(ItemIssueProcessingPath(\n                         Some(IssueProcessingPathItem::resolved_cell(\n                             IssueProcessingPathItem {\n-                                file_path: match file_path.into() {\n-                                    Some(path) => Some(path.to_resolved().await?),\n-                                    None => None,\n-                                },\n+                                file_path: file_path.into(),\n                                 description: ResolvedVc::cell(RcStr::from(description.into())),\n                             },\n                         )),\n@@ -1054,7 +1057,7 @@ where\n \n     async fn issue_file_path(\n         self,\n-        file_path: impl Into<Option<Vc<FileSystemPath>>> + Send,\n+        file_path: impl Into<Option<FileSystemPath>> + Send,\n         description: impl Into<String> + Send,\n     ) -> Result<Self> {\n         #[cfg(feature = \"issue_path\")]\n@@ -1065,10 +1068,7 @@ where\n                     ItemIssueProcessingPath::resolved_cell(ItemIssueProcessingPath(\n                         Some(IssueProcessingPathItem::resolved_cell(\n                             IssueProcessingPathItem {\n-                                file_path: match file_path.into() {\n-                                    Some(path) => Some(path.to_resolved().await?),\n-                                    None => None,\n-                                },\n+                                file_path: file_path.into(),\n                                 description: ResolvedVc::cell(RcStr::from(description.into())),\n                             },\n                         )),"
        },
        {
            "sha": "91c4fd7509d05008a59bb6f05ebc07934d64533f",
            "filename": "turbopack/crates/turbopack-core/src/issue/resolve.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fissue%2Fresolve.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fissue%2Fresolve.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fissue%2Fresolve.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -20,7 +20,7 @@ pub struct ResolvingIssue {\n     pub severity: IssueSeverity,\n     pub request_type: String,\n     pub request: ResolvedVc<Request>,\n-    pub file_path: ResolvedVc<FileSystemPath>,\n+    pub file_path: FileSystemPath,\n     pub resolve_options: ResolvedVc<ResolveOptions>,\n     pub error_message: Option<String>,\n     pub source: Option<IssueSource>,\n@@ -50,7 +50,7 @@ impl Issue for ResolvingIssue {\n \n     #[turbo_tasks::function]\n     fn file_path(&self) -> Vc<FileSystemPath> {\n-        *self.file_path\n+        self.file_path.clone().cell()\n     }\n \n     #[turbo_tasks::function]\n@@ -67,7 +67,7 @@ impl Issue for ResolvingIssue {\n \n         if let Some(import_map) = &self.resolve_options.await?.import_map {\n             for request in request_parts {\n-                match lookup_import_map(**import_map, *self.file_path, **request).await {\n+                match lookup_import_map(**import_map, self.file_path.clone(), **request).await {\n                     Ok(None) => {}\n                     Ok(Some(str)) => writeln!(description, \"Import map: {str}\")?,\n                     Err(err) => {\n@@ -102,7 +102,7 @@ impl Issue for ResolvingIssue {\n         writeln!(\n             detail,\n             \"Path where resolving has started: {context}\",\n-            context = self.file_path.to_string().await?\n+            context = self.file_path.value_to_string().await?\n         )?;\n         writeln!(\n             detail,\n@@ -128,7 +128,7 @@ impl Issue for ResolvingIssue {\n \n async fn lookup_import_map(\n     import_map: Vc<ImportMap>,\n-    file_path: Vc<FileSystemPath>,\n+    file_path: FileSystemPath,\n     request: Vc<Request>,\n ) -> Result<Option<ReadRef<RcStr>>> {\n     let result = import_map.await?.lookup(file_path, request).await?;"
        },
        {
            "sha": "2b2b5a1f772113fe11f0a15ac4ea3d8ec236b1b7",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/mod.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 5,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -877,12 +877,9 @@ impl ModuleGraphImportTracer {\n #[turbo_tasks::value_impl]\n impl ImportTracer for ModuleGraphImportTracer {\n     #[turbo_tasks::function]\n-    async fn get_traces(\n-        self: Vc<Self>,\n-        path: ResolvedVc<FileSystemPath>,\n-    ) -> Result<Vc<ImportTraces>> {\n+    async fn get_traces(self: Vc<Self>, path: FileSystemPath) -> Result<Vc<ImportTraces>> {\n         let path_to_modules = self.path_to_modules().await?;\n-        let Some(modules) = path_to_modules.map.get(&*path.await?) else {\n+        let Some(modules) = path_to_modules.map.get(&path) else {\n             return Ok(Vc::default()); // This isn't unusual, the file just might not be in this\n             // graph.\n         };"
        },
        {
            "sha": "a2bb6abd92d8eda251a9a74effafae75b1075563",
            "filename": "turbopack/crates/turbopack-core/src/package_json.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 6,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fpackage_json.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fpackage_json.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fpackage_json.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -3,9 +3,7 @@ use std::{fmt::Write, ops::Deref};\n use anyhow::Result;\n use serde_json::Value as JsonValue;\n use turbo_rcstr::RcStr;\n-use turbo_tasks::{\n-    NonLocalValue, ReadRef, ResolvedVc, Vc, debug::ValueDebugFormat, trace::TraceRawVcs,\n-};\n+use turbo_tasks::{NonLocalValue, ReadRef, Vc, debug::ValueDebugFormat, trace::TraceRawVcs};\n use turbo_tasks_fs::{FileContent, FileJsonContent, FileSystemPath};\n \n use super::issue::Issue;\n@@ -33,7 +31,7 @@ pub struct OptionPackageJson(Option<PackageJson>);\n /// Reads a package.json file (if it exists). If the file is unparseable, it\n /// emits a useful [Issue] pointing to the invalid location.\n #[turbo_tasks::function]\n-pub async fn read_package_json(path: ResolvedVc<FileSystemPath>) -> Result<Vc<OptionPackageJson>> {\n+pub async fn read_package_json(path: FileSystemPath) -> Result<Vc<OptionPackageJson>> {\n     let read = path.read_json().await?;\n     match &*read {\n         FileJsonContent::Content(_) => Ok(OptionPackageJson(Some(PackageJson(read))).cell()),\n@@ -60,7 +58,7 @@ pub async fn read_package_json(path: ResolvedVc<FileSystemPath>) -> Result<Vc<Op\n /// Reusable Issue struct representing any problem with a `package.json`\n #[turbo_tasks::value(shared)]\n pub struct PackageJsonIssue {\n-    pub path: ResolvedVc<FileSystemPath>,\n+    pub path: FileSystemPath,\n     pub error_message: RcStr,\n }\n \n@@ -78,7 +76,7 @@ impl Issue for PackageJsonIssue {\n \n     #[turbo_tasks::function]\n     fn file_path(&self) -> Vc<FileSystemPath> {\n-        *self.path\n+        self.path.clone().cell()\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "6861f7ccc9c1ec71763c04bd2302d66a6126cd4d",
            "filename": "turbopack/crates/turbopack-core/src/proxied_asset.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 6,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fproxied_asset.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fproxied_asset.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fproxied_asset.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -15,17 +15,14 @@ use crate::{\n #[turbo_tasks::value]\n pub struct ProxiedAsset {\n     asset: ResolvedVc<Box<dyn OutputAsset>>,\n-    path: ResolvedVc<FileSystemPath>,\n+    path: FileSystemPath,\n }\n \n #[turbo_tasks::value_impl]\n impl ProxiedAsset {\n     /// Creates a new [`ProxiedAsset`] from an [`Asset`] and a path.\n     #[turbo_tasks::function]\n-    pub fn new(\n-        asset: ResolvedVc<Box<dyn OutputAsset>>,\n-        path: ResolvedVc<FileSystemPath>,\n-    ) -> Vc<Self> {\n+    pub fn new(asset: ResolvedVc<Box<dyn OutputAsset>>, path: FileSystemPath) -> Vc<Self> {\n         ProxiedAsset { asset, path }.cell()\n     }\n }\n@@ -34,7 +31,7 @@ impl ProxiedAsset {\n impl OutputAsset for ProxiedAsset {\n     #[turbo_tasks::function]\n     fn path(&self) -> Vc<FileSystemPath> {\n-        *self.path\n+        self.path.clone().cell()\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "4edd623d6e24a5b29459da78591dd5235f0c3617",
            "filename": "turbopack/crates/turbopack-core/src/raw_output.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 6,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fraw_output.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fraw_output.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fraw_output.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -11,15 +11,15 @@ use crate::{\n /// This module has no references to other modules.\n #[turbo_tasks::value]\n pub struct RawOutput {\n-    path: ResolvedVc<FileSystemPath>,\n+    path: FileSystemPath,\n     source: ResolvedVc<Box<dyn Source>>,\n }\n \n #[turbo_tasks::value_impl]\n impl OutputAsset for RawOutput {\n     #[turbo_tasks::function]\n     fn path(&self) -> Vc<FileSystemPath> {\n-        *self.path\n+        self.path.clone().cell()\n     }\n }\n \n@@ -34,10 +34,7 @@ impl Asset for RawOutput {\n #[turbo_tasks::value_impl]\n impl RawOutput {\n     #[turbo_tasks::function]\n-    pub fn new(\n-        path: ResolvedVc<FileSystemPath>,\n-        source: ResolvedVc<Box<dyn Source>>,\n-    ) -> Vc<RawOutput> {\n+    pub fn new(path: FileSystemPath, source: ResolvedVc<Box<dyn Source>>) -> Vc<RawOutput> {\n         RawOutput { path, source }.cell()\n     }\n }"
        },
        {
            "sha": "494ebf163241db296c550fe7b93bcd24c4aa6a12",
            "filename": "turbopack/crates/turbopack-core/src/rebase.rs",
            "status": "modified",
            "additions": 11,
            "deletions": 11,
            "changes": 22,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Frebase.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Frebase.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Frebase.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -17,17 +17,17 @@ use crate::{\n #[derive(Hash)]\n pub struct RebasedAsset {\n     module: ResolvedVc<Box<dyn Module>>,\n-    input_dir: ResolvedVc<FileSystemPath>,\n-    output_dir: ResolvedVc<FileSystemPath>,\n+    input_dir: FileSystemPath,\n+    output_dir: FileSystemPath,\n }\n \n #[turbo_tasks::value_impl]\n impl RebasedAsset {\n     #[turbo_tasks::function]\n     pub fn new(\n         module: ResolvedVc<Box<dyn Module>>,\n-        input_dir: ResolvedVc<FileSystemPath>,\n-        output_dir: ResolvedVc<FileSystemPath>,\n+        input_dir: FileSystemPath,\n+        output_dir: FileSystemPath,\n     ) -> Vc<Self> {\n         Self::cell(RebasedAsset {\n             module,\n@@ -40,12 +40,12 @@ impl RebasedAsset {\n #[turbo_tasks::value_impl]\n impl OutputAsset for RebasedAsset {\n     #[turbo_tasks::function]\n-    fn path(&self) -> Vc<FileSystemPath> {\n-        FileSystemPath::rebase(\n-            self.module.ident().path(),\n-            *self.input_dir,\n-            *self.output_dir,\n-        )\n+    async fn path(&self) -> Result<Vc<FileSystemPath>> {\n+        Ok(FileSystemPath::rebase(\n+            self.module.ident().path().await?.clone_value(),\n+            self.input_dir.clone(),\n+            self.output_dir.clone(),\n+        ))\n     }\n \n     #[turbo_tasks::function]\n@@ -55,7 +55,7 @@ impl OutputAsset for RebasedAsset {\n             .iter()\n             .map(|module| async move {\n                 Ok(ResolvedVc::upcast(\n-                    RebasedAsset::new(**module, *self.input_dir, *self.output_dir)\n+                    RebasedAsset::new(**module, self.input_dir.clone(), self.output_dir.clone())\n                         .to_resolved()\n                         .await?,\n                 ))"
        },
        {
            "sha": "a89d95965844db2c82af64555b5c3f325eaaf3ca",
            "filename": "turbopack/crates/turbopack-core/src/reference/source_map.rs",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Freference%2Fsource_map.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Freference%2Fsource_map.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Freference%2Fsource_map.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -15,25 +15,25 @@ use crate::{\n \n #[turbo_tasks::value]\n pub struct SourceMapReference {\n-    from: ResolvedVc<FileSystemPath>,\n-    file: ResolvedVc<FileSystemPath>,\n+    from: FileSystemPath,\n+    file: FileSystemPath,\n }\n \n #[turbo_tasks::value_impl]\n impl SourceMapReference {\n     #[turbo_tasks::function]\n-    pub fn new(from: ResolvedVc<FileSystemPath>, file: ResolvedVc<FileSystemPath>) -> Vc<Self> {\n+    pub fn new(from: FileSystemPath, file: FileSystemPath) -> Vc<Self> {\n         Self::cell(SourceMapReference { from, file })\n     }\n }\n \n impl SourceMapReference {\n-    async fn get_file(&self) -> Option<Vc<FileSystemPath>> {\n+    async fn get_file(&self) -> Option<FileSystemPath> {\n         let file_type = self.file.get_type().await;\n         if let Ok(file_type_result) = file_type.as_ref()\n             && let FileSystemEntryType::File = &**file_type_result\n         {\n-            return Some(*self.file);\n+            return Some(self.file.clone());\n         }\n         None\n     }\n@@ -64,7 +64,7 @@ impl GenerateSourceMap for SourceMapReference {\n \n         let content = file.read().await?;\n         let content = content.as_content().map(|file| file.content());\n-        let source_map = resolve_source_map_sources(content, *self.from).await?;\n+        let source_map = resolve_source_map_sources(content, self.from.clone()).await?;\n         Ok(Vc::cell(source_map))\n     }\n }\n@@ -76,7 +76,7 @@ impl ValueToString for SourceMapReference {\n         Ok(Vc::cell(\n             format!(\n                 \"source map file is referenced by {}\",\n-                self.from.to_string().await?\n+                self.from.value_to_string().await?\n             )\n             .into(),\n         ))"
        },
        {
            "sha": "7793e64243a30303b152160db50bbd359ae139fb",
            "filename": "turbopack/crates/turbopack-core/src/resolve/mod.rs",
            "status": "modified",
            "additions": 230,
            "deletions": 203,
            "changes": 433,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fmod.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -1148,38 +1148,38 @@ impl ResolveResultOption {\n }\n \n async fn exists(\n-    fs_path: Vc<FileSystemPath>,\n+    fs_path: FileSystemPath,\n     refs: &mut Vec<ResolvedVc<Box<dyn Source>>>,\n-) -> Result<Option<ResolvedVc<FileSystemPath>>> {\n+) -> Result<Option<FileSystemPath>> {\n     type_exists(fs_path, FileSystemEntryType::File, refs).await\n }\n \n async fn dir_exists(\n-    fs_path: Vc<FileSystemPath>,\n+    fs_path: FileSystemPath,\n     refs: &mut Vec<ResolvedVc<Box<dyn Source>>>,\n-) -> Result<Option<ResolvedVc<FileSystemPath>>> {\n+) -> Result<Option<FileSystemPath>> {\n     type_exists(fs_path, FileSystemEntryType::Directory, refs).await\n }\n \n async fn type_exists(\n-    fs_path: Vc<FileSystemPath>,\n+    fs_path: FileSystemPath,\n     ty: FileSystemEntryType,\n     refs: &mut Vec<ResolvedVc<Box<dyn Source>>>,\n-) -> Result<Option<ResolvedVc<FileSystemPath>>> {\n-    let result = fs_path.resolve().await?.realpath_with_links().await?;\n+) -> Result<Option<FileSystemPath>> {\n+    let result = fs_path.realpath_with_links().await?;\n     refs.extend(\n         result\n             .symlinks\n             .iter()\n             .map(|path| async move {\n                 Ok(ResolvedVc::upcast(\n-                    FileSource::new(**path).to_resolved().await?,\n+                    FileSource::new(path.clone()).to_resolved().await?,\n                 ))\n             })\n             .try_join()\n             .await?,\n     );\n-    let path = result.path;\n+    let path = result.clone_value().path;\n     Ok(if *path.get_type().await? == ty {\n         Some(path)\n     } else {\n@@ -1188,23 +1188,23 @@ async fn type_exists(\n }\n \n async fn any_exists(\n-    fs_path: Vc<FileSystemPath>,\n+    fs_path: FileSystemPath,\n     refs: &mut Vec<ResolvedVc<Box<dyn Source>>>,\n-) -> Result<Option<(FileSystemEntryType, Vc<FileSystemPath>)>> {\n-    let result = fs_path.resolve().await?.realpath_with_links().await?;\n+) -> Result<Option<(FileSystemEntryType, FileSystemPath)>> {\n+    let result = fs_path.realpath_with_links().await?;\n     refs.extend(\n         result\n             .symlinks\n             .iter()\n             .map(|path| async move {\n                 Ok(ResolvedVc::upcast(\n-                    FileSource::new(**path).to_resolved().await?,\n+                    FileSource::new(path.clone()).to_resolved().await?,\n                 ))\n             })\n             .try_join()\n             .await?,\n     );\n-    let path = result.path;\n+    let path = result.clone_value().path;\n     let ty = *path.get_type().await?;\n     Ok(\n         if matches!(\n@@ -1213,7 +1213,7 @@ async fn any_exists(\n         ) {\n             None\n         } else {\n-            Some((ty, *path))\n+            Some((ty, path))\n         },\n     )\n }\n@@ -1227,10 +1227,8 @@ enum ExportsFieldResult {\n /// Extracts the \"exports\" field out of the package.json, parsing it into an\n /// appropriate [AliasMap] for lookups.\n #[turbo_tasks::function]\n-async fn exports_field(\n-    package_json_path: ResolvedVc<FileSystemPath>,\n-) -> Result<Vc<ExportsFieldResult>> {\n-    let read = read_package_json(*package_json_path).await?;\n+async fn exports_field(package_json_path: FileSystemPath) -> Result<Vc<ExportsFieldResult>> {\n+    let read = read_package_json(package_json_path.clone()).await?;\n     let package_json = match &*read {\n         Some(json) => json,\n         None => return Ok(ExportsFieldResult::None.cell()),\n@@ -1257,21 +1255,21 @@ async fn exports_field(\n enum ImportsFieldResult {\n     Some(\n         #[turbo_tasks(debug_ignore, trace_ignore)] ImportsField,\n-        ResolvedVc<FileSystemPath>,\n+        FileSystemPath,\n     ),\n     None,\n }\n \n /// Extracts the \"imports\" field out of the nearest package.json, parsing it\n /// into an appropriate [AliasMap] for lookups.\n #[turbo_tasks::function]\n-async fn imports_field(lookup_path: Vc<FileSystemPath>) -> Result<Vc<ImportsFieldResult>> {\n+async fn imports_field(lookup_path: FileSystemPath) -> Result<Vc<ImportsFieldResult>> {\n     let package_json_context = find_context_file(lookup_path, package_json()).await?;\n     let FindContextFileResult::Found(package_json_path, _refs) = &*package_json_context else {\n         return Ok(ImportsFieldResult::None.cell());\n     };\n \n-    let read = read_package_json(**package_json_path).await?;\n+    let read = read_package_json(package_json_path.clone()).await?;\n     let package_json = match &*read {\n         Some(json) => json,\n         None => return Ok(ImportsFieldResult::None.cell()),\n@@ -1281,10 +1279,10 @@ async fn imports_field(lookup_path: Vc<FileSystemPath>) -> Result<Vc<ImportsFiel\n         return Ok(ImportsFieldResult::None.cell());\n     };\n     match imports.try_into() {\n-        Ok(imports) => Ok(ImportsFieldResult::Some(imports, *package_json_path).cell()),\n+        Ok(imports) => Ok(ImportsFieldResult::Some(imports, package_json_path.clone()).cell()),\n         Err(err) => {\n             PackageJsonIssue {\n-                path: *package_json_path,\n+                path: package_json_path.clone(),\n                 error_message: err.to_string().into(),\n             }\n             .resolved_cell()\n@@ -1301,39 +1299,39 @@ pub fn package_json() -> Vc<Vec<RcStr>> {\n \n #[turbo_tasks::value(shared)]\n pub enum FindContextFileResult {\n-    Found(ResolvedVc<FileSystemPath>, Vec<ResolvedVc<Box<dyn Source>>>),\n+    Found(FileSystemPath, Vec<ResolvedVc<Box<dyn Source>>>),\n     NotFound(Vec<ResolvedVc<Box<dyn Source>>>),\n }\n \n #[turbo_tasks::function]\n pub async fn find_context_file(\n-    lookup_path: Vc<FileSystemPath>,\n+    lookup_path: FileSystemPath,\n     names: Vc<Vec<RcStr>>,\n ) -> Result<Vc<FindContextFileResult>> {\n     let mut refs = Vec::new();\n     for name in &*names.await? {\n-        let fs_path = lookup_path.join(name.clone());\n+        let fs_path = lookup_path.join(name)?;\n         if let Some(fs_path) = exists(fs_path, &mut refs).await? {\n             return Ok(FindContextFileResult::Found(fs_path, refs).cell());\n         }\n     }\n-    if lookup_path.await?.is_root() {\n+    if lookup_path.is_root() {\n         return Ok(FindContextFileResult::NotFound(refs).cell());\n     }\n     if refs.is_empty() {\n         // Tailcall\n         Ok(find_context_file(\n             // Hot codepath optimization: resolve all arguments to avoid an automatically-created\n             // intermediate task\n-            lookup_path.parent().resolve().await?,\n+            lookup_path.parent(),\n             names,\n         ))\n     } else {\n-        let parent_result = find_context_file(lookup_path.parent().resolve().await?, names).await?;\n+        let parent_result = find_context_file(lookup_path.parent(), names).await?;\n         Ok(match &*parent_result {\n             FindContextFileResult::Found(p, r) => {\n                 refs.extend(r.iter().copied());\n-                FindContextFileResult::Found(*p, refs)\n+                FindContextFileResult::Found(p.clone(), refs)\n             }\n             FindContextFileResult::NotFound(r) => {\n                 refs.extend(r.iter().copied());\n@@ -1347,39 +1345,36 @@ pub async fn find_context_file(\n // Same as find_context_file, but also stop for package.json with the specified key\n #[turbo_tasks::function]\n pub async fn find_context_file_or_package_key(\n-    lookup_path: Vc<FileSystemPath>,\n+    lookup_path: FileSystemPath,\n     names: Vc<Vec<RcStr>>,\n     package_key: RcStr,\n ) -> Result<Vc<FindContextFileResult>> {\n     let mut refs = Vec::new();\n-    let package_json_path = lookup_path.join(rcstr!(\"package.json\"));\n+    let package_json_path = lookup_path.join(\"package.json\")?;\n     if let Some(package_json_path) = exists(package_json_path, &mut refs).await?\n-        && let Some(json) = &*read_package_json(*package_json_path).await?\n+        && let Some(json) = &*read_package_json(package_json_path.clone()).await?\n         && json.get(&*package_key).is_some()\n     {\n         return Ok(FindContextFileResult::Found(package_json_path, refs).into());\n     }\n     for name in &*names.await? {\n-        let fs_path = lookup_path.join(name.clone());\n+        let fs_path = lookup_path.join(name)?;\n         if let Some(fs_path) = exists(fs_path, &mut refs).await? {\n             return Ok(FindContextFileResult::Found(fs_path, refs).into());\n         }\n     }\n-    if lookup_path.await?.is_root() {\n+    if lookup_path.is_root() {\n         return Ok(FindContextFileResult::NotFound(refs).into());\n     }\n     if refs.is_empty() {\n         // Tailcall\n-        Ok(find_context_file(\n-            lookup_path.parent().resolve().await?,\n-            names,\n-        ))\n+        Ok(find_context_file(lookup_path.parent(), names))\n     } else {\n-        let parent_result = find_context_file(lookup_path.parent().resolve().await?, names).await?;\n+        let parent_result = find_context_file(lookup_path.parent(), names).await?;\n         Ok(match &*parent_result {\n             FindContextFileResult::Found(p, r) => {\n                 refs.extend(r.iter().copied());\n-                FindContextFileResult::Found(*p, refs)\n+                FindContextFileResult::Found(p.clone(), refs)\n             }\n             FindContextFileResult::NotFound(r) => {\n                 refs.extend(r.iter().copied());\n@@ -1390,10 +1385,10 @@ pub async fn find_context_file_or_package_key(\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, Debug, NonLocalValue)]\n+#[derive(Clone, PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, Debug, NonLocalValue)]\n enum FindPackageItem {\n-    PackageDirectory(ResolvedVc<FileSystemPath>),\n-    PackageFile(ResolvedVc<FileSystemPath>),\n+    PackageDirectory(FileSystemPath),\n+    PackageFile(FileSystemPath),\n }\n \n #[turbo_tasks::value]\n@@ -1404,7 +1399,7 @@ struct FindPackageResult {\n \n #[turbo_tasks::function]\n async fn find_package(\n-    lookup_path: Vc<FileSystemPath>,\n+    lookup_path: FileSystemPath,\n     package_name: RcStr,\n     options: Vc<ResolveModulesOptions>,\n ) -> Result<Vc<FindPackageResult>> {\n@@ -1414,25 +1409,25 @@ async fn find_package(\n     for resolve_modules in &options.modules {\n         match resolve_modules {\n             ResolveModules::Nested(root_vc, names) => {\n-                let mut lookup_path = lookup_path;\n-                let mut lookup_path_value = lookup_path.await?;\n+                let mut lookup_path = lookup_path.clone();\n+                let mut lookup_path_value = lookup_path.clone();\n                 // For clippy -- This explicit deref is necessary\n-                let root = &*root_vc.await?;\n-                while lookup_path_value.is_inside_ref(root) {\n+                let root = root_vc.clone();\n+                while lookup_path_value.is_inside_ref(&root) {\n                     for name in names.iter() {\n-                        let fs_path = lookup_path.join(name.clone());\n+                        let fs_path = lookup_path.join(name)?;\n                         if let Some(fs_path) = dir_exists(fs_path, &mut affecting_sources).await? {\n-                            let fs_path = fs_path.join(package_name.clone());\n+                            let fs_path = fs_path.join(&package_name.clone())?;\n                             if let Some(fs_path) =\n-                                dir_exists(fs_path, &mut affecting_sources).await?\n+                                dir_exists(fs_path.clone(), &mut affecting_sources).await?\n                             {\n                                 packages.push(FindPackageItem::PackageDirectory(fs_path));\n                             }\n                         }\n                     }\n-                    lookup_path = lookup_path.parent().resolve().await?;\n-                    let new_context_value = lookup_path.await?;\n-                    if *new_context_value == *lookup_path_value {\n+                    lookup_path = lookup_path.parent();\n+                    let new_context_value = lookup_path.clone();\n+                    if new_context_value == lookup_path_value {\n                         break;\n                     }\n                     lookup_path_value = new_context_value;\n@@ -1443,20 +1438,16 @@ async fn find_package(\n                 excluded_extensions,\n             } => {\n                 let excluded_extensions = excluded_extensions.await?;\n-                let package_dir = dir.join(package_name.clone());\n+                let package_dir = dir.join(&package_name)?;\n                 if let Some((ty, package_dir)) =\n-                    any_exists(package_dir, &mut affecting_sources).await?\n+                    any_exists(package_dir.clone(), &mut affecting_sources).await?\n                 {\n                     match ty {\n                         FileSystemEntryType::Directory => {\n-                            packages.push(FindPackageItem::PackageDirectory(\n-                                package_dir.to_resolved().await?,\n-                            ));\n+                            packages.push(FindPackageItem::PackageDirectory(package_dir.clone()));\n                         }\n                         FileSystemEntryType::File => {\n-                            packages.push(FindPackageItem::PackageFile(\n-                                package_dir.to_resolved().await?,\n-                            ));\n+                            packages.push(FindPackageItem::PackageFile(package_dir.clone()));\n                         }\n                         _ => {}\n                     }\n@@ -1465,7 +1456,7 @@ async fn find_package(\n                     if excluded_extensions.contains(extension) {\n                         continue;\n                     }\n-                    let package_file = package_dir.append(extension.clone());\n+                    let package_file = package_dir.append(&extension.clone())?;\n                     if let Some(package_file) = exists(package_file, &mut affecting_sources).await?\n                     {\n                         packages.push(FindPackageItem::PackageFile(package_file));\n@@ -1511,23 +1502,20 @@ fn merge_results_with_affecting_sources(\n \n #[turbo_tasks::function]\n pub async fn resolve_raw(\n-    lookup_dir: Vc<FileSystemPath>,\n+    lookup_dir: FileSystemPath,\n     path: Vc<Pattern>,\n     force_in_lookup_dir: bool,\n ) -> Result<Vc<ResolveResult>> {\n-    async fn to_result(\n-        request: &str,\n-        path: ResolvedVc<FileSystemPath>,\n-    ) -> Result<Vc<ResolveResult>> {\n+    async fn to_result(request: &str, path: FileSystemPath) -> Result<Vc<ResolveResult>> {\n         let RealPathResult { path, symlinks } = &*path.realpath_with_links().await?;\n         Ok(*ResolveResult::source_with_affecting_sources(\n             RequestKey::new(request.into()),\n-            ResolvedVc::upcast(FileSource::new(**path).to_resolved().await?),\n+            ResolvedVc::upcast(FileSource::new(path.clone()).to_resolved().await?),\n             symlinks\n                 .iter()\n                 .map(|symlink| async move {\n                     anyhow::Ok(ResolvedVc::upcast(\n-                        FileSource::new(**symlink).to_resolved().await?,\n+                        FileSource::new(symlink.clone()).to_resolved().await?,\n                     ))\n                 })\n                 .try_join()\n@@ -1537,14 +1525,20 @@ pub async fn resolve_raw(\n \n     let mut results = Vec::new();\n \n-    let lookup_dir_str = lookup_dir.to_string().await?;\n+    let lookup_dir_str = lookup_dir.value_to_string().await?;\n     let pat = path.await?;\n     if let Some(pat) = pat\n         .filter_could_match(\"/ROOT/\")\n         .and_then(|pat| pat.filter_could_not_match(\"/ROOT/fsd8nz8og54z\"))\n     {\n         let path = Pattern::new(pat);\n-        let matches = read_matches(lookup_dir.root(), rcstr!(\"/ROOT/\"), true, path).await?;\n+        let matches = read_matches(\n+            lookup_dir.root().await?.clone_value(),\n+            rcstr!(\"/ROOT/\"),\n+            true,\n+            path,\n+        )\n+        .await?;\n         if matches.len() > 10000 {\n             let path_str = path.to_string().await?;\n             println!(\n@@ -1556,7 +1550,7 @@ pub async fn resolve_raw(\n         } else {\n             for m in matches.iter() {\n                 if let PatternMatch::File(request, path) = m {\n-                    results.push(to_result(request, *path).await?);\n+                    results.push(to_result(request, path.clone()).await?);\n                 }\n             }\n         }\n@@ -1574,7 +1568,7 @@ pub async fn resolve_raw(\n         }\n         for m in matches.iter() {\n             if let PatternMatch::File(request, path) = m {\n-                results.push(to_result(request, *path).await?);\n+                results.push(to_result(request, path.clone()).await?);\n             }\n         }\n     }\n@@ -1584,7 +1578,7 @@ pub async fn resolve_raw(\n \n #[turbo_tasks::function]\n pub async fn resolve(\n-    lookup_path: Vc<FileSystemPath>,\n+    lookup_path: FileSystemPath,\n     reference_type: ReferenceType,\n     request: Vc<Request>,\n     options: Vc<ResolveOptions>,\n@@ -1593,13 +1587,13 @@ pub async fn resolve(\n }\n \n pub async fn resolve_inline(\n-    lookup_path: Vc<FileSystemPath>,\n+    lookup_path: FileSystemPath,\n     reference_type: ReferenceType,\n     request: Vc<Request>,\n     options: Vc<ResolveOptions>,\n ) -> Result<Vc<ResolveResult>> {\n     let span = {\n-        let lookup_path = lookup_path.to_string().await?.to_string();\n+        let lookup_path = lookup_path.value_to_string().await?.to_string();\n         let request = request.to_string().await?.to_string();\n         tracing::info_span!(\n             \"resolving\",\n@@ -1609,14 +1603,18 @@ pub async fn resolve_inline(\n         )\n     };\n     async {\n-        let before_plugins_result =\n-            handle_before_resolve_plugins(lookup_path, reference_type.clone(), request, options)\n-                .await?;\n+        let before_plugins_result = handle_before_resolve_plugins(\n+            lookup_path.clone(),\n+            reference_type.clone(),\n+            request,\n+            options,\n+        )\n+        .await?;\n \n         let raw_result = match before_plugins_result {\n             Some(result) => result,\n             None => {\n-                resolve_internal(lookup_path, request, options)\n+                resolve_internal(lookup_path.clone(), request, options)\n                     .resolve()\n                     .await?\n             }\n@@ -1639,18 +1637,18 @@ pub async fn url_resolve(\n     issue_source: Option<IssueSource>,\n     is_optional: bool,\n ) -> Result<Vc<ModuleResolveResult>> {\n-    let resolve_options = origin.resolve_options(reference_type.clone());\n+    let resolve_options = origin.resolve_options(reference_type.clone()).await?;\n     let rel_request = request.as_relative();\n     let rel_result = resolve(\n-        origin.origin_path().parent(),\n+        origin.origin_path().await?.parent(),\n         reference_type.clone(),\n         rel_request,\n         resolve_options,\n     );\n     let result = if *rel_result.is_unresolvable().await? && rel_request.resolve().await? != request\n     {\n         resolve(\n-            origin.origin_path().parent(),\n+            origin.origin_path().await?.parent(),\n             reference_type.clone(),\n             request,\n             resolve_options,\n@@ -1671,7 +1669,7 @@ pub async fn url_resolve(\n     handle_resolve_error(\n         result,\n         reference_type,\n-        origin.origin_path(),\n+        origin.origin_path().await?.clone_value(),\n         request,\n         resolve_options,\n         is_optional,\n@@ -1682,7 +1680,7 @@ pub async fn url_resolve(\n \n #[tracing::instrument(level = \"trace\", skip_all)]\n async fn handle_before_resolve_plugins(\n-    lookup_path: Vc<FileSystemPath>,\n+    lookup_path: FileSystemPath,\n     reference_type: ReferenceType,\n     request: Vc<Request>,\n     options: Vc<ResolveOptions>,\n@@ -1694,7 +1692,7 @@ async fn handle_before_resolve_plugins(\n         }\n \n         if let Some(result) = *plugin\n-            .before_resolve(lookup_path, reference_type.clone(), request)\n+            .before_resolve(lookup_path.clone(), reference_type.clone(), request)\n             .await?\n         {\n             return Ok(Some(*result));\n@@ -1705,24 +1703,29 @@ async fn handle_before_resolve_plugins(\n \n #[tracing::instrument(level = \"trace\", skip_all)]\n async fn handle_after_resolve_plugins(\n-    lookup_path: Vc<FileSystemPath>,\n+    lookup_path: FileSystemPath,\n     reference_type: ReferenceType,\n     request: Vc<Request>,\n     options: Vc<ResolveOptions>,\n     result: Vc<ResolveResult>,\n ) -> Result<Vc<ResolveResult>> {\n     async fn apply_plugins_to_path(\n-        path: Vc<FileSystemPath>,\n-        lookup_path: Vc<FileSystemPath>,\n+        path: FileSystemPath,\n+        lookup_path: FileSystemPath,\n         reference_type: ReferenceType,\n         request: Vc<Request>,\n         options: Vc<ResolveOptions>,\n     ) -> Result<Option<Vc<ResolveResult>>> {\n         for plugin in &options.await?.after_resolve_plugins {\n             let after_resolve_condition = plugin.after_resolve_condition().resolve().await?;\n-            if *after_resolve_condition.matches(path).await?\n+            if *after_resolve_condition.matches(path.clone()).await?\n                 && let Some(result) = *plugin\n-                    .after_resolve(path, lookup_path, reference_type.clone(), request)\n+                    .after_resolve(\n+                        path.clone(),\n+                        lookup_path.clone(),\n+                        reference_type.clone(),\n+                        request,\n+                    )\n                     .await?\n             {\n                 return Ok(Some(*result));\n@@ -1739,10 +1742,15 @@ async fn handle_after_resolve_plugins(\n \n     for (key, primary) in result_value.primary.iter() {\n         if let &ResolveResultItem::Source(source) = primary {\n-            let path = source.ident().path().resolve().await?;\n-            if let Some(new_result) =\n-                apply_plugins_to_path(path, lookup_path, reference_type.clone(), request, options)\n-                    .await?\n+            let path = source.ident().path().await?.clone_value();\n+            if let Some(new_result) = apply_plugins_to_path(\n+                path.clone(),\n+                lookup_path.clone(),\n+                reference_type.clone(),\n+                request,\n+                options,\n+            )\n+            .await?\n             {\n                 let new_result = new_result.await?;\n                 changed = true;\n@@ -1777,20 +1785,20 @@ async fn handle_after_resolve_plugins(\n \n #[turbo_tasks::function]\n async fn resolve_internal(\n-    lookup_path: ResolvedVc<FileSystemPath>,\n+    lookup_path: FileSystemPath,\n     request: ResolvedVc<Request>,\n     options: ResolvedVc<ResolveOptions>,\n ) -> Result<Vc<ResolveResult>> {\n-    resolve_internal_inline(*lookup_path, *request, *options).await\n+    resolve_internal_inline(lookup_path.clone(), *request, *options).await\n }\n \n async fn resolve_internal_inline(\n-    lookup_path: Vc<FileSystemPath>,\n+    lookup_path: FileSystemPath,\n     request: Vc<Request>,\n     options: Vc<ResolveOptions>,\n ) -> Result<Vc<ResolveResult>> {\n     let span = {\n-        let lookup_path = lookup_path.to_string().await?.to_string();\n+        let lookup_path = lookup_path.value_to_string().await?.to_string();\n         let request = request.to_string().await?.to_string();\n         tracing::info_span!(\n             \"internal resolving\",\n@@ -1811,13 +1819,16 @@ async fn resolve_internal_inline(\n                 _ => &[request.to_resolved().await?],\n             };\n             for &request in request_parts {\n-                let result = import_map.await?.lookup(lookup_path, *request).await?;\n+                let result = import_map\n+                    .await?\n+                    .lookup(lookup_path.clone(), *request)\n+                    .await?;\n                 if !matches!(result, ImportMapResult::NoEntry) {\n                     has_alias = true;\n                     let resolved_result = resolve_import_map_result(\n                         &result,\n-                        lookup_path,\n-                        lookup_path,\n+                        lookup_path.clone(),\n+                        lookup_path.clone(),\n                         *request,\n                         options,\n                         request.query().owned().await?,\n@@ -1843,7 +1854,9 @@ async fn resolve_internal_inline(\n             Request::Alternatives { requests } => {\n                 let results = requests\n                     .iter()\n-                    .map(|req| async { resolve_internal_inline(lookup_path, **req, options).await })\n+                    .map(|req| async {\n+                        resolve_internal_inline(lookup_path.clone(), **req, options).await\n+                    })\n                     .try_join()\n                     .await?;\n \n@@ -1857,7 +1870,7 @@ async fn resolve_internal_inline(\n             } => {\n                 let mut results = Vec::new();\n                 let matches = read_matches(\n-                    lookup_path,\n+                    lookup_path.clone(),\n                     rcstr!(\"\"),\n                     *force_in_lookup_dir,\n                     Pattern::new(path.clone()).resolve().await?,\n@@ -1870,8 +1883,8 @@ async fn resolve_internal_inline(\n                             results.push(\n                                 resolved(\n                                     RequestKey::new(matched_pattern.clone()),\n-                                    **path,\n-                                    lookup_path,\n+                                    path.clone(),\n+                                    lookup_path.clone(),\n                                     request,\n                                     options_value,\n                                     options,\n@@ -1883,7 +1896,7 @@ async fn resolve_internal_inline(\n                         }\n                         PatternMatch::Directory(matched_pattern, path) => {\n                             results.push(\n-                                resolve_into_folder(**path, options)\n+                                resolve_into_folder(path.clone(), options)\n                                     .with_request(matched_pattern.clone()),\n                             );\n                         }\n@@ -1900,7 +1913,7 @@ async fn resolve_internal_inline(\n             } => {\n                 if !fragment.is_empty()\n                     && let Ok(result) = resolve_relative_request(\n-                        lookup_path,\n+                        lookup_path.clone(),\n                         request,\n                         options,\n                         options_value,\n@@ -1915,7 +1928,7 @@ async fn resolve_internal_inline(\n                 }\n                 // Resolve without fragment\n                 resolve_relative_request(\n-                    lookup_path,\n+                    lookup_path.clone(),\n                     request,\n                     options,\n                     options_value,\n@@ -1933,7 +1946,7 @@ async fn resolve_internal_inline(\n                 fragment,\n             } => {\n                 resolve_module_request(\n-                    lookup_path,\n+                    lookup_path.clone(),\n                     request,\n                     options,\n                     options_value,\n@@ -1958,7 +1971,7 @@ async fn resolve_internal_inline(\n                         severity: error_severity(options).await?,\n                         request_type: \"server relative import: not implemented yet\".to_string(),\n                         request: relative.to_resolved().await?,\n-                        file_path: lookup_path.to_resolved().await?,\n+                        file_path: lookup_path.clone(),\n                         resolve_options: options.to_resolved().await?,\n                         error_message: Some(\n                             \"server relative imports are not implemented yet. Please try an \\\n@@ -1972,7 +1985,7 @@ async fn resolve_internal_inline(\n                 }\n \n                 Box::pin(resolve_internal_inline(\n-                    lookup_path.root(),\n+                    lookup_path.root().await?.clone_value(),\n                     relative,\n                     options,\n                 ))\n@@ -1988,7 +2001,7 @@ async fn resolve_internal_inline(\n                         severity: error_severity(options).await?,\n                         request_type: \"windows import: not implemented yet\".to_string(),\n                         request: request.to_resolved().await?,\n-                        file_path: lookup_path.to_resolved().await?,\n+                        file_path: lookup_path.clone(),\n                         resolve_options: options.to_resolved().await?,\n                         error_message: Some(\"windows imports are not implemented yet\".to_string()),\n                         source: None,\n@@ -2014,7 +2027,7 @@ async fn resolve_internal_inline(\n                     })\n                     .unwrap_or_else(|| (Default::default(), ConditionValue::Unset));\n                 resolve_package_internal_with_imports_field(\n-                    lookup_path,\n+                    lookup_path.clone(),\n                     request,\n                     options,\n                     path,\n@@ -2040,7 +2053,7 @@ async fn resolve_internal_inline(\n                                 media_type.clone(),\n                                 encoding.clone(),\n                                 **data,\n-                                lookup_path,\n+                                lookup_path.clone(),\n                             )\n                             .to_resolved()\n                             .await?,\n@@ -2079,7 +2092,7 @@ async fn resolve_internal_inline(\n                         severity: error_severity(options).await?,\n                         request_type: format!(\"unknown import: `{path}`\"),\n                         request: request.to_resolved().await?,\n-                        file_path: lookup_path.to_resolved().await?,\n+                        file_path: lookup_path.clone(),\n                         resolve_options: options.to_resolved().await?,\n                         error_message: None,\n                         source: None,\n@@ -2095,11 +2108,14 @@ async fn resolve_internal_inline(\n         if let Some(import_map) = &options_value.fallback_import_map\n             && *result.is_unresolvable().await?\n         {\n-            let result = import_map.await?.lookup(lookup_path, request).await?;\n+            let result = import_map\n+                .await?\n+                .lookup(lookup_path.clone(), request)\n+                .await?;\n             let resolved_result = resolve_import_map_result(\n                 &result,\n-                lookup_path,\n-                lookup_path,\n+                lookup_path.clone(),\n+                lookup_path.clone(),\n                 request,\n                 options,\n                 request.query().owned().await?,\n@@ -2120,16 +2136,16 @@ async fn resolve_internal_inline(\n \n #[turbo_tasks::function]\n async fn resolve_into_folder(\n-    package_path: ResolvedVc<FileSystemPath>,\n+    package_path: FileSystemPath,\n     options: Vc<ResolveOptions>,\n ) -> Result<Vc<ResolveResult>> {\n-    let package_json_path = package_path.join(rcstr!(\"package.json\"));\n+    let package_json_path = package_path.join(\"package.json\")?;\n     let options_value = options.await?;\n \n     for resolve_into_package in options_value.into_package.iter() {\n         match resolve_into_package {\n             ResolveIntoPackage::MainField { field: name } => {\n-                if let Some(package_json) = &*read_package_json(package_json_path).await?\n+                if let Some(package_json) = &*read_package_json(package_json_path.clone()).await?\n                     && let Some(field_value) = package_json[name.as_str()].as_str()\n                 {\n                     let normalized_request: RcStr = normalize_request(field_value).into();\n@@ -2147,7 +2163,7 @@ async fn resolve_into_folder(\n                     } else {\n                         options\n                     };\n-                    let result = &*resolve_internal_inline(*package_path, request, options)\n+                    let result = &*resolve_internal_inline(package_path.clone(), request, options)\n                         .await?\n                         .await?;\n                     // we are not that strict when a main field fails to resolve\n@@ -2184,14 +2200,16 @@ async fn resolve_into_folder(\n \n     let request = Request::parse(pattern);\n \n-    Ok(resolve_internal_inline(*package_path, request, options)\n-        .await?\n-        .with_request(rcstr!(\".\")))\n+    Ok(\n+        resolve_internal_inline(package_path.clone(), request, options)\n+            .await?\n+            .with_request(rcstr!(\".\")),\n+    )\n }\n \n #[tracing::instrument(level = Level::TRACE, skip_all)]\n async fn resolve_relative_request(\n-    lookup_path: Vc<FileSystemPath>,\n+    lookup_path: FileSystemPath,\n     request: Vc<Request>,\n     options: Vc<ResolveOptions>,\n     options_value: &ResolveOptions,\n@@ -2201,14 +2219,14 @@ async fn resolve_relative_request(\n     fragment: RcStr,\n ) -> Result<Vc<ResolveResult>> {\n     // Check alias field for aliases first\n-    let lookup_path_ref = &*lookup_path.await?;\n+    let lookup_path_ref = lookup_path.clone();\n     if let Some(result) = apply_in_package(\n-        lookup_path,\n+        lookup_path.clone(),\n         options,\n         options_value,\n         |package_path| {\n             let request = path_pattern.as_string()?;\n-            let prefix_path = package_path.get_path_to(lookup_path_ref)?;\n+            let prefix_path = package_path.get_path_to(&lookup_path_ref)?;\n             let request = normalize_request(&format!(\"./{prefix_path}/{request}\"));\n             Some(request.into())\n         },\n@@ -2288,7 +2306,7 @@ async fn resolve_relative_request(\n \n     let mut results = Vec::new();\n     let matches = read_matches(\n-        lookup_path,\n+        lookup_path.clone(),\n         rcstr!(\"\"),\n         force_in_lookup_dir,\n         Pattern::new(new_path).resolve().await?,\n@@ -2314,8 +2332,8 @@ async fn resolve_relative_request(\n                             results.push(\n                                 resolved(\n                                     RequestKey::new(matched_pattern.into()),\n-                                    **path,\n-                                    lookup_path,\n+                                    path.clone(),\n+                                    lookup_path.clone(),\n                                     request,\n                                     options_value,\n                                     options,\n@@ -2331,8 +2349,8 @@ async fn resolve_relative_request(\n                         results.push(\n                             resolved(\n                                 RequestKey::new(matched_pattern.into()),\n-                                **path,\n-                                lookup_path,\n+                                path.clone(),\n+                                lookup_path.clone(),\n                                 request,\n                                 options_value,\n                                 options,\n@@ -2351,8 +2369,8 @@ async fn resolve_relative_request(\n                     results.push(\n                         resolved(\n                             RequestKey::new(matched_pattern.into()),\n-                            **path,\n-                            lookup_path,\n+                            path.clone(),\n+                            lookup_path.clone(),\n                             request,\n                             options_value,\n                             options,\n@@ -2369,8 +2387,8 @@ async fn resolve_relative_request(\n                 results.push(\n                     resolved(\n                         RequestKey::new(matched_pattern.clone()),\n-                        **path,\n-                        lookup_path,\n+                        path.clone(),\n+                        lookup_path.clone(),\n                         request,\n                         options_value,\n                         options,\n@@ -2385,8 +2403,9 @@ async fn resolve_relative_request(\n     // Directory matches must be resolved AFTER file matches\n     for m in matches.iter() {\n         if let PatternMatch::Directory(matched_pattern, path) = m {\n-            results\n-                .push(resolve_into_folder(**path, options).with_request(matched_pattern.clone()));\n+            results.push(\n+                resolve_into_folder(path.clone(), options).with_request(matched_pattern.clone()),\n+            );\n         }\n     }\n \n@@ -2395,7 +2414,7 @@ async fn resolve_relative_request(\n \n #[tracing::instrument(level = Level::TRACE, skip_all)]\n async fn apply_in_package(\n-    lookup_path: Vc<FileSystemPath>,\n+    lookup_path: FileSystemPath,\n     options: Vc<ResolveOptions>,\n     options_value: &ResolveOptions,\n     get_request: impl Fn(&FileSystemPath) -> Option<RcStr>,\n@@ -2412,12 +2431,12 @@ async fn apply_in_package(\n         };\n \n         let FindContextFileResult::Found(package_json_path, refs) =\n-            &*find_context_file(lookup_path, package_json().resolve().await?).await?\n+            &*find_context_file(lookup_path.clone(), package_json().resolve().await?).await?\n         else {\n             continue;\n         };\n \n-        let read = read_package_json(**package_json_path).await?;\n+        let read = read_package_json(package_json_path.clone()).await?;\n         let Some(package_json) = &*read else {\n             continue;\n         };\n@@ -2426,9 +2445,9 @@ async fn apply_in_package(\n             continue;\n         };\n \n-        let package_path = package_json_path.parent().resolve().await?;\n+        let package_path = package_json_path.parent();\n \n-        let Some(request) = get_request(&*package_path.await?) else {\n+        let Some(request) = get_request(&package_path) else {\n             continue;\n         };\n \n@@ -2474,7 +2493,7 @@ async fn apply_in_package(\n \n         ResolvingIssue {\n             severity: error_severity(options).await?,\n-            file_path: *package_json_path,\n+            file_path: package_json_path.clone(),\n             request_type: format!(\"alias field ({field})\"),\n             request: Request::parse(Pattern::Constant(request))\n                 .to_resolved()\n@@ -2497,7 +2516,7 @@ async fn apply_in_package(\n enum FindSelfReferencePackageResult {\n     Found {\n         name: String,\n-        package_path: ResolvedVc<FileSystemPath>,\n+        package_path: FileSystemPath,\n     },\n     NotFound,\n }\n@@ -2506,18 +2525,18 @@ enum FindSelfReferencePackageResult {\n /// Finds the nearest folder containing package.json that could be used for a\n /// self-reference (i.e. has an exports fields).\n async fn find_self_reference(\n-    lookup_path: Vc<FileSystemPath>,\n+    lookup_path: FileSystemPath,\n ) -> Result<Vc<FindSelfReferencePackageResult>> {\n     let package_json_context = find_context_file(lookup_path, package_json()).await?;\n     if let FindContextFileResult::Found(package_json_path, _refs) = &*package_json_context {\n-        let read = read_package_json(**package_json_path).await?;\n+        let read = read_package_json(package_json_path.clone()).await?;\n         if let Some(json) = &*read\n             && json.get(\"exports\").is_some()\n             && let Some(name) = json[\"name\"].as_str()\n         {\n             return Ok(FindSelfReferencePackageResult::Found {\n                 name: name.to_string(),\n-                package_path: package_json_path.parent().to_resolved().await?,\n+                package_path: package_json_path.parent(),\n             }\n             .cell());\n         }\n@@ -2527,7 +2546,7 @@ async fn find_self_reference(\n \n #[tracing::instrument(level = Level::TRACE, skip_all)]\n async fn resolve_module_request(\n-    lookup_path: Vc<FileSystemPath>,\n+    lookup_path: FileSystemPath,\n     request: Vc<Request>,\n     options: Vc<ResolveOptions>,\n     options_value: &ResolveOptions,\n@@ -2538,7 +2557,7 @@ async fn resolve_module_request(\n ) -> Result<Vc<ResolveResult>> {\n     // Check alias field for module aliases first\n     if let Some(result) = apply_in_package(\n-        lookup_path,\n+        lookup_path.clone(),\n         options,\n         options_value,\n         |_| {\n@@ -2557,12 +2576,12 @@ async fn resolve_module_request(\n     // module. This should match only using the exports field and no other\n     // fields/fallbacks.\n     if let FindSelfReferencePackageResult::Found { name, package_path } =\n-        &*find_self_reference(lookup_path).await?\n+        &*find_self_reference(lookup_path.clone()).await?\n         && name == module\n     {\n         let result = resolve_into_package(\n             path.clone(),\n-            **package_path,\n+            package_path.clone(),\n             query.clone(),\n             fragment.clone(),\n             options,\n@@ -2573,7 +2592,7 @@ async fn resolve_module_request(\n     }\n \n     let result = find_package(\n-        lookup_path,\n+        lookup_path.clone(),\n         module.into(),\n         resolve_modules_options(options).resolve().await?,\n     )\n@@ -2593,11 +2612,11 @@ async fn resolve_module_request(\n     // \"[baseUrl]/foo/bar\" or \"[baseUrl]/node_modules/foo/bar\", and we'll need to\n     // try both.\n     for item in &result.packages {\n-        match *item {\n+        match item {\n             FindPackageItem::PackageDirectory(package_path) => {\n                 results.push(resolve_into_package(\n                     path.clone(),\n-                    *package_path,\n+                    package_path.clone(),\n                     query.clone(),\n                     fragment.clone(),\n                     options,\n@@ -2607,8 +2626,8 @@ async fn resolve_module_request(\n                 if path.is_match(\"\") {\n                     let resolved = resolved(\n                         RequestKey::new(rcstr!(\".\")),\n-                        *package_path,\n-                        lookup_path,\n+                        package_path.clone(),\n+                        lookup_path.clone(),\n                         request,\n                         options_value,\n                         options,\n@@ -2636,8 +2655,12 @@ async fn resolve_module_request(\n         let relative = Request::relative(pattern, query, fragment, true)\n             .to_resolved()\n             .await?;\n-        let relative_result =\n-            Box::pin(resolve_internal_inline(lookup_path, *relative, options)).await?;\n+        let relative_result = Box::pin(resolve_internal_inline(\n+            lookup_path.clone(),\n+            *relative,\n+            options,\n+        ))\n+        .await?;\n         let relative_result = relative_result\n             .with_replaced_request_key(module_prefix, RequestKey::new(module.into()));\n \n@@ -2650,7 +2673,7 @@ async fn resolve_module_request(\n #[turbo_tasks::function]\n async fn resolve_into_package(\n     path: Pattern,\n-    package_path: ResolvedVc<FileSystemPath>,\n+    package_path: FileSystemPath,\n     query: RcStr,\n     fragment: RcStr,\n     options: ResolvedVc<ResolveOptions>,\n@@ -2669,9 +2692,9 @@ async fn resolve_into_package(\n                 conditions,\n                 unspecified_conditions,\n             } => {\n-                let package_json_path = package_path.join(rcstr!(\"package.json\"));\n+                let package_json_path = package_path.join(\"package.json\")?;\n                 let ExportsFieldResult::Some(exports_field) =\n-                    &*exports_field(package_json_path).await?\n+                    &*exports_field(package_json_path.clone()).await?\n                 else {\n                     continue;\n                 };\n@@ -2688,7 +2711,7 @@ async fn resolve_into_package(\n \n                 results.push(\n                     handle_exports_imports_field(\n-                        *package_path,\n+                        package_path.clone(),\n                         package_json_path,\n                         *options,\n                         exports_field,\n@@ -2710,7 +2733,7 @@ async fn resolve_into_package(\n     // apply main field(s) or fallback to index.js if there's no subpath\n     if is_root_match {\n         results.push(resolve_into_folder(\n-            *package_path,\n+            package_path.clone(),\n             options.with_fully_specified(false),\n         ));\n     }\n@@ -2722,7 +2745,7 @@ async fn resolve_into_package(\n         let relative = Request::relative(new_pat, query, fragment, true)\n             .to_resolved()\n             .await?;\n-        results.push(resolve_internal_inline(*package_path, *relative, *options).await?);\n+        results.push(resolve_internal_inline(package_path.clone(), *relative, *options).await?);\n     }\n \n     Ok(merge_results(results))\n@@ -2731,8 +2754,8 @@ async fn resolve_into_package(\n #[tracing::instrument(level = Level::TRACE, skip_all)]\n async fn resolve_import_map_result(\n     result: &ImportMapResult,\n-    lookup_path: Vc<FileSystemPath>,\n-    original_lookup_path: Vc<FileSystemPath>,\n+    lookup_path: FileSystemPath,\n+    original_lookup_path: FileSystemPath,\n     original_request: Vc<Request>,\n     options: Vc<ResolveOptions>,\n     query: RcStr,\n@@ -2742,7 +2765,7 @@ async fn resolve_import_map_result(\n         ImportMapResult::Alias(request, alias_lookup_path) => {\n             let request = **request;\n             let lookup_path = match alias_lookup_path {\n-                Some(path) => **path,\n+                Some(path) => path.clone(),\n                 None => lookup_path,\n             };\n             // We must avoid cycles during resolving\n@@ -2773,20 +2796,20 @@ async fn resolve_import_map_result(\n \n             // We must avoid cycles during resolving\n             if request.resolve().await? == original_request\n-                && **alias_lookup_path == original_lookup_path\n+                && *alias_lookup_path == original_lookup_path\n             {\n                 None\n             } else {\n                 let is_external_resolvable = !resolve_internal(\n-                    **alias_lookup_path,\n+                    alias_lookup_path.clone(),\n                     request,\n                     match ty {\n                         // TODO is that root correct?\n                         ExternalType::CommonJs => {\n-                            node_cjs_resolve_options(alias_lookup_path.root())\n+                            node_cjs_resolve_options(alias_lookup_path.root().await?.clone_value())\n                         }\n                         ExternalType::EcmaScriptModule => {\n-                            node_esm_resolve_options(alias_lookup_path.root())\n+                            node_esm_resolve_options(alias_lookup_path.root().await?.clone_value())\n                         }\n                         ExternalType::Script | ExternalType::Url | ExternalType::Global => options,\n                     },\n@@ -2810,8 +2833,8 @@ async fn resolve_import_map_result(\n                 .map(|result| {\n                     Box::pin(resolve_import_map_result(\n                         result,\n-                        lookup_path,\n-                        original_lookup_path,\n+                        lookup_path.clone(),\n+                        original_lookup_path.clone(),\n                         original_request,\n                         options,\n                         query.clone(),\n@@ -2829,8 +2852,8 @@ async fn resolve_import_map_result(\n #[tracing::instrument(level = Level::TRACE, skip_all)]\n async fn resolved(\n     request_key: RequestKey,\n-    fs_path: Vc<FileSystemPath>,\n-    original_context: Vc<FileSystemPath>,\n+    fs_path: FileSystemPath,\n+    original_context: FileSystemPath,\n     original_request: Vc<Request>,\n     options_value: &ResolveOptions,\n     options: Vc<ResolveOptions>,\n@@ -2839,13 +2862,13 @@ async fn resolved(\n ) -> Result<Vc<ResolveResult>> {\n     let RealPathResult { path, symlinks } = &*fs_path.realpath_with_links().await?;\n \n-    let path_ref = &*path.await?;\n+    let path_ref = path.clone();\n     // Check alias field for path aliases first\n     if let Some(result) = apply_in_package(\n-        path.parent().resolve().await?,\n+        path.parent(),\n         options,\n         options_value,\n-        |package_path| package_path.get_relative_path_to(path_ref),\n+        |package_path| package_path.get_relative_path_to(&path_ref),\n         query.clone(),\n         fragment.clone(),\n     )\n@@ -2856,13 +2879,13 @@ async fn resolved(\n \n     if let Some(resolved_map) = options_value.resolved_map {\n         let result = resolved_map\n-            .lookup(**path, original_context, original_request)\n+            .lookup(path.clone(), original_context.clone(), original_request)\n             .await?;\n \n         let resolved_result = resolve_import_map_result(\n             &result,\n             path.parent(),\n-            original_context,\n+            original_context.clone(),\n             original_request,\n             options,\n             query.clone(),\n@@ -2877,15 +2900,15 @@ async fn resolved(\n     Ok(*ResolveResult::source_with_affecting_sources(\n         request_key,\n         ResolvedVc::upcast(\n-            FileSource::new_with_query_and_fragment(**path, query, fragment)\n+            FileSource::new_with_query_and_fragment(path.clone(), query, fragment)\n                 .to_resolved()\n                 .await?,\n         ),\n         symlinks\n             .iter()\n             .map(|symlink| async move {\n                 anyhow::Ok(ResolvedVc::upcast(\n-                    FileSource::new(**symlink).to_resolved().await?,\n+                    FileSource::new(symlink.clone()).to_resolved().await?,\n                 ))\n             })\n             .try_join()\n@@ -2894,8 +2917,8 @@ async fn resolved(\n }\n \n async fn handle_exports_imports_field(\n-    package_path: Vc<FileSystemPath>,\n-    package_json_path: Vc<FileSystemPath>,\n+    package_path: FileSystemPath,\n+    package_json_path: FileSystemPath,\n     options: Vc<ResolveOptions>,\n     exports_imports_field: &AliasMap<SubpathValue>,\n     path: &str,\n@@ -2934,8 +2957,12 @@ async fn handle_exports_imports_field(\n             .to_resolved()\n             .await?;\n \n-            let resolve_result =\n-                Box::pin(resolve_internal_inline(package_path, *request, options)).await?;\n+            let resolve_result = Box::pin(resolve_internal_inline(\n+                package_path.clone(),\n+                *request,\n+                options,\n+            ))\n+            .await?;\n             if conditions.is_empty() {\n                 resolved_results.push(resolve_result.with_request(path.into()));\n             } else {\n@@ -2960,7 +2987,7 @@ async fn handle_exports_imports_field(\n /// static strings or conditions like `import` or `require` to handle ESM/CJS\n /// with differently compiled files.\n async fn resolve_package_internal_with_imports_field(\n-    file_path: Vc<FileSystemPath>,\n+    file_path: FileSystemPath,\n     request: Vc<Request>,\n     resolve_options: Vc<ResolveOptions>,\n     pattern: &Pattern,\n@@ -2974,7 +3001,7 @@ async fn resolve_package_internal_with_imports_field(\n     if specifier == \"#\" || specifier.starts_with(\"#/\") || specifier.ends_with('/') {\n         ResolvingIssue {\n             severity: error_severity(resolve_options).await?,\n-            file_path: file_path.to_resolved().await?,\n+            file_path: file_path.clone(),\n             request_type: format!(\"package imports request: `{specifier}`\"),\n             request: request.to_resolved().await?,\n             resolve_options: resolve_options.to_resolved().await?,\n@@ -2988,13 +3015,13 @@ async fn resolve_package_internal_with_imports_field(\n \n     let imports_result = imports_field(file_path).await?;\n     let (imports, package_json_path) = match &*imports_result {\n-        ImportsFieldResult::Some(i, p) => (i, *p),\n+        ImportsFieldResult::Some(i, p) => (i, p.clone()),\n         ImportsFieldResult::None => return Ok(*ResolveResult::unresolvable()),\n     };\n \n     handle_exports_imports_field(\n         package_json_path.parent(),\n-        *package_json_path,\n+        package_json_path.clone(),\n         resolve_options,\n         imports,\n         specifier,\n@@ -3008,7 +3035,7 @@ async fn resolve_package_internal_with_imports_field(\n pub async fn handle_resolve_error(\n     result: Vc<ModuleResolveResult>,\n     reference_type: ReferenceType,\n-    origin_path: Vc<FileSystemPath>,\n+    origin_path: FileSystemPath,\n     request: Vc<Request>,\n     resolve_options: Vc<ResolveOptions>,\n     is_optional: bool,\n@@ -3052,7 +3079,7 @@ pub async fn handle_resolve_error(\n pub async fn handle_resolve_source_error(\n     result: Vc<ResolveResult>,\n     reference_type: ReferenceType,\n-    origin_path: Vc<FileSystemPath>,\n+    origin_path: FileSystemPath,\n     request: Vc<Request>,\n     resolve_options: Vc<ResolveOptions>,\n     is_optional: bool,\n@@ -3095,7 +3122,7 @@ pub async fn handle_resolve_source_error(\n \n async fn emit_resolve_error_issue(\n     is_optional: bool,\n-    origin_path: Vc<FileSystemPath>,\n+    origin_path: FileSystemPath,\n     reference_type: ReferenceType,\n     request: Vc<Request>,\n     resolve_options: Vc<ResolveOptions>,\n@@ -3109,7 +3136,7 @@ async fn emit_resolve_error_issue(\n     };\n     ResolvingIssue {\n         severity,\n-        file_path: origin_path.to_resolved().await?,\n+        file_path: origin_path.clone(),\n         request_type: format!(\"{reference_type} request\"),\n         request: request.to_resolved().await?,\n         resolve_options: resolve_options.to_resolved().await?,\n@@ -3123,7 +3150,7 @@ async fn emit_resolve_error_issue(\n \n async fn emit_unresolvable_issue(\n     is_optional: bool,\n-    origin_path: Vc<FileSystemPath>,\n+    origin_path: FileSystemPath,\n     reference_type: ReferenceType,\n     request: Vc<Request>,\n     resolve_options: Vc<ResolveOptions>,\n@@ -3136,7 +3163,7 @@ async fn emit_unresolvable_issue(\n     };\n     ResolvingIssue {\n         severity,\n-        file_path: origin_path.to_resolved().await?,\n+        file_path: origin_path.clone(),\n         request_type: format!(\"{reference_type} request\"),\n         request: request.to_resolved().await?,\n         resolve_options: resolve_options.to_resolved().await?,"
        },
        {
            "sha": "19ce598c69d8fbe4edcb09a5bb1e7f68ca7b0227",
            "filename": "turbopack/crates/turbopack-core/src/resolve/node.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fnode.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fnode.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fnode.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -1,4 +1,4 @@\n-use turbo_tasks::{ResolvedVc, Vc};\n+use turbo_tasks::Vc;\n use turbo_tasks_fs::FileSystemPath;\n \n use super::options::{\n@@ -7,7 +7,7 @@ use super::options::{\n };\n \n #[turbo_tasks::function]\n-pub fn node_cjs_resolve_options(root: ResolvedVc<FileSystemPath>) -> Vc<ResolveOptions> {\n+pub fn node_cjs_resolve_options(root: FileSystemPath) -> Vc<ResolveOptions> {\n     let conditions: ResolutionConditions = [\n         (\"node\".into(), ConditionValue::Set),\n         (\"require\".into(), ConditionValue::Set),\n@@ -37,7 +37,7 @@ pub fn node_cjs_resolve_options(root: ResolvedVc<FileSystemPath>) -> Vc<ResolveO\n }\n \n #[turbo_tasks::function]\n-pub fn node_esm_resolve_options(root: ResolvedVc<FileSystemPath>) -> Vc<ResolveOptions> {\n+pub fn node_esm_resolve_options(root: FileSystemPath) -> Vc<ResolveOptions> {\n     let conditions: ResolutionConditions = [\n         (\"node\".into(), ConditionValue::Set),\n         (\"import\".into(), ConditionValue::Set),"
        },
        {
            "sha": "83165c10746c9a1cc7b796615646cd8676ead5b0",
            "filename": "turbopack/crates/turbopack-core/src/resolve/options.rs",
            "status": "modified",
            "additions": 45,
            "deletions": 35,
            "changes": 80,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Foptions.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Foptions.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Foptions.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -41,10 +41,10 @@ pub struct ExcludedExtensions(pub FxIndexSet<RcStr>);\n pub enum ResolveModules {\n     /// when inside of path, use the list of directories to\n     /// resolve inside these\n-    Nested(ResolvedVc<FileSystemPath>, Vec<RcStr>),\n+    Nested(FileSystemPath, Vec<RcStr>),\n     /// look into that directory, unless the request has an excluded extension\n     Path {\n-        dir: ResolvedVc<FileSystemPath>,\n+        dir: FileSystemPath,\n         excluded_extensions: ResolvedVc<ExcludedExtensions>,\n     },\n }\n@@ -115,14 +115,14 @@ pub enum ImportMapping {\n         name: Option<RcStr>,\n         ty: ExternalType,\n         traced: ExternalTraced,\n-        lookup_dir: ResolvedVc<FileSystemPath>,\n+        lookup_dir: FileSystemPath,\n     },\n     /// An already resolved result that will be returned directly.\n     Direct(ResolvedVc<ResolveResult>),\n     /// A request alias that will be resolved first, and fall back to resolving\n     /// the original request if it fails. Useful for the tsconfig.json\n     /// `compilerOptions.paths` option and Next aliases.\n-    PrimaryAlternative(RcStr, Option<ResolvedVc<FileSystemPath>>),\n+    PrimaryAlternative(RcStr, Option<FileSystemPath>),\n     Ignore,\n     Empty,\n     Alternatives(Vec<ResolvedVc<ImportMapping>>),\n@@ -139,10 +139,10 @@ pub enum ReplacedImportMapping {\n         name: Option<RcStr>,\n         ty: ExternalType,\n         traced: ExternalTraced,\n-        lookup_dir: ResolvedVc<FileSystemPath>,\n+        lookup_dir: FileSystemPath,\n     },\n     Direct(ResolvedVc<ResolveResult>),\n-    PrimaryAlternative(Pattern, Option<ResolvedVc<FileSystemPath>>),\n+    PrimaryAlternative(Pattern, Option<FileSystemPath>),\n     Ignore,\n     Empty,\n     Alternatives(Vec<ResolvedVc<ReplacedImportMapping>>),\n@@ -152,7 +152,7 @@ pub enum ReplacedImportMapping {\n impl ImportMapping {\n     pub fn primary_alternatives(\n         list: Vec<RcStr>,\n-        lookup_path: Option<ResolvedVc<FileSystemPath>>,\n+        lookup_path: Option<FileSystemPath>,\n     ) -> ImportMapping {\n         if list.is_empty() {\n             ImportMapping::Ignore\n@@ -161,7 +161,9 @@ impl ImportMapping {\n         } else {\n             ImportMapping::Alternatives(\n                 list.into_iter()\n-                    .map(|s| ImportMapping::PrimaryAlternative(s, lookup_path).resolved_cell())\n+                    .map(|s| {\n+                        ImportMapping::PrimaryAlternative(s, lookup_path.clone()).resolved_cell()\n+                    })\n                     .collect(),\n             )\n         }\n@@ -200,10 +202,13 @@ impl AliasTemplate for Vc<ImportMapping> {\n                     name: name.clone(),\n                     ty: *ty,\n                     traced: *traced,\n-                    lookup_dir: *lookup_dir,\n+                    lookup_dir: lookup_dir.clone(),\n                 },\n                 ImportMapping::PrimaryAlternative(name, lookup_dir) => {\n-                    ReplacedImportMapping::PrimaryAlternative((*name).clone().into(), *lookup_dir)\n+                    ReplacedImportMapping::PrimaryAlternative(\n+                        (*name).clone().into(),\n+                        lookup_dir.clone(),\n+                    )\n                 }\n                 ImportMapping::Direct(v) => ReplacedImportMapping::Direct(*v),\n                 ImportMapping::Ignore => ReplacedImportMapping::Ignore,\n@@ -248,21 +253,21 @@ impl AliasTemplate for Vc<ImportMapping> {\n                             name: capture.spread_into_star(name).as_string().map(|s| s.into()),\n                             ty: *ty,\n                             traced: *traced,\n-                            lookup_dir: *lookup_dir,\n+                            lookup_dir: lookup_dir.clone(),\n                         }\n                     } else {\n                         ReplacedImportMapping::PrimaryAlternativeExternal {\n                             name: None,\n                             ty: *ty,\n                             traced: *traced,\n-                            lookup_dir: *lookup_dir,\n+                            lookup_dir: lookup_dir.clone(),\n                         }\n                     }\n                 }\n                 ImportMapping::PrimaryAlternative(name, lookup_dir) => {\n                     ReplacedImportMapping::PrimaryAlternative(\n                         capture.spread_into_star(name),\n-                        *lookup_dir,\n+                        lookup_dir.clone(),\n                     )\n                 }\n                 ImportMapping::Direct(v) => ReplacedImportMapping::Direct(*v),\n@@ -346,14 +351,15 @@ impl ImportMap {\n     pub fn insert_singleton_alias<'a>(\n         &mut self,\n         prefix: impl Into<RcStr> + 'a,\n-        context_path: ResolvedVc<FileSystemPath>,\n+        context_path: FileSystemPath,\n     ) {\n         let prefix: RcStr = prefix.into();\n         let wildcard_prefix: RcStr = (prefix.to_string() + \"/\").into();\n         let wildcard_alias: RcStr = (prefix.to_string() + \"/*\").into();\n         self.insert_exact_alias(\n             prefix.clone(),\n-            ImportMapping::PrimaryAlternative(prefix.clone(), Some(context_path)).resolved_cell(),\n+            ImportMapping::PrimaryAlternative(prefix.clone(), Some(context_path.clone()))\n+                .resolved_cell(),\n         );\n         self.insert_wildcard_alias(\n             wildcard_prefix,\n@@ -376,11 +382,7 @@ impl ImportMap {\n #[turbo_tasks::value(shared)]\n #[derive(Clone, Default)]\n pub struct ResolvedMap {\n-    pub by_glob: Vec<(\n-        ResolvedVc<FileSystemPath>,\n-        ResolvedVc<Glob>,\n-        ResolvedVc<ImportMapping>,\n-    )>,\n+    pub by_glob: Vec<(FileSystemPath, ResolvedVc<Glob>, ResolvedVc<ImportMapping>)>,\n }\n \n #[turbo_tasks::value(shared)]\n@@ -392,16 +394,16 @@ pub enum ImportMapResult {\n         name: RcStr,\n         ty: ExternalType,\n         traced: ExternalTraced,\n-        lookup_dir: ResolvedVc<FileSystemPath>,\n+        lookup_dir: FileSystemPath,\n     },\n-    Alias(ResolvedVc<Request>, Option<ResolvedVc<FileSystemPath>>),\n+    Alias(ResolvedVc<Request>, Option<FileSystemPath>),\n     Alternatives(Vec<ImportMapResult>),\n     NoEntry,\n }\n \n async fn import_mapping_to_result(\n     mapping: Vc<ReplacedImportMapping>,\n-    lookup_path: Vc<FileSystemPath>,\n+    lookup_path: FileSystemPath,\n     request: Vc<Request>,\n ) -> Result<ImportMapResult> {\n     Ok(match &*mapping.await? {\n@@ -432,7 +434,7 @@ async fn import_mapping_to_result(\n             },\n             ty: *ty,\n             traced: *traced,\n-            lookup_dir: *lookup_dir,\n+            lookup_dir: lookup_dir.clone(),\n         },\n         ReplacedImportMapping::Ignore => {\n             ImportMapResult::Result(ResolveResult::primary(ResolveResultItem::Ignore))\n@@ -442,11 +444,17 @@ async fn import_mapping_to_result(\n         }\n         ReplacedImportMapping::PrimaryAlternative(name, context) => {\n             let request = Request::parse(name.clone()).to_resolved().await?;\n-            ImportMapResult::Alias(request, *context)\n+            ImportMapResult::Alias(request, context.clone())\n         }\n         ReplacedImportMapping::Alternatives(list) => ImportMapResult::Alternatives(\n             list.iter()\n-                .map(|mapping| Box::pin(import_mapping_to_result(**mapping, lookup_path, request)))\n+                .map(|mapping| {\n+                    Box::pin(import_mapping_to_result(\n+                        **mapping,\n+                        lookup_path.clone(),\n+                        request,\n+                    ))\n+                })\n                 .try_join()\n                 .await?,\n         ),\n@@ -466,7 +474,7 @@ impl ValueToString for ImportMapResult {\n             ImportMapResult::AliasExternal { .. } => Ok(Vc::cell(rcstr!(\"TODO external\"))),\n             ImportMapResult::Alias(request, context) => {\n                 let s = if let Some(path) = context {\n-                    let path = path.to_string().await?;\n+                    let path = path.value_to_string().await?;\n                     format!(\n                         \"aliased to {} inside of {}\",\n                         request.to_string().await?,\n@@ -499,7 +507,7 @@ impl ImportMap {\n     // lookup\n     pub async fn lookup(\n         &self,\n-        lookup_path: Vc<FileSystemPath>,\n+        lookup_path: FileSystemPath,\n         request: Vc<Request>,\n     ) -> Result<ImportMapResult> {\n         // relative requests must not match global wildcard aliases.\n@@ -528,8 +536,12 @@ impl ImportMap {\n             .chain(lookup_rel_parent.into_iter())\n             .chain(lookup.into_iter())\n             .map(async |result| {\n-                import_mapping_to_result(*result.try_join_into_self().await?, lookup_path, request)\n-                    .await\n+                import_mapping_to_result(\n+                    *result.try_join_into_self().await?,\n+                    lookup_path.clone(),\n+                    request,\n+                )\n+                .await\n             })\n             .try_join()\n             .await?;\n@@ -547,13 +559,11 @@ impl ResolvedMap {\n     #[turbo_tasks::function]\n     pub async fn lookup(\n         &self,\n-        resolved: Vc<FileSystemPath>,\n-        lookup_path: Vc<FileSystemPath>,\n+        resolved: FileSystemPath,\n+        lookup_path: FileSystemPath,\n         request: Vc<Request>,\n     ) -> Result<Vc<ImportMapResult>> {\n-        let resolved = resolved.await?;\n         for (root, glob, mapping) in self.by_glob.iter() {\n-            let root = root.await?;\n             if let Some(path) = root.get_path_to(&resolved)\n                 && glob.await?.matches(path)\n             {\n@@ -695,7 +705,7 @@ pub trait ImportMappingReplacement {\n     #[turbo_tasks::function]\n     fn result(\n         self: Vc<Self>,\n-        lookup_path: Vc<FileSystemPath>,\n+        lookup_path: FileSystemPath,\n         request: Vc<Request>,\n     ) -> Vc<ImportMapResult>;\n }"
        },
        {
            "sha": "36205a15b041a6537ab0f8cde6be1423ff57583c",
            "filename": "turbopack/crates/turbopack-core/src/resolve/origin.rs",
            "status": "modified",
            "additions": 15,
            "deletions": 8,
            "changes": 23,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Forigin.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Forigin.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Forigin.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -47,7 +47,10 @@ pub trait ResolveOriginExt: Send {\n     ) -> impl Future<Output = Result<Vc<ModuleResolveResult>>> + Send;\n \n     /// Get the resolve options that apply for this origin.\n-    fn resolve_options(self: Vc<Self>, reference_type: ReferenceType) -> Vc<ResolveOptions>;\n+    fn resolve_options(\n+        self: Vc<Self>,\n+        reference_type: ReferenceType,\n+    ) -> impl std::future::Future<Output = Result<Vc<ResolveOptions>>> + Send;\n \n     /// Adds a transition that is used for resolved assets.\n     fn with_transition(self: ResolvedVc<Self>, transition: RcStr) -> Vc<Box<dyn ResolveOrigin>>;\n@@ -66,9 +69,13 @@ where\n         resolve_asset(Vc::upcast(self), request, options, reference_type)\n     }\n \n-    fn resolve_options(self: Vc<Self>, reference_type: ReferenceType) -> Vc<ResolveOptions> {\n-        self.asset_context()\n-            .resolve_options(self.origin_path(), reference_type)\n+    async fn resolve_options(\n+        self: Vc<Self>,\n+        reference_type: ReferenceType,\n+    ) -> Result<Vc<ResolveOptions>> {\n+        Ok(self\n+            .asset_context()\n+            .resolve_options(self.origin_path().await?.clone_value(), reference_type))\n     }\n \n     fn with_transition(self: ResolvedVc<Self>, transition: RcStr) -> Vc<Box<dyn ResolveOrigin>> {\n@@ -96,7 +103,7 @@ async fn resolve_asset(\n         .resolve()\n         .await?\n         .resolve_asset(\n-            resolve_origin.origin_path().resolve().await?,\n+            resolve_origin.origin_path().await?.clone_value(),\n             request.resolve().await?,\n             options.resolve().await?,\n             reference_type,\n@@ -107,15 +114,15 @@ async fn resolve_asset(\n #[turbo_tasks::value]\n pub struct PlainResolveOrigin {\n     asset_context: ResolvedVc<Box<dyn AssetContext>>,\n-    origin_path: ResolvedVc<FileSystemPath>,\n+    origin_path: FileSystemPath,\n }\n \n #[turbo_tasks::value_impl]\n impl PlainResolveOrigin {\n     #[turbo_tasks::function]\n     pub fn new(\n         asset_context: ResolvedVc<Box<dyn AssetContext>>,\n-        origin_path: ResolvedVc<FileSystemPath>,\n+        origin_path: FileSystemPath,\n     ) -> Vc<Self> {\n         PlainResolveOrigin {\n             asset_context,\n@@ -129,7 +136,7 @@ impl PlainResolveOrigin {\n impl ResolveOrigin for PlainResolveOrigin {\n     #[turbo_tasks::function]\n     fn origin_path(&self) -> Vc<FileSystemPath> {\n-        *self.origin_path\n+        self.origin_path.clone().cell()\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "46b82208b8b2129343b887d8bf2bf45d8d6291aa",
            "filename": "turbopack/crates/turbopack-core/src/resolve/pattern.rs",
            "status": "modified",
            "additions": 51,
            "deletions": 54,
            "changes": 105,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fpattern.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fpattern.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fpattern.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -12,8 +12,7 @@ use serde::{Deserialize, Serialize};\n use tracing::Instrument;\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{\n-    NonLocalValue, ResolvedVc, TaskInput, ValueToString, Vc, debug::ValueDebugFormat,\n-    trace::TraceRawVcs,\n+    NonLocalValue, TaskInput, ValueToString, Vc, debug::ValueDebugFormat, trace::TraceRawVcs,\n };\n use turbo_tasks_fs::{\n     FileSystemPath, LinkContent, LinkType, RawDirectoryContent, RawDirectoryEntry,\n@@ -1326,14 +1325,14 @@ impl ValueToString for Pattern {\n     NonLocalValue,\n )]\n pub enum PatternMatch {\n-    File(RcStr, ResolvedVc<FileSystemPath>),\n-    Directory(RcStr, ResolvedVc<FileSystemPath>),\n+    File(RcStr, FileSystemPath),\n+    Directory(RcStr, FileSystemPath),\n }\n \n impl PatternMatch {\n-    pub fn path(&self) -> ResolvedVc<FileSystemPath> {\n-        match *self {\n-            PatternMatch::File(_, path) | PatternMatch::Directory(_, path) => path,\n+    pub fn path(&self) -> Vc<FileSystemPath> {\n+        match self {\n+            PatternMatch::File(_, path) | PatternMatch::Directory(_, path) => path.clone().cell(),\n         }\n     }\n \n@@ -1359,7 +1358,7 @@ pub struct PatternMatches(Vec<PatternMatch>);\n /// symlinks when they are interested in that.\n #[turbo_tasks::function]\n pub async fn read_matches(\n-    lookup_dir: ResolvedVc<FileSystemPath>,\n+    lookup_dir: FileSystemPath,\n     prefix: RcStr,\n     force_in_lookup_dir: bool,\n     pattern: Vc<Pattern>,\n@@ -1387,11 +1386,11 @@ pub async fn read_matches(\n                     if last_segment.is_empty() {\n                         // This means we don't have a last segment, so we just have a directory\n                         let joined = if force_in_lookup_dir {\n-                            lookup_dir.try_join_inside(parent_path.into()).await?\n+                            lookup_dir.try_join_inside(parent_path)?\n                         } else {\n-                            lookup_dir.try_join(parent_path.into()).await?\n+                            lookup_dir.try_join(parent_path)?\n                         };\n-                        let Some(fs_path) = *joined else {\n+                        let Some(fs_path) = joined else {\n                             continue;\n                         };\n                         results.push((\n@@ -1404,10 +1403,10 @@ pub async fn read_matches(\n                     let read_dir = match entry {\n                         Entry::Occupied(e) => Some(e.into_mut()),\n                         Entry::Vacant(e) => {\n-                            let path_option = *if force_in_lookup_dir {\n-                                lookup_dir.try_join_inside(parent_path.into()).await?\n+                            let path_option = if force_in_lookup_dir {\n+                                lookup_dir.try_join_inside(parent_path)?\n                             } else {\n-                                lookup_dir.try_join(parent_path.into()).await?\n+                                lookup_dir.try_join(parent_path)?\n                             };\n                             if let Some(path) = path_option {\n                                 Some(e.insert((path.raw_read_dir().await?, path)))\n@@ -1431,28 +1430,19 @@ pub async fn read_matches(\n                                 index,\n                                 PatternMatch::File(\n                                     concat(&prefix, str).into(),\n-                                    parent_fs_path\n-                                        .join(last_segment.into())\n-                                        .to_resolved()\n-                                        .await?,\n+                                    parent_fs_path.join(last_segment)?,\n                                 ),\n                             ));\n                         }\n                         RawDirectoryEntry::Directory => results.push((\n                             index,\n                             PatternMatch::Directory(\n                                 concat(&prefix, str).into(),\n-                                parent_fs_path\n-                                    .join(last_segment.into())\n-                                    .to_resolved()\n-                                    .await?,\n+                                parent_fs_path.join(last_segment)?,\n                             ),\n                         )),\n                         RawDirectoryEntry::Symlink => {\n-                            let fs_path = parent_fs_path\n-                                .join(last_segment.into())\n-                                .to_resolved()\n-                                .await?;\n+                            let fs_path = parent_fs_path.join(last_segment)?;\n                             let LinkContent::Link { link_type, .. } = &*fs_path.read_link().await?\n                             else {\n                                 continue;\n@@ -1470,17 +1460,17 @@ pub async fn read_matches(\n                     let subpath = &str[..=str.rfind('/').unwrap()];\n                     if handled.insert(subpath) {\n                         let joined = if force_in_lookup_dir {\n-                            lookup_dir.try_join_inside(subpath.into()).await?\n+                            lookup_dir.try_join_inside(subpath)?\n                         } else {\n-                            lookup_dir.try_join(subpath.into()).await?\n+                            lookup_dir.try_join(subpath)?\n                         };\n-                        let Some(fs_path) = *joined else {\n+                        let Some(fs_path) = joined else {\n                             continue;\n                         };\n                         nested.push((\n                             0,\n                             read_matches(\n-                                *fs_path,\n+                                fs_path.clone(),\n                                 concat(&prefix, subpath).into(),\n                                 force_in_lookup_dir,\n                                 pattern,\n@@ -1507,10 +1497,7 @@ pub async fn read_matches(\n                 if let Some(pos) = pat.match_position(&prefix) {\n                     results.push((\n                         pos,\n-                        PatternMatch::Directory(\n-                            prefix.clone().into(),\n-                            lookup_dir.parent().to_resolved().await?,\n-                        ),\n+                        PatternMatch::Directory(prefix.clone().into(), lookup_dir.parent()),\n                     ));\n                 }\n \n@@ -1519,10 +1506,7 @@ pub async fn read_matches(\n                 if let Some(pos) = pat.match_position(&prefix) {\n                     results.push((\n                         pos,\n-                        PatternMatch::Directory(\n-                            prefix.clone().into(),\n-                            lookup_dir.parent().to_resolved().await?,\n-                        ),\n+                        PatternMatch::Directory(prefix.clone().into(), lookup_dir.parent()),\n                     ));\n                 }\n                 if let Some(pos) = pat.could_match_position(&prefix) {\n@@ -1541,25 +1525,36 @@ pub async fn read_matches(\n                 if let Some(pos) = pat.match_position(&prefix) {\n                     results.push((\n                         pos,\n-                        PatternMatch::Directory(prefix.clone().into(), lookup_dir),\n+                        PatternMatch::Directory(prefix.clone().into(), lookup_dir.clone()),\n                     ));\n                 }\n                 prefix.pop();\n             }\n             if prefix.is_empty() {\n                 if let Some(pos) = pat.match_position(\"./\") {\n-                    results.push((pos, PatternMatch::Directory(rcstr!(\"./\"), lookup_dir)));\n+                    results.push((\n+                        pos,\n+                        PatternMatch::Directory(rcstr!(\"./\"), lookup_dir.clone()),\n+                    ));\n                 }\n                 if let Some(pos) = pat.could_match_position(\"./\") {\n-                    nested.push((pos, read_matches(*lookup_dir, rcstr!(\"./\"), false, pattern)));\n+                    nested.push((\n+                        pos,\n+                        read_matches(lookup_dir.clone(), rcstr!(\"./\"), false, pattern),\n+                    ));\n                 }\n             } else {\n                 prefix.push('/');\n                 // {prefix}/\n                 if let Some(pos) = pat.could_match_position(&prefix) {\n                     nested.push((\n                         pos,\n-                        read_matches(*lookup_dir, prefix.to_string().into(), false, pattern),\n+                        read_matches(\n+                            lookup_dir.clone(),\n+                            prefix.to_string().into(),\n+                            false,\n+                            pattern,\n+                        ),\n                     ));\n                 }\n                 prefix.pop();\n@@ -1568,7 +1563,12 @@ pub async fn read_matches(\n                 if let Some(pos) = pat.could_match_position(&prefix) {\n                     nested.push((\n                         pos,\n-                        read_matches(*lookup_dir, prefix.to_string().into(), false, pattern),\n+                        read_matches(\n+                            lookup_dir.clone(),\n+                            prefix.to_string().into(),\n+                            false,\n+                            pattern,\n+                        ),\n                     ));\n                 }\n                 prefix.pop();\n@@ -1583,7 +1583,7 @@ pub async fn read_matches(\n                                 prefix.push_str(key);\n                                 // {prefix}{key}\n                                 if let Some(pos) = pat.match_position(&prefix) {\n-                                    let path = lookup_dir.join(key.clone()).to_resolved().await?;\n+                                    let path = lookup_dir.join(key)?;\n                                     results.push((\n                                         pos,\n                                         PatternMatch::File(prefix.clone().into(), path),\n@@ -1599,7 +1599,7 @@ pub async fn read_matches(\n                                     prefix.pop();\n                                 }\n                                 if let Some(pos) = pat.match_position(&prefix) {\n-                                    let path = lookup_dir.join(key.clone()).to_resolved().await?;\n+                                    let path = lookup_dir.join(key)?;\n                                     results.push((\n                                         pos,\n                                         PatternMatch::Directory(prefix.clone().into(), path),\n@@ -1608,17 +1608,17 @@ pub async fn read_matches(\n                                 prefix.push('/');\n                                 // {prefix}{key}/\n                                 if let Some(pos) = pat.match_position(&prefix) {\n-                                    let path = lookup_dir.join(key.clone()).to_resolved().await?;\n+                                    let path = lookup_dir.join(key)?;\n                                     results.push((\n                                         pos,\n                                         PatternMatch::Directory(prefix.clone().into(), path),\n                                     ));\n                                 }\n                                 if let Some(pos) = pat.could_match_position(&prefix) {\n-                                    let path = lookup_dir.join(key.clone()).to_resolved().await?;\n+                                    let path = lookup_dir.join(key)?;\n                                     nested.push((\n                                         pos,\n-                                        read_matches(*path, prefix.clone().into(), true, pattern),\n+                                        read_matches(path, prefix.clone().into(), true, pattern),\n                                     ));\n                                 }\n                                 prefix.truncate(len)\n@@ -1631,8 +1631,7 @@ pub async fn read_matches(\n                                     prefix.pop();\n                                 }\n                                 if let Some(pos) = pat.match_position(&prefix) {\n-                                    let fs_path =\n-                                        lookup_dir.join(key.clone()).to_resolved().await?;\n+                                    let fs_path = lookup_dir.join(&key.clone())?;\n                                     if let LinkContent::Link { link_type, .. } =\n                                         &*fs_path.read_link().await?\n                                     {\n@@ -1654,8 +1653,7 @@ pub async fn read_matches(\n                                 }\n                                 prefix.push('/');\n                                 if let Some(pos) = pat.match_position(&prefix) {\n-                                    let fs_path =\n-                                        lookup_dir.join(key.clone()).to_resolved().await?;\n+                                    let fs_path = lookup_dir.join(&key.clone())?;\n                                     if let LinkContent::Link { link_type, .. } =\n                                         &*fs_path.read_link().await?\n                                         && link_type.contains(LinkType::DIRECTORY)\n@@ -1667,8 +1665,7 @@ pub async fn read_matches(\n                                     }\n                                 }\n                                 if let Some(pos) = pat.could_match_position(&prefix) {\n-                                    let fs_path =\n-                                        lookup_dir.join(key.clone()).to_resolved().await?;\n+                                    let fs_path = lookup_dir.join(&key.clone())?;\n                                     if let LinkContent::Link { link_type, .. } =\n                                         &*fs_path.read_link().await?\n                                         && link_type.contains(LinkType::DIRECTORY)"
        },
        {
            "sha": "aefce98d0d732d40e81d143721dc1fe2713bda0f",
            "filename": "turbopack/crates/turbopack-core/src/resolve/plugin.rs",
            "status": "modified",
            "additions": 8,
            "deletions": 8,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fplugin.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fplugin.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fplugin.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -12,23 +12,23 @@ use crate::{\n /// A condition which determines if the hooks of a resolve plugin gets called.\n #[turbo_tasks::value]\n pub struct AfterResolvePluginCondition {\n-    root: ResolvedVc<FileSystemPath>,\n+    root: FileSystemPath,\n     glob: ResolvedVc<Glob>,\n }\n \n #[turbo_tasks::value_impl]\n impl AfterResolvePluginCondition {\n     #[turbo_tasks::function]\n-    pub fn new(root: ResolvedVc<FileSystemPath>, glob: ResolvedVc<Glob>) -> Vc<Self> {\n+    pub fn new(root: FileSystemPath, glob: ResolvedVc<Glob>) -> Vc<Self> {\n         AfterResolvePluginCondition { root, glob }.cell()\n     }\n \n     #[turbo_tasks::function]\n-    pub async fn matches(&self, fs_path: Vc<FileSystemPath>) -> Result<Vc<bool>> {\n-        let root = self.root.await?;\n+    pub async fn matches(&self, fs_path: FileSystemPath) -> Result<Vc<bool>> {\n+        let root = self.root.clone();\n         let glob = self.glob.await?;\n \n-        let path = fs_path.await?;\n+        let path = fs_path;\n \n         if let Some(path) = root.get_path_to(&path)\n             && glob.matches(path)\n@@ -88,7 +88,7 @@ pub trait BeforeResolvePlugin {\n     #[turbo_tasks::function]\n     fn before_resolve(\n         self: Vc<Self>,\n-        lookup_path: Vc<FileSystemPath>,\n+        lookup_path: FileSystemPath,\n         reference_type: ReferenceType,\n         request: Vc<Request>,\n     ) -> Vc<ResolveResultOption>;\n@@ -106,8 +106,8 @@ pub trait AfterResolvePlugin {\n     #[turbo_tasks::function]\n     fn after_resolve(\n         self: Vc<Self>,\n-        fs_path: Vc<FileSystemPath>,\n-        lookup_path: Vc<FileSystemPath>,\n+        fs_path: FileSystemPath,\n+        lookup_path: FileSystemPath,\n         reference_type: ReferenceType,\n         request: Vc<Request>,\n     ) -> Vc<ResolveResultOption>;"
        },
        {
            "sha": "eede08c4e34530177931be40582014b1ffbeda7f",
            "filename": "turbopack/crates/turbopack-core/src/server_fs.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fserver_fs.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fserver_fs.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fserver_fs.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -19,32 +19,32 @@ impl ServerFileSystem {\n #[turbo_tasks::value_impl]\n impl FileSystem for ServerFileSystem {\n     #[turbo_tasks::function]\n-    fn read(&self, _fs_path: Vc<FileSystemPath>) -> Result<Vc<FileContent>> {\n+    fn read(&self, _fs_path: FileSystemPath) -> Result<Vc<FileContent>> {\n         bail!(\"Reading is not possible from the marker filesystem for the server\")\n     }\n \n     #[turbo_tasks::function]\n-    fn read_link(&self, _fs_path: Vc<FileSystemPath>) -> Result<Vc<LinkContent>> {\n+    fn read_link(&self, _fs_path: FileSystemPath) -> Result<Vc<LinkContent>> {\n         bail!(\"Reading is not possible from the marker filesystem for the server\")\n     }\n \n     #[turbo_tasks::function]\n-    fn raw_read_dir(&self, _fs_path: Vc<FileSystemPath>) -> Result<Vc<RawDirectoryContent>> {\n+    fn raw_read_dir(&self, _fs_path: FileSystemPath) -> Result<Vc<RawDirectoryContent>> {\n         bail!(\"Reading is not possible from the marker filesystem for the server\")\n     }\n \n     #[turbo_tasks::function]\n-    fn write(&self, _fs_path: Vc<FileSystemPath>, _content: Vc<FileContent>) -> Result<Vc<()>> {\n+    fn write(&self, _fs_path: FileSystemPath, _content: Vc<FileContent>) -> Result<Vc<()>> {\n         bail!(\"Writing is not possible to the marker filesystem for the server\")\n     }\n \n     #[turbo_tasks::function]\n-    fn write_link(&self, _fs_path: Vc<FileSystemPath>, _target: Vc<LinkContent>) -> Result<Vc<()>> {\n+    fn write_link(&self, _fs_path: FileSystemPath, _target: Vc<LinkContent>) -> Result<Vc<()>> {\n         bail!(\"Writing is not possible to the marker filesystem for the server\")\n     }\n \n     #[turbo_tasks::function]\n-    fn metadata(&self, _fs_path: Vc<FileSystemPath>) -> Result<Vc<FileMeta>> {\n+    fn metadata(&self, _fs_path: FileSystemPath) -> Result<Vc<FileMeta>> {\n         bail!(\"Reading is not possible from the marker filesystem for the server\")\n     }\n }"
        },
        {
            "sha": "0d918fbb3228296213347715c338ea2e03c350a9",
            "filename": "turbopack/crates/turbopack-core/src/source_map/mod.rs",
            "status": "modified",
            "additions": 26,
            "deletions": 19,
            "changes": 45,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fsource_map%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fsource_map%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fsource_map%2Fmod.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -8,7 +8,7 @@ use regex::Regex;\n use serde::{Deserialize, Deserializer, Serialize, Serializer};\n use swc_sourcemap::{DecodedMap, SourceMap as RegularMap, SourceMapBuilder, SourceMapIndex};\n use turbo_rcstr::RcStr;\n-use turbo_tasks::{ResolvedVc, TryJoinIterExt, ValueToString, Vc};\n+use turbo_tasks::{ResolvedVc, TryJoinIterExt, Vc};\n use turbo_tasks_fs::{\n     File, FileContent, FileSystem, FileSystemPath, VirtualFileSystem,\n     rope::{Rope, RopeBuilder},\n@@ -236,7 +236,7 @@ impl SourceMap {\n         Ok(Some(SourceMap::Decoded(InnerSourceMap::new(map))))\n     }\n \n-    pub async fn new_from_file(file: Vc<FileSystemPath>) -> Result<Option<Self>> {\n+    pub async fn new_from_file(file: FileSystemPath) -> Result<Option<Self>> {\n         let read = file.read();\n         Self::new_from_file_content(read).await\n     }\n@@ -409,15 +409,15 @@ impl SourceMap {\n         })\n     }\n \n-    pub async fn with_resolved_sources(&self, origin: Vc<FileSystemPath>) -> Result<Self> {\n+    pub async fn with_resolved_sources(&self, origin: FileSystemPath) -> Result<Self> {\n         async fn resolve_source(\n             source_request: BytesStr,\n             source_content: Option<BytesStr>,\n-            origin: Vc<FileSystemPath>,\n+            origin: FileSystemPath,\n         ) -> Result<(BytesStr, BytesStr)> {\n             Ok(\n-                if let Some(path) = *origin.parent().try_join((&*source_request).into()).await? {\n-                    let path_str = path.to_string().await?;\n+                if let Some(path) = origin.parent().try_join(&source_request)? {\n+                    let path_str = path.value_to_string().await?;\n                     let source = format!(\"{SOURCE_URL_PROTOCOL}///{path_str}\");\n                     let source_content = if let Some(source_content) = source_content {\n                         source_content\n@@ -429,7 +429,7 @@ impl SourceMap {\n                     };\n                     (source.into(), source_content)\n                 } else {\n-                    let origin_str = origin.to_string().await?;\n+                    let origin_str = origin.value_to_string().await?;\n                     static INVALID_REGEX: Lazy<Regex> =\n                         Lazy::new(|| Regex::new(r#\"(?:^|/)(?:\\.\\.?(?:/|$))+\"#).unwrap());\n                     let source = INVALID_REGEX\n@@ -450,7 +450,7 @@ impl SourceMap {\n         }\n         async fn regular_map_with_resolved_sources(\n             map: &RegularMapWrapper,\n-            origin: Vc<FileSystemPath>,\n+            origin: FileSystemPath,\n         ) -> Result<RegularMap> {\n             let map = &map.0;\n             let file = map.get_file().cloned();\n@@ -465,7 +465,7 @@ impl SourceMap {\n             let mut new_sources = Vec::with_capacity(count);\n             let mut new_source_contents = Vec::with_capacity(count);\n             for (source, source_content) in sources.into_iter().zip(source_contents.into_iter()) {\n-                let (source, name) = resolve_source(source, source_content, origin).await?;\n+                let (source, name) = resolve_source(source, source_content, origin.clone()).await?;\n                 new_sources.push(source);\n                 new_source_contents.push(Some(name));\n             }\n@@ -478,7 +478,7 @@ impl SourceMap {\n         }\n         async fn decoded_map_with_resolved_sources(\n             map: &CrateMapWrapper,\n-            origin: Vc<FileSystemPath>,\n+            origin: FileSystemPath,\n         ) -> Result<CrateMapWrapper> {\n             Ok(CrateMapWrapper(match &map.0 {\n                 DecodedMap::Regular(map) => {\n@@ -498,11 +498,18 @@ impl SourceMap {\n                         .collect::<Vec<_>>();\n                     let sections = sections\n                         .into_iter()\n-                        .map(|(offset, map)| async move {\n-                            Ok((\n-                                offset,\n-                                Box::pin(decoded_map_with_resolved_sources(map, origin)).await?,\n-                            ))\n+                        .map(|(offset, map)| {\n+                            let origin = origin.clone();\n+                            async move {\n+                                Ok((\n+                                    offset,\n+                                    Box::pin(decoded_map_with_resolved_sources(\n+                                        map,\n+                                        origin.clone(),\n+                                    ))\n+                                    .await?,\n+                                ))\n+                            }\n                         })\n                         .try_join()\n                         .await?;\n@@ -530,7 +537,7 @@ impl SourceMap {\n             Self::Sectioned(m) => {\n                 let mut sections = Vec::with_capacity(m.sections.len());\n                 for section in &m.sections {\n-                    let map = Box::pin(section.map.with_resolved_sources(origin)).await?;\n+                    let map = Box::pin(section.map.with_resolved_sources(origin.clone())).await?;\n                     sections.push(SourceMapSection::new(section.offset, map));\n                 }\n                 SourceMap::new_sectioned(sections)\n@@ -545,10 +552,10 @@ fn sourcemap_content_fs_root() -> Vc<FileSystemPath> {\n }\n \n #[turbo_tasks::function]\n-fn sourcemap_content_source(path: RcStr, content: RcStr) -> Vc<Box<dyn Source>> {\n-    let path = sourcemap_content_fs_root().join(path);\n+async fn sourcemap_content_source(path: RcStr, content: RcStr) -> Result<Vc<Box<dyn Source>>> {\n+    let path = sourcemap_content_fs_root().await?.join(&path)?;\n     let content = AssetContent::file(FileContent::new(File::from(content)).cell());\n-    Vc::upcast(VirtualSource::new(path, content))\n+    Ok(Vc::upcast(VirtualSource::new(path, content)))\n }\n \n impl SourceMap {"
        },
        {
            "sha": "f0e3bec4233199f68c1fc12946c0845fe3b7d9f2",
            "filename": "turbopack/crates/turbopack-core/src/source_map/source_map_asset.rs",
            "status": "modified",
            "additions": 8,
            "deletions": 6,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fsource_map%2Fsource_map_asset.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fsource_map%2Fsource_map_asset.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fsource_map%2Fsource_map_asset.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -19,7 +19,7 @@ use crate::{\n #[derive(PartialEq, Eq, Serialize, Deserialize, NonLocalValue, TraceRawVcs, ValueDebugFormat)]\n enum PathType {\n     Fixed {\n-        path: ResolvedVc<FileSystemPath>,\n+        path: FileSystemPath,\n     },\n     FromIdent {\n         chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n@@ -54,7 +54,7 @@ impl SourceMapAsset {\n \n     #[turbo_tasks::function]\n     pub fn new_fixed(\n-        path: ResolvedVc<FileSystemPath>,\n+        path: FileSystemPath,\n         generate_source_map: ResolvedVc<Box<dyn GenerateSourceMap>>,\n     ) -> Vc<Self> {\n         SourceMapAsset {\n@@ -72,14 +72,16 @@ impl OutputAsset for SourceMapAsset {\n         // NOTE(alexkirsz) We used to include the asset's version id in the path,\n         // but this caused `all_assets_map` to be recomputed on every change.\n         let this = self.await?;\n-        Ok(match this.path_ty {\n+        Ok(match &this.path_ty {\n             PathType::FromIdent {\n                 chunking_context,\n                 ident_for_path,\n             } => chunking_context\n-                .chunk_path(Some(Vc::upcast(self)), *ident_for_path, rcstr!(\".js\"))\n-                .append(rcstr!(\".map\")),\n-            PathType::Fixed { path } => path.append(rcstr!(\".map\")),\n+                .chunk_path(Some(Vc::upcast(self)), **ident_for_path, rcstr!(\".js\"))\n+                .await?\n+                .append(\".map\")?\n+                .cell(),\n+            PathType::Fixed { path } => path.append(\".map\")?.cell(),\n         })\n     }\n }"
        },
        {
            "sha": "66cee1b67935028e413f419ec9c93b383b9d3d20",
            "filename": "turbopack/crates/turbopack-core/src/source_map/utils.rs",
            "status": "modified",
            "additions": 13,
            "deletions": 17,
            "changes": 30,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fsource_map%2Futils.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fsource_map%2Futils.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fsource_map%2Futils.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -5,7 +5,7 @@ use const_format::concatcp;\n use once_cell::sync::Lazy;\n use regex::Regex;\n use serde::{Deserialize, Serialize};\n-use turbo_tasks::{ValueToString, Vc};\n+use turbo_tasks::Vc;\n use turbo_tasks_fs::{\n     DiskFileSystem, FileContent, FileSystemPath, rope::Rope, util::uri_from_file,\n };\n@@ -73,19 +73,15 @@ struct SourceMapJson {\n /// `sourceContent`s from disk.\n pub async fn resolve_source_map_sources(\n     map: Option<&Rope>,\n-    origin: Vc<FileSystemPath>,\n+    origin: FileSystemPath,\n ) -> Result<Option<Rope>> {\n     async fn resolve_source(\n         original_source: &mut String,\n         original_content: Option<&mut Option<String>>,\n-        origin: Vc<FileSystemPath>,\n+        origin: FileSystemPath,\n     ) -> Result<()> {\n-        if let Some(path) = *origin\n-            .parent()\n-            .try_join((&**original_source).into())\n-            .await?\n-        {\n-            let path_str = path.to_string().await?;\n+        if let Some(path) = origin.parent().try_join(original_source)? {\n+            let path_str = path.value_to_string().await?;\n             let source = format!(\"{SOURCE_URL_PROTOCOL}///{path_str}\");\n             *original_source = source;\n \n@@ -100,7 +96,7 @@ pub async fn resolve_source_map_sources(\n                 }\n             }\n         } else {\n-            let origin_str = origin.to_string().await?;\n+            let origin_str = origin.value_to_string().await?;\n             static INVALID_REGEX: Lazy<Regex> =\n                 Lazy::new(|| Regex::new(r#\"(?:^|/)(?:\\.\\.?(?:/|$))+\"#).unwrap());\n             let source = INVALID_REGEX.replace_all(original_source, |s: &regex::Captures<'_>| {\n@@ -119,7 +115,7 @@ pub async fn resolve_source_map_sources(\n         anyhow::Ok(())\n     }\n \n-    async fn resolve_map(map: &mut SourceMapJson, origin: Vc<FileSystemPath>) -> Result<()> {\n+    async fn resolve_map(map: &mut SourceMapJson, origin: FileSystemPath) -> Result<()> {\n         if let Some(sources) = &mut map.sources {\n             let mut contents = if let Some(mut contents) = map.sources_content.take() {\n                 contents.resize(sources.len(), None);\n@@ -130,7 +126,7 @@ pub async fn resolve_source_map_sources(\n \n             for (source, content) in sources.iter_mut().zip(contents.iter_mut()) {\n                 if let Some(source) = source {\n-                    resolve_source(source, Some(content), origin).await?;\n+                    resolve_source(source, Some(content), origin.clone()).await?;\n                 }\n             }\n \n@@ -149,12 +145,12 @@ pub async fn resolve_source_map_sources(\n     };\n \n     if let Some(file) = &mut map.file {\n-        resolve_source(file, None, origin).await?;\n+        resolve_source(file, None, origin.clone()).await?;\n     }\n \n-    resolve_map(&mut map, origin).await?;\n+    resolve_map(&mut map, origin.clone()).await?;\n     for section in map.sections.iter_mut().flatten() {\n-        resolve_map(&mut section.map, origin).await?;\n+        resolve_map(&mut section.map, origin.clone()).await?;\n     }\n \n     let map = Rope::from(serde_json::to_vec(&map)?);\n@@ -165,7 +161,7 @@ pub async fn resolve_source_map_sources(\n /// is useful for debugging environments.\n pub async fn fileify_source_map(\n     map: Option<&Rope>,\n-    context_path: Vc<FileSystemPath>,\n+    context_path: FileSystemPath,\n ) -> Result<Option<Rope>> {\n     let Some(map) = map else {\n         return Ok(None);\n@@ -187,7 +183,7 @@ pub async fn fileify_source_map(\n         if let Some(src) = src\n             && let Some(src_rest) = src.strip_prefix(&prefix)\n         {\n-            *src = uri_from_file(context_path, Some(src_rest)).await?;\n+            *src = uri_from_file(context_path.clone(), Some(src_rest)).await?;\n         }\n         anyhow::Ok(())\n     };"
        },
        {
            "sha": "74fb67394c2525eedfc461cb28730f096ee29ab2",
            "filename": "turbopack/crates/turbopack-core/src/virtual_output.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fvirtual_output.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fvirtual_output.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fvirtual_output.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -10,15 +10,15 @@ use crate::{\n /// to other assets.\n #[turbo_tasks::value]\n pub struct VirtualOutputAsset {\n-    pub path: ResolvedVc<FileSystemPath>,\n+    pub path: FileSystemPath,\n     pub content: ResolvedVc<AssetContent>,\n     pub references: ResolvedVc<OutputAssets>,\n }\n \n #[turbo_tasks::value_impl]\n impl VirtualOutputAsset {\n     #[turbo_tasks::function]\n-    pub fn new(path: ResolvedVc<FileSystemPath>, content: ResolvedVc<AssetContent>) -> Vc<Self> {\n+    pub fn new(path: FileSystemPath, content: ResolvedVc<AssetContent>) -> Vc<Self> {\n         VirtualOutputAsset {\n             path,\n             content,\n@@ -29,7 +29,7 @@ impl VirtualOutputAsset {\n \n     #[turbo_tasks::function]\n     pub fn new_with_references(\n-        path: ResolvedVc<FileSystemPath>,\n+        path: FileSystemPath,\n         content: ResolvedVc<AssetContent>,\n         references: ResolvedVc<OutputAssets>,\n     ) -> Vc<Self> {\n@@ -46,7 +46,7 @@ impl VirtualOutputAsset {\n impl OutputAsset for VirtualOutputAsset {\n     #[turbo_tasks::function]\n     fn path(&self) -> Vc<FileSystemPath> {\n-        *self.path\n+        self.path.clone().cell()\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "60adc536c980dfa8b6a2ecf1b4de6af9cbad0a82",
            "filename": "turbopack/crates/turbopack-core/src/virtual_source.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 4,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fvirtual_source.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fvirtual_source.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fvirtual_source.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -18,10 +18,7 @@ pub struct VirtualSource {\n #[turbo_tasks::value_impl]\n impl VirtualSource {\n     #[turbo_tasks::function]\n-    pub async fn new(\n-        path: Vc<FileSystemPath>,\n-        content: ResolvedVc<AssetContent>,\n-    ) -> Result<Vc<Self>> {\n+    pub async fn new(path: FileSystemPath, content: ResolvedVc<AssetContent>) -> Result<Vc<Self>> {\n         Ok(Self::cell(VirtualSource {\n             ident: AssetIdent::from_path(path).to_resolved().await?,\n             content,"
        },
        {
            "sha": "31536c4402752aecb7ef6577682a4f6d2c696021",
            "filename": "turbopack/crates/turbopack-css/src/chunk/mod.rs",
            "status": "modified",
            "additions": 8,
            "deletions": 8,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fmod.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -102,7 +102,7 @@ impl CssChunk {\n             {\n                 fileify_source_map(\n                     content.source_map.as_ref(),\n-                    self.chunking_context().root_path(),\n+                    self.chunking_context().root_path().await?.clone_value(),\n                 )\n                 .await?\n             } else {\n@@ -152,8 +152,8 @@ impl CssChunk {\n     async fn ident_for_path(&self) -> Result<Vc<AssetIdent>> {\n         let CssChunkContent { chunk_items, .. } = &*self.content.await?;\n         let mut common_path = if let Some(chunk_item) = chunk_items.first() {\n-            let path = chunk_item.asset_ident().path().to_resolved().await?;\n-            Some((path, path.await?))\n+            let path = chunk_item.asset_ident().path().await?.clone_value();\n+            Some((path.clone(), path))\n         } else {\n             None\n         };\n@@ -164,13 +164,13 @@ impl CssChunk {\n             if let Some((common_path_vc, common_path_ref)) = common_path.as_mut() {\n                 let path = chunk_item.asset_ident().path().await?;\n                 while !path.is_inside_or_equal_ref(common_path_ref) {\n-                    let parent = common_path_vc.parent().to_resolved().await?;\n+                    let parent = common_path_vc.parent();\n                     if parent == *common_path_vc {\n                         common_path = None;\n                         break;\n                     }\n                     *common_path_vc = parent;\n-                    *common_path_ref = (*common_path_vc).await?;\n+                    *common_path_ref = common_path_vc.clone();\n                 }\n             }\n         }\n@@ -189,7 +189,7 @@ impl CssChunk {\n             path: if let Some((common_path, _)) = common_path {\n                 common_path\n             } else {\n-                ServerFileSystem::new().root().to_resolved().await?\n+                ServerFileSystem::new().root().await?.clone_value()\n             },\n             query: RcStr::default(),\n             fragment: RcStr::default(),\n@@ -240,8 +240,8 @@ pub struct CssChunkContent {\n #[turbo_tasks::value_impl]\n impl Chunk for CssChunk {\n     #[turbo_tasks::function]\n-    fn ident(self: Vc<Self>) -> Vc<AssetIdent> {\n-        AssetIdent::from_path(self.path())\n+    async fn ident(self: Vc<Self>) -> Result<Vc<AssetIdent>> {\n+        Ok(AssetIdent::from_path(self.path().await?.clone_value()))\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "54f950ae7ea7601a99d29356c40fc58d2b18f69f",
            "filename": "turbopack/crates/turbopack-css/src/chunk/single_item_chunk/chunk.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fsingle_item_chunk%2Fchunk.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fsingle_item_chunk%2Fchunk.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fsingle_item_chunk%2Fchunk.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -82,9 +82,11 @@ impl SingleItemCssChunk {\n #[turbo_tasks::value_impl]\n impl Chunk for SingleItemCssChunk {\n     #[turbo_tasks::function]\n-    fn ident(self: Vc<Self>) -> Vc<AssetIdent> {\n+    async fn ident(self: Vc<Self>) -> Result<Vc<AssetIdent>> {\n         let self_as_output_asset: Vc<Box<dyn OutputAsset>> = Vc::upcast(self);\n-        AssetIdent::from_path(self_as_output_asset.path())\n+        Ok(AssetIdent::from_path(\n+            self_as_output_asset.path().await?.clone_value(),\n+        ))\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "210894e0d07debbf8ad647bcaef59b1183d37b8c",
            "filename": "turbopack/crates/turbopack-css/src/chunk/single_item_chunk/source_map.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fsingle_item_chunk%2Fsource_map.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fsingle_item_chunk%2Fsource_map.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fsingle_item_chunk%2Fsource_map.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -38,7 +38,9 @@ impl OutputAsset for SingleItemCssChunkSourceMapAsset {\n                 this.chunk.ident_for_path(),\n                 \".single.css\".into(),\n             )\n-            .append(\".map\".into()))\n+            .await?\n+            .append(\".map\")?\n+            .cell())\n     }\n }\n "
        },
        {
            "sha": "c19fd5443a02c0ac3640a9675d170958f54732e7",
            "filename": "turbopack/crates/turbopack-css/src/chunk/source_map.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fsource_map.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fsource_map.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fsource_map.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -35,7 +35,9 @@ impl OutputAsset for CssChunkSourceMapAsset {\n             .await?\n             .chunking_context\n             .chunk_path(Some(Vc::upcast(self)), ident, \".css\".into())\n-            .append(\".map\".into()))\n+            .await?\n+            .append(\".map\")?\n+            .cell())\n     }\n }\n "
        },
        {
            "sha": "3581e7b3f43d3933ef29ffe75745d69d0445f131",
            "filename": "turbopack/crates/turbopack-css/src/process.rs",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fprocess.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fprocess.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fprocess.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -381,7 +381,7 @@ pub async fn parse_css(\n                         process_content(\n                             *file_content,\n                             string.into_owned(),\n-                            fs_path.to_resolved().await?,\n+                            fs_path.await?.clone_value(),\n                             ident_str,\n                             source,\n                             origin,\n@@ -402,7 +402,7 @@ pub async fn parse_css(\n async fn process_content(\n     content_vc: ResolvedVc<FileContent>,\n     code: String,\n-    fs_path_vc: ResolvedVc<FileSystemPath>,\n+    fs_path_vc: FileSystemPath,\n     filename: &str,\n     source: ResolvedVc<Box<dyn Source>>,\n     origin: ResolvedVc<Box<dyn ResolveOrigin>>,\n@@ -463,7 +463,7 @@ async fn process_content(\n                     ss.visit(&mut validator).unwrap();\n \n                     for err in validator.errors {\n-                        err.report(fs_path_vc);\n+                        err.report(fs_path_vc.clone());\n                     }\n                 }\n \n@@ -488,7 +488,7 @@ async fn process_content(\n                             };\n \n                             ParsingIssue {\n-                                file: fs_path_vc,\n+                                file: fs_path_vc.clone(),\n                                 msg: err.to_string().into(),\n                                 source,\n                             }\n@@ -577,7 +577,7 @@ enum CssError {\n }\n \n impl CssError {\n-    fn report(self, file: ResolvedVc<FileSystemPath>) {\n+    fn report(self, file: FileSystemPath) {\n         match self {\n             CssError::CssSelectorInModuleNotPure { selector } => {\n                 ParsingIssue {\n@@ -685,15 +685,15 @@ fn generate_css_source_map(source_map: &parcel_sourcemap::SourceMap) -> Result<R\n #[turbo_tasks::value]\n struct ParsingIssue {\n     msg: RcStr,\n-    file: ResolvedVc<FileSystemPath>,\n+    file: FileSystemPath,\n     source: Option<IssueSource>,\n }\n \n #[turbo_tasks::value_impl]\n impl Issue for ParsingIssue {\n     #[turbo_tasks::function]\n     fn file_path(&self) -> Vc<FileSystemPath> {\n-        *self.file\n+        self.file.clone().cell()\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "6ba0b969ab97f6e5739757bada12da48d024de7e",
            "filename": "turbopack/crates/turbopack-dev-server/src/html.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fhtml.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fhtml.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fhtml.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -35,7 +35,7 @@ pub struct DevHtmlEntry {\n #[turbo_tasks::value(shared)]\n #[derive(Clone)]\n pub struct DevHtmlAsset {\n-    path: ResolvedVc<FileSystemPath>,\n+    path: FileSystemPath,\n     entries: Vec<DevHtmlEntry>,\n     body: Option<RcStr>,\n }\n@@ -44,7 +44,7 @@ pub struct DevHtmlAsset {\n impl OutputAsset for DevHtmlAsset {\n     #[turbo_tasks::function]\n     fn path(&self) -> Vc<FileSystemPath> {\n-        *self.path\n+        self.path.clone().cell()\n     }\n \n     #[turbo_tasks::function]\n@@ -68,7 +68,7 @@ impl Asset for DevHtmlAsset {\n \n impl DevHtmlAsset {\n     /// Create a new dev HTML asset.\n-    pub fn new(path: ResolvedVc<FileSystemPath>, entries: Vec<DevHtmlEntry>) -> Vc<Self> {\n+    pub fn new(path: FileSystemPath, entries: Vec<DevHtmlEntry>) -> Vc<Self> {\n         DevHtmlAsset {\n             path,\n             entries,\n@@ -79,7 +79,7 @@ impl DevHtmlAsset {\n \n     /// Create a new dev HTML asset.\n     pub fn new_with_body(\n-        path: ResolvedVc<FileSystemPath>,\n+        path: FileSystemPath,\n         entries: Vec<DevHtmlEntry>,\n         body: RcStr,\n     ) -> Vc<Self> {\n@@ -95,7 +95,7 @@ impl DevHtmlAsset {\n #[turbo_tasks::value_impl]\n impl DevHtmlAsset {\n     #[turbo_tasks::function]\n-    pub async fn with_path(self: Vc<Self>, path: ResolvedVc<FileSystemPath>) -> Result<Vc<Self>> {\n+    pub async fn with_path(self: Vc<Self>, path: FileSystemPath) -> Result<Vc<Self>> {\n         let mut html: DevHtmlAsset = self.owned().await?;\n         html.path = path;\n         Ok(html.cell())\n@@ -114,7 +114,7 @@ impl DevHtmlAsset {\n     #[turbo_tasks::function]\n     async fn html_content(self: Vc<Self>) -> Result<Vc<DevHtmlAssetContent>> {\n         let this = self.await?;\n-        let context_path = this.path.parent().await?;\n+        let context_path = this.path.parent();\n         let mut chunk_paths = vec![];\n         for chunk in &*self.chunks().await? {\n             let chunk_path = &*chunk.path().await?;"
        },
        {
            "sha": "0fe22fbf257f86446899ff6b043f99b7d690e80c",
            "filename": "turbopack/crates/turbopack-dev-server/src/source/asset_graph.rs",
            "status": "modified",
            "additions": 10,
            "deletions": 12,
            "changes": 22,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fsource%2Fasset_graph.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fsource%2Fasset_graph.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fsource%2Fasset_graph.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -4,8 +4,7 @@ use anyhow::Result;\n use rustc_hash::FxHashSet;\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{\n-    Completion, FxIndexMap, FxIndexSet, ResolvedVc, State, TryJoinIterExt, ValueToString, Vc,\n-    fxindexset,\n+    Completion, FxIndexMap, FxIndexSet, ResolvedVc, State, TryJoinIterExt, Vc, fxindexset,\n };\n use turbo_tasks_fs::FileSystemPath;\n use turbopack_core::{\n@@ -27,7 +26,7 @@ type ExpandedState = State<FxHashSet<RcStr>>;\n \n #[turbo_tasks::value(serialization = \"none\", eq = \"manual\", cell = \"new\")]\n pub struct AssetGraphContentSource {\n-    root_path: ResolvedVc<FileSystemPath>,\n+    root_path: FileSystemPath,\n     root_assets: ResolvedVc<OutputAssetsSet>,\n     expanded: Option<ExpandedState>,\n }\n@@ -37,7 +36,7 @@ impl AssetGraphContentSource {\n     /// Serves all assets references by root_asset.\n     #[turbo_tasks::function]\n     pub fn new_eager(\n-        root_path: ResolvedVc<FileSystemPath>,\n+        root_path: FileSystemPath,\n         root_asset: ResolvedVc<Box<dyn OutputAsset>>,\n     ) -> Vc<Self> {\n         Self::cell(AssetGraphContentSource {\n@@ -51,7 +50,7 @@ impl AssetGraphContentSource {\n     /// asset when it has served its content before.\n     #[turbo_tasks::function]\n     pub fn new_lazy(\n-        root_path: ResolvedVc<FileSystemPath>,\n+        root_path: FileSystemPath,\n         root_asset: ResolvedVc<Box<dyn OutputAsset>>,\n     ) -> Vc<Self> {\n         Self::cell(AssetGraphContentSource {\n@@ -64,7 +63,7 @@ impl AssetGraphContentSource {\n     /// Serves all assets references by all root_assets.\n     #[turbo_tasks::function]\n     pub fn new_eager_multiple(\n-        root_path: ResolvedVc<FileSystemPath>,\n+        root_path: FileSystemPath,\n         root_assets: ResolvedVc<OutputAssetsSet>,\n     ) -> Vc<Self> {\n         Self::cell(AssetGraphContentSource {\n@@ -78,7 +77,7 @@ impl AssetGraphContentSource {\n     /// of an asset when it has served its content before.\n     #[turbo_tasks::function]\n     pub fn new_lazy_multiple(\n-        root_path: ResolvedVc<FileSystemPath>,\n+        root_path: FileSystemPath,\n         root_assets: ResolvedVc<OutputAssetsSet>,\n     ) -> Vc<Self> {\n         Self::cell(AssetGraphContentSource {\n@@ -93,7 +92,7 @@ impl AssetGraphContentSource {\n         Ok(Vc::cell(\n             expand(\n                 &*self.root_assets.await?,\n-                &*self.root_path.await?,\n+                &self.root_path,\n                 self.expanded.as_ref(),\n             )\n             .await?,\n@@ -302,7 +301,7 @@ impl Introspectable for AssetGraphContentSource {\n \n     #[turbo_tasks::function]\n     fn title(&self) -> Vc<RcStr> {\n-        self.root_path.to_string()\n+        self.root_path.value_to_string()\n     }\n \n     #[turbo_tasks::function]\n@@ -372,15 +371,14 @@ impl Introspectable for FullyExpanded {\n \n     #[turbo_tasks::function]\n     async fn title(&self) -> Result<Vc<RcStr>> {\n-        Ok(self.0.await?.root_path.to_string())\n+        Ok(self.0.await?.root_path.value_to_string())\n     }\n \n     #[turbo_tasks::function]\n     async fn children(&self) -> Result<Vc<IntrospectableChildren>> {\n         let source = self.0.await?;\n \n-        let expanded_assets =\n-            expand(&*source.root_assets.await?, &*source.root_path.await?, None).await?;\n+        let expanded_assets = expand(&*source.root_assets.await?, &source.root_path, None).await?;\n         let children = expanded_assets\n             .iter()\n             .map(|(_k, &v)| async move {"
        },
        {
            "sha": "b6aa800f8a2070297ba6cf6aff7df238cf1b841c",
            "filename": "turbopack/crates/turbopack-dev-server/src/source/issue_context.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fsource%2Fissue_context.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fsource%2Fissue_context.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fsource%2Fissue_context.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -15,7 +15,7 @@ use super::{\n \n #[turbo_tasks::value]\n pub struct IssueFilePathContentSource {\n-    file_path: Option<ResolvedVc<FileSystemPath>>,\n+    file_path: Option<FileSystemPath>,\n     description: RcStr,\n     source: ResolvedVc<Box<dyn ContentSource>>,\n }\n@@ -24,7 +24,7 @@ pub struct IssueFilePathContentSource {\n impl IssueFilePathContentSource {\n     #[turbo_tasks::function]\n     pub fn new_file_path(\n-        file_path: ResolvedVc<FileSystemPath>,\n+        file_path: FileSystemPath,\n         description: RcStr,\n         source: ResolvedVc<Box<dyn ContentSource>>,\n     ) -> Vc<Self> {\n@@ -56,7 +56,7 @@ impl ContentSource for IssueFilePathContentSource {\n     async fn get_routes(self: ResolvedVc<Self>) -> Result<Vc<RouteTree>> {\n         let this = self.await?;\n         let routes = content_source_get_routes_operation(this.source)\n-            .issue_file_path(this.file_path.map(|v| *v), &*this.description)\n+            .issue_file_path(this.file_path.clone(), &*this.description)\n             .await?\n             .connect();\n         Ok(routes.map_routes(Vc::upcast(\n@@ -111,7 +111,7 @@ impl GetContentSourceContent for IssueContextGetContentSourceContent {\n     async fn vary(&self) -> Result<Vc<ContentSourceDataVary>> {\n         let source = self.source.await?;\n         Ok(get_content_source_vary_operation(self.get_content)\n-            .issue_file_path(source.file_path.map(|v| *v), &*source.description)\n+            .issue_file_path(source.file_path.clone(), &*source.description)\n             .await?\n             .connect())\n     }\n@@ -121,7 +121,7 @@ impl GetContentSourceContent for IssueContextGetContentSourceContent {\n         let source = self.source.await?;\n         Ok(\n             get_content_source_get_operation(self.get_content, path, data)\n-                .issue_file_path(source.file_path.map(|v| *v), &*source.description)\n+                .issue_file_path(source.file_path.clone(), &*source.description)\n                 .await?\n                 .connect(),\n         )"
        },
        {
            "sha": "0002a5e7c6150bfd247d4701ab9cfb7f797f2e27",
            "filename": "turbopack/crates/turbopack-dev-server/src/source/mod.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fsource%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fsource%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fsource%2Fmod.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -433,7 +433,7 @@ pub trait ContentSource {\n pub trait ContentSourceExt {\n     fn issue_file_path(\n         self: Vc<Self>,\n-        file_path: Vc<FileSystemPath>,\n+        file_path: FileSystemPath,\n         description: RcStr,\n     ) -> Vc<Box<dyn ContentSource>>;\n }\n@@ -444,7 +444,7 @@ where\n {\n     fn issue_file_path(\n         self: Vc<Self>,\n-        file_path: Vc<FileSystemPath>,\n+        file_path: FileSystemPath,\n         description: RcStr,\n     ) -> Vc<Box<dyn ContentSource>> {\n         Vc::upcast(IssueFilePathContentSource::new_file_path("
        },
        {
            "sha": "7138ba8e417c06b7af14261d3644cf8b58b7d6aa",
            "filename": "turbopack/crates/turbopack-dev-server/src/source/static_assets.rs",
            "status": "modified",
            "additions": 16,
            "deletions": 14,
            "changes": 30,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fsource%2Fstatic_assets.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fsource%2Fstatic_assets.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fsource%2Fstatic_assets.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -17,21 +17,21 @@ use super::{\n #[turbo_tasks::value(shared)]\n pub struct StaticAssetsContentSource {\n     pub prefix: ResolvedVc<RcStr>,\n-    pub dir: ResolvedVc<FileSystemPath>,\n+    pub dir: FileSystemPath,\n }\n \n #[turbo_tasks::value_impl]\n impl StaticAssetsContentSource {\n     // TODO(WEB-1151): Remove this method and migrate users to `with_prefix`.\n     #[turbo_tasks::function]\n-    pub fn new(prefix: RcStr, dir: Vc<FileSystemPath>) -> Vc<StaticAssetsContentSource> {\n+    pub fn new(prefix: RcStr, dir: FileSystemPath) -> Vc<StaticAssetsContentSource> {\n         StaticAssetsContentSource::with_prefix(Vc::cell(prefix), dir)\n     }\n \n     #[turbo_tasks::function]\n     pub async fn with_prefix(\n         prefix: ResolvedVc<RcStr>,\n-        dir: ResolvedVc<FileSystemPath>,\n+        dir: FileSystemPath,\n     ) -> Result<Vc<StaticAssetsContentSource>> {\n         if cfg!(debug_assertions) {\n             let prefix_string = prefix.await?;\n@@ -44,7 +44,7 @@ impl StaticAssetsContentSource {\n \n // TODO(WEB-1251) It would be better to lazily enumerate the directory\n #[turbo_tasks::function]\n-async fn get_routes_from_directory(dir: Vc<FileSystemPath>) -> Result<Vc<RouteTree>> {\n+async fn get_routes_from_directory(dir: FileSystemPath) -> Result<Vc<RouteTree>> {\n     let dir = dir.read_dir().await?;\n     let DirectoryContent::Entries(entries) = &*dir else {\n         return Ok(RouteTree::empty());\n@@ -57,11 +57,11 @@ async fn get_routes_from_directory(dir: Vc<FileSystemPath>) -> Result<Vc<RouteTr\n                 Some(RouteTree::new_route(\n                     vec![BaseSegment::Static(name.clone())],\n                     RouteType::Exact,\n-                    Vc::upcast(StaticAssetsContentSourceItem::new(**path)),\n+                    Vc::upcast(StaticAssetsContentSourceItem::new(path.clone())),\n                 ))\n             }\n             DirectoryEntry::Directory(path) => Some(\n-                get_routes_from_directory(**path)\n+                get_routes_from_directory(path.clone())\n                     .with_prepended_base(vec![BaseSegment::Static(name.clone())]),\n             ),\n             _ => None,\n@@ -78,19 +78,19 @@ impl ContentSource for StaticAssetsContentSource {\n     async fn get_routes(&self) -> Result<Vc<RouteTree>> {\n         let prefix = self.prefix.await?;\n         let prefix = BaseSegment::from_static_pathname(prefix.as_str()).collect::<Vec<_>>();\n-        Ok(get_routes_from_directory(*self.dir).with_prepended_base(prefix))\n+        Ok(get_routes_from_directory(self.dir.clone()).with_prepended_base(prefix))\n     }\n }\n \n #[turbo_tasks::value]\n struct StaticAssetsContentSourceItem {\n-    path: ResolvedVc<FileSystemPath>,\n+    path: FileSystemPath,\n }\n \n #[turbo_tasks::value_impl]\n impl StaticAssetsContentSourceItem {\n     #[turbo_tasks::function]\n-    pub fn new(path: ResolvedVc<FileSystemPath>) -> Vc<StaticAssetsContentSourceItem> {\n+    pub fn new(path: FileSystemPath) -> Vc<StaticAssetsContentSourceItem> {\n         StaticAssetsContentSourceItem { path }.cell()\n     }\n }\n@@ -99,7 +99,7 @@ impl StaticAssetsContentSourceItem {\n impl GetContentSourceContent for StaticAssetsContentSourceItem {\n     #[turbo_tasks::function]\n     fn get(&self, _path: RcStr, _data: ContentSourceData) -> Vc<ContentSourceContent> {\n-        let content = Vc::upcast::<Box<dyn Asset>>(FileSource::new(*self.path)).content();\n+        let content = Vc::upcast::<Box<dyn Asset>>(FileSource::new(self.path.clone())).content();\n         ContentSourceContent::static_content(content.versioned())\n     }\n }\n@@ -127,15 +127,17 @@ impl Introspectable for StaticAssetsContentSource {\n                     let child = match entry {\n                         DirectoryEntry::File(path) | DirectoryEntry::Symlink(path) => {\n                             ResolvedVc::upcast(\n-                                IntrospectableSource::new(Vc::upcast(FileSource::new(**path)))\n-                                    .to_resolved()\n-                                    .await?,\n+                                IntrospectableSource::new(Vc::upcast(FileSource::new(\n+                                    path.clone(),\n+                                )))\n+                                .to_resolved()\n+                                .await?,\n                             )\n                         }\n                         DirectoryEntry::Directory(path) => ResolvedVc::upcast(\n                             StaticAssetsContentSource::with_prefix(\n                                 Vc::cell(format!(\"{}{name}/\", &*prefix).into()),\n-                                **path,\n+                                path.clone(),\n                             )\n                             .to_resolved()\n                             .await?,"
        },
        {
            "sha": "a4e515da71aab2d928e05535c31fc610b2eff6d1",
            "filename": "turbopack/crates/turbopack-dev-server/src/update/stream.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 2,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fupdate%2Fstream.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fupdate%2Fstream.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fupdate%2Fstream.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -389,8 +389,12 @@ impl Issue for FatalStreamIssue {\n     }\n \n     #[turbo_tasks::function]\n-    fn file_path(&self) -> Vc<FileSystemPath> {\n-        ServerFileSystem::new().root().join(self.resource.clone())\n+    async fn file_path(&self) -> Result<Vc<FileSystemPath>> {\n+        Ok(ServerFileSystem::new()\n+            .root()\n+            .await?\n+            .join(&self.resource)?\n+            .cell())\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "6825d563e29e44115725c0c5f2dcc85a54d58af2",
            "filename": "turbopack/crates/turbopack-ecmascript-plugins/src/transform/directives/server.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript-plugins%2Fsrc%2Ftransform%2Fdirectives%2Fserver.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript-plugins%2Fsrc%2Ftransform%2Fdirectives%2Fserver.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript-plugins%2Fsrc%2Ftransform%2Fdirectives%2Fserver.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -41,7 +41,7 @@ impl CustomTransformer for ServerDirectiveTransformer {\n                 Program::Script(s) => s.body = vec![stmt],\n             }\n             UnsupportedServerActionIssue {\n-                file_path: ctx.file_path,\n+                file_path: ctx.file_path.clone(),\n             }\n             .resolved_cell()\n             .emit();"
        },
        {
            "sha": "2a33062352d476bf21772c75dc062bbe8919d61f",
            "filename": "turbopack/crates/turbopack-ecmascript-plugins/src/transform/relay.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript-plugins%2Fsrc%2Ftransform%2Frelay.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript-plugins%2Fsrc%2Ftransform%2Frelay.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript-plugins%2Fsrc%2Ftransform%2Frelay.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -66,7 +66,6 @@ impl CustomTransformer for RelayTransformer {\n         let path_to_proj = PathBuf::from(\n             ctx.file_path\n                 .parent()\n-                .await?\n                 .get_relative_path_to(&self.project_path)\n                 .context(\"Expected relative path to relay artifact\")?,\n         );"
        },
        {
            "sha": "088a08166516408a421d428d01b8dbdd601f487b",
            "filename": "turbopack/crates/turbopack-ecmascript-plugins/src/transform/swc_ecma_transform_plugins.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript-plugins%2Fsrc%2Ftransform%2Fswc_ecma_transform_plugins.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript-plugins%2Fsrc%2Ftransform%2Fswc_ecma_transform_plugins.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript-plugins%2Fsrc%2Ftransform%2Fswc_ecma_transform_plugins.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -2,7 +2,7 @@ use anyhow::Result;\n use async_trait::async_trait;\n use swc_core::ecma::ast::Program;\n use turbo_rcstr::rcstr;\n-use turbo_tasks::{ResolvedVc, Vc};\n+use turbo_tasks::Vc;\n use turbo_tasks_fs::FileSystemPath;\n use turbopack_core::issue::{Issue, IssueSeverity, IssueStage, OptionStyledString, StyledString};\n use turbopack_ecmascript::{CustomTransformer, TransformContext};\n@@ -50,7 +50,7 @@ impl SwcPluginModule {\n \n #[turbo_tasks::value(shared)]\n struct UnsupportedSwcEcmaTransformPluginsIssue {\n-    pub file_path: ResolvedVc<FileSystemPath>,\n+    pub file_path: FileSystemPath,\n }\n \n #[turbo_tasks::value_impl]\n@@ -74,7 +74,7 @@ impl Issue for UnsupportedSwcEcmaTransformPluginsIssue {\n \n     #[turbo_tasks::function]\n     fn file_path(&self) -> Vc<FileSystemPath> {\n-        *self.file_path\n+        self.file_path.clone().cell()\n     }\n \n     #[turbo_tasks::function]\n@@ -228,7 +228,7 @@ impl CustomTransformer for SwcEcmaTransformPluginsTransformer {\n             use turbopack_core::issue::IssueExt;\n \n             UnsupportedSwcEcmaTransformPluginsIssue {\n-                file_path: ctx.file_path,\n+                file_path: ctx.file_path.clone(),\n             }\n             .resolved_cell()\n             .emit();"
        },
        {
            "sha": "fbc06c8cd9b2ebac2cc595ffc73ea52d6583b500",
            "filename": "turbopack/crates/turbopack-ecmascript-runtime/src/embed_js.rs",
            "status": "modified",
            "additions": 13,
            "deletions": 7,
            "changes": 20,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fsrc%2Fembed_js.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fsrc%2Fembed_js.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fsrc%2Fembed_js.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -1,3 +1,4 @@\n+use anyhow::Result;\n use turbo_rcstr::RcStr;\n use turbo_tasks::Vc;\n use turbo_tasks_fs::{FileContent, FileSystem, FileSystemPath, embed_directory};\n@@ -10,20 +11,25 @@ pub fn embed_fs() -> Vc<Box<dyn FileSystem>> {\n }\n \n #[turbo_tasks::function]\n-pub fn embed_file(path: RcStr) -> Vc<FileContent> {\n-    embed_fs().root().join(path).read()\n+pub async fn embed_file(path: RcStr) -> Result<Vc<FileContent>> {\n+    Ok(embed_fs().root().await?.join(&path)?.read())\n }\n \n #[turbo_tasks::function]\n-pub fn embed_file_path(path: RcStr) -> Vc<FileSystemPath> {\n-    embed_fs().root().join(path)\n+pub async fn embed_file_path(path: RcStr) -> Result<Vc<FileSystemPath>> {\n+    Ok(embed_fs().root().await?.join(&path)?.cell())\n }\n \n #[turbo_tasks::function]\n-pub fn embed_static_code(\n+pub async fn embed_static_code(\n     asset_context: Vc<Box<dyn AssetContext>>,\n     path: RcStr,\n     generate_source_map: bool,\n-) -> Vc<Code> {\n-    StaticEcmascriptCode::new(asset_context, embed_file_path(path), generate_source_map).code()\n+) -> Result<Vc<Code>> {\n+    Ok(StaticEcmascriptCode::new(\n+        asset_context,\n+        embed_file_path(path).await?.clone_value(),\n+        generate_source_map,\n+    )\n+    .code())\n }"
        },
        {
            "sha": "10b8772a5f54c283ca55a6c7ba72876380fb3cfd",
            "filename": "turbopack/crates/turbopack-ecmascript/src/async_chunk/chunk_item.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fasync_chunk%2Fchunk_item.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fasync_chunk%2Fchunk_item.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fasync_chunk%2Fchunk_item.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -62,7 +62,7 @@ impl AsyncLoaderChunkItem {\n     async fn chunks_data(self: Vc<Self>) -> Result<Vc<ChunksData>> {\n         let this = self.await?;\n         Ok(ChunkData::from_assets(\n-            this.chunking_context.output_root(),\n+            this.chunking_context.output_root().await?.clone_value(),\n             self.chunks(),\n         ))\n     }"
        },
        {
            "sha": "3ad9666b045c7489584137387d6cb6981c7d4195",
            "filename": "turbopack/crates/turbopack-ecmascript/src/chunk/item.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fchunk%2Fitem.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fchunk%2Fitem.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fchunk%2Fitem.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -30,7 +30,7 @@ pub struct EcmascriptChunkItemContent {\n     pub source_map: Option<Rope>,\n     pub additional_ids: SmallVec<[ResolvedVc<ModuleId>; 1]>,\n     pub options: EcmascriptChunkItemOptions,\n-    pub rewrite_source_path: Option<ResolvedVc<FileSystemPath>>,\n+    pub rewrite_source_path: Option<FileSystemPath>,\n     pub placeholder_for_future_extensions: (),\n }\n \n@@ -55,7 +55,7 @@ impl EcmascriptChunkItemContent {\n \n         Ok(EcmascriptChunkItemContent {\n             rewrite_source_path: if *chunking_context.should_use_file_source_map_uris().await? {\n-                Some(chunking_context.root_path().to_resolved().await?)\n+                Some(chunking_context.root_path().await?.clone_value())\n             } else {\n                 None\n             },\n@@ -134,8 +134,8 @@ impl EcmascriptChunkItemContent {\n             code += \"{\\n\";\n         }\n \n-        let source_map = if let Some(rewrite_source_path) = self.rewrite_source_path {\n-            fileify_source_map(self.source_map.as_ref(), *rewrite_source_path).await?\n+        let source_map = if let Some(rewrite_source_path) = &self.rewrite_source_path {\n+            fileify_source_map(self.source_map.as_ref(), rewrite_source_path.clone()).await?\n         } else {\n             self.source_map.clone()\n         };\n@@ -279,7 +279,7 @@ async fn module_factory_with_code_generation_issue(\n                 let js_error_message = serde_json::to_string(&error_message)?;\n                 CodeGenerationIssue {\n                     severity: IssueSeverity::Error,\n-                    path: chunk_item.asset_ident().path().to_resolved().await?,\n+                    path: chunk_item.asset_ident().path().await?.clone_value(),\n                     title: StyledString::Text(rcstr!(\"Code generation for chunk item errored\"))\n                         .resolved_cell(),\n                     message: StyledString::Text(error_message).resolved_cell(),"
        },
        {
            "sha": "31b25930a566228cb1efa1896b597b7058f514b4",
            "filename": "turbopack/crates/turbopack-ecmascript/src/chunk/mod.rs",
            "status": "modified",
            "additions": 8,
            "deletions": 9,
            "changes": 17,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fchunk%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fchunk%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fchunk%2Fmod.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -72,24 +72,23 @@ impl Chunk for EcmascriptChunk {\n     async fn ident(&self) -> Result<Vc<AssetIdent>> {\n         let chunk_items = &*self.content.included_chunk_items().await?;\n         let mut common_path = if let Some(chunk_item) = chunk_items.first() {\n-            let path = chunk_item.asset_ident().path().to_resolved().await?;\n-            Some((path, path.await?))\n+            let path = chunk_item.asset_ident().path().await?.clone_value();\n+            Some(path)\n         } else {\n             None\n         };\n \n         // The included chunk items describe the chunk uniquely\n         for &chunk_item in chunk_items.iter() {\n-            if let Some((common_path_vc, common_path_ref)) = common_path.as_mut() {\n+            if let Some(common_path_ref) = common_path.as_mut() {\n                 let path = chunk_item.asset_ident().path().await?;\n                 while !path.is_inside_or_equal_ref(common_path_ref) {\n-                    let parent = common_path_vc.parent().to_resolved().await?;\n-                    if parent == *common_path_vc {\n+                    let parent = common_path_ref.parent();\n+                    if parent == *common_path_ref {\n                         common_path = None;\n                         break;\n                     }\n-                    *common_path_vc = parent;\n-                    *common_path_ref = (*common_path_vc).await?;\n+                    *common_path_ref = parent;\n                 }\n             }\n         }\n@@ -106,10 +105,10 @@ impl Chunk for EcmascriptChunk {\n             .await?;\n \n         let ident = AssetIdent {\n-            path: if let Some((common_path, _)) = common_path {\n+            path: if let Some(common_path) = common_path {\n                 common_path\n             } else {\n-                ServerFileSystem::new().root().to_resolved().await?\n+                ServerFileSystem::new().root().await?.clone_value()\n             },\n             query: RcStr::default(),\n             fragment: RcStr::default(),"
        },
        {
            "sha": "b636c8687436a98ee21f6a956cb1758e98267655",
            "filename": "turbopack/crates/turbopack-ecmascript/src/chunk/placeable.rs",
            "status": "modified",
            "additions": 37,
            "deletions": 35,
            "changes": 72,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fchunk%2Fplaceable.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fchunk%2Fplaceable.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fchunk%2Fplaceable.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -25,11 +25,14 @@ pub trait EcmascriptChunkPlaceable: ChunkableModule + Module + Asset {\n         Vc::cell(None)\n     }\n     #[turbo_tasks::function]\n-    fn is_marked_as_side_effect_free(\n+    async fn is_marked_as_side_effect_free(\n         self: Vc<Self>,\n         side_effect_free_packages: Vc<Glob>,\n-    ) -> Vc<bool> {\n-        is_marked_as_side_effect_free(self.ident().path(), side_effect_free_packages)\n+    ) -> Result<Vc<bool>> {\n+        Ok(is_marked_as_side_effect_free(\n+            self.ident().path().await?.clone_value(),\n+            side_effect_free_packages,\n+        ))\n     }\n }\n \n@@ -42,7 +45,7 @@ enum SideEffectsValue {\n \n #[turbo_tasks::function]\n async fn side_effects_from_package_json(\n-    package_json: ResolvedVc<FileSystemPath>,\n+    package_json: FileSystemPath,\n ) -> Result<Vc<SideEffectsValue>> {\n     if let FileJsonContent::Content(content) = &*package_json.read_json().await?\n         && let Some(side_effects) = content.get(\"sideEffects\")\n@@ -63,7 +66,7 @@ async fn side_effects_from_package_json(\n                         }\n                     } else {\n                         SideEffectsInPackageJsonIssue {\n-                            path: package_json,\n+                            path: package_json.clone(),\n                             description: Some(\n                                 StyledString::Text(\n                                     format!(\n@@ -80,26 +83,29 @@ async fn side_effects_from_package_json(\n                         None\n                     }\n                 })\n-                .map(|glob| async move {\n-                    match glob.resolve().await {\n-                        Ok(glob) => Ok(Some(glob)),\n-                        Err(err) => {\n-                            SideEffectsInPackageJsonIssue {\n-                                path: package_json,\n-                                description: Some(\n-                                    StyledString::Text(\n-                                        format!(\n-                                            \"Invalid glob in sideEffects: {}\",\n-                                            PrettyPrintError(&err)\n+                .map(|glob| {\n+                    let package_json = package_json.clone();\n+                    async move {\n+                        match glob.resolve().await {\n+                            Ok(glob) => Ok(Some(glob)),\n+                            Err(err) => {\n+                                SideEffectsInPackageJsonIssue {\n+                                    path: package_json.clone(),\n+                                    description: Some(\n+                                        StyledString::Text(\n+                                            format!(\n+                                                \"Invalid glob in sideEffects: {}\",\n+                                                PrettyPrintError(&err)\n+                                            )\n+                                            .into(),\n                                         )\n-                                        .into(),\n-                                    )\n-                                    .resolved_cell(),\n-                                ),\n+                                        .resolved_cell(),\n+                                    ),\n+                                }\n+                                .resolved_cell()\n+                                .emit();\n+                                Ok(None)\n                             }\n-                            .resolved_cell()\n-                            .emit();\n-                            Ok(None)\n                         }\n                     }\n                 })\n@@ -110,7 +116,7 @@ async fn side_effects_from_package_json(\n             );\n         } else {\n             SideEffectsInPackageJsonIssue {\n-                path: package_json,\n+                path: package_json.clone(),\n                 description: Some(\n                     StyledString::Text(\n                         format!(\n@@ -130,7 +136,7 @@ async fn side_effects_from_package_json(\n \n #[turbo_tasks::value]\n struct SideEffectsInPackageJsonIssue {\n-    path: ResolvedVc<FileSystemPath>,\n+    path: FileSystemPath,\n     description: Option<ResolvedVc<StyledString>>,\n }\n \n@@ -147,7 +153,7 @@ impl Issue for SideEffectsInPackageJsonIssue {\n \n     #[turbo_tasks::function]\n     fn file_path(&self) -> Vc<FileSystemPath> {\n-        *self.path\n+        self.path.clone().cell()\n     }\n \n     #[turbo_tasks::function]\n@@ -163,25 +169,21 @@ impl Issue for SideEffectsInPackageJsonIssue {\n \n #[turbo_tasks::function]\n pub async fn is_marked_as_side_effect_free(\n-    path: Vc<FileSystemPath>,\n+    path: FileSystemPath,\n     side_effect_free_packages: Vc<Glob>,\n ) -> Result<Vc<bool>> {\n-    if side_effect_free_packages.await?.matches(&path.await?.path) {\n+    if side_effect_free_packages.await?.matches(&path.path) {\n         return Ok(Vc::cell(true));\n     }\n \n     let find_package_json = find_context_file(path.parent(), package_json()).await?;\n \n-    if let FindContextFileResult::Found(package_json, _) = *find_package_json {\n-        match *side_effects_from_package_json(*package_json).await? {\n+    if let FindContextFileResult::Found(package_json, _) = &*find_package_json {\n+        match *side_effects_from_package_json(package_json.clone()).await? {\n             SideEffectsValue::None => {}\n             SideEffectsValue::Constant(side_effects) => return Ok(Vc::cell(!side_effects)),\n             SideEffectsValue::Glob(glob) => {\n-                if let Some(rel_path) = package_json\n-                    .parent()\n-                    .await?\n-                    .get_relative_path_to(&*path.await?)\n-                {\n+                if let Some(rel_path) = package_json.parent().get_relative_path_to(&path) {\n                     let rel_path = rel_path.strip_prefix(\"./\").unwrap_or(&rel_path);\n                     return Ok(Vc::cell(!glob.await?.matches(rel_path)));\n                 }"
        },
        {
            "sha": "d08f940372a0111c3222deb5367777bb7d433d7a",
            "filename": "turbopack/crates/turbopack-ecmascript/src/lib.rs",
            "status": "modified",
            "additions": 13,
            "deletions": 19,
            "changes": 32,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -381,10 +381,10 @@ impl EcmascriptModuleAsset {\n }\n \n #[turbo_tasks::value]\n-#[derive(Copy, Clone)]\n+#[derive(Clone)]\n pub(crate) struct ModuleTypeResult {\n     pub module_type: SpecifiedModuleType,\n-    pub referenced_package_json: Option<ResolvedVc<FileSystemPath>>,\n+    pub referenced_package_json: Option<FileSystemPath>,\n }\n \n #[turbo_tasks::value_impl]\n@@ -400,7 +400,7 @@ impl ModuleTypeResult {\n     #[turbo_tasks::function]\n     fn new_with_package_json(\n         module_type: SpecifiedModuleType,\n-        package_json: ResolvedVc<FileSystemPath>,\n+        package_json: FileSystemPath,\n     ) -> Vc<Self> {\n         Self::cell(ModuleTypeResult {\n             module_type,\n@@ -479,7 +479,7 @@ impl EcmascriptAnalyzable for EcmascriptModuleAsset {\n         let analyze = self.analyze();\n         let analyze_ref = analyze.await?;\n \n-        let module_type_result = *self.determine_module_type().await?;\n+        let module_type_result = self.determine_module_type().await?;\n         let generate_source_map = *chunking_context\n             .reference_module_source_maps(Vc::upcast(*self))\n             .await?;\n@@ -517,11 +517,11 @@ impl EcmascriptAnalyzable for EcmascriptModuleAsset {\n \n #[turbo_tasks::function]\n async fn determine_module_type_for_directory(\n-    context_path: Vc<FileSystemPath>,\n+    context_path: FileSystemPath,\n ) -> Result<Vc<ModuleTypeResult>> {\n     let find_package_json =\n         find_context_file(context_path, package_json().resolve().await?).await?;\n-    let FindContextFileResult::Found(package_json, _) = *find_package_json else {\n+    let FindContextFileResult::Found(package_json, _) = &*find_package_json else {\n         return Ok(ModuleTypeResult::new(SpecifiedModuleType::Automatic));\n     };\n \n@@ -535,13 +535,13 @@ async fn determine_module_type_for_directory(\n                 Some(\"commonjs\") => SpecifiedModuleType::CommonJs,\n                 _ => SpecifiedModuleType::Automatic,\n             },\n-            *package_json,\n+            package_json.clone(),\n         ));\n     }\n \n     Ok(ModuleTypeResult::new_with_package_json(\n         SpecifiedModuleType::Automatic,\n-        *package_json,\n+        package_json.clone(),\n     ))\n }\n \n@@ -638,15 +638,7 @@ impl EcmascriptModuleAsset {\n             SpecifiedModuleType::Automatic => {}\n         }\n \n-        determine_module_type_for_directory(\n-            self.origin_path()\n-                .resolve()\n-                .await?\n-                .parent()\n-                .resolve()\n-                .await?,\n-        )\n-        .await\n+        determine_module_type_for_directory(self.origin_path().await?.parent()).await\n     }\n }\n \n@@ -722,8 +714,10 @@ impl EcmascriptChunkPlaceable for EcmascriptModuleAsset {\n         side_effect_free_packages: Vc<Glob>,\n     ) -> Result<Vc<bool>> {\n         // Check package.json first, so that we can skip parsing the module if it's marked that way.\n-        let pkg_side_effect_free =\n-            is_marked_as_side_effect_free(self.ident().path(), side_effect_free_packages);\n+        let pkg_side_effect_free = is_marked_as_side_effect_free(\n+            self.ident().path().await?.clone_value(),\n+            side_effect_free_packages,\n+        );\n         Ok(if *pkg_side_effect_free.await? {\n             pkg_side_effect_free\n         } else {"
        },
        {
            "sha": "0f528285d0ff24c4e9ff40e2c8420c817f9849e3",
            "filename": "turbopack/crates/turbopack-ecmascript/src/manifest/chunk_item.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 2,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fmanifest%2Fchunk_item.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fmanifest%2Fchunk_item.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fmanifest%2Fchunk_item.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -30,8 +30,11 @@ pub(super) struct ManifestChunkItem {\n #[turbo_tasks::value_impl]\n impl ManifestChunkItem {\n     #[turbo_tasks::function]\n-    fn chunks_data(&self) -> Vc<ChunksData> {\n-        ChunkData::from_assets(self.chunking_context.output_root(), self.manifest.chunks())\n+    async fn chunks_data(&self) -> Result<Vc<ChunksData>> {\n+        Ok(ChunkData::from_assets(\n+            self.chunking_context.output_root().await?.clone_value(),\n+            self.manifest.chunks(),\n+        ))\n     }\n }\n "
        },
        {
            "sha": "d90e2a63f80265842cd32e930ca2e46b694ac339",
            "filename": "turbopack/crates/turbopack-ecmascript/src/manifest/loader_item.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 2,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fmanifest%2Floader_item.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fmanifest%2Floader_item.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fmanifest%2Floader_item.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -66,9 +66,12 @@ impl ManifestLoaderChunkItem {\n     }\n \n     #[turbo_tasks::function]\n-    pub fn chunks_data(&self) -> Vc<ChunksData> {\n+    pub async fn chunks_data(&self) -> Result<Vc<ChunksData>> {\n         let chunks = self.manifest.manifest_chunks();\n-        ChunkData::from_assets(self.chunking_context.output_root(), chunks)\n+        Ok(ChunkData::from_assets(\n+            self.chunking_context.output_root().await?.clone_value(),\n+            chunks,\n+        ))\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "83b19d429bc9b9db4d7cbc38e7c3a33be61ae4fb",
            "filename": "turbopack/crates/turbopack-ecmascript/src/parse.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fparse.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fparse.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fparse.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -215,8 +215,8 @@ async fn parse_internal(\n     transforms: Vc<EcmascriptInputTransforms>,\n ) -> Result<Vc<ParseResult>> {\n     let content = source.content();\n-    let fs_path_vc = source.ident().path();\n-    let fs_path = &*fs_path_vc.await?;\n+    let fs_path_vc = source.ident().path().await?.clone_value();\n+    let fs_path = fs_path_vc.clone();\n     let ident = &*source.ident().to_string().await?;\n     let file_path_hash = hash_xxh3_hash64(&*source.ident().to_string().await?) as u128;\n     let content = match content.await {\n@@ -245,8 +245,8 @@ async fn parse_internal(\n                         let transforms = &*transforms.await?;\n                         match parse_file_content(\n                             string,\n-                            fs_path_vc,\n-                            fs_path,\n+                            fs_path_vc.clone(),\n+                            &fs_path,\n                             ident,\n                             source.ident().await?.query.clone(),\n                             file_path_hash,\n@@ -291,7 +291,7 @@ async fn parse_internal(\n \n async fn parse_file_content(\n     string: BytesStr,\n-    fs_path_vc: Vc<FileSystemPath>,\n+    fs_path_vc: FileSystemPath,\n     fs_path: &FileSystemPath,\n     ident: &str,\n     query: RcStr,\n@@ -452,7 +452,7 @@ async fn parse_file_content(\n                 file_name_str: fs_path.file_name(),\n                 file_name_hash: file_path_hash,\n                 query_str: query,\n-                file_path: fs_path_vc.to_resolved().await?,\n+                file_path: fs_path_vc.clone(),\n             };\n             let span = tracing::trace_span!(\"transforms\");\n             async {"
        },
        {
            "sha": "0f16cfd01776dc57cf3ce91428f48205ce095966",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/esm/meta.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fmeta.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fmeta.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fmeta.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -8,7 +8,7 @@ use swc_core::{\n     quote,\n };\n use turbo_rcstr::rcstr;\n-use turbo_tasks::{NonLocalValue, ResolvedVc, Vc, debug::ValueDebugFormat, trace::TraceRawVcs};\n+use turbo_tasks::{NonLocalValue, Vc, debug::ValueDebugFormat, trace::TraceRawVcs};\n use turbo_tasks_fs::FileSystemPath;\n use turbopack_core::{chunk::ChunkingContext, module_graph::ModuleGraph};\n \n@@ -28,11 +28,11 @@ use crate::{\n /// This singleton behavior must be enforced by the caller!\n #[derive(PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue)]\n pub struct ImportMetaBinding {\n-    path: ResolvedVc<FileSystemPath>,\n+    path: FileSystemPath,\n }\n \n impl ImportMetaBinding {\n-    pub fn new(path: ResolvedVc<FileSystemPath>) -> Self {\n+    pub fn new(path: FileSystemPath) -> Self {\n         ImportMetaBinding { path }\n     }\n \n@@ -44,7 +44,7 @@ impl ImportMetaBinding {\n         let rel_path = chunking_context\n             .root_path()\n             .await?\n-            .get_relative_path_to(&*self.path.await?);\n+            .get_relative_path_to(&self.path);\n         let path = rel_path.map_or_else(\n             || {\n                 quote!("
        },
        {
            "sha": "c200fa069f6030106cc635c17b1eaab77f43c9ae",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/external_module.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fexternal_module.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fexternal_module.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fexternal_module.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -192,13 +192,13 @@ impl CachedExternalModule {\n #[turbo_tasks::value_impl]\n impl Module for CachedExternalModule {\n     #[turbo_tasks::function]\n-    fn ident(&self) -> Vc<AssetIdent> {\n+    async fn ident(&self) -> Result<Vc<AssetIdent>> {\n         let fs = VirtualFileSystem::new_with_name(rcstr!(\"externals\"));\n \n-        AssetIdent::from_path(fs.root().join(self.request.clone()))\n+        Ok(AssetIdent::from_path(fs.root().await?.join(&self.request)?)\n             .with_layer(Layer::new(rcstr!(\"external\")))\n             .with_modifier(self.request.clone())\n-            .with_modifier(self.external_type.to_string().into())\n+            .with_modifier(self.external_type.to_string().into()))\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "407cbaad7b9c309cd97200cc2994e1027f044d1c",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/mod.rs",
            "status": "modified",
            "additions": 42,
            "deletions": 28,
            "changes": 70,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fmod.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -526,7 +526,7 @@ pub(crate) async fn analyse_ecmascript_module_internal(\n     let origin = ResolvedVc::upcast::<Box<dyn ResolveOrigin>>(module);\n \n     let mut analysis = AnalyzeEcmascriptModuleResultBuilder::new();\n-    let path = origin.origin_path();\n+    let path = origin.origin_path().await?.clone_value();\n \n     // Is this a typescript file that requires analzying type references?\n     let analyze_types = match &ty {\n@@ -546,13 +546,13 @@ pub(crate) async fn analyse_ecmascript_module_internal(\n     let ModuleTypeResult {\n         module_type: specified_type,\n         referenced_package_json,\n-    } = *module.determine_module_type().await?;\n+    } = module.determine_module_type().await?.clone_value();\n \n     if let Some(package_json) = referenced_package_json {\n         let span = tracing::info_span!(\"package.json reference\");\n         async {\n             analysis.add_reference(\n-                PackageJsonReference::new(*package_json)\n+                PackageJsonReference::new(package_json.clone())\n                     .to_resolved()\n                     .await?,\n             );\n@@ -568,7 +568,7 @@ pub(crate) async fn analyse_ecmascript_module_internal(\n             match &*find_context_file(path.parent(), tsconfig()).await? {\n                 FindContextFileResult::Found(tsconfig, _) => {\n                     analysis.add_reference(\n-                        TsConfigReference::new(*origin, **tsconfig)\n+                        TsConfigReference::new(*origin, tsconfig.clone())\n                             .to_resolved()\n                             .await?,\n                     );\n@@ -581,7 +581,7 @@ pub(crate) async fn analyse_ecmascript_module_internal(\n         .await?;\n     }\n \n-    special_cases(&path.await?.path, &mut analysis);\n+    special_cases(&path.path, &mut analysis);\n \n     let parsed = parsed.await?;\n \n@@ -692,9 +692,9 @@ pub(crate) async fn analyse_ecmascript_module_internal(\n                 static JSON_DATA_URL_BASE64: LazyLock<Regex> = LazyLock::new(|| {\n                     Regex::new(r\"^data:application\\/json;(?:charset=utf-8;)?base64\").unwrap()\n                 });\n-                let origin_path = origin.origin_path();\n+                let origin_path = origin.origin_path().await?.clone_value();\n                 if path.ends_with(\".map\") {\n-                    let source_map_origin = origin_path.parent().join(path.into());\n+                    let source_map_origin = origin_path.parent().join(path)?;\n                     let reference = SourceMapReference::new(origin_path, source_map_origin)\n                         .to_resolved()\n                         .await?;\n@@ -704,7 +704,7 @@ pub(crate) async fn analyse_ecmascript_module_internal(\n                 } else if JSON_DATA_URL_BASE64.is_match(path) {\n                     analysis.set_source_map(ResolvedVc::upcast(\n                         InlineSourceMap {\n-                            origin_path: origin_path.to_resolved().await?,\n+                            origin_path,\n                             source_map: path.into(),\n                         }\n                         .resolved_cell(),\n@@ -841,7 +841,7 @@ pub(crate) async fn analyse_ecmascript_module_internal(\n         let exports = if !esm_exports.is_empty() || !esm_star_exports.is_empty() {\n             if specified_type == SpecifiedModuleType::CommonJs {\n                 SpecifiedModuleTypeIssue {\n-                    path: source.ident().path().to_resolved().await?,\n+                    path: source.ident().path().await?.clone_value(),\n                     specified_type,\n                 }\n                 .resolved_cell()\n@@ -859,7 +859,7 @@ pub(crate) async fn analyse_ecmascript_module_internal(\n             match detect_dynamic_export(program) {\n                 DetectedDynamicExportType::CommonJs => {\n                     SpecifiedModuleTypeIssue {\n-                        path: source.ident().path().to_resolved().await?,\n+                        path: source.ident().path().await?.clone_value(),\n                         specified_type,\n                     }\n                     .resolved_cell()\n@@ -1419,7 +1419,7 @@ pub(crate) async fn analyse_ecmascript_module_internal(\n                     if analysis_state.first_import_meta {\n                         analysis_state.first_import_meta = false;\n                         analysis.add_code_gen(ImportMetaBinding::new(\n-                            source.ident().path().to_resolved().await?,\n+                            source.ident().path().await?.clone_value(),\n                         ));\n                     }\n \n@@ -1946,7 +1946,7 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n         }\n \n         JsValue::WellKnownFunction(WellKnownFunctionKind::PathResolve(..)) => {\n-            let parent_path = origin.origin_path().parent().await?;\n+            let parent_path = origin.origin_path().await?.clone_value().parent();\n             let args = linked_args(args).await?;\n \n             let linked_func_call = state\n@@ -2149,7 +2149,7 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                 }\n                 analysis.add_reference(\n                     NodePreGypConfigReference::new(\n-                        origin.origin_path().parent(),\n+                        origin.origin_path().await?.parent(),\n                         Pattern::new(pat),\n                         compile_time_info.environment().compile_target(),\n                     )\n@@ -2182,8 +2182,10 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                     // TODO this resolving should happen within Vc<NodeGypBuildReference>\n                     let current_context = origin\n                         .origin_path()\n+                        .await?\n                         .root()\n-                        .join(s.trim_start_matches(\"/ROOT/\").into());\n+                        .await?\n+                        .join(s.trim_start_matches(\"/ROOT/\"))?;\n                     analysis.add_reference(\n                         NodeGypBuildReference::new(\n                             current_context,\n@@ -2216,9 +2218,12 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                     .await?;\n                 if let Some(s) = first_arg.as_str() {\n                     analysis.add_reference(\n-                        NodeBindingsReference::new(origin.origin_path(), s.into())\n-                            .to_resolved()\n-                            .await?,\n+                        NodeBindingsReference::new(\n+                            origin.origin_path().await?.clone_value(),\n+                            s.into(),\n+                        )\n+                        .to_resolved()\n+                        .await?,\n                     );\n                     return Ok(());\n                 }\n@@ -2596,7 +2601,7 @@ async fn handle_free_var_reference(\n                             ResolvedVc::upcast(\n                                 PlainResolveOrigin::new(\n                                     state.origin.asset_context(),\n-                                    **lookup_path,\n+                                    lookup_path.clone(),\n                                 )\n                                 .to_resolved()\n                                 .await?,\n@@ -2630,7 +2635,7 @@ async fn handle_free_var_reference(\n             ));\n         }\n         FreeVarReference::InputRelative(kind) => {\n-            let source_path = (*state.source).ident().path();\n+            let source_path = (*state.source).ident().path().await?.clone_value();\n             let source_path = match kind {\n                 InputRelativeConstant::DirName => source_path.parent(),\n                 InputRelativeConstant::FileName => source_path,\n@@ -2838,7 +2843,7 @@ async fn analyze_amd_define_with_deps(\n \n /// Used to generate the \"root\" path to a __filename/__dirname/import.meta.url\n /// reference.\n-pub async fn as_abs_path(path: Vc<FileSystemPath>) -> Result<String> {\n+pub async fn as_abs_path(path: FileSystemPath) -> Result<String> {\n     // TODO: This should be updated to generate a real system path on the fly\n     // during runtime, so that the generated code is constant between systems\n     // but the runtime evaluation can take into account the project's\n@@ -2847,8 +2852,8 @@ pub async fn as_abs_path(path: Vc<FileSystemPath>) -> Result<String> {\n }\n \n /// Generates an absolute path usable for `require.resolve()` calls.\n-async fn require_resolve(path: Vc<FileSystemPath>) -> Result<String> {\n-    Ok(format!(\"/ROOT/{}\", path.await?.path.as_str()))\n+async fn require_resolve(path: FileSystemPath) -> Result<String> {\n+    Ok(format!(\"/ROOT/{}\", path.path.as_str()))\n }\n \n async fn early_value_visitor(mut v: JsValue) -> Result<(JsValue, bool)> {\n@@ -2975,8 +2980,12 @@ async fn value_visitor_inner(\n             }\n         }\n         JsValue::FreeVar(ref kind) => match &**kind {\n-            \"__dirname\" => as_abs_path(origin.origin_path().parent()).await?.into(),\n-            \"__filename\" => as_abs_path(origin.origin_path()).await?.into(),\n+            \"__dirname\" => as_abs_path(origin.origin_path().await?.clone_value().parent())\n+                .await?\n+                .into(),\n+            \"__filename\" => as_abs_path(origin.origin_path().await?.clone_value())\n+                .await?\n+                .into(),\n \n             \"require\" => JsValue::unknown_if(\n                 ignore,\n@@ -3039,7 +3048,7 @@ async fn require_resolve_visitor(\n             .await?\n             .iter()\n             .map(|&source| async move {\n-                require_resolve(source.ident().path())\n+                require_resolve(source.ident().path().await?.clone_value())\n                     .await\n                     .map(JsValue::from)\n             })\n@@ -3094,7 +3103,12 @@ async fn require_context_visitor(\n         }\n     };\n \n-    let dir = origin.origin_path().parent().join(options.dir.clone());\n+    let dir = origin\n+        .origin_path()\n+        .await?\n+        .clone_value()\n+        .parent()\n+        .join(options.dir.as_str())?;\n \n     let map = RequireContextMap::generate(\n         origin,\n@@ -3512,12 +3526,12 @@ async fn resolve_as_webpack_runtime(\n     transforms: Vc<EcmascriptInputTransforms>,\n ) -> Result<Vc<WebpackRuntime>> {\n     let ty = ReferenceType::CommonJs(CommonJsReferenceSubType::Undefined);\n-    let options = origin.resolve_options(ty.clone());\n+    let options = origin.resolve_options(ty.clone()).await?;\n \n     let options = apply_cjs_specific_options(options);\n \n     let resolved = resolve(\n-        origin.origin_path().parent().resolve().await?,\n+        origin.origin_path().await?.parent(),\n         ReferenceType::CommonJs(CommonJsReferenceSubType::Undefined),\n         request,\n         options,"
        },
        {
            "sha": "29690f4c3cc5cd1b1016fc3fc3159e76b523b069",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/node.rs",
            "status": "modified",
            "additions": 16,
            "deletions": 15,
            "changes": 31,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fnode.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fnode.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fnode.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -18,13 +18,13 @@ use turbopack_core::{\n #[turbo_tasks::value]\n #[derive(Hash, Clone, Debug)]\n pub struct PackageJsonReference {\n-    pub package_json: ResolvedVc<FileSystemPath>,\n+    pub package_json: FileSystemPath,\n }\n \n #[turbo_tasks::value_impl]\n impl PackageJsonReference {\n     #[turbo_tasks::function]\n-    pub fn new(package_json: ResolvedVc<FileSystemPath>) -> Vc<Self> {\n+    pub fn new(package_json: FileSystemPath) -> Vc<Self> {\n         Self::cell(PackageJsonReference { package_json })\n     }\n }\n@@ -34,7 +34,7 @@ impl ModuleReference for PackageJsonReference {\n     #[turbo_tasks::function]\n     async fn resolve_reference(&self) -> Result<Vc<ModuleResolveResult>> {\n         Ok(*ModuleResolveResult::module(ResolvedVc::upcast(\n-            RawModule::new(Vc::upcast(FileSource::new(*self.package_json)))\n+            RawModule::new(Vc::upcast(FileSource::new(self.package_json.clone())))\n                 .to_resolved()\n                 .await?,\n         )))\n@@ -46,7 +46,11 @@ impl ValueToString for PackageJsonReference {\n     #[turbo_tasks::function]\n     async fn to_string(&self) -> Result<Vc<RcStr>> {\n         Ok(Vc::cell(\n-            format!(\"package.json {}\", self.package_json.to_string().await?,).into(),\n+            format!(\n+                \"package.json {}\",\n+                self.package_json.value_to_string().await?\n+            )\n+            .into(),\n         ))\n     }\n }\n@@ -68,15 +72,15 @@ impl DirAssetReference {\n \n #[turbo_tasks::function]\n async fn resolve_reference_from_dir(\n-    parent_path: Vc<FileSystemPath>,\n+    parent_path: FileSystemPath,\n     path: Vc<Pattern>,\n ) -> Result<Vc<ModuleResolveResult>> {\n     let path_ref = path.await?;\n     let (abs_path, rel_path) = path_ref.split_could_match(\"/ROOT/\");\n     let matches = match (abs_path, rel_path) {\n         (Some(abs_path), Some(rel_path)) => Either::Right(\n             read_matches(\n-                parent_path.root().resolve().await?,\n+                parent_path.root().await?.clone_value(),\n                 rcstr!(\"/ROOT/\"),\n                 true,\n                 Pattern::new(abs_path.or_any_nested_file()),\n@@ -97,7 +101,7 @@ async fn resolve_reference_from_dir(\n         (Some(abs_path), None) => Either::Left(\n             // absolute path only\n             read_matches(\n-                parent_path.root().resolve().await?,\n+                parent_path.root().await?.clone_value(),\n                 rcstr!(\"/ROOT/\"),\n                 true,\n                 Pattern::new(abs_path.or_any_nested_file()),\n@@ -124,15 +128,15 @@ async fn resolve_reference_from_dir(\n         match pat_match {\n             PatternMatch::File(matched_path, file) => {\n                 let realpath = file.realpath_with_links().await?;\n-                for &symlink in &realpath.symlinks {\n+                for symlink in &realpath.symlinks {\n                     affecting_sources.push(ResolvedVc::upcast(\n-                        FileSource::new(*symlink).to_resolved().await?,\n+                        FileSource::new(symlink.clone()).to_resolved().await?,\n                     ));\n                 }\n                 results.push((\n                     RequestKey::new(matched_path.clone()),\n                     ResolvedVc::upcast(\n-                        RawModule::new(Vc::upcast(FileSource::new(*realpath.path)))\n+                        RawModule::new(Vc::upcast(FileSource::new(realpath.path.clone())))\n                             .to_resolved()\n                             .await?,\n                     ),\n@@ -151,11 +155,8 @@ async fn resolve_reference_from_dir(\n impl ModuleReference for DirAssetReference {\n     #[turbo_tasks::function]\n     async fn resolve_reference(&self) -> Result<Vc<ModuleResolveResult>> {\n-        let parent_path = self.source.ident().path().parent();\n-        Ok(resolve_reference_from_dir(\n-            parent_path.resolve().await?,\n-            *self.path,\n-        ))\n+        let parent_path = self.source.ident().path().await?.parent();\n+        Ok(resolve_reference_from_dir(parent_path, *self.path))\n     }\n }\n "
        },
        {
            "sha": "435862b7fd322bf598decd798bf237d1d217317a",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/pattern_mapping.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fpattern_mapping.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fpattern_mapping.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fpattern_mapping.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -354,7 +354,7 @@ async fn to_single_pattern_mapping(\n                     .into(),\n                 )\n                 .resolved_cell(),\n-                path: origin.origin_path().to_resolved().await?,\n+                path: origin.origin_path().await?.clone_value(),\n             }\n             .resolved_cell()\n             .emit();\n@@ -380,7 +380,7 @@ async fn to_single_pattern_mapping(\n             \"asset is not placeable in ESM chunks, so it doesn't have a module id\".into(),\n         )\n         .resolved_cell(),\n-        path: origin.origin_path().to_resolved().await?,\n+        path: origin.origin_path().await?.clone_value(),\n     }\n     .resolved_cell()\n     .emit();"
        },
        {
            "sha": "2bb91a4e4ae626672244a64ca40ccb54087ae963",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/raw.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fraw.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fraw.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fraw.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -25,10 +25,10 @@ impl FileSourceReference {\n #[turbo_tasks::value_impl]\n impl ModuleReference for FileSourceReference {\n     #[turbo_tasks::function]\n-    fn resolve_reference(&self) -> Vc<ModuleResolveResult> {\n-        let context_dir = self.source.ident().path().parent();\n+    async fn resolve_reference(&self) -> Result<Vc<ModuleResolveResult>> {\n+        let context_dir = self.source.ident().path().await?.parent();\n \n-        resolve_raw(context_dir, *self.path, false).as_raw_module_result()\n+        Ok(resolve_raw(context_dir, *self.path, false).as_raw_module_result())\n     }\n }\n "
        },
        {
            "sha": "b8e6e13e9ea723f7178f40db6a86981bd0ca704a",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/require_context.rs",
            "status": "modified",
            "additions": 25,
            "deletions": 20,
            "changes": 45,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Frequire_context.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Frequire_context.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Frequire_context.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -54,7 +54,7 @@ use crate::{\n #[turbo_tasks::value]\n #[derive(Debug)]\n pub(crate) enum DirListEntry {\n-    File(ResolvedVc<FileSystemPath>),\n+    File(FileSystemPath),\n     Dir(ResolvedVc<DirList>),\n }\n \n@@ -64,19 +64,19 @@ pub(crate) struct DirList(FxIndexMap<RcStr, DirListEntry>);\n #[turbo_tasks::value_impl]\n impl DirList {\n     #[turbo_tasks::function]\n-    pub(crate) fn read(dir: Vc<FileSystemPath>, recursive: bool, filter: Vc<EsRegex>) -> Vc<Self> {\n-        Self::read_internal(dir, dir, recursive, filter)\n+    pub(crate) fn read(dir: FileSystemPath, recursive: bool, filter: Vc<EsRegex>) -> Vc<Self> {\n+        Self::read_internal(dir.clone(), dir, recursive, filter)\n     }\n \n     #[turbo_tasks::function]\n     pub(crate) async fn read_internal(\n-        root: Vc<FileSystemPath>,\n-        dir: Vc<FileSystemPath>,\n+        root: FileSystemPath,\n+        dir: FileSystemPath,\n         recursive: bool,\n         filter: Vc<EsRegex>,\n     ) -> Result<Vc<Self>> {\n-        let root_val = &root.await?;\n-        let dir_val = &dir.await?;\n+        let root_val = root.clone();\n+        let dir_val = dir.clone();\n         let regex = &filter.await?;\n \n         let mut list = FxIndexMap::default();\n@@ -90,20 +90,25 @@ impl DirList {\n         for (_, entry) in entries.iter().flat_map(|m| m.iter()) {\n             match entry {\n                 DirectoryEntry::File(path) => {\n-                    if let Some(relative_path) = root_val.get_relative_path_to(&*path.await?)\n+                    if let Some(relative_path) = root_val.get_relative_path_to(path)\n                         && regex.is_match(&relative_path)\n                     {\n-                        list.insert(relative_path, DirListEntry::File(*path));\n+                        list.insert(relative_path, DirListEntry::File(path.clone()));\n                     }\n                 }\n                 DirectoryEntry::Directory(path) if recursive => {\n-                    if let Some(relative_path) = dir_val.get_relative_path_to(&*path.await?) {\n+                    if let Some(relative_path) = dir_val.get_relative_path_to(path) {\n                         list.insert(\n                             relative_path,\n                             DirListEntry::Dir(\n-                                DirList::read_internal(root, **path, recursive, filter)\n-                                    .to_resolved()\n-                                    .await?,\n+                                DirList::read_internal(\n+                                    root.clone(),\n+                                    path.clone(),\n+                                    recursive,\n+                                    filter,\n+                                )\n+                                .to_resolved()\n+                                .await?,\n                             ),\n                         );\n                     }\n@@ -130,7 +135,7 @@ impl DirList {\n             for (k, entry) in &*dir {\n                 match entry {\n                     DirListEntry::File(path) => {\n-                        list.insert(k.clone(), *path);\n+                        list.insert(k.clone(), path.clone());\n                     }\n                     DirListEntry::Dir(d) => {\n                         queue.push_back(d.await?);\n@@ -144,12 +149,12 @@ impl DirList {\n }\n \n #[turbo_tasks::value(transparent)]\n-pub(crate) struct FlatDirList(FxIndexMap<RcStr, ResolvedVc<FileSystemPath>>);\n+pub(crate) struct FlatDirList(FxIndexMap<RcStr, FileSystemPath>);\n \n #[turbo_tasks::value_impl]\n impl FlatDirList {\n     #[turbo_tasks::function]\n-    pub(crate) fn read(dir: Vc<FileSystemPath>, recursive: bool, filter: Vc<EsRegex>) -> Vc<Self> {\n+    pub(crate) fn read(dir: FileSystemPath, recursive: bool, filter: Vc<EsRegex>) -> Vc<Self> {\n         DirList::read(dir, recursive, filter).flatten()\n     }\n }\n@@ -171,20 +176,20 @@ impl RequireContextMap {\n     #[turbo_tasks::function]\n     pub(crate) async fn generate(\n         origin: Vc<Box<dyn ResolveOrigin>>,\n-        dir: Vc<FileSystemPath>,\n+        dir: FileSystemPath,\n         recursive: bool,\n         filter: Vc<EsRegex>,\n         issue_source: Option<IssueSource>,\n         is_optional: bool,\n     ) -> Result<Vc<Self>> {\n-        let origin_path = &*origin.origin_path().parent().await?;\n+        let origin_path = origin.origin_path().await?.parent();\n \n         let list = &*FlatDirList::read(dir, recursive, filter).await?;\n \n         let mut map = FxIndexMap::default();\n \n         for (context_relative, path) in list {\n-            let Some(origin_relative) = origin_path.get_relative_path_to(&*path.await?) else {\n+            let Some(origin_relative) = origin_path.get_relative_path_to(path) else {\n                 bail!(\"invariant error: this was already checked in `list_dir`\");\n             };\n \n@@ -234,7 +239,7 @@ impl RequireContextAssetReference {\n     ) -> Result<Self> {\n         let map = RequireContextMap::generate(\n             *origin,\n-            origin.origin_path().parent().join(dir.clone()),\n+            origin.origin_path().await?.parent().join(&dir)?,\n             include_subdirs,\n             filter,\n             issue_source.clone(),"
        },
        {
            "sha": "f26e411fc86f8e93eae9a9b126e025736ae9cbad",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/type_issue.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Ftype_issue.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Ftype_issue.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Ftype_issue.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -1,20 +1,20 @@\n-use turbo_tasks::{ResolvedVc, Vc};\n+use turbo_tasks::Vc;\n use turbo_tasks_fs::FileSystemPath;\n use turbopack_core::issue::{Issue, IssueSeverity, IssueStage, OptionStyledString, StyledString};\n \n use crate::SpecifiedModuleType;\n \n #[turbo_tasks::value(shared)]\n pub struct SpecifiedModuleTypeIssue {\n-    pub path: ResolvedVc<FileSystemPath>,\n+    pub path: FileSystemPath,\n     pub specified_type: SpecifiedModuleType,\n }\n \n #[turbo_tasks::value_impl]\n impl Issue for SpecifiedModuleTypeIssue {\n     #[turbo_tasks::function]\n     fn file_path(&self) -> Vc<FileSystemPath> {\n-        *self.path\n+        self.path.clone().cell()\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "84fd1f11da3d45a2b8c18bd7fc345d29ca9c84c3",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/typescript.rs",
            "status": "modified",
            "additions": 13,
            "deletions": 13,
            "changes": 26,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Ftypescript.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Ftypescript.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Ftypescript.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -16,17 +16,14 @@ use crate::typescript::TsConfigModuleAsset;\n #[turbo_tasks::value]\n #[derive(Hash, Clone, Debug)]\n pub struct TsConfigReference {\n-    pub tsconfig: ResolvedVc<FileSystemPath>,\n+    pub tsconfig: FileSystemPath,\n     pub origin: ResolvedVc<Box<dyn ResolveOrigin>>,\n }\n \n #[turbo_tasks::value_impl]\n impl TsConfigReference {\n     #[turbo_tasks::function]\n-    pub fn new(\n-        origin: ResolvedVc<Box<dyn ResolveOrigin>>,\n-        tsconfig: ResolvedVc<FileSystemPath>,\n-    ) -> Vc<Self> {\n+    pub fn new(origin: ResolvedVc<Box<dyn ResolveOrigin>>, tsconfig: FileSystemPath) -> Vc<Self> {\n         Self::cell(TsConfigReference { tsconfig, origin })\n     }\n }\n@@ -36,9 +33,12 @@ impl ModuleReference for TsConfigReference {\n     #[turbo_tasks::function]\n     async fn resolve_reference(&self) -> Result<Vc<ModuleResolveResult>> {\n         Ok(*ModuleResolveResult::module(ResolvedVc::upcast(\n-            TsConfigModuleAsset::new(*self.origin, Vc::upcast(FileSource::new(*self.tsconfig)))\n-                .to_resolved()\n-                .await?,\n+            TsConfigModuleAsset::new(\n+                *self.origin,\n+                Vc::upcast(FileSource::new(self.tsconfig.clone())),\n+            )\n+            .to_resolved()\n+            .await?,\n         )))\n     }\n }\n@@ -48,7 +48,7 @@ impl ValueToString for TsConfigReference {\n     #[turbo_tasks::function]\n     async fn to_string(&self) -> Result<Vc<RcStr>> {\n         Ok(Vc::cell(\n-            format!(\"tsconfig {}\", self.tsconfig.to_string().await?,).into(),\n+            format!(\"tsconfig {}\", self.tsconfig.value_to_string().await?).into(),\n         ))\n     }\n }\n@@ -73,18 +73,18 @@ impl ModuleReference for TsReferencePathAssetReference {\n     #[turbo_tasks::function]\n     async fn resolve_reference(&self) -> Result<Vc<ModuleResolveResult>> {\n         Ok(\n-            if let Some(path) = &*self\n+            if let Some(path) = self\n                 .origin\n                 .origin_path()\n-                .parent()\n-                .try_join(self.path.clone())\n                 .await?\n+                .parent()\n+                .try_join(&self.path)?\n             {\n                 let module = self\n                     .origin\n                     .asset_context()\n                     .process(\n-                        Vc::upcast(FileSource::new(**path)),\n+                        Vc::upcast(FileSource::new(path.clone())),\n                         ReferenceType::TypeScript(TypeScriptReferenceSubType::Undefined),\n                     )\n                     .module()"
        },
        {
            "sha": "a9fa60aa50c840d3ecc02c82e65b4026cf7b03d8",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/util.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Futil.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Futil.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Futil.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -1,7 +1,7 @@\n use anyhow::Result;\n use swc_core::{ecma::ast::Expr, quote};\n use turbo_rcstr::{RcStr, rcstr};\n-use turbo_tasks::{ResolvedVc, Vc};\n+use turbo_tasks::Vc;\n use turbo_tasks_fs::{FileSystemPath, rope::Rope};\n use turbopack_core::{\n     resolve::parse::Request,\n@@ -47,7 +47,7 @@ pub async fn request_to_string(request: Vc<Request>) -> Result<Vc<RcStr>> {\n #[derive(Debug, Clone)]\n pub struct InlineSourceMap {\n     /// The file path of the module containing the sourcemap data URL\n-    pub origin_path: ResolvedVc<FileSystemPath>,\n+    pub origin_path: FileSystemPath,\n     /// The Base64 encoded JSON sourcemap string\n     pub source_map: RcStr,\n }\n@@ -57,7 +57,8 @@ impl GenerateSourceMap for InlineSourceMap {\n     #[turbo_tasks::function]\n     pub async fn generate_source_map(&self) -> Result<Vc<OptionStringifiedSourceMap>> {\n         let source_map = maybe_decode_data_url(&self.source_map);\n-        let source_map = resolve_source_map_sources(source_map.as_ref(), *self.origin_path).await?;\n+        let source_map =\n+            resolve_source_map_sources(source_map.as_ref(), self.origin_path.clone()).await?;\n         Ok(Vc::cell(source_map))\n     }\n }"
        },
        {
            "sha": "6de90962d1b5aff9d8217dc6bd0f7206dd10756f",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/worker.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fworker.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fworker.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fworker.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -74,7 +74,7 @@ impl WorkerAssetReference {\n                 title: StyledString::Text(rcstr!(\"non-ecmascript placeable asset\")).resolved_cell(),\n                 message: StyledString::Text(rcstr!(\"asset is not placeable in ESM chunks\"))\n                     .resolved_cell(),\n-                path: self.origin.origin_path().to_resolved().await?,\n+                path: self.origin.origin_path().await?.clone_value(),\n             }\n             .resolved_cell()\n             .emit();"
        },
        {
            "sha": "4e61262f3c9ba646ce62f9c7e517714a67bffd4a",
            "filename": "turbopack/crates/turbopack-ecmascript/src/side_effect_optimization/locals/module.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Flocals%2Fmodule.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Flocals%2Fmodule.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Flocals%2Fmodule.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -104,7 +104,7 @@ impl EcmascriptAnalyzable for EcmascriptModuleLocalsModule {\n         let analyze = original_module.analyze();\n         let analyze_result = analyze.await?;\n \n-        let module_type_result = *original_module.determine_module_type().await?;\n+        let module_type_result = original_module.determine_module_type().await?;\n         let generate_source_map = *chunking_context\n             .reference_module_source_maps(Vc::upcast(self))\n             .await?;"
        },
        {
            "sha": "414e58db5acfae834ee5c1b6ff24d452755d806b",
            "filename": "turbopack/crates/turbopack-ecmascript/src/static_code.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fstatic_code.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fstatic_code.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fstatic_code.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -27,12 +27,12 @@ impl StaticEcmascriptCode {\n     #[turbo_tasks::function]\n     pub async fn new(\n         asset_context: ResolvedVc<Box<dyn AssetContext>>,\n-        asset_path: ResolvedVc<FileSystemPath>,\n+        asset_path: FileSystemPath,\n         generate_source_map: bool,\n     ) -> Result<Vc<Self>> {\n         let module = asset_context\n             .process(\n-                Vc::upcast(FileSource::new(*asset_path)),\n+                Vc::upcast(FileSource::new(asset_path.clone())),\n                 ReferenceType::Runtime,\n             )\n             .module()"
        },
        {
            "sha": "7f619b7cb0fc6ed5f1da9bb922311aabc5200a25",
            "filename": "turbopack/crates/turbopack-ecmascript/src/transform/mod.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftransform%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftransform%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftransform%2Fmod.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -120,7 +120,7 @@ pub struct TransformContext<'a> {\n     pub file_name_str: &'a str,\n     pub file_name_hash: u128,\n     pub query_str: RcStr,\n-    pub file_path: ResolvedVc<FileSystemPath>,\n+    pub file_path: FileSystemPath,\n }\n \n impl EcmascriptInputTransform {\n@@ -355,7 +355,7 @@ pub fn remove_directives(program: &mut Program) {\n \n #[turbo_tasks::value(shared)]\n pub struct UnsupportedServerActionIssue {\n-    pub file_path: ResolvedVc<FileSystemPath>,\n+    pub file_path: FileSystemPath,\n }\n \n #[turbo_tasks::value_impl]\n@@ -374,7 +374,7 @@ impl Issue for UnsupportedServerActionIssue {\n \n     #[turbo_tasks::function]\n     fn file_path(&self) -> Vc<FileSystemPath> {\n-        *self.file_path\n+        self.file_path.clone().cell()\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "f55262942219242380ff1ef646b588641afa9614",
            "filename": "turbopack/crates/turbopack-ecmascript/src/tree_shake/asset.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fasset.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fasset.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fasset.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -92,7 +92,7 @@ impl EcmascriptAnalyzable for EcmascriptModulePartAsset {\n         let analyze = self.analyze();\n         let analyze_ref = analyze.await?;\n \n-        let module_type_result = *module.full_module.determine_module_type().await?;\n+        let module_type_result = module.full_module.determine_module_type().await?;\n         let generate_source_map = *chunking_context\n             .reference_module_source_maps(Vc::upcast(self))\n             .await?;"
        },
        {
            "sha": "4388fad979863b84f36155119e7c2af32fa9f494",
            "filename": "turbopack/crates/turbopack-ecmascript/src/typescript/mod.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 7,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftypescript%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftypescript%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftypescript%2Fmod.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -56,7 +56,8 @@ impl Module for TsConfigModuleAsset {\n             self.source,\n             apply_cjs_specific_options(\n                 self.origin\n-                    .resolve_options(ReferenceType::CommonJs(CommonJsReferenceSubType::Undefined)),\n+                    .resolve_options(ReferenceType::CommonJs(CommonJsReferenceSubType::Undefined))\n+                    .await?,\n             ),\n         )\n         .await?;\n@@ -133,12 +134,10 @@ impl Module for TsConfigModuleAsset {\n                 types\n             } else {\n                 let mut all_types = Vec::new();\n-                let mut current = self.source.ident().path().parent().resolve().await?;\n+                let mut current = self.source.ident().path().await?.parent();\n                 loop {\n-                    if let DirectoryContent::Entries(entries) = &*current\n-                        .join(rcstr!(\"node_modules/@types\"))\n-                        .read_dir()\n-                        .await?\n+                    if let DirectoryContent::Entries(entries) =\n+                        &*current.join(\"node_modules/@types\")?.read_dir().await?\n                     {\n                         all_types.extend(entries.iter().filter_map(|(name, _)| {\n                             if name.starts_with('.') {\n@@ -148,7 +147,7 @@ impl Module for TsConfigModuleAsset {\n                             }\n                         }));\n                     }\n-                    let parent = current.parent().resolve().await?;\n+                    let parent = current.parent();\n                     if parent == current {\n                         break;\n                     }"
        },
        {
            "sha": "201de6bc63359c9cd5e1bb4b5759a7e5295eb1a7",
            "filename": "turbopack/crates/turbopack-ecmascript/src/webpack/mod.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fwebpack%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fwebpack%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fwebpack%2Fmod.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -93,8 +93,8 @@ impl ModuleReference for WebpackChunkAssetReference {\n                     Lit::Num(num) => format!(\"{num}\"),\n                     _ => todo!(),\n                 };\n-                let filename = format!(\"./chunks/{chunk_id}.js\").into();\n-                let source = Vc::upcast(FileSource::new(context_path.join(filename)));\n+                let filename = format!(\"./chunks/{chunk_id}.js\");\n+                let source = Vc::upcast(FileSource::new(context_path.join(&filename)?));\n \n                 *ModuleResolveResult::module(ResolvedVc::upcast(\n                     WebpackModuleAsset::new(source, *self.runtime, *self.transforms)\n@@ -160,12 +160,12 @@ impl ModuleReference for WebpackRuntimeAssetReference {\n     #[turbo_tasks::function]\n     async fn resolve_reference(&self) -> Result<Vc<ModuleResolveResult>> {\n         let ty = ReferenceType::CommonJs(CommonJsReferenceSubType::Undefined);\n-        let options = self.origin.resolve_options(ty.clone());\n+        let options = self.origin.resolve_options(ty.clone()).await?;\n \n         let options = apply_cjs_specific_options(options);\n \n         let resolved = resolve(\n-            self.origin.origin_path().parent().resolve().await?,\n+            self.origin.origin_path().await?.parent(),\n             ReferenceType::CommonJs(CommonJsReferenceSubType::Undefined),\n             *self.request,\n             options,"
        },
        {
            "sha": "cfe84cb1a50f4ad67f381002559d1fc63d5748a4",
            "filename": "turbopack/crates/turbopack-ecmascript/src/webpack/parse.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fwebpack%2Fparse.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fwebpack%2Fparse.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fwebpack%2Fparse.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -12,7 +12,7 @@ use swc_core::{\n         visit::{Visit, VisitWith},\n     },\n };\n-use turbo_tasks::{ResolvedVc, Vc};\n+use turbo_tasks::Vc;\n use turbo_tasks_fs::FileSystemPath;\n use turbopack_core::source::Source;\n \n@@ -31,7 +31,7 @@ pub enum WebpackRuntime {\n         /// before converting to string\n         #[turbo_tasks(trace_ignore)]\n         chunk_request_expr: JsValue,\n-        context_path: ResolvedVc<FileSystemPath>,\n+        context_path: FileSystemPath,\n     },\n     None,\n }\n@@ -216,7 +216,7 @@ pub async fn webpack_runtime(\n \n                     return Ok(WebpackRuntime::Webpack5 {\n                         chunk_request_expr: value,\n-                        context_path: source.ident().path().parent().to_resolved().await?,\n+                        context_path: source.ident().path().await?.parent(),\n                     }\n                     .into());\n                 }"
        },
        {
            "sha": "fb027217d72b3492b5e5fe3ee39c675bee5bbd29",
            "filename": "turbopack/crates/turbopack-ecmascript/src/worker_chunk/chunk_item.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fworker_chunk%2Fchunk_item.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fworker_chunk%2Fchunk_item.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fworker_chunk%2Fchunk_item.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -48,7 +48,7 @@ impl WorkerLoaderChunkItem {\n     async fn chunks_data(self: Vc<Self>) -> Result<Vc<ChunksData>> {\n         let this = self.await?;\n         Ok(ChunkData::from_assets(\n-            this.chunking_context.output_root(),\n+            this.chunking_context.output_root().await?.clone_value(),\n             self.chunks(),\n         ))\n     }"
        },
        {
            "sha": "99dc791b0bd385ded93d3032efe62fb29de240c7",
            "filename": "turbopack/crates/turbopack-env/src/asset.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 8,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-env%2Fsrc%2Fasset.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-env%2Fsrc%2Fasset.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-env%2Fsrc%2Fasset.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -1,7 +1,6 @@\n use std::io::Write;\n \n use anyhow::Result;\n-use turbo_rcstr::rcstr;\n use turbo_tasks::{ResolvedVc, Vc};\n use turbo_tasks_env::ProcessEnv;\n use turbo_tasks_fs::{File, FileSystemPath, rope::RopeBuilder};\n@@ -17,7 +16,7 @@ use turbopack_ecmascript::utils::StringifyJs;\n #[turbo_tasks::value]\n pub struct ProcessEnvAsset {\n     /// The root path which we can construct our env asset path.\n-    root: ResolvedVc<FileSystemPath>,\n+    root: FileSystemPath,\n \n     /// A HashMap filled with the env key/values.\n     env: ResolvedVc<Box<dyn ProcessEnv>>,\n@@ -26,19 +25,16 @@ pub struct ProcessEnvAsset {\n #[turbo_tasks::value_impl]\n impl ProcessEnvAsset {\n     #[turbo_tasks::function]\n-    pub fn new(\n-        root: ResolvedVc<FileSystemPath>,\n-        env: ResolvedVc<Box<dyn ProcessEnv>>,\n-    ) -> Result<Vc<Self>> {\n+    pub fn new(root: FileSystemPath, env: ResolvedVc<Box<dyn ProcessEnv>>) -> Result<Vc<Self>> {\n         Ok(ProcessEnvAsset { root, env }.cell())\n     }\n }\n \n #[turbo_tasks::value_impl]\n impl Source for ProcessEnvAsset {\n     #[turbo_tasks::function]\n-    fn ident(&self) -> Vc<AssetIdent> {\n-        AssetIdent::from_path(self.root.join(rcstr!(\".env.js\")))\n+    fn ident(&self) -> Result<Vc<AssetIdent>> {\n+        Ok(AssetIdent::from_path(self.root.join(\".env.js\")?))\n     }\n }\n "
        },
        {
            "sha": "ee7cca988eb0a6afefd84d5384ee1c73a47e9049",
            "filename": "turbopack/crates/turbopack-env/src/dotenv.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-env%2Fsrc%2Fdotenv.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-env%2Fsrc%2Fdotenv.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-env%2Fsrc%2Fdotenv.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -9,7 +9,7 @@ use crate::TryDotenvProcessEnv;\n /// Loads a series of dotenv files according to the precedence rules set by\n /// https://nextjs.org/docs/app/building-your-application/configuring/environment-variables#environment-variable-load-order\n #[turbo_tasks::function]\n-pub async fn load_env(project_path: Vc<FileSystemPath>) -> Result<Vc<Box<dyn ProcessEnv>>> {\n+pub async fn load_env(project_path: FileSystemPath) -> Result<Vc<Box<dyn ProcessEnv>>> {\n     let env: Vc<Box<dyn ProcessEnv>> = Vc::upcast(CommandLineProcessEnv::new());\n \n     let node_env = env.read(rcstr!(\"NODE_ENV\")).await?;\n@@ -22,7 +22,7 @@ pub async fn load_env(project_path: Vc<FileSystemPath>) -> Result<Vc<Box<dyn Pro\n         }),\n     ));\n \n-    let files = [\n+    let mut files = [\n         Some(format!(\".env.{node_env}.local\")),\n         if node_env == \"test\" {\n             None\n@@ -35,10 +35,10 @@ pub async fn load_env(project_path: Vc<FileSystemPath>) -> Result<Vc<Box<dyn Pro\n     .into_iter()\n     .flatten();\n \n-    let env = files.fold(env, |prior, f| {\n-        let path = project_path.join(f.into());\n-        Vc::upcast(TryDotenvProcessEnv::new(prior, path))\n-    });\n+    let env = files.try_fold(env, |prior, f| {\n+        let path = project_path.join(&f)?;\n+        anyhow::Ok(Vc::upcast(TryDotenvProcessEnv::new(prior, path)))\n+    })?;\n \n     Ok(env)\n }"
        },
        {
            "sha": "f895c713a31687c0bcb8adbdadf2426bcb88da9a",
            "filename": "turbopack/crates/turbopack-env/src/issue.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-env%2Fsrc%2Fissue.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-env%2Fsrc%2Fissue.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-env%2Fsrc%2Fissue.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -6,7 +6,7 @@ use turbopack_core::issue::{Issue, IssueStage, OptionStyledString, StyledString}\n /// An issue that occurred while resolving the parsing or evaluating the .env.\n #[turbo_tasks::value(shared)]\n pub struct ProcessEnvIssue {\n-    pub path: ResolvedVc<FileSystemPath>,\n+    pub path: FileSystemPath,\n     pub description: ResolvedVc<StyledString>,\n }\n \n@@ -24,7 +24,7 @@ impl Issue for ProcessEnvIssue {\n \n     #[turbo_tasks::function]\n     fn file_path(&self) -> Vc<FileSystemPath> {\n-        *self.path\n+        self.path.clone().cell()\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "22fe220030d7366367589c54e279f7cebe640f41",
            "filename": "turbopack/crates/turbopack-env/src/try_env.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-env%2Fsrc%2Ftry_env.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-env%2Fsrc%2Ftry_env.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-env%2Fsrc%2Ftry_env.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -10,17 +10,17 @@ use crate::ProcessEnvIssue;\n pub struct TryDotenvProcessEnv {\n     dotenv: ResolvedVc<DotenvProcessEnv>,\n     prior: ResolvedVc<Box<dyn ProcessEnv>>,\n-    path: ResolvedVc<FileSystemPath>,\n+    path: FileSystemPath,\n }\n \n #[turbo_tasks::value_impl]\n impl TryDotenvProcessEnv {\n     #[turbo_tasks::function]\n     pub async fn new(\n         prior: ResolvedVc<Box<dyn ProcessEnv>>,\n-        path: ResolvedVc<FileSystemPath>,\n+        path: FileSystemPath,\n     ) -> Result<Vc<Self>> {\n-        let dotenv = DotenvProcessEnv::new(Some(*prior), *path)\n+        let dotenv = DotenvProcessEnv::new(Some(*prior), path.clone())\n             .to_resolved()\n             .await?;\n         Ok(TryDotenvProcessEnv {\n@@ -51,7 +51,7 @@ impl ProcessEnv for TryDotenvProcessEnv {\n                 // If parsing the dotenv file fails (but getting the prior value didn't), then\n                 // we want to emit an Issue and fall back to the prior's read.\n                 ProcessEnvIssue {\n-                    path: self.path,\n+                    path: self.path.clone(),\n                     // read_all_with_prior will wrap a current error with a context containing the\n                     // failing file, which we don't really care about (we report the filepath as the\n                     // Issue context, not the description). So extract the real error."
        },
        {
            "sha": "3e31d35f660a8830b63e1cb1c0c9eb317b69925a",
            "filename": "turbopack/crates/turbopack-image/src/process/mod.rs",
            "status": "modified",
            "additions": 14,
            "deletions": 14,
            "changes": 28,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-image%2Fsrc%2Fprocess%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-image%2Fsrc%2Fprocess%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-image%2Fsrc%2Fprocess%2Fmod.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -102,7 +102,7 @@ fn extension_to_image_format(extension: &str) -> Option<ImageFormat> {\n     })\n }\n \n-fn result_to_issue<T>(path: ResolvedVc<FileSystemPath>, result: Result<T>) -> Option<T> {\n+fn result_to_issue<T>(path: FileSystemPath, result: Result<T>) -> Option<T> {\n     match result {\n         Ok(r) => Some(r),\n         Err(err) => {\n@@ -121,11 +121,11 @@ fn result_to_issue<T>(path: ResolvedVc<FileSystemPath>, result: Result<T>) -> Op\n }\n \n fn load_image(\n-    path: ResolvedVc<FileSystemPath>,\n+    path: FileSystemPath,\n     bytes: &[u8],\n     extension: Option<&str>,\n ) -> Option<(ImageBuffer, Option<ImageFormat>)> {\n-    result_to_issue(path, load_image_internal(path, bytes, extension))\n+    result_to_issue(path.clone(), load_image_internal(path, bytes, extension))\n }\n \n /// Type of raw image buffer read by reader from `load_image`.\n@@ -136,7 +136,7 @@ enum ImageBuffer {\n }\n \n fn load_image_internal(\n-    path: ResolvedVc<FileSystemPath>,\n+    path: FileSystemPath,\n     bytes: &[u8],\n     extension: Option<&str>,\n ) -> Result<(ImageBuffer, Option<ImageFormat>)> {\n@@ -202,7 +202,7 @@ fn load_image_internal(\n }\n \n fn compute_blur_data(\n-    path: ResolvedVc<FileSystemPath>,\n+    path: FileSystemPath,\n     image: image::DynamicImage,\n     format: ImageFormat,\n     options: &BlurPlaceholderOptions,\n@@ -348,19 +348,19 @@ pub async fn get_meta_data(\n         bail!(\"Input image not found\");\n     };\n     let bytes = content.content().to_bytes();\n-    let path_resolved = ident.path().to_resolved().await?;\n-    let path = path_resolved.await?;\n+    let path_resolved = ident.path().await?.clone_value();\n+    let path = path_resolved.clone();\n     let extension = path.extension_ref();\n     if extension == Some(\"svg\") {\n         let content = result_to_issue(\n-            path_resolved,\n+            path_resolved.clone(),\n             std::str::from_utf8(&bytes).context(\"Input image is not valid utf-8\"),\n         );\n         let Some(content) = content else {\n             return Ok(ImageMetaData::fallback_value(Some(mime::IMAGE_SVG)).cell());\n         };\n         let info = result_to_issue(\n-            path_resolved,\n+            path_resolved.clone(),\n             calculate(content).context(\"Failed to parse svg source code for image dimensions\"),\n         );\n         let Some((width, height)) = info else {\n@@ -374,7 +374,7 @@ pub async fn get_meta_data(\n         }\n         .cell());\n     }\n-    let Some((image, format)) = load_image(path_resolved, &bytes, extension) else {\n+    let Some((image, format)) = load_image(path_resolved.clone(), &bytes, extension) else {\n         return Ok(ImageMetaData::fallback_value(None).cell());\n     };\n \n@@ -392,7 +392,7 @@ pub async fn get_meta_data(\n                         | Some(ImageFormat::Avif)\n                 ) {\n                     compute_blur_data(\n-                        path_resolved,\n+                        path_resolved.clone(),\n                         image,\n                         format.unwrap(),\n                         &*blur_placeholder.await?,\n@@ -431,7 +431,7 @@ pub async fn optimize(\n         return Ok(FileContent::NotFound.cell());\n     };\n     let bytes = content.content().to_bytes();\n-    let path = ident.path().to_resolved().await?;\n+    let path = ident.path().await?.clone_value();\n \n     let Some((image, format)) = load_image(path, &bytes, ident.path().await?.extension_ref())\n     else {\n@@ -486,7 +486,7 @@ pub async fn optimize(\n \n #[turbo_tasks::value]\n struct ImageProcessingIssue {\n-    path: ResolvedVc<FileSystemPath>,\n+    path: FileSystemPath,\n     message: ResolvedVc<StyledString>,\n     title: Option<ResolvedVc<StyledString>>,\n     issue_severity: Option<IssueSeverity>,\n@@ -500,7 +500,7 @@ impl Issue for ImageProcessingIssue {\n \n     #[turbo_tasks::function]\n     fn file_path(&self) -> Vc<FileSystemPath> {\n-        *self.path\n+        self.path.clone().cell()\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "0fbc7b8549ed056ea7c0d0b9d3c257c50abafdcc",
            "filename": "turbopack/crates/turbopack-mdx/src/lib.rs",
            "status": "modified",
            "additions": 7,
            "deletions": 4,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-mdx%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-mdx%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-mdx%2Fsrc%2Flib.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -120,7 +120,10 @@ impl Asset for MdxTransformedAsset {\n     async fn content(self: ResolvedVc<Self>) -> Result<Vc<AssetContent>> {\n         let this = self.await?;\n         Ok(*transform_process_operation(self)\n-            .issue_file_path(this.source.ident().path(), \"MDX processing\")\n+            .issue_file_path(\n+                this.source.ident().path().await?.clone_value(),\n+                \"MDX processing\",\n+            )\n             .await?\n             .connect()\n             .await?\n@@ -220,7 +223,7 @@ impl MdxTransformedAsset {\n                 };\n \n                 MdxIssue {\n-                    path: self.source.ident().path().to_resolved().await?,\n+                    path: self.source.ident().path().await?.clone_value(),\n                     loc,\n                     reason: err.reason,\n                     mdx_rule_id: *err.rule_id,\n@@ -247,7 +250,7 @@ struct MdxTransformResult {\n #[turbo_tasks::value]\n struct MdxIssue {\n     /// Place of message.\n-    path: ResolvedVc<FileSystemPath>,\n+    path: FileSystemPath,\n     loc: Option<IssueSource>,\n     /// Reason for message (should use markdown).\n     reason: String,\n@@ -261,7 +264,7 @@ struct MdxIssue {\n impl Issue for MdxIssue {\n     #[turbo_tasks::function]\n     fn file_path(&self) -> Vc<FileSystemPath> {\n-        *self.path\n+        self.path.clone().cell()\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "5dea178e28f7044deaa903ea413ee78b6cab8bb4",
            "filename": "turbopack/crates/turbopack-node/src/embed_js.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 4,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fembed_js.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fembed_js.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fembed_js.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -1,3 +1,4 @@\n+use anyhow::Result;\n use turbo_rcstr::RcStr;\n use turbo_tasks::Vc;\n use turbo_tasks_fs::{FileContent, FileSystem, FileSystemPath, embed_directory};\n@@ -8,11 +9,11 @@ pub fn embed_fs() -> Vc<Box<dyn FileSystem>> {\n }\n \n #[turbo_tasks::function]\n-pub(crate) fn embed_file(path: RcStr) -> Vc<FileContent> {\n-    embed_fs().root().join(path).read()\n+pub(crate) async fn embed_file(path: RcStr) -> Result<Vc<FileContent>> {\n+    Ok(embed_fs().root().await?.join(&path)?.read())\n }\n \n #[turbo_tasks::function]\n-pub(crate) fn embed_file_path(path: RcStr) -> Vc<FileSystemPath> {\n-    embed_fs().root().join(path)\n+pub(crate) async fn embed_file_path(path: RcStr) -> Result<Vc<FileSystemPath>> {\n+    Ok(embed_fs().root().await?.join(&path)?.cell())\n }"
        },
        {
            "sha": "51d115d0e1ad84cbeac95d081191db19dcb897ba",
            "filename": "turbopack/crates/turbopack-node/src/evaluate.rs",
            "status": "modified",
            "additions": 42,
            "deletions": 33,
            "changes": 75,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fevaluate.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fevaluate.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fevaluate.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -84,8 +84,8 @@ pub struct JavaScriptEvaluation(#[turbo_tasks(trace_ignore)] JavaScriptStream);\n #[turbo_tasks::value]\n struct EmittedEvaluatePoolAssets {\n     bootstrap: ResolvedVc<Box<dyn OutputAsset>>,\n-    output_root: ResolvedVc<FileSystemPath>,\n-    entrypoint: ResolvedVc<FileSystemPath>,\n+    output_root: FileSystemPath,\n+    entrypoint: FileSystemPath,\n }\n \n #[turbo_tasks::function(operation)]\n@@ -97,7 +97,11 @@ async fn emit_evaluate_pool_assets_operation(\n ) -> Result<Vc<EmittedEvaluatePoolAssets>> {\n     let runtime_asset = asset_context\n         .process(\n-            Vc::upcast(FileSource::new(embed_file_path(rcstr!(\"ipc/evaluate.ts\")))),\n+            Vc::upcast(FileSource::new(\n+                embed_file_path(rcstr!(\"ipc/evaluate.ts\"))\n+                    .await?\n+                    .clone_value(),\n+            )),\n             ReferenceType::Internal(InnerAssets::empty().to_resolved().await?),\n         )\n         .module()\n@@ -113,11 +117,11 @@ async fn emit_evaluate_pool_assets_operation(\n     } else {\n         Cow::Owned(format!(\"{file_name}.js\"))\n     };\n-    let entrypoint = chunking_context.output_root().join(file_name.into());\n+    let entrypoint = chunking_context.output_root().await?.join(&file_name)?;\n     let entry_module = asset_context\n         .process(\n             Vc::upcast(VirtualSource::new(\n-                runtime_asset.ident().path().join(rcstr!(\"evaluate.js\")),\n+                runtime_asset.ident().path().await?.join(\"evaluate.js\")?,\n                 AssetContent::file(\n                     File::from(\"import { run } from 'RUNTIME'; run(() => import('INNER'))\").into(),\n                 ),\n@@ -134,7 +138,9 @@ async fn emit_evaluate_pool_assets_operation(\n     let runtime_entries = {\n         let globals_module = asset_context\n             .process(\n-                Vc::upcast(FileSource::new(embed_file_path(rcstr!(\"globals.ts\")))),\n+                Vc::upcast(FileSource::new(\n+                    embed_file_path(rcstr!(\"globals.ts\")).await?.clone_value(),\n+                )),\n                 ReferenceType::Internal(InnerAssets::empty().to_resolved().await?),\n             )\n             .module();\n@@ -164,21 +170,21 @@ async fn emit_evaluate_pool_assets_operation(\n     );\n \n     let bootstrap = chunking_context.root_entry_chunk_group_asset(\n-        entrypoint,\n+        entrypoint.clone(),\n         Vc::<EvaluatableAssets>::cell(runtime_entries)\n             .with_entry(*ResolvedVc::try_downcast(entry_module).unwrap()),\n         module_graph,\n         OutputAssets::empty(),\n     );\n \n-    let output_root = chunking_context.output_root().to_resolved().await?;\n-    let _ = emit_package_json(*output_root).resolve().await?;\n-    let _ = emit(bootstrap, *output_root).resolve().await?;\n+    let output_root = chunking_context.output_root().await?.clone_value();\n+    let _ = emit_package_json(output_root.clone())?.resolve().await?;\n+    let _ = emit(bootstrap, output_root.clone()).resolve().await?;\n \n     Ok(EmittedEvaluatePoolAssets {\n         bootstrap: bootstrap.to_resolved().await?,\n         output_root,\n-        entrypoint: entrypoint.to_resolved().await?,\n+        entrypoint: entrypoint.clone(),\n     }\n     .cell())\n }\n@@ -224,7 +230,7 @@ pub enum EnvVarTracking {\n /// evaluated result automatically.\n pub async fn get_evaluate_pool(\n     module_asset: ResolvedVc<Box<dyn Module>>,\n-    cwd: ResolvedVc<FileSystemPath>,\n+    cwd: FileSystemPath,\n     env: ResolvedVc<Box<dyn ProcessEnv>>,\n     asset_context: ResolvedVc<Box<dyn AssetContext>>,\n     chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n@@ -237,7 +243,7 @@ pub async fn get_evaluate_pool(\n         bootstrap,\n         output_root,\n         entrypoint,\n-    } = *emit_evaluate_pool_assets_with_effects_operation(\n+    } = &*emit_evaluate_pool_assets_with_effects_operation(\n         module_asset,\n         asset_context,\n         chunking_context,\n@@ -246,16 +252,19 @@ pub async fn get_evaluate_pool(\n     .read_strongly_consistent()\n     .await?;\n \n-    let (Some(cwd), Some(entrypoint)) = (to_sys_path(*cwd).await?, to_sys_path(*entrypoint).await?)\n-    else {\n+    let (Some(cwd), Some(entrypoint)) = (\n+        to_sys_path(cwd.clone()).await?,\n+        to_sys_path(entrypoint.clone()).await?,\n+    ) else {\n         panic!(\"can only evaluate from a disk filesystem\");\n     };\n \n     // Invalidate pool when code content changes\n-    content_changed(Vc::upcast(*bootstrap)).await?;\n-    let assets_for_source_mapping = internal_assets_for_source_mapping(*bootstrap, *output_root)\n-        .to_resolved()\n-        .await?;\n+    content_changed(Vc::upcast(**bootstrap)).await?;\n+    let assets_for_source_mapping =\n+        internal_assets_for_source_mapping(**bootstrap, output_root.clone())\n+            .to_resolved()\n+            .await?;\n     let env = match env_var_tracking {\n         EnvVarTracking::WholeEnvTracked => env.read_all().await?,\n         EnvVarTracking::Untracked => {\n@@ -273,8 +282,8 @@ pub async fn get_evaluate_pool(\n         entrypoint,\n         env.iter().map(|(k, v)| (k.clone(), v.clone())).collect(),\n         assets_for_source_mapping,\n-        output_root,\n-        chunking_context.root_path().to_resolved().await?,\n+        output_root.clone(),\n+        chunking_context.root_path().await?.clone_value(),\n         available_parallelism().map_or(1, |v| v.get()),\n         debug,\n     );\n@@ -400,7 +409,7 @@ pub fn custom_evaluate(evaluate_context: impl EvaluateContext) -> Vc<JavaScriptE\n #[turbo_tasks::function]\n pub fn evaluate(\n     module_asset: ResolvedVc<Box<dyn Module>>,\n-    cwd: ResolvedVc<FileSystemPath>,\n+    cwd: FileSystemPath,\n     env: ResolvedVc<Box<dyn ProcessEnv>>,\n     context_ident_for_issue: ResolvedVc<AssetIdent>,\n     asset_context: ResolvedVc<Box<dyn AssetContext>>,\n@@ -581,7 +590,7 @@ async fn basic_compute(\n #[derive(Clone, PartialEq, Eq, Hash, TaskInput, Debug, Serialize, Deserialize, TraceRawVcs)]\n struct BasicEvaluateContext {\n     module_asset: ResolvedVc<Box<dyn Module>>,\n-    cwd: ResolvedVc<FileSystemPath>,\n+    cwd: FileSystemPath,\n     env: ResolvedVc<Box<dyn ProcessEnv>>,\n     context_ident_for_issue: ResolvedVc<AssetIdent>,\n     asset_context: ResolvedVc<Box<dyn AssetContext>>,\n@@ -606,7 +615,7 @@ impl EvaluateContext for BasicEvaluateContext {\n     fn pool(&self) -> OperationVc<crate::pool::NodeJsPool> {\n         get_evaluate_pool(\n             self.module_asset,\n-            self.cwd,\n+            self.cwd.clone(),\n             self.env,\n             self.asset_context,\n             self.chunking_context,\n@@ -622,7 +631,7 @@ impl EvaluateContext for BasicEvaluateContext {\n     }\n \n     fn cwd(&self) -> Vc<turbo_tasks_fs::FileSystemPath> {\n-        *self.cwd\n+        self.cwd.clone().cell()\n     }\n \n     fn keep_alive(&self) -> bool {\n@@ -634,8 +643,8 @@ impl EvaluateContext for BasicEvaluateContext {\n             error,\n             context_ident: self.context_ident_for_issue,\n             assets_for_source_mapping: pool.assets_for_source_mapping,\n-            assets_root: pool.assets_root,\n-            root_path: self.chunking_context.root_path().to_resolved().await?,\n+            assets_root: pool.assets_root.clone(),\n+            root_path: self.chunking_context.root_path().await?.clone_value(),\n         }\n         .resolved_cell()\n         .emit();\n@@ -681,8 +690,8 @@ async fn print_error(\n     error\n         .print(\n             *pool.assets_for_source_mapping,\n-            *pool.assets_root,\n-            evaluate_context.cwd(),\n+            pool.assets_root.clone(),\n+            evaluate_context.cwd().await?.clone_value(),\n             FormattingMode::Plain,\n         )\n         .await\n@@ -693,8 +702,8 @@ pub struct EvaluationIssue {\n     pub context_ident: ResolvedVc<AssetIdent>,\n     pub error: StructuredError,\n     pub assets_for_source_mapping: ResolvedVc<AssetsForSourceMapping>,\n-    pub assets_root: ResolvedVc<FileSystemPath>,\n-    pub root_path: ResolvedVc<FileSystemPath>,\n+    pub assets_root: FileSystemPath,\n+    pub root_path: FileSystemPath,\n }\n \n #[turbo_tasks::value_impl]\n@@ -721,8 +730,8 @@ impl Issue for EvaluationIssue {\n                 self.error\n                     .print(\n                         *self.assets_for_source_mapping,\n-                        *self.assets_root,\n-                        *self.root_path,\n+                        self.assets_root.clone(),\n+                        self.root_path.clone(),\n                         FormattingMode::Plain,\n                     )\n                     .await?"
        },
        {
            "sha": "b6fe5a2a737f666ea3c924701fe8a0e344c4ee57",
            "filename": "turbopack/crates/turbopack-node/src/execution_context.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fexecution_context.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fexecution_context.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fexecution_context.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -5,7 +5,7 @@ use turbopack_core::chunk::ChunkingContext;\n \n #[turbo_tasks::value]\n pub struct ExecutionContext {\n-    pub project_path: ResolvedVc<FileSystemPath>,\n+    pub project_path: FileSystemPath,\n     pub chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n     pub env: ResolvedVc<Box<dyn ProcessEnv>>,\n }\n@@ -14,7 +14,7 @@ pub struct ExecutionContext {\n impl ExecutionContext {\n     #[turbo_tasks::function]\n     pub fn new(\n-        project_path: ResolvedVc<FileSystemPath>,\n+        project_path: FileSystemPath,\n         chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n         env: ResolvedVc<Box<dyn ProcessEnv>>,\n     ) -> Vc<Self> {\n@@ -28,7 +28,7 @@ impl ExecutionContext {\n \n     #[turbo_tasks::function]\n     pub fn project_path(&self) -> Vc<FileSystemPath> {\n-        *self.project_path\n+        self.project_path.clone().cell()\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "cc651c31233ca01668b88aeca2940bf237142094",
            "filename": "turbopack/crates/turbopack-node/src/lib.rs",
            "status": "modified",
            "additions": 78,
            "deletions": 63,
            "changes": 141,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Flib.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -9,7 +9,7 @@ pub use node_entry::{NodeEntry, NodeRenderingEntries, NodeRenderingEntry};\n use rustc_hash::FxHashMap;\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{\n-    FxIndexSet, ResolvedVc, TryJoinIterExt, ValueToString, Vc,\n+    FxIndexSet, ResolvedVc, TryJoinIterExt, Vc,\n     graph::{AdjacencyMap, GraphTraversal},\n };\n use turbo_tasks_env::ProcessEnv;\n@@ -41,10 +41,14 @@ pub mod transforms;\n #[turbo_tasks::function]\n async fn emit(\n     intermediate_asset: Vc<Box<dyn OutputAsset>>,\n-    intermediate_output_path: Vc<FileSystemPath>,\n+    intermediate_output_path: FileSystemPath,\n ) -> Result<()> {\n     for asset in internal_assets(intermediate_asset, intermediate_output_path).await? {\n-        let _ = asset.content().write(asset.path()).resolve().await?;\n+        let _ = asset\n+            .content()\n+            .write(asset.path().await?.clone_value())\n+            .resolve()\n+            .await?;\n     }\n     Ok(())\n }\n@@ -64,7 +68,7 @@ struct SeparatedAssets {\n #[turbo_tasks::function]\n async fn internal_assets(\n     intermediate_asset: ResolvedVc<Box<dyn OutputAsset>>,\n-    intermediate_output_path: ResolvedVc<FileSystemPath>,\n+    intermediate_output_path: FileSystemPath,\n ) -> Result<Vc<OutputAssetsSet>> {\n     Ok(\n         *separate_assets_operation(intermediate_asset, intermediate_output_path)\n@@ -82,10 +86,11 @@ pub struct AssetsForSourceMapping(FxHashMap<String, ResolvedVc<Box<dyn GenerateS\n #[turbo_tasks::function]\n async fn internal_assets_for_source_mapping(\n     intermediate_asset: Vc<Box<dyn OutputAsset>>,\n-    intermediate_output_path: Vc<FileSystemPath>,\n+    intermediate_output_path: FileSystemPath,\n ) -> Result<Vc<AssetsForSourceMapping>> {\n-    let internal_assets = internal_assets(intermediate_asset, intermediate_output_path).await?;\n-    let intermediate_output_path = &*intermediate_output_path.await?;\n+    let internal_assets =\n+        internal_assets(intermediate_asset, intermediate_output_path.clone()).await?;\n+    let intermediate_output_path = intermediate_output_path.clone();\n     let mut internal_assets_for_source_mapping = FxHashMap::default();\n     for asset in internal_assets.iter() {\n         if let Some(generate_source_map) =\n@@ -105,7 +110,7 @@ pub async fn external_asset_entrypoints(\n     module: Vc<Box<dyn EvaluatableAsset>>,\n     runtime_entries: Vc<EvaluatableAssets>,\n     chunking_context: Vc<Box<dyn ChunkingContext>>,\n-    intermediate_output_path: ResolvedVc<FileSystemPath>,\n+    intermediate_output_path: FileSystemPath,\n ) -> Result<Vc<OutputAssetsSet>> {\n     Ok(*separate_assets_operation(\n         get_intermediate_asset(chunking_context, module, runtime_entries)\n@@ -123,35 +128,38 @@ pub async fn external_asset_entrypoints(\n #[turbo_tasks::function(operation)]\n async fn separate_assets_operation(\n     intermediate_asset: ResolvedVc<Box<dyn OutputAsset>>,\n-    intermediate_output_path: ResolvedVc<FileSystemPath>,\n+    intermediate_output_path: FileSystemPath,\n ) -> Result<Vc<SeparatedAssets>> {\n-    let intermediate_output_path = &*intermediate_output_path.await?;\n+    let intermediate_output_path = intermediate_output_path.clone();\n     #[derive(PartialEq, Eq, Hash, Clone, Copy)]\n     enum Type {\n         Internal(ResolvedVc<Box<dyn OutputAsset>>),\n         External(ResolvedVc<Box<dyn OutputAsset>>),\n     }\n-    let get_asset_children = |asset| async move {\n-        let Type::Internal(asset) = asset else {\n-            return Ok(Vec::new());\n-        };\n-        asset\n-            .references()\n-            .await?\n-            .iter()\n-            .map(|asset| async {\n-                // Assets within the output directory are considered as \"internal\" and all\n-                // others as \"external\". We follow references on \"internal\" assets, but do not\n-                // look into references of \"external\" assets, since there are no \"internal\"\n-                // assets behind \"externals\"\n-                if asset.path().await?.is_inside_ref(intermediate_output_path) {\n-                    Ok(Type::Internal(*asset))\n-                } else {\n-                    Ok(Type::External(*asset))\n-                }\n-            })\n-            .try_join()\n-            .await\n+    let get_asset_children = |asset| {\n+        let intermediate_output_path = intermediate_output_path.clone();\n+        async move {\n+            let Type::Internal(asset) = asset else {\n+                return Ok(Vec::new());\n+            };\n+            asset\n+                .references()\n+                .await?\n+                .iter()\n+                .map(|asset| async {\n+                    // Assets within the output directory are considered as \"internal\" and all\n+                    // others as \"external\". We follow references on \"internal\" assets, but do not\n+                    // look into references of \"external\" assets, since there are no \"internal\"\n+                    // assets behind \"externals\"\n+                    if asset.path().await?.is_inside_ref(&intermediate_output_path) {\n+                        Ok(Type::Internal(*asset))\n+                    } else {\n+                        Ok(Type::External(*asset))\n+                    }\n+                })\n+                .try_join()\n+                .await\n+        }\n     };\n \n     let graph = AdjacencyMap::new()\n@@ -185,45 +193,47 @@ async fn separate_assets_operation(\n /// Emit a basic package.json that sets the type of the package to commonjs.\n /// Currently code generated for Node is CommonJS, while authored code may be\n /// ESM, for example.\n-fn emit_package_json(dir: Vc<FileSystemPath>) -> Vc<()> {\n-    emit(\n+fn emit_package_json(dir: FileSystemPath) -> Result<Vc<()>> {\n+    Ok(emit(\n         Vc::upcast(VirtualOutputAsset::new(\n-            dir.join(rcstr!(\"package.json\")),\n+            dir.join(\"package.json\")?,\n             AssetContent::file(File::from(\"{\\\"type\\\": \\\"commonjs\\\"}\").into()),\n         )),\n         dir,\n-    )\n+    ))\n }\n \n /// Creates a node.js renderer pool for an entrypoint.\n #[turbo_tasks::function(operation)]\n pub async fn get_renderer_pool_operation(\n-    cwd: ResolvedVc<FileSystemPath>,\n+    cwd: FileSystemPath,\n     env: ResolvedVc<Box<dyn ProcessEnv>>,\n     intermediate_asset: ResolvedVc<Box<dyn OutputAsset>>,\n-    intermediate_output_path: ResolvedVc<FileSystemPath>,\n-    output_root: ResolvedVc<FileSystemPath>,\n-    project_dir: ResolvedVc<FileSystemPath>,\n+    intermediate_output_path: FileSystemPath,\n+    output_root: FileSystemPath,\n+    project_dir: FileSystemPath,\n     debug: bool,\n ) -> Result<Vc<NodeJsPool>> {\n-    emit_package_json(*intermediate_output_path).await?;\n+    emit_package_json(intermediate_output_path.clone())?.await?;\n \n-    let _ = emit(*intermediate_asset, *output_root).resolve().await?;\n+    let _ = emit(*intermediate_asset, output_root.clone())\n+        .resolve()\n+        .await?;\n     let assets_for_source_mapping =\n-        internal_assets_for_source_mapping(*intermediate_asset, *output_root);\n+        internal_assets_for_source_mapping(*intermediate_asset, output_root.clone());\n \n-    let entrypoint = intermediate_asset.path();\n+    let entrypoint = intermediate_asset.path().await?.clone_value();\n \n-    let Some(cwd) = to_sys_path(*cwd).await? else {\n+    let Some(cwd) = to_sys_path(cwd.clone()).await? else {\n         bail!(\n             \"can only render from a disk filesystem, but `cwd = {}`\",\n-            cwd.to_string().await?\n+            cwd.value_to_string().await?\n         );\n     };\n-    let Some(entrypoint) = to_sys_path(entrypoint).await? else {\n+    let Some(entrypoint) = to_sys_path(entrypoint.clone()).await? else {\n         bail!(\n             \"can only render from a disk filesystem, but `entrypoint = {}`\",\n-            entrypoint.to_string().await?\n+            entrypoint.value_to_string().await?\n         );\n     };\n     // Invalidate pool when code content changes\n@@ -253,23 +263,28 @@ pub async fn get_intermediate_asset(\n     main_entry: ResolvedVc<Box<dyn EvaluatableAsset>>,\n     other_entries: Vc<EvaluatableAssets>,\n ) -> Result<Vc<Box<dyn OutputAsset>>> {\n-    Ok(Vc::upcast(chunking_context.root_entry_chunk_group_asset(\n-        chunking_context.chunk_path(None, main_entry.ident(), rcstr!(\".js\")),\n-        other_entries.with_entry(*main_entry),\n-        ModuleGraph::from_modules(\n-            Vc::cell(vec![ChunkGroupEntry::Entry(\n-                other_entries\n-                    .await?\n-                    .into_iter()\n-                    .copied()\n-                    .chain(std::iter::once(main_entry))\n-                    .map(ResolvedVc::upcast)\n-                    .collect(),\n-            )]),\n-            false,\n+    Ok(Vc::upcast(\n+        chunking_context.root_entry_chunk_group_asset(\n+            chunking_context\n+                .chunk_path(None, main_entry.ident(), rcstr!(\".js\"))\n+                .await?\n+                .clone_value(),\n+            other_entries.with_entry(*main_entry),\n+            ModuleGraph::from_modules(\n+                Vc::cell(vec![ChunkGroupEntry::Entry(\n+                    other_entries\n+                        .await?\n+                        .into_iter()\n+                        .copied()\n+                        .chain(std::iter::once(main_entry))\n+                        .map(ResolvedVc::upcast)\n+                        .collect(),\n+                )]),\n+                false,\n+            ),\n+            OutputAssets::empty(),\n         ),\n-        OutputAssets::empty(),\n-    )))\n+    ))\n }\n \n #[derive(Clone, Debug)]"
        },
        {
            "sha": "68dce1413d4637a1e44753e63ef9b2f3542a7532",
            "filename": "turbopack/crates/turbopack-node/src/node_entry.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fnode_entry.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fnode_entry.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fnode_entry.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -9,9 +9,9 @@ pub struct NodeRenderingEntry {\n     pub runtime_entries: ResolvedVc<EvaluatableAssets>,\n     pub module: ResolvedVc<Box<dyn EvaluatableAsset>>,\n     pub chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n-    pub intermediate_output_path: ResolvedVc<FileSystemPath>,\n-    pub output_root: ResolvedVc<FileSystemPath>,\n-    pub project_dir: ResolvedVc<FileSystemPath>,\n+    pub intermediate_output_path: FileSystemPath,\n+    pub output_root: FileSystemPath,\n+    pub project_dir: FileSystemPath,\n }\n \n #[turbo_tasks::value(transparent)]"
        },
        {
            "sha": "abb013836e6415161f04e39f7612b7efe48a5919",
            "filename": "turbopack/crates/turbopack-node/src/pool.rs",
            "status": "modified",
            "additions": 28,
            "deletions": 28,
            "changes": 56,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fpool.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fpool.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fpool.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -73,8 +73,8 @@ struct NodeJsPoolProcess {\n     child: Option<Child>,\n     connection: TcpStream,\n     assets_for_source_mapping: ResolvedVc<AssetsForSourceMapping>,\n-    assets_root: ResolvedVc<FileSystemPath>,\n-    project_dir: ResolvedVc<FileSystemPath>,\n+    assets_root: FileSystemPath,\n+    project_dir: FileSystemPath,\n     stdout_handler: OutputStreamHandler<ChildStdout, Stdout>,\n     stderr_handler: OutputStreamHandler<ChildStderr, Stderr>,\n     debug: bool,\n@@ -120,8 +120,8 @@ impl NodeJsPoolProcess {\n                 apply_source_mapping(\n                     text,\n                     *self.assets_for_source_mapping,\n-                    *self.assets_root,\n-                    *self.project_dir,\n+                    self.assets_root.clone(),\n+                    self.project_dir.clone(),\n                     formatting_mode,\n                 )\n                 .await\n@@ -130,8 +130,8 @@ impl NodeJsPoolProcess {\n                 let cow = apply_source_mapping(\n                     text,\n                     *self.assets_for_source_mapping,\n-                    *self.assets_root,\n-                    *self.project_dir,\n+                    self.assets_root.clone(),\n+                    self.project_dir.clone(),\n                     formatting_mode,\n                 )\n                 .await?;\n@@ -159,8 +159,8 @@ struct OutputStreamHandler<R: AsyncRead + Unpin, W: AsyncWrite + Unpin> {\n     stream: BufReader<R>,\n     shared: SharedOutputSet,\n     assets_for_source_mapping: ResolvedVc<AssetsForSourceMapping>,\n-    root: ResolvedVc<FileSystemPath>,\n-    project_dir: ResolvedVc<FileSystemPath>,\n+    root: FileSystemPath,\n+    project_dir: FileSystemPath,\n     final_stream: W,\n }\n \n@@ -197,8 +197,8 @@ impl<R: AsyncRead + Unpin, W: AsyncWrite + Unpin> OutputStreamHandler<R, W> {\n         async fn write_source_mapped_final<W: AsyncWrite + Unpin>(\n             bytes: &[u8],\n             assets_for_source_mapping: Vc<AssetsForSourceMapping>,\n-            root: Vc<FileSystemPath>,\n-            project_dir: Vc<FileSystemPath>,\n+            root: FileSystemPath,\n+            project_dir: FileSystemPath,\n             final_stream: &mut W,\n         ) -> Result<()> {\n             if let Ok(text) = std::str::from_utf8(bytes) {\n@@ -298,8 +298,8 @@ impl<R: AsyncRead + Unpin, W: AsyncWrite + Unpin> OutputStreamHandler<R, W> {\n                             write_source_mapped_final(\n                                 &entry.data,\n                                 **assets_for_source_mapping,\n-                                **root,\n-                                **project_dir,\n+                                root.clone(),\n+                                project_dir.clone(),\n                                 final_stream,\n                             )\n                             .await?;\n@@ -325,8 +325,8 @@ impl<R: AsyncRead + Unpin, W: AsyncWrite + Unpin> OutputStreamHandler<R, W> {\n             write_source_mapped_final(\n                 &buffer,\n                 **assets_for_source_mapping,\n-                **root,\n-                **project_dir,\n+                root.clone(),\n+                project_dir.clone(),\n                 final_stream,\n             )\n             .await?;\n@@ -342,8 +342,8 @@ impl NodeJsPoolProcess {\n         env: &FxHashMap<RcStr, RcStr>,\n         entrypoint: &Path,\n         assets_for_source_mapping: ResolvedVc<AssetsForSourceMapping>,\n-        assets_root: ResolvedVc<FileSystemPath>,\n-        project_dir: ResolvedVc<FileSystemPath>,\n+        assets_root: FileSystemPath,\n+        project_dir: FileSystemPath,\n         shared_stdout: SharedOutputSet,\n         shared_stderr: SharedOutputSet,\n         debug: bool,\n@@ -440,25 +440,25 @@ impl NodeJsPoolProcess {\n             stream: child_stdout,\n             shared: shared_stdout,\n             assets_for_source_mapping,\n-            root: assets_root,\n-            project_dir,\n+            root: assets_root.clone(),\n+            project_dir: project_dir.clone(),\n             final_stream: stdout(),\n         };\n         let stderr_handler = OutputStreamHandler {\n             stream: child_stderr,\n             shared: shared_stderr,\n             assets_for_source_mapping,\n-            root: assets_root,\n-            project_dir,\n+            root: assets_root.clone(),\n+            project_dir: project_dir.clone(),\n             final_stream: stderr(),\n         };\n \n         let mut process = Self {\n             child: Some(child),\n             connection,\n             assets_for_source_mapping,\n-            assets_root,\n-            project_dir,\n+            assets_root: assets_root.clone(),\n+            project_dir: project_dir.clone(),\n             stdout_handler,\n             stderr_handler,\n             debug,\n@@ -727,8 +727,8 @@ pub struct NodeJsPool {\n     entrypoint: PathBuf,\n     env: FxHashMap<RcStr, RcStr>,\n     pub assets_for_source_mapping: ResolvedVc<AssetsForSourceMapping>,\n-    pub assets_root: ResolvedVc<FileSystemPath>,\n-    pub project_dir: ResolvedVc<FileSystemPath>,\n+    pub assets_root: FileSystemPath,\n+    pub project_dir: FileSystemPath,\n     #[turbo_tasks(trace_ignore, debug_ignore)]\n     processes: Arc<Mutex<BinaryHeap<NodeJsPoolProcess>>>,\n     /// Semaphore to limit the number of concurrent operations in general\n@@ -758,8 +758,8 @@ impl NodeJsPool {\n         entrypoint: PathBuf,\n         env: FxHashMap<RcStr, RcStr>,\n         assets_for_source_mapping: ResolvedVc<AssetsForSourceMapping>,\n-        assets_root: ResolvedVc<FileSystemPath>,\n-        project_dir: ResolvedVc<FileSystemPath>,\n+        assets_root: FileSystemPath,\n+        project_dir: FileSystemPath,\n         concurrency: usize,\n         debug: bool,\n     ) -> Self {\n@@ -838,8 +838,8 @@ impl NodeJsPool {\n             &self.env,\n             self.entrypoint.as_path(),\n             self.assets_for_source_mapping,\n-            self.assets_root,\n-            self.project_dir,\n+            self.assets_root.clone(),\n+            self.project_dir.clone(),\n             self.shared_stdout.clone(),\n             self.shared_stderr.clone(),\n             self.debug,"
        },
        {
            "sha": "39d6f1caf5988fd4fb2762abdecffb5c2d40e342",
            "filename": "turbopack/crates/turbopack-node/src/render/issue.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Fissue.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Fissue.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Fissue.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -3,9 +3,9 @@ use turbo_tasks::{ResolvedVc, Vc};\n use turbo_tasks_fs::FileSystemPath;\n use turbopack_core::issue::{Issue, IssueStage, OptionStyledString, StyledString};\n #[turbo_tasks::value(shared)]\n-#[derive(Copy, Clone)]\n+#[derive(Clone)]\n pub struct RenderingIssue {\n-    pub file_path: ResolvedVc<FileSystemPath>,\n+    pub file_path: FileSystemPath,\n     pub message: ResolvedVc<StyledString>,\n     pub status: Option<i32>,\n }\n@@ -24,7 +24,7 @@ impl Issue for RenderingIssue {\n \n     #[turbo_tasks::function]\n     fn file_path(&self) -> Vc<FileSystemPath> {\n-        *self.file_path\n+        self.file_path.clone().cell()\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "6033d62e09668b20697ddbaa54e36a4cf0edc171",
            "filename": "turbopack/crates/turbopack-node/src/render/node_api_source.rs",
            "status": "modified",
            "additions": 9,
            "deletions": 9,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Fnode_api_source.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Fnode_api_source.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Fnode_api_source.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -20,11 +20,11 @@ use crate::{get_intermediate_asset, node_entry::NodeEntry, route_matcher::RouteM\n /// Creates a [NodeApiContentSource].\n #[turbo_tasks::function]\n pub fn create_node_api_source(\n-    cwd: ResolvedVc<FileSystemPath>,\n+    cwd: FileSystemPath,\n     env: ResolvedVc<Box<dyn ProcessEnv>>,\n     base_segments: Vec<BaseSegment>,\n     route_type: RouteType,\n-    server_root: ResolvedVc<FileSystemPath>,\n+    server_root: FileSystemPath,\n     route_match: ResolvedVc<Box<dyn RouteMatcher>>,\n     pathname: ResolvedVc<RcStr>,\n     entry: ResolvedVc<Box<dyn NodeEntry>>,\n@@ -56,11 +56,11 @@ pub fn create_node_api_source(\n /// to this directory.\n #[turbo_tasks::value]\n pub struct NodeApiContentSource {\n-    cwd: ResolvedVc<FileSystemPath>,\n+    cwd: FileSystemPath,\n     env: ResolvedVc<Box<dyn ProcessEnv>>,\n     base_segments: Vec<BaseSegment>,\n     route_type: RouteType,\n-    server_root: ResolvedVc<FileSystemPath>,\n+    server_root: FileSystemPath,\n     pathname: ResolvedVc<RcStr>,\n     route_match: ResolvedVc<Box<dyn RouteMatcher>>,\n     entry: ResolvedVc<Box<dyn NodeEntry>>,\n@@ -125,15 +125,15 @@ impl GetContentSourceContent for NodeApiContentSource {\n         };\n         let entry = (*self.entry).entry(data.clone()).await?;\n         Ok(ContentSourceContent::HttpProxy(render_proxy_operation(\n-            self.cwd,\n+            self.cwd.clone(),\n             self.env,\n-            self.server_root.join(path.clone()).to_resolved().await?,\n+            self.server_root.join(&path.clone())?,\n             ResolvedVc::upcast(entry.module),\n             entry.runtime_entries,\n             entry.chunking_context,\n-            entry.intermediate_output_path,\n-            entry.output_root,\n-            entry.project_dir,\n+            entry.intermediate_output_path.clone(),\n+            entry.output_root.clone(),\n+            entry.project_dir.clone(),\n             RenderData {\n                 params: params.clone(),\n                 method: method.clone(),"
        },
        {
            "sha": "15fea4c7944c612d4ec32f669c505e39eae21317",
            "filename": "turbopack/crates/turbopack-node/src/render/render_proxy.rs",
            "status": "modified",
            "additions": 16,
            "deletions": 16,
            "changes": 32,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Frender_proxy.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Frender_proxy.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Frender_proxy.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -35,15 +35,15 @@ use crate::{\n /// Renders a module as static HTML in a node.js process.\n #[turbo_tasks::function(operation)]\n pub async fn render_proxy_operation(\n-    cwd: ResolvedVc<FileSystemPath>,\n+    cwd: FileSystemPath,\n     env: ResolvedVc<Box<dyn ProcessEnv>>,\n-    path: ResolvedVc<FileSystemPath>,\n+    path: FileSystemPath,\n     module: ResolvedVc<Box<dyn EvaluatableAsset>>,\n     runtime_entries: ResolvedVc<EvaluatableAssets>,\n     chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n-    intermediate_output_path: ResolvedVc<FileSystemPath>,\n-    output_root: ResolvedVc<FileSystemPath>,\n-    project_dir: ResolvedVc<FileSystemPath>,\n+    intermediate_output_path: FileSystemPath,\n+    output_root: FileSystemPath,\n+    project_dir: FileSystemPath,\n     data: ResolvedVc<RenderData>,\n     body: ResolvedVc<Body>,\n     debug: bool,\n@@ -96,7 +96,7 @@ pub async fn render_proxy_operation(\n }\n \n async fn proxy_error(\n-    path: ResolvedVc<FileSystemPath>,\n+    path: FileSystemPath,\n     error: anyhow::Error,\n     operation: Option<NodeJsOperation>,\n ) -> Result<(u16, RcStr)> {\n@@ -152,15 +152,15 @@ struct RenderStream(#[turbo_tasks(trace_ignore)] Stream<RenderItemResult>);\n \n #[derive(Clone, Debug, TaskInput, PartialEq, Eq, Hash, Serialize, Deserialize, TraceRawVcs)]\n struct RenderStreamOptions {\n-    cwd: ResolvedVc<FileSystemPath>,\n+    cwd: FileSystemPath,\n     env: ResolvedVc<Box<dyn ProcessEnv>>,\n-    path: ResolvedVc<FileSystemPath>,\n+    path: FileSystemPath,\n     module: ResolvedVc<Box<dyn EvaluatableAsset>>,\n     runtime_entries: ResolvedVc<EvaluatableAssets>,\n     chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n-    intermediate_output_path: ResolvedVc<FileSystemPath>,\n-    output_root: ResolvedVc<FileSystemPath>,\n-    project_dir: ResolvedVc<FileSystemPath>,\n+    intermediate_output_path: FileSystemPath,\n+    output_root: FileSystemPath,\n+    project_dir: FileSystemPath,\n     data: ResolvedVc<RenderData>,\n     body: ResolvedVc<Body>,\n     debug: bool,\n@@ -244,9 +244,9 @@ async fn render_stream_internal(\n             cwd,\n             env,\n             intermediate_asset,\n-            intermediate_output_path,\n+            intermediate_output_path.clone(),\n             output_root,\n-            project_dir,\n+            project_dir.clone(),\n             debug,\n         );\n \n@@ -281,8 +281,8 @@ async fn render_stream_internal(\n                 let trace = trace_stack(\n                     error,\n                     *intermediate_asset,\n-                    *intermediate_output_path,\n-                    *project_dir\n+                    intermediate_output_path.clone(),\n+                    project_dir.clone()\n                 )\n                 .await?;\n                 let (status, body) =  proxy_error(path, anyhow!(\"error rendering: {}\", trace), Some(operation)).await?;\n@@ -315,7 +315,7 @@ async fn render_stream_internal(\n                     // headers/body to a proxy error.\n                     operation.disallow_reuse();\n                     let trace =\n-                        trace_stack(error, *intermediate_asset, *intermediate_output_path, *project_dir).await?;\n+                        trace_stack(error, *intermediate_asset, intermediate_output_path.clone(), project_dir.clone()).await?;\n                     Err(anyhow!(\"error during streaming render: {}\", trace))?;\n                     return;\n                 }"
        },
        {
            "sha": "d11fd3281b2b8ae871a9018548c8cf27aa8bcbfd",
            "filename": "turbopack/crates/turbopack-node/src/render/render_static.rs",
            "status": "modified",
            "additions": 16,
            "deletions": 16,
            "changes": 32,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Frender_static.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Frender_static.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Frender_static.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -76,16 +76,16 @@ impl StaticResult {\n /// Renders a module as static HTML in a node.js process.\n #[turbo_tasks::function(operation)]\n pub async fn render_static_operation(\n-    cwd: ResolvedVc<FileSystemPath>,\n+    cwd: FileSystemPath,\n     env: ResolvedVc<Box<dyn ProcessEnv>>,\n-    path: ResolvedVc<FileSystemPath>,\n+    path: FileSystemPath,\n     module: ResolvedVc<Box<dyn EvaluatableAsset>>,\n     runtime_entries: ResolvedVc<EvaluatableAssets>,\n     fallback_page: ResolvedVc<DevHtmlAsset>,\n     chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n-    intermediate_output_path: ResolvedVc<FileSystemPath>,\n-    output_root: ResolvedVc<FileSystemPath>,\n-    project_dir: ResolvedVc<FileSystemPath>,\n+    intermediate_output_path: FileSystemPath,\n+    output_root: FileSystemPath,\n+    project_dir: FileSystemPath,\n     data: ResolvedVc<RenderData>,\n     debug: bool,\n ) -> Result<Vc<StaticResult>> {\n@@ -138,7 +138,7 @@ pub async fn render_static_operation(\n }\n \n async fn static_error(\n-    path: ResolvedVc<FileSystemPath>,\n+    path: FileSystemPath,\n     error: anyhow::Error,\n     operation: Option<NodeJsOperation>,\n     fallback_page: Vc<DevHtmlAsset>,\n@@ -203,16 +203,16 @@ struct RenderStream(#[turbo_tasks(trace_ignore)] Stream<RenderItemResult>);\n \n #[derive(Clone, Debug, TaskInput, PartialEq, Eq, Hash, Deserialize, Serialize, TraceRawVcs)]\n struct RenderStreamOptions {\n-    cwd: ResolvedVc<FileSystemPath>,\n+    cwd: FileSystemPath,\n     env: ResolvedVc<Box<dyn ProcessEnv>>,\n-    path: ResolvedVc<FileSystemPath>,\n+    path: FileSystemPath,\n     module: ResolvedVc<Box<dyn EvaluatableAsset>>,\n     runtime_entries: ResolvedVc<EvaluatableAssets>,\n     fallback_page: ResolvedVc<DevHtmlAsset>,\n     chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n-    intermediate_output_path: ResolvedVc<FileSystemPath>,\n-    output_root: ResolvedVc<FileSystemPath>,\n-    project_dir: ResolvedVc<FileSystemPath>,\n+    intermediate_output_path: FileSystemPath,\n+    output_root: FileSystemPath,\n+    project_dir: FileSystemPath,\n     data: ResolvedVc<RenderData>,\n     debug: bool,\n }\n@@ -295,9 +295,9 @@ async fn render_stream_internal(\n             cwd,\n             env,\n             intermediate_asset,\n-            intermediate_output_path,\n+            intermediate_output_path.clone(),\n             output_root,\n-            project_dir,\n+            project_dir.clone(),\n             debug,\n         );\n \n@@ -346,8 +346,8 @@ async fn render_stream_internal(\n                 let trace = trace_stack(\n                     error,\n                     *intermediate_asset,\n-                    *intermediate_output_path,\n-                    *project_dir,\n+                    intermediate_output_path.clone(),\n+                    project_dir.clone(),\n                 )\n                 .await?;\n                 yield RenderItem::Response(\n@@ -379,7 +379,7 @@ async fn render_stream_internal(\n                     // headers/body to a proxy error.\n                     operation.disallow_reuse();\n                     let trace =\n-                        trace_stack(error, *intermediate_asset, *intermediate_output_path, *project_dir).await?;\n+                        trace_stack(error, *intermediate_asset, intermediate_output_path.clone(), project_dir.clone()).await?;\n                         drop(guard);\n                     Err(anyhow!(\"error during streaming render: {}\", trace))?;\n                     return;"
        },
        {
            "sha": "07a8f16c34b8d3e045adab7284686134e6b9df25",
            "filename": "turbopack/crates/turbopack-node/src/render/rendered_source.rs",
            "status": "modified",
            "additions": 12,
            "deletions": 12,
            "changes": 24,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Frendered_source.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Frendered_source.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Frendered_source.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -43,11 +43,11 @@ use crate::{\n /// to this directory.\n #[turbo_tasks::function]\n pub fn create_node_rendered_source(\n-    cwd: ResolvedVc<FileSystemPath>,\n+    cwd: FileSystemPath,\n     env: ResolvedVc<Box<dyn ProcessEnv>>,\n     base_segments: Vec<BaseSegment>,\n     route_type: RouteType,\n-    server_root: ResolvedVc<FileSystemPath>,\n+    server_root: FileSystemPath,\n     route_match: ResolvedVc<Box<dyn RouteMatcher>>,\n     pathname: ResolvedVc<RcStr>,\n     entry: ResolvedVc<Box<dyn NodeEntry>>,\n@@ -83,11 +83,11 @@ pub fn create_node_rendered_source(\n /// see [create_node_rendered_source]\n #[turbo_tasks::value]\n pub struct NodeRenderContentSource {\n-    cwd: ResolvedVc<FileSystemPath>,\n+    cwd: FileSystemPath,\n     env: ResolvedVc<Box<dyn ProcessEnv>>,\n     base_segments: Vec<BaseSegment>,\n     route_type: RouteType,\n-    server_root: ResolvedVc<FileSystemPath>,\n+    server_root: FileSystemPath,\n     route_match: ResolvedVc<Box<dyn RouteMatcher>>,\n     pathname: ResolvedVc<RcStr>,\n     entry: ResolvedVc<Box<dyn NodeEntry>>,\n@@ -122,15 +122,15 @@ impl GetContentSource for NodeRenderContentSource {\n                     *entry.module,\n                     *entry.runtime_entries,\n                     *entry.chunking_context,\n-                    *entry.intermediate_output_path,\n+                    entry.intermediate_output_path.clone(),\n                 )\n                 .await?\n                 .iter()\n                 .copied(),\n             )\n         }\n         Ok(Vc::upcast(AssetGraphContentSource::new_lazy_multiple(\n-            *self.server_root,\n+            self.server_root.clone(),\n             Vc::cell(set),\n         )))\n     }\n@@ -183,16 +183,16 @@ impl GetContentSourceContent for NodeRenderContentSource {\n         };\n         let entry = (*self.entry).entry(data.clone()).await?;\n         let result_op = render_static_operation(\n-            self.cwd,\n+            self.cwd.clone(),\n             self.env,\n-            self.server_root.join(path.clone()).to_resolved().await?,\n+            self.server_root.join(&path)?,\n             ResolvedVc::upcast(entry.module),\n             entry.runtime_entries,\n             self.fallback_page,\n             entry.chunking_context,\n-            entry.intermediate_output_path,\n-            entry.output_root,\n-            entry.project_dir,\n+            entry.intermediate_output_path.clone(),\n+            entry.output_root.clone(),\n+            entry.project_dir.clone(),\n             RenderData {\n                 params: params.clone(),\n                 method: method.clone(),\n@@ -207,7 +207,7 @@ impl GetContentSourceContent for NodeRenderContentSource {\n             self.debug,\n         )\n         .issue_file_path(\n-            entry.module.ident().path(),\n+            entry.module.ident().path().await?.clone_value(),\n             format!(\"server-side rendering {pathname}\"),\n         )\n         .await?;"
        },
        {
            "sha": "c75279b883c229e319beb162ae9559ce2220a4aa",
            "filename": "turbopack/crates/turbopack-node/src/source_map/mod.rs",
            "status": "modified",
            "additions": 38,
            "deletions": 23,
            "changes": 61,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fsource_map%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fsource_map%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fsource_map%2Fmod.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -31,8 +31,8 @@ const MAX_CODE_FRAMES: usize = 3;\n pub async fn apply_source_mapping(\n     text: &'_ str,\n     assets_for_source_mapping: Vc<AssetsForSourceMapping>,\n-    root: Vc<FileSystemPath>,\n-    project_dir: Vc<FileSystemPath>,\n+    root: FileSystemPath,\n+    project_dir: FileSystemPath,\n     formatting_mode: FormattingMode,\n ) -> Result<Cow<'_, str>> {\n     static STACK_TRACE_LINE: Lazy<Regex> =\n@@ -62,9 +62,13 @@ pub async fn apply_source_mapping(\n             line: Some(line),\n             column: Some(column),\n         };\n-        let resolved =\n-            resolve_source_mapping(assets_for_source_mapping, root, project_dir.root(), &frame)\n-                .await;\n+        let resolved = resolve_source_mapping(\n+            assets_for_source_mapping,\n+            root.clone(),\n+            project_dir.root().await?.clone_value(),\n+            &frame,\n+        )\n+        .await;\n         write_resolved(\n             &mut new,\n             resolved,\n@@ -188,19 +192,19 @@ enum ResolvedSourceMapping {\n     },\n     MappedProject {\n         frame: StackFrame<'static>,\n-        project_path: ReadRef<FileSystemPath>,\n+        project_path: FileSystemPath,\n         lines: ReadRef<FileLinesContent>,\n     },\n     MappedLibrary {\n         frame: StackFrame<'static>,\n-        project_path: ReadRef<FileSystemPath>,\n+        project_path: FileSystemPath,\n     },\n }\n \n async fn resolve_source_mapping(\n     assets_for_source_mapping: Vc<AssetsForSourceMapping>,\n-    root: Vc<FileSystemPath>,\n-    project_dir: Vc<FileSystemPath>,\n+    root: FileSystemPath,\n+    project_dir: FileSystemPath,\n     frame: &StackFrame<'_>,\n ) -> Result<ResolvedSourceMapping> {\n     let Some((line, column)) = frame.get_pos() else {\n@@ -238,17 +242,17 @@ async fn resolve_source_mapping(\n                 PROJECT_FILESYSTEM_NAME,\n                 \"]/\"\n             )) {\n-                let fs_path = project_dir.join(project_path.into());\n+                let fs_path = project_dir.join(project_path)?;\n                 if lib_code {\n                     return Ok(ResolvedSourceMapping::MappedLibrary {\n                         frame: frame.clone(),\n-                        project_path: fs_path.await?,\n+                        project_path: fs_path.clone(),\n                     });\n                 } else {\n                     let lines = fs_path.read().lines().await?;\n                     return Ok(ResolvedSourceMapping::MappedProject {\n                         frame: frame.clone(),\n-                        project_path: fs_path.await?,\n+                        project_path: fs_path.clone(),\n                         lines,\n                     });\n                 }\n@@ -275,8 +279,8 @@ impl StructuredError {\n     pub async fn print(\n         &self,\n         assets_for_source_mapping: Vc<AssetsForSourceMapping>,\n-        root: Vc<FileSystemPath>,\n-        root_path: Vc<FileSystemPath>,\n+        root: FileSystemPath,\n+        root_path: FileSystemPath,\n         formatting_mode: FormattingMode,\n     ) -> Result<String> {\n         let mut message = String::new();\n@@ -295,8 +299,13 @@ impl StructuredError {\n \n         for frame in &self.stack {\n             let frame = frame.unmangle_identifiers(magic);\n-            let resolved =\n-                resolve_source_mapping(assets_for_source_mapping, root, root_path, &frame).await;\n+            let resolved = resolve_source_mapping(\n+                assets_for_source_mapping,\n+                root.clone(),\n+                root_path.clone(),\n+                &frame,\n+            )\n+            .await;\n             write_resolved(\n                 &mut message,\n                 resolved,\n@@ -310,8 +319,13 @@ impl StructuredError {\n         if let Some(cause) = &self.cause {\n             message.write_str(\"\\nCaused by: \")?;\n             message.write_str(\n-                &Box::pin(cause.print(assets_for_source_mapping, root, root_path, formatting_mode))\n-                    .await?,\n+                &Box::pin(cause.print(\n+                    assets_for_source_mapping,\n+                    root.clone(),\n+                    root_path.clone(),\n+                    formatting_mode,\n+                ))\n+                .await?,\n             )?;\n         }\n \n@@ -322,10 +336,11 @@ impl StructuredError {\n pub async fn trace_stack(\n     error: StructuredError,\n     root_asset: Vc<Box<dyn OutputAsset>>,\n-    output_path: Vc<FileSystemPath>,\n-    project_dir: Vc<FileSystemPath>,\n+    output_path: FileSystemPath,\n+    project_dir: FileSystemPath,\n ) -> Result<String> {\n-    let assets_for_source_mapping = internal_assets_for_source_mapping(root_asset, output_path);\n+    let assets_for_source_mapping =\n+        internal_assets_for_source_mapping(root_asset, output_path.clone());\n \n     trace_stack_with_source_mapping_assets(\n         error,\n@@ -340,8 +355,8 @@ pub async fn trace_stack(\n pub async fn trace_stack_with_source_mapping_assets(\n     error: StructuredError,\n     assets_for_source_mapping: Vc<AssetsForSourceMapping>,\n-    output_path: Vc<FileSystemPath>,\n-    project_dir: Vc<FileSystemPath>,\n+    output_path: FileSystemPath,\n+    project_dir: FileSystemPath,\n ) -> Result<String> {\n     error\n         .print("
        },
        {
            "sha": "b194747d467282ad0be907424c9ece1fe83cf0b2",
            "filename": "turbopack/crates/turbopack-node/src/transforms/postcss.rs",
            "status": "modified",
            "additions": 51,
            "deletions": 52,
            "changes": 103,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Fpostcss.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Fpostcss.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Fpostcss.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -170,7 +170,10 @@ impl Asset for PostCssTransformedAsset {\n     async fn content(self: ResolvedVc<Self>) -> Result<Vc<AssetContent>> {\n         let this = self.await?;\n         Ok(*transform_process_operation(self)\n-            .issue_file_path(this.source.ident().path(), \"PostCSS processing\")\n+            .issue_file_path(\n+                this.source.ident().path().await?.clone_value(),\n+                \"PostCSS processing\",\n+            )\n             .await?\n             .connect()\n             .await?\n@@ -194,11 +197,11 @@ struct ProcessPostCssResult {\n #[turbo_tasks::function]\n async fn config_changed(\n     asset_context: Vc<Box<dyn AssetContext>>,\n-    postcss_config_path: Vc<FileSystemPath>,\n+    postcss_config_path: FileSystemPath,\n ) -> Result<Vc<Completion>> {\n     let config_asset = asset_context\n         .process(\n-            Vc::upcast(FileSource::new(postcss_config_path)),\n+            Vc::upcast(FileSource::new(postcss_config_path.clone())),\n             ReferenceType::Internal(InnerAssets::empty().to_resolved().await?),\n         )\n         .module();\n@@ -217,14 +220,14 @@ async fn config_changed(\n #[turbo_tasks::function]\n async fn extra_configs_changed(\n     asset_context: Vc<Box<dyn AssetContext>>,\n-    postcss_config_path: Vc<FileSystemPath>,\n+    postcss_config_path: FileSystemPath,\n ) -> Result<Vc<Completion>> {\n     let parent_path = postcss_config_path.parent();\n \n     let config_paths = [\n-        parent_path.join(rcstr!(\"tailwind.config.js\")),\n-        parent_path.join(rcstr!(\"tailwind.config.mjs\")),\n-        parent_path.join(rcstr!(\"tailwind.config.ts\")),\n+        parent_path.join(\"tailwind.config.js\")?,\n+        parent_path.join(\"tailwind.config.mjs\")?,\n+        parent_path.join(\"tailwind.config.ts\")?,\n     ];\n \n     let configs = config_paths\n@@ -258,7 +261,7 @@ async fn extra_configs_changed(\n \n #[turbo_tasks::value]\n pub struct JsonSource {\n-    pub path: ResolvedVc<FileSystemPath>,\n+    pub path: FileSystemPath,\n     pub key: ResolvedVc<Option<RcStr>>,\n     pub allow_json5: bool,\n }\n@@ -267,7 +270,7 @@ pub struct JsonSource {\n impl JsonSource {\n     #[turbo_tasks::function]\n     pub fn new(\n-        path: ResolvedVc<FileSystemPath>,\n+        path: FileSystemPath,\n         key: ResolvedVc<Option<RcStr>>,\n         allow_json5: bool,\n     ) -> Vc<Self> {\n@@ -286,12 +289,9 @@ impl Source for JsonSource {\n     async fn ident(&self) -> Result<Vc<AssetIdent>> {\n         match &*self.key.await? {\n             Some(key) => Ok(AssetIdent::from_path(\n-                self.path\n-                    .append(rcstr!(\".\"))\n-                    .append(key.clone())\n-                    .append(rcstr!(\".json\")),\n+                self.path.append(\".\")?.append(key)?.append(\".json\")?,\n             )),\n-            None => Ok(AssetIdent::from_path(self.path.append(rcstr!(\".json\")))),\n+            None => Ok(AssetIdent::from_path(self.path.append(\".json\")?)),\n         }\n     }\n }\n@@ -329,10 +329,10 @@ impl Asset for JsonSource {\n \n #[turbo_tasks::function]\n pub(crate) async fn config_loader_source(\n-    project_path: Vc<FileSystemPath>,\n-    postcss_config_path: Vc<FileSystemPath>,\n+    project_path: FileSystemPath,\n+    postcss_config_path: FileSystemPath,\n ) -> Result<Vc<Box<dyn Source>>> {\n-    let postcss_config_path_value = &*postcss_config_path.await?;\n+    let postcss_config_path_value = postcss_config_path.clone();\n     let postcss_config_path_filename = postcss_config_path_value.file_name();\n \n     if postcss_config_path_filename == \"package.json\" {\n@@ -358,10 +358,7 @@ pub(crate) async fn config_loader_source(\n         return Ok(Vc::upcast(FileSource::new(postcss_config_path)));\n     }\n \n-    let Some(config_path) = project_path\n-        .await?\n-        .get_relative_path_to(postcss_config_path_value)\n-    else {\n+    let Some(config_path) = project_path.get_relative_path_to(&postcss_config_path_value) else {\n         bail!(\"Unable to get relative path to postcss config\");\n     };\n \n@@ -385,16 +382,16 @@ pub(crate) async fn config_loader_source(\n     };\n \n     Ok(Vc::upcast(VirtualSource::new(\n-        postcss_config_path.append(rcstr!(\"_.loader.mjs\")),\n+        postcss_config_path.append(\"_.loader.mjs\")?,\n         AssetContent::file(File::from(code).into()),\n     )))\n }\n \n #[turbo_tasks::function]\n async fn postcss_executor(\n     asset_context: Vc<Box<dyn AssetContext>>,\n-    project_path: Vc<FileSystemPath>,\n-    postcss_config_path: Vc<FileSystemPath>,\n+    project_path: FileSystemPath,\n+    postcss_config_path: FileSystemPath,\n ) -> Result<Vc<ProcessResult>> {\n     let config_asset = asset_context\n         .process(\n@@ -406,36 +403,38 @@ async fn postcss_executor(\n         .await?;\n \n     Ok(asset_context.process(\n-        Vc::upcast(FileSource::new(embed_file_path(rcstr!(\n-            \"transforms/postcss.ts\"\n-        )))),\n+        Vc::upcast(FileSource::new(\n+            embed_file_path(rcstr!(\"transforms/postcss.ts\"))\n+                .await?\n+                .clone_value(),\n+        )),\n         ReferenceType::Internal(ResolvedVc::cell(fxindexmap! {\n             rcstr!(\"CONFIG\") => config_asset\n         })),\n     ))\n }\n \n async fn find_config_in_location(\n-    project_path: Vc<FileSystemPath>,\n+    project_path: FileSystemPath,\n     location: PostCssConfigLocation,\n     source: Vc<Box<dyn Source>>,\n-) -> Result<Option<Vc<FileSystemPath>>> {\n+) -> Result<Option<FileSystemPath>> {\n     if let FindContextFileResult::Found(config_path, _) =\n-        *find_context_file_or_package_key(project_path, postcss_configs(), rcstr!(\"postcss\"))\n+        &*find_context_file_or_package_key(project_path, postcss_configs(), rcstr!(\"postcss\"))\n             .await?\n     {\n-        return Ok(Some(*config_path));\n+        return Ok(Some(config_path.clone()));\n     }\n \n     if matches!(location, PostCssConfigLocation::ProjectPathOrLocalPath)\n-        && let FindContextFileResult::Found(config_path, _) = *find_context_file_or_package_key(\n-            source.ident().path().parent(),\n+        && let FindContextFileResult::Found(config_path, _) = &*find_context_file_or_package_key(\n+            source.ident().path().await?.parent(),\n             postcss_configs(),\n             rcstr!(\"postcss\"),\n         )\n         .await?\n     {\n-        return Ok(Some(*config_path));\n+        return Ok(Some(config_path.clone()));\n     }\n \n     Ok(None)\n@@ -475,7 +474,8 @@ impl PostCssTransformedAsset {\n         //\n         // We look for the config in the project path first, then the source path\n         let Some(config_path) =\n-            find_config_in_location(**project_path, self.config_location, *self.source).await?\n+            find_config_in_location(project_path.clone(), self.config_location, *self.source)\n+                .await?\n         else {\n             return Ok(ProcessPostCssResult {\n                 content: self.source.content().to_resolved().await?,\n@@ -500,31 +500,30 @@ impl PostCssTransformedAsset {\n         let source_map = self.source_map;\n \n         // This invalidates the transform when the config changes.\n-        let config_changed = config_changed(*evaluate_context, config_path)\n+        let config_changed = config_changed(*evaluate_context, config_path.clone())\n             .to_resolved()\n             .await?;\n \n-        let postcss_executor = postcss_executor(*evaluate_context, **project_path, config_path)\n-            .module()\n-            .to_resolved()\n-            .await?;\n+        let postcss_executor =\n+            postcss_executor(*evaluate_context, project_path.clone(), config_path)\n+                .module()\n+                .to_resolved()\n+                .await?;\n         let css_fs_path = self.source.ident().path();\n \n         // We need to get a path relative to the project because the postcss loader\n         // runs with the project as the current working directory.\n-        let css_path = if let Some(css_path) = project_path\n-            .await?\n-            .get_relative_path_to(&*css_fs_path.await?)\n-        {\n-            css_path.into_owned()\n-        } else {\n-            // This shouldn't be an error since it can happen on virtual assets\n-            \"\".into()\n-        };\n+        let css_path =\n+            if let Some(css_path) = project_path.get_relative_path_to(&*css_fs_path.await?) {\n+                css_path.into_owned()\n+            } else {\n+                // This shouldn't be an error since it can happen on virtual assets\n+                \"\".into()\n+            };\n \n         let config_value = evaluate_webpack_loader(WebpackLoaderContext {\n             module_asset: postcss_executor,\n-            cwd: *project_path,\n+            cwd: project_path.clone(),\n             env: *env,\n             context_ident_for_issue: self.source.ident().to_resolved().await?,\n             asset_context: evaluate_context,\n@@ -561,7 +560,7 @@ impl PostCssTransformedAsset {\n \n #[turbo_tasks::value]\n struct PostCssTransformIssue {\n-    source: ResolvedVc<FileSystemPath>,\n+    source: FileSystemPath,\n     description: RcStr,\n     severity: IssueSeverity,\n     title: RcStr,\n@@ -571,7 +570,7 @@ struct PostCssTransformIssue {\n impl Issue for PostCssTransformIssue {\n     #[turbo_tasks::function]\n     fn file_path(&self) -> Vc<FileSystemPath> {\n-        *self.source\n+        self.source.clone().cell()\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "5ce3f422215bf152546762c60bfe3c5e13b0d9f5",
            "filename": "turbopack/crates/turbopack-node/src/transforms/util.rs",
            "status": "modified",
            "additions": 10,
            "deletions": 7,
            "changes": 17,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Futil.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Futil.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Futil.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -35,13 +35,16 @@ pub async fn emitted_assets_to_virtual_sources(\n         .collect::<BTreeMap<_, _>>()\n         .into_iter()\n         .map(|(file, (content, _source_map))| {\n-            // TODO handle SourceMap\n-            VirtualSource::new(\n-                ServerFileSystem::new().root().join(file),\n-                AssetContent::File(FileContent::Content(File::from(content)).resolved_cell())\n-                    .cell(),\n-            )\n-            .to_resolved()\n+            async move {\n+                // TODO handle SourceMap\n+                VirtualSource::new(\n+                    ServerFileSystem::new().root().await?.join(&file)?,\n+                    AssetContent::File(FileContent::Content(File::from(content)).resolved_cell())\n+                        .cell(),\n+                )\n+                .to_resolved()\n+                .await\n+            }\n         })\n         .try_join()\n         .await"
        },
        {
            "sha": "622342bdbfb1fafe3e16b0aa62eefa21911c1f67",
            "filename": "turbopack/crates/turbopack-node/src/transforms/webpack.rs",
            "status": "modified",
            "additions": 50,
            "deletions": 47,
            "changes": 97,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Fwebpack.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Fwebpack.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Fwebpack.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -188,9 +188,11 @@ async fn webpack_loaders_executor(\n     evaluate_context: Vc<Box<dyn AssetContext>>,\n ) -> Result<Vc<ProcessResult>> {\n     Ok(evaluate_context.process(\n-        Vc::upcast(FileSource::new(embed_file_path(rcstr!(\n-            \"transforms/webpack-loaders.ts\"\n-        )))),\n+        Vc::upcast(FileSource::new(\n+            embed_file_path(rcstr!(\"transforms/webpack-loaders.ts\"))\n+                .await?\n+                .clone_value(),\n+        )),\n         ReferenceType::Internal(InnerAssets::empty().to_resolved().await?),\n     ))\n }\n@@ -206,7 +208,7 @@ impl WebpackLoadersProcessedAsset {\n             project_path,\n             chunking_context,\n             env,\n-        } = *transform.execution_context.await?;\n+        } = &*transform.execution_context.await?;\n         let source_content = this.source.content();\n         let AssetContent::File(file) = *source_content.await? else {\n             bail!(\"Webpack Loaders transform only support transforming files\");\n@@ -239,26 +241,22 @@ impl WebpackLoadersProcessedAsset {\n             .to_resolved()\n             .await?;\n \n-        let resource_fs_path = this.source.ident().path();\n-        let resource_fs_path_ref = resource_fs_path.await?;\n-        let Some(resource_path) = project_path\n-            .await?\n-            .get_relative_path_to(&resource_fs_path_ref)\n-        else {\n+        let resource_fs_path = this.source.ident().path().await?.clone_value();\n+        let resource_fs_path_ref = resource_fs_path.clone();\n+        let Some(resource_path) = project_path.get_relative_path_to(&resource_fs_path_ref) else {\n             bail!(format!(\n                 \"Resource path \\\"{}\\\" need to be on project filesystem \\\"{}\\\"\",\n-                resource_fs_path_ref,\n-                project_path.await?\n+                resource_fs_path_ref, project_path\n             ));\n         };\n         let loaders = transform.loaders.await?;\n         let config_value = evaluate_webpack_loader(WebpackLoaderContext {\n             module_asset: webpack_loaders_executor,\n-            cwd: project_path,\n-            env,\n+            cwd: project_path.clone(),\n+            env: *env,\n             context_ident_for_issue: this.source.ident().to_resolved().await?,\n             asset_context: evaluate_context,\n-            chunking_context,\n+            chunking_context: *chunking_context,\n             resolve_options_context: Some(transform.resolve_options_context),\n             args: vec![\n                 ResolvedVc::cell(content),\n@@ -415,7 +413,7 @@ pub enum ResponseMessage {\n #[derive(Clone, PartialEq, Eq, Hash, TaskInput, Serialize, Deserialize, Debug, TraceRawVcs)]\n pub struct WebpackLoaderContext {\n     pub module_asset: ResolvedVc<Box<dyn Module>>,\n-    pub cwd: ResolvedVc<FileSystemPath>,\n+    pub cwd: FileSystemPath,\n     pub env: ResolvedVc<Box<dyn ProcessEnv>>,\n     pub context_ident_for_issue: ResolvedVc<AssetIdent>,\n     pub asset_context: ResolvedVc<Box<dyn AssetContext>>,\n@@ -439,7 +437,7 @@ impl EvaluateContext for WebpackLoaderContext {\n     fn pool(&self) -> OperationVc<crate::pool::NodeJsPool> {\n         get_evaluate_pool(\n             self.module_asset,\n-            self.cwd,\n+            self.cwd.clone(),\n             self.env,\n             self.asset_context,\n             self.chunking_context,\n@@ -458,7 +456,7 @@ impl EvaluateContext for WebpackLoaderContext {\n     }\n \n     fn cwd(&self) -> Vc<turbo_tasks_fs::FileSystemPath> {\n-        *self.cwd\n+        self.cwd.clone().cell()\n     }\n \n     fn keep_alive(&self) -> bool {\n@@ -470,8 +468,8 @@ impl EvaluateContext for WebpackLoaderContext {\n             error,\n             context_ident: self.context_ident_for_issue,\n             assets_for_source_mapping: pool.assets_for_source_mapping,\n-            assets_root: pool.assets_root,\n-            root_path: self.chunking_context.root_path().to_resolved().await?,\n+            assets_root: pool.assets_root.clone(),\n+            root_path: self.chunking_context.root_path().await?.clone_value(),\n         }\n         .resolved_cell()\n         .emit();\n@@ -504,19 +502,20 @@ impl EvaluateContext for WebpackLoaderContext {\n                     .try_join();\n                 let file_subscriptions = file_paths\n                     .iter()\n-                    .map(|p| self.cwd.join(p.clone()).read())\n+                    .map(|p| async move { self.cwd.join(p)?.read().await })\n                     .try_join();\n                 let directory_subscriptions = directories\n                     .iter()\n-                    .map(|(dir, glob)| {\n+                    .map(|(dir, glob)| async move {\n                         self.cwd\n-                            .join(dir.clone())\n+                            .join(dir)?\n                             .track_glob(Glob::new(glob.clone()), false)\n+                            .await\n                     })\n                     .try_join();\n                 let build_paths = build_file_paths\n                     .iter()\n-                    .map(|path| self.cwd.join(path.clone()).to_resolved())\n+                    .map(|path| async move { self.cwd.join(path) })\n                     .try_join();\n                 let (resolved_build_paths, ..) = try_join!(\n                     build_paths,\n@@ -536,12 +535,12 @@ impl EvaluateContext for WebpackLoaderContext {\n             }\n             InfoMessage::EmittedError { error, severity } => {\n                 EvaluateEmittedErrorIssue {\n-                    file_path: self.context_ident_for_issue.path().to_resolved().await?,\n+                    file_path: self.context_ident_for_issue.path().await?.clone_value(),\n                     error,\n                     severity,\n                     assets_for_source_mapping: pool.assets_for_source_mapping,\n-                    assets_root: pool.assets_root,\n-                    project_dir: self.chunking_context.root_path().to_resolved().await?,\n+                    assets_root: pool.assets_root.clone(),\n+                    project_dir: self.chunking_context.root_path().await?.clone_value(),\n                 }\n                 .resolved_cell()\n                 .emit();\n@@ -568,20 +567,24 @@ impl EvaluateContext for WebpackLoaderContext {\n                 let Some(resolve_options_context) = self.resolve_options_context else {\n                     bail!(\"Resolve options are not available in this context\");\n                 };\n-                let lookup_path = self.cwd.join(lookup_path);\n+                let lookup_path = self.cwd.join(&lookup_path)?;\n                 let request = Request::parse(Pattern::Constant(request));\n-                let options = resolve_options(lookup_path, *resolve_options_context);\n+                let options = resolve_options(lookup_path.clone(), *resolve_options_context);\n \n                 let options = apply_webpack_resolve_options(options, webpack_options);\n \n-                let resolved = resolve(lookup_path, ReferenceType::Undefined, request, options);\n+                let resolved = resolve(\n+                    lookup_path.clone(),\n+                    ReferenceType::Undefined,\n+                    request,\n+                    options,\n+                );\n \n                 let request_str = request.to_string().await?;\n-                let lookup_path_str = lookup_path.to_string().await?;\n+                let lookup_path_str = lookup_path.value_to_string().await?;\n                 if let Some(source) = *resolved.first_source().await? {\n                     if let Some(path) = self\n                         .cwd\n-                        .await?\n                         .get_relative_path_to(&*source.ident().path().await?)\n                     {\n                         Ok(ResponseMessage::Resolve { path })\n@@ -618,16 +621,16 @@ impl EvaluateContext for WebpackLoaderContext {\n                 .collect();\n \n             EvaluateErrorLoggingIssue {\n-                file_path: self.context_ident_for_issue.path().to_resolved().await?,\n+                file_path: self.context_ident_for_issue.path().await?.clone_value(),\n                 logging: logs,\n                 severity: if has_errors {\n                     IssueSeverity::Error\n                 } else {\n                     IssueSeverity::Warning\n                 },\n                 assets_for_source_mapping: pool.assets_for_source_mapping,\n-                assets_root: pool.assets_root,\n-                project_dir: self.chunking_context.root_path().to_resolved().await?,\n+                assets_root: pool.assets_root.clone(),\n+                project_dir: self.chunking_context.root_path().await?.clone_value(),\n             }\n             .resolved_cell()\n             .emit();\n@@ -723,7 +726,7 @@ async fn apply_webpack_resolve_options(\n #[turbo_tasks::value(shared)]\n pub struct BuildDependencyIssue {\n     pub context_ident: ResolvedVc<AssetIdent>,\n-    pub path: ResolvedVc<FileSystemPath>,\n+    pub path: FileSystemPath,\n }\n \n #[turbo_tasks::value_impl]\n@@ -752,7 +755,7 @@ impl Issue for BuildDependencyIssue {\n         Ok(Vc::cell(Some(\n             StyledString::Line(vec![\n                 StyledString::Text(rcstr!(\"The file at \")),\n-                StyledString::Code(self.path.await?.to_string().into()),\n+                StyledString::Code(self.path.to_string().into()),\n                 StyledString::Text(\n                     \" is a build dependency, which is not yet implemented.\n     Changing this file or any dependency will not be recognized and might require restarting the \\\n@@ -767,19 +770,19 @@ impl Issue for BuildDependencyIssue {\n \n #[turbo_tasks::value(shared)]\n pub struct EvaluateEmittedErrorIssue {\n-    pub file_path: ResolvedVc<FileSystemPath>,\n+    pub file_path: FileSystemPath,\n     pub severity: IssueSeverity,\n     pub error: StructuredError,\n     pub assets_for_source_mapping: ResolvedVc<AssetsForSourceMapping>,\n-    pub assets_root: ResolvedVc<FileSystemPath>,\n-    pub project_dir: ResolvedVc<FileSystemPath>,\n+    pub assets_root: FileSystemPath,\n+    pub project_dir: FileSystemPath,\n }\n \n #[turbo_tasks::value_impl]\n impl Issue for EvaluateEmittedErrorIssue {\n     #[turbo_tasks::function]\n     fn file_path(&self) -> Vc<FileSystemPath> {\n-        *self.file_path\n+        self.file_path.clone().cell()\n     }\n \n     #[turbo_tasks::function]\n@@ -803,8 +806,8 @@ impl Issue for EvaluateEmittedErrorIssue {\n                 self.error\n                     .print(\n                         *self.assets_for_source_mapping,\n-                        *self.assets_root,\n-                        *self.project_dir,\n+                        self.assets_root.clone(),\n+                        self.project_dir.clone(),\n                         FormattingMode::Plain,\n                     )\n                     .await?\n@@ -817,20 +820,20 @@ impl Issue for EvaluateEmittedErrorIssue {\n \n #[turbo_tasks::value(shared)]\n pub struct EvaluateErrorLoggingIssue {\n-    pub file_path: ResolvedVc<FileSystemPath>,\n+    pub file_path: FileSystemPath,\n     pub severity: IssueSeverity,\n     #[turbo_tasks(trace_ignore)]\n     pub logging: Vec<LogInfo>,\n     pub assets_for_source_mapping: ResolvedVc<AssetsForSourceMapping>,\n-    pub assets_root: ResolvedVc<FileSystemPath>,\n-    pub project_dir: ResolvedVc<FileSystemPath>,\n+    pub assets_root: FileSystemPath,\n+    pub project_dir: FileSystemPath,\n }\n \n #[turbo_tasks::value_impl]\n impl Issue for EvaluateErrorLoggingIssue {\n     #[turbo_tasks::function]\n     fn file_path(&self) -> Vc<FileSystemPath> {\n-        *self.file_path\n+        self.file_path.clone().cell()\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "5f16cdf8f5f7665155213a07c97ec16db8ae16b8",
            "filename": "turbopack/crates/turbopack-nodejs/src/chunking_context.rs",
            "status": "modified",
            "additions": 21,
            "deletions": 21,
            "changes": 42,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fchunking_context.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fchunking_context.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fchunking_context.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -105,17 +105,17 @@ impl NodeJsChunkingContextBuilder {\n #[derive(Debug, Clone, Hash, TaskInput)]\n pub struct NodeJsChunkingContext {\n     /// The root path of the project\n-    root_path: ResolvedVc<FileSystemPath>,\n+    root_path: FileSystemPath,\n     /// This path is used to compute the url to request chunks or assets from\n-    output_root: ResolvedVc<FileSystemPath>,\n+    output_root: FileSystemPath,\n     /// The relative path from the output_root to the root_path.\n     output_root_to_root_path: RcStr,\n     /// This path is used to compute the url to request chunks or assets from\n-    client_root: ResolvedVc<FileSystemPath>,\n+    client_root: FileSystemPath,\n     /// Chunks are placed at this path\n-    chunk_root_path: ResolvedVc<FileSystemPath>,\n+    chunk_root_path: FileSystemPath,\n     /// Static assets are placed at this path\n-    asset_root_path: ResolvedVc<FileSystemPath>,\n+    asset_root_path: FileSystemPath,\n     /// Static assets requested from this url base\n     asset_prefix: Option<RcStr>,\n     /// The environment chunks will be evaluated in.\n@@ -143,12 +143,12 @@ pub struct NodeJsChunkingContext {\n impl NodeJsChunkingContext {\n     /// Creates a new chunking context builder.\n     pub fn builder(\n-        root_path: ResolvedVc<FileSystemPath>,\n-        output_root: ResolvedVc<FileSystemPath>,\n+        root_path: FileSystemPath,\n+        output_root: FileSystemPath,\n         output_root_to_root_path: RcStr,\n-        client_root: ResolvedVc<FileSystemPath>,\n-        chunk_root_path: ResolvedVc<FileSystemPath>,\n-        asset_root_path: ResolvedVc<FileSystemPath>,\n+        client_root: FileSystemPath,\n+        chunk_root_path: FileSystemPath,\n+        asset_root_path: FileSystemPath,\n         environment: ResolvedVc<Environment>,\n         runtime_type: RuntimeType,\n     ) -> NodeJsChunkingContextBuilder {\n@@ -229,12 +229,12 @@ impl ChunkingContext for NodeJsChunkingContext {\n \n     #[turbo_tasks::function]\n     fn root_path(&self) -> Vc<FileSystemPath> {\n-        *self.root_path\n+        self.root_path.clone().cell()\n     }\n \n     #[turbo_tasks::function]\n     fn output_root(&self) -> Vc<FileSystemPath> {\n-        *self.output_root\n+        self.output_root.clone().cell()\n     }\n \n     #[turbo_tasks::function]\n@@ -263,10 +263,10 @@ impl ChunkingContext for NodeJsChunkingContext {\n     }\n \n     #[turbo_tasks::function]\n-    async fn asset_url(&self, ident: Vc<FileSystemPath>) -> Result<Vc<RcStr>> {\n-        let asset_path = ident.await?.to_string();\n+    async fn asset_url(&self, ident: FileSystemPath) -> Result<Vc<RcStr>> {\n+        let asset_path = ident.to_string();\n         let asset_path = asset_path\n-            .strip_prefix(&format!(\"{}/\", self.client_root.await?.path))\n+            .strip_prefix(&format!(\"{}/\", self.client_root.path))\n             .context(\"expected client root to contain asset path\")?;\n \n         Ok(Vc::cell(\n@@ -281,7 +281,7 @@ impl ChunkingContext for NodeJsChunkingContext {\n \n     #[turbo_tasks::function]\n     fn chunk_root_path(&self) -> Vc<FileSystemPath> {\n-        *self.chunk_root_path\n+        self.chunk_root_path.clone().cell()\n     }\n \n     #[turbo_tasks::function]\n@@ -291,12 +291,12 @@ impl ChunkingContext for NodeJsChunkingContext {\n         ident: Vc<AssetIdent>,\n         extension: RcStr,\n     ) -> Result<Vc<FileSystemPath>> {\n-        let root_path = *self.chunk_root_path;\n+        let root_path = self.chunk_root_path.clone();\n         let name = ident\n-            .output_name(*self.root_path, extension)\n+            .output_name(self.root_path.clone(), extension)\n             .owned()\n             .await?;\n-        Ok(root_path.join(name))\n+        Ok(root_path.join(&name)?.cell())\n     }\n \n     #[turbo_tasks::function]\n@@ -344,7 +344,7 @@ impl ChunkingContext for NodeJsChunkingContext {\n                 content_hash = &content_hash[..8]\n             ),\n         };\n-        Ok(self.asset_root_path.join(asset_path.into()))\n+        Ok(self.asset_root_path.join(&asset_path)?.cell())\n     }\n \n     #[turbo_tasks::function]\n@@ -388,7 +388,7 @@ impl ChunkingContext for NodeJsChunkingContext {\n     #[turbo_tasks::function]\n     pub async fn entry_chunk_group(\n         self: ResolvedVc<Self>,\n-        path: Vc<FileSystemPath>,\n+        path: FileSystemPath,\n         evaluatable_assets: Vc<EvaluatableAssets>,\n         module_graph: Vc<ModuleGraph>,\n         extra_chunks: Vc<OutputAssets>,"
        },
        {
            "sha": "e0d77bee827a3016ab5c6c1cd2bdd31805f25851",
            "filename": "turbopack/crates/turbopack-nodejs/src/ecmascript/node/content.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fcontent.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fcontent.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fcontent.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -87,8 +87,8 @@ impl EcmascriptBuildNodeChunkContent {\n     #[turbo_tasks::function]\n     pub(crate) async fn own_version(&self) -> Result<Vc<EcmascriptBuildNodeChunkVersion>> {\n         Ok(EcmascriptBuildNodeChunkVersion::new(\n-            self.chunking_context.output_root(),\n-            self.chunk.path(),\n+            self.chunking_context.output_root().await?.clone_value(),\n+            self.chunk.path().await?.clone_value(),\n             *self.content,\n             self.chunking_context.await?.minify_type(),\n         ))"
        },
        {
            "sha": "21dcc4b7c4c3a69062d1de87db3ffbc5a134ae3f",
            "filename": "turbopack/crates/turbopack-nodejs/src/ecmascript/node/entry/chunk.rs",
            "status": "modified",
            "additions": 11,
            "deletions": 8,
            "changes": 19,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fentry%2Fchunk.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fentry%2Fchunk.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fentry%2Fchunk.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -22,7 +22,7 @@ use crate::NodeJsChunkingContext;\n /// runtime entries.\n #[turbo_tasks::value(shared)]\n pub(crate) struct EcmascriptBuildNodeEntryChunk {\n-    path: ResolvedVc<FileSystemPath>,\n+    path: FileSystemPath,\n     other_chunks: ResolvedVc<OutputAssets>,\n     evaluatable_assets: ResolvedVc<EvaluatableAssets>,\n     exported_module: ResolvedVc<Box<dyn EcmascriptChunkPlaceable>>,\n@@ -35,7 +35,7 @@ impl EcmascriptBuildNodeEntryChunk {\n     /// Creates a new [`Vc<EcmascriptBuildNodeEntryChunk>`].\n     #[turbo_tasks::function]\n     pub fn new(\n-        path: ResolvedVc<FileSystemPath>,\n+        path: FileSystemPath,\n         other_chunks: ResolvedVc<OutputAssets>,\n         evaluatable_assets: ResolvedVc<EvaluatableAssets>,\n         exported_module: ResolvedVc<Box<dyn EcmascriptChunkPlaceable>>,\n@@ -57,10 +57,10 @@ impl EcmascriptBuildNodeEntryChunk {\n     async fn code(self: Vc<Self>) -> Result<Vc<Code>> {\n         let this = self.await?;\n \n-        let output_root = this.chunking_context.output_root().await?;\n-        let chunk_path = self.path().await?;\n-        let chunk_directory = self.path().parent().await?;\n-        let runtime_path = self.runtime_chunk().path().await?;\n+        let output_root = this.chunking_context.output_root().await?.clone_value();\n+        let chunk_path = self.path().await?.clone_value();\n+        let chunk_directory = self.path().await?.parent();\n+        let runtime_path = self.runtime_chunk().path().await?.clone_value();\n         let runtime_relative_path =\n             if let Some(path) = chunk_directory.get_relative_path_to(&runtime_path) {\n                 path\n@@ -152,7 +152,10 @@ impl EcmascriptBuildNodeEntryChunk {\n     #[turbo_tasks::function]\n     async fn source_map(self: Vc<Self>) -> Result<Vc<SourceMapAsset>> {\n         let this = self.await?;\n-        Ok(SourceMapAsset::new_fixed(*this.path, Vc::upcast(self)))\n+        Ok(SourceMapAsset::new_fixed(\n+            this.path.clone(),\n+            Vc::upcast(self),\n+        ))\n     }\n }\n \n@@ -168,7 +171,7 @@ impl ValueToString for EcmascriptBuildNodeEntryChunk {\n impl OutputAsset for EcmascriptBuildNodeEntryChunk {\n     #[turbo_tasks::function]\n     fn path(&self) -> Vc<FileSystemPath> {\n-        *self.path\n+        self.path.clone().cell()\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "ec655e339d3f9d98245a99e7c3f07ad9086d0095",
            "filename": "turbopack/crates/turbopack-nodejs/src/ecmascript/node/entry/runtime.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 4,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fentry%2Fruntime.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fentry%2Fruntime.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fentry%2Fruntime.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -95,12 +95,13 @@ impl EcmascriptBuildNodeRuntimeChunk {\n     }\n \n     #[turbo_tasks::function]\n-    fn ident_for_path(self: Vc<Self>) -> Vc<AssetIdent> {\n-        AssetIdent::from_path(\n+    async fn ident_for_path(self: Vc<Self>) -> Result<Vc<AssetIdent>> {\n+        Ok(AssetIdent::from_path(\n             turbopack_ecmascript_runtime::embed_fs()\n                 .root()\n-                .join(rcstr!(\"runtime.js\")),\n-        )\n+                .await?\n+                .join(\"runtime.js\")?,\n+        ))\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "c3f3537f88f7bb94345aa7628a8762e9e1ba1f0f",
            "filename": "turbopack/crates/turbopack-nodejs/src/ecmascript/node/version.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fversion.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fversion.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fversion.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -17,13 +17,13 @@ pub(super) struct EcmascriptBuildNodeChunkVersion {\n impl EcmascriptBuildNodeChunkVersion {\n     #[turbo_tasks::function]\n     pub async fn new(\n-        output_root: Vc<FileSystemPath>,\n-        chunk_path: Vc<FileSystemPath>,\n+        output_root: FileSystemPath,\n+        chunk_path: FileSystemPath,\n         content: Vc<EcmascriptChunkContent>,\n         minify_type: MinifyType,\n     ) -> Result<Vc<Self>> {\n-        let output_root = output_root.await?;\n-        let chunk_path = chunk_path.await?;\n+        let output_root = output_root.clone();\n+        let chunk_path = chunk_path.clone();\n         let chunk_path = if let Some(path) = output_root.get_path_to(&chunk_path) {\n             path\n         } else {"
        },
        {
            "sha": "17a99301e589317dbb8425b89dd6a2d3ff841e4e",
            "filename": "turbopack/crates/turbopack-resolve/src/ecmascript.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Fecmascript.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Fecmascript.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Fecmascript.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -94,7 +94,7 @@ pub async fn esm_resolve(\n     issue_source: Option<IssueSource>,\n ) -> Result<Vc<ModuleResolveResult>> {\n     let ty = ReferenceType::EcmaScriptModules(ty);\n-    let options = apply_esm_specific_options(origin.resolve_options(ty.clone()), ty.clone())\n+    let options = apply_esm_specific_options(origin.resolve_options(ty.clone()).await?, ty.clone())\n         .resolve()\n         .await?;\n     specific_resolve(origin, request, options, ty, is_optional, issue_source).await\n@@ -109,7 +109,7 @@ pub async fn cjs_resolve(\n ) -> Result<Vc<ModuleResolveResult>> {\n     // TODO pass CommonJsReferenceSubType\n     let ty = ReferenceType::CommonJs(CommonJsReferenceSubType::Undefined);\n-    let options = apply_cjs_specific_options(origin.resolve_options(ty.clone()))\n+    let options = apply_cjs_specific_options(origin.resolve_options(ty.clone()).await?)\n         .resolve()\n         .await?;\n     specific_resolve(origin, request, options, ty, is_optional, issue_source).await\n@@ -124,11 +124,11 @@ pub async fn cjs_resolve_source(\n ) -> Result<Vc<ResolveResult>> {\n     // TODO pass CommonJsReferenceSubType\n     let ty = ReferenceType::CommonJs(CommonJsReferenceSubType::Undefined);\n-    let options = apply_cjs_specific_options(origin.resolve_options(ty.clone()))\n+    let options = apply_cjs_specific_options(origin.resolve_options(ty.clone()).await?)\n         .resolve()\n         .await?;\n     let result = resolve(\n-        origin.origin_path().parent().resolve().await?,\n+        origin.origin_path().await?.parent(),\n         ty.clone(),\n         *request,\n         options,\n@@ -137,7 +137,7 @@ pub async fn cjs_resolve_source(\n     handle_resolve_source_error(\n         result,\n         ty,\n-        origin.origin_path(),\n+        origin.origin_path().await?.clone_value(),\n         *request,\n         options,\n         is_optional,\n@@ -161,7 +161,7 @@ async fn specific_resolve(\n     handle_resolve_error(\n         result,\n         reference_type,\n-        origin.origin_path(),\n+        origin.origin_path().await?.clone_value(),\n         request,\n         options,\n         is_optional,"
        },
        {
            "sha": "1cc4714f51302d1dcade6e3876360301688bcd44",
            "filename": "turbopack/crates/turbopack-resolve/src/node_native_binding.rs",
            "status": "modified",
            "additions": 35,
            "deletions": 39,
            "changes": 74,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Fnode_native_binding.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Fnode_native_binding.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Fnode_native_binding.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -34,7 +34,7 @@ struct NodePreGypConfig {\n #[turbo_tasks::value]\n #[derive(Hash, Clone, Debug)]\n pub struct NodePreGypConfigReference {\n-    pub context_dir: ResolvedVc<FileSystemPath>,\n+    pub context_dir: FileSystemPath,\n     pub config_file_pattern: ResolvedVc<Pattern>,\n     pub compile_target: ResolvedVc<CompileTarget>,\n }\n@@ -43,7 +43,7 @@ pub struct NodePreGypConfigReference {\n impl NodePreGypConfigReference {\n     #[turbo_tasks::function]\n     pub fn new(\n-        context_dir: ResolvedVc<FileSystemPath>,\n+        context_dir: FileSystemPath,\n         config_file_pattern: ResolvedVc<Pattern>,\n         compile_target: ResolvedVc<CompileTarget>,\n     ) -> Vc<Self> {\n@@ -60,7 +60,7 @@ impl ModuleReference for NodePreGypConfigReference {\n     #[turbo_tasks::function]\n     fn resolve_reference(&self) -> Vc<ModuleResolveResult> {\n         resolve_node_pre_gyp_files(\n-            *self.context_dir,\n+            self.context_dir.clone(),\n             *self.config_file_pattern,\n             *self.compile_target,\n         )\n@@ -71,7 +71,7 @@ impl ModuleReference for NodePreGypConfigReference {\n impl ValueToString for NodePreGypConfigReference {\n     #[turbo_tasks::function]\n     async fn to_string(&self) -> Result<Vc<RcStr>> {\n-        let context_dir = self.context_dir.to_string().await?;\n+        let context_dir = self.context_dir.value_to_string().await?;\n         let config_file_pattern = self.config_file_pattern.to_string().await?;\n         let compile_target = self.compile_target.await?;\n         Ok(Vc::cell(\n@@ -83,7 +83,7 @@ impl ValueToString for NodePreGypConfigReference {\n \n #[turbo_tasks::function]\n pub async fn resolve_node_pre_gyp_files(\n-    context_dir: Vc<FileSystemPath>,\n+    context_dir: FileSystemPath,\n     config_file_pattern: Vc<Pattern>,\n     compile_target: Vc<CompileTarget>,\n ) -> Result<Vc<ModuleResolveResult>> {\n@@ -105,8 +105,8 @@ pub async fn resolve_node_pre_gyp_files(\n         && let AssetContent::File(file) = &*config_asset.content().await?\n         && let FileContent::Content(config_file) = &*file.await?\n     {\n-        let config_file_path = config_asset.ident().path();\n-        let mut affecting_paths = vec![config_file_path];\n+        let config_file_path = config_asset.ident().path().await?.clone_value();\n+        let mut affecting_paths = vec![config_file_path.clone()];\n         let config_file_dir = config_file_path.parent();\n         let node_pre_gyp_config: NodePreGypConfigJson =\n             parse_json_rope_with_source_context(config_file.content())?;\n@@ -135,16 +135,16 @@ pub async fn resolve_node_pre_gyp_files(\n \n             // Find all dynamic libraries in the given directory.\n             if let DirectoryContent::Entries(entries) = &*config_file_dir\n-                .join(native_binding_path.clone())\n+                .join(&native_binding_path)?\n                 .read_dir()\n                 .await?\n             {\n                 let extension = compile_target.dylib_ext();\n                 for (key, entry) in entries.iter().filter(|(k, _)| k.ends_with(extension)) {\n-                    if let &DirectoryEntry::File(dylib) | &DirectoryEntry::Symlink(dylib) = entry {\n+                    if let DirectoryEntry::File(dylib) | DirectoryEntry::Symlink(dylib) = entry {\n                         sources.insert(\n                             format!(\"{native_binding_path}/{key}\").into(),\n-                            Vc::upcast(FileSource::new(*dylib)),\n+                            Vc::upcast(FileSource::new(dylib.clone())),\n                         );\n                     }\n                 }\n@@ -155,7 +155,7 @@ pub async fn resolve_node_pre_gyp_files(\n                 native_binding_path, node_pre_gyp_config.binary.module_name\n             )\n             .into();\n-            let resolved_file_vc = config_file_dir.join(node_file_path.clone());\n+            let resolved_file_vc = config_file_dir.join(&node_file_path)?;\n             if *resolved_file_vc.get_type().await? == FileSystemEntryType::File {\n                 sources.insert(\n                     node_file_path,\n@@ -166,26 +166,26 @@ pub async fn resolve_node_pre_gyp_files(\n         if let DirectoryContent::Entries(entries) = &*config_file_dir\n             // TODO\n             // read the dependencies path from `bindings.gyp`\n-            .join(rcstr!(\"deps/lib\"))\n+            .join(\"deps/lib\")?\n             .read_dir()\n             .await?\n         {\n             for (key, entry) in entries.iter() {\n-                match *entry {\n+                match entry {\n                     DirectoryEntry::File(dylib) => {\n                         sources.insert(\n                             format!(\"deps/lib/{key}\").into(),\n-                            Vc::upcast(FileSource::new(*dylib)),\n+                            Vc::upcast(FileSource::new(dylib.clone())),\n                         );\n                     }\n                     DirectoryEntry::Symlink(dylib) => {\n                         let realpath_with_links = dylib.realpath_with_links().await?;\n-                        for &symlink in realpath_with_links.symlinks.iter() {\n-                            affecting_paths.push(*symlink);\n+                        for symlink in realpath_with_links.symlinks.iter() {\n+                            affecting_paths.push(symlink.clone());\n                         }\n                         sources.insert(\n                             format!(\"deps/lib/{key}\").into(),\n-                            Vc::upcast(FileSource::new(*realpath_with_links.path)),\n+                            Vc::upcast(FileSource::new(realpath_with_links.path.clone())),\n                         );\n                     }\n                     _ => {}\n@@ -218,17 +218,14 @@ pub async fn resolve_node_pre_gyp_files(\n #[turbo_tasks::value]\n #[derive(Hash, Clone, Debug)]\n pub struct NodeGypBuildReference {\n-    pub context_dir: ResolvedVc<FileSystemPath>,\n+    pub context_dir: FileSystemPath,\n     pub compile_target: ResolvedVc<CompileTarget>,\n }\n \n #[turbo_tasks::value_impl]\n impl NodeGypBuildReference {\n     #[turbo_tasks::function]\n-    pub fn new(\n-        context_dir: ResolvedVc<FileSystemPath>,\n-        compile_target: ResolvedVc<CompileTarget>,\n-    ) -> Vc<Self> {\n+    pub fn new(context_dir: FileSystemPath, compile_target: ResolvedVc<CompileTarget>) -> Vc<Self> {\n         Self::cell(NodeGypBuildReference {\n             context_dir,\n             compile_target,\n@@ -240,15 +237,15 @@ impl NodeGypBuildReference {\n impl ModuleReference for NodeGypBuildReference {\n     #[turbo_tasks::function]\n     fn resolve_reference(&self) -> Vc<ModuleResolveResult> {\n-        resolve_node_gyp_build_files(*self.context_dir, *self.compile_target)\n+        resolve_node_gyp_build_files(self.context_dir.clone(), *self.compile_target)\n     }\n }\n \n #[turbo_tasks::value_impl]\n impl ValueToString for NodeGypBuildReference {\n     #[turbo_tasks::function]\n     async fn to_string(&self) -> Result<Vc<RcStr>> {\n-        let context_dir = self.context_dir.to_string().await?;\n+        let context_dir = self.context_dir.value_to_string().await?;\n         let compile_target = self.compile_target.await?;\n         Ok(Vc::cell(\n             format!(\"node-gyp in {context_dir} for {compile_target}\").into(),\n@@ -258,7 +255,7 @@ impl ValueToString for NodeGypBuildReference {\n \n #[turbo_tasks::function]\n pub async fn resolve_node_gyp_build_files(\n-    context_dir: Vc<FileSystemPath>,\n+    context_dir: FileSystemPath,\n     compile_target: Vc<CompileTarget>,\n ) -> Result<Vc<ModuleResolveResult>> {\n     // TODO Proper parser\n@@ -267,7 +264,7 @@ pub async fn resolve_node_gyp_build_files(\n             .expect(\"create napi_build_version regex failed\")\n     });\n     let binding_gyp_pat = Pattern::new(Pattern::Constant(rcstr!(\"binding.gyp\")));\n-    let gyp_file = resolve_raw(context_dir, binding_gyp_pat, true);\n+    let gyp_file = resolve_raw(context_dir.clone(), binding_gyp_pat, true);\n     if let [binding_gyp] = &gyp_file.primary_sources().await?[..] {\n         let mut merged_affecting_sources =\n             gyp_file.await?.get_affecting_sources().collect::<Vec<_>>();\n@@ -279,7 +276,7 @@ pub async fn resolve_node_gyp_build_files(\n                 FxIndexMap::with_capacity_and_hasher(captured.len(), Default::default());\n             for found in captured.iter().skip(1).flatten() {\n                 let name = found.as_str();\n-                let target_path = context_dir.join(rcstr!(\"build/Release\"));\n+                let target_path = context_dir.join(\"build/Release\")?;\n                 let resolved_prebuilt_file = resolve_raw(\n                     target_path,\n                     Pattern::new(Pattern::Constant(format!(\"{name}.node\").into())),\n@@ -331,14 +328,14 @@ pub async fn resolve_node_gyp_build_files(\n #[turbo_tasks::value]\n #[derive(Hash, Clone, Debug)]\n pub struct NodeBindingsReference {\n-    pub context_dir: ResolvedVc<FileSystemPath>,\n+    pub context_dir: FileSystemPath,\n     pub file_name: RcStr,\n }\n \n #[turbo_tasks::value_impl]\n impl NodeBindingsReference {\n     #[turbo_tasks::function]\n-    pub fn new(context_dir: ResolvedVc<FileSystemPath>, file_name: RcStr) -> Vc<Self> {\n+    pub fn new(context_dir: FileSystemPath, file_name: RcStr) -> Vc<Self> {\n         Self::cell(NodeBindingsReference {\n             context_dir,\n             file_name,\n@@ -350,7 +347,7 @@ impl NodeBindingsReference {\n impl ModuleReference for NodeBindingsReference {\n     #[turbo_tasks::function]\n     fn resolve_reference(&self) -> Vc<ModuleResolveResult> {\n-        resolve_node_bindings_files(*self.context_dir, self.file_name.clone())\n+        resolve_node_bindings_files(self.context_dir.clone(), self.file_name.clone())\n     }\n }\n \n@@ -359,14 +356,14 @@ impl ValueToString for NodeBindingsReference {\n     #[turbo_tasks::function]\n     async fn to_string(&self) -> Result<Vc<RcStr>> {\n         Ok(Vc::cell(\n-            format!(\"bindings in {}\", self.context_dir.to_string().await?,).into(),\n+            format!(\"bindings in {}\", self.context_dir.value_to_string().await?,).into(),\n         ))\n     }\n }\n \n #[turbo_tasks::function]\n pub async fn resolve_node_bindings_files(\n-    context_dir: Vc<FileSystemPath>,\n+    context_dir: FileSystemPath,\n     file_name: RcStr,\n ) -> Result<Vc<ModuleResolveResult>> {\n     static BINDINGS_TRY: LazyLock<[&'static str; 5]> = LazyLock::new(|| {\n@@ -381,7 +378,7 @@ pub async fn resolve_node_bindings_files(\n     let mut root_context_dir = context_dir;\n     loop {\n         let resolved = resolve_raw(\n-            root_context_dir,\n+            root_context_dir.clone(),\n             Pattern::new(Pattern::Constant(rcstr!(\"package.json\"))),\n             true,\n         )\n@@ -393,23 +390,22 @@ pub async fn resolve_node_bindings_files(\n         {\n             break;\n         };\n-        let current_context = root_context_dir.await?;\n+        let current_context = root_context_dir.clone();\n         let parent = root_context_dir.parent();\n-        let parent_context = parent.await?;\n-        if parent_context.path == current_context.path {\n+        if parent.path == current_context.path {\n             break;\n         }\n         root_context_dir = parent;\n     }\n \n     let try_path = |sub_path: RcStr| async move {\n-        let path = root_context_dir.join(sub_path.clone());\n+        let path = root_context_dir.join(&sub_path)?;\n         Ok(\n             if matches!(*path.get_type().await?, FileSystemEntryType::File) {\n                 Some((\n                     RequestKey::new(sub_path),\n                     ResolvedVc::upcast(\n-                        RawModule::new(Vc::upcast(FileSource::new(path)))\n+                        RawModule::new(Vc::upcast(FileSource::new(path.clone())))\n                             .to_resolved()\n                             .await?,\n                     ),\n@@ -422,7 +418,7 @@ pub async fn resolve_node_bindings_files(\n \n     let modules = BINDINGS_TRY\n         .iter()\n-        .map(|try_dir| try_path(format!(\"{}/{}\", try_dir, &file_name).into()))\n+        .map(|try_dir| try_path.clone()(format!(\"{}/{}\", try_dir, &file_name).into()))\n         .try_flat_join()\n         .await?;\n     Ok(*ModuleResolveResult::modules(modules))"
        },
        {
            "sha": "a983d100d98c6608dd19a8b2341b453256642038",
            "filename": "turbopack/crates/turbopack-resolve/src/resolve.rs",
            "status": "modified",
            "additions": 23,
            "deletions": 19,
            "changes": 42,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Fresolve.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Fresolve.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Fresolve.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -86,17 +86,17 @@ const EDGE_NODE_EXTERNALS: [&str; 5] = [\"buffer\", \"events\", \"assert\", \"util\", \"a\n \n #[turbo_tasks::function]\n async fn base_resolve_options(\n-    resolve_path: Vc<FileSystemPath>,\n+    resolve_path: FileSystemPath,\n     options_context: Vc<ResolveOptionsContext>,\n ) -> Result<Vc<ResolveOptions>> {\n-    let parent = resolve_path.parent().resolve().await?;\n+    let parent = resolve_path.parent();\n     if parent != resolve_path {\n         return Ok(base_resolve_options(parent, options_context));\n     }\n-    let resolve_path_value = resolve_path.await?;\n+    let resolve_path_value = resolve_path.clone();\n     let opt = options_context.await?;\n     let emulating = opt.emulate_environment;\n-    let root = resolve_path_value.fs.root();\n+    let root = resolve_path_value.fs.root().await?.clone_value();\n     let mut direct_mappings = AliasMap::new();\n     let node_externals = if let Some(environment) = emulating {\n         environment.node_externals().owned().await?\n@@ -220,16 +220,19 @@ async fn base_resolve_options(\n         modules: if let Some(environment) = emulating {\n             if *environment.resolve_node_modules().await? {\n                 vec![ResolveModules::Nested(\n-                    root.to_resolved().await?,\n+                    root.clone(),\n                     vec![rcstr!(\"node_modules\")],\n                 )]\n             } else {\n                 Vec::new()\n             }\n         } else {\n             let mut mods = Vec::new();\n-            if let Some(dir) = opt.enable_node_modules {\n-                mods.push(ResolveModules::Nested(dir, vec![rcstr!(\"node_modules\")]));\n+            if let Some(dir) = &opt.enable_node_modules {\n+                mods.push(ResolveModules::Nested(\n+                    dir.clone(),\n+                    vec![rcstr!(\"node_modules\")],\n+                ));\n             }\n             mods\n         },\n@@ -276,42 +279,43 @@ async fn base_resolve_options(\n \n #[turbo_tasks::function]\n pub async fn resolve_options(\n-    resolve_path: Vc<FileSystemPath>,\n+    resolve_path: FileSystemPath,\n     options_context: Vc<ResolveOptionsContext>,\n ) -> Result<Vc<ResolveOptions>> {\n     let options_context_value = options_context.await?;\n     if !options_context_value.rules.is_empty() {\n-        let context_value = &*resolve_path.await?;\n+        let context_value = resolve_path.clone();\n         for (condition, new_options_context) in options_context_value.rules.iter() {\n-            if condition.matches(context_value).await? {\n-                return Ok(resolve_options(resolve_path, **new_options_context));\n+            if condition.matches(&context_value).await? {\n+                return Ok(resolve_options(resolve_path.clone(), **new_options_context));\n             }\n         }\n     }\n \n-    let resolve_options = base_resolve_options(resolve_path, options_context);\n+    let resolve_options = base_resolve_options(resolve_path.clone(), options_context);\n \n     let resolve_options = if options_context_value.enable_typescript {\n         let find_tsconfig = async || {\n             // Otherwise, attempt to find a tsconfig up the file tree\n-            let tsconfig = find_context_file(resolve_path, tsconfig()).await?;\n-            anyhow::Ok::<Vc<ResolveOptions>>(match *tsconfig {\n-                FindContextFileResult::Found(path, _) => {\n-                    apply_tsconfig_resolve_options(resolve_options, tsconfig_resolve_options(*path))\n-                }\n+            let tsconfig = find_context_file(resolve_path.clone(), tsconfig()).await?;\n+            anyhow::Ok::<Vc<ResolveOptions>>(match &*tsconfig {\n+                FindContextFileResult::Found(path, _) => apply_tsconfig_resolve_options(\n+                    resolve_options,\n+                    tsconfig_resolve_options(path.clone()),\n+                ),\n                 FindContextFileResult::NotFound(_) => resolve_options,\n             })\n         };\n \n         // Use a specified tsconfig path if provided. In Next.js, this is always provided by the\n         // default config, at the very least.\n-        if let Some(tsconfig_path) = options_context_value.tsconfig_path {\n+        if let Some(tsconfig_path) = &options_context_value.tsconfig_path {\n             let meta = tsconfig_path.metadata().await;\n             if meta.is_ok() {\n                 // If the file exists, use it.\n                 apply_tsconfig_resolve_options(\n                     resolve_options,\n-                    tsconfig_resolve_options(*tsconfig_path),\n+                    tsconfig_resolve_options(tsconfig_path.clone()),\n                 )\n             } else {\n                 // Otherwise, try and find one."
        },
        {
            "sha": "d58df1e3e6cce8e66e797287da5a59a2d26baa80",
            "filename": "turbopack/crates/turbopack-resolve/src/resolve_options_context.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Fresolve_options_context.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Fresolve_options_context.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Fresolve_options_context.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -30,11 +30,11 @@ pub struct ResolveOptionsContext {\n     #[serde(default)]\n     /// Enable resolving of the node_modules folder when within the provided\n     /// directory\n-    pub enable_node_modules: Option<ResolvedVc<FileSystemPath>>,\n+    pub enable_node_modules: Option<FileSystemPath>,\n     #[serde(default)]\n     /// A specific path to a tsconfig.json file to use for resolving modules. If `None`, one will\n     /// be looked up through the filesystem\n-    pub tsconfig_path: Option<ResolvedVc<FileSystemPath>>,\n+    pub tsconfig_path: Option<FileSystemPath>,\n     #[serde(default)]\n     /// Mark well-known Node.js modules as external imports and load them using\n     /// native `require`. e.g. url, querystring, os"
        },
        {
            "sha": "6fec4f0ac565ee4aae6298e291fa42dc2954d1ef",
            "filename": "turbopack/crates/turbopack-resolve/src/typescript.rs",
            "status": "modified",
            "additions": 33,
            "deletions": 24,
            "changes": 57,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Ftypescript.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Ftypescript.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Ftypescript.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -4,7 +4,7 @@ use anyhow::Result;\n use serde_json::Value as JsonValue;\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{ResolvedVc, ValueDefault, Vc, fxindexset};\n-use turbo_tasks_fs::{FileContent, FileJsonContent, FileSystemPath};\n+use turbo_tasks_fs::{FileContent, FileJsonContent, FileSystemPath, FileSystemPathOption};\n use turbopack_core::{\n     asset::Asset,\n     context::AssetContext,\n@@ -122,7 +122,7 @@ async fn resolve_extends(\n     extends: &str,\n     resolve_options: Vc<ResolveOptions>,\n ) -> Result<Vc<OptionSource>> {\n-    let parent_dir = tsconfig.ident().path().parent();\n+    let parent_dir = tsconfig.ident().path().await?.parent();\n     let request = Request::parse_string(extends.into());\n \n     // TS's resolution is weird, and has special behavior for different import\n@@ -157,7 +157,7 @@ async fn resolve_extends(\n         // All other types are treated as module imports, and potentially joined with\n         // \"tsconfig.json\". This includes \"relative\" imports like '.' and '..'.\n         _ => {\n-            let mut result = resolve(parent_dir, ReferenceType::TypeScript(TypeScriptReferenceSubType::Undefined), request, resolve_options).first_source();\n+            let mut result = resolve(parent_dir.clone(), ReferenceType::TypeScript(TypeScriptReferenceSubType::Undefined), request, resolve_options).first_source();\n             if result.await?.is_none() {\n                 let request = Request::parse_string(format!(\"{extends}/tsconfig\").into());\n                 result = resolve(parent_dir, ReferenceType::TypeScript(TypeScriptReferenceSubType::Undefined), request, resolve_options).first_source();\n@@ -168,13 +168,13 @@ async fn resolve_extends(\n }\n \n async fn resolve_extends_rooted_or_relative(\n-    lookup_path: Vc<FileSystemPath>,\n+    lookup_path: FileSystemPath,\n     request: Vc<Request>,\n     resolve_options: Vc<ResolveOptions>,\n     path: &str,\n ) -> Result<Vc<OptionSource>> {\n     let mut result = resolve(\n-        lookup_path,\n+        lookup_path.clone(),\n         ReferenceType::TypeScript(TypeScriptReferenceSubType::Undefined),\n         request,\n         resolve_options,\n@@ -187,7 +187,7 @@ async fn resolve_extends_rooted_or_relative(\n     if !path.ends_with(\".json\") && result.await?.is_none() {\n         let request = Request::parse_string(format!(\"{path}.json\").into());\n         result = resolve(\n-            lookup_path,\n+            lookup_path.clone(),\n             ReferenceType::TypeScript(TypeScriptReferenceSubType::Undefined),\n             request,\n             resolve_options,\n@@ -215,7 +215,7 @@ pub async fn read_from_tsconfigs<T>(\n #[turbo_tasks::value]\n #[derive(Default)]\n pub struct TsConfigResolveOptions {\n-    base_url: Option<ResolvedVc<FileSystemPath>>,\n+    base_url: Option<FileSystemPath>,\n     import_map: Option<ResolvedVc<ImportMap>>,\n     is_module_resolution_nodenext: bool,\n }\n@@ -228,15 +228,25 @@ impl ValueDefault for TsConfigResolveOptions {\n     }\n }\n \n+#[turbo_tasks::function]\n+async fn try_join_base_url(\n+    source: ResolvedVc<Box<dyn Source>>,\n+    base_url: RcStr,\n+) -> Result<Vc<FileSystemPathOption>> {\n+    Ok(Vc::cell(\n+        source.ident().path().await?.parent().try_join(&base_url)?,\n+    ))\n+}\n+\n /// Returns the resolve options\n #[turbo_tasks::function]\n pub async fn tsconfig_resolve_options(\n-    tsconfig: Vc<FileSystemPath>,\n+    tsconfig: FileSystemPath,\n ) -> Result<Vc<TsConfigResolveOptions>> {\n     let configs = read_tsconfigs(\n         tsconfig.read(),\n-        ResolvedVc::upcast(FileSource::new(tsconfig).to_resolved().await?),\n-        node_cjs_resolve_options(tsconfig.root()),\n+        ResolvedVc::upcast(FileSource::new(tsconfig.clone()).to_resolved().await?),\n+        node_cjs_resolve_options(tsconfig.root().await?.clone_value()),\n     )\n     .await?;\n \n@@ -247,11 +257,11 @@ pub async fn tsconfig_resolve_options(\n     let base_url = if let Some(base_url) = read_from_tsconfigs(&configs, |json, source| {\n         json[\"compilerOptions\"][\"baseUrl\"]\n             .as_str()\n-            .map(|base_url| source.ident().path().parent().try_join(base_url.into()))\n+            .map(|base_url| try_join_base_url(*source, base_url.into()))\n     })\n     .await?\n     {\n-        *base_url.await?\n+        (*base_url.await?).clone()\n     } else {\n         None\n     };\n@@ -261,13 +271,13 @@ pub async fn tsconfig_resolve_options(\n         if let FileJsonContent::Content(json) = &*content.await?\n             && let JsonValue::Object(paths) = &json[\"compilerOptions\"][\"paths\"]\n         {\n-            let mut context_dir = source.ident().path().parent();\n+            let mut context_dir = source.ident().path().await?.parent();\n             if let Some(base_url) = json[\"compilerOptions\"][\"baseUrl\"].as_str()\n-                && let Some(new_context) = *context_dir.try_join(base_url.into()).await?\n+                && let Some(new_context) = context_dir.try_join(base_url)?\n             {\n-                context_dir = *new_context;\n+                context_dir = new_context;\n             };\n-            let context_dir = context_dir.to_resolved().await?;\n+            let context_dir = context_dir.clone();\n             for (key, value) in paths.iter() {\n                 if let JsonValue::Array(vec) = value {\n                     let entries = vec\n@@ -291,7 +301,7 @@ pub async fn tsconfig_resolve_options(\n                         .collect();\n                     all_paths.insert(\n                         key.to_string(),\n-                        ImportMapping::primary_alternatives(entries, Some(context_dir)),\n+                        ImportMapping::primary_alternatives(entries, Some(context_dir.clone())),\n                     );\n                 } else {\n                     TsConfigIssue {\n@@ -350,13 +360,13 @@ pub async fn apply_tsconfig_resolve_options(\n ) -> Result<Vc<ResolveOptions>> {\n     let tsconfig_resolve_options = tsconfig_resolve_options.await?;\n     let mut resolve_options = resolve_options.owned().await?;\n-    if let Some(base_url) = tsconfig_resolve_options.base_url {\n+    if let Some(base_url) = &tsconfig_resolve_options.base_url {\n         // We want to resolve in `compilerOptions.baseUrl` first, then in other\n         // locations as a fallback.\n         resolve_options.modules.insert(\n             0,\n             ResolveModules::Path {\n-                dir: base_url,\n+                dir: base_url.clone(),\n                 // tsconfig basepath doesn't apply to json requests\n                 excluded_extensions: ResolvedVc::cell(fxindexset![rcstr!(\".json\")]),\n             },\n@@ -384,8 +394,8 @@ pub async fn type_resolve(\n     request: Vc<Request>,\n ) -> Result<Vc<ModuleResolveResult>> {\n     let ty = ReferenceType::TypeScript(TypeScriptReferenceSubType::Undefined);\n-    let context_path = origin.origin_path().parent();\n-    let options = origin.resolve_options(ty.clone());\n+    let context_path = origin.origin_path().await?.parent();\n+    let options = origin.resolve_options(ty.clone()).await?;\n     let options = apply_typescript_types_options(options);\n     let types_request = if let Request::Module {\n         module: m,\n@@ -408,10 +418,9 @@ pub async fn type_resolve(\n     } else {\n         None\n     };\n-    let context_path = context_path.resolve().await?;\n     let result = if let Some(types_request) = types_request {\n         let result1 = resolve(\n-            context_path,\n+            context_path.clone(),\n             ReferenceType::TypeScript(TypeScriptReferenceSubType::Undefined),\n             request,\n             options,\n@@ -442,7 +451,7 @@ pub async fn type_resolve(\n     handle_resolve_error(\n         result,\n         ty,\n-        origin.origin_path(),\n+        origin.origin_path().await?.clone_value(),\n         request,\n         options,\n         false,"
        },
        {
            "sha": "eb75149e9b50b22c3a0e969fa3fc89c5f2fa3ddb",
            "filename": "turbopack/crates/turbopack-static/src/ecma.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-static%2Fsrc%2Fecma.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-static%2Fsrc%2Fecma.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-static%2Fsrc%2Fecma.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -137,7 +137,7 @@ impl EcmascriptChunkItem for StaticUrlJsChunkItem {\n                 path = StringifyJs(\n                     &self\n                         .chunking_context\n-                        .asset_url(self.static_asset.path())\n+                        .asset_url(self.static_asset.path().await?.clone_value())\n                         .await?\n                 )\n             )"
        },
        {
            "sha": "9ebaa041d0e401f5e7d2204a6ff8aa9a729dc861",
            "filename": "turbopack/crates/turbopack-static/src/fixed.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 6,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-static%2Fsrc%2Ffixed.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-static%2Fsrc%2Ffixed.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-static%2Fsrc%2Ffixed.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -10,17 +10,14 @@ use turbopack_core::{\n /// content hashing to generate a long term cacheable URL.\n #[turbo_tasks::value]\n pub struct FixedStaticAsset {\n-    output_path: ResolvedVc<FileSystemPath>,\n+    output_path: FileSystemPath,\n     source: ResolvedVc<Box<dyn Source>>,\n }\n \n #[turbo_tasks::value_impl]\n impl FixedStaticAsset {\n     #[turbo_tasks::function]\n-    pub fn new(\n-        output_path: ResolvedVc<FileSystemPath>,\n-        source: ResolvedVc<Box<dyn Source>>,\n-    ) -> Vc<Self> {\n+    pub fn new(output_path: FileSystemPath, source: ResolvedVc<Box<dyn Source>>) -> Vc<Self> {\n         FixedStaticAsset {\n             output_path,\n             source,\n@@ -33,7 +30,7 @@ impl FixedStaticAsset {\n impl OutputAsset for FixedStaticAsset {\n     #[turbo_tasks::function]\n     fn path(&self) -> Vc<FileSystemPath> {\n-        *self.output_path\n+        self.output_path.clone().cell()\n     }\n }\n "
        },
        {
            "sha": "1c6fe3b0c4f18358cbcfb680bad965c9a81e7371",
            "filename": "turbopack/crates/turbopack-test-utils/src/snapshot.rs",
            "status": "modified",
            "additions": 27,
            "deletions": 27,
            "changes": 54,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-test-utils%2Fsrc%2Fsnapshot.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-test-utils%2Fsrc%2Fsnapshot.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-test-utils%2Fsrc%2Fsnapshot.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -6,7 +6,7 @@ use regex::Regex;\n use rustc_hash::{FxHashMap, FxHashSet};\n use similar::TextDiff;\n use turbo_rcstr::RcStr;\n-use turbo_tasks::{ReadRef, TryJoinIterExt, ValueToString, Vc};\n+use turbo_tasks::{ReadRef, TryJoinIterExt, Vc};\n use turbo_tasks_fs::{\n     DirectoryContent, DirectoryEntry, File, FileContent, FileSystemEntryType, FileSystemPath,\n };\n@@ -25,10 +25,10 @@ static ANSI_REGEX: Lazy<Regex> = Lazy::new(|| Regex::new(r\"\\x1b\\[\\d+m\").unwrap()\n \n pub async fn snapshot_issues<I: IntoIterator<Item = ReadRef<PlainIssue>>>(\n     captured_issues: I,\n-    issues_path: Vc<FileSystemPath>,\n+    issues_path: FileSystemPath,\n     workspace_root: &str,\n ) -> Result<()> {\n-    let expected_issues = expected(issues_path).await?;\n+    let expected_issues = expected(issues_path.clone()).await?;\n     let mut seen = FxHashSet::default();\n     for plain_issue in captured_issues.into_iter() {\n         let title = styled_string_to_file_safe_string(&plain_issue.title)\n@@ -45,8 +45,8 @@ pub async fn snapshot_issues<I: IntoIterator<Item = ReadRef<PlainIssue>>>(\n         };\n         let hash = encode_hex(plain_issue.internal_hash_ref(true));\n \n-        let path = issues_path.join(format!(\"{title}-{}.txt\", &hash[0..6]).into());\n-        if !seen.insert(path) {\n+        let path = issues_path.join(&format!(\"{title}-{}.txt\", &hash[0..6]))?;\n+        if !seen.insert(path.clone()) {\n             continue;\n         }\n \n@@ -63,7 +63,7 @@ pub async fn snapshot_issues<I: IntoIterator<Item = ReadRef<PlainIssue>>>(\n         );\n \n         // Annoyingly, the PlainIssue.source -> PlainIssueSource.asset ->\n-        // PlainSource.path -> FileSystemPath.fs -> DiskFileSystem.root changes\n+        // PlainSource.path -> Vc<FileSystemPath>.fs -> DiskFileSystem.root changes\n         // for everyone.\n         let content: RcStr = formatted\n             .as_str()\n@@ -81,14 +81,14 @@ pub async fn snapshot_issues<I: IntoIterator<Item = ReadRef<PlainIssue>>>(\n     matches_expected(expected_issues, seen).await\n }\n \n-pub async fn expected(dir: Vc<FileSystemPath>) -> Result<FxHashSet<Vc<FileSystemPath>>> {\n+pub async fn expected(dir: FileSystemPath) -> Result<FxHashSet<FileSystemPath>> {\n     let mut expected = FxHashSet::default();\n     let entries = dir.read_dir().await?;\n     if let DirectoryContent::Entries(entries) = &*entries {\n         for (file, entry) in entries {\n             match entry {\n                 DirectoryEntry::File(file) => {\n-                    expected.insert(**file);\n+                    expected.insert(file.clone());\n                 }\n                 _ => bail!(\n                     \"expected file at {}, found {:?}\",\n@@ -102,13 +102,13 @@ pub async fn expected(dir: Vc<FileSystemPath>) -> Result<FxHashSet<Vc<FileSystem\n }\n \n pub async fn matches_expected(\n-    expected: FxHashSet<Vc<FileSystemPath>>,\n-    seen: FxHashSet<Vc<FileSystemPath>>,\n+    expected: FxHashSet<FileSystemPath>,\n+    seen: FxHashSet<FileSystemPath>,\n ) -> Result<()> {\n     for path in diff_paths(&expected, &seen).await? {\n-        let p = &path.await?.path;\n+        let p = &path.path;\n         if *UPDATE {\n-            remove_file(path).await?;\n+            remove_file(path.clone()).await?;\n             println!(\"removed file {p}\");\n         } else {\n             bail!(\"expected file {}, but it was not emitted\", p);\n@@ -117,12 +117,12 @@ pub async fn matches_expected(\n     Ok(())\n }\n \n-pub async fn diff(path: Vc<FileSystemPath>, actual: Vc<AssetContent>) -> Result<()> {\n-    let path_str = &path.await?.path;\n+pub async fn diff(path: FileSystemPath, actual: Vc<AssetContent>) -> Result<()> {\n+    let path_str = &path.path;\n     let expected = AssetContent::file(path.read());\n \n-    let actual = get_contents(actual, path).await?;\n-    let expected = get_contents(expected, path).await?;\n+    let actual = get_contents(actual, path.clone()).await?;\n+    let expected = get_contents(expected, path.clone()).await?;\n \n     if actual != expected {\n         if let Some(actual) = actual {\n@@ -154,15 +154,15 @@ pub async fn diff(path: Vc<FileSystemPath>, actual: Vc<AssetContent>) -> Result<\n     Ok(())\n }\n \n-async fn get_contents(file: Vc<AssetContent>, path: Vc<FileSystemPath>) -> Result<Option<String>> {\n+async fn get_contents(file: Vc<AssetContent>, path: FileSystemPath) -> Result<Option<String>> {\n     Ok(\n         match &*file.await.context(format!(\n             \"Unable to read AssetContent of {}\",\n-            path.to_string().await?\n+            path.value_to_string().await?\n         ))? {\n             AssetContent::File(file) => match &*file.await.context(format!(\n                 \"Unable to read FileContent of {}\",\n-                path.to_string().await?\n+                path.value_to_string().await?\n             ))? {\n                 FileContent::NotFound => None,\n                 FileContent::Content(expected) => {\n@@ -184,30 +184,30 @@ async fn get_contents(file: Vc<AssetContent>, path: Vc<FileSystemPath>) -> Resul\n     )\n }\n \n-async fn remove_file(path: Vc<FileSystemPath>) -> Result<()> {\n+async fn remove_file(path: FileSystemPath) -> Result<()> {\n     path.write(FileContent::NotFound.cell()).await?;\n     Ok(())\n }\n \n /// Values in left that are not in right.\n-/// Vc<FileSystemPath> hashes as a Vc, not as the file path, so we need to get\n+/// FileSystemPath hashes as a Vc, not as the file path, so we need to get\n /// the path to properly diff.\n async fn diff_paths(\n-    left: &FxHashSet<Vc<FileSystemPath>>,\n-    right: &FxHashSet<Vc<FileSystemPath>>,\n-) -> Result<FxHashSet<Vc<FileSystemPath>>> {\n+    left: &FxHashSet<FileSystemPath>,\n+    right: &FxHashSet<FileSystemPath>,\n+) -> Result<FxHashSet<FileSystemPath>> {\n     let mut map = left\n         .iter()\n-        .map(|p| async move { Ok((p.await?.path.clone(), *p)) })\n+        .map(|p| async move { Ok((p.path.clone(), p.clone())) })\n         .try_join()\n         .await?\n         .iter()\n         .cloned()\n         .collect::<FxHashMap<_, _>>();\n     for p in right {\n-        map.remove(&p.await?.path);\n+        map.remove(&p.path);\n     }\n-    Ok(map.values().copied().collect())\n+    Ok(map.values().cloned().collect())\n }\n \n fn styled_string_to_file_safe_string(styled_string: &StyledString) -> String {"
        },
        {
            "sha": "eda091d933ce7da5afa32b0ebb1a060d701e011a",
            "filename": "turbopack/crates/turbopack-tests/tests/execution.rs",
            "status": "modified",
            "additions": 34,
            "deletions": 38,
            "changes": 72,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -61,7 +61,7 @@ use crate::util::REPO_ROOT;\n #[turbo_tasks::value]\n struct RunTestResult {\n     js_result: ResolvedVc<JsResult>,\n-    path: ResolvedVc<FileSystemPath>,\n+    path: FileSystemPath,\n }\n \n #[turbo_tasks::value]\n@@ -250,10 +250,10 @@ struct TestOptions {\n \n #[turbo_tasks::value]\n struct PreparedTest {\n-    path: ResolvedVc<FileSystemPath>,\n-    project_path: ResolvedVc<FileSystemPath>,\n-    tests_path: ResolvedVc<FileSystemPath>,\n-    project_root: ResolvedVc<FileSystemPath>,\n+    path: FileSystemPath,\n+    project_path: FileSystemPath,\n+    tests_path: FileSystemPath,\n+    project_root: FileSystemPath,\n     options: TestOptions,\n }\n \n@@ -269,21 +269,22 @@ async fn prepare_test(resource: RcStr) -> Result<Vc<PreparedTest>> {\n \n     let root_fs = DiskFileSystem::new(rcstr!(\"workspace\"), REPO_ROOT.clone(), vec![]);\n     let project_fs = DiskFileSystem::new(rcstr!(\"project\"), REPO_ROOT.clone(), vec![]);\n-    let project_root = project_fs.root().to_resolved().await?;\n+    let project_root = project_fs.root().await?.clone_value();\n \n     let relative_path = resource_path.strip_prefix(&*REPO_ROOT).context(format!(\n         \"stripping repo root {:?} from resource path {:?}\",\n         &*REPO_ROOT,\n         resource_path.display()\n     ))?;\n     let relative_path: RcStr = sys_to_unix(relative_path.to_str().unwrap()).into();\n-    let path = root_fs.root().join(relative_path.clone());\n-    let project_path = project_root.join(relative_path.clone());\n+    let path = root_fs.root().await?.join(&relative_path.clone())?;\n+    let project_path = project_root.join(&relative_path.clone())?;\n     let tests_path = project_fs\n         .root()\n-        .join(rcstr!(\"turbopack/crates/turbopack-tests\"));\n+        .await?\n+        .join(\"turbopack/crates/turbopack-tests\")?;\n \n-    let options_file = path.join(rcstr!(\"options.json\"));\n+    let options_file = path.join(\"options.json\")?;\n \n     let mut options = TestOptions::default();\n     if matches!(*options_file.get_type().await?, FileSystemEntryType::File)\n@@ -294,9 +295,9 @@ async fn prepare_test(resource: RcStr) -> Result<Vc<PreparedTest>> {\n     }\n \n     Ok(PreparedTest {\n-        path: path.to_resolved().await?,\n-        project_path: project_path.to_resolved().await?,\n-        tests_path: tests_path.to_resolved().await?,\n+        path: path.clone(),\n+        project_path: project_path.clone(),\n+        tests_path: tests_path.clone(),\n         project_root,\n         options,\n     }\n@@ -310,19 +311,18 @@ async fn run_test_operation(prepared_test: ResolvedVc<PreparedTest>) -> Result<V\n         project_path,\n         tests_path,\n         project_root,\n-        ref options,\n-    } = *prepared_test.await?;\n+        options,\n+    } = &*prepared_test.await?;\n \n-    let jest_entry_path = tests_path.join(rcstr!(\"js/jest-entry.ts\"));\n-    let test_path = project_path.join(rcstr!(\"input/index.js\"));\n+    let jest_entry_path = tests_path.join(\"js/jest-entry.ts\")?;\n+    let test_path = project_path.join(\"input/index.js\")?;\n \n-    let chunk_root_path = path.join(rcstr!(\"output\")).to_resolved().await?;\n-    let static_root_path = path.join(rcstr!(\"static\")).to_resolved().await?;\n+    let chunk_root_path = path.join(\"output\")?;\n+    let static_root_path = path.join(\"static\")?;\n \n     let chunk_root_path_in_root_path_offset = project_path\n-        .join(rcstr!(\"output\"))\n-        .await?\n-        .get_relative_path_to(&*project_root.await?)\n+        .join(\"output\")?\n+        .get_relative_path_to(project_root)\n         .context(\"Project path is in root path\")?;\n \n     let env = Environment::new(ExecutionEnvironment::NodeJsBuildTime(\n@@ -394,12 +394,12 @@ async fn run_test_operation(prepared_test: ResolvedVc<PreparedTest>) -> Result<V\n         .into(),\n         ResolveOptionsContext {\n             enable_typescript: true,\n-            enable_node_modules: Some(project_root),\n+            enable_node_modules: Some(project_root.clone()),\n             custom_conditions: vec![rcstr!(\"development\")],\n             rules: vec![(\n                 ContextCondition::InDirectory(\"node_modules\".into()),\n                 ResolveOptionsContext {\n-                    enable_node_modules: Some(project_root),\n+                    enable_node_modules: Some(project_root.clone()),\n                     custom_conditions: vec![rcstr!(\"development\")],\n                     browser: true,\n                     ..Default::default()\n@@ -416,10 +416,10 @@ async fn run_test_operation(prepared_test: ResolvedVc<PreparedTest>) -> Result<V\n     ));\n \n     let chunking_context = NodeJsChunkingContext::builder(\n-        project_root,\n-        chunk_root_path,\n+        project_root.clone(),\n+        chunk_root_path.clone(),\n         chunk_root_path_in_root_path_offset,\n-        static_root_path,\n+        static_root_path.clone(),\n         chunk_root_path,\n         static_root_path,\n         env,\n@@ -472,7 +472,7 @@ async fn run_test_operation(prepared_test: ResolvedVc<PreparedTest>) -> Result<V\n \n     let res = evaluate(\n         jest_entry_asset,\n-        *path,\n+        path.clone(),\n         Vc::upcast(CommandLineProcessEnv::new()),\n         test_source.ident(),\n         asset_context,\n@@ -499,14 +499,14 @@ async fn run_test_operation(prepared_test: ResolvedVc<PreparedTest>) -> Result<V\n                 },\n             }\n             .resolved_cell(),\n-            path,\n+            path: path.clone(),\n         }\n         .cell());\n     };\n \n     Ok(RunTestResult {\n         js_result: JsResult::resolved_cell(parse_json_with_source_context(bytes.to_str()?)?),\n-        path,\n+        path: path.clone(),\n     }\n     .cell())\n }\n@@ -516,20 +516,16 @@ async fn snapshot_issues(\n     prepared_test: Vc<PreparedTest>,\n     run_result_op: OperationVc<RunTestResult>,\n ) -> Result<Vc<()>> {\n-    let PreparedTest { path, .. } = *prepared_test.await?;\n+    let PreparedTest { path, .. } = &*prepared_test.await?;\n     let _ = run_result_op.resolve_strongly_consistent().await;\n \n     let captured_issues = run_result_op.peek_issues_with_path().await?;\n \n     let plain_issues = captured_issues.get_plain_issues().await?;\n \n-    turbopack_test_utils::snapshot::snapshot_issues(\n-        plain_issues,\n-        path.join(rcstr!(\"issues\")),\n-        &REPO_ROOT,\n-    )\n-    .await\n-    .context(\"Unable to handle issues\")?;\n+    turbopack_test_utils::snapshot::snapshot_issues(plain_issues, path.join(\"issues\")?, &REPO_ROOT)\n+        .await\n+        .context(\"Unable to handle issues\")?;\n \n     Ok(Default::default())\n }"
        },
        {
            "sha": "fdd313c644b598af85d68f39bacd4ca278ffe69a",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot.rs",
            "status": "modified",
            "additions": 40,
            "deletions": 51,
            "changes": 91,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -11,9 +11,7 @@ use rustc_hash::FxHashSet;\n use serde::Deserialize;\n use serde_json::json;\n use turbo_rcstr::{RcStr, rcstr};\n-use turbo_tasks::{\n-    ReadConsistency, ReadRef, ResolvedVc, TurboTasks, ValueToString, Vc, apply_effects,\n-};\n+use turbo_tasks::{ReadConsistency, ResolvedVc, TurboTasks, ValueToString, Vc, apply_effects};\n use turbo_tasks_backend::{BackendOptions, TurboTasksBackend, noop_backing_storage};\n use turbo_tasks_env::DotenvProcessEnv;\n use turbo_tasks_fs::{\n@@ -191,12 +189,16 @@ async fn run(resource: PathBuf) -> Result<()> {\n #[turbo_tasks::function(operation)]\n async fn run_inner_operation(resource: RcStr) -> Result<()> {\n     let out_op = run_test_operation(resource);\n-    let out_vc = out_op.resolve_strongly_consistent().await?;\n+    let out_vc = out_op\n+        .resolve_strongly_consistent()\n+        .await?\n+        .await?\n+        .clone_value();\n     let captured_issues = out_op.peek_issues_with_path().await?;\n \n     let plain_issues = captured_issues.get_plain_issues().await?;\n \n-    snapshot_issues(plain_issues, out_vc.join(rcstr!(\"issues\")), &REPO_ROOT)\n+    snapshot_issues(plain_issues, out_vc.join(\"issues\")?, &REPO_ROOT)\n         .await\n         .context(\"Unable to handle issues\")?;\n \n@@ -219,21 +221,17 @@ async fn run_test_operation(resource: RcStr) -> Result<Vc<FileSystemPath>> {\n         Ok(options_str) => parse_json_with_source_context(&options_str).unwrap(),\n     };\n     let project_fs = DiskFileSystem::new(rcstr!(\"project\"), REPO_ROOT.clone(), vec![]);\n-    let project_root = project_fs.root().to_resolved().await?;\n+    let project_root = project_fs.root().await?.clone_value();\n \n     let relative_path = test_path.strip_prefix(&*REPO_ROOT)?;\n     let relative_path: RcStr = sys_to_unix(relative_path.to_str().unwrap()).into();\n-    let project_path = project_root\n-        .join(relative_path.clone())\n-        .to_resolved()\n-        .await?;\n+    let project_path = project_root.join(&relative_path)?;\n \n     let project_path_to_project_root = project_path\n-        .await?\n-        .get_relative_path_to(&*project_root.await?)\n+        .get_relative_path_to(&project_root)\n         .context(\"Project path is in root path\")?;\n \n-    let entry_asset = project_path.join(options.entry.into());\n+    let entry_asset = project_path.join(&options.entry)?;\n \n     let env = Environment::new(match options.environment {\n         SnapshotEnvironment::Browser => {\n@@ -333,12 +331,12 @@ async fn run_test_operation(resource: RcStr) -> Result<Vc<FileSystemPath>> {\n         ResolveOptionsContext {\n             enable_typescript: true,\n             enable_react: true,\n-            enable_node_modules: Some(project_root),\n+            enable_node_modules: Some(project_root.clone()),\n             custom_conditions: vec![rcstr!(\"development\")],\n             rules: vec![(\n                 ContextCondition::InDirectory(\"node_modules\".into()),\n                 ResolveOptionsContext {\n-                    enable_node_modules: Some(project_root),\n+                    enable_node_modules: Some(project_root.clone()),\n                     custom_conditions: vec![rcstr!(\"development\")],\n                     ..Default::default()\n                 }\n@@ -350,22 +348,22 @@ async fn run_test_operation(resource: RcStr) -> Result<Vc<FileSystemPath>> {\n         Layer::new(rcstr!(\"test\")),\n     ));\n \n-    let runtime_entries = maybe_load_env(asset_context, *project_path)\n+    let runtime_entries = maybe_load_env(asset_context, project_path.clone())\n         .await?\n         .map(|asset| EvaluatableAssets::one(asset.to_evaluatable(asset_context)));\n \n-    let chunk_root_path = project_path.join(rcstr!(\"output\")).to_resolved().await?;\n-    let static_root_path = project_path.join(rcstr!(\"static\")).to_resolved().await?;\n+    let chunk_root_path = project_path.join(\"output\")?;\n+    let static_root_path = project_path.join(\"static\")?;\n \n     let chunking_context: Vc<Box<dyn ChunkingContext>> = match options.runtime {\n         Runtime::Browser => {\n             let mut builder = BrowserChunkingContext::builder(\n                 project_root,\n-                project_path,\n+                project_path.clone(),\n                 project_path_to_project_root,\n-                project_path,\n-                chunk_root_path,\n-                static_root_path,\n+                project_path.clone(),\n+                chunk_root_path.clone(),\n+                static_root_path.clone(),\n                 env,\n                 options.runtime_type,\n             )\n@@ -387,11 +385,11 @@ async fn run_test_operation(resource: RcStr) -> Result<Vc<FileSystemPath>> {\n         Runtime::NodeJs => {\n             let mut builder = NodeJsChunkingContext::builder(\n                 project_root,\n-                project_path,\n+                project_path.clone(),\n                 project_path_to_project_root,\n-                project_path,\n-                chunk_root_path,\n-                static_root_path,\n+                project_path.clone(),\n+                chunk_root_path.clone(),\n+                static_root_path.clone(),\n                 env,\n                 options.runtime_type,\n             )\n@@ -413,10 +411,10 @@ async fn run_test_operation(resource: RcStr) -> Result<Vc<FileSystemPath>> {\n         }\n     };\n \n-    let expected_paths = expected(*chunk_root_path)\n+    let expected_paths = expected(chunk_root_path.clone())\n         .await?\n-        .union(&expected(*static_root_path).await?)\n-        .copied()\n+        .union(&expected(static_root_path.clone()).await?)\n+        .cloned()\n         .collect();\n \n     let entry_module = asset_context\n@@ -458,17 +456,8 @@ async fn run_test_operation(resource: RcStr) -> Result<Vc<FileSystemPath>> {\n                         .entry_chunk_group(\n                             // `expected` expects a completely flat output directory.\n                             chunk_root_path\n-                                .join(\n-                                    entry_module\n-                                        .ident()\n-                                        .path()\n-                                        .file_stem()\n-                                        .await?\n-                                        .as_deref()\n-                                        .unwrap()\n-                                        .into(),\n-                                )\n-                                .with_extension(rcstr!(\"entry.js\")),\n+                                .join(entry_module.ident().path().await?.file_stem().unwrap())?\n+                                .with_extension(\"entry.js\"),\n                             evaluatable_assets,\n                             module_graph,\n                             OutputAssets::empty(),\n@@ -487,7 +476,7 @@ async fn run_test_operation(resource: RcStr) -> Result<Vc<FileSystemPath>> {\n     let mut seen = FxHashSet::default();\n     let mut queue: VecDeque<_> = chunks.await?.iter().copied().collect();\n \n-    let output_path = project_path.await?;\n+    let output_path = project_path.clone();\n     while let Some(asset) = queue.pop_front() {\n         walk_asset(asset, &output_path, &mut seen, &mut queue)\n             .await\n@@ -501,24 +490,24 @@ async fn run_test_operation(resource: RcStr) -> Result<Vc<FileSystemPath>> {\n         .await\n         .context(\"Actual assets doesn't match with expected assets\")?;\n \n-    Ok(*project_path)\n+    Ok(project_path.cell())\n }\n \n async fn walk_asset(\n     asset: ResolvedVc<Box<dyn OutputAsset>>,\n-    output_path: &ReadRef<FileSystemPath>,\n-    seen: &mut FxHashSet<Vc<FileSystemPath>>,\n+    output_path: &FileSystemPath,\n+    seen: &mut FxHashSet<FileSystemPath>,\n     queue: &mut VecDeque<ResolvedVc<Box<dyn OutputAsset>>>,\n ) -> Result<()> {\n-    let path = asset.path().resolve().await?;\n+    let path = asset.path().await?.clone_value();\n \n-    if !seen.insert(path) {\n+    if !seen.insert(path.clone()) {\n         return Ok(());\n     }\n \n-    if path.await?.is_inside_ref(output_path) {\n+    if path.is_inside_ref(output_path) {\n         // Only consider assets that should be written to disk.\n-        diff(path, asset.content()).await?;\n+        diff(path.clone(), asset.content()).await?;\n     }\n \n     queue.extend(\n@@ -535,15 +524,15 @@ async fn walk_asset(\n \n async fn maybe_load_env(\n     _context: Vc<Box<dyn AssetContext>>,\n-    path: Vc<FileSystemPath>,\n+    path: FileSystemPath,\n ) -> Result<Option<Vc<Box<dyn Source>>>> {\n-    let dotenv_path = path.join(rcstr!(\"input/.env\"));\n+    let dotenv_path = path.join(\"input/.env\")?;\n \n     if !dotenv_path.read().await?.is_content() {\n         return Ok(None);\n     }\n \n-    let env = DotenvProcessEnv::new(None, dotenv_path);\n+    let env = DotenvProcessEnv::new(None, dotenv_path.clone());\n     let asset = ProcessEnvAsset::new(dotenv_path, Vc::upcast(env));\n     Ok(Some(Vc::upcast(asset)))\n }"
        },
        {
            "sha": "f74651aae879ccc7a0b3d32b394814748764f600",
            "filename": "turbopack/crates/turbopack-wasm/src/loader.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-wasm%2Fsrc%2Floader.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-wasm%2Fsrc%2Floader.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-wasm%2Fsrc%2Floader.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -2,7 +2,7 @@ use std::fmt::Write;\n \n use anyhow::Result;\n use indoc::{formatdoc, writedoc};\n-use turbo_rcstr::{RcStr, rcstr};\n+use turbo_rcstr::RcStr;\n use turbo_tasks::Vc;\n use turbo_tasks_fs::File;\n use turbopack_core::{asset::AssetContent, source::Source, virtual_source::VirtualSource};\n@@ -56,7 +56,7 @@ pub(crate) async fn instantiating_loader_source(\n     let code: RcStr = code.into();\n \n     Ok(Vc::upcast(VirtualSource::new(\n-        source.ident().path().append(rcstr!(\"_.loader.mjs\")),\n+        source.ident().path().await?.append(\"_.loader.mjs\")?,\n         AssetContent::file(File::from(code).into()),\n     )))\n }\n@@ -80,7 +80,7 @@ pub(crate) async fn compiling_loader_source(\n     .into();\n \n     Ok(Vc::upcast(VirtualSource::new(\n-        source.ident().path().append(rcstr!(\"_.loader.mjs\")),\n+        source.ident().path().await?.append(\"_.loader.mjs\")?,\n         AssetContent::file(File::from(code).into()),\n     )))\n }"
        },
        {
            "sha": "bda03b3ef14cbab916f40a97d60bc3d9ce79477d",
            "filename": "turbopack/crates/turbopack-wasm/src/source.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 5,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-wasm%2Fsrc%2Fsource.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack-wasm%2Fsrc%2Fsource.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-wasm%2Fsrc%2Fsource.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -1,6 +1,5 @@\n use anyhow::Result;\n use serde::{Deserialize, Serialize};\n-use turbo_rcstr::rcstr;\n use turbo_tasks::{NonLocalValue, ResolvedVc, TaskInput, Vc, trace::TraceRawVcs};\n use turbo_tasks_fs::{File, FileContent};\n use turbopack_core::{\n@@ -51,14 +50,14 @@ impl WebAssemblySource {\n #[turbo_tasks::value_impl]\n impl Source for WebAssemblySource {\n     #[turbo_tasks::function]\n-    fn ident(&self) -> Vc<AssetIdent> {\n-        match self.source_ty {\n+    async fn ident(&self) -> Result<Vc<AssetIdent>> {\n+        Ok(match self.source_ty {\n             WebAssemblySourceType::Binary => self.source.ident(),\n             WebAssemblySourceType::Text => self\n                 .source\n                 .ident()\n-                .with_path(self.source.ident().path().append(rcstr!(\"_.wasm\"))),\n-        }\n+                .with_path(self.source.ident().path().await?.append(\"_.wasm\")?),\n+        })\n     }\n }\n "
        },
        {
            "sha": "f7cc0a4c21009d49110fd45b00a5365a45bfe2c2",
            "filename": "turbopack/crates/turbopack/benches/node_file_trace.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack%2Fbenches%2Fnode_file_trace.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack%2Fbenches%2Fnode_file_trace.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack%2Fbenches%2Fnode_file_trace.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -80,11 +80,11 @@ fn bench_emit(b: &mut Bencher, bench_input: &BenchInput) {\n         async move {\n             let task = tt.spawn_once_task(async move {\n                 let input_fs = DiskFileSystem::new(\"tests\".into(), tests_root.clone(), vec![]);\n-                let input = input_fs.root().join(input.clone());\n+                let input = input_fs.root().await?.join(&input)?;\n \n                 let input_dir = input.parent().parent();\n                 let output_fs: Vc<NullFileSystem> = NullFileSystem.into();\n-                let output_dir = output_fs.root().to_resolved().await?;\n+                let output_dir = output_fs.root().await?.clone_value();\n \n                 let source = FileSource::new(input);\n                 let compile_time_info = CompileTimeInfo::builder(\n@@ -119,7 +119,7 @@ fn bench_emit(b: &mut Bencher, bench_input: &BenchInput) {\n                 let module = module_asset_context\n                     .process(Vc::upcast(source), ReferenceType::Undefined)\n                     .module();\n-                let rebased = RebasedAsset::new(Vc::upcast(module), input_dir, *output_dir)\n+                let rebased = RebasedAsset::new(Vc::upcast(module), input_dir, output_dir.clone())\n                     .to_resolved()\n                     .await?;\n "
        },
        {
            "sha": "c0500a7c6746347489f978fdccaf6135dd716a37",
            "filename": "turbopack/crates/turbopack/examples/turbopack.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack%2Fexamples%2Fturbopack.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack%2Fexamples%2Fturbopack.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack%2Fexamples%2Fturbopack.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -42,9 +42,9 @@ async fn main() -> Result<()> {\n \n             // Smart Pointer cast\n             let fs: Vc<Box<dyn FileSystem>> = Vc::upcast(disk_fs);\n-            let input = fs.root().join(rcstr!(\"demo\"));\n-            let output = fs.root().join(rcstr!(\"out\"));\n-            let entry = fs.root().join(rcstr!(\"demo/index.js\"));\n+            let input = fs.root().await?.join(\"demo\")?;\n+            let output = fs.root().await?.join(\"out\")?;\n+            let entry = fs.root().await?.join(\"demo/index.js\")?;\n \n             let source = FileSource::new(entry);\n             let module_asset_context = turbopack::ModuleAssetContext::new(\n@@ -56,7 +56,7 @@ async fn main() -> Result<()> {\n                 ResolveOptionsContext {\n                     enable_typescript: true,\n                     enable_react: true,\n-                    enable_node_modules: Some(fs.root().to_resolved().await?),\n+                    enable_node_modules: Some(fs.root().await?.clone_value()),\n                     custom_conditions: vec![rcstr!(\"development\")],\n                     ..Default::default()\n                 }\n@@ -69,7 +69,7 @@ async fn main() -> Result<()> {\n                     turbopack_core::reference_type::ReferenceType::Undefined,\n                 )\n                 .module();\n-            let rebased = RebasedAsset::new(module, input, output);\n+            let rebased = RebasedAsset::new(module, input, output.clone());\n             emit_with_completion(Vc::upcast(rebased), output).await?;\n \n             anyhow::Ok::<Vc<()>>(Default::default())"
        },
        {
            "sha": "53704df0bcf92139661ccc83a784f3580f39df2c",
            "filename": "turbopack/crates/turbopack/src/evaluate_context.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 4,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fevaluate_context.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fevaluate_context.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fevaluate_context.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae",
            "patch": "@@ -49,8 +49,8 @@ pub async fn node_evaluate_asset_context(\n             Some(\n                 turbopack_node::embed_js::embed_fs()\n                     .root()\n-                    .to_resolved()\n-                    .await?,\n+                    .await?\n+                    .clone_value(),\n             ),\n         )\n         .resolved_cell(),\n@@ -69,9 +69,10 @@ pub async fn node_evaluate_asset_context(\n         enable_node_modules: Some(\n             execution_context\n                 .project_path()\n+                .await?\n                 .root()\n-                .to_resolved()\n-                .await?,\n+                .await?\n+                .clone_value(),\n         ),\n         enable_node_externals: true,\n         enable_node_native_modules: true,"
        },
        {
            "sha": "db3342042f7831c4a91dcb0f3d80529602a47e0e",
            "filename": "turbopack/crates/turbopack/src/lib.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Flib.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae"
        },
        {
            "sha": "e17535d20099125fe9e256521979a005d7d68441",
            "filename": "turbopack/crates/turbopack/src/module_options/mod.rs",
            "status": "modified",
            "additions": 8,
            "deletions": 7,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Fmod.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae"
        },
        {
            "sha": "eb972c529caa24e194b397ab4366f4bd96b9ba93",
            "filename": "turbopack/crates/turbopack/src/module_options/module_options_context.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Fmodule_options_context.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Fmodule_options_context.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Fmodule_options_context.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae"
        },
        {
            "sha": "6d8c44bd4878e35bf2c58cedfd8287e9a9745e7d",
            "filename": "turbopack/crates/turbopack/src/module_options/rule_condition.rs",
            "status": "modified",
            "additions": 39,
            "deletions": 70,
            "changes": 109,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Frule_condition.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Frule_condition.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Frule_condition.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae"
        },
        {
            "sha": "8ab13f7544b5e17b48ba5c1c7045c9155033bbc4",
            "filename": "turbopack/crates/turbopack/src/unsupported_sass.rs",
            "status": "modified",
            "additions": 13,
            "deletions": 10,
            "changes": 23,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Funsupported_sass.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Funsupported_sass.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Funsupported_sass.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae"
        },
        {
            "sha": "8eb30fe3f9e17c0e736705c8a192270fd5146c30",
            "filename": "turbopack/crates/turbopack/tests/node-file-trace.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack%2Ftests%2Fnode-file-trace.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1e3a7dd74f9fcea14721dc5e33c5e209f013bae/turbopack%2Fcrates%2Fturbopack%2Ftests%2Fnode-file-trace.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack%2Ftests%2Fnode-file-trace.rs?ref=b1e3a7dd74f9fcea14721dc5e33c5e209f013bae"
        }
    ],
    "stats": {
        "total": 7997,
        "additions": 4128,
        "deletions": 3869
    }
}