{
    "author": "bgw",
    "message": "Turbopack: bincode: Add crate with bincode serialization helpers (#85878)\n\nAdd helpers for using bincode with various commonly-used foreign types that do not implement `bincode::Encode`/`bincode::Decode`. We can't implement the bincode traits on these types ourselves because of the orphan rules.\n\nThis is pulled out of #85878 to make it easier to review.\n\nThis depends on my fork of bincode here: https://github.com/bgw/bincode/commits/bgw/patches/\nSpecifically, the `with =` attribute I added here: https://github.com/bgw/bincode/commit/4103717399d0695f5ee76e881cc50aed260aa0e1\n\nThis behaves like the serde equivalent: https://serde.rs/field-attrs.html#with\n\nI am working on trying to get the changes with the bincode fork upstreamed. I submitted a bugfix (https://github.com/bgw/bincode/commit/92472863e2774c67058176dcacefe8077f1480a7) via email to the maintainer to start. Upstream is hosted at https://git.sr.ht/~stygianentity/bincode and my fork there is at https://git.sr.ht/~bgw/bincode .",
    "sha": "4c99cf39f41fa6deba237caaa6bb5e31307f2f42",
    "files": [
        {
            "sha": "924cd9d9dc950420b334146a724cf6cb5a2bc1fe",
            "filename": "Cargo.lock",
            "status": "modified",
            "additions": 51,
            "deletions": 7,
            "changes": 58,
            "blob_url": "https://github.com/vercel/next.js/blob/4c99cf39f41fa6deba237caaa6bb5e31307f2f42/Cargo.lock",
            "raw_url": "https://github.com/vercel/next.js/raw/4c99cf39f41fa6deba237caaa6bb5e31307f2f42/Cargo.lock",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/Cargo.lock?ref=4c99cf39f41fa6deba237caaa6bb5e31307f2f42",
            "patch": "@@ -572,6 +572,24 @@ dependencies = [\n  \"serde\",\n ]\n \n+[[package]]\n+name = \"bincode\"\n+version = \"2.0.1\"\n+source = \"git+https://github.com/bgw/bincode.git?branch=bgw%2Fpatches#19f09c5f6895d769883c10b3d374f761ab7fe83d\"\n+dependencies = [\n+ \"bincode_derive\",\n+ \"serde\",\n+ \"unty\",\n+]\n+\n+[[package]]\n+name = \"bincode_derive\"\n+version = \"2.0.1\"\n+source = \"git+https://github.com/bgw/bincode.git?branch=bgw%2Fpatches#19f09c5f6895d769883c10b3d374f761ab7fe83d\"\n+dependencies = [\n+ \"virtue\",\n+]\n+\n [[package]]\n name = \"bindgen\"\n version = \"0.70.1\"\n@@ -1178,7 +1196,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"35584c5fcba8059780748866387fb97c5a203bcfc563fc3d0790af406727a117\"\n dependencies = [\n  \"anyhow\",\n- \"bincode\",\n+ \"bincode 1.3.3\",\n  \"colored\",\n  \"glob\",\n  \"libc\",\n@@ -6753,9 +6771,9 @@ checksum = \"03b634d87b960ab1a38c4fe143b508576f075e7c978bfad18217645ebfdfa2ec\"\n \n [[package]]\n name = \"smallvec\"\n-version = \"1.13.1\"\n+version = \"1.15.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e6ecd384b10a64542d77071bd64bd7b231f4ed5940fba55e98c3de13824cf3d7\"\n+checksum = \"67b1b7a3b5fe4f1376887184045fcf45c69e92af734b7aaddc05fb777b6fbd03\"\n dependencies = [\n  \"serde\",\n ]\n@@ -9079,6 +9097,20 @@ dependencies = [\n  \"utf-8\",\n ]\n \n+[[package]]\n+name = \"turbo-bincode\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"bincode 2.0.1\",\n+ \"either\",\n+ \"indexmap 2.9.0\",\n+ \"mime\",\n+ \"ringmap\",\n+ \"serde\",\n+ \"serde_json\",\n+ \"smallvec\",\n+]\n+\n [[package]]\n name = \"turbo-dyn-eq-hash\"\n version = \"0.0.1\"\n@@ -9151,7 +9183,7 @@ dependencies = [\n name = \"turbo-static\"\n version = \"0.1.0\"\n dependencies = [\n- \"bincode\",\n+ \"bincode 1.3.3\",\n  \"clap\",\n  \"ctrlc\",\n  \"ignore\",\n@@ -10237,6 +10269,12 @@ version = \"0.9.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"8ecb6da28b8a351d773b68d5825ac39017e680750f980f3a1a85cd8dd28a47c1\"\n \n+[[package]]\n+name = \"unty\"\n+version = \"0.0.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"6d49784317cd0d1ee7ec5c716dd598ec5b4483ea832a2dced265471cc0f690ae\"\n+\n [[package]]\n name = \"url\"\n version = \"2.5.4\"\n@@ -10419,7 +10457,7 @@ dependencies = [\n  \"anyhow\",\n  \"async-trait\",\n  \"base64 0.22.1\",\n- \"bincode\",\n+ \"bincode 1.3.3\",\n  \"bytecheck 0.6.11\",\n  \"bytes\",\n  \"derive_more 2.0.1\",\n@@ -10436,6 +10474,12 @@ dependencies = [\n  \"virtual-mio\",\n ]\n \n+[[package]]\n+name = \"virtue\"\n+version = \"0.0.18\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"051eb1abcf10076295e815102942cc58f9d5e3b4560e46e53c21e8ff6f3af7b1\"\n+\n [[package]]\n name = \"vlq\"\n version = \"0.5.1\"\n@@ -10806,7 +10850,7 @@ dependencies = [\n  \"anyhow\",\n  \"async-trait\",\n  \"base64 0.22.1\",\n- \"bincode\",\n+ \"bincode 1.3.3\",\n  \"bytecheck 0.6.11\",\n  \"bytes\",\n  \"derive_more 2.0.1\",\n@@ -10912,7 +10956,7 @@ dependencies = [\n  \"anyhow\",\n  \"async-trait\",\n  \"base64 0.22.1\",\n- \"bincode\",\n+ \"bincode 1.3.3\",\n  \"blake3\",\n  \"bus\",\n  \"bytecheck 0.6.11\","
        },
        {
            "sha": "a80c1aeb34554d02e01943f3d1f4e45001801738",
            "filename": "Cargo.toml",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/4c99cf39f41fa6deba237caaa6bb5e31307f2f42/Cargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/4c99cf39f41fa6deba237caaa6bb5e31307f2f42/Cargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/Cargo.toml?ref=4c99cf39f41fa6deba237caaa6bb5e31307f2f42",
            "patch": "@@ -293,6 +293,7 @@ next-taskless = { path = \"crates/next-taskless\" }\n \n # Turbopack\n auto-hash-map = { path = \"turbopack/crates/turbo-tasks-auto-hash-map\" }\n+turbo-bincode = { path = \"turbopack/crates/turbo-bincode\" }\n turbo-prehash = { path = \"turbopack/crates/turbo-prehash\" }\n turbo-rcstr = { path = \"turbopack/crates/turbo-rcstr\" }\n turbo-dyn-eq-hash = { path = \"turbopack/crates/turbo-dyn-eq-hash\" }\n@@ -359,6 +360,7 @@ preset_env_base = \"6.0.0\"\n \n \n # General Deps\n+bincode = { version = \"2.0.1\", features = [\"serde\"] }\n chromiumoxide = { version = \"0.5.4\", features = [\n   \"tokio-runtime\",\n ], default-features = false }\n@@ -481,4 +483,5 @@ webbrowser = \"1.0.6\"\n inventory = \"0.3.21\"\n \n [patch.crates-io]\n+bincode = { git = \"https://github.com/bgw/bincode.git\", branch = \"bgw/patches\" }\n mdxjs = { git = \"https://github.com/mischnic/mdxjs-rs.git\", branch = \"swc-core-32\" }"
        },
        {
            "sha": "abac7b2d57c910c49db9825a4d920174de426039",
            "filename": "turbopack/crates/turbo-bincode/Cargo.toml",
            "status": "added",
            "additions": 21,
            "deletions": 0,
            "changes": 21,
            "blob_url": "https://github.com/vercel/next.js/blob/4c99cf39f41fa6deba237caaa6bb5e31307f2f42/turbopack%2Fcrates%2Fturbo-bincode%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/4c99cf39f41fa6deba237caaa6bb5e31307f2f42/turbopack%2Fcrates%2Fturbo-bincode%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-bincode%2FCargo.toml?ref=4c99cf39f41fa6deba237caaa6bb5e31307f2f42",
            "patch": "@@ -0,0 +1,21 @@\n+[package]\n+name = \"turbo-bincode\"\n+version = \"0.0.0\"\n+description = \"Utilities for bincode used in turbo-tasks and turbopack\"\n+license = \"MIT\"\n+edition = \"2024\"\n+\n+[lib]\n+\n+[lints]\n+workspace = true\n+\n+[dependencies]\n+bincode = { workspace = true }\n+either = { workspace = true }\n+indexmap = { workspace = true }\n+mime = { workspace = true }\n+ringmap = { workspace = true }\n+serde = { workspace = true }\n+serde_json = { workspace = true }\n+smallvec = { workspace = true }"
        },
        {
            "sha": "a6569d1e873ae0ef93bffedcadd98eba38954dd0",
            "filename": "turbopack/crates/turbo-bincode/src/lib.rs",
            "status": "added",
            "additions": 568,
            "deletions": 0,
            "changes": 568,
            "blob_url": "https://github.com/vercel/next.js/blob/4c99cf39f41fa6deba237caaa6bb5e31307f2f42/turbopack%2Fcrates%2Fturbo-bincode%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4c99cf39f41fa6deba237caaa6bb5e31307f2f42/turbopack%2Fcrates%2Fturbo-bincode%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-bincode%2Fsrc%2Flib.rs?ref=4c99cf39f41fa6deba237caaa6bb5e31307f2f42",
            "patch": "@@ -0,0 +1,568 @@\n+use ::smallvec::SmallVec;\n+use bincode::{\n+    BorrowDecode, Decode, Encode,\n+    de::{BorrowDecoder, Decoder},\n+    enc::Encoder,\n+    error::{DecodeError, EncodeError},\n+};\n+\n+pub mod indexmap {\n+    use std::hash::{BuildHasher, Hash};\n+\n+    use ::indexmap::IndexMap;\n+\n+    use super::*;\n+\n+    pub fn encode<E, K, V, S>(map: &IndexMap<K, V, S>, encoder: &mut E) -> Result<(), EncodeError>\n+    where\n+        E: Encoder,\n+        K: Encode,\n+        V: Encode,\n+    {\n+        usize::encode(&map.len(), encoder)?;\n+        for (k, v) in map {\n+            K::encode(k, encoder)?;\n+            V::encode(v, encoder)?;\n+        }\n+        Ok(())\n+    }\n+\n+    pub fn decode<Context, D, K, V, S>(decoder: &mut D) -> Result<IndexMap<K, V, S>, DecodeError>\n+    where\n+        D: Decoder<Context = Context>,\n+        K: Decode<Context> + Eq + Hash,\n+        V: Decode<Context>,\n+        S: BuildHasher + Default,\n+    {\n+        let len = usize::decode(decoder)?;\n+        let mut map = IndexMap::with_capacity_and_hasher(len, Default::default());\n+        for _i in 0..len {\n+            map.insert(K::decode(decoder)?, V::decode(decoder)?);\n+        }\n+        Ok(map)\n+    }\n+\n+    pub fn borrow_decode<'de, Context, D, K, V, S>(\n+        decoder: &mut D,\n+    ) -> Result<IndexMap<K, V, S>, DecodeError>\n+    where\n+        D: BorrowDecoder<'de, Context = Context>,\n+        K: BorrowDecode<'de, Context> + Eq + Hash,\n+        V: BorrowDecode<'de, Context>,\n+        S: BuildHasher + Default,\n+    {\n+        let len = usize::decode(decoder)?;\n+        let mut map = IndexMap::with_capacity_and_hasher(len, Default::default());\n+        for _i in 0..len {\n+            map.insert(K::borrow_decode(decoder)?, V::borrow_decode(decoder)?);\n+        }\n+        Ok(map)\n+    }\n+\n+    #[cfg(test)]\n+    mod tests {\n+        use bincode::{decode_from_slice, encode_to_vec};\n+\n+        use super::*;\n+\n+        #[test]\n+        fn test_roundtrip() {\n+            let cfg = bincode::config::standard();\n+\n+            #[derive(Encode, Decode)]\n+            struct Wrapper(#[bincode(with = \"crate::indexmap\")] IndexMap<String, u32>);\n+\n+            let map1 = Wrapper(IndexMap::from([\n+                (\"key1\".to_string(), 12345u32),\n+                (\"key2\".to_string(), 23456u32),\n+            ]));\n+\n+            let map2: Wrapper = decode_from_slice(&encode_to_vec(&map1, cfg).unwrap(), cfg)\n+                .unwrap()\n+                .0;\n+\n+            assert_eq!(map1.0, map2.0);\n+        }\n+    }\n+}\n+\n+pub mod indexset {\n+    use std::hash::{BuildHasher, Hash};\n+\n+    use ::indexmap::IndexSet;\n+\n+    use super::*;\n+\n+    pub fn encode<E, T, S>(set: &IndexSet<T, S>, encoder: &mut E) -> Result<(), EncodeError>\n+    where\n+        E: Encoder,\n+        T: Encode,\n+    {\n+        usize::encode(&set.len(), encoder)?;\n+        for item in set {\n+            T::encode(item, encoder)?;\n+        }\n+        Ok(())\n+    }\n+\n+    pub fn decode<Context, D, T, S>(decoder: &mut D) -> Result<IndexSet<T, S>, DecodeError>\n+    where\n+        D: Decoder<Context = Context>,\n+        T: Decode<Context> + Eq + Hash,\n+        S: BuildHasher + Default,\n+    {\n+        let len = usize::decode(decoder)?;\n+        let mut set = IndexSet::with_capacity_and_hasher(len, Default::default());\n+        for _i in 0..len {\n+            set.insert(T::decode(decoder)?);\n+        }\n+        Ok(set)\n+    }\n+\n+    pub fn borrow_decode<'de, Context, D, T, S>(\n+        decoder: &mut D,\n+    ) -> Result<IndexSet<T, S>, DecodeError>\n+    where\n+        D: BorrowDecoder<'de, Context = Context>,\n+        T: BorrowDecode<'de, Context> + Eq + Hash,\n+        S: BuildHasher + Default,\n+    {\n+        let len = usize::decode(decoder)?;\n+        let mut set = IndexSet::with_capacity_and_hasher(len, Default::default());\n+        for _i in 0..len {\n+            set.insert(T::borrow_decode(decoder)?);\n+        }\n+        Ok(set)\n+    }\n+\n+    #[cfg(test)]\n+    mod tests {\n+        use bincode::{decode_from_slice, encode_to_vec};\n+\n+        use super::*;\n+\n+        #[test]\n+        fn test_roundtrip() {\n+            let cfg = bincode::config::standard();\n+\n+            #[derive(Encode, Decode)]\n+            struct Wrapper(#[bincode(with = \"crate::indexset\")] IndexSet<String>);\n+\n+            let set1 = Wrapper(IndexSet::from([\n+                \"value1\".to_string(),\n+                \"value2\".to_string(),\n+                \"value3\".to_string(),\n+            ]));\n+\n+            let set2: Wrapper = decode_from_slice(&encode_to_vec(&set1, cfg).unwrap(), cfg)\n+                .unwrap()\n+                .0;\n+\n+            assert_eq!(set1.0, set2.0);\n+        }\n+    }\n+}\n+\n+pub mod ringset {\n+    use std::hash::{BuildHasher, Hash};\n+\n+    use ::ringmap::RingSet;\n+\n+    use super::*;\n+\n+    pub fn encode<E, T, S>(set: &RingSet<T, S>, encoder: &mut E) -> Result<(), EncodeError>\n+    where\n+        E: Encoder,\n+        T: Encode,\n+    {\n+        usize::encode(&set.len(), encoder)?;\n+        for item in set {\n+            T::encode(item, encoder)?;\n+        }\n+        Ok(())\n+    }\n+\n+    pub fn decode<Context, D, T, S>(decoder: &mut D) -> Result<RingSet<T, S>, DecodeError>\n+    where\n+        D: Decoder<Context = Context>,\n+        T: Decode<Context> + Eq + Hash,\n+        S: BuildHasher + Default,\n+    {\n+        let len = usize::decode(decoder)?;\n+        let mut set = RingSet::with_capacity_and_hasher(len, Default::default());\n+        for _i in 0..len {\n+            set.insert(T::decode(decoder)?);\n+        }\n+        Ok(set)\n+    }\n+\n+    pub fn borrow_decode<'de, Context, D, T, S>(\n+        decoder: &mut D,\n+    ) -> Result<RingSet<T, S>, DecodeError>\n+    where\n+        D: BorrowDecoder<'de, Context = Context>,\n+        T: BorrowDecode<'de, Context> + Eq + Hash,\n+        S: BuildHasher + Default,\n+    {\n+        let len = usize::decode(decoder)?;\n+        let mut set = RingSet::with_capacity_and_hasher(len, Default::default());\n+        for _i in 0..len {\n+            set.insert(T::borrow_decode(decoder)?);\n+        }\n+        Ok(set)\n+    }\n+\n+    #[cfg(test)]\n+    mod tests {\n+        use bincode::{decode_from_slice, encode_to_vec};\n+\n+        use super::*;\n+\n+        #[test]\n+        fn test_roundtrip() {\n+            let cfg = bincode::config::standard();\n+\n+            #[derive(Encode, Decode)]\n+            struct Wrapper(#[bincode(with = \"crate::ringset\")] RingSet<String>);\n+\n+            let set1 = Wrapper(RingSet::from([\n+                \"value1\".to_string(),\n+                \"value2\".to_string(),\n+                \"value3\".to_string(),\n+            ]));\n+\n+            let set2: Wrapper = decode_from_slice(&encode_to_vec(&set1, cfg).unwrap(), cfg)\n+                .unwrap()\n+                .0;\n+\n+            assert_eq!(set1.0, set2.0);\n+        }\n+    }\n+}\n+\n+pub mod mime_option {\n+    use std::str::FromStr;\n+\n+    use mime::Mime;\n+\n+    use super::*;\n+\n+    pub fn encode<E: Encoder>(mime: &Option<Mime>, encoder: &mut E) -> Result<(), EncodeError> {\n+        let mime_str: Option<&str> = mime.as_ref().map(AsRef::as_ref);\n+        Encode::encode(&mime_str, encoder)\n+    }\n+\n+    pub fn decode<Context, D: Decoder<Context = Context>>(\n+        decoder: &mut D,\n+    ) -> Result<Option<Mime>, DecodeError> {\n+        if let Some(mime_str) = <Option<String> as Decode<Context>>::decode(decoder)? {\n+            Ok(Some(\n+                Mime::from_str(&mime_str).map_err(|e| DecodeError::OtherString(e.to_string()))?,\n+            ))\n+        } else {\n+            Ok(None)\n+        }\n+    }\n+\n+    pub fn borrow_decode<'de, Context, D: BorrowDecoder<'de, Context = Context>>(\n+        decoder: &mut D,\n+    ) -> Result<Option<Mime>, DecodeError> {\n+        decode(decoder)\n+    }\n+\n+    #[cfg(test)]\n+    mod tests {\n+        use bincode::{decode_from_slice, encode_to_vec};\n+\n+        use super::*;\n+\n+        #[derive(Encode, Decode)]\n+        struct Wrapper(#[bincode(with = \"crate::mime_option\")] Option<Mime>);\n+\n+        #[test]\n+        fn test_roundtrip() {\n+            let cfg = bincode::config::standard();\n+\n+            let mime1 = Wrapper(Some(\"text/html; charset=utf-8\".parse().unwrap()));\n+\n+            let mime2: Wrapper = decode_from_slice(&encode_to_vec(&mime1, cfg).unwrap(), cfg)\n+                .unwrap()\n+                .0;\n+\n+            assert_eq!(mime1.0, mime2.0);\n+        }\n+\n+        #[test]\n+        fn test_roundtrip_none() {\n+            let cfg = bincode::config::standard();\n+\n+            let mime1 = Wrapper(None);\n+\n+            let mime2: Wrapper = decode_from_slice(&encode_to_vec(&mime1, cfg).unwrap(), cfg)\n+                .unwrap()\n+                .0;\n+\n+            assert_eq!(mime1.0, mime2.0);\n+        }\n+    }\n+}\n+\n+/// Encode/decode as a serialized string encoded using `serde_json`.\n+///\n+/// This encodes less efficiently than `#[bincode(with_serde)]` would, but avoids [bincode's known\n+/// compatibility issues][serde-issues]. Use this for infrequently-serialized types and when you're\n+/// unsure if the underlying type may trigger a serde compatibility issue.\n+///\n+/// In the future this could be replaced with a more efficient serde-compatible self-describing\n+/// format with a compact binary representation (e.g. pot or MessagePack), but `serde_json` is\n+/// convenient because it avoids introducing additional dependencies.\n+///\n+/// [serde-issues]: https://docs.rs/bincode/latest/bincode/serde/index.html#known-issues\n+pub mod serde_json {\n+    use super::*;\n+\n+    pub fn encode<E: Encoder, T: serde::Serialize>(\n+        value: &T,\n+        encoder: &mut E,\n+    ) -> Result<(), EncodeError> {\n+        let json_str =\n+            ::serde_json::to_string(value).map_err(|e| EncodeError::OtherString(e.to_string()))?;\n+        Encode::encode(&json_str, encoder)\n+    }\n+\n+    pub fn decode<Context, D: Decoder<Context = Context>, T: serde::de::DeserializeOwned>(\n+        decoder: &mut D,\n+    ) -> Result<T, DecodeError> {\n+        let json_str: String = Decode::decode(decoder)?;\n+        ::serde_json::from_str(&json_str).map_err(|e| DecodeError::OtherString(e.to_string()))\n+    }\n+\n+    pub fn borrow_decode<\n+        'de,\n+        Context,\n+        D: BorrowDecoder<'de, Context = Context>,\n+        T: serde::de::Deserialize<'de>,\n+    >(\n+        decoder: &mut D,\n+    ) -> Result<T, DecodeError> {\n+        let json_str: &str = BorrowDecode::borrow_decode(decoder)?;\n+        ::serde_json::from_str(json_str).map_err(|e| DecodeError::OtherString(e.to_string()))\n+    }\n+\n+    #[cfg(test)]\n+    mod tests {\n+        use ::serde_json::{Value, json};\n+        use bincode::{decode_from_slice, encode_to_vec};\n+\n+        use super::*;\n+\n+        #[test]\n+        fn test_roundtrip() {\n+            let cfg = bincode::config::standard();\n+\n+            #[derive(Encode, Decode)]\n+            struct Wrapper(#[bincode(with = \"crate::serde_json\")] Value);\n+\n+            let value1 = Wrapper(json!({\n+                \"key1\": [1, 2, 3],\n+                \"key2\": [4, 5, 6]\n+            }));\n+\n+            let value2: Wrapper = decode_from_slice(&encode_to_vec(&value1, cfg).unwrap(), cfg)\n+                .unwrap()\n+                .0;\n+\n+            assert_eq!(value1.0, value2.0);\n+        }\n+    }\n+}\n+\n+pub mod either {\n+    use ::either::Either;\n+\n+    use super::*;\n+\n+    pub fn encode<E: Encoder, L: Encode, R: Encode>(\n+        value: &Either<L, R>,\n+        encoder: &mut E,\n+    ) -> Result<(), EncodeError> {\n+        value.is_left().encode(encoder)?;\n+        ::either::for_both!(value, v => Encode::encode(v, encoder))\n+    }\n+\n+    pub fn decode<\n+        Context,\n+        D: Decoder<Context = Context>,\n+        L: Decode<Context>,\n+        R: Decode<Context>,\n+    >(\n+        decoder: &mut D,\n+    ) -> Result<Either<L, R>, DecodeError> {\n+        let is_left = bool::decode(decoder)?;\n+        Ok(if is_left {\n+            Either::Left(L::decode(decoder)?)\n+        } else {\n+            Either::Right(R::decode(decoder)?)\n+        })\n+    }\n+\n+    pub fn borrow_decode<\n+        'de,\n+        Context,\n+        D: BorrowDecoder<'de, Context = Context>,\n+        L: BorrowDecode<'de, Context>,\n+        R: BorrowDecode<'de, Context>,\n+    >(\n+        decoder: &mut D,\n+    ) -> Result<Either<L, R>, DecodeError> {\n+        let is_left = bool::borrow_decode(decoder)?;\n+        Ok(if is_left {\n+            Either::Left(L::borrow_decode(decoder)?)\n+        } else {\n+            Either::Right(R::borrow_decode(decoder)?)\n+        })\n+    }\n+\n+    #[cfg(test)]\n+    mod tests {\n+        use bincode::{decode_from_slice, encode_to_vec};\n+\n+        use super::*;\n+\n+        #[derive(Encode, Decode)]\n+        struct Wrapper(#[bincode(with = \"crate::either\")] Either<String, u32>);\n+\n+        #[test]\n+        fn test_roundtrip_left() {\n+            let cfg = bincode::config::standard();\n+\n+            let either1 = Wrapper(Either::Left(\"hello\".to_string()));\n+\n+            let either2: Wrapper = decode_from_slice(&encode_to_vec(&either1, cfg).unwrap(), cfg)\n+                .unwrap()\n+                .0;\n+\n+            assert_eq!(either1.0, either2.0);\n+        }\n+\n+        #[test]\n+        fn test_roundtrip_right() {\n+            let cfg = bincode::config::standard();\n+\n+            let either1 = Wrapper(Either::Right(42u32));\n+\n+            let either2: Wrapper = decode_from_slice(&encode_to_vec(&either1, cfg).unwrap(), cfg)\n+                .unwrap()\n+                .0;\n+\n+            assert_eq!(either1.0, either2.0);\n+        }\n+    }\n+}\n+\n+pub mod smallvec {\n+    use ::smallvec::Array;\n+\n+    use super::*;\n+\n+    pub fn encode<E: Encoder, A: Array<Item = impl Encode>>(\n+        vec: &SmallVec<A>,\n+        encoder: &mut E,\n+    ) -> Result<(), EncodeError> {\n+        usize::encode(&vec.len(), encoder)?;\n+        for item in vec {\n+            Encode::encode(item, encoder)?;\n+        }\n+        Ok(())\n+    }\n+\n+    pub fn decode<Context, D: Decoder<Context = Context>, A: Array<Item = impl Decode<Context>>>(\n+        decoder: &mut D,\n+    ) -> Result<SmallVec<A>, DecodeError> {\n+        let len = usize::decode(decoder)?;\n+        let mut vec = SmallVec::with_capacity(len);\n+        for _ in 0..len {\n+            vec.push(Decode::decode(decoder)?);\n+        }\n+        Ok(vec)\n+    }\n+\n+    pub fn borrow_decode<\n+        'de,\n+        Context,\n+        D: BorrowDecoder<'de, Context = Context>,\n+        A: Array<Item = impl BorrowDecode<'de, Context>>,\n+    >(\n+        decoder: &mut D,\n+    ) -> Result<SmallVec<A>, DecodeError> {\n+        let len = usize::decode(decoder)?;\n+        let mut vec = SmallVec::with_capacity(len);\n+        for _ in 0..len {\n+            vec.push(BorrowDecode::borrow_decode(decoder)?);\n+        }\n+        Ok(vec)\n+    }\n+\n+    #[cfg(test)]\n+    mod tests {\n+        use bincode::{decode_from_slice, encode_to_vec};\n+\n+        use super::*;\n+\n+        #[test]\n+        fn test_roundtrip() {\n+            let cfg = bincode::config::standard();\n+\n+            #[derive(Encode, Decode)]\n+            struct Wrapper(#[bincode(with = \"crate::smallvec\")] SmallVec<[u32; 4]>);\n+\n+            let vec1 = Wrapper(SmallVec::from_slice(&[1u32, 2, 3, 4, 5]));\n+\n+            let vec2: Wrapper = decode_from_slice(&encode_to_vec(&vec1, cfg).unwrap(), cfg)\n+                .unwrap()\n+                .0;\n+\n+            assert_eq!(vec1.0, vec2.0);\n+        }\n+    }\n+}\n+\n+pub mod owned_cow {\n+    //! Overrides the default [`BorrowDecode`] implementation to always use the owned representation\n+    //! of [`Cow`], so that the resulting [`BorrowDecode`] type is independent of the [`Cow`]'s\n+    //! lifetime.\n+\n+    use std::borrow::Cow;\n+\n+    use super::*;\n+\n+    #[allow(clippy::ptr_arg)]\n+    pub fn encode<E, T>(cow: &Cow<'_, T>, encoder: &mut E) -> Result<(), EncodeError>\n+    where\n+        E: Encoder,\n+        T: ToOwned + ?Sized,\n+        for<'a> &'a T: Encode,\n+    {\n+        cow.encode(encoder)\n+    }\n+\n+    pub fn decode<'cow, Context, D, T>(decoder: &mut D) -> Result<Cow<'cow, T>, DecodeError>\n+    where\n+        D: Decoder<Context = Context>,\n+        T: ToOwned + ?Sized,\n+        <T as ToOwned>::Owned: Decode<Context>,\n+    {\n+        Decode::decode(decoder)\n+    }\n+\n+    pub fn borrow_decode<'de, 'cow, Context, D, T>(\n+        decoder: &mut D,\n+    ) -> Result<Cow<'cow, T>, DecodeError>\n+    where\n+        D: BorrowDecoder<'de, Context = Context>,\n+        T: ToOwned + ?Sized,\n+        <T as ToOwned>::Owned: Decode<Context>,\n+    {\n+        Decode::decode(decoder)\n+    }\n+}"
        }
    ],
    "stats": {
        "total": 650,
        "additions": 643,
        "deletions": 7
    }
}