{
    "author": "lukesandberg",
    "message": "[turbopack] Support traversing the graph in reverse order (#86427)\n\nThis makes certain aggregations trivial since we are are guaranteed to only traverse relevant edges.\n\nUse it to fix a bug in the async module identification logic.  Previously we would aggregate async cycles after propagating 'asyncness' through the DFS post order traversal, but this could cause us to fail to propagate async to all reverse dependencies depending on which part of a cycle a node would happen to visit first.\n\nBy traversing starting from the async modules we just need to mark everything we find and not worry about cycles at all since the underlying DFS mechanism will ensure we don't loop.  In addition to only requiring a single pass, this is guaranteed to visit fewer nodes in that single pass.\n\nOne caveat is that reverse traversals only work within a single `SingleModuleGraph` so a debug assert was added to prevent misuse\n\nCloses #85988\nCloses #86391\nCloses PACK-5806",
    "sha": "a51a2e4c2688c48b856825f807e369f2e1364b09",
    "files": [
        {
            "sha": "89c4cb5de1b382fdbdea1da2a1bc5903249bfc3d",
            "filename": "contributing/core/testing.md",
            "status": "modified",
            "additions": 13,
            "deletions": 0,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/a51a2e4c2688c48b856825f807e369f2e1364b09/contributing%2Fcore%2Ftesting.md",
            "raw_url": "https://github.com/vercel/next.js/raw/a51a2e4c2688c48b856825f807e369f2e1364b09/contributing%2Fcore%2Ftesting.md",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/contributing%2Fcore%2Ftesting.md?ref=a51a2e4c2688c48b856825f807e369f2e1364b09",
            "patch": "@@ -103,6 +103,19 @@ we attempt to capture traces of the playwright run to make debugging the failure\n A test-trace artifact should be uploaded after the workflow completes which can be downloaded, unzipped,\n and then inspected with `pnpm playwright show-trace ./path/to/trace`\n \n+To attach the chrome debugger to next the easiest approach is to modify the `createNext` call in your test to pass `--inspect` to next.\n+\n+```js\n+const next = await createNext({\n+  ...\n+  startArgs: =['--inspect'],\n+})\n+```\n+\n+Consider also sett `NEXT_E2E_TEST_TIMEOUT=0`\n+\n+To debug the test process itself you need to pass the `inspect` flag to the node process running jest. e.g. `IS_TURBOPACK_TEST=1 TURBOPACK_DEV=1 NEXT_TEST_MODE=dev node --inspect node_modules/jest/bin/jest.js ...`\n+\n ### Profiling tests\n \n Add `NEXT_TEST_TRACE=1` to enable test profiling. It's useful for improving our testing infrastructure."
        },
        {
            "sha": "437dde72a6fe5fe46e8f6db12a9a927c17cf4e55",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/async_module_info.rs",
            "status": "modified",
            "additions": 41,
            "deletions": 40,
            "changes": 81,
            "blob_url": "https://github.com/vercel/next.js/blob/a51a2e4c2688c48b856825f807e369f2e1364b09/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fasync_module_info.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a51a2e4c2688c48b856825f807e369f2e1364b09/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fasync_module_info.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fasync_module_info.rs?ref=a51a2e4c2688c48b856825f807e369f2e1364b09",
            "patch": "@@ -1,6 +1,6 @@\n use anyhow::Result;\n use rustc_hash::FxHashSet;\n-use turbo_tasks::{ResolvedVc, TryJoinIterExt, Vc};\n+use turbo_tasks::{ResolvedVc, TryFlatJoinIterExt, Vc};\n \n use crate::{\n     module::{Module, Modules},\n@@ -57,52 +57,53 @@ async fn compute_async_module_info_single(\n     let graph = graph.read().await?;\n \n     let self_async_modules = graph\n-        .graphs\n-        .first()\n-        .unwrap()\n-        .iter_nodes()\n-        .map(async |node| Ok((node, *node.is_self_async().await?)))\n-        .try_join()\n-        .await?\n-        .into_iter()\n-        .flat_map(|(k, v)| v.then_some(k))\n-        .chain(parent_async_modules.iter().copied())\n-        .collect::<FxHashSet<_>>();\n+        .enumerate_nodes()\n+        .map(async |(_, node)| {\n+            Ok(match node {\n+                super::SingleModuleGraphNode::Module(node) => {\n+                    node.is_self_async().await?.then_some(*node)\n+                }\n+                super::SingleModuleGraphNode::VisitedModule { idx: _, module } => {\n+                    // If a module is async in the parent then we need to mark reverse dependencies\n+                    // async in this graph as well.\n+                    parent_async_modules.contains(module).then_some(*module)\n+                }\n+            })\n+        })\n+        .try_flat_join()\n+        .await?;\n \n     // To determine which modules are async, we need to propagate the self-async flag to all\n-    // importers, which is done using a postorder traversal of the graph.\n-    //\n-    // This however doesn't cover cycles of async modules, which are handled by determining all\n-    // strongly-connected components, and then marking all the whole SCC as async if one of the\n-    // modules in the SCC is async.\n+    // importers, which is done using a reverse traversal over the graph\n+    // Because we walk edges in the reverse direction we can trivially handle things like cycles\n+    // without actually computing them.\n+    let mut async_modules = FxHashSet::default();\n+    async_modules.extend(self_async_modules.iter());\n \n-    let mut async_modules = self_async_modules;\n-    graph.traverse_edges_from_entries_dfs(\n-        graph.graphs.first().unwrap().entry_modules(),\n+    graph.traverse_edges_from_entries_dfs_reversed(\n+        self_async_modules,\n         &mut (),\n-        |_, _, _| Ok(GraphTraversalAction::Continue),\n-        |parent_info, module, _| {\n-            let Some((parent_module, ref_data)) = parent_info else {\n-                // An entry module\n-                return Ok(());\n-            };\n-\n-            if ref_data.chunking_type.is_inherit_async() && async_modules.contains(&module) {\n-                async_modules.insert(parent_module);\n-            }\n-            Ok(())\n+        // child is the previously visited module which must be async\n+        // parent is a new module that depends on it\n+        |child, parent, _state| {\n+            Ok(if let Some((_, edge)) = child {\n+                if edge.chunking_type.is_inherit_async() {\n+                    async_modules.insert(parent);\n+                    GraphTraversalAction::Continue\n+                } else {\n+                    // Wrong edge type to follow\n+                    GraphTraversalAction::Exclude\n+                }\n+            } else {\n+                // These are our entry points, just continue\n+                GraphTraversalAction::Continue\n+            })\n         },\n+        |_, _, _| Ok(()),\n     )?;\n \n-    graph.traverse_cycles(\n-        |ref_data| ref_data.chunking_type.is_inherit_async(),\n-        |cycle| {\n-            if cycle.iter().any(|node| async_modules.contains(node)) {\n-                async_modules.extend(cycle.iter().map(|n| **n));\n-            }\n-            Ok(())\n-        },\n-    )?;\n+    // Accumulate the parent modules at the end. Not all parent async modules were in this graph\n+    async_modules.extend(parent_async_modules);\n \n     Ok(Vc::cell(async_modules))\n }"
        },
        {
            "sha": "e5c6f6a795781b18000e01aaa2ad2a4307826a4e",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/mod.rs",
            "status": "modified",
            "additions": 265,
            "deletions": 25,
            "changes": 290,
            "blob_url": "https://github.com/vercel/next.js/blob/a51a2e4c2688c48b856825f807e369f2e1364b09/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a51a2e4c2688c48b856825f807e369f2e1364b09/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs?ref=a51a2e4c2688c48b856825f807e369f2e1364b09",
            "patch": "@@ -7,6 +7,7 @@ use std::{\n use anyhow::{Context, Result, bail};\n use auto_hash_map::AutoSet;\n use petgraph::{\n+    Direction,\n     graph::{DiGraph, EdgeIndex, NodeIndex},\n     visit::{EdgeRef, IntoNeighbors, IntoNodeReferences, NodeIndexable, Reversed},\n };\n@@ -412,7 +413,7 @@ impl SingleModuleGraph {\n     pub fn has_entry_module(&self, module: ResolvedVc<Box<dyn Module>>) -> bool {\n         if let Some(index) = self.modules.get(&module) {\n             self.graph\n-                .edges_directed(*index, petgraph::Direction::Incoming)\n+                .edges_directed(*index, Direction::Incoming)\n                 .next()\n                 .is_none()\n         } else {\n@@ -845,7 +846,7 @@ impl ModuleGraph {\n \n         let entry = graph_ref.get_entry(module)?;\n         let referenced_modules = graph_ref\n-            .iter_graphs_neighbors_rev(entry)\n+            .iter_graphs_neighbors_rev(entry, Direction::Outgoing)\n             .filter(|(edge_idx, _)| {\n                 let ty = graph_ref.get_edge(*edge_idx).unwrap();\n                 ty.chunking_type.is_inherit_async()\n@@ -997,29 +998,36 @@ impl ModuleGraphRef {\n             .context(\"Expected graph node\")\n     }\n \n-    fn should_visit_node(&self, node: &SingleModuleGraphNode) -> bool {\n-        if self.skip_visited_module_children {\n+    fn should_visit_node(&self, node: &SingleModuleGraphNode, direction: Direction) -> bool {\n+        if self.skip_visited_module_children && direction == Direction::Outgoing {\n             !matches!(node, SingleModuleGraphNode::VisitedModule { .. })\n         } else {\n             true\n         }\n     }\n \n+    pub fn enumerate_nodes(\n+        &self,\n+    ) -> impl Iterator<Item = (NodeIndex, &'_ SingleModuleGraphNode)> + '_ {\n+        self.graphs.iter().flat_map(|g| g.enumerate_nodes())\n+    }\n+\n     /// Iterate the edges of a node REVERSED!\n     fn iter_graphs_neighbors_rev<'a>(\n         &'a self,\n         node: GraphNodeIndex,\n+        direction: Direction,\n     ) -> impl Iterator<Item = (GraphEdgeIndex, GraphNodeIndex)> + 'a {\n         let graph = &*self.get_graph(node.graph_idx).graph;\n \n-        if cfg!(debug_assertions) {\n+        if cfg!(debug_assertions) && direction == Direction::Outgoing {\n             let node_weight = graph.node_weight(node.node_idx).unwrap();\n             if let SingleModuleGraphNode::VisitedModule { .. } = node_weight {\n                 panic!(\"iter_graphs_neighbors_rev called on VisitedModule node\");\n             }\n         }\n \n-        let mut walker = graph.neighbors(node.node_idx).detach();\n+        let mut walker = graph.neighbors_directed(node.node_idx, direction).detach();\n         std::iter::from_fn(move || {\n             while let Some((edge_idx, succ_idx)) = walker.next(graph) {\n                 let edge_idx = GraphEdgeIndex::new(node.graph_idx, edge_idx);\n@@ -1094,11 +1102,13 @@ impl ModuleGraphRef {\n                     }\n                     stack.push((Pass::Visit, current));\n                     if action == GraphTraversalAction::Continue\n-                        && self.should_visit_node(current_node)\n+                        && self.should_visit_node(current_node, Direction::Outgoing)\n                     {\n-                        let current = current_node.target_idx().unwrap_or(current);\n+                        let current = current_node\n+                            .target_idx(Direction::Outgoing)\n+                            .unwrap_or(current);\n                         stack.extend(\n-                            self.iter_graphs_neighbors_rev(current)\n+                            self.iter_graphs_neighbors_rev(current, Direction::Outgoing)\n                                 .map(|(_, child)| (Pass::ExpandAndVisit, child)),\n                         );\n                     }\n@@ -1140,16 +1150,16 @@ impl ModuleGraphRef {\n         while let Some(node) = queue.pop_front() {\n             if visited.insert(node) {\n                 let node_weight = self.get_node(node)?;\n-                for (edge, succ) in self.iter_graphs_neighbors_rev(node) {\n+                for (edge, succ) in self.iter_graphs_neighbors_rev(node, Direction::Outgoing) {\n                     let succ_weight = self.get_node(succ)?;\n                     let action = visitor(\n                         Some((node_weight.module(), self.get_edge(edge)?)),\n                         succ_weight.module(),\n                     )?;\n-                    if !self.should_visit_node(succ_weight) {\n+                    if !self.should_visit_node(succ_weight, Direction::Outgoing) {\n                         continue;\n                     }\n-                    let succ = succ_weight.target_idx().unwrap_or(succ);\n+                    let succ = succ_weight.target_idx(Direction::Outgoing).unwrap_or(succ);\n                     if !visited.contains(&succ) && action == GraphTraversalAction::Continue {\n                         queue.push_back(succ);\n                     }\n@@ -1189,16 +1199,16 @@ impl ModuleGraphRef {\n         while let Some(node) = stack.pop() {\n             if visited.insert(node) {\n                 let node_weight = self.get_node(node)?;\n-                for (edge, succ) in self.iter_graphs_neighbors_rev(node) {\n+                for (edge, succ) in self.iter_graphs_neighbors_rev(node, Direction::Outgoing) {\n                     let succ_weight = self.get_node(succ)?;\n                     let action = visitor(\n                         Some((node_weight.module(), self.get_edge(edge)?)),\n                         succ_weight.module(),\n                     );\n-                    if !self.should_visit_node(succ_weight) {\n+                    if !self.should_visit_node(succ_weight, Direction::Outgoing) {\n                         continue;\n                     }\n-                    let succ = succ_weight.target_idx().unwrap_or(succ);\n+                    let succ = succ_weight.target_idx(Direction::Outgoing).unwrap_or(succ);\n                     if !visited.contains(&succ) && action == GraphTraversalAction::Continue {\n                         stack.push(succ);\n                     }\n@@ -1256,6 +1266,70 @@ impl ModuleGraphRef {\n     ///    - Receives: (originating &SingleModuleGraphNode, edge &ChunkingType), target\n     ///      &SingleModuleGraphNode, state &S\n     pub fn traverse_edges_from_entries_dfs<S>(\n+        &self,\n+        entries: impl IntoIterator<Item = ResolvedVc<Box<dyn Module>>>,\n+        state: &mut S,\n+        visit_preorder: impl FnMut(\n+            Option<(ResolvedVc<Box<dyn Module>>, &'_ RefData)>,\n+            ResolvedVc<Box<dyn Module>>,\n+            &mut S,\n+        ) -> Result<GraphTraversalAction>,\n+        visit_postorder: impl FnMut(\n+            Option<(ResolvedVc<Box<dyn Module>>, &'_ RefData)>,\n+            ResolvedVc<Box<dyn Module>>,\n+            &mut S,\n+        ) -> Result<()>,\n+    ) -> Result<()> {\n+        self.traverse_edges_from_entries_dfs_impl::<S>(\n+            entries,\n+            state,\n+            visit_preorder,\n+            visit_postorder,\n+            Direction::Outgoing,\n+        )\n+    }\n+\n+    /// Traverses all reachable edges in dfs order over the reversed graph. The preorder visitor can\n+    /// be used to forward state up the graph, and to skip subgraphs\n+    ///\n+    /// Target nodes can be revisited (once per incoming edge) in the preorder_visitor, in the post\n+    /// order visitor they are visited exactly once with the first edge they were discovered with.\n+    /// Edges are traversed in normal order, so should correspond to reference order.\n+    ///\n+    /// * `entries` - The entry modules to start the traversal from\n+    /// * `state` - The state to be passed to the visitors\n+    /// * `visit_preorder` - Called before visiting the children of a node.\n+    ///    - Receives: (originating &SingleModuleGraphNode, edge &ChunkingType), target\n+    ///      &SingleModuleGraphNode, state &S\n+    ///    - Can return [GraphTraversalAction]s to control the traversal\n+    /// * `visit_postorder` - Called after visiting the parents of a node. Return\n+    ///    - Receives: (originating &SingleModuleGraphNode, edge &ChunkingType), target\n+    ///      &SingleModuleGraphNode, state &S\n+    pub fn traverse_edges_from_entries_dfs_reversed<S>(\n+        &self,\n+        entries: impl IntoIterator<Item = ResolvedVc<Box<dyn Module>>>,\n+        state: &mut S,\n+        visit_preorder: impl FnMut(\n+            Option<(ResolvedVc<Box<dyn Module>>, &'_ RefData)>,\n+            ResolvedVc<Box<dyn Module>>,\n+            &mut S,\n+        ) -> Result<GraphTraversalAction>,\n+        visit_postorder: impl FnMut(\n+            Option<(ResolvedVc<Box<dyn Module>>, &'_ RefData)>,\n+            ResolvedVc<Box<dyn Module>>,\n+            &mut S,\n+        ) -> Result<()>,\n+    ) -> Result<()> {\n+        self.traverse_edges_from_entries_dfs_impl::<S>(\n+            entries,\n+            state,\n+            visit_preorder,\n+            visit_postorder,\n+            Direction::Incoming,\n+        )\n+    }\n+\n+    fn traverse_edges_from_entries_dfs_impl<S>(\n         &self,\n         entries: impl IntoIterator<Item = ResolvedVc<Box<dyn Module>>>,\n         state: &mut S,\n@@ -1269,7 +1343,15 @@ impl ModuleGraphRef {\n             ResolvedVc<Box<dyn Module>>,\n             &mut S,\n         ) -> Result<()>,\n+        direction: Direction,\n     ) -> Result<()> {\n+        if direction == Direction::Incoming {\n+            debug_assert!(\n+                self.skip_visited_module_children,\n+                \"Can only trace reverse edges in a single layer graph. We do not model cross \\\n+                 graph reverse edges\"\n+            );\n+        }\n         let entries = entries.into_iter().collect::<Vec<_>>();\n \n         enum Pass {\n@@ -1307,10 +1389,10 @@ impl ModuleGraphRef {\n                     stack.push((Pass::Visit, parent, current));\n                     if action == GraphTraversalAction::Continue\n                         && expanded.insert(current)\n-                        && self.should_visit_node(current_node)\n+                        && self.should_visit_node(current_node, direction)\n                     {\n-                        let current = current_node.target_idx().unwrap_or(current);\n-                        stack.extend(self.iter_graphs_neighbors_rev(current).map(\n+                        let current = current_node.target_idx(direction).unwrap_or(current);\n+                        stack.extend(self.iter_graphs_neighbors_rev(current, direction).map(\n                             |(edge, child)| (Pass::ExpandAndVisit, Some((current, edge)), child),\n                         ));\n                     }\n@@ -1419,11 +1501,11 @@ impl ModuleGraphRef {\n         while let Some(NodeWithPriority { node, .. }) = queue.pop() {\n             queue_set.remove(&node);\n             let node_weight = self.get_node(node)?;\n-            let node = node_weight.target_idx().unwrap_or(node);\n+            let node = node_weight.target_idx(Direction::Outgoing).unwrap_or(node);\n \n             visit_count += 1;\n \n-            for (edge, succ) in self.iter_graphs_neighbors_rev(node) {\n+            for (edge, succ) in self.iter_graphs_neighbors_rev(node, Direction::Outgoing) {\n                 let succ_weight = self.get_node(succ)?;\n \n                 let action = visit(\n@@ -1432,7 +1514,7 @@ impl ModuleGraphRef {\n                     state,\n                 )?;\n \n-                let succ = succ_weight.target_idx().unwrap_or(succ);\n+                let succ = succ_weight.target_idx(Direction::Outgoing).unwrap_or(succ);\n                 if action == GraphTraversalAction::Continue && queue_set.insert(succ) {\n                     queue.push(NodeWithPriority {\n                         node: succ,\n@@ -1499,9 +1581,12 @@ impl SingleModuleGraphNode {\n             SingleModuleGraphNode::VisitedModule { module, .. } => *module,\n         }\n     }\n-    pub fn target_idx(&self) -> Option<GraphNodeIndex> {\n+    pub fn target_idx(&self, direction: Direction) -> Option<GraphNodeIndex> {\n         match self {\n-            SingleModuleGraphNode::VisitedModule { idx, .. } => Some(*idx),\n+            SingleModuleGraphNode::VisitedModule { idx, .. } => match direction {\n+                Direction::Outgoing => Some(*idx),\n+                Direction::Incoming => None,\n+            },\n             SingleModuleGraphNode::Module(_) => None,\n         }\n     }\n@@ -1793,7 +1878,7 @@ pub mod tests {\n     use anyhow::Result;\n     use rustc_hash::FxHashMap;\n     use turbo_rcstr::{RcStr, rcstr};\n-    use turbo_tasks::{ResolvedVc, TryJoinIterExt, Vc};\n+    use turbo_tasks::{ResolvedVc, TryJoinIterExt, ValueToString, Vc};\n     use turbo_tasks_backend::{BackendOptions, TurboTasksBackend, noop_backing_storage};\n     use turbo_tasks_fs::{FileSystem, FileSystemPath, VirtualFileSystem};\n \n@@ -1803,7 +1888,7 @@ pub mod tests {\n         module::Module,\n         module_graph::{\n             GraphEntries, GraphTraversalAction, ModuleGraph, ModuleGraphRef, SingleModuleGraph,\n-            chunk_group_info::ChunkGroupEntry,\n+            VisitedModules, chunk_group_info::ChunkGroupEntry,\n         },\n         reference::{ModuleReference, ModuleReferences, SingleChunkableModuleReference},\n         resolve::ExportUsage,\n@@ -1980,6 +2065,161 @@ pub mod tests {\n         )\n         .await;\n     }\n+\n+    #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n+    async fn test_reverse_edges_through_layered_graph() {\n+        let tt = turbo_tasks::TurboTasks::new(TurboTasksBackend::new(\n+            BackendOptions::default(),\n+            noop_backing_storage(),\n+        ));\n+        tt.run_once(async move {\n+            let fs = VirtualFileSystem::new_with_name(rcstr!(\"test\"));\n+            let root = fs.root().await?;\n+\n+            // a simple linear graph a -> b ->c\n+            // but b->c is in a parent graph and a is in the child\n+            let graph = {\n+                let mut deps = FxHashMap::default();\n+\n+                deps.insert(rcstr!(\"a.js\"), vec![rcstr!(\"b.js\"), rcstr!(\"d.js\")]);\n+                deps.insert(rcstr!(\"b.js\"), vec![rcstr!(\"c.js\")]);\n+                deps\n+            };\n+            let repo = TestRepo {\n+                repo: graph\n+                    .iter()\n+                    .map(|(k, v)| {\n+                        (\n+                            root.join(k).unwrap(),\n+                            v.iter().map(|f| root.join(f).unwrap()).collect(),\n+                        )\n+                    })\n+                    .collect(),\n+            }\n+            .cell();\n+            let make_module = |name| {\n+                Vc::upcast::<Box<dyn Module>>(MockModule::new(root.join(name).unwrap(), repo))\n+                    .to_resolved()\n+            };\n+            let a_module = make_module(\"a.js\").await?;\n+            let b_module = make_module(\"b.js\").await?;\n+\n+            let parent_graph = SingleModuleGraph::new_with_entries(\n+                GraphEntries::cell(GraphEntries(vec![ChunkGroupEntry::Entry(vec![b_module])])),\n+                false,\n+            );\n+\n+            let module_graph = ModuleGraph::from_graphs(vec![\n+                parent_graph,\n+                SingleModuleGraph::new_with_entries_visited(\n+                    GraphEntries::cell(GraphEntries(vec![ChunkGroupEntry::Entry(vec![a_module])])),\n+                    VisitedModules::from_graph(parent_graph),\n+                    false,\n+                ),\n+            ])\n+            .await?;\n+            let child_graph = module_graph.iter_graphs().nth(1).unwrap().read().await?;\n+            // test traversing forward from a in the child graph\n+            {\n+                let mut visited_forward = Vec::new();\n+                child_graph.traverse_edges_from_entries_dfs(\n+                    vec![a_module],\n+                    &mut (),\n+                    |_parent, child, _state_| {\n+                        visited_forward.push(child);\n+                        Ok(GraphTraversalAction::Continue)\n+                    },\n+                    |_, _, _| Ok(()),\n+                )?;\n+\n+                assert_eq!(\n+                    visited_forward\n+                        .iter()\n+                        .map(|m| m.ident().to_string().owned())\n+                        .try_join()\n+                        .await?,\n+                    vec![\n+                        rcstr!(\"[test]/a.js\"),\n+                        rcstr!(\"[test]/b.js\"),\n+                        rcstr!(\"[test]/d.js\")\n+                    ]\n+                );\n+            }\n+\n+            // test traversing backwards from 'd' which is only in the child graph\n+            {\n+                use turbo_tasks::TryFlatJoinIterExt;\n+                let d_module = child_graph\n+                    .enumerate_nodes()\n+                    .map(|(_index, module)| async move {\n+                        Ok(match module {\n+                            crate::module_graph::SingleModuleGraphNode::Module(module) => {\n+                                if module.ident().to_string().owned().await.unwrap()\n+                                    == \"[test]/d.js\"\n+                                {\n+                                    Some(*module)\n+                                } else {\n+                                    None\n+                                }\n+                            }\n+                            crate::module_graph::SingleModuleGraphNode::VisitedModule {\n+                                ..\n+                            } => None,\n+                        })\n+                    })\n+                    .try_flat_join()\n+                    .await?\n+                    .into_iter()\n+                    .next()\n+                    .unwrap();\n+                let mut visited_reverse = Vec::new();\n+                child_graph.traverse_edges_from_entries_dfs_reversed(\n+                    vec![d_module],\n+                    &mut (),\n+                    |_parent, child, _state_| {\n+                        visited_reverse.push(child);\n+                        Ok(GraphTraversalAction::Continue)\n+                    },\n+                    |_, _, _| Ok(()),\n+                )?;\n+                assert_eq!(\n+                    visited_reverse\n+                        .iter()\n+                        .map(|m| m.ident().to_string().owned())\n+                        .try_join()\n+                        .await?,\n+                    vec![rcstr!(\"[test]/d.js\"), rcstr!(\"[test]/a.js\")]\n+                );\n+            }\n+            // test traversing backwards from `b` which is in the parent graph and thus a\n+            // VisitedModule in this graph\n+            {\n+                let mut visited_reverse = Vec::new();\n+                child_graph.traverse_edges_from_entries_dfs_reversed(\n+                    vec![b_module],\n+                    &mut (),\n+                    |_parent, child, _state_| {\n+                        visited_reverse.push(child);\n+                        Ok(GraphTraversalAction::Continue)\n+                    },\n+                    |_, _, _| Ok(()),\n+                )?;\n+                assert_eq!(\n+                    visited_reverse\n+                        .iter()\n+                        .map(|m| m.ident().to_string().owned())\n+                        .try_join()\n+                        .await?,\n+                    vec![rcstr!(\"[test]/b.js\"), rcstr!(\"[test]/a.js\")]\n+                );\n+            }\n+\n+            Ok(())\n+        })\n+        .await\n+        .unwrap();\n+    }\n+\n     #[turbo_tasks::value(shared)]\n     struct TestRepo {\n         repo: FxHashMap<FileSystemPath, Vec<FileSystemPath>>,"
        },
        {
            "sha": "30936749a337942664e6364a2bd41b45317f1fa8",
            "filename": "turbopack/crates/turbopack-tests/tests/execution/turbopack/async-modules/cycle-2/input/A.ts",
            "status": "added",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/a51a2e4c2688c48b856825f807e369f2e1364b09/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fasync-modules%2Fcycle-2%2Finput%2FA.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/a51a2e4c2688c48b856825f807e369f2e1364b09/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fasync-modules%2Fcycle-2%2Finput%2FA.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fasync-modules%2Fcycle-2%2Finput%2FA.ts?ref=a51a2e4c2688c48b856825f807e369f2e1364b09",
            "patch": "@@ -0,0 +1,7 @@\n+import { B } from './B'\n+\n+export function A(n: number) {\n+  if (n > 0) {\n+    B(n - 1)\n+  }\n+}"
        },
        {
            "sha": "f19cfe7b8f2f5dd9410891ba381fbbda198994ea",
            "filename": "turbopack/crates/turbopack-tests/tests/execution/turbopack/async-modules/cycle-2/input/B.ts",
            "status": "added",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/a51a2e4c2688c48b856825f807e369f2e1364b09/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fasync-modules%2Fcycle-2%2Finput%2FB.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/a51a2e4c2688c48b856825f807e369f2e1364b09/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fasync-modules%2Fcycle-2%2Finput%2FB.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fasync-modules%2Fcycle-2%2Finput%2FB.ts?ref=a51a2e4c2688c48b856825f807e369f2e1364b09",
            "patch": "@@ -0,0 +1,9 @@\n+import { C } from './C'\n+import { asyncImportFn } from './asyncImportFn'\n+\n+export function B(n: number) {\n+  if (n > 0) {\n+    C(n - 1)\n+    asyncImportFn()\n+  }\n+}"
        },
        {
            "sha": "ca509266a375f5d940fbdb802345355d2e147798",
            "filename": "turbopack/crates/turbopack-tests/tests/execution/turbopack/async-modules/cycle-2/input/C.ts",
            "status": "added",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/a51a2e4c2688c48b856825f807e369f2e1364b09/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fasync-modules%2Fcycle-2%2Finput%2FC.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/a51a2e4c2688c48b856825f807e369f2e1364b09/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fasync-modules%2Fcycle-2%2Finput%2FC.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fasync-modules%2Fcycle-2%2Finput%2FC.ts?ref=a51a2e4c2688c48b856825f807e369f2e1364b09",
            "patch": "@@ -0,0 +1,7 @@\n+import { A } from './A'\n+\n+export function C(n: number) {\n+  if (n > 0) {\n+    A(n - 1)\n+  }\n+}"
        },
        {
            "sha": "bfc5676497d2a8f98577a6f457f885bd2e0b5c19",
            "filename": "turbopack/crates/turbopack-tests/tests/execution/turbopack/async-modules/cycle-2/input/D.ts",
            "status": "added",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/a51a2e4c2688c48b856825f807e369f2e1364b09/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fasync-modules%2Fcycle-2%2Finput%2FD.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/a51a2e4c2688c48b856825f807e369f2e1364b09/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fasync-modules%2Fcycle-2%2Finput%2FD.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fasync-modules%2Fcycle-2%2Finput%2FD.ts?ref=a51a2e4c2688c48b856825f807e369f2e1364b09",
            "patch": "@@ -0,0 +1,7 @@\n+import { C } from './C'\n+\n+export function D(n: number) {\n+  if (n > 0) {\n+    C(n - 1)\n+  }\n+}"
        },
        {
            "sha": "6afe670514a783fbddcfaa7522671752c675161e",
            "filename": "turbopack/crates/turbopack-tests/tests/execution/turbopack/async-modules/cycle-2/input/E.ts",
            "status": "added",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/a51a2e4c2688c48b856825f807e369f2e1364b09/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fasync-modules%2Fcycle-2%2Finput%2FE.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/a51a2e4c2688c48b856825f807e369f2e1364b09/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fasync-modules%2Fcycle-2%2Finput%2FE.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fasync-modules%2Fcycle-2%2Finput%2FE.ts?ref=a51a2e4c2688c48b856825f807e369f2e1364b09",
            "patch": "@@ -0,0 +1,7 @@\n+import { B } from './B'\n+\n+export function E(n: number) {\n+  if (n > 0) {\n+    B(n - 1)\n+  }\n+}"
        },
        {
            "sha": "866d19415ad5b6af807fd2d9b46d936309a197e5",
            "filename": "turbopack/crates/turbopack-tests/tests/execution/turbopack/async-modules/cycle-2/input/asyncImportFn.js",
            "status": "added",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/a51a2e4c2688c48b856825f807e369f2e1364b09/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fasync-modules%2Fcycle-2%2Finput%2FasyncImportFn.js",
            "raw_url": "https://github.com/vercel/next.js/raw/a51a2e4c2688c48b856825f807e369f2e1364b09/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fasync-modules%2Fcycle-2%2Finput%2FasyncImportFn.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fasync-modules%2Fcycle-2%2Finput%2FasyncImportFn.js?ref=a51a2e4c2688c48b856825f807e369f2e1364b09",
            "patch": "@@ -0,0 +1,7 @@\n+function sleep(ms) {\n+  return new Promise((resolve) => setTimeout(resolve, ms))\n+}\n+await sleep(0)\n+console.log('Imported asyncImportFn')\n+\n+export function asyncImportFn() {}"
        },
        {
            "sha": "50ccf91ad0ff110253f8512c70df89922ef6d5e9",
            "filename": "turbopack/crates/turbopack-tests/tests/execution/turbopack/async-modules/cycle-2/input/index.js",
            "status": "added",
            "additions": 27,
            "deletions": 0,
            "changes": 27,
            "blob_url": "https://github.com/vercel/next.js/blob/a51a2e4c2688c48b856825f807e369f2e1364b09/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fasync-modules%2Fcycle-2%2Finput%2Findex.js",
            "raw_url": "https://github.com/vercel/next.js/raw/a51a2e4c2688c48b856825f807e369f2e1364b09/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fasync-modules%2Fcycle-2%2Finput%2Findex.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fasync-modules%2Fcycle-2%2Finput%2Findex.js?ref=a51a2e4c2688c48b856825f807e369f2e1364b09",
            "patch": "@@ -0,0 +1,27 @@\n+import { A } from './A'\n+import { D } from './D'\n+\n+/*\n+ * {A,B,C,D}.ts and asyncImportFn.ts have an import graph topology that\n+ * exposes a bug in `compute_async_module_info_single` in turbopack. Requesting\n+ * this page (localhost:3000/api/test) will fail with:\n+ *   TypeError: (0 , t.C) is not a function\n+ * This is because C has been marked as an async module, but D hasn't.\n+ *\n+ * route\n+ * |   \\\n+ * v    v\n+ * A<-  D\n+ * |  \\ |\n+ * v   \\v\n+ * B--->C\n+ * |\n+ * v\n+ * async\n+ */\n+\n+it('should handle cycles in async modules', () => {\n+  A(10)\n+  D(10)\n+  expect(true).toBe(true)\n+})"
        }
    ],
    "stats": {
        "total": 455,
        "additions": 390,
        "deletions": 65
    }
}