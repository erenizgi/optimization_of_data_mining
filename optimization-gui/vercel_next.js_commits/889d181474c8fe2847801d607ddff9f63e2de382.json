{
    "author": "acdlite",
    "message": "Delete old navigation response handling implementation (#87149)\n\nBased on:\n\n- #87128 \n- #87147 \n- #87134 \n- #87135 \n\n---\n\nThis completes the migration of navigation response handling to the new\nSegment Cache and PPR-based implementation.\n\nMost of this PR is just deleting vestigial code. No behavioral changes\nare expected. The substance of the migration was completed in earlier\nsteps.",
    "sha": "889d181474c8fe2847801d607ddff9f63e2de382",
    "files": [
        {
            "sha": "26c5a90ff66d7fbc0e0c7b1b3723f097411eca38",
            "filename": "packages/next/src/client/components/app-router-instance.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 4,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/889d181474c8fe2847801d607ddff9f63e2de382/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fapp-router-instance.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/889d181474c8fe2847801d607ddff9f63e2de382/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fapp-router-instance.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fapp-router-instance.ts?ref=889d181474c8fe2847801d607ddff9f63e2de382",
            "patch": "@@ -341,10 +341,6 @@ export const publicAppRouterInstance: AppRouterInstance = {\n           fetchStrategy = FetchStrategy.Full\n           break\n         }\n-        case PrefetchKind.TEMPORARY: {\n-          // This concept doesn't exist in the segment cache implementation.\n-          return\n-        }\n         default: {\n           prefetchKind satisfies never\n           // Despite typescript thinking that this can't happen,"
        },
        {
            "sha": "9feda357421fcf566f28f28109991c56ce652764",
            "filename": "packages/next/src/client/components/app-router.tsx",
            "status": "modified",
            "additions": 0,
            "deletions": 13,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/889d181474c8fe2847801d607ddff9f63e2de382/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fapp-router.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/889d181474c8fe2847801d607ddff9f63e2de382/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fapp-router.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fapp-router.tsx?ref=889d181474c8fe2847801d607ddff9f63e2de382",
            "patch": "@@ -105,19 +105,6 @@ function HistoryUpdater({\n   return null\n }\n \n-export function createEmptyCacheNode(): CacheNode {\n-  return {\n-    lazyData: null,\n-    rsc: null,\n-    prefetchRsc: null,\n-    head: null,\n-    prefetchHead: null,\n-    parallelRoutes: new Map(),\n-    loading: null,\n-    navigatedAt: -1,\n-  }\n-}\n-\n function copyNextJsInternalHistoryState(data: any) {\n   if (data == null) data = {}\n   const currentState = window.history.state"
        },
        {
            "sha": "7433d5d558b66ce68468112b0120c67746e0627d",
            "filename": "packages/next/src/client/components/layout-router.tsx",
            "status": "modified",
            "additions": 27,
            "deletions": 151,
            "changes": 178,
            "blob_url": "https://github.com/vercel/next.js/blob/889d181474c8fe2847801d607ddff9f63e2de382/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Flayout-router.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/889d181474c8fe2847801d607ddff9f63e2de382/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Flayout-router.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Flayout-router.tsx?ref=889d181474c8fe2847801d607ddff9f63e2de382",
            "patch": "@@ -1,26 +1,19 @@\n 'use client'\n \n-import type {\n-  CacheNode,\n-  LazyCacheNode,\n-} from '../../shared/lib/app-router-types'\n+import type { CacheNode } from '../../shared/lib/app-router-types'\n import type { LoadingModuleData } from '../../shared/lib/app-router-types'\n import type {\n   FlightRouterState,\n   FlightSegmentPath,\n   Segment,\n } from '../../shared/lib/app-router-types'\n import type { ErrorComponent } from './error-boundary'\n-import {\n-  ACTION_SERVER_PATCH,\n-  type FocusAndScrollRef,\n-} from './router-reducer/router-reducer-types'\n+import type { FocusAndScrollRef } from './router-reducer/router-reducer-types'\n \n import React, {\n   Activity,\n   useContext,\n   use,\n-  startTransition,\n   Suspense,\n   useDeferredValue,\n   type JSX,\n@@ -32,16 +25,13 @@ import {\n   GlobalLayoutRouterContext,\n   TemplateContext,\n } from '../../shared/lib/app-router-context.shared-runtime'\n-import { fetchServerResponse } from './router-reducer/fetch-server-response'\n import { unresolvedThenable } from './unresolved-thenable'\n import { ErrorBoundary } from './error-boundary'\n import { matchSegment } from './match-segments'\n import { disableSmoothScrollDuringRouteTransition } from '../../shared/lib/router/utils/disable-smooth-scroll'\n import { RedirectBoundary } from './redirect-boundary'\n import { HTTPAccessFallbackBoundary } from './http-access-fallback/error-boundary'\n import { createRouterCacheKey } from './router-reducer/create-router-cache-key'\n-import { hasInterceptionRouteInCurrentTree } from './router-reducer/reducers/has-interception-route-in-current-tree'\n-import { dispatchAppRouterAction } from './use-action-queue'\n import { useRouterBFCache, type RouterBFCacheEntry } from './bfcache'\n import { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\n import {\n@@ -52,56 +42,6 @@ import { getParamValueFromCacheKey } from '../route-params'\n import type { Params } from '../../server/request/params'\n import { isDeferredRsc } from './router-reducer/ppr-navigations'\n \n-/**\n- * Add refetch marker to router state at the point of the current layout segment.\n- * This ensures the response returned is not further down than the current layout segment.\n- */\n-function walkAddRefetch(\n-  segmentPathToWalk: FlightSegmentPath | undefined,\n-  treeToRecreate: FlightRouterState\n-): FlightRouterState {\n-  if (segmentPathToWalk) {\n-    const [segment, parallelRouteKey] = segmentPathToWalk\n-    const isLast = segmentPathToWalk.length === 2\n-\n-    if (matchSegment(treeToRecreate[0], segment)) {\n-      if (treeToRecreate[1].hasOwnProperty(parallelRouteKey)) {\n-        if (isLast) {\n-          const subTree = walkAddRefetch(\n-            undefined,\n-            treeToRecreate[1][parallelRouteKey]\n-          )\n-          return [\n-            treeToRecreate[0],\n-            {\n-              ...treeToRecreate[1],\n-              [parallelRouteKey]: [\n-                subTree[0],\n-                subTree[1],\n-                subTree[2],\n-                'refetch',\n-              ],\n-            },\n-          ]\n-        }\n-\n-        return [\n-          treeToRecreate[0],\n-          {\n-            ...treeToRecreate[1],\n-            [parallelRouteKey]: walkAddRefetch(\n-              segmentPathToWalk.slice(2),\n-              treeToRecreate[1][parallelRouteKey]\n-            ),\n-          },\n-        ]\n-      }\n-    }\n-  }\n-\n-  return treeToRecreate\n-}\n-\n const __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = (\n   ReactDOM as any\n ).__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE\n@@ -335,15 +275,15 @@ function InnerLayoutRouter({\n   tree,\n   segmentPath,\n   debugNameContext,\n-  cacheNode,\n+  cacheNode: maybeCacheNode,\n   params,\n   url,\n   isActive,\n }: {\n   tree: FlightRouterState\n   segmentPath: FlightSegmentPath\n   debugNameContext: string\n-  cacheNode: CacheNode\n+  cacheNode: CacheNode | null\n   params: Params\n   url: string\n   isActive: boolean\n@@ -355,7 +295,18 @@ function InnerLayoutRouter({\n     throw new Error('invariant global layout router not mounted')\n   }\n \n-  const { tree: fullTree } = context\n+  const cacheNode =\n+    maybeCacheNode !== null\n+      ? maybeCacheNode\n+      : // This segment is not in the cache. Suspend indefinitely.\n+        //\n+        // This should only be reachable for inactive/hidden segments, during\n+        // prerendering The active segment should always be consistent with the\n+        // CacheNode tree. Regardless, if we don't have a matching CacheNode, we\n+        // must suspend rather than render nothing, to prevent showing an\n+        // inconsistent route.\n+\n+        (use(unresolvedThenable) as never)\n \n   // `rsc` represents the renderable node for this segment.\n \n@@ -389,71 +340,12 @@ function InnerLayoutRouter({\n     resolvedRsc = unwrappedRsc\n   } else {\n     // This is not a deferred RSC promise. Don't need to unwrap it.\n-    resolvedRsc = rsc\n-  }\n-\n-  // TODO: At this point, the only reason `resolvedRsc` would be null is if the\n-  // data for this segment was fetched by a reducer that hasn't been migrated\n-  // yet to the Segment Cache implementation. It shouldn't happen for regular\n-  // navigations. Once we convert the remaining reducers, we can delete the\n-  // lazy fetching block below.\n-  if (!resolvedRsc) {\n-    // The data for this segment is not available, and there's no pending\n-    // navigation that will be able to fulfill it. We need to fetch more from\n-    // the server and patch the cache.\n-\n-    // Only fetch data for the active segment. Inactive segments (rendered\n-    // offscreen for bfcache) should not trigger fetches.\n-    if (isActive) {\n-      // Check if there's already a pending request.\n-      let lazyData = cacheNode.lazyData\n-      if (lazyData === null) {\n-        /**\n-         * Router state with refetch marker added\n-         */\n-        // TODO-APP: remove ''\n-        const refetchTree = walkAddRefetch(['', ...segmentPath], fullTree)\n-        const includeNextUrl = hasInterceptionRouteInCurrentTree(fullTree)\n-        const navigatedAt = Date.now()\n-        cacheNode.lazyData = lazyData = fetchServerResponse(\n-          new URL(url, location.origin),\n-          {\n-            flightRouterState: refetchTree,\n-            nextUrl: includeNextUrl\n-              ? // We always send the last next-url, not the current when\n-                // performing a dynamic request. This is because we update\n-                // the next-url after a navigation, but we want the same\n-                // interception route to be matched that used the last\n-                // next-url.\n-                context.previousNextUrl || context.nextUrl\n-              : null,\n-          }\n-        ).then((serverResponse) => {\n-          startTransition(() => {\n-            dispatchAppRouterAction({\n-              type: ACTION_SERVER_PATCH,\n-              previousTree: fullTree,\n-              serverResponse,\n-              navigatedAt,\n-              retry: null,\n-            })\n-          })\n-\n-          return serverResponse\n-        })\n-\n-        // Suspend while waiting for lazyData to resolve\n-        use(lazyData)\n-      }\n+    if (rsc === null) {\n+      use(unresolvedThenable) as never\n     }\n-    // Suspend infinitely as `changeByServerResponse` will cause a different part of the tree to be rendered.\n-    // A falsey `resolvedRsc` indicates missing data -- we should not commit that branch, and we need to wait for the data to arrive.\n-    use(unresolvedThenable) as never\n+    resolvedRsc = rsc\n   }\n \n-  // If we get to this point, then we know we have something we can render.\n-  let content = resolvedRsc\n-\n   // In dev, we create a NavigationPromisesContext containing the instrumented promises that provide\n   // `useSelectedLayoutSegment` and `useSelectedLayoutSegments`.\n   // Promises are cached outside of render to survive suspense retries.\n@@ -468,15 +360,17 @@ function InnerLayoutRouter({\n     )\n   }\n \n+  let children = resolvedRsc\n+\n   if (navigationPromises) {\n-    content = (\n+    children = (\n       <NavigationPromisesContext.Provider value={navigationPromises}>\n         {resolvedRsc}\n       </NavigationPromisesContext.Provider>\n     )\n   }\n \n-  const subtree = (\n+  children = (\n     // The layout router context narrows down tree and childNodes at each level.\n     <LayoutRouterContext.Provider\n       value={{\n@@ -491,11 +385,11 @@ function InnerLayoutRouter({\n         isActive: isActive,\n       }}\n     >\n-      {content}\n+      {children}\n     </LayoutRouterContext.Provider>\n   )\n-  // Ensure root layout is not wrapped in a div as the root layout renders `<html>`\n-  return subtree\n+\n+  return children\n }\n \n /**\n@@ -657,25 +551,7 @@ export default function OuterLayoutRouter({\n     const cacheKey = createRouterCacheKey(segment)\n \n     // Read segment path from the parallel router cache node.\n-    let cacheNode = segmentMap.get(cacheKey)\n-    if (cacheNode === undefined) {\n-      // When data is not available during rendering client-side we need to fetch\n-      // it from the server.\n-      const newLazyCacheNode: LazyCacheNode = {\n-        lazyData: null,\n-        rsc: null,\n-        prefetchRsc: null,\n-        head: null,\n-        prefetchHead: null,\n-        parallelRoutes: new Map(),\n-        loading: null,\n-        navigatedAt: -1,\n-      }\n-\n-      // Flight data fetch kicked off during render and put into the cache.\n-      cacheNode = newLazyCacheNode\n-      segmentMap.set(cacheKey, newLazyCacheNode)\n-    }\n+    const cacheNode = segmentMap.get(cacheKey) ?? null\n \n     /*\n     - Error boundary"
        },
        {
            "sha": "90e9a632cd5c61120d5458d97a91876319ac0ce5",
            "filename": "packages/next/src/client/components/router-reducer/aliased-prefetch-navigations.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 272,
            "changes": 272,
            "blob_url": "https://github.com/vercel/next.js/blob/80fb15cea6a8f157ec91fe090f4b069a8835895a/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Faliased-prefetch-navigations.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/80fb15cea6a8f157ec91fe090f4b069a8835895a/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Faliased-prefetch-navigations.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Faliased-prefetch-navigations.ts?ref=80fb15cea6a8f157ec91fe090f4b069a8835895a",
            "patch": "@@ -1,272 +0,0 @@\n-import type {\n-  CacheNodeSeedData,\n-  FlightRouterState,\n-  FlightSegmentPath,\n-} from '../../../shared/lib/app-router-types'\n-import type { CacheNode } from '../../../shared/lib/app-router-types'\n-import {\n-  addSearchParamsIfPageSegment,\n-  DEFAULT_SEGMENT_KEY,\n-  PAGE_SEGMENT_KEY,\n-} from '../../../shared/lib/segment'\n-import type { NormalizedFlightData } from '../../flight-data-helpers'\n-import { createEmptyCacheNode } from '../app-router'\n-import { applyRouterStatePatchToTree } from './apply-router-state-patch-to-tree'\n-import { createHrefFromUrl } from './create-href-from-url'\n-import { createRouterCacheKey } from './create-router-cache-key'\n-import { fillCacheWithNewSubTreeDataButOnlyLoading } from './fill-cache-with-new-subtree-data'\n-import { handleMutable } from './handle-mutable'\n-import { generateSegmentsFromPatch } from './reducers/navigate-reducer'\n-import type { Mutable, ReadonlyReducerState } from './router-reducer-types'\n-\n-/**\n- * This is a stop-gap until per-segment caching is implemented. It leverages the `aliased` flag that is added\n- * to prefetch entries when it's determined that the loading state from that entry should be used for this navigation.\n- * This function takes the aliased entry and only applies the loading state to the updated cache node.\n- * We should remove this once per-segment fetching is implemented as ideally the prefetch cache will contain a\n- * more granular segment map and so the router will be able to simply re-use the loading segment for the new navigation.\n- */\n-export function handleAliasedPrefetchEntry(\n-  navigatedAt: number,\n-  state: ReadonlyReducerState,\n-  flightData: string | NormalizedFlightData[],\n-  url: URL,\n-  renderedSearch: string,\n-  mutable: Mutable\n-) {\n-  let currentTree = state.tree\n-  let currentCache = state.cache\n-  const href = createHrefFromUrl(url)\n-  let applied\n-  let scrollableSegments: FlightSegmentPath[] = []\n-\n-  if (typeof flightData === 'string') {\n-    return false\n-  }\n-\n-  for (const normalizedFlightData of flightData) {\n-    // If the segment doesn't have a loading component, we don't need to do anything.\n-    if (!hasLoadingComponentInSeedData(normalizedFlightData.seedData)) {\n-      continue\n-    }\n-\n-    let treePatch = normalizedFlightData.tree\n-    // Segments are keyed by searchParams (e.g. __PAGE__?{\"foo\":\"bar\"}). We might return a less specific, param-less entry,\n-    // so we ensure that the final tree contains the correct searchParams (reflected in the URL) are provided in the updated FlightRouterState tree.\n-    // We only do this on the first read, as otherwise we'd be overwriting the searchParams that may have already been set\n-    treePatch = addSearchParamsToPageSegments(\n-      treePatch,\n-      Object.fromEntries(url.searchParams)\n-    )\n-\n-    const { seedData, isRootRender, pathToSegment } = normalizedFlightData\n-    // TODO-APP: remove ''\n-    const flightSegmentPathWithLeadingEmpty = ['', ...pathToSegment]\n-\n-    // Segments are keyed by searchParams (e.g. __PAGE__?{\"foo\":\"bar\"}). We might return a less specific, param-less entry,\n-    // so we ensure that the final tree contains the correct searchParams (reflected in the URL) are provided in the updated FlightRouterState tree.\n-    // We only do this on the first read, as otherwise we'd be overwriting the searchParams that may have already been set\n-    treePatch = addSearchParamsToPageSegments(\n-      treePatch,\n-      Object.fromEntries(url.searchParams)\n-    )\n-\n-    let newTree = applyRouterStatePatchToTree(\n-      flightSegmentPathWithLeadingEmpty,\n-      currentTree,\n-      treePatch,\n-      href\n-    )\n-\n-    const newCache = createEmptyCacheNode()\n-\n-    // The prefetch cache entry was aliased -- this signals that we only fill in the cache with the\n-    // loading state and not the actual parallel route seed data.\n-    if (isRootRender && seedData) {\n-      // Fill in the cache with the new loading / rsc data\n-      const rsc = seedData[0]\n-      const loading = seedData[2]\n-      newCache.loading = loading\n-      newCache.rsc = rsc\n-\n-      // Construct a new tree and apply the aliased loading state for each parallel route\n-      fillNewTreeWithOnlyLoadingSegments(\n-        navigatedAt,\n-        newCache,\n-        currentCache,\n-        treePatch,\n-        seedData\n-      )\n-    } else {\n-      // Copy rsc for the root node of the cache.\n-      newCache.rsc = currentCache.rsc\n-      newCache.prefetchRsc = currentCache.prefetchRsc\n-      newCache.loading = currentCache.loading\n-      newCache.parallelRoutes = new Map(currentCache.parallelRoutes)\n-\n-      // copy the loading state only into the leaf node (the part that changed)\n-      fillCacheWithNewSubTreeDataButOnlyLoading(\n-        navigatedAt,\n-        newCache,\n-        currentCache,\n-        normalizedFlightData\n-      )\n-    }\n-\n-    // If we don't have an updated tree, there's no reason to update the cache, as the tree\n-    // dictates what cache nodes to render.\n-    if (newTree) {\n-      currentTree = newTree\n-      currentCache = newCache\n-      applied = true\n-    }\n-\n-    for (const subSegment of generateSegmentsFromPatch(treePatch)) {\n-      const scrollableSegmentPath = [\n-        ...normalizedFlightData.pathToSegment,\n-        ...subSegment,\n-      ]\n-      // Filter out the __DEFAULT__ paths as they shouldn't be scrolled to in this case.\n-      if (\n-        scrollableSegmentPath[scrollableSegmentPath.length - 1] !==\n-        DEFAULT_SEGMENT_KEY\n-      ) {\n-        scrollableSegments.push(scrollableSegmentPath)\n-      }\n-    }\n-  }\n-\n-  if (!applied) {\n-    return false\n-  }\n-\n-  mutable.patchedTree = currentTree\n-  mutable.renderedSearch = renderedSearch\n-  mutable.cache = currentCache\n-  mutable.canonicalUrl = href\n-  mutable.hashFragment = url.hash\n-  mutable.scrollableSegments = scrollableSegments\n-\n-  return handleMutable(state, mutable)\n-}\n-\n-function hasLoadingComponentInSeedData(seedData: CacheNodeSeedData | null) {\n-  if (!seedData) return false\n-\n-  const parallelRoutes = seedData[1]\n-  const loading = seedData[2]\n-\n-  if (loading) {\n-    return true\n-  }\n-\n-  for (const key in parallelRoutes) {\n-    if (hasLoadingComponentInSeedData(parallelRoutes[key])) {\n-      return true\n-    }\n-  }\n-\n-  return false\n-}\n-\n-function fillNewTreeWithOnlyLoadingSegments(\n-  navigatedAt: number,\n-  newCache: CacheNode,\n-  existingCache: CacheNode,\n-  routerState: FlightRouterState,\n-  cacheNodeSeedData: CacheNodeSeedData | null\n-) {\n-  const isLastSegment = Object.keys(routerState[1]).length === 0\n-  if (isLastSegment) {\n-    return\n-  }\n-\n-  for (const key in routerState[1]) {\n-    const parallelRouteState = routerState[1][key]\n-    const segmentForParallelRoute = parallelRouteState[0]\n-    const cacheKey = createRouterCacheKey(segmentForParallelRoute)\n-\n-    const parallelSeedData =\n-      cacheNodeSeedData !== null && cacheNodeSeedData[1][key] !== undefined\n-        ? cacheNodeSeedData[1][key]\n-        : null\n-\n-    let newCacheNode: CacheNode\n-    if (parallelSeedData !== null) {\n-      // New data was sent from the server.\n-      const rsc = parallelSeedData[0]\n-      const loading = parallelSeedData[2]\n-      newCacheNode = {\n-        lazyData: null,\n-        // copy the layout but null the page segment as that's not meant to be used\n-        rsc: segmentForParallelRoute.includes(PAGE_SEGMENT_KEY) ? null : rsc,\n-        prefetchRsc: null,\n-        head: null,\n-        prefetchHead: null,\n-        parallelRoutes: new Map(),\n-        loading,\n-        navigatedAt,\n-      }\n-    } else {\n-      // No data available for this node. This will trigger a lazy fetch\n-      // during render.\n-      newCacheNode = {\n-        lazyData: null,\n-        rsc: null,\n-        prefetchRsc: null,\n-        head: null,\n-        prefetchHead: null,\n-        parallelRoutes: new Map(),\n-        loading: null,\n-        navigatedAt: -1,\n-      }\n-    }\n-\n-    const existingParallelRoutes = newCache.parallelRoutes.get(key)\n-    if (existingParallelRoutes) {\n-      existingParallelRoutes.set(cacheKey, newCacheNode)\n-    } else {\n-      newCache.parallelRoutes.set(key, new Map([[cacheKey, newCacheNode]]))\n-    }\n-\n-    fillNewTreeWithOnlyLoadingSegments(\n-      navigatedAt,\n-      newCacheNode,\n-      existingCache,\n-      parallelRouteState,\n-      parallelSeedData\n-    )\n-  }\n-}\n-\n-/**\n- * Add search params to the page segments in the flight router state\n- * Page segments that are associated with search params have a page segment key\n- * followed by a query string. This function will add those params to the page segment.\n- * This is useful if we return an aliased prefetch entry (ie, won't have search params)\n- * but the canonical router URL has search params.\n- */\n-export function addSearchParamsToPageSegments(\n-  flightRouterState: FlightRouterState,\n-  searchParams: Record<string, string | string[] | undefined>\n-): FlightRouterState {\n-  const [segment, parallelRoutes, ...rest] = flightRouterState\n-\n-  // If it's a page segment, modify the segment by adding search params\n-  if (segment.includes(PAGE_SEGMENT_KEY)) {\n-    const newSegment = addSearchParamsIfPageSegment(segment, searchParams)\n-    return [newSegment, parallelRoutes, ...rest]\n-  }\n-\n-  // Otherwise, recurse through the parallel routes and return a new tree\n-  const updatedParallelRoutes: { [key: string]: FlightRouterState } = {}\n-\n-  for (const [key, parallelRoute] of Object.entries(parallelRoutes)) {\n-    updatedParallelRoutes[key] = addSearchParamsToPageSegments(\n-      parallelRoute,\n-      searchParams\n-    )\n-  }\n-\n-  return [segment, updatedParallelRoutes, ...rest]\n-}"
        },
        {
            "sha": "2be5f94048ebd043115b261666b6409d2efa3909",
            "filename": "packages/next/src/client/components/router-reducer/apply-flight-data.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 53,
            "changes": 53,
            "blob_url": "https://github.com/vercel/next.js/blob/80fb15cea6a8f157ec91fe090f4b069a8835895a/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fapply-flight-data.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/80fb15cea6a8f157ec91fe090f4b069a8835895a/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fapply-flight-data.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fapply-flight-data.ts?ref=80fb15cea6a8f157ec91fe090f4b069a8835895a",
            "patch": "@@ -1,53 +0,0 @@\n-import type { CacheNode } from '../../../shared/lib/app-router-types'\n-import { fillLazyItemsTillLeafWithHead } from './fill-lazy-items-till-leaf-with-head'\n-import { fillCacheWithNewSubTreeData } from './fill-cache-with-new-subtree-data'\n-import type { NormalizedFlightData } from '../../flight-data-helpers'\n-\n-export function applyFlightData(\n-  navigatedAt: number,\n-  existingCache: CacheNode,\n-  cache: CacheNode,\n-  flightData: NormalizedFlightData\n-): boolean {\n-  // The one before last item is the router state tree patch\n-  const { tree: treePatch, seedData, head, isRootRender } = flightData\n-\n-  // Handles case where prefetch only returns the router tree patch without rendered components.\n-  if (seedData === null) {\n-    return false\n-  }\n-\n-  if (isRootRender) {\n-    const rsc = seedData[0]\n-    const loading = seedData[2]\n-    cache.loading = loading\n-    cache.rsc = rsc\n-    // This is a PPR-only field. When PPR is enabled, we shouldn't hit\n-    // this path during a navigation, but until PPR is fully implemented\n-    // yet it's possible the existing node does have a non-null\n-    // `prefetchRsc`. As an incremental step, we'll just de-opt to the\n-    // old behavior â€” no PPR value.\n-    cache.prefetchRsc = null\n-    fillLazyItemsTillLeafWithHead(\n-      navigatedAt,\n-      cache,\n-      existingCache,\n-      treePatch,\n-      seedData,\n-      head\n-    )\n-  } else {\n-    // Copy rsc for the root node of the cache.\n-    cache.rsc = existingCache.rsc\n-    // This is a PPR-only field. Unlike the previous branch, since we're\n-    // just cloning the existing cache node, we might as well keep the\n-    // PPR value, if it exists.\n-    cache.prefetchRsc = existingCache.prefetchRsc\n-    cache.parallelRoutes = new Map(existingCache.parallelRoutes)\n-    cache.loading = existingCache.loading\n-    // Create a copy of the existing cache with the rsc applied.\n-    fillCacheWithNewSubTreeData(navigatedAt, cache, existingCache, flightData)\n-  }\n-\n-  return true\n-}"
        },
        {
            "sha": "d41649eb53dd090e4142634f8312854d4d42a0ec",
            "filename": "packages/next/src/client/components/router-reducer/apply-router-state-patch-to-tree.test.tsx",
            "status": "removed",
            "additions": 0,
            "deletions": 87,
            "changes": 87,
            "blob_url": "https://github.com/vercel/next.js/blob/80fb15cea6a8f157ec91fe090f4b069a8835895a/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fapply-router-state-patch-to-tree.test.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/80fb15cea6a8f157ec91fe090f4b069a8835895a/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fapply-router-state-patch-to-tree.test.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fapply-router-state-patch-to-tree.test.tsx?ref=80fb15cea6a8f157ec91fe090f4b069a8835895a",
            "patch": "@@ -1,87 +0,0 @@\n-import React from 'react'\n-import type {\n-  FlightData,\n-  FlightRouterState,\n-} from '../../../shared/lib/app-router-types'\n-import { applyRouterStatePatchToTree } from './apply-router-state-patch-to-tree'\n-\n-const getInitialRouterStateTree = (): FlightRouterState => [\n-  '',\n-  {\n-    children: [\n-      'linking',\n-      {\n-        children: ['', {}],\n-      },\n-    ],\n-  },\n-  undefined,\n-  undefined,\n-  true,\n-]\n-\n-const getFlightData = (): FlightData => {\n-  return [\n-    [\n-      'children',\n-      'linking',\n-      'children',\n-      'about',\n-      [\n-        'about',\n-        {\n-          children: ['', {}],\n-        },\n-      ],\n-      ['about', {}, <h1>About Page!</h1>],\n-      <>\n-        <title>About page!</title>\n-      </>,\n-      false,\n-    ],\n-  ]\n-}\n-\n-describe('applyRouterStatePatchToTree', () => {\n-  it('should apply a patch to the tree', () => {\n-    const initialRouterStateTree = getInitialRouterStateTree()\n-    const flightData = getFlightData()\n-\n-    if (typeof flightData === 'string') {\n-      throw new Error('invalid flight data')\n-    }\n-\n-    // Mirrors the way router-reducer values are passed in.\n-    const flightDataPath = flightData[0]\n-    const [treePatch /*, cacheNodeSeedData, head, isHeadPartial*/] =\n-      flightDataPath.slice(-4)\n-    const flightSegmentPath = flightDataPath.slice(0, -4)\n-\n-    const newRouterStateTree = applyRouterStatePatchToTree(\n-      ['', ...flightSegmentPath],\n-      initialRouterStateTree,\n-      treePatch,\n-      ''\n-    )\n-\n-    expect(newRouterStateTree).toMatchObject([\n-      '',\n-      {\n-        children: [\n-          'linking',\n-          {\n-            children: [\n-              'about',\n-              {\n-                children: ['', {}],\n-              },\n-            ],\n-          },\n-        ],\n-      },\n-      undefined,\n-      undefined,\n-      true,\n-    ])\n-  })\n-})"
        },
        {
            "sha": "c008e267d873c32b2d1727bd20e8d00f87eb952f",
            "filename": "packages/next/src/client/components/router-reducer/apply-router-state-patch-to-tree.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 139,
            "changes": 139,
            "blob_url": "https://github.com/vercel/next.js/blob/80fb15cea6a8f157ec91fe090f4b069a8835895a/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fapply-router-state-patch-to-tree.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/80fb15cea6a8f157ec91fe090f4b069a8835895a/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fapply-router-state-patch-to-tree.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fapply-router-state-patch-to-tree.ts?ref=80fb15cea6a8f157ec91fe090f4b069a8835895a",
            "patch": "@@ -1,139 +0,0 @@\n-import type {\n-  FlightRouterState,\n-  FlightSegmentPath,\n-} from '../../../shared/lib/app-router-types'\n-import { DEFAULT_SEGMENT_KEY } from '../../../shared/lib/segment'\n-import { getNextFlightSegmentPath } from '../../flight-data-helpers'\n-import { matchSegment } from '../match-segments'\n-import { addRefreshMarkerToActiveParallelSegments } from './refetch-inactive-parallel-segments'\n-\n-/**\n- * Deep merge of the two router states. Parallel route keys are preserved if the patch doesn't have them.\n- */\n-function applyPatch(\n-  initialTree: FlightRouterState,\n-  patchTree: FlightRouterState\n-): FlightRouterState {\n-  const [initialSegment, initialParallelRoutes] = initialTree\n-  const [patchSegment, patchParallelRoutes] = patchTree\n-\n-  // if the applied patch segment is __DEFAULT__ then it can be ignored in favor of the initial tree\n-  // this is because the __DEFAULT__ segment is used as a placeholder on navigation\n-  if (\n-    patchSegment === DEFAULT_SEGMENT_KEY &&\n-    initialSegment !== DEFAULT_SEGMENT_KEY\n-  ) {\n-    return initialTree\n-  }\n-\n-  if (matchSegment(initialSegment, patchSegment)) {\n-    const newParallelRoutes: FlightRouterState[1] = {}\n-    for (const key in initialParallelRoutes) {\n-      const isInPatchTreeParallelRoutes =\n-        typeof patchParallelRoutes[key] !== 'undefined'\n-      if (isInPatchTreeParallelRoutes) {\n-        newParallelRoutes[key] = applyPatch(\n-          initialParallelRoutes[key],\n-          patchParallelRoutes[key]\n-        )\n-      } else {\n-        newParallelRoutes[key] = initialParallelRoutes[key]\n-      }\n-    }\n-\n-    for (const key in patchParallelRoutes) {\n-      if (newParallelRoutes[key]) {\n-        continue\n-      }\n-\n-      newParallelRoutes[key] = patchParallelRoutes[key]\n-    }\n-\n-    const tree: FlightRouterState = [initialSegment, newParallelRoutes]\n-\n-    // Copy over the existing tree\n-    if (initialTree[2]) {\n-      tree[2] = initialTree[2]\n-    }\n-\n-    if (initialTree[3]) {\n-      tree[3] = initialTree[3]\n-    }\n-\n-    if (initialTree[4]) {\n-      tree[4] = initialTree[4]\n-    }\n-\n-    return tree\n-  }\n-\n-  return patchTree\n-}\n-\n-/**\n- * Apply the router state from the Flight response, but skip patching default segments.\n- * Useful for patching the router cache when navigating, where we persist the existing default segment if there isn't a new one.\n- * Creates a new router state tree.\n- */\n-export function applyRouterStatePatchToTree(\n-  flightSegmentPath: FlightSegmentPath,\n-  flightRouterState: FlightRouterState,\n-  treePatch: FlightRouterState,\n-  path: string\n-): FlightRouterState | null {\n-  const [segment, parallelRoutes, url, refetch, isRootLayout] =\n-    flightRouterState\n-\n-  // Root refresh\n-  if (flightSegmentPath.length === 1) {\n-    const tree: FlightRouterState = applyPatch(flightRouterState, treePatch)\n-\n-    addRefreshMarkerToActiveParallelSegments(tree, path)\n-\n-    return tree\n-  }\n-\n-  const [currentSegment, parallelRouteKey] = flightSegmentPath\n-\n-  // Tree path returned from the server should always match up with the current tree in the browser\n-  if (!matchSegment(currentSegment, segment)) {\n-    return null\n-  }\n-\n-  const lastSegment = flightSegmentPath.length === 2\n-\n-  let parallelRoutePatch\n-  if (lastSegment) {\n-    parallelRoutePatch = applyPatch(parallelRoutes[parallelRouteKey], treePatch)\n-  } else {\n-    parallelRoutePatch = applyRouterStatePatchToTree(\n-      getNextFlightSegmentPath(flightSegmentPath),\n-      parallelRoutes[parallelRouteKey],\n-      treePatch,\n-      path\n-    )\n-\n-    if (parallelRoutePatch === null) {\n-      return null\n-    }\n-  }\n-\n-  const tree: FlightRouterState = [\n-    flightSegmentPath[0],\n-    {\n-      ...parallelRoutes,\n-      [parallelRouteKey]: parallelRoutePatch,\n-    },\n-    url,\n-    refetch,\n-  ]\n-\n-  // Current segment is the root layout\n-  if (isRootLayout) {\n-    tree[4] = true\n-  }\n-\n-  addRefreshMarkerToActiveParallelSegments(tree, path)\n-\n-  return tree\n-}"
        },
        {
            "sha": "bccf3066e3fd2376493f23a5fcea45ea9556efed",
            "filename": "packages/next/src/client/components/router-reducer/clear-cache-node-data-for-segment-path.test.tsx",
            "status": "removed",
            "additions": 0,
            "deletions": 131,
            "changes": 131,
            "blob_url": "https://github.com/vercel/next.js/blob/80fb15cea6a8f157ec91fe090f4b069a8835895a/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fclear-cache-node-data-for-segment-path.test.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/80fb15cea6a8f157ec91fe090f4b069a8835895a/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fclear-cache-node-data-for-segment-path.test.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fclear-cache-node-data-for-segment-path.test.tsx?ref=80fb15cea6a8f157ec91fe090f4b069a8835895a",
            "patch": "@@ -1,131 +0,0 @@\n-import React from 'react'\n-import { clearCacheNodeDataForSegmentPath } from './clear-cache-node-data-for-segment-path'\n-import type { CacheNode } from '../../../shared/lib/app-router-types'\n-\n-const navigatedAt = -1\n-\n-describe('clearCacheNodeDataForSegmentPath', () => {\n-  it('should clear the data property', () => {\n-    const pathname = '/dashboard/settings'\n-    const segments = pathname.split('/')\n-\n-    const flightSegmentPath = segments\n-      .slice(1)\n-      .map((segment) => ['children', segment])\n-      .flat()\n-\n-    const cache: CacheNode = {\n-      navigatedAt,\n-      lazyData: null,\n-      rsc: null,\n-      prefetchRsc: null,\n-      head: null,\n-      prefetchHead: null,\n-      parallelRoutes: new Map(),\n-      loading: null,\n-    }\n-    const existingCache: CacheNode = {\n-      navigatedAt,\n-      lazyData: null,\n-      rsc: <>Root layout</>,\n-      prefetchRsc: null,\n-      head: null,\n-      prefetchHead: null,\n-      loading: null,\n-      parallelRoutes: new Map([\n-        [\n-          'children',\n-          new Map([\n-            [\n-              'linking',\n-              {\n-                navigatedAt,\n-                lazyData: null,\n-                rsc: <>Linking</>,\n-                prefetchRsc: null,\n-                head: null,\n-                prefetchHead: null,\n-                loading: null,\n-                parallelRoutes: new Map([\n-                  [\n-                    'children',\n-                    new Map([\n-                      [\n-                        '',\n-                        {\n-                          navigatedAt,\n-                          lazyData: null,\n-                          rsc: <>Page</>,\n-                          prefetchRsc: null,\n-                          head: null,\n-                          prefetchHead: null,\n-                          parallelRoutes: new Map(),\n-                          loading: null,\n-                        },\n-                      ],\n-                    ]),\n-                  ],\n-                ]),\n-              },\n-            ],\n-          ]),\n-        ],\n-      ]),\n-    }\n-\n-    clearCacheNodeDataForSegmentPath(cache, existingCache, flightSegmentPath)\n-\n-    expect(cache).toMatchInlineSnapshot(`\n-     {\n-       \"head\": null,\n-       \"lazyData\": null,\n-       \"loading\": null,\n-       \"navigatedAt\": -1,\n-       \"parallelRoutes\": Map {\n-         \"children\" => Map {\n-           \"linking\" => {\n-             \"head\": null,\n-             \"lazyData\": null,\n-             \"loading\": null,\n-             \"navigatedAt\": -1,\n-             \"parallelRoutes\": Map {\n-               \"children\" => Map {\n-                 \"\" => {\n-                   \"head\": null,\n-                   \"lazyData\": null,\n-                   \"loading\": null,\n-                   \"navigatedAt\": -1,\n-                   \"parallelRoutes\": Map {},\n-                   \"prefetchHead\": null,\n-                   \"prefetchRsc\": null,\n-                   \"rsc\": <React.Fragment>\n-                     Page\n-                   </React.Fragment>,\n-                 },\n-               },\n-             },\n-             \"prefetchHead\": null,\n-             \"prefetchRsc\": null,\n-             \"rsc\": <React.Fragment>\n-               Linking\n-             </React.Fragment>,\n-           },\n-           \"dashboard\" => {\n-             \"head\": null,\n-             \"lazyData\": null,\n-             \"loading\": null,\n-             \"navigatedAt\": -1,\n-             \"parallelRoutes\": Map {},\n-             \"prefetchHead\": null,\n-             \"prefetchRsc\": null,\n-             \"rsc\": null,\n-           },\n-         },\n-       },\n-       \"prefetchHead\": null,\n-       \"prefetchRsc\": null,\n-       \"rsc\": null,\n-     }\n-    `)\n-  })\n-})"
        },
        {
            "sha": "f6e8b3425bdc709f8bd9977f17d5d6fa1784175f",
            "filename": "packages/next/src/client/components/router-reducer/clear-cache-node-data-for-segment-path.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 90,
            "changes": 90,
            "blob_url": "https://github.com/vercel/next.js/blob/80fb15cea6a8f157ec91fe090f4b069a8835895a/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fclear-cache-node-data-for-segment-path.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/80fb15cea6a8f157ec91fe090f4b069a8835895a/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fclear-cache-node-data-for-segment-path.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fclear-cache-node-data-for-segment-path.ts?ref=80fb15cea6a8f157ec91fe090f4b069a8835895a",
            "patch": "@@ -1,90 +0,0 @@\n-import type {\n-  FlightSegmentPath,\n-  CacheNode,\n-} from '../../../shared/lib/app-router-types'\n-import { getNextFlightSegmentPath } from '../../flight-data-helpers'\n-import { createRouterCacheKey } from './create-router-cache-key'\n-\n-/**\n- * This will clear the CacheNode data for a particular segment path. This will cause a lazy-fetch in layout router to fill in new data.\n- */\n-export function clearCacheNodeDataForSegmentPath(\n-  newCache: CacheNode,\n-  existingCache: CacheNode,\n-  flightSegmentPath: FlightSegmentPath\n-): void {\n-  const isLastEntry = flightSegmentPath.length <= 2\n-\n-  const [parallelRouteKey, segment] = flightSegmentPath\n-  const cacheKey = createRouterCacheKey(segment)\n-\n-  const existingChildSegmentMap =\n-    existingCache.parallelRoutes.get(parallelRouteKey)\n-\n-  let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey)\n-\n-  if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n-    childSegmentMap = new Map(existingChildSegmentMap)\n-    newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap)\n-  }\n-\n-  const existingChildCacheNode = existingChildSegmentMap?.get(cacheKey)\n-  let childCacheNode = childSegmentMap.get(cacheKey)\n-\n-  // In case of last segment start off the fetch at this level and don't copy further down.\n-  if (isLastEntry) {\n-    if (\n-      !childCacheNode ||\n-      !childCacheNode.lazyData ||\n-      childCacheNode === existingChildCacheNode\n-    ) {\n-      childSegmentMap.set(cacheKey, {\n-        lazyData: null,\n-        rsc: null,\n-        prefetchRsc: null,\n-        head: null,\n-        prefetchHead: null,\n-        parallelRoutes: new Map(),\n-        loading: null,\n-        navigatedAt: -1,\n-      })\n-    }\n-    return\n-  }\n-\n-  if (!childCacheNode || !existingChildCacheNode) {\n-    // Start fetch in the place where the existing cache doesn't have the data yet.\n-    if (!childCacheNode) {\n-      childSegmentMap.set(cacheKey, {\n-        lazyData: null,\n-        rsc: null,\n-        prefetchRsc: null,\n-        head: null,\n-        prefetchHead: null,\n-        parallelRoutes: new Map(),\n-        loading: null,\n-        navigatedAt: -1,\n-      })\n-    }\n-    return\n-  }\n-\n-  if (childCacheNode === existingChildCacheNode) {\n-    childCacheNode = {\n-      lazyData: childCacheNode.lazyData,\n-      rsc: childCacheNode.rsc,\n-      prefetchRsc: childCacheNode.prefetchRsc,\n-      head: childCacheNode.head,\n-      prefetchHead: childCacheNode.prefetchHead,\n-      parallelRoutes: new Map(childCacheNode.parallelRoutes),\n-      loading: childCacheNode.loading,\n-    } as CacheNode\n-    childSegmentMap.set(cacheKey, childCacheNode)\n-  }\n-\n-  return clearCacheNodeDataForSegmentPath(\n-    childCacheNode,\n-    existingChildCacheNode,\n-    getNextFlightSegmentPath(flightSegmentPath)\n-  )\n-}"
        },
        {
            "sha": "6b845d1c9f307e2e24490e2605c32f0785aec3f0",
            "filename": "packages/next/src/client/components/router-reducer/fetch-server-response.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 26,
            "changes": 30,
            "blob_url": "https://github.com/vercel/next.js/blob/889d181474c8fe2847801d607ddff9f63e2de382/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Ffetch-server-response.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/889d181474c8fe2847801d607ddff9f63e2de382/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Ffetch-server-response.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Ffetch-server-response.ts?ref=889d181474c8fe2847801d607ddff9f63e2de382",
            "patch": "@@ -12,9 +12,9 @@ import type {\n   NavigationFlightResponse,\n } from '../../../shared/lib/app-router-types'\n \n-import type { NEXT_ROUTER_SEGMENT_PREFETCH_HEADER } from '../app-router-headers'\n import {\n-  NEXT_ROUTER_PREFETCH_HEADER,\n+  type NEXT_ROUTER_PREFETCH_HEADER,\n+  type NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n   NEXT_ROUTER_STATE_TREE_HEADER,\n   NEXT_RSC_UNION_QUERY,\n   NEXT_URL,\n@@ -28,7 +28,6 @@ import {\n } from '../app-router-headers'\n import { callServer } from '../../app-call-server'\n import { findSourceMapURL } from '../../app-find-source-map-url'\n-import { PrefetchKind } from './router-reducer-types'\n import {\n   normalizeFlightData,\n   prepareFlightRouterStateForRequest,\n@@ -64,7 +63,6 @@ if (\n export interface FetchServerResponseOptions {\n   readonly flightRouterState: FlightRouterState\n   readonly nextUrl: string | null\n-  readonly prefetchKind?: PrefetchKind\n   readonly isHmrRefresh?: boolean\n }\n \n@@ -128,7 +126,7 @@ export async function fetchServerResponse(\n   url: URL,\n   options: FetchServerResponseOptions\n ): Promise<FetchServerResponseResult> {\n-  const { flightRouterState, nextUrl, prefetchKind } = options\n+  const { flightRouterState, nextUrl } = options\n \n   const headers: RequestHeaders = {\n     // Enable flight response\n@@ -140,16 +138,6 @@ export async function fetchServerResponse(\n     ),\n   }\n \n-  /**\n-   * Three cases:\n-   * - `prefetchKind` is `undefined`, it means it's a normal navigation, so we want to prefetch the page data fully\n-   * - `prefetchKind` is `full` - we want to prefetch the whole page so same as above\n-   * - `prefetchKind` is `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully\n-   */\n-  if (prefetchKind === PrefetchKind.AUTO) {\n-    headers[NEXT_ROUTER_PREFETCH_HEADER] = '1'\n-  }\n-\n   if (process.env.NODE_ENV === 'development' && options.isHmrRefresh) {\n     headers[NEXT_HMR_REFRESH_HEADER] = '1'\n   }\n@@ -163,16 +151,6 @@ export async function fetchServerResponse(\n   const originalUrl = url\n \n   try {\n-    // When creating a \"temporary\" prefetch (the \"on-demand\" prefetch that gets created on navigation, if one doesn't exist)\n-    // we send the request with a \"high\" priority as it's in response to a user interaction that could be blocking a transition.\n-    // Otherwise, all other prefetches are sent with a \"low\" priority.\n-    // We use \"auto\" for in all other cases to match the existing default, as this function is shared outside of prefetching.\n-    const fetchPriority = prefetchKind\n-      ? prefetchKind === PrefetchKind.TEMPORARY\n-        ? 'high'\n-        : 'low'\n-      : 'auto'\n-\n     if (process.env.NODE_ENV === 'production') {\n       if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\n         // In \"output: export\" mode, we can't rely on headers to distinguish\n@@ -196,7 +174,7 @@ export async function fetchServerResponse(\n     const res = await createFetch<NavigationFlightResponse>(\n       url,\n       headers,\n-      fetchPriority,\n+      'auto',\n       shouldImmediatelyDecode\n     )\n "
        },
        {
            "sha": "8f236251f87fb10a54569fb468740861df44967d",
            "filename": "packages/next/src/client/components/router-reducer/fill-cache-with-new-subtree-data.test.tsx",
            "status": "removed",
            "additions": 0,
            "deletions": 181,
            "changes": 181,
            "blob_url": "https://github.com/vercel/next.js/blob/80fb15cea6a8f157ec91fe090f4b069a8835895a/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Ffill-cache-with-new-subtree-data.test.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/80fb15cea6a8f157ec91fe090f4b069a8835895a/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Ffill-cache-with-new-subtree-data.test.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Ffill-cache-with-new-subtree-data.test.tsx?ref=80fb15cea6a8f157ec91fe090f4b069a8835895a",
            "patch": "@@ -1,181 +0,0 @@\n-import { fillCacheWithNewSubTreeData } from './fill-cache-with-new-subtree-data'\n-import type { CacheNode } from '../../../shared/lib/app-router-types'\n-import type { NormalizedFlightData } from '../../flight-data-helpers'\n-\n-const getFlightData = (): NormalizedFlightData[] => {\n-  return [\n-    {\n-      pathToSegment: ['children', 'linking', 'children'],\n-      segmentPath: ['children', 'linking', 'children', 'about'],\n-      segment: 'about',\n-      tree: ['about', { children: ['', {}] }],\n-      seedData: [<h1>SubTreeData Injected!</h1>, {}, null, false, false],\n-      head: null,\n-      isHeadPartial: false,\n-      isRootRender: false,\n-    },\n-  ]\n-}\n-\n-describe('fillCacheWithNewSubtreeData', () => {\n-  it('should apply rsc and head property', () => {\n-    const cache: CacheNode = {\n-      navigatedAt: -1,\n-      lazyData: null,\n-      rsc: null,\n-      prefetchRsc: null,\n-      head: null,\n-      prefetchHead: null,\n-      loading: null,\n-      parallelRoutes: new Map(),\n-    }\n-    const existingCache: CacheNode = {\n-      navigatedAt: -1,\n-      lazyData: null,\n-      rsc: <>Root layout</>,\n-      prefetchRsc: null,\n-      head: null,\n-      prefetchHead: null,\n-      loading: null,\n-      parallelRoutes: new Map([\n-        [\n-          'children',\n-          new Map([\n-            [\n-              'linking',\n-              {\n-                navigatedAt: -1,\n-                lazyData: null,\n-                rsc: <>Linking</>,\n-                prefetchRsc: null,\n-                head: null,\n-                prefetchHead: null,\n-                loading: null,\n-                parallelRoutes: new Map([\n-                  [\n-                    'children',\n-                    new Map([\n-                      [\n-                        '',\n-                        {\n-                          navigatedAt: -1,\n-                          lazyData: null,\n-                          rsc: <>Page</>,\n-                          prefetchRsc: null,\n-                          head: null,\n-                          prefetchHead: null,\n-                          loading: null,\n-                          parallelRoutes: new Map(),\n-                        },\n-                      ],\n-                    ]),\n-                  ],\n-                ]),\n-              },\n-            ],\n-          ]),\n-        ],\n-      ]),\n-    }\n-\n-    const flightData = getFlightData()\n-\n-    if (typeof flightData === 'string') {\n-      throw new Error('invalid flight data')\n-    }\n-\n-    // Mirrors the way router-reducer values are passed in.\n-    const normalizedFlightData = flightData[0]\n-\n-    const navigatedAt = -1\n-    fillCacheWithNewSubTreeData(\n-      navigatedAt,\n-      cache,\n-      existingCache,\n-      normalizedFlightData\n-    )\n-\n-    const expectedCache: CacheNode = {\n-      navigatedAt: -1,\n-      lazyData: null,\n-      rsc: null,\n-      prefetchRsc: null,\n-      head: null,\n-      prefetchHead: null,\n-      loading: null,\n-      parallelRoutes: new Map([\n-        [\n-          'children',\n-          new Map([\n-            [\n-              'linking',\n-              {\n-                navigatedAt: -1,\n-                lazyData: null,\n-                rsc: <>Linking</>,\n-                prefetchRsc: null,\n-                head: null,\n-                prefetchHead: null,\n-                loading: null,\n-                parallelRoutes: new Map([\n-                  [\n-                    'children',\n-                    new Map([\n-                      // TODO-APP: this segment should be preserved when creating the new cache\n-                      [\n-                        '',\n-                        {\n-                          navigatedAt: -1,\n-                          lazyData: null,\n-                          rsc: <>Page</>,\n-                          prefetchRsc: null,\n-                          head: null,\n-                          prefetchHead: null,\n-                          loading: null,\n-                          parallelRoutes: new Map(),\n-                        },\n-                      ],\n-                      [\n-                        'about',\n-                        {\n-                          navigatedAt: -1,\n-                          lazyData: null,\n-                          head: null,\n-                          prefetchHead: null,\n-                          loading: null,\n-                          parallelRoutes: new Map([\n-                            [\n-                              'children',\n-                              new Map([\n-                                [\n-                                  '',\n-                                  {\n-                                    lazyData: null,\n-                                    rsc: null,\n-                                    prefetchRsc: null,\n-                                    parallelRoutes: new Map(),\n-                                    prefetchHead: null,\n-                                    loading: null,\n-                                    head: null,\n-                                  },\n-                                ],\n-                              ]),\n-                            ],\n-                          ]),\n-                          rsc: <h1>SubTreeData Injected!</h1>,\n-                          prefetchRsc: null,\n-                        },\n-                      ],\n-                    ]),\n-                  ],\n-                ]),\n-              },\n-            ],\n-          ]),\n-        ],\n-      ]),\n-    }\n-\n-    expect(cache).toMatchObject(expectedCache)\n-  })\n-})"
        },
        {
            "sha": "26f92047c8e955ee5cda8faa2aee497e6643216e",
            "filename": "packages/next/src/client/components/router-reducer/fill-cache-with-new-subtree-data.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 147,
            "changes": 147,
            "blob_url": "https://github.com/vercel/next.js/blob/80fb15cea6a8f157ec91fe090f4b069a8835895a/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Ffill-cache-with-new-subtree-data.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/80fb15cea6a8f157ec91fe090f4b069a8835895a/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Ffill-cache-with-new-subtree-data.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Ffill-cache-with-new-subtree-data.ts?ref=80fb15cea6a8f157ec91fe090f4b069a8835895a",
            "patch": "@@ -1,147 +0,0 @@\n-import type { CacheNode, Segment } from '../../../shared/lib/app-router-types'\n-import { invalidateCacheByRouterState } from './invalidate-cache-by-router-state'\n-import { fillLazyItemsTillLeafWithHead } from './fill-lazy-items-till-leaf-with-head'\n-import { createRouterCacheKey } from './create-router-cache-key'\n-import { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\n-import type { NormalizedFlightData } from '../../flight-data-helpers'\n-\n-/**\n- * Common logic for filling cache with new sub tree data.\n- */\n-function fillCacheHelper(\n-  navigatedAt: number,\n-  newCache: CacheNode,\n-  existingCache: CacheNode,\n-  flightData: NormalizedFlightData,\n-  fillLazyItems: boolean\n-): void {\n-  const {\n-    segmentPath,\n-    seedData: cacheNodeSeedData,\n-    tree: treePatch,\n-    head,\n-  } = flightData\n-  let newCacheNode = newCache\n-  let existingCacheNode = existingCache\n-\n-  for (let i = 0; i < segmentPath.length; i += 2) {\n-    const parallelRouteKey: string = segmentPath[i]\n-    const segment: Segment = segmentPath[i + 1]\n-\n-    // segmentPath is a repeating tuple of parallelRouteKey and segment\n-    // we know we've hit the last entry we've reached our final pair\n-    const isLastEntry = i === segmentPath.length - 2\n-    const cacheKey = createRouterCacheKey(segment)\n-\n-    const existingChildSegmentMap =\n-      existingCacheNode.parallelRoutes.get(parallelRouteKey)\n-\n-    if (!existingChildSegmentMap) {\n-      // Bailout because the existing cache does not have the path to the leaf node\n-      // Will trigger lazy fetch in layout-router because of missing segment\n-      continue\n-    }\n-\n-    let childSegmentMap = newCacheNode.parallelRoutes.get(parallelRouteKey)\n-    if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n-      childSegmentMap = new Map(existingChildSegmentMap)\n-      newCacheNode.parallelRoutes.set(parallelRouteKey, childSegmentMap)\n-    }\n-\n-    const existingChildCacheNode = existingChildSegmentMap.get(cacheKey)\n-    let childCacheNode = childSegmentMap.get(cacheKey)\n-\n-    if (isLastEntry) {\n-      if (\n-        cacheNodeSeedData &&\n-        (!childCacheNode ||\n-          !childCacheNode.lazyData ||\n-          childCacheNode === existingChildCacheNode)\n-      ) {\n-        const rsc = cacheNodeSeedData[0]\n-        const loading = cacheNodeSeedData[2]\n-\n-        childCacheNode = {\n-          lazyData: null,\n-          // When `fillLazyItems` is false, we only want to fill the RSC data for the layout,\n-          // not the page segment.\n-          rsc: fillLazyItems || segment !== PAGE_SEGMENT_KEY ? rsc : null,\n-          prefetchRsc: null,\n-          head: null,\n-          prefetchHead: null,\n-          loading,\n-          parallelRoutes:\n-            fillLazyItems && existingChildCacheNode\n-              ? new Map(existingChildCacheNode.parallelRoutes)\n-              : new Map(),\n-          navigatedAt,\n-        }\n-\n-        if (existingChildCacheNode && fillLazyItems) {\n-          invalidateCacheByRouterState(\n-            childCacheNode,\n-            existingChildCacheNode,\n-            treePatch\n-          )\n-        }\n-        if (fillLazyItems) {\n-          fillLazyItemsTillLeafWithHead(\n-            navigatedAt,\n-            childCacheNode,\n-            existingChildCacheNode,\n-            treePatch,\n-            cacheNodeSeedData,\n-            head\n-          )\n-        }\n-\n-        childSegmentMap.set(cacheKey, childCacheNode)\n-      }\n-      continue\n-    }\n-\n-    if (!childCacheNode || !existingChildCacheNode) {\n-      // Bailout because the existing cache does not have the path to the leaf node\n-      // Will trigger lazy fetch in layout-router because of missing segment\n-      continue\n-    }\n-\n-    if (childCacheNode === existingChildCacheNode) {\n-      childCacheNode = {\n-        lazyData: childCacheNode.lazyData,\n-        rsc: childCacheNode.rsc,\n-        prefetchRsc: childCacheNode.prefetchRsc,\n-        head: childCacheNode.head,\n-        prefetchHead: childCacheNode.prefetchHead,\n-        parallelRoutes: new Map(childCacheNode.parallelRoutes),\n-        loading: childCacheNode.loading,\n-      } as CacheNode\n-      childSegmentMap.set(cacheKey, childCacheNode)\n-    }\n-\n-    // Move deeper into the cache nodes\n-    newCacheNode = childCacheNode\n-    existingCacheNode = existingChildCacheNode\n-  }\n-}\n-\n-/**\n- * Fill cache with rsc based on flightDataPath\n- */\n-export function fillCacheWithNewSubTreeData(\n-  navigatedAt: number,\n-  newCache: CacheNode,\n-  existingCache: CacheNode,\n-  flightData: NormalizedFlightData\n-): void {\n-  fillCacheHelper(navigatedAt, newCache, existingCache, flightData, true)\n-}\n-\n-export function fillCacheWithNewSubTreeDataButOnlyLoading(\n-  navigatedAt: number,\n-  newCache: CacheNode,\n-  existingCache: CacheNode,\n-  flightData: NormalizedFlightData\n-): void {\n-  fillCacheHelper(navigatedAt, newCache, existingCache, flightData, false)\n-}"
        },
        {
            "sha": "5c50be79549294e0b30fcc614a67d75b7b56e99f",
            "filename": "packages/next/src/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.test.tsx",
            "status": "removed",
            "additions": 0,
            "deletions": 204,
            "changes": 204,
            "blob_url": "https://github.com/vercel/next.js/blob/80fb15cea6a8f157ec91fe090f4b069a8835895a/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Ffill-lazy-items-till-leaf-with-head.test.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/80fb15cea6a8f157ec91fe090f4b069a8835895a/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Ffill-lazy-items-till-leaf-with-head.test.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Ffill-lazy-items-till-leaf-with-head.test.tsx?ref=80fb15cea6a8f157ec91fe090f4b069a8835895a",
            "patch": "@@ -1,204 +0,0 @@\n-import React from 'react'\n-import { fillLazyItemsTillLeafWithHead } from './fill-lazy-items-till-leaf-with-head'\n-import type {\n-  CacheNode,\n-  FlightData,\n-} from '../../../shared/lib/app-router-types'\n-\n-const getFlightData = (): FlightData => {\n-  return [\n-    [\n-      [\n-        '',\n-        {\n-          children: [\n-            'linking',\n-            {\n-              children: [\n-                'about',\n-                {\n-                  children: ['', {}],\n-                },\n-              ],\n-            },\n-          ],\n-        },\n-        null,\n-        null,\n-        true,\n-      ],\n-      ['', {}, <h1>About Page!</h1>],\n-      <>\n-        <title>About page!</title>\n-      </>,\n-    ],\n-  ]\n-}\n-\n-const navigatedAt = Date.now()\n-\n-describe('fillLazyItemsTillLeafWithHead', () => {\n-  it('should fill lazy items till leaf with head', () => {\n-    const cache: CacheNode = {\n-      navigatedAt,\n-      lazyData: null,\n-      rsc: null,\n-      prefetchRsc: null,\n-      head: null,\n-      prefetchHead: null,\n-      parallelRoutes: new Map(),\n-      loading: null,\n-    }\n-    const existingCache: CacheNode = {\n-      navigatedAt,\n-      lazyData: null,\n-      rsc: <>Root layout</>,\n-      prefetchRsc: null,\n-      head: null,\n-      prefetchHead: null,\n-      loading: null,\n-      parallelRoutes: new Map([\n-        [\n-          'children',\n-          new Map([\n-            [\n-              'linking',\n-              {\n-                navigatedAt,\n-                lazyData: null,\n-                rsc: <>Linking</>,\n-                prefetchRsc: null,\n-                head: null,\n-                prefetchHead: null,\n-                loading: null,\n-                parallelRoutes: new Map([\n-                  [\n-                    'children',\n-                    new Map([\n-                      [\n-                        '',\n-                        {\n-                          navigatedAt,\n-                          lazyData: null,\n-                          rsc: <>Page</>,\n-                          prefetchRsc: null,\n-                          head: null,\n-                          prefetchHead: null,\n-                          loading: null,\n-                          parallelRoutes: new Map(),\n-                        },\n-                      ],\n-                    ]),\n-                  ],\n-                ]),\n-              },\n-            ],\n-          ]),\n-        ],\n-      ]),\n-    }\n-\n-    const flightData = getFlightData()\n-\n-    if (typeof flightData === 'string') {\n-      throw new Error('invalid flight data')\n-    }\n-\n-    // Mirrors the way router-reducer values are passed in.\n-    const flightDataPath = flightData[0]\n-    const [treePatch, cacheNodeSeedData, head /*, isHeadPartial */] =\n-      flightDataPath.slice(-4)\n-\n-    fillLazyItemsTillLeafWithHead(\n-      navigatedAt,\n-      cache,\n-      existingCache,\n-      treePatch,\n-      cacheNodeSeedData,\n-      head\n-    )\n-\n-    const expectedCache: CacheNode = {\n-      navigatedAt,\n-      lazyData: null,\n-      rsc: null,\n-      prefetchRsc: null,\n-      head: null,\n-      prefetchHead: null,\n-      loading: null,\n-      parallelRoutes: new Map([\n-        [\n-          'children',\n-          new Map([\n-            [\n-              'linking',\n-              {\n-                navigatedAt,\n-                lazyData: null,\n-                rsc: null,\n-                prefetchRsc: null,\n-                head: null,\n-                prefetchHead: null,\n-                loading: null,\n-                parallelRoutes: new Map([\n-                  [\n-                    'children',\n-                    new Map([\n-                      [\n-                        'about',\n-                        {\n-                          navigatedAt,\n-                          lazyData: null,\n-                          loading: null,\n-                          parallelRoutes: new Map([\n-                            [\n-                              'children',\n-                              new Map([\n-                                [\n-                                  '',\n-                                  {\n-                                    navigatedAt,\n-                                    lazyData: null,\n-                                    rsc: null,\n-                                    prefetchRsc: null,\n-                                    prefetchHead: null,\n-                                    loading: null,\n-                                    parallelRoutes: new Map(),\n-                                    head: null,\n-                                  },\n-                                ],\n-                              ]),\n-                            ],\n-                          ]),\n-                          rsc: null,\n-                          prefetchRsc: null,\n-                          head: null,\n-                          prefetchHead: null,\n-                        },\n-                      ],\n-                      [\n-                        '',\n-                        {\n-                          navigatedAt,\n-                          lazyData: null,\n-                          rsc: <>Page</>,\n-                          prefetchRsc: null,\n-                          head: null,\n-                          prefetchHead: null,\n-                          loading: null,\n-                          parallelRoutes: new Map(),\n-                        },\n-                      ],\n-                    ]),\n-                  ],\n-                ]),\n-              },\n-            ],\n-          ]),\n-        ],\n-      ]),\n-    }\n-\n-    expect(cache).toMatchObject(expectedCache)\n-  })\n-})"
        },
        {
            "sha": "9667fb230084e0a75f1b3dab661382cc894c2e65",
            "filename": "packages/next/src/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 145,
            "changes": 145,
            "blob_url": "https://github.com/vercel/next.js/blob/80fb15cea6a8f157ec91fe090f4b069a8835895a/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Ffill-lazy-items-till-leaf-with-head.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/80fb15cea6a8f157ec91fe090f4b069a8835895a/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Ffill-lazy-items-till-leaf-with-head.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Ffill-lazy-items-till-leaf-with-head.ts?ref=80fb15cea6a8f157ec91fe090f4b069a8835895a",
            "patch": "@@ -1,145 +0,0 @@\n-import type { CacheNode } from '../../../shared/lib/app-router-types'\n-import type {\n-  FlightRouterState,\n-  CacheNodeSeedData,\n-} from '../../../shared/lib/app-router-types'\n-import { createRouterCacheKey } from './create-router-cache-key'\n-\n-export function fillLazyItemsTillLeafWithHead(\n-  navigatedAt: number,\n-  newCache: CacheNode,\n-  existingCache: CacheNode | undefined,\n-  routerState: FlightRouterState,\n-  cacheNodeSeedData: CacheNodeSeedData | null,\n-  head: React.ReactNode\n-): void {\n-  const isLastSegment = Object.keys(routerState[1]).length === 0\n-  if (isLastSegment) {\n-    newCache.head = head\n-    return\n-  }\n-  // Remove segment that we got data for so that it is filled in during rendering of rsc.\n-  for (const key in routerState[1]) {\n-    const parallelRouteState = routerState[1][key]\n-    const segmentForParallelRoute = parallelRouteState[0]\n-    const cacheKey = createRouterCacheKey(segmentForParallelRoute)\n-\n-    // TODO: We should traverse the cacheNodeSeedData tree instead of the router\n-    // state tree. Ideally, they would always be the same shape, but because of\n-    // the loading.js pattern, cacheNodeSeedData sometimes only represents a\n-    // partial tree. That's why this node is sometimes null. Once PPR lands,\n-    // loading.js will no longer have special behavior and we can traverse the\n-    // data tree instead.\n-    //\n-    // We should also consider merging the router state tree and the data tree\n-    // in the response format, so that we don't have to send the keys twice.\n-    // Then the client can convert them into separate representations.\n-    const parallelSeedData =\n-      cacheNodeSeedData !== null && cacheNodeSeedData[1][key] !== undefined\n-        ? cacheNodeSeedData[1][key]\n-        : null\n-    if (existingCache) {\n-      const existingParallelRoutesCacheNode =\n-        existingCache.parallelRoutes.get(key)\n-      if (existingParallelRoutesCacheNode) {\n-        let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode)\n-        const existingCacheNode = parallelRouteCacheNode.get(cacheKey)\n-        let newCacheNode: CacheNode\n-        if (parallelSeedData !== null) {\n-          // New data was sent from the server.\n-          const seedNode = parallelSeedData[0]\n-          const loading = parallelSeedData[2]\n-          newCacheNode = {\n-            lazyData: null,\n-            rsc: seedNode,\n-            // This is a PPR-only field. When PPR is enabled, we shouldn't hit\n-            // this path during a navigation, but until PPR is fully implemented\n-            // yet it's possible the existing node does have a non-null\n-            // `prefetchRsc`. As an incremental step, we'll just de-opt to the\n-            // old behavior â€” no PPR value.\n-            prefetchRsc: null,\n-            head: null,\n-            prefetchHead: null,\n-            loading,\n-            parallelRoutes: new Map(existingCacheNode?.parallelRoutes),\n-            navigatedAt,\n-          }\n-        } else {\n-          // No data available for this node. This will trigger a lazy fetch\n-          // during render.\n-          newCacheNode = {\n-            lazyData: null,\n-            rsc: null,\n-            prefetchRsc: null,\n-            head: null,\n-            prefetchHead: null,\n-            parallelRoutes: new Map(existingCacheNode?.parallelRoutes),\n-            loading: null,\n-            navigatedAt,\n-          }\n-        }\n-\n-        // Overrides the cache key with the new cache node.\n-        parallelRouteCacheNode.set(cacheKey, newCacheNode)\n-        // Traverse deeper to apply the head / fill lazy items till the head.\n-        fillLazyItemsTillLeafWithHead(\n-          navigatedAt,\n-          newCacheNode,\n-          existingCacheNode,\n-          parallelRouteState,\n-          parallelSeedData ? parallelSeedData : null,\n-          head\n-        )\n-\n-        newCache.parallelRoutes.set(key, parallelRouteCacheNode)\n-        continue\n-      }\n-    }\n-\n-    let newCacheNode: CacheNode\n-    if (parallelSeedData !== null) {\n-      // New data was sent from the server.\n-      const seedNode = parallelSeedData[0]\n-      const loading = parallelSeedData[2]\n-      newCacheNode = {\n-        lazyData: null,\n-        rsc: seedNode,\n-        prefetchRsc: null,\n-        head: null,\n-        prefetchHead: null,\n-        parallelRoutes: new Map(),\n-        loading,\n-        navigatedAt,\n-      }\n-    } else {\n-      // No data available for this node. This will trigger a lazy fetch\n-      // during render.\n-      newCacheNode = {\n-        lazyData: null,\n-        rsc: null,\n-        prefetchRsc: null,\n-        head: null,\n-        prefetchHead: null,\n-        parallelRoutes: new Map(),\n-        loading: null,\n-        navigatedAt,\n-      }\n-    }\n-\n-    const existingParallelRoutes = newCache.parallelRoutes.get(key)\n-    if (existingParallelRoutes) {\n-      existingParallelRoutes.set(cacheKey, newCacheNode)\n-    } else {\n-      newCache.parallelRoutes.set(key, new Map([[cacheKey, newCacheNode]]))\n-    }\n-\n-    fillLazyItemsTillLeafWithHead(\n-      navigatedAt,\n-      newCacheNode,\n-      undefined,\n-      parallelRouteState,\n-      parallelSeedData,\n-      head\n-    )\n-  }\n-}"
        },
        {
            "sha": "4aadfffe57291b6002b8f63320a26dc142b2bc40",
            "filename": "packages/next/src/client/components/router-reducer/handle-segment-mismatch.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 28,
            "changes": 28,
            "blob_url": "https://github.com/vercel/next.js/blob/80fb15cea6a8f157ec91fe090f4b069a8835895a/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fhandle-segment-mismatch.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/80fb15cea6a8f157ec91fe090f4b069a8835895a/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fhandle-segment-mismatch.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fhandle-segment-mismatch.ts?ref=80fb15cea6a8f157ec91fe090f4b069a8835895a",
            "patch": "@@ -1,28 +0,0 @@\n-import type { FlightRouterState } from '../../../shared/lib/app-router-types'\n-import { handleExternalUrl } from './reducers/navigate-reducer'\n-import type {\n-  ReadonlyReducerState,\n-  ReducerActions,\n-} from './router-reducer-types'\n-\n-/**\n- * Handles the case where the client router attempted to patch the tree but, due to a mismatch, the patch failed.\n- * This will perform an MPA navigation to return the router to a valid state.\n- */\n-export function handleSegmentMismatch(\n-  state: ReadonlyReducerState,\n-  action: ReducerActions,\n-  treePatch: FlightRouterState\n-) {\n-  if (process.env.NODE_ENV === 'development') {\n-    console.warn(\n-      'Performing hard navigation because your application experienced an unrecoverable error. If this keeps occurring, please file a Next.js issue.\\n\\n' +\n-        'Reason: Segment mismatch\\n' +\n-        `Last Action: ${action.type}\\n\\n` +\n-        `Current Tree: ${JSON.stringify(state.tree)}\\n\\n` +\n-        `Tree Patch Payload: ${JSON.stringify(treePatch)}`\n-    )\n-  }\n-\n-  return handleExternalUrl(state, {}, state.canonicalUrl, true)\n-}"
        },
        {
            "sha": "91087f70de46998d90f684e74752bda9f0381c28",
            "filename": "packages/next/src/client/components/router-reducer/invalidate-cache-below-flight-segmentpath.test.tsx",
            "status": "removed",
            "additions": 0,
            "deletions": 163,
            "changes": 163,
            "blob_url": "https://github.com/vercel/next.js/blob/80fb15cea6a8f157ec91fe090f4b069a8835895a/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Finvalidate-cache-below-flight-segmentpath.test.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/80fb15cea6a8f157ec91fe090f4b069a8835895a/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Finvalidate-cache-below-flight-segmentpath.test.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Finvalidate-cache-below-flight-segmentpath.test.tsx?ref=80fb15cea6a8f157ec91fe090f4b069a8835895a",
            "patch": "@@ -1,163 +0,0 @@\n-import React from 'react'\n-import { invalidateCacheBelowFlightSegmentPath } from './invalidate-cache-below-flight-segmentpath'\n-import type { CacheNode } from '../../../shared/lib/app-router-types'\n-import { fillCacheWithNewSubTreeData } from './fill-cache-with-new-subtree-data'\n-import type { NormalizedFlightData } from '../../flight-data-helpers'\n-\n-const getFlightData = (): NormalizedFlightData[] => {\n-  return [\n-    {\n-      pathToSegment: ['children', 'linking', 'children'],\n-      segmentPath: ['children', 'linking', 'children', 'about'],\n-      segment: 'about',\n-      tree: ['about', { children: ['', {}] }],\n-      seedData: [<h1>About Page!</h1>, {}, null, false, false],\n-      head: null,\n-      isHeadPartial: false,\n-      isRootRender: false,\n-    },\n-  ]\n-}\n-\n-const navigatedAt = Date.now()\n-\n-describe('invalidateCacheBelowFlightSegmentPath', () => {\n-  it('should invalidate cache below flight segment path', () => {\n-    const cache: CacheNode = {\n-      navigatedAt,\n-      lazyData: null,\n-      rsc: null,\n-      prefetchRsc: null,\n-      head: null,\n-      prefetchHead: null,\n-      loading: null,\n-      parallelRoutes: new Map(),\n-    }\n-    const existingCache: CacheNode = {\n-      navigatedAt,\n-      lazyData: null,\n-      rsc: <>Root layout</>,\n-      prefetchRsc: null,\n-      head: null,\n-      prefetchHead: null,\n-      loading: null,\n-      parallelRoutes: new Map([\n-        [\n-          'children',\n-          new Map([\n-            [\n-              'linking',\n-              {\n-                navigatedAt,\n-                lazyData: null,\n-                rsc: <>Linking</>,\n-                prefetchRsc: null,\n-                head: null,\n-                prefetchHead: null,\n-                loading: null,\n-                parallelRoutes: new Map([\n-                  [\n-                    'children',\n-                    new Map([\n-                      [\n-                        '',\n-                        {\n-                          navigatedAt,\n-                          lazyData: null,\n-                          rsc: <>Page</>,\n-                          prefetchRsc: null,\n-                          head: null,\n-                          prefetchHead: null,\n-                          loading: null,\n-                          parallelRoutes: new Map(),\n-                        },\n-                      ],\n-                    ]),\n-                  ],\n-                ]),\n-              },\n-            ],\n-          ]),\n-        ],\n-      ]),\n-    }\n-\n-    const flightData = getFlightData()\n-\n-    if (typeof flightData === 'string') {\n-      throw new Error('invalid flight data')\n-    }\n-\n-    // Mirrors the way router-reducer values are passed in.\n-    const normalizedFlightData = flightData[0]\n-\n-    // Copy rsc for the root node of the cache.\n-    cache.rsc = existingCache.rsc\n-    cache.prefetchRsc = existingCache.prefetchRsc\n-    // Create a copy of the existing cache with the rsc applied.\n-    fillCacheWithNewSubTreeData(\n-      navigatedAt,\n-      cache,\n-      existingCache,\n-      normalizedFlightData\n-    )\n-\n-    // Invalidate the cache below the flight segment path. This should remove the 'about' node.\n-    invalidateCacheBelowFlightSegmentPath(\n-      cache,\n-      existingCache,\n-      normalizedFlightData.segmentPath\n-    )\n-\n-    const expectedCache: CacheNode = {\n-      navigatedAt,\n-      lazyData: null,\n-      head: null,\n-      prefetchHead: null,\n-      loading: null,\n-      parallelRoutes: new Map([\n-        [\n-          'children',\n-          new Map([\n-            [\n-              'linking',\n-              {\n-                navigatedAt,\n-                lazyData: null,\n-                head: null,\n-                prefetchHead: null,\n-                loading: null,\n-                parallelRoutes: new Map([\n-                  [\n-                    'children',\n-                    new Map([\n-                      [\n-                        '',\n-                        {\n-                          navigatedAt,\n-                          lazyData: null,\n-                          loading: null,\n-                          parallelRoutes: new Map(),\n-                          rsc: <React.Fragment>Page</React.Fragment>,\n-                          prefetchRsc: null,\n-                          head: null,\n-                          prefetchHead: null,\n-                        },\n-                      ],\n-                    ]),\n-                  ],\n-                ]),\n-                rsc: <React.Fragment>Linking</React.Fragment>,\n-                prefetchRsc: null,\n-              },\n-            ],\n-          ]),\n-        ],\n-      ]),\n-      rsc: <>Root layout</>,\n-      prefetchRsc: null,\n-    }\n-\n-    expect(cache).toMatchObject(expectedCache)\n-  })\n-})"
        },
        {
            "sha": "9c9d617572e6900a91a2078bb39dd30f733875f8",
            "filename": "packages/next/src/client/components/router-reducer/invalidate-cache-below-flight-segmentpath.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 68,
            "changes": 68,
            "blob_url": "https://github.com/vercel/next.js/blob/80fb15cea6a8f157ec91fe090f4b069a8835895a/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Finvalidate-cache-below-flight-segmentpath.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/80fb15cea6a8f157ec91fe090f4b069a8835895a/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Finvalidate-cache-below-flight-segmentpath.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Finvalidate-cache-below-flight-segmentpath.ts?ref=80fb15cea6a8f157ec91fe090f4b069a8835895a",
            "patch": "@@ -1,68 +0,0 @@\n-import type {\n-  CacheNode,\n-  FlightSegmentPath,\n-} from '../../../shared/lib/app-router-types'\n-import { createRouterCacheKey } from './create-router-cache-key'\n-import { getNextFlightSegmentPath } from '../../flight-data-helpers'\n-\n-/**\n- * Fill cache up to the end of the flightSegmentPath, invalidating anything below it.\n- */\n-export function invalidateCacheBelowFlightSegmentPath(\n-  newCache: CacheNode,\n-  existingCache: CacheNode,\n-  flightSegmentPath: FlightSegmentPath\n-): void {\n-  const isLastEntry = flightSegmentPath.length <= 2\n-  const [parallelRouteKey, segment] = flightSegmentPath\n-\n-  const cacheKey = createRouterCacheKey(segment)\n-\n-  const existingChildSegmentMap =\n-    existingCache.parallelRoutes.get(parallelRouteKey)\n-\n-  if (!existingChildSegmentMap) {\n-    // Bailout because the existing cache does not have the path to the leaf node\n-    // Will trigger lazy fetch in layout-router because of missing segment\n-    return\n-  }\n-\n-  let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey)\n-  if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n-    childSegmentMap = new Map(existingChildSegmentMap)\n-    newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap)\n-  }\n-\n-  // In case of last entry don't copy further down.\n-  if (isLastEntry) {\n-    childSegmentMap.delete(cacheKey)\n-    return\n-  }\n-\n-  const existingChildCacheNode = existingChildSegmentMap.get(cacheKey)\n-  let childCacheNode = childSegmentMap.get(cacheKey)\n-\n-  if (!childCacheNode || !existingChildCacheNode) {\n-    // Bailout because the existing cache does not have the path to the leaf node\n-    // Will trigger lazy fetch in layout-router because of missing segment\n-    return\n-  }\n-\n-  if (childCacheNode === existingChildCacheNode) {\n-    childCacheNode = {\n-      lazyData: childCacheNode.lazyData,\n-      rsc: childCacheNode.rsc,\n-      prefetchRsc: childCacheNode.prefetchRsc,\n-      head: childCacheNode.head,\n-      prefetchHead: childCacheNode.prefetchHead,\n-      parallelRoutes: new Map(childCacheNode.parallelRoutes),\n-    } as CacheNode\n-    childSegmentMap.set(cacheKey, childCacheNode)\n-  }\n-\n-  invalidateCacheBelowFlightSegmentPath(\n-    childCacheNode,\n-    existingChildCacheNode,\n-    getNextFlightSegmentPath(flightSegmentPath)\n-  )\n-}"
        },
        {
            "sha": "c4130307cd358feeafb779f9605f544871389e28",
            "filename": "packages/next/src/client/components/router-reducer/invalidate-cache-by-router-state.test.tsx",
            "status": "removed",
            "additions": 0,
            "deletions": 105,
            "changes": 105,
            "blob_url": "https://github.com/vercel/next.js/blob/80fb15cea6a8f157ec91fe090f4b069a8835895a/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Finvalidate-cache-by-router-state.test.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/80fb15cea6a8f157ec91fe090f4b069a8835895a/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Finvalidate-cache-by-router-state.test.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Finvalidate-cache-by-router-state.test.tsx?ref=80fb15cea6a8f157ec91fe090f4b069a8835895a",
            "patch": "@@ -1,105 +0,0 @@\n-import { invalidateCacheByRouterState } from './invalidate-cache-by-router-state'\n-import type {\n-  CacheNode,\n-  FlightRouterState,\n-} from '../../../shared/lib/app-router-types'\n-\n-const navigatedAt = -1\n-\n-describe('invalidateCacheByRouterState', () => {\n-  it('should invalidate the cache by router state', () => {\n-    const cache: CacheNode = {\n-      navigatedAt,\n-      lazyData: null,\n-      rsc: null,\n-      prefetchRsc: null,\n-      head: null,\n-      prefetchHead: null,\n-      loading: null,\n-      parallelRoutes: new Map(),\n-    }\n-    const existingCache: CacheNode = {\n-      navigatedAt,\n-      lazyData: null,\n-      rsc: <>Root layout</>,\n-      prefetchRsc: null,\n-      head: null,\n-      prefetchHead: null,\n-      loading: null,\n-      parallelRoutes: new Map([\n-        [\n-          'children',\n-          new Map([\n-            [\n-              'linking',\n-              {\n-                navigatedAt,\n-                lazyData: null,\n-                rsc: <>Linking</>,\n-                prefetchRsc: null,\n-                head: null,\n-                prefetchHead: null,\n-                loading: null,\n-                parallelRoutes: new Map([\n-                  [\n-                    'children',\n-                    new Map([\n-                      [\n-                        '',\n-                        {\n-                          navigatedAt,\n-                          lazyData: null,\n-                          rsc: <>Page</>,\n-                          prefetchRsc: null,\n-                          head: null,\n-                          prefetchHead: null,\n-                          loading: null,\n-                          parallelRoutes: new Map(),\n-                        },\n-                      ],\n-                    ]),\n-                  ],\n-                ]),\n-              },\n-            ],\n-          ]),\n-        ],\n-      ]),\n-    }\n-\n-    const routerState: FlightRouterState = [\n-      '',\n-      {\n-        children: [\n-          'linking',\n-          {\n-            children: [\n-              'about',\n-              {\n-                children: ['', {}],\n-              },\n-            ],\n-          },\n-        ],\n-      },\n-      null,\n-      null,\n-      true,\n-    ]\n-\n-    invalidateCacheByRouterState(cache, existingCache, routerState)\n-\n-    const expectedCache: CacheNode = {\n-      navigatedAt,\n-      lazyData: null,\n-      rsc: null,\n-      prefetchRsc: null,\n-      head: null,\n-      prefetchHead: null,\n-      loading: null,\n-      parallelRoutes: new Map([['children', new Map()]]),\n-    }\n-\n-    expect(cache).toMatchObject(expectedCache)\n-  })\n-})"
        },
        {
            "sha": "099061f8e8b66588cc74b7c95b42d2146a46bfcd",
            "filename": "packages/next/src/client/components/router-reducer/invalidate-cache-by-router-state.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 27,
            "changes": 27,
            "blob_url": "https://github.com/vercel/next.js/blob/80fb15cea6a8f157ec91fe090f4b069a8835895a/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Finvalidate-cache-by-router-state.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/80fb15cea6a8f157ec91fe090f4b069a8835895a/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Finvalidate-cache-by-router-state.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Finvalidate-cache-by-router-state.ts?ref=80fb15cea6a8f157ec91fe090f4b069a8835895a",
            "patch": "@@ -1,27 +0,0 @@\n-import type {\n-  CacheNode,\n-  FlightRouterState,\n-} from '../../../shared/lib/app-router-types'\n-import { createRouterCacheKey } from './create-router-cache-key'\n-\n-/**\n- * Invalidate cache one level down from the router state.\n- */\n-export function invalidateCacheByRouterState(\n-  newCache: CacheNode,\n-  existingCache: CacheNode,\n-  routerState: FlightRouterState\n-): void {\n-  // Remove segment that we got data for so that it is filled in during rendering of rsc.\n-  for (const key in routerState[1]) {\n-    const segmentForParallelRoute = routerState[1][key][0]\n-    const cacheKey = createRouterCacheKey(segmentForParallelRoute)\n-    const existingParallelRoutesCacheNode =\n-      existingCache.parallelRoutes.get(key)\n-    if (existingParallelRoutesCacheNode) {\n-      let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode)\n-      parallelRouteCacheNode.delete(cacheKey)\n-      newCache.parallelRoutes.set(key, parallelRouteCacheNode)\n-    }\n-  }\n-}"
        },
        {
            "sha": "680fb13766ef786e8e6645bfa29c33a87469b89c",
            "filename": "packages/next/src/client/components/router-reducer/ppr-navigations.ts",
            "status": "modified",
            "additions": 13,
            "deletions": 21,
            "changes": 34,
            "blob_url": "https://github.com/vercel/next.js/blob/889d181474c8fe2847801d607ddff9f63e2de382/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fppr-navigations.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/889d181474c8fe2847801d607ddff9f63e2de382/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fppr-navigations.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fppr-navigations.ts?ref=889d181474c8fe2847801d607ddff9f63e2de382",
            "patch": "@@ -4,9 +4,8 @@ import type {\n   FlightSegmentPath,\n } from '../../../shared/lib/app-router-types'\n import type {\n-  CacheNode,\n   ChildSegmentMap,\n-  ReadyCacheNode,\n+  CacheNode,\n } from '../../../shared/lib/app-router-types'\n import type {\n   HeadData,\n@@ -371,7 +370,7 @@ function updateCacheNodeOnNavigation(\n   // usually we just clone the data from the old CacheNode. However, during a\n   // refresh or a revalidation, there won't be any existing CacheNode. So we\n   // may need to consult the prefetch cache, like we would for a new segment.\n-  let newCacheNode: ReadyCacheNode\n+  let newCacheNode: CacheNode\n   let needsDynamicRequest: boolean\n   if (\n     oldCacheNode !== undefined &&\n@@ -748,7 +747,7 @@ function createCacheNodeOnNavigation(\n     accumulation.scrollableSegments.push(segmentPath)\n   }\n \n-  let newCacheNode: ReadyCacheNode\n+  let newCacheNode: CacheNode\n   let needsDynamicRequest: boolean\n   if (!shouldRefreshDynamicData && oldCacheNode !== undefined) {\n     // Reuse the existing CacheNode\n@@ -1045,10 +1044,9 @@ function reuseDynamicCacheNode(\n   dropPrefetchRsc: boolean,\n   existingCacheNode: CacheNode,\n   parallelRoutes: Map<string, ChildSegmentMap>\n-): ReadyCacheNode {\n+): CacheNode {\n   // Clone an existing CacheNode's data, with (possibly) new children.\n-  const cacheNode: ReadyCacheNode = {\n-    lazyData: null,\n+  const cacheNode: CacheNode = {\n     rsc: existingCacheNode.rsc,\n     prefetchRsc: dropPrefetchRsc ? null : existingCacheNode.prefetchRsc,\n     head: existingCacheNode.head,\n@@ -1073,7 +1071,7 @@ function readCacheNodeFromSeedData(\n   isPageSegment: boolean,\n   parallelRoutes: Map<string, ChildSegmentMap>,\n   navigatedAt: number\n-): ReadyCacheNode {\n+): CacheNode {\n   // TODO: Currently this is threaded through the navigation logic using the\n   // CacheNodeSeedData type, but in the future this will read directly from\n   // the Segment Cache. See readRenderSnapshotFromCache.\n@@ -1107,8 +1105,7 @@ function readCacheNodeFromSeedData(\n     head = null\n   }\n \n-  const cacheNode: ReadyCacheNode = {\n-    lazyData: null,\n+  const cacheNode: CacheNode = {\n     rsc,\n     prefetchRsc,\n     head,\n@@ -1129,7 +1126,7 @@ function spawnNewCacheNode(\n   isLeafSegment: boolean,\n   navigatedAt: number,\n   freshness: FreshnessPolicy\n-): ReadyCacheNode {\n+): CacheNode {\n   // We should never spawn network requests during hydration. We must treat the\n   // initial payload as authoritative, because the initial page load is used\n   // as a last-ditch mechanism for recovering the app.\n@@ -1146,8 +1143,7 @@ function spawnNewCacheNode(\n   // case in updateCacheNodeOnNavigation.\n   const isHydration = freshness === FreshnessPolicy.Hydration\n \n-  const cacheNode: ReadyCacheNode = {\n-    lazyData: null,\n+  const cacheNode: CacheNode = {\n     rsc: !isHydration ? createDeferredRsc() : null,\n     prefetchRsc: null,\n     head: !isHydration && isLeafSegment ? createDeferredRsc() : null,\n@@ -1412,15 +1408,11 @@ function dispatchRetryDueToTreeMismatch(\n   previousNavigationDidMismatch = true\n   const retryAction: ServerPatchAction = {\n     type: ACTION_SERVER_PATCH,\n-    navigatedAt: Date.now(),\n     previousTree: baseTree,\n-    serverResponse: null,\n-    retry: {\n-      url: retryUrl,\n-      nextUrl: retryNextUrl,\n-      seed,\n-      mpa: isHardRetry,\n-    },\n+    url: retryUrl,\n+    nextUrl: retryNextUrl,\n+    seed,\n+    mpa: isHardRetry,\n   }\n   dispatchAppRouterAction(retryAction)\n }"
        },
        {
            "sha": "487bae92d1073bf7ae245f813c8de61637305cb0",
            "filename": "packages/next/src/client/components/router-reducer/reducers/find-head-in-cache.test.tsx",
            "status": "modified",
            "additions": 0,
            "deletions": 5,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/889d181474c8fe2847801d607ddff9f63e2de382/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Ffind-head-in-cache.test.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/889d181474c8fe2847801d607ddff9f63e2de382/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Ffind-head-in-cache.test.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Ffind-head-in-cache.test.tsx?ref=889d181474c8fe2847801d607ddff9f63e2de382",
            "patch": "@@ -30,7 +30,6 @@ describe('findHeadInCache', () => {\n \n     const cache: CacheNode = {\n       navigatedAt,\n-      lazyData: null,\n       rsc: null,\n       prefetchRsc: null,\n       head: null,\n@@ -44,7 +43,6 @@ describe('findHeadInCache', () => {\n               'linking',\n               {\n                 navigatedAt,\n-                lazyData: null,\n                 rsc: null,\n                 prefetchRsc: null,\n                 head: null,\n@@ -58,7 +56,6 @@ describe('findHeadInCache', () => {\n                         'about',\n                         {\n                           navigatedAt,\n-                          lazyData: null,\n                           head: null,\n                           prefetchHead: null,\n                           loading: null,\n@@ -70,7 +67,6 @@ describe('findHeadInCache', () => {\n                                   '',\n                                   {\n                                     navigatedAt,\n-                                    lazyData: null,\n                                     rsc: null,\n                                     prefetchRsc: null,\n                                     prefetchHead: null,\n@@ -90,7 +86,6 @@ describe('findHeadInCache', () => {\n                       // [\n                       //   '',\n                       //   {\n-                      //     lazyData: null,\n                       //     rsc: <>Page</>,\n                       //     prefetchRsc: null,\n                       //     parallelRoutes: new Map(),"
        },
        {
            "sha": "977186b42bf050831e9abd61551d293a2bf89184",
            "filename": "packages/next/src/client/components/router-reducer/reducers/server-patch-reducer.ts",
            "status": "modified",
            "additions": 38,
            "deletions": 123,
            "changes": 161,
            "blob_url": "https://github.com/vercel/next.js/blob/889d181474c8fe2847801d607ddff9f63e2de382/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fserver-patch-reducer.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/889d181474c8fe2847801d607ddff9f63e2de382/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fserver-patch-reducer.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fserver-patch-reducer.ts?ref=889d181474c8fe2847801d607ddff9f63e2de382",
            "patch": "@@ -1,17 +1,11 @@\n import { createHrefFromUrl } from '../create-href-from-url'\n-import { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\n-import { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\n import type {\n   ServerPatchAction,\n   ReducerState,\n   ReadonlyReducerState,\n   Mutable,\n } from '../router-reducer-types'\n import { handleExternalUrl, handleNavigationResult } from './navigate-reducer'\n-import { applyFlightData } from '../apply-flight-data'\n-import { handleMutable } from '../handle-mutable'\n-import type { CacheNode } from '../../../../shared/lib/app-router-types'\n-import { createEmptyCacheNode } from '../../app-router'\n import { navigateToSeededRoute } from '../../segment-cache/navigation'\n import { refreshReducer } from './refresh-reducer'\n import { FreshnessPolicy } from '../ppr-navigations'\n@@ -20,126 +14,47 @@ export function serverPatchReducer(\n   state: ReadonlyReducerState,\n   action: ServerPatchAction\n ): ReducerState {\n-  const { serverResponse, navigatedAt, retry, previousTree } = action\n-\n   const mutable: Mutable = {}\n-\n   mutable.preserveCustomHistoryState = false\n \n-  if (retry !== null) {\n-    // A \"retry\" is a navigation that happens due to a route mismatch. It's\n-    // similar to a refresh, because we will omit any existing dynamic data on\n-    // the page. But we seed the retry navigation with the exact tree that the\n-    // server just responded with.\n-    const retryMpa = retry.mpa\n-    const retryUrl = new URL(retry.url, location.origin)\n-    const retrySeed = retry.seed\n-    if (retryMpa || retrySeed === null) {\n-      // If the server did not send back data during the mismatch, fall back to\n-      // an MPA navigation.\n-      return handleExternalUrl(state, mutable, retryUrl.href, false)\n-    }\n-    const currentUrl = new URL(state.canonicalUrl, location.origin)\n-    if (previousTree !== state.tree) {\n-      // There was another, more recent navigation since the once that\n-      // mismatched. We can abort the retry, but we still need to refresh the\n-      // page to evict any stale dynamic data.\n-      return refreshReducer(state)\n-    }\n-    // There have been no new navigations since the mismatched one. Refresh,\n-    // using the tree we just received from the server.\n-    const retryCanonicalUrl = createHrefFromUrl(retryUrl)\n-    const retryNextUrl = retry.nextUrl\n-    // A retry should not create a new history entry.\n-    const pendingPush = false\n-    const shouldScroll = true\n-    const now = Date.now()\n-    const result = navigateToSeededRoute(\n-      now,\n-      retryUrl,\n-      retryCanonicalUrl,\n-      retrySeed,\n-      currentUrl,\n-      state.cache,\n-      state.tree,\n-      FreshnessPolicy.RefreshAll,\n-      retryNextUrl,\n-      shouldScroll\n-    )\n-    return handleNavigationResult(retryUrl, state, mutable, pendingPush, result)\n-  }\n-\n-  // TODO: The rest of this reducer will be deleted once we migrate the\n-  // remaining to reducers to no longer rely on the lazy data fetch that happens\n-  // on mismatch in LayoutRouter.\n-\n-  if (serverResponse === null) {\n-    // No data provided. Fall back to a hard refresh.\n-    return handleExternalUrl(\n-      state,\n-      mutable,\n-      state.canonicalUrl,\n-      state.pushRef.pendingPush\n-    )\n+  // A \"retry\" is a navigation that happens due to a route mismatch. It's\n+  // similar to a refresh, because we will omit any existing dynamic data on\n+  // the page. But we seed the retry navigation with the exact tree that the\n+  // server just responded with.\n+  const retryMpa = action.mpa\n+  const retryUrl = new URL(action.url, location.origin)\n+  const retrySeed = action.seed\n+  if (retryMpa || retrySeed === null) {\n+    // If the server did not send back data during the mismatch, fall back to\n+    // an MPA navigation.\n+    return handleExternalUrl(state, mutable, retryUrl.href, false)\n   }\n-\n-  // Handle case when navigating to page in `pages` from `app`\n-  if (typeof serverResponse === 'string') {\n-    return handleExternalUrl(\n-      state,\n-      mutable,\n-      serverResponse,\n-      state.pushRef.pendingPush\n-    )\n-  }\n-\n-  const { flightData, canonicalUrl, renderedSearch } = serverResponse\n-\n-  let currentTree = state.tree\n-  let currentCache = state.cache\n-\n-  for (const normalizedFlightData of flightData) {\n-    const { segmentPath: flightSegmentPath, tree: treePatch } =\n-      normalizedFlightData\n-\n-    const newTree = applyRouterStatePatchToTree(\n-      // TODO-APP: remove ''\n-      ['', ...flightSegmentPath],\n-      currentTree,\n-      treePatch,\n-      state.canonicalUrl\n-    )\n-\n-    // `applyRouterStatePatchToTree` returns `null` when it determined that the server response is not applicable to the current tree.\n-    // In other words, the server responded with a tree that doesn't match what the client is currently rendering.\n-    // This can happen if the server patch action took longer to resolve than a subsequent navigation which would have changed the tree.\n-    // Previously this case triggered an MPA navigation but it should be safe to simply discard the server response rather than forcing\n-    // the entire page to reload.\n-    if (newTree === null) {\n-      return state\n-    }\n-\n-    if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n-      return handleExternalUrl(\n-        state,\n-        mutable,\n-        state.canonicalUrl,\n-        state.pushRef.pendingPush\n-      )\n-    }\n-\n-    mutable.canonicalUrl = createHrefFromUrl(canonicalUrl)\n-\n-    const cache: CacheNode = createEmptyCacheNode()\n-    applyFlightData(navigatedAt, currentCache, cache, normalizedFlightData)\n-\n-    mutable.patchedTree = newTree\n-    mutable.renderedSearch = renderedSearch\n-    mutable.cache = cache\n-\n-    currentCache = cache\n-    currentTree = newTree\n+  const currentUrl = new URL(state.canonicalUrl, location.origin)\n+  if (action.previousTree !== state.tree) {\n+    // There was another, more recent navigation since the once that\n+    // mismatched. We can abort the retry, but we still need to refresh the\n+    // page to evict any stale dynamic data.\n+    return refreshReducer(state)\n   }\n-\n-  return handleMutable(state, mutable)\n+  // There have been no new navigations since the mismatched one. Refresh,\n+  // using the tree we just received from the server.\n+  const retryCanonicalUrl = createHrefFromUrl(retryUrl)\n+  const retryNextUrl = action.nextUrl\n+  // A retry should not create a new history entry.\n+  const pendingPush = false\n+  const shouldScroll = true\n+  const now = Date.now()\n+  const result = navigateToSeededRoute(\n+    now,\n+    retryUrl,\n+    retryCanonicalUrl,\n+    retrySeed,\n+    currentUrl,\n+    state.cache,\n+    state.tree,\n+    FreshnessPolicy.RefreshAll,\n+    retryNextUrl,\n+    shouldScroll\n+  )\n+  return handleNavigationResult(retryUrl, state, mutable, pendingPush, result)\n }"
        },
        {
            "sha": "d7cca9bd1d04ae567ada7b80d78b11c8c76a850b",
            "filename": "packages/next/src/client/components/router-reducer/refetch-inactive-parallel-segments.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 139,
            "changes": 139,
            "blob_url": "https://github.com/vercel/next.js/blob/80fb15cea6a8f157ec91fe090f4b069a8835895a/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Frefetch-inactive-parallel-segments.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/80fb15cea6a8f157ec91fe090f4b069a8835895a/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Frefetch-inactive-parallel-segments.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Frefetch-inactive-parallel-segments.ts?ref=80fb15cea6a8f157ec91fe090f4b069a8835895a",
            "patch": "@@ -1,139 +0,0 @@\n-import type {\n-  FlightRouterState,\n-  CacheNode,\n-} from '../../../shared/lib/app-router-types'\n-import type { AppRouterState } from './router-reducer-types'\n-import { applyFlightData } from './apply-flight-data'\n-import { fetchServerResponse } from './fetch-server-response'\n-import { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\n-\n-interface RefreshInactiveParallelSegments {\n-  navigatedAt: number\n-  state: AppRouterState\n-  updatedTree: FlightRouterState\n-  updatedCache: CacheNode\n-  includeNextUrl: boolean\n-  canonicalUrl: string\n-}\n-\n-/**\n- * Refreshes inactive segments that are still in the current FlightRouterState.\n- * A segment is considered \"inactive\" when the server response indicates it didn't match to a page component.\n- * This happens during a soft-navigation, where the server will want to patch in the segment\n- * with the \"default\" component, but we explicitly ignore the server in this case\n- * and keep the existing state for that segment. New data for inactive segments are inherently\n- * not part of the server response when we patch the tree, because they were associated with a response\n- * from an earlier navigation/request. For each segment, once it becomes \"active\", we encode the URL that provided\n- * the data for it. This function traverses parallel routes looking for these markers so that it can re-fetch\n- * and patch the new data into the tree.\n- */\n-export async function refreshInactiveParallelSegments(\n-  options: RefreshInactiveParallelSegments\n-) {\n-  const fetchedSegments = new Set<string>()\n-  await refreshInactiveParallelSegmentsImpl({\n-    ...options,\n-    rootTree: options.updatedTree,\n-    fetchedSegments,\n-  })\n-}\n-\n-async function refreshInactiveParallelSegmentsImpl({\n-  navigatedAt,\n-  state,\n-  updatedTree,\n-  updatedCache,\n-  includeNextUrl,\n-  fetchedSegments,\n-  rootTree = updatedTree,\n-  canonicalUrl,\n-}: RefreshInactiveParallelSegments & {\n-  fetchedSegments: Set<string>\n-  rootTree: FlightRouterState\n-}) {\n-  const [, parallelRoutes, refetchPath, refetchMarker] = updatedTree\n-  const fetchPromises = []\n-\n-  if (\n-    refetchPath &&\n-    refetchPath !== canonicalUrl &&\n-    refetchMarker === 'refresh' &&\n-    // it's possible for the tree to contain multiple segments that contain data at the same URL\n-    // we keep track of them so we can dedupe the requests\n-    !fetchedSegments.has(refetchPath)\n-  ) {\n-    fetchedSegments.add(refetchPath) // Mark this URL as fetched\n-\n-    // Eagerly kick off the fetch for the refetch path & the parallel routes. This should be fine to do as they each operate\n-    // independently on their own cache nodes, and `applyFlightData` will copy anything it doesn't care about from the existing cache.\n-    const fetchPromise = fetchServerResponse(\n-      new URL(refetchPath, location.origin),\n-      {\n-        // refetch from the root of the updated tree, otherwise it will be scoped to the current segment\n-        // and might not contain the data we need to patch in interception route data (such as dynamic params from a previous segment)\n-        flightRouterState: [rootTree[0], rootTree[1], rootTree[2], 'refetch'],\n-        nextUrl: includeNextUrl ? state.nextUrl : null,\n-      }\n-    ).then((result) => {\n-      if (typeof result !== 'string') {\n-        const { flightData } = result\n-        for (const flightDataPath of flightData) {\n-          // we only pass the new cache as this function is called after clearing the router cache\n-          // and filling in the new page data from the server. Meaning the existing cache is actually the cache that's\n-          // just been created & has been written to, but hasn't been \"committed\" yet.\n-          applyFlightData(\n-            navigatedAt,\n-            updatedCache,\n-            updatedCache,\n-            flightDataPath\n-          )\n-        }\n-      } else {\n-        // When result is a string, it suggests that the server response should have triggered an MPA navigation\n-        // I'm not 100% sure of this decision, but it seems unlikely that we'd want to introduce a redirect side effect\n-        // when refreshing on-screen data, so handling this has been ommitted.\n-      }\n-    })\n-\n-    fetchPromises.push(fetchPromise)\n-  }\n-\n-  for (const key in parallelRoutes) {\n-    const parallelFetchPromise = refreshInactiveParallelSegmentsImpl({\n-      navigatedAt,\n-      state,\n-      updatedTree: parallelRoutes[key],\n-      updatedCache,\n-      includeNextUrl,\n-      fetchedSegments,\n-      rootTree,\n-      canonicalUrl,\n-    })\n-\n-    fetchPromises.push(parallelFetchPromise)\n-  }\n-\n-  await Promise.all(fetchPromises)\n-}\n-\n-/**\n- * Walks the current parallel segments to determine if they are \"active\".\n- * An active parallel route will have a `__PAGE__` segment in the FlightRouterState.\n- * As opposed to a `__DEFAULT__` segment, which means there was no match for that parallel route.\n- * We add a special marker here so that we know how to refresh its data when the router is revalidated.\n- */\n-export function addRefreshMarkerToActiveParallelSegments(\n-  tree: FlightRouterState,\n-  path: string\n-) {\n-  const [segment, parallelRoutes, , refetchMarker] = tree\n-  // a page segment might also contain concatenated search params, so we do a partial match on the key\n-  if (segment.includes(PAGE_SEGMENT_KEY) && refetchMarker !== 'refresh') {\n-    tree[2] = path\n-    tree[3] = 'refresh'\n-  }\n-\n-  for (const key in parallelRoutes) {\n-    addRefreshMarkerToActiveParallelSegments(parallelRoutes[key], path)\n-  }\n-}"
        },
        {
            "sha": "02feeb2379a0322f8b30f29cb5e90bc39b561137",
            "filename": "packages/next/src/client/components/router-reducer/router-reducer-types.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 12,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/889d181474c8fe2847801d607ddff9f63e2de382/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Frouter-reducer-types.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/889d181474c8fe2847801d607ddff9f63e2de382/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Frouter-reducer-types.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Frouter-reducer-types.ts?ref=889d181474c8fe2847801d607ddff9f63e2de382",
            "patch": "@@ -132,33 +132,25 @@ export type AppHistoryState = {\n \n /**\n  * Server-patch applies the provided Flight data to the cache and router tree.\n- * - Only triggered in layout-router.\n- * - Creates a new cache and router state with the Flight data applied.\n  */\n export interface ServerPatchAction {\n   type: typeof ACTION_SERVER_PATCH\n-  navigatedAt: number\n-  serverResponse: FetchServerResponseResult | null\n   previousTree: FlightRouterState\n-  retry: null | {\n-    url: URL\n-    nextUrl: string | null\n-    seed: NavigationSeed | null\n-    mpa: boolean\n-  }\n+  url: URL\n+  nextUrl: string | null\n+  seed: NavigationSeed | null\n+  mpa: boolean\n }\n \n /**\n  * PrefetchKind defines the type of prefetching that should be done.\n  * - `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully.\n  * - `full` - prefetch the page data fully.\n- * - `temporary` - a temporary prefetch entry is added to the cache, this is used when prefetch={false} is used in next/link or when you push a route programmatically.\n  */\n \n export enum PrefetchKind {\n   AUTO = 'auto',\n   FULL = 'full',\n-  TEMPORARY = 'temporary',\n }\n \n /**"
        },
        {
            "sha": "60927b3d5ec5173c58aab6a4103cf1c983b4e9e9",
            "filename": "packages/next/src/shared/lib/app-router-types.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 61,
            "changes": 70,
            "blob_url": "https://github.com/vercel/next.js/blob/889d181474c8fe2847801d607ddff9f63e2de382/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fapp-router-types.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/889d181474c8fe2847801d607ddff9f63e2de382/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fapp-router-types.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fapp-router-types.ts?ref=889d181474c8fe2847801d607ddff9f63e2de382",
            "patch": "@@ -4,7 +4,7 @@\n  * This file contains type definitions that can be safely imported\n  * by both client-side and server-side code without circular dependencies.\n  */\n-import type { FetchServerResponseResult } from '../../client/components/router-reducer/fetch-server-response'\n+\n import type React from 'react'\n \n export type LoadingModuleData =\n@@ -19,68 +19,15 @@ export type ChildSegmentMap = Map<string, CacheNode>\n /**\n  * Cache node used in app-router / layout-router.\n  */\n-export type CacheNode = ReadyCacheNode | LazyCacheNode\n-\n-export type LazyCacheNode = {\n-  /**\n-   * When rsc is null, this is a lazily-initialized cache node.\n-   *\n-   * If the app attempts to render it, it triggers a lazy data fetch,\n-   * postpones the render, and schedules an update to a new tree.\n-   *\n-   * TODO: This mechanism should not be used when PPR is enabled, though it\n-   * currently is in some cases until we've implemented partial\n-   * segment fetching.\n-   */\n-  rsc: null\n-\n-  /**\n-   * A prefetched version of the segment data. See explanation in corresponding\n-   * field of ReadyCacheNode (below).\n-   *\n-   * Since LazyCacheNode mostly only exists in the non-PPR implementation, this\n-   * will usually be null, but it could have been cloned from a previous\n-   * CacheNode that was created by the PPR implementation. Eventually we want\n-   * to migrate everything away from LazyCacheNode entirely.\n-   */\n-  prefetchRsc: React.ReactNode\n-\n-  /**\n-   * A pending response for the lazy data fetch. If this is not present\n-   * during render, it is lazily created.\n-   */\n-  lazyData: Promise<FetchServerResponseResult> | null\n-\n-  prefetchHead: HeadData | null\n-\n-  head: HeadData\n-\n-  loading: LoadingModuleData | Promise<LoadingModuleData>\n \n-  /**\n-   * Child parallel routes.\n-   */\n-  parallelRoutes: Map<string, ChildSegmentMap>\n-\n-  /**\n-   * The timestamp of the navigation that last updated the CacheNode's data. If\n-   * a CacheNode is reused from a previous navigation, this value is not\n-   * updated. Used to track the staleness of the data.\n-   */\n-  navigatedAt: number\n-}\n-\n-export type ReadyCacheNode = {\n+export type CacheNode = {\n   /**\n    * When rsc is not null, it represents the RSC data for the\n    * corresponding segment.\n    *\n    * `null` is a valid React Node but because segment data is always a\n-   * <LayoutRouter> component, we can use `null` to represent empty.\n-   *\n-   * TODO: For additional type safety, update this type to\n-   * Exclude<React.ReactNode, null>. Need to update createEmptyCacheNode to\n-   * accept rsc as an argument, or just inline the callers.\n+   * <LayoutRouter> component, we can use `null` to represent empty. When it is\n+   * null, it represents missing data, and rendering should suspend.\n    */\n   rsc: React.ReactNode\n \n@@ -97,10 +44,6 @@ export type ReadyCacheNode = {\n    */\n   prefetchRsc: React.ReactNode\n \n-  /**\n-   * There should never be a lazy data request in this case.\n-   */\n-  lazyData: null\n   prefetchHead: HeadData | null\n \n   head: HeadData\n@@ -109,6 +52,11 @@ export type ReadyCacheNode = {\n \n   parallelRoutes: Map<string, ChildSegmentMap>\n \n+  /**\n+   * The timestamp of the navigation that last updated the CacheNode's data. If\n+   * a CacheNode is reused from a previous navigation, this value is not\n+   * updated. Used to track the staleness of the data.\n+   */\n   navigatedAt: number\n }\n "
        }
    ],
    "stats": {
        "total": 2490,
        "additions": 95,
        "deletions": 2395
    }
}