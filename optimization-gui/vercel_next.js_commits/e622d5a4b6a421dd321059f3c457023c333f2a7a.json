{
    "author": "lukesandberg",
    "message": "[turbopack] Remove LocalTaskType::Native, it is dead (#85480)\n\n### What\nRemove `LocalTaskType::Native` and supporting infrastructure.  Simplify schedule_local_task to remove an allocation and `CaptureFuture`.\n\n### Why?\nlocal tasks for things other than 'resolve' tasks have been proven to not be a very useful idea.  However, for resolve tasks they do still make sense.  We can use the small amount of indirection provided by `LocalTask` to optimize how we launch other turbotasks.\n\nNow that the local task implementation is clearly just about turbo-tasks infrastructure (rather than calling arbitrary 'user code') we can simplify dispatching a bit.",
    "sha": "e622d5a4b6a421dd321059f3c457023c333f2a7a",
    "files": [
        {
            "sha": "d704546f0de747e74678d76482c7155cfb853e58",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/local_tasks.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 74,
            "changes": 74,
            "blob_url": "https://github.com/vercel/next.js/blob/13bf3d97bb3013a49b32f7a1f5c4ebe893b289ce/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Flocal_tasks.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/13bf3d97bb3013a49b32f7a1f5c4ebe893b289ce/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Flocal_tasks.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Flocal_tasks.rs?ref=13bf3d97bb3013a49b32f7a1f5c4ebe893b289ce",
            "patch": "@@ -1,74 +0,0 @@\n-#![feature(arbitrary_self_types)]\n-#![feature(arbitrary_self_types_pointers)]\n-#![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n-\n-use anyhow::Result;\n-use turbo_tasks::{Vc, test_helpers::current_task_for_testing};\n-use turbo_tasks_testing::{Registration, register, run_once};\n-\n-static REGISTRATION: Registration = register!();\n-\n-fn task_id() -> u32 {\n-    if let Some(id) = current_task_for_testing() {\n-        *id\n-    } else {\n-        0\n-    }\n-}\n-\n-#[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n-async fn test_local_task_id() -> Result<()> {\n-    run_once(&REGISTRATION, || async {\n-        let local_vc = get_local_task_id();\n-        assert!(local_vc.is_local());\n-        assert_eq!(*local_vc.await.unwrap(), task_id());\n-\n-        let local_trait_vc = Foo {}.cell().get_local_task_id();\n-        assert!(local_trait_vc.is_local());\n-        assert_eq!(*local_trait_vc.await.unwrap(), task_id());\n-\n-        let non_local_vc = get_non_local_task_id();\n-        assert!(!non_local_vc.is_local());\n-        assert_ne!(*non_local_vc.await.unwrap(), task_id());\n-\n-        let non_local_trait_vc = Foo {}.cell().get_non_local_task_id();\n-        assert!(!non_local_trait_vc.is_local());\n-        assert_ne!(*non_local_trait_vc.await.unwrap(), task_id());\n-\n-        Ok(())\n-    })\n-    .await\n-}\n-\n-#[turbo_tasks::function(local)]\n-fn get_local_task_id() -> Vc<u32> {\n-    Vc::cell(task_id())\n-}\n-\n-#[turbo_tasks::function]\n-fn get_non_local_task_id() -> Vc<u32> {\n-    Vc::cell(task_id())\n-}\n-\n-#[turbo_tasks::value_trait]\n-trait SomeTrait {\n-    #[turbo_tasks::function]\n-    fn get_local_task_id(self: Vc<Self>) -> Vc<u32>;\n-    #[turbo_tasks::function]\n-    fn get_non_local_task_id(self: Vc<Self>) -> Vc<u32>;\n-}\n-#[turbo_tasks::value(shared)]\n-struct Foo {}\n-\n-#[turbo_tasks::value_impl]\n-impl SomeTrait for Foo {\n-    #[turbo_tasks::function(local)]\n-    fn get_local_task_id(self: Vc<Self>) -> Vc<u32> {\n-        Vc::cell(task_id())\n-    }\n-\n-    #[turbo_tasks::function]\n-    fn get_non_local_task_id(self: Vc<Self>) -> Vc<u32> {\n-        Vc::cell(task_id())\n-    }\n-}"
        },
        {
            "sha": "fde319111907ac0b50a6c1f92728ac65633433e2",
            "filename": "turbopack/crates/turbo-tasks-macros-tests/tests/function/fail_attribute_invalid_args.stderr",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/e622d5a4b6a421dd321059f3c457023c333f2a7a/turbopack%2Fcrates%2Fturbo-tasks-macros-tests%2Ftests%2Ffunction%2Ffail_attribute_invalid_args.stderr",
            "raw_url": "https://github.com/vercel/next.js/raw/e622d5a4b6a421dd321059f3c457023c333f2a7a/turbopack%2Fcrates%2Fturbo-tasks-macros-tests%2Ftests%2Ffunction%2Ffail_attribute_invalid_args.stderr",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros-tests%2Ftests%2Ffunction%2Ffail_attribute_invalid_args.stderr?ref=e622d5a4b6a421dd321059f3c457023c333f2a7a",
            "patch": "@@ -1,4 +1,4 @@\n-error: unexpected token, expected one of: \"fs\", \"network\", \"operation\", \"local\"\n+error: unexpected token, expected one of: \"fs\", \"network\", or \"operation\"\n   --> tests/function/fail_attribute_invalid_args.rs:10:25\n    |\n 10 | #[turbo_tasks::function(invalid_argument)]"
        },
        {
            "sha": "56e5323844be930ebdefc1ea7c083f10ef12201e",
            "filename": "turbopack/crates/turbo-tasks-macros-tests/tests/function/fail_attribute_invalid_args_inherent_impl.stderr",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/e622d5a4b6a421dd321059f3c457023c333f2a7a/turbopack%2Fcrates%2Fturbo-tasks-macros-tests%2Ftests%2Ffunction%2Ffail_attribute_invalid_args_inherent_impl.stderr",
            "raw_url": "https://github.com/vercel/next.js/raw/e622d5a4b6a421dd321059f3c457023c333f2a7a/turbopack%2Fcrates%2Fturbo-tasks-macros-tests%2Ftests%2Ffunction%2Ffail_attribute_invalid_args_inherent_impl.stderr",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros-tests%2Ftests%2Ffunction%2Ffail_attribute_invalid_args_inherent_impl.stderr?ref=e622d5a4b6a421dd321059f3c457023c333f2a7a",
            "patch": "@@ -1,4 +1,4 @@\n-error: unexpected token, expected one of: \"fs\", \"network\", \"operation\", \"local\"\n+error: unexpected token, expected one of: \"fs\", \"network\", or \"operation\"\n   --> tests/function/fail_attribute_invalid_args_inherent_impl.rs:15:29\n    |\n 15 |     #[turbo_tasks::function(invalid_argument)]"
        },
        {
            "sha": "8bff9d3b19277a874e2190cfadae9f465c95f895",
            "filename": "turbopack/crates/turbo-tasks-macros/src/func.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 45,
            "changes": 51,
            "blob_url": "https://github.com/vercel/next.js/blob/e622d5a4b6a421dd321059f3c457023c333f2a7a/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Ffunc.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e622d5a4b6a421dd321059f3c457023c333f2a7a/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Ffunc.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Ffunc.rs?ref=e622d5a4b6a421dd321059f3c457023c333f2a7a",
            "patch": "@@ -30,8 +30,6 @@ pub struct TurboFn<'a> {\n     exposed_inputs: Vec<Input>,\n     /// Should we return `OperationVc` and require that all arguments are `NonLocalValue`s?\n     operation: bool,\n-    /// Should this function use `TaskPersistence::LocalCells`?\n-    local: bool,\n }\n \n #[derive(Debug)]\n@@ -206,7 +204,6 @@ impl TurboFn<'_> {\n             this,\n             exposed_inputs,\n             operation: args.operation.is_some(),\n-            local: args.local.is_some(),\n             inline_ident,\n         })\n     }\n@@ -494,26 +491,14 @@ impl TurboFn<'_> {\n     }\n \n     pub fn persistence(&self) -> impl ToTokens {\n-        if self.local {\n-            quote! {\n-                turbo_tasks::TaskPersistence::Local\n-            }\n-        } else {\n-            quote! {\n-                turbo_tasks::macro_helpers::get_non_local_persistence_from_inputs(&*inputs)\n-            }\n+        quote! {\n+            turbo_tasks::macro_helpers::get_persistence_from_inputs(&*inputs)\n         }\n     }\n \n     pub fn persistence_with_this(&self) -> impl ToTokens {\n-        if self.local {\n-            quote! {\n-                turbo_tasks::TaskPersistence::Local\n-            }\n-        } else {\n-            quote! {\n-                turbo_tasks::macro_helpers::get_non_local_persistence_from_inputs_and_this(this, &*inputs)\n-            }\n+        quote! {\n+            turbo_tasks::macro_helpers::get_persistence_from_inputs_and_this(this, &*inputs)\n         }\n     }\n \n@@ -748,10 +733,6 @@ pub struct FunctionArguments {\n     ///\n     /// If there is an error due to this option being set, it should be reported to this span.\n     pub operation: Option<Span>,\n-    /// Does not run the function as a real task, and instead runs it inside the parent task using\n-    /// task-local state. The function call itself will not be cached, but cells will be created on\n-    /// the parent task.\n-    pub local: Option<Span>,\n }\n \n impl Parse for FunctionArguments {\n@@ -776,24 +757,15 @@ impl Parse for FunctionArguments {\n                 (\"operation\", Meta::Path(_)) => {\n                     parsed_args.operation = Some(meta.span());\n                 }\n-                (\"local\", Meta::Path(_)) => {\n-                    parsed_args.local = Some(meta.span());\n-                }\n                 (_, meta) => {\n                     return Err(syn::Error::new_spanned(\n                         meta,\n-                        \"unexpected token, expected one of: \\\"fs\\\", \\\"network\\\", \\\"operation\\\", \\\n-                         \\\"local\\\"\",\n+                        \"unexpected token, expected one of: \\\"fs\\\", \\\"network\\\", or \\\"operation\\\"\",\n                     ));\n                 }\n             }\n         }\n-        if let (Some(_), Some(span)) = (parsed_args.local, parsed_args.operation) {\n-            return Err(syn::Error::new(\n-                span,\n-                \"\\\"operation\\\" is mutually exclusive with the \\\"local\\\" option\",\n-            ));\n-        }\n+\n         Ok(parsed_args)\n     }\n }\n@@ -1111,7 +1083,6 @@ pub struct NativeFn {\n     /// Used only if `is_method` is true.\n     pub is_self_used: bool,\n     pub filter_trait_call_args: Option<FilterTraitCallArgsTokens>,\n-    pub local: bool,\n }\n \n impl NativeFn {\n@@ -1127,7 +1098,6 @@ impl NativeFn {\n             is_method,\n             is_self_used,\n             filter_trait_call_args,\n-            local,\n         } = self;\n \n         if *is_method {\n@@ -1153,9 +1123,6 @@ impl NativeFn {\n                         turbo_tasks::macro_helpers::NativeFunction::new_method(\n                             #function_path_string,\n                             #function_global_name,\n-                            turbo_tasks::macro_helpers::FunctionMeta {\n-                                local: #local,\n-                            },\n                             #arg_filter,\n                             #function_path,\n                         )\n@@ -1168,9 +1135,6 @@ impl NativeFn {\n                         turbo_tasks::macro_helpers::NativeFunction::new_method_without_this(\n                             #function_path_string,\n                             #function_global_name,\n-                            turbo_tasks::macro_helpers::FunctionMeta {\n-                                local: #local,\n-                            },\n                             #arg_filter,\n                             #function_path,\n                         )\n@@ -1184,9 +1148,6 @@ impl NativeFn {\n                     turbo_tasks::macro_helpers::NativeFunction::new_function(\n                         #function_path_string,\n                         #function_global_name,\n-                        turbo_tasks::macro_helpers::FunctionMeta {\n-                            local: #local,\n-                        },\n                         #function_path,\n                     )\n                 }"
        },
        {
            "sha": "b01529f020016beeaa8630506aae143259472702",
            "filename": "turbopack/crates/turbo-tasks-macros/src/function_macro.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/e622d5a4b6a421dd321059f3c457023c333f2a7a/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Ffunction_macro.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e622d5a4b6a421dd321059f3c457023c333f2a7a/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Ffunction_macro.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Ffunction_macro.rs?ref=e622d5a4b6a421dd321059f3c457023c333f2a7a",
            "patch": "@@ -41,7 +41,6 @@ pub fn function(args: TokenStream, input: TokenStream) -> TokenStream {\n     let args = syn::parse::<FunctionArguments>(args)\n         .inspect_err(|err| errors.push(err.to_compile_error()))\n         .unwrap_or_default();\n-    let local = args.local.is_some();\n     let is_self_used = args.operation.is_some() || is_self_used(&block);\n \n     let Some(turbo_fn) = TurboFn::new(&sig, DefinitionContext::NakedFn, args) else {\n@@ -66,7 +65,6 @@ pub fn function(args: TokenStream, input: TokenStream) -> TokenStream {\n         is_method: turbo_fn.is_method(),\n         is_self_used,\n         filter_trait_call_args: None, // not a trait method\n-        local,\n     };\n     let native_function_ident = get_native_function_ident(ident);\n     let native_function_ty = native_fn.ty();"
        },
        {
            "sha": "5308431bcb40b334a87020a24ee9750ae613f944",
            "filename": "turbopack/crates/turbo-tasks-macros/src/value_impl_macro.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 4,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/e622d5a4b6a421dd321059f3c457023c333f2a7a/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_impl_macro.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e622d5a4b6a421dd321059f3c457023c333f2a7a/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_impl_macro.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_impl_macro.rs?ref=e622d5a4b6a421dd321059f3c457023c333f2a7a",
            "patch": "@@ -97,7 +97,6 @@ pub fn value_impl(args: TokenStream, input: TokenStream) -> TokenStream {\n                         FunctionArguments::default()\n                     }\n                 };\n-                let local = func_args.local.is_some();\n                 let is_self_used = func_args.operation.is_some() || is_self_used(block);\n \n                 let Some(turbo_fn) =\n@@ -120,7 +119,6 @@ pub fn value_impl(args: TokenStream, input: TokenStream) -> TokenStream {\n                     is_method: turbo_fn.is_method(),\n                     is_self_used,\n                     filter_trait_call_args: None, // not a trait method\n-                    local,\n                 };\n \n                 let native_function_ident = get_inherent_impl_function_ident(ty_ident, ident);\n@@ -209,7 +207,6 @@ pub fn value_impl(args: TokenStream, input: TokenStream) -> TokenStream {\n                         continue;\n                     }\n                 };\n-                let local = func_args.local.is_some();\n                 let is_self_used = func_args.operation.is_some() || is_self_used(block);\n \n                 let Some(turbo_fn) =\n@@ -246,7 +243,6 @@ pub fn value_impl(args: TokenStream, input: TokenStream) -> TokenStream {\n                     is_method: turbo_fn.is_method(),\n                     is_self_used,\n                     filter_trait_call_args: turbo_fn.filter_trait_call_args(),\n-                    local,\n                 };\n \n                 let native_function_ident ="
        },
        {
            "sha": "c3c64e332962e4765f7386dda5cd6f7ed12404df",
            "filename": "turbopack/crates/turbo-tasks-macros/src/value_trait_macro.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 5,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/e622d5a4b6a421dd321059f3c457023c333f2a7a/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_trait_macro.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e622d5a4b6a421dd321059f3c457023c333f2a7a/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_trait_macro.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_trait_macro.rs?ref=e622d5a4b6a421dd321059f3c457023c333f2a7a",
            "patch": "@@ -212,11 +212,6 @@ pub fn value_trait(args: TokenStream, input: TokenStream) -> TokenStream {\n                 is_method: turbo_fn.is_method(),\n                 is_self_used,\n                 filter_trait_call_args: turbo_fn.filter_trait_call_args(),\n-                // `local` is currently unsupported here because:\n-                // - The `#[turbo_tasks::function]` macro needs to be present for us to read this\n-                //   argument. (This could be fixed)\n-                // - This only makes sense when a default implementation is present.\n-                local: false,\n             };\n \n             let native_function_ident = get_trait_default_impl_function_ident(trait_ident, ident);"
        },
        {
            "sha": "10b3be172cb251c5b5b995b8d7981d17fc68b7e9",
            "filename": "turbopack/crates/turbo-tasks/src/macro_helpers.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/e622d5a4b6a421dd321059f3c457023c333f2a7a/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmacro_helpers.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e622d5a4b6a421dd321059f3c457023c333f2a7a/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmacro_helpers.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmacro_helpers.rs?ref=e622d5a4b6a421dd321059f3c457023c333f2a7a",
            "patch": "@@ -16,7 +16,7 @@ pub use crate::{\n     magic_any::MagicAny,\n     manager::{find_cell_by_type, spawn_detached_for_testing},\n     native_function::{\n-        CollectableFunction, FunctionMeta, NativeFunction, downcast_args_owned, downcast_args_ref,\n+        CollectableFunction, NativeFunction, downcast_args_owned, downcast_args_ref,\n     },\n     value_type::{CollectableTrait, CollectableValueType},\n };\n@@ -32,15 +32,15 @@ pub async fn value_debug_format_field(value: ValueDebugFormatString<'_>) -> Stri\n     }\n }\n \n-pub fn get_non_local_persistence_from_inputs(inputs: &impl TaskInput) -> TaskPersistence {\n+pub fn get_persistence_from_inputs(inputs: &impl TaskInput) -> TaskPersistence {\n     if inputs.is_transient() {\n         TaskPersistence::Transient\n     } else {\n         TaskPersistence::Persistent\n     }\n }\n \n-pub fn get_non_local_persistence_from_inputs_and_this(\n+pub fn get_persistence_from_inputs_and_this(\n     this: RawVc,\n     inputs: &impl TaskInput,\n ) -> TaskPersistence {"
        },
        {
            "sha": "35614148370c2e65ebd07464d738fa5a379ffba7",
            "filename": "turbopack/crates/turbo-tasks/src/manager.rs",
            "status": "modified",
            "additions": 49,
            "deletions": 65,
            "changes": 114,
            "blob_url": "https://github.com/vercel/next.js/blob/e622d5a4b6a421dd321059f3c457023c333f2a7a/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e622d5a4b6a421dd321059f3c457023c333f2a7a/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs?ref=e622d5a4b6a421dd321059f3c457023c333f2a7a",
            "patch": "@@ -279,16 +279,6 @@ pub enum TaskPersistence {\n     /// type [`TransientValue`][crate::value::TransientValue] or\n     /// [`TransientInstance`][crate::value::TransientInstance].\n     Transient,\n-\n-    /// Tasks that are persisted only for the lifetime of the nearest non-`Local` parent caller.\n-    ///\n-    /// This task does not have a unique task id, and is not shared with the backend. Instead it\n-    /// uses the parent task's id.\n-    ///\n-    /// This is useful for functions that have a low cache hit rate. Those functions could be\n-    /// converted to non-task functions, but that would break their function signature. This\n-    /// provides a mechanism for skipping caching without changing the function signature.\n-    Local,\n }\n \n #[derive(Clone, Copy, Debug, Eq, PartialEq, Default)]\n@@ -620,42 +610,23 @@ impl<B: Backend + 'static> TurboTasks<B> {\n         arg: Box<dyn MagicAny>,\n         persistence: TaskPersistence,\n     ) -> RawVc {\n-        match persistence {\n-            TaskPersistence::Local => {\n-                let task_type = LocalTaskSpec {\n-                    task_type: LocalTaskType::Native { native_fn },\n-                    this,\n-                    arg,\n-                };\n-                self.schedule_local_task(task_type, persistence)\n-            }\n-            TaskPersistence::Transient => {\n-                let task_type = CachedTaskType {\n-                    native_fn,\n-                    this,\n-                    arg,\n-                };\n-\n-                RawVc::TaskOutput(self.backend.get_or_create_transient_task(\n-                    task_type,\n-                    current_task_if_available(\"turbo_function calls\"),\n-                    self,\n-                ))\n-            }\n-            TaskPersistence::Persistent => {\n-                let task_type = CachedTaskType {\n-                    native_fn,\n-                    this,\n-                    arg,\n-                };\n-\n-                RawVc::TaskOutput(self.backend.get_or_create_persistent_task(\n-                    task_type,\n-                    current_task_if_available(\"turbo_function calls\"),\n-                    self,\n-                ))\n-            }\n-        }\n+        let task_type = CachedTaskType {\n+            native_fn,\n+            this,\n+            arg,\n+        };\n+        RawVc::TaskOutput(match persistence {\n+            TaskPersistence::Transient => self.backend.get_or_create_transient_task(\n+                task_type,\n+                current_task_if_available(\"turbo_function calls\"),\n+                self,\n+            ),\n+            TaskPersistence::Persistent => self.backend.get_or_create_persistent_task(\n+                task_type,\n+                current_task_if_available(\"turbo_function calls\"),\n+                self,\n+            ),\n+        })\n     }\n \n     pub fn dynamic_call(\n@@ -794,12 +765,6 @@ impl<B: Backend + 'static> TurboTasks<B> {\n         &self,\n         ty: LocalTaskSpec,\n         // if this is a `LocalTaskType::Resolve*`, we may spawn another task with this persistence,\n-        // if this is a `LocalTaskType::Native`, persistence is unused.\n-        //\n-        // TODO: In the rare case that we're crossing a transient->persistent boundary, we should\n-        // force `LocalTaskType::Native` to be spawned as real tasks, so that any cells they create\n-        // have the correct persistence. This is not an issue for resolution stub task, as they\n-        // don't end up owning any cells.\n         persistence: TaskPersistence,\n     ) -> RawVc {\n         let task_type = ty.task_type;\n@@ -830,24 +795,43 @@ impl<B: Backend + 'static> TurboTasks<B> {\n \n         let this = self.pin();\n         let future = async move {\n-            let TaskExecutionSpec { future, span } =\n-                crate::task::local_task::get_local_task_execution_spec(&*this, &ty, persistence);\n+            let span = match &ty.task_type {\n+                LocalTaskType::ResolveNative { native_fn } => native_fn.resolve_span(),\n+                LocalTaskType::ResolveTrait { trait_method } => trait_method.resolve_span(),\n+            };\n             async move {\n-                let result = CaptureFuture::new(future).await;\n-\n-                let result = match result {\n-                    Ok(Ok(raw_vc)) => Ok(raw_vc),\n-                    Ok(Err(err)) => Err(err.into()),\n-                    Err(err) => Err(TurboTasksExecutionError::Panic(Arc::new(err))),\n+                let result = match ty.task_type {\n+                    LocalTaskType::ResolveNative { native_fn } => {\n+                        LocalTaskType::run_resolve_native(\n+                            native_fn,\n+                            ty.this,\n+                            &*ty.arg,\n+                            persistence,\n+                            this,\n+                        )\n+                        .await\n+                    }\n+                    LocalTaskType::ResolveTrait { trait_method } => {\n+                        LocalTaskType::run_resolve_trait(\n+                            trait_method,\n+                            ty.this.unwrap(),\n+                            &*ty.arg,\n+                            persistence,\n+                            this,\n+                        )\n+                        .await\n+                    }\n                 };\n \n-                let local_task = LocalTask::Done {\n-                    output: match result {\n-                        Ok(raw_vc) => OutputContent::Link(raw_vc),\n-                        Err(err) => OutputContent::Error(err.with_task_context(task_type)),\n-                    },\n+                let output = match result {\n+                    Ok(raw_vc) => OutputContent::Link(raw_vc),\n+                    Err(err) => OutputContent::Error(\n+                        TurboTasksExecutionError::from(err).with_task_context(task_type),\n+                    ),\n                 };\n \n+                let local_task = LocalTask::Done { output };\n+\n                 let done_event = CURRENT_TASK_STATE.with(move |gts| {\n                     let mut gts_write = gts.write().unwrap();\n                     let scheduled_task ="
        },
        {
            "sha": "0c06ea985be715840478c11a07ddc1e0259b5126",
            "filename": "turbopack/crates/turbo-tasks/src/native_function.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 25,
            "changes": 27,
            "blob_url": "https://github.com/vercel/next.js/blob/e622d5a4b6a421dd321059f3c457023c333f2a7a/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fnative_function.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e622d5a4b6a421dd321059f3c457023c333f2a7a/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fnative_function.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fnative_function.rs?ref=e622d5a4b6a421dd321059f3c457023c333f2a7a",
            "patch": "@@ -142,22 +142,12 @@ pub fn downcast_args_ref<T: MagicAny>(args: &dyn MagicAny) -> &T {\n         .unwrap()\n }\n \n-#[derive(Debug)]\n-pub struct FunctionMeta {\n-    /// Does not run the function as a task, and instead runs it inside the parent task using\n-    /// task-local state. The function call itself will not be cached, but cells will be created on\n-    /// the parent task.\n-    pub local: bool,\n-}\n-\n /// A native (rust) turbo-tasks function. It's used internally by\n /// `#[turbo_tasks::function]`.\n pub struct NativeFunction {\n     /// A readable name of the function that is used to reporting purposes.\n     pub(crate) name: &'static str,\n \n-    pub(crate) function_meta: FunctionMeta,\n-\n     pub(crate) arg_meta: ArgMeta,\n \n     /// The functor that creates a functor from inputs. The inner functor\n@@ -173,7 +163,6 @@ impl Debug for NativeFunction {\n         f.debug_struct(\"NativeFunction\")\n             .field(\"name\", &self.name)\n             .field(\"global_name\", &self.global_name)\n-            .field(\"function_meta\", &self.function_meta)\n             .finish_non_exhaustive()\n     }\n }\n@@ -182,7 +171,6 @@ impl NativeFunction {\n     pub fn new_function<Mode, Inputs>(\n         name: &'static str,\n         global_name: &'static str,\n-        function_meta: FunctionMeta,\n         implementation: impl IntoTaskFn<Mode, Inputs>,\n     ) -> Self\n     where\n@@ -191,7 +179,6 @@ impl NativeFunction {\n         Self {\n             name,\n             global_name,\n-            function_meta,\n             arg_meta: ArgMeta::new::<Inputs>(),\n             implementation: Box::new(implementation.into_task_fn()),\n         }\n@@ -200,7 +187,6 @@ impl NativeFunction {\n     pub fn new_method_without_this<Mode, Inputs, I>(\n         name: &'static str,\n         global_name: &'static str,\n-        function_meta: FunctionMeta,\n         arg_filter: Option<(FilterOwnedArgsFunctor, FilterAndResolveFunctor)>,\n         implementation: I,\n     ) -> Self\n@@ -211,7 +197,6 @@ impl NativeFunction {\n         Self {\n             name,\n             global_name,\n-            function_meta,\n             arg_meta: if let Some((filter_owned, filter_and_resolve)) = arg_filter {\n                 ArgMeta::with_filter_trait_call::<Inputs>(filter_owned, filter_and_resolve)\n             } else {\n@@ -224,7 +209,6 @@ impl NativeFunction {\n     pub fn new_method<Mode, This, Inputs, I>(\n         name: &'static str,\n         global_name: &'static str,\n-        function_meta: FunctionMeta,\n         arg_filter: Option<(FilterOwnedArgsFunctor, FilterAndResolveFunctor)>,\n         implementation: I,\n     ) -> Self\n@@ -236,7 +220,6 @@ impl NativeFunction {\n         Self {\n             name,\n             global_name,\n-            function_meta,\n             arg_meta: if let Some((filter_owned, filter_and_resolve)) = arg_filter {\n                 ArgMeta::with_filter_trait_call::<Inputs>(filter_owned, filter_and_resolve)\n             } else {\n@@ -258,7 +241,6 @@ impl NativeFunction {\n         let flags = match persistence {\n             TaskPersistence::Persistent => \"\",\n             TaskPersistence::Transient => \"transient\",\n-            TaskPersistence::Local => \"local\",\n         };\n         tracing::trace_span!(\n             \"turbo_tasks::function\",\n@@ -268,13 +250,8 @@ impl NativeFunction {\n         )\n     }\n \n-    pub fn resolve_span(&'static self, persistence: TaskPersistence) -> Span {\n-        let flags = match persistence {\n-            TaskPersistence::Persistent => \"\",\n-            TaskPersistence::Transient => \"transient\",\n-            TaskPersistence::Local => \"local\",\n-        };\n-        tracing::trace_span!(\"turbo_tasks::resolve_call\", name = self.name, flags = flags)\n+    pub fn resolve_span(&'static self) -> Span {\n+        tracing::trace_span!(\"turbo_tasks::resolve_call\", name = self.name)\n     }\n }\n impl PartialEq for NativeFunction {"
        },
        {
            "sha": "e39257434ca3b20a54346bbbf8ce4f79b6dd6eed",
            "filename": "turbopack/crates/turbo-tasks/src/raw_vc.rs",
            "status": "modified",
            "additions": 11,
            "deletions": 9,
            "changes": 20,
            "blob_url": "https://github.com/vercel/next.js/blob/e622d5a4b6a421dd321059f3c457023c333f2a7a/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fraw_vc.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e622d5a4b6a421dd321059f3c457023c333f2a7a/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fraw_vc.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fraw_vc.rs?ref=e622d5a4b6a421dd321059f3c457023c333f2a7a",
            "patch": "@@ -241,16 +241,18 @@ impl RawVc {\n     /// Convert a potentially local `RawVc` into a non-local `RawVc`. This is a subset of resolution\n     /// resolution, because the returned `RawVc` can be a `TaskOutput`.\n     pub(crate) async fn to_non_local(self) -> Result<RawVc> {\n-        let tt = turbo_tasks();\n-        let mut current = self;\n-        loop {\n-            match current {\n-                RawVc::LocalOutput(execution_id, local_task_id, ..) => {\n-                    current = read_local_output(&*tt, execution_id, local_task_id).await?;\n-                }\n-                non_local => return Ok(non_local),\n+        Ok(match self {\n+            RawVc::LocalOutput(execution_id, local_task_id, ..) => {\n+                let tt = turbo_tasks();\n+                let local_output = read_local_output(&*tt, execution_id, local_task_id).await?;\n+                debug_assert!(\n+                    !matches!(local_output, RawVc::LocalOutput(_, _, _)),\n+                    \"a LocalOutput cannot point at other LocalOutputs\"\n+                );\n+                local_output\n             }\n-        }\n+            non_local => non_local,\n+        })\n     }\n \n     pub(crate) fn connect(&self) {"
        },
        {
            "sha": "da5c4fb4fcf3501128fdb7f033ee875f5a194095",
            "filename": "turbopack/crates/turbo-tasks/src/task/function.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 4,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/e622d5a4b6a421dd321059f3c457023c333f2a7a/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask%2Ffunction.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e622d5a4b6a421dd321059f3c457023c333f2a7a/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask%2Ffunction.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask%2Ffunction.rs?ref=e622d5a4b6a421dd321059f3c457023c333f2a7a",
            "patch": "@@ -186,10 +186,6 @@ fn get_args<T: MagicAny + Clone>(arg: &dyn MagicAny) -> Result<T> {\n \n // Helper function for `task_fn_impl!()`\n async fn output_try_into_non_local_raw_vc(output: impl TaskOutput) -> Result<RawVc> {\n-    // TODO: Potential future optimization: If we know we're inside a local task, we can avoid\n-    // calling `to_non_local()` here, which might let us avoid constructing a non-local cell for the\n-    // local task's return value. Flattening chains of `RawVc::LocalOutput` may still be useful to\n-    // reduce traversal later.\n     output.try_into_raw_vc()?.to_non_local().await\n }\n "
        },
        {
            "sha": "32288856862c0d8d11a6676f347df27f9d7a4325",
            "filename": "turbopack/crates/turbo-tasks/src/task/local_task.rs",
            "status": "modified",
            "additions": 8,
            "deletions": 56,
            "changes": 64,
            "blob_url": "https://github.com/vercel/next.js/blob/e622d5a4b6a421dd321059f3c457023c333f2a7a/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask%2Flocal_task.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e622d5a4b6a421dd321059f3c457023c333f2a7a/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask%2Flocal_task.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask%2Flocal_task.rs?ref=e622d5a4b6a421dd321059f3c457023c333f2a7a",
            "patch": "@@ -3,9 +3,9 @@ use std::{fmt, sync::Arc};\n use anyhow::{Result, anyhow};\n \n use crate::{\n-    MagicAny, OutputContent, RawVc, TaskExecutionReason, TaskPersistence, TraitMethod,\n-    TurboTasksBackendApi, ValueTypeId,\n-    backend::{Backend, TaskExecutionSpec, TypedCellContent},\n+    MagicAny, OutputContent, RawVc, TaskPersistence, TraitMethod, TurboTasksBackendApi,\n+    ValueTypeId,\n+    backend::{Backend, TypedCellContent},\n     event::Event,\n     macro_helpers::NativeFunction,\n     registry,\n@@ -17,50 +17,6 @@ pub enum LocalTask {\n     Done { output: OutputContent },\n }\n \n-pub fn get_local_task_execution_spec<'a>(\n-    turbo_tasks: &'_ dyn TurboTasksBackendApi<impl Backend + 'static>,\n-    ty: &'a LocalTaskSpec,\n-    // if this is a `LocalTaskType::Resolve*`, we'll spawn another task with this persistence, if\n-    // this is a `LocalTaskType::Native`, this refers to the parent non-local task.\n-    persistence: TaskPersistence,\n-) -> TaskExecutionSpec<'a> {\n-    match ty.task_type {\n-        LocalTaskType::Native { native_fn } => {\n-            let span = native_fn.span(TaskPersistence::Local, TaskExecutionReason::Local);\n-            let entered = span.enter();\n-            let future = native_fn.execute(ty.this, &*ty.arg);\n-            drop(entered);\n-            TaskExecutionSpec { future, span }\n-        }\n-        LocalTaskType::ResolveNative { native_fn } => {\n-            let span = native_fn.resolve_span(TaskPersistence::Local);\n-            let entered = span.enter();\n-            let future = Box::pin(LocalTaskType::run_resolve_native(\n-                native_fn,\n-                ty.this,\n-                &*ty.arg,\n-                persistence,\n-                turbo_tasks.pin(),\n-            ));\n-            drop(entered);\n-            TaskExecutionSpec { future, span }\n-        }\n-        LocalTaskType::ResolveTrait { trait_method } => {\n-            let span = trait_method.resolve_span();\n-            let entered = span.enter();\n-            let future = Box::pin(LocalTaskType::run_resolve_trait(\n-                trait_method,\n-                ty.this.unwrap(),\n-                &*ty.arg,\n-                persistence,\n-                turbo_tasks.pin(),\n-            ));\n-            drop(entered);\n-            TaskExecutionSpec { future, span }\n-        }\n-    }\n-}\n-\n pub struct LocalTaskSpec {\n     /// The self value, will always be present for `ResolveTrait` tasks and is optional otherwise\n     pub(crate) this: Option<RawVc>,\n@@ -71,11 +27,8 @@ pub struct LocalTaskSpec {\n \n #[derive(Copy, Clone)]\n pub enum LocalTaskType {\n-    /// A normal task execution a native (rust) function\n-    Native { native_fn: &'static NativeFunction },\n-\n     /// A resolve task, which resolves arguments and calls the function with resolve arguments. The\n-    /// inner function call will be a `PersistentTaskType` or `LocalTaskType::Native`.\n+    /// inner function call will be a `PersistentTaskType`.\n     ResolveNative { native_fn: &'static NativeFunction },\n \n     /// A trait method resolve task. It resolves the first (`self`) argument and looks up the trait\n@@ -87,7 +40,6 @@ pub enum LocalTaskType {\n impl fmt::Display for LocalTaskType {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n-            LocalTaskType::Native { native_fn } => f.write_str(native_fn.name),\n             LocalTaskType::ResolveNative { native_fn } => write!(f, \"*{}\", native_fn.name),\n             LocalTaskType::ResolveTrait { trait_method } => write!(\n                 f,\n@@ -101,7 +53,7 @@ impl fmt::Display for LocalTaskType {\n impl LocalTaskType {\n     /// Implementation of the LocalTaskType::ResolveNative task.\n     /// Resolves all the task inputs and then calls the given function.\n-    async fn run_resolve_native<B: Backend + 'static>(\n+    pub(crate) async fn run_resolve_native<B: Backend + 'static>(\n         native_fn: &'static NativeFunction,\n         mut this: Option<RawVc>,\n         arg: &dyn MagicAny,\n@@ -115,7 +67,7 @@ impl LocalTaskType {\n         Ok(turbo_tasks.native_call(native_fn, this, arg, persistence))\n     }\n     /// Implementation of the LocalTaskType::ResolveTrait task.\n-    async fn run_resolve_trait<B: Backend + 'static>(\n+    pub(crate) async fn run_resolve_trait<B: Backend + 'static>(\n         trait_method: &'static TraitMethod,\n         this: RawVc,\n         arg: &dyn MagicAny,\n@@ -164,11 +116,11 @@ pub(crate) mod tests {\n     #[test]\n     fn test_fmt() {\n         assert_eq!(\n-            LocalTaskType::Native {\n+            LocalTaskType::ResolveNative {\n                 native_fn: &MOCK_FUNC_TASK_FUNCTION,\n             }\n             .to_string(),\n-            \"mock_func_task\",\n+            \"*mock_func_task\",\n         );\n         assert_eq!(\n             LocalTaskType::ResolveTrait {"
        }
    ],
    "stats": {
        "total": 375,
        "additions": 81,
        "deletions": 294
    }
}