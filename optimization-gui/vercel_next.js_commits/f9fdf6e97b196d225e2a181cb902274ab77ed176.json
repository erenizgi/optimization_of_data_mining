{
    "author": "bgw",
    "message": "Turbopack: bincode: Add custom bincode reader/writer implementations (#86632)\n\n- We need a custom writer because we want to write to a `SmallVec`, and I don't want to go through `std::io::Write`â€‹ to do that, as there's potential error checking overhead that's not needed (might compile away, but I don't want to take any chances).\n- We need a custom reader because bincode's reader doesn't allow underlying access to the buffer mid-read.",
    "sha": "f9fdf6e97b196d225e2a181cb902274ab77ed176",
    "files": [
        {
            "sha": "171d6e0e6eb94af2abc459fd0f432e23683b9501",
            "filename": "turbopack/crates/turbo-bincode/src/lib.rs",
            "status": "modified",
            "additions": 111,
            "deletions": 2,
            "changes": 113,
            "blob_url": "https://github.com/vercel/next.js/blob/f9fdf6e97b196d225e2a181cb902274ab77ed176/turbopack%2Fcrates%2Fturbo-bincode%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f9fdf6e97b196d225e2a181cb902274ab77ed176/turbopack%2Fcrates%2Fturbo-bincode%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-bincode%2Fsrc%2Flib.rs?ref=f9fdf6e97b196d225e2a181cb902274ab77ed176",
            "patch": "@@ -1,11 +1,120 @@\n+use std::ptr::copy_nonoverlapping;\n+\n use ::smallvec::SmallVec;\n use bincode::{\n     BorrowDecode, Decode, Encode,\n-    de::{BorrowDecoder, Decoder},\n-    enc::Encoder,\n+    de::{BorrowDecoder, Decoder, DecoderImpl, read::Reader},\n+    enc::{Encoder, EncoderImpl, write::Writer},\n     error::{DecodeError, EncodeError},\n };\n \n+pub const TURBO_BINCODE_CONFIG: bincode::config::Configuration = bincode::config::standard();\n+pub type TurboBincodeBuffer = SmallVec<[u8; 16]>;\n+pub type TurboBincodeEncoder<'a> =\n+    EncoderImpl<TurboBincodeWriter<'a>, bincode::config::Configuration>;\n+pub type TurboBincodeDecoder<'a> =\n+    DecoderImpl<TurboBincodeReader<'a>, bincode::config::Configuration, ()>;\n+\n+fn new_turbo_bincode_encoder(buf: &mut TurboBincodeBuffer) -> TurboBincodeEncoder<'_> {\n+    EncoderImpl::new(TurboBincodeWriter::new(buf), TURBO_BINCODE_CONFIG)\n+}\n+\n+fn new_turbo_bincode_decoder(buffer: &[u8]) -> TurboBincodeDecoder<'_> {\n+    DecoderImpl::new(TurboBincodeReader::new(buffer), TURBO_BINCODE_CONFIG, ())\n+}\n+\n+/// Encode the value into a new [`SmallVec`] using a [`TurboBincodeEncoder`].\n+///\n+/// Note: If you can re-use a buffer, you should. That will always be cheaper than creating a new\n+/// [`SmallVec`].\n+pub fn turbo_bincode_encode<T: Encode>(value: &T) -> Result<TurboBincodeBuffer, EncodeError> {\n+    let mut buffer = TurboBincodeBuffer::new();\n+    turbo_bincode_encode_into(value, &mut buffer)?;\n+    Ok(buffer)\n+}\n+\n+pub fn turbo_bincode_encode_into<T: Encode>(\n+    value: &T,\n+    buffer: &mut TurboBincodeBuffer,\n+) -> Result<(), EncodeError> {\n+    let mut encoder = new_turbo_bincode_encoder(buffer);\n+    value.encode(&mut encoder)?;\n+    Ok(())\n+}\n+\n+/// Decode using a [`TurboBincodeDecoder`] and check that the entire slice was consumed. Returns a\n+/// [`DecodeError::ArrayLengthMismatch`] if some of the slice is not consumed during decoding.\n+pub fn turbo_bincode_decode<T: Decode<()>>(buf: &[u8]) -> Result<T, DecodeError> {\n+    let mut decoder = new_turbo_bincode_decoder(buf);\n+    let val = T::decode(&mut decoder)?;\n+    let remaining_buf = decoder.reader().buffer;\n+    if !remaining_buf.is_empty() {\n+        return Err(DecodeError::ArrayLengthMismatch {\n+            required: buf.len() - remaining_buf.len(),\n+            found: buf.len(),\n+        });\n+    }\n+    Ok(val)\n+}\n+\n+pub struct TurboBincodeWriter<'a> {\n+    pub buffer: &'a mut TurboBincodeBuffer,\n+}\n+\n+impl<'a> TurboBincodeWriter<'a> {\n+    pub fn new(buffer: &'a mut TurboBincodeBuffer) -> Self {\n+        Self { buffer }\n+    }\n+}\n+\n+impl Writer for TurboBincodeWriter<'_> {\n+    fn write(&mut self, bytes: &[u8]) -> Result<(), EncodeError> {\n+        self.buffer.extend_from_slice(bytes);\n+        Ok(())\n+    }\n+}\n+\n+/// This is equivalent to [`bincode::de::read::SliceReader`], but with a little `unsafe` code to\n+/// avoid some redundant bounds checks, and `pub` access to the underlying `buffer`.\n+pub struct TurboBincodeReader<'a> {\n+    pub buffer: &'a [u8],\n+}\n+\n+impl<'a> TurboBincodeReader<'a> {\n+    pub fn new(buffer: &'a [u8]) -> Self {\n+        Self { buffer }\n+    }\n+}\n+\n+impl Reader for TurboBincodeReader<'_> {\n+    fn read(&mut self, target_buffer: &mut [u8]) -> Result<(), DecodeError> {\n+        let len = target_buffer.len();\n+        let (head, rest) =\n+            self.buffer\n+                .split_at_checked(len)\n+                .ok_or_else(|| DecodeError::UnexpectedEnd {\n+                    additional: len - self.buffer.len(),\n+                })?;\n+        // SAFETY:\n+        // - We already checked the bounds.\n+        // - These memory ranges can't overlap because it would violate rust aliasing rules.\n+        // - `u8` is `Copy`.\n+        unsafe {\n+            copy_nonoverlapping(head.as_ptr(), target_buffer.as_mut_ptr(), len);\n+        }\n+        self.buffer = rest;\n+        Ok(())\n+    }\n+\n+    fn peek_read(&mut self, n: usize) -> Option<&[u8]> {\n+        self.buffer.get(..n)\n+    }\n+\n+    fn consume(&mut self, n: usize) {\n+        self.buffer = &self.buffer[n..];\n+    }\n+}\n+\n pub mod indexmap {\n     use std::hash::{BuildHasher, Hash};\n "
        }
    ],
    "stats": {
        "total": 113,
        "additions": 111,
        "deletions": 2
    }
}