{
    "author": "acdlite",
    "message": "Replay redirect if RSC parameter is missing (#80180)\n\nIf the server responds with a redirect (e.g. 307), and the redirected\nlocation does not contain the cache busting search param set in the\noriginal request, the response is likely invalid — when following the\nredirect, the browser will have forwarded the request headers, but\nwithout a corresponding cache busting search param. (See\nhttps://github.com/vercel/next.js/pull/79563 for more context.)\n\nIdeally, we would be able to intercept the redirect response and perform\nit manually, instead of letting the browser automatically follow it, but\nthis is not allowed by the fetch API.\n\nSo instead, we must \"replay\" the redirect by fetching the new location\nagain, but this time we'll append the cache busting search param to\nprevent a mismatch.\n\nWe can optimize Next.js's built-in middleware APIs by returning a custom\nstatus code, to prevent the browser from automatically following it.\nThis will land in future PRs. Third-party proxies can choose to\nimplement this same protocol for cases where they need to redirect\nNext.js requests but are not using Next.js APIs.\n\nHowever, we'll still need this fallback behavior for third-party proxies\nthat don't implement our optimized redirect protocol.\n\nThis does not affect Server Action-based redirects; those are encoded\ndifferently, as part of the Flight body.\n\nAs of now, this is gated behind the experimental\n`validateRSCRequestHeaders` flag. We will test it before turning it on\nby default.",
    "sha": "f75598fe43e20c4778aff3ee264fc22d133d59c5",
    "files": [
        {
            "sha": "2b0402a1f5ae39c1662d0141d5bb6b56f07a0341",
            "filename": "packages/next/src/build/define-env.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/f75598fe43e20c4778aff3ee264fc22d133d59c5/packages%2Fnext%2Fsrc%2Fbuild%2Fdefine-env.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f75598fe43e20c4778aff3ee264fc22d133d59c5/packages%2Fnext%2Fsrc%2Fbuild%2Fdefine-env.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fdefine-env.ts?ref=f75598fe43e20c4778aff3ee264fc22d133d59c5",
            "patch": "@@ -187,6 +187,9 @@ export function getDefineEnv({\n     'process.env.__NEXT_CLIENT_SEGMENT_CACHE': Boolean(\n       config.experimental.clientSegmentCache\n     ),\n+    'process.env.__NEXT_CLIENT_VALIDATE_RSC_REQUEST_HEADERS': Boolean(\n+      config.experimental.validateRSCRequestHeaders\n+    ),\n     'process.env.__NEXT_DYNAMIC_ON_HOVER': Boolean(\n       config.experimental.dynamicOnHover\n     ),"
        },
        {
            "sha": "7881c8a8c78741e72922c482170a27265dd912d9",
            "filename": "packages/next/src/client/components/router-reducer/fetch-server-response.ts",
            "status": "modified",
            "additions": 108,
            "deletions": 7,
            "changes": 115,
            "blob_url": "https://github.com/vercel/next.js/blob/f75598fe43e20c4778aff3ee264fc22d133d59c5/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Ffetch-server-response.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f75598fe43e20c4778aff3ee264fc22d133d59c5/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Ffetch-server-response.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Ffetch-server-response.ts?ref=f75598fe43e20c4778aff3ee264fc22d133d59c5",
            "patch": "@@ -267,18 +267,29 @@ export async function fetchServerResponse(\n   }\n }\n \n-export function createFetch(\n+// This is a subset of the standard Response type. We use a custom type for\n+// this so we can limit which details about the response leak into the rest of\n+// the codebase. For example, there's some custom logic for manually following\n+// redirects, so \"redirected\" in this type could be a composite of multiple\n+// browser fetch calls; however, this fact should not leak to the caller.\n+export type RSCResponse = {\n+  ok: boolean\n+  redirected: boolean\n+  headers: Headers\n+  body: ReadableStream<Uint8Array> | null\n+  status: number\n+  url: string\n+}\n+\n+export async function createFetch(\n   url: URL,\n   headers: RequestHeaders,\n   fetchPriority: 'auto' | 'high' | 'low' | null,\n   signal?: AbortSignal\n-) {\n-  const fetchUrl = new URL(url)\n-\n+): Promise<RSCResponse> {\n   // TODO: In output: \"export\" mode, the headers do nothing. Omit them (and the\n   // cache busting search param) from the request so they're\n   // maximally cacheable.\n-  setCacheBustingSearchParam(fetchUrl, headers)\n \n   if (process.env.__NEXT_TEST_MODE && fetchPriority !== null) {\n     headers['Next-Test-Fetch-Priority'] = fetchPriority\n@@ -288,13 +299,103 @@ export function createFetch(\n     headers['x-deployment-id'] = process.env.NEXT_DEPLOYMENT_ID\n   }\n \n-  return fetch(fetchUrl, {\n+  const fetchOptions: RequestInit = {\n     // Backwards compat for older browsers. `same-origin` is the default in modern browsers.\n     credentials: 'same-origin',\n     headers,\n     priority: fetchPriority || undefined,\n     signal,\n-  })\n+  }\n+  // `fetchUrl` is slightly different from `url` because we add a cache-busting\n+  // search param to it. This should not leak outside of this function, so we\n+  // track them separately.\n+  let fetchUrl = new URL(url)\n+  setCacheBustingSearchParam(fetchUrl, headers)\n+  let browserResponse = await fetch(fetchUrl, fetchOptions)\n+\n+  // If the server responds with a redirect (e.g. 307), and the redirected\n+  // location does not contain the cache busting search param set in the\n+  // original request, the response is likely invalid — when following the\n+  // redirect, the browser forwards the request headers, but since the cache\n+  // busting search param is missing, the server will reject the request due to\n+  // a mismatch.\n+  //\n+  // Ideally, we would be able to intercept the redirect response and perform it\n+  // manually, instead of letting the browser automatically follow it, but this\n+  // is not allowed by the fetch API.\n+  //\n+  // So instead, we must \"replay\" the redirect by fetching the new location\n+  // again, but this time we'll append the cache busting search param to prevent\n+  // a mismatch.\n+  //\n+  // TODO: We can optimize Next.js's built-in middleware APIs by returning a\n+  // custom status code, to prevent the browser from automatically following it.\n+  //\n+  // This does not affect Server Action-based redirects; those are encoded\n+  // differently, as part of the Flight body. It only affects redirects that\n+  // occur in a middleware or a third-party proxy.\n+\n+  let redirected = browserResponse.redirected\n+  if (process.env.__NEXT_CLIENT_VALIDATE_RSC_REQUEST_HEADERS) {\n+    // This is to prevent a redirect loop. Same limit used by Chrome.\n+    const MAX_REDIRECTS = 20\n+    for (let n = 0; n < MAX_REDIRECTS; n++) {\n+      if (!browserResponse.redirected) {\n+        // The server did not perform a redirect.\n+        break\n+      }\n+      const responseUrl = new URL(browserResponse.url, fetchUrl)\n+      if (responseUrl.origin !== fetchUrl.origin) {\n+        // The server redirected to an external URL. The rest of the logic below\n+        // is not relevant, because it only applies to internal redirects.\n+        break\n+      }\n+      if (\n+        responseUrl.searchParams.get(NEXT_RSC_UNION_QUERY) ===\n+        fetchUrl.searchParams.get(NEXT_RSC_UNION_QUERY)\n+      ) {\n+        // The redirected URL already includes the cache busting search param.\n+        // This was probably intentional. Regardless, there's no reason to\n+        // issue another request to this URL because it already has the param\n+        // value that we would have added below.\n+        break\n+      }\n+      // The RSC request was redirected. Assume the response is invalid.\n+      //\n+      // Append the cache busting search param to the redirected URL and\n+      // fetch again.\n+      fetchUrl = new URL(responseUrl)\n+      setCacheBustingSearchParam(fetchUrl, headers)\n+      browserResponse = await fetch(fetchUrl, fetchOptions)\n+      // We just performed a manual redirect, so this is now true.\n+      redirected = true\n+    }\n+  }\n+\n+  // Remove the cache busting search param from the response URL, to prevent it\n+  // from leaking outside of this function.\n+  const responseUrl = new URL(browserResponse.url, fetchUrl)\n+  responseUrl.searchParams.delete(NEXT_RSC_UNION_QUERY)\n+\n+  const rscResponse: RSCResponse = {\n+    url: responseUrl.href,\n+\n+    // This is true if any redirects occurred, either automatically by the\n+    // browser, or manually by us. So it's different from\n+    // `browserResponse.redirected`, which only tells us whether the browser\n+    // followed a redirect, and only for the last response in the chain.\n+    redirected,\n+\n+    // These can be copied from the last browser response we received. We\n+    // intentionally only expose the subset of fields that are actually used\n+    // elsewhere in the codebase.\n+    ok: browserResponse.ok,\n+    headers: browserResponse.headers,\n+    body: browserResponse.body,\n+    status: browserResponse.status,\n+  }\n+\n+  return rscResponse\n }\n \n export function createFromNextReadableStream("
        },
        {
            "sha": "e4805bd3cebd01316c368de3639e288b73a8b28c",
            "filename": "packages/next/src/client/components/segment-cache-impl/cache.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 3,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/f75598fe43e20c4778aff3ee264fc22d133d59c5/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f75598fe43e20c4778aff3ee264fc22d133d59c5/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts?ref=f75598fe43e20c4778aff3ee264fc22d133d59c5",
            "patch": "@@ -25,6 +25,7 @@ import {\n import {\n   createFetch,\n   createFromNextReadableStream,\n+  type RSCResponse,\n   type RequestHeaders,\n } from '../router-reducer/fetch-server-response'\n import {\n@@ -997,6 +998,8 @@ export async function fetchRouteOnCacheMiss(\n   }\n \n   // In output: \"export\" mode, we need to add the segment path to the URL.\n+  // TODO: Consider moving this to `createFetch`, where we do similar logic for\n+  // manipulating the request URL to encode extra information.\n   const url = new URL(href)\n   const requestUrl = isOutputExportMode\n     ? addSegmentPathToUrlInOutputExportMode(url, segmentPath)\n@@ -1372,7 +1375,7 @@ export async function fetchSegmentPrefetchesUsingDynamicRequest(\n function writeDynamicTreeResponseIntoCache(\n   now: number,\n   task: PrefetchTask,\n-  response: Response,\n+  response: RSCResponse,\n   serverData: NavigationFlightResponse,\n   entry: PendingRouteCacheEntry,\n   couldBeIntercepted: boolean,\n@@ -1462,7 +1465,7 @@ function rejectSegmentEntriesIfStillPending(\n function writeDynamicRenderResponseIntoCache(\n   now: number,\n   task: PrefetchTask,\n-  response: Response,\n+  response: RSCResponse,\n   serverData: NavigationFlightResponse,\n   isResponsePartial: boolean,\n   route: FulfilledRouteCacheEntry,\n@@ -1629,7 +1632,7 @@ function writeSeedDataIntoCache(\n async function fetchPrefetchResponse(\n   url: URL,\n   headers: RequestHeaders\n-): Promise<Response | null> {\n+): Promise<RSCResponse | null> {\n   const fetchPriority = 'low'\n   const response = await createFetch(url, headers, fetchPriority)\n   if (!response.ok) {"
        },
        {
            "sha": "df801b9ac549d7b19871623a7da40e0251c29b5c",
            "filename": "packages/next/src/server/base-server.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/f75598fe43e20c4778aff3ee264fc22d133d59c5/packages%2Fnext%2Fsrc%2Fserver%2Fbase-server.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f75598fe43e20c4778aff3ee264fc22d133d59c5/packages%2Fnext%2Fsrc%2Fserver%2Fbase-server.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fbase-server.ts?ref=f75598fe43e20c4778aff3ee264fc22d133d59c5",
            "patch": "@@ -2106,7 +2106,8 @@ export default abstract class Server<\n         // The hash sent by the client does not match the expected value.\n         // Respond with an error.\n         res.statusCode = 400\n-        res.body('Bad Request').send()\n+        res.setHeader('content-type', 'text/plain')\n+        res.body('').send()\n         return null\n       }\n     }"
        },
        {
            "sha": "3455d80e3b30454bf302ed9abdea2e09701e2e6b",
            "filename": "test/e2e/app-dir/segment-cache/cdn-cache-busting/app/page.tsx",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/f75598fe43e20c4778aff3ee264fc22d133d59c5/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fcdn-cache-busting%2Fapp%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/f75598fe43e20c4778aff3ee264fc22d133d59c5/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fcdn-cache-busting%2Fapp%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fcdn-cache-busting%2Fapp%2Fpage.tsx?ref=f75598fe43e20c4778aff3ee264fc22d133d59c5",
            "patch": "@@ -6,6 +6,11 @@ export default function Page() {\n       <li>\n         <LinkAccordion href=\"/target-page\">Target page</LinkAccordion>\n       </li>\n+      <li>\n+        <LinkAccordion href=\"/redirect-to-target-page\">\n+          Redirects to target page\n+        </LinkAccordion>\n+      </li>\n     </ul>\n   )\n }"
        },
        {
            "sha": "f72dfebdef72659bbd2140386f152ed1d8070496",
            "filename": "test/e2e/app-dir/segment-cache/cdn-cache-busting/cdn-cache-busting.test.ts",
            "status": "modified",
            "additions": 39,
            "deletions": 2,
            "changes": 41,
            "blob_url": "https://github.com/vercel/next.js/blob/f75598fe43e20c4778aff3ee264fc22d133d59c5/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fcdn-cache-busting%2Fcdn-cache-busting.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f75598fe43e20c4778aff3ee264fc22d133d59c5/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fcdn-cache-busting%2Fcdn-cache-busting.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fcdn-cache-busting%2Fcdn-cache-busting.test.ts?ref=f75598fe43e20c4778aff3ee264fc22d133d59c5",
            "patch": "@@ -79,7 +79,7 @@ describe('segment cache (CDN cache busting)', () => {\n       'search param',\n     async () => {\n       const browser = await webdriver(port, '/')\n-      const { status, text } = await browser.eval(async () => {\n+      const { status } = await browser.eval(async () => {\n         const res = await fetch('/target-page', {\n           headers: {\n             RSC: '1',\n@@ -91,7 +91,44 @@ describe('segment cache (CDN cache busting)', () => {\n       })\n \n       expect(status).toBe(400)\n-      expect(text).toContain('Bad Request')\n+    }\n+  )\n+\n+  it(\n+    'perform fully prefetched navigation when a third-party proxy ' +\n+      'performs a redirect',\n+    async () => {\n+      let act\n+      const browser = await webdriver(port, '/', {\n+        beforePageLoad(p: Playwright.Page) {\n+          act = createRouterAct(p)\n+        },\n+      })\n+\n+      await act(\n+        async () => {\n+          const linkToggle = await browser.elementByCss(\n+            '[data-link-accordion=\"/redirect-to-target-page\"]'\n+          )\n+          await linkToggle.click()\n+        },\n+        {\n+          includes: 'Target page',\n+        }\n+      )\n+\n+      // Navigate to the prefetched target page.\n+      await act(async () => {\n+        const link = await browser.elementByCss(\n+          'a[href=\"/redirect-to-target-page\"]'\n+        )\n+        await link.click()\n+\n+        // The page was prefetched, so we're able to render the target\n+        // page immediately.\n+        const div = await browser.elementById('target-page')\n+        expect(await div.text()).toBe('Target page')\n+      }, 'no-requests')\n     }\n   )\n })"
        },
        {
            "sha": "30745c88f0f5a23552797e70ac571500ed0c3d83",
            "filename": "test/e2e/app-dir/segment-cache/cdn-cache-busting/server.mjs",
            "status": "modified",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/f75598fe43e20c4778aff3ee264fc22d133d59c5/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fcdn-cache-busting%2Fserver.mjs",
            "raw_url": "https://github.com/vercel/next.js/raw/f75598fe43e20c4778aff3ee264fc22d133d59c5/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fcdn-cache-busting%2Fserver.mjs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fcdn-cache-busting%2Fserver.mjs?ref=f75598fe43e20c4778aff3ee264fc22d133d59c5",
            "patch": "@@ -8,6 +8,13 @@ import { createGunzip } from 'zlib'\n \n const dir = dirname(fileURLToPath(import.meta.url))\n \n+// Redirects that happen in the proxy layer, rather than in Next.js itself. This\n+// is used to test that the client is still able to fully prefetch the\n+// target page.\n+const proxyRedirects = {\n+  '/redirect-to-target-page': '/target-page',\n+}\n+\n async function spawnNext(port) {\n   const child = spawn('pnpm', ['next', 'start', '-p', port, dir], {\n     env: process.env,\n@@ -48,6 +55,17 @@ async function createFakeCDN(destPort) {\n \n   const proxy = httpProxy.createProxyServer()\n   const cdnServer = createServer(async (req, res) => {\n+    const pathname = new URL(req.url, `http://localhost`).pathname\n+    const redirectUrl = proxyRedirects[pathname]\n+    if (redirectUrl) {\n+      console.log('Redirecting to:', redirectUrl)\n+      res.writeHead(307, {\n+        Location: redirectUrl,\n+      })\n+      res.end()\n+      return\n+    }\n+\n     if (isCacheableRequest(req)) {\n       // Serve from our fake CDN if there's a matching entry.\n       const entry = await fakeCDNCache.get(req.url)"
        },
        {
            "sha": "c5b00d6726f582acb6c0fa854b7410e1337c764e",
            "filename": "test/e2e/app-dir/segment-cache/router-act.ts",
            "status": "modified",
            "additions": 24,
            "deletions": 8,
            "changes": 32,
            "blob_url": "https://github.com/vercel/next.js/blob/f75598fe43e20c4778aff3ee264fc22d133d59c5/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frouter-act.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f75598fe43e20c4778aff3ee264fc22d133d59c5/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frouter-act.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frouter-act.ts?ref=f75598fe43e20c4778aff3ee264fc22d133d59c5",
            "patch": "@@ -9,7 +9,12 @@ type Batch = {\n \n type PendingRSCRequest = {\n   route: Playwright.Route\n-  result: Promise<{ body: string; headers: Record<string, string> }>\n+  result: Promise<{\n+    text: string\n+    body: any\n+    headers: Record<string, string>\n+    status: number\n+  }>\n   didProcess: boolean\n }\n \n@@ -145,10 +150,14 @@ export function createRouterAct(\n             // but it should not affect the timing of when requests reach the\n             // server; we pass the request to the server the immediately.\n             result: new Promise(async (resolve) => {\n-              const originalResponse = await page.request.fetch(request)\n+              const originalResponse = await page.request.fetch(request, {\n+                maxRedirects: 0,\n+              })\n               resolve({\n-                body: await originalResponse.text(),\n+                text: await originalResponse.text(),\n+                body: await originalResponse.body(),\n                 headers: originalResponse.headers(),\n+                status: originalResponse.status(),\n               })\n             }),\n             didProcess: false,\n@@ -343,7 +352,11 @@ Choose a more specific substring to assert on.\n             // fulfill it yet.\n             remaining.add(item)\n           } else {\n-            await route.fulfill(fulfilled)\n+            await route.fulfill({\n+              body: fulfilled.body,\n+              headers: fulfilled.headers,\n+              status: fulfilled.status,\n+            })\n             const browserResponse = await request.response()\n             if (browserResponse !== null) {\n               await browserResponse.finished()\n@@ -353,10 +366,13 @@ Choose a more specific substring to assert on.\n \n         // After flushing the queue, wait for the microtask queue to be\n         // exhausted, then check if any additional requests are initiated. A\n-        // microtask should be enough because if the router queue is network\n-        // throttled, the next request is issued within a microtask of the\n-        // previous one finishing.\n-        await page.evaluate(() => Promise.resolve())\n+        // single macrotask should be enough because if the router queue is\n+        // network throttled, the next request is issued either directly within\n+        // the task of the previous request's completion event, or in the\n+        // microtask queue of that event.\n+        await page.evaluate(\n+          () => new Promise<void>((res) => requestIdleCallback(() => res()))\n+        )\n \n         await waitForPendingRequestChecks()\n       }"
        }
    ],
    "stats": {
        "total": 226,
        "additions": 205,
        "deletions": 21
    }
}