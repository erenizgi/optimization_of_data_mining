{
    "author": "kdy1",
    "message": "fix(turbopack): Fix static immutability analysis (#80646)\n\n### What?\n\nDo not mark functions with `(&self)` receiver as imuutable.\n\n### Why?\n\n`&self` is `self: Vc<Self>` with `self.await?`\n\n---------\n\nCo-authored-by: Luke Sandberg <lukesandberg@users.noreply.github.com>",
    "sha": "e25792b54997020cd389cd6f38d73ffd9ad47c3c",
    "files": [
        {
            "sha": "749c970d88ffd2351f683cece011f74b6c256a6b",
            "filename": "turbopack/crates/turbo-tasks-macros/src/function_macro.rs",
            "status": "modified",
            "additions": 13,
            "deletions": 1,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/e25792b54997020cd389cd6f38d73ffd9ad47c3c/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Ffunction_macro.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e25792b54997020cd389cd6f38d73ffd9ad47c3c/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Ffunction_macro.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Ffunction_macro.rs?ref=e25792b54997020cd389cd6f38d73ffd9ad47c3c",
            "patch": "@@ -67,7 +67,7 @@ pub fn function(args: TokenStream, input: TokenStream) -> TokenStream {\n         filter_trait_call_args: None, // not a trait method\n         local,\n         invalidator,\n-        immutable: sig.asyncness.is_none() && !invalidator,\n+        immutable: is_immutable(&sig) && !invalidator,\n     };\n     let native_function_ident = get_native_function_ident(ident);\n     let native_function_ty = native_fn.ty();\n@@ -102,3 +102,15 @@ pub fn function(args: TokenStream, input: TokenStream) -> TokenStream {\n     }\n     .into()\n }\n+\n+/// Computes whether the task is statically immutable based on the signature.\n+/// - if the task is `async` we assume it is reading some other task.\n+/// - if a task accepts `&self` then we know it read `Vc<Self>` in the generated calling code. See\n+///   also: turbopack/crates/turbo-tasks/src/task/function.rs for the binding code.\n+pub(crate) fn is_immutable(sig: &syn::Signature) -> bool {\n+    sig.asyncness.is_none()\n+        && match sig.receiver() {\n+            Some(recv) => recv.reference.is_none(),\n+            _ => true,\n+        }\n+}"
        },
        {
            "sha": "03c9a8bf4da0a42e3583725747b41fe0b3d34fa5",
            "filename": "turbopack/crates/turbo-tasks-macros/src/value_impl_macro.rs",
            "status": "modified",
            "additions": 8,
            "deletions": 5,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/e25792b54997020cd389cd6f38d73ffd9ad47c3c/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_impl_macro.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e25792b54997020cd389cd6f38d73ffd9ad47c3c/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_impl_macro.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_impl_macro.rs?ref=e25792b54997020cd389cd6f38d73ffd9ad47c3c",
            "patch": "@@ -14,9 +14,12 @@ use turbo_tasks_macros_shared::{\n     get_trait_impl_function_id_ident, get_trait_impl_function_ident, get_type_ident, is_self_used,\n };\n \n-use crate::func::{\n-    DefinitionContext, FunctionArguments, NativeFn, TurboFn, filter_inline_attributes,\n-    split_function_attributes,\n+use crate::{\n+    func::{\n+        DefinitionContext, FunctionArguments, NativeFn, TurboFn, filter_inline_attributes,\n+        split_function_attributes,\n+    },\n+    function_macro::is_immutable,\n };\n \n struct ValueImplArguments {\n@@ -119,7 +122,7 @@ pub fn value_impl(args: TokenStream, input: TokenStream) -> TokenStream {\n                     filter_trait_call_args: None, // not a trait method\n                     local,\n                     invalidator,\n-                    immutable: sig.asyncness.is_none() && !invalidator,\n+                    immutable: is_immutable(sig) && !invalidator,\n                 };\n \n                 let native_function_ident = get_inherent_impl_function_ident(ty_ident, ident);\n@@ -249,7 +252,7 @@ pub fn value_impl(args: TokenStream, input: TokenStream) -> TokenStream {\n                     filter_trait_call_args: turbo_fn.filter_trait_call_args(),\n                     local,\n                     invalidator,\n-                    immutable: sig.asyncness.is_none() && !invalidator,\n+                    immutable: is_immutable(sig) && !invalidator,\n                 };\n \n                 let native_function_ident ="
        },
        {
            "sha": "a14de7daeb61611262be7b7bcbe2c7e5eab124fe",
            "filename": "turbopack/crates/turbo-tasks-macros/src/value_trait_macro.rs",
            "status": "modified",
            "additions": 7,
            "deletions": 4,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/e25792b54997020cd389cd6f38d73ffd9ad47c3c/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_trait_macro.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e25792b54997020cd389cd6f38d73ffd9ad47c3c/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_trait_macro.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_trait_macro.rs?ref=e25792b54997020cd389cd6f38d73ffd9ad47c3c",
            "patch": "@@ -10,9 +10,12 @@ use turbo_tasks_macros_shared::{\n     get_trait_type_vtable_registry, is_self_used,\n };\n \n-use crate::func::{\n-    DefinitionContext, FunctionArguments, NativeFn, TurboFn, filter_inline_attributes,\n-    split_function_attributes,\n+use crate::{\n+    func::{\n+        DefinitionContext, FunctionArguments, NativeFn, TurboFn, filter_inline_attributes,\n+        split_function_attributes,\n+    },\n+    function_macro::is_immutable,\n };\n \n pub fn value_trait(args: TokenStream, input: TokenStream) -> TokenStream {\n@@ -194,7 +197,7 @@ pub fn value_trait(args: TokenStream, input: TokenStream) -> TokenStream {\n                 // - This only makes sense when a default implementation is present.\n                 local: false,\n                 invalidator: func_args.invalidator.is_some(),\n-                immutable: sig.asyncness.is_none() && func_args.invalidator.is_none(),\n+                immutable: is_immutable(sig) && func_args.invalidator.is_none(),\n             };\n \n             let native_function_ident = get_trait_default_impl_function_ident(trait_ident, ident);"
        },
        {
            "sha": "d708707ff78462a55c2772c7266126a5ac8e5bb1",
            "filename": "turbopack/crates/turbo-tasks-testing/tests/recompute.rs",
            "status": "modified",
            "additions": 43,
            "deletions": 1,
            "changes": 44,
            "blob_url": "https://github.com/vercel/next.js/blob/e25792b54997020cd389cd6f38d73ffd9ad47c3c/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Frecompute.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e25792b54997020cd389cd6f38d73ffd9ad47c3c/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Frecompute.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Frecompute.rs?ref=e25792b54997020cd389cd6f38d73ffd9ad47c3c",
            "patch": "@@ -3,7 +3,7 @@\n #![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n \n use anyhow::Result;\n-use turbo_tasks::{State, Vc};\n+use turbo_tasks::{ResolvedVc, State, Vc};\n use turbo_tasks_testing::{Registration, register, run};\n \n static REGISTRATION: Registration = register!();\n@@ -58,11 +58,53 @@ async fn recompute() {\n     .unwrap()\n }\n \n+#[tokio::test]\n+async fn immutable_analysis() {\n+    run(&REGISTRATION, || async {\n+        let input = ChangingInput {\n+            state: State::new(1),\n+        }\n+        .resolved_cell();\n+\n+        // Verify\n+\n+        let vc_holder = VcHolder { vc: input }.resolved_cell();\n+        let read = vc_holder.compute().strongly_consistent().await?;\n+        assert_eq!(read.state_value, 1);\n+        assert_eq!(read.state_value2, 1);\n+        let random_value = read.random_value;\n+\n+        println!(\"changing input1\");\n+        input.await?.state.set(30);\n+        let read = vc_holder.compute().strongly_consistent().await?;\n+        assert_eq!(read.state_value, 30);\n+        assert_eq!(read.state_value2, 42);\n+        assert_ne!(read.random_value, random_value);\n+\n+        anyhow::Ok(())\n+    })\n+    .await\n+    .unwrap()\n+}\n+\n #[turbo_tasks::value]\n struct ChangingInput {\n     state: State<u32>,\n }\n \n+#[turbo_tasks::value]\n+struct VcHolder {\n+    vc: ResolvedVc<ChangingInput>,\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl VcHolder {\n+    #[turbo_tasks::function]\n+    fn compute(&self) -> Vc<Output> {\n+        compute(*self.vc, *self.vc)\n+    }\n+}\n+\n #[turbo_tasks::value]\n struct Output {\n     state_value: u32,"
        }
    ],
    "stats": {
        "total": 82,
        "additions": 71,
        "deletions": 11
    }
}