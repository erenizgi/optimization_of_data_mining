{
    "author": "lukesandberg",
    "message": "[turbopack] Handle relative paths before matching in node file traces (#82539)\n\n# Fix glob handling for NFT JSON asset includes and excludes\n\nThe current webpack version uses the  https://www.npmjs.com/package/glob package to match and notably only handles `../` when it appears in a prefix position ([ref](https://www.npmjs.com/package/glob#:~:text=..%20path%20portions%20are%20not%20handled%20unless%20they%20appear%20at%20the%20start%20of%20the%20pattern)), so we do the exact same thing here.\n\nThis allows our read_glob traversal to only consider traversing 'down' from the root since we can preprocess the patterns to not include `../` or `./`\n\nPart-Of PACK-5219",
    "sha": "bd802d13277f4b44d5cf4c1f1d61f9c32956bbc3",
    "files": [
        {
            "sha": "49473bdfe3499ced011be55af29116eec11020bc",
            "filename": "crates/next-api/src/nft_json.rs",
            "status": "modified",
            "additions": 256,
            "deletions": 39,
            "changes": 295,
            "blob_url": "https://github.com/vercel/next.js/blob/bd802d13277f4b44d5cf4c1f1d61f9c32956bbc3/crates%2Fnext-api%2Fsrc%2Fnft_json.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/bd802d13277f4b44d5cf4c1f1d61f9c32956bbc3/crates%2Fnext-api%2Fsrc%2Fnft_json.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fnft_json.rs?ref=bd802d13277f4b44d5cf4c1f1d61f9c32956bbc3",
            "patch": "@@ -4,7 +4,7 @@ use anyhow::{Result, bail};\n use serde_json::json;\n use turbo_rcstr::RcStr;\n use turbo_tasks::{\n-    ReadRef, ResolvedVc, TryFlatJoinIterExt, Vc,\n+    FxIndexMap, ReadRef, ResolvedVc, TryFlatJoinIterExt, TryJoinIterExt, Vc,\n     graph::{AdjacencyMap, GraphTraversal},\n };\n use turbo_tasks_fs::{DirectoryEntry, File, FileSystem, FileSystemPath, glob::Glob};\n@@ -102,6 +102,7 @@ async fn apply_includes(\n     glob: Vc<Glob>,\n     ident_folder: &FileSystemPath,\n ) -> Result<BTreeSet<RcStr>> {\n+    debug_assert_eq!(project_root_path.fs, ident_folder.fs);\n     // Read files matching the glob pattern from the project root\n     let glob_result = project_root_path.read_glob(glob).await?;\n \n@@ -118,9 +119,10 @@ async fn apply_includes(\n \n             let file_path_ref = file_path;\n             // Convert to relative path from ident_folder to the file\n-            if let Some(relative_path) = ident_folder.get_relative_path_to(file_path_ref) {\n-                result.insert(relative_path);\n-            }\n+            // unwrap is safe because project_root_path and ident_folder have the same filesystem\n+            // and paths produced by read_glob stay in the filesystem\n+            let relative_path = ident_folder.get_relative_path_to(file_path_ref).unwrap();\n+            result.insert(relative_path);\n         }\n \n         for nested_result in glob_result.inner.values() {\n@@ -163,9 +165,8 @@ impl Asset for NftJsonAsset {\n             .chain(std::iter::once(chunk))\n             .collect();\n \n+        let project_path = this.project.project_path().owned().await?;\n         let exclude_glob = if let Some(route) = &this.page_name {\n-            let project_path = this.project.project_path().await?;\n-\n             if let Some(excludes_config) = output_file_tracing_excludes {\n                 let mut combined_excludes = BTreeSet::new();\n \n@@ -178,26 +179,37 @@ impl Asset for NftJsonAsset {\n                         {\n                             for pattern in patterns {\n                                 if let Some(pattern_str) = pattern.as_str() {\n-                                    combined_excludes.insert(pattern_str);\n+                                    let (glob, root) =\n+                                        relativize_glob(pattern_str, project_path.clone())?;\n+                                    let glob = if root.path.is_empty() {\n+                                        glob.to_string()\n+                                    } else {\n+                                        format!(\"{root}/{glob}\")\n+                                    };\n+                                    combined_excludes.insert(glob);\n                                 }\n                             }\n                         }\n                     }\n                 }\n \n-                let glob = Glob::new(\n-                    format!(\n-                        \"{project_path}/{{{}}}\",\n-                        combined_excludes\n-                            .iter()\n-                            .copied()\n-                            .collect::<Vec<_>>()\n-                            .join(\",\")\n-                    )\n-                    .into(),\n-                );\n-\n-                Some(glob)\n+                if combined_excludes.is_empty() {\n+                    None\n+                } else {\n+                    let glob = Glob::new(\n+                        format!(\n+                            \"{{{}}}\",\n+                            combined_excludes\n+                                .iter()\n+                                .map(|s| s.as_str())\n+                                .collect::<Vec<_>>()\n+                                .join(\",\")\n+                        )\n+                        .into(),\n+                    );\n+\n+                    Some(glob)\n+                }\n             } else {\n                 None\n             }\n@@ -234,8 +246,8 @@ impl Asset for NftJsonAsset {\n         // Apply outputFileTracingIncludes and outputFileTracingExcludes\n         // Extract route from chunk path for pattern matching\n         if let Some(route) = &this.page_name {\n-            let project_path = this.project.project_path().owned().await?;\n-            let mut combined_includes = BTreeSet::new();\n+            let mut combined_includes_by_root: FxIndexMap<FileSystemPath, Vec<&str>> =\n+                FxIndexMap::default();\n \n             // Process includes\n             if let Some(includes_config) = output_file_tracing_includes\n@@ -249,30 +261,29 @@ impl Asset for NftJsonAsset {\n                     {\n                         for pattern in patterns {\n                             if let Some(pattern_str) = pattern.as_str() {\n-                                combined_includes.insert(pattern_str);\n+                                let (glob, root) =\n+                                    relativize_glob(pattern_str, project_path.clone())?;\n+                                combined_includes_by_root\n+                                    .entry(root)\n+                                    .or_default()\n+                                    .push(glob);\n                             }\n                         }\n                     }\n                 }\n             }\n \n             // Apply includes - find additional files that match the include patterns\n-            if !combined_includes.is_empty() {\n-                let glob = Glob::new(\n-                    format!(\n-                        \"{{{}}}\",\n-                        combined_includes\n-                            .iter()\n-                            .copied()\n-                            .collect::<Vec<_>>()\n-                            .join(\",\")\n-                    )\n-                    .into(),\n-                );\n-                let additional_files =\n-                    apply_includes(project_path, glob, &ident_folder_in_project_fs).await?;\n-                result.extend(additional_files);\n-            }\n+            let includes = combined_includes_by_root\n+                .into_iter()\n+                .map(|(root, globs)| {\n+                    let glob = Glob::new(format!(\"{{{}}}\", globs.join(\",\")).into());\n+                    apply_includes(root, glob, &ident_folder_in_project_fs)\n+                })\n+                .try_join()\n+                .await?;\n+\n+            result.extend(includes.into_iter().flatten());\n         }\n \n         let json = json!({\n@@ -284,6 +295,33 @@ impl Asset for NftJsonAsset {\n     }\n }\n \n+/// The globs defined in the next.config.mjs are relative to the project root.\n+/// The glob walker in turbopack is somewhat naive so we handle relative path directives first so\n+/// traversal doesn't need to consider them and can just traverse 'down' the tree.\n+/// The main alternative is to merge glob evaluation with directory traversal which is what the npm\n+/// `glob` package does, but this would be a substantial rewrite.`\n+fn relativize_glob(glob: &str, relative_to: FileSystemPath) -> Result<(&str, FileSystemPath)> {\n+    let mut relative_to = relative_to;\n+    let mut processed_glob = glob;\n+    loop {\n+        if let Some(stripped) = processed_glob.strip_prefix(\"../\") {\n+            if relative_to.path.is_empty() {\n+                bail!(\n+                    \"glob '{glob}' is invalid, it has a prefix that navigates out of the project \\\n+                     root\"\n+                );\n+            }\n+            relative_to = relative_to.parent();\n+            processed_glob = stripped;\n+        } else if let Some(stripped) = processed_glob.strip_prefix(\"./\") {\n+            processed_glob = stripped;\n+        } else {\n+            break;\n+        }\n+    }\n+    Ok((processed_glob, relative_to))\n+}\n+\n /// Walks the asset graph from multiple assets and collect all referenced\n /// assets, but filters out all client assets and glob matches.\n #[turbo_tasks::function]\n@@ -341,3 +379,182 @@ async fn get_referenced_server_assets(\n         .try_flat_join()\n         .await\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use turbo_tasks::ResolvedVc;\n+    use turbo_tasks_backend::{BackendOptions, TurboTasksBackend, noop_backing_storage};\n+    use turbo_tasks_fs::{FileSystemPath, NullFileSystem};\n+\n+    use super::*;\n+\n+    fn create_test_fs_path(path: &str) -> FileSystemPath {\n+        crate::register();\n+\n+        FileSystemPath {\n+            fs: ResolvedVc::upcast(NullFileSystem {}.resolved_cell()),\n+            path: path.into(),\n+        }\n+    }\n+\n+    #[tokio::test]\n+    async fn test_relativize_glob_normal_patterns() {\n+        let tt = turbo_tasks::TurboTasks::new(TurboTasksBackend::new(\n+            BackendOptions::default(),\n+            noop_backing_storage(),\n+        ));\n+        tt.run_once(async {\n+            // Test normal glob patterns without relative prefixes\n+            let base_path = create_test_fs_path(\"project/src\");\n+\n+            let (glob, path) = relativize_glob(\"*.js\", base_path.clone()).unwrap();\n+            assert_eq!(glob, \"*.js\");\n+            assert_eq!(path.path.as_str(), \"project/src\");\n+\n+            let (glob, path) = relativize_glob(\"components/**/*.tsx\", base_path.clone()).unwrap();\n+            assert_eq!(glob, \"components/**/*.tsx\");\n+            assert_eq!(path.path.as_str(), \"project/src\");\n+\n+            let (glob, path) = relativize_glob(\"lib/utils.ts\", base_path.clone()).unwrap();\n+            assert_eq!(glob, \"lib/utils.ts\");\n+            assert_eq!(path.path.as_str(), \"project/src\");\n+            Ok(())\n+        })\n+        .await\n+        .unwrap();\n+    }\n+\n+    #[tokio::test]\n+    async fn test_relativize_glob_current_directory_prefix() {\n+        let tt = turbo_tasks::TurboTasks::new(TurboTasksBackend::new(\n+            BackendOptions::default(),\n+            noop_backing_storage(),\n+        ));\n+        tt.run_once(async {\n+            let base_path = create_test_fs_path(\"project/src\");\n+\n+            // Single ./ prefix\n+            let (glob, path) = relativize_glob(\"./components/*.tsx\", base_path.clone()).unwrap();\n+            assert_eq!(glob, \"components/*.tsx\");\n+            assert_eq!(path.path.as_str(), \"project/src\");\n+\n+            // Multiple ./ prefixes\n+            let (glob, path) = relativize_glob(\"././utils.js\", base_path.clone()).unwrap();\n+            assert_eq!(glob, \"utils.js\");\n+            assert_eq!(path.path.as_str(), \"project/src\");\n+\n+            // ./ with complex glob\n+            let (glob, path) = relativize_glob(\"./lib/**/*.{js,ts}\", base_path.clone()).unwrap();\n+            assert_eq!(glob, \"lib/**/*.{js,ts}\");\n+            assert_eq!(path.path.as_str(), \"project/src\");\n+            Ok(())\n+        })\n+        .await\n+        .unwrap();\n+    }\n+\n+    #[tokio::test]\n+    async fn test_relativize_glob_parent_directory_navigation() {\n+        let tt = turbo_tasks::TurboTasks::new(TurboTasksBackend::new(\n+            BackendOptions::default(),\n+            noop_backing_storage(),\n+        ));\n+        tt.run_once(async {\n+            let base_path = create_test_fs_path(\"project/src/components\");\n+\n+            // Single ../ prefix\n+            let (glob, path) = relativize_glob(\"../utils/*.js\", base_path.clone()).unwrap();\n+            assert_eq!(glob, \"utils/*.js\");\n+            assert_eq!(path.path.as_str(), \"project/src\");\n+\n+            // Multiple ../ prefixes\n+            let (glob, path) = relativize_glob(\"../../lib/*.ts\", base_path.clone()).unwrap();\n+            assert_eq!(glob, \"lib/*.ts\");\n+            assert_eq!(path.path.as_str(), \"project\");\n+\n+            // Complex navigation with glob\n+            let (glob, path) =\n+                relativize_glob(\"../../../external/**/*.json\", base_path.clone()).unwrap();\n+            assert_eq!(glob, \"external/**/*.json\");\n+            assert_eq!(path.path.as_str(), \"\");\n+            Ok(())\n+        })\n+        .await\n+        .unwrap();\n+    }\n+\n+    #[tokio::test]\n+    async fn test_relativize_glob_mixed_prefixes() {\n+        let tt = turbo_tasks::TurboTasks::new(TurboTasksBackend::new(\n+            BackendOptions::default(),\n+            noop_backing_storage(),\n+        ));\n+        tt.run_once(async {\n+            let base_path = create_test_fs_path(\"project/src/components\");\n+\n+            // ../ followed by ./\n+            let (glob, path) = relativize_glob(\".././utils/*.js\", base_path.clone()).unwrap();\n+            assert_eq!(glob, \"utils/*.js\");\n+            assert_eq!(path.path.as_str(), \"project/src\");\n+\n+            // ./ followed by ../\n+            let (glob, path) = relativize_glob(\"./../lib/*.ts\", base_path.clone()).unwrap();\n+            assert_eq!(glob, \"lib/*.ts\");\n+            assert_eq!(path.path.as_str(), \"project/src\");\n+\n+            // Multiple mixed prefixes\n+            let (glob, path) =\n+                relativize_glob(\"././../.././external/*.json\", base_path.clone()).unwrap();\n+            assert_eq!(glob, \"external/*.json\");\n+            assert_eq!(path.path.as_str(), \"project\");\n+            Ok(())\n+        })\n+        .await\n+        .unwrap();\n+    }\n+\n+    #[tokio::test]\n+    async fn test_relativize_glob_error_navigation_out_of_root() {\n+        let tt = turbo_tasks::TurboTasks::new(TurboTasksBackend::new(\n+            BackendOptions::default(),\n+            noop_backing_storage(),\n+        ));\n+        tt.run_once(async {\n+            // Test navigating out of project root with empty path\n+            let empty_path = create_test_fs_path(\"\");\n+            let result = relativize_glob(\"../outside.js\", empty_path);\n+            assert!(result.is_err());\n+            assert!(\n+                result\n+                    .unwrap_err()\n+                    .to_string()\n+                    .contains(\"navigates out of the project root\")\n+            );\n+\n+            // Test navigating too far up from a shallow path\n+            let shallow_path = create_test_fs_path(\"project\");\n+            let result = relativize_glob(\"../../outside.js\", shallow_path);\n+            assert!(result.is_err());\n+            assert!(\n+                result\n+                    .unwrap_err()\n+                    .to_string()\n+                    .contains(\"navigates out of the project root\")\n+            );\n+\n+            // Test multiple ../ that would go out of root\n+            let base_path = create_test_fs_path(\"a/b\");\n+            let result = relativize_glob(\"../../../outside.js\", base_path);\n+            assert!(result.is_err());\n+            assert!(\n+                result\n+                    .unwrap_err()\n+                    .to_string()\n+                    .contains(\"navigates out of the project root\")\n+            );\n+            Ok(())\n+        })\n+        .await\n+        .unwrap();\n+    }\n+}"
        },
        {
            "sha": "553158eb34c459d066610d7adba81aba7a8c8d45",
            "filename": "test/integration/build-trace-extra-entries/app/next.config.js",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/bd802d13277f4b44d5cf4c1f1d61f9c32956bbc3/test%2Fintegration%2Fbuild-trace-extra-entries%2Fapp%2Fnext.config.js",
            "raw_url": "https://github.com/vercel/next.js/raw/bd802d13277f4b44d5cf4c1f1d61f9c32956bbc3/test%2Fintegration%2Fbuild-trace-extra-entries%2Fapp%2Fnext.config.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fintegration%2Fbuild-trace-extra-entries%2Fapp%2Fnext.config.js?ref=bd802d13277f4b44d5cf4c1f1d61f9c32956bbc3",
            "patch": "@@ -21,10 +21,10 @@ module.exports = {\n   },\n   outputFileTracingIncludes: {\n     '/index': ['include-me/**/*'],\n-    '/route1': ['include-me/**/*'],\n+    '/route1': ['./include-me/**/*'],\n   },\n   outputFileTracingExcludes: {\n     '/index': ['public/exclude-me/**/*'],\n-    '/route1': ['public/exclude-me/**/*'],\n+    '/route1': ['./public/exclude-me/**/*'],\n   },\n }"
        },
        {
            "sha": "e33a6696a74378906b0707cf00897d44d8d8fc88",
            "filename": "test/integration/build-trace-extra-entries/test/index.test.js",
            "status": "modified",
            "additions": 8,
            "deletions": 20,
            "changes": 28,
            "blob_url": "https://github.com/vercel/next.js/blob/bd802d13277f4b44d5cf4c1f1d61f9c32956bbc3/test%2Fintegration%2Fbuild-trace-extra-entries%2Ftest%2Findex.test.js",
            "raw_url": "https://github.com/vercel/next.js/raw/bd802d13277f4b44d5cf4c1f1d61f9c32956bbc3/test%2Fintegration%2Fbuild-trace-extra-entries%2Ftest%2Findex.test.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fintegration%2Fbuild-trace-extra-entries%2Ftest%2Findex.test.js?ref=bd802d13277f4b44d5cf4c1f1d61f9c32956bbc3",
            "patch": "@@ -35,16 +35,12 @@ describe('build trace with extra entries', () => {\n           join(appDir, '.next/server/app/route1/route.js.nft.json')\n         )\n \n-        expect(\n-          appDirRoute1Trace.files.some(\n-            (file) => file === '../../../../include-me/hello.txt'\n-          )\n-        ).toBe(true)\n-        expect(\n-          appDirRoute1Trace.files.some(\n-            (file) => file === '../../../../include-me/second.txt'\n-          )\n-        ).toBe(true)\n+        expect(appDirRoute1Trace.files).toContain(\n+          '../../../../include-me/hello.txt'\n+        )\n+        expect(appDirRoute1Trace.files).toContain(\n+          '../../../../include-me/second.txt'\n+        )\n         expect(\n           appDirRoute1Trace.files.some((file) => file.includes('exclude-me'))\n         ).toBe(false)\n@@ -89,16 +85,8 @@ describe('build trace with extra entries', () => {\n         expect(\n           indexTrace.files.some((file) => file.includes('some-cms/index.js'))\n         ).toBe(true)\n-        expect(\n-          indexTrace.files.some(\n-            (file) => file === '../../../include-me/hello.txt'\n-          )\n-        ).toBe(true)\n-        expect(\n-          indexTrace.files.some(\n-            (file) => file === '../../../include-me/second.txt'\n-          )\n-        ).toBe(true)\n+        expect(indexTrace.files).toContain('../../../include-me/hello.txt')\n+        expect(indexTrace.files).toContain('../../../include-me/second.txt')\n         expect(\n           indexTrace.files.some((file) => file.includes('exclude-me'))\n         ).toBe(false)"
        },
        {
            "sha": "221855bef59b8cd275cb90b6d42c32206a26626e",
            "filename": "turbopack/crates/turbo-tasks-fs/src/glob.rs",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/bd802d13277f4b44d5cf4c1f1d61f9c32956bbc3/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fglob.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/bd802d13277f4b44d5cf4c1f1d61f9c32956bbc3/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fglob.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fglob.rs?ref=bd802d13277f4b44d5cf4c1f1d61f9c32956bbc3",
            "patch": "@@ -1,3 +1,5 @@\n+use std::fmt::Display;\n+\n use anyhow::Result;\n use regex::bytes::{Regex, RegexBuilder};\n use serde::{Deserialize, Serialize};\n@@ -35,6 +37,12 @@ impl PartialEq for Glob {\n }\n impl Eq for Glob {}\n \n+impl Display for Glob {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        write!(f, \"Glob({})\", self.glob)\n+    }\n+}\n+\n #[derive(Serialize, Deserialize)]\n #[serde(transparent)]\n #[repr(transparent)]"
        }
    ],
    "stats": {
        "total": 335,
        "additions": 274,
        "deletions": 61
    }
}