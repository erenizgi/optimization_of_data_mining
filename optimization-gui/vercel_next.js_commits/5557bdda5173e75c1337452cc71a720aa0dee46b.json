{
    "author": "acdlite",
    "message": "[Segment Cache] Support third-party redirects in output: \"export\" mode (#81247)\n\nIn output: \"export\" mode, we can't use headers to request a particular\nsegment. Instead, we encode the extra request information into the URL.\nThis is not part of the \"public\" interface of the app; it's an internal\nNext.js implementation detail that the app developer should not need to\nconcern themselves with.\n\nFor example, to request a segment:\n\n- Path passed to <Link>:   /path/to/page\n- Path passed to fetch:    /path/to/page/__next-segments/_tree\n\n*(This is not the exact protocol, just an illustration.)*\n\nBefore we do that, though, we need to account for redirects. Even in\noutput: \"export\" mode, a proxy might redirect the page to a different\nlocation, but we shouldn't assume or expect that they also redirect all\nthe segment files, too.\n\nTo check whether the page is redirected, we perform a range request of\nthe first N bytes of the HTML document, just enough to verify the\ndocument comes from the same build. The canonical URL is determined from\nthe response.\n\nThen we can use the canonical URL to request the route tree.\n\nNote: We could embed the route tree into the HTML document, to avoid a\nsecond request. We're not doing that currently because it would make the\nHTML document larger and affect normal page loads.",
    "sha": "5557bdda5173e75c1337452cc71a720aa0dee46b",
    "files": [
        {
            "sha": "954cb70330745e09f25c6066325bb40d8686e336",
            "filename": "package.json",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/5557bdda5173e75c1337452cc71a720aa0dee46b/package.json",
            "raw_url": "https://github.com/vercel/next.js/raw/5557bdda5173e75c1337452cc71a720aa0dee46b/package.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/package.json?ref=5557bdda5173e75c1337452cc71a720aa0dee46b",
            "patch": "@@ -256,6 +256,7 @@\n     \"scheduler-experimental-builtin\": \"npm:scheduler@0.0.0-experimental-73aa744b-20250702\",\n     \"seedrandom\": \"3.0.5\",\n     \"semver\": \"7.3.7\",\n+    \"serve-handler\": \"6.1.6\",\n     \"shell-quote\": \"1.7.3\",\n     \"strip-ansi\": \"6.0.0\",\n     \"styled-jsx\": \"5.1.6\","
        },
        {
            "sha": "381b4717574da6d554e80810781fdadcc87522b3",
            "filename": "packages/next/src/client/components/segment-cache-impl/cache.ts",
            "status": "modified",
            "additions": 66,
            "deletions": 49,
            "changes": 115,
            "blob_url": "https://github.com/vercel/next.js/blob/5557bdda5173e75c1337452cc71a720aa0dee46b/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/5557bdda5173e75c1337452cc71a720aa0dee46b/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts?ref=5557bdda5173e75c1337452cc71a720aa0dee46b",
            "patch": "@@ -58,6 +58,10 @@ import { normalizeFlightData } from '../../flight-data-helpers'\n import { STATIC_STALETIME_MS } from '../router-reducer/prefetch-cache-utils'\n import { pingVisibleLinks } from '../links'\n import { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\n+import {\n+  DOC_PREFETCH_RANGE_HEADER_VALUE,\n+  doesExportedHtmlMatchBuildId,\n+} from '../../../shared/lib/segment-cache/output-export-prefetch-encoding'\n \n // A note on async/await when working in the prefetch cache:\n //\n@@ -997,16 +1001,68 @@ export async function fetchRouteOnCacheMiss(\n     headers[NEXT_URL] = nextUrl\n   }\n \n-  // In output: \"export\" mode, we need to add the segment path to the URL.\n-  // TODO: Consider moving this to `createFetch`, where we do similar logic for\n-  // manipulating the request URL to encode extra information.\n-  const url = new URL(href)\n-  const requestUrl = isOutputExportMode\n-    ? addSegmentPathToUrlInOutputExportMode(url, segmentPath)\n-    : url\n-\n   try {\n-    const response = await fetchPrefetchResponse(requestUrl, headers)\n+    let response\n+    let urlAfterRedirects\n+    if (isOutputExportMode) {\n+      // In output: \"export\" mode, we can't use headers to request a particular\n+      // segment. Instead, we encode the extra request information into the URL.\n+      // This is not part of the \"public\" interface of the app; it's an internal\n+      // Next.js implementation detail that the app developer should not need to\n+      // concern themselves with.\n+      //\n+      // For example, to request a segment:\n+      //\n+      //   Path passed to <Link>:   /path/to/page\n+      //   Path passed to fetch:    /path/to/page/__next-segments/_tree\n+      //\n+      //   (This is not the exact protocol, just an illustration.)\n+      //\n+      // Before we do that, though, we need to account for redirects. Even in\n+      // output: \"export\" mode, a proxy might redirect the page to a different\n+      // location, but we shouldn't assume or expect that they also redirect all\n+      // the segment files, too.\n+      //\n+      // To check whether the page is redirected, we perform a range request of\n+      // the first N bytes of the HTML document. The canonical URL is determined\n+      // from the response.\n+      //\n+      // Then we can use the canonical URL to request the route tree.\n+      //\n+      // NOTE: We could embed the route tree into the HTML document, to avoid\n+      // a second request. We're not doing that currently because it would make\n+      // the HTML document larger and affect normal page loads.\n+      const url = new URL(href)\n+      const htmlResponse = await fetch(href, {\n+        headers: {\n+          Range: DOC_PREFETCH_RANGE_HEADER_VALUE,\n+        },\n+      })\n+      const partialHtml = await htmlResponse.text()\n+      if (!doesExportedHtmlMatchBuildId(partialHtml, getAppBuildId())) {\n+        // The target page is not part of this app, or it belongs to a\n+        // different build.\n+        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n+        return null\n+      }\n+      urlAfterRedirects = htmlResponse.redirected\n+        ? new URL(htmlResponse.url)\n+        : url\n+      response = await fetchPrefetchResponse(\n+        addSegmentPathToUrlInOutputExportMode(urlAfterRedirects, segmentPath),\n+        headers\n+      )\n+    } else {\n+      // \"Server\" mode. We can use request headers instead of the pathname.\n+      // TODO: The eventual plan is to get rid of our custom request headers and\n+      // encode everything into the URL, using a similar strategy to the\n+      // \"output: export\" block above.\n+      const url = new URL(href)\n+      response = await fetchPrefetchResponse(url, headers)\n+      urlAfterRedirects =\n+        response !== null && response.redirected ? new URL(response.url) : url\n+    }\n+\n     if (\n       !response ||\n       !response.ok ||\n@@ -1035,17 +1091,7 @@ export async function fetchRouteOnCacheMiss(\n     // Or, we should just use a (readonly) URL object instead. The type of the\n     // prop that we pass to seed the initial state does not need to be the same\n     // type as the state itself.\n-    const canonicalUrl = createHrefFromUrl(\n-      new URL(\n-        response.redirected\n-          ? removeSegmentPathFromURLInOutputExportMode(\n-              href,\n-              requestUrl.href,\n-              response.url\n-            )\n-          : href\n-      )\n-    )\n+    const canonicalUrl = createHrefFromUrl(urlAfterRedirects)\n \n     // Check whether the response varies based on the Next-Url header.\n     const varyHeader = response.headers.get('vary')\n@@ -1722,35 +1768,6 @@ function addSegmentPathToUrlInOutputExportMode(\n   return url\n }\n \n-function removeSegmentPathFromURLInOutputExportMode(\n-  href: string,\n-  requestUrl: string,\n-  redirectUrl: string\n-) {\n-  if (isOutputExportMode) {\n-    // Reverse of addSegmentPathToUrlInOutputExportMode.\n-    //\n-    // In output: \"export\" mode, we append an extra string to the URL that\n-    // represents the segment path. If the server performs a redirect, it must\n-    // include the segment path in new URL.\n-    //\n-    // This removes the segment path from the redirected URL to obtain the\n-    // URL of the page.\n-    const segmentPath = requestUrl.substring(href.length)\n-    if (redirectUrl.endsWith(segmentPath)) {\n-      // Remove the segment path from the redirect URL to get the page URL.\n-      return redirectUrl.substring(0, redirectUrl.length - segmentPath.length)\n-    } else {\n-      // The server redirected to a URL that doesn't include the segment path.\n-      // This suggests the server may not have been configured correctly, but\n-      // we'll assume the redirected URL represents the page URL and continue.\n-      // TODO: Consider printing a warning with a link to a page that explains\n-      // how to configure redirects and rewrites correctly.\n-    }\n-  }\n-  return redirectUrl\n-}\n-\n function createPromiseWithResolvers<T>(): PromiseWithResolvers<T> {\n   // Shim of Stage 4 Promise.withResolvers proposal\n   let resolve: (value: T | PromiseLike<T>) => void"
        },
        {
            "sha": "f47decbbc84160b8fef7424d58ed8a552890e5d4",
            "filename": "packages/next/src/server/app-render/app-render.tsx",
            "status": "modified",
            "additions": 16,
            "deletions": 0,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/5557bdda5173e75c1337452cc71a720aa0dee46b/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/5557bdda5173e75c1337452cc71a720aa0dee46b/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx?ref=5557bdda5173e75c1337452cc71a720aa0dee46b",
            "patch": "@@ -2073,6 +2073,8 @@ async function renderToStream(\n         formState\n       ),\n       isStaticGeneration: generateStaticHTML,\n+      isBuildTimePrerendering: ctx.workStore.isBuildTimePrerendering === true,\n+      buildId: ctx.workStore.buildId,\n       getServerInsertedHTML,\n       getServerInsertedMetadata,\n       validateRootLayout: dev,\n@@ -2219,6 +2221,8 @@ async function renderToStream(\n           formState\n         ),\n         isStaticGeneration: generateStaticHTML,\n+        isBuildTimePrerendering: ctx.workStore.isBuildTimePrerendering === true,\n+        buildId: ctx.workStore.buildId,\n         getServerInsertedHTML: makeGetServerInsertedHTML({\n           polyfills,\n           renderServerInsertedHTML,\n@@ -3403,6 +3407,9 @@ async function prerenderToStream(\n             ),\n             getServerInsertedHTML,\n             getServerInsertedMetadata,\n+            isBuildTimePrerendering:\n+              ctx.workStore.isBuildTimePrerendering === true,\n+            buildId: ctx.workStore.buildId,\n           }),\n           dynamicAccess: consumeDynamicAccess(\n             serverDynamicTracking,\n@@ -3636,6 +3643,9 @@ async function prerenderToStream(\n             ),\n             getServerInsertedHTML,\n             getServerInsertedMetadata,\n+            isBuildTimePrerendering:\n+              ctx.workStore.isBuildTimePrerendering === true,\n+            buildId: ctx.workStore.buildId,\n           }),\n           dynamicAccess: dynamicTracking.dynamicAccesses,\n           // TODO: Should this include the SSR pass?\n@@ -3728,6 +3738,9 @@ async function prerenderToStream(\n             formState\n           ),\n           isStaticGeneration: true,\n+          isBuildTimePrerendering:\n+            ctx.workStore.isBuildTimePrerendering === true,\n+          buildId: ctx.workStore.buildId,\n           getServerInsertedHTML,\n           getServerInsertedMetadata,\n         }),\n@@ -3906,6 +3919,9 @@ async function prerenderToStream(\n             formState\n           ),\n           isStaticGeneration: true,\n+          isBuildTimePrerendering:\n+            ctx.workStore.isBuildTimePrerendering === true,\n+          buildId: ctx.workStore.buildId,\n           getServerInsertedHTML: makeGetServerInsertedHTML({\n             polyfills,\n             renderServerInsertedHTML,"
        },
        {
            "sha": "955cd58c97db996ea0e7114be2080e28f0d0e67c",
            "filename": "packages/next/src/server/stream-utils/node-web-streams-helper.ts",
            "status": "modified",
            "additions": 43,
            "deletions": 0,
            "changes": 43,
            "blob_url": "https://github.com/vercel/next.js/blob/5557bdda5173e75c1337452cc71a720aa0dee46b/packages%2Fnext%2Fsrc%2Fserver%2Fstream-utils%2Fnode-web-streams-helper.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/5557bdda5173e75c1337452cc71a720aa0dee46b/packages%2Fnext%2Fsrc%2Fserver%2Fstream-utils%2Fnode-web-streams-helper.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fstream-utils%2Fnode-web-streams-helper.ts?ref=5557bdda5173e75c1337452cc71a720aa0dee46b",
            "patch": "@@ -9,6 +9,7 @@ import {\n   removeFromUint8Array,\n } from './uint8array-helpers'\n import { MISSING_ROOT_TAGS_ERROR } from '../../shared/lib/errors/constants'\n+import { insertBuildIdComment } from '../../shared/lib/segment-cache/output-export-prefetch-encoding'\n \n function voidCatch() {\n   // this catcher is designed to be used with pipeTo where we expect the underlying\n@@ -179,6 +180,33 @@ export function createBufferedTransformStream(): TransformStream<\n   })\n }\n \n+function createPrefetchCommentStream(\n+  isBuildTimePrerendering: boolean,\n+  buildId: string\n+): TransformStream<Uint8Array, Uint8Array> {\n+  // Insert an extra comment at the beginning of the HTML document. This must\n+  // come after the DOCTYPE, which is inserted by React.\n+  //\n+  // The first chunk sent by React will contain the doctype. After that, we can\n+  // pass through the rest of the chunks as-is.\n+  let didTransformFirstChunk = false\n+  return new TransformStream({\n+    transform(chunk, controller) {\n+      if (isBuildTimePrerendering && !didTransformFirstChunk) {\n+        didTransformFirstChunk = true\n+        const decoder = new TextDecoder('utf-8', { fatal: true })\n+        const chunkStr = decoder.decode(chunk, {\n+          stream: true,\n+        })\n+        const updatedChunkStr = insertBuildIdComment(chunkStr, buildId)\n+        controller.enqueue(encoder.encode(updatedChunkStr))\n+        return\n+      }\n+      controller.enqueue(chunk)\n+    },\n+  })\n+}\n+\n export function renderToInitialFizzStream({\n   ReactDOMServer,\n   element,\n@@ -616,6 +644,8 @@ function chainTransformers<T>(\n export type ContinueStreamOptions = {\n   inlinedDataStream: ReadableStream<Uint8Array> | undefined\n   isStaticGeneration: boolean\n+  isBuildTimePrerendering: boolean\n+  buildId: string\n   getServerInsertedHTML: () => Promise<string>\n   getServerInsertedMetadata: () => Promise<string>\n   validateRootLayout?: boolean\n@@ -631,6 +661,8 @@ export async function continueFizzStream(\n     suffix,\n     inlinedDataStream,\n     isStaticGeneration,\n+    isBuildTimePrerendering,\n+    buildId,\n     getServerInsertedHTML,\n     getServerInsertedMetadata,\n     validateRootLayout,\n@@ -649,6 +681,9 @@ export async function continueFizzStream(\n     // Buffer everything to avoid flushing too frequently\n     createBufferedTransformStream(),\n \n+    // Add build id comment to start of the HTML document (in export mode)\n+    createPrefetchCommentStream(isBuildTimePrerendering, buildId),\n+\n     // Transform metadata\n     createMetadataTransformStream(getServerInsertedMetadata),\n \n@@ -701,6 +736,8 @@ type ContinueStaticPrerenderOptions = {\n   inlinedDataStream: ReadableStream<Uint8Array>\n   getServerInsertedHTML: () => Promise<string>\n   getServerInsertedMetadata: () => Promise<string>\n+  isBuildTimePrerendering: boolean\n+  buildId: string\n }\n \n export async function continueStaticPrerender(\n@@ -709,12 +746,18 @@ export async function continueStaticPrerender(\n     inlinedDataStream,\n     getServerInsertedHTML,\n     getServerInsertedMetadata,\n+    isBuildTimePrerendering,\n+    buildId,\n   }: ContinueStaticPrerenderOptions\n ) {\n   return (\n     prerenderStream\n       // Buffer everything to avoid flushing too frequently\n       .pipeThrough(createBufferedTransformStream())\n+      // Add build id comment to start of the HTML document (in export mode)\n+      .pipeThrough(\n+        createPrefetchCommentStream(isBuildTimePrerendering, buildId)\n+      )\n       // Insert generated tags to head\n       .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))\n       // Transform metadata"
        },
        {
            "sha": "b1364777cb53d04ad127d2f69f47835a19ec2f55",
            "filename": "packages/next/src/shared/lib/segment-cache/output-export-prefetch-encoding.ts",
            "status": "added",
            "additions": 61,
            "deletions": 0,
            "changes": 61,
            "blob_url": "https://github.com/vercel/next.js/blob/5557bdda5173e75c1337452cc71a720aa0dee46b/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fsegment-cache%2Foutput-export-prefetch-encoding.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/5557bdda5173e75c1337452cc71a720aa0dee46b/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fsegment-cache%2Foutput-export-prefetch-encoding.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fsegment-cache%2Foutput-export-prefetch-encoding.ts?ref=5557bdda5173e75c1337452cc71a720aa0dee46b",
            "patch": "@@ -0,0 +1,61 @@\n+// In output: export mode, the build id is added to the start of the HTML\n+// document, directly after the doctype declaration. During a prefetch, the\n+// client performs a range request to get the build id, so it can check whether\n+// the target page belongs to the same build.\n+//\n+// The first 64 bytes of the document are requested. The exact number isn't\n+// too important; it must be larger than the build id + doctype + closing and\n+// ending comment markers, but it doesn't need to match the end of the\n+// comment exactly.\n+//\n+// Build ids are 21 bytes long in the default implementation, though this\n+// can be overridden in the Next.js config. For the purposes of this check,\n+// it's OK to only match the start of the id, so we'll truncate it if exceeds\n+// a certain length.\n+\n+const DOCTYPE_PREFIX = '<!DOCTYPE html>' // 15 bytes\n+const MAX_BUILD_ID_LENGTH = 24\n+\n+// Request the first 64 bytes. The Range header is inclusive of the end value.\n+export const DOC_PREFETCH_RANGE_HEADER_VALUE = 'bytes=0-63'\n+\n+function escapeBuildId(buildId: string) {\n+  // If the build id is longer than the given limit, it's OK for our purposes\n+  // to only match the beginning.\n+  const truncated = buildId.slice(0, MAX_BUILD_ID_LENGTH)\n+  // Replace hyphens with underscores so it doesn't break the HTML comment.\n+  // (Unlikely, but if this did happen it would break the whole document.)\n+  return truncated.replace(/-/g, '_')\n+}\n+\n+export function insertBuildIdComment(originalHtml: string, buildId: string) {\n+  if (\n+    // Skip if the build id contains a closing comment marker.\n+    buildId.includes('-->') ||\n+    // React always inserts a doctype at the start of the document. Skip if it\n+    // isn't present. Shouldn't happen; suggests an issue elsewhere.\n+    !originalHtml.startsWith(DOCTYPE_PREFIX)\n+  ) {\n+    // Return the original HTML unchanged. This means the document will not\n+    // be prefetched.\n+    // TODO: The build id comment is currently only used during prefetches, but\n+    // if we eventually use this mechanism for regular navigations, we may need\n+    // to error during build if we fail to insert it for some reason.\n+    return originalHtml\n+  }\n+  // The comment must be inserted after the doctype.\n+  return originalHtml.replace(\n+    DOCTYPE_PREFIX,\n+    DOCTYPE_PREFIX + '<!--' + escapeBuildId(buildId) + '-->'\n+  )\n+}\n+\n+export function doesExportedHtmlMatchBuildId(\n+  partialHtmlDocument: string,\n+  buildId: string\n+) {\n+  // Check whether the document starts with the expected buildId.\n+  return partialHtmlDocument.startsWith(\n+    DOCTYPE_PREFIX + '<!--' + escapeBuildId(buildId) + '-->'\n+  )\n+}"
        },
        {
            "sha": "814ce087c7c56f07de78a91cd3af5559f480ebe5",
            "filename": "pnpm-lock.yaml",
            "status": "modified",
            "additions": 48,
            "deletions": 1,
            "changes": 49,
            "blob_url": "https://github.com/vercel/next.js/blob/5557bdda5173e75c1337452cc71a720aa0dee46b/pnpm-lock.yaml",
            "raw_url": "https://github.com/vercel/next.js/raw/5557bdda5173e75c1337452cc71a720aa0dee46b/pnpm-lock.yaml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/pnpm-lock.yaml?ref=5557bdda5173e75c1337452cc71a720aa0dee46b",
            "patch": "@@ -550,6 +550,9 @@ importers:\n       semver:\n         specifier: 7.3.7\n         version: 7.3.7\n+      serve-handler:\n+        specifier: 6.1.6\n+        version: 6.1.6\n       shell-quote:\n         specifier: 1.7.3\n         version: 1.7.3\n@@ -7382,6 +7385,10 @@ packages:\n   constants-browserify@1.0.0:\n     resolution: {integrity: sha512-xFxOwqIzR/e1k1gLiWEophSCMqXcwVHIH7akf7b/vxcUeGunlj3hvZaaqxwHsTgn+IndtkQJgSztIDWeumWJDQ==}\n \n+  content-disposition@0.5.2:\n+    resolution: {integrity: sha512-kRGRZw3bLlFISDBgwTSA1TMBFN6J6GWDeubmDE3AF+3+yXL8hTWv8r5rkLbqYXY4RjPk/EzHnClI3zQf1cFmHA==}\n+    engines: {node: '>= 0.6'}\n+\n   content-disposition@0.5.3:\n     resolution: {integrity: sha512-ExO0774ikEObIAEV9kDo50o+79VCUdEB6n6lzKgGwupcVeRlhrj3qGAfwq8G6uBJjkqLrhT0qEYFcWng8z1z0g==}\n     engines: {node: '>= 0.6'}\n@@ -11873,6 +11880,10 @@ packages:\n     resolution: {integrity: sha512-115fLhvZVqWwHPbClyntxEVfVDfl9DLLTuJvq3g2O/Oxi8AiNouAHvDSzHS0viUJc+V5vm3eq91Xwqn9dp4jRA==}\n     hasBin: true\n \n+  mime-db@1.33.0:\n+    resolution: {integrity: sha512-BHJ/EKruNIqJf/QahvxwQZXKygOQ256myeN/Ew+THcAa5q+PjyTTMMeNQC4DZw5AwfvelsUrA6B67NKMqXDbzQ==}\n+    engines: {node: '>= 0.6'}\n+\n   mime-db@1.47.0:\n     resolution: {integrity: sha512-QBmA/G2y+IfeS4oktet3qRZ+P5kPhCKRXxXnQEudYqUaEioAU1/Lq2us3D/t1Jfo4hE9REQPrbB7K5sOczJVIw==}\n     engines: {node: '>= 0.6'}\n@@ -11881,6 +11892,10 @@ packages:\n     resolution: {integrity: sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==}\n     engines: {node: '>= 0.6'}\n \n+  mime-types@2.1.18:\n+    resolution: {integrity: sha512-lc/aahn+t4/SWV/qcmumYjymLsWfN3ELhpmVuUFjgsORruuZPVSwAQryq+HHGvO/SI2KVX26bx+En+zhM8g8hQ==}\n+    engines: {node: '>= 0.6'}\n+\n   mime-types@2.1.35:\n     resolution: {integrity: sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==}\n     engines: {node: '>= 0.6'}\n@@ -12826,6 +12841,9 @@ packages:\n   path-to-regexp@0.1.7:\n     resolution: {integrity: sha512-5DFkuoqlv1uYQKxy8omFBeJPQcdoE07Kv2sferDCrAq1ohOU+MSDswDIbnx3YAM60qIOnYa53wBhXW0EbMonrQ==}\n \n+  path-to-regexp@3.3.0:\n+    resolution: {integrity: sha512-qyCH421YQPS2WFDxDjftfc1ZR5WKQzVzqsp4n9M2kQhVOo/ByahFoUNJfl58kOcEGfQ//7weFTDhm+ss8Ecxgw==}\n+\n   path-to-regexp@6.1.0:\n     resolution: {integrity: sha512-h9DqehX3zZZDCEm+xbfU0ZmwCGFCAAraPJWMXJ4+v32NjZJilVg3k1TcKsRgIb8IQ/izZSaydDc1OhJCZvs2Dw==}\n \n@@ -13943,6 +13961,10 @@ packages:\n   randomfill@1.0.4:\n     resolution: {integrity: sha512-87lcbR8+MhcWcUiQ+9e+Rwx8MyR2P7qnt15ynUlbm3TU/fjbgz4GsvfSUDTemtCCtVCqb4ZcEFlyPNTh9bBTLw==}\n \n+  range-parser@1.2.0:\n+    resolution: {integrity: sha512-kA5WQoNVo4t9lNx2kQNFCxKeBl5IbbSNBl1M/tLkw9WCn+hxNBAW5Qh8gdhs63CJnhjJ2zQWFoqPJP2sK1AV5A==}\n+    engines: {node: '>= 0.6'}\n+\n   range-parser@1.2.1:\n     resolution: {integrity: sha512-Hrgsx+orqoygnmhFbKaHE6c296J+HTAQXoxEF6gNupROmmGJRoyzfG3ccAveqCBrwr/2yxQ5BVd/GTl5agOwSg==}\n     engines: {node: '>= 0.6'}\n@@ -14748,6 +14770,9 @@ packages:\n   serialize-javascript@6.0.2:\n     resolution: {integrity: sha512-Saa1xPByTTq2gdeFZYLLo+RFE35NHZkAbqZeWNd3BpzppeVisAqpDjcp8dyf6uIvEqJRd46jemmyA4iFIeVk8g==}\n \n+  serve-handler@6.1.6:\n+    resolution: {integrity: sha512-x5RL9Y2p5+Sh3D38Fh9i/iQ5ZK+e4xuXRd/pGbM4D13tgo/MGwbttUk8emytcr1YYzBYs+apnUngBDFYfpjPuQ==}\n+\n   serve-index@1.9.1:\n     resolution: {integrity: sha512-pXHfKNP4qujrtteMrSBb0rc8HJ9Ms/GrXwcUtUtD5s4ewDJI8bT3Cz2zTVRMKtri49pLx2e0Ya8ziP5Ya2pZZw==}\n     engines: {node: '>= 0.8.0'}\n@@ -15329,7 +15354,7 @@ packages:\n   superagent@3.8.3:\n     resolution: {integrity: sha512-GLQtLMCoEIK4eDv6OGtkOoSMt3D+oq0y3dsxMuYuDvaNUvuT8eFBuLmfR0iYYzHC1e8hpzC6ZsxbuP6DIalMFA==}\n     engines: {node: '>= 4.0'}\n-    deprecated: Please upgrade to v9.0.0+ as we have fixed a public vulnerability with formidable dependency. Note that v9.0.0+ requires Node.js v14.18.0+. See https://github.com/ladjs/superagent/pull/1800 for insight. This project is supported and maintained by the team at Forward Email @ https://forwardemail.net\n+    deprecated: Please upgrade to v7.0.2+ of superagent.  We have fixed numerous issues with streams, form-data, attach(), filesystem errors not bubbling up (ENOENT on attach()), and all tests are now passing.  See the releases tab for more information at <https://github.com/visionmedia/superagent/releases>.\n \n   superstruct@1.0.3:\n     resolution: {integrity: sha512-8iTn3oSS8nRGn+C2pgXSKPI3jmpm6FExNazNpjvqS6ZUJQCej3PUXEKM8NjHBOs54ExM+LPW/FBRhymrdcCiSg==}\n@@ -23580,6 +23605,8 @@ snapshots:\n \n   constants-browserify@1.0.0: {}\n \n+  content-disposition@0.5.2: {}\n+\n   content-disposition@0.5.3:\n     dependencies:\n       safe-buffer: 5.1.2\n@@ -29868,10 +29895,16 @@ snapshots:\n       bn.js: 4.11.9\n       brorand: 1.1.0\n \n+  mime-db@1.33.0: {}\n+\n   mime-db@1.47.0: {}\n \n   mime-db@1.52.0: {}\n \n+  mime-types@2.1.18:\n+    dependencies:\n+      mime-db: 1.33.0\n+\n   mime-types@2.1.35:\n     dependencies:\n       mime-db: 1.52.0\n@@ -30927,6 +30960,8 @@ snapshots:\n \n   path-to-regexp@0.1.7: {}\n \n+  path-to-regexp@3.3.0: {}\n+\n   path-to-regexp@6.1.0: {}\n \n   path-to-regexp@6.2.1: {}\n@@ -32058,6 +32093,8 @@ snapshots:\n       randombytes: 2.1.0\n       safe-buffer: 5.2.1\n \n+  range-parser@1.2.0: {}\n+\n   range-parser@1.2.1: {}\n \n   raw-body@2.4.0:\n@@ -33133,6 +33170,16 @@ snapshots:\n     dependencies:\n       randombytes: 2.1.0\n \n+  serve-handler@6.1.6:\n+    dependencies:\n+      bytes: 3.0.0\n+      content-disposition: 0.5.2\n+      mime-types: 2.1.18\n+      minimatch: 3.1.2\n+      path-is-inside: 1.0.2\n+      path-to-regexp: 3.3.0\n+      range-parser: 1.2.0\n+\n   serve-index@1.9.1:\n     dependencies:\n       accepts: 1.3.7"
        },
        {
            "sha": "f96006b798a17f1148f34ee2dcffa5017a3ad062",
            "filename": "test/e2e/app-dir/segment-cache/export/server.mjs",
            "status": "modified",
            "additions": 29,
            "deletions": 25,
            "changes": 54,
            "blob_url": "https://github.com/vercel/next.js/blob/5557bdda5173e75c1337452cc71a720aa0dee46b/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fexport%2Fserver.mjs",
            "raw_url": "https://github.com/vercel/next.js/raw/5557bdda5173e75c1337452cc71a720aa0dee46b/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fexport%2Fserver.mjs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fexport%2Fserver.mjs?ref=5557bdda5173e75c1337452cc71a720aa0dee46b",
            "patch": "@@ -1,37 +1,41 @@\n-import express from 'express'\n+// import express from 'express'\n import { join, dirname } from 'node:path'\n import { fileURLToPath } from 'node:url'\n import { createServer } from 'node:http'\n \n-const OUT_DIR = join(dirname(fileURLToPath(import.meta.url)), 'out')\n+// output: \"export\" mode was originally designed to work seamlessly with the\n+// \"serve\" package, which uses \"server-handler\" internally. It has built-in\n+// conventions for things like .html extensions and trailing slashes. Apps that\n+// use a different server like ngnix need configuration to match this behavior.\n+// TODO: We should improve our documentation around this.\n+import handler from 'serve-handler'\n \n-const app = express()\n+const OUT_DIR = join(dirname(fileURLToPath(import.meta.url)), 'out')\n \n-// Redirect /redirect-to-target-page/* to /target-page/*\n-app.get('/redirect-to-target-page/:file?', (req, res) => {\n-  const { file } = req.params\n-  const newUrl = file ? `/target-page/${file}` : '/target-page'\n-  console.log(`Redirecting to ${newUrl}`)\n-  res.redirect(302, newUrl)\n-})\n+export const server = createServer((request, response) => {\n+  // Redirect /redirect-to-target-page to /target-page. Notice that we only have\n+  // to redirect the path of the page, not any other resources.\n+  if (request.url === '/redirect-to-target-page') {\n+    console.log('Redirecting to /target-page')\n+    response.writeHead(302, { Location: '/target-page' })\n+    response.end()\n+    return\n+  }\n \n-// Rewrite /rewrite-to-target-page/* to /target-page/*\n-// NOTE: This intentionally uses `app.use` instead of `app.get` because\n-// the latter doesn't let you modify the `req.url` property.\n-app.use((req, res, next) => {\n-  const url = req.originalUrl\n-  if (/^\\/rewrite-to-target-page\\/?[^/]*$/.test(url)) {\n-    const newUrl = req.originalUrl.replace(\n+  // Rewrite /rewrite-to-target-page to /target-page\n+  // NOTE: This simulates a rewrite using a proxy, which is not something we\n+  // officially support or document. It's just here to illustrate how it would\n+  // be done in theory.\n+  if (/^\\/rewrite-to-target-page\\/?[^/]*$/.test(request.url)) {\n+    const newUrl = request.url.replace(\n       '/rewrite-to-target-page',\n       '/target-page'\n     )\n-    console.log(`Rewriting to ${newUrl}`)\n-    req.url = newUrl\n+    console.log(`Rewriting ${request.url} to ${newUrl}`)\n+    request.url = newUrl\n   }\n-  next()\n-})\n-\n-// Serve static files from the out directory\n-app.use(express.static(OUT_DIR, { extensions: ['html'] }))\n \n-export const server = createServer(app)\n+  return handler(request, response, {\n+    public: OUT_DIR,\n+  })\n+})"
        }
    ],
    "stats": {
        "total": 339,
        "additions": 264,
        "deletions": 75
    }
}