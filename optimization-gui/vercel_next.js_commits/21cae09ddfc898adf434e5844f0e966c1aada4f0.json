{
    "author": "mischnic",
    "message": "Turbopack: lazily create syntax contexts for scope hoisting (#81193)\n\nPreviously, if 10k modules are merged together, it would create 10k syntax context for each of the 10k modules. That involves a TLS and a `Mutex`.\nMost of these are never used, so instead create the contexts lazily with some interior mutability.\nNow this step doesn't show up in the trace at all anymore (in one case, cutting build time from 10s to 5s)\n\nhttps://vercel.slack.com/archives/C06PPGZ0FD3/p1751475796580989?thread_ts=1751302539.808369&cid=C06PPGZ0FD3",
    "sha": "21cae09ddfc898adf434e5844f0e966c1aada4f0",
    "files": [
        {
            "sha": "bfd5e4a84f31bdaeb0b7f50496af3d534840ca6c",
            "filename": "Cargo.lock",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/21cae09ddfc898adf434e5844f0e966c1aada4f0/Cargo.lock",
            "raw_url": "https://github.com/vercel/next.js/raw/21cae09ddfc898adf434e5844f0e966c1aada4f0/Cargo.lock",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/Cargo.lock?ref=21cae09ddfc898adf434e5844f0e966c1aada4f0",
            "patch": "@@ -9734,6 +9734,7 @@ dependencies = [\n  \"bitvec\",\n  \"bytes-str\",\n  \"codspeed-criterion-compat\",\n+ \"dashmap 6.1.0\",\n  \"data-encoding\",\n  \"either\",\n  \"indexmap 2.9.0\","
        },
        {
            "sha": "3b9593e6eea987cca0eb88f42d6a13032e7e1cba",
            "filename": "turbopack/crates/turbopack-ecmascript/Cargo.toml",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/21cae09ddfc898adf434e5844f0e966c1aada4f0/turbopack%2Fcrates%2Fturbopack-ecmascript%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/21cae09ddfc898adf434e5844f0e966c1aada4f0/turbopack%2Fcrates%2Fturbopack-ecmascript%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2FCargo.toml?ref=21cae09ddfc898adf434e5844f0e966c1aada4f0",
            "patch": "@@ -27,6 +27,7 @@ num-traits = \"0.2.15\"\n once_cell = { workspace = true }\n parking_lot = { workspace = true }\n petgraph = { workspace = true }\n+dashmap = { workspace = true }\n regex = { workspace = true }\n rustc-hash = { workspace = true }\n serde = { workspace = true }"
        },
        {
            "sha": "194c31739ca47e7edd7ea2c16cfc0bf3b3719248",
            "filename": "turbopack/crates/turbopack-ecmascript/src/lib.rs",
            "status": "modified",
            "additions": 92,
            "deletions": 72,
            "changes": 164,
            "blob_url": "https://github.com/vercel/next.js/blob/21cae09ddfc898adf434e5844f0e966c1aada4f0/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/21cae09ddfc898adf434e5844f0e966c1aada4f0/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs?ref=21cae09ddfc898adf434e5844f0e966c1aada4f0",
            "patch": "@@ -84,8 +84,8 @@ pub use transform::{\n };\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{\n-    FxIndexMap, IntoTraitRef, NonLocalValue, ReadRef, ResolvedVc, TaskInput, TryFlatJoinIterExt,\n-    TryJoinIterExt, ValueToString, Vc, trace::TraceRawVcs,\n+    FxDashMap, FxIndexMap, IntoTraitRef, NonLocalValue, ReadRef, ResolvedVc, TaskInput,\n+    TryFlatJoinIterExt, TryJoinIterExt, ValueToString, Vc, trace::TraceRawVcs,\n };\n use turbo_tasks_fs::{FileJsonContent, FileSystemPath, glob::Glob, rope::Rope};\n use turbopack_core::{\n@@ -1077,37 +1077,33 @@ impl EcmascriptModuleContent {\n                 .iter()\n                 .zip(modules.keys().copied())\n                 .map(async |(options, module)| {\n-                    async {\n-                        let options = options.await?;\n-                        let EcmascriptModuleContentOptions {\n-                            chunking_context,\n-                            parsed,\n-                            ident,\n-                            specified_module_type,\n-                            generate_source_map,\n-                            original_source_map,\n-                            ..\n-                        } = &*options;\n-\n-                        let result = process_parse_result(\n-                            *parsed,\n-                            **ident,\n-                            *specified_module_type,\n-                            *generate_source_map,\n-                            *original_source_map,\n-                            *chunking_context.minify_type().await?,\n-                            Some(&*options),\n-                            Some(ScopeHoistingOptions {\n-                                module,\n-                                modules: &modules,\n-                            }),\n-                        )\n-                        .await?;\n+                    let options = options.await?;\n+                    let EcmascriptModuleContentOptions {\n+                        chunking_context,\n+                        parsed,\n+                        ident,\n+                        specified_module_type,\n+                        generate_source_map,\n+                        original_source_map,\n+                        ..\n+                    } = &*options;\n+\n+                    let result = process_parse_result(\n+                        *parsed,\n+                        **ident,\n+                        *specified_module_type,\n+                        *generate_source_map,\n+                        *original_source_map,\n+                        *chunking_context.minify_type().await?,\n+                        Some(&*options),\n+                        Some(ScopeHoistingOptions {\n+                            module,\n+                            modules: &modules,\n+                        }),\n+                    )\n+                    .await?;\n \n-                        Ok((module, result))\n-                    }\n-                    .instrument(tracing::trace_span!(\"process individual module\"))\n-                    .await\n+                    Ok((module, result))\n                 })\n                 .try_join()\n                 .await?;\n@@ -1196,7 +1192,7 @@ async fn merge_modules(\n         current_module_idx: u32,\n         /// The export syntax contexts in the current AST, which will be mapped to merged_ctxts\n         reverse_module_contexts:\n-            FxIndexMap<SyntaxContext, ResolvedVc<Box<dyn EcmascriptChunkPlaceable>>>,\n+            FxHashMap<SyntaxContext, ResolvedVc<Box<dyn EcmascriptChunkPlaceable>>>,\n         /// For a given module, the `eval_context.imports.exports`. So for a given export, this\n         /// allows looking up the corresponding local binding's name and context.\n         export_contexts:\n@@ -1322,28 +1318,25 @@ async fn merge_modules(\n             FxHashMap::with_capacity_and_hasher(contents.len() * 5, Default::default());\n \n         let mut prepare_module =\n-            |(module, content): &(ResolvedVc<Box<dyn EcmascriptChunkPlaceable>>, CodeGenResult),\n+            |module_count: usize,\n+             current_module_idx: usize,\n+             (module, content): &(ResolvedVc<Box<dyn EcmascriptChunkPlaceable>>, CodeGenResult),\n              program: &mut Program| {\n                 let _ = tracing::trace_span!(\"prepare module\").entered();\n                 if let CodeGenResult {\n                     scope_hoisting_syntax_contexts: Some(module_contexts),\n                     ..\n                 } = content\n                 {\n+                    let modules_header_width = module_count.next_power_of_two().trailing_zeros();\n                     GLOBALS.set(globals_merged, || {\n                         program.visit_mut_with(&mut SetSyntaxContextVisitor {\n-                            modules_header_width: module_contexts\n-                                .len()\n-                                .next_power_of_two()\n-                                .trailing_zeros(),\n+                            modules_header_width,\n                             current_module: *module,\n-                            current_module_idx: module_contexts\n-                                .get_index_of(module)\n-                                .context(\"expected module in module_contexts\")?\n-                                as u32,\n+                            current_module_idx: current_module_idx as u32,\n                             reverse_module_contexts: module_contexts\n                                 .iter()\n-                                .map(|(m, ctxt)| (*ctxt, *m))\n+                                .map(|e| (*e.value(), *e.key()))\n                                 .collect(),\n                             export_contexts: &export_contexts,\n                             unique_contexts_cache: &mut unique_contexts_cache,\n@@ -1375,7 +1368,7 @@ async fn merge_modules(\n         // ith-module.\n         let mut queue = entry_points\n             .iter()\n-            .map(|(_, i)| prepare_module(&contents[*i], &mut programs[*i]))\n+            .map(|(_, i)| prepare_module(contents.len(), *i, &contents[*i], &mut programs[*i]))\n             .flatten_ok()\n             .rev()\n             .collect::<Result<Vec<_>>>()?;\n@@ -1397,9 +1390,14 @@ async fn merge_modules(\n                             // Only insert once, otherwise the module was already executed\n                             if inserted.insert(index) {\n                                 queue.extend(\n-                                    prepare_module(&contents[index], &mut programs[index])?\n-                                        .into_iter()\n-                                        .rev(),\n+                                    prepare_module(\n+                                        contents.len(),\n+                                        index,\n+                                        &contents[index],\n+                                        &mut programs[index],\n+                                    )?\n+                                    .into_iter()\n+                                    .rev(),\n                                 );\n                             }\n                             continue;\n@@ -1493,6 +1491,9 @@ async fn merge_modules(\n }\n \n /// Provides information about the other modules in the current scope hoisting group.\n+///\n+/// Note that this object contains interior mutability to lazily create syntax contexts in\n+/// `get_module_syntax_context`.\n #[derive(Clone, Copy)]\n pub enum ScopeHoistingContext<'a> {\n     Some {\n@@ -1501,9 +1502,12 @@ pub enum ScopeHoistingContext<'a> {\n         /// All modules in the current group, and whether they should expose their exports\n         modules:\n             &'a FxIndexMap<ResolvedVc<Box<dyn EcmascriptChunkPlaceable>>, MergeableModuleExposure>,\n-        /// To import a specifier from another module, apply this context to the Ident\n-        module_syntax_contexts:\n-            &'a FxIndexMap<ResolvedVc<Box<dyn EcmascriptChunkPlaceable>>, SyntaxContext>,\n+\n+        is_import_mark: Mark,\n+        globals: &'a Arc<Globals>,\n+        // Interior mutability!\n+        module_syntax_contexts_cache:\n+            &'a FxDashMap<ResolvedVc<Box<dyn EcmascriptChunkPlaceable>>, SyntaxContext>,\n     },\n     None,\n }\n@@ -1530,15 +1534,38 @@ impl<'a> ScopeHoistingContext<'a> {\n         }\n     }\n \n+    /// To import a specifier from another module, apply this context to the Ident\n     pub fn get_module_syntax_context(\n         &self,\n         module: ResolvedVc<Box<dyn EcmascriptChunkPlaceable>>,\n     ) -> Option<SyntaxContext> {\n         match self {\n             ScopeHoistingContext::Some {\n-                module_syntax_contexts,\n+                modules,\n+                module_syntax_contexts_cache,\n+                globals,\n+                is_import_mark,\n                 ..\n-            } => module_syntax_contexts.get(&module).copied(),\n+            } => {\n+                if !modules.contains_key(&module) {\n+                    return None;\n+                }\n+\n+                Some(match module_syntax_contexts_cache.entry(module) {\n+                    dashmap::Entry::Occupied(e) => *e.get(),\n+                    dashmap::Entry::Vacant(e) => {\n+                        let ctxt = GLOBALS.set(globals, || {\n+                            let mark = Mark::fresh(*is_import_mark);\n+                            SyntaxContext::empty()\n+                                .apply_mark(*is_import_mark)\n+                                .apply_mark(mark)\n+                        });\n+\n+                        e.insert(ctxt);\n+                        ctxt\n+                    }\n+                })\n+            }\n             ScopeHoistingContext::None => None,\n         }\n     }\n@@ -1565,14 +1592,15 @@ struct CodeGenResult {\n     original_source_map: CodeGenResultOriginalSourceMap,\n     minify: MinifyType,\n     scope_hoisting_syntax_contexts:\n-        Option<FxIndexMap<ResolvedVc<Box<dyn EcmascriptChunkPlaceable + 'static>>, SyntaxContext>>,\n+        Option<FxDashMap<ResolvedVc<Box<dyn EcmascriptChunkPlaceable + 'static>>, SyntaxContext>>,\n }\n \n struct ScopeHoistingOptions<'a> {\n     module: ResolvedVc<Box<dyn EcmascriptChunkPlaceable>>,\n     modules: &'a FxIndexMap<ResolvedVc<Box<dyn EcmascriptChunkPlaceable>>, MergeableModuleExposure>,\n }\n \n+#[instrument(level = Level::TRACE, skip_all, name = \"process module\")]\n async fn process_parse_result(\n     parsed: ResolvedVc<ParseResult>,\n     ident: Vc<AssetIdent>,\n@@ -1609,28 +1637,15 @@ async fn process_parse_result(\n \n             let (mut code_gens, retain_syntax_context, prepend_ident_comment) =\n                 if let Some(scope_hoisting_options) = scope_hoisting_options {\n-                    let (is_import_mark, module_syntax_contexts) = GLOBALS.set(globals, || {\n-                        let is_import_mark = Mark::new();\n-                        let module_syntax_contexts: FxIndexMap<_, _> = scope_hoisting_options\n-                            .modules\n-                            .keys()\n-                            .map(|m| {\n-                                let mark = Mark::fresh(is_import_mark);\n-                                (\n-                                    *m,\n-                                    SyntaxContext::empty()\n-                                        .apply_mark(is_import_mark)\n-                                        .apply_mark(mark),\n-                                )\n-                            })\n-                            .collect();\n-                        (is_import_mark, module_syntax_contexts)\n-                    });\n+                    let is_import_mark = GLOBALS.set(globals, || Mark::new());\n \n+                    let module_syntax_contexts_cache = FxDashMap::default();\n                     let ctx = ScopeHoistingContext::Some {\n                         module: scope_hoisting_options.module,\n                         modules: scope_hoisting_options.modules,\n-                        module_syntax_contexts: &module_syntax_contexts,\n+                        module_syntax_contexts_cache: &module_syntax_contexts_cache,\n+                        is_import_mark,\n+                        globals,\n                     };\n                     let code_gens = options.unwrap().merged_code_gens(ctx).await?;\n                     let preserved_exports =\n@@ -1663,7 +1678,11 @@ async fn process_parse_result(\n \n                     (\n                         code_gens,\n-                        Some((is_import_mark, module_syntax_contexts, preserved_exports)),\n+                        Some((\n+                            is_import_mark,\n+                            module_syntax_contexts_cache,\n+                            preserved_exports,\n+                        )),\n                         prepend_ident_comment,\n                     )\n                 } else if let Some(options) = options {\n@@ -1971,6 +1990,7 @@ async fn emit_content(\n     .cell())\n }\n \n+#[instrument(level = Level::TRACE, skip_all, name = \"apply code generation\")]\n fn process_content_with_code_gens(\n     program: &mut Program,\n     globals: &Globals,"
        }
    ],
    "stats": {
        "total": 166,
        "additions": 94,
        "deletions": 72
    }
}