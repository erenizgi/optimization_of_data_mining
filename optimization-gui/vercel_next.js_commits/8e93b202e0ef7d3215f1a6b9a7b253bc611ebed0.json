{
    "author": "timneutkens",
    "message": "Development: Skip route matching when there is an existing match (#84227)\n\n## What?\n\nAdds a fast path when there is an existing match already from matching\nearlier in the request lifecycle. This works for the majority of cases\nexcept for Parallel Routes as it will end up finding the wrong bundle\npath. That is fundamentally related to the implementation of parallel\nroutes and where the bundles are created (under the specific parallel\nroute name). This will need a larger refactor to fix but that doesn't\nhave to block landing the fast path for all other cases.",
    "sha": "8e93b202e0ef7d3215f1a6b9a7b253bc611ebed0",
    "files": [
        {
            "sha": "c1bf52279e8f6cb402592f8dc4be5f704dd805cc",
            "filename": "packages/next/src/server/base-server.ts",
            "status": "modified",
            "additions": 23,
            "deletions": 4,
            "changes": 27,
            "blob_url": "https://github.com/vercel/next.js/blob/8e93b202e0ef7d3215f1a6b9a7b253bc611ebed0/packages%2Fnext%2Fsrc%2Fserver%2Fbase-server.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/8e93b202e0ef7d3215f1a6b9a7b253bc611ebed0/packages%2Fnext%2Fsrc%2Fserver%2Fbase-server.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fbase-server.ts?ref=8e93b202e0ef7d3215f1a6b9a7b253bc611ebed0",
            "patch": "@@ -2558,11 +2558,30 @@ export default abstract class Server<\n       i18n: this.i18nProvider?.fromRequest(req, pathname),\n     }\n \n+    const existingMatch = getRequestMeta(ctx.req, 'match')\n+\n+    let fastPath = true\n+    // when a specific invoke-output is meant to be matched\n+    // ensure a prior dynamic route/page doesn't take priority\n+    const invokeOutput = getRequestMeta(ctx.req, 'invokeOutput')\n+\n+    if (\n+      (!this.minimalMode &&\n+        typeof invokeOutput === 'string' &&\n+        isDynamicRoute(invokeOutput || '') &&\n+        invokeOutput !== existingMatch?.definition.pathname) ||\n+      // Parallel routes are matched in `existingMatch` but since currently\n+      // there can be multiple matches it's not guaranteed to be the right match\n+      // therefor we need to opt-out of the fast path for parallel routes.\n+      existingMatch?.definition.page.includes('/@')\n+    ) {\n+      fastPath = false\n+    }\n+\n     try {\n-      for await (const match of this.matchers.matchAll(pathname, options)) {\n-        // when a specific invoke-output is meant to be matched\n-        // ensure a prior dynamic route/page doesn't take priority\n-        const invokeOutput = getRequestMeta(ctx.req, 'invokeOutput')\n+      for await (const match of fastPath && existingMatch\n+        ? [existingMatch]\n+        : this.matchers.matchAll(pathname, options)) {\n         if (\n           !this.minimalMode &&\n           typeof invokeOutput === 'string' &&"
        }
    ],
    "stats": {
        "total": 27,
        "additions": 23,
        "deletions": 4
    }
}