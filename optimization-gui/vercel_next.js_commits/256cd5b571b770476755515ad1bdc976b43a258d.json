{
    "author": "ijjk",
    "message": "Add response handling inside handlers (#80189)\n\nThis continues the `handler` signature work from\nhttps://github.com/vercel/next.js/pull/78166 and moves the\ncache/response handling work inside of the pages, app pages, and app route handlers which allows them\nto be fully invoked independent of `next-server`/`router-server`.\n\nValidated against our deploy tests\nhttps://github.com/vercel/vercel/actions/runs/15583209888/job/43883202911?pr=13433\nand\nhttps://github.com/vercel/next.js/actions/runs/15583265934/job/43883389321",
    "sha": "256cd5b571b770476755515ad1bdc976b43a258d",
    "files": [
        {
            "sha": "00830369fff6f4c8cf14b98d1546ed157e6bba7e",
            "filename": "packages/next/errors.json",
            "status": "modified",
            "additions": 13,
            "deletions": 5,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/256cd5b571b770476755515ad1bdc976b43a258d/packages%2Fnext%2Ferrors.json",
            "raw_url": "https://github.com/vercel/next.js/raw/256cd5b571b770476755515ad1bdc976b43a258d/packages%2Fnext%2Ferrors.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Ferrors.json?ref=256cd5b571b770476755515ad1bdc976b43a258d",
            "patch": "@@ -693,10 +693,18 @@\n   \"692\": \"Expected clientReferenceManifest to be defined.\",\n   \"693\": \"%s must not be used within a client component. Next.js should be preventing %s from being included in client components statically, but did not in this case.\",\n   \"694\": \"createPrerenderPathname was called inside a client component scope.\",\n-  \"695\": \"Expected workUnitAsyncStorage to have a store.\",\n-  \"696\": \"Next DevTools: Can't dispatch %s in this environment. This is a bug in Next.js\",\n+  \"695\": \"Invariant: received non-pages cache entry in pages handler\",\n+  \"696\": \"Expected workUnitAsyncStorage to have a store.\",\n   \"697\": \"Next DevTools: Can't render in this environment. This is a bug in Next.js\",\n-  \"698\": \"Next DevTools: App Dev Overlay is already mounted. This is a bug in Next.js\",\n-  \"699\": \"Next DevTools: Pages Dev Overlay is already mounted. This is a bug in Next.js\",\n-  \"700\": \"Failed to persist Chrome DevTools workspace UUID. The Chrome DevTools Workspace needs to be reconnected after the next page reload.\"\n+  \"698\": \"Next DevTools: Can't dispatch %s in this environment. This is a bug in Next.js\",\n+  \"699\": \"Next DevTools: App Dev Overlay is already mounted. This is a bug in Next.js\",\n+  \"700\": \"Next DevTools: Pages Dev Overlay is already mounted. This is a bug in Next.js\",\n+  \"701\": \"Invariant: app-route received invalid cache entry %s\",\n+  \"702\": \"Invariant: unexpected APP_ROUTE cache data\",\n+  \"703\": \"Route is configured with dynamic = error which cannot be statically generated.\",\n+  \"704\": \"Route is configured with dynamic = error be statically generated.\",\n+  \"705\": \"Route is configured with dynamic = error that cannot be statically generated.\",\n+  \"706\": \"Invariant: static responses cannot be streamed %s\",\n+  \"707\": \"Invariant app-page handler received invalid cache entry %s\",\n+  \"708\": \"Failed to persist Chrome DevTools workspace UUID. The Chrome DevTools Workspace needs to be reconnected after the next page reload.\"\n }"
        },
        {
            "sha": "b9cfa9adce1af06bdda5192d780204fb2f7157e4",
            "filename": "packages/next/src/build/templates/app-page.ts",
            "status": "modified",
            "additions": 852,
            "deletions": 193,
            "changes": 1045,
            "blob_url": "https://github.com/vercel/next.js/blob/256cd5b571b770476755515ad1bdc976b43a258d/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fapp-page.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/256cd5b571b770476755515ad1bdc976b43a258d/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fapp-page.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fapp-page.ts?ref=256cd5b571b770476755515ad1bdc976b43a258d",
            "patch": "@@ -1,5 +1,4 @@\n import type { LoaderTree } from '../../server/lib/app-dir-module'\n-import type { ServerOnInstrumentationRequestError } from '../../server/app-render/types'\n import type { IncomingMessage, ServerResponse } from 'node:http'\n \n import {\n@@ -16,7 +15,10 @@ import { BaseServerSpan } from '../../server/lib/trace/constants'\n import { interopDefault } from '../../server/app-render/interop-default'\n import { NodeNextRequest, NodeNextResponse } from '../../server/base-http/node'\n import { checkIsAppPPREnabled } from '../../server/lib/experimental/ppr'\n-import { getFallbackRouteParams } from '../../server/request/fallback-params'\n+import {\n+  getFallbackRouteParams,\n+  type FallbackRouteParams,\n+} from '../../server/request/fallback-params'\n import { setReferenceManifestsSingleton } from '../../server/app-render/encryption-utils'\n import {\n   isHtmlBotRequest,\n@@ -26,13 +28,27 @@ import { createServerModuleMap } from '../../server/app-render/action-utils'\n import { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\n import { getIsPossibleServerAction } from '../../server/lib/server-action-request-meta'\n import {\n-  RouterServerContextSymbol,\n-  routerServerGlobal,\n-} from '../../server/lib/router-utils/router-server-context'\n-import {\n-  NEXT_ROUTER_PREFETCH_HEADER,\n   RSC_HEADER,\n+  NEXT_ROUTER_PREFETCH_HEADER,\n+  NEXT_IS_PRERENDER_HEADER,\n+  NEXT_DID_POSTPONE_HEADER,\n } from '../../client/components/app-router-headers'\n+import { getBotType, isBot } from '../../shared/lib/router/utils/is-bot'\n+import {\n+  CachedRouteKind,\n+  type CachedAppPageValue,\n+  type CachedPageValue,\n+  type ResponseCacheEntry,\n+  type ResponseGenerator,\n+} from '../../server/response-cache'\n+import { decodePathParams } from '../../server/lib/router-utils/decode-path-params'\n+import { FallbackMode, parseFallbackField } from '../../lib/fallback'\n+import RenderResult from '../../server/render-result'\n+import { CACHE_ONE_YEAR, NEXT_CACHE_TAGS_HEADER } from '../../lib/constants'\n+import type { CacheControl } from '../../server/lib/cache-control'\n+import { ENCODED_TAGS } from '../../server/stream-utils/encoded-tags'\n+import { sendRenderResult } from '../../server/send-payload'\n+import { NoFallbackError } from '../../shared/lib/no-fallback-error.external'\n \n // These are injected by the loader afterwards.\n \n@@ -67,7 +83,6 @@ export const __next_app__ = {\n }\n \n import * as entryBase from '../../server/app-render/entry-base' with { 'turbopack-transition': 'next-server-utility' }\n-import { getBotType } from '../../shared/lib/router/utils/is-bot'\n \n export * from '../../server/app-render/entry-base' with { 'turbopack-transition': 'next-server-utility' }\n \n@@ -110,7 +125,9 @@ export async function handler(\n   const multiZoneDraftMode = process.env\n     .__NEXT_MULTI_ZONE_DRAFT_MODE as any as boolean\n \n-  const postponed = getRequestMeta(req, 'postponed')\n+  const initialPostponed = getRequestMeta(req, 'postponed')\n+  // TODO: replace with more specific flags\n+  const minimalMode = getRequestMeta(req, 'minimalMode')\n \n   const prepareResult = await routeModule.prepare(req, res, {\n     srcPage,\n@@ -132,57 +149,71 @@ export async function handler(\n     pageIsDynamic,\n     buildManifest,\n     nextFontManifest,\n-    serverFilesManifest,\n     reactLoadableManifest,\n     serverActionsManifest,\n     clientReferenceManifest,\n     subresourceIntegrityManifest,\n     prerenderManifest,\n     isDraftMode,\n-    isOnDemandRevalidate,\n+\n+    revalidateOnlyGenerated,\n+    routerServerContext,\n+    nextConfig,\n   } = prepareResult\n \n-  const routerServerContext =\n-    routerServerGlobal[RouterServerContextSymbol]?.[\n-      process.env.__NEXT_RELATIVE_PROJECT_DIR || ''\n-    ]\n-\n-  const onInstrumentationRequestError =\n-    routeModule.instrumentationOnRequestError.bind(routeModule)\n-\n-  const onError: ServerOnInstrumentationRequestError = (\n-    err,\n-    _,\n-    errorContext\n-  ) => {\n-    if (routerServerContext?.logErrorWithOriginalStack) {\n-      routerServerContext.logErrorWithOriginalStack(err, 'app-dir')\n-    } else {\n-      console.error(err)\n-    }\n-    return onInstrumentationRequestError(\n-      req,\n-      err,\n-      {\n-        path: req.url || '/',\n-        headers: req.headers,\n-        method: req.method || 'GET',\n-      },\n-      errorContext\n-    )\n+  const pathname = parsedUrl.pathname || '/'\n+  const normalizedSrcPage = normalizeAppPath(srcPage)\n+\n+  let { isOnDemandRevalidate } = prepareResult\n+\n+  // TODO: rework this to not be necessary as a middleware\n+  // rewrite should not need to pass this context like this\n+  // maybe we rely on rewrite header instead\n+  let resolvedPathname = getRequestMeta(req, 'rewroteURL') || pathname\n+\n+  if (resolvedPathname === '/index') {\n+    resolvedPathname = '/'\n   }\n+  resolvedPathname = decodePathParams(resolvedPathname)\n \n-  const nextConfig =\n-    routerServerContext?.nextConfig || serverFilesManifest.config\n+  const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage]\n+  const isPrerendered = prerenderManifest.routes[resolvedPathname]\n \n-  const pathname = parsedUrl.pathname || '/'\n-  const normalizedSrcPage = normalizeAppPath(srcPage)\n-  let isIsr = Boolean(\n-    prerenderManifest.dynamicRoutes[normalizedSrcPage] ||\n-      prerenderManifest.routes[normalizedSrcPage] ||\n-      prerenderManifest.routes[pathname]\n+  let isSSG = Boolean(\n+    prerenderInfo ||\n+      isPrerendered ||\n+      prerenderManifest.routes[normalizedSrcPage]\n   )\n \n+  // if the page is dynamicParams: false and this pathname wasn't prerender\n+  // trigger the no fallback handling\n+  if (isSSG && prerenderInfo?.fallback === false && !isPrerendered) {\n+    throw new NoFallbackError()\n+  }\n+\n+  const userAgent = req.headers['user-agent'] || ''\n+  const botType = getBotType(userAgent)\n+  const isHtmlBot = isHtmlBotRequest(req)\n+\n+  /**\n+   * If true, this indicates that the request being made is for an app\n+   * prefetch request.\n+   */\n+  const isPrefetchRSCRequest =\n+    getRequestMeta(req, 'isPrefetchRSCRequest') ??\n+    Boolean(req.headers[NEXT_ROUTER_PREFETCH_HEADER])\n+\n+  // NOTE: Don't delete headers[RSC] yet, it still needs to be used in renderToHTML later\n+\n+  const isRSCRequest =\n+    getRequestMeta(req, 'isRSCRequest') ?? Boolean(req.headers[RSC_HEADER])\n+\n+  const isPossibleServerAction = getIsPossibleServerAction(req)\n+\n+  /**\n+   * If the route being rendered is an app page, and the ppr feature has been\n+   * enabled, then the given route _could_ support PPR.\n+   */\n   const couldSupportPPR: boolean = checkIsAppPPREnabled(\n     nextConfig.experimental.ppr\n   )\n@@ -201,22 +232,19 @@ export async function handler(\n \n   // This page supports PPR if it is marked as being `PARTIALLY_STATIC` in the\n   // prerender manifest and this is an app page.\n-  const isRoutePPREnabled = Boolean(\n+  const isRoutePPREnabled: boolean =\n     couldSupportPPR &&\n-      ((\n-        prerenderManifest.routes[normalizedSrcPage] ??\n-        prerenderManifest.routes[pathname] ??\n-        prerenderManifest.dynamicRoutes[normalizedSrcPage]\n-      )?.renderingMode === 'PARTIALLY_STATIC' ||\n-        // Ideally we'd want to check the appConfig to see if this page has PPR\n-        // enabled or not, but that would require plumbing the appConfig through\n-        // to the server during development. We assume that the page supports it\n-        // but only during development.\n-        (hasDebugStaticShellQuery &&\n-          (routeModule.isDev || routerServerContext?.experimentalTestProxy)))\n-  )\n-\n-  const isDebugFallbackShell = hasDebugFallbackShellQuery && isRoutePPREnabled\n+    ((\n+      prerenderManifest.routes[normalizedSrcPage] ??\n+      prerenderManifest.dynamicRoutes[normalizedSrcPage]\n+    )?.renderingMode === 'PARTIALLY_STATIC' ||\n+      // Ideally we'd want to check the appConfig to see if this page has PPR\n+      // enabled or not, but that would require plumbing the appConfig through\n+      // to the server during development. We assume that the page supports it\n+      // but only during development.\n+      (hasDebugStaticShellQuery &&\n+        (routeModule.isDev === true ||\n+          routerServerContext?.experimentalTestProxy === true)))\n \n   const isDebugStaticShell: boolean =\n     hasDebugStaticShellQuery && isRoutePPREnabled\n@@ -226,23 +254,67 @@ export async function handler(\n   const isDebugDynamicAccesses =\n     isDebugStaticShell && routeModule.isDev === true\n \n-  const isRSCRequest =\n-    getRequestMeta(req, 'isRSCRequest') || Boolean(req.headers[RSC_HEADER])\n+  const isDebugFallbackShell = hasDebugFallbackShellQuery && isRoutePPREnabled\n \n-  const userAgent = req.headers['user-agent'] || ''\n-  const botType = getBotType(userAgent)\n-  const isHtmlBot = isHtmlBotRequest(req)\n+  // If we're in minimal mode, then try to get the postponed information from\n+  // the request metadata. If available, use it for resuming the postponed\n+  // render.\n+  const minimalPostponed = isRoutePPREnabled ? initialPostponed : undefined\n+\n+  // If PPR is enabled, and this is a RSC request (but not a prefetch), then\n+  // we can use this fact to only generate the flight data for the request\n+  // because we can't cache the HTML (as it's also dynamic).\n+  const isDynamicRSCRequest =\n+    isRoutePPREnabled && isRSCRequest && !isPrefetchRSCRequest\n+\n+  // Need to read this before it's stripped by stripFlightHeaders. We don't\n+  // need to transfer it to the request meta because it's only read\n+  // within this function; the static segment data should have already been\n+  // generated, so we will always either return a static response or a 404.\n+  const segmentPrefetchHeader = getRequestMeta(req, 'segmentPrefetchRSCRequest')\n+\n+  // TODO: investigate existing bug with shouldServeStreamingMetadata always\n+  // being true for a revalidate due to modifying the base-server this.renderOpts\n+  // when fixing this to correct logic it causes hydration issue since we set\n+  // serveStreamingMetadata to true during export\n+  let serveStreamingMetadata = !userAgent\n+    ? true\n+    : shouldServeStreamingMetadata(userAgent, nextConfig.htmlLimitedBots)\n+\n+  if (isHtmlBot && isRoutePPREnabled) {\n+    isSSG = false\n+    serveStreamingMetadata = false\n+  }\n+\n+  // In development, we always want to generate dynamic HTML.\n+  let supportsDynamicResponse: boolean =\n+    // If we're in development, we always support dynamic HTML, unless it's\n+    // a data request, in which case we only produce static HTML.\n+    routeModule.isDev === true ||\n+    // If this is not SSG or does not have static paths, then it supports\n+    // dynamic HTML.\n+    !isSSG ||\n+    // If this request has provided postponed data, it supports dynamic\n+    // HTML.\n+    typeof initialPostponed === 'string' ||\n+    // If this is a dynamic RSC request, then this render supports dynamic\n+    // HTML (it's dynamic).\n+    isDynamicRSCRequest\n+\n+  // When html bots request PPR page, perform the full dynamic rendering.\n   const shouldWaitOnAllReady = isHtmlBot && isRoutePPREnabled\n \n-  // If this is a dynamic route with PPR enabled and the default route\n-  // matches were set, then we should pass the fallback route params to\n-  // the renderer as this is a fallback revalidation request.\n-  const fallbackRouteParams =\n-    pageIsDynamic &&\n-    isRoutePPREnabled &&\n-    (getRequestMeta(req, 'renderFallbackShell') || isDebugFallbackShell)\n-      ? getFallbackRouteParams(normalizedSrcPage)\n-      : null\n+  let ssgCacheKey: string | null = null\n+  if (\n+    !isDraftMode &&\n+    isSSG &&\n+    !supportsDynamicResponse &&\n+    !isPossibleServerAction &&\n+    !minimalPostponed &&\n+    !isDynamicRSCRequest\n+  ) {\n+    ssgCacheKey = resolvedPathname\n+  }\n \n   const ComponentMod = {\n     ...entryBase,\n@@ -268,66 +340,97 @@ export async function handler(\n     })\n   }\n \n-  const isPossibleServerAction = getIsPossibleServerAction(req)\n+  const method = req.method || 'GET'\n+  const tracer = getTracer()\n+  const activeSpan = tracer.getActiveScopeSpan()\n \n-  /**\n-   * If true, this indicates that the request being made is for an app\n-   * prefetch request.\n-   */\n-  const isPrefetchRSCRequest =\n-    getRequestMeta(req, 'isPrefetchRSCRequest') ??\n-    Boolean(isRSCRequest && req.headers[NEXT_ROUTER_PREFETCH_HEADER])\n+  try {\n+    const invokeRouteModule = async (\n+      span: Span | undefined,\n+      context: AppPageRouteHandlerContext\n+    ) => {\n+      const nextReq = new NodeNextRequest(req)\n+      const nextRes = new NodeNextResponse(res)\n \n-  // If PPR is enabled, and this is a RSC request (but not a prefetch), then\n-  // we can use this fact to only generate the flight data for the request\n-  // because we can't cache the HTML (as it's also dynamic).\n-  const isDynamicRSCRequest =\n-    isRoutePPREnabled && isRSCRequest && !isPrefetchRSCRequest\n+      // TODO: adapt for putting the RDC inside the postponed data\n+      // If we're in dev, and this isn't a prefetch or a server action,\n+      // we should seed the resume data cache.\n+      if (process.env.NODE_ENV === 'development') {\n+        if (\n+          nextConfig.experimental.dynamicIO &&\n+          !isPrefetchRSCRequest &&\n+          !context.renderOpts.isPossibleServerAction\n+        ) {\n+          const warmup = await routeModule.warmup(nextReq, nextRes, context)\n \n-  let supportsDynamicResponse: boolean =\n-    // If we're in development, we always support dynamic HTML\n-    routeModule.isDev === true ||\n-    // If this is not SSG or does not have static paths, then it supports\n-    // dynamic HTML.\n-    !isIsr ||\n-    // If this request has provided postponed data, it supports dynamic\n-    // HTML.\n-    typeof postponed === 'string' ||\n-    // If this is a dynamic RSC request, then this render supports dynamic\n-    // HTML (it's dynamic).\n-    isDynamicRSCRequest\n+          // If the warmup is successful, we should use the resume data\n+          // cache from the warmup.\n+          if (warmup.metadata.devRenderResumeDataCache) {\n+            context.renderOpts.devRenderResumeDataCache =\n+              warmup.metadata.devRenderResumeDataCache\n+          }\n+        }\n+      }\n \n-  // This is a revalidation request if the request is for a static\n-  // page and it is not being resumed from a postponed render and\n-  // it is not a dynamic RSC request then it is a revalidation\n-  // request.\n-  const isRevalidate =\n-    isIsr && !supportsDynamicResponse && !postponed && !isDynamicRSCRequest\n-\n-  let serveStreamingMetadata =\n-    // During the export phase of `next build` we're hard-coding\n-    // `serveStreamingMetadata` to `true`, so we need to do the same during\n-    // revalidation.\n-    isRevalidate ||\n-    // Otherwise we're checking the user agent to decide if we should\n-    // serve streaming metadata.\n-    shouldServeStreamingMetadata(\n-      userAgent,\n-      // @ts-expect-error update for readonly\n-      nextConfig.htmlLimitedBots\n-    )\n+      return routeModule.render(nextReq, nextRes, context).finally(() => {\n+        if (!span) return\n \n-  if (isHtmlBot && isRoutePPREnabled) {\n-    isIsr = false\n-    serveStreamingMetadata = false\n-  }\n+        span.setAttributes({\n+          'http.status_code': res.statusCode,\n+          'next.rsc': false,\n+        })\n \n-  const method = req.method || 'GET'\n-  const tracer = getTracer()\n-  const activeSpan = tracer.getActiveScopeSpan()\n+        const rootSpanAttributes = tracer.getRootSpanAttributes()\n+        // We were unable to get attributes, probably OTEL is not enabled\n+        if (!rootSpanAttributes) {\n+          return\n+        }\n \n-  try {\n-    const invokeRouteModule = async (span?: Span) => {\n+        if (\n+          rootSpanAttributes.get('next.span_type') !==\n+          BaseServerSpan.handleRequest\n+        ) {\n+          console.warn(\n+            `Unexpected root span type '${rootSpanAttributes.get(\n+              'next.span_type'\n+            )}'. Please report this Next.js issue https://github.com/vercel/next.js`\n+          )\n+          return\n+        }\n+\n+        const route = rootSpanAttributes.get('next.route')\n+        if (route) {\n+          const name = `${method} ${route}`\n+\n+          span.setAttributes({\n+            'next.route': route,\n+            'http.route': route,\n+            'next.span_name': name,\n+          })\n+          span.updateName(name)\n+        } else {\n+          span.updateName(`${method} ${req.url}`)\n+        }\n+      })\n+    }\n+\n+    const doRender = async ({\n+      span,\n+      postponed,\n+      fallbackRouteParams,\n+    }: {\n+      span?: Span\n+      /**\n+       * The postponed data for this render. This is only provided when resuming\n+       * a render that has been postponed.\n+       */\n+      postponed: string | undefined\n+\n+      /**\n+       * The unknown route params for this render.\n+       */\n+      fallbackRouteParams: FallbackRouteParams | null\n+    }): Promise<ResponseCacheEntry> => {\n       const context: AppPageRouteHandlerContext = {\n         query,\n         params,\n@@ -353,29 +456,29 @@ export async function handler(\n           postponed,\n           shouldWaitOnAllReady,\n           serveStreamingMetadata,\n-          supportsDynamicResponse,\n+          supportsDynamicResponse:\n+            typeof postponed === 'string' || supportsDynamicResponse,\n           buildManifest,\n           nextFontManifest,\n           reactLoadableManifest,\n           subresourceIntegrityManifest,\n           serverActionsManifest,\n           clientReferenceManifest,\n-          isPossibleServerAction,\n-          isOnDemandRevalidate,\n           setIsrStatus: routerServerContext?.setIsrStatus,\n \n           dir: routeModule.projectDir,\n           isDraftMode,\n-          isRevalidate,\n+          isRevalidate: isSSG && !postponed && !isDynamicRSCRequest,\n           botType,\n+          isOnDemandRevalidate,\n+          isPossibleServerAction,\n           assetPrefix: nextConfig.assetPrefix,\n           nextConfigOutput: nextConfig.output,\n           crossOrigin: nextConfig.crossOrigin,\n           trailingSlash: nextConfig.trailingSlash,\n           previewProps: prerenderManifest.preview,\n           deploymentId: nextConfig.deploymentId,\n           enableTainting: nextConfig.experimental.taint,\n-          // @ts-expect-error fix issue with readonly regex object type\n           htmlLimitedBots: nextConfig.htmlLimitedBots,\n           devtoolSegmentExplorer:\n             nextConfig.experimental.devtoolSegmentExplorer,\n@@ -385,7 +488,6 @@ export async function handler(\n           incrementalCache: getRequestMeta(req, 'incrementalCache'),\n           cacheLifeProfiles: nextConfig.experimental.cacheLife,\n           basePath: nextConfig.basePath,\n-          // @ts-expect-error fix issue with readonly regex object type\n           serverActions: nextConfig.experimental.serverActions,\n \n           ...(isDebugStaticShell || isDebugDynamicAccesses\n@@ -419,80 +521,632 @@ export async function handler(\n           },\n           onAfterTaskError: () => {},\n \n-          onInstrumentationRequestError: onError,\n+          onInstrumentationRequestError: (error, _request, errorContext) =>\n+            routeModule.onRequestError(\n+              req,\n+              error,\n+              errorContext,\n+              routerServerContext\n+            ),\n           err: getRequestMeta(req, 'invokeError'),\n           dev: routeModule.isDev,\n         },\n       }\n-      const nextReq = new NodeNextRequest(req)\n-      const nextRes = new NodeNextResponse(res)\n \n-      // TODO: adapt for putting the RDC inside the postponed data\n-      // If we're in dev, and this isn't a prefetch or a server action,\n-      // we should seed the resume data cache.\n-      if (process.env.NODE_ENV === 'development') {\n-        if (\n-          nextConfig.experimental.dynamicIO &&\n-          !isPrefetchRSCRequest &&\n-          !isPossibleServerAction\n-        ) {\n-          const warmup = await routeModule.warmup(nextReq, nextRes, context)\n+      const result = await invokeRouteModule(span, context)\n \n-          // If the warmup is successful, we should use the resume data\n-          // cache from the warmup.\n-          if (warmup.metadata.devRenderResumeDataCache) {\n-            context.renderOpts.devRenderResumeDataCache =\n-              warmup.metadata.devRenderResumeDataCache\n+      const { metadata } = result\n+\n+      const {\n+        cacheControl,\n+        headers = {},\n+        // Add any fetch tags that were on the page to the response headers.\n+        fetchTags: cacheTags,\n+      } = metadata\n+\n+      if (cacheTags) {\n+        headers[NEXT_CACHE_TAGS_HEADER] = cacheTags\n+      }\n+\n+      // Pull any fetch metrics from the render onto the request.\n+      ;(req as any).fetchMetrics = metadata.fetchMetrics\n+\n+      // we don't throw static to dynamic errors in dev as isSSG\n+      // is a best guess in dev since we don't have the prerender pass\n+      // to know whether the path is actually static or not\n+      if (\n+        isSSG &&\n+        cacheControl?.revalidate === 0 &&\n+        !routeModule.isDev &&\n+        !isRoutePPREnabled\n+      ) {\n+        const staticBailoutInfo = metadata.staticBailoutInfo\n+\n+        const err = new Error(\n+          `Page changed from static to dynamic at runtime ${resolvedPathname}${\n+            staticBailoutInfo?.description\n+              ? `, reason: ${staticBailoutInfo.description}`\n+              : ``\n+          }` +\n+            `\\nsee more here https://nextjs.org/docs/messages/app-static-to-dynamic-error`\n+        )\n+\n+        if (staticBailoutInfo?.stack) {\n+          const stack = staticBailoutInfo.stack\n+          err.stack = err.message + stack.substring(stack.indexOf('\\n'))\n+        }\n+\n+        throw err\n+      }\n+\n+      return {\n+        value: {\n+          kind: CachedRouteKind.APP_PAGE,\n+          html: result,\n+          headers,\n+          rscData: metadata.flightData,\n+          postponed: metadata.postponed,\n+          status: metadata.statusCode,\n+          segmentData: metadata.segmentData,\n+        } satisfies CachedAppPageValue,\n+        cacheControl,\n+      } satisfies ResponseCacheEntry\n+    }\n+\n+    const responseGenerator: ResponseGenerator = async ({\n+      hasResolved,\n+      previousCacheEntry,\n+      isRevalidating,\n+      span,\n+    }) => {\n+      const isProduction = routeModule.isDev === false\n+      const didRespond = hasResolved || res.writableEnded\n+\n+      // skip on-demand revalidate if cache is not present and\n+      // revalidate-if-generated is set\n+      if (\n+        isOnDemandRevalidate &&\n+        revalidateOnlyGenerated &&\n+        !previousCacheEntry &&\n+        !minimalMode\n+      ) {\n+        if (routerServerContext?.render404) {\n+          await routerServerContext.render404(req, res)\n+        } else {\n+          res.statusCode = 404\n+          res.end('This page could not be found')\n+        }\n+        return null\n+      }\n+\n+      let fallbackMode: FallbackMode | undefined\n+\n+      if (prerenderInfo) {\n+        fallbackMode = parseFallbackField(prerenderInfo.fallback)\n+      }\n+\n+      // When serving a bot request, we want to serve a blocking render and not\n+      // the prerendered page. This ensures that the correct content is served\n+      // to the bot in the head.\n+      if (fallbackMode === FallbackMode.PRERENDER && isBot(userAgent)) {\n+        fallbackMode = FallbackMode.BLOCKING_STATIC_RENDER\n+      }\n+\n+      if (previousCacheEntry?.isStale === -1) {\n+        isOnDemandRevalidate = true\n+      }\n+\n+      // TODO: adapt for PPR\n+      // only allow on-demand revalidate for fallback: true/blocking\n+      // or for prerendered fallback: false paths\n+      if (\n+        isOnDemandRevalidate &&\n+        (fallbackMode !== FallbackMode.NOT_FOUND || previousCacheEntry)\n+      ) {\n+        fallbackMode = FallbackMode.BLOCKING_STATIC_RENDER\n+      }\n+\n+      if (\n+        !minimalMode &&\n+        fallbackMode !== FallbackMode.BLOCKING_STATIC_RENDER &&\n+        ssgCacheKey &&\n+        !didRespond &&\n+        !isDraftMode &&\n+        pageIsDynamic &&\n+        (isProduction || !isPrerendered)\n+      ) {\n+        let fallbackResponse: ResponseCacheEntry | null | undefined\n+\n+        if (isRoutePPREnabled && !isRSCRequest) {\n+          // We use the response cache here to handle the revalidation and\n+          // management of the fallback shell.\n+          fallbackResponse = await routeModule.handleResponse({\n+            cacheKey: isProduction ? normalizedSrcPage : null,\n+            req,\n+            nextConfig,\n+            routeKind: RouteKind.APP_PAGE,\n+            isFallback: true,\n+            prerenderManifest,\n+            isRoutePPREnabled,\n+            responseGenerator: async () =>\n+              doRender({\n+                span,\n+                // We pass `undefined` as rendering a fallback isn't resumed\n+                // here.\n+                postponed: undefined,\n+                fallbackRouteParams:\n+                  // If we're in production or we're debugging the fallback\n+                  // shell then we should postpone when dynamic params are\n+                  // accessed.\n+                  isProduction || isDebugFallbackShell\n+                    ? getFallbackRouteParams(normalizedSrcPage)\n+                    : null,\n+              }),\n+            waitUntil: ctx.waitUntil,\n+          })\n+\n+          // If the fallback response was set to null, then we should return null.\n+          if (fallbackResponse === null) return null\n+\n+          // Otherwise, if we did get a fallback response, we should return it.\n+          if (fallbackResponse) {\n+            // Remove the cache control from the response to prevent it from being\n+            // used in the surrounding cache.\n+            delete fallbackResponse.cacheControl\n+\n+            return fallbackResponse\n           }\n         }\n       }\n+      // Only requests that aren't revalidating can be resumed. If we have the\n+      // minimal postponed data, then we should resume the render with it.\n+      const postponed =\n+        !isOnDemandRevalidate && !isRevalidating && minimalPostponed\n+          ? minimalPostponed\n+          : undefined\n+\n+      // When we're in minimal mode, if we're trying to debug the static shell,\n+      // we should just return nothing instead of resuming the dynamic render.\n+      if (\n+        (isDebugStaticShell || isDebugDynamicAccesses) &&\n+        typeof postponed !== 'undefined'\n+      ) {\n+        return {\n+          cacheControl: { revalidate: 1, expire: undefined },\n+          value: {\n+            kind: CachedRouteKind.PAGES,\n+            html: RenderResult.fromStatic(''),\n+            pageData: {},\n+            headers: undefined,\n+            status: undefined,\n+          } satisfies CachedPageValue,\n+        }\n+      }\n \n-      return routeModule.render(nextReq, nextRes, context).finally(() => {\n-        if (!span) return\n+      // If this is a dynamic route with PPR enabled and the default route\n+      // matches were set, then we should pass the fallback route params to\n+      // the renderer as this is a fallback revalidation request.\n+      const fallbackRouteParams =\n+        pageIsDynamic &&\n+        isRoutePPREnabled &&\n+        (getRequestMeta(req, 'renderFallbackShell') || isDebugFallbackShell)\n+          ? getFallbackRouteParams(pathname)\n+          : null\n+\n+      // Perform the render.\n+      return doRender({\n+        span,\n+        postponed,\n+        fallbackRouteParams,\n+      })\n+    }\n \n-        span.setAttributes({\n-          'http.status_code': res.statusCode,\n-          'next.rsc': false,\n-        })\n+    const handleResponse = async (span?: Span): Promise<null | void> => {\n+      const cacheEntry = await routeModule.handleResponse({\n+        cacheKey: ssgCacheKey,\n+        responseGenerator: (c) =>\n+          responseGenerator({\n+            span,\n+            ...c,\n+          }),\n+        routeKind: RouteKind.APP_PAGE,\n+        isOnDemandRevalidate,\n+        isRoutePPREnabled,\n+        req,\n+        nextConfig,\n+        prerenderManifest,\n+        waitUntil: ctx.waitUntil,\n+      })\n \n-        const rootSpanAttributes = tracer.getRootSpanAttributes()\n-        // We were unable to get attributes, probably OTEL is not enabled\n-        if (!rootSpanAttributes) {\n-          return\n+      if (isDraftMode) {\n+        res.setHeader(\n+          'Cache-Control',\n+          'private, no-cache, no-store, max-age=0, must-revalidate'\n+        )\n+      }\n+\n+      // In dev, we should not cache pages for any reason.\n+      if (routeModule.isDev) {\n+        res.setHeader('Cache-Control', 'no-store, must-revalidate')\n+      }\n+\n+      if (!cacheEntry) {\n+        if (ssgCacheKey) {\n+          // A cache entry might not be generated if a response is written\n+          // in `getInitialProps` or `getServerSideProps`, but those shouldn't\n+          // have a cache key. If we do have a cache key but we don't end up\n+          // with a cache entry, then either Next.js or the application has a\n+          // bug that needs fixing.\n+          throw new Error('invariant: cache entry required but not generated')\n         }\n+        return null\n+      }\n \n-        if (\n-          rootSpanAttributes.get('next.span_type') !==\n-          BaseServerSpan.handleRequest\n-        ) {\n-          console.warn(\n-            `Unexpected root span type '${rootSpanAttributes.get(\n-              'next.span_type'\n-            )}'. Please report this Next.js issue https://github.com/vercel/next.js`\n+      if (cacheEntry.value?.kind !== CachedRouteKind.APP_PAGE) {\n+        throw new Error(\n+          `Invariant app-page handler received invalid cache entry ${cacheEntry.value?.kind}`\n+        )\n+      }\n+\n+      const didPostpone = typeof cacheEntry.value.postponed === 'string'\n+\n+      if (\n+        isSSG &&\n+        // We don't want to send a cache header for requests that contain dynamic\n+        // data. If this is a Dynamic RSC request or wasn't a Prefetch RSC\n+        // request, then we should set the cache header.\n+        !isDynamicRSCRequest &&\n+        (!didPostpone || isPrefetchRSCRequest)\n+      ) {\n+        if (!minimalMode) {\n+          // set x-nextjs-cache header to match the header\n+          // we set for the image-optimizer\n+          res.setHeader(\n+            'x-nextjs-cache',\n+            isOnDemandRevalidate\n+              ? 'REVALIDATED'\n+              : cacheEntry.isMiss\n+                ? 'MISS'\n+                : cacheEntry.isStale\n+                  ? 'STALE'\n+                  : 'HIT'\n           )\n-          return\n         }\n+        // Set a header used by the client router to signal the response is static\n+        // and should respect the `static` cache staleTime value.\n+        res.setHeader(NEXT_IS_PRERENDER_HEADER, '1')\n+      }\n+      const { value: cachedData } = cacheEntry\n \n-        const route = rootSpanAttributes.get('next.route')\n-        if (route) {\n-          const name = `${method} ${route}`\n+      // Coerce the cache control parameter from the render.\n+      let cacheControl: CacheControl | undefined\n \n-          span.setAttributes({\n-            'next.route': route,\n-            'http.route': route,\n-            'next.span_name': name,\n+      // If this is a resume request in minimal mode it is streamed with dynamic\n+      // content and should not be cached.\n+      if (minimalPostponed) {\n+        cacheControl = { revalidate: 0, expire: undefined }\n+      }\n+\n+      // If this is in minimal mode and this is a flight request that isn't a\n+      // prefetch request while PPR is enabled, it cannot be cached as it contains\n+      // dynamic content.\n+      else if (\n+        minimalMode &&\n+        isRSCRequest &&\n+        !isPrefetchRSCRequest &&\n+        isRoutePPREnabled\n+      ) {\n+        cacheControl = { revalidate: 0, expire: undefined }\n+      } else if (!routeModule.isDev) {\n+        // If this is a preview mode request, we shouldn't cache it\n+        if (isDraftMode) {\n+          cacheControl = { revalidate: 0, expire: undefined }\n+        }\n+\n+        // If this isn't SSG, then we should set change the header only if it is\n+        // not set already.\n+        else if (!isSSG) {\n+          if (!res.getHeader('Cache-Control')) {\n+            cacheControl = { revalidate: 0, expire: undefined }\n+          }\n+        } else if (cacheEntry.cacheControl) {\n+          // If the cache entry has a cache control with a revalidate value that's\n+          // a number, use it.\n+          if (typeof cacheEntry.cacheControl.revalidate === 'number') {\n+            if (cacheEntry.cacheControl.revalidate < 1) {\n+              throw new Error(\n+                `Invalid revalidate configuration provided: ${cacheEntry.cacheControl.revalidate} < 1`\n+              )\n+            }\n+\n+            cacheControl = {\n+              revalidate: cacheEntry.cacheControl.revalidate,\n+              expire: cacheEntry.cacheControl?.expire ?? nextConfig.expireTime,\n+            }\n+          }\n+          // Otherwise if the revalidate value is false, then we should use the\n+          // cache time of one year.\n+          else {\n+            cacheControl = { revalidate: CACHE_ONE_YEAR, expire: undefined }\n+          }\n+        }\n+      }\n+\n+      cacheEntry.cacheControl = cacheControl\n+\n+      if (\n+        typeof segmentPrefetchHeader === 'string' &&\n+        cachedData?.kind === CachedRouteKind.APP_PAGE &&\n+        cachedData.segmentData\n+      ) {\n+        // This is a prefetch request issued by the client Segment Cache. These\n+        // should never reach the application layer (lambda). We should either\n+        // respond from the cache (HIT) or respond with 204 No Content (MISS).\n+\n+        // Set a header to indicate that PPR is enabled for this route. This\n+        // lets the client distinguish between a regular cache miss and a cache\n+        // miss due to PPR being disabled. In other contexts this header is used\n+        // to indicate that the response contains dynamic data, but here we're\n+        // only using it to indicate that the feature is enabled â€” the segment\n+        // response itself contains whether the data is dynamic.\n+        res.setHeader(NEXT_DID_POSTPONE_HEADER, '2')\n+\n+        // Add the cache tags header to the response if it exists and we're in\n+        // minimal mode while rendering a static page.\n+        const tags = cachedData.headers?.[NEXT_CACHE_TAGS_HEADER]\n+        if (minimalMode && isSSG && tags && typeof tags === 'string') {\n+          res.setHeader(NEXT_CACHE_TAGS_HEADER, tags)\n+        }\n+\n+        const matchedSegment = cachedData.segmentData.get(segmentPrefetchHeader)\n+        if (matchedSegment !== undefined) {\n+          // Cache hit\n+          return sendRenderResult({\n+            req,\n+            res,\n+            type: 'rsc',\n+            generateEtags: nextConfig.generateEtags,\n+            poweredByHeader: nextConfig.poweredByHeader,\n+            result: RenderResult.fromStatic(matchedSegment),\n+            cacheControl: cacheEntry.cacheControl,\n+          })\n+        }\n+\n+        // Cache miss. Either a cache entry for this route has not been generated\n+        // (which technically should not be possible when PPR is enabled, because\n+        // at a minimum there should always be a fallback entry) or there's no\n+        // match for the requested segment. Respond with a 204 No Content. We\n+        // don't bother to respond with 404, because these requests are only\n+        // issued as part of a prefetch.\n+        res.statusCode = 204\n+        return sendRenderResult({\n+          req,\n+          res,\n+          type: 'rsc',\n+          generateEtags: nextConfig.generateEtags,\n+          poweredByHeader: nextConfig.poweredByHeader,\n+          result: RenderResult.fromStatic(''),\n+          cacheControl: cacheEntry.cacheControl,\n+        })\n+      }\n+\n+      // If there's a callback for `onCacheEntry`, call it with the cache entry\n+      // and the revalidate options.\n+      const onCacheEntry = getRequestMeta(req, 'onCacheEntry')\n+      if (onCacheEntry) {\n+        const finished = await onCacheEntry(\n+          {\n+            ...cacheEntry,\n+            // TODO: remove this when upstream doesn't\n+            // always expect this value to be \"PAGE\"\n+            value: {\n+              ...cacheEntry.value,\n+              kind: 'PAGE',\n+            },\n+          },\n+          {\n+            url: getRequestMeta(req, 'initURL'),\n+          }\n+        )\n+        if (finished) {\n+          // TODO: maybe we have to end the request?\n+          return null\n+        }\n+      }\n+\n+      // If the request has a postponed state and it's a resume request we\n+      // should error.\n+      if (didPostpone && minimalPostponed) {\n+        throw new Error(\n+          'Invariant: postponed state should not be present on a resume request'\n+        )\n+      }\n+\n+      if (cachedData.headers) {\n+        const headers = { ...cachedData.headers }\n+\n+        if (!minimalMode || !isSSG) {\n+          delete headers[NEXT_CACHE_TAGS_HEADER]\n+        }\n+\n+        for (let [key, value] of Object.entries(headers)) {\n+          if (typeof value === 'undefined') continue\n+\n+          if (Array.isArray(value)) {\n+            for (const v of value) {\n+              res.appendHeader(key, v)\n+            }\n+          } else if (typeof value === 'number') {\n+            value = value.toString()\n+            res.appendHeader(key, value)\n+          } else {\n+            res.appendHeader(key, value)\n+          }\n+        }\n+      }\n+\n+      // Add the cache tags header to the response if it exists and we're in\n+      // minimal mode while rendering a static page.\n+      const tags = cachedData.headers?.[NEXT_CACHE_TAGS_HEADER]\n+      if (minimalMode && isSSG && tags && typeof tags === 'string') {\n+        res.setHeader(NEXT_CACHE_TAGS_HEADER, tags)\n+      }\n+\n+      // If the request is a data request, then we shouldn't set the status code\n+      // from the response because it should always be 200. This should be gated\n+      // behind the experimental PPR flag.\n+      if (cachedData.status && (!isRSCRequest || !isRoutePPREnabled)) {\n+        res.statusCode = cachedData.status\n+      }\n+\n+      // Mark that the request did postpone.\n+      if (didPostpone) {\n+        res.setHeader(NEXT_DID_POSTPONE_HEADER, '1')\n+      }\n+\n+      // we don't go through this block when preview mode is true\n+      // as preview mode is a dynamic request (bypasses cache) and doesn't\n+      // generate both HTML and payloads in the same request so continue to just\n+      // return the generated payload\n+      if (isRSCRequest && !isDraftMode) {\n+        // If this is a dynamic RSC request, then stream the response.\n+        if (typeof cachedData.rscData === 'undefined') {\n+          if (cachedData.postponed) {\n+            throw new Error('Invariant: Expected postponed to be undefined')\n+          }\n+\n+          return sendRenderResult({\n+            req,\n+            res,\n+            type: 'rsc',\n+            generateEtags: nextConfig.generateEtags,\n+            poweredByHeader: nextConfig.poweredByHeader,\n+            result: cachedData.html,\n+            // Dynamic RSC responses cannot be cached, even if they're\n+            // configured with `force-static` because we have no way of\n+            // distinguishing between `force-static` and pages that have no\n+            // postponed state.\n+            // TODO: distinguish `force-static` from pages with no postponed state (static)\n+            cacheControl: isDynamicRSCRequest\n+              ? { revalidate: 0, expire: undefined }\n+              : cacheEntry.cacheControl,\n           })\n-          span.updateName(name)\n-        } else {\n-          span.updateName(`${method} ${req.url}`)\n         }\n+\n+        // As this isn't a prefetch request, we should serve the static flight\n+        // data.\n+        return sendRenderResult({\n+          req,\n+          res,\n+          type: 'rsc',\n+          generateEtags: nextConfig.generateEtags,\n+          poweredByHeader: nextConfig.poweredByHeader,\n+          result: RenderResult.fromStatic(cachedData.rscData),\n+          cacheControl: cacheEntry.cacheControl,\n+        })\n+      }\n+\n+      // This is a request for HTML data.\n+      let body = cachedData.html\n+\n+      // If there's no postponed state, we should just serve the HTML. This\n+      // should also be the case for a resume request because it's completed\n+      // as a server render (rather than a static render).\n+      if (!didPostpone || minimalMode) {\n+        return sendRenderResult({\n+          req,\n+          res,\n+          type: 'html',\n+          generateEtags: nextConfig.generateEtags,\n+          poweredByHeader: nextConfig.poweredByHeader,\n+          result: body,\n+          cacheControl: cacheEntry.cacheControl,\n+        })\n+      }\n+\n+      // If we're debugging the static shell or the dynamic API accesses, we\n+      // should just serve the HTML without resuming the render. The returned\n+      // HTML will be the static shell so all the Dynamic API's will be used\n+      // during static generation.\n+      if (isDebugStaticShell || isDebugDynamicAccesses) {\n+        // Since we're not resuming the render, we need to at least add the\n+        // closing body and html tags to create valid HTML.\n+        body.chain(\n+          new ReadableStream({\n+            start(controller) {\n+              controller.enqueue(ENCODED_TAGS.CLOSED.BODY_AND_HTML)\n+              controller.close()\n+            },\n+          })\n+        )\n+\n+        return sendRenderResult({\n+          req,\n+          res,\n+          type: 'html',\n+          generateEtags: nextConfig.generateEtags,\n+          poweredByHeader: nextConfig.poweredByHeader,\n+          result: body,\n+          cacheControl: { revalidate: 0, expire: undefined },\n+        })\n+      }\n+\n+      // This request has postponed, so let's create a new transformer that the\n+      // dynamic data can pipe to that will attach the dynamic data to the end\n+      // of the response.\n+      const transformer = new TransformStream<Uint8Array, Uint8Array>()\n+      body.chain(transformer.readable)\n+\n+      // Perform the render again, but this time, provide the postponed state.\n+      // We don't await because we want the result to start streaming now, and\n+      // we've already chained the transformer's readable to the render result.\n+      doRender({\n+        span,\n+        postponed: cachedData.postponed,\n+        // This is a resume render, not a fallback render, so we don't need to\n+        // set this.\n+        fallbackRouteParams: null,\n+      })\n+        .then(async (result) => {\n+          if (!result) {\n+            throw new Error('Invariant: expected a result to be returned')\n+          }\n+\n+          if (result.value?.kind !== CachedRouteKind.APP_PAGE) {\n+            throw new Error(\n+              `Invariant: expected a page response, got ${result.value?.kind}`\n+            )\n+          }\n+\n+          // Pipe the resume result to the transformer.\n+          await result.value.html.pipeTo(transformer.writable)\n+        })\n+        .catch((err) => {\n+          // An error occurred during piping or preparing the render, abort\n+          // the transformers writer so we can terminate the stream.\n+          transformer.writable.abort(err).catch((e) => {\n+            console.error(\"couldn't abort transformer\", e)\n+          })\n+        })\n+\n+      return sendRenderResult({\n+        req,\n+        res,\n+        type: 'html',\n+        generateEtags: nextConfig.generateEtags,\n+        poweredByHeader: nextConfig.poweredByHeader,\n+        result: body,\n+        // We don't want to cache the response if it has postponed data because\n+        // the response being sent to the client it's dynamic parts are streamed\n+        // to the client on the same request.\n+        cacheControl: { revalidate: 0, expire: undefined },\n       })\n     }\n \n     // TODO: activeSpan code path is for when wrapped by\n     // next-server can be removed when this is no longer used\n     if (activeSpan) {\n-      return await invokeRouteModule(activeSpan)\n+      await handleResponse(activeSpan)\n     } else {\n       return await tracer.withPropagatedContext(req.headers, () =>\n         tracer.trace(\n@@ -505,22 +1159,27 @@ export async function handler(\n               'http.target': req.url,\n             },\n           },\n-          invokeRouteModule\n+          handleResponse\n         )\n       )\n     }\n   } catch (err) {\n     // if we aren't wrapped by base-server handle here\n     if (!activeSpan) {\n-      await onError(err, req, {\n-        routerKind: 'App Router',\n-        routePath: srcPage,\n-        routeType: 'render',\n-        revalidateReason: getRevalidateReason({\n-          isRevalidate,\n-          isOnDemandRevalidate,\n-        }),\n-      })\n+      await routeModule.onRequestError(\n+        req,\n+        err,\n+        {\n+          routerKind: 'App Router',\n+          routePath: srcPage,\n+          routeType: 'render',\n+          revalidateReason: getRevalidateReason({\n+            isRevalidate: isSSG,\n+            isOnDemandRevalidate,\n+          }),\n+        },\n+        routerServerContext\n+      )\n     }\n \n     // rethrow so that we can handle serving error page"
        },
        {
            "sha": "485dd516becea2c1401b2b8370e4298e42903b05",
            "filename": "packages/next/src/build/templates/app-route.ts",
            "status": "modified",
            "additions": 239,
            "deletions": 114,
            "changes": 353,
            "blob_url": "https://github.com/vercel/next.js/blob/256cd5b571b770476755515ad1bdc976b43a258d/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fapp-route.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/256cd5b571b770476755515ad1bdc976b43a258d/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fapp-route.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fapp-route.ts?ref=256cd5b571b770476755515ad1bdc976b43a258d",
            "patch": "@@ -5,16 +5,9 @@ import {\n } from '../../server/route-modules/app-route/module.compiled'\n import { RouteKind } from '../../server/route-kind'\n import { patchFetch as _patchFetch } from '../../server/lib/patch-fetch'\n-\n-import * as userland from 'VAR_USERLAND'\n-import {\n-  RouterServerContextSymbol,\n-  routerServerGlobal,\n-} from '../../server/lib/router-utils/router-server-context'\n import type { IncomingMessage, ServerResponse } from 'node:http'\n import { getRequestMeta } from '../../server/request-meta'\n import { getTracer, type Span, SpanKind } from '../../server/lib/trace/tracer'\n-import type { ServerOnInstrumentationRequestError } from '../../server/app-render/types'\n import { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\n import { NodeNextRequest, NodeNextResponse } from '../../server/base-http/node'\n import {\n@@ -24,13 +17,22 @@ import {\n import { BaseServerSpan } from '../../server/lib/trace/constants'\n import { getRevalidateReason } from '../../server/instrumentation/utils'\n import { sendResponse } from '../../server/send-response'\n-import { toNodeOutgoingHttpHeaders } from '../../server/web/utils'\n+import {\n+  fromNodeOutgoingHttpHeaders,\n+  toNodeOutgoingHttpHeaders,\n+} from '../../server/web/utils'\n+import { decodePathParams } from '../../server/lib/router-utils/decode-path-params'\n+import { getCacheControlHeader } from '../../server/lib/cache-control'\n import { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from '../../lib/constants'\n+import { NoFallbackError } from '../../shared/lib/no-fallback-error.external'\n import {\n   CachedRouteKind,\n   type ResponseCacheEntry,\n+  type ResponseGenerator,\n } from '../../server/response-cache'\n \n+import * as userland from 'VAR_USERLAND'\n+\n // These are injected by the loader afterwards. This is injected as a variable\n // instead of a replacement because this could also be `undefined` instead of\n // an empty string.\n@@ -111,53 +113,55 @@ export async function handler(\n   const {\n     buildId,\n     params,\n+    nextConfig,\n     parsedUrl,\n-    serverFilesManifest,\n+    isDraftMode,\n     prerenderManifest,\n+    routerServerContext,\n     isOnDemandRevalidate,\n+    revalidateOnlyGenerated,\n   } = prepareResult\n \n-  const routerServerContext =\n-    routerServerGlobal[RouterServerContextSymbol]?.[\n-      process.env.__NEXT_RELATIVE_PROJECT_DIR || ''\n-    ]\n-\n-  const onInstrumentationRequestError =\n-    routeModule.instrumentationOnRequestError.bind(routeModule)\n-\n-  const onError: ServerOnInstrumentationRequestError = (\n-    err,\n-    _,\n-    errorContext\n-  ) => {\n-    if (routerServerContext?.logErrorWithOriginalStack) {\n-      routerServerContext.logErrorWithOriginalStack(err, 'app-dir')\n-    } else {\n-      console.error(err)\n-    }\n-    return onInstrumentationRequestError(\n-      req,\n-      err,\n-      {\n-        path: req.url || '/',\n-        headers: req.headers,\n-        method: req.method || 'GET',\n-      },\n-      errorContext\n-    )\n+  const normalizedSrcPage = normalizeAppPath(srcPage)\n+\n+  // TODO: rework this to not be necessary as a middleware\n+  // rewrite should not need to pass this context like this\n+  // maybe we rely on rewrite header instead\n+  let resolvedPathname = getRequestMeta(req, 'rewroteURL')\n+\n+  if (!resolvedPathname) {\n+    resolvedPathname = parsedUrl.pathname || '/'\n   }\n \n-  const nextConfig =\n-    routerServerContext?.nextConfig || serverFilesManifest.config\n+  if (resolvedPathname === '/index') {\n+    resolvedPathname = '/'\n+  }\n+  resolvedPathname = decodePathParams(resolvedPathname)\n \n-  const pathname = parsedUrl.pathname || '/'\n-  const normalizedSrcPage = normalizeAppPath(srcPage)\n   let isIsr = Boolean(\n     prerenderManifest.dynamicRoutes[normalizedSrcPage] ||\n-      prerenderManifest.routes[normalizedSrcPage] ||\n-      prerenderManifest.routes[pathname]\n+      prerenderManifest.routes[resolvedPathname]\n   )\n \n+  if (isIsr && !isDraftMode) {\n+    const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname])\n+    const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage]\n+\n+    if (prerenderInfo) {\n+      if (prerenderInfo.fallback === false && !isPrerendered) {\n+        throw new NoFallbackError()\n+      }\n+    }\n+  }\n+\n+  let cacheKey: string | null = null\n+\n+  if (isIsr && !routeModule.isDev && !isDraftMode) {\n+    cacheKey = resolvedPathname\n+    // ensure /index and / is normalized to one key\n+    cacheKey = cacheKey === '/index' ? '/' : cacheKey\n+  }\n+\n   const supportsDynamicResponse: boolean =\n     // If we're in development, we always support dynamic HTML\n     routeModule.isDev === true ||\n@@ -192,7 +196,13 @@ export async function handler(\n         res.on('close', cb)\n       },\n       onAfterTaskError: undefined,\n-      onInstrumentationRequestError: onError,\n+      onInstrumentationRequestError: (error, _request, errorContext) =>\n+        routeModule.onRequestError(\n+          req,\n+          error,\n+          errorContext,\n+          routerServerContext\n+        ),\n     },\n     sharedContext: {\n       buildId,\n@@ -249,14 +259,194 @@ export async function handler(\n       })\n     }\n \n-    let response: Response\n+    const handleResponse = async (currentSpan?: Span) => {\n+      const responseGenerator: ResponseGenerator = async ({\n+        previousCacheEntry,\n+      }) => {\n+        try {\n+          if (\n+            !getRequestMeta(req, 'minimalMode') &&\n+            isOnDemandRevalidate &&\n+            revalidateOnlyGenerated &&\n+            !previousCacheEntry\n+          ) {\n+            res.statusCode = 404\n+            // on-demand revalidate always sets this header\n+            res.setHeader('x-nextjs-cache', 'REVALIDATED')\n+            res.end('This page could not be found')\n+            return null\n+          }\n+\n+          const response = await invokeRouteModule(currentSpan)\n+\n+          ;(req as any).fetchMetrics = (context.renderOpts as any).fetchMetrics\n+          let pendingWaitUntil = context.renderOpts.pendingWaitUntil\n+\n+          // Attempt using provided waitUntil if available\n+          // if it's not we fallback to sendResponse's handling\n+          if (pendingWaitUntil) {\n+            if (ctx.waitUntil) {\n+              ctx.waitUntil(pendingWaitUntil)\n+              pendingWaitUntil = undefined\n+            }\n+          }\n+          const cacheTags = context.renderOpts.collectedTags\n+\n+          // If the request is for a static response, we can cache it so long\n+          // as it's not edge.\n+          if (isIsr) {\n+            const blob = await response.blob()\n+\n+            // Copy the headers from the response.\n+            const headers = toNodeOutgoingHttpHeaders(response.headers)\n+\n+            if (cacheTags) {\n+              headers[NEXT_CACHE_TAGS_HEADER] = cacheTags\n+            }\n+\n+            if (!headers['content-type'] && blob.type) {\n+              headers['content-type'] = blob.type\n+            }\n+\n+            const revalidate =\n+              typeof context.renderOpts.collectedRevalidate === 'undefined' ||\n+              context.renderOpts.collectedRevalidate >= INFINITE_CACHE\n+                ? false\n+                : context.renderOpts.collectedRevalidate\n+\n+            const expire =\n+              typeof context.renderOpts.collectedExpire === 'undefined' ||\n+              context.renderOpts.collectedExpire >= INFINITE_CACHE\n+                ? undefined\n+                : context.renderOpts.collectedExpire\n+\n+            // Create the cache entry for the response.\n+            const cacheEntry: ResponseCacheEntry = {\n+              value: {\n+                kind: CachedRouteKind.APP_ROUTE,\n+                status: response.status,\n+                body: Buffer.from(await blob.arrayBuffer()),\n+                headers,\n+              },\n+              cacheControl: { revalidate, expire },\n+            }\n+\n+            return cacheEntry\n+          } else {\n+            // send response without caching if not ISR\n+            await sendResponse(\n+              nodeNextReq,\n+              nodeNextRes,\n+              response,\n+              context.renderOpts.pendingWaitUntil\n+            )\n+            return null\n+          }\n+        } catch (err) {\n+          // if this is a background revalidate we need to report\n+          // the request error here as it won't be bubbled\n+          if (previousCacheEntry?.isStale) {\n+            await routeModule.onRequestError(\n+              req,\n+              err,\n+              {\n+                routerKind: 'App Router',\n+                routePath: srcPage,\n+                routeType: 'route',\n+                revalidateReason: getRevalidateReason({\n+                  isRevalidate,\n+                  isOnDemandRevalidate,\n+                }),\n+              },\n+              routerServerContext\n+            )\n+          }\n+          throw err\n+        }\n+      }\n+\n+      const cacheEntry = await routeModule.handleResponse({\n+        req,\n+        nextConfig,\n+        cacheKey,\n+        routeKind: RouteKind.APP_ROUTE,\n+        isFallback: false,\n+        prerenderManifest,\n+        isRoutePPREnabled: false,\n+        isOnDemandRevalidate,\n+        revalidateOnlyGenerated,\n+        responseGenerator,\n+        waitUntil: ctx.waitUntil,\n+      })\n+\n+      // we don't create a cacheEntry for ISR\n+      if (!isIsr) {\n+        return null\n+      }\n+\n+      if (cacheEntry?.value?.kind !== CachedRouteKind.APP_ROUTE) {\n+        throw new Error(\n+          `Invariant: app-route received invalid cache entry ${cacheEntry?.value?.kind}`\n+        )\n+      }\n+\n+      if (!getRequestMeta(req, 'minimalMode')) {\n+        res.setHeader(\n+          'x-nextjs-cache',\n+          isOnDemandRevalidate\n+            ? 'REVALIDATED'\n+            : cacheEntry.isMiss\n+              ? 'MISS'\n+              : cacheEntry.isStale\n+                ? 'STALE'\n+                : 'HIT'\n+        )\n+      }\n+\n+      // Draft mode should never be cached\n+      if (isDraftMode) {\n+        res.setHeader(\n+          'Cache-Control',\n+          'private, no-cache, no-store, max-age=0, must-revalidate'\n+        )\n+      }\n+\n+      const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers)\n+\n+      if (!(getRequestMeta(req, 'minimalMode') && isIsr)) {\n+        headers.delete(NEXT_CACHE_TAGS_HEADER)\n+      }\n+\n+      // If cache control is already set on the response we don't\n+      // override it to allow users to customize it via next.config\n+      if (\n+        cacheEntry.cacheControl &&\n+        !res.getHeader('Cache-Control') &&\n+        !headers.get('Cache-Control')\n+      ) {\n+        headers.set(\n+          'Cache-Control',\n+          getCacheControlHeader(cacheEntry.cacheControl)\n+        )\n+      }\n+\n+      await sendResponse(\n+        nodeNextReq,\n+        nodeNextRes,\n+        new Response(cacheEntry.value.body, {\n+          headers,\n+          status: cacheEntry.value.status || 200,\n+        })\n+      )\n+      return null\n+    }\n \n     // TODO: activeSpan code path is for when wrapped by\n     // next-server can be removed when this is no longer used\n     if (activeSpan) {\n-      response = await invokeRouteModule(activeSpan)\n+      await handleResponse(activeSpan)\n     } else {\n-      response = await tracer.withPropagatedContext(req.headers, () =>\n+      await tracer.withPropagatedContext(req.headers, () =>\n         tracer.trace(\n           BaseServerSpan.handleRequest,\n           {\n@@ -267,79 +457,14 @@ export async function handler(\n               'http.target': req.url,\n             },\n           },\n-          invokeRouteModule\n+          handleResponse\n         )\n       )\n     }\n-\n-    ;(req as any).fetchMetrics = (context.renderOpts as any).fetchMetrics\n-\n-    const cacheTags = context.renderOpts.collectedTags\n-\n-    // If the request is for a static response, we can cache it so long\n-    // as it's not edge.\n-    if (isIsr) {\n-      const blob = await response.blob()\n-\n-      // Copy the headers from the response.\n-      const headers = toNodeOutgoingHttpHeaders(response.headers)\n-\n-      if (cacheTags) {\n-        headers[NEXT_CACHE_TAGS_HEADER] = cacheTags\n-      }\n-\n-      if (!headers['content-type'] && blob.type) {\n-        headers['content-type'] = blob.type\n-      }\n-\n-      const revalidate =\n-        typeof context.renderOpts.collectedRevalidate === 'undefined' ||\n-        context.renderOpts.collectedRevalidate >= INFINITE_CACHE\n-          ? false\n-          : context.renderOpts.collectedRevalidate\n-\n-      const expire =\n-        typeof context.renderOpts.collectedExpire === 'undefined' ||\n-        context.renderOpts.collectedExpire >= INFINITE_CACHE\n-          ? undefined\n-          : context.renderOpts.collectedExpire\n-\n-      // Create the cache entry for the response.\n-      const cacheEntry: ResponseCacheEntry = {\n-        value: {\n-          kind: CachedRouteKind.APP_ROUTE,\n-          status: response.status,\n-          body: Buffer.from(await blob.arrayBuffer()),\n-          headers,\n-        },\n-        cacheControl: { revalidate, expire },\n-      }\n-\n-      return cacheEntry\n-    }\n-    let pendingWaitUntil = context.renderOpts.pendingWaitUntil\n-\n-    // Attempt using provided waitUntil if available\n-    // if it's not we fallback to sendResponse's handling\n-    if (pendingWaitUntil) {\n-      if (context.renderOpts.waitUntil) {\n-        context.renderOpts.waitUntil(pendingWaitUntil)\n-        pendingWaitUntil = undefined\n-      }\n-    }\n-\n-    // Send the response now that we have copied it into the cache.\n-    await sendResponse(\n-      nodeNextReq,\n-      nodeNextRes,\n-      response,\n-      context.renderOpts.pendingWaitUntil\n-    )\n-    return null\n   } catch (err) {\n     // if we aren't wrapped by base-server handle here\n     if (!activeSpan) {\n-      await onError(err, req, {\n+      await routeModule.onRequestError(req, err, {\n         routerKind: 'App Router',\n         routePath: normalizedSrcPage,\n         routeType: 'route',"
        },
        {
            "sha": "29bd4b29c4f127d0fa33ca01777561df7d36fd43",
            "filename": "packages/next/src/build/templates/pages.ts",
            "status": "modified",
            "additions": 624,
            "deletions": 184,
            "changes": 808,
            "blob_url": "https://github.com/vercel/next.js/blob/256cd5b571b770476755515ad1bdc976b43a258d/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fpages.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/256cd5b571b770476755515ad1bdc976b43a258d/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fpages.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fpages.ts?ref=256cd5b571b770476755515ad1bdc976b43a258d",
            "patch": "@@ -1,19 +1,22 @@\n import type { IncomingMessage, ServerResponse } from 'node:http'\n-import type RenderResult from '../../server/render-result'\n import type { ParsedUrlQuery } from 'node:querystring'\n import { PagesRouteModule } from '../../server/route-modules/pages/module.compiled'\n import { RouteKind } from '../../server/route-kind'\n import { BaseServerSpan } from '../../server/lib/trace/constants'\n import { getTracer, SpanKind, type Span } from '../../server/lib/trace/tracer'\n import { formatUrl } from '../../shared/lib/router/utils/format-url'\n-import {\n-  RouterServerContextSymbol,\n-  routerServerGlobal,\n-} from '../../server/lib/router-utils/router-server-context'\n-import { getRequestMeta } from '../../server/request-meta'\n+import { addRequestMeta, getRequestMeta } from '../../server/request-meta'\n import { interopDefault } from '../../server/app-render/interop-default'\n import { getRevalidateReason } from '../../server/instrumentation/utils'\n import { normalizeDataPath } from '../../shared/lib/page-path/normalize-data-path'\n+import {\n+  CachedRouteKind,\n+  type CachedPageValue,\n+  type CachedRedirectValue,\n+  type ResponseCacheEntry,\n+  type ResponseGenerator,\n+} from '../../server/response-cache'\n+\n import { hoist } from './helpers'\n \n // Import the app and document modules.\n@@ -22,6 +25,24 @@ import * as app from 'VAR_MODULE_APP'\n \n // Import the userland code.\n import * as userland from 'VAR_USERLAND'\n+import {\n+  getCacheControlHeader,\n+  type CacheControl,\n+} from '../../server/lib/cache-control'\n+import { normalizeRepeatedSlashes } from '../../shared/lib/utils'\n+import { getRedirectStatus } from '../../lib/redirect-status'\n+import { CACHE_ONE_YEAR } from '../../lib/constants'\n+import { sendRenderResult } from '../../server/send-payload'\n+import RenderResult from '../../server/render-result'\n+import { decodePathParams } from '../../server/lib/router-utils/decode-path-params'\n+import { toResponseCacheEntry } from '../../server/response-cache/utils'\n+import { NoFallbackError } from '../../shared/lib/no-fallback-error.external'\n+import { RedirectStatusCode } from '../../client/components/redirect-status-code'\n+import { isBot } from '../../shared/lib/router/utils/is-bot'\n+import { addPathPrefix } from '../../shared/lib/router/utils/add-path-prefix'\n+import { removeTrailingSlash } from '../../shared/lib/router/utils/remove-trailing-slash'\n+import { pathHasPrefix } from '../../shared/lib/router/utils/path-has-prefix'\n+import { normalizeLocalePath } from '../../shared/lib/i18n/normalize-locale-path'\n \n // Re-export the component (should be the default export).\n export default hoist(userland, 'default')\n@@ -81,7 +102,7 @@ export async function handler(\n   ctx: {\n     waitUntil: (prom: Promise<void>) => void\n   }\n-): Promise<RenderResult | null> {\n+): Promise<void> {\n   let srcPage = 'VAR_DEFINITION_PAGE'\n \n   // turbopack doesn't normalize `/index` in the page name\n@@ -105,7 +126,7 @@ export async function handler(\n     res.statusCode = 400\n     res.end('Bad Request')\n     ctx.waitUntil?.(Promise.resolve())\n-    return null\n+    return\n   }\n \n   const {\n@@ -117,41 +138,125 @@ export async function handler(\n     originalPathname,\n     buildManifest,\n     nextFontManifest,\n-    isNextDataRequest,\n     serverFilesManifest,\n     reactLoadableManifest,\n     prerenderManifest,\n     isDraftMode,\n     isOnDemandRevalidate,\n+    revalidateOnlyGenerated,\n     locale,\n     locales,\n     defaultLocale,\n+    routerServerContext,\n+    nextConfig,\n   } = prepareResult\n \n-  const routerServerContext =\n-    routerServerGlobal[RouterServerContextSymbol]?.[\n-      process.env.__NEXT_RELATIVE_PROJECT_DIR || ''\n-    ]\n-\n-  const onError = routeModule.instrumentationOnRequestError.bind(routeModule)\n-  const nextConfig =\n-    routerServerContext?.nextConfig || serverFilesManifest.config\n-\n   const isExperimentalCompile =\n     serverFilesManifest?.config?.experimental?.isExperimentalCompile\n \n-  const isIsrFallback = Boolean(getRequestMeta(req, 'isIsrFallback'))\n   const hasServerProps = Boolean(getServerSideProps)\n   const hasStaticProps = Boolean(getStaticProps)\n+  const hasStaticPaths = Boolean(getStaticPaths)\n   const hasGetInitialProps = Boolean(\n     (userland.default || userland).getInitialProps\n   )\n+  const isAmp = query.amp && config.amp\n+  let cacheKey: null | string = null\n+  let isIsrFallback = Boolean(getRequestMeta(req, 'isIsrFallback'))\n+  let isNextDataRequest =\n+    prepareResult.isNextDataRequest && (hasStaticProps || hasServerProps)\n+\n+  const is404Page = srcPage === '/404'\n+  const is500Page = srcPage === '/500'\n+  const isErrorPage = srcPage === '/_error'\n+  const pathname = parsedUrl.pathname || '/'\n+\n+  // TODO: rework this to not be necessary as a middleware\n+  // rewrite should not need to pass this context like this\n+  // maybe we rely on rewrite header instead\n+  let resolvedPathname = getRequestMeta(req, 'rewroteURL')\n+\n+  if (resolvedPathname) {\n+    if (pathHasPrefix(resolvedPathname, '/_next/data/')) {\n+      resolvedPathname = normalizeDataPath(resolvedPathname)\n+    }\n+\n+    if (locale) {\n+      resolvedPathname = normalizeLocalePath(\n+        resolvedPathname,\n+        nextConfig.i18n?.locales || []\n+      ).pathname\n+    }\n+  } else {\n+    resolvedPathname = pathname\n+  }\n+\n+  if (resolvedPathname === '/index') {\n+    resolvedPathname = '/'\n+  }\n+\n+  if (!routeModule.isDev && !isDraftMode && hasStaticProps) {\n+    cacheKey = `${locale ? `/${locale}` : ''}${\n+      (srcPage === '/' || resolvedPathname === '/') && locale\n+        ? ''\n+        : resolvedPathname\n+    }${isAmp ? '.amp' : ''}`\n+\n+    if (is404Page || is500Page || isErrorPage) {\n+      cacheKey = `${locale ? `/${locale}` : ''}${srcPage}${isAmp ? '.amp' : ''}`\n+    }\n+\n+    cacheKey = decodePathParams(cacheKey)\n+\n+    // ensure /index and / is normalized to one key\n+    cacheKey = cacheKey === '/index' ? '/' : cacheKey\n+  }\n+\n+  if (hasStaticPaths && !isDraftMode) {\n+    const decodedPathname = removeTrailingSlash(\n+      decodePathParams(\n+        locale\n+          ? addPathPrefix(resolvedPathname, `/${locale}`)\n+          : resolvedPathname\n+      )\n+    )\n+    const isPrerendered =\n+      Boolean(prerenderManifest.routes[decodedPathname]) ||\n+      prerenderManifest.notFoundRoutes.includes(decodedPathname)\n+\n+    const prerenderInfo = prerenderManifest.dynamicRoutes[srcPage]\n+\n+    if (prerenderInfo) {\n+      if (prerenderInfo.fallback === false && !isPrerendered) {\n+        throw new NoFallbackError()\n+      }\n+\n+      if (\n+        typeof prerenderInfo.fallback === 'string' &&\n+        !isPrerendered &&\n+        !isNextDataRequest\n+      ) {\n+        isIsrFallback = true\n+      }\n+    }\n+  }\n+\n+  // When serving a bot request, we want to serve a blocking render and not\n+  // the prerendered page. This ensures that the correct content is served\n+  // to the bot in the head.\n+  if (\n+    (isIsrFallback && isBot(req.headers['user-agent'] || '')) ||\n+    getRequestMeta(req, 'minimalMode')\n+  ) {\n+    isIsrFallback = false\n+  }\n+\n+  const tracer = getTracer()\n+  const activeSpan = tracer.getActiveScopeSpan()\n \n   try {\n     const method = req.method || 'GET'\n-    const tracer = getTracer()\n \n-    const activeSpan = tracer.getActiveScopeSpan()\n     const resolvedUrl = formatUrl({\n       pathname: parsedUrl.pathname,\n       // make sure to only add query values from original URL\n@@ -161,171 +266,515 @@ export async function handler(\n     const publicRuntimeConfig: Record<string, string> =\n       routerServerContext?.publicRuntimeConfig || nextConfig.publicRuntimeConfig\n \n-    const invokeRouteModule = async (span?: Span) =>\n-      routeModule\n-        .render(req, res, {\n-          query:\n-            hasStaticProps && !isExperimentalCompile\n-              ? ({\n-                  ...params,\n-                  ...(query.amp && config.amp\n-                    ? {\n-                        amp: query.amp as string,\n-                      }\n-                    : {}),\n-                } as ParsedUrlQuery)\n-              : {\n-                  ...query,\n-                  ...params,\n+    const handleResponse = async (span?: Span) => {\n+      const responseGenerator: ResponseGenerator = async ({\n+        previousCacheEntry,\n+      }) => {\n+        const doRender = async () => {\n+          try {\n+            return await routeModule\n+              .render(req, res, {\n+                query:\n+                  hasStaticProps && !isExperimentalCompile\n+                    ? ({\n+                        ...params,\n+                        ...(isAmp\n+                          ? {\n+                              amp: query.amp,\n+                            }\n+                          : {}),\n+                      } as ParsedUrlQuery)\n+                    : {\n+                        ...query,\n+                        ...params,\n+                      },\n+                params,\n+                page: srcPage,\n+                renderContext: {\n+                  isDraftMode,\n+                  isFallback: isIsrFallback,\n+                  developmentNotFoundSourcePage: getRequestMeta(\n+                    req,\n+                    'developmentNotFoundSourcePage'\n+                  ),\n                 },\n-          params,\n-          page: srcPage,\n-          renderContext: {\n-            isDraftMode,\n-            isFallback: isIsrFallback,\n-            developmentNotFoundSourcePage: getRequestMeta(\n-              req,\n-              'developmentNotFoundSourcePage'\n-            ),\n-          },\n-          sharedContext: {\n-            buildId,\n-            customServer:\n-              Boolean(routerServerContext?.isCustomServer) || undefined,\n-            deploymentId: process.env.NEXT_DEPLOYMENT_ID,\n-          },\n-          renderOpts: {\n-            params,\n-            routeModule,\n-            page: srcPage,\n-            pageConfig: config || {},\n-            Component: interopDefault(userland),\n-            ComponentMod: userland,\n-            getStaticProps,\n-            getStaticPaths,\n-            getServerSideProps,\n-            supportsDynamicResponse: !hasStaticProps,\n-            buildManifest,\n-            nextFontManifest,\n-            reactLoadableManifest,\n-\n-            assetPrefix: nextConfig.assetPrefix,\n-            strictNextHead: Boolean(nextConfig.experimental.strictNextHead),\n-            previewProps: prerenderManifest.preview,\n-            images: nextConfig.images as any,\n-            nextConfigOutput: nextConfig.output,\n-            optimizeCss: Boolean(nextConfig.experimental.optimizeCss),\n-            nextScriptWorkers: Boolean(\n-              nextConfig.experimental.nextScriptWorkers\n-            ),\n-            domainLocales: nextConfig.i18n?.domains,\n-            crossOrigin: nextConfig.crossOrigin,\n-\n-            multiZoneDraftMode,\n-            basePath: nextConfig.basePath,\n-            canonicalBase: nextConfig.amp.canonicalBase || '',\n-            ampOptimizerConfig: nextConfig.experimental.amp?.optimizer,\n-            disableOptimizedLoading:\n-              nextConfig.experimental.disableOptimizedLoading,\n-            largePageDataBytes: nextConfig.experimental.largePageDataBytes,\n-            // Only the `publicRuntimeConfig` key is exposed to the client side\n-            // It'll be rendered as part of __NEXT_DATA__ on the client side\n-            runtimeConfig:\n-              Object.keys(publicRuntimeConfig).length > 0\n-                ? publicRuntimeConfig\n-                : undefined,\n-\n-            isExperimentalCompile,\n-\n-            experimental: {\n-              clientTraceMetadata:\n-                nextConfig.experimental.clientTraceMetadata || ([] as any),\n-            },\n-\n-            locale,\n-            locales,\n-            defaultLocale,\n-            setIsrStatus: routerServerContext?.setIsrStatus,\n-\n-            isNextDataRequest:\n-              isNextDataRequest && (hasServerProps || hasStaticProps),\n-\n-            resolvedUrl,\n-            // For getServerSideProps and getInitialProps we need to ensure we use the original URL\n-            // and not the resolved URL to prevent a hydration mismatch on\n-            // asPath\n-            resolvedAsPath:\n-              hasServerProps || hasGetInitialProps\n-                ? formatUrl({\n-                    // we use the original URL pathname less the _next/data prefix if\n-                    // present\n-                    pathname: isNextDataRequest\n-                      ? normalizeDataPath(originalPathname)\n-                      : originalPathname,\n-                    query: originalQuery,\n+                sharedContext: {\n+                  buildId,\n+                  customServer:\n+                    Boolean(routerServerContext?.isCustomServer) || undefined,\n+                  deploymentId: process.env.NEXT_DEPLOYMENT_ID,\n+                },\n+                renderOpts: {\n+                  params,\n+                  routeModule,\n+                  page: srcPage,\n+                  pageConfig: config || {},\n+                  Component: interopDefault(userland),\n+                  ComponentMod: userland,\n+                  getStaticProps,\n+                  getStaticPaths,\n+                  getServerSideProps,\n+                  supportsDynamicResponse: !hasStaticProps,\n+                  buildManifest,\n+                  nextFontManifest,\n+                  reactLoadableManifest,\n+\n+                  assetPrefix: nextConfig.assetPrefix,\n+                  strictNextHead: Boolean(\n+                    nextConfig.experimental.strictNextHead\n+                  ),\n+                  previewProps: prerenderManifest.preview,\n+                  images: nextConfig.images as any,\n+                  nextConfigOutput: nextConfig.output,\n+                  optimizeCss: Boolean(nextConfig.experimental.optimizeCss),\n+                  nextScriptWorkers: Boolean(\n+                    nextConfig.experimental.nextScriptWorkers\n+                  ),\n+                  domainLocales: nextConfig.i18n?.domains,\n+                  crossOrigin: nextConfig.crossOrigin,\n+\n+                  multiZoneDraftMode,\n+                  basePath: nextConfig.basePath,\n+                  canonicalBase: nextConfig.amp.canonicalBase || '',\n+                  ampOptimizerConfig: nextConfig.experimental.amp?.optimizer,\n+                  disableOptimizedLoading:\n+                    nextConfig.experimental.disableOptimizedLoading,\n+                  largePageDataBytes:\n+                    nextConfig.experimental.largePageDataBytes,\n+                  // Only the `publicRuntimeConfig` key is exposed to the client side\n+                  // It'll be rendered as part of __NEXT_DATA__ on the client side\n+                  runtimeConfig:\n+                    Object.keys(publicRuntimeConfig).length > 0\n+                      ? publicRuntimeConfig\n+                      : undefined,\n+\n+                  isExperimentalCompile,\n+\n+                  experimental: {\n+                    clientTraceMetadata:\n+                      nextConfig.experimental.clientTraceMetadata ||\n+                      ([] as any),\n+                  },\n+\n+                  locale,\n+                  locales,\n+                  defaultLocale,\n+                  setIsrStatus: routerServerContext?.setIsrStatus,\n+\n+                  isNextDataRequest:\n+                    isNextDataRequest && (hasServerProps || hasStaticProps),\n+\n+                  resolvedUrl,\n+                  // For getServerSideProps and getInitialProps we need to ensure we use the original URL\n+                  // and not the resolved URL to prevent a hydration mismatch on\n+                  // asPath\n+                  resolvedAsPath:\n+                    hasServerProps || hasGetInitialProps\n+                      ? formatUrl({\n+                          // we use the original URL pathname less the _next/data prefix if\n+                          // present\n+                          pathname: isNextDataRequest\n+                            ? normalizeDataPath(originalPathname)\n+                            : originalPathname,\n+                          query: originalQuery,\n+                        })\n+                      : resolvedUrl,\n+\n+                  isOnDemandRevalidate,\n+\n+                  ErrorDebug: getRequestMeta(req, 'PagesErrorDebug'),\n+                  err: getRequestMeta(req, 'invokeError'),\n+                  dev: routeModule.isDev,\n+\n+                  // needed for experimental.optimizeCss feature\n+                  distDir: `${routeModule.projectDir}/${routeModule.distDir}`,\n+\n+                  ampSkipValidation:\n+                    nextConfig.experimental.amp?.skipValidation,\n+                  ampValidator: getRequestMeta(req, 'ampValidator'),\n+                },\n+              })\n+              .then((renderResult): ResponseCacheEntry => {\n+                const { metadata } = renderResult\n+\n+                let cacheControl: CacheControl | undefined =\n+                  metadata.cacheControl\n+\n+                if ('isNotFound' in metadata && metadata.isNotFound) {\n+                  return {\n+                    value: null,\n+                    cacheControl,\n+                  } satisfies ResponseCacheEntry\n+                }\n+\n+                // Handle `isRedirect`.\n+                if (metadata.isRedirect) {\n+                  return {\n+                    value: {\n+                      kind: CachedRouteKind.REDIRECT,\n+                      props: metadata.pageData ?? metadata.flightData,\n+                    } satisfies CachedRedirectValue,\n+                    cacheControl,\n+                  } satisfies ResponseCacheEntry\n+                }\n+\n+                return {\n+                  value: {\n+                    kind: CachedRouteKind.PAGES,\n+                    html: renderResult,\n+                    pageData: renderResult.metadata.pageData,\n+                    headers: renderResult.metadata.headers,\n+                    status: renderResult.metadata.statusCode,\n+                  },\n+                  cacheControl,\n+                }\n+              })\n+              .finally(() => {\n+                if (!span) return\n+\n+                span.setAttributes({\n+                  'http.status_code': res.statusCode,\n+                  'next.rsc': false,\n+                })\n+\n+                const rootSpanAttributes = tracer.getRootSpanAttributes()\n+                // We were unable to get attributes, probably OTEL is not enabled\n+                if (!rootSpanAttributes) {\n+                  return\n+                }\n+\n+                if (\n+                  rootSpanAttributes.get('next.span_type') !==\n+                  BaseServerSpan.handleRequest\n+                ) {\n+                  console.warn(\n+                    `Unexpected root span type '${rootSpanAttributes.get(\n+                      'next.span_type'\n+                    )}'. Please report this Next.js issue https://github.com/vercel/next.js`\n+                  )\n+                  return\n+                }\n+\n+                const route = rootSpanAttributes.get('next.route')\n+                if (route) {\n+                  const name = `${method} ${route}`\n+\n+                  span.setAttributes({\n+                    'next.route': route,\n+                    'http.route': route,\n+                    'next.span_name': name,\n                   })\n-                : resolvedUrl,\n-\n-            isOnDemandRevalidate,\n+                  span.updateName(name)\n+                } else {\n+                  span.updateName(`${method} ${req.url}`)\n+                }\n+              })\n+          } catch (err: unknown) {\n+            // if this is a background revalidate we need to report\n+            // the request error here as it won't be bubbled\n+            if (previousCacheEntry?.isStale) {\n+              await routeModule.onRequestError(\n+                req,\n+                err,\n+                {\n+                  routerKind: 'Pages Router',\n+                  routePath: srcPage,\n+                  routeType: 'render',\n+                  revalidateReason: getRevalidateReason({\n+                    isRevalidate: hasStaticProps,\n+                    isOnDemandRevalidate,\n+                  }),\n+                },\n+                routerServerContext\n+              )\n+            }\n+            throw err\n+          }\n+        }\n+\n+        // if we've already generated this page we no longer\n+        // serve the fallback\n+        if (previousCacheEntry) {\n+          isIsrFallback = false\n+        }\n+\n+        if (isIsrFallback) {\n+          const fallbackResponse = await routeModule.getResponseCache(req).get(\n+            routeModule.isDev\n+              ? null\n+              : locale\n+                ? `/${locale}${srcPage}`\n+                : srcPage,\n+            async ({\n+              previousCacheEntry: previousFallbackCacheEntry = null,\n+            }) => {\n+              if (!routeModule.isDev) {\n+                return toResponseCacheEntry(previousFallbackCacheEntry)\n+              }\n+              return doRender()\n+            },\n+            {\n+              routeKind: RouteKind.PAGES,\n+              isFallback: true,\n+              isRoutePPREnabled: false,\n+              isOnDemandRevalidate: false,\n+              incrementalCache: await routeModule.getIncrementalCache(\n+                req,\n+                nextConfig,\n+                prerenderManifest\n+              ),\n+              waitUntil: ctx.waitUntil,\n+            }\n+          )\n+          if (fallbackResponse) {\n+            // Remove the cache control from the response to prevent it from being\n+            // used in the surrounding cache.\n+            delete fallbackResponse.cacheControl\n+            return fallbackResponse\n+          }\n+        }\n+\n+        if (\n+          !getRequestMeta(req, 'minimalMode') &&\n+          isOnDemandRevalidate &&\n+          revalidateOnlyGenerated &&\n+          !previousCacheEntry\n+        ) {\n+          res.statusCode = 404\n+          // on-demand revalidate always sets this header\n+          res.setHeader('x-nextjs-cache', 'REVALIDATED')\n+          res.end('This page could not be found')\n+          return null\n+        }\n+\n+        if (\n+          isIsrFallback &&\n+          previousCacheEntry?.value?.kind === CachedRouteKind.PAGES\n+        ) {\n+          return {\n+            value: {\n+              kind: CachedRouteKind.PAGES,\n+              html: new RenderResult(\n+                Buffer.from(previousCacheEntry.value.html),\n+                {\n+                  contentType: 'text/html;utf-8',\n+                  metadata: {\n+                    statusCode: previousCacheEntry.value.status,\n+                    headers: previousCacheEntry.value.headers,\n+                  },\n+                }\n+              ),\n+              pageData: {},\n+              status: previousCacheEntry.value.status,\n+              headers: previousCacheEntry.value.headers,\n+            } satisfies CachedPageValue,\n+            cacheControl: { revalidate: 0, expire: undefined },\n+          } satisfies ResponseCacheEntry\n+        }\n+        return doRender()\n+      }\n \n-            ErrorDebug: getRequestMeta(req, 'PagesErrorDebug'),\n-            err: getRequestMeta(req, 'invokeError'),\n-            dev: routeModule.isDev,\n+      const result = await routeModule.handleResponse({\n+        cacheKey,\n+        req,\n+        nextConfig,\n+        routeKind: RouteKind.PAGES,\n+        isOnDemandRevalidate,\n+        revalidateOnlyGenerated,\n+        waitUntil: ctx.waitUntil,\n+        responseGenerator: responseGenerator,\n+        prerenderManifest,\n+      })\n+\n+      // response is finished is no cache entry\n+      if (!result) {\n+        return\n+      }\n \n-            // needed for experimental.optimizeCss feature\n-            distDir: `${routeModule.projectDir}/${routeModule.distDir}`,\n+      if (hasStaticProps && !getRequestMeta(req, 'minimalMode')) {\n+        res.setHeader(\n+          'x-nextjs-cache',\n+          isOnDemandRevalidate\n+            ? 'REVALIDATED'\n+            : result.isMiss\n+              ? 'MISS'\n+              : result.isStale\n+                ? 'STALE'\n+                : 'HIT'\n+        )\n+      }\n \n-            ampSkipValidation: nextConfig.experimental.amp?.skipValidation,\n-            ampValidator: getRequestMeta(req, 'ampValidator'),\n-          },\n-        })\n-        .finally(() => {\n-          if (!span) return\n-\n-          span.setAttributes({\n-            'http.status_code': res.statusCode,\n-            'next.rsc': false,\n-          })\n-\n-          const rootSpanAttributes = tracer.getRootSpanAttributes()\n-          // We were unable to get attributes, probably OTEL is not enabled\n-          if (!rootSpanAttributes) {\n-            return\n+      let cacheControl: CacheControl | undefined\n+\n+      if (!hasStaticProps || isIsrFallback) {\n+        if (!res.getHeader('Cache-Control')) {\n+          cacheControl = { revalidate: 0, expire: undefined }\n+        }\n+      } else if (is404Page) {\n+        const notFoundRevalidate = getRequestMeta(req, 'notFoundRevalidate')\n+\n+        cacheControl = {\n+          revalidate:\n+            typeof notFoundRevalidate === 'undefined' ? 0 : notFoundRevalidate,\n+          expire: undefined,\n+        }\n+      } else if (is500Page) {\n+        cacheControl = { revalidate: 0, expire: undefined }\n+      } else if (result.cacheControl) {\n+        // If the cache entry has a cache control with a revalidate value that's\n+        // a number, use it.\n+        if (typeof result.cacheControl.revalidate === 'number') {\n+          if (result.cacheControl.revalidate < 1) {\n+            throw new Error(\n+              `Invalid revalidate configuration provided: ${result.cacheControl.revalidate} < 1`\n+            )\n           }\n \n-          if (\n-            rootSpanAttributes.get('next.span_type') !==\n-            BaseServerSpan.handleRequest\n-          ) {\n-            console.warn(\n-              `Unexpected root span type '${rootSpanAttributes.get(\n-                'next.span_type'\n-              )}'. Please report this Next.js issue https://github.com/vercel/next.js`\n-            )\n-            return\n+          cacheControl = {\n+            revalidate: result.cacheControl.revalidate,\n+            expire: result.cacheControl?.expire ?? nextConfig.expireTime,\n+          }\n+        } else {\n+          // revalidate: false\n+          cacheControl = {\n+            revalidate: CACHE_ONE_YEAR,\n+            expire: undefined,\n           }\n+        }\n+      }\n+\n+      // If cache control is already set on the response we don't\n+      // override it to allow users to customize it via next.config\n+      if (cacheControl && !res.getHeader('Cache-Control')) {\n+        res.setHeader('Cache-Control', getCacheControlHeader(cacheControl))\n+      }\n+\n+      // notFound: true case\n+      if (!result.value) {\n+        // add revalidate metadata before rendering 404 page\n+        // so that we can use this as source of truth for the\n+        // cache-control header instead of what the 404 page returns\n+        // for the revalidate value\n+        addRequestMeta(\n+          req,\n+          'notFoundRevalidate',\n+          result.cacheControl?.revalidate\n+        )\n+\n+        res.statusCode = 404\n+\n+        if (isNextDataRequest) {\n+          res.end('{\"notFound\":true}')\n+          return\n+        }\n+        // TODO: should route-module itself handle rendering the 404\n+        if (routerServerContext?.render404) {\n+          await routerServerContext.render404(req, res, parsedUrl, false)\n+        } else {\n+          res.end('This page could not be found')\n+        }\n+        return\n+      }\n \n-          const route = rootSpanAttributes.get('next.route')\n-          if (route) {\n-            const name = `${method} ${route}`\n-\n-            span.setAttributes({\n-              'next.route': route,\n-              'http.route': route,\n-              'next.span_name': name,\n-            })\n-            span.updateName(name)\n-          } else {\n-            span.updateName(`${method} ${req.url}`)\n+      if (result.value.kind === CachedRouteKind.REDIRECT) {\n+        if (isNextDataRequest) {\n+          res.setHeader('content-type', 'application/json')\n+          res.end(JSON.stringify(result.value.props))\n+          return\n+        } else {\n+          const handleRedirect = (pageData: any) => {\n+            const redirect = {\n+              destination: pageData.pageProps.__N_REDIRECT,\n+              statusCode: pageData.pageProps.__N_REDIRECT_STATUS,\n+              basePath: pageData.pageProps.__N_REDIRECT_BASE_PATH,\n+            }\n+            const statusCode = getRedirectStatus(redirect)\n+            const { basePath } = nextConfig\n+\n+            if (\n+              basePath &&\n+              redirect.basePath !== false &&\n+              redirect.destination.startsWith('/')\n+            ) {\n+              redirect.destination = `${basePath}${redirect.destination}`\n+            }\n+\n+            if (redirect.destination.startsWith('/')) {\n+              redirect.destination = normalizeRepeatedSlashes(\n+                redirect.destination\n+              )\n+            }\n+\n+            res.statusCode = statusCode\n+            res.setHeader('Location', redirect.destination)\n+            if (statusCode === RedirectStatusCode.PermanentRedirect) {\n+              res.setHeader('Refresh', `0;url=${redirect.destination}`)\n+            }\n+            res.end(redirect.destination)\n           }\n-        })\n+          await handleRedirect(result.value.props)\n+          return null\n+        }\n+      }\n+\n+      if (result.value.kind !== CachedRouteKind.PAGES) {\n+        throw new Error(\n+          `Invariant: received non-pages cache entry in pages handler`\n+        )\n+      }\n+\n+      // In dev, we should not cache pages for any reason.\n+      if (routeModule.isDev) {\n+        res.setHeader('Cache-Control', 'no-store, must-revalidate')\n+      }\n+\n+      // Draft mode should never be cached\n+      if (isDraftMode) {\n+        res.setHeader(\n+          'Cache-Control',\n+          'private, no-cache, no-store, max-age=0, must-revalidate'\n+        )\n+      }\n+\n+      // when invoking _error before pages/500 we don't actually\n+      // send the _error response\n+      if (\n+        getRequestMeta(req, 'customErrorRender') ||\n+        (isErrorPage &&\n+          getRequestMeta(req, 'minimalMode') &&\n+          res.statusCode === 500)\n+      ) {\n+        return null\n+      }\n+\n+      await sendRenderResult({\n+        req,\n+        res,\n+        // If we are rendering the error page it's not a data request\n+        // anymore\n+        result:\n+          isNextDataRequest && !isErrorPage && !is500Page\n+            ? new RenderResult(\n+                Buffer.from(JSON.stringify(result.value.pageData)),\n+                {\n+                  contentType: 'application/json',\n+                  metadata: result.value.html.metadata,\n+                }\n+              )\n+            : result.value.html,\n+        generateEtags: nextConfig.generateEtags,\n+        poweredByHeader: nextConfig.poweredByHeader,\n+        cacheControl: routeModule.isDev ? undefined : cacheControl,\n+        type: isNextDataRequest ? 'json' : 'html',\n+      })\n+    }\n \n     // TODO: activeSpan code path is for when wrapped by\n     // next-server can be removed when this is no longer used\n     if (activeSpan) {\n-      return await invokeRouteModule(activeSpan)\n+      await handleResponse()\n     } else {\n-      return await tracer.withPropagatedContext(req.headers, () =>\n+      await tracer.withPropagatedContext(req.headers, () =>\n         tracer.trace(\n           BaseServerSpan.handleRequest,\n           {\n@@ -336,19 +785,14 @@ export async function handler(\n               'http.target': req.url,\n             },\n           },\n-          invokeRouteModule\n+          handleResponse\n         )\n       )\n     }\n   } catch (err) {\n-    await onError(\n+    await routeModule.onRequestError(\n       req,\n       err,\n-      {\n-        path: req.url || '/',\n-        headers: req.headers,\n-        method: req.method || 'GET',\n-      },\n       {\n         routerKind: 'Pages Router',\n         routePath: srcPage,\n@@ -357,15 +801,11 @@ export async function handler(\n           isRevalidate: hasStaticProps,\n           isOnDemandRevalidate,\n         }),\n-      }\n+      },\n+      routerServerContext\n     )\n \n     // rethrow so that we can handle serving error page\n     throw err\n-  } finally {\n-    // We don't allow any waitUntil work in pages API routes currently\n-    // so if callback is present return with resolved promise since no\n-    // pending work\n-    ctx.waitUntil?.(Promise.resolve())\n   }\n }"
        },
        {
            "sha": "dbdd8346afe185052cef5424a61d95e18375f10b",
            "filename": "packages/next/src/server/app-render/action-handler.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 6,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/256cd5b571b770476755515ad1bdc976b43a258d/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Faction-handler.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/256cd5b571b770476755515ad1bdc976b43a258d/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Faction-handler.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Faction-handler.ts?ref=256cd5b571b770476755515ad1bdc976b43a258d",
            "patch": "@@ -52,6 +52,7 @@ import type { TemporaryReferenceSet } from 'react-server-dom-webpack/server.edge\n import { workUnitAsyncStorage } from '../app-render/work-unit-async-storage.external'\n import { InvariantError } from '../../shared/lib/invariant-error'\n import { executeRevalidates } from '../revalidation-utils'\n+import { getRequestMeta } from '../request-meta'\n \n function formDataFromSearchQueryString(query: string) {\n   const searchParams = new URLSearchParams(query)\n@@ -160,8 +161,7 @@ async function createForwardedActionResponse(\n   res: BaseNextResponse,\n   host: Host,\n   workerPathname: string,\n-  basePath: string,\n-  workStore: WorkStore\n+  basePath: string\n ) {\n   if (!host) {\n     throw new Error(\n@@ -176,7 +176,8 @@ async function createForwardedActionResponse(\n   // with the response from the forwarded worker\n   forwardedHeaders.set('x-action-forwarded', '1')\n \n-  const proto = workStore.incrementalCache?.requestProtocol || 'https'\n+  const proto =\n+    getRequestMeta(req, 'initProtocol')?.replace(/:+$/, '') || 'https'\n \n   // For standalone or the serverful mode, use the internal origin directly\n   // other than the host headers from the request.\n@@ -306,7 +307,8 @@ async function createRedirectRenderResult(\n     const forwardedHeaders = getForwardedHeaders(req, res)\n     forwardedHeaders.set(RSC_HEADER, '1')\n \n-    const proto = workStore.incrementalCache?.requestProtocol || 'https'\n+    const proto =\n+      getRequestMeta(req, 'initProtocol')?.replace(/:+$/, '') || 'https'\n \n     // For standalone or the serverful mode, use the internal origin directly\n     // other than the host headers from the request.\n@@ -616,8 +618,7 @@ export async function handleAction({\n           res,\n           host,\n           forwardedWorker,\n-          ctx.renderOpts.basePath,\n-          workStore\n+          ctx.renderOpts.basePath\n         ),\n       }\n     }"
        },
        {
            "sha": "75b3442fbe9a1a4cd4663b764161cd6199c528ed",
            "filename": "packages/next/src/server/app-render/types.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/256cd5b571b770476755515ad1bdc976b43a258d/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Ftypes.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/256cd5b571b770476755515ad1bdc976b43a258d/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Ftypes.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Ftypes.ts?ref=256cd5b571b770476755515ad1bdc976b43a258d",
            "patch": "@@ -202,6 +202,8 @@ export interface RenderOptsPartial {\n   cacheLifeProfiles?: {\n     [profile: string]: import('../use-cache/cache-life').CacheLife\n   }\n+  isOnDemandRevalidate?: boolean\n+  isPossibleServerAction?: boolean\n   setIsrStatus?: (key: string, value: boolean | null) => void\n   isRevalidate?: boolean\n   nextExport?: boolean"
        },
        {
            "sha": "56cce7d5b741f7eb751db8f84f92f6bf402f9a26",
            "filename": "packages/next/src/server/base-server.ts",
            "status": "modified",
            "additions": 68,
            "deletions": 81,
            "changes": 149,
            "blob_url": "https://github.com/vercel/next.js/blob/256cd5b571b770476755515ad1bdc976b43a258d/packages%2Fnext%2Fsrc%2Fserver%2Fbase-server.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/256cd5b571b770476755515ad1bdc976b43a258d/packages%2Fnext%2Fsrc%2Fserver%2Fbase-server.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fbase-server.ts?ref=256cd5b571b770476755515ad1bdc976b43a258d",
            "patch": "@@ -121,10 +121,7 @@ import { getTracer, isBubbledError, SpanKind } from './lib/trace/tracer'\n import { BaseServerSpan } from './lib/trace/constants'\n import { I18NProvider } from './lib/i18n-provider'\n import { sendResponse } from './send-response'\n-import {\n-  fromNodeOutgoingHttpHeaders,\n-  normalizeNextQueryParam,\n-} from './web/utils'\n+import { normalizeNextQueryParam } from './web/utils'\n import {\n   CACHE_ONE_YEAR,\n   MATCHED_PATH_HEADER,\n@@ -169,6 +166,7 @@ import {\n } from './lib/streaming-metadata'\n import { InvariantError } from '../shared/lib/invariant-error'\n import { decodeQueryPathParameter } from './lib/decode-query-path-parameter'\n+import { NoFallbackError } from '../shared/lib/no-fallback-error.external'\n import { getCacheHandlers } from './use-cache/handlers'\n import { fixMojibake } from './lib/fix-mojibake'\n import { computeCacheBustingSearchParam } from '../shared/lib/router/utils/cache-busting-search-param'\n@@ -302,8 +300,6 @@ export type RequestContext<\n   renderOpts: RenderOpts\n }\n \n-export class NoFallbackError extends Error {}\n-\n // Internal wrapper around build errors at development\n // time, to prevent us from propagating or logging them\n export class WrappedBuildError extends Error {\n@@ -417,7 +413,6 @@ export default abstract class Server<\n \n   protected abstract getIncrementalCache(options: {\n     requestHeaders: Record<string, undefined | string | string[]>\n-    requestProtocol: 'http' | 'https'\n   }): Promise<import('./lib/incremental-cache').IncrementalCache>\n \n   protected abstract getResponseCache(options: {\n@@ -1452,21 +1447,8 @@ export default abstract class Server<\n         !(this.serverOptions as any).webServerConfig &&\n         !getRequestMeta(req, 'incrementalCache')\n       ) {\n-        let protocol: 'http:' | 'https:' = 'https:'\n-\n-        try {\n-          const parsedFullUrl = new URL(\n-            getRequestMeta(req, 'initURL') || '/',\n-            'http://n'\n-          )\n-          protocol = parsedFullUrl.protocol as 'https:' | 'http:'\n-        } catch {}\n-\n         const incrementalCache = await this.getIncrementalCache({\n           requestHeaders: Object.assign({}, req.headers),\n-          requestProtocol: protocol.substring(0, protocol.length - 1) as\n-            | 'http'\n-            | 'https',\n         })\n \n         incrementalCache.resetRequestCache()\n@@ -2495,15 +2477,6 @@ export default abstract class Server<\n       ssgCacheKey =\n         ssgCacheKey === '/index' && pathname === '/' ? '/' : ssgCacheKey\n     }\n-    let protocol: 'http:' | 'https:' = 'https:'\n-\n-    try {\n-      const parsedFullUrl = new URL(\n-        getRequestMeta(req, 'initURL') || '/',\n-        'http://n'\n-      )\n-      protocol = parsedFullUrl.protocol as 'https:' | 'http:'\n-    } catch {}\n \n     // use existing incrementalCache instance if available\n     const incrementalCache: import('./lib/incremental-cache').IncrementalCache =\n@@ -2512,9 +2485,6 @@ export default abstract class Server<\n         ? (globalThis as any).__incrementalCache\n         : await this.getIncrementalCache({\n             requestHeaders: Object.assign({}, req.headers),\n-            requestProtocol: protocol.substring(0, protocol.length - 1) as\n-              | 'http'\n-              | 'https',\n           })\n \n     // TODO: investigate, this is not safe across multiple concurrent requests\n@@ -2667,26 +2637,20 @@ export default abstract class Server<\n             const parsedInitUrl = parseUrl(\n               getRequestMeta(req, 'initURL') || req.url\n             )\n-            request.url =\n-              req.url = `${parsedInitUrl.pathname}${parsedInitUrl.search || ''}`\n+            request.url = `${parsedInitUrl.pathname}${parsedInitUrl.search || ''}`\n \n             // propagate the request context for dev\n             setRequestMeta(request, getRequestMeta(req))\n-            addRequestMeta(request, 'postponed', postponed)\n             addRequestMeta(request, 'projectDir', this.dir)\n             addRequestMeta(request, 'isIsrFallback', pagesFallback)\n-            addRequestMeta(\n-              request,\n-              'renderFallbackShell',\n-              Boolean(fallbackRouteParams)\n-            )\n             addRequestMeta(request, 'query', query)\n             addRequestMeta(request, 'params', opts.params)\n             addRequestMeta(\n               request,\n               'ampValidator',\n               this.renderOpts.ampValidator\n             )\n+            addRequestMeta(request, 'minimalMode', this.minimalMode)\n \n             if (renderOpts.err) {\n               addRequestMeta(request, 'invokeError', renderOpts.err)\n@@ -2700,20 +2664,35 @@ export default abstract class Server<\n               }\n             ) => Promise<RenderResult> = components.ComponentMod.handler\n \n-            result = await handler(request, response, {\n+            const maybeDevRequest =\n+              // we need to capture fetch metrics when they are set\n+              // and can't wait for handler to resolve as the fetch\n+              // metrics are logged on response close which happens\n+              // before handler resolves\n+              process.env.NODE_ENV === 'development'\n+                ? new Proxy(request, {\n+                    get(target: any, prop) {\n+                      if (typeof target[prop] === 'function') {\n+                        return target[prop].bind(target)\n+                      }\n+                      return target[prop]\n+                    },\n+                    set(target: any, prop, value) {\n+                      if (prop === 'fetchMetrics') {\n+                        ;(req as any).fetchMetrics = value\n+                      }\n+                      target[prop] = value\n+                      return true\n+                    },\n+                  })\n+                : request\n+\n+            result = await handler(maybeDevRequest, response, {\n               waitUntil: this.getWaitUntil(),\n             })\n \n-            // this is handled fully in handler\n-            if (isAppRouteRouteModule(routeModule)) {\n-              return result as any as ResponseCacheEntry | null\n-            }\n-\n-            if (!result) {\n-              throw new Error(\n-                `Invariant: missing result from invoking ${pathname} handler`\n-              )\n-            }\n+            // response is handled fully in handler\n+            return null\n           } else {\n             if (isPagesRouteModule(routeModule)) {\n               // Due to the way we pass data by mutating `renderOpts`, we can't extend\n@@ -3073,7 +3052,7 @@ export default abstract class Server<\n             }\n           )\n         }\n-        // If this is a app router page, PPR is enabled, and PFPR is also\n+        // If this is a app router page, PPR is enabled, and PPR is also\n         // enabled, then we should use the fallback renderer.\n         else if (\n           isRoutePPREnabled &&\n@@ -3164,6 +3143,34 @@ export default abstract class Server<\n       })\n     }\n \n+    if (\n+      process.env.NEXT_RUNTIME !== 'edge' &&\n+      // default _error module in dev doesn't have handler yet\n+      components.ComponentMod.handler &&\n+      (isPagesRouteModule(components.routeModule) ||\n+        isAppRouteRouteModule(components.routeModule) ||\n+        isAppPageRouteModule(components.routeModule))\n+    ) {\n+      if (\n+        routeModule?.isDev &&\n+        isDynamicRoute(pathname) &&\n+        (components.getStaticPaths || isAppPath)\n+      ) {\n+        await this.getStaticPaths({\n+          pathname,\n+          requestHeaders: req.headers,\n+          page: components.page,\n+          isAppPath,\n+        })\n+      }\n+      await doRender({\n+        postponed: undefined,\n+        pagesFallback: false,\n+        fallbackRouteParams: null,\n+      })\n+      return null\n+    }\n+\n     const cacheEntry = await this.responseCache.get(\n       ssgCacheKey,\n       responseGenerator,\n@@ -3188,7 +3195,13 @@ export default abstract class Server<\n     }\n \n     if (!cacheEntry) {\n-      if (ssgCacheKey && !(isOnDemandRevalidate && revalidateOnlyGenerated)) {\n+      if (\n+        ssgCacheKey &&\n+        !(isOnDemandRevalidate && revalidateOnlyGenerated) &&\n+        !isPagesRouteModule(components.routeModule) &&\n+        !isAppRouteRouteModule(components.routeModule) &&\n+        !isAppPageRouteModule(components.routeModule)\n+      ) {\n         // A cache entry might not be generated if a response is written\n         // in `getInitialProps` or `getServerSideProps`, but those shouldn't\n         // have a cache key. If we do have a cache key but we don't end up\n@@ -3443,34 +3456,8 @@ export default abstract class Server<\n         return null\n       }\n     } else if (cachedData.kind === CachedRouteKind.APP_ROUTE) {\n-      const headers = fromNodeOutgoingHttpHeaders(cachedData.headers)\n-\n-      if (!(this.minimalMode && isSSG)) {\n-        headers.delete(NEXT_CACHE_TAGS_HEADER)\n-      }\n-\n-      // If cache control is already set on the response we don't\n-      // override it to allow users to customize it via next.config\n-      if (\n-        cacheEntry.cacheControl &&\n-        !res.getHeader('Cache-Control') &&\n-        !headers.get('Cache-Control')\n-      ) {\n-        headers.set(\n-          'Cache-Control',\n-          getCacheControlHeader(cacheEntry.cacheControl)\n-        )\n-      }\n-\n-      await sendResponse(\n-        req,\n-        res,\n-        new Response(cachedData.body, {\n-          headers,\n-          status: cachedData.status || 200,\n-        })\n-      )\n-      return null\n+      // this is handled inside the app_route handler fully\n+      throw new Error(`Invariant: unexpected APP_ROUTE cache data`)\n     } else if (cachedData.kind === CachedRouteKind.APP_PAGE) {\n       // If the request has a postponed state and it's a resume request we\n       // should error."
        },
        {
            "sha": "2137b2f95cbd815bad3d394f130f97e1dad4e5b9",
            "filename": "packages/next/src/server/dev/next-dev-server.ts",
            "status": "modified",
            "additions": 31,
            "deletions": 2,
            "changes": 33,
            "blob_url": "https://github.com/vercel/next.js/blob/256cd5b571b770476755515ad1bdc976b43a258d/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fnext-dev-server.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/256cd5b571b770476755515ad1bdc976b43a258d/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fnext-dev-server.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fnext-dev-server.ts?ref=256cd5b571b770476755515ad1bdc976b43a258d",
            "patch": "@@ -33,6 +33,7 @@ import {\n   PAGES_MANIFEST,\n   APP_PATHS_MANIFEST,\n   COMPILER_NAMES,\n+  PRERENDER_MANIFEST,\n } from '../../shared/lib/constants'\n import Server, { WrappedBuildError } from '../next-server'\n import { normalizePagePath } from '../../shared/lib/page-path/normalize-page-path'\n@@ -67,12 +68,13 @@ import { decorateServerError } from '../../shared/lib/error-source'\n import type { ServerOnInstrumentationRequestError } from '../app-render/types'\n import type { ServerComponentsHmrCache } from '../response-cache'\n import { logRequests } from './log-requests'\n-import { FallbackMode } from '../../lib/fallback'\n+import { FallbackMode, fallbackModeToFallbackField } from '../../lib/fallback'\n import type { PagesDevOverlayBridgeType } from '../../client/components/react-dev-overlay/pages/pages-dev-overlay-setup'\n import {\n   ensureInstrumentationRegistered,\n   getInstrumentationModule,\n } from '../lib/router-utils/instrumentation-globals.external'\n+import type { PrerenderManifest } from '../../build'\n \n // Load ReactDevOverlay only when needed\n let PagesDevOverlayBridgeImpl: PagesDevOverlayBridgeType\n@@ -848,9 +850,10 @@ export default class DevServer extends Server {\n       `staticPaths-${pathname}`,\n       []\n     )\n-      .then((res) => {\n+      .then(async (res) => {\n         const { prerenderedRoutes: staticPaths, fallbackMode: fallback } =\n           res.value\n+\n         if (!isAppPath && this.nextConfig.output === 'export') {\n           if (fallback === FallbackMode.BLOCKING_STATIC_RENDER) {\n             throw new Error(\n@@ -870,6 +873,32 @@ export default class DevServer extends Server {\n           staticPaths: staticPaths?.map((route) => route.pathname),\n           fallbackMode: fallback,\n         }\n+\n+        if (res.value?.fallbackMode !== undefined) {\n+          // we write the static paths to partial manifest for\n+          // fallback handling inside of entry handler's\n+          const rawExistingManifest = await fs.promises.readFile(\n+            pathJoin(this.distDir, PRERENDER_MANIFEST),\n+            'utf8'\n+          )\n+          const existingManifest: PrerenderManifest =\n+            JSON.parse(rawExistingManifest)\n+          for (const staticPath of value.staticPaths || []) {\n+            existingManifest.routes[staticPath] = {} as any\n+          }\n+          existingManifest.dynamicRoutes[pathname] = {\n+            fallback: fallbackModeToFallbackField(res.value.fallbackMode, page),\n+          } as any\n+\n+          const updatedManifest = JSON.stringify(existingManifest)\n+\n+          if (updatedManifest !== rawExistingManifest) {\n+            await fs.promises.writeFile(\n+              pathJoin(this.distDir, PRERENDER_MANIFEST),\n+              updatedManifest\n+            )\n+          }\n+        }\n         this.staticPathsCache.set(pathname, value)\n         return value\n       })"
        },
        {
            "sha": "7d44e9f0831a054aeb841aa2ebe60b7814c310de",
            "filename": "packages/next/src/server/lib/incremental-cache/index.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 4,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/256cd5b571b770476755515ad1bdc976b43a258d/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fincremental-cache%2Findex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/256cd5b571b770476755515ad1bdc976b43a258d/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fincremental-cache%2Findex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fincremental-cache%2Findex.ts?ref=256cd5b571b770476755515ad1bdc976b43a258d",
            "patch": "@@ -85,7 +85,6 @@ export class IncrementalCache implements IncrementalCacheType {\n   readonly hasCustomCacheHandler: boolean\n   readonly prerenderManifest: DeepReadonly<PrerenderManifest>\n   readonly requestHeaders: Record<string, undefined | string | string[]>\n-  readonly requestProtocol?: 'http' | 'https'\n   readonly allowedRevalidateHeaderKeys?: string[]\n   readonly minimalMode?: boolean\n   readonly fetchCacheKeyPrefix?: string\n@@ -107,7 +106,6 @@ export class IncrementalCache implements IncrementalCacheType {\n     minimalMode,\n     serverDistDir,\n     requestHeaders,\n-    requestProtocol,\n     maxMemoryCacheSize,\n     getPrerenderManifest,\n     fetchCacheKeyPrefix,\n@@ -119,7 +117,6 @@ export class IncrementalCache implements IncrementalCacheType {\n     minimalMode?: boolean\n     serverDistDir?: string\n     flushToDisk?: boolean\n-    requestProtocol?: 'http' | 'https'\n     allowedRevalidateHeaderKeys?: string[]\n     requestHeaders: IncrementalCache['requestHeaders']\n     maxMemoryCacheSize?: number\n@@ -166,7 +163,6 @@ export class IncrementalCache implements IncrementalCacheType {\n     const minimalModeKey = 'minimalMode'\n     this[minimalModeKey] = minimalMode\n     this.requestHeaders = requestHeaders\n-    this.requestProtocol = requestProtocol\n     this.allowedRevalidateHeaderKeys = allowedRevalidateHeaderKeys\n     this.prerenderManifest = getPrerenderManifest()\n     this.cacheControls = new SharedCacheControls(this.prerenderManifest)"
        },
        {
            "sha": "8f4c196cdb7530aadb23ab8e0046f2d595485304",
            "filename": "packages/next/src/server/lib/router-server.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/256cd5b571b770476755515ad1bdc976b43a258d/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-server.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/256cd5b571b770476755515ad1bdc976b43a258d/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-server.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-server.ts?ref=256cd5b571b770476755515ad1bdc976b43a258d",
            "patch": "@@ -23,7 +23,6 @@ import { addRequestMeta, getRequestMeta } from '../request-meta'\n import { pathHasPrefix } from '../../shared/lib/router/utils/path-has-prefix'\n import { removePathPrefix } from '../../shared/lib/router/utils/remove-path-prefix'\n import setupCompression from 'next/dist/compiled/compression'\n-import { NoFallbackError } from '../base-server'\n import { signalFromNodeResponse } from '../web/spec-extension/adapters/next-request'\n import { isPostpone } from './router-utils/is-postpone'\n import { parseUrl as parseUrlUtil } from '../../shared/lib/router/utils/parse-url'\n@@ -51,6 +50,7 @@ import type { ServerInitResult } from './render-server'\n import { filterInternalHeaders } from './server-ipc/utils'\n import { blockCrossSite } from './router-utils/block-cross-site'\n import { traceGlobals } from '../../trace/shared'\n+import { NoFallbackError } from '../../shared/lib/no-fallback-error.external'\n import {\n   RouterServerContextSymbol,\n   routerServerGlobal,\n@@ -686,10 +686,11 @@ export async function initialize(opts: {\n     nextConfig: config,\n     hostname: handlers.server.hostname,\n     revalidate: handlers.server.revalidate.bind(handlers.server),\n+    render404: handlers.server.render404.bind(handlers.server),\n     experimentalTestProxy: renderServerOpts.experimentalTestProxy,\n     logErrorWithOriginalStack: opts.dev\n       ? handlers.server.logErrorWithOriginalStack.bind(handlers.server)\n-      : (err: unknown) => Log.error(err),\n+      : (err: unknown) => !opts.quiet && Log.error(err),\n     setIsrStatus: devBundlerService?.setIsrStatus.bind(devBundlerService),\n   }\n "
        },
        {
            "sha": "bb2aa2ab004a7106e6d6afae94d6ec1dffcae3a6",
            "filename": "packages/next/src/server/lib/router-utils/resolve-routes.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/256cd5b571b770476755515ad1bdc976b43a258d/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Fresolve-routes.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/256cd5b571b770476755515ad1bdc976b43a258d/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Fresolve-routes.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Fresolve-routes.ts?ref=256cd5b571b770476755515ad1bdc976b43a258d",
            "patch": "@@ -251,7 +251,7 @@ export function getResolveRoutes(\n     }\n \n     async function checkTrue() {\n-      const pathname = parsedUrl.pathname || ''\n+      const pathname = parsedUrl.pathname || '/'\n \n       if (checkLocaleApi(pathname)) {\n         return\n@@ -435,7 +435,7 @@ export function getResolveRoutes(\n         }\n \n         if (route.name === 'check_fs') {\n-          const pathname = parsedUrl.pathname || ''\n+          const pathname = parsedUrl.pathname || '/'\n \n           if (invokedOutputs?.has(pathname) || checkLocaleApi(pathname)) {\n             return"
        },
        {
            "sha": "a38c2251989064e92a413c305fba26e090766472",
            "filename": "packages/next/src/server/lib/router-utils/router-server-context.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/256cd5b571b770476755515ad1bdc976b43a258d/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Frouter-server-context.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/256cd5b571b770476755515ad1bdc976b43a258d/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Frouter-server-context.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Frouter-server-context.ts?ref=256cd5b571b770476755515ad1bdc976b43a258d",
            "patch": "@@ -1,4 +1,6 @@\n+import type { IncomingMessage, ServerResponse } from 'node:http'\n import type { NextConfigComplete } from '../../config-shared'\n+import type { UrlWithParsedQuery } from 'node:url'\n \n export type RevalidateFn = (config: {\n   urlPath: string\n@@ -19,6 +21,13 @@ export type RouterServerContext = Record<\n     // revalidate function to bypass going through network\n     // to invoke revalidate request (uses mocked req/res)\n     revalidate?: RevalidateFn\n+    // function to render the 404 page\n+    render404?: (\n+      req: IncomingMessage,\n+      res: ServerResponse,\n+      parsedUrl?: UrlWithParsedQuery,\n+      setHeaders?: boolean\n+    ) => Promise<void>\n     // current loaded public runtime config\n     publicRuntimeConfig?: NextConfigComplete['publicRuntimeConfig']\n     // exposing nextConfig for dev mode specifically"
        },
        {
            "sha": "5a5230439940a20af01ba682d60b4431e4f2cf2d",
            "filename": "packages/next/src/server/next-server.ts",
            "status": "modified",
            "additions": 20,
            "deletions": 5,
            "changes": 25,
            "blob_url": "https://github.com/vercel/next.js/blob/256cd5b571b770476755515ad1bdc976b43a258d/packages%2Fnext%2Fsrc%2Fserver%2Fnext-server.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/256cd5b571b770476755515ad1bdc976b43a258d/packages%2Fnext%2Fsrc%2Fserver%2Fnext-server.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fnext-server.ts?ref=256cd5b571b770476755515ad1bdc976b43a258d",
            "patch": "@@ -25,7 +25,7 @@ import type { CacheControl } from './lib/cache-control'\n import type { WaitUntil } from './after/builtin-request-context'\n \n import fs from 'fs'\n-import { join } from 'path'\n+import { join, relative } from 'path'\n import { getRouteMatcher } from '../shared/lib/router/utils/route-matcher'\n import { addRequestMeta, getRequestMeta } from './request-meta'\n import {\n@@ -58,7 +58,7 @@ import type {\n   NextEnabledDirectories,\n   BaseRequestHandler,\n } from './base-server'\n-import BaseServer, { NoFallbackError } from './base-server'\n+import BaseServer from './base-server'\n import { getMaybePagePath, getPagePath } from './require'\n import { denormalizePagePath } from '../shared/lib/page-path/denormalize-page-path'\n import { normalizePagePath } from '../shared/lib/page-path/normalize-page-path'\n@@ -110,10 +110,15 @@ import type { UnwrapPromise } from '../lib/coalesced-function'\n import { populateStaticEnv } from '../lib/static-env'\n import { isPostpone } from './lib/router-utils/is-postpone'\n import { NodeModuleLoader } from './lib/module-loader/node-module-loader'\n+import { NoFallbackError } from '../shared/lib/no-fallback-error.external'\n import {\n   ensureInstrumentationRegistered,\n   getInstrumentationModule,\n } from './lib/router-utils/instrumentation-globals.external'\n+import {\n+  RouterServerContextSymbol,\n+  routerServerGlobal,\n+} from './lib/router-utils/router-server-context'\n \n export * from './base-server'\n \n@@ -493,10 +498,8 @@ export default class NextNodeServer extends BaseServer<\n \n   protected async getIncrementalCache({\n     requestHeaders,\n-    requestProtocol,\n   }: {\n     requestHeaders: IncrementalCache['requestHeaders']\n-    requestProtocol: 'http' | 'https'\n   }) {\n     const dev = !!this.renderOpts.dev\n     let CacheHandler: any\n@@ -519,7 +522,6 @@ export default class NextNodeServer extends BaseServer<\n       fs: this.getCacheFilesystem(),\n       dev,\n       requestHeaders,\n-      requestProtocol,\n       allowedRevalidateHeaderKeys:\n         this.nextConfig.experimental.allowedRevalidateHeaderKeys,\n       minimalMode: this.minimalMode,\n@@ -1097,6 +1099,19 @@ export default class NextNodeServer extends BaseServer<\n     // such.\n     addRequestMeta(req, 'bubbleNoFallback', true)\n \n+    // TODO: this is only needed until route-module can handle\n+    // rendering/serving the 404 directly with next-server\n+    if (!routerServerGlobal[RouterServerContextSymbol]) {\n+      routerServerGlobal[RouterServerContextSymbol] = {}\n+    }\n+    const relativeProjectDir = relative(process.cwd(), this.dir)\n+\n+    if (!routerServerGlobal[RouterServerContextSymbol][relativeProjectDir]) {\n+      routerServerGlobal[RouterServerContextSymbol][relativeProjectDir] = {\n+        render404: this.render404.bind(this),\n+      }\n+    }\n+\n     try {\n       // next.js core assumes page path without trailing slash\n       pathname = removeTrailingSlash(pathname)"
        },
        {
            "sha": "6f572cef878c779dd8cb4cf64fe77975b73b5736",
            "filename": "packages/next/src/server/request-meta.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/256cd5b571b770476755515ad1bdc976b43a258d/packages%2Fnext%2Fsrc%2Fserver%2Frequest-meta.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/256cd5b571b770476755515ad1bdc976b43a258d/packages%2Fnext%2Fsrc%2Fserver%2Frequest-meta.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest-meta.ts?ref=256cd5b571b770476755515ad1bdc976b43a258d",
            "patch": "@@ -225,6 +225,12 @@ export interface RequestMeta {\n    * ErrorOverlay component to use in development for pages router\n    */\n   PagesErrorDebug?: PagesDevOverlayBridgeType\n+\n+  /**\n+   * Whether server is in minimal mode (this will be replaced with more\n+   * specific flags in future)\n+   */\n+  minimalMode?: boolean\n }\n \n /**"
        },
        {
            "sha": "45beebdd80513fe7475294bb352fd9f7fc191341",
            "filename": "packages/next/src/server/response-cache/index.ts",
            "status": "modified",
            "additions": 119,
            "deletions": 108,
            "changes": 227,
            "blob_url": "https://github.com/vercel/next.js/blob/256cd5b571b770476755515ad1bdc976b43a258d/packages%2Fnext%2Fsrc%2Fserver%2Fresponse-cache%2Findex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/256cd5b571b770476755515ad1bdc976b43a258d/packages%2Fnext%2Fsrc%2Fserver%2Fresponse-cache%2Findex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fresponse-cache%2Findex.ts?ref=256cd5b571b770476755515ad1bdc976b43a258d",
            "patch": "@@ -39,13 +39,13 @@ export default class ResponseCache implements ResponseCacheBase {\n     expiresAt: number\n   }\n \n-  private minimalMode?: boolean\n+  // we don't use minimal_mode name here as this.minimal_mode is\n+  // statically replace for server runtimes but we need it to\n+  // be dynamic here\n+  private minimal_mode?: boolean\n \n-  constructor(minimalMode: boolean) {\n-    // this is a hack to avoid Webpack knowing this is equal to this.minimalMode\n-    // because we replace this.minimalMode to true in production bundles.\n-    const minimalModeKey = 'minimalMode'\n-    this[minimalModeKey] = minimalMode\n+  constructor(minimal_mode: boolean) {\n+    this.minimal_mode = minimal_mode\n   }\n \n   public async get(\n@@ -58,6 +58,7 @@ export default class ResponseCache implements ResponseCacheBase {\n       incrementalCache: IncrementalResponseCache\n       isRoutePPREnabled?: boolean\n       isFallback?: boolean\n+      waitUntil?: (prom: Promise<any>) => void\n     }\n   ): Promise<ResponseCacheEntry | null> {\n     // If there is no key for the cache, we can't possibly look this up in the\n@@ -71,130 +72,140 @@ export default class ResponseCache implements ResponseCacheBase {\n       isOnDemandRevalidate = false,\n       isFallback = false,\n       isRoutePPREnabled = false,\n+      waitUntil,\n     } = context\n \n     const response = await this.batcher.batch(\n       { key, isOnDemandRevalidate },\n-      async (cacheKey, resolve) => {\n-        // We keep the previous cache entry around to leverage when the\n-        // incremental cache is disabled in minimal mode.\n-        if (\n-          this.minimalMode &&\n-          this.previousCacheItem?.key === cacheKey &&\n-          this.previousCacheItem.expiresAt > Date.now()\n-        ) {\n-          return this.previousCacheItem.entry\n-        }\n-\n-        // Coerce the kindHint into a given kind for the incremental cache.\n-        const kind = routeKindToIncrementalCacheKind(context.routeKind)\n+      (cacheKey, resolve) => {\n+        const prom = (async () => {\n+          // We keep the previous cache entry around to leverage when the\n+          // incremental cache is disabled in minimal mode.\n+          if (\n+            this.minimal_mode &&\n+            this.previousCacheItem?.key === cacheKey &&\n+            this.previousCacheItem.expiresAt > Date.now()\n+          ) {\n+            return this.previousCacheItem.entry\n+          }\n \n-        let resolved = false\n-        let cachedResponse: IncrementalResponseCacheEntry | null = null\n-        try {\n-          cachedResponse = !this.minimalMode\n-            ? await incrementalCache.get(key, {\n-                kind,\n-                isRoutePPREnabled: context.isRoutePPREnabled,\n-                isFallback,\n-              })\n-            : null\n+          // Coerce the kindHint into a given kind for the incremental cache.\n+          const kind = routeKindToIncrementalCacheKind(context.routeKind)\n+\n+          let resolved = false\n+          let cachedResponse: IncrementalResponseCacheEntry | null = null\n+          try {\n+            cachedResponse = !this.minimal_mode\n+              ? await incrementalCache.get(key, {\n+                  kind,\n+                  isRoutePPREnabled: context.isRoutePPREnabled,\n+                  isFallback,\n+                })\n+              : null\n+\n+            if (cachedResponse && !isOnDemandRevalidate) {\n+              resolve(cachedResponse)\n+              resolved = true\n+\n+              if (!cachedResponse.isStale || context.isPrefetch) {\n+                // The cached value is still valid, so we don't need\n+                // to update it yet.\n+                return null\n+              }\n+            }\n \n-          if (cachedResponse && !isOnDemandRevalidate) {\n-            resolve(cachedResponse)\n-            resolved = true\n+            const cacheEntry = await responseGenerator({\n+              hasResolved: resolved,\n+              previousCacheEntry: cachedResponse,\n+              isRevalidating: true,\n+            })\n \n-            if (!cachedResponse.isStale || context.isPrefetch) {\n-              // The cached value is still valid, so we don't need\n-              // to update it yet.\n+            // If the cache entry couldn't be generated, we don't want to cache\n+            // the result.\n+            if (!cacheEntry) {\n+              // Unset the previous cache item if it was set.\n+              if (this.minimal_mode) this.previousCacheItem = undefined\n               return null\n             }\n-          }\n \n-          const cacheEntry = await responseGenerator({\n-            hasResolved: resolved,\n-            previousCacheEntry: cachedResponse,\n-            isRevalidating: true,\n-          })\n-\n-          // If the cache entry couldn't be generated, we don't want to cache\n-          // the result.\n-          if (!cacheEntry) {\n-            // Unset the previous cache item if it was set.\n-            if (this.minimalMode) this.previousCacheItem = undefined\n-            return null\n-          }\n-\n-          const resolveValue = await fromResponseCacheEntry({\n-            ...cacheEntry,\n-            isMiss: !cachedResponse,\n-          })\n-          if (!resolveValue) {\n-            // Unset the previous cache item if it was set.\n-            if (this.minimalMode) this.previousCacheItem = undefined\n-            return null\n-          }\n+            const resolveValue = await fromResponseCacheEntry({\n+              ...cacheEntry,\n+              isMiss: !cachedResponse,\n+            })\n+            if (!resolveValue) {\n+              // Unset the previous cache item if it was set.\n+              if (this.minimal_mode) this.previousCacheItem = undefined\n+              return null\n+            }\n \n-          // For on-demand revalidate wait to resolve until cache is set.\n-          // Otherwise resolve now.\n-          if (!isOnDemandRevalidate && !resolved) {\n-            resolve(resolveValue)\n-            resolved = true\n-          }\n+            // For on-demand revalidate wait to resolve until cache is set.\n+            // Otherwise resolve now.\n+            if (!isOnDemandRevalidate && !resolved) {\n+              resolve(resolveValue)\n+              resolved = true\n+            }\n \n-          // We want to persist the result only if it has a cache control value\n-          // defined.\n-          if (resolveValue.cacheControl) {\n-            if (this.minimalMode) {\n-              this.previousCacheItem = {\n-                key: cacheKey,\n-                entry: resolveValue,\n-                expiresAt: Date.now() + 1000,\n+            // We want to persist the result only if it has a cache control value\n+            // defined.\n+            if (resolveValue.cacheControl) {\n+              if (this.minimal_mode) {\n+                this.previousCacheItem = {\n+                  key: cacheKey,\n+                  entry: resolveValue,\n+                  expiresAt: Date.now() + 1000,\n+                }\n+              } else {\n+                await incrementalCache.set(key, resolveValue.value, {\n+                  cacheControl: resolveValue.cacheControl,\n+                  isRoutePPREnabled,\n+                  isFallback,\n+                })\n               }\n-            } else {\n-              await incrementalCache.set(key, resolveValue.value, {\n-                cacheControl: resolveValue.cacheControl,\n+            }\n+\n+            return resolveValue\n+          } catch (err) {\n+            // When a path is erroring we automatically re-set the existing cache\n+            // with new revalidate and expire times to prevent non-stop retrying.\n+            if (cachedResponse?.cacheControl) {\n+              const newRevalidate = Math.min(\n+                Math.max(cachedResponse.cacheControl.revalidate || 3, 3),\n+                30\n+              )\n+\n+              const newExpire =\n+                cachedResponse.cacheControl.expire === undefined\n+                  ? undefined\n+                  : Math.max(\n+                      newRevalidate + 3,\n+                      cachedResponse.cacheControl.expire\n+                    )\n+\n+              await incrementalCache.set(key, cachedResponse.value, {\n+                cacheControl: { revalidate: newRevalidate, expire: newExpire },\n                 isRoutePPREnabled,\n                 isFallback,\n               })\n             }\n-          }\n \n-          return resolveValue\n-        } catch (err) {\n-          // When a path is erroring we automatically re-set the existing cache\n-          // with new revalidate and expire times to prevent non-stop retrying.\n-          if (cachedResponse?.cacheControl) {\n-            const newRevalidate = Math.min(\n-              Math.max(cachedResponse.cacheControl.revalidate || 3, 3),\n-              30\n-            )\n-\n-            const newExpire =\n-              cachedResponse.cacheControl.expire === undefined\n-                ? undefined\n-                : Math.max(\n-                    newRevalidate + 3,\n-                    cachedResponse.cacheControl.expire\n-                  )\n-\n-            await incrementalCache.set(key, cachedResponse.value, {\n-              cacheControl: { revalidate: newRevalidate, expire: newExpire },\n-              isRoutePPREnabled,\n-              isFallback,\n-            })\n-          }\n+            // While revalidating in the background we can't reject as we already\n+            // resolved the cache entry so log the error here.\n+            if (resolved) {\n+              console.error(err)\n+              return null\n+            }\n \n-          // While revalidating in the background we can't reject as we already\n-          // resolved the cache entry so log the error here.\n-          if (resolved) {\n-            console.error(err)\n-            return null\n+            // We haven't resolved yet, so let's throw to indicate an error.\n+            throw err\n           }\n+        })()\n \n-          // We haven't resolved yet, so let's throw to indicate an error.\n-          throw err\n+        // we need to ensure background revalidates are\n+        // passed to waitUntil\n+        if (waitUntil) {\n+          waitUntil(prom)\n         }\n+        return prom\n       }\n     )\n "
        },
        {
            "sha": "fc2478bf93d2fad7ca9105ada05b8374be603b82",
            "filename": "packages/next/src/server/response-cache/types.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/256cd5b571b770476755515ad1bdc976b43a258d/packages%2Fnext%2Fsrc%2Fserver%2Fresponse-cache%2Ftypes.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/256cd5b571b770476755515ad1bdc976b43a258d/packages%2Fnext%2Fsrc%2Fserver%2Fresponse-cache%2Ftypes.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fresponse-cache%2Ftypes.ts?ref=256cd5b571b770476755515ad1bdc976b43a258d",
            "patch": "@@ -187,6 +187,7 @@ export type ResponseGenerator = (state: {\n   hasResolved: boolean\n   previousCacheEntry?: IncrementalResponseCacheEntry | null\n   isRevalidating?: boolean\n+  span?: any\n }) => Promise<ResponseCacheEntry | null>\n \n export const enum IncrementalCacheKind {"
        },
        {
            "sha": "0a1be7c6676e45c17f4ac113c6b9cf3e3490e1a6",
            "filename": "packages/next/src/server/route-modules/app-route/module.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/256cd5b571b770476755515ad1bdc976b43a258d/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Fapp-route%2Fmodule.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/256cd5b571b770476755515ad1bdc976b43a258d/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Fapp-route%2Fmodule.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Fapp-route%2Fmodule.ts?ref=256cd5b571b770476755515ad1bdc976b43a258d",
            "patch": "@@ -724,6 +724,14 @@ export class AppRouteRouteModule extends RouteModule<\n               case 'force-dynamic': {\n                 // Routes of generated paths should be dynamic\n                 workStore.forceDynamic = true\n+                if (workStore.isStaticGeneration) {\n+                  const err = new DynamicServerError(\n+                    'Route is configured with dynamic = error which cannot be statically generated.'\n+                  )\n+                  workStore.dynamicUsageDescription = err.message\n+                  workStore.dynamicUsageStack = err.stack\n+                  throw err\n+                }\n                 break\n               }\n               case 'force-static':"
        },
        {
            "sha": "02c0ca226928623a5332843da1adfa0ab2ee57cd",
            "filename": "packages/next/src/server/route-modules/route-module.ts",
            "status": "modified",
            "additions": 241,
            "deletions": 15,
            "changes": 256,
            "blob_url": "https://github.com/vercel/next.js/blob/256cd5b571b770476755515ad1bdc976b43a258d/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Froute-module.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/256cd5b571b770476755515ad1bdc976b43a258d/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Froute-module.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Froute-module.ts?ref=256cd5b571b770476755515ad1bdc976b43a258d",
            "patch": "@@ -1,5 +1,8 @@\n import type { IncomingMessage, ServerResponse } from 'node:http'\n-import type { InstrumentationOnRequestError } from '../instrumentation/types'\n+import type {\n+  InstrumentationOnRequestError,\n+  RequestErrorContext,\n+} from '../instrumentation/types'\n import type { ParsedUrlQuery } from 'node:querystring'\n import type { UrlWithParsedQuery } from 'node:url'\n import type {\n@@ -9,7 +12,6 @@ import type {\n import type { DevRoutesManifest } from '../lib/router-utils/setup-dev-bundler'\n import type { RouteDefinition } from '../route-definitions/route-definition'\n import type { DeepReadonly } from '../../shared/lib/deep-readonly'\n-\n import {\n   BUILD_ID_FILE,\n   BUILD_MANIFEST,\n@@ -42,6 +44,17 @@ import { pathHasPrefix } from '../../shared/lib/router/utils/path-has-prefix'\n import { addRequestMeta, getRequestMeta } from '../request-meta'\n import { normalizePagePath } from '../../shared/lib/page-path/normalize-page-path'\n import { isStaticMetadataRoute } from '../../lib/metadata/is-metadata-route'\n+import { IncrementalCache } from '../lib/incremental-cache'\n+import { initializeCacheHandlers, setCacheHandler } from '../use-cache/handlers'\n+import { interopDefault } from '../app-render/interop-default'\n+import type { RouteKind } from '../route-kind'\n+import type { NextConfigComplete } from '../config-shared'\n+import ResponseCache, { type ResponseGenerator } from '../response-cache'\n+import {\n+  RouterServerContextSymbol,\n+  routerServerGlobal,\n+  type RouterServerContext,\n+} from '../lib/router-utils/router-server-context'\n \n /**\n  * RouteModuleOptions is the options that are passed to the route module, other\n@@ -69,6 +82,11 @@ export interface RouteModuleHandleContext {\n   params: Record<string, string | string[] | undefined> | undefined\n }\n \n+const dynamicImportEsmDefault = (id: string) =>\n+  import(/* webpackIgnore: true */ /* turbopackIgnore: true */ id).then(\n+    (mod) => mod.default || mod\n+  )\n+\n /**\n  * RouteModule is the base class for all route modules. This class should be\n  * extended by all route modules.\n@@ -98,6 +116,8 @@ export abstract class RouteModule<\n   public distDir: string\n   public projectDir: string\n   public isAppRouter?: boolean\n+  public incrementCache?: IncrementalCache\n+  public responseCache?: ResponseCache\n \n   constructor({\n     userland,\n@@ -120,23 +140,26 @@ export abstract class RouteModule<\n     // is handled in the adapter/loader instead\n     if (process.env.NEXT_RUNTIME !== 'edge') {\n       const { join } = require('node:path') as typeof import('node:path')\n-      const projectDir =\n+      const absoluteProjectDir =\n         getRequestMeta(req, 'projectDir') ||\n         join(process.cwd(), this.projectDir)\n \n       const { instrumentationOnRequestError } = await import(\n         '../lib/router-utils/instrumentation-globals.external'\n       )\n \n-      return instrumentationOnRequestError(projectDir, this.distDir, ...args)\n+      return instrumentationOnRequestError(\n+        absoluteProjectDir,\n+        this.distDir,\n+        ...args\n+      )\n     }\n   }\n \n-  private async loadManifests(projectDir: string, srcPage: string) {\n+  private loadManifests(projectDir: string, srcPage: string) {\n     if (process.env.NEXT_RUNTIME !== 'edge') {\n-      const { loadManifestFromRelativePath } = await import(\n-        '../load-manifest.external'\n-      )\n+      const { loadManifestFromRelativePath } =\n+        require('../load-manifest.external') as typeof import('../load-manifest.external')\n       const normalizedPagePath = normalizePagePath(srcPage)\n \n       const [\n@@ -150,21 +173,24 @@ export abstract class RouteModule<\n         subresourceIntegrityManifest,\n         serverFilesManifest,\n         buildId,\n-      ] = await Promise.all([\n+      ] = [\n         loadManifestFromRelativePath<DevRoutesManifest>({\n           projectDir,\n           distDir: this.distDir,\n           manifest: ROUTES_MANIFEST,\n+          shouldCache: !this.isDev,\n         }),\n         loadManifestFromRelativePath<PrerenderManifest>({\n           projectDir,\n           distDir: this.distDir,\n           manifest: PRERENDER_MANIFEST,\n+          shouldCache: !this.isDev,\n         }),\n         loadManifestFromRelativePath<BuildManifest>({\n           projectDir,\n           distDir: this.distDir,\n           manifest: BUILD_MANIFEST,\n+          shouldCache: !this.isDev,\n         }),\n         loadManifestFromRelativePath<ReactLoadableManifest>({\n           projectDir,\n@@ -173,11 +199,13 @@ export abstract class RouteModule<\n             ? `server/${this.isAppRouter ? 'app' : 'pages'}${normalizedPagePath}/${REACT_LOADABLE_MANIFEST}`\n             : REACT_LOADABLE_MANIFEST,\n           handleMissing: true,\n+          shouldCache: !this.isDev,\n         }),\n         loadManifestFromRelativePath<NextFontManifest>({\n           projectDir,\n           distDir: this.distDir,\n           manifest: `server/${NEXT_FONT_MANIFEST}.json`,\n+          shouldCache: !this.isDev,\n         }),\n         this.isAppRouter && !isStaticMetadataRoute(srcPage)\n           ? loadManifestFromRelativePath({\n@@ -220,7 +248,7 @@ export abstract class RouteModule<\n               manifest: BUILD_ID_FILE,\n               skipParse: true,\n             }),\n-      ])\n+      ]\n \n       return {\n         buildId,\n@@ -239,6 +267,117 @@ export abstract class RouteModule<\n     throw new Error('Invariant: loadManifests called for edge runtime')\n   }\n \n+  public async loadCustomCacheHandlers(\n+    req: IncomingMessage,\n+    nextConfig: NextConfigComplete\n+  ) {\n+    if (process.env.NEXT_RUNTIME !== 'edge') {\n+      const { cacheHandlers } = nextConfig.experimental\n+      if (!cacheHandlers) return\n+\n+      // If we've already initialized the cache handlers interface, don't do it\n+      // again.\n+      if (!initializeCacheHandlers()) return\n+\n+      for (const [kind, handler] of Object.entries(cacheHandlers)) {\n+        if (!handler) continue\n+\n+        const { formatDynamicImportPath } =\n+          require('../../lib/format-dynamic-import-path') as typeof import('../../lib/format-dynamic-import-path')\n+\n+        const { join } = require('node:path') as typeof import('node:path')\n+        const absoluteProjectDir =\n+          getRequestMeta(req, 'projectDir') ||\n+          join(process.cwd(), this.projectDir)\n+\n+        setCacheHandler(\n+          kind,\n+          interopDefault(\n+            await dynamicImportEsmDefault(\n+              formatDynamicImportPath(\n+                `${absoluteProjectDir}/${this.distDir}`,\n+                handler\n+              )\n+            )\n+          )\n+        )\n+      }\n+    }\n+  }\n+\n+  public async getIncrementalCache(\n+    req: IncomingMessage,\n+    nextConfig: NextConfigComplete,\n+    prerenderManifest: DeepReadonly<PrerenderManifest>\n+  ): Promise<IncrementalCache> {\n+    if (process.env.NEXT_RUNTIME === 'edge') {\n+      return (globalThis as any).__incrementalCache\n+    } else {\n+      let CacheHandler: any\n+      const { cacheHandler } = nextConfig\n+\n+      if (cacheHandler) {\n+        const { formatDynamicImportPath } =\n+          require('../../lib/format-dynamic-import-path') as typeof import('../../lib/format-dynamic-import-path')\n+\n+        CacheHandler = interopDefault(\n+          await dynamicImportEsmDefault(\n+            formatDynamicImportPath(this.distDir, cacheHandler)\n+          )\n+        )\n+      }\n+      const { join } = require('node:path') as typeof import('node:path')\n+      const projectDir =\n+        getRequestMeta(req, 'projectDir') ||\n+        join(process.cwd(), this.projectDir)\n+\n+      await this.loadCustomCacheHandlers(req, nextConfig)\n+\n+      // incremental-cache is request specific\n+      // although can have shared caches in module scope\n+      // per-cache handler\n+      return new IncrementalCache({\n+        fs: (\n+          require('../lib/node-fs-methods') as typeof import('../lib/node-fs-methods')\n+        ).nodeFs,\n+        dev: this.isDev,\n+        requestHeaders: req.headers,\n+        allowedRevalidateHeaderKeys:\n+          nextConfig.experimental.allowedRevalidateHeaderKeys,\n+        minimalMode: getRequestMeta(req, 'minimalMode'),\n+        serverDistDir: `${projectDir}/${this.distDir}/server`,\n+        fetchCacheKeyPrefix: nextConfig.experimental.fetchCacheKeyPrefix,\n+        maxMemoryCacheSize: nextConfig.cacheMaxMemorySize,\n+        flushToDisk: nextConfig.experimental.isrFlushToDisk,\n+        getPrerenderManifest: () => prerenderManifest,\n+        CurCacheHandler: CacheHandler,\n+      })\n+    }\n+  }\n+\n+  public async onRequestError(\n+    req: IncomingMessage,\n+    err: unknown,\n+    errorContext: RequestErrorContext,\n+    routerServerContext?: RouterServerContext[string]\n+  ) {\n+    if (routerServerContext?.logErrorWithOriginalStack) {\n+      routerServerContext.logErrorWithOriginalStack(err, 'app-dir')\n+    } else {\n+      console.error(err)\n+    }\n+    await this.instrumentationOnRequestError(\n+      req,\n+      err,\n+      {\n+        path: req.url || '/',\n+        headers: req.headers,\n+        method: req.method || 'GET',\n+      },\n+      errorContext\n+    )\n+  }\n+\n   public async prepare(\n     req: IncomingMessage,\n     res: ServerResponse,\n@@ -277,6 +416,8 @@ export abstract class RouteModule<\n         subresourceIntegrityManifest?: DeepReadonly<Record<string, string>>\n         isOnDemandRevalidate: boolean\n         revalidateOnlyGenerated: boolean\n+        nextConfig: NextConfigComplete\n+        routerServerContext?: RouterServerContext[string]\n       }\n     | undefined\n   > {\n@@ -297,7 +438,9 @@ export abstract class RouteModule<\n       ensureInstrumentationRegistered(projectDir, this.distDir)\n \n       const manifests = await this.loadManifests(projectDir, srcPage)\n-      const { routesManifest, prerenderManifest } = manifests\n+      const { routesManifest, prerenderManifest, serverFilesManifest } =\n+        manifests\n+\n       const { basePath, i18n, rewrites } = routesManifest\n \n       if (basePath) {\n@@ -360,7 +503,7 @@ export abstract class RouteModule<\n       // Ensure parsedUrl.pathname includes locale before processing\n       // rewrites or they won't match correctly.\n       if (defaultLocale && !detectedLocale) {\n-        parsedUrl.pathname = `/${defaultLocale}${parsedUrl.pathname}`\n+        parsedUrl.pathname = `/${defaultLocale}${parsedUrl.pathname === '/' ? '' : parsedUrl.pathname}`\n       }\n       const locale =\n         getRequestMeta(req, 'locale') || detectedLocale || defaultLocale\n@@ -439,17 +582,28 @@ export abstract class RouteModule<\n       if (pageIsDynamic) {\n         const queryResult = serverUtils.normalizeDynamicRouteParams(query, true)\n \n+        const paramsResult = serverUtils.normalizeDynamicRouteParams(\n+          params || {},\n+          true\n+        )\n+        const paramsToInterpolate: ParsedUrlQuery =\n+          paramsResult.hasValidParams && params\n+            ? params\n+            : queryResult.hasValidParams\n+              ? query\n+              : {}\n+\n         req.url = serverUtils.interpolateDynamicPath(\n           req.url || '/',\n-          params || query\n+          paramsToInterpolate\n         )\n         parsedUrl.pathname = serverUtils.interpolateDynamicPath(\n           parsedUrl.pathname || '/',\n-          params || query\n+          paramsToInterpolate\n         )\n         originalPathname = serverUtils.interpolateDynamicPath(\n           originalPathname,\n-          params || query\n+          paramsToInterpolate\n         )\n \n         // try pulling from query if valid\n@@ -505,6 +659,11 @@ export abstract class RouteModule<\n       )\n       isDraftMode = previewData !== false\n \n+      const routerServerContext =\n+        routerServerGlobal[RouterServerContextSymbol]?.[this.projectDir]\n+      const nextConfig =\n+        routerServerContext?.nextConfig || serverFilesManifest.config\n+\n       return {\n         query,\n         originalQuery,\n@@ -523,7 +682,74 @@ export abstract class RouteModule<\n         ...manifests,\n         serverActionsManifest: manifests.serverActionsManifest,\n         clientReferenceManifest: manifests.clientReferenceManifest,\n+        nextConfig,\n+        routerServerContext,\n+      }\n+    }\n+  }\n+\n+  public getResponseCache(req: IncomingMessage) {\n+    if (!this.responseCache) {\n+      const minimalMode = getRequestMeta(req, 'minimalMode') ?? false\n+      this.responseCache = new ResponseCache(minimalMode)\n+    }\n+    return this.responseCache\n+  }\n+\n+  public async handleResponse({\n+    req,\n+    nextConfig,\n+    cacheKey,\n+    routeKind,\n+    isFallback,\n+    prerenderManifest,\n+    isRoutePPREnabled,\n+    isOnDemandRevalidate,\n+    revalidateOnlyGenerated,\n+    responseGenerator,\n+    waitUntil,\n+  }: {\n+    req: IncomingMessage\n+    nextConfig: NextConfigComplete\n+    cacheKey: string | null\n+    routeKind: RouteKind\n+    isFallback?: boolean\n+    prerenderManifest: DeepReadonly<PrerenderManifest>\n+    isRoutePPREnabled?: boolean\n+    isOnDemandRevalidate?: boolean\n+    revalidateOnlyGenerated?: boolean\n+    responseGenerator: ResponseGenerator\n+    waitUntil?: (prom: Promise<any>) => void\n+  }) {\n+    const responseCache = this.getResponseCache(req)\n+    const cacheEntry = await responseCache.get(cacheKey, responseGenerator, {\n+      routeKind,\n+      isFallback,\n+      isRoutePPREnabled,\n+      isOnDemandRevalidate,\n+      isPrefetch: req.headers.purpose === 'prefetch',\n+      incrementalCache: await this.getIncrementalCache(\n+        req,\n+        nextConfig,\n+        prerenderManifest\n+      ),\n+      waitUntil,\n+    })\n+\n+    if (!cacheEntry) {\n+      if (\n+        cacheKey &&\n+        // revalidate only generated can bail even if cacheKey is provided\n+        !(isOnDemandRevalidate && revalidateOnlyGenerated)\n+      ) {\n+        // A cache entry might not be generated if a response is written\n+        // in `getInitialProps` or `getServerSideProps`, but those shouldn't\n+        // have a cache key. If we do have a cache key but we don't end up\n+        // with a cache entry, then either Next.js or the application has a\n+        // bug that needs fixing.\n+        throw new Error('invariant: cache entry required but not generated')\n       }\n     }\n+    return cacheEntry\n   }\n }"
        },
        {
            "sha": "5d18b09b2a777c94a11a7ec3e1e0094e3eb73a62",
            "filename": "packages/next/src/server/web-server.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/256cd5b571b770476755515ad1bdc976b43a258d/packages%2Fnext%2Fsrc%2Fserver%2Fweb-server.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/256cd5b571b770476755515ad1bdc976b43a258d/packages%2Fnext%2Fsrc%2Fserver%2Fweb-server.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fweb-server.ts?ref=256cd5b571b770476755515ad1bdc976b43a258d",
            "patch": "@@ -13,7 +13,7 @@ import type {\n import type { CacheControl } from './lib/cache-control'\n \n import { byteLength } from './api-utils/web'\n-import BaseServer, { NoFallbackError } from './base-server'\n+import BaseServer from './base-server'\n import { generateETag } from './lib/etag'\n import { addRequestMeta, getRequestMeta } from './request-meta'\n import WebResponseCache from './response-cache/web'\n@@ -34,6 +34,7 @@ import { UNDERSCORE_NOT_FOUND_ROUTE } from '../api/constants'\n import { getEdgeInstrumentationModule } from './web/globals'\n import type { ServerOnInstrumentationRequestError } from './app-render/types'\n import { getEdgePreviewProps } from './web/get-edge-preview-props'\n+import { NoFallbackError } from '../shared/lib/no-fallback-error.external'\n \n interface WebServerOptions extends Options {\n   buildId: string\n@@ -79,7 +80,6 @@ export default class NextWebServer extends BaseServer<\n     return new IncrementalCache({\n       dev,\n       requestHeaders,\n-      requestProtocol: 'https',\n       allowedRevalidateHeaderKeys:\n         this.nextConfig.experimental.allowedRevalidateHeaderKeys,\n       minimalMode: this.minimalMode,"
        },
        {
            "sha": "2c541fb6238113355ea3ca8449f2d36a943bb77d",
            "filename": "packages/next/src/server/web/adapter.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/256cd5b571b770476755515ad1bdc976b43a258d/packages%2Fnext%2Fsrc%2Fserver%2Fweb%2Fadapter.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/256cd5b571b770476755515ad1bdc976b43a258d/packages%2Fnext%2Fsrc%2Fserver%2Fweb%2Fadapter.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fweb%2Fadapter.ts?ref=256cd5b571b770476755515ad1bdc976b43a258d",
            "patch": "@@ -200,7 +200,6 @@ export async function adapter(\n       fetchCacheKeyPrefix: process.env.__NEXT_FETCH_CACHE_KEY_PREFIX,\n       dev: process.env.NODE_ENV === 'development',\n       requestHeaders: params.request.headers as any,\n-      requestProtocol: 'https',\n       getPrerenderManifest: () => {\n         return {\n           version: -1 as any, // letting us know this doesn't conform to spec"
        },
        {
            "sha": "f16ead553bde335312d7dfaa52905d1ae8019d4d",
            "filename": "packages/next/src/shared/lib/no-fallback-error.external.ts",
            "status": "added",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/256cd5b571b770476755515ad1bdc976b43a258d/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fno-fallback-error.external.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/256cd5b571b770476755515ad1bdc976b43a258d/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fno-fallback-error.external.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fno-fallback-error.external.ts?ref=256cd5b571b770476755515ad1bdc976b43a258d",
            "patch": "@@ -0,0 +1,6 @@\n+export class NoFallbackError extends Error {\n+  constructor() {\n+    super()\n+    this.message = 'Internal: NoFallbackError'\n+  }\n+}"
        },
        {
            "sha": "254f55802f31cda958977ffc268a5bea0b6d48ff",
            "filename": "test/integration/server-side-dev-errors/test/index.test.js",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/256cd5b571b770476755515ad1bdc976b43a258d/test%2Fintegration%2Fserver-side-dev-errors%2Ftest%2Findex.test.js",
            "raw_url": "https://github.com/vercel/next.js/raw/256cd5b571b770476755515ad1bdc976b43a258d/test%2Fintegration%2Fserver-side-dev-errors%2Ftest%2Findex.test.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fintegration%2Fserver-side-dev-errors%2Ftest%2Findex.test.js?ref=256cd5b571b770476755515ad1bdc976b43a258d",
            "patch": "@@ -49,6 +49,8 @@ describe('server-side dev errors', () => {\n   function stripInternalHandler(output) {\n     return output\n       .replace(/.*at async handler .*next-route-loader.*/, '')\n+      .replace(/.*at async handleResponse.*/, '')\n+      .replace(/.*at async doRender \\(.*/, '')\n       .split(/\\n/)\n       .filter((item) => !!item.trim())\n       .join('\\n')"
        }
    ],
    "stats": {
        "total": 2979,
        "additions": 2255,
        "deletions": 724
    }
}