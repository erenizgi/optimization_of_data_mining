{
    "author": "unstubbable",
    "message": "Discard prerendered route handler data from FS cache after revalidation (#81611)\n\nAfter having revalidated a prerendered route handler, on the subsequent request we must discard the prerendered data from the file system cache, as we already do for pages and fetch caches as well.\r\n\r\n> [!NOTE]  \r\n> This PR is best reviewed with hidden whitespace changes.",
    "sha": "4430409206e3d634dbc075253277e34912e24bcf",
    "files": [
        {
            "sha": "49c05d4d3ef9fc3915f49b8f9a8f01f7e9732ded",
            "filename": "packages/next/src/server/lib/incremental-cache/file-system-cache.ts",
            "status": "modified",
            "additions": 123,
            "deletions": 127,
            "changes": 250,
            "blob_url": "https://github.com/vercel/next.js/blob/4430409206e3d634dbc075253277e34912e24bcf/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fincremental-cache%2Ffile-system-cache.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/4430409206e3d634dbc075253277e34912e24bcf/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fincremental-cache%2Ffile-system-cache.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fincremental-cache%2Ffile-system-cache.ts?ref=4430409206e3d634dbc075253277e34912e24bcf",
            "patch": "@@ -101,8 +101,8 @@ export default class FileSystemCache implements CacheHandler {\n \n     // let's check the disk for seed data\n     if (!data && process.env.NEXT_RUNTIME !== 'edge') {\n-      if (kind === IncrementalCacheKind.APP_ROUTE) {\n-        try {\n+      try {\n+        if (kind === IncrementalCacheKind.APP_ROUTE) {\n           const filePath = this.getFilePath(\n             `${key}.body`,\n             IncrementalCacheKind.APP_ROUTE\n@@ -117,7 +117,7 @@ export default class FileSystemCache implements CacheHandler {\n             )\n           )\n \n-          const cacheEntry: CacheHandlerValue = {\n+          data = {\n             lastModified: mtime.getTime(),\n             value: {\n               kind: CachedRouteKind.APP_ROUTE,\n@@ -126,146 +126,141 @@ export default class FileSystemCache implements CacheHandler {\n               status: meta.status,\n             },\n           }\n-          return cacheEntry\n-        } catch {\n-          return null\n-        }\n-      }\n-\n-      try {\n-        const filePath = this.getFilePath(\n-          kind === IncrementalCacheKind.FETCH ? key : `${key}.html`,\n-          kind\n-        )\n+        } else {\n+          const filePath = this.getFilePath(\n+            kind === IncrementalCacheKind.FETCH ? key : `${key}.html`,\n+            kind\n+          )\n \n-        const fileData = await this.fs.readFile(filePath, 'utf8')\n-        const { mtime } = await this.fs.stat(filePath)\n+          const fileData = await this.fs.readFile(filePath, 'utf8')\n+          const { mtime } = await this.fs.stat(filePath)\n \n-        if (kind === IncrementalCacheKind.FETCH) {\n-          const { tags, fetchIdx, fetchUrl } = ctx\n+          if (kind === IncrementalCacheKind.FETCH) {\n+            const { tags, fetchIdx, fetchUrl } = ctx\n \n-          if (!this.flushToDisk) return null\n+            if (!this.flushToDisk) return null\n \n-          const lastModified = mtime.getTime()\n-          const parsedData: CachedFetchValue = JSON.parse(fileData)\n-          data = {\n-            lastModified,\n-            value: parsedData,\n-          }\n+            const lastModified = mtime.getTime()\n+            const parsedData: CachedFetchValue = JSON.parse(fileData)\n+            data = {\n+              lastModified,\n+              value: parsedData,\n+            }\n \n-          if (data.value?.kind === CachedRouteKind.FETCH) {\n-            const storedTags = data.value?.tags\n+            if (data.value?.kind === CachedRouteKind.FETCH) {\n+              const storedTags = data.value?.tags\n \n-            // update stored tags if a new one is being added\n-            // TODO: remove this when we can send the tags\n-            // via header on GET same as SET\n-            if (!tags?.every((tag) => storedTags?.includes(tag))) {\n-              if (FileSystemCache.debug) {\n-                console.log('tags vs storedTags mismatch', tags, storedTags)\n+              // update stored tags if a new one is being added\n+              // TODO: remove this when we can send the tags\n+              // via header on GET same as SET\n+              if (!tags?.every((tag) => storedTags?.includes(tag))) {\n+                if (FileSystemCache.debug) {\n+                  console.log('tags vs storedTags mismatch', tags, storedTags)\n+                }\n+                await this.set(key, data.value, {\n+                  fetchCache: true,\n+                  tags,\n+                  fetchIdx,\n+                  fetchUrl,\n+                })\n               }\n-              await this.set(key, data.value, {\n-                fetchCache: true,\n-                tags,\n-                fetchIdx,\n-                fetchUrl,\n-              })\n             }\n-          }\n-        } else if (kind === IncrementalCacheKind.APP_PAGE) {\n-          // We try to load the metadata file, but if it fails, we don't\n-          // error. We also don't load it if this is a fallback.\n-          let meta: RouteMetadata | undefined\n-          try {\n-            meta = JSON.parse(\n-              await this.fs.readFile(\n-                filePath.replace(/\\.html$/, NEXT_META_SUFFIX),\n-                'utf8'\n-              )\n-            )\n-          } catch {}\n-\n-          let maybeSegmentData: Map<string, Buffer> | undefined\n-          if (meta?.segmentPaths) {\n-            // Collect all the segment data for this page.\n-            // TODO: To optimize file system reads, we should consider creating\n-            // separate cache entries for each segment, rather than storing them\n-            // all on the page's entry. Though the behavior is\n-            // identical regardless.\n-            const segmentData: Map<string, Buffer> = new Map()\n-            maybeSegmentData = segmentData\n-            const segmentsDir = key + RSC_SEGMENTS_DIR_SUFFIX\n-            await Promise.all(\n-              meta.segmentPaths.map(async (segmentPath: string) => {\n-                const segmentDataFilePath = this.getFilePath(\n-                  segmentsDir + segmentPath + RSC_SEGMENT_SUFFIX,\n-                  IncrementalCacheKind.APP_PAGE\n+          } else if (kind === IncrementalCacheKind.APP_PAGE) {\n+            // We try to load the metadata file, but if it fails, we don't\n+            // error. We also don't load it if this is a fallback.\n+            let meta: RouteMetadata | undefined\n+            try {\n+              meta = JSON.parse(\n+                await this.fs.readFile(\n+                  filePath.replace(/\\.html$/, NEXT_META_SUFFIX),\n+                  'utf8'\n                 )\n-                try {\n-                  segmentData.set(\n-                    segmentPath,\n-                    await this.fs.readFile(segmentDataFilePath)\n+              )\n+            } catch {}\n+\n+            let maybeSegmentData: Map<string, Buffer> | undefined\n+            if (meta?.segmentPaths) {\n+              // Collect all the segment data for this page.\n+              // TODO: To optimize file system reads, we should consider creating\n+              // separate cache entries for each segment, rather than storing them\n+              // all on the page's entry. Though the behavior is\n+              // identical regardless.\n+              const segmentData: Map<string, Buffer> = new Map()\n+              maybeSegmentData = segmentData\n+              const segmentsDir = key + RSC_SEGMENTS_DIR_SUFFIX\n+              await Promise.all(\n+                meta.segmentPaths.map(async (segmentPath: string) => {\n+                  const segmentDataFilePath = this.getFilePath(\n+                    segmentsDir + segmentPath + RSC_SEGMENT_SUFFIX,\n+                    IncrementalCacheKind.APP_PAGE\n                   )\n-                } catch {\n-                  // This shouldn't happen, but if for some reason we fail to\n-                  // load a segment from the filesystem, treat it the same as if\n-                  // the segment is dynamic and does not have a prefetch.\n-                }\n-              })\n-            )\n-          }\n-\n-          let rscData: Buffer | undefined\n-          if (!ctx.isFallback) {\n-            rscData = await this.fs.readFile(\n-              this.getFilePath(\n-                `${key}${ctx.isRoutePPREnabled ? RSC_PREFETCH_SUFFIX : RSC_SUFFIX}`,\n-                IncrementalCacheKind.APP_PAGE\n+                  try {\n+                    segmentData.set(\n+                      segmentPath,\n+                      await this.fs.readFile(segmentDataFilePath)\n+                    )\n+                  } catch {\n+                    // This shouldn't happen, but if for some reason we fail to\n+                    // load a segment from the filesystem, treat it the same as if\n+                    // the segment is dynamic and does not have a prefetch.\n+                  }\n+                })\n               )\n-            )\n-          }\n-\n-          data = {\n-            lastModified: mtime.getTime(),\n-            value: {\n-              kind: CachedRouteKind.APP_PAGE,\n-              html: fileData,\n-              rscData,\n-              postponed: meta?.postponed,\n-              headers: meta?.headers,\n-              status: meta?.status,\n-              segmentData: maybeSegmentData,\n-            },\n-          }\n-        } else if (kind === IncrementalCacheKind.PAGES) {\n-          let meta: RouteMetadata | undefined\n-          let pageData: string | object = {}\n+            }\n \n-          if (!ctx.isFallback) {\n-            pageData = JSON.parse(\n-              await this.fs.readFile(\n+            let rscData: Buffer | undefined\n+            if (!ctx.isFallback) {\n+              rscData = await this.fs.readFile(\n                 this.getFilePath(\n-                  `${key}${NEXT_DATA_SUFFIX}`,\n-                  IncrementalCacheKind.PAGES\n-                ),\n-                'utf8'\n+                  `${key}${ctx.isRoutePPREnabled ? RSC_PREFETCH_SUFFIX : RSC_SUFFIX}`,\n+                  IncrementalCacheKind.APP_PAGE\n+                )\n               )\n-            )\n-          }\n+            }\n \n-          data = {\n-            lastModified: mtime.getTime(),\n-            value: {\n-              kind: CachedRouteKind.PAGES,\n-              html: fileData,\n-              pageData,\n-              headers: meta?.headers,\n-              status: meta?.status,\n-            },\n+            data = {\n+              lastModified: mtime.getTime(),\n+              value: {\n+                kind: CachedRouteKind.APP_PAGE,\n+                html: fileData,\n+                rscData,\n+                postponed: meta?.postponed,\n+                headers: meta?.headers,\n+                status: meta?.status,\n+                segmentData: maybeSegmentData,\n+              },\n+            }\n+          } else if (kind === IncrementalCacheKind.PAGES) {\n+            let meta: RouteMetadata | undefined\n+            let pageData: string | object = {}\n+\n+            if (!ctx.isFallback) {\n+              pageData = JSON.parse(\n+                await this.fs.readFile(\n+                  this.getFilePath(\n+                    `${key}${NEXT_DATA_SUFFIX}`,\n+                    IncrementalCacheKind.PAGES\n+                  ),\n+                  'utf8'\n+                )\n+              )\n+            }\n+\n+            data = {\n+              lastModified: mtime.getTime(),\n+              value: {\n+                kind: CachedRouteKind.PAGES,\n+                html: fileData,\n+                pageData,\n+                headers: meta?.headers,\n+                status: meta?.status,\n+              },\n+            }\n+          } else {\n+            throw new Error(\n+              `Invariant: Unexpected route kind ${kind} in file system cache.`\n+            )\n           }\n-        } else {\n-          throw new Error(\n-            `Invariant: Unexpected route kind ${kind} in file system cache.`\n-          )\n         }\n \n         if (data) {\n@@ -278,6 +273,7 @@ export default class FileSystemCache implements CacheHandler {\n \n     if (\n       data?.value?.kind === CachedRouteKind.APP_PAGE ||\n+      data?.value?.kind === CachedRouteKind.APP_ROUTE ||\n       data?.value?.kind === CachedRouteKind.PAGES\n     ) {\n       let cacheTags: undefined | string[]"
        },
        {
            "sha": "085ecc1a845e2a0d1aa79adf346fd36186fac20b",
            "filename": "test/cache-components-tests-manifest.json",
            "status": "modified",
            "additions": 1,
            "deletions": 4,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/4430409206e3d634dbc075253277e34912e24bcf/test%2Fcache-components-tests-manifest.json",
            "raw_url": "https://github.com/vercel/next.js/raw/4430409206e3d634dbc075253277e34912e24bcf/test%2Fcache-components-tests-manifest.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fcache-components-tests-manifest.json?ref=4430409206e3d634dbc075253277e34912e24bcf",
            "patch": "@@ -28,10 +28,7 @@\n       ]\n     },\n     \"test/e2e/app-dir/use-cache/use-cache.test.ts\": {\n-      \"failed\": [\n-        \"use-cache should revalidate before redirecting in a route handler\",\n-        \"use-cache should update after unstable_expireTag correctly\"\n-      ]\n+      \"failed\": [\"use-cache should update after unstable_expireTag correctly\"]\n     },\n     \"test/production/app-dir/browser-chunks/browser-chunks.test.ts\": {\n       \"failed\": ["
        }
    ],
    "stats": {
        "total": 255,
        "additions": 124,
        "deletions": 131
    }
}