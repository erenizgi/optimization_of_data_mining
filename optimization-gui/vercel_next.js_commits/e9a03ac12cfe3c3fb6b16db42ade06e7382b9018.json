{
    "author": "acdlite",
    "message": "Refactor: Navigate and refresh simultaneously (#86747)\n\nThis is a refactor of the ppr-navigations module to support navigating\nto a new tree and refreshing shared layouts within the same navigation.\n\nRather than modeling navigations and refreshes/revalidations as separate\noperations, a refresh is considered a special case of a navigation where\nany existing dynamic data is disregarded, and new data is fetched from\nthe server. The rest of the tree is diffed as usual, and the routing\nbehavior is the same.\n\nPreviously, the ppr-navigations module would revert to the \"create\" path\nwhenever it was missing dynamic data (the CacheNode) for a shared\nsegment. Now, the FlightRouterState alone is used to diff the old and\nnew trees.\n\nWhen dynamic data is missing, any shared segment (one that exists in\nboth the old and new trees) is considered to be part of a \"refresh\", and\nany segment that is present only in the new tree is considered to be\npart of a \"navigation\". There are subtle distinctions in behavior\nbetween refreshes and navigations. For example, refreshed page segments\naren't scrolled to, but navigated page segments are.",
    "sha": "e9a03ac12cfe3c3fb6b16db42ade06e7382b9018",
    "files": [
        {
            "sha": "5869f968eadb185680d7fa0ba13359d64536053c",
            "filename": "packages/next/src/client/components/router-reducer/ppr-navigations.ts",
            "status": "modified",
            "additions": 581,
            "deletions": 721,
            "changes": 1302,
            "blob_url": "https://github.com/vercel/next.js/blob/e9a03ac12cfe3c3fb6b16db42ade06e7382b9018/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fppr-navigations.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/e9a03ac12cfe3c3fb6b16db42ade06e7382b9018/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fppr-navigations.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fppr-navigations.ts?ref=e9a03ac12cfe3c3fb6b16db42ade06e7382b9018",
            "patch": "@@ -13,9 +13,11 @@ import type {\n   HeadData,\n   LoadingModuleData,\n } from '../../../shared/lib/app-router-types'\n-import { DEFAULT_SEGMENT_KEY } from '../../../shared/lib/segment'\n+import {\n+  DEFAULT_SEGMENT_KEY,\n+  NOT_FOUND_SEGMENT_KEY,\n+} from '../../../shared/lib/segment'\n import { matchSegment } from '../match-segments'\n-import { revalidateEntireCache } from '../segment-cache/cache'\n import { createHrefFromUrl } from './create-href-from-url'\n import { createRouterCacheKey } from './create-router-cache-key'\n import {\n@@ -31,46 +33,23 @@ import { DYNAMIC_STALETIME_MS } from './reducers/navigate-reducer'\n // request. We can't use the Cache Node tree or Route State tree directly\n // because those include reused nodes, too. This tree is discarded as soon as\n // the navigation response is received.\n-type SPANavigationTask = {\n+export type NavigationTask = {\n   // The router state that corresponds to the tree that this Task represents.\n   route: FlightRouterState\n-  // The CacheNode that corresponds to the tree that this Task represents. If\n-  // `children` is null (i.e. if this is a terminal task node), then `node`\n-  // represents a brand new Cache Node tree, which way or may not need to be\n-  // filled with dynamic data from the server.\n-  node: CacheNode | null\n-  // The tree sent to the server during the dynamic request. This is the\n-  // same as `route`, except with the `refetch` marker set on dynamic segments.\n-  // If all the segments are static, then this will be null, and no server\n-  // request is required.\n+  // The CacheNode that corresponds to the tree that this Task represents.\n+  node: CacheNode\n+  // The tree sent to the server during the dynamic request. If all the segments\n+  // are static, then this will be null, and no server request is required.\n+  // Otherwise, this is the same as `route`, except with the `refetch` marker\n+  // set on the top-most segment that needs to be fetched.\n   dynamicRequestTree: FlightRouterState | null\n   // The URL that should be used to fetch the dynamic data. This is only set\n   // when the segment cannot be refetched from the current route, because it's\n   // part of a \"default\" parallel slot that was reused during a navigation.\n   refreshUrl: string | null\n-  children: Map<string, SPANavigationTask> | null\n-}\n-\n-// A special type used to bail out and trigger a full-page navigation.\n-type MPANavigationTask = {\n-  // MPA tasks are distinguised from SPA tasks by having a null `route`.\n-  route: null\n-  node: null\n-  dynamicRequestTree: null\n-  refreshUrl: null\n-  children: null\n+  children: Map<string, NavigationTask> | null\n }\n \n-const MPA_NAVIGATION_TASK: MPANavigationTask = {\n-  route: null,\n-  node: null,\n-  dynamicRequestTree: null,\n-  refreshUrl: null,\n-  children: null,\n-}\n-\n-export type Task = SPANavigationTask | MPANavigationTask\n-\n export type NavigationRequestAccumulation = {\n   scrollableSegments: Array<FlightSegmentPath>\n   separateRefreshUrls: Set<string> | null\n@@ -108,104 +87,145 @@ export type NavigationRequestAccumulation = {\n export function startPPRNavigation(\n   navigatedAt: number,\n   oldUrl: URL,\n-  oldCacheNode: CacheNode,\n+  oldCacheNode: CacheNode | null,\n   oldRouterState: FlightRouterState,\n   newRouterState: FlightRouterState,\n+  shouldRefreshDynamicData: boolean,\n   prefetchData: CacheNodeSeedData | null,\n   prefetchHead: HeadData | null,\n   isPrefetchHeadPartial: boolean,\n   isSamePageNavigation: boolean,\n   accumulation: NavigationRequestAccumulation\n-): Task | null {\n-  const segmentPath: Array<FlightSegmentPath> = []\n+): NavigationTask | null {\n+  const didFindRootLayout = false\n+  const parentNeedsDynamicRequest = false\n+  const parentRefreshUrl = null\n   return updateCacheNodeOnNavigation(\n     navigatedAt,\n     oldUrl,\n-    oldCacheNode,\n+    oldCacheNode !== null ? oldCacheNode : undefined,\n     oldRouterState,\n     newRouterState,\n-    false,\n+    shouldRefreshDynamicData,\n+    didFindRootLayout,\n     prefetchData,\n     prefetchHead,\n     isPrefetchHeadPartial,\n     isSamePageNavigation,\n-    segmentPath,\n-    accumulation\n-  )\n-}\n-\n-export function startPPRRefresh(\n-  navigatedAt: number,\n-  currentRouterState: FlightRouterState,\n-  currentNextUrl: string | null,\n-  accumulation: NavigationRequestAccumulation\n-): Task | null {\n-  // A refresh is a special case of a navigation where all the dynamic data in\n-  // the page is re-fetched. There is no \"shared layout\" to consider because\n-  // the route hasn't changed.\n-\n-  // TODO: Currently, all refreshes purge the prefetch cache. In the future,\n-  // only client-side refreshes will have this behavior; the server-side\n-  // `refresh` should send new data without purging the prefetch cache.\n-  revalidateEntireCache(currentNextUrl, currentRouterState)\n-\n-  // TODO: Currently refreshes do not read from the prefetch cache, as in the\n-  // pre-Segment Cache implementation. This will be added in a subsequent PR.\n-  const prefetchData = null\n-  const prefetchHead = null\n-  const isPrefetchHeadPartial = true\n-\n-  const isRefresh = true\n-  const refreshUrl = null\n-  // During a refresh, we intentionally don't pass in the previous\n-  // CacheNode tree.\n-  const existingCacheNode = undefined\n-  const segmentPath: FlightSegmentPath = []\n-  return createCacheNodeOnNavigation(\n-    isRefresh,\n-    refreshUrl,\n-    navigatedAt,\n-    currentRouterState,\n-    existingCacheNode,\n-    prefetchData,\n-    prefetchHead,\n-    isPrefetchHeadPartial,\n-    segmentPath,\n+    null,\n+    null,\n+    parentNeedsDynamicRequest,\n+    parentRefreshUrl,\n     accumulation\n   )\n }\n \n function updateCacheNodeOnNavigation(\n   navigatedAt: number,\n   oldUrl: URL,\n-  oldCacheNode: CacheNode,\n+  oldCacheNode: CacheNode | void,\n   oldRouterState: FlightRouterState,\n   newRouterState: FlightRouterState,\n+  shouldRefreshDynamicData: boolean,\n   didFindRootLayout: boolean,\n   prefetchData: CacheNodeSeedData | null,\n   prefetchHead: HeadData | null,\n   isPrefetchHeadPartial: boolean,\n   isSamePageNavigation: boolean,\n-  segmentPath: FlightSegmentPath,\n+  parentSegmentPath: FlightSegmentPath | null,\n+  parentParallelRouteKey: string | null,\n+  parentNeedsDynamicRequest: boolean,\n+  parentRefreshUrl: string | null,\n   accumulation: NavigationRequestAccumulation\n-): Task | null {\n-  // Diff the old and new trees to reuse the shared layouts.\n-  const oldRouterStateChildren = oldRouterState[1]\n+): NavigationTask | null {\n+  // Check if this segment matches the one in the previous route.\n+  const oldSegment = oldRouterState[0]\n+  const newSegment = newRouterState[0]\n+  if (!matchSegment(newSegment, oldSegment)) {\n+    // This segment does not match the previous route. We're now entering the\n+    // new part of the target route. Switch to the \"create\" path.\n+    if (\n+      // Check if the route tree changed before we reached a layout. (The\n+      // highest-level layout in a route tree is referred to as the \"root\"\n+      // layout.) This could mean that we're navigating between two different\n+      // root layouts. When this happens, we perform a full-page (MPA-style)\n+      // navigation.\n+      //\n+      // However, the algorithm for deciding where to start rendering a route\n+      // (i.e. the one performed in order to reach this function) is stricter\n+      // than the one used to detect a change in the root layout. So just\n+      // because we're re-rendering a segment outside of the root layout does\n+      // not mean we should trigger a full-page navigation.\n+      //\n+      // Specifically, we handle dynamic parameters differently: two segments\n+      // are considered the same even if their parameter values are different.\n+      //\n+      // Refer to isNavigatingToNewRootLayout for details.\n+      //\n+      // Note that we only have to perform this extra traversal if we didn't\n+      // already discover a root layout in the part of the tree that is\n+      // unchanged. We also only need to compare the subtree that is not\n+      // shared. In the common case, this branch is skipped completely.\n+      (!didFindRootLayout &&\n+        isNavigatingToNewRootLayout(oldRouterState, newRouterState)) ||\n+      // The global Not Found route (app/global-not-found.tsx) is a special\n+      // case, because it acts like a root layout, but in the router tree, it\n+      // is rendered in the same position as app/layout.tsx.\n+      //\n+      // Any navigation to the global Not Found route should trigger a\n+      // full-page navigation.\n+      //\n+      // TODO: We should probably model this by changing the key of the root\n+      // segment when this happens. Then the root layout check would work\n+      // as expected, without a special case.\n+      newSegment === NOT_FOUND_SEGMENT_KEY\n+    ) {\n+      return null\n+    }\n+    if (parentSegmentPath === null || parentParallelRouteKey === null) {\n+      // The root should never mismatch. If it does, it suggests an internal\n+      // Next.js error, or a malformed server response. Trigger a full-\n+      // page navigation.\n+      return null\n+    }\n+    return createCacheNodeOnNavigation(\n+      navigatedAt,\n+      newRouterState,\n+      oldCacheNode,\n+      shouldRefreshDynamicData,\n+      prefetchData,\n+      prefetchHead,\n+      isPrefetchHeadPartial,\n+      parentSegmentPath,\n+      parentParallelRouteKey,\n+      parentNeedsDynamicRequest,\n+      accumulation\n+    )\n+  }\n+\n+  // TODO: The segment paths are tracked so that LayoutRouter knows which\n+  // segments to scroll to after a navigation. But we should just mark this\n+  // information on the CacheNode directly. It used to be necessary to do this\n+  // separately because CacheNodes were created lazily during render, not when\n+  // rather than when creating the route tree.\n+  const segmentPath =\n+    parentParallelRouteKey !== null && parentSegmentPath !== null\n+      ? parentSegmentPath.concat([parentParallelRouteKey, newSegment])\n+      : // NOTE: The root segment is intentionally omitted from the segment path\n+        []\n+\n   const newRouterStateChildren = newRouterState[1]\n+  const oldRouterStateChildren = oldRouterState[1]\n   const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null\n \n-  if (!didFindRootLayout) {\n-    // We're currently traversing the part of the tree that was also part of\n-    // the previous route. If we discover a root layout, then we don't need to\n-    // trigger an MPA navigation. See beginRenderingNewRouteTree for context.\n-    const isRootLayout = newRouterState[4] === true\n-    if (isRootLayout) {\n-      // Found a matching root layout.\n-      didFindRootLayout = true\n-    }\n-  }\n+  // We're currently traversing the part of the tree that was also part of\n+  // the previous route. If we discover a root layout, then we don't need to\n+  // trigger an MPA navigation.\n+  const isRootLayout = newRouterState[4] === true\n+  const childDidFindRootLayout = didFindRootLayout || isRootLayout\n \n-  const oldParallelRoutes = oldCacheNode.parallelRoutes\n+  const oldParallelRoutes =\n+    oldCacheNode !== undefined ? oldCacheNode.parallelRoutes : undefined\n \n   // Clone the current set of segment children, even if they aren't active in\n   // the new tree.\n@@ -218,7 +238,79 @@ function updateCacheNodeOnNavigation(\n   // leak. We should figure out a better model for the lifetime of inactive\n   // segments, so we can maintain instant back/forward navigations without\n   // leaking memory indefinitely.\n-  const prefetchParallelRoutes = new Map(oldParallelRoutes)\n+  const newParallelRoutes = new Map(\n+    shouldRefreshDynamicData ? undefined : oldParallelRoutes\n+  )\n+\n+  // TODO: We're not consistent about how we do this check. Some places\n+  // check if the segment starts with PAGE_SEGMENT_KEY, but most seem to\n+  // check if there any any children, which is why I'm doing it here. We\n+  // should probably encode an empty children set as `null` though. Either\n+  // way, we should update all the checks to be consistent.\n+  const isLeafSegment = Object.keys(newRouterStateChildren).length === 0\n+\n+  // Get the data for this segment. Since it was part of the previous route,\n+  // usually we just clone the data from the old CacheNode. However, during a\n+  // refresh or a revalidation, there won't be any existing CacheNode. So we\n+  // may need to consult the prefetch cache, like we would for a new segment.\n+  let newCacheNode: ReadyCacheNode\n+  let needsDynamicRequest: boolean\n+  if (\n+    oldCacheNode !== undefined &&\n+    !shouldRefreshDynamicData &&\n+    // During a same-page navigation, we always refetch the page segments\n+    !(isLeafSegment && isSamePageNavigation)\n+  ) {\n+    // Reuse the existing CacheNode\n+    newCacheNode = reuseDynamicCacheNode(oldCacheNode, newParallelRoutes)\n+    needsDynamicRequest = false\n+  } else if (prefetchData !== null) {\n+    // Consult the prefetch cache.\n+    const prefetchRsc = prefetchData[0]\n+    const prefetchLoading = prefetchData[2]\n+    const isPrefetchRSCPartial = prefetchData[3]\n+    newCacheNode = readCacheNodeFromSeedData(\n+      prefetchRsc,\n+      prefetchLoading,\n+      isPrefetchRSCPartial,\n+      prefetchHead,\n+      isPrefetchHeadPartial,\n+      isLeafSegment,\n+      newParallelRoutes,\n+      navigatedAt\n+    )\n+    needsDynamicRequest =\n+      isPrefetchRSCPartial || (isLeafSegment && isPrefetchHeadPartial)\n+  } else {\n+    // Spawn a request to fetch new data from the server.\n+    newCacheNode = spawnNewCacheNode(\n+      newParallelRoutes,\n+      isLeafSegment,\n+      navigatedAt\n+    )\n+    needsDynamicRequest = true\n+  }\n+\n+  // During a refresh navigation, there's a special case that happens when\n+  // entering a \"default\" slot. The default slot may not be part of the\n+  // current route; it may have been reused from an older route. If so,\n+  // we need to fetch its data from the old route's URL rather than current\n+  // route's URL. Keep track of this as we traverse the tree.\n+  const href = newRouterState[2]\n+  const refreshUrl =\n+    typeof href === 'string' && newRouterState[3] === 'refresh'\n+      ? // This segment is not present in the current route. Track its\n+        // refresh URL as we continue traversing the tree.\n+        href\n+      : // Inherit the refresh URL from the parent.\n+        parentRefreshUrl\n+\n+  // If this segment itself needs to fetch new data from the server, then by\n+  // definition it is being refreshed. Track its refresh URL so we know which\n+  // URL to request the data from.\n+  if (needsDynamicRequest && refreshUrl !== null) {\n+    accumulateRefreshUrl(accumulation, refreshUrl)\n+  }\n \n   // As we diff the trees, we may sometimes modify (copy-on-write, not mutate)\n   // the Route Tree that was returned by the server — for example, in the case\n@@ -239,11 +331,11 @@ function updateCacheNodeOnNavigation(\n   //\n   // This starts off as `false`, and is set to `true` if any of the child\n   // routes requires a dynamic request.\n-  let needsDynamicRequest = false\n+  let childNeedsDynamicRequest = false\n   // As we traverse the children, we'll construct a FlightRouterState that can\n   // be sent to the server to request the dynamic data. If it turns out that\n-  // nothing in the subtree is dynamic (i.e. needsDynamicRequest is false at the\n-  // end), then this will be discarded.\n+  // nothing in the subtree is dynamic (i.e. childNeedsDynamicRequest is false\n+  // at the end), then this will be discarded.\n   // TODO: We can probably optimize the format of this data structure to only\n   // include paths that are dynamic. Instead of reusing the\n   // FlightRouterState type.\n@@ -252,520 +344,308 @@ function updateCacheNodeOnNavigation(\n   } = {}\n \n   for (let parallelRouteKey in newRouterStateChildren) {\n-    const newRouterStateChild: FlightRouterState =\n+    let newRouterStateChild: FlightRouterState =\n       newRouterStateChildren[parallelRouteKey]\n     const oldRouterStateChild: FlightRouterState | void =\n       oldRouterStateChildren[parallelRouteKey]\n-    const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey)\n-    const prefetchDataChild: CacheNodeSeedData | void | null =\n+    if (oldRouterStateChild === undefined) {\n+      // This should never happen, but if it does, it suggests a malformed\n+      // server response. Trigger a full-page navigation.\n+      return null\n+    }\n+    const oldSegmentMapChild =\n+      oldParallelRoutes !== undefined\n+        ? oldParallelRoutes.get(parallelRouteKey)\n+        : undefined\n+    let prefetchDataChild: CacheNodeSeedData | void | null =\n       prefetchDataChildren !== null\n         ? prefetchDataChildren[parallelRouteKey]\n         : null\n \n-    const newSegmentChild = newRouterStateChild[0]\n-    const newSegmentPathChild = segmentPath.concat([\n-      parallelRouteKey,\n-      newSegmentChild,\n-    ])\n-    const newSegmentKeyChild = createRouterCacheKey(newSegmentChild)\n+    let newSegmentChild = newRouterStateChild[0]\n+    let prefetchHeadChild = prefetchHead\n+    let isPrefetchHeadPartialChild = isPrefetchHeadPartial\n+    if (newSegmentChild === DEFAULT_SEGMENT_KEY) {\n+      // This is a \"default\" segment. These are never sent by the server during\n+      // a soft navigation; instead, the client reuses whatever segment was\n+      // already active in that slot on the previous route.\n+      newRouterStateChild = reuseActiveSegmentInDefaultSlot(\n+        oldUrl,\n+        oldRouterStateChild\n+      )\n+      newSegmentChild = newRouterStateChild[0]\n \n-    const oldSegmentChild =\n-      oldRouterStateChild !== undefined ? oldRouterStateChild[0] : undefined\n+      // Since we're switching to a different route tree, these are no\n+      // longer valid, because they correspond to the outer tree.\n+      prefetchDataChild = null\n+      prefetchHeadChild = null\n+      isPrefetchHeadPartialChild = false\n+    }\n \n+    const newSegmentKeyChild = createRouterCacheKey(newSegmentChild)\n     const oldCacheNodeChild =\n       oldSegmentMapChild !== undefined\n         ? oldSegmentMapChild.get(newSegmentKeyChild)\n         : undefined\n \n-    let taskChild: Task | null\n-    if (newSegmentChild === DEFAULT_SEGMENT_KEY) {\n-      // This is another kind of leaf segment — a default route.\n-      //\n-      // Default routes have special behavior. When there's no matching segment\n-      // for a parallel route, Next.js preserves the currently active segment\n-      // during a client navigation — but not for initial render. The server\n-      // leaves it to the client to account for this. So we need to handle\n-      // it here.\n-      if (oldRouterStateChild !== undefined) {\n-        // Reuse the existing Router State for this segment. We spawn a \"task\"\n-        // just to keep track of the updated router state; unlike most, it's\n-        // already fulfilled and won't be affected by the dynamic response.\n-        taskChild = reuseActiveSegmentInDefaultSlot(oldUrl, oldRouterStateChild)\n-      } else {\n-        // There's no currently active segment. Switch to the \"create\" path.\n-        taskChild = beginRenderingNewRouteTree(\n-          navigatedAt,\n-          oldRouterStateChild,\n-          newRouterStateChild,\n-          oldCacheNodeChild,\n-          didFindRootLayout,\n-          prefetchDataChild !== undefined ? prefetchDataChild : null,\n-          prefetchHead,\n-          isPrefetchHeadPartial,\n-          newSegmentPathChild,\n-          accumulation\n-        )\n-      }\n-    } else if (\n-      isSamePageNavigation &&\n-      // Check if this is a page segment.\n-      // TODO: We're not consistent about how we do this check. Some places\n-      // check if the segment starts with PAGE_SEGMENT_KEY, but most seem to\n-      // check if there any any children, which is why I'm doing it here. We\n-      // should probably encode an empty children set as `null` though. Either\n-      // way, we should update all the checks to be consistent.\n-      Object.keys(newRouterStateChild[1]).length === 0\n-    ) {\n-      // We special case navigations to the exact same URL as the current\n-      // location. It's a common UI pattern for apps to refresh when you click a\n-      // link to the current page. So when this happens, we refresh the dynamic\n-      // data in the page segments.\n-      //\n-      // Note that this does not apply if the any part of the hash or search\n-      // query has changed. This might feel a bit weird but it makes more sense\n-      // when you consider that the way to trigger this behavior is to click\n-      // the same link multiple times.\n-      //\n-      // TODO: We should probably refresh the *entire* route when this case\n-      // occurs, not just the page segments. Essentially treating it the same as\n-      // a refresh() triggered by an action, which is the more explicit way of\n-      // modeling the UI pattern described above.\n-      //\n-      // Also note that this only refreshes the dynamic data, not static/\n-      // cached data. If the page segment is fully static and prefetched, the\n-      // request is skipped. (This is also how refresh() works.)\n-      taskChild = beginRenderingNewRouteTree(\n-        navigatedAt,\n-        oldRouterStateChild,\n-        newRouterStateChild,\n-        oldCacheNodeChild,\n-        didFindRootLayout,\n-        prefetchDataChild !== undefined ? prefetchDataChild : null,\n-        prefetchHead,\n-        isPrefetchHeadPartial,\n-        newSegmentPathChild,\n-        accumulation\n-      )\n-    } else if (\n-      oldRouterStateChild !== undefined &&\n-      oldSegmentChild !== undefined &&\n-      matchSegment(newSegmentChild, oldSegmentChild)\n-    ) {\n-      if (\n-        oldCacheNodeChild !== undefined &&\n-        oldRouterStateChild !== undefined\n-      ) {\n-        // This segment exists in both the old and new trees. Recursively update\n-        // the children.\n-        taskChild = updateCacheNodeOnNavigation(\n-          navigatedAt,\n-          oldUrl,\n-          oldCacheNodeChild,\n-          oldRouterStateChild,\n-          newRouterStateChild,\n-          didFindRootLayout,\n-          prefetchDataChild,\n-          prefetchHead,\n-          isPrefetchHeadPartial,\n-          isSamePageNavigation,\n-          newSegmentPathChild,\n-          accumulation\n-        )\n-      } else {\n-        // There's no existing Cache Node for this segment. Switch to the\n-        // \"create\" path.\n-        taskChild = beginRenderingNewRouteTree(\n-          navigatedAt,\n-          oldRouterStateChild,\n-          newRouterStateChild,\n-          oldCacheNodeChild,\n-          didFindRootLayout,\n-          prefetchDataChild !== undefined ? prefetchDataChild : null,\n-          prefetchHead,\n-          isPrefetchHeadPartial,\n-          newSegmentPathChild,\n-          accumulation\n-        )\n-      }\n-    } else {\n-      // This is a new tree. Switch to the \"create\" path.\n-      taskChild = beginRenderingNewRouteTree(\n-        navigatedAt,\n-        oldRouterStateChild,\n-        newRouterStateChild,\n-        oldCacheNodeChild,\n-        didFindRootLayout,\n-        prefetchDataChild !== undefined ? prefetchDataChild : null,\n-        prefetchHead,\n-        isPrefetchHeadPartial,\n-        newSegmentPathChild,\n-        accumulation\n-      )\n-    }\n-\n-    if (taskChild !== null) {\n-      // Recursively propagate up the child tasks.\n+    const taskChild = updateCacheNodeOnNavigation(\n+      navigatedAt,\n+      oldUrl,\n+      oldCacheNodeChild,\n+      oldRouterStateChild,\n+      newRouterStateChild,\n+      shouldRefreshDynamicData,\n+      childDidFindRootLayout,\n+      prefetchDataChild ?? null,\n+      prefetchHeadChild,\n+      isPrefetchHeadPartialChild,\n+      isSamePageNavigation,\n+      segmentPath,\n+      parallelRouteKey,\n+      parentNeedsDynamicRequest || needsDynamicRequest,\n+      refreshUrl,\n+      accumulation\n+    )\n \n-      if (taskChild.route === null) {\n-        // One of the child tasks discovered a change to the root layout.\n-        // Immediately unwind from this recursive traversal.\n-        return MPA_NAVIGATION_TASK\n-      }\n+    if (taskChild === null) {\n+      // One of the child tasks discovered a change to the root layout.\n+      // Immediately unwind from this recursive traversal. This will trigger a\n+      // full-page navigation.\n+      return null\n+    }\n \n-      if (taskChildren === null) {\n-        taskChildren = new Map()\n-      }\n-      taskChildren.set(parallelRouteKey, taskChild)\n-      const newCacheNodeChild = taskChild.node\n-      if (newCacheNodeChild !== null) {\n-        const newSegmentMapChild: ChildSegmentMap = new Map(oldSegmentMapChild)\n-        newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild)\n-        prefetchParallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n-      }\n+    // Recursively propagate up the child tasks.\n+    if (taskChildren === null) {\n+      taskChildren = new Map()\n+    }\n+    taskChildren.set(parallelRouteKey, taskChild)\n+    const newCacheNodeChild = taskChild.node\n+    if (newCacheNodeChild !== null) {\n+      const newSegmentMapChild: ChildSegmentMap = new Map(oldSegmentMapChild)\n+      newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild)\n+      newParallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n+    }\n \n-      // The child tree's route state may be different from the prefetched\n-      // route sent by the server. We need to clone it as we traverse back up\n-      // the tree.\n-      const taskChildRoute = taskChild.route\n-      patchedRouterStateChildren[parallelRouteKey] = taskChildRoute\n-\n-      const dynamicRequestTreeChild = taskChild.dynamicRequestTree\n-      if (dynamicRequestTreeChild !== null) {\n-        // Something in the child tree is dynamic.\n-        needsDynamicRequest = true\n-        dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild\n-      } else {\n-        dynamicRequestTreeChildren[parallelRouteKey] = taskChildRoute\n-      }\n+    // The child tree's route state may be different from the prefetched\n+    // route sent by the server. We need to clone it as we traverse back up\n+    // the tree.\n+    const taskChildRoute = taskChild.route\n+    patchedRouterStateChildren[parallelRouteKey] = taskChildRoute\n+\n+    const dynamicRequestTreeChild = taskChild.dynamicRequestTree\n+    if (dynamicRequestTreeChild !== null) {\n+      // Something in the child tree is dynamic.\n+      childNeedsDynamicRequest = true\n+      dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild\n     } else {\n-      // The child didn't change. We can use the prefetched router state.\n-      patchedRouterStateChildren[parallelRouteKey] = newRouterStateChild\n-      dynamicRequestTreeChildren[parallelRouteKey] = newRouterStateChild\n+      dynamicRequestTreeChildren[parallelRouteKey] = taskChildRoute\n     }\n   }\n \n-  if (taskChildren === null) {\n-    // No new tasks were spawned.\n-    return null\n-  }\n-\n-  const newCacheNode: ReadyCacheNode = {\n-    lazyData: null,\n-    rsc: oldCacheNode.rsc,\n-    // We intentionally aren't updating the prefetchRsc field, since this node\n-    // is already part of the current tree, because it would be weird for\n-    // prefetch data to be newer than the final data. It probably won't ever be\n-    // observable anyway, but it could happen if the segment is unmounted then\n-    // mounted again, because LayoutRouter will momentarily switch to rendering\n-    // prefetchRsc, via useDeferredValue.\n-    prefetchRsc: oldCacheNode.prefetchRsc,\n-    head: oldCacheNode.head,\n-    prefetchHead: oldCacheNode.prefetchHead,\n-    loading: oldCacheNode.loading,\n-\n-    // Everything is cloned except for the children, which we computed above.\n-    parallelRoutes: prefetchParallelRoutes,\n-\n-    navigatedAt,\n-  }\n-\n   return {\n-    // Return a cloned copy of the router state with updated children.\n     route: patchRouterStateWithNewChildren(\n       newRouterState,\n       patchedRouterStateChildren\n     ),\n     node: newCacheNode,\n-    dynamicRequestTree: needsDynamicRequest\n-      ? patchRouterStateWithNewChildren(\n-          newRouterState,\n-          dynamicRequestTreeChildren\n-        )\n-      : null,\n-    // This function is never called during a refresh, only a regular\n-    // navigation, so we can always set this to null.\n-    refreshUrl: null,\n-    children: taskChildren,\n+    dynamicRequestTree: createDynamicRequestTree(\n+      newRouterState,\n+      dynamicRequestTreeChildren,\n+      needsDynamicRequest,\n+      childNeedsDynamicRequest,\n+      parentNeedsDynamicRequest\n+    ),\n+    refreshUrl,\n+    // NavigationTasks only have children if neither itself nor any of its\n+    // parents require a dynamic request. When writing dynamic data into the\n+    // tree, we can skip over any tasks that have children.\n+    // TODO: This is probably an unncessary optimization. The task tree only\n+    // lives for as long as the navigation request, anyway.\n+    children:\n+      parentNeedsDynamicRequest || needsDynamicRequest ? null : taskChildren,\n   }\n }\n \n-function beginRenderingNewRouteTree(\n+function createCacheNodeOnNavigation(\n   navigatedAt: number,\n-  oldRouterState: FlightRouterState | void,\n   newRouterState: FlightRouterState,\n-  existingCacheNode: CacheNode | void,\n-  didFindRootLayout: boolean,\n+  oldCacheNode: CacheNode | void,\n+  shouldRefreshDynamicData: boolean,\n   prefetchData: CacheNodeSeedData | null,\n-  possiblyPartialPrefetchHead: HeadData | null,\n+  prefetchHead: HeadData | null,\n   isPrefetchHeadPartial: boolean,\n-  segmentPath: FlightSegmentPath,\n+  parentSegmentPath: FlightSegmentPath,\n+  parentParallelRouteKey: string,\n+  parentNeedsDynamicRequest: boolean,\n   accumulation: NavigationRequestAccumulation\n-): Task {\n-  if (!didFindRootLayout) {\n-    // The route tree changed before we reached a layout. (The highest-level\n-    // layout in a route tree is referred to as the \"root\" layout.) This could\n-    // mean that we're navigating between two different root layouts. When this\n-    // happens, we perform a full-page (MPA-style) navigation.\n-    //\n-    // However, the algorithm for deciding where to start rendering a route\n-    // (i.e. the one performed in order to reach this function) is stricter\n-    // than the one used to detect a change in the root layout. So just because\n-    // we're re-rendering a segment outside of the root layout does not mean we\n-    // should trigger a full-page navigation.\n-    //\n-    // Specifically, we handle dynamic parameters differently: two segments are\n-    // considered the same even if their parameter values are different.\n-    //\n-    // Refer to isNavigatingToNewRootLayout for details.\n-    //\n-    // Note that we only have to perform this extra traversal if we didn't\n-    // already discover a root layout in the part of the tree that is unchanged.\n-    // In the common case, this branch is skipped completely.\n-    if (\n-      oldRouterState === undefined ||\n-      isNavigatingToNewRootLayout(oldRouterState, newRouterState)\n-    ) {\n-      // The root layout changed. Perform a full-page navigation.\n-      return MPA_NAVIGATION_TASK\n-    }\n-  }\n-  const isRefresh = false\n-  const refreshUrl = null\n-  return createCacheNodeOnNavigation(\n-    isRefresh,\n-    refreshUrl,\n-    navigatedAt,\n-    newRouterState,\n-    existingCacheNode,\n-    prefetchData,\n-    possiblyPartialPrefetchHead,\n-    isPrefetchHeadPartial,\n-    segmentPath,\n-    accumulation\n-  )\n-}\n+): NavigationTask {\n+  // Same traversal as updateCacheNodeNavigation, but simpler. We switch to this\n+  // path once we reach the part of the tree that was not in the previous route.\n+  // We don't need to diff against the old tree, we just need to create a new\n+  // one. We also don't need to worry about any refresh-related logic.\n+  //\n+  // For the most part, this is a subset of updateCacheNodeOnNavigation, so any\n+  // change that happens in this function likely needs to be applied to that\n+  // one, too. However there are some places where the behavior intentionally\n+  // diverges, which is why we keep them separate.\n \n-function createCacheNodeOnNavigation(\n-  isRefresh: boolean,\n-  parentRefreshUrl: string | null,\n-  navigatedAt: number,\n-  routerState: FlightRouterState,\n-  existingCacheNode: CacheNode | void,\n-  prefetchData: CacheNodeSeedData | null,\n-  possiblyPartialPrefetchHead: HeadData | null,\n-  isPrefetchHeadPartial: boolean,\n-  segmentPath: FlightSegmentPath,\n-  accumulation: NavigationRequestAccumulation\n-): SPANavigationTask {\n-  // Same traversal as updateCacheNodeNavigation, but we switch to this path\n-  // once we reach the part of the tree that was not in the previous route. We\n-  // don't need to diff against the old tree, we just need to create a new one.\n+  const newSegment = newRouterState[0]\n+  const segmentPath = parentSegmentPath.concat([\n+    parentParallelRouteKey,\n+    newSegment,\n+  ])\n \n-  // The head is assigned to every leaf segment delivered by the server. Based\n-  // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts\n-  const routerStateChildren = routerState[1]\n-  const isLeafSegment = Object.keys(routerStateChildren).length === 0\n-\n-  let refreshUrl: string | null\n-  if (isRefresh) {\n-    // During a refresh navigation, there's a special case that happens when\n-    // entering a \"default\" slot. The default slot may not be part of the\n-    // current route; it may have been reused from an older route. If so,\n-    // we need to fetch its data from the old route's URL rather than current\n-    // route's URL. Keep track of this as we traverse the tree. See\n-    // spawnPendingTask for more details.\n-    const href = routerState[2]\n-    refreshUrl =\n-      typeof href === 'string' && routerState[3] === 'refresh'\n-        ? // This segment is not present in the current route. Track its\n-          // refresh URL as we continue traversing the tree.\n-          href\n-        : // Inherit the refresh URL from the parent.\n-          parentRefreshUrl\n-  } else {\n-    // This is not a refresh, so there's no need to track the refresh URL as\n-    // we traverse the tree.\n-    refreshUrl = null\n+  const newRouterStateChildren = newRouterState[1]\n+  const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null\n+  const oldParallelRoutes =\n+    oldCacheNode !== undefined ? oldCacheNode.parallelRoutes : undefined\n+  const newParallelRoutes = new Map(\n+    shouldRefreshDynamicData ? undefined : oldParallelRoutes\n+  )\n+  const isLeafSegment = Object.keys(newRouterStateChildren).length === 0\n+\n+  if (isLeafSegment) {\n+    // The segment path of every leaf segment (i.e. page) is collected into\n+    // a result array. This is used by the LayoutRouter to scroll to ensure that\n+    // new pages are visible after a navigation.\n+    //\n+    // This only happens for new pages, not for refreshed pages.\n+    //\n+    // TODO: We should use a string to represent the segment path instead of\n+    // an array. We already use a string representation for the path when\n+    // accessing the Segment Cache, so we can use the same one.\n+    accumulation.scrollableSegments.push(segmentPath)\n   }\n \n-  // Even we're rendering inside the \"new\" part of the target tree, we may have\n-  // a locally cached segment that we can reuse. This may come from either 1)\n-  // the CacheNode tree, which lives in React state and is populated by previous\n-  // navigations; or 2) the prefetch cache, which is a separate cache that is\n-  // populated by prefetches.\n-  let rsc: React.ReactNode\n-  let loading: LoadingModuleData | Promise<LoadingModuleData>\n-  let head: HeadData | null\n-  let cacheNodeNavigatedAt: number\n+  let newCacheNode: ReadyCacheNode\n+  let needsDynamicRequest: boolean\n   if (\n-    existingCacheNode !== undefined &&\n+    !shouldRefreshDynamicData &&\n+    oldCacheNode !== undefined &&\n     // DYNAMIC_STALETIME_MS defaults to 0, but it can be increased using\n     // the experimental.staleTimes.dynamic config. When set, we'll avoid\n     // refetching dynamic data if it was fetched within the given threshold.\n     // TODO: We should use this same logic for popstate navigations, replacing\n     // the `updateCacheNodeOnPopstateRestoration` function. That way we can\n     // handle the case where the data is missing here, like we would for a\n     // normal navigation, rather than rely on the lazy fetch in LazyRouter.\n-    existingCacheNode.navigatedAt + DYNAMIC_STALETIME_MS > navigatedAt\n+    oldCacheNode.navigatedAt + DYNAMIC_STALETIME_MS > navigatedAt\n   ) {\n-    // We have an existing CacheNode for this segment, and it's not stale. We\n-    // should reuse it rather than request a new one.\n-    rsc = existingCacheNode.rsc\n-    loading = existingCacheNode.loading\n-    head = existingCacheNode.head\n-\n-    // Don't update the navigatedAt timestamp, since we're reusing stale data.\n-    cacheNodeNavigatedAt = existingCacheNode.navigatedAt\n+    // Reuse the existing CacheNode\n+    newCacheNode = reuseDynamicCacheNode(oldCacheNode, newParallelRoutes)\n+    needsDynamicRequest = false\n   } else if (prefetchData !== null) {\n-    // There's no existing CacheNode for this segment, but we do have prefetch\n-    // data. If the prefetch data is fully static (i.e. does not contain any\n-    // dynamic holes), we don't need to request it from the server.\n-    rsc = prefetchData[0]\n-    loading = prefetchData[2]\n-    head = isLeafSegment ? possiblyPartialPrefetchHead : null\n-    // Even though we're accessing the data from the prefetch cache, this is\n-    // conceptually a new segment, not a reused one. So we should update the\n-    // navigatedAt timestamp.\n-    cacheNodeNavigatedAt = navigatedAt\n-    const isPrefetchRscPartial = prefetchData[3]\n-    if (\n-      // Check if the segment data is partial\n-      isPrefetchRscPartial ||\n-      // Check if the head is partial (only relevant if this is a leaf segment)\n-      (isPrefetchHeadPartial && isLeafSegment)\n-    ) {\n-      // We only have partial data from this segment. Like missing segments, we\n-      // must request the full data from the server.\n-      return spawnPendingTask(\n-        isRefresh,\n-        refreshUrl,\n-        navigatedAt,\n-        routerState,\n-        prefetchData,\n-        possiblyPartialPrefetchHead,\n-        isPrefetchHeadPartial,\n-        segmentPath,\n-        accumulation\n-      )\n-    } else {\n-      // The prefetch data is fully static, so we can omit it from the\n-      // navigation request.\n-    }\n-  } else {\n-    // There's no prefetch for this segment. Everything from this point will be\n-    // requested from the server, even if there are static children below it.\n-    // Create a terminal task node that will later be fulfilled by\n-    // server response.\n-    return spawnPendingTask(\n-      isRefresh,\n-      refreshUrl,\n-      navigatedAt,\n-      routerState,\n-      null,\n-      possiblyPartialPrefetchHead,\n+    // Consult the prefetch cache.\n+    const prefetchRsc = prefetchData[0]\n+    const prefetchLoading = prefetchData[2]\n+    const isPrefetchRSCPartial = prefetchData[3]\n+    newCacheNode = readCacheNodeFromSeedData(\n+      prefetchRsc,\n+      prefetchLoading,\n+      isPrefetchRSCPartial,\n+      prefetchHead,\n       isPrefetchHeadPartial,\n-      segmentPath,\n-      accumulation\n+      isLeafSegment,\n+      newParallelRoutes,\n+      navigatedAt\n     )\n+    needsDynamicRequest =\n+      isPrefetchRSCPartial || (isLeafSegment && isPrefetchHeadPartial)\n+  } else {\n+    // Spawn a request to fetch new data from the server.\n+    newCacheNode = spawnNewCacheNode(\n+      newParallelRoutes,\n+      isLeafSegment,\n+      navigatedAt\n+    )\n+    needsDynamicRequest = true\n   }\n \n-  // We already have a full segment we can render, so we don't need to request a\n-  // new one from the server. Keep traversing down the tree until we reach\n-  // something that requires a dynamic request.\n-  const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null\n-  const taskChildren = new Map()\n-  const existingCacheNodeChildren =\n-    existingCacheNode !== undefined ? existingCacheNode.parallelRoutes : null\n-  const cacheNodeChildren = new Map(existingCacheNodeChildren)\n+  let patchedRouterStateChildren: {\n+    [parallelRouteKey: string]: FlightRouterState\n+  } = {}\n+  let taskChildren = null\n+\n+  let childNeedsDynamicRequest = false\n   let dynamicRequestTreeChildren: {\n     [parallelRouteKey: string]: FlightRouterState\n   } = {}\n-  let needsDynamicRequest = false\n-  if (isLeafSegment) {\n-    // The segment path of every leaf segment (i.e. page) is collected into\n-    // a result array. This is used by the LayoutRouter to scroll to ensure that\n-    // new pages are visible after a navigation.\n-    // TODO: We should use a string to represent the segment path instead of\n-    // an array. We already use a string representation for the path when\n-    // accessing the Segment Cache, so we can use the same one.\n-    accumulation.scrollableSegments.push(segmentPath)\n-  } else {\n-    for (let parallelRouteKey in routerStateChildren) {\n-      const routerStateChild: FlightRouterState =\n-        routerStateChildren[parallelRouteKey]\n-      const prefetchDataChild: CacheNodeSeedData | void | null =\n-        prefetchDataChildren !== null\n-          ? prefetchDataChildren[parallelRouteKey]\n-          : null\n-      const existingSegmentMapChild =\n-        existingCacheNodeChildren !== null\n-          ? existingCacheNodeChildren.get(parallelRouteKey)\n-          : undefined\n-      const segmentChild = routerStateChild[0]\n-      const segmentPathChild = segmentPath.concat([\n-        parallelRouteKey,\n-        segmentChild,\n-      ])\n-      const segmentKeyChild = createRouterCacheKey(segmentChild)\n-\n-      const existingCacheNodeChild =\n-        existingSegmentMapChild !== undefined\n-          ? existingSegmentMapChild.get(segmentKeyChild)\n-          : undefined\n-\n-      const taskChild = createCacheNodeOnNavigation(\n-        isRefresh,\n-        refreshUrl,\n-        navigatedAt,\n-        routerStateChild,\n-        existingCacheNodeChild,\n-        prefetchDataChild,\n-        possiblyPartialPrefetchHead,\n-        isPrefetchHeadPartial,\n-        segmentPathChild,\n-        accumulation\n-      )\n-      taskChildren.set(parallelRouteKey, taskChild)\n-      const dynamicRequestTreeChild = taskChild.dynamicRequestTree\n-      if (dynamicRequestTreeChild !== null) {\n-        // Something in the child tree is dynamic.\n-        needsDynamicRequest = true\n-        dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild\n-      } else {\n-        dynamicRequestTreeChildren[parallelRouteKey] = routerStateChild\n-      }\n-      const newCacheNodeChild = taskChild.node\n-      if (newCacheNodeChild !== null) {\n-        const newSegmentMapChild: ChildSegmentMap = new Map()\n-        newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild)\n-        cacheNodeChildren.set(parallelRouteKey, newSegmentMapChild)\n-      }\n+\n+  for (let parallelRouteKey in newRouterStateChildren) {\n+    const newRouterStateChild: FlightRouterState =\n+      newRouterStateChildren[parallelRouteKey]\n+    const oldSegmentMapChild =\n+      oldParallelRoutes !== undefined\n+        ? oldParallelRoutes.get(parallelRouteKey)\n+        : undefined\n+    const prefetchDataChild: CacheNodeSeedData | void | null =\n+      prefetchDataChildren !== null\n+        ? prefetchDataChildren[parallelRouteKey]\n+        : null\n+\n+    const newSegmentChild = newRouterStateChild[0]\n+    const newSegmentKeyChild = createRouterCacheKey(newSegmentChild)\n+\n+    const oldCacheNodeChild =\n+      oldSegmentMapChild !== undefined\n+        ? oldSegmentMapChild.get(newSegmentKeyChild)\n+        : undefined\n+\n+    const taskChild = createCacheNodeOnNavigation(\n+      navigatedAt,\n+      newRouterStateChild,\n+      oldCacheNodeChild,\n+      shouldRefreshDynamicData,\n+      prefetchDataChild ?? null,\n+      prefetchHead,\n+      isPrefetchHeadPartial,\n+      segmentPath,\n+      parallelRouteKey,\n+      parentNeedsDynamicRequest || needsDynamicRequest,\n+      accumulation\n+    )\n+\n+    if (taskChildren === null) {\n+      taskChildren = new Map()\n+    }\n+    taskChildren.set(parallelRouteKey, taskChild)\n+    const newCacheNodeChild = taskChild.node\n+    if (newCacheNodeChild !== null) {\n+      const newSegmentMapChild: ChildSegmentMap = new Map(oldSegmentMapChild)\n+      newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild)\n+      newParallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n+    }\n+\n+    const taskChildRoute = taskChild.route\n+    patchedRouterStateChildren[parallelRouteKey] = taskChildRoute\n+\n+    const dynamicRequestTreeChild = taskChild.dynamicRequestTree\n+    if (dynamicRequestTreeChild !== null) {\n+      childNeedsDynamicRequest = true\n+      dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild\n+    } else {\n+      dynamicRequestTreeChildren[parallelRouteKey] = taskChildRoute\n     }\n   }\n \n   return {\n-    // Since we're inside a new route tree, unlike the\n-    // `updateCacheNodeOnNavigation` path, the router state on the children\n-    // tasks is always the same as the router state we pass in. So we don't need\n-    // to clone/modify it.\n-    route: routerState,\n-    node: {\n-      lazyData: null,\n-      // Since this segment is already full, we don't need to use the\n-      // `prefetchRsc` field.\n-      rsc,\n-      prefetchRsc: null,\n-      head,\n-      prefetchHead: null,\n-      loading,\n-      parallelRoutes: cacheNodeChildren,\n-      navigatedAt: cacheNodeNavigatedAt,\n-    },\n-    dynamicRequestTree: needsDynamicRequest\n-      ? patchRouterStateWithNewChildren(routerState, dynamicRequestTreeChildren)\n-      : null,\n-    refreshUrl,\n-    children: taskChildren,\n+    route: patchRouterStateWithNewChildren(\n+      newRouterState,\n+      patchedRouterStateChildren\n+    ),\n+    node: newCacheNode,\n+    dynamicRequestTree: createDynamicRequestTree(\n+      newRouterState,\n+      dynamicRequestTreeChildren,\n+      needsDynamicRequest,\n+      childNeedsDynamicRequest,\n+      parentNeedsDynamicRequest\n+    ),\n+    // This route is not part of the current tree, so there's no reason to\n+    // track the refresh URL.\n+    refreshUrl: null,\n+    children:\n+      parentNeedsDynamicRequest || needsDynamicRequest ? null : taskChildren,\n   }\n }\n \n@@ -789,52 +669,40 @@ function patchRouterStateWithNewChildren(\n   return clone\n }\n \n-function spawnPendingTask(\n-  isRefresh: boolean,\n-  refreshUrl: string | null,\n-  navigatedAt: number,\n-  routerState: FlightRouterState,\n-  prefetchData: CacheNodeSeedData | null,\n-  prefetchHead: HeadData | null,\n-  isPrefetchHeadPartial: boolean,\n-  segmentPath: FlightSegmentPath,\n-  accumulation: NavigationRequestAccumulation\n-): SPANavigationTask {\n-  // Create a task that will later be fulfilled by data from the server.\n-\n-  // Clone the prefetched route tree and the `refetch` marker to it. We'll send\n-  // this to the server so it knows where to start rendering.\n-  const dynamicRequestTree = patchRouterStateWithNewChildren(\n-    routerState,\n-    routerState[1]\n-  )\n-  dynamicRequestTree[3] = 'refetch'\n-\n-  if (isRefresh && refreshUrl !== null) {\n-    accumulateRefreshUrl(accumulation, refreshUrl)\n-  }\n-\n-  const newTask: Task = {\n-    route: routerState,\n-\n-    // Corresponds to the part of the route that will be rendered on the server.\n-    node: createPendingCacheNode(\n-      isRefresh,\n-      navigatedAt,\n-      routerState,\n-      prefetchData,\n-      prefetchHead,\n-      isPrefetchHeadPartial,\n-      segmentPath,\n-      accumulation\n-    ),\n-    // Because this is non-null, and it gets propagated up through the parent\n-    // tasks, the root task will know that it needs to perform a server request.\n-    dynamicRequestTree,\n-    refreshUrl,\n-    children: null,\n+function createDynamicRequestTree(\n+  newRouterState: FlightRouterState,\n+  dynamicRequestTreeChildren: Record<string, FlightRouterState>,\n+  needsDynamicRequest: boolean,\n+  childNeedsDynamicRequest: boolean,\n+  parentNeedsDynamicRequest: boolean\n+): FlightRouterState | null {\n+  // Create a FlightRouterState that instructs the server how to render the\n+  // requested segment.\n+  //\n+  // Or, if neither this segment nor any of the children require a new data,\n+  // then we return `null` to skip the request.\n+  let dynamicRequestTree: FlightRouterState | null = null\n+  if (needsDynamicRequest) {\n+    dynamicRequestTree = patchRouterStateWithNewChildren(\n+      newRouterState,\n+      dynamicRequestTreeChildren\n+    )\n+    // The \"refetch\" marker is set on the top-most segment that requires new\n+    // data. We can omit it if a parent was already marked.\n+    if (!parentNeedsDynamicRequest) {\n+      dynamicRequestTree[3] = 'refetch'\n+    }\n+  } else if (childNeedsDynamicRequest) {\n+    // This segment does not request new data, but at least one of its\n+    // children does.\n+    dynamicRequestTree = patchRouterStateWithNewChildren(\n+      newRouterState,\n+      dynamicRequestTreeChildren\n+    )\n+  } else {\n+    dynamicRequestTree = null\n   }\n-  return newTask\n+  return dynamicRequestTree\n }\n \n function accumulateRefreshUrl(\n@@ -862,7 +730,7 @@ function accumulateRefreshUrl(\n function reuseActiveSegmentInDefaultSlot(\n   oldUrl: URL,\n   oldRouterState: FlightRouterState\n-): Task {\n+): FlightRouterState {\n   // This is a \"default\" segment. These are never sent by the server during a\n   // soft navigation; instead, the client reuses whatever segment was already\n   // active in that slot on the previous route. This means if we later need to\n@@ -890,15 +758,103 @@ function reuseActiveSegmentInDefaultSlot(\n     reusedRouterState[3] = 'refresh'\n   }\n \n-  return {\n-    route: reusedRouterState,\n-    node: null,\n-    dynamicRequestTree: null,\n-    // This function is never called during a refresh, only a regular\n-    // navigation, so we can always set this to null.\n-    refreshUrl: null,\n-    children: null,\n+  return reusedRouterState\n+}\n+\n+function reuseDynamicCacheNode(\n+  existingCacheNode: CacheNode,\n+  parallelRoutes: Map<string, ChildSegmentMap>\n+): ReadyCacheNode {\n+  // Clone an existing CacheNode's data, with (possibly) new children.\n+  const cacheNode: ReadyCacheNode = {\n+    lazyData: null,\n+    rsc: existingCacheNode.rsc,\n+    prefetchRsc: existingCacheNode.prefetchRsc,\n+    head: existingCacheNode.head,\n+    prefetchHead: existingCacheNode.prefetchHead,\n+    loading: existingCacheNode.loading,\n+\n+    parallelRoutes,\n+\n+    // Don't update the navigatedAt timestamp, since we're reusing\n+    // existing data.\n+    navigatedAt: existingCacheNode.navigatedAt,\n   }\n+  return cacheNode\n+}\n+\n+function readCacheNodeFromSeedData(\n+  prefetchRsc: React.ReactNode,\n+  prefetchLoading: LoadingModuleData | Promise<LoadingModuleData>,\n+  isPrefetchRSCPartial: boolean,\n+  prefetchHead: HeadData | null,\n+  isPrefetchHeadPartial: boolean,\n+  isPageSegment: boolean,\n+  parallelRoutes: Map<string, ChildSegmentMap>,\n+  navigatedAt: number\n+): ReadyCacheNode {\n+  // TODO: Currently this is threaded through the navigation logic using the\n+  // CacheNodeSeedData type, but in the future this will read directly from\n+  // the Segment Cache. See readRenderSnapshotFromCache.\n+\n+  let rsc: React.ReactNode\n+  if (isPrefetchRSCPartial) {\n+    // The prefetched data contains dynamic holes. Create a pending promise that\n+    // will be fulfilled when the dynamic data is received from the server.\n+    rsc = createDeferredRsc()\n+  } else {\n+    // The prefetched data is complete. Use it directly.\n+    rsc = prefetchRsc\n+  }\n+\n+  // If this is a page segment, also read the head.\n+  let resolvedPrefetchHead: HeadData | null\n+  let resolvedHead: HeadData | null\n+  if (isPageSegment) {\n+    resolvedPrefetchHead = prefetchHead\n+    if (isPrefetchHeadPartial) {\n+      resolvedHead = createDeferredRsc()\n+    } else {\n+      resolvedHead = prefetchHead\n+    }\n+  } else {\n+    resolvedPrefetchHead = null\n+    resolvedHead = null\n+  }\n+\n+  const cacheNode: ReadyCacheNode = {\n+    lazyData: null,\n+    rsc,\n+    prefetchRsc,\n+    head: resolvedHead,\n+    prefetchHead: resolvedPrefetchHead,\n+    // TODO: Technically, a loading boundary could contain dynamic data. We\n+    // should have separate `loading` and `prefetchLoading` fields to handle\n+    // this, like we do for the segment data and head.\n+    loading: prefetchLoading,\n+    parallelRoutes,\n+    navigatedAt,\n+  }\n+\n+  return cacheNode\n+}\n+\n+function spawnNewCacheNode(\n+  parallelRoutes: Map<string, ChildSegmentMap>,\n+  isLeafSegment: boolean,\n+  navigatedAt: number\n+): ReadyCacheNode {\n+  const cacheNode: ReadyCacheNode = {\n+    lazyData: null,\n+    rsc: createDeferredRsc(),\n+    prefetchRsc: null,\n+    head: isLeafSegment ? createDeferredRsc() : null,\n+    prefetchHead: null,\n+    loading: createDeferredRsc<LoadingModuleData>(),\n+    parallelRoutes,\n+    navigatedAt,\n+  }\n+  return cacheNode\n }\n \n // Writes a dynamic server response into the tree created by\n@@ -919,8 +875,11 @@ function reuseActiveSegmentInDefaultSlot(\n export function listenForDynamicRequest(\n   url: URL,\n   nextUrl: string | null,\n-  task: SPANavigationTask,\n+  task: NavigationTask,\n   dynamicRequestTree: FlightRouterState,\n+  // TODO: Rather than pass this into listenForDynamicRequest, we should seed\n+  // the data into the CacheNode tree during the first traversal. Similar to\n+  // what we will do for seeding navigations from a Server Action.\n   existingDynamicRequestPromise: Promise<FetchServerResponseResult> | null,\n   accumulation: NavigationRequestAccumulation\n ): void {\n@@ -1029,7 +988,7 @@ export function listenForDynamicRequest(\n }\n \n function attachServerResponseListener(\n-  task: SPANavigationTask,\n+  task: NavigationTask,\n   requestPromise: Promise<FetchServerResponseResult>\n ): Promise<void> {\n   return requestPromise.then((result) => {\n@@ -1068,7 +1027,7 @@ function attachServerResponseListener(\n }\n \n function writeDynamicDataIntoPendingTask(\n-  rootTask: SPANavigationTask,\n+  rootTask: NavigationTask,\n   segmentPath: FlightSegmentPath,\n   serverRouterState: FlightRouterState,\n   dynamicData: CacheNodeSeedData,\n@@ -1118,7 +1077,7 @@ function writeDynamicDataIntoPendingTask(\n }\n \n function finishTaskUsingDynamicDataPayload(\n-  task: SPANavigationTask,\n+  task: NavigationTask,\n   serverRouterState: FlightRouterState,\n   dynamicData: CacheNodeSeedData,\n   dynamicHead: HeadData,\n@@ -1154,7 +1113,7 @@ function finishTaskUsingDynamicDataPayload(\n   const serverChildren = serverRouterState[1]\n   const dynamicDataChildren = dynamicData[1]\n \n-  for (const parallelRouteKey in serverRouterState) {\n+  for (const parallelRouteKey in serverChildren) {\n     const serverRouterStateChild: FlightRouterState =\n       serverChildren[parallelRouteKey]\n     const dynamicDataChild: CacheNodeSeedData | null | void =\n@@ -1169,7 +1128,7 @@ function finishTaskUsingDynamicDataPayload(\n         dynamicDataChild !== undefined\n       ) {\n         // Found a match for this task. Keep traversing down the task tree.\n-        return finishTaskUsingDynamicDataPayload(\n+        finishTaskUsingDynamicDataPayload(\n           taskChild,\n           serverRouterStateChild,\n           dynamicDataChild,\n@@ -1178,103 +1137,6 @@ function finishTaskUsingDynamicDataPayload(\n         )\n       }\n     }\n-    // We didn't find a child task that matches the server data. We won't abort\n-    // the task, though, because a different FlightDataPath may be able to\n-    // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n-    // once we've run out of data.\n-  }\n-}\n-\n-function createPendingCacheNode(\n-  isRefresh: boolean,\n-  navigatedAt: number,\n-  routerState: FlightRouterState,\n-  prefetchData: CacheNodeSeedData | null,\n-  prefetchHead: HeadData | null,\n-  isPrefetchHeadPartial: boolean,\n-  segmentPath: FlightSegmentPath,\n-  accumulation: NavigationRequestAccumulation\n-): ReadyCacheNode {\n-  const routerStateChildren = routerState[1]\n-  const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null\n-\n-  if (isRefresh) {\n-    const refreshUrl = routerState[2]\n-    if (typeof refreshUrl === 'string' && routerState[3] === 'refresh') {\n-      accumulateRefreshUrl(accumulation, refreshUrl)\n-    }\n-  }\n-\n-  const parallelRoutes = new Map()\n-  for (let parallelRouteKey in routerStateChildren) {\n-    const routerStateChild: FlightRouterState =\n-      routerStateChildren[parallelRouteKey]\n-    const prefetchDataChild: CacheNodeSeedData | null | void =\n-      prefetchDataChildren !== null\n-        ? prefetchDataChildren[parallelRouteKey]\n-        : null\n-\n-    const segmentChild = routerStateChild[0]\n-    const segmentPathChild = segmentPath.concat([\n-      parallelRouteKey,\n-      segmentChild,\n-    ])\n-    const segmentKeyChild = createRouterCacheKey(segmentChild)\n-\n-    const newCacheNodeChild = createPendingCacheNode(\n-      isRefresh,\n-      navigatedAt,\n-      routerStateChild,\n-      prefetchDataChild === undefined ? null : prefetchDataChild,\n-      prefetchHead,\n-      isPrefetchHeadPartial,\n-      segmentPathChild,\n-      accumulation\n-    )\n-\n-    const newSegmentMapChild: ChildSegmentMap = new Map()\n-    newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild)\n-    parallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n-  }\n-\n-  // The head is assigned to every leaf segment delivered by the server. Based\n-  // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts\n-  const isLeafSegment = parallelRoutes.size === 0\n-\n-  if (isLeafSegment) {\n-    // The segment path of every leaf segment (i.e. page) is collected into\n-    // a result array. This is used by the LayoutRouter to scroll to ensure that\n-    // new pages are visible after a navigation.\n-    // TODO: We should use a string to represent the segment path instead of\n-    // an array. We already use a string representation for the path when\n-    // accessing the Segment Cache, so we can use the same one.\n-    accumulation.scrollableSegments.push(segmentPath)\n-  }\n-\n-  const maybePrefetchRsc = prefetchData !== null ? prefetchData[0] : null\n-  return {\n-    lazyData: null,\n-    parallelRoutes: parallelRoutes,\n-\n-    prefetchRsc: maybePrefetchRsc !== undefined ? maybePrefetchRsc : null,\n-    prefetchHead: isLeafSegment ? prefetchHead : [null, null],\n-\n-    // Create a deferred promise. This will be fulfilled once the dynamic\n-    // response is received from the server.\n-    rsc: createDeferredRsc() as React.ReactNode,\n-    head: isLeafSegment ? (createDeferredRsc() as React.ReactNode) : null,\n-\n-    // TODO: Technically, a loading boundary could contain dynamic data. We must\n-    // have separate `loading` and `prefetchLoading` fields to handle this, like\n-    // we do for the segment data and head.\n-    loading:\n-      prefetchData !== null\n-        ? (prefetchData[2] ?? null)\n-        : // If we don't have a prefetch, then we don't know if there's a loading component.\n-          // We'll fulfill it based on the dynamic response, just like `rsc` and `head`.\n-          createDeferredRsc<LoadingModuleData>(),\n-\n-    navigatedAt,\n   }\n }\n \n@@ -1336,15 +1198,7 @@ function finishPendingCacheNode(\n           dynamicHead,\n           debugInfo\n         )\n-      } else {\n-        // The response does not include data for this segment, but it may\n-        // be included in a separate response. Don't abort the task until all\n-        // responses are received.\n       }\n-    } else {\n-      // There's no matching Cache Node in the task tree. This is a bug in the\n-      // implementation because we should have created a node for every segment\n-      // in the tree that's associated with this task.\n     }\n   }\n \n@@ -1384,7 +1238,7 @@ function finishPendingCacheNode(\n }\n \n export function abortTask(\n-  task: SPANavigationTask,\n+  task: NavigationTask,\n   error: any,\n   debugInfo: Array<any> | null\n ): void {\n@@ -1483,7 +1337,13 @@ export function updateCacheNodeOnPopstateRestoration(\n   // This function clones the entire cache node tree and sets the `prefetchRsc`\n   // field to `null` to prevent it from being rendered. We can't mutate the node\n   // in place because this is a concurrent data structure.\n-\n+  //\n+  // TODO: Delete this function and instead move the logic into the normal\n+  // navigation path (updateCacheNodeOnNavigation) to ensure we handle all the\n+  // same cases. The only difference is that whenever a segment is missing, we\n+  // should always check for existing dynamic data rather than spawning a new\n+  // request. We can handle this using the same branch that handles stale\n+  // dynamic data (see createCacheNodeOnNavigation).\n   const routerStateChildren = routerState[1]\n   const oldParallelRoutes = oldCacheNode.parallelRoutes\n   const newParallelRoutes = new Map(oldParallelRoutes)"
        },
        {
            "sha": "8afaa1c40ac0db634b1495ccc187511bdee13a46",
            "filename": "packages/next/src/client/components/router-reducer/reducers/navigate-reducer.ts",
            "status": "modified",
            "additions": 15,
            "deletions": 22,
            "changes": 37,
            "blob_url": "https://github.com/vercel/next.js/blob/e9a03ac12cfe3c3fb6b16db42ade06e7382b9018/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fnavigate-reducer.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/e9a03ac12cfe3c3fb6b16db42ade06e7382b9018/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fnavigate-reducer.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fnavigate-reducer.ts?ref=e9a03ac12cfe3c3fb6b16db42ade06e7382b9018",
            "patch": "@@ -80,11 +80,21 @@ export function handleNavigationResult(\n       const newUrl = result.data\n       return handleExternalUrl(state, mutable, newUrl, pendingPush)\n     }\n-    case NavigationResultTag.NoOp: {\n-      // The server responded with no change to the current page. However, if\n-      // the URL changed, we still need to update that.\n-      const newCanonicalUrl = result.data.canonicalUrl\n-      mutable.canonicalUrl = newCanonicalUrl\n+    case NavigationResultTag.Success: {\n+      // Received a new result.\n+      mutable.cache = result.data.cacheNode\n+      mutable.patchedTree = result.data.flightRouterState\n+      mutable.renderedSearch = result.data.renderedSearch\n+      mutable.canonicalUrl = result.data.canonicalUrl\n+      // TODO: During a refresh, we don't set the `scrollableSegments`. There's\n+      // some confusing and subtle logic in `handleMutable` that decides what\n+      // to do when `shouldScroll` is set but `scrollableSegments` is not. I'm\n+      // not convinced it's totally coherent but the tests assert on this\n+      // particular behavior so I've ported the logic as-is from the previous\n+      // router implementation, for now.\n+      mutable.scrollableSegments = result.data.scrollableSegments ?? undefined\n+      mutable.shouldScroll = result.data.shouldScroll\n+      mutable.hashFragment = result.data.hash\n \n       // Check if the only thing that changed was the hash fragment.\n       const oldUrl = new URL(state.canonicalUrl, url)\n@@ -106,23 +116,6 @@ export function handleNavigationResult(\n \n       return handleMutable(state, mutable)\n     }\n-    case NavigationResultTag.Success: {\n-      // Received a new result.\n-      mutable.cache = result.data.cacheNode\n-      mutable.patchedTree = result.data.flightRouterState\n-      mutable.renderedSearch = result.data.renderedSearch\n-      mutable.canonicalUrl = result.data.canonicalUrl\n-      // TODO: During a refresh, we don't set the `scrollableSegments`. There's\n-      // some confusing and subtle logic in `handleMutable` that decides what\n-      // to do when `shouldScroll` is set but `scrollableSegments` is not. I'm\n-      // not convinced it's totally coherent but the tests assert on this\n-      // particular behavior so I've ported the logic as-is from the previous\n-      // router implementation, for now.\n-      mutable.scrollableSegments = result.data.scrollableSegments ?? undefined\n-      mutable.shouldScroll = result.data.shouldScroll\n-      mutable.hashFragment = result.data.hash\n-      return handleMutable(state, mutable)\n-    }\n     case NavigationResultTag.Async: {\n       return result.data.then(\n         (asyncResult) =>"
        },
        {
            "sha": "1c47f3c72ef3da5386e9bb92a4186d9b00744a93",
            "filename": "packages/next/src/client/components/router-reducer/reducers/refresh-reducer.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/e9a03ac12cfe3c3fb6b16db42ade06e7382b9018/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Frefresh-reducer.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/e9a03ac12cfe3c3fb6b16db42ade06e7382b9018/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Frefresh-reducer.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Frefresh-reducer.ts?ref=e9a03ac12cfe3c3fb6b16db42ade06e7382b9018",
            "patch": "@@ -6,14 +6,23 @@ import type {\n } from '../router-reducer-types'\n import { handleNavigationResult } from './navigate-reducer'\n import { refresh as refreshUsingSegmentCache } from '../../segment-cache/navigation'\n+import { revalidateEntireCache } from '../../segment-cache/cache'\n \n export function refreshReducer(\n   state: ReadonlyReducerState,\n   action: RefreshAction\n ): ReducerState {\n+  // TODO: Currently, all refreshes purge the prefetch cache. In the future,\n+  // only client-side refreshes will have this behavior; the server-side\n+  // `refresh` should send new data without purging the prefetch cache.\n+  const currentNextUrl = state.nextUrl\n+  const currentRouterState = state.tree\n+  revalidateEntireCache(currentNextUrl, currentRouterState)\n+\n   const currentUrl = new URL(state.canonicalUrl, action.origin)\n   const result = refreshUsingSegmentCache(\n     currentUrl,\n+    state.cache,\n     state.tree,\n     state.nextUrl,\n     state.renderedSearch,"
        },
        {
            "sha": "452f2c13a13786b1ddf2825e45c51a16eab603b3",
            "filename": "packages/next/src/client/components/segment-cache/navigation.ts",
            "status": "modified",
            "additions": 51,
            "deletions": 78,
            "changes": 129,
            "blob_url": "https://github.com/vercel/next.js/blob/e9a03ac12cfe3c3fb6b16db42ade06e7382b9018/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fnavigation.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/e9a03ac12cfe3c3fb6b16db42ade06e7382b9018/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fnavigation.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fnavigation.ts?ref=e9a03ac12cfe3c3fb6b16db42ade06e7382b9018",
            "patch": "@@ -12,9 +12,8 @@ import type { NormalizedFlightData } from '../../flight-data-helpers'\n import { fetchServerResponse } from '../router-reducer/fetch-server-response'\n import {\n   startPPRNavigation,\n-  startPPRRefresh,\n   listenForDynamicRequest,\n-  type Task as PPRNavigationTask,\n+  type NavigationTask,\n   type NavigationRequestAccumulation,\n } from '../router-reducer/ppr-navigations'\n import { createHrefFromUrl } from '../router-reducer/create-href-from-url'\n@@ -37,14 +36,6 @@ type MPANavigationResult = {\n   data: string\n }\n \n-type NoOpNavigationResult = {\n-  tag: NavigationResultTag.NoOp\n-  data: {\n-    canonicalUrl: string\n-    shouldScroll: boolean\n-  }\n-}\n-\n type SuccessfulNavigationResult = {\n   tag: NavigationResultTag.Success\n   data: {\n@@ -60,15 +51,12 @@ type SuccessfulNavigationResult = {\n \n type AsyncNavigationResult = {\n   tag: NavigationResultTag.Async\n-  data: Promise<\n-    MPANavigationResult | NoOpNavigationResult | SuccessfulNavigationResult\n-  >\n+  data: Promise<MPANavigationResult | SuccessfulNavigationResult>\n }\n \n export type NavigationResult =\n   | MPANavigationResult\n   | SuccessfulNavigationResult\n-  | NoOpNavigationResult\n   | AsyncNavigationResult\n \n /**\n@@ -82,7 +70,7 @@ export type NavigationResult =\n export function navigate(\n   url: URL,\n   currentUrl: URL,\n-  currentCacheNode: CacheNode,\n+  currentCacheNode: CacheNode | null,\n   currentFlightRouterState: FlightRouterState,\n   nextUrl: string | null,\n   shouldScroll: boolean,\n@@ -223,25 +211,34 @@ export function navigate(\n \n export function refresh(\n   currentUrl: URL,\n+  currentCacheNode: CacheNode,\n   currentFlightRouterState: FlightRouterState,\n   currentNextUrl: string | null,\n   currentRenderedSearch: string,\n   currentCanonicalUrl: string\n-): SuccessfulNavigationResult | NoOpNavigationResult | MPANavigationResult {\n+): SuccessfulNavigationResult | MPANavigationResult {\n   // A refresh is a special case of a navigation where all the dynamic data\n   // on the current router is re-fetched. Most of the logic is handled within\n-  // the ppr-navigations module. The main difference here is that we call\n-  // startPPRRefresh instead of startPPRNavigation.\n+  // the ppr-navigations module. The main difference here is that we set\n+  // shouldRefreshDynamicData to true.\n   const now = Date.now()\n   const shouldScroll = true\n   const accumulation: NavigationRequestAccumulation = {\n     scrollableSegments: [],\n     separateRefreshUrls: null,\n   }\n-  const task = startPPRRefresh(\n+  const shouldRefreshDynamicData = true\n+  const task = startPPRNavigation(\n     now,\n+    currentUrl,\n+    currentCacheNode,\n+    currentFlightRouterState,\n     currentFlightRouterState,\n-    currentNextUrl,\n+    shouldRefreshDynamicData,\n+    null,\n+    null,\n+    false,\n+    true,\n     accumulation\n   )\n   if (task !== null) {\n@@ -268,31 +265,26 @@ export function refresh(\n \n     const newTree = task.route\n     const newCacheNode = task.node\n-    if (newTree !== null && newCacheNode !== null) {\n-      // Re-render with the new data. All the other data remains the same.\n-      return {\n-        tag: NavigationResultTag.Success,\n-        data: {\n-          flightRouterState: newTree,\n-          cacheNode: newCacheNode,\n-          canonicalUrl: currentCanonicalUrl,\n-          renderedSearch: currentRenderedSearch,\n-          // During a refresh, we don't set the `scrollableSegments`. See\n-          // corresponding comment in navigate-reducer.ts for context.\n-          scrollableSegments: null,\n-          shouldScroll,\n-          hash: currentUrl.hash,\n-        },\n-      }\n+    // Re-render with the new data. All the other data remains the same.\n+    return {\n+      tag: NavigationResultTag.Success,\n+      data: {\n+        flightRouterState: newTree,\n+        cacheNode: newCacheNode,\n+        canonicalUrl: currentCanonicalUrl,\n+        renderedSearch: currentRenderedSearch,\n+        // During a refresh, we don't set the `scrollableSegments`. See\n+        // corresponding comment in navigate-reducer.ts for context.\n+        scrollableSegments: null,\n+        shouldScroll,\n+        hash: currentUrl.hash,\n+      },\n     }\n   }\n-\n+  // Could not perform a SPA navigation. Revert to a full-page (MPA) navigation.\n   return {\n-    tag: NavigationResultTag.NoOp,\n-    data: {\n-      canonicalUrl: currentCanonicalUrl,\n-      shouldScroll,\n-    },\n+    tag: NavigationResultTag.MPA,\n+    data: currentCanonicalUrl,\n   }\n }\n \n@@ -302,7 +294,7 @@ function navigateUsingPrefetchedRouteTree(\n   currentUrl: URL,\n   nextUrl: string | null,\n   isSamePageNavigation: boolean,\n-  currentCacheNode: CacheNode,\n+  currentCacheNode: CacheNode | null,\n   currentFlightRouterState: FlightRouterState,\n   prefetchFlightRouterState: FlightRouterState,\n   prefetchSeedData: CacheNodeSeedData | null,\n@@ -312,7 +304,7 @@ function navigateUsingPrefetchedRouteTree(\n   renderedSearch: string,\n   shouldScroll: boolean,\n   hash: string\n-): SuccessfulNavigationResult | NoOpNavigationResult | MPANavigationResult {\n+): SuccessfulNavigationResult | MPANavigationResult {\n   // Recursively construct a prefetch tree by reading from the Segment Cache. To\n   // maintain compatibility, we output the same data structures as the old\n   // prefetching implementation: FlightRouterState and CacheNodeSeedData.\n@@ -323,12 +315,14 @@ function navigateUsingPrefetchedRouteTree(\n     scrollableSegments: [],\n     separateRefreshUrls: null,\n   }\n+  const shouldRefreshDynamicData = false\n   const task = startPPRNavigation(\n     now,\n     currentUrl,\n     currentCacheNode,\n     currentFlightRouterState,\n     prefetchFlightRouterState,\n+    shouldRefreshDynamicData,\n     prefetchSeedData,\n     prefetchHead,\n     isPrefetchHeadPartial,\n@@ -348,49 +342,33 @@ function navigateUsingPrefetchedRouteTree(\n     }\n     return navigationTaskToResult(\n       task,\n-      currentCacheNode,\n       canonicalUrl,\n       renderedSearch,\n       accumulation.scrollableSegments,\n       shouldScroll,\n       hash\n     )\n   }\n-  // The server sent back an empty tree patch. There's nothing to update, except\n-  // possibly the URL.\n+  // Could not perform a SPA navigation. Revert to a full-page (MPA) navigation.\n   return {\n-    tag: NavigationResultTag.NoOp,\n-    data: {\n-      canonicalUrl,\n-      shouldScroll,\n-    },\n+    tag: NavigationResultTag.MPA,\n+    data: canonicalUrl,\n   }\n }\n \n function navigationTaskToResult(\n-  task: PPRNavigationTask,\n-  currentCacheNode: CacheNode,\n+  task: NavigationTask,\n   canonicalUrl: string,\n   renderedSearch: string,\n   scrollableSegments: Array<FlightSegmentPath>,\n   shouldScroll: boolean,\n   hash: string\n ): SuccessfulNavigationResult | MPANavigationResult {\n-  const flightRouterState = task.route\n-  if (flightRouterState === null) {\n-    // When no router state is provided, it signals that we should perform an\n-    // MPA navigation.\n-    return {\n-      tag: NavigationResultTag.MPA,\n-      data: canonicalUrl,\n-    }\n-  }\n-  const newCacheNode = task.node\n   return {\n     tag: NavigationResultTag.Success,\n     data: {\n-      flightRouterState,\n-      cacheNode: newCacheNode !== null ? newCacheNode : currentCacheNode,\n+      flightRouterState: task.route,\n+      cacheNode: task.node,\n       canonicalUrl,\n       renderedSearch,\n       scrollableSegments,\n@@ -534,14 +512,12 @@ async function navigateDynamicallyWithNoPrefetch(\n   currentUrl: URL,\n   nextUrl: string | null,\n   isSamePageNavigation: boolean,\n-  currentCacheNode: CacheNode,\n+  currentCacheNode: CacheNode | null,\n   currentFlightRouterState: FlightRouterState,\n   shouldScroll: boolean,\n   hash: string,\n   collectedDebugInfo: Array<unknown>\n-): Promise<\n-  MPANavigationResult | SuccessfulNavigationResult | NoOpNavigationResult\n-> {\n+): Promise<MPANavigationResult | SuccessfulNavigationResult> {\n   // Runs when a navigation happens but there's no cached prefetch we can use.\n   // Don't bother to wait for a prefetch response; go straight to a full\n   // navigation that contains both static and dynamic data in a single stream.\n@@ -597,12 +573,14 @@ async function navigateDynamicallyWithNoPrefetch(\n     scrollableSegments: [],\n     separateRefreshUrls: null,\n   }\n+  const shouldRefreshDynamicData = false\n   const task = startPPRNavigation(\n     now,\n     currentUrl,\n     currentCacheNode,\n     currentFlightRouterState,\n     prefetchFlightRouterState,\n+    shouldRefreshDynamicData,\n     prefetchSeedData,\n     prefetchHead,\n     isPrefetchHeadPartial,\n@@ -633,22 +611,17 @@ async function navigateDynamicallyWithNoPrefetch(\n     }\n     return navigationTaskToResult(\n       task,\n-      currentCacheNode,\n       createHrefFromUrl(canonicalUrl),\n       renderedSearch,\n       accumulation.scrollableSegments,\n       shouldScroll,\n       hash\n     )\n   }\n-  // The server sent back an empty tree patch. There's nothing to update, except\n-  // possibly the URL.\n+  // Could not perform a SPA navigation. Revert to a full-page (MPA) navigation.\n   return {\n-    tag: NavigationResultTag.NoOp,\n-    data: {\n-      canonicalUrl: createHrefFromUrl(canonicalUrl),\n-      shouldScroll,\n-    },\n+    tag: NavigationResultTag.MPA,\n+    data: createHrefFromUrl(canonicalUrl),\n   }\n }\n "
        },
        {
            "sha": "8d8117f598e65dd6d3b5dceabab44c792398a364",
            "filename": "packages/next/src/shared/lib/segment.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/e9a03ac12cfe3c3fb6b16db42ade06e7382b9018/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fsegment.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/e9a03ac12cfe3c3fb6b16db42ade06e7382b9018/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fsegment.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fsegment.ts?ref=e9a03ac12cfe3c3fb6b16db42ade06e7382b9018",
            "patch": "@@ -86,3 +86,4 @@ export function getSelectedLayoutSegmentPath(\n \n export const PAGE_SEGMENT_KEY = '__PAGE__'\n export const DEFAULT_SEGMENT_KEY = '__DEFAULT__'\n+export const NOT_FOUND_SEGMENT_KEY = '/_not-found'"
        }
    ],
    "stats": {
        "total": 1478,
        "additions": 657,
        "deletions": 821
    }
}