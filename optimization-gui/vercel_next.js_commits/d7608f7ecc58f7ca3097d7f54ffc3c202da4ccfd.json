{
    "author": "wyattjoh",
    "message": "Fix prerendering of interception routes with generateStaticParams (#85835)\n\n## What\n\nFixes a bug where interception routes in parallel slots could not be\nprerendered using `generateStaticParams`, causing 404 responses when\nthese routes were accessed directly.\n\n## Why\n\n**The Problem:**\n\nInterception routes like `app/@modal/(.)photo/[id]/page.tsx` could not\nbe prerendered even when they exported `generateStaticParams`. This was\nbecause the static path generation code only examined \"children\"\nsegments in the loader tree, completely missing segments from parallel\nroutes (like `@modal`) that actually contribute to the pathname.\n\n**Root Cause:**\n\nThe previous implementation used `childrenRouteParamSegments` which only\ntraversed the `children` branch of the loader tree:\n\n```typescript\n// OLD: Only looked at children\nconst childrenRouteParamSegments = [...segments from children only...]\n\n// This missed parallel routes like @modal that have dynamic segments\n```\n\nFor a route structure like:\n```\napp/\n  [username]/\n    page.tsx\n  @modal/\n    (.)[username]/\n      [id]/\n        page.tsx  // â† This route's segments were MISSED\n```\n\nThe build system couldn't discover the `[id]` parameter in the parallel\nroute because it never traversed that branch of the tree.\n\n## How\n\n**Solution:**\n\nIntroduces `extractPathnameSegments()` which properly traverses the\nENTIRE loader tree (not just children) to find ALL segments that\ncontribute to the pathname:\n\n1. **BFS Traversal**: Explores both `children` AND all parallel route\nslots (e.g., `@modal`, `@sidebar`)\n\n2. **Depth Tracking**: Correctly tracks URL depth by:\n   - Skipping route groups `(marketing)` - not in URL\n   - Skipping parallel markers `@modal` - not in URL\n   - Including interception markers `(.)photo` - ARE in URL\n\n3. **Prefix Validation**: Ensures static segments match the target\npathname before including dynamic segments\n\n4. **Complete Parameter Discovery**: Returns all segments that\ncontribute to pathname construction, regardless of which tree branch\nthey're in\n\n**Example:**\n\nFor `app/@modal/(.)photo/[id]/page.tsx`:\n- Old: Missed the `[id]` parameter entirely\n- New: Discovers `[id]` and enables prerendering with\n`generateStaticParams`\n\n## Changes\n\n**New Module**: `extract-pathname-segments.ts` (192 lines)\n- Core algorithm for traversing loader tree and extracting pathname\nsegments\n- Handles complex cases: parallel routes, interception routes, route\ngroups\n- Well-documented with examples and algorithm explanation\n\n**Comprehensive Tests**: `extract-pathname-segments.test.ts` (897 lines)\n- Tests for simple cases, nested structures, parallel routes\n- Interception route handling in various configurations\n- Route group behavior and edge cases\n- Depth tracking validation\n\n**Integration**: `static-paths/app.ts`\n- Replaced `childrenRouteParamSegments` with `extractPathnameSegments()`\n- Updated pathname construction to use segments from parallel routes\n- Maintained backward compatibility\n\n**E2E Test**: Added test validating prerendering works for intercepted\nroutes\n\n## Test Plan\n\nThe new E2E test verifies:\n```typescript\nit('should prerender a dynamic intercepted route', async () => {\n  // Verifies build output contains the prerendered interception route\n  expect(next.cliOutput).toContain('/(.)john/1')\n  // Verifies it doesn't generate the non-intercepted path\n  expect(next.cliOutput).not.toContain('/john/1')\n})\n```\n\n## Impact\n\n**Before**: Interception routes with dynamic segments returned 404 when\naccessed directly, even with `generateStaticParams`\n\n**After**: These routes are properly prerendered at build time and\nreturn correct responses",
    "sha": "d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd",
    "files": [
        {
            "sha": "9d8d3884e58b5e2357f6690b65a7468b8ac87939",
            "filename": "packages/next/errors.json",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Ferrors.json",
            "raw_url": "https://github.com/vercel/next.js/raw/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Ferrors.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Ferrors.json?ref=d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd",
            "patch": "@@ -927,5 +927,8 @@\n   \"926\": \"Optional route parameters are not yet supported (\\\"[%s]\\\") in route \\\"%s\\\".\",\n   \"927\": \"No debug targets found\",\n   \"928\": \"Unable to get server address\",\n-  \"929\": \"No pages or app directory found.\"\n+  \"929\": \"No pages or app directory found.\",\n+  \"930\": \"Expected a dynamic route, but got a static route: %s\",\n+  \"931\": \"Unexpected empty path segments match for a route \\\"%s\\\" with param \\\"%s\\\" of type \\\"%s\\\"\",\n+  \"932\": \"Could not resolve param value for segment: %s\"\n }"
        },
        {
            "sha": "2472b7fd7c3159b0065c017ef4ea491d63a9c77b",
            "filename": "packages/next/src/build/segment-config/app/app-segments.ts",
            "status": "modified",
            "additions": 26,
            "deletions": 112,
            "changes": 138,
            "blob_url": "https://github.com/vercel/next.js/blob/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fbuild%2Fsegment-config%2Fapp%2Fapp-segments.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fbuild%2Fsegment-config%2Fapp%2Fapp-segments.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fsegment-config%2Fapp%2Fapp-segments.ts?ref=d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd",
            "patch": "@@ -17,9 +17,6 @@ import {\n   getLayoutOrPageModule,\n   type LoaderTree,\n } from '../../../server/lib/app-dir-module'\n-import { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\n-import type { FallbackRouteParam } from '../../static-paths/types'\n-import { createFallbackRouteParam } from '../../static-paths/utils'\n import type { DynamicParamTypes } from '../../../shared/lib/app-router-types'\n \n type GenerateStaticParams = (options: { params?: Params }) => Promise<Params[]>\n@@ -63,14 +60,7 @@ export type AppSegment = {\n   paramType: DynamicParamTypes | undefined\n   filePath: string | undefined\n   config: AppSegmentConfig | undefined\n-  isDynamicSegment: boolean\n   generateStaticParams: GenerateStaticParams | undefined\n-\n-  /**\n-   * Whether this segment is a parallel route segment or descends from a\n-   * parallel route segment.\n-   */\n-  isParallelRouteSegment: boolean | undefined\n }\n \n /**\n@@ -82,79 +72,57 @@ export type AppSegment = {\n async function collectAppPageSegments(routeModule: AppPageRouteModule) {\n   // We keep track of unique segments, since with parallel routes, it's possible\n   // to see the same segment multiple times.\n-  const uniqueSegments = new Map<string, AppSegment>()\n+  const segments: AppSegment[] = []\n \n-  // Queue will store tuples of [loaderTree, currentSegments, isParallelRouteSegment]\n-  type QueueItem = [\n-    loaderTree: LoaderTree,\n-    currentSegments: AppSegment[],\n-    isParallelRouteSegment: boolean,\n-  ]\n-  const queue: QueueItem[] = [[routeModule.userland.loaderTree, [], false]]\n+  // Queue will store loader trees.\n+  const queue: LoaderTree[] = [routeModule.userland.loaderTree]\n \n   while (queue.length > 0) {\n-    const [loaderTree, currentSegments, isParallelRouteSegment] = queue.shift()!\n+    const loaderTree = queue.shift()!\n     const [name, parallelRoutes] = loaderTree\n \n     // Process current node\n     const { mod: userland, filePath } = await getLayoutOrPageModule(loaderTree)\n     const isClientComponent = userland && isClientReference(userland)\n \n-    const { param: paramName, type: paramType } = getSegmentParam(name) ?? {}\n+    const param = getSegmentParam(name)\n \n     const segment: AppSegment = {\n       name,\n-      paramName,\n-      paramType,\n+      paramName: param?.paramName,\n+      paramType: param?.paramType,\n       filePath,\n       config: undefined,\n-      isDynamicSegment: !!paramName,\n       generateStaticParams: undefined,\n-      isParallelRouteSegment,\n     }\n \n     // Only server components can have app segment configurations\n     if (!isClientComponent) {\n       attach(segment, userland, routeModule.definition.pathname)\n     }\n \n-    // Create a unique key for the segment\n-    const segmentKey = getSegmentKey(segment)\n-    if (!uniqueSegments.has(segmentKey)) {\n-      uniqueSegments.set(segmentKey, segment)\n-    }\n-\n-    const updatedSegments = [...currentSegments, segment]\n-\n-    // If this is a page segment, we've reached a leaf node\n-    if (name === PAGE_SEGMENT_KEY) {\n-      // Add all segments in the current path, preferring non-parallel segments\n-      updatedSegments.forEach((seg) => {\n-        const key = getSegmentKey(seg)\n-        if (!uniqueSegments.has(key)) {\n-          uniqueSegments.set(key, seg)\n-        }\n-      })\n+    // If this segment doesn't already exist, then add it to the segments array.\n+    // The list of segments is short so we just use a list traversal to check\n+    // for duplicates and spare us needing to maintain the string key.\n+    if (\n+      segments.every(\n+        (s) =>\n+          s.name !== segment.name ||\n+          s.paramName !== segment.paramName ||\n+          s.paramType !== segment.paramType ||\n+          s.filePath !== segment.filePath\n+      )\n+    ) {\n+      segments.push(segment)\n     }\n \n     // Add all parallel routes to the queue\n-    for (const parallelRouteKey in parallelRoutes) {\n-      const parallelRoute = parallelRoutes[parallelRouteKey]\n-      queue.push([\n-        parallelRoute,\n-        updatedSegments,\n-        // A parallel route segment is one that descends from a segment that is\n-        // not children or descends from a parallel route segment.\n-        isParallelRouteSegment || parallelRouteKey !== 'children',\n-      ])\n+    for (const parallelRoute of Object.values(parallelRoutes)) {\n+      queue.push(parallelRoute)\n     }\n   }\n \n-  return Array.from(uniqueSegments.values())\n-}\n-\n-function getSegmentKey(segment: AppSegment) {\n-  return `${segment.name}-${segment.filePath ?? ''}-${segment.paramName ?? ''}-${segment.isParallelRouteSegment ? 'pr' : 'np'}`\n+  return segments\n }\n \n /**\n@@ -174,17 +142,15 @@ function collectAppRouteSegments(\n \n   // Generate all the segments.\n   const segments: AppSegment[] = parts.map((name) => {\n-    const { param: paramName, type: paramType } = getSegmentParam(name) ?? {}\n+    const param = getSegmentParam(name)\n \n     return {\n       name,\n-      paramName,\n-      paramType,\n+      paramName: param?.paramName,\n+      paramType: param?.paramType,\n       filePath: undefined,\n-      isDynamicSegment: !!paramName,\n       config: undefined,\n       generateStaticParams: undefined,\n-      isParallelRouteSegment: undefined,\n     } satisfies AppSegment\n   })\n \n@@ -221,55 +187,3 @@ export function collectSegments(\n     'Expected a route module to be one of app route or page'\n   )\n }\n-\n-/**\n- * Collects the fallback route params for a given app page route module. This is\n- * a variant of the `collectSegments` function that only collects the fallback\n- * route params without importing anything.\n- *\n- * @param routeModule the app page route module\n- * @returns the fallback route params for the app page route module\n- */\n-export function collectFallbackRouteParams(\n-  routeModule: AppPageRouteModule\n-): readonly FallbackRouteParam[] {\n-  const uniqueSegments = new Map<string, FallbackRouteParam>()\n-\n-  // Queue will store tuples of [loaderTree, isParallelRouteSegment]\n-  type QueueItem = [loaderTree: LoaderTree, isParallelRouteSegment: boolean]\n-  const queue: QueueItem[] = [[routeModule.userland.loaderTree, false]]\n-\n-  while (queue.length > 0) {\n-    const [loaderTree, isParallelRouteSegment] = queue.shift()!\n-    const [name, parallelRoutes] = loaderTree\n-\n-    // Handle this segment (if it's a dynamic segment param).\n-    const segmentParam = getSegmentParam(name)\n-    if (segmentParam) {\n-      const key = `${name}-${segmentParam.param}-${isParallelRouteSegment ? 'pr' : 'np'}`\n-      if (!uniqueSegments.has(key)) {\n-        uniqueSegments.set(\n-          key,\n-          createFallbackRouteParam(\n-            segmentParam.param,\n-            segmentParam.type,\n-            isParallelRouteSegment\n-          )\n-        )\n-      }\n-    }\n-\n-    // Add all of this segment's parallel routes to the queue.\n-    for (const parallelRouteKey in parallelRoutes) {\n-      const parallelRoute = parallelRoutes[parallelRouteKey]\n-      queue.push([\n-        parallelRoute,\n-        // A parallel route segment is one that descends from a segment that is\n-        // not children or descends from a parallel route segment.\n-        isParallelRouteSegment || parallelRouteKey !== 'children',\n-      ])\n-    }\n-  }\n-\n-  return Array.from(uniqueSegments.values())\n-}"
        },
        {
            "sha": "2ba80b88c3f844fa015fb7368831ee4ad9e0174f",
            "filename": "packages/next/src/build/segment-config/app/collect-root-param-keys.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fbuild%2Fsegment-config%2Fapp%2Fcollect-root-param-keys.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fbuild%2Fsegment-config%2Fapp%2Fcollect-root-param-keys.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fsegment-config%2Fapp%2Fcollect-root-param-keys.ts?ref=d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd",
            "patch": "@@ -17,9 +17,9 @@ function collectAppPageRootParamKeys(\n     const [name, parallelRoutes, modules] = current\n \n     // If this is a dynamic segment, then we collect the param.\n-    const param = getSegmentParam(name)?.param\n-    if (param) {\n-      rootParams.push(param)\n+    const paramName = getSegmentParam(name)?.paramName\n+    if (paramName) {\n+      rootParams.push(paramName)\n     }\n \n     // If this has a layout module, then we've found the root layout because"
        },
        {
            "sha": "0d0c4d43653a92fc4a0a5ad0331f6c16fb91b4bd",
            "filename": "packages/next/src/build/static-paths/app.test.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1291,
            "changes": 1292,
            "blob_url": "https://github.com/vercel/next.js/blob/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp.test.ts?ref=d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd",
            "patch": "@@ -6,12 +6,10 @@ import {\n   calculateFallbackMode,\n   filterUniqueParams,\n   generateRouteStaticParams,\n-  resolveParallelRouteParams,\n } from './app'\n-import type { PrerenderedRoute, FallbackRouteParam } from './types'\n+import type { PrerenderedRoute } from './types'\n import type { WorkStore } from '../../server/app-render/work-async-storage.external'\n import type { AppSegment } from '../segment-config/app/app-segments'\n-import type { DynamicParamTypes } from '../../shared/lib/app-router-types'\n \n describe('assignErrorIfEmpty', () => {\n   it('should assign throwOnEmptyStaticShell true for a static route with no children', () => {\n@@ -42,7 +40,6 @@ describe('assignErrorIfEmpty', () => {\n           {\n             paramName: 'id',\n             paramType: 'dynamic',\n-            isParallelRouteParam: false,\n           },\n         ],\n         fallbackMode: FallbackMode.NOT_FOUND,\n@@ -76,12 +73,10 @@ describe('assignErrorIfEmpty', () => {\n           {\n             paramName: 'id',\n             paramType: 'dynamic',\n-            isParallelRouteParam: false,\n           },\n           {\n             paramName: 'name',\n             paramType: 'dynamic',\n-            isParallelRouteParam: false,\n           },\n         ],\n         fallbackMode: FallbackMode.NOT_FOUND,\n@@ -96,7 +91,6 @@ describe('assignErrorIfEmpty', () => {\n           {\n             paramName: 'name',\n             paramType: 'dynamic',\n-            isParallelRouteParam: false,\n           },\n         ],\n         fallbackMode: FallbackMode.NOT_FOUND,\n@@ -129,7 +123,6 @@ describe('assignErrorIfEmpty', () => {\n           {\n             paramName: 'name',\n             paramType: 'dynamic',\n-            isParallelRouteParam: false,\n           },\n         ],\n         fallbackMode: FallbackMode.NOT_FOUND,\n@@ -160,7 +153,6 @@ describe('assignErrorIfEmpty', () => {\n           {\n             paramName: 'name',\n             paramType: 'dynamic',\n-            isParallelRouteParam: false,\n           },\n         ],\n         fallbackMode: FallbackMode.NOT_FOUND,\n@@ -175,12 +167,10 @@ describe('assignErrorIfEmpty', () => {\n           {\n             paramName: 'name',\n             paramType: 'dynamic',\n-            isParallelRouteParam: false,\n           },\n           {\n             paramName: 'extra',\n             paramType: 'catchall',\n-            isParallelRouteParam: false,\n           },\n         ],\n         fallbackMode: FallbackMode.NOT_FOUND,\n@@ -225,7 +215,6 @@ describe('assignErrorIfEmpty', () => {\n           {\n             paramName: 'slug',\n             paramType: 'dynamic',\n-            isParallelRouteParam: false,\n           },\n         ],\n         fallbackMode: FallbackMode.NOT_FOUND,\n@@ -269,12 +258,10 @@ describe('assignErrorIfEmpty', () => {\n           {\n             paramName: 'id',\n             paramType: 'dynamic',\n-            isParallelRouteParam: false,\n           },\n           {\n             paramName: 'slug',\n             paramType: 'catchall',\n-            isParallelRouteParam: false,\n           },\n         ],\n         fallbackMode: FallbackMode.NOT_FOUND,\n@@ -289,7 +276,6 @@ describe('assignErrorIfEmpty', () => {\n           {\n             paramName: 'slug',\n             paramType: 'catchall',\n-            isParallelRouteParam: false,\n           },\n         ],\n         fallbackMode: FallbackMode.NOT_FOUND,\n@@ -327,17 +313,14 @@ describe('assignErrorIfEmpty', () => {\n           {\n             paramName: 'category',\n             paramType: 'dynamic',\n-            isParallelRouteParam: false,\n           },\n           {\n             paramName: 'subcategory',\n             paramType: 'dynamic',\n-            isParallelRouteParam: false,\n           },\n           {\n             paramName: 'item',\n             paramType: 'dynamic',\n-            isParallelRouteParam: false,\n           },\n         ],\n         fallbackMode: FallbackMode.NOT_FOUND,\n@@ -352,12 +335,10 @@ describe('assignErrorIfEmpty', () => {\n           {\n             paramName: 'subcategory',\n             paramType: 'dynamic',\n-            isParallelRouteParam: false,\n           },\n           {\n             paramName: 'item',\n             paramType: 'dynamic',\n-            isParallelRouteParam: false,\n           },\n         ],\n         fallbackMode: FallbackMode.NOT_FOUND,\n@@ -372,7 +353,6 @@ describe('assignErrorIfEmpty', () => {\n           {\n             paramName: 'item',\n             paramType: 'dynamic',\n-            isParallelRouteParam: false,\n           },\n         ],\n         fallbackMode: FallbackMode.NOT_FOUND,\n@@ -417,7 +397,6 @@ describe('assignErrorIfEmpty', () => {\n           {\n             paramName: 'segments',\n             paramType: 'catchall',\n-            isParallelRouteParam: false,\n           },\n         ],\n         fallbackMode: FallbackMode.NOT_FOUND,\n@@ -1307,1272 +1286,3 @@ describe('calculateFallbackMode', () => {\n     expect(result).toBe(FallbackMode.BLOCKING_STATIC_RENDER)\n   })\n })\n-\n-describe('resolveParallelRouteParams', () => {\n-  // Helper to create LoaderTree structures for testing\n-  type TestLoaderTree = [\n-    segment: string,\n-    parallelRoutes: { [key: string]: TestLoaderTree },\n-    modules: Record<string, unknown>,\n-  ]\n-\n-  function createLoaderTree(\n-    segment: string,\n-    parallelRoutes: { [key: string]: TestLoaderTree } = {},\n-    children?: TestLoaderTree\n-  ): TestLoaderTree {\n-    const routes = children ? { ...parallelRoutes, children } : parallelRoutes\n-    return [segment, routes, {}]\n-  }\n-\n-  function createFallbackParam(\n-    paramName: string,\n-    isParallelRouteParam: boolean,\n-    paramType: DynamicParamTypes = 'dynamic'\n-  ): FallbackRouteParam {\n-    return { paramName, paramType, isParallelRouteParam }\n-  }\n-\n-  describe('direct match case', () => {\n-    it('should skip processing when param already exists in params object', () => {\n-      // Tree: / -> @sidebar/[existingParam]\n-      const loaderTree = createLoaderTree('', {\n-        sidebar: createLoaderTree('[existingParam]'),\n-      })\n-      const params: Params = { existingParam: 'value' }\n-      const pathname = '/some/path'\n-      const fallbackRouteParams: FallbackRouteParam[] = []\n-\n-      resolveParallelRouteParams(\n-        loaderTree,\n-        params,\n-        pathname,\n-        fallbackRouteParams\n-      )\n-\n-      expect(params.existingParam).toBe('value')\n-      expect(fallbackRouteParams).toHaveLength(0)\n-    })\n-\n-    it('should skip processing for multiple existing params', () => {\n-      // Tree: / -> @sidebar/[param1] + @modal/[...param2]\n-      const loaderTree = createLoaderTree('', {\n-        sidebar: createLoaderTree('[param1]'),\n-        modal: createLoaderTree('[...param2]'),\n-      })\n-      const params: Params = { param1: 'value1', param2: ['a', 'b'] }\n-      const pathname = '/some/path'\n-      const fallbackRouteParams: FallbackRouteParam[] = []\n-\n-      resolveParallelRouteParams(\n-        loaderTree,\n-        params,\n-        pathname,\n-        fallbackRouteParams\n-      )\n-\n-      expect(params.param1).toBe('value1')\n-      expect(params.param2).toEqual(['a', 'b'])\n-      expect(fallbackRouteParams).toHaveLength(0)\n-    })\n-  })\n-\n-  describe('dynamic params', () => {\n-    it('should extract dynamic param from pathname when not already in params', () => {\n-      // Tree: / -> @sidebar/[dynamicParam]\n-      // At depth 0, should extract 'some' from pathname '/some/path'\n-      const loaderTree = createLoaderTree('', {\n-        sidebar: createLoaderTree('[dynamicParam]'),\n-      })\n-      const params: Params = {}\n-      const pathname = '/some/path'\n-      const fallbackRouteParams: FallbackRouteParam[] = []\n-\n-      resolveParallelRouteParams(\n-        loaderTree,\n-        params,\n-        pathname,\n-        fallbackRouteParams\n-      )\n-\n-      expect(params.dynamicParam).toBe('some')\n-      expect(fallbackRouteParams).toHaveLength(0)\n-    })\n-\n-    it('should handle multiple dynamic params in parallel routes at same depth', () => {\n-      // Tree: / -> @modal/[id] + @sidebar/[category]\n-      // Both at depth 0, so both extract 'photo' from pathname '/photo/123'\n-      const loaderTree = createLoaderTree('', {\n-        modal: createLoaderTree('[id]'),\n-        sidebar: createLoaderTree('[category]'),\n-      })\n-      const params: Params = {}\n-      const pathname = '/photo/123'\n-      const fallbackRouteParams: FallbackRouteParam[] = []\n-\n-      resolveParallelRouteParams(\n-        loaderTree,\n-        params,\n-        pathname,\n-        fallbackRouteParams\n-      )\n-\n-      // Both should extract the first segment 'photo'\n-      expect(params.id).toBe('photo')\n-      expect(params.category).toBe('photo')\n-      expect(fallbackRouteParams).toHaveLength(0)\n-    })\n-\n-    it('should extract dynamic param from pathname at depth 0', () => {\n-      // Tree: / -> @sidebar/[category]\n-      const loaderTree = createLoaderTree('', {\n-        sidebar: createLoaderTree('[category]'),\n-      })\n-      const params: Params = {}\n-      const pathname = '/tech'\n-      const fallbackRouteParams: FallbackRouteParam[] = []\n-\n-      resolveParallelRouteParams(\n-        loaderTree,\n-        params,\n-        pathname,\n-        fallbackRouteParams\n-      )\n-\n-      expect(params.category).toBe('tech')\n-      expect(fallbackRouteParams).toHaveLength(0)\n-    })\n-\n-    it('should extract dynamic param from pathname at nested depth', () => {\n-      // Tree: /blog -> @sidebar/[category]\n-      const loaderTree = createLoaderTree(\n-        '',\n-        {},\n-        createLoaderTree('blog', {\n-          sidebar: createLoaderTree('[category]'),\n-        })\n-      )\n-      const params: Params = {}\n-      const pathname = '/blog/tech'\n-      const fallbackRouteParams: FallbackRouteParam[] = []\n-\n-      resolveParallelRouteParams(\n-        loaderTree,\n-        params,\n-        pathname,\n-        fallbackRouteParams\n-      )\n-\n-      expect(params.category).toBe('tech')\n-      expect(fallbackRouteParams).toHaveLength(0)\n-    })\n-\n-    it('should extract dynamic param even when other unknown params exist at different depths', () => {\n-      // Tree: / -> @sidebar/[category]\n-      // Even though there's an unknown 'slug' param somewhere else, if the segment\n-      // at this depth is known, we can extract it\n-      const loaderTree = createLoaderTree('', {\n-        sidebar: createLoaderTree('[category]'),\n-      })\n-      const params: Params = {}\n-      const pathname = '/tech'\n-      const fallbackRouteParams: FallbackRouteParam[] = [\n-        createFallbackParam('slug', false), // Non-parallel fallback param at different depth\n-      ]\n-\n-      resolveParallelRouteParams(\n-        loaderTree,\n-        params,\n-        pathname,\n-        fallbackRouteParams\n-      )\n-\n-      // Should extract 'tech' because pathSegments[0] is known, regardless of slug\n-      expect(params.category).toBe('tech')\n-      expect(fallbackRouteParams).toHaveLength(1) // Still just slug\n-    })\n-\n-    it('should mark dynamic param as fallback when depth exceeds pathname length', () => {\n-      // Tree: /blog/posts -> @sidebar/[category]\n-      const loaderTree = createLoaderTree(\n-        '',\n-        {},\n-        createLoaderTree(\n-          'blog',\n-          {},\n-          createLoaderTree('posts', {\n-            sidebar: createLoaderTree('[category]'),\n-          })\n-        )\n-      )\n-      const params: Params = {}\n-      const pathname = '/blog' // Only 1 segment, but dynamic param is at depth 2\n-      const fallbackRouteParams: FallbackRouteParam[] = []\n-\n-      resolveParallelRouteParams(\n-        loaderTree,\n-        params,\n-        pathname,\n-        fallbackRouteParams\n-      )\n-\n-      expect(params.category).toBeUndefined()\n-      expect(fallbackRouteParams).toHaveLength(1)\n-      expect(fallbackRouteParams[0]).toEqual({\n-        paramName: 'category',\n-        paramType: 'dynamic',\n-        isParallelRouteParam: true,\n-      })\n-    })\n-\n-    it('should resolve embedded params when extracting dynamic param value', () => {\n-      // Tree: /[lang] -> @sidebar/[category]\n-      const loaderTree = createLoaderTree(\n-        '',\n-        {},\n-        createLoaderTree('[lang]', {\n-          sidebar: createLoaderTree('[category]'),\n-        })\n-      )\n-      const params: Params = { lang: 'en' }\n-      const pathname = '/en/tech'\n-      const fallbackRouteParams: FallbackRouteParam[] = []\n-\n-      resolveParallelRouteParams(\n-        loaderTree,\n-        params,\n-        pathname,\n-        fallbackRouteParams\n-      )\n-\n-      expect(params.category).toBe('tech')\n-      expect(fallbackRouteParams).toHaveLength(0)\n-    })\n-\n-    it('should extract dynamic param when unknown params exist at LATER depth', () => {\n-      // Tree: /[lang] -> @sidebar/[filter] (at depth 1)\n-      //       /[lang]/products/[category] (category at depth 2 is unknown)\n-      // @sidebar/[filter] is at depth 1, should extract 'products'\n-      // [category] at depth 2 is unknown, but shouldn't affect depth 1 resolution\n-      const loaderTree = createLoaderTree(\n-        '',\n-        {},\n-        createLoaderTree(\n-          '[lang]',\n-          {\n-            sidebar: createLoaderTree('[filter]'),\n-          },\n-          createLoaderTree('products', {}, createLoaderTree('[category]'))\n-        )\n-      )\n-      const params: Params = { lang: 'en' }\n-      // Pathname with placeholder at depth 2: /en/products/[category]\n-      const pathname = '/en/products/[category]'\n-      const fallbackRouteParams: FallbackRouteParam[] = [\n-        createFallbackParam('category', false), // category at depth 2 is unknown\n-      ]\n-\n-      resolveParallelRouteParams(\n-        loaderTree,\n-        params,\n-        pathname,\n-        fallbackRouteParams\n-      )\n-\n-      // Should extract 'products' at depth 1, even though category at depth 2 is unknown\n-      expect(params.filter).toBe('products')\n-      expect(fallbackRouteParams).toHaveLength(1) // Still just category\n-    })\n-\n-    it('should NOT extract dynamic param when placeholder is at SAME depth', () => {\n-      // Tree: /[lang]/products/[category] -> @sidebar/[filter]\n-      // @sidebar/[filter] is at depth 2\n-      // [category] at depth 2 is also unknown - same depth!\n-      const loaderTree = createLoaderTree(\n-        '',\n-        {},\n-        createLoaderTree(\n-          '[lang]',\n-          {},\n-          createLoaderTree(\n-            'products',\n-            {},\n-            createLoaderTree('[category]', {\n-              sidebar: createLoaderTree('[filter]'),\n-            })\n-          )\n-        )\n-      )\n-      const params: Params = { lang: 'en' }\n-      // Pathname with placeholder at depth 2: /en/products/[category]\n-      const pathname = '/en/products/[category]'\n-      const fallbackRouteParams: FallbackRouteParam[] = [\n-        createFallbackParam('category', false), // category at depth 2 is unknown\n-      ]\n-\n-      resolveParallelRouteParams(\n-        loaderTree,\n-        params,\n-        pathname,\n-        fallbackRouteParams\n-      )\n-\n-      // Should NOT extract because pathSegments[2] = '[category]' is a placeholder\n-      expect(params.filter).toBeUndefined()\n-      expect(fallbackRouteParams).toHaveLength(2)\n-      expect(fallbackRouteParams[1]).toEqual({\n-        paramName: 'filter',\n-        paramType: 'dynamic',\n-        isParallelRouteParam: true,\n-      })\n-    })\n-  })\n-\n-  describe('catchall with non-parallel fallback params', () => {\n-    it('should add to fallbackRouteParams when non-parallel fallback params exist', () => {\n-      // Tree: / -> @sidebar/[...catchallParam]\n-      const loaderTree = createLoaderTree('', {\n-        sidebar: createLoaderTree('[...catchallParam]'),\n-      })\n-      const params: Params = {}\n-      const pathname = '/some/path/segments'\n-      const fallbackRouteParams: FallbackRouteParam[] = [\n-        createFallbackParam('regularParam', false), // Non-parallel fallback param\n-      ]\n-\n-      resolveParallelRouteParams(\n-        loaderTree,\n-        params,\n-        pathname,\n-        fallbackRouteParams\n-      )\n-\n-      expect(params.catchallParam).toBeUndefined()\n-      expect(fallbackRouteParams).toHaveLength(2)\n-      expect(fallbackRouteParams[1]).toEqual({\n-        paramName: 'catchallParam',\n-        paramType: 'catchall',\n-        isParallelRouteParam: true,\n-      })\n-    })\n-  })\n-\n-  describe('optional-catchall with non-parallel fallback params', () => {\n-    it('should add to fallbackRouteParams when non-parallel fallback params exist', () => {\n-      // Tree: / -> @sidebar/[[...optionalCatchall]]\n-      const loaderTree = createLoaderTree('', {\n-        sidebar: createLoaderTree('[[...optionalCatchall]]'),\n-      })\n-      const params: Params = {}\n-      const pathname = '/some/path'\n-      const fallbackRouteParams: FallbackRouteParam[] = [\n-        createFallbackParam('regularParam', false), // Non-parallel fallback param\n-      ]\n-\n-      resolveParallelRouteParams(\n-        loaderTree,\n-        params,\n-        pathname,\n-        fallbackRouteParams\n-      )\n-\n-      expect(params.optionalCatchall).toBeUndefined()\n-      expect(fallbackRouteParams).toHaveLength(2)\n-      expect(fallbackRouteParams[1]).toEqual({\n-        paramName: 'optionalCatchall',\n-        paramType: 'optional-catchall',\n-        isParallelRouteParam: true,\n-      })\n-    })\n-  })\n-\n-  describe('catchall deriving from pathname with depth', () => {\n-    it('should use depth to correctly slice pathname segments', () => {\n-      // Tree: /blog -> @sidebar/[...catchallParam]\n-      // At depth 1 (after /blog), should get remaining segments\n-      const loaderTree = createLoaderTree(\n-        '',\n-        {},\n-        createLoaderTree('blog', {\n-          sidebar: createLoaderTree('[...catchallParam]'),\n-        })\n-      )\n-      const params: Params = {}\n-      const pathname = '/blog/2023/posts/my-article'\n-      const fallbackRouteParams: FallbackRouteParam[] = []\n-\n-      resolveParallelRouteParams(\n-        loaderTree,\n-        params,\n-        pathname,\n-        fallbackRouteParams\n-      )\n-\n-      // Should get segments from depth 1 onwards\n-      expect(params.catchallParam).toEqual(['2023', 'posts', 'my-article'])\n-      expect(fallbackRouteParams).toHaveLength(0)\n-    })\n-\n-    it('should handle catchall at depth 0 (root level)', () => {\n-      // Tree: / -> @sidebar/[...catchallParam]\n-      const loaderTree = createLoaderTree('', {\n-        sidebar: createLoaderTree('[...catchallParam]'),\n-      })\n-      const params: Params = {}\n-      const pathname = '/blog/2023/posts'\n-      const fallbackRouteParams: FallbackRouteParam[] = []\n-\n-      resolveParallelRouteParams(\n-        loaderTree,\n-        params,\n-        pathname,\n-        fallbackRouteParams\n-      )\n-\n-      // Should get all segments\n-      expect(params.catchallParam).toEqual(['blog', '2023', 'posts'])\n-      expect(fallbackRouteParams).toHaveLength(0)\n-    })\n-\n-    it('should handle nested depth correctly', () => {\n-      // Tree: /products/[category] -> @filters/[...filterPath]\n-      const loaderTree = createLoaderTree(\n-        '',\n-        {},\n-        createLoaderTree(\n-          'products',\n-          {},\n-          createLoaderTree('[category]', {\n-            filters: createLoaderTree('[...filterPath]'),\n-          })\n-        )\n-      )\n-      const params: Params = { category: 'electronics' }\n-      const pathname = '/products/electronics/phones/iphone'\n-      const fallbackRouteParams: FallbackRouteParam[] = []\n-\n-      resolveParallelRouteParams(\n-        loaderTree,\n-        params,\n-        pathname,\n-        fallbackRouteParams\n-      )\n-\n-      // Should get segments from depth 2 onwards (after /products/[category])\n-      expect(params.filterPath).toEqual(['phones', 'iphone'])\n-      expect(fallbackRouteParams).toHaveLength(0)\n-    })\n-\n-    it('should handle single path segment', () => {\n-      // Tree: / -> @sidebar/[...catchallParam]\n-      const loaderTree = createLoaderTree('', {\n-        sidebar: createLoaderTree('[...catchallParam]'),\n-      })\n-      const params: Params = {}\n-      const pathname = '/single'\n-      const fallbackRouteParams: FallbackRouteParam[] = []\n-\n-      resolveParallelRouteParams(\n-        loaderTree,\n-        params,\n-        pathname,\n-        fallbackRouteParams\n-      )\n-\n-      expect(params.catchallParam).toEqual(['single'])\n-      expect(fallbackRouteParams).toHaveLength(0)\n-    })\n-  })\n-\n-  describe('route groups', () => {\n-    it('should not increment depth for route groups', () => {\n-      // Tree: /(marketing) -> @sidebar/[...catchallParam]\n-      // Route groups don't contribute to pathname depth\n-      const loaderTree = createLoaderTree(\n-        '',\n-        {},\n-        createLoaderTree('(marketing)', {\n-          sidebar: createLoaderTree('[...catchallParam]'),\n-        })\n-      )\n-      const params: Params = {}\n-      const pathname = '/blog/post'\n-      const fallbackRouteParams: FallbackRouteParam[] = []\n-\n-      resolveParallelRouteParams(\n-        loaderTree,\n-        params,\n-        pathname,\n-        fallbackRouteParams\n-      )\n-\n-      // Should get all segments since route group doesn't increment depth\n-      expect(params.catchallParam).toEqual(['blog', 'post'])\n-      expect(fallbackRouteParams).toHaveLength(0)\n-    })\n-\n-    it('should handle multiple route groups', () => {\n-      // Tree: /(group1)/(group2)/blog -> @sidebar/[...path]\n-      const loaderTree = createLoaderTree(\n-        '',\n-        {},\n-        createLoaderTree(\n-          '(group1)',\n-          {},\n-          createLoaderTree(\n-            '(group2)',\n-            {},\n-            createLoaderTree('blog', {\n-              sidebar: createLoaderTree('[...path]'),\n-            })\n-          )\n-        )\n-      )\n-      const params: Params = {}\n-      const pathname = '/blog/2023/posts'\n-      const fallbackRouteParams: FallbackRouteParam[] = []\n-\n-      resolveParallelRouteParams(\n-        loaderTree,\n-        params,\n-        pathname,\n-        fallbackRouteParams\n-      )\n-\n-      // Should get segments from depth 1 (after /blog), route groups don't count\n-      expect(params.path).toEqual(['2023', 'posts'])\n-      expect(fallbackRouteParams).toHaveLength(0)\n-    })\n-  })\n-\n-  describe('optional-catchall with empty pathname', () => {\n-    it('should set params to empty array when pathname has no segments', () => {\n-      // Tree: / -> @sidebar/[[...optionalCatchall]]\n-      const loaderTree = createLoaderTree('', {\n-        sidebar: createLoaderTree('[[...optionalCatchall]]'),\n-      })\n-      const params: Params = {}\n-      const pathname = '/'\n-      const fallbackRouteParams: FallbackRouteParam[] = []\n-\n-      resolveParallelRouteParams(\n-        loaderTree,\n-        params,\n-        pathname,\n-        fallbackRouteParams\n-      )\n-\n-      expect(params.optionalCatchall).toEqual([])\n-      expect(fallbackRouteParams).toHaveLength(0)\n-    })\n-\n-    it('should handle optional catchall at nested depth with no remaining segments', () => {\n-      // Tree: /blog -> @sidebar/[[...optionalPath]]\n-      const loaderTree = createLoaderTree(\n-        '',\n-        {},\n-        createLoaderTree('blog', {\n-          sidebar: createLoaderTree('[[...optionalPath]]'),\n-        })\n-      )\n-      const params: Params = {}\n-      const pathname = '/blog'\n-      const fallbackRouteParams: FallbackRouteParam[] = []\n-\n-      resolveParallelRouteParams(\n-        loaderTree,\n-        params,\n-        pathname,\n-        fallbackRouteParams\n-      )\n-\n-      expect(params.optionalPath).toEqual([])\n-      expect(fallbackRouteParams).toHaveLength(0)\n-    })\n-  })\n-\n-  describe('optional-catchall with non-empty pathname', () => {\n-    it('should populate params with path segments', () => {\n-      // Tree: / -> @sidebar/[[...optionalCatchall]]\n-      const loaderTree = createLoaderTree('', {\n-        sidebar: createLoaderTree('[[...optionalCatchall]]'),\n-      })\n-      const params: Params = {}\n-      const pathname = '/api/v1/users'\n-      const fallbackRouteParams: FallbackRouteParam[] = []\n-\n-      resolveParallelRouteParams(\n-        loaderTree,\n-        params,\n-        pathname,\n-        fallbackRouteParams\n-      )\n-\n-      expect(params.optionalCatchall).toEqual(['api', 'v1', 'users'])\n-      expect(fallbackRouteParams).toHaveLength(0)\n-    })\n-  })\n-\n-  describe('catchall-intercepted params', () => {\n-    it('should handle catchall-intercepted params in parallel routes', () => {\n-      // Tree: / -> @modal/[...path]  where [...path] uses catchall-intercepted type\n-      // Note: catchall-intercepted is a param type, not related to interception routes\n-      const loaderTree = createLoaderTree('', {\n-        modal: createLoaderTree('[...path]'),\n-      })\n-      const params: Params = {}\n-      const pathname = '/photos/album/2023'\n-      const fallbackRouteParams: FallbackRouteParam[] = []\n-\n-      resolveParallelRouteParams(\n-        loaderTree,\n-        params,\n-        pathname,\n-        fallbackRouteParams\n-      )\n-\n-      // Should get all segments\n-      expect(params.path).toEqual(['photos', 'album', '2023'])\n-      expect(fallbackRouteParams).toHaveLength(0)\n-    })\n-  })\n-\n-  describe('error cases', () => {\n-    it('should throw error for catchall with empty pathname', () => {\n-      // Tree: / -> @sidebar/[...catchallParam]\n-      const loaderTree = createLoaderTree('', {\n-        sidebar: createLoaderTree('[...catchallParam]'),\n-      })\n-      const params: Params = {}\n-      const pathname = '/'\n-      const fallbackRouteParams: FallbackRouteParam[] = []\n-\n-      expect(() =>\n-        resolveParallelRouteParams(\n-          loaderTree,\n-          params,\n-          pathname,\n-          fallbackRouteParams\n-        )\n-      ).toThrow(/Unexpected empty path segments/)\n-    })\n-\n-    it('should throw error for catchall when depth exceeds pathname', () => {\n-      // Tree: /blog/posts -> @sidebar/[...catchallParam]\n-      // But pathname is just /blog\n-      const loaderTree = createLoaderTree(\n-        '',\n-        {},\n-        createLoaderTree(\n-          'blog',\n-          {},\n-          createLoaderTree('posts', {\n-            sidebar: createLoaderTree('[...catchallParam]'),\n-          })\n-        )\n-      )\n-      const params: Params = {}\n-      const pathname = '/blog'\n-      const fallbackRouteParams: FallbackRouteParam[] = []\n-\n-      expect(() =>\n-        resolveParallelRouteParams(\n-          loaderTree,\n-          params,\n-          pathname,\n-          fallbackRouteParams\n-        )\n-      ).toThrow(/Unexpected empty path segments/)\n-    })\n-  })\n-\n-  describe('complex scenarios', () => {\n-    it('should handle multiple parallel routes at same level', () => {\n-      // Tree: / -> @sidebar/[...sidebarPath] + @modal/[[...modalPath]]\n-      const loaderTree = createLoaderTree('', {\n-        sidebar: createLoaderTree('[...sidebarPath]'),\n-        modal: createLoaderTree('[[...modalPath]]'),\n-      })\n-      const params: Params = {}\n-      const pathname = '/products/electronics'\n-      const fallbackRouteParams: FallbackRouteParam[] = []\n-\n-      resolveParallelRouteParams(\n-        loaderTree,\n-        params,\n-        pathname,\n-        fallbackRouteParams\n-      )\n-\n-      expect(params.sidebarPath).toEqual(['products', 'electronics'])\n-      expect(params.modalPath).toEqual(['products', 'electronics'])\n-      expect(fallbackRouteParams).toHaveLength(0)\n-    })\n-\n-    it('should handle parallel route with embedded dynamic param from pathname', () => {\n-      // Tree: /[lang] -> @sidebar/[...path]\n-      const loaderTree = createLoaderTree(\n-        '',\n-        {},\n-        createLoaderTree('[lang]', {\n-          sidebar: createLoaderTree('[...path]'),\n-        })\n-      )\n-      const params: Params = { lang: 'en' }\n-      const pathname = '/en/blog/post'\n-      const fallbackRouteParams: FallbackRouteParam[] = []\n-\n-      resolveParallelRouteParams(\n-        loaderTree,\n-        params,\n-        pathname,\n-        fallbackRouteParams\n-      )\n-\n-      // Should resolve [lang] in path segments to 'en'\n-      expect(params.path).toEqual(['blog', 'post'])\n-      expect(fallbackRouteParams).toHaveLength(0)\n-    })\n-\n-    it('should only process parallel routes, not children route', () => {\n-      // Tree: / -> children: /blog, sidebar: /[...path]\n-      const loaderTree = createLoaderTree(\n-        '',\n-        {\n-          sidebar: createLoaderTree('[...path]'),\n-        },\n-        createLoaderTree('blog')\n-      )\n-      const params: Params = {}\n-      const pathname = '/blog/post'\n-      const fallbackRouteParams: FallbackRouteParam[] = []\n-\n-      resolveParallelRouteParams(\n-        loaderTree,\n-        params,\n-        pathname,\n-        fallbackRouteParams\n-      )\n-\n-      // Should only process @sidebar, not children\n-      expect(params.path).toEqual(['blog', 'post'])\n-      expect(fallbackRouteParams).toHaveLength(0)\n-    })\n-  })\n-\n-  describe('interception routes', () => {\n-    it('should increment depth for (.) interception route (same level)', () => {\n-      // Tree: /(.)photo -> @modal/[...segments]\n-      // Interception routes should increment depth unlike route groups\n-      const loaderTree = createLoaderTree(\n-        '',\n-        {},\n-        createLoaderTree('(.)photo', {\n-          modal: createLoaderTree('[...segments]'),\n-        })\n-      )\n-      const params: Params = {}\n-      const pathname = '/photo/123/details'\n-      const fallbackRouteParams: FallbackRouteParam[] = []\n-\n-      resolveParallelRouteParams(\n-        loaderTree,\n-        params,\n-        pathname,\n-        fallbackRouteParams\n-      )\n-\n-      // Should get segments from depth 1 onwards (after /(.)photo)\n-      expect(params.segments).toEqual(['123', 'details'])\n-      expect(fallbackRouteParams).toHaveLength(0)\n-    })\n-\n-    it('should increment depth for (..) interception route (parent level)', () => {\n-      // Tree: /gallery/(..)photo -> @modal/[id]\n-      const loaderTree = createLoaderTree(\n-        '',\n-        {},\n-        createLoaderTree(\n-          'gallery',\n-          {},\n-          createLoaderTree('(..)photo', {\n-            modal: createLoaderTree('[id]'),\n-          })\n-        )\n-      )\n-      const params: Params = {}\n-      const pathname = '/gallery/photo/123'\n-      const fallbackRouteParams: FallbackRouteParam[] = []\n-\n-      resolveParallelRouteParams(\n-        loaderTree,\n-        params,\n-        pathname,\n-        fallbackRouteParams\n-      )\n-\n-      // (..)photo is at depth 1, @modal/[id] should extract from depth 2\n-      expect(params.id).toBe('123')\n-      expect(fallbackRouteParams).toHaveLength(0)\n-    })\n-\n-    it('should increment depth for (...) interception route (root level)', () => {\n-      // Tree: /app/gallery/(...)photo -> @modal/[...path]\n-      const loaderTree = createLoaderTree(\n-        '',\n-        {},\n-        createLoaderTree(\n-          'app',\n-          {},\n-          createLoaderTree(\n-            'gallery',\n-            {},\n-            createLoaderTree('(...)photo', {\n-              modal: createLoaderTree('[...path]'),\n-            })\n-          )\n-        )\n-      )\n-      const params: Params = {}\n-      const pathname = '/app/gallery/photo/2023/album'\n-      const fallbackRouteParams: FallbackRouteParam[] = []\n-\n-      resolveParallelRouteParams(\n-        loaderTree,\n-        params,\n-        pathname,\n-        fallbackRouteParams\n-      )\n-\n-      // (...)photo is at depth 2, @modal/[...path] should extract from depth 3\n-      expect(params.path).toEqual(['2023', 'album'])\n-      expect(fallbackRouteParams).toHaveLength(0)\n-    })\n-\n-    it('should increment depth for (..)(..) interception route (grandparent level)', () => {\n-      // Tree: /a/b/(..)(..)photo -> @modal/[category]\n-      const loaderTree = createLoaderTree(\n-        '',\n-        {},\n-        createLoaderTree(\n-          'a',\n-          {},\n-          createLoaderTree(\n-            'b',\n-            {},\n-            createLoaderTree('(..)(..)photo', {\n-              modal: createLoaderTree('[category]'),\n-            })\n-          )\n-        )\n-      )\n-      const params: Params = {}\n-      const pathname = '/a/b/photo/nature'\n-      const fallbackRouteParams: FallbackRouteParam[] = []\n-\n-      resolveParallelRouteParams(\n-        loaderTree,\n-        params,\n-        pathname,\n-        fallbackRouteParams\n-      )\n-\n-      // (..)(..)photo is at depth 2, @modal/[category] should extract from depth 3\n-      expect(params.category).toBe('nature')\n-      expect(fallbackRouteParams).toHaveLength(0)\n-    })\n-\n-    it('should distinguish interception routes from regular route groups', () => {\n-      // Tree: /(marketing) -> @sidebar/[...path] (route group)\n-      //   vs: /(.)photo -> @modal/[...path] (interception route)\n-      const routeGroupTree = createLoaderTree(\n-        '',\n-        {},\n-        createLoaderTree('(marketing)', {\n-          sidebar: createLoaderTree('[...path]'),\n-        })\n-      )\n-\n-      const interceptionTree = createLoaderTree(\n-        '',\n-        {},\n-        createLoaderTree('(.)photo', {\n-          modal: createLoaderTree('[...path]'),\n-        })\n-      )\n-\n-      const pathname = '/photo/123'\n-\n-      // Route group - should NOT increment depth\n-      const routeGroupParams: Params = {}\n-      const routeGroupFallback: FallbackRouteParam[] = []\n-      resolveParallelRouteParams(\n-        routeGroupTree,\n-        routeGroupParams,\n-        pathname,\n-        routeGroupFallback\n-      )\n-      // Gets all segments because route group doesn't increment depth\n-      expect(routeGroupParams.path).toEqual(['photo', '123'])\n-\n-      // Interception route - SHOULD increment depth\n-      const interceptionParams: Params = {}\n-      const interceptionFallback: FallbackRouteParam[] = []\n-      resolveParallelRouteParams(\n-        interceptionTree,\n-        interceptionParams,\n-        pathname,\n-        interceptionFallback\n-      )\n-      // Gets segments from depth 1 because (.)photo increments depth\n-      expect(interceptionParams.path).toEqual(['123'])\n-    })\n-  })\n-\n-  describe('empty pathname edge cases', () => {\n-    it('should mark dynamic param as fallback when pathname is empty', () => {\n-      // Tree: / -> @modal/[id]\n-      const loaderTree = createLoaderTree('', {\n-        modal: createLoaderTree('[id]'),\n-      })\n-      const params: Params = {}\n-      const pathname = '/'\n-      const fallbackRouteParams: FallbackRouteParam[] = []\n-\n-      resolveParallelRouteParams(\n-        loaderTree,\n-        params,\n-        pathname,\n-        fallbackRouteParams\n-      )\n-\n-      expect(params.id).toBeUndefined()\n-      expect(fallbackRouteParams).toHaveLength(1)\n-      expect(fallbackRouteParams[0]).toEqual({\n-        paramName: 'id',\n-        paramType: 'dynamic',\n-        isParallelRouteParam: true,\n-      })\n-    })\n-\n-    it('should mark multiple dynamic params as fallback when pathname is empty', () => {\n-      // Tree: / -> @modal/[category] + @sidebar/[filter]\n-      const loaderTree = createLoaderTree('', {\n-        modal: createLoaderTree('[category]'),\n-        sidebar: createLoaderTree('[filter]'),\n-      })\n-      const params: Params = {}\n-      const pathname = '/'\n-      const fallbackRouteParams: FallbackRouteParam[] = []\n-\n-      resolveParallelRouteParams(\n-        loaderTree,\n-        params,\n-        pathname,\n-        fallbackRouteParams\n-      )\n-\n-      expect(params.category).toBeUndefined()\n-      expect(params.filter).toBeUndefined()\n-      expect(fallbackRouteParams).toHaveLength(2)\n-      expect(fallbackRouteParams).toContainEqual({\n-        paramName: 'category',\n-        paramType: 'dynamic',\n-        isParallelRouteParam: true,\n-      })\n-      expect(fallbackRouteParams).toContainEqual({\n-        paramName: 'filter',\n-        paramType: 'dynamic',\n-        isParallelRouteParam: true,\n-      })\n-    })\n-\n-    it('should handle nested parallel route with empty pathname at that depth', () => {\n-      // Tree: /blog -> @modal/[id]\n-      const loaderTree = createLoaderTree(\n-        '',\n-        {},\n-        createLoaderTree('blog', {\n-          modal: createLoaderTree('[id]'),\n-        })\n-      )\n-      const params: Params = {}\n-      const pathname = '/blog'\n-      const fallbackRouteParams: FallbackRouteParam[] = []\n-\n-      resolveParallelRouteParams(\n-        loaderTree,\n-        params,\n-        pathname,\n-        fallbackRouteParams\n-      )\n-\n-      // No segment at depth 1, should mark as fallback\n-      expect(params.id).toBeUndefined()\n-      expect(fallbackRouteParams).toHaveLength(1)\n-      expect(fallbackRouteParams[0]).toEqual({\n-        paramName: 'id',\n-        paramType: 'dynamic',\n-        isParallelRouteParam: true,\n-      })\n-    })\n-  })\n-\n-  describe('complex path segments', () => {\n-    it('should handle catch-all with embedded param placeholders in pathname', () => {\n-      // Tree: / -> @sidebar/[...path]\n-      // Pathname contains a placeholder like [category] which is unknown\n-      const loaderTree = createLoaderTree('', {\n-        sidebar: createLoaderTree('[...path]'),\n-      })\n-      const params: Params = {}\n-      const pathname = '/blog/[category]/tech'\n-      const fallbackRouteParams: FallbackRouteParam[] = [\n-        createFallbackParam('category', false), // category is unknown\n-      ]\n-\n-      resolveParallelRouteParams(\n-        loaderTree,\n-        params,\n-        pathname,\n-        fallbackRouteParams\n-      )\n-\n-      // Should mark as fallback because there's a non-parallel fallback param\n-      expect(params.path).toBeUndefined()\n-      expect(fallbackRouteParams).toHaveLength(2)\n-      expect(fallbackRouteParams[1]).toEqual({\n-        paramName: 'path',\n-        paramType: 'catchall',\n-        isParallelRouteParam: true,\n-      })\n-    })\n-\n-    it('should mark catch-all as fallback when pathname has unknown param placeholder', () => {\n-      // Tree: /[lang] -> @sidebar/[...path]\n-      // Pathname has [lang] which is known, but [category] which is not\n-      const loaderTree = createLoaderTree(\n-        '',\n-        {},\n-        createLoaderTree('[lang]', {\n-          sidebar: createLoaderTree('[...path]'),\n-        })\n-      )\n-      const params: Params = { lang: 'en' }\n-      const pathname = '/en/blog/[category]'\n-      const fallbackRouteParams: FallbackRouteParam[] = []\n-\n-      resolveParallelRouteParams(\n-        loaderTree,\n-        params,\n-        pathname,\n-        fallbackRouteParams\n-      )\n-\n-      // Should mark path as fallback because pathname contains unknown [category] placeholder\n-      expect(params.path).toBeUndefined()\n-      expect(fallbackRouteParams).toHaveLength(1)\n-      expect(fallbackRouteParams[0]).toEqual({\n-        paramName: 'path',\n-        paramType: 'catchall',\n-        isParallelRouteParam: true,\n-      })\n-    })\n-\n-    it('should handle mixed static and dynamic segments in catch-all resolution', () => {\n-      // Tree: /products/[category] -> @filters/[...filterPath]\n-      const loaderTree = createLoaderTree(\n-        '',\n-        {},\n-        createLoaderTree(\n-          'products',\n-          {},\n-          createLoaderTree('[category]', {\n-            filters: createLoaderTree('[...filterPath]'),\n-          })\n-        )\n-      )\n-      const params: Params = { category: 'electronics' }\n-      const pathname = '/products/electronics/brand/apple/price/high'\n-      const fallbackRouteParams: FallbackRouteParam[] = []\n-\n-      resolveParallelRouteParams(\n-        loaderTree,\n-        params,\n-        pathname,\n-        fallbackRouteParams\n-      )\n-\n-      // Should get remaining path after resolving category\n-      expect(params.filterPath).toEqual(['brand', 'apple', 'price', 'high'])\n-      expect(fallbackRouteParams).toHaveLength(0)\n-    })\n-  })\n-\n-  describe('integration scenarios', () => {\n-    it('should handle interception route + parallel route together', () => {\n-      // Tree: /gallery/(.)photo -> @modal/[id] + @sidebar/[category]\n-      const loaderTree = createLoaderTree(\n-        '',\n-        {},\n-        createLoaderTree(\n-          'gallery',\n-          {},\n-          createLoaderTree('(.)photo', {\n-            modal: createLoaderTree('[id]'),\n-            sidebar: createLoaderTree('[category]'),\n-          })\n-        )\n-      )\n-      const params: Params = {}\n-      const pathname = '/gallery/photo/123'\n-      const fallbackRouteParams: FallbackRouteParam[] = []\n-\n-      resolveParallelRouteParams(\n-        loaderTree,\n-        params,\n-        pathname,\n-        fallbackRouteParams\n-      )\n-\n-      // Both should extract from depth 2 (after /gallery/(.)photo)\n-      expect(params.id).toBe('123')\n-      expect(params.category).toBe('123')\n-      expect(fallbackRouteParams).toHaveLength(0)\n-    })\n-\n-    it('should handle route group + parallel route + interception route', () => {\n-      // Tree: /(marketing)/gallery/(.)photo -> @modal/[...path]\n-      const loaderTree = createLoaderTree(\n-        '',\n-        {},\n-        createLoaderTree(\n-          '(marketing)',\n-          {},\n-          createLoaderTree(\n-            'gallery',\n-            {},\n-            createLoaderTree('(.)photo', {\n-              modal: createLoaderTree('[...path]'),\n-            })\n-          )\n-        )\n-      )\n-      const params: Params = {}\n-      const pathname = '/gallery/photo/2023/album'\n-      const fallbackRouteParams: FallbackRouteParam[] = []\n-\n-      resolveParallelRouteParams(\n-        loaderTree,\n-        params,\n-        pathname,\n-        fallbackRouteParams\n-      )\n-\n-      // Route group doesn't increment, gallery does, (.)photo does\n-      // So depth is 2, extract from depth 2 onwards\n-      expect(params.path).toEqual(['2023', 'album'])\n-      expect(fallbackRouteParams).toHaveLength(0)\n-    })\n-\n-    it('should handle all param types together', () => {\n-      // Tree: /[lang] -> @modal/[category] + @sidebar/[...tags] + @info/[[...extra]]\n-      const loaderTree = createLoaderTree(\n-        '',\n-        {},\n-        createLoaderTree('[lang]', {\n-          modal: createLoaderTree('[category]'),\n-          sidebar: createLoaderTree('[...tags]'),\n-          info: createLoaderTree('[[...extra]]'),\n-        })\n-      )\n-      const params: Params = { lang: 'en' }\n-      const pathname = '/en/tech/react/nextjs'\n-      const fallbackRouteParams: FallbackRouteParam[] = []\n-\n-      resolveParallelRouteParams(\n-        loaderTree,\n-        params,\n-        pathname,\n-        fallbackRouteParams\n-      )\n-\n-      // All should extract from depth 1 onwards\n-      expect(params.category).toBe('tech')\n-      expect(params.tags).toEqual(['tech', 'react', 'nextjs'])\n-      expect(params.extra).toEqual(['tech', 'react', 'nextjs'])\n-      expect(fallbackRouteParams).toHaveLength(0)\n-    })\n-\n-    it('should handle complex nesting with multiple interception routes', () => {\n-      // Tree: /app/(.)modal/(.)photo -> @dialog/[id]\n-      const loaderTree = createLoaderTree(\n-        '',\n-        {},\n-        createLoaderTree(\n-          'app',\n-          {},\n-          createLoaderTree(\n-            '(.)modal',\n-            {},\n-            createLoaderTree('(.)photo', {\n-              dialog: createLoaderTree('[id]'),\n-            })\n-          )\n-        )\n-      )\n-      const params: Params = {}\n-      const pathname = '/app/modal/photo/image-123'\n-      const fallbackRouteParams: FallbackRouteParam[] = []\n-\n-      resolveParallelRouteParams(\n-        loaderTree,\n-        params,\n-        pathname,\n-        fallbackRouteParams\n-      )\n-\n-      // app (depth 1) + (.)modal (depth 2) + (.)photo (depth 3) -> extract at depth 3\n-      expect(params.id).toBe('image-123')\n-      expect(fallbackRouteParams).toHaveLength(0)\n-    })\n-  })\n-})\n-\n-/**\n- * Test coverage note for dynamicParams validation in buildAppStaticPaths:\n- *\n- * The two-phase validation for segments with `dynamicParams: false` should be tested\n- * in integration/e2e tests due to the complexity of mocking buildAppStaticPaths dependencies.\n- *\n- * Key scenarios to test:\n- *\n- * Phase 1 (Children route validation - lines 972-997):\n- * - âœ… Should throw error when children route segment has dynamicParams: false\n- *      but param is missing from generateStaticParams\n- * - âœ… Should skip validation for parallel route segments (tested in Phase 2)\n- *\n- * Phase 2 (Parallel route validation - lines 1159-1201):\n- * - âœ… Should throw error when parallel route segment has dynamicParams: false\n- *      but param cannot be resolved from pathname\n- * - âœ… Should throw error when parallel route segment has dynamicParams: false\n- *      but param is marked as fallback (requires request-time resolution)\n- * - âœ… Should succeed when parallel route param can be derived from pathname\n- * - âœ… Should succeed when parallel route param is provided via generateStaticParams\n- *\n- * Example test structure for e2e:\n- *\n- * app/\n- *   @modal/[category]/page.tsx  // dynamicParams: false, no generateStaticParams\n- *   [slug]/page.tsx             // generateStaticParams: [{slug: 'post-1'}]\n- *\n- * Expected behavior:\n- * - If @modal/[category] can derive category from pathname \"/post-1\": âœ… Success\n- * - If @modal/[category] cannot derive category: âŒ Phase 2 error with pathname context\n- *\n- * app/\n- *   [slug]/page.tsx  // dynamicParams: false, no generateStaticParams\n- *\n- * Expected behavior:\n- * - âŒ Phase 1 error: param missing from generateStaticParams\n- */"
        },
        {
            "sha": "59595df54c88b08cc1060b1b2ec231914f8410b9",
            "filename": "packages/next/src/build/static-paths/app.ts",
            "status": "modified",
            "additions": 102,
            "deletions": 285,
            "changes": 387,
            "blob_url": "https://github.com/vercel/next.js/blob/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp.ts?ref=d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd",
            "patch": "@@ -12,26 +12,22 @@ import { AfterRunner } from '../../server/after/run-with-after'\n import { createWorkStore } from '../../server/async-storage/work-store'\n import { FallbackMode } from '../../lib/fallback'\n import type { IncrementalCache } from '../../server/lib/incremental-cache'\n-import type { LoaderTree } from '../../server/lib/app-dir-module'\n import {\n   normalizePathname,\n   encodeParam,\n-  createFallbackRouteParam,\n+  extractPathnameRouteParamSegments,\n+  resolveRouteParamsFromTree,\n } from './utils'\n import escapePathDelimiters from '../../shared/lib/router/utils/escape-path-delimiters'\n import { createIncrementalCache } from '../../export/helpers/create-incremental-cache'\n import type { NextConfigComplete } from '../../server/config-shared'\n import type { WorkStore } from '../../server/app-render/work-async-storage.external'\n import type { DynamicParamTypes } from '../../shared/lib/app-router-types'\n-import { InvariantError } from '../../shared/lib/invariant-error'\n-import {\n-  getParamProperties,\n-  getSegmentParam,\n-} from '../../shared/lib/router/utils/get-segment-param'\n-import { parseLoaderTree } from '../../shared/lib/router/utils/parse-loader-tree'\n-import { INTERCEPTION_ROUTE_MARKERS } from '../../shared/lib/router/utils/interception-routes'\n+import { getParamProperties } from '../../shared/lib/router/utils/get-segment-param'\n import { throwEmptyGenerateStaticParamsError } from '../../shared/lib/errors/empty-generate-static-params-error'\n import type { AppRouteModule } from '../../server/route-modules/app-route/module.compiled'\n+import type { NormalizedAppRoute } from '../../shared/lib/router/routes/app'\n+import { interceptionPrefixFromParamType } from '../../shared/lib/router/utils/interception-prefix-from-param-type'\n \n /**\n  * Filters out duplicate parameters from a list of parameters.\n@@ -306,15 +302,15 @@ export function calculateFallbackMode(\n  * @param page - The page to validate.\n  * @param regex - The route regex.\n  * @param isRoutePPREnabled - Whether the route has partial prerendering enabled.\n- * @param childrenRouteParamSegments - The keys of the parameters.\n+ * @param pathnameSegments - The keys of the parameters.\n  * @param rootParamKeys - The keys of the root params.\n  * @param routeParams - The list of parameters to validate.\n  * @returns The list of validated parameters.\n  */\n function validateParams(\n   page: string,\n   isRoutePPREnabled: boolean,\n-  childrenRouteParamSegments: ReadonlyArray<{\n+  pathnameSegments: ReadonlyArray<{\n     readonly paramName: string\n     readonly paramType: DynamicParamTypes\n   }>,\n@@ -347,7 +343,7 @@ function validateParams(\n   for (const params of routeParams) {\n     const item: Params = {}\n \n-    for (const { paramName: key, paramType } of childrenRouteParamSegments) {\n+    for (const { paramName: key, paramType } of pathnameSegments) {\n       const { repeat, optional } = getParamProperties(paramType)\n \n       let paramValue = params[key]\n@@ -419,11 +415,11 @@ interface TrieNode {\n  * `/blog/[slug]` should not throw because `/blog/first-post` is a more specific concrete route.\n  *\n  * @param prerenderedRoutes - The prerendered routes.\n- * @param childrenRouteParams - The keys of the route parameters.\n+ * @param pathnameSegments - The keys of the route parameters.\n  */\n export function assignErrorIfEmpty(\n   prerenderedRoutes: readonly PrerenderedRoute[],\n-  childrenRouteParams: ReadonlyArray<{\n+  pathnameSegments: ReadonlyArray<{\n     readonly paramName: string\n   }>\n ): void {\n@@ -446,7 +442,7 @@ export function assignErrorIfEmpty(\n     // for ensuring that routes with the same concrete parameters follow the\n     // same path in the Trie, regardless of the original order of properties\n     // in the `params` object.\n-    for (const { paramName: key } of childrenRouteParams) {\n+    for (const { paramName: key } of pathnameSegments) {\n       // Check if the current route actually has a concrete value for this parameter.\n       // If a dynamic segment is not filled (i.e., it's a fallback), it won't have\n       // this property, and we stop building the path for this route at this point.\n@@ -552,171 +548,6 @@ export function assignErrorIfEmpty(\n   }\n }\n \n-/**\n- * Resolves parallel route parameters from the loader tree. This function uses\n- * tree-based traversal to correctly handle the hierarchical structure of parallel\n- * routes and accurately determine parameter values based on their depth in the tree.\n- *\n- * Unlike interpolateParallelRouteParams (which has a complete URL at runtime),\n- * this build-time function determines which parallel route params are unknown.\n- * The pathname may contain placeholders like [slug], making it incomplete.\n- *\n- * @param loaderTree - The loader tree structure containing route hierarchy\n- * @param params - The current route parameters object (will be mutated)\n- * @param pathname - The current pathname being processed (may contain placeholders)\n- * @param fallbackRouteParams - Array of fallback route parameters (will be mutated)\n- */\n-export function resolveParallelRouteParams(\n-  loaderTree: LoaderTree,\n-  params: Params,\n-  pathname: string,\n-  fallbackRouteParams: FallbackRouteParam[]\n-): void {\n-  // Stack-based traversal with depth and parallel route key tracking\n-  const stack: Array<{\n-    tree: LoaderTree\n-    depth: number\n-    parallelKey: string\n-  }> = [{ tree: loaderTree, depth: 0, parallelKey: 'children' }]\n-\n-  // Parse pathname into segments for depth-based resolution\n-  const pathSegments = pathname.split('/').filter(Boolean)\n-\n-  while (stack.length > 0) {\n-    const { tree, depth, parallelKey } = stack.pop()!\n-    const { segment, parallelRoutes } = parseLoaderTree(tree)\n-\n-    // Only process segments that are in parallel routes (not the main 'children' route)\n-    if (parallelKey !== 'children') {\n-      const segmentParam = getSegmentParam(segment)\n-\n-      if (segmentParam && !params.hasOwnProperty(segmentParam.param)) {\n-        const { param: paramName, type: paramType } = segmentParam\n-\n-        switch (paramType) {\n-          case 'catchall':\n-          case 'optional-catchall':\n-          case 'catchall-intercepted-(..)(..)':\n-          case 'catchall-intercepted-(.)':\n-          case 'catchall-intercepted-(..)':\n-          case 'catchall-intercepted-(...)':\n-            // If there are any non-parallel fallback route segments, we can't use the\n-            // pathname to derive the value because it's not complete. We can make\n-            // this assumption because routes are resolved left to right.\n-            if (\n-              fallbackRouteParams.some((param) => !param.isParallelRouteParam)\n-            ) {\n-              fallbackRouteParams.push(\n-                createFallbackRouteParam(paramName, paramType, true)\n-              )\n-              break\n-            }\n-\n-            // For catchall routes in parallel segments, derive from pathname\n-            // using depth to determine which segments to use\n-            const remainingSegments = pathSegments.slice(depth)\n-\n-            // Process segments to handle any embedded dynamic params\n-            // Track if we encounter any unknown param placeholders\n-            let hasUnknownParam = false\n-            const processedSegments = remainingSegments\n-              .flatMap((pathSegment) => {\n-                const param = getSegmentParam(pathSegment)\n-                if (param) {\n-                  // If the segment is a param placeholder, check if we have its value\n-                  if (!params.hasOwnProperty(param.param)) {\n-                    // Unknown param placeholder in pathname - can't derive full value\n-                    hasUnknownParam = true\n-                    return undefined\n-                  }\n-                  // If the segment matches a param, return the param value\n-                  // We don't encode values here as that's handled during retrieval.\n-                  return params[param.param]\n-                }\n-                // Otherwise it's a static segment\n-                return pathSegment\n-              })\n-              .filter((s) => s !== undefined)\n-\n-            // If we encountered any unknown param placeholders, we can't derive\n-            // the full catch-all value from the pathname, so mark as fallback.\n-            if (hasUnknownParam) {\n-              fallbackRouteParams.push(\n-                createFallbackRouteParam(paramName, paramType, true)\n-              )\n-              break\n-            }\n-\n-            if (processedSegments.length > 0) {\n-              params[paramName] = processedSegments\n-            } else if (paramType === 'optional-catchall') {\n-              params[paramName] = []\n-            } else {\n-              // We shouldn't be able to match a catchall segment without any path\n-              // segments if it's not an optional catchall\n-              throw new InvariantError(\n-                `Unexpected empty path segments match for a pathname \"${pathname}\" with param \"${paramName}\" of type \"${paramType}\"`\n-              )\n-            }\n-            break\n-\n-          case 'dynamic':\n-          case 'dynamic-intercepted-(..)(..)':\n-          case 'dynamic-intercepted-(.)':\n-          case 'dynamic-intercepted-(..)':\n-          case 'dynamic-intercepted-(...)':\n-            // For regular dynamic parameters, take the segment at this depth\n-            if (depth < pathSegments.length) {\n-              const pathSegment = pathSegments[depth]\n-              const param = getSegmentParam(pathSegment)\n-\n-              // Check if the segment at this depth is a placeholder for an unknown param\n-              if (param && !params.hasOwnProperty(param.param)) {\n-                // The segment is a placeholder like [category] and we don't have the value\n-                fallbackRouteParams.push(\n-                  createFallbackRouteParam(paramName, paramType, true)\n-                )\n-                break\n-              }\n-\n-              // If the segment matches a param, use the param value from params object\n-              // Otherwise it's a static segment, just use it directly\n-              // We don't encode values here as that's handled during retrieval\n-              params[paramName] = param ? params[param.param] : pathSegment\n-            } else {\n-              // No segment at this depth, mark as fallback.\n-              fallbackRouteParams.push(\n-                createFallbackRouteParam(paramName, paramType, true)\n-              )\n-            }\n-            break\n-\n-          default:\n-            paramType satisfies never\n-        }\n-      }\n-    }\n-\n-    // Calculate next depth - increment if this is not a route group and not empty\n-    let nextDepth = depth\n-    // Route groups are like (marketing) or (dashboard), NOT interception routes like (.)photo\n-    // Interception routes start with markers like (.), (..), (...), (..)(..)) and should increment depth\n-    const isInterceptionRoute = INTERCEPTION_ROUTE_MARKERS.some((marker) =>\n-      segment.startsWith(marker)\n-    )\n-    const isRouteGroup =\n-      !isInterceptionRoute && segment.startsWith('(') && segment.endsWith(')')\n-    if (!isRouteGroup && segment !== '') {\n-      nextDepth++\n-    }\n-\n-    // Add all parallel routes to the stack for processing.\n-    for (const [key, route] of Object.entries(parallelRoutes)) {\n-      stack.push({ tree: route, depth: nextDepth, parallelKey: key })\n-    }\n-  }\n-}\n-\n /**\n  * Processes app directory segments to build route parameters from generateStaticParams functions.\n  * This function walks through the segments array and calls generateStaticParams for each segment that has it,\n@@ -807,15 +638,50 @@ export async function generateRouteStaticParams(\n   return currentParams\n }\n \n+function createReplacements(\n+  segment: Pick<AppSegment, 'paramType'>,\n+  paramValue: string | string[]\n+) {\n+  // Determine the prefix to use for the interception marker.\n+  let prefix: string\n+  if (segment.paramType) {\n+    prefix = interceptionPrefixFromParamType(segment.paramType) ?? ''\n+  } else {\n+    prefix = ''\n+  }\n+\n+  return {\n+    pathname:\n+      prefix +\n+      encodeParam(paramValue, (value) =>\n+        // Only escape path delimiters if the value is a string, the following\n+        // version will URL encode the value.\n+        escapePathDelimiters(value, true)\n+      ),\n+    encodedPathname:\n+      prefix +\n+      encodeParam(\n+        paramValue,\n+        // URL encode the value.\n+        encodeURIComponent\n+      ),\n+  }\n+}\n+\n /**\n- * Builds the static paths for an app using `generateStaticParams`.\n+ * Processes app directory segments to build route parameters from generateStaticParams functions.\n+ * This function walks through the segments array and calls generateStaticParams for each segment that has it,\n+ * combining parent parameters with child parameters to build the complete parameter combinations.\n+ * Uses iterative processing instead of recursion for better performance.\n  *\n- * @param params - The parameters for the build.\n- * @returns The static paths.\n+ * @param segments - Array of app directory segments to process\n+ * @param store - Work store for tracking fetch cache configuration\n+ * @returns Promise that resolves to an array of all parameter combinations\n  */\n export async function buildAppStaticPaths({\n   dir,\n   page,\n+  route,\n   distDir,\n   cacheComponents,\n   authInterrupts,\n@@ -835,6 +701,7 @@ export async function buildAppStaticPaths({\n }: {\n   dir: string\n   page: string\n+  route: NormalizedAppRoute\n   cacheComponents: boolean\n   authInterrupts: boolean\n   segments: readonly Readonly<AppSegment>[]\n@@ -876,55 +743,15 @@ export async function buildAppStaticPaths({\n     cacheMaxMemorySize,\n   })\n \n-  const childrenRouteParamSegments: Array<{\n-    readonly name: string\n-    readonly paramName: string\n-    readonly paramType: DynamicParamTypes\n-  }> = []\n-\n-  // These are all the parallel fallback route params that will be included when\n-  // we're emitting the route for the base route.\n-  const parallelFallbackRouteParams: FallbackRouteParam[] = []\n-\n-  // First pass: collect all non-parallel route param names.\n-  // This allows us to filter out parallel route params that duplicate non-parallel ones.\n-  const nonParallelParamNames = new Set<string>()\n-  for (const segment of segments) {\n-    if (!segment.paramName || !segment.paramType) continue\n-    if (!segment.isParallelRouteSegment) {\n-      nonParallelParamNames.add(segment.paramName)\n-    }\n-  }\n-\n-  // Second pass: collect segments, ensuring non-parallel route params take precedence.\n-  for (const segment of segments) {\n-    // If this segment doesn't have a param name then it's not param that we\n-    // need to resolve.\n-    if (!segment.paramName || !segment.paramType) continue\n-\n-    if (segment.isParallelRouteSegment) {\n-      // Skip parallel route params that are already defined as non-parallel route params.\n-      // Non-parallel route params take precedence because they appear in the URL pathname.\n-      if (nonParallelParamNames.has(segment.paramName)) {\n-        continue\n-      }\n-\n-      // Collect parallel fallback route params for the base route.\n-      // The actual parallel route param resolution is now handled by\n-      // resolveParallelRouteParams using the loader tree.\n-      parallelFallbackRouteParams.push(\n-        createFallbackRouteParam(segment.paramName, segment.paramType, true)\n-      )\n-    } else {\n-      // Collect all the route param keys that are not parallel route params.\n-      // These are the ones that will be included in the request pathname.\n-      childrenRouteParamSegments.push({\n-        name: segment.name,\n-        paramName: segment.paramName,\n-        paramType: segment.paramType,\n-      })\n-    }\n-  }\n+  // Extract segments that contribute to the pathname.\n+  // For AppPageRouteModule: Traverses the loader tree to find all segments (including\n+  //   interception routes in parallel slots) that match the pathname\n+  // For AppRouteRouteModule: Filters the segments array to get non-parallel route params\n+  const pathnameRouteParamSegments = extractPathnameRouteParamSegments(\n+    ComponentMod.routeModule,\n+    segments,\n+    route\n+  )\n \n   const afterRunner = new AfterRunner()\n \n@@ -962,7 +789,7 @@ export async function buildAppStaticPaths({\n     // dynamicParams set to false.\n     if (\n       segment.paramName &&\n-      segment.isDynamicSegment &&\n+      segment.paramType &&\n       segment.config?.dynamicParams === false\n     ) {\n       for (const params of routeParams) {\n@@ -979,7 +806,8 @@ export async function buildAppStaticPaths({\n     }\n \n     if (\n-      segment.isDynamicSegment &&\n+      segment.paramName &&\n+      segment.paramType &&\n       typeof segment.generateStaticParams !== 'function'\n     ) {\n       lastDynamicSegmentHadGenerateStaticParams = false\n@@ -990,10 +818,10 @@ export async function buildAppStaticPaths({\n \n   // Determine if all the segments have had their parameters provided.\n   const hadAllParamsGenerated =\n-    childrenRouteParamSegments.length === 0 ||\n+    pathnameRouteParamSegments.length === 0 ||\n     (routeParams.length > 0 &&\n       routeParams.every((params) => {\n-        for (const { paramName } of childrenRouteParamSegments) {\n+        for (const { paramName } of pathnameRouteParamSegments) {\n           if (paramName in params) continue\n           return false\n         }\n@@ -1031,19 +859,20 @@ export async function buildAppStaticPaths({\n       // routes that won't throw on empty static shell for each of them if\n       // they're available.\n       paramsToProcess = generateAllParamCombinations(\n-        childrenRouteParamSegments,\n+        pathnameRouteParamSegments,\n         routeParams,\n         rootParamKeys\n       )\n \n-      // The fallback route params for this route is a combination of the\n-      // parallel route params and the non-parallel route params.\n-      const fallbackRouteParams: readonly FallbackRouteParam[] = [\n-        ...childrenRouteParamSegments.map(({ paramName, paramType: type }) =>\n-          createFallbackRouteParam(paramName, type, false)\n-        ),\n-        ...parallelFallbackRouteParams,\n-      ]\n+      // Collect all the fallback route params for the segments.\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+      for (const segment of segments) {\n+        if (!segment.paramName || !segment.paramType) continue\n+        fallbackRouteParams.push({\n+          paramName: segment.paramName,\n+          paramType: segment.paramType,\n+        })\n+      }\n \n       // Add the base route, this is the route with all the placeholders as it's\n       // derived from the `page` string.\n@@ -1063,11 +892,11 @@ export async function buildAppStaticPaths({\n     }\n \n     filterUniqueParams(\n-      childrenRouteParamSegments,\n+      pathnameRouteParamSegments,\n       validateParams(\n         page,\n         isRoutePPREnabled,\n-        childrenRouteParamSegments,\n+        pathnameRouteParamSegments,\n         rootParamKeys,\n         paramsToProcess\n       )\n@@ -1077,31 +906,25 @@ export async function buildAppStaticPaths({\n \n       const fallbackRouteParams: FallbackRouteParam[] = []\n \n-      for (const {\n-        paramName: key,\n-        paramType: type,\n-      } of childrenRouteParamSegments) {\n-        const paramValue = params[key]\n+      for (const { name, paramName, paramType } of pathnameRouteParamSegments) {\n+        const paramValue = params[paramName]\n \n         if (!paramValue) {\n           if (isRoutePPREnabled) {\n             // Mark remaining params as fallback params.\n-            fallbackRouteParams.push(createFallbackRouteParam(key, type, false))\n+            fallbackRouteParams.push({ paramName, paramType })\n             for (\n               let i =\n-                childrenRouteParamSegments.findIndex(\n-                  (param) => param.paramName === key\n+                pathnameRouteParamSegments.findIndex(\n+                  (param) => param.paramName === paramName\n                 ) + 1;\n-              i < childrenRouteParamSegments.length;\n+              i < pathnameRouteParamSegments.length;\n               i++\n             ) {\n-              fallbackRouteParams.push(\n-                createFallbackRouteParam(\n-                  childrenRouteParamSegments[i].paramName,\n-                  childrenRouteParamSegments[i].paramType,\n-                  false\n-                )\n-              )\n+              fallbackRouteParams.push({\n+                paramName: pathnameRouteParamSegments[i].paramName,\n+                paramType: pathnameRouteParamSegments[i].paramType,\n+              })\n             }\n             break\n           } else {\n@@ -1111,45 +934,39 @@ export async function buildAppStaticPaths({\n           }\n         }\n \n-        const segment = childrenRouteParamSegments.find(\n-          ({ paramName }) => paramName === key\n-        )\n-        if (!segment) {\n-          throw new InvariantError(\n-            `Param ${key} not found in childrenRouteParamSegments ${childrenRouteParamSegments.map(({ paramName }) => paramName).join(', ')}`\n-          )\n-        }\n+        const replacements = createReplacements({ paramType }, paramValue)\n \n         pathname = pathname.replace(\n-          segment.name,\n-          encodeParam(paramValue, (value) => escapePathDelimiters(value, true))\n+          name,\n+          // We're replacing the segment name with the replacement pathname\n+          // which will include the interception marker prefix if it exists.\n+          replacements.pathname\n         )\n+\n         encodedPathname = encodedPathname.replace(\n-          segment.name,\n-          encodeParam(paramValue, encodeURIComponent)\n+          name,\n+          // We're replacing the segment name with the replacement encoded\n+          // pathname which will include the encoded param value.\n+          replacements.encodedPathname\n         )\n       }\n \n-      // Resolve parallel route params from the loader tree if this is from an\n-      // app page.\n+      // Resolve all route params from the loader tree if this is from an\n+      // app page. This processes both regular route params and parallel route params.\n       if (\n         'loaderTree' in ComponentMod.routeModule.userland &&\n         Array.isArray(ComponentMod.routeModule.userland.loaderTree)\n       ) {\n-        resolveParallelRouteParams(\n+        resolveRouteParamsFromTree(\n           ComponentMod.routeModule.userland.loaderTree,\n           params,\n-          pathname,\n+          route,\n           fallbackRouteParams\n         )\n       }\n \n       const fallbackRootParams: string[] = []\n-      for (const { paramName, isParallelRouteParam } of fallbackRouteParams) {\n-        // Only add the param to the fallback root params if it's not a\n-        // parallel route param. They won't contribute to the request pathname.\n-        if (isParallelRouteParam) continue\n-\n+      for (const { paramName } of fallbackRouteParams) {\n         // If the param is a root param then we can add it to the fallback\n         // root params.\n         if (rootParamSet.has(paramName)) {\n@@ -1183,7 +1000,7 @@ export async function buildAppStaticPaths({\n \n   // Now we have to set the throwOnEmptyStaticShell for each of the routes.\n   if (prerenderedRoutes && cacheComponents) {\n-    assignErrorIfEmpty(prerenderedRoutes, childrenRouteParamSegments)\n+    assignErrorIfEmpty(prerenderedRoutes, pathnameRouteParamSegments)\n   }\n \n   return { fallbackMode, prerenderedRoutes }"
        },
        {
            "sha": "8793b5b78d44291739c9872fdbd9c8ff3e9a1e14",
            "filename": "packages/next/src/build/static-paths/app/extract-pathname-route-param-segments-from-loader-tree.test.ts",
            "status": "added",
            "additions": 1354,
            "deletions": 0,
            "changes": 1354,
            "blob_url": "https://github.com/vercel/next.js/blob/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp%2Fextract-pathname-route-param-segments-from-loader-tree.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp%2Fextract-pathname-route-param-segments-from-loader-tree.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp%2Fextract-pathname-route-param-segments-from-loader-tree.test.ts?ref=d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd",
            "patch": "@@ -0,0 +1,1354 @@\n+import { parseAppRoute } from '../../../shared/lib/router/routes/app'\n+import { extractPathnameRouteParamSegmentsFromLoaderTree } from './extract-pathname-route-param-segments-from-loader-tree'\n+\n+// Helper to create LoaderTree structures for testing\n+type TestLoaderTree = [\n+  segment: string,\n+  parallelRoutes: { [key: string]: TestLoaderTree },\n+  modules: Record<string, unknown>,\n+]\n+\n+function createLoaderTree(\n+  segment: string,\n+  parallelRoutes: { [key: string]: TestLoaderTree } = {},\n+  children?: TestLoaderTree\n+): TestLoaderTree {\n+  const routes = children ? { ...parallelRoutes, children } : parallelRoutes\n+  return [segment, routes, {}]\n+}\n+\n+describe('extractPathnameRouteParamSegmentsFromLoaderTree', () => {\n+  describe('Regular Routes (children segments)', () => {\n+    it('should extract single dynamic segment from children route', () => {\n+      // Tree: /[slug]\n+      const loaderTree = createLoaderTree('', {}, createLoaderTree('[slug]'))\n+      const route = parseAppRoute('/[slug]', true)\n+      const { pathnameRouteParamSegments: result } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(result).toEqual([\n+        { name: '[slug]', paramName: 'slug', paramType: 'dynamic' },\n+      ])\n+    })\n+\n+    it('should extract multiple nested dynamic segments', () => {\n+      // Tree: /[category]/[slug]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('[category]', {}, createLoaderTree('[slug]'))\n+      )\n+      const route = parseAppRoute('/[category]/[slug]', true)\n+      const { pathnameRouteParamSegments: result } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(result).toEqual([\n+        { name: '[category]', paramName: 'category', paramType: 'dynamic' },\n+        { name: '[slug]', paramName: 'slug', paramType: 'dynamic' },\n+      ])\n+    })\n+\n+    it('should extract catchall segment', () => {\n+      // Tree: /[...slug]\n+      const loaderTree = createLoaderTree('', {}, createLoaderTree('[...slug]'))\n+      const route = parseAppRoute('/[...slug]', true)\n+      const { pathnameRouteParamSegments: result } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(result).toEqual([\n+        { name: '[...slug]', paramName: 'slug', paramType: 'catchall' },\n+      ])\n+    })\n+\n+    it('should extract optional catchall segment', () => {\n+      // Tree: /[[...slug]]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('[[...slug]]')\n+      )\n+      const route = parseAppRoute('/[[...slug]]', true)\n+      const { pathnameRouteParamSegments: result } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(result).toEqual([\n+        {\n+          name: '[[...slug]]',\n+          paramName: 'slug',\n+          paramType: 'optional-catchall',\n+        },\n+      ])\n+    })\n+\n+    it('should extract mixed static and dynamic segments', () => {\n+      // Tree: /blog/[category]/posts/[slug]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          'blog',\n+          {},\n+          createLoaderTree(\n+            '[category]',\n+            {},\n+            createLoaderTree('posts', {}, createLoaderTree('[slug]'))\n+          )\n+        )\n+      )\n+      const route = parseAppRoute('/blog/[category]/posts/[slug]', true)\n+      const { pathnameRouteParamSegments: result } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(result).toEqual([\n+        { name: '[category]', paramName: 'category', paramType: 'dynamic' },\n+        { name: '[slug]', paramName: 'slug', paramType: 'dynamic' },\n+      ])\n+    })\n+\n+    it('should handle route with no dynamic segments', () => {\n+      // Tree: /blog/posts\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('blog', {}, createLoaderTree('posts'))\n+      )\n+      const route = parseAppRoute('/blog/posts', true)\n+      const { pathnameRouteParamSegments: result } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(result).toEqual([])\n+    })\n+\n+    it('should extract only segments matching the target pathname', () => {\n+      // Tree: /blog/[category] but target pathname is /[category]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('blog', {}, createLoaderTree('[category]'))\n+      )\n+      const route = parseAppRoute('/[category]', true)\n+      const { pathnameRouteParamSegments: result } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      // Should not match because depths don't align\n+      expect(result).toEqual([])\n+    })\n+  })\n+\n+  describe('Route Groups', () => {\n+    it('should ignore route groups when extracting segments', () => {\n+      // Tree: /(marketing)/blog/[slug]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          '(marketing)',\n+          {},\n+          createLoaderTree('blog', {}, createLoaderTree('[slug]'))\n+        )\n+      )\n+      const route = parseAppRoute('/blog/[slug]', true)\n+      const { pathnameRouteParamSegments: result } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(result).toEqual([\n+        { name: '[slug]', paramName: 'slug', paramType: 'dynamic' },\n+      ])\n+    })\n+\n+    it('should ignore nested route groups', () => {\n+      // Tree: /(group1)/(group2)/[id]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          '(group1)',\n+          {},\n+          createLoaderTree('(group2)', {}, createLoaderTree('[id]'))\n+        )\n+      )\n+      const route = parseAppRoute('/[id]', true)\n+      const { pathnameRouteParamSegments: result } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(result).toEqual([\n+        { name: '[id]', paramName: 'id', paramType: 'dynamic' },\n+      ])\n+    })\n+\n+    it('should handle route groups mixed with static segments', () => {\n+      // Tree: /(app)/dashboard/(users)/[userId]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          '(app)',\n+          {},\n+          createLoaderTree(\n+            'dashboard',\n+            {},\n+            createLoaderTree('(users)', {}, createLoaderTree('[userId]'))\n+          )\n+        )\n+      )\n+      const route = parseAppRoute('/dashboard/[userId]', true)\n+      const { pathnameRouteParamSegments: result } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(result).toEqual([\n+        { name: '[userId]', paramName: 'userId', paramType: 'dynamic' },\n+      ])\n+    })\n+  })\n+\n+  describe('Parallel Routes', () => {\n+    it('should extract segment from parallel route matching pathname', () => {\n+      // Tree: / -> @modal/[id]\n+      const loaderTree = createLoaderTree('', {\n+        modal: createLoaderTree('[id]'),\n+      })\n+      const route = parseAppRoute('/[id]', true)\n+      const { pathnameRouteParamSegments: result } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(result).toEqual([\n+        { name: '[id]', paramName: 'id', paramType: 'dynamic' },\n+      ])\n+    })\n+\n+    it('should extract segments from multiple parallel routes at same depth', () => {\n+      // Tree: / -> @modal/[id] + @sidebar/[category]\n+      const loaderTree = createLoaderTree('', {\n+        modal: createLoaderTree('[id]'),\n+        sidebar: createLoaderTree('[category]'),\n+      })\n+      const route = parseAppRoute('/[id]', true)\n+      const { pathnameRouteParamSegments: result } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      // Only [id] matches - [category] has different param name\n+      expect(result).toEqual([\n+        { name: '[id]', paramName: 'id', paramType: 'dynamic' },\n+      ])\n+    })\n+\n+    it('should extract segments from both children and parallel routes', () => {\n+      // Tree: /[lang] -> children + @modal/[photoId]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('[lang]', {\n+          modal: createLoaderTree('[photoId]'),\n+        })\n+      )\n+      const route = parseAppRoute('/[lang]/[photoId]', true)\n+      const { pathnameRouteParamSegments: result } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(result).toEqual([\n+        { name: '[lang]', paramName: 'lang', paramType: 'dynamic' },\n+        { name: '[photoId]', paramName: 'photoId', paramType: 'dynamic' },\n+      ])\n+    })\n+\n+    it('should extract catchall from parallel route', () => {\n+      // Tree: / -> @sidebar/[...path]\n+      const loaderTree = createLoaderTree('', {\n+        sidebar: createLoaderTree('[...path]'),\n+      })\n+      const route = parseAppRoute('/[...path]', true)\n+      const { pathnameRouteParamSegments: result } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(result).toEqual([\n+        { name: '[...path]', paramName: 'path', paramType: 'catchall' },\n+      ])\n+    })\n+\n+    it('should NOT extract parallel route segments that do not match pathname', () => {\n+      // Tree: /[id] -> @modal/[photoId] + @sidebar/[category]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('[id]', {\n+          modal: createLoaderTree('[photoId]'),\n+          sidebar: createLoaderTree('[category]'),\n+        })\n+      )\n+      const route = parseAppRoute('/[id]', true)\n+      const { pathnameRouteParamSegments: result } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      // Only [id] should match, parallel routes are at depth 1\n+      expect(result).toEqual([\n+        { name: '[id]', paramName: 'id', paramType: 'dynamic' },\n+      ])\n+    })\n+  })\n+\n+  describe('Interception Routes', () => {\n+    it('should extract segment from (.) same-level interception route', () => {\n+      // Tree: /(.)photo/[photoId]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('(.)photo', {}, createLoaderTree('[photoId]'))\n+      )\n+      const route = parseAppRoute('/(.)photo/[photoId]', true)\n+      const { pathnameRouteParamSegments: result } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(result).toEqual([\n+        {\n+          name: '[photoId]',\n+          paramName: 'photoId',\n+          paramType: 'dynamic',\n+        },\n+      ])\n+    })\n+\n+    it('should extract segment from (..) parent-level interception route', () => {\n+      // Tree: /gallery/(..)photo/[photoId]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          'gallery',\n+          {},\n+          createLoaderTree('(..)photo', {}, createLoaderTree('[photoId]'))\n+        )\n+      )\n+      const route = parseAppRoute('/gallery/(..)photo/[photoId]', true)\n+      const { pathnameRouteParamSegments: result } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(result).toEqual([\n+        {\n+          name: '[photoId]',\n+          paramName: 'photoId',\n+          paramType: 'dynamic',\n+        },\n+      ])\n+    })\n+\n+    it('should extract segment from (...) root-level interception route', () => {\n+      // Tree: /app/gallery/(...)photo/[photoId]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          'app',\n+          {},\n+          createLoaderTree(\n+            'gallery',\n+            {},\n+            createLoaderTree('(...)photo', {}, createLoaderTree('[photoId]'))\n+          )\n+        )\n+      )\n+      const route = parseAppRoute('/app/gallery/(...)photo/[photoId]', true)\n+      const { pathnameRouteParamSegments: result } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(result).toEqual([\n+        {\n+          name: '[photoId]',\n+          paramName: 'photoId',\n+          paramType: 'dynamic',\n+        },\n+      ])\n+    })\n+\n+    it('should extract segment from (..)(..) grandparent-level interception route', () => {\n+      // Tree: /a/b/(..)(..)photo/[photoId]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          'a',\n+          {},\n+          createLoaderTree(\n+            'b',\n+            {},\n+            createLoaderTree('(..)(..)photo', {}, createLoaderTree('[photoId]'))\n+          )\n+        )\n+      )\n+      const route = parseAppRoute('/a/b/(..)(..)photo/[photoId]', true)\n+      const { pathnameRouteParamSegments: result } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(result).toEqual([\n+        {\n+          name: '[photoId]',\n+          paramName: 'photoId',\n+          paramType: 'dynamic',\n+        },\n+      ])\n+    })\n+\n+    it('should distinguish interception routes from route groups', () => {\n+      // Tree: /(marketing)/[slug] vs /(.)photo/[photoId]\n+      const routeGroupTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('(marketing)', {}, createLoaderTree('[slug]'))\n+      )\n+      const interceptionTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('(.)photo', {}, createLoaderTree('[photoId]'))\n+      )\n+\n+      const routeGroupRoute = parseAppRoute('/[slug]', true)\n+      const interceptionRoute = parseAppRoute('/(.)photo/[photoId]', true)\n+\n+      const { pathnameRouteParamSegments: routeGroupResult } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(\n+          routeGroupTree,\n+          routeGroupRoute\n+        )\n+      const { pathnameRouteParamSegments: interceptionResult } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(\n+          interceptionTree,\n+          interceptionRoute\n+        )\n+\n+      // Route group ignored, slug at depth 0\n+      expect(routeGroupResult).toEqual([\n+        { name: '[slug]', paramName: 'slug', paramType: 'dynamic' },\n+      ])\n+\n+      // Interception route counts, photoId at depth 1\n+      expect(interceptionResult).toEqual([\n+        {\n+          name: '[photoId]',\n+          paramName: 'photoId',\n+          paramType: 'dynamic',\n+        },\n+      ])\n+    })\n+\n+    it('should handle catchall in interception route', () => {\n+      // Tree: /(.)photo/[...segments]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('(.)photo', {}, createLoaderTree('[...segments]'))\n+      )\n+      const route = parseAppRoute('/(.)photo/[...segments]', true)\n+      const { pathnameRouteParamSegments: result } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(result).toEqual([\n+        {\n+          name: '[...segments]',\n+          paramName: 'segments',\n+          paramType: 'catchall',\n+        },\n+      ])\n+    })\n+\n+    it('should extract intercepted param when marker is part of the segment itself', () => {\n+      // Tree: /(.)[photoId] - the interception marker is PART OF the dynamic segment\n+      // This is the case where -intercepted- types apply (handled by getSegmentParam)\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('(.)[photoId]')\n+      )\n+      const route = parseAppRoute('/[photoId]', true)\n+      const { pathnameRouteParamSegments: result } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(result).toEqual([\n+        {\n+          name: '(.)[photoId]',\n+          paramName: 'photoId',\n+          paramType: 'dynamic-intercepted-(.)', // NOW it has -intercepted- type\n+        },\n+      ])\n+    })\n+  })\n+\n+  describe('Interception Routes in Parallel Routes', () => {\n+    it('should extract segment from interception route in parallel slot', () => {\n+      // Tree: @modal/(.)photo/[photoId]\n+      const loaderTree = createLoaderTree('', {\n+        modal: createLoaderTree('(.)photo', {}, createLoaderTree('[photoId]')),\n+      })\n+      const route = parseAppRoute('/(.)photo/[photoId]', true)\n+      const { pathnameRouteParamSegments: result } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(result).toEqual([\n+        {\n+          name: '[photoId]',\n+          paramName: 'photoId',\n+          paramType: 'dynamic',\n+        },\n+      ])\n+    })\n+\n+    it('should extract segments from both children and intercepting parallel route', () => {\n+      // Tree: /[id] -> children + @modal/(.)photo/[photoId]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('[id]', {\n+          modal: createLoaderTree(\n+            '(.)photo',\n+            {},\n+            createLoaderTree('[photoId]')\n+          ),\n+        })\n+      )\n+      const route = parseAppRoute('/[id]/(.)photo/[photoId]', true)\n+      const { pathnameRouteParamSegments: result } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(result).toEqual([\n+        { name: '[id]', paramName: 'id', paramType: 'dynamic' },\n+        {\n+          name: '[photoId]',\n+          paramName: 'photoId',\n+          paramType: 'dynamic',\n+        },\n+      ])\n+    })\n+\n+    it('should extract from multiple parallel routes with interception', () => {\n+      // Tree: /[category] -> @modal/(.)photo/[photoId] + @sidebar/(.)filter/[filterId]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('[category]', {\n+          modal: createLoaderTree(\n+            '(.)photo',\n+            {},\n+            createLoaderTree('[photoId]')\n+          ),\n+          sidebar: createLoaderTree(\n+            '(.)filter',\n+            {},\n+            createLoaderTree('[filterId]')\n+          ),\n+        })\n+      )\n+      const route = parseAppRoute('/[category]/(.)photo/[photoId]', true)\n+      const { pathnameRouteParamSegments: result } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(result).toEqual([\n+        { name: '[category]', paramName: 'category', paramType: 'dynamic' },\n+        {\n+          name: '[photoId]',\n+          paramName: 'photoId',\n+          paramType: 'dynamic',\n+        },\n+      ])\n+    })\n+\n+    it('should handle (..) interception in parallel route with nested structure', () => {\n+      // Tree: /gallery/[id] -> @modal/(..)photo/[photoId]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          'gallery',\n+          {},\n+          createLoaderTree('[id]', {\n+            modal: createLoaderTree(\n+              '(..)photo',\n+              {},\n+              createLoaderTree('[photoId]')\n+            ),\n+          })\n+        )\n+      )\n+      const route = parseAppRoute('/gallery/[id]/(..)photo/[photoId]', true)\n+      const { pathnameRouteParamSegments: result } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(result).toEqual([\n+        { name: '[id]', paramName: 'id', paramType: 'dynamic' },\n+        {\n+          name: '[photoId]',\n+          paramName: 'photoId',\n+          paramType: 'dynamic',\n+        },\n+      ])\n+    })\n+\n+    it('should handle (...) root-level interception in parallel route', () => {\n+      // Tree: /app/gallery/[id] -> @modal/(...)photo/[photoId]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          'app',\n+          {},\n+          createLoaderTree(\n+            'gallery',\n+            {},\n+            createLoaderTree('[id]', {\n+              modal: createLoaderTree(\n+                '(...)photo',\n+                {},\n+                createLoaderTree('[photoId]')\n+              ),\n+            })\n+          )\n+        )\n+      )\n+      const route = parseAppRoute(\n+        '/app/gallery/[id]/(...)photo/[photoId]',\n+        true\n+      )\n+      const { pathnameRouteParamSegments: result } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(result).toEqual([\n+        { name: '[id]', paramName: 'id', paramType: 'dynamic' },\n+        {\n+          name: '[photoId]',\n+          paramName: 'photoId',\n+          paramType: 'dynamic',\n+        },\n+      ])\n+    })\n+\n+    it('should handle catchall in intercepting parallel route', () => {\n+      // Tree: /[id] -> @modal/(.)details/[...segments]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('[id]', {\n+          modal: createLoaderTree(\n+            '(.)details',\n+            {},\n+            createLoaderTree('[...segments]')\n+          ),\n+        })\n+      )\n+      const route = parseAppRoute('/[id]/(.)details/[...segments]', true)\n+      const { pathnameRouteParamSegments: result } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(result).toEqual([\n+        { name: '[id]', paramName: 'id', paramType: 'dynamic' },\n+        {\n+          name: '[...segments]',\n+          paramName: 'segments',\n+          paramType: 'catchall',\n+        },\n+      ])\n+    })\n+  })\n+\n+  describe('Complex Mixed Scenarios', () => {\n+    it('should handle route groups + parallel routes + interception routes', () => {\n+      // Tree: /(marketing)/[lang] -> @modal/(.)photo/[photoId]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          '(marketing)',\n+          {},\n+          createLoaderTree('[lang]', {\n+            modal: createLoaderTree(\n+              '(.)photo',\n+              {},\n+              createLoaderTree('[photoId]')\n+            ),\n+          })\n+        )\n+      )\n+      const route = parseAppRoute('/[lang]/(.)photo/[photoId]', true)\n+      const { pathnameRouteParamSegments: result } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(result).toEqual([\n+        { name: '[lang]', paramName: 'lang', paramType: 'dynamic' },\n+        {\n+          name: '[photoId]',\n+          paramName: 'photoId',\n+          paramType: 'dynamic',\n+        },\n+      ])\n+    })\n+\n+    it('should handle deeply nested parallel routes with interception', () => {\n+      // Tree: /[lang]/blog/[category] -> @modal/(.)post/[slug]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          '[lang]',\n+          {},\n+          createLoaderTree(\n+            'blog',\n+            {},\n+            createLoaderTree('[category]', {\n+              modal: createLoaderTree(\n+                '(.)post',\n+                {},\n+                createLoaderTree('[slug]')\n+              ),\n+            })\n+          )\n+        )\n+      )\n+      const route = parseAppRoute(\n+        '/[lang]/blog/[category]/(.)post/[slug]',\n+        true\n+      )\n+      const { pathnameRouteParamSegments: result } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(result).toEqual([\n+        { name: '[lang]', paramName: 'lang', paramType: 'dynamic' },\n+        { name: '[category]', paramName: 'category', paramType: 'dynamic' },\n+        {\n+          name: '[slug]',\n+          paramName: 'slug',\n+          paramType: 'dynamic',\n+        },\n+      ])\n+    })\n+\n+    it('should handle multiple interception routes at different levels', () => {\n+      // Tree: /[id] -> @modal1/(.)a/[a] + @modal2/(..)b/[b]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('[id]', {\n+          modal1: createLoaderTree('(.)a', {}, createLoaderTree('[a]')),\n+          modal2: createLoaderTree('(..)b', {}, createLoaderTree('[b]')),\n+        })\n+      )\n+      const route = parseAppRoute('/[id]/(.)a/[a]', true)\n+      const { pathnameRouteParamSegments: result } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(result).toEqual([\n+        { name: '[id]', paramName: 'id', paramType: 'dynamic' },\n+        {\n+          name: '[a]',\n+          paramName: 'a',\n+          paramType: 'dynamic',\n+        },\n+      ])\n+    })\n+\n+    it('should extract from actual Next.js photo gallery pattern', () => {\n+      // Realistic pattern: /photos/[id] with @modal/(.)photo/[photoId]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          'photos',\n+          {},\n+          createLoaderTree('[id]', {\n+            modal: createLoaderTree(\n+              '(.)photo',\n+              {},\n+              createLoaderTree('[photoId]')\n+            ),\n+          })\n+        )\n+      )\n+      const route = parseAppRoute('/photos/[id]/(.)photo/[photoId]', true)\n+      const { pathnameRouteParamSegments: result } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(result).toEqual([\n+        { name: '[id]', paramName: 'id', paramType: 'dynamic' },\n+        {\n+          name: '[photoId]',\n+          paramName: 'photoId',\n+          paramType: 'dynamic',\n+        },\n+      ])\n+    })\n+\n+    it('should handle i18n with interception routes', () => {\n+      // Tree: /[locale]/products/[category] -> @modal/(.)product/[productId]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          '[locale]',\n+          {},\n+          createLoaderTree(\n+            'products',\n+            {},\n+            createLoaderTree('[category]', {\n+              modal: createLoaderTree(\n+                '(.)product',\n+                {},\n+                createLoaderTree('[productId]')\n+              ),\n+            })\n+          )\n+        )\n+      )\n+      const route = parseAppRoute(\n+        '/[locale]/products/[category]/(.)product/[productId]',\n+        true\n+      )\n+      const { pathnameRouteParamSegments: result } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(result).toEqual([\n+        { name: '[locale]', paramName: 'locale', paramType: 'dynamic' },\n+        { name: '[category]', paramName: 'category', paramType: 'dynamic' },\n+        {\n+          name: '[productId]',\n+          paramName: 'productId',\n+          paramType: 'dynamic',\n+        },\n+      ])\n+    })\n+  })\n+\n+  describe('Edge Cases', () => {\n+    it('should return empty array for pathname with no dynamic segments', () => {\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('blog', {}, createLoaderTree('posts'))\n+      )\n+      const route = parseAppRoute('/blog/posts', true)\n+      const { pathnameRouteParamSegments: result } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(result).toEqual([])\n+    })\n+\n+    it('should return empty array when no segments match pathname', () => {\n+      // Tree has dynamic segments but they don't match the pathname structure\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('api', {}, createLoaderTree('[version]'))\n+      )\n+      const route = parseAppRoute('/different/path', true)\n+      const { pathnameRouteParamSegments: result } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(result).toEqual([])\n+    })\n+\n+    it('should handle empty segment in tree', () => {\n+      // Tree: '' -> [id]\n+      const loaderTree = createLoaderTree('', {}, createLoaderTree('[id]'))\n+      const route = parseAppRoute('/[id]', true)\n+      const { pathnameRouteParamSegments: result } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(result).toEqual([\n+        { name: '[id]', paramName: 'id', paramType: 'dynamic' },\n+      ])\n+    })\n+\n+    it('should match segments by depth and param name', () => {\n+      // Tree: /[lang]/blog/[slug] but pathname is /[lang]/[slug]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          '[lang]',\n+          {},\n+          createLoaderTree('blog', {}, createLoaderTree('[slug]'))\n+        )\n+      )\n+      const route = parseAppRoute('/[lang]/[slug]', true)\n+      const { pathnameRouteParamSegments: result } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      // Should match [lang] at depth 0 but not [slug] (wrong depth)\n+      expect(result).toEqual([\n+        { name: '[lang]', paramName: 'lang', paramType: 'dynamic' },\n+      ])\n+    })\n+\n+    it('should handle optional catchall in parallel route', () => {\n+      // Tree: @sidebar/[[...optional]]\n+      const loaderTree = createLoaderTree('', {\n+        sidebar: createLoaderTree('[[...optional]]'),\n+      })\n+      const route = parseAppRoute('/[[...optional]]', true)\n+      const { pathnameRouteParamSegments: result } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(result).toEqual([\n+        {\n+          name: '[[...optional]]',\n+          paramName: 'optional',\n+          paramType: 'optional-catchall',\n+        },\n+      ])\n+    })\n+\n+    it('should handle multiple route groups in sequence', () => {\n+      // Tree: /(a)/(b)/(c)/[id]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          '(a)',\n+          {},\n+          createLoaderTree(\n+            '(b)',\n+            {},\n+            createLoaderTree('(c)', {}, createLoaderTree('[id]'))\n+          )\n+        )\n+      )\n+      const route = parseAppRoute('/[id]', true)\n+      const { pathnameRouteParamSegments: result } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(result).toEqual([\n+        { name: '[id]', paramName: 'id', paramType: 'dynamic' },\n+      ])\n+    })\n+  })\n+\n+  describe('Static Segment Matching', () => {\n+    it('should not extract segments when static segments do not match', () => {\n+      // Tree: /blog/[slug] but pathname is /news/[slug]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('blog', {}, createLoaderTree('[slug]'))\n+      )\n+      const route = parseAppRoute('/news/[slug]', true)\n+      const { pathnameRouteParamSegments: result } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(result).toEqual([])\n+    })\n+\n+    it('should match when static segments align correctly', () => {\n+      // Tree: /api/v1/[endpoint] -> /api/v1/[endpoint]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          'api',\n+          {},\n+          createLoaderTree('v1', {}, createLoaderTree('[endpoint]'))\n+        )\n+      )\n+      const route = parseAppRoute('/api/v1/[endpoint]', true)\n+      const { pathnameRouteParamSegments: result } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(result).toEqual([\n+        { name: '[endpoint]', paramName: 'endpoint', paramType: 'dynamic' },\n+      ])\n+    })\n+\n+    it('should handle segments with values already present in the page', () => {\n+      // Tree: /blog/[slug] but pathname is /blog/my-slug\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {\n+          sidebar: createLoaderTree('[[...catchAll]]'),\n+        },\n+        createLoaderTree('blog', {}, createLoaderTree('[slug]'))\n+      )\n+      const route = parseAppRoute('/blog/my-slug', true)\n+      const { pathnameRouteParamSegments: result } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(result).toEqual([])\n+    })\n+  })\n+\n+  describe('Prefix Validation with Type Mismatch', () => {\n+    it('should NOT extract param when prefix has type mismatch (static vs dynamic)', () => {\n+      // Tree: /(.)photo -> @modal/[id]\n+      // Route: /[category]/[id]\n+      //\n+      // When checking @modal/[id] at depth 1:\n+      //   currentPath = [(.)photo] (STATIC segment)\n+      //   route.segments[0] = [category] (DYNAMIC segment)\n+      //   route.segments[1] = [id] (DYNAMIC segment)\n+      //\n+      // The [id] param matches at depth 1, BUT the prefix validation should fail\n+      // because (.)photo (static) doesn't match [category] (dynamic) at depth 0\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('(.)photo', {\n+          modal: createLoaderTree('[id]'),\n+        })\n+      )\n+      const route = parseAppRoute('/[category]/[id]', true)\n+      const { pathnameRouteParamSegments: result } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      // Should return empty array - [id] should NOT be extracted\n+      // Without the type check, validatePrefixMatch would incorrectly return true\n+      // because neither the static nor dynamic comparison would trigger\n+      expect(result).toEqual([])\n+    })\n+\n+    it('should NOT extract param when prefix has type mismatch (dynamic vs static)', () => {\n+      // Tree: /[lang] -> @modal/[id]\n+      // Route: /photo/[id]\n+      //\n+      // When checking @modal/[id] at depth 1:\n+      //   currentPath = [lang] (DYNAMIC segment)\n+      //   route.segments[0] = photo (STATIC segment)\n+      //   route.segments[1] = [id] (DYNAMIC segment)\n+      //\n+      // The [id] param matches at depth 1, BUT the prefix validation should fail\n+      // because [lang] (dynamic) doesn't match photo (static) at depth 0\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('[lang]', {\n+          modal: createLoaderTree('[id]'),\n+        })\n+      )\n+      const route = parseAppRoute('/photo/[id]', true)\n+      const { pathnameRouteParamSegments: result } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      // Should return empty array - [id] should NOT be extracted\n+      // Without the type check, validatePrefixMatch would incorrectly return true\n+      expect(result).toEqual([])\n+    })\n+\n+    it('should extract param when prefix types match correctly', () => {\n+      // Tree: /blog -> @modal/(.)photo/[id]\n+      // Route: /blog/(.)photo/[id]\n+      //\n+      // When checking @modal/(.)photo/[id]:\n+      //   currentPath at depth 1 = (.)photo (STATIC segment)\n+      //   route.segments at depth 1 = (.)photo (STATIC segment)\n+      //\n+      // Types match AND names match, so [id] should be extracted\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('blog', {\n+          modal: createLoaderTree('(.)photo', {}, createLoaderTree('[id]')),\n+        })\n+      )\n+      const route = parseAppRoute('/blog/(.)photo/[id]', true)\n+      const { pathnameRouteParamSegments: result } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      // Should extract [id] because prefix validation succeeds\n+      expect(result).toEqual([\n+        {\n+          name: '[id]',\n+          paramName: 'id',\n+          paramType: 'dynamic',\n+        },\n+      ])\n+    })\n+  })\n+\n+  describe('Params Resolution', () => {\n+    it('should resolve single static value for dynamic segment', () => {\n+      // Tree: /[id]\n+      // Route: /123 (static value)\n+      const loaderTree = createLoaderTree('', {}, createLoaderTree('[id]'))\n+      const route = parseAppRoute('/123', true)\n+      const { pathnameRouteParamSegments, params } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(pathnameRouteParamSegments).toEqual([])\n+      expect(params).toEqual({ id: '123' })\n+    })\n+\n+    it('should resolve multiple static values for dynamic segments', () => {\n+      // Tree: /[category]/[id]\n+      // Route: /electronics/123\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('[category]', {}, createLoaderTree('[id]'))\n+      )\n+      const route = parseAppRoute('/electronics/123', true)\n+      const { pathnameRouteParamSegments, params } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(pathnameRouteParamSegments).toEqual([])\n+      expect(params).toEqual({\n+        category: 'electronics',\n+        id: '123',\n+      })\n+    })\n+\n+    it('should resolve static value in interception route', () => {\n+      // Tree: /blog -> @modal/(.)photo/[id]\n+      // Route: /blog/(.)photo/123\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('blog', {\n+          modal: createLoaderTree('(.)photo', {}, createLoaderTree('[id]')),\n+        })\n+      )\n+      const route = parseAppRoute('/blog/(.)photo/123', true)\n+      const { pathnameRouteParamSegments, params } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(pathnameRouteParamSegments).toEqual([])\n+      expect(params).toEqual({ id: '123' })\n+    })\n+\n+    it('should resolve catchall with static segments', () => {\n+      // Tree: /docs/[...slug]\n+      // Route: /docs/getting-started/installation\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('docs', {}, createLoaderTree('[...slug]'))\n+      )\n+      const route = parseAppRoute('/docs/getting-started/installation', true)\n+      const { pathnameRouteParamSegments, params } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(pathnameRouteParamSegments).toEqual([])\n+      expect(params).toEqual({\n+        slug: ['getting-started', 'installation'],\n+      })\n+    })\n+\n+    it('should resolve optional catchall with static segments', () => {\n+      // Tree: /docs/[[...slug]]\n+      // Route: /docs/api/reference\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('docs', {}, createLoaderTree('[[...slug]]'))\n+      )\n+      const route = parseAppRoute('/docs/api/reference', true)\n+      const { pathnameRouteParamSegments, params } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(pathnameRouteParamSegments).toEqual([])\n+      expect(params).toEqual({\n+        slug: ['api', 'reference'],\n+      })\n+    })\n+\n+    it('should resolve optional catchall with empty value', () => {\n+      // Tree: /docs/[[...slug]]\n+      // Route: /docs\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('docs', {}, createLoaderTree('[[...slug]]'))\n+      )\n+      const route = parseAppRoute('/docs', true)\n+      const { pathnameRouteParamSegments, params } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(pathnameRouteParamSegments).toEqual([])\n+      expect(params).toEqual({})\n+    })\n+\n+    it('should handle mixed static and dynamic segments', () => {\n+      // Tree: /blog/[lang]/[slug]\n+      // Route: /blog/en/[slug] (lang is static, slug is dynamic)\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          'blog',\n+          {},\n+          createLoaderTree('[lang]', {}, createLoaderTree('[slug]'))\n+        )\n+      )\n+      const route = parseAppRoute('/blog/en/[slug]', true)\n+      const { pathnameRouteParamSegments, params } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      // [slug] is not in pathnameRouteParamSegments because the prefix has a type\n+      // mismatch ([lang] dynamic vs 'en' static), so validation fails\n+      expect(pathnameRouteParamSegments).toEqual([])\n+      // But lang is still resolved from the static value\n+      expect(params).toEqual({\n+        lang: 'en',\n+      })\n+    })\n+\n+    it('should not resolve params when segment is dynamic placeholder', () => {\n+      // Tree: /[category]/[id]\n+      // Route: /[category]/[id] (both are placeholders)\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('[category]', {}, createLoaderTree('[id]'))\n+      )\n+      const route = parseAppRoute('/[category]/[id]', true)\n+      const { pathnameRouteParamSegments, params } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(pathnameRouteParamSegments).toEqual([\n+        { name: '[category]', paramName: 'category', paramType: 'dynamic' },\n+        { name: '[id]', paramName: 'id', paramType: 'dynamic' },\n+      ])\n+      expect(params).toEqual({})\n+    })\n+\n+    it('should resolve params with route groups', () => {\n+      // Tree: /(shop)/[category]/[id]\n+      // Route: /electronics/123\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          '(shop)',\n+          {},\n+          createLoaderTree('[category]', {}, createLoaderTree('[id]'))\n+        )\n+      )\n+      const route = parseAppRoute('/electronics/123', true)\n+      const { pathnameRouteParamSegments, params } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(pathnameRouteParamSegments).toEqual([])\n+      expect(params).toEqual({\n+        category: 'electronics',\n+        id: '123',\n+      })\n+    })\n+\n+    it('should resolve params in parallel routes', () => {\n+      // Tree: /blog -> @modal/[id]\n+      // Route: /blog/123 (via parallel route)\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('blog', {\n+          modal: createLoaderTree('[id]'),\n+        })\n+      )\n+      const route = parseAppRoute('/blog/123', true)\n+      const { pathnameRouteParamSegments, params } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(pathnameRouteParamSegments).toEqual([])\n+      expect(params).toEqual({ id: '123' })\n+    })\n+\n+    it('should resolve params with interception markers in segment', () => {\n+      // Tree: /(.)[id]\n+      // Route: /(.)123\n+      const loaderTree = createLoaderTree('', {}, createLoaderTree('(.)[id]'))\n+      const route = parseAppRoute('/(.)123', true)\n+      const { pathnameRouteParamSegments, params } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(pathnameRouteParamSegments).toEqual([])\n+      // The interception marker is part of the segment name\n+      expect(params).toEqual({ id: '123' })\n+    })\n+\n+    it('should handle catchall with mixed static and dynamic in pathname', () => {\n+      // Tree: /[...slug]\n+      // Route: /api/[version]/users (version is dynamic, api and users are static)\n+      const loaderTree = createLoaderTree('', {}, createLoaderTree('[...slug]'))\n+      const route = parseAppRoute('/api/[version]/users', true)\n+      const { pathnameRouteParamSegments, params } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(pathnameRouteParamSegments).toEqual([])\n+      // Should not resolve because pathname contains unknown [version]\n+      expect(params).toEqual({})\n+    })\n+\n+    it('should resolve complex interception route in photo gallery pattern', () => {\n+      // Tree: / -> @modal/(.)photo/[id]\n+      // Route: /(.)photo/abc123\n+      const loaderTree = createLoaderTree('', {\n+        modal: createLoaderTree('(.)photo', {}, createLoaderTree('[id]')),\n+      })\n+      const route = parseAppRoute('/(.)photo/abc123', true)\n+      const { pathnameRouteParamSegments, params } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(pathnameRouteParamSegments).toEqual([])\n+      expect(params).toEqual({ id: 'abc123' })\n+    })\n+\n+    it('should resolve params with (..) parent-level interception', () => {\n+      // Tree: /blog -> @modal/(..)[id]\n+      // Route: /blog/(..)456\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('blog', {\n+          modal: createLoaderTree('(..)[id]'),\n+        })\n+      )\n+      const route = parseAppRoute('/blog/(..)456', true)\n+      const { pathnameRouteParamSegments, params } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(pathnameRouteParamSegments).toEqual([])\n+      expect(params).toEqual({ id: '456' })\n+    })\n+\n+    it('should resolve catch-all params with (..) parent-level interception', () => {\n+      // Tree: /blog -> @modal/(..)[...catchAll]\n+      // Route: /blog/(..)some/path/here\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('blog', {\n+          modal: createLoaderTree('(..)[...catchAll]'),\n+        })\n+      )\n+      const route = parseAppRoute('/blog/(..)some/path/here', true)\n+      const { pathnameRouteParamSegments, params } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(pathnameRouteParamSegments).toEqual([])\n+      expect(params).toEqual({ catchAll: ['some', 'path', 'here'] })\n+    })\n+\n+    it('should handle deeply nested static values', () => {\n+      // Tree: /[lang]/[region]/shop/[category]/[id]\n+      // Route: /en/us/shop/electronics/laptop-123\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          '[lang]',\n+          {},\n+          createLoaderTree(\n+            '[region]',\n+            {},\n+            createLoaderTree(\n+              'shop',\n+              {},\n+              createLoaderTree('[category]', {}, createLoaderTree('[id]'))\n+            )\n+          )\n+        )\n+      )\n+      const route = parseAppRoute('/en/us/shop/electronics/laptop-123', true)\n+      const { pathnameRouteParamSegments, params } =\n+        extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route)\n+\n+      expect(pathnameRouteParamSegments).toEqual([])\n+      expect(params).toEqual({\n+        lang: 'en',\n+        region: 'us',\n+        category: 'electronics',\n+        id: 'laptop-123',\n+      })\n+    })\n+  })\n+})"
        },
        {
            "sha": "25510961559347e25b5c5405455f4db7736e72fa",
            "filename": "packages/next/src/build/static-paths/app/extract-pathname-route-param-segments-from-loader-tree.ts",
            "status": "added",
            "additions": 192,
            "deletions": 0,
            "changes": 192,
            "blob_url": "https://github.com/vercel/next.js/blob/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp%2Fextract-pathname-route-param-segments-from-loader-tree.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp%2Fextract-pathname-route-param-segments-from-loader-tree.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp%2Fextract-pathname-route-param-segments-from-loader-tree.ts?ref=d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd",
            "patch": "@@ -0,0 +1,192 @@\n+import type { LoaderTree } from '../../../server/lib/app-dir-module'\n+import type { Params } from '../../../server/request/params'\n+import type { DynamicParamTypes } from '../../../shared/lib/app-router-types'\n+import {\n+  parseAppRouteSegment,\n+  type NormalizedAppRoute,\n+  type NormalizedAppRouteSegment,\n+} from '../../../shared/lib/router/routes/app'\n+import { parseLoaderTree } from '../../../shared/lib/router/utils/parse-loader-tree'\n+import { resolveParamValue } from '../../../shared/lib/router/utils/resolve-param-value'\n+\n+/**\n+ * Validates that the static segments in currentPath match the corresponding\n+ * segments in targetSegments. This ensures we only extract dynamic parameters\n+ * that are part of the target pathname structure.\n+ *\n+ * Segments are compared literally - interception markers like \"(.)photo\" are\n+ * part of the pathname and must match exactly.\n+ *\n+ * @example\n+ * // Matching paths\n+ * currentPath: ['blog', '(.)photo']\n+ * targetSegments: ['blog', '(.)photo', '[id]']\n+ * â†’ Returns true (both static segments match exactly)\n+ *\n+ * @example\n+ * // Non-matching paths\n+ * currentPath: ['blog', '(.)photo']\n+ * targetSegments: ['blog', 'photo', '[id]']\n+ * â†’ Returns false (segments don't match - marker is part of pathname)\n+ *\n+ * @param currentPath - The accumulated path segments from the loader tree\n+ * @param targetSegments - The target pathname split into segments\n+ * @returns true if all static segments match, false otherwise\n+ */\n+function validatePrefixMatch(\n+  currentPath: NormalizedAppRouteSegment[],\n+  route: NormalizedAppRoute\n+): boolean {\n+  for (let i = 0; i < currentPath.length; i++) {\n+    const pathSegment = currentPath[i]\n+    const targetPathSegment = route.segments[i]\n+\n+    // Type mismatch - one is static, one is dynamic\n+    if (pathSegment.type !== targetPathSegment.type) {\n+      return false\n+    }\n+\n+    // One has an interception marker, the other doesn't.\n+    if (\n+      pathSegment.interceptionMarker !== targetPathSegment.interceptionMarker\n+    ) {\n+      return false\n+    }\n+\n+    // Both are static but names don't match\n+    if (\n+      pathSegment.type === 'static' &&\n+      targetPathSegment.type === 'static' &&\n+      pathSegment.name !== targetPathSegment.name\n+    ) {\n+      return false\n+    }\n+    // Both are dynamic but param names don't match\n+    else if (\n+      pathSegment.type === 'dynamic' &&\n+      targetPathSegment.type === 'dynamic' &&\n+      pathSegment.param.paramType !== targetPathSegment.param.paramType &&\n+      pathSegment.param.paramName !== targetPathSegment.param.paramName\n+    ) {\n+      return false\n+    }\n+  }\n+\n+  return true\n+}\n+\n+/**\n+ * Extracts pathname route param segments from a loader tree and resolves\n+ * parameter values from static segments in the route.\n+ *\n+ * @param loaderTree - The loader tree structure containing route hierarchy\n+ * @param route - The target route to match against\n+ * @returns Object containing pathname route param segments and resolved params\n+ */\n+export function extractPathnameRouteParamSegmentsFromLoaderTree(\n+  loaderTree: LoaderTree,\n+  route: NormalizedAppRoute\n+): {\n+  pathnameRouteParamSegments: Array<{\n+    readonly name: string\n+    readonly paramName: string\n+    readonly paramType: DynamicParamTypes\n+  }>\n+  params: Params\n+} {\n+  const pathnameRouteParamSegments: Array<{\n+    readonly name: string\n+    readonly paramName: string\n+    readonly paramType: DynamicParamTypes\n+  }> = []\n+  const params: Params = {}\n+\n+  // BFS traversal with depth and path tracking\n+  const queue: Array<{\n+    tree: LoaderTree\n+    depth: number\n+    currentPath: NormalizedAppRouteSegment[]\n+  }> = [{ tree: loaderTree, depth: 0, currentPath: [] }]\n+\n+  while (queue.length > 0) {\n+    const { tree, depth, currentPath } = queue.shift()!\n+    const { segment, parallelRoutes } = parseLoaderTree(tree)\n+\n+    // Build the path for the current node\n+    let updatedPath = currentPath\n+    let nextDepth = depth\n+\n+    const appSegment = parseAppRouteSegment(segment)\n+\n+    // Only add to path if it's a real segment that appears in the URL\n+    // Route groups and parallel markers don't contribute to URL pathname\n+    if (\n+      appSegment &&\n+      appSegment.type !== 'route-group' &&\n+      appSegment.type !== 'parallel-route'\n+    ) {\n+      updatedPath = [...currentPath, appSegment]\n+      nextDepth = depth + 1\n+    }\n+\n+    // Check if this segment has a param and matches the target pathname at this depth\n+    if (appSegment?.type === 'dynamic') {\n+      const { paramName, paramType } = appSegment.param\n+\n+      // Check if this segment is at the correct depth in the target pathname\n+      // A segment matches if:\n+      // 1. There's a dynamic segment at this depth in the pathname\n+      // 2. The parameter names match (e.g., [id] matches [id], not [category])\n+      // 3. The static segments leading up to this point match (prefix check)\n+      if (depth < route.segments.length) {\n+        const targetSegment = route.segments[depth]\n+\n+        // Match if the target pathname has a dynamic segment at this depth\n+        if (targetSegment.type === 'dynamic') {\n+          // Check that parameter names match exactly\n+          // This prevents [category] from matching against /[id]\n+          if (paramName !== targetSegment.param.paramName) {\n+            continue // Different param names, skip this segment\n+          }\n+\n+          // Validate that the path leading up to this dynamic segment matches\n+          // the target pathname. This prevents false matches like extracting\n+          // [slug] from \"/news/[slug]\" when the tree has \"/blog/[slug]\"\n+          if (validatePrefixMatch(currentPath, route)) {\n+            pathnameRouteParamSegments.push({\n+              name: segment,\n+              paramName,\n+              paramType,\n+            })\n+          }\n+        }\n+      }\n+\n+      // Resolve parameter value if it's not already known.\n+      if (!params.hasOwnProperty(paramName)) {\n+        const paramValue = resolveParamValue(\n+          paramName,\n+          paramType,\n+          depth,\n+          route,\n+          params\n+        )\n+\n+        if (paramValue !== undefined) {\n+          params[paramName] = paramValue\n+        }\n+      }\n+    }\n+\n+    // Continue traversing all parallel routes to find matching segments\n+    for (const parallelRoute of Object.values(parallelRoutes)) {\n+      queue.push({\n+        tree: parallelRoute,\n+        depth: nextDepth,\n+        currentPath: updatedPath,\n+      })\n+    }\n+  }\n+\n+  return { pathnameRouteParamSegments, params }\n+}"
        },
        {
            "sha": "0afe7a6b29a7aa750f9709578fdf3994be983fe9",
            "filename": "packages/next/src/build/static-paths/types.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 8,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Ftypes.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Ftypes.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Ftypes.ts?ref=d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd",
            "patch": "@@ -27,12 +27,6 @@ export type FallbackRouteParam = {\n    * The type of the param.\n    */\n   readonly paramType: DynamicParamTypes\n-\n-  /**\n-   * Whether this is a parallel route param or descends from a parallel route\n-   * param.\n-   */\n-  readonly isParallelRouteParam: boolean\n }\n \n type FallbackPrerenderedRoute = {\n@@ -41,8 +35,9 @@ type FallbackPrerenderedRoute = {\n   readonly encodedPathname: string\n \n   /**\n-   * The fallback route params for the route. This includes both the parallel\n-   * route params and the non-parallel route params.\n+   * The fallback route params for the route. This includes all route parameters\n+   * that are unknown at build time, from both the main children route and any\n+   * parallel routes.\n    */\n   readonly fallbackRouteParams: readonly FallbackRouteParam[]\n   readonly fallbackMode: FallbackMode | undefined"
        },
        {
            "sha": "8733020221c49e740b4ff0d72dd8e37a897183c1",
            "filename": "packages/next/src/build/static-paths/utils.test.ts",
            "status": "added",
            "additions": 972,
            "deletions": 0,
            "changes": 972,
            "blob_url": "https://github.com/vercel/next.js/blob/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Futils.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Futils.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Futils.test.ts?ref=d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd",
            "patch": "@@ -0,0 +1,972 @@\n+import type { Params } from '../../server/request/params'\n+import { parseAppRoute } from '../../shared/lib/router/routes/app'\n+import type { FallbackRouteParam } from './types'\n+import { resolveRouteParamsFromTree } from './utils'\n+\n+// Helper to create LoaderTree structures for testing\n+type TestLoaderTree = [\n+  segment: string,\n+  parallelRoutes: { [key: string]: TestLoaderTree },\n+  modules: Record<string, unknown>,\n+]\n+\n+function createLoaderTree(\n+  segment: string,\n+  parallelRoutes: { [key: string]: TestLoaderTree } = {},\n+  children?: TestLoaderTree\n+): TestLoaderTree {\n+  const routes = children ? { ...parallelRoutes, children } : parallelRoutes\n+  return [segment, routes, {}]\n+}\n+\n+describe('resolveRouteParamsFromTree', () => {\n+  describe('direct match case', () => {\n+    it('should skip processing when param already exists in params object', () => {\n+      // Tree: / -> @sidebar/[existingParam]\n+      const loaderTree = createLoaderTree('', {\n+        sidebar: createLoaderTree('[existingParam]'),\n+      })\n+      const params: Params = { existingParam: 'value' }\n+      const route = parseAppRoute('/some/path', true)\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveRouteParamsFromTree(loaderTree, params, route, fallbackRouteParams)\n+\n+      expect(params.existingParam).toBe('value')\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+\n+    it('should skip processing for multiple existing params', () => {\n+      // Tree: / -> @sidebar/[param1] + @modal/[...param2]\n+      const loaderTree = createLoaderTree('', {\n+        sidebar: createLoaderTree('[param1]'),\n+        modal: createLoaderTree('[...param2]'),\n+      })\n+      const params: Params = { param1: 'value1', param2: ['a', 'b'] }\n+      const route = parseAppRoute('/some/path', true)\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveRouteParamsFromTree(loaderTree, params, route, fallbackRouteParams)\n+\n+      expect(params.param1).toBe('value1')\n+      expect(params.param2).toEqual(['a', 'b'])\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+  })\n+\n+  describe('dynamic params', () => {\n+    it('should extract dynamic param from pathname when not already in params', () => {\n+      // Tree: / -> @sidebar/[dynamicParam]\n+      // At depth 0, should extract 'some' from pathname '/some/path'\n+      const loaderTree = createLoaderTree('', {\n+        sidebar: createLoaderTree('[dynamicParam]'),\n+      })\n+      const params: Params = {}\n+      const route = parseAppRoute('/some/path', true)\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveRouteParamsFromTree(loaderTree, params, route, fallbackRouteParams)\n+\n+      expect(params.dynamicParam).toBe('some')\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+\n+    it('should handle multiple dynamic params in parallel routes at same depth', () => {\n+      // Tree: / -> @modal/[id] + @sidebar/[category]\n+      // Both at depth 0, so both extract 'photo' from pathname '/photo/123'\n+      const loaderTree = createLoaderTree('', {\n+        modal: createLoaderTree('[id]'),\n+        sidebar: createLoaderTree('[category]'),\n+      })\n+      const params: Params = {}\n+      const route = parseAppRoute('/photo/123', true)\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveRouteParamsFromTree(loaderTree, params, route, fallbackRouteParams)\n+\n+      // Both should extract the first segment 'photo'\n+      expect(params.id).toBe('photo')\n+      expect(params.category).toBe('photo')\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+\n+    it('should extract dynamic param from pathname at depth 0', () => {\n+      // Tree: / -> @sidebar/[category]\n+      const loaderTree = createLoaderTree('', {\n+        sidebar: createLoaderTree('[category]'),\n+      })\n+      const params: Params = {}\n+      const route = parseAppRoute('/tech', true)\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveRouteParamsFromTree(loaderTree, params, route, fallbackRouteParams)\n+\n+      expect(params.category).toBe('tech')\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+\n+    it('should extract dynamic param from pathname at nested depth', () => {\n+      // Tree: /blog -> @sidebar/[category]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('blog', {\n+          sidebar: createLoaderTree('[category]'),\n+        })\n+      )\n+      const params: Params = {}\n+      const route = parseAppRoute('/blog/tech', true)\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveRouteParamsFromTree(loaderTree, params, route, fallbackRouteParams)\n+\n+      expect(params.category).toBe('tech')\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+\n+    it('should extract dynamic param even when other unknown params exist at different depths', () => {\n+      // Tree: / -> @sidebar/[category]\n+      // Even though there's an unknown 'slug' param somewhere else, if the segment\n+      // at this depth is known, we can extract it\n+      const loaderTree = createLoaderTree('', {\n+        sidebar: createLoaderTree('[category]'),\n+      })\n+      const params: Params = {}\n+      const route = parseAppRoute('/tech', true)\n+      const fallbackRouteParams: FallbackRouteParam[] = [\n+        { paramName: 'slug', paramType: 'dynamic' },\n+      ]\n+\n+      resolveRouteParamsFromTree(loaderTree, params, route, fallbackRouteParams)\n+\n+      // Should extract 'tech' because pathSegments[0] is known, regardless of slug\n+      expect(params.category).toBe('tech')\n+      expect(fallbackRouteParams).toHaveLength(1) // Still just slug\n+    })\n+\n+    it('should mark dynamic param as fallback when depth exceeds pathname length', () => {\n+      // Tree: /blog/posts -> @sidebar/[category]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          'blog',\n+          {},\n+          createLoaderTree('posts', {\n+            sidebar: createLoaderTree('[category]'),\n+          })\n+        )\n+      )\n+      const params: Params = {}\n+      const route = parseAppRoute('/blog', true)\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveRouteParamsFromTree(loaderTree, params, route, fallbackRouteParams)\n+\n+      expect(params.category).toBeUndefined()\n+      expect(fallbackRouteParams).toHaveLength(1)\n+      expect(fallbackRouteParams[0]).toEqual({\n+        paramName: 'category',\n+        paramType: 'dynamic',\n+      })\n+    })\n+\n+    it('should resolve embedded params when extracting dynamic param value', () => {\n+      // Tree: /[lang] -> @sidebar/[category]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('[lang]', {\n+          sidebar: createLoaderTree('[category]'),\n+        })\n+      )\n+      const params: Params = { lang: 'en' }\n+      const route = parseAppRoute('/en/tech', true)\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveRouteParamsFromTree(loaderTree, params, route, fallbackRouteParams)\n+\n+      expect(params.category).toBe('tech')\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+\n+    it('should extract dynamic param when unknown params exist at LATER depth', () => {\n+      // Tree: /[lang] -> @sidebar/[filter] (at depth 1)\n+      //       /[lang]/products/[category] (category at depth 2 is unknown)\n+      // @sidebar/[filter] is at depth 1, should extract 'products'\n+      // [category] at depth 2 is unknown, but shouldn't affect depth 1 resolution\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          '[lang]',\n+          {\n+            sidebar: createLoaderTree('[filter]'),\n+          },\n+          createLoaderTree('products', {}, createLoaderTree('[category]'))\n+        )\n+      )\n+      const params: Params = { lang: 'en' }\n+      const route = parseAppRoute('/en/products/[category]', true)\n+      const fallbackRouteParams: FallbackRouteParam[] = [\n+        { paramName: 'category', paramType: 'dynamic' },\n+      ]\n+\n+      resolveRouteParamsFromTree(loaderTree, params, route, fallbackRouteParams)\n+\n+      // Should extract 'products' at depth 1, even though category at depth 2 is unknown\n+      expect(params.filter).toBe('products')\n+      expect(fallbackRouteParams).toHaveLength(1) // Still just category\n+    })\n+\n+    it('should NOT extract dynamic param when placeholder is at SAME depth', () => {\n+      // Tree: /[lang]/products/[category] -> @sidebar/[filter]\n+      // @sidebar/[filter] is at depth 2\n+      // [category] at depth 2 is also unknown - same depth!\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          '[lang]',\n+          {},\n+          createLoaderTree(\n+            'products',\n+            {},\n+            createLoaderTree('[category]', {\n+              sidebar: createLoaderTree('[filter]'),\n+            })\n+          )\n+        )\n+      )\n+      const params: Params = { lang: 'en' }\n+      const route = parseAppRoute('/en/products/[category]', true)\n+      const fallbackRouteParams: FallbackRouteParam[] = [\n+        { paramName: 'category', paramType: 'dynamic' },\n+      ]\n+\n+      resolveRouteParamsFromTree(loaderTree, params, route, fallbackRouteParams)\n+\n+      // Should NOT extract because pathSegments[2] = '[category]' is a placeholder\n+      expect(params.filter).toBeUndefined()\n+      expect(fallbackRouteParams).toHaveLength(2)\n+      expect(fallbackRouteParams[1]).toEqual({\n+        paramName: 'filter',\n+        paramType: 'dynamic',\n+      })\n+    })\n+  })\n+\n+  describe('catchall deriving from pathname with depth', () => {\n+    it('should use depth to correctly slice pathname segments', () => {\n+      // Tree: /blog -> @sidebar/[...catchallParam]\n+      // At depth 1 (after /blog), should get remaining segments\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('blog', {\n+          sidebar: createLoaderTree('[...catchallParam]'),\n+        })\n+      )\n+      const params: Params = {}\n+      const route = parseAppRoute('/blog/2023/posts/my-article', true)\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveRouteParamsFromTree(loaderTree, params, route, fallbackRouteParams)\n+\n+      // Should get segments from depth 1 onwards\n+      expect(params.catchallParam).toEqual(['2023', 'posts', 'my-article'])\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+\n+    it('should handle catchall at depth 0 (root level)', () => {\n+      // Tree: / -> @sidebar/[...catchallParam]\n+      const loaderTree = createLoaderTree('', {\n+        sidebar: createLoaderTree('[...catchallParam]'),\n+      })\n+      const params: Params = {}\n+      const route = parseAppRoute('/blog/2023/posts', true)\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveRouteParamsFromTree(loaderTree, params, route, fallbackRouteParams)\n+\n+      // Should get all segments\n+      expect(params.catchallParam).toEqual(['blog', '2023', 'posts'])\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+\n+    it('should handle nested depth correctly', () => {\n+      // Tree: /products/[category] -> @filters/[...filterPath]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          'products',\n+          {},\n+          createLoaderTree('[category]', {\n+            filters: createLoaderTree('[...filterPath]'),\n+          })\n+        )\n+      )\n+      const params: Params = { category: 'electronics' }\n+      const route = parseAppRoute('/products/electronics/phones/iphone', true)\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveRouteParamsFromTree(loaderTree, params, route, fallbackRouteParams)\n+\n+      // Should get segments from depth 2 onwards (after /products/[category])\n+      expect(params.filterPath).toEqual(['phones', 'iphone'])\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+\n+    it('should handle single path segment', () => {\n+      // Tree: / -> @sidebar/[...catchallParam]\n+      const loaderTree = createLoaderTree('', {\n+        sidebar: createLoaderTree('[...catchallParam]'),\n+      })\n+      const params: Params = {}\n+      const route = parseAppRoute('/single', true)\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveRouteParamsFromTree(loaderTree, params, route, fallbackRouteParams)\n+\n+      expect(params.catchallParam).toEqual(['single'])\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+  })\n+\n+  describe('route groups', () => {\n+    it('should not increment depth for route groups', () => {\n+      // Tree: /(marketing) -> @sidebar/[...catchallParam]\n+      // Route groups don't contribute to pathname depth\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('(marketing)', {\n+          sidebar: createLoaderTree('[...catchallParam]'),\n+        })\n+      )\n+      const params: Params = {}\n+      const route = parseAppRoute('/blog/post', true)\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveRouteParamsFromTree(loaderTree, params, route, fallbackRouteParams)\n+\n+      // Should get all segments since route group doesn't increment depth\n+      expect(params.catchallParam).toEqual(['blog', 'post'])\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+\n+    it('should handle multiple route groups', () => {\n+      // Tree: /(group1)/(group2)/blog -> @sidebar/[...path]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          '(group1)',\n+          {},\n+          createLoaderTree(\n+            '(group2)',\n+            {},\n+            createLoaderTree('blog', {\n+              sidebar: createLoaderTree('[...path]'),\n+            })\n+          )\n+        )\n+      )\n+      const params: Params = {}\n+      const route = parseAppRoute('/blog/2023/posts', true)\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveRouteParamsFromTree(loaderTree, params, route, fallbackRouteParams)\n+\n+      // Should get segments from depth 1 (after /blog), route groups don't count\n+      expect(params.path).toEqual(['2023', 'posts'])\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+  })\n+\n+  describe('optional-catchall with empty pathname', () => {\n+    it('should set params to empty array when pathname has no segments', () => {\n+      // Tree: / -> @sidebar/[[...optionalCatchall]]\n+      const loaderTree = createLoaderTree('', {\n+        sidebar: createLoaderTree('[[...optionalCatchall]]'),\n+      })\n+      const params: Params = {}\n+      const route = parseAppRoute('/', true)\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveRouteParamsFromTree(loaderTree, params, route, fallbackRouteParams)\n+\n+      expect(params.optionalCatchall).toBeUndefined()\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+\n+    it('should handle optional catchall at nested depth with no remaining segments', () => {\n+      // Tree: /blog -> @sidebar/[[...optionalPath]]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('blog', {\n+          sidebar: createLoaderTree('[[...optionalPath]]'),\n+        })\n+      )\n+      const params: Params = {}\n+      const route = parseAppRoute('/blog', true)\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveRouteParamsFromTree(loaderTree, params, route, fallbackRouteParams)\n+\n+      expect(params.optionalPath).toBeUndefined()\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+  })\n+\n+  describe('optional-catchall with non-empty pathname', () => {\n+    it('should populate params with path segments', () => {\n+      // Tree: / -> @sidebar/[[...optionalCatchall]]\n+      const loaderTree = createLoaderTree('', {\n+        sidebar: createLoaderTree('[[...optionalCatchall]]'),\n+      })\n+      const params: Params = {}\n+      const route = parseAppRoute('/api/v1/users', true)\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveRouteParamsFromTree(loaderTree, params, route, fallbackRouteParams)\n+\n+      expect(params.optionalCatchall).toEqual(['api', 'v1', 'users'])\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+  })\n+\n+  describe('catchall-intercepted params', () => {\n+    it('should handle catchall-intercepted params in parallel routes', () => {\n+      // Tree: / -> @modal/[...path]  where [...path] uses catchall-intercepted type\n+      // Note: catchall-intercepted is a param type, not related to interception routes\n+      const loaderTree = createLoaderTree('', {\n+        modal: createLoaderTree('[...path]'),\n+      })\n+      const params: Params = {}\n+      const route = parseAppRoute('/photos/album/2023', true)\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveRouteParamsFromTree(loaderTree, params, route, fallbackRouteParams)\n+\n+      // Should get all segments\n+      expect(params.path).toEqual(['photos', 'album', '2023'])\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+  })\n+\n+  describe('error cases', () => {\n+    it('should throw error for catchall with empty pathname', () => {\n+      // Tree: / -> @sidebar/[...catchallParam]\n+      const loaderTree = createLoaderTree('', {\n+        sidebar: createLoaderTree('[...catchallParam]'),\n+      })\n+      const params: Params = {}\n+      const route = parseAppRoute('/', true)\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      expect(() =>\n+        resolveRouteParamsFromTree(\n+          loaderTree,\n+          params,\n+          route,\n+          fallbackRouteParams\n+        )\n+      ).toThrow(/Unexpected empty path segments/)\n+    })\n+\n+    it('should throw error for catchall when depth exceeds pathname', () => {\n+      // Tree: /blog/posts -> @sidebar/[...catchallParam]\n+      // But pathname is just /blog\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          'blog',\n+          {},\n+          createLoaderTree('posts', {\n+            sidebar: createLoaderTree('[...catchallParam]'),\n+          })\n+        )\n+      )\n+      const params: Params = {}\n+      const route = parseAppRoute('/blog', true)\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      expect(() =>\n+        resolveRouteParamsFromTree(\n+          loaderTree,\n+          params,\n+          route,\n+          fallbackRouteParams\n+        )\n+      ).toThrow(/Unexpected empty path segments/)\n+    })\n+  })\n+\n+  describe('complex scenarios', () => {\n+    it('should handle multiple parallel routes at same level', () => {\n+      // Tree: / -> @sidebar/[...sidebarPath] + @modal/[[...modalPath]]\n+      const loaderTree = createLoaderTree('', {\n+        sidebar: createLoaderTree('[...sidebarPath]'),\n+        modal: createLoaderTree('[[...modalPath]]'),\n+      })\n+      const params: Params = {}\n+      const route = parseAppRoute('/products/electronics', true)\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveRouteParamsFromTree(loaderTree, params, route, fallbackRouteParams)\n+\n+      expect(params.sidebarPath).toEqual(['products', 'electronics'])\n+      expect(params.modalPath).toEqual(['products', 'electronics'])\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+\n+    it('should handle parallel route with embedded dynamic param from pathname', () => {\n+      // Tree: /[lang] -> @sidebar/[...path]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('[lang]', {\n+          sidebar: createLoaderTree('[...path]'),\n+        })\n+      )\n+      const params: Params = { lang: 'en' }\n+      const route = parseAppRoute('/en/blog/post', true)\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveRouteParamsFromTree(loaderTree, params, route, fallbackRouteParams)\n+\n+      // Should resolve [lang] in path segments to 'en'\n+      expect(params.path).toEqual(['blog', 'post'])\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+\n+    it('should only process parallel routes, not children route', () => {\n+      // Tree: / -> children: /blog, sidebar: /[...path]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {\n+          sidebar: createLoaderTree('[...path]'),\n+        },\n+        createLoaderTree('blog')\n+      )\n+      const params: Params = {}\n+      const route = parseAppRoute('/blog/post', true)\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveRouteParamsFromTree(loaderTree, params, route, fallbackRouteParams)\n+\n+      // Should only process @sidebar, not children\n+      expect(params.path).toEqual(['blog', 'post'])\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+  })\n+\n+  describe('interception routes', () => {\n+    it('should increment depth for (.) interception route (same level)', () => {\n+      // Tree: /(.)photo -> @modal/[...segments]\n+      // Interception routes should increment depth unlike route groups\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('(.)photo', {\n+          modal: createLoaderTree('[...segments]'),\n+        })\n+      )\n+      const params: Params = {}\n+      const route = parseAppRoute('/photo/123/details', true)\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveRouteParamsFromTree(loaderTree, params, route, fallbackRouteParams)\n+\n+      // Should get segments from depth 1 onwards (after /(.)photo)\n+      expect(params.segments).toEqual(['123', 'details'])\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+\n+    it('should increment depth for (..) interception route (parent level)', () => {\n+      // Tree: /gallery/(..)photo -> @modal/[id]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          'gallery',\n+          {},\n+          createLoaderTree('(..)photo', {\n+            modal: createLoaderTree('[id]'),\n+          })\n+        )\n+      )\n+      const params: Params = {}\n+      const route = parseAppRoute('/gallery/photo/123', true)\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveRouteParamsFromTree(loaderTree, params, route, fallbackRouteParams)\n+\n+      // (..)photo is at depth 1, @modal/[id] should extract from depth 2\n+      expect(params.id).toBe('123')\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+\n+    it('should increment depth for (...) interception route (root level)', () => {\n+      // Tree: /app/gallery/(...)photo -> @modal/[...path]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          'app',\n+          {},\n+          createLoaderTree(\n+            'gallery',\n+            {},\n+            createLoaderTree('(...)photo', {\n+              modal: createLoaderTree('[...path]'),\n+            })\n+          )\n+        )\n+      )\n+      const params: Params = {}\n+      const route = parseAppRoute('/app/gallery/photo/2023/album', true)\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveRouteParamsFromTree(loaderTree, params, route, fallbackRouteParams)\n+\n+      // (...)photo is at depth 2, @modal/[...path] should extract from depth 3\n+      expect(params.path).toEqual(['2023', 'album'])\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+\n+    it('should increment depth for (..)(..) interception route (grandparent level)', () => {\n+      // Tree: /a/b/(..)(..)photo -> @modal/[category]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          'a',\n+          {},\n+          createLoaderTree(\n+            'b',\n+            {},\n+            createLoaderTree('(..)(..)photo', {\n+              modal: createLoaderTree('[category]'),\n+            })\n+          )\n+        )\n+      )\n+      const params: Params = {}\n+      const route = parseAppRoute('/a/b/photo/nature', true)\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveRouteParamsFromTree(loaderTree, params, route, fallbackRouteParams)\n+\n+      // (..)(..)photo is at depth 2, @modal/[category] should extract from depth 3\n+      expect(params.category).toBe('nature')\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+\n+    it('should distinguish interception routes from regular route groups', () => {\n+      // Tree: /(marketing) -> @sidebar/[...path] (route group)\n+      //   vs: /(.)photo -> @modal/[...path] (interception route)\n+      const routeGroupTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('(marketing)', {\n+          sidebar: createLoaderTree('[...path]'),\n+        })\n+      )\n+\n+      const interceptionTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('(.)photo', {\n+          modal: createLoaderTree('[...path]'),\n+        })\n+      )\n+\n+      const route = parseAppRoute('/photo/123', true)\n+\n+      // Route group - should NOT increment depth\n+      const routeGroupParams: Params = {}\n+      const routeGroupFallback: FallbackRouteParam[] = []\n+      resolveRouteParamsFromTree(\n+        routeGroupTree,\n+        routeGroupParams,\n+        route,\n+        routeGroupFallback\n+      )\n+      // Gets all segments because route group doesn't increment depth\n+      expect(routeGroupParams.path).toEqual(['photo', '123'])\n+\n+      // Interception route - SHOULD increment depth\n+      const interceptionParams: Params = {}\n+      const interceptionFallback: FallbackRouteParam[] = []\n+      resolveRouteParamsFromTree(\n+        interceptionTree,\n+        interceptionParams,\n+        route,\n+        interceptionFallback\n+      )\n+      // Gets segments from depth 1 because (.)photo increments depth\n+      expect(interceptionParams.path).toEqual(['123'])\n+    })\n+  })\n+\n+  describe('empty pathname edge cases', () => {\n+    it('should mark dynamic param as fallback when pathname is empty', () => {\n+      // Tree: / -> @modal/[id]\n+      const loaderTree = createLoaderTree('', {\n+        modal: createLoaderTree('[id]'),\n+      })\n+      const params: Params = {}\n+      const route = parseAppRoute('/', true)\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveRouteParamsFromTree(loaderTree, params, route, fallbackRouteParams)\n+\n+      expect(params.id).toBeUndefined()\n+      expect(fallbackRouteParams).toHaveLength(1)\n+      expect(fallbackRouteParams[0]).toEqual({\n+        paramName: 'id',\n+        paramType: 'dynamic',\n+      })\n+    })\n+\n+    it('should mark multiple dynamic params as fallback when pathname is empty', () => {\n+      // Tree: / -> @modal/[category] + @sidebar/[filter]\n+      const loaderTree = createLoaderTree('', {\n+        modal: createLoaderTree('[category]'),\n+        sidebar: createLoaderTree('[filter]'),\n+      })\n+      const params: Params = {}\n+      const route = parseAppRoute('/', true)\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveRouteParamsFromTree(loaderTree, params, route, fallbackRouteParams)\n+\n+      expect(params.category).toBeUndefined()\n+      expect(params.filter).toBeUndefined()\n+      expect(fallbackRouteParams).toHaveLength(2)\n+      expect(fallbackRouteParams).toContainEqual({\n+        paramName: 'category',\n+        paramType: 'dynamic',\n+      })\n+      expect(fallbackRouteParams).toContainEqual({\n+        paramName: 'filter',\n+        paramType: 'dynamic',\n+      })\n+    })\n+\n+    it('should handle nested parallel route with empty pathname at that depth', () => {\n+      // Tree: /blog -> @modal/[id]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('blog', {\n+          modal: createLoaderTree('[id]'),\n+        })\n+      )\n+      const params: Params = {}\n+      const route = parseAppRoute('/blog', true)\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveRouteParamsFromTree(loaderTree, params, route, fallbackRouteParams)\n+\n+      // No segment at depth 1, should mark as fallback\n+      expect(params.id).toBeUndefined()\n+      expect(fallbackRouteParams).toHaveLength(1)\n+      expect(fallbackRouteParams[0]).toEqual({\n+        paramName: 'id',\n+        paramType: 'dynamic',\n+      })\n+    })\n+  })\n+\n+  describe('complex path segments', () => {\n+    it('should handle catch-all with embedded param placeholders in pathname', () => {\n+      // Tree: / -> @sidebar/[...path]\n+      // Pathname contains a placeholder like [category] which is unknown\n+      const loaderTree = createLoaderTree('', {\n+        sidebar: createLoaderTree('[...path]'),\n+      })\n+      const params: Params = {}\n+      const route = parseAppRoute('/blog/[category]/tech', true)\n+      const fallbackRouteParams: FallbackRouteParam[] = [\n+        { paramName: 'category', paramType: 'dynamic' },\n+      ]\n+\n+      resolveRouteParamsFromTree(loaderTree, params, route, fallbackRouteParams)\n+\n+      // Should mark as fallback because there's a non-parallel fallback param\n+      expect(params.path).toBeUndefined()\n+      expect(fallbackRouteParams).toHaveLength(2)\n+      expect(fallbackRouteParams[1]).toEqual({\n+        paramName: 'path',\n+        paramType: 'catchall',\n+      })\n+    })\n+\n+    it('should mark catch-all as fallback when pathname has unknown param placeholder', () => {\n+      // Tree: /[lang] -> @sidebar/[...path]\n+      // Pathname has [lang] which is known, but [category] which is not\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('[lang]', {\n+          sidebar: createLoaderTree('[...path]'),\n+        })\n+      )\n+      const params: Params = { lang: 'en' }\n+      const route = parseAppRoute('/en/blog/[category]', true)\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveRouteParamsFromTree(loaderTree, params, route, fallbackRouteParams)\n+\n+      // Should mark path as fallback because pathname contains unknown [category] placeholder\n+      expect(params.path).toBeUndefined()\n+      expect(fallbackRouteParams).toHaveLength(1)\n+      expect(fallbackRouteParams[0]).toEqual({\n+        paramName: 'path',\n+        paramType: 'catchall',\n+      })\n+    })\n+\n+    it('should handle mixed static and dynamic segments in catch-all resolution', () => {\n+      // Tree: /products/[category] -> @filters/[...filterPath]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          'products',\n+          {},\n+          createLoaderTree('[category]', {\n+            filters: createLoaderTree('[...filterPath]'),\n+          })\n+        )\n+      )\n+      const params: Params = { category: 'electronics' }\n+      const route = parseAppRoute(\n+        '/products/electronics/brand/apple/price/high',\n+        true\n+      )\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveRouteParamsFromTree(loaderTree, params, route, fallbackRouteParams)\n+\n+      // Should get remaining path after resolving category\n+      expect(params.filterPath).toEqual(['brand', 'apple', 'price', 'high'])\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+  })\n+\n+  describe('integration scenarios', () => {\n+    it('should handle interception route + parallel route together', () => {\n+      // Tree: /gallery/(.)photo -> @modal/[id] + @sidebar/[category]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          'gallery',\n+          {},\n+          createLoaderTree('(.)photo', {\n+            modal: createLoaderTree('[id]'),\n+            sidebar: createLoaderTree('[category]'),\n+          })\n+        )\n+      )\n+      const params: Params = {}\n+      const route = parseAppRoute('/gallery/photo/123', true)\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveRouteParamsFromTree(loaderTree, params, route, fallbackRouteParams)\n+\n+      // Both should extract from depth 2 (after /gallery/(.)photo)\n+      expect(params.id).toBe('123')\n+      expect(params.category).toBe('123')\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+\n+    it('should handle route group + parallel route + interception route', () => {\n+      // Tree: /(marketing)/gallery/(.)photo -> @modal/[...path]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          '(marketing)',\n+          {},\n+          createLoaderTree(\n+            'gallery',\n+            {},\n+            createLoaderTree('(.)photo', {\n+              modal: createLoaderTree('[...path]'),\n+            })\n+          )\n+        )\n+      )\n+      const params: Params = {}\n+      const route = parseAppRoute('/gallery/photo/2023/album', true)\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveRouteParamsFromTree(loaderTree, params, route, fallbackRouteParams)\n+\n+      // Route group doesn't increment, gallery does, (.)photo does\n+      // So depth is 2, extract from depth 2 onwards\n+      expect(params.path).toEqual(['2023', 'album'])\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+\n+    it('should handle all param types together', () => {\n+      // Tree: /[lang] -> @modal/[category] + @sidebar/[...tags] + @info/[[...extra]]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('[lang]', {\n+          modal: createLoaderTree('[category]'),\n+          sidebar: createLoaderTree('[...tags]'),\n+          info: createLoaderTree('[[...extra]]'),\n+        })\n+      )\n+      const params: Params = { lang: 'en' }\n+      const route = parseAppRoute('/en/tech/react/nextjs', true)\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveRouteParamsFromTree(loaderTree, params, route, fallbackRouteParams)\n+\n+      // All should extract from depth 1 onwards\n+      expect(params.category).toBe('tech')\n+      expect(params.tags).toEqual(['tech', 'react', 'nextjs'])\n+      expect(params.extra).toEqual(['tech', 'react', 'nextjs'])\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+\n+    it('should handle complex nesting with multiple interception routes', () => {\n+      // Tree: /app/(.)modal/(.)photo -> @dialog/[id]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          'app',\n+          {},\n+          createLoaderTree(\n+            '(.)modal',\n+            {},\n+            createLoaderTree('(.)photo', {\n+              dialog: createLoaderTree('[id]'),\n+            })\n+          )\n+        )\n+      )\n+      const params: Params = {}\n+      const route = parseAppRoute('/app/modal/photo/image-123', true)\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveRouteParamsFromTree(loaderTree, params, route, fallbackRouteParams)\n+\n+      // app (depth 1) + (.)modal (depth 2) + (.)photo (depth 3) -> extract at depth 3\n+      expect(params.id).toBe('image-123')\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+  })\n+})"
        },
        {
            "sha": "c52b65c69a761294a363c33c62e27c9d1476dee9",
            "filename": "packages/next/src/build/static-paths/utils.ts",
            "status": "modified",
            "additions": 151,
            "deletions": 11,
            "changes": 162,
            "blob_url": "https://github.com/vercel/next.js/blob/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Futils.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Futils.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Futils.ts?ref=d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd",
            "patch": "@@ -1,4 +1,17 @@\n+import type { LoaderTree } from '../../server/lib/app-dir-module'\n+import type { Params } from '../../server/request/params'\n+import type { AppPageRouteModule } from '../../server/route-modules/app-page/module.compiled'\n+import type { AppRouteRouteModule } from '../../server/route-modules/app-route/module.compiled'\n+import { isAppPageRouteModule } from '../../server/route-modules/checks'\n import type { DynamicParamTypes } from '../../shared/lib/app-router-types'\n+import {\n+  parseAppRouteSegment,\n+  type NormalizedAppRoute,\n+} from '../../shared/lib/router/routes/app'\n+import { parseLoaderTree } from '../../shared/lib/router/utils/parse-loader-tree'\n+import type { AppSegment } from '../segment-config/app/app-segments'\n+import { extractPathnameRouteParamSegmentsFromLoaderTree } from './app/extract-pathname-route-param-segments-from-loader-tree'\n+import { resolveParamValue } from '../../shared/lib/router/utils/resolve-param-value'\n import type { FallbackRouteParam } from './types'\n \n /**\n@@ -33,17 +46,144 @@ export function normalizePathname(pathname: string) {\n }\n \n /**\n- * Creates a fallback route param.\n+ * Extracts segments that contribute to the pathname by traversing the loader tree\n+ * based on the route module type.\n  *\n- * @param paramName - The name of the param.\n- * @param isParallelRouteParam - Whether this is a parallel route param or\n- * descends from a parallel route param.\n- * @returns The fallback route param.\n+ * @param routeModule - The app route module (page or route handler)\n+ * @param segments - Array of AppSegment objects collected from the route\n+ * @param page - The target pathname to match against, INCLUDING interception\n+ *               markers (e.g., \"/blog/[slug]\", \"/(.)photo/[id]\")\n+ * @returns Array of segments with param info that contribute to the pathname\n  */\n-export function createFallbackRouteParam(\n-  paramName: string,\n-  paramType: DynamicParamTypes,\n-  isParallelRouteParam: boolean\n-): FallbackRouteParam {\n-  return { paramName, paramType, isParallelRouteParam }\n+export function extractPathnameRouteParamSegments(\n+  routeModule: AppRouteRouteModule | AppPageRouteModule,\n+  segments: readonly Readonly<AppSegment>[],\n+  route: NormalizedAppRoute\n+): Array<{\n+  readonly name: string\n+  readonly paramName: string\n+  readonly paramType: DynamicParamTypes\n+}> {\n+  // For AppPageRouteModule, use the loaderTree traversal approach\n+  if (isAppPageRouteModule(routeModule)) {\n+    const { pathnameRouteParamSegments } =\n+      extractPathnameRouteParamSegmentsFromLoaderTree(\n+        routeModule.userland.loaderTree,\n+        route\n+      )\n+    return pathnameRouteParamSegments\n+  }\n+\n+  return extractPathnameRouteParamSegmentsFromSegments(segments)\n+}\n+\n+export function extractPathnameRouteParamSegmentsFromSegments(\n+  segments: readonly Readonly<AppSegment>[]\n+): Array<{\n+  readonly name: string\n+  readonly paramName: string\n+  readonly paramType: DynamicParamTypes\n+}> {\n+  // TODO: should we consider what values are already present in the page?\n+\n+  // For AppRouteRouteModule, filter the segments array to get the route params\n+  // that contribute to the pathname.\n+  const result: Array<{\n+    readonly name: string\n+    readonly paramName: string\n+    readonly paramType: DynamicParamTypes\n+  }> = []\n+\n+  for (const segment of segments) {\n+    // Skip segments without param info.\n+    if (!segment.paramName || !segment.paramType) continue\n+\n+    // Collect all the route param keys that contribute to the pathname.\n+    result.push({\n+      name: segment.name,\n+      paramName: segment.paramName,\n+      paramType: segment.paramType,\n+    })\n+  }\n+\n+  return result\n+}\n+\n+/**\n+ * Resolves all route parameters from the loader tree. This function uses\n+ * tree-based traversal to correctly handle the hierarchical structure of routes\n+ * and accurately determine parameter values based on their depth in the tree.\n+ *\n+ * This processes both regular route parameters (from the main children route) and\n+ * parallel route parameters (from slots like @modal, @sidebar).\n+ *\n+ * Unlike interpolateParallelRouteParams (which has a complete URL at runtime),\n+ * this build-time function determines which route params are unknown.\n+ * The pathname may contain placeholders like [slug], making it incomplete.\n+ *\n+ * @param loaderTree - The loader tree structure containing route hierarchy\n+ * @param params - The current route parameters object (will be mutated)\n+ * @param route - The current route being processed\n+ * @param fallbackRouteParams - Array of fallback route parameters (will be mutated)\n+ */\n+export function resolveRouteParamsFromTree(\n+  loaderTree: LoaderTree,\n+  params: Params,\n+  route: NormalizedAppRoute,\n+  fallbackRouteParams: FallbackRouteParam[]\n+): void {\n+  // Stack-based traversal with depth tracking\n+  const stack: Array<{\n+    tree: LoaderTree\n+    depth: number\n+  }> = [{ tree: loaderTree, depth: 0 }]\n+\n+  while (stack.length > 0) {\n+    const { tree, depth } = stack.pop()!\n+    const { segment, parallelRoutes } = parseLoaderTree(tree)\n+\n+    const appSegment = parseAppRouteSegment(segment)\n+\n+    // If this segment is a route parameter, then we should process it if it's\n+    // not already known and is not already marked as a fallback route param.\n+    if (\n+      appSegment?.type === 'dynamic' &&\n+      !params.hasOwnProperty(appSegment.param.paramName) &&\n+      !fallbackRouteParams.some(\n+        (param) => param.paramName === appSegment.param.paramName\n+      )\n+    ) {\n+      const { paramName, paramType } = appSegment.param\n+\n+      const paramValue = resolveParamValue(\n+        paramName,\n+        paramType,\n+        depth,\n+        route,\n+        params\n+      )\n+\n+      if (paramValue !== undefined) {\n+        params[paramName] = paramValue\n+      } else if (paramType !== 'optional-catchall') {\n+        // If we couldn't resolve the param, mark it as a fallback\n+        fallbackRouteParams.push({ paramName, paramType })\n+      }\n+    }\n+\n+    // Calculate next depth - increment if this is not a route group and not empty\n+    let nextDepth = depth\n+    if (\n+      appSegment &&\n+      appSegment.type !== 'route-group' &&\n+      appSegment.type !== 'parallel-route'\n+    ) {\n+      nextDepth++\n+    }\n+\n+    // Add all parallel routes to the stack for processing.\n+    for (const parallelRoute of Object.values(parallelRoutes)) {\n+      stack.push({ tree: parallelRoute, depth: nextDepth })\n+    }\n+  }\n }"
        },
        {
            "sha": "a889669b34f7ac1ddbb915f03447168068485acb",
            "filename": "packages/next/src/build/utils.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fbuild%2Futils.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fbuild%2Futils.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Futils.ts?ref=d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd",
            "patch": "@@ -78,6 +78,7 @@ import { formatIssue, isRelevantWarning } from '../shared/lib/turbopack/utils'\n import type { TurbopackResult } from './swc/types'\n import type { FunctionsConfigManifest, ManifestRoute } from './index'\n import { getNamedRouteRegex } from '../shared/lib/router/utils/route-regex'\n+import { parseAppRoute } from '../shared/lib/router/routes/app'\n \n export type ROUTER_TYPE = 'pages' | 'app'\n \n@@ -870,14 +871,17 @@ export async function isPageStatic({\n           appConfig.revalidate = 0\n         }\n \n+        const route = parseAppRoute(page, true)\n+\n         // If the page is dynamic and we're not in edge runtime, then we need to\n         // build the static paths. The edge runtime doesn't support static\n         // paths.\n-        if (isDynamicRoute(page) && !pathIsEdgeRuntime) {\n+        if (route.dynamicSegments.length > 0 && !pathIsEdgeRuntime) {\n           ;({ prerenderedRoutes, fallbackMode: prerenderFallbackMode } =\n             await buildAppStaticPaths({\n               dir,\n               page,\n+              route,\n               cacheComponents,\n               authInterrupts,\n               segments,"
        },
        {
            "sha": "17e0e371f487dd622a78d304282de914d7dbebcb",
            "filename": "packages/next/src/build/validate-app-paths.ts",
            "status": "modified",
            "additions": 21,
            "deletions": 21,
            "changes": 42,
            "blob_url": "https://github.com/vercel/next.js/blob/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fbuild%2Fvalidate-app-paths.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fbuild%2Fvalidate-app-paths.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fvalidate-app-paths.ts?ref=d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd",
            "patch": "@@ -15,39 +15,39 @@ import {\n  */\n function validateSegmentParam(param: SegmentParam, pathname: string): void {\n   // Check for empty parameter names\n-  if (param.param.length === 0) {\n+  if (param.paramName.length === 0) {\n     throw new Error(`Parameter names cannot be empty in route \"${pathname}\".`)\n   }\n \n   // Check for three-dot character (â€¦) instead of ...\n-  if (param.param.includes('â€¦')) {\n+  if (param.paramName.includes('â€¦')) {\n     throw new Error(\n-      `Detected a three-dot character ('â€¦') in parameter \"${param.param}\" in route \"${pathname}\". Did you mean ('...')?`\n+      `Detected a three-dot character ('â€¦') in parameter \"${param.paramName}\" in route \"${pathname}\". Did you mean ('...')?`\n     )\n   }\n \n   // Check for optional non-catch-all segments (not yet supported)\n   if (\n-    param.type !== 'optional-catchall' &&\n-    param.param.startsWith('[') &&\n-    param.param.endsWith(']')\n+    param.paramType !== 'optional-catchall' &&\n+    param.paramName.startsWith('[') &&\n+    param.paramName.endsWith(']')\n   ) {\n     throw new Error(\n-      `Optional route parameters are not yet supported (\"[${param.param}]\") in route \"${pathname}\".`\n+      `Optional route parameters are not yet supported (\"[${param.paramName}]\") in route \"${pathname}\".`\n     )\n   }\n \n   // Check for extra brackets\n-  if (param.param.startsWith('[') || param.param.endsWith(']')) {\n+  if (param.paramName.startsWith('[') || param.paramName.endsWith(']')) {\n     throw new Error(\n-      `Segment names may not start or end with extra brackets ('${param.param}') in route \"${pathname}\".`\n+      `Segment names may not start or end with extra brackets ('${param.paramName}') in route \"${pathname}\".`\n     )\n   }\n \n   // Check for erroneous periods\n-  if (param.param.startsWith('.')) {\n+  if (param.paramName.startsWith('.')) {\n     throw new Error(\n-      `Segment names may not start with erroneous periods ('${param.param}') in route \"${pathname}\".`\n+      `Segment names may not start with erroneous periods ('${param.paramName}') in route \"${pathname}\".`\n     )\n   }\n }\n@@ -82,7 +82,7 @@ function validateAppRoute(route: NormalizedAppRoute): void {\n       // First, validate syntax\n       validateSegmentParam(segment.param, route.pathname)\n \n-      const properties = getParamProperties(segment.param.type)\n+      const properties = getParamProperties(segment.param.paramType)\n \n       if (properties.repeat) {\n         if (properties.optional) {\n@@ -95,25 +95,25 @@ function validateAppRoute(route: NormalizedAppRoute): void {\n       }\n \n       // Check to see if the parameter name is already in use.\n-      if (slugNames.has(segment.param.param)) {\n+      if (slugNames.has(segment.param.paramName)) {\n         throw new Error(\n-          `You cannot have the same slug name \"${segment.param.param}\" repeat within a single dynamic path in route \"${route.pathname}\".`\n+          `You cannot have the same slug name \"${segment.param.paramName}\" repeat within a single dynamic path in route \"${route.pathname}\".`\n         )\n       }\n \n       // Normalize parameter name for comparison by removing all non-word\n       // characters.\n-      const normalizedSegment = segment.param.param.replace(/\\W/g, '')\n+      const normalizedSegment = segment.param.paramName.replace(/\\W/g, '')\n       if (normalizedSegments.has(normalizedSegment)) {\n         const existing = Array.from(slugNames).find((s) => {\n           return s.replace(/\\W/g, '') === normalizedSegment\n         })\n         throw new Error(\n-          `You cannot have the slug names \"${existing}\" and \"${segment.param.param}\" differ only by non-word symbols within a single dynamic path in route \"${route.pathname}\".`\n+          `You cannot have the slug names \"${existing}\" and \"${segment.param.paramName}\" differ only by non-word symbols within a single dynamic path in route \"${route.pathname}\".`\n         )\n       }\n \n-      slugNames.add(segment.param.param)\n+      slugNames.add(segment.param.paramName)\n       normalizedSegments.add(normalizedSegment)\n     }\n \n@@ -179,7 +179,7 @@ function normalizeSegments(\n         // Dynamic segment - normalize the parameter name by replacing the\n         // parameter name with a wildcard. The interception marker is already\n         // included in the segment name, so no special handling is needed.\n-        return segment.name.replace(segment.param.param, '*')\n+        return segment.name.replace(segment.param.paramName, '*')\n       })\n       .join('/')\n   )\n@@ -217,7 +217,7 @@ export function validateAppPaths(\n     const lastSegment = route.segments[route.segments.length - 1]\n     if (\n       lastSegment?.type === 'dynamic' &&\n-      lastSegment.param.type === 'optional-catchall'\n+      lastSegment.param.paramType === 'optional-catchall'\n     ) {\n       const prefixSegments = route.segments.slice(0, -1)\n       const normalizedPrefix = normalizeSegments(prefixSegments)\n@@ -229,14 +229,14 @@ export function validateAppPaths(\n         // /[[...slug]] has prefix '' which should match '/'\n         if (prefixSegments.length === 0 && appPath === '/') {\n           throw new Error(\n-            `You cannot define a route with the same specificity as an optional catch-all route (\"${appPath}\" and \"/[[...${lastSegment.param.param}]]\").`\n+            `You cannot define a route with the same specificity as an optional catch-all route (\"${appPath}\" and \"/[[...${lastSegment.param.paramName}]]\").`\n           )\n         }\n \n         // General case: compare normalized structures\n         if (normalizedAppPath === normalizedPrefix) {\n           throw new Error(\n-            `You cannot define a route with the same specificity as an optional catch-all route (\"${appPath}\" and \"${normalizedPrefix}/[[...${lastSegment.param.param}]]\").`\n+            `You cannot define a route with the same specificity as an optional catch-all route (\"${appPath}\" and \"${normalizedPrefix}/[[...${lastSegment.param.paramName}]]\").`\n           )\n         }\n       }"
        },
        {
            "sha": "cf89abe1077de7a34fa76821c9c3bdfc25ed6133",
            "filename": "packages/next/src/build/webpack/loaders/next-root-params-loader.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack%2Floaders%2Fnext-root-params-loader.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack%2Floaders%2Fnext-root-params-loader.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack%2Floaders%2Fnext-root-params-loader.ts?ref=d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd",
            "patch": "@@ -159,7 +159,7 @@ function getParamsFromLayoutFilePath({\n   for (const segment of segments) {\n     const param = getSegmentParam(segment)\n     if (param !== null) {\n-      paramNames.push(param.param)\n+      paramNames.push(param.paramName)\n     }\n   }\n   return paramNames"
        },
        {
            "sha": "d466eaa827c2da8842dbb1908da4c73c4a562866",
            "filename": "packages/next/src/server/app-render/app-render.tsx",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx?ref=d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd",
            "patch": "@@ -408,8 +408,8 @@ function makeGetDynamicParamFromSegment(\n     if (!segmentParam) {\n       return null\n     }\n-    const segmentKey = segmentParam.param\n-    const dynamicParamType = dynamicParamTypes[segmentParam.type]\n+    const segmentKey = segmentParam.paramName\n+    const dynamicParamType = dynamicParamTypes[segmentParam.paramType]\n     return getDynamicParam(\n       interpolatedParams,\n       segmentKey,"
        },
        {
            "sha": "b4edfb6b2d6ae81cdde3570e5253c0245361e521",
            "filename": "packages/next/src/server/app-render/walk-tree-with-flight-router-state.tsx",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwalk-tree-with-flight-router-state.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwalk-tree-with-flight-router-state.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwalk-tree-with-flight-router-state.tsx?ref=d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd",
            "patch": "@@ -307,5 +307,5 @@ const canSegmentBeOverridden = (\n     return false\n   }\n \n-  return getSegmentParam(existingSegment)?.param === segment[0]\n+  return getSegmentParam(existingSegment)?.paramName === segment[0]\n }"
        },
        {
            "sha": "f38663f675b9f1b28c5295f7f6a1fb4cbd9ffed3",
            "filename": "packages/next/src/server/dev/static-paths-worker.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fstatic-paths-worker.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fstatic-paths-worker.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fstatic-paths-worker.ts?ref=d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd",
            "patch": "@@ -20,6 +20,7 @@ import { buildPagesStaticPaths } from '../../build/static-paths/pages'\n import { createIncrementalCache } from '../../export/helpers/create-incremental-cache'\n import type { AppPageRouteModule } from '../route-modules/app-page/module'\n import type { AppRouteRouteModule } from '../route-modules/app-route/module'\n+import { parseAppRoute } from '../../shared/lib/router/routes/app'\n \n type RuntimeConfig = {\n   pprConfig: ExperimentalPPRConfig | undefined\n@@ -111,6 +112,13 @@ export async function loadStaticPaths({\n       routeModule as AppPageRouteModule | AppRouteRouteModule\n     )\n \n+    const route = parseAppRoute(pathname, true)\n+    if (route.dynamicSegments.length === 0) {\n+      throw new InvariantError(\n+        `Expected a dynamic route, but got a static route: ${pathname}`\n+      )\n+    }\n+\n     const isRoutePPREnabled =\n       isAppPageRouteModule(routeModule) &&\n       checkIsRoutePPREnabled(config.pprConfig)\n@@ -120,6 +128,7 @@ export async function loadStaticPaths({\n     return buildAppStaticPaths({\n       dir,\n       page: pathname,\n+      route,\n       cacheComponents: config.cacheComponents,\n       segments,\n       distDir,"
        },
        {
            "sha": "c16eb0f18ea2e0efda8d9e84917cd5d454d23db4",
            "filename": "packages/next/src/server/request/fallback-params.test.ts",
            "status": "modified",
            "additions": 557,
            "deletions": 3,
            "changes": 560,
            "blob_url": "https://github.com/vercel/next.js/blob/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Ffallback-params.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Ffallback-params.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Ffallback-params.test.ts?ref=d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd",
            "patch": "@@ -1,11 +1,43 @@\n-import { createOpaqueFallbackRouteParams } from './fallback-params'\n+import {\n+  createOpaqueFallbackRouteParams,\n+  getFallbackRouteParams,\n+} from './fallback-params'\n import type { FallbackRouteParam } from '../../build/static-paths/types'\n+import type AppPageRouteModule from '../route-modules/app-page/module'\n+import type { LoaderTree } from '../lib/app-dir-module'\n+\n+// Helper to create LoaderTree structures for testing\n+type TestLoaderTree = [\n+  segment: string,\n+  parallelRoutes: { [key: string]: TestLoaderTree },\n+  modules: Record<string, unknown>,\n+]\n+\n+function createLoaderTree(\n+  segment: string,\n+  parallelRoutes: { [key: string]: TestLoaderTree } = {},\n+  children?: TestLoaderTree\n+): TestLoaderTree {\n+  const routes = children ? { ...parallelRoutes, children } : parallelRoutes\n+  return [segment, routes, {}]\n+}\n+\n+/**\n+ * Creates a mock AppPageRouteModule for testing.\n+ */\n+function createMockRouteModule(loaderTree: LoaderTree): AppPageRouteModule {\n+  return {\n+    userland: {\n+      loaderTree,\n+    },\n+  } as AppPageRouteModule\n+}\n \n describe('createOpaqueFallbackRouteParams', () => {\n   describe('opaque object interface', () => {\n     const fallbackParams: readonly FallbackRouteParam[] = [\n-      { paramName: 'slug', paramType: 'dynamic', isParallelRouteParam: false },\n-      { paramName: 'modal', paramType: 'dynamic', isParallelRouteParam: true },\n+      { paramName: 'slug', paramType: 'dynamic' },\n+      { paramName: 'modal', paramType: 'dynamic' },\n     ]\n \n     it('has method works correctly', () => {\n@@ -38,3 +70,525 @@ describe('createOpaqueFallbackRouteParams', () => {\n     })\n   })\n })\n+\n+describe('getFallbackRouteParams', () => {\n+  describe('Regular Routes (children segments)', () => {\n+    it('should extract single dynamic segment from children route', () => {\n+      // Tree: /[slug]\n+      const loaderTree = createLoaderTree('', {}, createLoaderTree('[slug]'))\n+      const routeModule = createMockRouteModule(loaderTree)\n+      const result = getFallbackRouteParams('/[slug]', routeModule)\n+\n+      expect(result).not.toBeNull()\n+      expect(result!.has('slug')).toBe(true)\n+      expect(result!.get('slug')?.[1]).toBe('d') // 'd' = dynamic (short type)\n+    })\n+\n+    it('should extract multiple nested dynamic segments', () => {\n+      // Tree: /[category]/[slug]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('[category]', {}, createLoaderTree('[slug]'))\n+      )\n+      const routeModule = createMockRouteModule(loaderTree)\n+      const result = getFallbackRouteParams('/[category]/[slug]', routeModule)\n+\n+      expect(result).not.toBeNull()\n+      expect(result!.size).toBe(2)\n+      expect(result!.has('category')).toBe(true)\n+      expect(result!.has('slug')).toBe(true)\n+      expect(result!.get('category')?.[1]).toBe('d')\n+      expect(result!.get('slug')?.[1]).toBe('d')\n+    })\n+\n+    it('should extract catchall segment', () => {\n+      // Tree: /[...slug]\n+      const loaderTree = createLoaderTree('', {}, createLoaderTree('[...slug]'))\n+      const routeModule = createMockRouteModule(loaderTree)\n+      const result = getFallbackRouteParams('/[...slug]', routeModule)\n+\n+      expect(result).not.toBeNull()\n+      expect(result!.size).toBe(1)\n+      expect(result!.has('slug')).toBe(true)\n+      expect(result!.get('slug')?.[1]).toBe('c') // 'c' = catchall\n+    })\n+\n+    it('should extract optional catchall segment', () => {\n+      // Tree: /[[...slug]]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('[[...slug]]')\n+      )\n+      const routeModule = createMockRouteModule(loaderTree)\n+      const result = getFallbackRouteParams('/[[...slug]]', routeModule)\n+\n+      expect(result).not.toBeNull()\n+      expect(result!.size).toBe(1)\n+      expect(result!.has('slug')).toBe(true)\n+      expect(result!.get('slug')?.[1]).toBe('oc') // 'oc' = optional-catchall\n+    })\n+\n+    it('should extract mixed static and dynamic segments', () => {\n+      // Tree: /blog/[category]/posts/[slug]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          'blog',\n+          {},\n+          createLoaderTree(\n+            '[category]',\n+            {},\n+            createLoaderTree('posts', {}, createLoaderTree('[slug]'))\n+          )\n+        )\n+      )\n+      const routeModule = createMockRouteModule(loaderTree)\n+      const result = getFallbackRouteParams(\n+        '/blog/[category]/posts/[slug]',\n+        routeModule\n+      )\n+\n+      expect(result).not.toBeNull()\n+      expect(result!.size).toBe(2)\n+      expect(result!.has('category')).toBe(true)\n+      expect(result!.has('slug')).toBe(true)\n+    })\n+\n+    it('should handle route with no dynamic segments', () => {\n+      // Tree: /blog/posts\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('blog', {}, createLoaderTree('posts'))\n+      )\n+      const routeModule = createMockRouteModule(loaderTree)\n+      const result = getFallbackRouteParams('/blog/posts', routeModule)\n+\n+      // Should return null for no fallback params\n+      expect(result).toBeNull()\n+    })\n+\n+    it('should handle partially static routes', () => {\n+      // Tree: /[teamSlug]/[projectSlug] but page is /vercel/[projectSlug]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('[teamSlug]', {}, createLoaderTree('[projectSlug]'))\n+      )\n+      const routeModule = createMockRouteModule(loaderTree)\n+      const result = getFallbackRouteParams(\n+        '/vercel/[projectSlug]',\n+        routeModule\n+      )\n+\n+      expect(result).not.toBeNull()\n+      // Only projectSlug should be a fallback param, vercel is static\n+      expect(result!.has('projectSlug')).toBe(true)\n+      expect(result!.has('teamSlug')).toBe(false)\n+    })\n+  })\n+\n+  describe('Route Groups', () => {\n+    it('should ignore route groups when extracting segments', () => {\n+      // Tree: /(marketing)/blog/[slug]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          '(marketing)',\n+          {},\n+          createLoaderTree('blog', {}, createLoaderTree('[slug]'))\n+        )\n+      )\n+      const routeModule = createMockRouteModule(loaderTree)\n+      const result = getFallbackRouteParams('/blog/[slug]', routeModule)\n+\n+      expect(result).not.toBeNull()\n+      expect(result!.size).toBe(1)\n+      expect(result!.has('slug')).toBe(true)\n+    })\n+\n+    it('should handle route groups mixed with static segments', () => {\n+      // Tree: /(app)/dashboard/(users)/[userId]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          '(app)',\n+          {},\n+          createLoaderTree(\n+            'dashboard',\n+            {},\n+            createLoaderTree('(users)', {}, createLoaderTree('[userId]'))\n+          )\n+        )\n+      )\n+      const routeModule = createMockRouteModule(loaderTree)\n+      const result = getFallbackRouteParams('/dashboard/[userId]', routeModule)\n+\n+      expect(result).not.toBeNull()\n+      expect(result!.size).toBe(1)\n+      expect(result!.has('userId')).toBe(true)\n+    })\n+  })\n+\n+  describe('Parallel Routes', () => {\n+    it('should extract segment from parallel route matching pathname', () => {\n+      // Tree: / -> @modal/[id]\n+      const loaderTree = createLoaderTree('', {\n+        modal: createLoaderTree('[id]'),\n+      })\n+      const routeModule = createMockRouteModule(loaderTree)\n+      const result = getFallbackRouteParams('/[id]', routeModule)\n+\n+      expect(result).not.toBeNull()\n+      expect(result!.size).toBe(1)\n+      expect(result!.has('id')).toBe(true)\n+    })\n+\n+    it('should extract segments from both children and parallel routes', () => {\n+      // Tree: /[lang] -> children + @modal/[photoId]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('[lang]', {\n+          modal: createLoaderTree('[photoId]'),\n+        })\n+      )\n+      const routeModule = createMockRouteModule(loaderTree)\n+      const result = getFallbackRouteParams('/[lang]/[photoId]', routeModule)\n+\n+      expect(result).not.toBeNull()\n+      expect(result!.size).toBe(2)\n+      expect(result!.has('lang')).toBe(true)\n+      expect(result!.has('photoId')).toBe(true)\n+    })\n+\n+    it('should handle parallel route params that are not in pathname', () => {\n+      // Tree: /[id] -> @modal/[photoId] (photoId is not in pathname /[id])\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('[id]', {\n+          modal: createLoaderTree('[photoId]'),\n+        })\n+      )\n+      const routeModule = createMockRouteModule(loaderTree)\n+      const result = getFallbackRouteParams('/[id]', routeModule)\n+\n+      expect(result).not.toBeNull()\n+      expect(result!.size).toBe(2)\n+      expect(result!.has('id')).toBe(true)\n+      // photoId should also be included as it's a parallel route param\n+      expect(result!.has('photoId')).toBe(true)\n+    })\n+  })\n+\n+  describe('Interception Routes', () => {\n+    it('should extract segment from (.) same-level interception route', () => {\n+      // Tree: /(.)photo/[photoId]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('(.)photo', {}, createLoaderTree('[photoId]'))\n+      )\n+      const routeModule = createMockRouteModule(loaderTree)\n+      const result = getFallbackRouteParams('/(.)photo/[photoId]', routeModule)\n+\n+      expect(result).not.toBeNull()\n+      expect(result!.size).toBe(1)\n+      expect(result!.has('photoId')).toBe(true)\n+    })\n+\n+    it('should extract segment from (..) parent-level interception route', () => {\n+      // Tree: /gallery/(..)photo/[photoId]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          'gallery',\n+          {},\n+          createLoaderTree('(..)photo', {}, createLoaderTree('[photoId]'))\n+        )\n+      )\n+      const routeModule = createMockRouteModule(loaderTree)\n+      const result = getFallbackRouteParams(\n+        '/gallery/(..)photo/[photoId]',\n+        routeModule\n+      )\n+\n+      expect(result).not.toBeNull()\n+      expect(result!.size).toBe(1)\n+      expect(result!.has('photoId')).toBe(true)\n+    })\n+\n+    it('should extract intercepted param when marker is part of the segment itself', () => {\n+      // Tree: /(.)[photoId] - the interception marker is PART OF the dynamic segment\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('(.)[photoId]')\n+      )\n+      const routeModule = createMockRouteModule(loaderTree)\n+      const result = getFallbackRouteParams('/[photoId]', routeModule)\n+\n+      expect(result).not.toBeNull()\n+      expect(result!.size).toBe(1)\n+      expect(result!.has('photoId')).toBe(true)\n+      // Should have intercepted type\n+      expect(result!.get('photoId')?.[1]).toBe('di(.)') // 'di(.)' = dynamic-intercepted-(.)'\n+    })\n+  })\n+\n+  describe('Interception Routes in Parallel Routes', () => {\n+    it('should extract segment from interception route in parallel slot', () => {\n+      // Tree: @modal/(.)photo/[photoId]\n+      const loaderTree = createLoaderTree('', {\n+        modal: createLoaderTree('(.)photo', {}, createLoaderTree('[photoId]')),\n+      })\n+      const routeModule = createMockRouteModule(loaderTree)\n+      const result = getFallbackRouteParams('/(.)photo/[photoId]', routeModule)\n+\n+      expect(result).not.toBeNull()\n+      expect(result!.size).toBe(1)\n+      expect(result!.has('photoId')).toBe(true)\n+    })\n+\n+    it('should extract segments from both children and intercepting parallel route', () => {\n+      // Tree: /[id] -> children + @modal/(.)photo/[photoId]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('[id]', {\n+          modal: createLoaderTree(\n+            '(.)photo',\n+            {},\n+            createLoaderTree('[photoId]')\n+          ),\n+        })\n+      )\n+      const routeModule = createMockRouteModule(loaderTree)\n+      const result = getFallbackRouteParams(\n+        '/[id]/(.)photo/[photoId]',\n+        routeModule\n+      )\n+\n+      expect(result).not.toBeNull()\n+      expect(result!.size).toBe(2)\n+      expect(result!.has('id')).toBe(true)\n+      expect(result!.has('photoId')).toBe(true)\n+    })\n+\n+    it('should handle realistic photo gallery pattern with interception', () => {\n+      // Realistic pattern: /photos/[id] with @modal/(.)photo/[photoId]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          'photos',\n+          {},\n+          createLoaderTree('[id]', {\n+            modal: createLoaderTree(\n+              '(.)photo',\n+              {},\n+              createLoaderTree('[photoId]')\n+            ),\n+          })\n+        )\n+      )\n+      const routeModule = createMockRouteModule(loaderTree)\n+      const result = getFallbackRouteParams(\n+        '/photos/[id]/(.)photo/[photoId]',\n+        routeModule\n+      )\n+\n+      expect(result).not.toBeNull()\n+      expect(result!.size).toBe(2)\n+      expect(result!.has('id')).toBe(true)\n+      expect(result!.has('photoId')).toBe(true)\n+    })\n+  })\n+\n+  describe('Complex Mixed Scenarios', () => {\n+    it('should handle route groups + parallel routes + interception routes', () => {\n+      // Tree: /(marketing)/[lang] -> @modal/(.)photo/[photoId]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          '(marketing)',\n+          {},\n+          createLoaderTree('[lang]', {\n+            modal: createLoaderTree(\n+              '(.)photo',\n+              {},\n+              createLoaderTree('[photoId]')\n+            ),\n+          })\n+        )\n+      )\n+      const routeModule = createMockRouteModule(loaderTree)\n+      const result = getFallbackRouteParams(\n+        '/[lang]/(.)photo/[photoId]',\n+        routeModule\n+      )\n+\n+      expect(result).not.toBeNull()\n+      expect(result!.size).toBe(2)\n+      expect(result!.has('lang')).toBe(true)\n+      expect(result!.has('photoId')).toBe(true)\n+    })\n+\n+    it('should handle i18n with interception routes', () => {\n+      // Tree: /[locale]/products/[category] -> @modal/(.)product/[productId]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          '[locale]',\n+          {},\n+          createLoaderTree(\n+            'products',\n+            {},\n+            createLoaderTree('[category]', {\n+              modal: createLoaderTree(\n+                '(.)product',\n+                {},\n+                createLoaderTree('[productId]')\n+              ),\n+            })\n+          )\n+        )\n+      )\n+      const routeModule = createMockRouteModule(loaderTree)\n+      const result = getFallbackRouteParams(\n+        '/[locale]/products/[category]/(.)product/[productId]',\n+        routeModule\n+      )\n+\n+      expect(result).not.toBeNull()\n+      expect(result!.size).toBe(3)\n+      expect(result!.has('locale')).toBe(true)\n+      expect(result!.has('category')).toBe(true)\n+      expect(result!.has('productId')).toBe(true)\n+    })\n+\n+    it('should handle partially static i18n route', () => {\n+      // Tree: /[locale]/products/[category] but page is /en/products/[category]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          '[locale]',\n+          {},\n+          createLoaderTree('products', {}, createLoaderTree('[category]'))\n+        )\n+      )\n+      const routeModule = createMockRouteModule(loaderTree)\n+      const result = getFallbackRouteParams(\n+        '/en/products/[category]',\n+        routeModule\n+      )\n+\n+      expect(result).not.toBeNull()\n+      expect(result!.size).toBe(1)\n+      expect(result!.has('category')).toBe(true)\n+      // locale should not be a fallback param because 'en' is static\n+      expect(result!.has('locale')).toBe(false)\n+    })\n+\n+    it('should handle a partially static intercepting route', () => {\n+      // Tree: /[locale]/(.)photo/[photoId] but page is /en/(.)photo/[photoId]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('[locale]', {\n+          modal: createLoaderTree(\n+            '(.)photo',\n+            {},\n+            createLoaderTree('[photoId]')\n+          ),\n+        })\n+      )\n+      const routeModule = createMockRouteModule(loaderTree)\n+      const result = getFallbackRouteParams(\n+        '/en/(.)photo/[photoId]',\n+        routeModule\n+      )\n+\n+      expect(result).not.toBeNull()\n+      expect(result!.size).toBe(1)\n+      expect(result!.has('photoId')).toBe(true)\n+      // locale should not be a fallback param because 'en' is static\n+      expect(result!.has('locale')).toBe(false)\n+    })\n+  })\n+\n+  describe('Edge Cases', () => {\n+    it('should return null for pathname with no dynamic segments', () => {\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('blog', {}, createLoaderTree('posts'))\n+      )\n+      const routeModule = createMockRouteModule(loaderTree)\n+      const result = getFallbackRouteParams('/blog/posts', routeModule)\n+\n+      expect(result).toBeNull()\n+    })\n+\n+    it('should handle empty segment in tree', () => {\n+      // Tree: '' -> [id]\n+      const loaderTree = createLoaderTree('', {}, createLoaderTree('[id]'))\n+      const routeModule = createMockRouteModule(loaderTree)\n+      const result = getFallbackRouteParams('/[id]', routeModule)\n+\n+      expect(result).not.toBeNull()\n+      expect(result!.size).toBe(1)\n+      expect(result!.has('id')).toBe(true)\n+    })\n+\n+    it('should handle root dynamic route', () => {\n+      // Tree: /[slug]\n+      const loaderTree = createLoaderTree('', {}, createLoaderTree('[slug]'))\n+      const routeModule = createMockRouteModule(loaderTree)\n+      const result = getFallbackRouteParams('/[slug]', routeModule)\n+\n+      expect(result).not.toBeNull()\n+      expect(result!.size).toBe(1)\n+      expect(result!.has('slug')).toBe(true)\n+    })\n+\n+    it('should handle catchall at root', () => {\n+      // Tree: /[...slug]\n+      const loaderTree = createLoaderTree('', {}, createLoaderTree('[...slug]'))\n+      const routeModule = createMockRouteModule(loaderTree)\n+      const result = getFallbackRouteParams('/[...slug]', routeModule)\n+\n+      expect(result).not.toBeNull()\n+      expect(result!.size).toBe(1)\n+      expect(result!.has('slug')).toBe(true)\n+      expect(result!.get('slug')?.[1]).toBe('c') // catchall\n+    })\n+\n+    it('should handle optional catchall in parallel route', () => {\n+      // Tree: @sidebar/[[...optional]]\n+      const loaderTree = createLoaderTree('', {\n+        sidebar: createLoaderTree('[[...optional]]'),\n+      })\n+      const routeModule = createMockRouteModule(loaderTree)\n+\n+      let result = getFallbackRouteParams('/[[...optional]]', routeModule)\n+      expect(result).not.toBeNull()\n+      expect(result!.size).toBe(1)\n+      expect(result!.has('optional')).toBe(true)\n+      expect(result!.get('optional')?.[1]).toBe('oc') // optional-catchall\n+\n+      result = getFallbackRouteParams('/sidebar/is/real', routeModule)\n+      expect(result).toBeNull()\n+    })\n+  })\n+})"
        },
        {
            "sha": "cadde0b603d19211801fef6a0fbd48791ae21863",
            "filename": "packages/next/src/server/request/fallback-params.ts",
            "status": "modified",
            "additions": 36,
            "deletions": 85,
            "changes": 121,
            "blob_url": "https://github.com/vercel/next.js/blob/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Ffallback-params.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Ffallback-params.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Ffallback-params.ts?ref=d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd",
            "patch": "@@ -1,19 +1,10 @@\n-import { collectFallbackRouteParams } from '../../build/segment-config/app/app-segments'\n+import { resolveRouteParamsFromTree } from '../../build/static-paths/utils'\n import type { FallbackRouteParam } from '../../build/static-paths/types'\n import type { DynamicParamTypesShort } from '../../shared/lib/app-router-types'\n-import { InvariantError } from '../../shared/lib/invariant-error'\n-import { getRouteMatcher } from '../../shared/lib/router/utils/route-matcher'\n-import { getRouteRegex } from '../../shared/lib/router/utils/route-regex'\n import { dynamicParamTypes } from '../app-render/get-short-dynamic-param-type'\n import type AppPageRouteModule from '../route-modules/app-page/module'\n-\n-function getParamKeys(page: string) {\n-  const pattern = getRouteRegex(page)\n-  const matcher = getRouteMatcher(pattern)\n-\n-  // Get the default list of allowed params.\n-  return Object.keys(matcher(page))\n-}\n+import { parseAppRoute } from '../../shared/lib/router/routes/app'\n+import { extractPathnameRouteParamSegmentsFromLoaderTree } from '../../build/static-paths/app/extract-pathname-route-param-segments-from-loader-tree'\n \n export type OpaqueFallbackRouteParamValue = [\n   /**\n@@ -96,78 +87,38 @@ export function getFallbackRouteParams(\n   page: string,\n   routeModule: AppPageRouteModule\n ) {\n-  // First, get the fallback route params based on the provided page.\n-  const unknownParamKeys = new Set(getParamKeys(page))\n-\n-  // Needed when processing fallback route params for catchall routes in\n-  // parallel segments, derive from pathname. This is similar to\n-  // getDynamicParam's pagePath parsing logic.\n-  const pathSegments = page.split('/').filter(Boolean)\n-\n-  const collected = collectFallbackRouteParams(routeModule)\n-\n-  // Then, we have to get the fallback route params from the segments that are\n-  // associated with parallel route segments.\n-  const fallbackRouteParams: FallbackRouteParam[] = []\n-  for (const fallbackRouteParam of collected) {\n-    if (fallbackRouteParam.isParallelRouteParam) {\n-      // Try to see if we can resolve this parameter from the page that was\n-      // passed in.\n-      if (unknownParamKeys.has(fallbackRouteParam.paramName)) {\n-        // The parameter is known, we can skip adding it to the fallback route\n-        // params.\n-        continue\n-      }\n-\n-      if (\n-        fallbackRouteParam.paramType === 'optional-catchall' ||\n-        fallbackRouteParam.paramType === 'catchall'\n-      ) {\n-        // If there are any fallback route segments then we can't use the\n-        // pathname to derive the value because it's not complete. We can\n-        // make this assumption because the routes are always resolved left\n-        // to right and the catchall is always the last segment, so any\n-        // route parameters that are unknown will always contribute to the\n-        // pathname and therefore the catchall param too.\n-        if (\n-          collected.some(\n-            (param) =>\n-              !param.isParallelRouteParam &&\n-              unknownParamKeys.has(param.paramName)\n-          )\n-        ) {\n-          fallbackRouteParams.push(fallbackRouteParam)\n-          continue\n-        }\n-\n-        if (\n-          pathSegments.length === 0 &&\n-          fallbackRouteParam.paramType !== 'optional-catchall'\n-        ) {\n-          // We shouldn't be able to match a catchall segment without any path\n-          // segments if it's not an optional catchall.\n-          throw new InvariantError(\n-            `Unexpected empty path segments match for a pathname \"${page}\" with param \"${fallbackRouteParam.paramName}\" of type \"${fallbackRouteParam.paramType}\"`\n-          )\n-        }\n-\n-        // The path segments are not empty, and the segments didn't contain any\n-        // unknown params, so we know that this particular fallback route param\n-        // route param is not actually unknown, and is known. We can skip adding\n-        // it to the fallback route params.\n-      } else {\n-        // This is some other type of route param that shouldn't get resolved\n-        // statically.\n-        throw new InvariantError(\n-          `Unexpected match for a pathname \"${page}\" with a param \"${fallbackRouteParam.paramName}\" of type \"${fallbackRouteParam.paramType}\"`\n-        )\n-      }\n-    } else if (unknownParamKeys.has(fallbackRouteParam.paramName)) {\n-      // As this is a non-parallel route segment, and it exists in the unknown\n-      // param keys, we know it's a fallback route param.\n-      fallbackRouteParams.push(fallbackRouteParam)\n-    }\n-  }\n-\n+  const route = parseAppRoute(page, true)\n+\n+  // Extract the pathname-contributing segments from the loader tree. This\n+  // mirrors the logic in buildAppStaticPaths where we determine which segments\n+  // actually contribute to the pathname.\n+  const { pathnameRouteParamSegments, params } =\n+    extractPathnameRouteParamSegmentsFromLoaderTree(\n+      routeModule.userland.loaderTree,\n+      route\n+    )\n+\n+  // Create fallback route params for the pathname segments.\n+  const fallbackRouteParams: FallbackRouteParam[] =\n+    pathnameRouteParamSegments.map(({ paramName, paramType }) => ({\n+      paramName,\n+      paramType,\n+    }))\n+\n+  // Resolve route params from the loader tree. This mutates the\n+  // fallbackRouteParams array to add any route params that are\n+  // unknown at request time.\n+  //\n+  // The page parameter contains placeholders like [slug], which helps\n+  // resolveRouteParamsFromTree determine which params are unknown.\n+  resolveRouteParamsFromTree(\n+    routeModule.userland.loaderTree,\n+    params, // Static params extracted from the page\n+    route, // The page pattern with placeholders\n+    fallbackRouteParams // Will be mutated to add route params\n+  )\n+\n+  // Convert the fallback route params to an opaque format that can be safely\n+  // used in the postponed state without exposing implementation details.\n   return createOpaqueFallbackRouteParams(fallbackRouteParams)\n }"
        },
        {
            "sha": "0112713fa0fed9e812892879051a6c51848b4937",
            "filename": "packages/next/src/shared/lib/router/routes/app.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Froutes%2Fapp.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Froutes%2Fapp.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Froutes%2Fapp.ts?ref=d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd",
            "patch": "@@ -115,7 +115,10 @@ export type NormalizedAppRoute = Omit<AppRoute, 'normalized' | 'segments'> & {\n }\n \n export function isNormalizedAppRoute(\n-  route: AppRoute\n+  route: InterceptionAppRoute\n+): route is NormalizedInterceptionAppRoute\n+export function isNormalizedAppRoute(\n+  route: AppRoute | InterceptionAppRoute\n ): route is NormalizedAppRoute {\n   return route.normalized\n }"
        },
        {
            "sha": "900d588062273a4fa9ebd984ce7db5290cec5634",
            "filename": "packages/next/src/shared/lib/router/utils/get-dynamic-param.test.ts",
            "status": "modified",
            "additions": 28,
            "deletions": 46,
            "changes": 74,
            "blob_url": "https://github.com/vercel/next.js/blob/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Fget-dynamic-param.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Fget-dynamic-param.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Fget-dynamic-param.test.ts?ref=d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd",
            "patch": "@@ -7,7 +7,6 @@ import {\n import type { Params } from '../../../../server/request/params'\n import { InvariantError } from '../../invariant-error'\n import { createMockOpaqueFallbackRouteParams } from '../../../../server/app-render/postponed-state.test'\n-import type { LoaderTree } from '../../../../server/lib/app-dir-module'\n \n describe('getDynamicParam', () => {\n   describe('basic dynamic parameters (d, di)', () => {\n@@ -403,60 +402,43 @@ describe('parseMatchedParameter', () => {\n   })\n })\n \n+// Helper to create LoaderTree structures for testing\n+type TestLoaderTree = [\n+  segment: string,\n+  parallelRoutes: { [key: string]: TestLoaderTree },\n+  modules: Record<string, unknown>,\n+]\n+\n+function createLoaderTree(\n+  segment: string,\n+  parallelRoutes: { [key: string]: TestLoaderTree } = {},\n+  children?: TestLoaderTree\n+): TestLoaderTree {\n+  const routes = children ? { ...parallelRoutes, children } : parallelRoutes\n+  return [segment, routes, {}]\n+}\n+\n describe('interpolateParallelRouteParams', () => {\n   it('should interpolate parallel route params', () => {\n-    const loaderTree = [\n+    const loaderTree = createLoaderTree(\n       '',\n-      {\n-        children: [\n-          'optional-catch-all',\n-          {\n-            children: [\n-              '[[...path]]',\n-              {\n-                children: [\n-                  '__PAGE__',\n-                  {},\n-                  {\n-                    page: [\n-                      null,\n-                      '/private/var/folders/xy/84vxj27s21x2brb851sdl_5c0000gn/T/next-install-1265b780415069863d37bb613af21623e2ce3eecc0c3a770cbbc66e0a4cf18aa/app/optional-catch-all/[[...path]]/page.tsx',\n-                    ],\n-                  },\n-                ],\n-              },\n-              {\n-                layout: [\n-                  null,\n-                  '/private/var/folders/xy/84vxj27s21x2brb851sdl_5c0000gn/T/next-install-1265b780415069863d37bb613af21623e2ce3eecc0c3a770cbbc66e0a4cf18aa/app/optional-catch-all/[[...path]]/layout.tsx',\n-                ],\n-              },\n-            ],\n-          },\n-          {},\n-        ],\n-      },\n-      {\n-        'global-error': [\n-          null,\n-          'next/dist/client/components/builtin/global-error.js',\n-        ],\n-        'not-found': [null, 'next/dist/client/components/builtin/not-found.js'],\n-        forbidden: [null, 'next/dist/client/components/builtin/forbidden.js'],\n-        unauthorized: [\n-          null,\n-          'next/dist/client/components/builtin/unauthorized.js',\n-        ],\n-      },\n-    ] as unknown as LoaderTree\n+      {},\n+      createLoaderTree(\n+        'optional-catch-all',\n+        {\n+          modal: createLoaderTree('[[...catchAll]]'),\n+        },\n+        createLoaderTree('[[...path]]')\n+      )\n+    )\n \n     expect(\n       interpolateParallelRouteParams(\n         loaderTree,\n-        {},\n+        { path: ['foo', 'bar'] },\n         '/optional-catch-all/[[...path]]',\n         null\n       )\n-    ).toEqual({})\n+    ).toEqual({ path: ['foo', 'bar'], catchAll: ['foo', 'bar'] })\n   })\n })"
        },
        {
            "sha": "8521bac670bf6b8642cba6ab860aad318140d2f0",
            "filename": "packages/next/src/shared/lib/router/utils/get-dynamic-param.ts",
            "status": "modified",
            "additions": 33,
            "deletions": 57,
            "changes": 90,
            "blob_url": "https://github.com/vercel/next.js/blob/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Fget-dynamic-param.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Fget-dynamic-param.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Fget-dynamic-param.ts?ref=d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd",
            "patch": "@@ -5,7 +5,8 @@ import type { Params } from '../../../../server/request/params'\n import type { DynamicParamTypesShort } from '../../app-router-types'\n import { InvariantError } from '../../invariant-error'\n import { parseLoaderTree } from './parse-loader-tree'\n-import { getSegmentParam } from './get-segment-param'\n+import { parseAppRoute, parseAppRouteSegment } from '../routes/app'\n+import { resolveParamValue } from './resolve-param-value'\n \n /**\n  * Gets the value of a param from the params object. This correctly handles the\n@@ -43,87 +44,62 @@ export function interpolateParallelRouteParams(\n   params: Params,\n   pagePath: string,\n   fallbackRouteParams: OpaqueFallbackRouteParams | null\n-) {\n+): Params {\n   const interpolated = structuredClone(params)\n \n   // Stack-based traversal with depth tracking\n   const stack: Array<{ tree: LoaderTree; depth: number }> = [\n     { tree: loaderTree, depth: 0 },\n   ]\n \n-  // Derive value from pagePath based on depth and parameter type\n-  const pathSegments = pagePath.split('/').slice(1) // Remove first empty string\n+  // Parse the route from the provided page path.\n+  const route = parseAppRoute(pagePath, true)\n \n   while (stack.length > 0) {\n     const { tree, depth } = stack.pop()!\n     const { segment, parallelRoutes } = parseLoaderTree(tree)\n \n-    // Check if current segment contains a parameter\n-    const segmentParam = getSegmentParam(segment)\n+    const appSegment = parseAppRouteSegment(segment)\n+\n     if (\n-      segmentParam &&\n-      !interpolated.hasOwnProperty(segmentParam.param) &&\n+      appSegment?.type === 'dynamic' &&\n+      !interpolated.hasOwnProperty(appSegment.param.paramName) &&\n       // If the param is in the fallback route params, we don't need to\n       // interpolate it because it's already marked as being unknown.\n-      !fallbackRouteParams?.has(segmentParam.param)\n+      !fallbackRouteParams?.has(appSegment.param.paramName)\n     ) {\n-      switch (segmentParam.type) {\n-        case 'catchall':\n-        case 'optional-catchall':\n-        case 'catchall-intercepted-(..)(..)':\n-        case 'catchall-intercepted-(.)':\n-        case 'catchall-intercepted-(..)':\n-        case 'catchall-intercepted-(...)':\n-          // For catchall parameters, take all remaining segments from this depth\n-          const remainingSegments = pathSegments.slice(depth)\n-\n-          // Process each segment to handle any dynamic params\n-          const processedSegments = remainingSegments\n-            .flatMap((pathSegment) => {\n-              const param = getSegmentParam(pathSegment)\n-              // If the segment matches a param, return the param value otherwise,\n-              // it's a static segment, so just return that. We don't use the\n-              // `getParamValue` function here because we don't want the values to\n-              // be encoded, that's handled on get by the `getDynamicParam`\n-              // function.\n-              return param ? interpolated[param.param] : pathSegment\n-            })\n-            .filter((s) => s !== undefined)\n-\n-          if (processedSegments.length > 0) {\n-            interpolated[segmentParam.param] = processedSegments\n-          }\n-          break\n-        case 'dynamic':\n-        case 'dynamic-intercepted-(..)(..)':\n-        case 'dynamic-intercepted-(.)':\n-        case 'dynamic-intercepted-(..)':\n-        case 'dynamic-intercepted-(...)':\n-          // For regular dynamic parameters, take the segment at this depth\n-          if (depth < pathSegments.length) {\n-            const pathSegment = pathSegments[depth]\n-            const param = getSegmentParam(pathSegment)\n-\n-            interpolated[segmentParam.param] = param\n-              ? interpolated[param.param]\n-              : pathSegment\n-          }\n-          break\n-        default:\n-          segmentParam.type satisfies never\n+      const { paramName, paramType } = appSegment.param\n+\n+      const paramValue = resolveParamValue(\n+        paramName,\n+        paramType,\n+        depth,\n+        route,\n+        interpolated\n+      )\n+\n+      if (paramValue !== undefined) {\n+        interpolated[paramName] = paramValue\n+      } else if (paramType !== 'optional-catchall') {\n+        throw new InvariantError(\n+          `Could not resolve param value for segment: ${paramName}`\n+        )\n       }\n     }\n \n     // Calculate next depth - increment if this is not a route group and not empty\n     let nextDepth = depth\n-    const isRouteGroup = segment.startsWith('(') && segment.endsWith(')')\n-    if (!isRouteGroup && segment !== '') {\n+    if (\n+      appSegment &&\n+      appSegment.type !== 'route-group' &&\n+      appSegment.type !== 'parallel-route'\n+    ) {\n       nextDepth++\n     }\n \n     // Add all parallel routes to the stack for processing\n-    for (const route of Object.values(parallelRoutes)) {\n-      stack.push({ tree: route, depth: nextDepth })\n+    for (const parallelRoute of Object.values(parallelRoutes)) {\n+      stack.push({ tree: parallelRoute, depth: nextDepth })\n     }\n   }\n "
        },
        {
            "sha": "a76ab0dcdaf0e82917ca65606e3d7f74b3d63236",
            "filename": "packages/next/src/shared/lib/router/utils/get-segment-param.tsx",
            "status": "modified",
            "additions": 8,
            "deletions": 8,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Fget-segment-param.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Fget-segment-param.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Fget-segment-param.tsx?ref=d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd",
            "patch": "@@ -2,8 +2,8 @@ import { INTERCEPTION_ROUTE_MARKERS } from './interception-routes'\n import type { DynamicParamTypes } from '../../app-router-types'\n \n export type SegmentParam = {\n-  param: string\n-  type: DynamicParamTypes\n+  paramName: string\n+  paramType: DynamicParamTypes\n }\n \n /**\n@@ -24,26 +24,26 @@ export function getSegmentParam(segment: string): SegmentParam | null {\n     return {\n       // TODO-APP: Optional catchall does not currently work with parallel routes,\n       // so for now aren't handling a potential interception marker.\n-      type: 'optional-catchall',\n-      param: segment.slice(5, -2),\n+      paramType: 'optional-catchall',\n+      paramName: segment.slice(5, -2),\n     }\n   }\n \n   if (segment.startsWith('[...') && segment.endsWith(']')) {\n     return {\n-      type: interceptionMarker\n+      paramType: interceptionMarker\n         ? `catchall-intercepted-${interceptionMarker}`\n         : 'catchall',\n-      param: segment.slice(4, -1),\n+      paramName: segment.slice(4, -1),\n     }\n   }\n \n   if (segment.startsWith('[') && segment.endsWith(']')) {\n     return {\n-      type: interceptionMarker\n+      paramType: interceptionMarker\n         ? `dynamic-intercepted-${interceptionMarker}`\n         : 'dynamic',\n-      param: segment.slice(1, -1),\n+      paramName: segment.slice(1, -1),\n     }\n   }\n "
        },
        {
            "sha": "d9af52b64e976ea4a4facb3eba63f81e598a18ef",
            "filename": "packages/next/src/shared/lib/router/utils/interception-prefix-from-param-type.ts",
            "status": "added",
            "additions": 25,
            "deletions": 0,
            "changes": 25,
            "blob_url": "https://github.com/vercel/next.js/blob/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Finterception-prefix-from-param-type.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Finterception-prefix-from-param-type.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Finterception-prefix-from-param-type.ts?ref=d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd",
            "patch": "@@ -0,0 +1,25 @@\n+import type { DynamicParamTypes } from '../../app-router-types'\n+\n+export function interceptionPrefixFromParamType(\n+  paramType: DynamicParamTypes\n+): string | null {\n+  switch (paramType) {\n+    case 'catchall-intercepted-(..)(..)':\n+    case 'dynamic-intercepted-(..)(..)':\n+      return '(..)(..)'\n+    case 'catchall-intercepted-(.)':\n+    case 'dynamic-intercepted-(.)':\n+      return '(.)'\n+    case 'catchall-intercepted-(..)':\n+    case 'dynamic-intercepted-(..)':\n+      return '(..)'\n+    case 'catchall-intercepted-(...)':\n+    case 'dynamic-intercepted-(...)':\n+      return '(...)'\n+    case 'catchall':\n+    case 'dynamic':\n+    case 'optional-catchall':\n+    default:\n+      return null\n+  }\n+}"
        },
        {
            "sha": "47901f9cd3860e067b729d9d88d8b62f4acc13e1",
            "filename": "packages/next/src/shared/lib/router/utils/resolve-param-value.ts",
            "status": "added",
            "additions": 154,
            "deletions": 0,
            "changes": 154,
            "blob_url": "https://github.com/vercel/next.js/blob/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Fresolve-param-value.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Fresolve-param-value.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Fresolve-param-value.ts?ref=d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd",
            "patch": "@@ -0,0 +1,154 @@\n+import type { Params } from '../../../../server/request/params'\n+import type { DynamicParamTypes } from '../../app-router-types'\n+import { InvariantError } from '../../invariant-error'\n+import type {\n+  NormalizedAppRoute,\n+  NormalizedAppRouteSegment,\n+} from '../routes/app'\n+import { interceptionPrefixFromParamType } from './interception-prefix-from-param-type'\n+\n+/**\n+ * Extracts the param value from a path segment, handling interception markers\n+ * based on the expected param type.\n+ *\n+ * @param pathSegment - The path segment to extract the value from\n+ * @param params - The current params object for resolving dynamic param references\n+ * @param paramType - The expected param type which may include interception marker info\n+ * @returns The extracted param value\n+ */\n+function getParamValueFromSegment(\n+  pathSegment: NormalizedAppRouteSegment,\n+  params: Params,\n+  paramType: DynamicParamTypes\n+): string {\n+  // If the segment is dynamic, resolve it from the params object\n+  if (pathSegment.type === 'dynamic') {\n+    return params[pathSegment.param.paramName] as string\n+  }\n+\n+  // If the paramType indicates this is an intercepted param, strip the marker\n+  // that matches the interception marker in the param type\n+  const interceptionPrefix = interceptionPrefixFromParamType(paramType)\n+  if (interceptionPrefix === pathSegment.interceptionMarker) {\n+    return pathSegment.name.replace(pathSegment.interceptionMarker, '')\n+  }\n+\n+  // For static segments, use the name\n+  return pathSegment.name\n+}\n+\n+/**\n+ * Resolves a route parameter value from the route segments at the given depth.\n+ * This shared logic is used by both extractPathnameRouteParamSegmentsFromLoaderTree\n+ * and resolveRouteParamsFromTree.\n+ *\n+ * @param paramName - The parameter name to resolve\n+ * @param paramType - The parameter type (dynamic, catchall, etc.)\n+ * @param depth - The current depth in the route tree\n+ * @param route - The normalized route containing segments\n+ * @param params - The current params object (used to resolve embedded param references)\n+ * @param options - Configuration options\n+ * @returns The resolved parameter value, or undefined if it cannot be resolved\n+ */\n+export function resolveParamValue(\n+  paramName: string,\n+  paramType: DynamicParamTypes,\n+  depth: number,\n+  route: NormalizedAppRoute,\n+  params: Params\n+): string | string[] | undefined {\n+  switch (paramType) {\n+    case 'catchall':\n+    case 'optional-catchall':\n+    case 'catchall-intercepted-(..)(..)':\n+    case 'catchall-intercepted-(.)':\n+    case 'catchall-intercepted-(..)':\n+    case 'catchall-intercepted-(...)':\n+      // For catchall routes, derive from pathname using depth to determine\n+      // which segments to use\n+      const processedSegments: string[] = []\n+\n+      // Process segments to handle any embedded dynamic params\n+      for (let index = depth; index < route.segments.length; index++) {\n+        const pathSegment = route.segments[index]\n+\n+        if (pathSegment.type === 'static') {\n+          let value = pathSegment.name\n+\n+          // For intercepted catch-all params, strip the marker from the first segment\n+          const interceptionPrefix = interceptionPrefixFromParamType(paramType)\n+          if (\n+            interceptionPrefix &&\n+            index === depth &&\n+            interceptionPrefix === pathSegment.interceptionMarker\n+          ) {\n+            // Strip the interception marker from the value\n+            value = value.replace(pathSegment.interceptionMarker, '')\n+          }\n+\n+          processedSegments.push(value)\n+        } else {\n+          // If the segment is a param placeholder, check if we have its value\n+          if (!params.hasOwnProperty(pathSegment.param.paramName)) {\n+            // If the segment is an optional catchall, we can break out of the\n+            // loop because it's optional!\n+            if (pathSegment.param.paramType === 'optional-catchall') {\n+              break\n+            }\n+\n+            // Unknown param placeholder in pathname - can't derive full value\n+            return undefined\n+          }\n+\n+          // If the segment matches a param, use the param value\n+          // We don't encode values here as that's handled during retrieval.\n+          const paramValue = params[pathSegment.param.paramName]\n+          if (Array.isArray(paramValue)) {\n+            processedSegments.push(...paramValue)\n+          } else {\n+            processedSegments.push(paramValue as string)\n+          }\n+        }\n+      }\n+\n+      if (processedSegments.length > 0) {\n+        return processedSegments\n+      } else if (paramType === 'optional-catchall') {\n+        return undefined\n+      } else {\n+        // We shouldn't be able to match a catchall segment without any path\n+        // segments if it's not an optional catchall\n+        throw new InvariantError(\n+          `Unexpected empty path segments match for a route \"${route.pathname}\" with param \"${paramName}\" of type \"${paramType}\"`\n+        )\n+      }\n+    case 'dynamic':\n+    case 'dynamic-intercepted-(..)(..)':\n+    case 'dynamic-intercepted-(.)':\n+    case 'dynamic-intercepted-(..)':\n+    case 'dynamic-intercepted-(...)':\n+      // For regular dynamic parameters, take the segment at this depth\n+      if (depth < route.segments.length) {\n+        const pathSegment = route.segments[depth]\n+\n+        // Check if the segment at this depth is a placeholder for an unknown param\n+        if (\n+          pathSegment.type === 'dynamic' &&\n+          !params.hasOwnProperty(pathSegment.param.paramName)\n+        ) {\n+          // The segment is a placeholder like [category] and we don't have the value\n+          return undefined\n+        }\n+\n+        // If the segment matches a param, use the param value from params object\n+        // Otherwise it's a static segment, just use it directly\n+        // We don't encode values here as that's handled during retrieval\n+        return getParamValueFromSegment(pathSegment, params, paramType)\n+      }\n+\n+      return undefined\n+\n+    default:\n+      paramType satisfies never\n+  }\n+}"
        },
        {
            "sha": "1621e9d34051a1081c74915f988ae8e69187771b",
            "filename": "test/e2e/app-dir/interception-dynamic-segment/app/@modal/(.)[username]/[id]/page.tsx",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-segment%2Fapp%2F%40modal%2F(.)%5Busername%5D%2F%5Bid%5D%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-segment%2Fapp%2F%40modal%2F(.)%5Busername%5D%2F%5Bid%5D%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-segment%2Fapp%2F%40modal%2F(.)%5Busername%5D%2F%5Bid%5D%2Fpage.tsx?ref=d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd",
            "patch": "@@ -1,3 +1,7 @@\n export default function Page() {\n   return 'intercepted'\n }\n+\n+export async function generateStaticParams() {\n+  return [{ username: 'john', id: '1' }]\n+}"
        },
        {
            "sha": "465af127abfbd020edc8b6096f48875d3874bcb0",
            "filename": "test/e2e/app-dir/interception-dynamic-segment/interception-dynamic-segment.test.ts",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-segment%2Finterception-dynamic-segment.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-segment%2Finterception-dynamic-segment.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-segment%2Finterception-dynamic-segment.test.ts?ref=d7608f7ecc58f7ca3097d7f54ffc3c202da4ccfd",
            "patch": "@@ -146,6 +146,16 @@ describe('interception-dynamic-segment', () => {\n       expect(res.status).toBe(200)\n       expect(res.headers.get('x-nextjs-cache')).toBe('HIT')\n     })\n+\n+    it('should prerender a dynamic intercepted route', async () => {\n+      if (process.env.__NEXT_CACHE_COMPONENTS === 'true') {\n+        expect(next.cliOutput).toContain('/(.)[username]/[id]')\n+        expect(next.cliOutput).toContain('/(.)john/[id]')\n+      }\n+\n+      expect(next.cliOutput).toContain('/(.)john/1')\n+      expect(next.cliOutput).not.toContain('/john/1')\n+    })\n   }\n \n   if (!isNextDev) {"
        }
    ],
    "stats": {
        "total": 5643,
        "additions": 3706,
        "deletions": 1937
    }
}