{
    "author": "ztanner",
    "message": "[test]: convert prefetching tests to be segmentCache compatible (#84521)\n\nRefactors some older prefetching tests to be compatible with\n`clientSegmentCache`. The old tests were too tightly coupled to router\nimplementation details. Some of the ones that don't make sense to\nconvert were removed (for ex, asserting on prefetch cache seeding\nbehavior, or fetch priority of \"high\", as fetch priority is managed\ndifferently with the new router).\n\nThis refactors the tests to leverage the `act` util from `segment-cache`\ntest suites, and implemented the accordion behavior to more granularly\ncontrol when prefetches are dispatched. I copied those implementations\nfor now since we don't have a global util for it.",
    "sha": "9c053332ccbc17220982f169b94c7cbdca0a648e",
    "files": [
        {
            "sha": "9e337d331d8801b703f266dfe216b9722d1501a3",
            "filename": "test/client-segment-cache-tests-manifest.json",
            "status": "modified",
            "additions": 0,
            "deletions": 20,
            "changes": 20,
            "blob_url": "https://github.com/vercel/next.js/blob/9c053332ccbc17220982f169b94c7cbdca0a648e/test%2Fclient-segment-cache-tests-manifest.json",
            "raw_url": "https://github.com/vercel/next.js/raw/9c053332ccbc17220982f169b94c7cbdca0a648e/test%2Fclient-segment-cache-tests-manifest.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fclient-segment-cache-tests-manifest.json?ref=9c053332ccbc17220982f169b94c7cbdca0a648e",
            "patch": "@@ -11,26 +11,6 @@\n         \"app-dir action handling should reset the form state when the action redirects to itself\"\n       ]\n     },\n-    \"test/e2e/app-dir/app-prefetch/prefetching.stale-times.test.ts\": {\n-      \"failed\": [\n-        \"app dir - prefetching (custom staleTime) should fetch again when a static page was prefetched when navigating to it after the stale time has passed\",\n-        \"app dir - prefetching (custom staleTime) should fetch again when the initially visited static page is visited after the stale time has passed\",\n-        \"app dir - prefetching (custom staleTime) should not fetch again when a static page was prefetched when navigating to it twice\",\n-        \"app dir - prefetching (custom staleTime) should renew the stale time after refetching expired RSC data\"\n-      ]\n-    },\n-    \"test/e2e/app-dir/app-prefetch/prefetching.test.ts\": {\n-      \"failed\": [\n-        \"app dir - prefetching fetch priority should have an auto priority for all other fetch operations\",\n-        \"app dir - prefetching fetch priority should prefetch with high priority when navigating to a page without a prefetch entry\",\n-        \"app dir - prefetching prefetch cache seeding should not re-fetch the initial dynamic page if the same page is prefetched with prefetch={true}\",\n-        \"app dir - prefetching prefetch cache seeding should not re-fetch the initial static page if the same page is prefetched with prefetch={true}\",\n-        \"app dir - prefetching should calculate `_rsc` query based on `Next-Url`\",\n-        \"app dir - prefetching should immediately render the loading state for a dynamic segment when fetched from higher up in the tree\",\n-        \"app dir - prefetching should not fetch again when a static page was prefetched\",\n-        \"app dir - prefetching should not unintentionally modify the requested prefetch by escaping the uri encoded query params\"\n-      ]\n-    },\n     \"test/e2e/app-dir/navigation/navigation.test.ts\": {\n       \"failed\": [\n         \"app dir - navigation middleware redirect should change browser location when router.refresh() gets a redirect response\""
        },
        {
            "sha": "b4563f802d8717aeb76ffc3f3d2dcdf68e78f4ca",
            "filename": "test/e2e/app-dir/app-prefetch/app/components/link-accordion.tsx",
            "status": "added",
            "additions": 26,
            "deletions": 0,
            "changes": 26,
            "blob_url": "https://github.com/vercel/next.js/blob/9c053332ccbc17220982f169b94c7cbdca0a648e/test%2Fe2e%2Fapp-dir%2Fapp-prefetch%2Fapp%2Fcomponents%2Flink-accordion.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/9c053332ccbc17220982f169b94c7cbdca0a648e/test%2Fe2e%2Fapp-dir%2Fapp-prefetch%2Fapp%2Fcomponents%2Flink-accordion.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fapp-prefetch%2Fapp%2Fcomponents%2Flink-accordion.tsx?ref=9c053332ccbc17220982f169b94c7cbdca0a648e",
            "patch": "@@ -0,0 +1,26 @@\n+'use client'\n+\n+import Link from 'next/link'\n+import { useState } from 'react'\n+\n+export function LinkAccordion({ href, children, id }) {\n+  const [isVisible, setIsVisible] = useState(false)\n+  return (\n+    <>\n+      <input\n+        type=\"checkbox\"\n+        checked={isVisible}\n+        onChange={() => setIsVisible(!isVisible)}\n+        data-link-accordion={href}\n+        id={`accordion-${id}`}\n+      />\n+      {isVisible ? (\n+        <Link href={href} id={id}>\n+          {children}\n+        </Link>\n+      ) : (\n+        <>{children} (link is hidden)</>\n+      )}\n+    </>\n+  )\n+}"
        },
        {
            "sha": "f1a07adea7dc5e2aed18a5aed6826ff278188dff",
            "filename": "test/e2e/app-dir/app-prefetch/app/dashboard/loading.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/9c053332ccbc17220982f169b94c7cbdca0a648e/test%2Fe2e%2Fapp-dir%2Fapp-prefetch%2Fapp%2Fdashboard%2Floading.js",
            "raw_url": "https://github.com/vercel/next.js/raw/9c053332ccbc17220982f169b94c7cbdca0a648e/test%2Fe2e%2Fapp-dir%2Fapp-prefetch%2Fapp%2Fdashboard%2Floading.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fapp-prefetch%2Fapp%2Fdashboard%2Floading.js?ref=9c053332ccbc17220982f169b94c7cbdca0a648e",
            "patch": "@@ -1,3 +1,3 @@\n export default function DashboardLoading() {\n-  return <>Loading dashboard...</>\n+  return <>Loading dashboard... [dashboard-prefetch-sentinel]</>\n }"
        },
        {
            "sha": "eec62d7df32ae86a071472d9086d595b94638e14",
            "filename": "test/e2e/app-dir/app-prefetch/app/dashboard/page.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/9c053332ccbc17220982f169b94c7cbdca0a648e/test%2Fe2e%2Fapp-dir%2Fapp-prefetch%2Fapp%2Fdashboard%2Fpage.js",
            "raw_url": "https://github.com/vercel/next.js/raw/9c053332ccbc17220982f169b94c7cbdca0a648e/test%2Fe2e%2Fapp-dir%2Fapp-prefetch%2Fapp%2Fdashboard%2Fpage.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fapp-prefetch%2Fapp%2Fdashboard%2Fpage.js?ref=9c053332ccbc17220982f169b94c7cbdca0a648e",
            "patch": "@@ -13,7 +13,7 @@ export default async function DashboardPage(props) {\n \n   return (\n     <>\n-      <p id=\"dashboard-page\">{message}</p>\n+      <p id=\"dashboard-page\">{message} [dashboard-prefetch-sentinel]</p>\n       <Link href=\"/static-page\" id=\"to-static-page\">\n         To Static Page\n       </Link>"
        },
        {
            "sha": "3cea305aa0f9ceaa23648965c05a87c93decce33",
            "filename": "test/e2e/app-dir/app-prefetch/app/page.js",
            "status": "modified",
            "additions": 16,
            "deletions": 11,
            "changes": 27,
            "blob_url": "https://github.com/vercel/next.js/blob/9c053332ccbc17220982f169b94c7cbdca0a648e/test%2Fe2e%2Fapp-dir%2Fapp-prefetch%2Fapp%2Fpage.js",
            "raw_url": "https://github.com/vercel/next.js/raw/9c053332ccbc17220982f169b94c7cbdca0a648e/test%2Fe2e%2Fapp-dir%2Fapp-prefetch%2Fapp%2Fpage.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fapp-prefetch%2Fapp%2Fpage.js?ref=9c053332ccbc17220982f169b94c7cbdca0a648e",
            "patch": "@@ -1,22 +1,27 @@\n-import Link from 'next/link'\n+import { LinkAccordion } from './components/link-accordion'\n+\n export default function HomePage() {\n   return (\n     <>\n-      <Link href=\"/dashboard\" id=\"to-dashboard\">\n+      <p id=\"home-page\">Home Page [prefetch-sentinel]</p>\n+      <LinkAccordion href=\"/dashboard\" id=\"to-dashboard\">\n         To Dashboard\n-      </Link>\n-      <Link href=\"/static-page\" id=\"to-static-page\">\n+      </LinkAccordion>\n+      <LinkAccordion href=\"/static-page\" id=\"to-static-page\">\n         To Static Page\n-      </Link>\n-      <Link href=\"/static-page-no-prefetch\" id=\"to-static-page-no-prefetch\">\n+      </LinkAccordion>\n+      <LinkAccordion\n+        href=\"/static-page-no-prefetch\"\n+        id=\"to-static-page-no-prefetch\"\n+      >\n         To Static Page No Prefetch\n-      </Link>\n-      <Link href=\"/dynamic-page\" id=\"to-dynamic-page-no-params\">\n+      </LinkAccordion>\n+      <LinkAccordion href=\"/dynamic-page\" id=\"to-dynamic-page-no-params\">\n         To Dynamic Page\n-      </Link>\n-      <Link href=\"/prefetch-auto/foobar\" id=\"to-dynamic-page\">\n+      </LinkAccordion>\n+      <LinkAccordion href=\"/prefetch-auto/foobar\" id=\"to-dynamic-page\">\n         To Dynamic Slug Page\n-      </Link>\n+      </LinkAccordion>\n       <a href=\"/static-page\" id=\"to-static-page-hard\">\n         Hard Nav to Static Page\n       </a>"
        },
        {
            "sha": "fff51f9434186c89acfbbb5af51c02dee543d84b",
            "filename": "test/e2e/app-dir/app-prefetch/app/static-page-no-prefetch/page.js",
            "status": "modified",
            "additions": 6,
            "deletions": 4,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/9c053332ccbc17220982f169b94c7cbdca0a648e/test%2Fe2e%2Fapp-dir%2Fapp-prefetch%2Fapp%2Fstatic-page-no-prefetch%2Fpage.js",
            "raw_url": "https://github.com/vercel/next.js/raw/9c053332ccbc17220982f169b94c7cbdca0a648e/test%2Fe2e%2Fapp-dir%2Fapp-prefetch%2Fapp%2Fstatic-page-no-prefetch%2Fpage.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fapp-prefetch%2Fapp%2Fstatic-page-no-prefetch%2Fpage.js?ref=9c053332ccbc17220982f169b94c7cbdca0a648e",
            "patch": "@@ -1,13 +1,15 @@\n-import Link from 'next/link'\n+import { LinkAccordion } from '../components/link-accordion'\n \n export default async function Page() {\n   return (\n     <>\n-      <p id=\"static-page-no-prefetch\">Static Page No Prefetch</p>\n+      <p id=\"static-page-no-prefetch\">\n+        Static Page No Prefetch [prefetch-sentinel]\n+      </p>\n       <p>\n-        <Link href=\"/\" id=\"to-home\">\n+        <LinkAccordion href=\"/\" id=\"to-home\">\n           To home\n-        </Link>\n+        </LinkAccordion>\n       </p>\n     </>\n   )"
        },
        {
            "sha": "a9624289559c1594fc59b19ef800ffb778453e41",
            "filename": "test/e2e/app-dir/app-prefetch/app/static-page/page.js",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/9c053332ccbc17220982f169b94c7cbdca0a648e/test%2Fe2e%2Fapp-dir%2Fapp-prefetch%2Fapp%2Fstatic-page%2Fpage.js",
            "raw_url": "https://github.com/vercel/next.js/raw/9c053332ccbc17220982f169b94c7cbdca0a648e/test%2Fe2e%2Fapp-dir%2Fapp-prefetch%2Fapp%2Fstatic-page%2Fpage.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fapp-prefetch%2Fapp%2Fstatic-page%2Fpage.js?ref=9c053332ccbc17220982f169b94c7cbdca0a648e",
            "patch": "@@ -1,19 +1,19 @@\n-import Link from 'next/link'\n+import { LinkAccordion } from '../components/link-accordion'\n import { BackButton } from './back-button'\n \n export default async function Page() {\n   return (\n     <>\n-      <p id=\"static-page\">Static Page</p>\n+      <p id=\"static-page\">Static Page [prefetch-sentinel]</p>\n       <p>\n-        <Link href=\"/\" id=\"to-home\">\n+        <LinkAccordion href=\"/\" id=\"to-home\">\n           To home\n-        </Link>\n+        </LinkAccordion>\n       </p>\n       <p>\n-        <Link href=\"/static-page\" prefetch>\n-          To Same Page\n-        </Link>\n+        <LinkAccordion href=\"/static-page\" id=\"to-same-page\">\n+          To Static Page (self)\n+        </LinkAccordion>\n       </p>\n       <p>\n         <BackButton />"
        },
        {
            "sha": "be510febeae7128f587ebd181f5b9a06aebdd612",
            "filename": "test/e2e/app-dir/app-prefetch/prefetching.stale-times.test.ts",
            "status": "modified",
            "additions": 267,
            "deletions": 182,
            "changes": 449,
            "blob_url": "https://github.com/vercel/next.js/blob/9c053332ccbc17220982f169b94c7cbdca0a648e/test%2Fe2e%2Fapp-dir%2Fapp-prefetch%2Fprefetching.stale-times.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/9c053332ccbc17220982f169b94c7cbdca0a648e/test%2Fe2e%2Fapp-dir%2Fapp-prefetch%2Fprefetching.stale-times.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fapp-prefetch%2Fprefetching.stale-times.test.ts?ref=9c053332ccbc17220982f169b94c7cbdca0a648e",
            "patch": "@@ -1,14 +1,18 @@\n-import { nextTestSetup } from 'e2e-utils'\n-import { retry, waitFor } from 'next-test-utils'\n+import { FileRef, nextTestSetup } from 'e2e-utils'\n+import { createRouterAct } from './router-act'\n+import { createTimeController } from './test-utils'\n+import { join } from 'path'\n \n describe('app dir - prefetching (custom staleTime)', () => {\n   const { next, isNextDev } = nextTestSetup({\n-    files: __dirname,\n+    files: {\n+      app: new FileRef(join(__dirname, 'app')),\n+    },\n     skipDeployment: true,\n     nextConfig: {\n       experimental: {\n         staleTimes: {\n-          static: 10,\n+          static: 30, // Minimum enforced by clientSegmentCache is 30 seconds\n           dynamic: 5,\n         },\n       },\n@@ -21,218 +25,299 @@ describe('app dir - prefetching (custom staleTime)', () => {\n   }\n \n   it('should not fetch again when a static page was prefetched when navigating to it twice', async () => {\n-    const browser = await next.browser('/404')\n-    let requests: string[] = []\n-\n-    browser.on('request', (req) => {\n-      requests.push(new URL(req.url()).pathname)\n-    })\n-    await browser.eval('location.href = \"/\"')\n-\n-    await retry(async () => {\n-      expect(\n-        requests.filter((request) => request === '/static-page')\n-      ).toHaveLength(1)\n+    let act: ReturnType<typeof createRouterAct>\n+    const browser = await next.browser('/', {\n+      beforePageLoad(page) {\n+        act = createRouterAct(page)\n+      },\n     })\n \n-    await browser\n-      .elementByCss('#to-static-page')\n-      .click()\n-      .waitForElementByCss('#static-page')\n-\n-    await browser\n-      .elementByCss('#to-home')\n-      // Go back to home page\n-      .click()\n-      // Wait for homepage to load\n-      .waitForElementByCss('#to-static-page')\n-      // Click on the link to the static page again\n-      .click()\n-      // Wait for the static page to load again\n-      .waitForElementByCss('#static-page')\n-\n-    await retry(async () => {\n-      expect(\n-        requests.filter((request) => request === '/static-page')\n-      ).toHaveLength(1)\n-    })\n+    // Reveal the link to trigger prefetch and wait for it to complete\n+    const link = await act(\n+      async () => {\n+        const reveal = await browser.elementByCss('#accordion-to-static-page')\n+        await reveal.click()\n+        await browser.waitForElementByCss('#to-static-page')\n+        return await browser.elementByCss('#to-static-page')\n+      },\n+      { includes: 'Static Page [prefetch-sentinel]' }\n+    )\n+\n+    // Navigate to static page - should use prefetched data with no additional requests\n+    await act(async () => {\n+      await link.click()\n+      await browser.waitForElementByCss('#static-page')\n+      const staticPageText = await browser.elementByCss('#static-page').text()\n+      expect(staticPageText).toBe('Static Page [prefetch-sentinel]')\n+    }, 'no-requests')\n+\n+    // Reveal the \"to-home\" link and navigate back\n+    // Note: Not using act() here because behavior differs between cache models.\n+    // With clientSegmentCache, revealing may trigger a prefetch. Without it, home is already\n+    // cached so no prefetch occurs. Either way, navigation works with cached data.\n+    const reveal = await browser.elementByCss('#accordion-to-home')\n+    await reveal.click()\n+    const homeLink = await browser.waitForElementByCss('#to-home')\n+    await homeLink.click()\n+    await browser.waitForElementByCss('#accordion-to-static-page')\n+\n+    // Reveal the static page link again since accordion is hidden after navigation\n+    await browser.elementByCss('#accordion-to-static-page').click()\n+    await browser.waitForElementByCss('#to-static-page')\n+\n+    // Navigate to static page again using the accordion - should still use cached data with no additional requests\n+    await act(async () => {\n+      await browser.elementByCss('#to-static-page').click()\n+      await browser.waitForElementByCss('#static-page')\n+      const staticPageText = await browser.elementByCss('#static-page').text()\n+      expect(staticPageText).toBe('Static Page [prefetch-sentinel]')\n+    }, 'no-requests')\n   })\n \n   it('should fetch again when a static page was prefetched when navigating to it after the stale time has passed', async () => {\n-    const browser = await next.browser('/404')\n-    let requests: string[] = []\n-\n-    browser.on('request', (req) => {\n-      requests.push(new URL(req.url()).pathname)\n+    let act: ReturnType<typeof createRouterAct>\n+    const timeController = createTimeController()\n+    const browser = await next.browser('/', {\n+      beforePageLoad(page) {\n+        act = createRouterAct(page)\n+      },\n     })\n-    await browser.eval('location.href = \"/\"')\n \n-    await retry(async () => {\n-      expect(\n-        requests.filter((request) => request === '/static-page')\n-      ).toHaveLength(1)\n-    })\n+    // Install time controller\n+    await timeController.install(browser)\n \n-    await browser\n-      .elementByCss('#to-static-page')\n-      .click()\n-      .waitForElementByCss('#static-page')\n-\n-    const linkToStaticPage = await browser\n-      .elementByCss('#to-home')\n-      // Go back to home page\n-      .click()\n-      // Wait for homepage to load\n-      .waitForElementByCss('#to-static-page')\n-\n-    // Wait for the stale time to pass.\n-    await waitFor(10000)\n-    // Click on the link to the static page again\n-    await linkToStaticPage.click()\n-    // Wait for the static page to load again\n-    await browser.waitForElementByCss('#static-page')\n-\n-    await retry(async () => {\n-      expect(\n-        requests.filter((request) => request === '/static-page')\n-      ).toHaveLength(2)\n-    })\n+    // Reveal the static-page link to trigger prefetch and wait for it to complete\n+    let link = await act(\n+      async () => {\n+        const reveal = await browser.elementByCss('#accordion-to-static-page')\n+        await reveal.click()\n+        await browser.waitForElementByCss('#to-static-page')\n+        return await browser.elementByCss('#to-static-page')\n+      },\n+      { includes: 'Static Page [prefetch-sentinel]' }\n+    )\n+\n+    // Navigate to static page - should use prefetched data with no additional requests\n+    await act(async () => {\n+      await link.click()\n+      await browser.waitForElementByCss('#static-page')\n+    }, 'no-requests')\n+\n+    // Reveal the \"to-home\" link and navigate back\n+    const reveal = await browser.elementByCss('#accordion-to-home')\n+    await reveal.click()\n+    const homeLink = await browser.waitForElementByCss('#to-home')\n+    await homeLink.click()\n+    await browser.waitForElementByCss('#accordion-to-static-page')\n+\n+    // Advance time past the stale time\n+    await timeController.advance(browser, 31000)\n+\n+    // Reveal the static-page link to trigger prefetch and wait for it to complete\n+    link = await act(\n+      async () => {\n+        const reveal = await browser.elementByCss('#accordion-to-static-page')\n+        await reveal.click()\n+        await browser.waitForElementByCss('#to-static-page')\n+        return await browser.elementByCss('#to-static-page')\n+      },\n+      { includes: 'Static Page [prefetch-sentinel]' }\n+    )\n+\n+    // Navigate to static page - should use prefetched data with no additional requests\n+    await act(async () => {\n+      await link.click()\n+      await browser.waitForElementByCss('#static-page')\n+    }, 'no-requests')\n   })\n \n   it('should not re-fetch cached data when navigating back to a route group', async () => {\n-    const browser = await next.browser('/prefetch-auto-route-groups')\n-    // once the page has loaded, we expect a data fetch\n-    expect(await browser.elementById('count').text()).toBe('1')\n-\n-    // once navigating to a sub-page, we expect another data fetch\n-    await browser\n-      .elementByCss(\"[href='/prefetch-auto-route-groups/sub/foo']\")\n-      .click()\n-\n-    // navigating back to the route group page shouldn't trigger any data fetch\n-    await browser.elementByCss(\"[href='/prefetch-auto-route-groups']\").click()\n+    let act: ReturnType<typeof createRouterAct>\n+    const browser = await next.browser('/prefetch-auto-route-groups', {\n+      beforePageLoad(page) {\n+        act = createRouterAct(page)\n+      },\n+    })\n \n-    // confirm that the dashboard page is still rendering the stale fetch count, as it should be cached\n+    // Once the page has loaded, we expect a data fetch (initial page load)\n     expect(await browser.elementById('count').text()).toBe('1')\n \n-    // navigating to a new sub-page, we expect another data fetch\n-    await browser\n-      .elementByCss(\"[href='/prefetch-auto-route-groups/sub/bar']\")\n-      .click()\n+    // Navigate to a sub-page - this will trigger a data fetch\n+    await act(async () => {\n+      await browser\n+        .elementByCss(\"[href='/prefetch-auto-route-groups/sub/foo']\")\n+        .click()\n+    })\n \n-    // finally, going back to the route group page shouldn't trigger any data fetch\n-    await browser.elementByCss(\"[href='/prefetch-auto-route-groups']\").click()\n+    // Navigate back to the route group page - should use cached data with no additional fetch\n+    await act(async () => {\n+      await browser.elementByCss(\"[href='/prefetch-auto-route-groups']\").click()\n+      // Confirm that the dashboard page is still rendering the stale fetch count, as it should be cached\n+      expect(await browser.elementById('count').text()).toBe('1')\n+    }, 'no-requests')\n+\n+    // Navigate to a new sub-page - this will trigger another data fetch\n+    await act(async () => {\n+      await browser\n+        .elementByCss(\"[href='/prefetch-auto-route-groups/sub/bar']\")\n+        .click()\n+    })\n \n-    // confirm that the dashboard page is still rendering the stale fetch count, as it should be cached\n-    expect(await browser.elementById('count').text()).toBe('1')\n+    // Finally, go back to the route group page - should use cached data with no additional fetch\n+    await act(async () => {\n+      await browser.elementByCss(\"[href='/prefetch-auto-route-groups']\").click()\n+      // Confirm that the dashboard page is still rendering the stale fetch count, as it should be cached\n+      expect(await browser.elementById('count').text()).toBe('1')\n+    }, 'no-requests')\n \n+    // Reload the page to get the accurate total number of fetches\n     await browser.refresh()\n-    // reloading the page, we should now get an accurate total number of fetches\n-    // the initial fetch, 2 sub-page fetches, and a final fetch when reloading the page\n+    // The initial fetch, 2 sub-page fetches, and a final fetch when reloading the page\n     expect(await browser.elementById('count').text()).toBe('4')\n   })\n \n   it('should fetch again when the initially visited static page is visited after the stale time has passed', async () => {\n-    const browser = await next.browser('/404')\n-    let requests: string[] = []\n-\n-    browser.on('request', (req) => {\n-      const path = new URL(req.url()).pathname\n-      const headers = req.headers()\n-\n-      if (headers['rsc']) {\n-        requests.push(path)\n-      }\n+    let act: ReturnType<typeof createRouterAct>\n+    const timeController = createTimeController()\n+    const browser = await next.browser('/static-page-no-prefetch', {\n+      beforePageLoad(page) {\n+        act = createRouterAct(page)\n+      },\n     })\n \n-    await browser.eval('location.href = \"/static-page-no-prefetch\"')\n-\n-    await browser\n-      .elementByCss('#to-home')\n-      .click()\n-      .waitForElementByCss('#to-static-page')\n+    // Install time controller\n+    await timeController.install(browser)\n \n-    // Wait for the stale time to pass.\n-    await waitFor(10000)\n-\n-    await browser.elementByCss('#to-static-page-no-prefetch').click()\n-\n-    // Wait for the static page to load again\n+    // Wait for the page to load (initial navigation request happened during browser load)\n     await browser.waitForElementByCss('#static-page-no-prefetch')\n \n-    await retry(async () => {\n-      expect(\n-        requests.filter((request) => request === '/static-page-no-prefetch')\n-      ).toHaveLength(1)\n-    })\n+    // Reveal the home link and wait for prefetch to complete, then navigate\n+    const homeLink = await act(\n+      async () => {\n+        const reveal = await browser.elementByCss('#accordion-to-home')\n+        await reveal.click()\n+        await browser.waitForElementByCss('#to-home')\n+        return await browser.elementByCss('#to-home')\n+      },\n+      { includes: 'Home Page [prefetch-sentinel]' }\n+    )\n+\n+    // Navigate to home - no additional requests since we just prefetched\n+    await homeLink.click()\n+    await browser.waitForElementByCss('#accordion-to-static-page')\n+\n+    // Advance time past the stale time\n+    await timeController.advance(browser, 31000)\n+\n+    // Reveal the link to static-page-no-prefetch and wait for prefetch\n+    const link = await act(\n+      async () => {\n+        const reveal = await browser.elementByCss(\n+          '#accordion-to-static-page-no-prefetch'\n+        )\n+        await reveal.click()\n+        await browser.waitForElementByCss('#to-static-page-no-prefetch')\n+        return await browser.elementByCss('#to-static-page-no-prefetch')\n+      },\n+      { includes: 'Static Page No Prefetch [prefetch-sentinel]' }\n+    )\n+\n+    // Navigate back to static-page-no-prefetch - should use the fresh prefetch data\n+    await act(async () => {\n+      await link.click()\n+      await browser.waitForElementByCss('#static-page-no-prefetch')\n+      const staticPageText = await browser\n+        .elementByCss('#static-page-no-prefetch')\n+        .text()\n+      expect(staticPageText).toBe('Static Page No Prefetch [prefetch-sentinel]')\n+    }, 'no-requests')\n   })\n \n   it('should renew the stale time after refetching expired RSC data', async () => {\n-    const browser = await next.browser('/404')\n-    let requests: string[] = []\n-\n-    browser.on('request', (req) => {\n-      requests.push(new URL(req.url()).pathname)\n-    })\n-\n-    // Navigate to home and wait for static page to be prefetched\n-    await browser.eval('location.href = \"/\"')\n-\n-    await retry(async () => {\n-      expect(\n-        requests.filter((request) => request === '/static-page')\n-      ).toHaveLength(1)\n-    })\n-\n-    // Navigate to static page (should use cached data)\n-    await browser\n-      .elementByCss('#to-static-page')\n-      .click()\n-      .waitForElementByCss('#static-page')\n-\n-    // Go back to home\n-    await browser\n-      .elementByCss('#to-home')\n-      .click()\n-      .waitForElementByCss('#to-static-page')\n-\n-    // Wait for stale time to expire (10 seconds)\n-    await waitFor(10000)\n-\n-    // Navigate to static page again (should refetch due to expired cache)\n-    await browser\n-      .elementByCss('#to-static-page')\n-      .click()\n-      .waitForElementByCss('#static-page')\n-\n-    // Verify that refetch happened\n-    await retry(async () => {\n-      expect(\n-        requests.filter((request) => request === '/static-page')\n-      ).toHaveLength(2)\n+    let act: ReturnType<typeof createRouterAct>\n+    const timeController = createTimeController()\n+    const browser = await next.browser('/', {\n+      beforePageLoad(page) {\n+        act = createRouterAct(page)\n+      },\n     })\n \n-    // Go back to home\n-    await browser\n-      .elementByCss('#to-home')\n-      .click()\n-      .waitForElementByCss('#to-static-page')\n+    // Install time controller\n+    await timeController.install(browser)\n \n-    // Wait less than the stale time (5 seconds - should still be fresh)\n-    await waitFor(5000)\n+    // Reveal the static-page link to trigger prefetch and wait for it to complete\n+    let link = await act(\n+      async () => {\n+        const reveal = await browser.elementByCss('#accordion-to-static-page')\n+        await reveal.click()\n+        await browser.waitForElementByCss('#to-static-page')\n+        return await browser.elementByCss('#to-static-page')\n+      },\n+      { includes: 'Static Page [prefetch-sentinel]' }\n+    )\n+\n+    // Navigate to static page (should use prefetched data with no additional requests)\n+    await act(async () => {\n+      await link.click()\n+      await browser.waitForElementByCss('#static-page')\n+    }, 'no-requests')\n+\n+    // Reveal the \"to-home\" link and navigate back\n+    // Note: Not using act() here because behavior differs between cache models.\n+    // With clientSegmentCache, revealing may trigger a prefetch. Without it, home is already\n+    // cached so no prefetch occurs. Either way, navigation works with cached data.\n+    const reveal = await browser.elementByCss('#accordion-to-home')\n+    await reveal.click()\n+    const homeLink = await browser.waitForElementByCss('#to-home')\n+    await homeLink.click()\n+    await browser.waitForElementByCss('#accordion-to-static-page')\n+\n+    // Advance time past the stale time\n+    await timeController.advance(browser, 31000)\n+\n+    // Reveal the static-page link to trigger prefetch and wait for it to complete\n+    link = await act(\n+      async () => {\n+        const reveal = await browser.elementByCss('#accordion-to-static-page')\n+        await reveal.click()\n+        await browser.waitForElementByCss('#to-static-page')\n+        return await browser.elementByCss('#to-static-page')\n+      },\n+      { includes: 'Static Page [prefetch-sentinel]' }\n+    )\n+\n+    // Navigate to static page again (should use freshly prefetched data with no additional requests)\n+    await act(async () => {\n+      await link.click()\n+      await browser.waitForElementByCss('#static-page')\n+    }, 'no-requests')\n+\n+    // Go back to home (reveal the link and navigate)\n+    // Note: Not using act() here because behavior differs between cache models.\n+    const reveal2 = await browser.elementByCss('#accordion-to-home')\n+    await reveal2.click()\n+    const homeLink2 = await browser.waitForElementByCss('#to-home')\n+    await homeLink2.click()\n+    await browser.waitForElementByCss('#accordion-to-static-page')\n+\n+    // Advance time but not past the stale time (20 seconds < 30 second stale time - should still be fresh)\n+    await timeController.advance(browser, 20000)\n+\n+    // Reveal the static-page link to trigger prefetch (should use cached data, not refetch)\n+    link = await act(async () => {\n+      const reveal = await browser.elementByCss('#accordion-to-static-page')\n+      await reveal.click()\n+      await browser.waitForElementByCss('#to-static-page')\n+      return await browser.elementByCss('#to-static-page')\n+    }, 'no-requests')\n \n     // Navigate to static page again (should NOT refetch - stale time should be renewed)\n-    await browser\n-      .elementByCss('#to-static-page')\n-      .click()\n-      .waitForElementByCss('#static-page')\n-\n-    // This should still be 2 - no new request should have been made\n-    // If this fails, it means the stale time was not renewed after the refetch\n-    await retry(async () => {\n-      expect(\n-        requests.filter((request) => request === '/static-page')\n-      ).toHaveLength(2)\n-    })\n+    // If this assertion passes, it means the stale time was properly renewed after the refetch\n+    await act(async () => {\n+      await link.click()\n+      await browser.waitForElementByCss('#static-page')\n+      const staticPageText = await browser.elementByCss('#static-page').text()\n+      expect(staticPageText).toBe('Static Page [prefetch-sentinel]')\n+    }, 'no-requests')\n   })\n })"
        },
        {
            "sha": "4c9492d98dff76d3c92aa3e6ce1269abd7d067fe",
            "filename": "test/e2e/app-dir/app-prefetch/prefetching.test.ts",
            "status": "modified",
            "additions": 167,
            "deletions": 289,
            "changes": 456,
            "blob_url": "https://github.com/vercel/next.js/blob/9c053332ccbc17220982f169b94c7cbdca0a648e/test%2Fe2e%2Fapp-dir%2Fapp-prefetch%2Fprefetching.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/9c053332ccbc17220982f169b94c7cbdca0a648e/test%2Fe2e%2Fapp-dir%2Fapp-prefetch%2Fprefetching.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fapp-prefetch%2Fprefetching.test.ts?ref=9c053332ccbc17220982f169b94c7cbdca0a648e",
            "patch": "@@ -1,37 +1,18 @@\n-import { nextTestSetup } from 'e2e-utils'\n-import { check, waitFor, retry } from 'next-test-utils'\n+import { FileRef, nextTestSetup } from 'e2e-utils'\n+import { waitFor, retry } from 'next-test-utils'\n import { NEXT_RSC_UNION_QUERY } from 'next/dist/client/components/app-router-headers'\n import { computeCacheBustingSearchParam } from 'next/dist/shared/lib/router/utils/cache-busting-search-param'\n-\n-const browserConfigWithFixedTime = {\n-  beforePageLoad: (page) => {\n-    page.addInitScript(() => {\n-      const startTime = new Date()\n-      const fixedTime = new Date('2023-04-17T00:00:00Z')\n-\n-      // Override the Date constructor\n-      // @ts-ignore\n-      // eslint-disable-next-line no-native-reassign\n-      Date = class extends Date {\n-        constructor() {\n-          super()\n-          // @ts-ignore\n-          return new startTime.constructor(fixedTime)\n-        }\n-\n-        static now() {\n-          return fixedTime.getTime()\n-        }\n-      }\n-    })\n-  },\n-}\n+import { createRouterAct } from './router-act'\n+import { createTimeController } from './test-utils'\n+import { join } from 'path'\n \n const itHeaded = process.env.HEADLESS ? it.skip : it\n \n describe('app dir - prefetching', () => {\n   const { next, isNextDev, isNextDeploy } = nextTestSetup({\n-    files: __dirname,\n+    files: {\n+      app: new FileRef(join(__dirname, 'app')),\n+    },\n   })\n \n   // TODO: re-enable for dev after https://vercel.slack.com/archives/C035J346QQL/p1663822388387959 is resolved (Sep 22nd 2022)\n@@ -45,15 +26,30 @@ describe('app dir - prefetching', () => {\n   })\n \n   it('should show layout eagerly when prefetched with loading one level down', async () => {\n-    const browser = await next.browser('/', browserConfigWithFixedTime)\n-    // Ensure the page is prefetched\n-    await waitFor(1000)\n+    let act: ReturnType<typeof createRouterAct>\n+    const timeController = createTimeController()\n+    const browser = await next.browser('/', {\n+      beforePageLoad(page) {\n+        act = createRouterAct(page)\n+      },\n+    })\n+\n+    await timeController.install(browser)\n+\n+    // Reveal the dashboard accordion and wait for prefetch to complete\n+    const dashboardLink = await act(\n+      async () => {\n+        const reveal = await browser.elementByCss('#accordion-to-dashboard')\n+        await reveal.click()\n+        await browser.waitForElementByCss('#to-dashboard')\n+        return await browser.elementByCss('#to-dashboard')\n+      },\n+      { includes: '[dashboard-prefetch-sentinel]' }\n+    )\n \n     const before = Date.now()\n-    await browser\n-      .elementByCss('#to-dashboard')\n-      .click()\n-      .waitForElementByCss('#dashboard-layout')\n+    await dashboardLink.click()\n+    await browser.waitForElementByCss('#dashboard-layout')\n     const after = Date.now()\n     const timeToComplete = after - before\n \n@@ -66,15 +62,15 @@ describe('app dir - prefetching', () => {\n     await browser.waitForElementByCss('#dashboard-page')\n \n     expect(await browser.waitForElementByCss('#dashboard-page').text()).toBe(\n-      'Welcome to the dashboard'\n+      'Welcome to the dashboard [dashboard-prefetch-sentinel]'\n     )\n   })\n \n   it('should not have prefetch error for static path', async () => {\n     const browser = await next.browser('/')\n-    await browser.eval('window.nd.router.prefetch(\"/dashboard/123\")')\n+    await browser.eval('window.next.router.prefetch(\"/dashboard/123\")')\n     await waitFor(3000)\n-    await browser.eval('window.nd.router.push(\"/dashboard/123\")')\n+    await browser.eval('window.next.router.push(\"/dashboard/123\")')\n     expect(next.cliOutput).not.toContain('ReferenceError')\n     expect(next.cliOutput).not.toContain('is not defined')\n   })\n@@ -116,89 +112,51 @@ describe('app dir - prefetching', () => {\n   })\n \n   it('should not fetch again when a static page was prefetched', async () => {\n-    const browser = await next.browser('/404', browserConfigWithFixedTime)\n-    let requests: string[] = []\n-\n-    browser.on('request', (req) => {\n-      requests.push(new URL(req.url()).pathname)\n+    let act: ReturnType<typeof createRouterAct>\n+    const timeController = createTimeController()\n+    const browser = await next.browser('/404', {\n+      beforePageLoad(page) {\n+        act = createRouterAct(page)\n+      },\n     })\n-    await browser.eval('location.href = \"/\"')\n \n-    await browser.eval(\n-      'window.nd.router.prefetch(\"/static-page\", {kind: \"auto\"})'\n+    await browser.eval('location.href = \"/\"')\n+    await browser.waitForElementByCss('#accordion-to-static-page')\n+    await timeController.install(browser)\n+\n+    // Reveal the static-page accordion to trigger prefetch\n+    await act(\n+      async () => {\n+        const reveal = await browser.elementByCss('#accordion-to-static-page')\n+        await reveal.click()\n+        await browser.waitForElementByCss('#to-static-page')\n+      },\n+      { includes: 'Static Page [prefetch-sentinel]' }\n     )\n \n-    await check(() => {\n-      return requests.some(\n-        (req) =>\n-          req.includes('static-page') && !req.includes(NEXT_RSC_UNION_QUERY)\n-      )\n-        ? 'success'\n-        : JSON.stringify(requests)\n-    }, 'success')\n+    // Navigate to static page using cached prefetch\n+    await act(async () => {\n+      await browser.elementByCss('#to-static-page').click()\n+      await browser.waitForElementByCss('#static-page')\n+    }, 'no-requests')\n \n-    await browser\n-      .elementByCss('#to-static-page')\n-      .click()\n-      .waitForElementByCss('#static-page')\n+    // Return to the home page - reveal accordion and navigate\n+    const reveal = await browser.elementByCss('#accordion-to-home')\n+    await reveal.click()\n+    const homeLink = await browser.waitForElementByCss('#to-home')\n \n-    expect(\n-      requests.filter((request) => request === '/static-page').length\n-    ).toBe(1)\n+    await homeLink.click()\n+    await browser.waitForElementByCss('#accordion-to-static-page')\n \n-    // return to the home page\n-    await browser.elementByCss('#to-home').click()\n+    // Reveal the static-page accordion again - should not trigger new prefetch (cache still fresh)\n+    await browser.elementByCss('#accordion-to-static-page').click()\n     await browser.waitForElementByCss('#to-static-page')\n-    // there shouldn't be any additional prefetches\n-    expect(\n-      requests.filter((request) => request === '/static-page').length\n-    ).toBe(1)\n-\n-    // navigate to the static page again\n-    await browser.elementByCss('#to-static-page').click()\n-    await browser.waitForElementByCss('#static-page')\n \n-    // there still should only be the initial request to the static page\n-    expect(\n-      requests.filter((request) => request === '/static-page').length\n-    ).toBe(1)\n-  })\n-\n-  it('should calculate `_rsc` query based on `Next-Url`', async () => {\n-    const browser = await next.browser('/404', browserConfigWithFixedTime)\n-    let staticPageRequests: string[] = []\n-\n-    browser.on('request', (req) => {\n-      const url = new URL(req.url())\n-      if (url.toString().includes(`/static-page?${NEXT_RSC_UNION_QUERY}=`)) {\n-        staticPageRequests.push(`${url.pathname}${url.search}`)\n-      }\n-    })\n-    await browser.eval('location.href = \"/\"')\n-    await browser.eval(\n-      `window.nd.router.prefetch(\"/static-page\", {kind: \"auto\"})`\n-    )\n-    await check(() => {\n-      return staticPageRequests.length === 1\n-        ? 'success'\n-        : JSON.stringify(staticPageRequests)\n-    }, 'success')\n-\n-    // Unable to clear router cache so mpa navigation\n-    await browser.eval('location.href = \"/dashboard\"')\n-    await browser.eval(\n-      `window.nd.router.prefetch(\"/static-page\", {kind: \"auto\"})`\n-    )\n-    await check(() => {\n-      return staticPageRequests.length === 2\n-        ? 'success'\n-        : JSON.stringify(staticPageRequests)\n-    }, 'success')\n-\n-    expect(staticPageRequests[0]).toMatch('/static-page?_rsc=')\n-    expect(staticPageRequests[1]).toMatch('/static-page?_rsc=')\n-    // `_rsc` does not match because it depends on the `Next-Url`\n-    expect(staticPageRequests[0]).not.toBe(staticPageRequests[1])\n+    // Navigate to the static page again using cached data\n+    await act(async () => {\n+      await browser.elementByCss('#to-static-page').click()\n+      await browser.waitForElementByCss('#static-page')\n+    }, 'no-requests')\n   })\n \n   it('should not prefetch for a bot user agent', async () => {\n@@ -214,6 +172,11 @@ describe('app dir - prefetching', () => {\n       )}\"`\n     )\n \n+    // Reveal the static-page accordion\n+    await browser.elementByCss('#accordion-to-static-page').click()\n+    await browser.waitForElementByCss('#to-static-page')\n+\n+    // Hover over the link - bot agents should not trigger prefetch\n     await browser.elementByCss('#to-static-page').moveTo()\n \n     // check five times to ensure prefetch didn't occur\n@@ -339,15 +302,36 @@ describe('app dir - prefetching', () => {\n   })\n \n   it('should immediately render the loading state for a dynamic segment when fetched from higher up in the tree', async () => {\n-    const browser = await next.browser('/')\n-    const loadingText = await browser\n-      .elementById('to-dynamic-page')\n-      .click()\n-      .waitForElementByCss('#loading-text')\n-      .text()\n+    let act: ReturnType<typeof createRouterAct>\n+    const browser = await next.browser('/', {\n+      beforePageLoad(page) {\n+        act = createRouterAct(page)\n+      },\n+    })\n \n-    expect(loadingText).toBe('Loading Prefetch Auto')\n+    // Reveal the accordion and wait for prefetch - should get loading state\n+    const link = await act(\n+      async () => {\n+        const reveal = await browser.elementByCss('#accordion-to-dynamic-page')\n+        await reveal.click()\n+        await browser.waitForElementByCss('#to-dynamic-page')\n+        return await browser.elementByCss('#to-dynamic-page')\n+      },\n+      { includes: 'Loading Prefetch Auto' }\n+    )\n \n+    // Click the link to navigate - should trigger dynamic data fetch\n+    await act(\n+      async () => {\n+        await link.click()\n+        await browser.waitForElementByCss('#loading-text')\n+        const loadingText = await browser.elementByCss('#loading-text').text()\n+        expect(loadingText).toBe('Loading Prefetch Auto')\n+      },\n+      { includes: 'prefetch-auto-page-data' }\n+    )\n+\n+    // Wait for final data to appear\n     await browser.waitForElementByCss('#prefetch-auto-page-data')\n   })\n \n@@ -372,133 +356,29 @@ describe('app dir - prefetching', () => {\n     // The space encoding of the prefetch request should be the same as the href, and should not be replaced with a +\n     await retry(async () => {\n       expect(\n-        rscRequests.filter((req) => req.includes('/?param=with%20space'))\n-      ).toHaveLength(1)\n+        rscRequests.filter((req) => req.includes('/?param=with%20space')).length\n+      ).toBeGreaterThanOrEqual(1)\n     })\n \n+    const initialRequestCount = rscRequests.filter((req) =>\n+      req.includes('/?param=with%20space')\n+    ).length\n+\n     // Click the link\n     await browser.elementById('prefetch-via-link').click()\n \n-    // Assert that we're on the homepage\n-    expect(await browser.hasElementByCssSelector('#to-dashboard')).toBe(true)\n+    // Assert that we're on the homepage (check for accordion since links are hidden)\n+    expect(\n+      await browser.hasElementByCssSelector('#accordion-to-dashboard')\n+    ).toBe(true)\n \n     await browser.waitForIdleNetwork()\n \n     // No new requests should be made since it is correctly prefetched\n     await retry(async () => {\n       expect(\n-        rscRequests.filter((req) => req.includes('/?param=with%20space'))\n-      ).toHaveLength(1)\n-    })\n-  })\n-\n-  describe('prefetch cache seeding', () => {\n-    it('should not re-fetch the initial static page if the same page is prefetched with prefetch={true}', async () => {\n-      const rscRequests = []\n-      const browser = await next.browser('/static-page', {\n-        beforePageLoad(page) {\n-          page.on('request', async (req) => {\n-            const url = new URL(req.url())\n-            if (url.pathname === '/static-page' || url.pathname === '/') {\n-              const headers = await req.allHeaders()\n-              if (headers['rsc']) {\n-                rscRequests.push(url.pathname)\n-              }\n-            }\n-          })\n-        },\n-      })\n-\n-      expect(\n-        await browser.hasElementByCssSelector('[href=\"/static-page\"]')\n-      ).toBe(true)\n-\n-      // sanity check: we should see a prefetch request to the root page\n-      await retry(async () => {\n-        expect(rscRequests.filter((req) => req === '/').length).toBe(1)\n-      })\n-\n-      // We shouldn't see any requests to the static page since the prefetch cache was seeded as part of the SSR render\n-      await retry(async () => {\n-        expect(rscRequests.filter((req) => req === '/static-page').length).toBe(\n-          0\n-        )\n-      })\n-\n-      // navigate to index\n-      await browser.elementByCss('[href=\"/\"]').click()\n-\n-      // we should be on the index page\n-      await browser.waitForElementByCss('#to-dashboard')\n-\n-      // navigate to the static page\n-      await browser.elementByCss('[href=\"/static-page\"]').click()\n-\n-      // we should be on the static page\n-      await browser.waitForElementByCss('#static-page')\n-\n-      await browser.waitForIdleNetwork()\n-\n-      // We still shouldn't see any requests since it respects the static staletime (default 5m)\n-      await retry(async () => {\n-        expect(rscRequests.filter((req) => req === '/static-page').length).toBe(\n-          0\n-        )\n-      })\n-    })\n-\n-    it('should not re-fetch the initial dynamic page if the same page is prefetched with prefetch={true}', async () => {\n-      const rscRequests = []\n-      const browser = await next.browser('/dynamic-page', {\n-        beforePageLoad(page) {\n-          page.on('request', async (req) => {\n-            const url = new URL(req.url())\n-            if (url.pathname === '/dynamic-page' || url.pathname === '/') {\n-              const headers = await req.allHeaders()\n-              if (headers['rsc']) {\n-                rscRequests.push(url.pathname)\n-              }\n-            }\n-          })\n-        },\n-      })\n-\n-      expect(\n-        await browser.hasElementByCssSelector('[href=\"/dynamic-page\"]')\n-      ).toBe(true)\n-\n-      // sanity check: we should see a prefetch request to the root page\n-      await retry(async () => {\n-        expect(rscRequests.filter((req) => req === '/').length).toBe(1)\n-      })\n-\n-      // We shouldn't see any requests to the dynamic page since the prefetch cache was seeded as part of the SSR render\n-      await retry(async () => {\n-        expect(\n-          rscRequests.filter((req) => req === '/dynamic-page').length\n-        ).toBe(0)\n-      })\n-\n-      // navigate to index\n-      await browser.elementByCss('[href=\"/\"]').click()\n-\n-      // we should be on the index page\n-      await browser.waitForElementByCss('#to-dashboard')\n-\n-      // navigate to the dynamic page\n-      await browser.elementByCss('[href=\"/dynamic-page\"]').click()\n-\n-      // we should be on the dynamic page\n-      await browser.waitForElementByCss('#dynamic-page')\n-\n-      await browser.waitForIdleNetwork()\n-\n-      // We should see a request for the dynamic page since it respects the dynamic staletime (default 0)\n-      await retry(async () => {\n-        expect(\n-          rscRequests.filter((req) => req === '/dynamic-page').length\n-        ).toBe(1)\n-      })\n+        rscRequests.filter((req) => req.includes('/?param=with%20space')).length\n+      ).toBe(initialRequestCount)\n     })\n   })\n \n@@ -517,46 +397,50 @@ describe('app dir - prefetching', () => {\n             .elementByCss(`[href=\"${basePath}/test-page/sub-page\"]`)\n             .click()\n \n-          await check(() => browser.hasElementByCssSelector('#sub-page'), true)\n+          await retry(async () => {\n+            expect(await browser.hasElementByCssSelector('#sub-page')).toBe(\n+              true\n+            )\n+          })\n \n           const newRandomNumber = await browser\n             .elementById('random-number')\n             .text()\n \n           expect(initialRandomNumber).toBe(newRandomNumber)\n \n-          await check(() => {\n+          await retry(async () => {\n             const logOccurrences =\n               next.cliOutput.slice(logStartIndex).split('re-fetching in layout')\n                 .length - 1\n \n-            return logOccurrences\n-          }, 1)\n+            expect(logOccurrences).toBe(1)\n+          })\n         })\n \n         it('should update search params following a link click', async () => {\n           const browser = await next.browser(`${basePath}/search-params`)\n-          await check(\n-            () => browser.elementById('search-params-data').text(),\n-            /{}/\n-          )\n+          await retry(async () => {\n+            const text = await browser.elementById('search-params-data').text()\n+            expect(text).toMatch(/{}/)\n+          })\n           await browser.elementByCss('[href=\"?foo=true\"]').click()\n-          await check(\n-            () => browser.elementById('search-params-data').text(),\n-            /{\"foo\":\"true\"}/\n-          )\n+          await retry(async () => {\n+            const text = await browser.elementById('search-params-data').text()\n+            expect(text).toMatch(/{\"foo\":\"true\"}/)\n+          })\n           await browser\n             .elementByCss(`[href=\"${basePath}/search-params\"]`)\n             .click()\n-          await check(\n-            () => browser.elementById('search-params-data').text(),\n-            /{}/\n-          )\n+          await retry(async () => {\n+            const text = await browser.elementById('search-params-data').text()\n+            expect(text).toMatch(/{}/)\n+          })\n           await browser.elementByCss('[href=\"?foo=true\"]').click()\n-          await check(\n-            () => browser.elementById('search-params-data').text(),\n-            /{\"foo\":\"true\"}/\n-          )\n+          await retry(async () => {\n+            const text = await browser.elementById('search-params-data').text()\n+            expect(text).toMatch(/{\"foo\":\"true\"}/)\n+          })\n         })\n       })\n     })\n@@ -566,14 +450,18 @@ describe('app dir - prefetching', () => {\n     it('should not throw when an invalid URL is passed to Link', async () => {\n       const browser = await next.browser('/invalid-url/from-link')\n \n-      await check(() => browser.hasElementByCssSelector('h1'), true)\n+      await retry(async () => {\n+        expect(await browser.hasElementByCssSelector('h1')).toBe(true)\n+      })\n       expect(await browser.elementByCss('h1').text()).toEqual('Hello, world!')\n     })\n \n     it('should throw when an invalid URL is passed to router.prefetch', async () => {\n       const browser = await next.browser('/invalid-url/from-router-prefetch')\n \n-      await check(() => browser.hasElementByCssSelector('h1'), true)\n+      await retry(async () => {\n+        expect(await browser.hasElementByCssSelector('h1')).toBe(true)\n+      })\n       expect(await browser.elementByCss('h1').text()).toEqual(\n         'A prefetch threw an error'\n       )\n@@ -598,39 +486,18 @@ describe('app dir - prefetching', () => {\n         },\n       })\n \n+      // Reveal an accordion to trigger prefetch\n+      await browser.elementByCss('#accordion-to-static-page').click()\n       await browser.waitForIdleNetwork()\n \n       await retry(async () => {\n-        expect(requests.length).toBeGreaterThan(0)\n-        expect(requests.every((req) => req.priority === 'low')).toBe(true)\n-      })\n-    })\n-\n-    it('should prefetch with high priority when navigating to a page without a prefetch entry', async () => {\n-      const requests: { priority: string; url: string }[] = []\n-      const browser = await next.browser('/prefetch-false/initial', {\n-        beforePageLoad(page) {\n-          page.on('request', async (req) => {\n-            const url = new URL(req.url())\n-            const headers = await req.allHeaders()\n-            if (headers['rsc']) {\n-              requests.push({\n-                priority: headers['next-test-fetch-priority'],\n-                url: url.pathname,\n-              })\n-            }\n-          })\n-        },\n-      })\n-\n-      await browser.waitForIdleNetwork()\n-\n-      expect(requests.length).toBe(0)\n-\n-      await browser.elementByCss('#to-prefetch-false-result').click()\n-      await retry(async () => {\n-        expect(requests.length).toBe(1)\n-        expect(requests[0].priority).toBe('high')\n+        const staticPageRequests = requests.filter(\n+          (req) => req.url === '/static-page'\n+        )\n+        expect(staticPageRequests.length).toBeGreaterThan(0)\n+        expect(staticPageRequests.every((req) => req.priority === 'low')).toBe(\n+          true\n+        )\n       })\n     })\n \n@@ -651,16 +518,27 @@ describe('app dir - prefetching', () => {\n         },\n       })\n \n+      // Reveal the dashboard accordion\n+      await browser.elementByCss('#accordion-to-dashboard').click()\n+      await browser.waitForElementByCss('#to-dashboard')\n+\n+      // Click to navigate\n       await browser.elementByCss('#to-dashboard').click()\n       await browser.waitForIdleNetwork()\n \n       await retry(async () => {\n         const dashboardRequests = requests.filter(\n           (req) => req.url === '/dashboard'\n         )\n-        expect(dashboardRequests.length).toBe(2)\n-        expect(dashboardRequests[0].priority).toBe('low') // the first request is the prefetch\n-        expect(dashboardRequests[1].priority).toBe('auto') // the second request is the lazy fetch to fill in missing data\n+        expect(dashboardRequests.length).toBeGreaterThanOrEqual(2)\n+        // Should have at least one low priority prefetch request\n+        expect(dashboardRequests.some((req) => req.priority === 'low')).toBe(\n+          true\n+        )\n+        // Should have at least one auto priority fetch to fill in missing data\n+        expect(dashboardRequests.some((req) => req.priority === 'auto')).toBe(\n+          true\n+        )\n       })\n     })\n "
        },
        {
            "sha": "d73e4cfdb8277c817a3d631df087c6688d0d13c0",
            "filename": "test/e2e/app-dir/app-prefetch/router-act.ts",
            "status": "added",
            "additions": 504,
            "deletions": 0,
            "changes": 504,
            "blob_url": "https://github.com/vercel/next.js/blob/9c053332ccbc17220982f169b94c7cbdca0a648e/test%2Fe2e%2Fapp-dir%2Fapp-prefetch%2Frouter-act.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/9c053332ccbc17220982f169b94c7cbdca0a648e/test%2Fe2e%2Fapp-dir%2Fapp-prefetch%2Frouter-act.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fapp-prefetch%2Frouter-act.ts?ref=9c053332ccbc17220982f169b94c7cbdca0a648e",
            "patch": "@@ -0,0 +1,504 @@\n+import type * as Playwright from 'playwright'\n+import { diff } from 'jest-diff'\n+import { equals } from '@jest/expect-utils'\n+\n+type Batch = {\n+  pendingRequestChecks: Set<Promise<void>>\n+  pendingRequests: Set<PendingRSCRequest>\n+}\n+\n+type PendingRSCRequest = {\n+  url: string\n+  route: Playwright.Route | null\n+  result: Promise<{\n+    text: string\n+    body: any\n+    headers: Record<string, string>\n+    status: number\n+  }>\n+  didProcess: boolean\n+}\n+\n+let currentBatch: Batch | null = null\n+\n+type ExpectedResponseConfig = { includes: string; block?: boolean | 'reject' }\n+\n+/**\n+ * Represents the expected responses sent by the server to fulfill requests\n+ * initiated by the `scope` function.\n+ *\n+ * - `includes` is a substring of an expected response body.\n+ * - `block` indicates whether the response should not yet be sent to the\n+ *   client. This option is only supported when nested inside an outer `act`\n+ *   scope. The blocked response will be fulfilled when the outer\n+ *   scope completes.\n+ *\n+ * The list of expected responses does not need to be exhaustive  any\n+ * responses that don't match will proceed like normal. However, `act` will\n+ * error if the expected substring is not found in any of the responses, or\n+ * if the expected responses are received out of order. It will also error\n+ * if the same expected substring is found in multiple responses.\n+ *\n+ * If no expected responses are provided, the only expectation is that at\n+ * least one request is initiated. (This is the same as passing an\n+ * empty array.)\n+ *\n+ * Alternatively, if no network activity is expected, pass \"no-requests\".\n+ */\n+type ActConfig =\n+  | ExpectedResponseConfig\n+  | Array<ExpectedResponseConfig>\n+  | 'block'\n+  | 'no-requests'\n+  | null\n+\n+export function createRouterAct(\n+  page: Playwright.Page\n+): <T>(scope: () => Promise<T> | T, config?: ActConfig) => Promise<T> {\n+  /**\n+   * Test utility for requests initiated by the Next.js Router, such as\n+   * prefetches and navigations. Calls the given async function then intercepts\n+   * any router requests that are initiated as a result. It will then wait for\n+   * all the requests to complete before exiting. Inspired by the React\n+   * `act` API.\n+   */\n+  async function act<T>(\n+    scope: () => Promise<T> | T,\n+    config?: ActConfig\n+  ): Promise<T> {\n+    // Capture a stack trace for better async error messages.\n+    const error = new Error()\n+    if (Error.captureStackTrace) {\n+      Error.captureStackTrace(error, act)\n+    }\n+\n+    let expectedResponses: Array<ExpectedResponseConfig> | null\n+    let forbiddenResponses: Array<ExpectedResponseConfig> | null = null\n+    let shouldBlockAll = false\n+    if (config === undefined || config === null) {\n+      // Default. Expect at least one request, but don't assert on the response.\n+      expectedResponses = []\n+    } else if (config === 'block') {\n+      // Expect at least one request, and block them all from being fulfilled.\n+      if (currentBatch === null) {\n+        error.message =\n+          '`block` option only supported when nested inside an outer ' +\n+          '`act` scope.'\n+        throw error\n+      }\n+      expectedResponses = []\n+      shouldBlockAll = true\n+    } else if (config === 'no-requests') {\n+      // Expect no requests to be initiated.\n+      expectedResponses = null\n+    } else if (!Array.isArray(config)) {\n+      // Shortcut for a single expected response.\n+      if (config.block === true && currentBatch === null) {\n+        error.message =\n+          '`block: true` option only supported when nested inside an outer ' +\n+          '`act` scope.'\n+        throw error\n+      }\n+      if (config.block !== 'reject') {\n+        expectedResponses = [config]\n+      } else {\n+        expectedResponses = []\n+        forbiddenResponses = [config]\n+      }\n+    } else {\n+      expectedResponses = []\n+      for (const item of config) {\n+        if (item.block === true && currentBatch === null) {\n+          error.message =\n+            '`block: true` option only supported when nested inside an outer ' +\n+            '`act` scope.'\n+          throw error\n+        }\n+        if (item.block !== 'reject') {\n+          expectedResponses.push(item)\n+        } else {\n+          if (forbiddenResponses === null) {\n+            forbiddenResponses = [item]\n+          } else {\n+            forbiddenResponses.push(item)\n+          }\n+        }\n+      }\n+    }\n+\n+    // Attach a route handler to intercept router requests for the duration\n+    // of the `act` scope. It will be removed before `act` exits.\n+    let onDidIssueFirstRequest: (() => void) | null = null\n+    const routeHandler = async (route: Playwright.Route) => {\n+      const request = route.request()\n+\n+      const pendingRequests = batch.pendingRequests\n+      const pendingRequestChecks = batch.pendingRequestChecks\n+\n+      // Because determining whether we need to intercept the request is an\n+      // async operation, we collect these promises so we can await them at the\n+      // end of the `act` scope to see whether any additional requests\n+      // were initiated.\n+      // NOTE: The default check doesn't actually need to be async, but since\n+      // this logic is subtle, to preserve the ability to add an async\n+      // check later, I'm treating it as if it could possibly be async.\n+      const checkIfRouterRequest = (async () => {\n+        const headers = request.headers()\n+\n+        // The default check includes navigations, prefetches, and actions.\n+        const isRouterRequest =\n+          headers['rsc'] !== undefined || // Matches navigations and prefetches\n+          headers['next-action'] !== undefined // Matches Server Actions\n+\n+        if (isRouterRequest) {\n+          // This request was initiated by the Next.js Router. Intercept it and\n+          // add it to the current batch.\n+          pendingRequests.add({\n+            url: request.url(),\n+            route,\n+            // `act` controls the timing of when responses reach the client,\n+            // but it should not affect the timing of when requests reach the\n+            // server; we pass the request to the server the immediately.\n+            result: new Promise(async (resolve) => {\n+              const originalResponse = await page.request.fetch(request, {\n+                maxRedirects: 0,\n+              })\n+\n+              // WORKAROUND:\n+              // intercepting responses with 'Transfer-Encoding: chunked' (used for streaming)\n+              // seems to be problematic sometimes, making the browser error with `net::ERR_INCOMPLETE_CHUNKED_ENCODING`.\n+              // In particular, this seems to happen when blocking a streaming navigation response. (but not always)\n+              // Playwright buffers the whole body anyway, so we can remove the header to sidestep this.\n+              const headers = originalResponse.headers()\n+              delete headers['transfer-encoding']\n+\n+              resolve({\n+                text: await originalResponse.text(),\n+                body: await originalResponse.body(),\n+                headers,\n+                status: originalResponse.status(),\n+              })\n+            }),\n+            didProcess: false,\n+          })\n+          if (onDidIssueFirstRequest !== null) {\n+            onDidIssueFirstRequest()\n+            onDidIssueFirstRequest = null\n+          }\n+          return\n+        }\n+        // This is some other request not related to the Next.js Router. Allow\n+        // it to continue as normal.\n+        route.continue()\n+      })()\n+\n+      pendingRequestChecks.add(checkIfRouterRequest)\n+      await checkIfRouterRequest\n+      // Once we've read the header, we can remove it from the pending set.\n+      pendingRequestChecks.delete(checkIfRouterRequest)\n+    }\n+\n+    let didHardNavigate = false\n+    const hardNavigationHandler = async () => {\n+      // If a hard navigation occurs, the current batch of requests is no longer\n+      // valid. In fact, Playwright will hang indefinitely if we attempt to\n+      // await the response of an orphaned request. Reset the batch and unblock\n+      // all the orphaned requests.\n+      const orphanedRequests = batch.pendingRequests\n+      batch.pendingRequests = new Set()\n+      batch.pendingRequestChecks = new Set()\n+      await Promise.all(\n+        Array.from(orphanedRequests).map((item) => item.route.continue())\n+      )\n+      didHardNavigate = true\n+    }\n+\n+    const waitForPendingRequestChecks = async () => {\n+      const prevChecks = batch.pendingRequestChecks\n+      batch.pendingRequestChecks = new Set()\n+      await Promise.all(prevChecks)\n+    }\n+\n+    const prevBatch = currentBatch\n+    const batch: Batch = {\n+      pendingRequestChecks: new Set(),\n+      pendingRequests: new Set(),\n+    }\n+    currentBatch = batch\n+    await page.route('**/*', routeHandler)\n+    await page.on('framedetached', hardNavigationHandler)\n+    try {\n+      // Call the user-provided scope function\n+      const returnValue = await scope()\n+\n+      // Wait until the first request is initiated, up to some timeout.\n+      if (expectedResponses !== null && batch.pendingRequests.size === 0) {\n+        await new Promise<void>((resolve, reject) => {\n+          const timerId = setTimeout(() => {\n+            error.message = 'Timed out waiting for a request to be initiated.'\n+            reject(error)\n+          }, 500)\n+          onDidIssueFirstRequest = () => {\n+            clearTimeout(timerId)\n+            resolve()\n+          }\n+        })\n+      }\n+\n+      // Fulfill all the requests that were initiated by the scope function. But\n+      // first, wait an additional browser task. This simulates the real world\n+      // behavior where the network response is received in an async event/task\n+      // that comes after the scope function, rather than immediately when the\n+      // scope function exits.\n+      //\n+      // We use requestIdleCallback to schedule the task because that's\n+      // guaranteed to fire after any IntersectionObserver events, which the\n+      // router uses to track the visibility of links.\n+      await page.evaluate(\n+        () => new Promise<void>((res) => requestIdleCallback(() => res()))\n+      )\n+\n+      // Checking whether a request needs to be intercepted is an async\n+      // operation, so we need to wait for all the checks to complete before\n+      // checking whether the queue is empty.\n+      await waitForPendingRequestChecks()\n+\n+      // Because responding to one request may unblock additional requests,\n+      // keep checking for more requests until the queue has settled.\n+      const remaining = new Set<PendingRSCRequest>()\n+      let actualResponses: Array<ExpectedResponseConfig> = []\n+      let alreadyMatched = new Map<string, string>()\n+      while (batch.pendingRequests.size > 0) {\n+        const pending = batch.pendingRequests\n+        batch.pendingRequests = new Set()\n+        for (const item of pending) {\n+          const route = item.route\n+          const url = item.url\n+\n+          let shouldBlock = false\n+          const fulfilled = await item.result\n+          if (item.didProcess) {\n+            // This response was already processed by an inner `act` call.\n+          } else {\n+            item.didProcess = true\n+            if (expectedResponses === null) {\n+              error.message = `\n+Expected no network requests to be initiated.\n+\n+URL: ${url}\n+Headers: ${JSON.stringify(fulfilled.headers)}\n+\n+Response:\n+${fulfilled.body}\n+`\n+\n+              throw error\n+            }\n+            if (fulfilled.status >= 400) {\n+              error.message = `\n+Received a response with an error status code.\n+\n+Status: ${fulfilled.status}\n+URL: ${url}\n+Headers: ${JSON.stringify(fulfilled.headers)}\n+\n+Response:\n+${fulfilled.body}\n+`\n+              throw error\n+            }\n+            if (forbiddenResponses !== null) {\n+              for (const forbiddenResponse of forbiddenResponses) {\n+                const includes = forbiddenResponse.includes\n+                if (fulfilled.body.includes(includes)) {\n+                  error.message = `\n+Received a response containing an unexpected substring:\n+\n+Rejected substring: ${includes}\n+\n+Response:\n+${fulfilled.body}\n+`\n+                  throw error\n+                }\n+              }\n+            }\n+            if (expectedResponses !== null) {\n+              for (const expectedResponse of expectedResponses) {\n+                const includes = expectedResponse.includes\n+                const block = expectedResponse.block\n+                if (fulfilled.body.includes(includes)) {\n+                  // Match. Don't check yet whether the responses are received\n+                  // in the expected order. Instead collect all the matches and\n+                  // check at the end so we can include a diff in the\n+                  // error message.\n+                  const otherResponse = alreadyMatched.get(includes)\n+                  if (otherResponse !== undefined) {\n+                    error.message = `\n+Received multiple responses containing the same expected substring.\n+\n+Expected substring:\n+${includes}\n+\n+Responses:\n+\n+${otherResponse}\n+\n+${fulfilled.body}\n+\n+Choose a more specific substring to assert on.\n+`\n+                    throw error\n+                  }\n+                  alreadyMatched.set(includes, fulfilled.body)\n+                  if (actualResponses === null) {\n+                    actualResponses = [expectedResponse]\n+                  } else {\n+                    actualResponses.push(expectedResponse)\n+                  }\n+                  if (block) {\n+                    shouldBlock = true\n+                  }\n+                  // Keep checking all the expected responses to verify there\n+                  // are no duplicate matches\n+                }\n+              }\n+            }\n+          }\n+\n+          if (shouldBlock || shouldBlockAll) {\n+            // This response was blocked by the `block` option. Don't\n+            // fulfill it yet.\n+            remaining.add(item)\n+            if (route === null) {\n+              error.message = `\n+The \"block\" option is not supported for requests that are redirected.\n+\n+URL: ${url}\n+Headers: ${JSON.stringify(fulfilled.headers)}\n+\n+Response:\n+${fulfilled.body}\n+`\n+\n+              throw error\n+            }\n+          } else {\n+            if (route !== null) {\n+              const request = route.request()\n+              await route.fulfill({\n+                body: fulfilled.body,\n+                headers: fulfilled.headers,\n+                status: fulfilled.status,\n+              })\n+              const browserResponse = await request.response()\n+              if (browserResponse !== null) {\n+                await browserResponse.finished()\n+              }\n+            }\n+          }\n+\n+          if (fulfilled.status === 307 || fulfilled.status === 308) {\n+            // When fulfilling a redirect, for some reason, the page.route()\n+            // handler installed earlier will not intercept the\n+            // redirect request. Install a one-off event listener to wait for\n+            // the redirected request to finish. This works for this case\n+            // because we don't need to modify to delay the response; we only\n+            // need to observe when it has finished.\n+            // TODO: Because this request cannot be intercepted, it's\n+            // incompatible with the \"block\" option. I haven't yet figured out\n+            // a strategy to make that work. In the meantime, attempting to\n+            // write a test that blocks a redirect will result in an error\n+            // (see error above).\n+            await new Promise<void>((resolve) => {\n+              page.once('request', (req) => {\n+                const handleResponse = (res: Playwright.Response) => {\n+                  if (res.url() === req.url()) {\n+                    batch.pendingRequests.add({\n+                      url: req.url(),\n+                      route: null,\n+                      result: new Promise(async (resolve) => {\n+                        resolve({\n+                          text: await res.text(),\n+                          body: await res.body(),\n+                          headers: res.headers(),\n+                          status: res.status(),\n+                        })\n+                      }),\n+                      didProcess: false,\n+                    })\n+                    page.off('response', handleResponse)\n+                    resolve()\n+                  }\n+                }\n+                page.on('response', handleResponse)\n+              })\n+            })\n+          }\n+        }\n+\n+        // After flushing the queue, wait for the microtask queue to be\n+        // exhausted, then check if any additional requests are initiated. A\n+        // single macrotask should be enough because if the router queue is\n+        // network throttled, the next request is issued either directly within\n+        // the task of the previous request's completion event, or in the\n+        // microtask queue of that event.\n+        await page.evaluate(\n+          () => new Promise<void>((res) => requestIdleCallback(() => res()))\n+        )\n+\n+        await waitForPendingRequestChecks()\n+      }\n+\n+      if (didHardNavigate) {\n+        error.message =\n+          'A hard navigation or refresh was triggerd during the `act` scope. ' +\n+          'This is not supported.'\n+        throw error\n+      }\n+\n+      if (expectedResponses !== null) {\n+        // Assert that the responses were received in the expected order\n+        if (!equals(actualResponses, expectedResponses)) {\n+          // Print a helpful error message.\n+\n+          if (expectedResponses.length === 1) {\n+            error.message =\n+              'Expected a response containing the given string:\\n\\n' +\n+              expectedResponses[0].includes +\n+              '\\n'\n+          } else {\n+            const expectedSubstrings = expectedResponses.map(\n+              (item) => item.includes\n+            )\n+            const actualSubstrings = actualResponses.map(\n+              (item) => item.includes\n+            )\n+            error.message =\n+              'Expected sequence of responses does not match:\\n\\n' +\n+              diff(expectedSubstrings, actualSubstrings) +\n+              '\\n'\n+          }\n+          throw error\n+        }\n+      }\n+\n+      // Some of the requests were blocked. Transfer them to the outer `act`\n+      // batch so it can flush them.\n+      if (remaining.size !== 0 && prevBatch !== null) {\n+        for (const item of remaining) {\n+          prevBatch.pendingRequests.add(item)\n+        }\n+      }\n+\n+      return returnValue\n+    } finally {\n+      // Clean up\n+      currentBatch = prevBatch\n+      await page.unroute('**/*', routeHandler)\n+      await page.off('framedetached', hardNavigationHandler)\n+    }\n+  }\n+\n+  return act\n+}"
        },
        {
            "sha": "fef2ed8eeec93a8968875a0e4289509b6da6f792",
            "filename": "test/e2e/app-dir/app-prefetch/test-utils.ts",
            "status": "added",
            "additions": 108,
            "deletions": 0,
            "changes": 108,
            "blob_url": "https://github.com/vercel/next.js/blob/9c053332ccbc17220982f169b94c7cbdca0a648e/test%2Fe2e%2Fapp-dir%2Fapp-prefetch%2Ftest-utils.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/9c053332ccbc17220982f169b94c7cbdca0a648e/test%2Fe2e%2Fapp-dir%2Fapp-prefetch%2Ftest-utils.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fapp-prefetch%2Ftest-utils.ts?ref=9c053332ccbc17220982f169b94c7cbdca0a648e",
            "patch": "@@ -0,0 +1,108 @@\n+export function createTimeController() {\n+  let fixedTime = Date.now()\n+\n+  return {\n+    install: (browser) => {\n+      return browser.eval(`\n+        (() => {\n+          const OriginalDate = Date;\n+          const originalSetTimeout = globalThis.setTimeout;\n+          const originalSetInterval = globalThis.setInterval;\n+          const originalClearTimeout = globalThis.clearTimeout;\n+          const originalClearInterval = globalThis.clearInterval;\n+\n+          let fixedTime = ${fixedTime};\n+          let timerIdCounter = 1;\n+          const timers = new Map();\n+\n+          // Override the Date constructor\n+          globalThis.Date = class extends OriginalDate {\n+            constructor(...args) {\n+              if (args.length === 0) {\n+                super(fixedTime);\n+              } else {\n+                super(...args);\n+              }\n+            }\n+\n+            static now() {\n+              return fixedTime;\n+            }\n+          };\n+\n+          // Preserve static methods\n+          Object.setPrototypeOf(globalThis.Date, OriginalDate);\n+\n+          // Override setTimeout\n+          globalThis.setTimeout = function(callback, delay, ...args) {\n+            const id = timerIdCounter++;\n+            timers.set(id, {\n+              callback,\n+              args,\n+              fireTime: fixedTime + (delay || 0),\n+              interval: false\n+            });\n+            return id;\n+          };\n+\n+          // Override setInterval\n+          globalThis.setInterval = function(callback, delay, ...args) {\n+            const id = timerIdCounter++;\n+            timers.set(id, {\n+              callback,\n+              args,\n+              fireTime: fixedTime + (delay || 0),\n+              interval: true,\n+              delay: delay || 0\n+            });\n+            return id;\n+          };\n+\n+          // Override clearTimeout\n+          globalThis.clearTimeout = function(id) {\n+            timers.delete(id);\n+          };\n+\n+          // Override clearInterval\n+          globalThis.clearInterval = function(id) {\n+            timers.delete(id);\n+          };\n+\n+          // Add method to advance time\n+          globalThis.__advanceTime = (ms) => {\n+            fixedTime += ms;\n+\n+            // Fire any timers that should have fired\n+            const toFire = [];\n+            for (const [id, timer] of timers.entries()) {\n+              if (timer.fireTime <= fixedTime) {\n+                toFire.push({ id, timer });\n+              }\n+            }\n+\n+            for (const { id, timer } of toFire) {\n+              try {\n+                timer.callback(...timer.args);\n+              } catch (e) {\n+                console.error('Timer callback error:', e);\n+              }\n+\n+              if (timer.interval) {\n+                // Reschedule interval timer\n+                timer.fireTime = fixedTime + timer.delay;\n+              } else {\n+                // Remove one-time timer\n+                timers.delete(id);\n+              }\n+            }\n+          };\n+        })();\n+      `)\n+    },\n+\n+    advance: async (browser, ms: number) => {\n+      fixedTime += ms\n+      await browser.eval(`globalThis.__advanceTime(${ms})`)\n+    },\n+  }\n+}"
        }
    ],
    "stats": {
        "total": 1618,
        "additions": 1103,
        "deletions": 515
    }
}