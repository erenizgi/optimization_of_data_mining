{
    "author": "ijjk",
    "message": "Update types and more test coverage for adapters (#82919)\n\nThis tweaks the output structure a bit and makes types more\nstrong/specific for easier handling. Also adds additional test coverage.",
    "sha": "f507b0e66bb10275fa2c1c6c6d344b36e28458a1",
    "files": [
        {
            "sha": "a29f85ee4bbee854e3152bff51c8f7f45559f6e2",
            "filename": "packages/next/src/build/adapter/build-complete.ts",
            "status": "modified",
            "additions": 489,
            "deletions": 85,
            "changes": 574,
            "blob_url": "https://github.com/vercel/next.js/blob/f507b0e66bb10275fa2c1c6c6d344b36e28458a1/packages%2Fnext%2Fsrc%2Fbuild%2Fadapter%2Fbuild-complete.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f507b0e66bb10275fa2c1c6c6d344b36e28458a1/packages%2Fnext%2Fsrc%2Fbuild%2Fadapter%2Fbuild-complete.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fadapter%2Fbuild-complete.ts?ref=f507b0e66bb10275fa2c1c6c6d344b36e28458a1",
            "patch": "@@ -1,59 +1,338 @@\n import path from 'path'\n import fs from 'fs/promises'\n-import { promisify } from 'util'\n import { pathToFileURL } from 'url'\n import * as Log from '../output/log'\n-import globOriginal from 'next/dist/compiled/glob'\n+import { isMiddlewareFilename } from '../utils'\n+import { RenderingMode } from '../rendering-mode'\n import { interopDefault } from '../../lib/interop-default'\n-import type { AdapterOutputs, NextAdapter } from '../../server/config-shared'\n-import type {\n-  FunctionsConfigManifest,\n-  PrerenderManifest,\n-  RoutesManifest,\n-} from '..'\n+import type { RouteHas } from '../../lib/load-custom-routes'\n+import { recursiveReadDir } from '../../lib/recursive-readdir'\n+import { isDynamicRoute } from '../../shared/lib/router/utils'\n+import type { Revalidate } from '../../server/lib/cache-control'\n+import type { NextConfigComplete } from '../../server/config-shared'\n+import type { MiddlewareMatcher } from '../analysis/get-page-static-info'\n+import { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\n+import { AdapterOutputType, type PHASE_TYPE } from '../../shared/lib/constants'\n+import { normalizePagePath } from '../../shared/lib/page-path/normalize-page-path'\n+\n import type {\n-  EdgeFunctionDefinition,\n   MiddlewareManifest,\n+  EdgeFunctionDefinition,\n } from '../webpack/plugins/middleware-plugin'\n-import { isMiddlewareFilename } from '../utils'\n-import { normalizePagePath } from '../../shared/lib/page-path/normalize-page-path'\n-import { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\n-import { AdapterOutputType } from '../../shared/lib/constants'\n-import { RenderingMode } from '../rendering-mode'\n-import { isDynamicRoute } from '../../shared/lib/router/utils'\n \n-const glob = promisify(globOriginal)\n+import type {\n+  ManifestRoute,\n+  RoutesManifest,\n+  PrerenderManifest,\n+  ManifestHeaderRoute,\n+  ManifestRewriteRoute,\n+  ManifestRedirectRoute,\n+  FunctionsConfigManifest,\n+} from '..'\n+\n+import {\n+  HTML_CONTENT_TYPE_HEADER,\n+  JSON_CONTENT_TYPE_HEADER,\n+  NEXT_RESUME_HEADER,\n+} from '../../lib/constants'\n+\n+interface SharedRouteFields {\n+  /**\n+   * id is the unique identifier of the output\n+   */\n+  id: string\n+  /**\n+   * filePath is the location on disk of the built entrypoint asset\n+   */\n+  filePath: string\n+  /**\n+   * pathname is the URL pathname the asset should be served at\n+   */\n+  pathname: string\n+  /**\n+   * runtime is which runtime the entrypoint is built for\n+   */\n+  runtime: 'nodejs' | 'edge'\n+  /**\n+   * assets are all necessary traced assets that could be\n+   * loaded by the output to handle a request e.g. traced\n+   * node_modules or necessary manifests for Next.js.\n+   * The key is the relative path from the repo root and the value\n+   * is the absolute path to the file\n+   */\n+  assets: Record<string, string>\n+\n+  /**\n+   * config related to the route\n+   */\n+  config: {\n+    /**\n+     * maxDuration is a segment config to signal the max\n+     * execution duration a route should be allowed before\n+     * it's timed out\n+     */\n+    maxDuration?: number\n+    /**\n+     * preferredRegion is a segment config to signal deployment\n+     * region preferences to the provider being used\n+     */\n+    preferredRegion?: string | string[]\n+  }\n+}\n+\n+export interface AdapterOutput {\n+  /**\n+   * `PAGES` represents all the React pages that are under `pages/`.\n+   */\n+  PAGES: SharedRouteFields & {\n+    type: AdapterOutputType.PAGES\n+  }\n+\n+  /**\n+   * `PAGES_API` represents all the API routes under `pages/api/`.\n+   */\n+  PAGES_API: SharedRouteFields & {\n+    type: AdapterOutputType.PAGES_API\n+  }\n+  /**\n+   * `APP_PAGE` represents all the React pages that are under `app/` with the\n+   * filename of `page.{j,t}s{,x}`.\n+   */\n+  APP_PAGE: SharedRouteFields & {\n+    type: AdapterOutputType.APP_PAGE\n+  }\n+\n+  /**\n+   * `APP_ROUTE` represents all the API routes and metadata routes that are under `app/` with the\n+   * filename of `route.{j,t}s{,x}`.\n+   */\n+  APP_ROUTE: SharedRouteFields & {\n+    type: AdapterOutputType.APP_ROUTE\n+  }\n+\n+  /**\n+   * `PRERENDER` represents an ISR enabled route that might\n+   * have a seeded cache entry or fallback generated during build\n+   */\n+  PRERENDER: {\n+    id: string\n+    pathname: string\n+    type: AdapterOutputType.PRERENDER\n+\n+    /**\n+     * For prerenders the parent output is the originating\n+     * page that the prerender is created from\n+     */\n+    parentOutputId: string\n+\n+    /**\n+     * groupId is the identifier for a group of prerenders that should be\n+     * revalidated together\n+     */\n+    groupId: number\n+\n+    pprChain?: {\n+      headers: Record<string, string>\n+    }\n+\n+    /**\n+     * fallback is initial cache data generated during build for a prerender\n+     */\n+    fallback?: {\n+      /**\n+       * path to the fallback file can be HTML/JSON/RSC\n+       */\n+      filePath: string\n+      /**\n+       * initialStatus is the status code that should be applied\n+       * when serving the fallback\n+       */\n+      initialStatus?: number\n+      /**\n+       * initialHeaders are the headers that should be sent when\n+       * serving the fallback\n+       */\n+      initialHeaders?: Record<string, string | string[]>\n+      /**\n+       * initial expiration is how long until the fallback entry\n+       * is considered expired and no longer valid to serve\n+       */\n+      initialExpiration?: number\n+      /**\n+       * initial revalidate is how long until the fallback is\n+       * considered stale and should be revalidated\n+       */\n+      initialRevalidate?: Revalidate\n+\n+      /**\n+       * postponedState is the PPR state when it postponed and is used for resuming\n+       */\n+      postponedState?: string\n+    }\n+    /**\n+     * config related to the route\n+     */\n+    config: {\n+      /**\n+       * allowQuery is the allowed query values to be passed\n+       * to an ISR function and what should be considered for the cacheKey\n+       * e.g. for /blog/[slug], \"slug\" is the only allowQuery\n+       */\n+      allowQuery?: string[]\n+      /**\n+       * allowHeader is the allowed headers to be passed to an\n+       * ISR function to prevent accidentally poisoning the cache\n+       * from leaking additional information that can impact the render\n+       */\n+      allowHeader?: string[]\n+      /**\n+       * bypass for is a list of has conditions the cache\n+       * should be bypassed and invoked directly e.g. action header\n+       */\n+      bypassFor?: RouteHas[]\n+      /**\n+       * renderingMode signals PPR or not for a prerender\n+       */\n+      renderingMode?: RenderingMode\n+\n+      /**\n+       * matchers are the configured matchers for middleware\n+       */\n+      matchers?: MiddlewareMatcher[]\n+\n+      /**\n+       * bypassToken is the generated token that signals a prerender cache\n+       * should be bypassed\n+       */\n+      bypassToken?: string\n+    }\n+  }\n+\n+  /**\n+   * `STATIC_FILE` represents a static file (ie /_next/static) or a purely\n+   * static HTML asset e.g. an automatically statically optimized page\n+   * that does not use ISR\n+   */\n+  STATIC_FILE: {\n+    id: string\n+    filePath: string\n+    pathname: string\n+    type: AdapterOutputType.STATIC_FILE\n+  }\n+\n+  /**\n+   * `MIDDLEWARE` represents the middleware output if present\n+   */\n+  MIDDLEWARE: SharedRouteFields & {\n+    type: AdapterOutputType.MIDDLEWARE\n+    /**\n+     * config related to the route\n+     */\n+    config: SharedRouteFields['config'] & {\n+      /**\n+       * matchers are the configured matchers for middleware\n+       */\n+      matchers?: MiddlewareMatcher[]\n+    }\n+  }\n+}\n+\n+export interface AdapterOutputs {\n+  pages: Array<AdapterOutput['PAGES']>\n+  middleware?: AdapterOutput['MIDDLEWARE']\n+  appPages: Array<AdapterOutput['APP_PAGE']>\n+  pagesApi: Array<AdapterOutput['PAGES_API']>\n+  appRoutes: Array<AdapterOutput['APP_ROUTE']>\n+  prerenders: Array<AdapterOutput['PRERENDER']>\n+  staticFiles: Array<AdapterOutput['STATIC_FILE']>\n+}\n+\n+export interface NextAdapter {\n+  name: string\n+  /**\n+   * modifyConfig is called for any CLI command that loads the next.config\n+   * to only apply for specific commands the \"phase\" should be used\n+   * @param config\n+   * @param ctx\n+   * @returns\n+   */\n+  modifyConfig?: (\n+    config: NextConfigComplete,\n+    ctx: {\n+      phase: PHASE_TYPE\n+    }\n+  ) => Promise<NextConfigComplete> | NextConfigComplete\n+  onBuildComplete?: (ctx: {\n+    routes: {\n+      headers: Array<ManifestHeaderRoute>\n+      redirects: Array<ManifestRedirectRoute>\n+      rewrites: {\n+        beforeFiles: Array<ManifestRewriteRoute>\n+        afterFiles: Array<ManifestRewriteRoute>\n+        fallback: Array<ManifestRewriteRoute>\n+      }\n+      dynamicRoutes: ReadonlyArray<ManifestRoute>\n+    }\n+    outputs: AdapterOutputs\n+    /**\n+     * projectDir is the absolute directory the Next.js application is in\n+     */\n+    projectDir: string\n+    /**\n+     * repoRoot is the absolute path of the detected root of the repo\n+     */\n+    repoRoot: string\n+    /**\n+     * distDir is the absolute path to the dist directory\n+     */\n+    distDir: string\n+    /**\n+     * config is the loaded next.config (has modifyConfig applied)\n+     */\n+    config: NextConfigComplete\n+    /**\n+     * nextVersion is the current version of Next.js being used\n+     */\n+    nextVersion: string\n+  }) => Promise<void> | void\n+}\n \n export async function handleBuildComplete({\n-  // dir,\n+  dir,\n+  config,\n   distDir,\n+  pageKeys,\n   tracingRoot,\n   adapterPath,\n-  pageKeys,\n   appPageKeys,\n-  hasNodeMiddleware,\n-  hasInstrumentationHook,\n-  requiredServerFiles,\n+  staticPages,\n+  nextVersion,\n+  hasStatic404,\n   routesManifest,\n+  hasNodeMiddleware,\n   prerenderManifest,\n   middlewareManifest,\n+  requiredServerFiles,\n+  hasInstrumentationHook,\n   functionsConfigManifest,\n-  hasStatic404,\n }: {\n   dir: string\n   distDir: string\n   adapterPath: string\n   tracingRoot: string\n+  nextVersion: string\n+  hasStatic404: boolean\n+  staticPages: Set<string>\n   hasNodeMiddleware: boolean\n+  config: NextConfigComplete\n   pageKeys: readonly string[]\n-  hasInstrumentationHook: boolean\n-  appPageKeys?: readonly string[] | undefined\n   requiredServerFiles: string[]\n   routesManifest: RoutesManifest\n+  hasInstrumentationHook: boolean\n   prerenderManifest: PrerenderManifest\n   middlewareManifest: MiddlewareManifest\n+  appPageKeys?: readonly string[] | undefined\n   functionsConfigManifest: FunctionsConfigManifest\n-  hasStatic404: boolean\n }) {\n   const adapterMod = interopDefault(\n     await import(pathToFileURL(require.resolve(adapterPath)).href)\n@@ -63,16 +342,21 @@ export async function handleBuildComplete({\n     Log.info(`Running onBuildComplete from ${adapterMod.name}`)\n \n     try {\n-      const outputs: AdapterOutputs = []\n+      const outputs: AdapterOutputs = {\n+        pages: [],\n+        pagesApi: [],\n+        appPages: [],\n+        appRoutes: [],\n+        prerenders: [],\n+        staticFiles: [],\n+      }\n \n-      const staticFiles = await glob('**/*', {\n-        cwd: path.join(distDir, 'static'),\n-      })\n+      const staticFiles = await recursiveReadDir(path.join(distDir, 'static'))\n \n       for (const file of staticFiles) {\n         const pathname = path.posix.join('/_next/static', file)\n         const filePath = path.join(distDir, 'static', file)\n-        outputs.push({\n+        outputs.staticFiles.push({\n           type: AdapterOutputType.STATIC_FILE,\n           id: path.join('static', file),\n           pathname,\n@@ -84,7 +368,7 @@ export async function handleBuildComplete({\n \n       for (const file of requiredServerFiles) {\n         // add to shared node assets\n-        const filePath = path.join(distDir, file)\n+        const filePath = path.join(dir, file)\n         const fileOutputPath = path.relative(tracingRoot, filePath)\n         sharedNodeAssets[fileOutputPath] = filePath\n       }\n@@ -131,35 +415,51 @@ export async function handleBuildComplete({\n         page: EdgeFunctionDefinition,\n         isMiddleware: boolean = false\n       ) {\n-        let type = AdapterOutputType.PAGES\n+        let type: AdapterOutputType = AdapterOutputType.PAGES\n         const isAppPrefix = page.page.startsWith('app/')\n         const isAppPage = isAppPrefix && page.page.endsWith('/page')\n         const isAppRoute = isAppPrefix && page.page.endsWith('/route')\n+        let currentOutputs: Array<\n+          | AdapterOutput['PAGES']\n+          | AdapterOutput['PAGES_API']\n+          | AdapterOutput['APP_PAGE']\n+          | AdapterOutput['APP_ROUTE']\n+        > = outputs.pages\n \n         if (isMiddleware) {\n           type = AdapterOutputType.MIDDLEWARE\n         } else if (isAppPage) {\n+          currentOutputs = outputs.appPages\n           type = AdapterOutputType.APP_PAGE\n         } else if (isAppRoute) {\n+          currentOutputs = outputs.appRoutes\n           type = AdapterOutputType.APP_ROUTE\n         } else if (page.page.startsWith('/api')) {\n+          currentOutputs = outputs.pagesApi\n           type = AdapterOutputType.PAGES_API\n         }\n \n-        const output: AdapterOutputs[0] = {\n+        const output: Omit<AdapterOutput[typeof type], 'type'> & {\n+          type: any\n+        } = {\n+          type,\n           id: page.name,\n           runtime: 'edge',\n           pathname: isAppPrefix ? normalizeAppPath(page.name) : page.name,\n           filePath: path.join(\n             distDir,\n-            'server',\n             page.files.find(\n               (item) =>\n                 item.startsWith('server/app') || item.startsWith('server/pages')\n-            ) || ''\n+            ) ||\n+              // TODO: turbopack build doesn't name the main entry chunk\n+              // identifiably so we don't know which to mark here but\n+              // technically edge needs all chunks to load always so\n+              // should this field even be provided?\n+              page.files[0] ||\n+              ''\n           ),\n           assets: {},\n-          type,\n           config:\n             type === AdapterOutputType.MIDDLEWARE\n               ? {\n@@ -185,7 +485,12 @@ export async function handleBuildComplete({\n         for (const item of [...(page.wasm || []), ...(page.assets || [])]) {\n           handleFile(item.filePath)\n         }\n-        outputs.push(output)\n+\n+        if (type === AdapterOutputType.MIDDLEWARE) {\n+          outputs.middleware = output\n+        } else {\n+          currentOutputs.push(output)\n+        }\n       }\n \n       const edgeFunctionHandlers: Promise<any>[] = []\n@@ -200,18 +505,38 @@ export async function handleBuildComplete({\n         edgeFunctionHandlers.push(handleEdgeFunction(page))\n       }\n       const pagesDistDir = path.join(distDir, 'server', 'pages')\n-      const pageOutputMap: Record<string, AdapterOutputs[0]> = {}\n+      const pageOutputMap: Record<\n+        string,\n+        AdapterOutput['PAGES'] | AdapterOutput['PAGES_API']\n+      > = {}\n \n       for (const page of pageKeys) {\n+        if (page === '/_app' || page === '/_document') {\n+          continue\n+        }\n+\n         if (middlewareManifest.functions.hasOwnProperty(page)) {\n           continue\n         }\n-        const route = normalizePagePath(page)\n \n+        const route = normalizePagePath(page)\n         const pageFile = path.join(\n           pagesDistDir,\n           `${normalizePagePath(page)}.js`\n         )\n+\n+        // if it's an auto static optimized page it's just\n+        // a static file\n+        if (staticPages.has(page)) {\n+          outputs.staticFiles.push({\n+            id: page,\n+            pathname: route,\n+            type: AdapterOutputType.STATIC_FILE,\n+            filePath: pageFile.replace(/\\.js$/, '.html'),\n+          } satisfies AdapterOutput['STATIC_FILE'])\n+          continue\n+        }\n+\n         const pageTraceFile = `${pageFile}.nft.json`\n         const assets = await handleTraceFiles(pageTraceFile).catch((err) => {\n           if (err.code !== 'ENOENT' || (page !== '/404' && page !== '/500')) {\n@@ -221,7 +546,7 @@ export async function handleBuildComplete({\n         })\n         const functionConfig = functionsConfigManifest.functions[route] || {}\n \n-        const output: AdapterOutputs[0] = {\n+        const output: AdapterOutput['PAGES'] | AdapterOutput['PAGES_API'] = {\n           id: route,\n           type: page.startsWith('/api')\n             ? AdapterOutputType.PAGES_API\n@@ -236,7 +561,12 @@ export async function handleBuildComplete({\n           },\n         }\n         pageOutputMap[page] = output\n-        outputs.push(output)\n+\n+        if (output.type === AdapterOutputType.PAGES) {\n+          outputs.pages.push(output)\n+        } else {\n+          outputs.pagesApi.push(output)\n+        }\n       }\n \n       if (hasNodeMiddleware) {\n@@ -246,7 +576,7 @@ export async function handleBuildComplete({\n         const functionConfig =\n           functionsConfigManifest.functions['/_middleware'] || {}\n \n-        outputs.push({\n+        outputs.middleware = {\n           pathname: '/_middleware',\n           id: '/_middleware',\n           assets,\n@@ -256,9 +586,12 @@ export async function handleBuildComplete({\n           config: {\n             matchers: functionConfig.matchers,\n           },\n-        })\n+        } satisfies AdapterOutput['MIDDLEWARE']\n       }\n-      const appOutputMap: Record<string, AdapterOutputs[0]> = {}\n+      const appOutputMap: Record<\n+        string,\n+        AdapterOutput['APP_PAGE'] | AdapterOutput['APP_ROUTE']\n+      > = {}\n       const appDistDir = path.join(distDir, 'server', 'app')\n \n       if (appPageKeys) {\n@@ -276,22 +609,28 @@ export async function handleBuildComplete({\n           const functionConfig =\n             functionsConfigManifest.functions[normalizedPage] || {}\n \n-          const output: AdapterOutputs[0] = {\n-            pathname: normalizedPage,\n-            id: normalizedPage,\n-            assets,\n-            type: page.endsWith('/route')\n-              ? AdapterOutputType.APP_ROUTE\n-              : AdapterOutputType.APP_PAGE,\n-            runtime: 'nodejs',\n-            filePath: pageFile,\n-            config: {\n-              maxDuration: functionConfig.maxDuration,\n-              preferredRegion: functionConfig.regions,\n-            },\n-          }\n+          const output: AdapterOutput['APP_PAGE'] | AdapterOutput['APP_ROUTE'] =\n+            {\n+              pathname: normalizedPage,\n+              id: normalizedPage,\n+              assets,\n+              type: page.endsWith('/route')\n+                ? AdapterOutputType.APP_ROUTE\n+                : AdapterOutputType.APP_PAGE,\n+              runtime: 'nodejs',\n+              filePath: pageFile,\n+              config: {\n+                maxDuration: functionConfig.maxDuration,\n+                preferredRegion: functionConfig.regions,\n+              },\n+            }\n           appOutputMap[normalizedPage] = output\n-          outputs.push(output)\n+\n+          if (output.type === AdapterOutputType.APP_PAGE) {\n+            outputs.appPages.push(output)\n+          } else {\n+            outputs.appRoutes.push(output)\n+          }\n         }\n       }\n \n@@ -319,24 +658,19 @@ export async function handleBuildComplete({\n         prefetchSegmentSuffix,\n         varyHeader,\n         didPostponeHeader,\n-        contentTypeHeader,\n+        contentTypeHeader: rscContentTypeHeader,\n       } = routesManifest.rsc\n \n       const handleAppMeta = async (\n         route: string,\n-        initialOutput: AdapterOutputs[0]\n-      ) => {\n-        const meta: {\n-          segmentPaths?: string[]\n+        initialOutput: AdapterOutput['PRERENDER'],\n+        meta: {\n           postponed?: string\n-        } = JSON.parse(\n-          await fs\n-            .readFile(path.join(appDistDir, `${route}.meta`), 'utf8')\n-            .catch(() => '{}')\n-        )\n-\n-        if (meta.postponed && initialOutput.config) {\n-          initialOutput.config.postponed = meta.postponed\n+          segmentPaths?: string[]\n+        }\n+      ) => {\n+        if (meta.postponed && initialOutput.fallback) {\n+          initialOutput.fallback.postponedState = meta.postponed\n         }\n \n         if (meta?.segmentPaths) {\n@@ -358,11 +692,12 @@ export async function handleBuildComplete({\n               segmentPath + prefetchSegmentSuffix\n             )\n \n-            outputs.push({\n+            outputs.prerenders.push({\n               id: outputSegmentPath,\n               pathname: outputSegmentPath,\n               type: AdapterOutputType.PRERENDER,\n               parentOutputId: initialOutput.parentOutputId,\n+              groupId: initialOutput.groupId,\n \n               config: {\n                 ...initialOutput.config,\n@@ -376,13 +711,49 @@ export async function handleBuildComplete({\n                 initialHeaders: {\n                   ...initialOutput.fallback?.initialHeaders,\n                   vary: varyHeader,\n-                  'content-type': contentTypeHeader,\n+                  'content-type': rscContentTypeHeader,\n                   [didPostponeHeader]: '2',\n                 },\n               },\n-            })\n+            } satisfies AdapterOutput['PRERENDER'])\n+          }\n+        }\n+      }\n+\n+      let prerenderGroupId = 1\n+\n+      type AppRouteMeta = {\n+        segmentPaths?: string[]\n+        postponed?: string\n+        headers?: Record<string, string>\n+        status?: number\n+      }\n+\n+      const getAppRouteMeta = async (\n+        route: string,\n+        isAppPage: boolean\n+      ): Promise<AppRouteMeta> => {\n+        const meta: AppRouteMeta = isAppPage\n+          ? JSON.parse(\n+              await fs\n+                .readFile(path.join(appDistDir, `${route}.meta`), 'utf8')\n+                .catch(() => '{}')\n+            )\n+          : {}\n+\n+        if (meta.headers) {\n+          // normalize these for consistency\n+          for (const key of Object.keys(meta.headers)) {\n+            const keyLower = key.toLowerCase()\n+            if (keyLower !== key) {\n+              const value = meta.headers[key]\n+              delete meta.headers[key]\n+              meta.headers[keyLower] = value\n+            }\n           }\n         }\n+\n+        return meta\n       }\n \n       for (const route in prerenderManifest.routes) {\n@@ -433,14 +804,27 @@ export async function handleBuildComplete({\n           filePath = path.join(pagesDistDir, '404.html')\n         }\n \n-        const initialOutput: AdapterOutputs[0] = {\n+        const meta = await getAppRouteMeta(route, isAppPage)\n+\n+        const initialOutput: AdapterOutput['PRERENDER'] = {\n           id: route,\n           type: AdapterOutputType.PRERENDER,\n           pathname: route,\n           parentOutputId:\n             srcRoute === '/_not-found'\n               ? srcRoute\n               : getParentOutput(srcRoute, route).id,\n+          groupId: prerenderGroupId,\n+\n+          pprChain:\n+            isAppPage && config.experimental.ppr\n+              ? {\n+                  headers: {\n+                    [NEXT_RESUME_HEADER]: '1',\n+                  },\n+                }\n+              : undefined,\n+\n           fallback:\n             !isNotFoundTrue || (isNotFoundTrue && hasStatic404)\n               ? {\n@@ -449,7 +833,8 @@ export async function handleBuildComplete({\n                   initialHeaders: {\n                     ...initialHeaders,\n                     vary: varyHeader,\n-                    'content-type': contentTypeHeader,\n+                    'content-type': HTML_CONTENT_TYPE_HEADER,\n+                    ...meta.headers,\n                   },\n                   initialExpiration,\n                   initialRevalidate: initialRevalidate || 1,\n@@ -463,7 +848,7 @@ export async function handleBuildComplete({\n             bypassToken: prerenderManifest.preview.previewModeId,\n           },\n         }\n-        outputs.push(initialOutput)\n+        outputs.prerenders.push(initialOutput)\n \n         if (dataRoute) {\n           let dataFilePath = path.join(pagesDistDir, `${route}.json`)\n@@ -483,22 +868,29 @@ export async function handleBuildComplete({\n             )\n           }\n \n-          outputs.push({\n+          outputs.prerenders.push({\n             ...initialOutput,\n             id: dataRoute,\n             pathname: dataRoute,\n             fallback: isNotFoundTrue\n               ? undefined\n               : {\n                   ...initialOutput.fallback,\n+                  initialHeaders: {\n+                    ...initialOutput.fallback?.initialHeaders,\n+                    'content-type': isAppPage\n+                      ? rscContentTypeHeader\n+                      : JSON_CONTENT_TYPE_HEADER,\n+                  },\n                   filePath: dataFilePath,\n                 },\n           })\n         }\n \n         if (isAppPage) {\n-          await handleAppMeta(route, initialOutput)\n+          await handleAppMeta(route, initialOutput, meta)\n         }\n+        prerenderGroupId += 1\n       }\n \n       for (const dynamicRoute in prerenderManifest.dynamicRoutes) {\n@@ -521,12 +913,14 @@ export async function handleBuildComplete({\n             (item) => item.page === dynamicRoute\n           )?.routeKeys || {}\n         )\n+        const meta = await getAppRouteMeta(dynamicRoute, isAppPage)\n \n-        const initialOutput: AdapterOutputs[0] = {\n+        const initialOutput: AdapterOutput['PRERENDER'] = {\n           id: dynamicRoute,\n           type: AdapterOutputType.PRERENDER,\n           pathname: dynamicRoute,\n           parentOutputId: getParentOutput(dynamicRoute, dynamicRoute).id,\n+          groupId: prerenderGroupId,\n           config: {\n             allowQuery,\n             allowHeader,\n@@ -542,26 +936,30 @@ export async function handleBuildComplete({\n                     fallback\n                   ),\n                   initialStatus: fallbackStatus,\n-                  initialHeaders: fallbackHeaders,\n+                  initialHeaders: {\n+                    ...fallbackHeaders,\n+                    'content-type': HTML_CONTENT_TYPE_HEADER,\n+                  },\n                   initialExpiration: fallbackExpire,\n                   initialRevalidate: fallbackRevalidate || 1,\n                 }\n               : undefined,\n         }\n-        outputs.push(initialOutput)\n+        outputs.prerenders.push(initialOutput)\n \n         if (isAppPage) {\n-          await handleAppMeta(dynamicRoute, initialOutput)\n+          await handleAppMeta(dynamicRoute, initialOutput, meta)\n         }\n \n         if (dataRoute) {\n-          outputs.push({\n+          outputs.prerenders.push({\n             ...initialOutput,\n             id: dataRoute,\n             pathname: dataRoute,\n             fallback: undefined,\n           })\n         }\n+        prerenderGroupId += 1\n       }\n \n       await adapterMod.onBuildComplete({\n@@ -572,6 +970,12 @@ export async function handleBuildComplete({\n           headers: routesManifest.headers,\n         },\n         outputs,\n+\n+        config,\n+        distDir,\n+        nextVersion,\n+        projectDir: dir,\n+        repoRoot: tracingRoot,\n       })\n     } catch (err) {\n       Log.error(`Failed to run onBuildComplete from ${adapterMod.name}`)"
        },
        {
            "sha": "6577a3126b4010d9e17d5b7e1a3734d6245f60b2",
            "filename": "packages/next/src/build/index.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 2,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/f507b0e66bb10275fa2c1c6c6d344b36e28458a1/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f507b0e66bb10275fa2c1c6c6d344b36e28458a1/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts?ref=f507b0e66bb10275fa2c1c6c6d344b36e28458a1",
            "patch": "@@ -391,8 +391,8 @@ export type ManifestHeaderRoute = ManifestBuiltRoute & Header\n \n export type ManifestRoute = ManifestBuiltRoute & {\n   page: string\n-  namedRegex?: string\n-  routeKeys?: { [key: string]: string }\n+  namedRegex: string\n+  routeKeys: { [key: string]: string }\n \n   /**\n    * If true, this indicates that the route has fallback root params. This is\n@@ -4112,6 +4112,9 @@ export default async function build(\n         await handleBuildComplete({\n           dir,\n           distDir,\n+          config,\n+          staticPages,\n+          nextVersion: process.env.__NEXT_VERSION as string,\n           tracingRoot: outputFileTracingRoot,\n           hasNodeMiddleware,\n           hasInstrumentationHook,"
        },
        {
            "sha": "382e808cbb0e8083f1c3b96b17b172cdd8cb92f6",
            "filename": "packages/next/src/lib/load-custom-routes.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/f507b0e66bb10275fa2c1c6c6d344b36e28458a1/packages%2Fnext%2Fsrc%2Flib%2Fload-custom-routes.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f507b0e66bb10275fa2c1c6c6d344b36e28458a1/packages%2Fnext%2Fsrc%2Flib%2Fload-custom-routes.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Flib%2Fload-custom-routes.ts?ref=f507b0e66bb10275fa2c1c6c6d344b36e28458a1",
            "patch": "@@ -55,6 +55,7 @@ export type Redirect = {\n   locale?: false\n   has?: RouteHas[]\n   missing?: RouteHas[]\n+  priority?: boolean\n \n   /**\n    * @internal - used internally for routing\n@@ -740,6 +741,7 @@ export default async function loadCustomRoutes(\n           permanent: true,\n           locale: config.i18n ? false : undefined,\n           internal: true,\n+          priority: true,\n           // don't run this redirect for _next/data requests\n           missing: [\n             {\n@@ -754,6 +756,7 @@ export default async function loadCustomRoutes(\n           permanent: true,\n           locale: config.i18n ? false : undefined,\n           internal: true,\n+          priority: true,\n         }\n       )\n       if (config.basePath) {\n@@ -764,6 +767,7 @@ export default async function loadCustomRoutes(\n           basePath: false,\n           locale: config.i18n ? false : undefined,\n           internal: true,\n+          priority: true,\n         })\n       }\n     } else {\n@@ -773,6 +777,7 @@ export default async function loadCustomRoutes(\n         permanent: true,\n         locale: config.i18n ? false : undefined,\n         internal: true,\n+        priority: true,\n       })\n       if (config.basePath) {\n         redirects.unshift({\n@@ -782,6 +787,7 @@ export default async function loadCustomRoutes(\n           basePath: false,\n           locale: config.i18n ? false : undefined,\n           internal: true,\n+          priority: true,\n         })\n       }\n     }"
        },
        {
            "sha": "080eecac25373f37732f9fdc146be95e9fbb3c91",
            "filename": "packages/next/src/server/config-shared.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 156,
            "changes": 157,
            "blob_url": "https://github.com/vercel/next.js/blob/f507b0e66bb10275fa2c1c6c6d344b36e28458a1/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f507b0e66bb10275fa2c1c6c6d344b36e28458a1/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts?ref=f507b0e66bb10275fa2c1c6c6d344b36e28458a1",
            "patch": "@@ -1,11 +1,6 @@\n import os from 'os'\n import type { webpack } from 'next/dist/compiled/webpack/webpack'\n-import type {\n-  Header,\n-  Redirect,\n-  Rewrite,\n-  RouteHas,\n-} from '../lib/load-custom-routes'\n+import type { Header, Redirect, Rewrite } from '../lib/load-custom-routes'\n import { imageConfigDefault } from '../shared/lib/image-config'\n import type {\n   ImageConfig,\n@@ -18,17 +13,7 @@ import type { SizeLimit } from '../types'\n import type { SupportedTestRunners } from '../cli/next-test'\n import type { ExperimentalPPRConfig } from './lib/experimental/ppr'\n import { INFINITE_CACHE } from '../lib/constants'\n-import type {\n-  ManifestRewriteRoute,\n-  ManifestHeaderRoute,\n-  ManifestRedirectRoute,\n-  ManifestRoute,\n-} from '../build'\n import { isStableBuild } from '../shared/lib/canary-only'\n-import type { RenderingMode } from '../build/rendering-mode'\n-import type { Revalidate } from './lib/cache-control'\n-import type { AdapterOutputType } from '../shared/lib/constants'\n-import type { MiddlewareMatcher } from '../build/analysis/get-page-static-info'\n import type { FallbackRouteParam } from '../build/static-paths/types'\n \n export type NextConfigComplete = Required<NextConfig> & {\n@@ -43,146 +28,6 @@ export type NextConfigComplete = Required<NextConfig> & {\n   experimental: Omit<ExperimentalConfig, 'turbo'>\n }\n \n-export type AdapterOutputs = Array<{\n-  /**\n-   * id is a unique identifier for the output\n-   */\n-  id: string\n-  /**\n-   * pathname is the URL path that the output is meant to\n-   * be routable to at e.g. /blog/[slug] or /_next/static/chunks/chunk.js\n-   */\n-  pathname: string\n-  /**\n-   * runtime for the route, this doesn't apply for prerender or static\n-   */\n-  runtime?: 'nodejs' | 'edge'\n-  /**\n-   * config related to the route\n-   */\n-  config?: {\n-    /**\n-     * maxDuration is a segment config to signal the max\n-     * execution duration a route should be allowed before\n-     * it's timed out\n-     */\n-    maxDuration?: number\n-    /**\n-     * preferredRegion is a segment config to signal deployment\n-     * region preferences to the provider being used\n-     */\n-    preferredRegion?: string | string[]\n-\n-    /**\n-     * allowQuery is the allowed query values to be passed\n-     * to an ISR function and what should be considered for the cacheKey\n-     * e.g. for /blog/[slug], \"slug\" is the only allowQuery\n-     */\n-    allowQuery?: string[]\n-    /**\n-     * allowHeader is the allowed headers to be passed to an\n-     * ISR function to prevent accidentally poisoning the cache\n-     * from leaking additional information that can impact the render\n-     */\n-    allowHeader?: string[]\n-    /**\n-     * bypass for is a list of has conditions the cache\n-     * should be bypassed and invoked directly e.g. action header\n-     */\n-    bypassFor?: RouteHas[]\n-    /**\n-     * renderingMode signals PPR or not for a prerender\n-     */\n-    renderingMode?: RenderingMode\n-\n-    /**\n-     * matchers are the configured matchers for middleware\n-     */\n-    matchers?: MiddlewareMatcher[]\n-\n-    /**\n-     * bypassToken is the generated token that signals a prerender cache\n-     * should be bypassed\n-     */\n-    bypassToken?: string\n-\n-    /**\n-     * postponed is the PPR state when it postponed and is used for resuming\n-     */\n-    postponed?: string\n-  }\n-  /**\n-   * For prerenders the parent output is the originating\n-   * page that the prerender is created from\n-   */\n-  parentOutputId?: string\n-  /**\n-   * fallback is initial cache data generated during build for a prerender\n-   */\n-  fallback?: {\n-    /**\n-     * path to the fallback file can be HTML/JSON/RSC\n-     */\n-    filePath: string\n-    /**\n-     * initialStatus is the status code that should be applied\n-     * when serving the fallback\n-     */\n-    initialStatus?: number\n-    /**\n-     * initialHeaders are the headers that should be sent when\n-     * serving the fallback\n-     */\n-    initialHeaders?: Record<string, string | string[]>\n-    /**\n-     * initial expiration is how long until the fallback entry\n-     * is considered expired and no longer valid to serve\n-     */\n-    initialExpiration?: number\n-    /**\n-     * initial revalidate is how long until the fallback is\n-     * considered stale and should be revalidated\n-     */\n-    initialRevalidate?: Revalidate\n-  }\n-  /**\n-   * assets are all necessary traced assets that could be\n-   * loaded by the output to handle a request e.g. traced\n-   * node_modules or necessary manifests for Next.js\n-   */\n-  assets?: Record<string, string>\n-  /**\n-   * filePath is present for all cases except a Prerender\n-   * which may or may not have a fallback (initial cache entry).\n-   * The parent output will have a filePath for a prerender though\n-   */\n-  filePath?: string\n-  /**\n-   * type of output\n-   */\n-  type: AdapterOutputType\n-}>\n-\n-export interface NextAdapter {\n-  name: string\n-  modifyConfig?: (\n-    config: NextConfigComplete\n-  ) => Promise<NextConfigComplete> | NextConfigComplete\n-  onBuildComplete?: (ctx: {\n-    routes: {\n-      headers: Array<ManifestHeaderRoute>\n-      redirects: Array<ManifestRedirectRoute>\n-      rewrites: {\n-        beforeFiles: Array<ManifestRewriteRoute>\n-        afterFiles: Array<ManifestRewriteRoute>\n-        fallback: Array<ManifestRewriteRoute>\n-      }\n-      dynamicRoutes: ReadonlyArray<ManifestRoute>\n-    }\n-    outputs: AdapterOutputs\n-  }) => Promise<void> | void\n-}\n-\n export type I18NDomains = readonly DomainLocale[]\n \n export interface I18NConfig {"
        },
        {
            "sha": "0f49f77f7d68d5aebfd85f65ddc4ae8d9ddd3bc1",
            "filename": "packages/next/src/server/config.test.ts",
            "status": "modified",
            "additions": 17,
            "deletions": 15,
            "changes": 32,
            "blob_url": "https://github.com/vercel/next.js/blob/f507b0e66bb10275fa2c1c6c6d344b36e28458a1/packages%2Fnext%2Fsrc%2Fserver%2Fconfig.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f507b0e66bb10275fa2c1c6c6d344b36e28458a1/packages%2Fnext%2Fsrc%2Fserver%2Fconfig.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fconfig.test.ts?ref=f507b0e66bb10275fa2c1c6c6d344b36e28458a1",
            "patch": "@@ -1,3 +1,5 @@\n+import { PHASE_PRODUCTION_BUILD } from '../api/constants'\n+\n describe('loadConfig', () => {\n   let loadConfig: typeof import('./config').default\n \n@@ -12,7 +14,7 @@ describe('loadConfig', () => {\n   })\n   describe('nextConfig.images defaults', () => {\n     it('should assign a `images.remotePatterns` when using assetPrefix', async () => {\n-      const result = await loadConfig('', __dirname, {\n+      const result = await loadConfig(PHASE_PRODUCTION_BUILD, __dirname, {\n         customConfig: {\n           assetPrefix: 'https://cdn.example.com',\n           images: {\n@@ -33,7 +35,7 @@ describe('loadConfig', () => {\n     })\n \n     it('should not assign a duplicate `images.remotePatterns` value when using assetPrefix', async () => {\n-      let result = await loadConfig('', __dirname, {\n+      let result = await loadConfig(PHASE_PRODUCTION_BUILD, __dirname, {\n         customConfig: {\n           assetPrefix: 'https://cdn.example.com',\n           images: {\n@@ -51,7 +53,7 @@ describe('loadConfig', () => {\n \n       expect(result.images.remotePatterns.length).toBe(1)\n \n-      result = await loadConfig('', __dirname, {\n+      result = await loadConfig(PHASE_PRODUCTION_BUILD, __dirname, {\n         customConfig: {\n           assetPrefix: 'https://cdn.example.com/foobar',\n           images: {\n@@ -81,7 +83,7 @@ describe('loadConfig', () => {\n     })\n \n     it('should not print a stack trace when throwing an error', async () => {\n-      const loadConfigPromise = loadConfig('', __dirname, {\n+      const loadConfigPromise = loadConfig(PHASE_PRODUCTION_BUILD, __dirname, {\n         customConfig: {\n           experimental: {\n             ppr: true,\n@@ -105,7 +107,7 @@ describe('loadConfig', () => {\n \n     it('errors when using PPR if not in canary', async () => {\n       await expect(\n-        loadConfig('', __dirname, {\n+        loadConfig(PHASE_PRODUCTION_BUILD, __dirname, {\n           customConfig: {\n             experimental: {\n               ppr: true,\n@@ -119,7 +121,7 @@ describe('loadConfig', () => {\n \n     it('errors when using cacheComponents if not in canary', async () => {\n       await expect(\n-        loadConfig('', __dirname, {\n+        loadConfig(PHASE_PRODUCTION_BUILD, __dirname, {\n           customConfig: {\n             experimental: {\n               cacheComponents: true,\n@@ -133,7 +135,7 @@ describe('loadConfig', () => {\n \n     it('errors when using persistentCaching if not in canary', async () => {\n       await expect(\n-        loadConfig('', __dirname, {\n+        loadConfig(PHASE_PRODUCTION_BUILD, __dirname, {\n           customConfig: {\n             experimental: {\n               turbopackPersistentCaching: true,\n@@ -157,7 +159,7 @@ describe('loadConfig', () => {\n \n     it('errors when cacheComponents is enabled but PPR is disabled', async () => {\n       await expect(\n-        loadConfig('', __dirname, {\n+        loadConfig(PHASE_PRODUCTION_BUILD, __dirname, {\n           customConfig: {\n             experimental: {\n               cacheComponents: true,\n@@ -172,7 +174,7 @@ describe('loadConfig', () => {\n \n     it('errors when rdcForNavigations is enabled but ppr is disabled', async () => {\n       await expect(\n-        loadConfig('', __dirname, {\n+        loadConfig(PHASE_PRODUCTION_BUILD, __dirname, {\n           customConfig: {\n             experimental: {\n               rdcForNavigations: true,\n@@ -186,7 +188,7 @@ describe('loadConfig', () => {\n     })\n \n     it('defaults rdcForNavigations to true when ppr is enabled', async () => {\n-      const result = await loadConfig('', __dirname, {\n+      const result = await loadConfig(PHASE_PRODUCTION_BUILD, __dirname, {\n         customConfig: {\n           experimental: {\n             ppr: true,\n@@ -198,7 +200,7 @@ describe('loadConfig', () => {\n     })\n \n     it('allows explicitly disabling rdcForNavigations when ppr is enabled', async () => {\n-      const result = await loadConfig('', __dirname, {\n+      const result = await loadConfig(PHASE_PRODUCTION_BUILD, __dirname, {\n         customConfig: {\n           experimental: {\n             ppr: true,\n@@ -212,7 +214,7 @@ describe('loadConfig', () => {\n \n     it('errors when cacheComponents is enabled but PPR set to \"incremental\"', async () => {\n       await expect(\n-        loadConfig('', __dirname, {\n+        loadConfig(PHASE_PRODUCTION_BUILD, __dirname, {\n           customConfig: {\n             experimental: {\n               cacheComponents: true,\n@@ -228,7 +230,7 @@ describe('loadConfig', () => {\n     it('migrates experimental.dynamicIO to experimental.cacheComponents', async () => {\n       process.env.__NEXT_VERSION = 'canary'\n \n-      const result = await loadConfig('', __dirname, {\n+      const result = await loadConfig(PHASE_PRODUCTION_BUILD, __dirname, {\n         customConfig: {\n           experimental: {\n             dynamicIO: true,\n@@ -246,7 +248,7 @@ describe('loadConfig', () => {\n     it('preserves cacheComponents when both dynamicIO and cacheComponents are set', async () => {\n       process.env.__NEXT_VERSION = 'canary'\n \n-      const result = await loadConfig('', __dirname, {\n+      const result = await loadConfig(PHASE_PRODUCTION_BUILD, __dirname, {\n         customConfig: {\n           experimental: {\n             dynamicIO: true,\n@@ -267,7 +269,7 @@ describe('loadConfig', () => {\n \n       const consoleSpy = jest.spyOn(console, 'warn').mockImplementation()\n \n-      await loadConfig('', __dirname, {\n+      await loadConfig(PHASE_PRODUCTION_BUILD, __dirname, {\n         customConfig: {\n           experimental: {\n             dynamicIO: true,"
        },
        {
            "sha": "23e95f85cddf59b3a8ad6017d901d522bf1d5a1a",
            "filename": "packages/next/src/server/config.ts",
            "status": "modified",
            "additions": 13,
            "deletions": 13,
            "changes": 26,
            "blob_url": "https://github.com/vercel/next.js/blob/f507b0e66bb10275fa2c1c6c6d344b36e28458a1/packages%2Fnext%2Fsrc%2Fserver%2Fconfig.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f507b0e66bb10275fa2c1c6c6d344b36e28458a1/packages%2Fnext%2Fsrc%2Fserver%2Fconfig.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fconfig.ts?ref=f507b0e66bb10275fa2c1c6c6d344b36e28458a1",
            "patch": "@@ -9,15 +9,14 @@ import {\n   PHASE_DEVELOPMENT_SERVER,\n   PHASE_EXPORT,\n   PHASE_PRODUCTION_BUILD,\n-  PHASE_PRODUCTION_SERVER,\n+  type PHASE_TYPE,\n } from '../shared/lib/constants'\n import { defaultConfig, normalizeConfig } from './config-shared'\n import type {\n   ExperimentalConfig,\n   NextConfigComplete,\n   NextConfig,\n   TurbopackLoaderItem,\n-  NextAdapter,\n } from './config-shared'\n \n import { loadWebpackHook } from './config-utils'\n@@ -43,6 +42,7 @@ import { findDir } from '../lib/find-pages-dir'\n import { CanaryOnlyError, isStableBuild } from '../shared/lib/canary-only'\n import { interopDefault } from '../lib/interop-default'\n import { djb2Hash } from '../shared/lib/hash'\n+import type { NextAdapter } from '../build/adapter/build-complete'\n \n export { normalizeConfig } from './config-shared'\n export type { DomainLocale, NextConfig } from './config-shared'\n@@ -1203,15 +1203,12 @@ function assignDefaultsAndValidate(\n \n async function applyModifyConfig(\n   config: NextConfigComplete,\n-  phase: string,\n+  phase: PHASE_TYPE,\n   silent: boolean\n ): Promise<NextConfigComplete> {\n-  if (\n-    // TODO: should this be called for server start as\n-    // adapters shouldn't be relying on \"next start\"\n-    [PHASE_PRODUCTION_BUILD, PHASE_PRODUCTION_SERVER].includes(phase) &&\n-    config.experimental?.adapterPath\n-  ) {\n+  // we always call modify config  and phase can be used to only\n+  // modify for specific times\n+  if (config.experimental?.adapterPath) {\n     const adapterMod = interopDefault(\n       await import(\n         pathToFileURL(require.resolve(config.experimental.adapterPath)).href\n@@ -1222,7 +1219,10 @@ async function applyModifyConfig(\n       if (!silent) {\n         Log.info(`Applying modifyConfig from ${adapterMod.name}`)\n       }\n-      config = await adapterMod.modifyConfig(config)\n+\n+      config = await adapterMod.modifyConfig(config, {\n+        phase,\n+      })\n     }\n   }\n   return config\n@@ -1241,7 +1241,7 @@ const configCache = new Map<\n // Generate cache key based on parameters that affect config output\n // We need a unique key for cache because there can be multiple values\n function getCacheKey(\n-  phase: string,\n+  phase: PHASE_TYPE,\n   dir: string,\n   customConfig?: object | null,\n   reactProductionProfiling?: boolean,\n@@ -1261,7 +1261,7 @@ function getCacheKey(\n }\n \n export default async function loadConfig(\n-  phase: string,\n+  phase: PHASE_TYPE,\n   dir: string,\n   {\n     customConfig,\n@@ -1656,7 +1656,7 @@ function enforceExperimentalFeatures(\n     isDefaultConfig: boolean\n     configuredExperimentalFeatures: ConfiguredExperimentalFeature[] | undefined\n     debugPrerender: boolean | undefined\n-    phase: string\n+    phase: PHASE_TYPE\n   }\n ) {\n   const {"
        },
        {
            "sha": "8c57901fdc58275d0de49b809f8374dd87f2d692",
            "filename": "packages/next/src/server/lib/router-utils/filesystem.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 2,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/f507b0e66bb10275fa2c1c6c6d344b36e28458a1/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Ffilesystem.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f507b0e66bb10275fa2c1c6c6d344b36e28458a1/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Ffilesystem.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Ffilesystem.ts?ref=f507b0e66bb10275fa2c1c6c6d344b36e28458a1",
            "patch": "@@ -22,7 +22,10 @@ import { recursiveReadDir } from '../../../lib/recursive-readdir'\n import { isDynamicRoute } from '../../../shared/lib/router/utils'\n import { escapeStringRegexp } from '../../../shared/lib/escape-regexp'\n import { getPathMatch } from '../../../shared/lib/router/utils/path-match'\n-import { getRouteRegex } from '../../../shared/lib/router/utils/route-regex'\n+import {\n+  getNamedRouteRegex,\n+  getRouteRegex,\n+} from '../../../shared/lib/router/utils/route-regex'\n import { getRouteMatcher } from '../../../shared/lib/router/utils/route-matcher'\n import { pathHasPrefix } from '../../../shared/lib/router/utils/path-has-prefix'\n import { normalizeLocalePath } from '../../../shared/lib/i18n/normalize-locale-path'\n@@ -255,10 +258,14 @@ export async function setupFsCheck(opts: {\n \n     for (const route of routesManifest.dataRoutes) {\n       if (isDynamicRoute(route.page)) {\n-        const routeRegex = getRouteRegex(route.page)\n+        const routeRegex = getNamedRouteRegex(route.page, {\n+          prefixRouteKeys: true,\n+        })\n         dynamicRoutes.push({\n           ...route,\n           regex: routeRegex.re.toString(),\n+          namedRegex: routeRegex.namedRegex,\n+          routeKeys: routeRegex.routeKeys,\n           match: getRouteMatcher({\n             // TODO: fix this in the manifest itself, must also be fixed in\n             // upstream builder that relies on this"
        },
        {
            "sha": "d08ed2d3d734b6282de9ffcbc29a46d4466b1b51",
            "filename": "packages/next/src/server/lib/router-utils/setup-dev-bundler.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 3,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/f507b0e66bb10275fa2c1c6c6d344b36e28458a1/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Fsetup-dev-bundler.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f507b0e66bb10275fa2c1c6c6d344b36e28458a1/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Fsetup-dev-bundler.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Fsetup-dev-bundler.ts?ref=f507b0e66bb10275fa2c1c6c6d344b36e28458a1",
            "patch": "@@ -37,7 +37,7 @@ import {\n } from '../../../build/entries'\n import { verifyTypeScriptSetup } from '../../../lib/verify-typescript-setup'\n import { verifyPartytownSetup } from '../../../lib/verify-partytown-setup'\n-import { getRouteRegex } from '../../../shared/lib/router/utils/route-regex'\n+import { getNamedRouteRegex } from '../../../shared/lib/router/utils/route-regex'\n import { normalizeAppPath } from '../../../shared/lib/router/utils/app-paths'\n import { buildDataRoute } from './build-data-route'\n import { getRouteMatcher } from '../../../shared/lib/router/utils/route-matcher'\n@@ -970,9 +970,13 @@ async function startWatcher(\n \n         opts.fsChecker.dynamicRoutes = sortedRoutes.map(\n           (page): FilesystemDynamicRoute => {\n-            const regex = getRouteRegex(page)\n+            const regex = getNamedRouteRegex(page, {\n+              prefixRouteKeys: true,\n+            })\n             return {\n               regex: regex.re.toString(),\n+              namedRegex: regex.namedRegex,\n+              routeKeys: regex.routeKeys,\n               match: getRouteMatcher(regex),\n               page,\n             }\n@@ -983,10 +987,14 @@ async function startWatcher(\n \n         for (const page of sortedRoutes) {\n           const route = buildDataRoute(page, 'development')\n-          const routeRegex = getRouteRegex(route.page)\n+          const routeRegex = getNamedRouteRegex(route.page, {\n+            prefixRouteKeys: true,\n+          })\n           dataRoutes.push({\n             ...route,\n             regex: routeRegex.re.toString(),\n+            namedRegex: routeRegex.namedRegex,\n+            routeKeys: routeRegex.routeKeys,\n             match: getRouteMatcher({\n               // TODO: fix this in the manifest itself, must also be fixed in\n               // upstream builder that relies on this"
        },
        {
            "sha": "6ee0e79e1435fa14744ea89459fffbf2a9aecd23",
            "filename": "packages/next/src/shared/lib/constants.ts",
            "status": "modified",
            "additions": 25,
            "deletions": 16,
            "changes": 41,
            "blob_url": "https://github.com/vercel/next.js/blob/f507b0e66bb10275fa2c1c6c6d344b36e28458a1/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fconstants.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f507b0e66bb10275fa2c1c6c6d344b36e28458a1/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fconstants.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fconstants.ts?ref=f507b0e66bb10275fa2c1c6c6d344b36e28458a1",
            "patch": "@@ -12,6 +12,22 @@ export const COMPILER_NAMES = {\n \n export type CompilerNameValues = ValueOf<typeof COMPILER_NAMES>\n \n+export const COMPILER_INDEXES: {\n+  [compilerKey in CompilerNameValues]: number\n+} = {\n+  [COMPILER_NAMES.client]: 0,\n+  [COMPILER_NAMES.server]: 1,\n+  [COMPILER_NAMES.edgeServer]: 2,\n+} as const\n+\n+// Re-export entry constants for backward compatibility\n+export {\n+  UNDERSCORE_NOT_FOUND_ROUTE,\n+  UNDERSCORE_NOT_FOUND_ROUTE_ENTRY,\n+  UNDERSCORE_GLOBAL_ERROR_ROUTE,\n+  UNDERSCORE_GLOBAL_ERROR_ROUTE_ENTRY,\n+} from './entry-constants'\n+\n export enum AdapterOutputType {\n   /**\n    * `PAGES` represents all the React pages that are under `pages/`.\n@@ -51,28 +67,21 @@ export enum AdapterOutputType {\n   MIDDLEWARE = 'MIDDLEWARE',\n }\n \n-export const COMPILER_INDEXES: {\n-  [compilerKey in CompilerNameValues]: number\n-} = {\n-  [COMPILER_NAMES.client]: 0,\n-  [COMPILER_NAMES.server]: 1,\n-  [COMPILER_NAMES.edgeServer]: 2,\n-} as const\n-\n-// Re-export entry constants for backward compatibility\n-export {\n-  UNDERSCORE_NOT_FOUND_ROUTE,\n-  UNDERSCORE_NOT_FOUND_ROUTE_ENTRY,\n-  UNDERSCORE_GLOBAL_ERROR_ROUTE,\n-  UNDERSCORE_GLOBAL_ERROR_ROUTE_ENTRY,\n-} from './entry-constants'\n-\n export const PHASE_EXPORT = 'phase-export'\n export const PHASE_PRODUCTION_BUILD = 'phase-production-build'\n export const PHASE_PRODUCTION_SERVER = 'phase-production-server'\n export const PHASE_DEVELOPMENT_SERVER = 'phase-development-server'\n export const PHASE_TEST = 'phase-test'\n export const PHASE_INFO = 'phase-info'\n+\n+export type PHASE_TYPE =\n+  | typeof PHASE_INFO\n+  | typeof PHASE_TEST\n+  | typeof PHASE_EXPORT\n+  | typeof PHASE_PRODUCTION_BUILD\n+  | typeof PHASE_PRODUCTION_SERVER\n+  | typeof PHASE_DEVELOPMENT_SERVER\n+\n export const PAGES_MANIFEST = 'pages-manifest.json'\n export const WEBPACK_STATS = 'webpack-stats.json'\n export const APP_PATHS_MANIFEST = 'app-paths-manifest.json'"
        },
        {
            "sha": "adecee2e84ee6a2f9ced8d05cc13650d77320714",
            "filename": "packages/next/src/types.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/f507b0e66bb10275fa2c1c6c6d344b36e28458a1/packages%2Fnext%2Fsrc%2Ftypes.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f507b0e66bb10275fa2c1c6c6d344b36e28458a1/packages%2Fnext%2Fsrc%2Ftypes.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Ftypes.ts?ref=f507b0e66bb10275fa2c1c6c6d344b36e28458a1",
            "patch": "@@ -29,7 +29,7 @@ export type ServerRuntime = 'nodejs' | 'experimental-edge' | 'edge' | undefined\n // @ts-ignore This path is generated at build time and conflicts otherwise\n export { NextConfig } from './server/config'\n \n-export type { NextAdapter } from './server/config-shared'\n+export type { NextAdapter, AdapterOutput } from './build/adapter/build-complete'\n \n export type {\n   Metadata,"
        },
        {
            "sha": "fa3261bafc3178bc5dd5e822a8b99f802f9b1b47",
            "filename": "test/integration/custom-routes/test/index.test.js",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/f507b0e66bb10275fa2c1c6c6d344b36e28458a1/test%2Fintegration%2Fcustom-routes%2Ftest%2Findex.test.js",
            "raw_url": "https://github.com/vercel/next.js/raw/f507b0e66bb10275fa2c1c6c6d344b36e28458a1/test%2Fintegration%2Fcustom-routes%2Ftest%2Findex.test.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fintegration%2Fcustom-routes%2Ftest%2Findex.test.js?ref=f507b0e66bb10275fa2c1c6c6d344b36e28458a1",
            "patch": "@@ -1857,6 +1857,7 @@ const runTests = (isDev = false) => {\n            {\n              \"destination\": \"/:path+\",\n              \"internal\": true,\n+             \"priority\": true,\n              \"regex\": \"^(?:\\\\/((?:[^\\\\/]+?)(?:\\\\/(?:[^\\\\/]+?))*))\\\\/$\",\n              \"source\": \"/:path+/\",\n              \"statusCode\": 308,"
        },
        {
            "sha": "87614daf776b64cca405f957cbb7afa4ca9231c8",
            "filename": "test/integration/dynamic-routing/test/index.test.js",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/f507b0e66bb10275fa2c1c6c6d344b36e28458a1/test%2Fintegration%2Fdynamic-routing%2Ftest%2Findex.test.js",
            "raw_url": "https://github.com/vercel/next.js/raw/f507b0e66bb10275fa2c1c6c6d344b36e28458a1/test%2Fintegration%2Fdynamic-routing%2Ftest%2Findex.test.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fintegration%2Fdynamic-routing%2Ftest%2Findex.test.js?ref=f507b0e66bb10275fa2c1c6c6d344b36e28458a1",
            "patch": "@@ -1456,6 +1456,7 @@ function runTests({ dev }) {\n            {\n              \"destination\": \"/:path+\",\n              \"internal\": true,\n+             \"priority\": true,\n              \"regex\": \"^(?:/((?:[^/]+?)(?:/(?:[^/]+?))*))/$\",\n              \"source\": \"/:path+/\",\n              \"statusCode\": 308,"
        },
        {
            "sha": "771c6f26073e6ca321d313ae68320c37ec02b9be",
            "filename": "test/production/adapter-config/adapter-config.test.ts",
            "status": "modified",
            "additions": 117,
            "deletions": 51,
            "changes": 168,
            "blob_url": "https://github.com/vercel/next.js/blob/f507b0e66bb10275fa2c1c6c6d344b36e28458a1/test%2Fproduction%2Fadapter-config%2Fadapter-config.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f507b0e66bb10275fa2c1c6c6d344b36e28458a1/test%2Fproduction%2Fadapter-config%2Fadapter-config.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fadapter-config%2Fadapter-config.test.ts?ref=f507b0e66bb10275fa2c1c6c6d344b36e28458a1",
            "patch": "@@ -1,7 +1,7 @@\n import fs from 'fs'\n import { nextTestSetup } from 'e2e-utils'\n-import type { NextAdapter } from 'next'\n-import { AdapterOutputType } from 'next/constants'\n+import type { AdapterOutput, NextAdapter } from 'next'\n+import { version as nextVersion } from 'next/package.json'\n \n describe('adapter-config', () => {\n   const { next } = nextTestSetup({\n@@ -23,56 +23,64 @@ describe('adapter-config', () => {\n   it('should call onBuildComplete with correct context', async () => {\n     expect(next.cliOutput).toContain('onBuildComplete called')\n \n-    const buildContext: Parameters<NextAdapter['onBuildComplete']>[0] =\n-      await next.readJSON('build-complete.json')\n+    const {\n+      outputs,\n+      routes,\n+      config,\n+      ...ctx\n+    }: Parameters<NextAdapter['onBuildComplete']>[0] = await next.readJSON(\n+      'build-complete.json'\n+    )\n \n-    const outputMap = new Map<string, (typeof buildContext.outputs)[0]>()\n-    const prerenderOutputs: typeof buildContext.outputs = []\n-    const staticOutputs: typeof buildContext.outputs = []\n-    const nodeOutputs: typeof buildContext.outputs = []\n-    const edgeOutputs: typeof buildContext.outputs = []\n+    for (const field of ['distDir', 'projectDir', 'repoRoot']) {\n+      expect(ctx[field]).toBeString()\n \n-    for (const output of buildContext.outputs) {\n-      if (outputMap.has(output.id)) {\n+      if (!fs.existsSync(ctx[field])) {\n         throw new Error(\n-          `multiple outputs with same ID ${JSON.stringify(\n-            {\n-              first: outputMap.get(output.id),\n-              second: output,\n-            },\n-            null,\n-            2\n-          )}`\n+          `Invalid dir value provided for ${field} value ${ctx[field]}`\n         )\n       }\n+    }\n \n-      switch (output.type) {\n-        case AdapterOutputType.PRERENDER: {\n-          prerenderOutputs.push(output)\n-          break\n-        }\n-        case AdapterOutputType.STATIC_FILE: {\n-          staticOutputs.push(output)\n-          break\n-        }\n-        case AdapterOutputType.APP_PAGE:\n-        case AdapterOutputType.APP_ROUTE:\n-        case AdapterOutputType.PAGES:\n-        case AdapterOutputType.PAGES_API: {\n-          if (output.runtime === 'nodejs') {\n-            nodeOutputs.push(output)\n-          } else if (output.runtime === 'edge') {\n-            edgeOutputs.push(output)\n-          } else {\n-            throw new Error(\n-              `unrecognized runtime on ${JSON.stringify(output, null, 2)}`\n-            )\n-          }\n-          break\n-        }\n-        default: {\n-          throw new Error(`unrecognized output type ${output.type}`)\n-        }\n+    expect(ctx.nextVersion).toBe(nextVersion)\n+    expect(config?.basePath).toBe('/docs')\n+\n+    const combinedRouteOutputs = [\n+      ...outputs.appPages,\n+      ...outputs.appRoutes,\n+      ...outputs.pages,\n+      ...outputs.pagesApi,\n+    ]\n+\n+    type PageRoutesType =\n+      | AdapterOutput['APP_PAGE']\n+      | AdapterOutput['APP_ROUTE']\n+      | AdapterOutput['PAGES']\n+      | AdapterOutput['PAGES_API']\n+\n+    const outputMap = new Map<string, PageRoutesType>()\n+    const prerenderOutputs: AdapterOutput['PRERENDER'][] = outputs.prerenders\n+    const staticOutputs: AdapterOutput['STATIC_FILE'][] = outputs.staticFiles\n+    const nodeOutputs: PageRoutesType[] = []\n+    const edgeOutputs: PageRoutesType[] = []\n+\n+    for (const routeOutput of combinedRouteOutputs) {\n+      if (outputMap.has(routeOutput.id)) {\n+        require('console').error({\n+          existingOutput: outputMap.get(routeOutput.id),\n+          newOutput: routeOutput,\n+        })\n+        throw new Error(`duplicate id on route outputs ${routeOutput.id}`)\n+      }\n+      outputMap.set(routeOutput.id, routeOutput)\n+\n+      if (routeOutput.runtime === 'edge') {\n+        edgeOutputs.push(routeOutput)\n+      } else if (routeOutput.runtime === 'nodejs') {\n+        nodeOutputs.push(routeOutput)\n+      } else {\n+        require('console').error(routeOutput)\n+        throw new Error(`Unexpected runtime on output ${routeOutput.runtime}`)\n       }\n     }\n \n@@ -83,17 +91,25 @@ describe('adapter-config', () => {\n \n     for (const output of staticOutputs) {\n       expect(output.id).toBeTruthy()\n-      expect(output.pathname).toStartWith('/_next/static')\n-      expect(fs.existsSync(output.filePath)).toBe(true)\n+\n+      if (output.filePath.endsWith('.html')) {\n+        expect(output.pathname.endsWith('.html')).toBe(false)\n+      } else {\n+        expect(output.pathname).toStartWith('/_next/static')\n+      }\n+\n+      const stats = await fs.promises.stat(output.filePath)\n+      expect(stats.isFile()).toBe(true)\n     }\n \n     for (const prerenderOutput of prerenderOutputs) {\n       try {\n         expect(prerenderOutput.parentOutputId).toBeTruthy()\n         if (prerenderOutput.fallback) {\n-          expect(await fs.existsSync(prerenderOutput.fallback.filePath)).toBe(\n-            true\n+          const stats = await fs.promises.stat(\n+            prerenderOutput.fallback.filePath\n           )\n+          expect(stats.isFile()).toBe(true)\n           expect(prerenderOutput.fallback.initialRevalidate).toBeDefined()\n         }\n \n@@ -106,7 +122,57 @@ describe('adapter-config', () => {\n       }\n     }\n \n-    expect(buildContext.routes).toEqual({\n+    for (const route of nodeOutputs) {\n+      try {\n+        expect(route.id).toBeString()\n+        expect(route.config).toBeObject()\n+        expect(route.pathname).toBeString()\n+        expect(route.runtime).toBe('nodejs')\n+\n+        const stats = await fs.promises.stat(route.filePath)\n+        expect(stats.isFile()).toBe(true)\n+\n+        const missingAssets: string[] = []\n+\n+        for (const filePath of Object.values(route.assets)) {\n+          if (!fs.existsSync(filePath)) {\n+            missingAssets.push(filePath)\n+          }\n+        }\n+\n+        expect(missingAssets).toEqual([])\n+      } catch (err) {\n+        require('console').error(`Invalid fields for ${route.id}`, route, err)\n+        throw err\n+      }\n+    }\n+\n+    for (const route of edgeOutputs) {\n+      try {\n+        expect(route.id).toBeString()\n+        expect(route.config).toBeObject()\n+        expect(route.pathname).toBeString()\n+        expect(route.runtime).toBe('edge')\n+\n+        const stats = await fs.promises.stat(route.filePath)\n+        expect(stats.isFile()).toBe(true)\n+\n+        const missingAssets: string[] = []\n+\n+        for (const filePath of Object.values(route.assets)) {\n+          if (!fs.existsSync(filePath)) {\n+            missingAssets.push(filePath)\n+          }\n+        }\n+\n+        expect(missingAssets).toEqual([])\n+      } catch (err) {\n+        require('console').error(`Invalid fields for ${route.id}`, route, err)\n+        throw err\n+      }\n+    }\n+\n+    expect(routes).toEqual({\n       dynamicRoutes: expect.toBeArray(),\n       rewrites: expect.toBeObject(),\n       redirects: expect.toBeArray(),"
        },
        {
            "sha": "e961d8308cf7220e8da38c5a978cff3aea324fcc",
            "filename": "test/production/adapter-config/my-adapter.mjs",
            "status": "modified",
            "additions": 5,
            "deletions": 2,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/f507b0e66bb10275fa2c1c6c6d344b36e28458a1/test%2Fproduction%2Fadapter-config%2Fmy-adapter.mjs",
            "raw_url": "https://github.com/vercel/next.js/raw/f507b0e66bb10275fa2c1c6c6d344b36e28458a1/test%2Fproduction%2Fadapter-config%2Fmy-adapter.mjs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fadapter-config%2Fmy-adapter.mjs?ref=f507b0e66bb10275fa2c1c6c6d344b36e28458a1",
            "patch": "@@ -4,8 +4,11 @@ import fs from 'fs'\n /** @type {import('next').NextAdapter } */\n const myAdapter = {\n   name: 'my-custom-adapter',\n-  modifyConfig: (config) => {\n-    console.log('called modify config in adapter')\n+  modifyConfig: (config, { phase }) => {\n+    if (typeof phase !== 'string') {\n+      throw new Error(`invalid phase value provided to modifyConfig ${phase}`)\n+    }\n+    console.log('called modify config in adapter with phase', phase)\n     config.basePath = '/docs'\n     return config\n   },"
        },
        {
            "sha": "4604ad2c2ffd5d6c2b5afd21ce29263caf0a0bae",
            "filename": "test/production/adapter-config/pages/automatic-static-pages.js",
            "status": "added",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/f507b0e66bb10275fa2c1c6c6d344b36e28458a1/test%2Fproduction%2Fadapter-config%2Fpages%2Fautomatic-static-pages.js",
            "raw_url": "https://github.com/vercel/next.js/raw/f507b0e66bb10275fa2c1c6c6d344b36e28458a1/test%2Fproduction%2Fadapter-config%2Fpages%2Fautomatic-static-pages.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fadapter-config%2Fpages%2Fautomatic-static-pages.js?ref=f507b0e66bb10275fa2c1c6c6d344b36e28458a1",
            "patch": "@@ -0,0 +1,3 @@\n+export default function Pages() {\n+  return <p>automatic-static-pages</p>\n+}"
        }
    ],
    "stats": {
        "total": 1050,
        "additions": 704,
        "deletions": 346
    }
}