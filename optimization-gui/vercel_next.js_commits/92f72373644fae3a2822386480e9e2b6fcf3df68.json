{
    "author": "sokra",
    "message": "Turbopack: refactor graph traveral and fix module graph determinism (#87312)\n\n### What?\n\nSimplifies the graph traversal.\nAllows the GraphStore to store edges and nodes.\nThis no longer forces us to abuse the node type to store edge info, which actually has lead to a race condition problem which made the module graph non-deterministic.\n\nRemoves `skip_duplicated` and made the AdjacencyMap always skip duplicates. That simplifies the implementation. We never not skipped duplicates and that rarely makes sense anyway since any cycle would make it traverse forever...\n\nAlso removed a bunch of unused stuff...",
    "sha": "92f72373644fae3a2822386480e9e2b6fcf3df68",
    "files": [
        {
            "sha": "95eb96cca73e0b5f54118361213f45bdad719c05",
            "filename": "crates/next-api/src/nft_json.rs",
            "status": "modified",
            "additions": 23,
            "deletions": 18,
            "changes": 41,
            "blob_url": "https://github.com/vercel/next.js/blob/92f72373644fae3a2822386480e9e2b6fcf3df68/crates%2Fnext-api%2Fsrc%2Fnft_json.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/92f72373644fae3a2822386480e9e2b6fcf3df68/crates%2Fnext-api%2Fsrc%2Fnft_json.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fnft_json.rs?ref=92f72373644fae3a2822386480e9e2b6fcf3df68",
            "patch": "@@ -6,7 +6,7 @@ use tracing::{Instrument, Level, Span};\n use turbo_rcstr::RcStr;\n use turbo_tasks::{\n     FxIndexMap, ReadRef, ResolvedVc, TryFlatJoinIterExt, TryJoinIterExt, ValueToString, Vc,\n-    graph::{AdjacencyMap, GraphTraversal, Visit, VisitControlFlow},\n+    graph::{AdjacencyMap, GraphTraversal, Visit},\n };\n use turbo_tasks_fs::{\n     DirectoryEntry, File, FileContent, FileSystem, FileSystemPath,\n@@ -404,7 +404,6 @@ pub async fn all_assets_from_entries_filtered(\n     let emit_spans = tracing::enabled!(Level::INFO);\n     Ok(Vc::cell(\n         AdjacencyMap::new()\n-            .skip_duplicates()\n             .visit(\n                 entries\n                     .await?\n@@ -431,7 +430,6 @@ pub async fn all_assets_from_entries_filtered(\n             )\n             .await\n             .completed()?\n-            .into_inner()\n             .into_postorder_topological()\n             .map(|n| n.0)\n             .collect(),\n@@ -446,14 +444,12 @@ struct OutputAssetFilteredVisit {\n impl Visit<(ResolvedVc<Box<dyn OutputAsset>>, Option<ReadRef<RcStr>>)>\n     for OutputAssetFilteredVisit\n {\n-    type Edge = (ResolvedVc<Box<dyn OutputAsset>>, Option<ReadRef<RcStr>>);\n-    type EdgesIntoIter = Vec<Self::Edge>;\n+    type EdgesIntoIter = Vec<(\n+        (ResolvedVc<Box<dyn OutputAsset>>, Option<ReadRef<RcStr>>),\n+        (),\n+    )>;\n     type EdgesFuture = impl Future<Output = Result<Self::EdgesIntoIter>>;\n \n-    fn visit(&mut self, edge: Self::Edge) -> VisitControlFlow<Self::Edge> {\n-        VisitControlFlow::Continue(edge)\n-    }\n-\n     fn edges(\n         &mut self,\n         node: &(ResolvedVc<Box<dyn OutputAsset>>, Option<ReadRef<RcStr>>),\n@@ -466,6 +462,7 @@ impl Visit<(ResolvedVc<Box<dyn OutputAsset>>, Option<ReadRef<RcStr>>)>\n     fn span(\n         &mut self,\n         node: &(ResolvedVc<Box<dyn OutputAsset>>, Option<ReadRef<RcStr>>),\n+        _edge: Option<&()>,\n     ) -> tracing::Span {\n         if let Some(ident) = &node.1 {\n             tracing::trace_span!(\"asset\", name = display(ident))\n@@ -482,7 +479,12 @@ async fn get_referenced_server_assets(\n     asset: ResolvedVc<Box<dyn OutputAsset>>,\n     client_root: Option<FileSystemPath>,\n     exclude_glob: Option<ReadRef<Glob>>,\n-) -> Result<Vec<(ResolvedVc<Box<dyn OutputAsset>>, Option<ReadRef<RcStr>>)>> {\n+) -> Result<\n+    Vec<(\n+        (ResolvedVc<Box<dyn OutputAsset>>, Option<ReadRef<RcStr>>),\n+        (),\n+    )>,\n+> {\n     let refs = asset.references().all_assets().await?;\n \n     refs.iter()\n@@ -503,14 +505,17 @@ async fn get_referenced_server_assets(\n             }\n \n             Ok(Some((\n-                *asset,\n-                if emit_spans {\n-                    // INVALIDATION: we don't need to invalidate the list of assets when the span\n-                    // name changes\n-                    Some(asset.path_string().untracked().await?)\n-                } else {\n-                    None\n-                },\n+                (\n+                    *asset,\n+                    if emit_spans {\n+                        // INVALIDATION: we don't need to invalidate the list of assets when the\n+                        // span name changes\n+                        Some(asset.path_string().untracked().await?)\n+                    } else {\n+                        None\n+                    },\n+                ),\n+                (),\n             )))\n         })\n         .try_flat_join()"
        },
        {
            "sha": "ac4b0aab9ae9d29161865a1877ff915608090c33",
            "filename": "crates/next-core/src/next_client_reference/visit_client_reference.rs",
            "status": "modified",
            "additions": 41,
            "deletions": 34,
            "changes": 75,
            "blob_url": "https://github.com/vercel/next.js/blob/92f72373644fae3a2822386480e9e2b6fcf3df68/crates%2Fnext-core%2Fsrc%2Fnext_client_reference%2Fvisit_client_reference.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/92f72373644fae3a2822386480e9e2b6fcf3df68/crates%2Fnext-core%2Fsrc%2Fnext_client_reference%2Fvisit_client_reference.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_client_reference%2Fvisit_client_reference.rs?ref=92f72373644fae3a2822386480e9e2b6fcf3df68",
            "patch": "@@ -86,7 +86,6 @@ pub async fn find_server_entries(\n     async move {\n         let emit_spans = tracing::enabled!(Level::INFO);\n         let graph = AdjacencyMap::new()\n-            .skip_duplicates()\n             .visit(\n                 vec![FindServerEntriesNode::Internal(\n                     entry,\n@@ -104,8 +103,7 @@ pub async fn find_server_entries(\n                 },\n             )\n             .await\n-            .completed()?\n-            .into_inner();\n+            .completed()?;\n \n         let mut server_component_entries = vec![];\n         let mut server_utils = vec![];\n@@ -151,16 +149,15 @@ enum FindServerEntriesNode {\n }\n \n impl Visit<FindServerEntriesNode> for FindServerEntries {\n-    type Edge = FindServerEntriesNode;\n-    type EdgesIntoIter = Vec<Self::Edge>;\n+    type EdgesIntoIter = Vec<(FindServerEntriesNode, ())>;\n     type EdgesFuture = impl Future<Output = Result<Self::EdgesIntoIter>>;\n \n-    fn visit(&mut self, edge: Self::Edge) -> VisitControlFlow<FindServerEntriesNode> {\n-        match edge {\n-            FindServerEntriesNode::Internal(..) => VisitControlFlow::Continue(edge),\n+    fn visit(&mut self, node: &FindServerEntriesNode, _edge: Option<&()>) -> VisitControlFlow {\n+        match node {\n+            FindServerEntriesNode::Internal(..) => VisitControlFlow::Continue,\n             FindServerEntriesNode::ClientReference\n             | FindServerEntriesNode::ServerUtilEntry(..)\n-            | FindServerEntriesNode::ServerComponentEntry(..) => VisitControlFlow::Skip(edge),\n+            | FindServerEntriesNode::ServerComponentEntry(..) => VisitControlFlow::Skip,\n         }\n     }\n \n@@ -202,47 +199,57 @@ impl Visit<FindServerEntriesNode> for FindServerEntries {\n                         || ResolvedVc::try_downcast_type::<CssClientReferenceModule>(*module)\n                             .is_some()\n                     {\n-                        return Ok(FindServerEntriesNode::ClientReference);\n+                        return Ok((FindServerEntriesNode::ClientReference, ()));\n                     }\n \n                     if let Some(server_component_asset) =\n                         ResolvedVc::try_downcast_type::<NextServerComponentModule>(*module)\n                     {\n-                        return Ok(FindServerEntriesNode::ServerComponentEntry(\n-                            server_component_asset,\n-                            if emit_spans {\n-                                // INVALIDATION: we don't need to invalidate when the span name\n-                                // changes\n-                                Some(server_component_asset.ident_string().untracked().await?)\n-                            } else {\n-                                None\n-                            },\n+                        return Ok((\n+                            FindServerEntriesNode::ServerComponentEntry(\n+                                server_component_asset,\n+                                if emit_spans {\n+                                    // INVALIDATION: we don't need to invalidate when the span name\n+                                    // changes\n+                                    Some(server_component_asset.ident_string().untracked().await?)\n+                                } else {\n+                                    None\n+                                },\n+                            ),\n+                            (),\n                         ));\n                     }\n \n                     if let Some(server_util_module) =\n                         ResolvedVc::try_downcast_type::<NextServerUtilityModule>(*module)\n                     {\n-                        return Ok(FindServerEntriesNode::ServerUtilEntry(\n-                            server_util_module,\n+                        return Ok((\n+                            FindServerEntriesNode::ServerUtilEntry(\n+                                server_util_module,\n+                                if emit_spans {\n+                                    // INVALIDATION: we don't need to invalidate when the span name\n+                                    // changes\n+                                    Some(module.ident_string().untracked().await?)\n+                                } else {\n+                                    None\n+                                },\n+                            ),\n+                            (),\n+                        ));\n+                    }\n+\n+                    Ok((\n+                        FindServerEntriesNode::Internal(\n+                            *module,\n                             if emit_spans {\n                                 // INVALIDATION: we don't need to invalidate when the span name\n                                 // changes\n                                 Some(module.ident_string().untracked().await?)\n                             } else {\n                                 None\n                             },\n-                        ));\n-                    }\n-\n-                    Ok(FindServerEntriesNode::Internal(\n-                        *module,\n-                        if emit_spans {\n-                            // INVALIDATION: we don't need to invalidate when the span name changes\n-                            Some(module.ident_string().untracked().await?)\n-                        } else {\n-                            None\n-                        },\n+                        ),\n+                        (),\n                     ))\n                 });\n \n@@ -252,9 +259,9 @@ impl Visit<FindServerEntriesNode> for FindServerEntries {\n         }\n     }\n \n-    fn span(&mut self, node: &FindServerEntriesNode) -> tracing::Span {\n+    fn span(&mut self, node: &FindServerEntriesNode, _edge: Option<&()>) -> tracing::Span {\n         if !self.emit_spans {\n-            return Span::current();\n+            return Span::none();\n         }\n         match node {\n             FindServerEntriesNode::ClientReference => {"
        },
        {
            "sha": "076c65d49b96df09faf05dd6bd9a8cfa932e3b09",
            "filename": "turbopack/crates/turbo-tasks/src/graph/adjacency_map.rs",
            "status": "modified",
            "additions": 77,
            "deletions": 44,
            "changes": 121,
            "blob_url": "https://github.com/vercel/next.js/blob/92f72373644fae3a2822386480e9e2b6fcf3df68/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fgraph%2Fadjacency_map.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/92f72373644fae3a2822386480e9e2b6fcf3df68/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fgraph%2Fadjacency_map.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fgraph%2Fadjacency_map.rs?ref=92f72373644fae3a2822386480e9e2b6fcf3df68",
            "patch": "@@ -1,34 +1,44 @@\n-use std::{collections::VecDeque, hash::Hash};\n+use std::{\n+    collections::{VecDeque, hash_map::Entry},\n+    hash::Hash,\n+};\n \n use rustc_hash::{FxHashMap, FxHashSet};\n use turbo_tasks_macros::{TraceRawVcs, ValueDebugFormat};\n \n-use crate::{\n-    self as turbo_tasks, NonLocalValue,\n-    graph::graph_store::{GraphNode, GraphStore},\n-};\n+use crate::{self as turbo_tasks, NonLocalValue, graph::graph_store::GraphStore};\n \n /// A graph traversal that builds an adjacency map\n #[derive(Debug, Clone, TraceRawVcs, ValueDebugFormat)]\n-pub struct AdjacencyMap<T> {\n-    adjacency_map: FxHashMap<T, Vec<T>>,\n+pub struct AdjacencyMap<T, E> {\n+    adjacency_map: FxHashMap<T, Vec<(T, E)>>,\n     roots: Vec<T>,\n }\n \n-unsafe impl<T> NonLocalValue for AdjacencyMap<T> where T: NonLocalValue {}\n-\n-impl<T> PartialEq for AdjacencyMap<T>\n+unsafe impl<T, E> NonLocalValue for AdjacencyMap<T, E>\n+where\n+    T: NonLocalValue,\n+    E: NonLocalValue,\n+{\n+}\n+impl<T, E> PartialEq for AdjacencyMap<T, E>\n where\n     T: Eq + Hash,\n+    E: Eq,\n {\n     fn eq(&self, other: &Self) -> bool {\n         self.adjacency_map == other.adjacency_map && self.roots == other.roots\n     }\n }\n \n-impl<T> Eq for AdjacencyMap<T> where T: Eq + Hash {}\n+impl<T, E> Eq for AdjacencyMap<T, E>\n+where\n+    T: Eq + Hash,\n+    E: Eq,\n+{\n+}\n \n-impl<T> Default for AdjacencyMap<T>\n+impl<T, E> Default for AdjacencyMap<T, E>\n where\n     T: Eq + Hash + Clone,\n {\n@@ -37,7 +47,7 @@ where\n     }\n }\n \n-impl<T> AdjacencyMap<T>\n+impl<T, E> AdjacencyMap<T, E>\n where\n     T: Eq + Hash + Clone,\n {\n@@ -55,39 +65,60 @@ where\n     }\n \n     /// Returns an iterator over the children of the given node\n-    pub fn get(&self, node: &T) -> Option<impl Iterator<Item = &T>> {\n+    pub fn get(&self, node: &T) -> Option<impl Iterator<Item = &(T, E)>> {\n         self.adjacency_map.get(node).map(|vec| vec.iter())\n     }\n+\n+    /// Returns the number of nodes in the graph\n+    pub fn len(&self) -> usize {\n+        self.adjacency_map.len()\n+    }\n+\n+    /// Returns true if the graph is empty\n+    pub fn is_empty(&self) -> bool {\n+        self.adjacency_map.is_empty()\n+    }\n }\n \n-impl<T> GraphStore for AdjacencyMap<T>\n+impl<T, E> GraphStore for AdjacencyMap<T, E>\n where\n     T: Eq + Hash + Clone + Send,\n+    E: Send,\n {\n     type Node = T;\n+    type Edge = E;\n     type Handle = T;\n \n-    fn insert(&mut self, from_handle: Option<T>, node: GraphNode<T>) -> Option<(Self::Handle, &T)> {\n-        let vec = if let Some(from_handle) = from_handle {\n-            self.adjacency_map\n-                .entry(from_handle)\n-                .or_insert_with(|| Vec::with_capacity(1))\n+    fn insert(&mut self, from: Option<(&T, E)>, node: T) {\n+        if let Some((from_node, edge)) = from {\n+            let vec = self\n+                .adjacency_map\n+                .entry(from_node.clone())\n+                .or_insert_with(|| Vec::with_capacity(1));\n+            vec.push((node, edge));\n         } else {\n-            &mut self.roots\n+            self.roots.push(node);\n         };\n+    }\n \n-        vec.push(node.node().clone());\n-        Some((node.into_node(), vec.last().unwrap()))\n+    fn try_enter(&mut self, node: &T) -> Option<T> {\n+        match self.adjacency_map.entry(node.clone()) {\n+            Entry::Occupied(_) => None,\n+            Entry::Vacant(e) => {\n+                e.insert(Vec::new());\n+                Some(node.clone())\n+            }\n+        }\n     }\n }\n \n-impl<T> AdjacencyMap<T>\n+impl<T, E> AdjacencyMap<T, E>\n where\n     T: Eq + Hash + Clone,\n {\n     /// Returns an owned iterator over the nodes in postorder topological order,\n     /// starting from the roots.\n-    pub fn into_postorder_topological(self) -> IntoPostorderTopologicalIter<T> {\n+    pub fn into_postorder_topological(self) -> IntoPostorderTopologicalIter<T, E> {\n         IntoPostorderTopologicalIter {\n             adjacency_map: self.adjacency_map,\n             stack: self\n@@ -102,7 +133,7 @@ where\n \n     /// Returns an owned iterator over all edges (node pairs) in reverse breadth first order,\n     /// starting from the roots.\n-    pub fn into_breadth_first_edges(self) -> IntoBreadthFirstEdges<T> {\n+    pub fn into_breadth_first_edges(self) -> IntoBreadthFirstEdges<T, E> {\n         IntoBreadthFirstEdges {\n             adjacency_map: self.adjacency_map,\n             queue: self\n@@ -117,7 +148,7 @@ where\n \n     /// Returns an iterator over the nodes in postorder topological order,\n     /// starting from the roots.\n-    pub fn postorder_topological(&self) -> PostorderTopologicalIter<'_, T> {\n+    pub fn postorder_topological(&self) -> PostorderTopologicalIter<'_, T, E> {\n         PostorderTopologicalIter {\n             adjacency_map: &self.adjacency_map,\n             stack: self\n@@ -135,7 +166,7 @@ where\n     pub fn postorder_topological_from_node<'graph>(\n         &'graph self,\n         node: &'graph T,\n-    ) -> PostorderTopologicalIter<'graph, T> {\n+    ) -> PostorderTopologicalIter<'graph, T, E> {\n         PostorderTopologicalIter {\n             adjacency_map: &self.adjacency_map,\n             stack: vec![(ReverseTopologicalPass::Pre, node)],\n@@ -152,18 +183,19 @@ enum ReverseTopologicalPass {\n \n /// An iterator over the nodes of a graph in postorder topological order, starting\n /// from the roots.\n-pub struct IntoPostorderTopologicalIter<T>\n+pub struct IntoPostorderTopologicalIter<T, E>\n where\n     T: Eq + Hash + Clone,\n {\n-    adjacency_map: FxHashMap<T, Vec<T>>,\n+    adjacency_map: FxHashMap<T, Vec<(T, E)>>,\n     stack: Vec<(ReverseTopologicalPass, T)>,\n     visited: FxHashSet<T>,\n }\n \n-impl<T> Iterator for IntoPostorderTopologicalIter<T>\n+impl<T, E> Iterator for IntoPostorderTopologicalIter<T, E>\n where\n     T: Eq + Hash + Clone,\n+    E: Clone,\n {\n     type Item = T;\n \n@@ -191,7 +223,7 @@ where\n                         neighbors\n                             .iter()\n                             .rev()\n-                            .map(|neighbor| (ReverseTopologicalPass::Pre, neighbor.clone())),\n+                            .map(|(neighbor, _)| (ReverseTopologicalPass::Pre, neighbor.clone())),\n                     );\n                 }\n             }\n@@ -201,20 +233,21 @@ where\n     }\n }\n \n-pub struct IntoBreadthFirstEdges<T>\n+pub struct IntoBreadthFirstEdges<T, E>\n where\n     T: Eq + std::hash::Hash + Clone,\n {\n-    adjacency_map: FxHashMap<T, Vec<T>>,\n-    queue: VecDeque<(Option<T>, T)>,\n+    adjacency_map: FxHashMap<T, Vec<(T, E)>>,\n+    queue: VecDeque<(Option<(T, E)>, T)>,\n     expanded: FxHashSet<T>,\n }\n \n-impl<T> Iterator for IntoBreadthFirstEdges<T>\n+impl<T, E> Iterator for IntoBreadthFirstEdges<T, E>\n where\n     T: Eq + std::hash::Hash + Clone,\n+    E: Clone,\n {\n-    type Item = (Option<T>, T);\n+    type Item = (Option<(T, E)>, T);\n \n     fn next(&mut self) -> Option<Self::Item> {\n         let (parent, current) = self.queue.pop_front()?;\n@@ -225,9 +258,9 @@ where\n \n         if self.expanded.insert(current.clone()) {\n             self.queue.extend(\n-                neighbors\n-                    .iter()\n-                    .map(|neighbor| (Some(current.clone()), neighbor.clone())),\n+                neighbors.iter().map(|(neighbor, edge)| {\n+                    (Some((current.clone(), edge.clone())), neighbor.clone())\n+                }),\n             );\n         }\n \n@@ -237,16 +270,16 @@ where\n \n /// An iterator over the nodes of a graph in postorder topological order, starting\n /// from the roots.\n-pub struct PostorderTopologicalIter<'graph, T>\n+pub struct PostorderTopologicalIter<'graph, T, E>\n where\n     T: Eq + Hash + Clone,\n {\n-    adjacency_map: &'graph FxHashMap<T, Vec<T>>,\n+    adjacency_map: &'graph FxHashMap<T, Vec<(T, E)>>,\n     stack: Vec<(ReverseTopologicalPass, &'graph T)>,\n     visited: FxHashSet<&'graph T>,\n }\n \n-impl<'graph, T> Iterator for PostorderTopologicalIter<'graph, T>\n+impl<'graph, T, E> Iterator for PostorderTopologicalIter<'graph, T, E>\n where\n     T: Eq + Hash + Clone,\n {\n@@ -276,7 +309,7 @@ where\n                         neighbors\n                             .iter()\n                             .rev()\n-                            .map(|neighbor| (ReverseTopologicalPass::Pre, neighbor)),\n+                            .map(|(neighbor, _)| (ReverseTopologicalPass::Pre, neighbor)),\n                     );\n                 }\n             }"
        },
        {
            "sha": "44f1a4bf803c0053e187db56f9909d493853fe12",
            "filename": "turbopack/crates/turbo-tasks/src/graph/control_flow.rs",
            "status": "modified",
            "additions": 10,
            "deletions": 32,
            "changes": 42,
            "blob_url": "https://github.com/vercel/next.js/blob/92f72373644fae3a2822386480e9e2b6fcf3df68/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fgraph%2Fcontrol_flow.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/92f72373644fae3a2822386480e9e2b6fcf3df68/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fgraph%2Fcontrol_flow.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fgraph%2Fcontrol_flow.rs?ref=92f72373644fae3a2822386480e9e2b6fcf3df68",
            "patch": "@@ -1,35 +1,13 @@\n /// The control flow of visiting an edge during a graph traversal.\n-pub enum VisitControlFlow<Node, Abort = !> {\n-    /// The traversal should continue on the outgoing edges of the given node.\n-    Continue(Node),\n-    /// The traversal should skip visiting the edges the given node.\n-    Skip(Node),\n+pub enum VisitControlFlow {\n+    /// The edge is included, and the traversal should continue on the outgoing edges of the given\n+    /// node.\n+    Continue,\n+    /// The edge is included, but the traversal should skip visiting the edges the given node.\n+    Skip,\n+    /// The edge is excluded, and the traversal should not continue on the outgoing edges of the\n+    /// given node.\n+    Exclude,\n     /// The traversal should abort and return immediately.\n-    Abort(Abort),\n-}\n-\n-impl<Node, Abort> VisitControlFlow<Node, Abort> {\n-    /// Map the continue and skip values of this control flow.\n-    pub fn map_node<Map, Mapped>(self, mut map: Map) -> VisitControlFlow<Mapped, Abort>\n-    where\n-        Map: FnMut(Node) -> Mapped,\n-    {\n-        match self {\n-            VisitControlFlow::Continue(node) => VisitControlFlow::Continue(map(node)),\n-            VisitControlFlow::Skip(node) => VisitControlFlow::Skip(map(node)),\n-            VisitControlFlow::Abort(abort) => VisitControlFlow::Abort(abort),\n-        }\n-    }\n-\n-    /// Map the abort value of this control flow.\n-    pub fn map_abort<Map, Mapped>(self, mut map: Map) -> VisitControlFlow<Node, Mapped>\n-    where\n-        Map: FnMut(Abort) -> Mapped,\n-    {\n-        match self {\n-            VisitControlFlow::Continue(node) => VisitControlFlow::Continue(node),\n-            VisitControlFlow::Skip(node) => VisitControlFlow::Skip(node),\n-            VisitControlFlow::Abort(abort) => VisitControlFlow::Abort(map(abort)),\n-        }\n-    }\n+    Abort,\n }"
        },
        {
            "sha": "5b0037145f8bb74eaafacc62230f508514fec58e",
            "filename": "turbopack/crates/turbo-tasks/src/graph/graph_store.rs",
            "status": "modified",
            "additions": 7,
            "deletions": 184,
            "changes": 191,
            "blob_url": "https://github.com/vercel/next.js/blob/92f72373644fae3a2822386480e9e2b6fcf3df68/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fgraph%2Fgraph_store.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/92f72373644fae3a2822386480e9e2b6fcf3df68/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fgraph%2Fgraph_store.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fgraph%2Fgraph_store.rs?ref=92f72373644fae3a2822386480e9e2b6fcf3df68",
            "patch": "@@ -1,196 +1,19 @@\n-use std::hash::Hash;\n-\n-use rustc_hash::FxHashSet;\n-\n-use super::VisitedNodes;\n-\n /// A graph store is a data structure that will be built up during a graph\n /// traversal. It is used to store the results of the traversal.\n pub trait GraphStore: Send {\n     type Node: Send;\n-    type Handle: Clone + Send;\n+    type Edge: Send;\n+    type Handle: Send;\n \n     // TODO(alexkirsz) An `entry(from_handle) -> Entry` API would be more\n     // efficient, as right now we're getting the same key multiple times.\n     /// Inserts a node into the graph store, and returns a handle to it.\n     ///\n     /// If this method returns `None`, the node edges will not be visited.\n-    fn insert(\n-        &mut self,\n-        from_handle: Option<Self::Handle>,\n-        node: GraphNode<Self::Node>,\n-    ) -> Option<(Self::Handle, &Self::Node)>;\n-}\n-\n-/// Utility type to ensure that GraphStore::insert can only ever be called from\n-/// within this module, as a GraphNode can't be constructed outside of it.\n-#[derive(Clone, Copy, Eq, PartialEq, Debug, Hash, Ord, PartialOrd)]\n-pub struct GraphNode<Node>(pub(super) Node);\n-\n-impl<Node> GraphNode<Node> {\n-    /// Consumes this `GraphNode` and returns the underlying node.\n-    pub fn into_node(self) -> Node {\n-        self.0\n-    }\n-\n-    /// Returns a reference the underlying node.\n-    pub fn node(&self) -> &Node {\n-        &self.0\n-    }\n-\n-    /// Returns a mutable reference the underlying node.\n-    pub fn node_mut(&mut self) -> &mut Node {\n-        &mut self.0\n-    }\n-}\n-\n-/// A [`GraphStore`] wrapper that skips nodes that have already been\n-/// visited.\n-///\n-/// This is necessary to avoid repeated work when traversing non-tree\n-/// graphs (i.e. where a node can have more than one incoming edge).\n-#[derive(Debug)]\n-pub struct SkipDuplicates<StoreImpl>\n-where\n-    StoreImpl: GraphStore,\n-{\n-    store: StoreImpl,\n-    visited: FxHashSet<StoreImpl::Node>,\n-}\n-\n-impl<StoreImpl> SkipDuplicates<StoreImpl>\n-where\n-    StoreImpl: GraphStore,\n-{\n-    pub fn new(store: StoreImpl) -> Self {\n-        Self {\n-            store,\n-            visited: FxHashSet::default(),\n-        }\n-    }\n-\n-    pub fn new_with_visited_nodes(store: StoreImpl, visited: FxHashSet<StoreImpl::Node>) -> Self {\n-        Self { store, visited }\n-    }\n-}\n-\n-impl<StoreImpl> GraphStore for SkipDuplicates<StoreImpl>\n-where\n-    StoreImpl: GraphStore,\n-    StoreImpl::Node: Eq + std::hash::Hash + Clone,\n-{\n-    type Node = StoreImpl::Node;\n-    type Handle = StoreImpl::Handle;\n-\n-    fn insert(\n-        &mut self,\n-        from_handle: Option<Self::Handle>,\n-        node: GraphNode<StoreImpl::Node>,\n-    ) -> Option<(Self::Handle, &StoreImpl::Node)> {\n-        if !self.visited.contains(node.node()) {\n-            self.visited.insert(node.node().clone());\n-            self.store.insert(from_handle, node)\n-        } else {\n-            // Always insert the node into the store, even if we've already\n-            // visited it. This is necessary to ensure that the store sees all\n-            // edges.\n-            self.store.insert(from_handle, node);\n-            None\n-        }\n-    }\n-}\n-\n-impl<StoreImpl> SkipDuplicates<StoreImpl>\n-where\n-    StoreImpl: GraphStore,\n-{\n-    /// Consumes the wrapper and returns the underlying store.\n-    pub fn into_inner(self) -> StoreImpl {\n-        self.store\n-    }\n-\n-    /// Consumes the wrapper and returns the underlying store along with the visited nodes.\n-    pub fn into_inner_with_visited(self) -> (StoreImpl, VisitedNodes<StoreImpl::Node>) {\n-        (self.store, VisitedNodes(self.visited))\n-    }\n-}\n-\n-/// A [`GraphStore`] wrapper that skips nodes that have already been\n-/// visited, based on a key extracted from the node.\n-///\n-/// This is necessary to avoid repeated work when traversing non-tree\n-/// graphs (i.e. where a node can have more than one incoming edge).\n-#[derive(Debug)]\n-pub struct SkipDuplicatesWithKey<StoreImpl, Key, KeyExtractor>\n-where\n-    StoreImpl: GraphStore,\n-    Key: Send + Eq + Hash,\n-    KeyExtractor: Send + Fn(&StoreImpl::Node) -> &Key,\n-{\n-    store: StoreImpl,\n-    visited: FxHashSet<Key>,\n-    key_extractor: KeyExtractor,\n-}\n-\n-impl<StoreImpl, Key, KeyExtractor> SkipDuplicatesWithKey<StoreImpl, Key, KeyExtractor>\n-where\n-    StoreImpl: GraphStore,\n-    Key: Send + Eq + std::hash::Hash + Clone,\n-    KeyExtractor: Send + Fn(&StoreImpl::Node) -> &Key,\n-{\n-    pub fn new(store: StoreImpl, key_extractor: KeyExtractor) -> Self {\n-        Self {\n-            store,\n-            visited: FxHashSet::default(),\n-            key_extractor,\n-        }\n-    }\n-}\n-\n-impl<StoreImpl, Key, KeyExtractor> GraphStore\n-    for SkipDuplicatesWithKey<StoreImpl, Key, KeyExtractor>\n-where\n-    StoreImpl: GraphStore,\n-    StoreImpl::Node: Eq + std::hash::Hash + Clone,\n-    Key: Send + Eq + std::hash::Hash + Clone,\n-    KeyExtractor: Send + Fn(&StoreImpl::Node) -> &Key,\n-{\n-    type Node = StoreImpl::Node;\n-    type Handle = StoreImpl::Handle;\n-\n-    fn insert(\n-        &mut self,\n-        from_handle: Option<Self::Handle>,\n-        node: GraphNode<StoreImpl::Node>,\n-    ) -> Option<(Self::Handle, &StoreImpl::Node)> {\n-        let key = (self.key_extractor)(node.node());\n-\n-        if !self.visited.contains(key) {\n-            self.visited.insert(key.clone());\n-            self.store.insert(from_handle, node)\n-        } else {\n-            // Always insert the node into the store, even if we've already\n-            // visited it. This is necessary to ensure that the store sees all\n-            // edges.\n-            self.store.insert(from_handle, node);\n-            None\n-        }\n-    }\n-}\n-\n-impl<StoreImpl, Key, KeyExtractor> SkipDuplicatesWithKey<StoreImpl, Key, KeyExtractor>\n-where\n-    StoreImpl: GraphStore,\n-    Key: Send + Eq + std::hash::Hash + Clone,\n-    KeyExtractor: Send + Fn(&StoreImpl::Node) -> &Key,\n-{\n-    /// Consumes the wrapper and returns the underlying store.\n-    pub fn into_inner(self) -> StoreImpl {\n-        self.store\n-    }\n+    fn insert(&mut self, from: Option<(&Self::Handle, Self::Edge)>, node: Self::Node);\n \n-    /// Consumes the wrapper and returns the underlying store along with the visited nodes.\n-    pub fn into_inner_with_visited(self) -> (StoreImpl, VisitedNodes<Key>) {\n-        (self.store, VisitedNodes(self.visited))\n-    }\n+    /// Tries to enter a node during traversal for visiting its edges.\n+    /// Returns `true` if the node edges should be visited.\n+    /// Returns `false` if the node has already been visited and should not be explored again.\n+    fn try_enter(&mut self, node: &Self::Node) -> Option<Self::Handle>;\n }"
        },
        {
            "sha": "a311799efe9ad06d911431c839478304353ddb12",
            "filename": "turbopack/crates/turbo-tasks/src/graph/graph_traversal.rs",
            "status": "modified",
            "additions": 48,
            "deletions": 86,
            "changes": 134,
            "blob_url": "https://github.com/vercel/next.js/blob/92f72373644fae3a2822386480e9e2b6fcf3df68/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fgraph%2Fgraph_traversal.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/92f72373644fae3a2822386480e9e2b6fcf3df68/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fgraph%2Fgraph_traversal.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fgraph%2Fgraph_traversal.rs?ref=92f72373644fae3a2822386480e9e2b6fcf3df68",
            "patch": "@@ -4,11 +4,7 @@ use anyhow::Result;\n use futures::{StreamExt, stream::FuturesUnordered};\n use rustc_hash::FxHashSet;\n \n-use super::{\n-    SkipDuplicates, Visit, VisitControlFlow,\n-    graph_store::{GraphNode, GraphStore, SkipDuplicatesWithKey},\n-    with_future::With,\n-};\n+use super::{Visit, VisitControlFlow, graph_store::GraphStore, with_future::With};\n \n /// A list of modules that were already visited and should be skipped (including their subgraphs).\n #[derive(Clone, Default, Debug)]\n@@ -20,29 +16,14 @@ pub struct VisitedNodes<T>(pub FxHashSet<T>);\n /// The traversal is done in parallel, and the order of the nodes in the traversal\n /// result is determined by the [`GraphStore`] parameter.\n pub trait GraphTraversal: GraphStore + Sized {\n-    fn visit<VisitImpl, Abort, Impl>(\n+    fn visit<VisitImpl, Impl>(\n         self,\n-        root_edges: impl IntoIterator<Item = VisitImpl::Edge>,\n+        root_nodes: impl IntoIterator<Item = Self::Node>,\n         visit: VisitImpl,\n-    ) -> impl Future<Output = GraphTraversalResult<Result<Self>, Abort>> + Send\n+    ) -> impl Future<Output = GraphTraversalResult<Result<Self>>> + Send\n     where\n-        VisitImpl: Visit<Self::Node, Abort, Impl> + Send,\n-        Abort: Send,\n+        VisitImpl: Visit<Self::Node, Self::Edge, Impl> + Send,\n         Impl: Send;\n-\n-    fn skip_duplicates(self) -> SkipDuplicates<Self>;\n-    fn skip_duplicates_with_visited_nodes(\n-        self,\n-        visited: VisitedNodes<Self::Node>,\n-    ) -> SkipDuplicates<Self>;\n-\n-    fn skip_duplicates_with_key<\n-        Key: Send + Eq + std::hash::Hash + Clone,\n-        KeyExtractor: Send + Fn(&Self::Node) -> &Key,\n-    >(\n-        self,\n-        key_extractor: KeyExtractor,\n-    ) -> SkipDuplicatesWithKey<Self, Key, KeyExtractor>;\n }\n \n impl<Store> GraphTraversal for Store\n@@ -51,68 +32,70 @@ where\n {\n     /// Visits the graph starting from the given `roots`, and returns a future\n     /// that will resolve to the traversal result.\n-    fn visit<VisitImpl, Abort, Impl>(\n+    fn visit<VisitImpl, Impl>(\n         mut self,\n-        root_edges: impl IntoIterator<Item = VisitImpl::Edge>,\n+        root_nodes: impl IntoIterator<Item = Self::Node>,\n         mut visit: VisitImpl,\n-    ) -> impl Future<Output = GraphTraversalResult<Result<Self>, Abort>> + Send\n+    ) -> impl Future<Output = GraphTraversalResult<Result<Self>>> + Send\n     where\n-        VisitImpl: Visit<Self::Node, Abort, Impl> + Send,\n-        Abort: Send,\n+        VisitImpl: Visit<Self::Node, Self::Edge, Impl> + Send,\n         Impl: Send,\n     {\n         let mut futures = FuturesUnordered::new();\n-        let mut root_abort = None;\n+        let mut is_abort = false;\n \n-        // Populate `futures` with all the roots, `root_edges` isn't required to be `Send`, so this\n-        // has to happen outside of the future. We could require `root_edges` to be `Send` in the\n+        // Populate `futures` with all the roots, `root_nodes` isn't required to be `Send`, so this\n+        // has to happen outside of the future. We could require `root_nodes` to be `Send` in the\n         // future.\n-        for edge in root_edges {\n-            match visit.visit(edge) {\n-                VisitControlFlow::Continue(node) => {\n-                    if let Some((parent_handle, node_ref)) = self.insert(None, GraphNode(node)) {\n-                        let span = visit.span(node_ref);\n-                        futures.push(With::new(visit.edges(node_ref), span, parent_handle));\n+        for node in root_nodes {\n+            match visit.visit(&node, None) {\n+                VisitControlFlow::Continue => {\n+                    if let Some(handle) = self.try_enter(&node) {\n+                        let span = visit.span(&node, None);\n+                        futures.push(With::new(visit.edges(&node), span, handle));\n                     }\n+                    self.insert(None, node);\n                 }\n-                VisitControlFlow::Skip(node) => {\n-                    self.insert(None, GraphNode(node));\n+                VisitControlFlow::Skip => {\n+                    self.insert(None, node);\n                 }\n-                VisitControlFlow::Abort(abort) => {\n+                VisitControlFlow::Exclude => {\n+                    // do nothing\n+                }\n+                VisitControlFlow::Abort => {\n                     // this must be returned inside the `async` block below so that it's part of the\n                     // returned future\n-                    root_abort = Some(abort)\n+                    is_abort = true;\n                 }\n             }\n         }\n \n         async move {\n-            if let Some(abort) = root_abort {\n-                return GraphTraversalResult::Aborted(abort);\n+            if is_abort {\n+                return GraphTraversalResult::Aborted;\n             }\n             loop {\n                 match futures.next().await {\n-                    Some((parent_handle, span, Ok(edges))) => {\n+                    Some((parent_node, span, Ok(edges))) => {\n                         let _guard = span.enter();\n-                        for edge in edges {\n-                            match visit.visit(edge) {\n-                                VisitControlFlow::Continue(node) => {\n-                                    if let Some((node_handle, node_ref)) =\n-                                        self.insert(Some(parent_handle.clone()), GraphNode(node))\n-                                    {\n-                                        let span = visit.span(node_ref);\n-                                        futures.push(With::new(\n-                                            visit.edges(node_ref),\n-                                            span,\n-                                            node_handle,\n-                                        ));\n+                        for (node, edge) in edges {\n+                            match visit.visit(&node, Some(&edge)) {\n+                                VisitControlFlow::Continue => {\n+                                    if let Some(handle) = self.try_enter(&node) {\n+                                        let span = visit.span(&node, Some(&edge));\n+                                        let edges_future = visit.edges(&node);\n+                                        futures.push(With::new(edges_future, span, handle));\n                                     }\n+                                    self.insert(Some((&parent_node, edge)), node);\n+                                }\n+                                VisitControlFlow::Skip => {\n+                                    self.insert(Some((&parent_node, edge)), node);\n                                 }\n-                                VisitControlFlow::Skip(node) => {\n-                                    self.insert(Some(parent_handle.clone()), GraphNode(node));\n+                                VisitControlFlow::Exclude => {\n+                                    // do nothing\n                                 }\n-                                VisitControlFlow::Abort(abort) => {\n-                                    return GraphTraversalResult::Aborted(abort);\n+                                VisitControlFlow::Abort => {\n+                                    return GraphTraversalResult::Aborted;\n                                 }\n                             }\n                         }\n@@ -127,39 +110,18 @@ where\n             }\n         }\n     }\n-\n-    fn skip_duplicates(self) -> SkipDuplicates<Self> {\n-        SkipDuplicates::new(self)\n-    }\n-\n-    fn skip_duplicates_with_visited_nodes(\n-        self,\n-        visited: VisitedNodes<Store::Node>,\n-    ) -> SkipDuplicates<Self> {\n-        SkipDuplicates::new_with_visited_nodes(self, visited.0)\n-    }\n-\n-    fn skip_duplicates_with_key<\n-        Key: Send + Eq + std::hash::Hash + Clone,\n-        KeyExtractor: Send + Fn(&Self::Node) -> &Key,\n-    >(\n-        self,\n-        key_extractor: KeyExtractor,\n-    ) -> SkipDuplicatesWithKey<Self, Key, KeyExtractor> {\n-        SkipDuplicatesWithKey::new(self, key_extractor)\n-    }\n }\n \n-pub enum GraphTraversalResult<Completed, Aborted> {\n+pub enum GraphTraversalResult<Completed> {\n     Completed(Completed),\n-    Aborted(Aborted),\n+    Aborted,\n }\n \n-impl<Completed> GraphTraversalResult<Completed, !> {\n+impl<Completed> GraphTraversalResult<Completed> {\n     pub fn completed(self) -> Completed {\n         match self {\n             GraphTraversalResult::Completed(completed) => completed,\n-            GraphTraversalResult::Aborted(_) => unreachable!(\"the type parameter `Aborted` is `!`\"),\n+            GraphTraversalResult::Aborted => panic!(\"Graph traversal was aborted\"),\n         }\n     }\n }"
        },
        {
            "sha": "ca272fed375a5b8ca25679c08f2434a2ada1a3b9",
            "filename": "turbopack/crates/turbo-tasks/src/graph/mod.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/92f72373644fae3a2822386480e9e2b6fcf3df68/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fgraph%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/92f72373644fae3a2822386480e9e2b6fcf3df68/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fgraph%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fgraph%2Fmod.rs?ref=92f72373644fae3a2822386480e9e2b6fcf3df68",
            "patch": "@@ -8,7 +8,7 @@ mod with_future;\n \n pub use adjacency_map::AdjacencyMap;\n pub use control_flow::VisitControlFlow;\n-pub use graph_store::{GraphStore, SkipDuplicates};\n+pub use graph_store::GraphStore;\n pub use graph_traversal::{GraphTraversal, GraphTraversalResult, VisitedNodes};\n pub use non_deterministic::NonDeterministic;\n pub use visit::Visit;"
        },
        {
            "sha": "f6697b4d4dd90ae2c9b1faa252e697703e90ebcb",
            "filename": "turbopack/crates/turbo-tasks/src/graph/non_deterministic.rs",
            "status": "modified",
            "additions": 30,
            "deletions": 15,
            "changes": 45,
            "blob_url": "https://github.com/vercel/next.js/blob/92f72373644fae3a2822386480e9e2b6fcf3df68/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fgraph%2Fnon_deterministic.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/92f72373644fae3a2822386480e9e2b6fcf3df68/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fgraph%2Fnon_deterministic.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fgraph%2Fnon_deterministic.rs?ref=92f72373644fae3a2822386480e9e2b6fcf3df68",
            "patch": "@@ -1,41 +1,56 @@\n-use super::graph_store::{GraphNode, GraphStore};\n+use std::hash::Hash;\n+\n+use rustc_hash::FxHashSet;\n+\n+use super::graph_store::GraphStore;\n \n /// A graph traversal that does not guarantee any particular order, and may not\n /// return the same order every time it is run.\n-pub struct NonDeterministic<T> {\n+pub struct NonDeterministic<T, E> {\n     output: Vec<T>,\n+    visited: FxHashSet<T>,\n+    phantom: std::marker::PhantomData<E>,\n }\n \n-impl<T> Default for NonDeterministic<T> {\n+impl<T, E> Default for NonDeterministic<T, E> {\n     fn default() -> Self {\n         Self::new()\n     }\n }\n \n-impl<T> NonDeterministic<T> {\n+impl<T, E> NonDeterministic<T, E> {\n     pub fn new() -> Self {\n-        Self { output: Vec::new() }\n+        Self {\n+            output: Vec::new(),\n+            visited: FxHashSet::default(),\n+            phantom: std::marker::PhantomData,\n+        }\n     }\n }\n \n-impl<T> GraphStore for NonDeterministic<T>\n+impl<T, E> GraphStore for NonDeterministic<T, E>\n where\n-    T: Send,\n+    T: Send + Hash + Eq + Clone,\n+    E: Send,\n {\n     type Node = T;\n+    type Edge = E;\n     type Handle = ();\n \n-    fn insert(\n-        &mut self,\n-        _from_handle: Option<Self::Handle>,\n-        node: GraphNode<T>,\n-    ) -> Option<(Self::Handle, &T)> {\n-        self.output.push(node.into_node());\n-        Some(((), self.output.last().unwrap()))\n+    fn insert(&mut self, _from: Option<(&(), E)>, node: T) {\n+        self.output.push(node);\n+    }\n+\n+    fn try_enter(&mut self, node: &T) -> Option<()> {\n+        if self.visited.insert(node.clone()) {\n+            Some(())\n+        } else {\n+            None\n+        }\n     }\n }\n \n-impl<T> IntoIterator for NonDeterministic<T> {\n+impl<T, E> IntoIterator for NonDeterministic<T, E> {\n     type Item = T;\n     type IntoIter = <Vec<T> as IntoIterator>::IntoIter;\n "
        },
        {
            "sha": "d0255022901ce4a5c338aab99b4bc4e2fe0cb30f",
            "filename": "turbopack/crates/turbo-tasks/src/graph/visit.rs",
            "status": "modified",
            "additions": 76,
            "deletions": 26,
            "changes": 102,
            "blob_url": "https://github.com/vercel/next.js/blob/92f72373644fae3a2822386480e9e2b6fcf3df68/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fgraph%2Fvisit.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/92f72373644fae3a2822386480e9e2b6fcf3df68/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fgraph%2Fvisit.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fgraph%2Fvisit.rs?ref=92f72373644fae3a2822386480e9e2b6fcf3df68",
            "patch": "@@ -1,4 +1,4 @@\n-use std::future::Future;\n+use std::{future::Future, iter::Map};\n \n use anyhow::Result;\n use tracing::Span;\n@@ -7,17 +7,20 @@ use super::VisitControlFlow;\n \n /// A trait that allows a graph traversal to visit the edges of a node\n /// transitively.\n-pub trait Visit<Node, Abort = !, Impl = ()> {\n-    type Edge;\n-    type EdgesIntoIter: IntoIterator<Item = Self::Edge>;\n+pub trait Visit<Node, Edge = (), Impl = ()> {\n+    type EdgesIntoIter: IntoIterator<Item = (Node, Edge)>;\n     type EdgesFuture: Future<Output = Result<Self::EdgesIntoIter>> + Send;\n \n-    /// Visits an edge to get to the neighbor node. Should return a\n+    /// Visits an edge. Should return a\n     /// [`VisitControlFlow`] that indicates whether to:\n     /// * continue visiting the neighbor node edges;\n     /// * skip visiting the neighbor node's edges;\n     /// * abort the traversal entirely.\n-    fn visit(&mut self, edge: Self::Edge) -> VisitControlFlow<Node, Abort>;\n+    fn visit(&mut self, node: &Node, edge: Option<&Edge>) -> VisitControlFlow {\n+        let _ = node;\n+        let _ = edge;\n+        VisitControlFlow::Continue\n+    }\n \n     /// Returns a future that resolves to the outgoing edges of the given `node`.\n     ///\n@@ -28,11 +31,9 @@ pub trait Visit<Node, Abort = !, Impl = ()> {\n     ///   returns a node reference that's only valid for the lifetime of its `&mut self` reference.\n     fn edges(&mut self, node: &Node) -> Self::EdgesFuture;\n \n-    /// Returns a [Span] for the given `node`, under which all edges are\n-    /// processed.\n-    fn span(&mut self, node: &Node) -> Span {\n-        let _ = node;\n-        Span::current()\n+    /// Returns a [Span] for the given `node`, under which all edges are processed.\n+    fn span(&mut self, _node: &Node, _edge: Option<&Edge>) -> Span {\n+        Span::none()\n     }\n }\n \n@@ -41,45 +42,94 @@ pub trait Visit<Node, Abort = !, Impl = ()> {\n // kinds of `FnMut`.\n // See https://users.rust-lang.org/t/conflicting-implementation-when-implementing-traits-for-fn/53359/3\n \n-pub struct ImplRef;\n+pub struct ImplWithEdgeRef;\n \n-impl<Node, VisitFn, NeighFut, NeighIt> Visit<Node, !, ImplRef> for VisitFn\n+impl<Node, Edge, VisitFn, NeighFut, NeighIt> Visit<Node, Edge, ImplWithEdgeRef> for VisitFn\n where\n     VisitFn: FnMut(&Node) -> NeighFut,\n     NeighFut: Future<Output = Result<NeighIt>> + Send,\n-    NeighIt: IntoIterator<Item = Node>,\n+    NeighIt: IntoIterator<Item = (Node, Edge)>,\n {\n-    type Edge = Node;\n     type EdgesIntoIter = NeighIt;\n     type EdgesFuture = NeighFut;\n \n-    fn visit(&mut self, edge: Self::Edge) -> VisitControlFlow<Node> {\n-        VisitControlFlow::Continue(edge)\n-    }\n-\n     fn edges(&mut self, node: &Node) -> Self::EdgesFuture {\n         (self)(node)\n     }\n }\n \n-pub struct ImplValue;\n+pub struct ImplWithEdgeValue;\n \n-impl<Node, VisitFn, NeighFut, NeighIt> Visit<Node, !, ImplValue> for VisitFn\n+impl<Node, Edge, VisitFn, NeighFut, NeighIt> Visit<Node, Edge, ImplWithEdgeValue> for VisitFn\n where\n     Node: Clone,\n     VisitFn: FnMut(Node) -> NeighFut,\n     NeighFut: Future<Output = Result<NeighIt>> + Send,\n-    NeighIt: IntoIterator<Item = Node>,\n+    NeighIt: IntoIterator<Item = (Node, Edge)>,\n {\n-    type Edge = Node;\n     type EdgesIntoIter = NeighIt;\n     type EdgesFuture = NeighFut;\n \n-    fn visit(&mut self, edge: Self::Edge) -> VisitControlFlow<Node> {\n-        VisitControlFlow::Continue(edge)\n+    fn edges(&mut self, node: &Node) -> Self::EdgesFuture {\n+        (self)(node.clone())\n     }\n+}\n+\n+pub struct ImplRef;\n+\n+impl<Node, VisitFn, NeighFut, NeighIt> Visit<Node, (), ImplRef> for VisitFn\n+where\n+    VisitFn: FnMut(&Node) -> NeighFut,\n+    NeighFut: Future<Output = Result<NeighIt>> + Send,\n+    NeighIt: IntoIterator<Item = Node>,\n+{\n+    type EdgesIntoIter = Map<NeighIt::IntoIter, fn(Node) -> (Node, ())>;\n+    type EdgesFuture = NoEdgeFuture<NeighFut>;\n \n     fn edges(&mut self, node: &Node) -> Self::EdgesFuture {\n-        (self)(node.clone())\n+        NoEdgeFuture((self)(node))\n+    }\n+}\n+\n+pub struct ImplValue;\n+\n+impl<Node, VisitFn, NeighFut, NeighIt> Visit<Node, (), ImplValue> for VisitFn\n+where\n+    Node: Clone,\n+    VisitFn: FnMut(Node) -> NeighFut,\n+    NeighFut: Future<Output = Result<NeighIt>> + Send,\n+    NeighIt: IntoIterator<Item = Node>,\n+{\n+    type EdgesIntoIter = Map<NeighIt::IntoIter, fn(Node) -> (Node, ())>;\n+    type EdgesFuture = NoEdgeFuture<NeighFut>;\n+\n+    fn edges(&mut self, node: &Node) -> Self::EdgesFuture {\n+        NoEdgeFuture((self)(node.clone()))\n+    }\n+}\n+\n+pub struct NoEdgeFuture<F>(F);\n+\n+impl<F, Node, NeighIt> Future for NoEdgeFuture<F>\n+where\n+    F: Future<Output = Result<NeighIt>> + Send,\n+    NeighIt: IntoIterator<Item = Node>,\n+{\n+    type Output = Result<Map<NeighIt::IntoIter, fn(Node) -> (Node, ())>>;\n+\n+    fn poll(\n+        self: std::pin::Pin<&mut Self>,\n+        cx: &mut std::task::Context<'_>,\n+    ) -> std::task::Poll<Self::Output> {\n+        let future = unsafe { self.map_unchecked_mut(|s| &mut s.0) };\n+        future.poll(cx).map(|res| {\n+            res.map(|it| {\n+                fn map_fn<Node>(node: Node) -> (Node, ()) {\n+                    (node, ())\n+                }\n+                let f: fn(Node) -> (Node, ()) = map_fn;\n+                it.into_iter().map(f)\n+            })\n+        })\n     }\n }"
        },
        {
            "sha": "09ac9af445b9aa71029c5e78a23ad1f41ae61723",
            "filename": "turbopack/crates/turbo-tasks/src/graph/with_future.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/92f72373644fae3a2822386480e9e2b6fcf3df68/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fgraph%2Fwith_future.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/92f72373644fae3a2822386480e9e2b6fcf3df68/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fgraph%2Fwith_future.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fgraph%2Fwith_future.rs?ref=92f72373644fae3a2822386480e9e2b6fcf3df68",
            "patch": "@@ -11,19 +11,19 @@ pin_project! {\n         #[pin]\n         future: T,\n         span: Span,\n-        handle: Option<H>,\n+        data: Option<H>,\n     }\n }\n \n impl<T, H> With<T, H>\n where\n     T: Future,\n {\n-    pub fn new(future: T, span: Span, handle: H) -> Self {\n+    pub fn new(future: T, span: Span, data: H) -> Self {\n         Self {\n             future,\n             span,\n-            handle: Some(handle),\n+            data: Some(data),\n         }\n     }\n }\n@@ -44,7 +44,7 @@ where\n             std::task::Poll::Ready(result) => {\n                 drop(guard);\n                 std::task::Poll::Ready((\n-                    this.handle.take().expect(\"polled after completion\"),\n+                    this.data.take().expect(\"polled after completion\"),\n                     replace(this.span, Span::none()),\n                     result,\n                 ))"
        },
        {
            "sha": "99e7e1bacd4d4569560400c2a01c7b44c05af559",
            "filename": "turbopack/crates/turbopack-core/src/changed.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/92f72373644fae3a2822386480e9e2b6fcf3df68/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchanged.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/92f72373644fae3a2822386480e9e2b6fcf3df68/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchanged.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchanged.rs?ref=92f72373644fae3a2822386480e9e2b6fcf3df68",
            "patch": "@@ -27,11 +27,9 @@ pub async fn any_content_changed_of_module(\n     root: ResolvedVc<Box<dyn Module>>,\n ) -> Result<Vc<Completion>> {\n     let completions = AdjacencyMap::new()\n-        .skip_duplicates()\n         .visit([root], get_referenced_modules)\n         .await\n         .completed()?\n-        .into_inner()\n         .into_postorder_topological()\n         .map(|m| content_changed(*ResolvedVc::upcast(m)))\n         .map(|v| v.to_resolved())"
        },
        {
            "sha": "ad12b85fdd28606d805a0a662ac1892cf87ca2a0",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/mod.rs",
            "status": "modified",
            "additions": 124,
            "deletions": 276,
            "changes": 400,
            "blob_url": "https://github.com/vercel/next.js/blob/92f72373644fae3a2822386480e9e2b6fcf3df68/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/92f72373644fae3a2822386480e9e2b6fcf3df68/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs?ref=92f72373644fae3a2822386480e9e2b6fcf3df68",
            "patch": "@@ -270,23 +270,16 @@ impl SingleModuleGraph {\n         include_binding_usage: bool,\n     ) -> Result<Vc<Self>> {\n         let emit_spans = tracing::enabled!(Level::INFO);\n-        let root_edges = entries\n+        let root_nodes = entries\n             .iter()\n             .flat_map(|e| e.entries())\n-            .map(|e| async move {\n-                Ok(SingleModuleGraphBuilderEdge {\n-                    to: SingleModuleGraphBuilderNode::new_module(emit_spans, e).await?,\n-                    binding_usage: BindingUsage::default(),\n-                    reference: None,\n-                })\n-            })\n+            .map(|e| SingleModuleGraphBuilderNode::new_module(emit_spans, e))\n             .try_join()\n             .await?;\n \n-        let (children_nodes_iter, visited_nodes) = AdjacencyMap::new()\n-            .skip_duplicates_with_key(|node: &(SingleModuleGraphBuilderNode, _, _)| &node.0)\n+        let children_nodes_iter = AdjacencyMap::new()\n             .visit(\n-                root_edges,\n+                root_nodes,\n                 SingleModuleGraphBuilder {\n                     visited_modules,\n                     emit_spans,\n@@ -295,10 +288,8 @@ impl SingleModuleGraph {\n                 },\n             )\n             .await\n-            .completed()?\n-            .into_inner_with_visited();\n-        let node_count = visited_nodes.0.len();\n-        drop(visited_nodes);\n+            .completed()?;\n+        let node_count = children_nodes_iter.len();\n \n         let mut graph: DiGraph<SingleModuleGraphNode, RefData> = DiGraph::with_capacity(\n             node_count,\n@@ -312,80 +303,33 @@ impl SingleModuleGraph {\n             FxHashMap::with_capacity_and_hasher(node_count, Default::default());\n         {\n             let _span = tracing::info_span!(\"build module graph\").entered();\n-            for (parent, (current, reference, binding_usage)) in\n-                children_nodes_iter.into_breadth_first_edges()\n-            {\n-                let parent_edge = match parent.map(|v| v.0) {\n-                    Some(SingleModuleGraphBuilderNode::Module { module, .. }) => Some((\n-                        *modules.get(&module).unwrap(),\n-                        RefData {\n-                            chunking_type: COMMON_CHUNKING_TYPE,\n-                            binding_usage,\n-                            reference: reference.unwrap(),\n-                        },\n-                    )),\n-                    Some(SingleModuleGraphBuilderNode::ChunkableReference { .. }) => {\n-                        // Handled when visiting ChunkableReference below\n-                        continue;\n+            for (parent, current) in children_nodes_iter.into_breadth_first_edges() {\n+                let (module, graph_node, count) = match current {\n+                    SingleModuleGraphBuilderNode::Module { module, ident: _ } => {\n+                        (module, SingleModuleGraphNode::Module(module), 1)\n                     }\n-                    Some(SingleModuleGraphBuilderNode::VisitedModule { .. }) => unreachable!(),\n-                    None => None,\n+                    SingleModuleGraphBuilderNode::VisitedModule { module, idx } => (\n+                        module,\n+                        SingleModuleGraphNode::VisitedModule { idx, module },\n+                        0,\n+                    ),\n                 };\n \n-                match current {\n-                    SingleModuleGraphBuilderNode::Module { module, ident: _ } => {\n-                        // Find the current node, if it was already added\n-                        let current_idx = if let Some(current_idx) = modules.get(&module) {\n-                            *current_idx\n-                        } else {\n-                            let idx = graph.add_node(SingleModuleGraphNode::Module(module));\n-                            number_of_modules += 1;\n-                            modules.insert(module, idx);\n-                            idx\n-                        };\n-                        // Add the edge\n-                        if let Some((parent_idx, ref_data)) = parent_edge {\n-                            graph.add_edge(parent_idx, current_idx, ref_data);\n-                        }\n-                    }\n-                    SingleModuleGraphBuilderNode::VisitedModule { module, idx } => {\n-                        // Find the current node, if it was already added\n-                        let current_idx = if let Some(current_idx) = modules.get(&module) {\n-                            *current_idx\n-                        } else {\n-                            let idx = graph\n-                                .add_node(SingleModuleGraphNode::VisitedModule { idx, module });\n-                            modules.insert(module, idx);\n-                            idx\n-                        };\n-                        // Add the edge\n-                        if let Some((parent_idx, data)) = parent_edge {\n-                            graph.add_edge(parent_idx, current_idx, data);\n-                        }\n-                    }\n-                    SingleModuleGraphBuilderNode::ChunkableReference {\n-                        source,\n-                        target,\n-                        ref_data,\n-                        ..\n-                    } => {\n-                        // Find the current node, if it was already added\n-                        let target_idx = if let Some(target_idx) = modules.get(&target) {\n-                            *target_idx\n-                        } else {\n-                            let target_idx = visited_modules.get(&target);\n-                            let idx = graph.add_node(match target_idx {\n-                                Some(idx) => SingleModuleGraphNode::VisitedModule {\n-                                    idx: *idx,\n-                                    module: target,\n-                                },\n-                                None => SingleModuleGraphNode::Module(target),\n-                            });\n-                            modules.insert(target, idx);\n-                            idx\n-                        };\n-                        graph.add_edge(*modules.get(&source).unwrap(), target_idx, ref_data);\n-                    }\n+                // Find the current node, if it was already added\n+                let current_idx = if let Some(current_idx) = modules.get(&module) {\n+                    *current_idx\n+                } else {\n+                    let idx = graph.add_node(graph_node);\n+                    number_of_modules += count;\n+                    modules.insert(module, idx);\n+                    idx\n+                };\n+                // Add the edge\n+                if let Some((SingleModuleGraphBuilderNode::Module { module, .. }, ref_data)) =\n+                    parent\n+                {\n+                    let parent_idx = *modules.get(&module).unwrap();\n+                    graph.add_edge(parent_idx, current_idx, ref_data);\n                 }\n             }\n         }\n@@ -1623,16 +1567,6 @@ pub enum GraphTraversalAction {\n // afterwards build the SingleModuleGraph.\n #[derive(Clone, Hash, PartialEq, Eq)]\n enum SingleModuleGraphBuilderNode {\n-    /// This edge is represented as a node: source Module -> ChunkableReference ->  target Module\n-    ChunkableReference {\n-        ref_data: RefData,\n-        source: ResolvedVc<Box<dyn Module>>,\n-        target: ResolvedVc<Box<dyn Module>>,\n-        // These two fields are only used for tracing. Derived from `source.ident()` and\n-        // `target.ident()`\n-        source_ident: Option<ReadRef<RcStr>>,\n-        target_ident: Option<ReadRef<RcStr>>,\n-    },\n     /// A regular module\n     Module {\n         module: ResolvedVc<Box<dyn Module>>,\n@@ -1658,46 +1592,10 @@ impl SingleModuleGraphBuilderNode {\n             },\n         })\n     }\n-    async fn new_chunkable_ref(\n-        emit_spans: bool,\n-        source: ResolvedVc<Box<dyn Module>>,\n-        target: ResolvedVc<Box<dyn Module>>,\n-        ref_data: RefData,\n-    ) -> Result<Self> {\n-        Ok(Self::ChunkableReference {\n-            ref_data,\n-            source,\n-            source_ident: if emit_spans {\n-                // INVALIDATION: we don't need to invalidate when the span name changes\n-                Some(source.ident_string().untracked().await?)\n-            } else {\n-                None\n-            },\n-            target,\n-            target_ident: if emit_spans {\n-                // INVALIDATION: we don't need to invalidate when the span name changes\n-                Some(target.ident_string().untracked().await?)\n-            } else {\n-                None\n-            },\n-        })\n-    }\n     fn new_visited_module(module: ResolvedVc<Box<dyn Module>>, idx: GraphNodeIndex) -> Self {\n         Self::VisitedModule { module, idx }\n     }\n }\n-struct SingleModuleGraphBuilderEdge {\n-    to: SingleModuleGraphBuilderNode,\n-    binding_usage: BindingUsage,\n-    reference: Option<ResolvedVc<Box<dyn ModuleReference>>>,\n-}\n-\n-/// The chunking type that occurs most often, is handled more efficiently by not creating\n-/// intermediate SingleModuleGraphBuilderNode::ChunkableReference nodes.\n-const COMMON_CHUNKING_TYPE: ChunkingType = ChunkingType::Parallel {\n-    inherit_async: true,\n-    hoisted: true,\n-};\n \n struct SingleModuleGraphBuilder<'a> {\n     visited_modules: &'a FxIndexMap<ResolvedVc<Box<dyn Module>>, GraphNodeIndex>,\n@@ -1710,191 +1608,141 @@ struct SingleModuleGraphBuilder<'a> {\n     /// Whether to read ChunkableModuleReference::binding_usage()\n     include_binding_usage: bool,\n }\n-impl\n-    Visit<(\n-        SingleModuleGraphBuilderNode,\n-        Option<ResolvedVc<Box<dyn ModuleReference>>>,\n-        BindingUsage,\n-    )> for SingleModuleGraphBuilder<'_>\n-{\n-    type Edge = SingleModuleGraphBuilderEdge;\n-    type EdgesIntoIter = Vec<Self::Edge>;\n+impl Visit<SingleModuleGraphBuilderNode, RefData> for SingleModuleGraphBuilder<'_> {\n+    type EdgesIntoIter = Vec<(SingleModuleGraphBuilderNode, RefData)>;\n     type EdgesFuture = impl Future<Output = Result<Self::EdgesIntoIter>>;\n \n     fn visit(\n         &mut self,\n-        edge: Self::Edge,\n-    ) -> VisitControlFlow<(\n-        SingleModuleGraphBuilderNode,\n-        Option<ResolvedVc<Box<dyn ModuleReference>>>,\n-        BindingUsage,\n-    )> {\n-        match edge.to {\n-            SingleModuleGraphBuilderNode::Module { .. } => {\n-                VisitControlFlow::Continue((edge.to, edge.reference, edge.binding_usage))\n-            }\n-            SingleModuleGraphBuilderNode::ChunkableReference { ref ref_data, .. } => {\n-                match &ref_data.chunking_type {\n-                    ChunkingType::Traced => {\n-                        VisitControlFlow::Skip((edge.to, edge.reference, edge.binding_usage))\n-                    }\n-                    _ => VisitControlFlow::Continue((edge.to, edge.reference, edge.binding_usage)),\n-                }\n-            }\n+        node: &SingleModuleGraphBuilderNode,\n+        edge: Option<&RefData>,\n+    ) -> VisitControlFlow {\n+        if let Some(edge) = edge\n+            && matches!(edge.chunking_type, ChunkingType::Traced)\n+        {\n+            // The graph behind traced references is not part of the module graph traversal\n+            return VisitControlFlow::Skip;\n+        }\n+        match node {\n+            SingleModuleGraphBuilderNode::Module { .. } => VisitControlFlow::Continue,\n             // Module was already visited previously\n-            SingleModuleGraphBuilderNode::VisitedModule { .. } => {\n-                VisitControlFlow::Skip((edge.to, edge.reference, edge.binding_usage))\n-            }\n+            SingleModuleGraphBuilderNode::VisitedModule { .. } => VisitControlFlow::Skip,\n         }\n     }\n \n     fn edges(\n         &mut self,\n         // The `skip_duplicates_with_key()` above ensures only a single `edges()` call per module\n         // (and not per `(module, export)` pair), so the export must not be read here!\n-        (node, ..): &(\n-            SingleModuleGraphBuilderNode,\n-            Option<ResolvedVc<Box<dyn ModuleReference>>>,\n-            BindingUsage,\n-        ),\n+        node: &SingleModuleGraphBuilderNode,\n     ) -> Self::EdgesFuture {\n         // Destructure beforehand to not have to clone the whole node when entering the async block\n-        let (module, chunkable_ref_target) = match node {\n-            SingleModuleGraphBuilderNode::Module { module, .. } => (Some(*module), None),\n-            SingleModuleGraphBuilderNode::ChunkableReference {\n-                target, ref_data, ..\n-            } => (\n-                None,\n-                Some((*target, ref_data.reference, ref_data.binding_usage.clone())),\n-            ),\n+        let &SingleModuleGraphBuilderNode::Module { module, .. } = node else {\n             // These are always skipped in `visit()`\n-            SingleModuleGraphBuilderNode::VisitedModule { .. } => unreachable!(),\n+            unreachable!()\n         };\n         let visited_modules = self.visited_modules;\n         let emit_spans = self.emit_spans;\n         let include_traced = self.include_traced;\n         let include_binding_usage = self.include_binding_usage;\n         async move {\n-            Ok(match (module, chunkable_ref_target) {\n-                (Some(module), None) => {\n-                    let refs_cell = primary_chunkable_referenced_modules(\n-                        *module,\n-                        include_traced,\n-                        include_binding_usage,\n-                    );\n-                    let refs = match refs_cell.await {\n-                        Ok(refs) => refs,\n-                        Err(e) => {\n-                            return Err(e.context(module.ident().to_string().await?));\n-                        }\n-                    };\n-\n-                    refs.iter()\n-                        .flat_map(|(reference, resolved)| {\n-                            resolved.modules.iter().map(|m| {\n-                                (\n-                                    *reference,\n-                                    resolved.chunking_type.clone(),\n-                                    resolved.binding_usage.clone(),\n-                                    *m,\n-                                )\n-                            })\n-                        })\n-                        .map(async |(reference, ty, binding_usage, target)| {\n-                            let to = if ty == COMMON_CHUNKING_TYPE {\n-                                if let Some(idx) = visited_modules.get(&target) {\n-                                    SingleModuleGraphBuilderNode::new_visited_module(target, *idx)\n-                                } else {\n-                                    SingleModuleGraphBuilderNode::new_module(emit_spans, target)\n-                                        .await?\n-                                }\n-                            } else {\n-                                SingleModuleGraphBuilderNode::new_chunkable_ref(\n-                                    emit_spans,\n-                                    module,\n-                                    target,\n-                                    RefData {\n-                                        chunking_type: ty,\n-                                        binding_usage: binding_usage.clone(),\n-                                        reference,\n-                                    },\n-                                )\n-                                .await?\n-                            };\n-                            Ok(SingleModuleGraphBuilderEdge {\n-                                to,\n-                                binding_usage,\n-                                reference: Some(reference),\n-                            })\n-                        })\n-                        .try_join()\n-                        .await?\n+            let refs_cell = primary_chunkable_referenced_modules(\n+                *module,\n+                include_traced,\n+                include_binding_usage,\n+            );\n+            let refs = match refs_cell.await {\n+                Ok(refs) => refs,\n+                Err(e) => {\n+                    return Err(e.context(module.ident().to_string().await?));\n                 }\n-                (None, Some((chunkable_ref_target, reference, binding_usage))) => {\n-                    vec![SingleModuleGraphBuilderEdge {\n-                        to: if let Some(idx) = visited_modules.get(&chunkable_ref_target) {\n-                            SingleModuleGraphBuilderNode::new_visited_module(\n-                                chunkable_ref_target,\n-                                *idx,\n-                            )\n-                        } else {\n-                            SingleModuleGraphBuilderNode::new_module(\n-                                emit_spans,\n-                                chunkable_ref_target,\n-                            )\n-                            .await?\n+            };\n+\n+            refs.iter()\n+                .flat_map(|(reference, resolved)| {\n+                    resolved.modules.iter().map(|m| {\n+                        (\n+                            *reference,\n+                            resolved.chunking_type.clone(),\n+                            resolved.binding_usage.clone(),\n+                            *m,\n+                        )\n+                    })\n+                })\n+                .map(async |(reference, ty, binding_usage, target)| {\n+                    let to = if let Some(idx) = visited_modules.get(&target) {\n+                        SingleModuleGraphBuilderNode::new_visited_module(target, *idx)\n+                    } else {\n+                        SingleModuleGraphBuilderNode::new_module(emit_spans, target).await?\n+                    };\n+                    Ok((\n+                        to,\n+                        RefData {\n+                            chunking_type: ty,\n+                            binding_usage,\n+                            reference,\n                         },\n-                        binding_usage,\n-                        reference: Some(reference),\n-                    }]\n-                }\n-                _ => unreachable!(),\n-            })\n+                    ))\n+                })\n+                .try_join()\n+                .await\n         }\n     }\n \n     fn span(\n         &mut self,\n-        (node, ..): &(\n-            SingleModuleGraphBuilderNode,\n-            Option<ResolvedVc<Box<dyn ModuleReference>>>,\n-            BindingUsage,\n-        ),\n+        node: &SingleModuleGraphBuilderNode,\n+        edge: Option<&RefData>,\n     ) -> tracing::Span {\n         if !self.emit_spans {\n-            return Span::current();\n+            return Span::none();\n         }\n \n-        match node {\n+        let mut span = match node {\n             SingleModuleGraphBuilderNode::Module {\n                 ident: Some(ident), ..\n             } => {\n                 tracing::info_span!(\"module\", name = display(ident))\n             }\n-            SingleModuleGraphBuilderNode::ChunkableReference {\n-                ref_data,\n-                source_ident: Some(source_ident),\n-                target_ident: Some(target_ident),\n-                ..\n-            } => match &ref_data.chunking_type {\n-                ChunkingType::Parallel {\n-                    inherit_async: false,\n-                    ..\n-                } => Span::current(),\n-                _ => {\n-                    tracing::info_span!(\n-                        \"chunkable reference\",\n-                        ty = debug(&ref_data.chunking_type),\n-                        source = display(source_ident),\n-                        target = display(target_ident)\n-                    )\n-                }\n-            },\n             SingleModuleGraphBuilderNode::VisitedModule { .. } => {\n                 tracing::info_span!(\"visited module\")\n             }\n-            _ => Span::current(),\n+            _ => unreachable!(),\n+        };\n+\n+        if let Some(edge) = edge {\n+            match &edge.chunking_type {\n+                ChunkingType::Parallel {\n+                    inherit_async: _,\n+                    hoisted: _,\n+                } => {}\n+                ChunkingType::Traced => {\n+                    let _span = span.entered();\n+                    span = tracing::info_span!(\"traced reference\");\n+                }\n+                ChunkingType::Async => {\n+                    let _span = span.entered();\n+                    span = tracing::info_span!(\"async reference\");\n+                }\n+                ChunkingType::Isolated { _ty: ty, merge_tag } => {\n+                    let _span = span.entered();\n+                    span = tracing::info_span!(\n+                        \"isolated reference\",\n+                        ty = debug(&ty),\n+                        merge_tag = debug(&merge_tag)\n+                    );\n+                }\n+                ChunkingType::Shared {\n+                    inherit_async: _,\n+                    merge_tag,\n+                } => {\n+                    let _span = span.entered();\n+                    span = tracing::info_span!(\"shared reference\", merge_tag = debug(&merge_tag));\n+                }\n+            };\n         }\n+\n+        span\n     }\n }\n "
        },
        {
            "sha": "e3999b07f02a4bcea07395e5822ba6544858ff37",
            "filename": "turbopack/crates/turbopack-core/src/output.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/92f72373644fae3a2822386480e9e2b6fcf3df68/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Foutput.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/92f72373644fae3a2822386480e9e2b6fcf3df68/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Foutput.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Foutput.rs?ref=92f72373644fae3a2822386480e9e2b6fcf3df68",
            "patch": "@@ -266,13 +266,11 @@ pub async fn expand_output_assets(\n     inner_output_assets: bool,\n ) -> Result<Vec<ResolvedVc<Box<dyn OutputAsset>>>> {\n     let edges = AdjacencyMap::new()\n-        .skip_duplicates()\n         .visit(inputs, async |input| {\n             get_referenced_assets(inner_output_assets, input).await\n         })\n         .await\n         .completed()?\n-        .into_inner()\n         .into_postorder_topological();\n \n     let mut assets = Vec::new();"
        }
    ],
    "stats": {
        "total": 1165,
        "additions": 441,
        "deletions": 724
    }
}