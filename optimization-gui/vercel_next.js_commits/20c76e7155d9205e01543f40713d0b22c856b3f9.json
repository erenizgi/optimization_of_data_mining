{
    "author": "acdlite",
    "message": "Split each path param into a separate cache key  (#85758)\n\nRefactors the keypath used to cache segments so that each route param is\na separate cache key. The search string was already its own separate\nkey, so this generalizes it to include path params, too.\n\nThis is a prerequisite for reusing cache entries across different values\nof a param if the server indicates that the response does not vary on\nthat param. Currently the server does not send that information, but\nwe'll add this in a subsequent step.\n\nAs part of this change, this refines the concept of a \"keypath\" to be\ncalled a \"vary path\" instead. From the perspective of the CacheMap\nmodule, they are functionally identical, but from the perspective of the\noverall caching design, it's more specific: a vary path is a pure\nfunction of a segment's position in a particular route tree and the\n(post-rewrite) URL that is being queried. More concretely, successive\nqueries of the cache for the same segment always use the same vary path.",
    "sha": "20c76e7155d9205e01543f40713d0b22c856b3f9",
    "files": [
        {
            "sha": "07d65dc10025d2358c37787fc68ac870362fdff9",
            "filename": "packages/next/src/client/components/segment-cache/cache-map.ts",
            "status": "modified",
            "additions": 67,
            "deletions": 82,
            "changes": 149,
            "blob_url": "https://github.com/vercel/next.js/blob/20c76e7155d9205e01543f40713d0b22c856b3f9/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fcache-map.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/20c76e7155d9205e01543f40713d0b22c856b3f9/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fcache-map.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fcache-map.ts?ref=20c76e7155d9205e01543f40713d0b22c856b3f9",
            "patch": "@@ -1,3 +1,4 @@\n+import type { VaryPath } from './vary-path'\n import { lruPut, updateLruSize, deleteFromLru } from './lru'\n \n /**\n@@ -10,10 +11,15 @@ import { lruPut, updateLruSize, deleteFromLru } from './lru'\n  *   set(map, ['https://localhost', 'foo/bar/baz'], 'yay');\n  *   get(map, ['https://localhost', 'foo/bar/baz']) -> 'yay'\n  *\n+ * NOTE: Array syntax is used in these examples for illustration purposes, but\n+ * in reality the paths are lists.\n+ * \n  * The parts of the keypath represent the different inputs that contribute\n  * to the entry value. To illustrate, if you were to use this data type to store\n  * HTTP responses, the keypath would include the URL and everything listed by\n  * the Vary header.\n+ * \n+ * See vary-path.ts for more details.\n  *\n  * The order of elements in a keypath must be consistent between lookups to\n  * be considered the same, but besides that, the order of the keys is not\n@@ -40,10 +46,11 @@ import { lruPut, updateLruSize, deleteFromLru } from './lru'\n  * regular JS maps do not have: a value cannot be stored at multiple keypaths\n  * simultaneously. These cases should be expressed with Fallback keys instead.\n  *\n- * Additionally, because values only exist at a single keypath at a time, we can\n- * optimize successive lookups by caching the internal map entry on the value\n- * itself, using the `ref` field. This is especially useful because it lets us\n- * skip the O(n ^ 2) lookup that occurs when Fallback entries are present.\n+ * Additionally, because values only exist at a single keypath at a time, we\n+ * can optimize successive lookups by caching the internal map entry on the\n+ * value itself, using the `ref` field. This is especially useful because it\n+ * lets us skip the O(n ^ 2) lookup that occurs when Fallback entries\n+ * are present.\n  *\n \n  * How to decide if stuff belongs in here, or in cache.ts?\n@@ -58,68 +65,50 @@ import { lruPut, updateLruSize, deleteFromLru } from './lru'\n  * should prefer to put it in cache.ts.\n  */\n \n-type MapEntryShared<K extends readonly unknown[], V extends MapValue> = {\n-  parent: MapEntry<K, V> | null\n+type MapEntryShared<V extends MapValue> = {\n+  parent: MapEntry<V> | null\n   key: any\n-  map: Map<any, MapEntry<K, V>> | null\n+  map: Map<any, MapEntry<V>> | null\n \n   // LRU-related fields\n-  prev: MapEntry<any, any> | null\n-  next: MapEntry<any, any> | null\n+  prev: MapEntry<any> | null\n+  next: MapEntry<any> | null\n   size: number\n }\n \n-type EmptyMapEntry<\n-  K extends readonly unknown[],\n-  V extends MapValue,\n-> = MapEntryShared<K, V> & {\n+type EmptyMapEntry<V extends MapValue> = MapEntryShared<V> & {\n   value: null\n }\n \n-type FullMapEntry<\n-  K extends readonly unknown[],\n-  V extends MapValue,\n-> = MapEntryShared<K, V> & {\n+type FullMapEntry<V extends MapValue> = MapEntryShared<V> & {\n   value: V\n }\n \n-export type MapEntry<K extends readonly unknown[], V extends MapValue> =\n-  | EmptyMapEntry<K, V>\n-  | FullMapEntry<K, V>\n+export type MapEntry<V extends MapValue> = EmptyMapEntry<V> | FullMapEntry<V>\n \n // The CacheMap type is just the root entry of the map.\n-export type CacheMap<\n-  K extends readonly unknown[],\n-  V extends MapValue,\n-> = MapEntry<K, V>\n+export type CacheMap<V extends MapValue> = MapEntry<V>\n \n // The protocol that values must implement. In practice, the only two types that\n // we ever actually deal with in this module are RouteCacheEntry and\n // SegmentCacheEntry; this is just to keep track of the coupling so we don't\n // leak concerns between the modules unnecessarily.\n export interface MapValue {\n-  ref: MapEntry<any, any> | null\n+  ref: MapEntry<any> | null\n   size: number\n   staleAt: number\n   version: number\n }\n \n-type KeyWithFallback<K extends readonly unknown[]> = {\n-  [I in keyof K]: K[I] | FallbackType\n-}\n-\n export type FallbackType = { __brand: 'Fallback' }\n export const Fallback = {} as FallbackType\n \n // This is a special internal key that is used for \"revalidation\" entries. It's\n // an implementation detail that shouldn't leak outside of this module.\n const Revalidation = {}\n \n-export function createCacheMap<\n-  Keypath extends Array<any>,\n-  V extends MapValue,\n->(): CacheMap<Keypath, V> {\n-  let cacheMap: MapEntry<Keypath, V> = {\n+export function createCacheMap<V extends MapValue>(): CacheMap<V> {\n+  const cacheMap: MapEntry<V> = {\n     parent: null,\n     key: null,\n     value: null,\n@@ -133,24 +122,26 @@ export function createCacheMap<\n   return cacheMap\n }\n \n-function getOrInitialize<K extends readonly unknown[], V extends MapValue>(\n-  cacheMap: CacheMap<K, V>,\n-  keys: K,\n+function getOrInitialize<V extends MapValue>(\n+  cacheMap: CacheMap<V>,\n+  keys: VaryPath,\n   isRevalidation: boolean\n-): MapEntry<K, V> {\n+): MapEntry<V> {\n   // Go through each level of keys until we find the entry that matches, or\n   // create a new entry if one doesn't exist.\n   //\n   // This function will only return entries that match the keypath _exactly_.\n   // Unlike getWithFallback, it will not access fallback entries unless it's\n   // explicitly part of the keypath.\n   let entry = cacheMap\n-  let i = 0\n+  let remainingKeys: VaryPath | null = keys\n+  let key: unknown | null = null\n   while (true) {\n-    let key\n-    if (i < keys.length) {\n-      key = keys[i]\n-    } else if (isRevalidation && i === keys.length) {\n+    const previousKey = key\n+    if (remainingKeys !== null) {\n+      key = remainingKeys.value\n+      remainingKeys = remainingKeys.parent\n+    } else if (isRevalidation && previousKey !== Revalidation) {\n       // During a revalidation, we append an internal \"Revalidation\" key to\n       // the end of the keypath. The \"normal\" entry is its parent.\n \n@@ -167,7 +158,6 @@ function getOrInitialize<K extends readonly unknown[], V extends MapValue>(\n       // There are no more keys. This is the terminal entry.\n       break\n     }\n-    i++\n \n     let map = entry.map\n     if (map !== null) {\n@@ -182,7 +172,7 @@ function getOrInitialize<K extends readonly unknown[], V extends MapValue>(\n       entry.map = map\n     }\n     // No entry exists yet at this level. Create a new one.\n-    const newEntry: EmptyMapEntry<K, V> = {\n+    const newEntry: EmptyMapEntry<V> = {\n       parent: entry,\n       key,\n       value: null,\n@@ -200,14 +190,11 @@ function getOrInitialize<K extends readonly unknown[], V extends MapValue>(\n   return entry\n }\n \n-export function getFromCacheMap<\n-  K extends readonly unknown[],\n-  V extends MapValue,\n->(\n+export function getFromCacheMap<V extends MapValue>(\n   now: number,\n   currentCacheVersion: number,\n-  rootEntry: CacheMap<K, V>,\n-  keys: KeyWithFallback<K>,\n+  rootEntry: CacheMap<V>,\n+  keys: VaryPath,\n   isRevalidation: boolean\n ): V | null {\n   const entry = getEntryWithFallbackImpl(\n@@ -234,10 +221,10 @@ export function isValueExpired<V extends MapValue>(\n   return value.staleAt <= now || value.version < currentCacheVersion\n }\n \n-function lazilyEvictIfNeeded<K extends readonly unknown[], V extends MapValue>(\n+function lazilyEvictIfNeeded<V extends MapValue>(\n   now: number,\n   currentCacheVersion: number,\n-  entry: MapEntry<K, V>\n+  entry: MapEntry<V>\n ) {\n   // We have a matching entry, but before we can return it, we need to check if\n   // it's still fresh. Otherwise it should be treated the same as a cache miss.\n@@ -259,30 +246,30 @@ function lazilyEvictIfNeeded<K extends readonly unknown[], V extends MapValue>(\n   return entry\n }\n \n-function getEntryWithFallbackImpl<\n-  K extends readonly unknown[],\n-  V extends MapValue,\n->(\n+function getEntryWithFallbackImpl<V extends MapValue>(\n   now: number,\n   currentCacheVersion: number,\n-  entry: MapEntry<K, V>,\n-  keys: K,\n+  entry: MapEntry<V>,\n+  keys: VaryPath | null,\n   isRevalidation: boolean,\n-  index: number\n-): MapEntry<K, V> | null {\n+  previousKey: unknown | null\n+): MapEntry<V> | null {\n   // This is similar to getExactEntry, but if an exact match is not found for\n   // a key, it will return the fallback entry instead. This is recursive at\n   // every level, e.g. an entry with keypath [a, Fallback, c, Fallback] is\n   // valid match for [a, b, c, d].\n   //\n   // It will return the most specific match available.\n   let key\n-  if (index < keys.length) {\n-    key = keys[index]\n-  } else if (isRevalidation && index === keys.length) {\n+  let remainingKeys: VaryPath | null\n+  if (keys !== null) {\n+    key = keys.value\n+    remainingKeys = keys.parent\n+  } else if (isRevalidation && previousKey !== Revalidation) {\n     // During a revalidation, we append an internal \"Revalidation\" key to\n     // the end of the keypath.\n     key = Revalidation\n+    remainingKeys = null\n   } else {\n     // There are no more keys. This is the terminal entry.\n \n@@ -299,13 +286,13 @@ function getEntryWithFallbackImpl<\n     const existingEntry = map.get(key)\n     if (existingEntry !== undefined) {\n       // Found an exact match for this key. Keep searching.\n-      const result = getEntryWithFallbackImpl<K, V>(\n+      const result = getEntryWithFallbackImpl<V>(\n         now,\n         currentCacheVersion,\n         existingEntry,\n-        keys,\n+        remainingKeys,\n         isRevalidation,\n-        index + 1\n+        key\n       )\n       if (result !== null) {\n         return result\n@@ -319,18 +306,18 @@ function getEntryWithFallbackImpl<\n         now,\n         currentCacheVersion,\n         fallbackEntry,\n-        keys,\n+        remainingKeys,\n         isRevalidation,\n-        index + 1\n+        key\n       )\n     }\n   }\n   return null\n }\n \n-export function setInCacheMap<K extends readonly unknown[], V extends MapValue>(\n-  cacheMap: CacheMap<K, V>,\n-  keys: K,\n+export function setInCacheMap<V extends MapValue>(\n+  cacheMap: CacheMap<V>,\n+  keys: VaryPath,\n   value: V,\n   isRevalidation: boolean\n ): void {\n@@ -345,8 +332,8 @@ export function setInCacheMap<K extends readonly unknown[], V extends MapValue>(\n   updateLruSize(entry, value.size)\n }\n \n-function setMapEntryValue<K extends readonly unknown[], V extends MapValue>(\n-  entry: MapEntry<K, V>,\n+function setMapEntryValue<V extends MapValue>(\n+  entry: MapEntry<V>,\n   value: V\n ): void {\n   if (entry.value !== null) {\n@@ -356,23 +343,23 @@ function setMapEntryValue<K extends readonly unknown[], V extends MapValue>(\n     dropRef(entry.value)\n \n     // Fill the entry with the updated value.\n-    const emptyEntry: EmptyMapEntry<K, V> = entry as any\n+    const emptyEntry: EmptyMapEntry<V> = entry as any\n     emptyEntry.value = null\n     fillEmptyReference(emptyEntry, value)\n   } else {\n     fillEmptyReference(entry as any, value)\n   }\n }\n \n-function fillEmptyReference<K extends readonly unknown[], V extends MapValue>(\n-  entry: EmptyMapEntry<K, V>,\n+function fillEmptyReference<V extends MapValue>(\n+  entry: EmptyMapEntry<V>,\n   value: V\n ): void {\n   // This value may already be in the map at a different keypath.\n   // Grab a reference before we overwrite it.\n   const oldEntry = value.ref\n \n-  const fullEntry: FullMapEntry<K, V> = entry as any\n+  const fullEntry: FullMapEntry<V> = entry as any\n   fullEntry.value = value\n   value.ref = fullEntry\n \n@@ -409,11 +396,9 @@ function dropRef<V extends MapValue>(value: V): void {\n   value.ref = null\n }\n \n-function deleteMapEntry<K extends readonly unknown[], V extends MapValue>(\n-  entry: MapEntry<K, V>\n-): void {\n+function deleteMapEntry<V extends MapValue>(entry: MapEntry<V>): void {\n   // Delete the entry from the cache.\n-  const emptyEntry: EmptyMapEntry<K, V> = entry as any\n+  const emptyEntry: EmptyMapEntry<V> = entry as any\n   emptyEntry.value = null\n \n   deleteFromLru(entry)"
        },
        {
            "sha": "e053fd7c09aec3201e55f1a778bd8fe46468c50a",
            "filename": "packages/next/src/client/components/segment-cache/cache.ts",
            "status": "modified",
            "additions": 378,
            "deletions": 272,
            "changes": 650,
            "blob_url": "https://github.com/vercel/next.js/blob/20c76e7155d9205e01543f40713d0b22c856b3f9/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fcache.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/20c76e7155d9205e01543f40713d0b22c856b3f9/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fcache.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fcache.ts?ref=20c76e7155d9205e01543f40713d0b22c856b3f9",
            "patch": "@@ -6,7 +6,6 @@ import type {\n import type { LoadingModuleData } from '../../../shared/lib/app-router-types'\n import type {\n   CacheNodeSeedData,\n-  DynamicParamTypesShort,\n   Segment as FlightRouterStateSegment,\n } from '../../../shared/lib/app-router-types'\n import { HasLoadingBoundary } from '../../../shared/lib/app-router-types'\n@@ -33,24 +32,31 @@ import {\n   type PrefetchSubtaskResult,\n   startRevalidationCooldown,\n } from './scheduler'\n+import {\n+  type RouteVaryPath,\n+  type SegmentVaryPath,\n+  type PartialSegmentVaryPath,\n+  getRouteVaryPath,\n+  getFulfilledRouteVaryPath,\n+  getSegmentVaryPathForRequest,\n+  appendLayoutVaryPath,\n+  finalizeLayoutVaryPath,\n+  finalizePageVaryPath,\n+  clonePageVaryPathWithNewSearchParams,\n+  type PageVaryPath,\n+  finalizeMetadataVaryPath,\n+} from './vary-path'\n import { getAppBuildId } from '../../app-build-id'\n import { createHrefFromUrl } from '../router-reducer/create-href-from-url'\n-import type {\n-  NormalizedPathname,\n-  NormalizedNextUrl,\n-  NormalizedSearch,\n-  RouteCacheKey,\n-} from './cache-key'\n+import type { NormalizedSearch, RouteCacheKey } from './cache-key'\n // TODO: Rename this module to avoid confusion with other types of cache keys\n import { createCacheKey as createPrefetchRequestKey } from './cache-key'\n import {\n   doesStaticSegmentAppearInURL,\n   getCacheKeyForDynamicParam,\n-  getParamValueFromCacheKey,\n   getRenderedPathname,\n   getRenderedSearch,\n   parseDynamicParamFromURLPart,\n-  type RouteParam,\n } from '../../route-params'\n import {\n   createCacheMap,\n@@ -59,23 +65,15 @@ import {\n   setSizeInCacheMap,\n   deleteFromCacheMap,\n   isValueExpired,\n-  Fallback,\n   type CacheMap,\n   type MapEntry,\n-  type FallbackType,\n } from './cache-map'\n import {\n-  appendSegmentCacheKeyPart,\n   appendSegmentRequestKeyPart,\n   convertSegmentPathToStaticExportFilename,\n-  createSegmentCacheKeyPart,\n   createSegmentRequestKeyPart,\n-  createHeadCacheKey,\n-  isHeadCacheKey,\n   HEAD_REQUEST_KEY,\n-  ROOT_SEGMENT_CACHE_KEY,\n   ROOT_SEGMENT_REQUEST_KEY,\n-  type SegmentCacheKey,\n   type SegmentRequestKey,\n } from '../../../shared/lib/segment-cache/segment-value-encoding'\n import type {\n@@ -125,13 +123,11 @@ export function getStaleTimeMs(staleTimeSeconds: number): number {\n // the root, then it's effectively canceled. This is similar to the design of\n // Rust Futures, or React Suspense.\n \n-export type RouteTree = {\n-  cacheKey: SegmentCacheKey\n+type RouteTreeShared = {\n   requestKey: SegmentRequestKey\n   // TODO: Remove the `segment` field, now that it can be reconstructed\n   // from `param`.\n   segment: FlightRouterStateSegment\n-  param: RouteParam | null\n   slots: null | {\n     [parallelRouteKey: string]: RouteTree\n   }\n@@ -151,14 +147,26 @@ export type RouteTree = {\n   hasRuntimePrefetch: boolean\n }\n \n+type LayoutRouteTree = RouteTreeShared & {\n+  isPage: false\n+  varyPath: SegmentVaryPath\n+}\n+\n+type PageRouteTree = RouteTreeShared & {\n+  isPage: true\n+  varyPath: PageVaryPath\n+}\n+\n+export type RouteTree = LayoutRouteTree | PageRouteTree\n+\n type RouteCacheEntryShared = {\n   // This is false only if we're certain the route cannot be intercepted. It's\n   // true in all other cases, including on initialization when we haven't yet\n   // received a response from the server.\n   couldBeIntercepted: boolean\n \n   // Map-related fields.\n-  ref: null | MapEntry<RouteCacheKeypath, RouteCacheEntry>\n+  ref: null | MapEntry<RouteCacheEntry>\n   size: number\n   staleAt: number\n   version: number\n@@ -215,7 +223,7 @@ type SegmentCacheEntryShared = {\n   fetchStrategy: FetchStrategy\n \n   // Map-related fields.\n-  ref: null | MapEntry<SegmentCacheKeypath, SegmentCacheEntry>\n+  ref: null | MapEntry<SegmentCacheEntry>\n   size: number\n   staleAt: number\n   version: number\n@@ -275,23 +283,8 @@ const MetadataOnlyRequestTree: FlightRouterState = [\n   'metadata-only',\n ]\n \n-// Route cache entries vary on multiple keys: the href and the Next-Url. Each of\n-// these parts needs to be included in the internal cache key. Rather than\n-// concatenate the keys into a single key, we use a multi-level map, where the\n-// first level is keyed by href, the second level is keyed by Next-Url, and so\n-// on (if were to add more levels).\n-type RouteCacheKeypath = [\n-  NormalizedPathname,\n-  NormalizedSearch,\n-  NormalizedNextUrl | null | FallbackType,\n-]\n-let routeCacheMap: CacheMap<RouteCacheKeypath, RouteCacheEntry> =\n-  createCacheMap()\n-\n-export type SegmentCacheKeypath = [string, NormalizedSearch | FallbackType]\n-\n-let segmentCacheMap: CacheMap<SegmentCacheKeypath, SegmentCacheEntry> =\n-  createCacheMap()\n+let routeCacheMap: CacheMap<RouteCacheEntry> = createCacheMap()\n+let segmentCacheMap: CacheMap<SegmentCacheEntry> = createCacheMap()\n \n // All invalidation listeners for the whole cache are tracked in single set.\n // Since we don't yet support tag or path-based invalidation, there's no point\n@@ -396,88 +389,45 @@ export function readRouteCacheEntry(\n   now: number,\n   key: RouteCacheKey\n ): RouteCacheEntry | null {\n-  const keypath: RouteCacheKeypath = [key.pathname, key.search, key.nextUrl]\n+  const varyPath: RouteVaryPath = getRouteVaryPath(\n+    key.pathname,\n+    key.search,\n+    key.nextUrl\n+  )\n   const isRevalidation = false\n   return getFromCacheMap(\n     now,\n     getCurrentCacheVersion(),\n     routeCacheMap,\n-    keypath,\n+    varyPath,\n     isRevalidation\n   )\n }\n \n-export function getCanonicalSegmentKeypath(\n-  route: FulfilledRouteCacheEntry,\n-  cacheKey: SegmentCacheKey\n-): SegmentCacheKeypath {\n-  // Returns the actual keypath for a segment, without omitting any params.\n-  return [\n-    cacheKey,\n-    cacheKey.endsWith('/' + PAGE_SEGMENT_KEY) || isHeadCacheKey(cacheKey)\n-      ? route.renderedSearch\n-      : // Only page segments and the head may contain search params. There's no\n-        // reason to include them in the keypath otherwise.\n-        Fallback,\n-  ]\n-}\n-\n-export function getGenericSegmentKeypathFromFetchStrategy(\n-  fetchStrategy: FetchStrategy,\n-  route: FulfilledRouteCacheEntry,\n-  cacheKey: SegmentCacheKey\n-): SegmentCacheKeypath {\n-  // Returns the most generic possible keypath for a segment, based on the\n-  // strategy used to fetch it, i.e. static/PPR versus runtime prefetching.\n-  //\n-  // This is used when _writing_ to the cache. We want to choose the most\n-  // generic keypath so that it can be reused as much as possible.\n-  //\n-  // We may be able to re-key the response to something even more generic once\n-  // we receive it — for example, if the server tells us that the response\n-  // doesn't vary on a particular param — but even before we send the request,\n-  // we know somethings based on the fetch strategy alone.\n-  const doesVaryOnSearchParams =\n-    // Only page segments and the head may contain search params. There's no\n-    // reason to include them in the keypath otherwise.\n-    (cacheKey.endsWith('/' + PAGE_SEGMENT_KEY) || isHeadCacheKey(cacheKey)) &&\n-    // Only a runtime prefetch will include search params in the result. Static\n-    // prefetches never include search params, so they can be reused across all\n-    // possible search param values.\n-    (fetchStrategy === FetchStrategy.Full ||\n-      fetchStrategy === FetchStrategy.PPRRuntime)\n-  const keypath: SegmentCacheKeypath = [\n-    cacheKey,\n-\n-    doesVaryOnSearchParams ? route.renderedSearch : Fallback,\n-  ]\n-  return keypath\n-}\n-\n export function readSegmentCacheEntry(\n   now: number,\n-  keypath: SegmentCacheKeypath\n+  varyPath: SegmentVaryPath\n ): SegmentCacheEntry | null {\n   const isRevalidation = false\n   return getFromCacheMap(\n     now,\n     getCurrentCacheVersion(),\n     segmentCacheMap,\n-    keypath,\n+    varyPath,\n     isRevalidation\n   )\n }\n \n function readRevalidatingSegmentCacheEntry(\n   now: number,\n-  keypath: SegmentCacheKeypath\n+  varyPath: SegmentVaryPath\n ): SegmentCacheEntry | null {\n   const isRevalidation = true\n   return getFromCacheMap(\n     now,\n     getCurrentCacheVersion(),\n     segmentCacheMap,\n-    keypath,\n+    varyPath,\n     isRevalidation\n   )\n }\n@@ -535,9 +485,13 @@ export function readOrCreateRouteCacheEntry(\n     staleAt: Infinity,\n     version: getCurrentCacheVersion(),\n   }\n-  const keypath: RouteCacheKeypath = [key.pathname, key.search, key.nextUrl]\n+  const varyPath: RouteVaryPath = getRouteVaryPath(\n+    key.pathname,\n+    key.search,\n+    key.nextUrl\n+  )\n   const isRevalidation = false\n-  setInCacheMap(routeCacheMap, keypath, pendingEntry, isRevalidation)\n+  setInCacheMap(routeCacheMap, varyPath, pendingEntry, isRevalidation)\n   return pendingEntry\n }\n \n@@ -626,6 +580,15 @@ export function requestOptimisticRouteCacheEntry(\n   optimisticUrl.search = optimisticCanonicalSearch\n   const optimisticCanonicalUrl = createHrefFromUrl(optimisticUrl)\n \n+  const optimisticRouteTree = createOptimisticRouteTree(\n+    routeWithNoSearchParams.tree,\n+    optimisticRenderedSearch\n+  )\n+  const optimisticMetadataTree = createOptimisticRouteTree(\n+    routeWithNoSearchParams.metadata,\n+    optimisticRenderedSearch\n+  )\n+\n   // Clone the base route tree, and override the relevant fields with our\n   // optimistic values.\n   const optimisticEntry: FulfilledRouteCacheEntry = {\n@@ -634,8 +597,8 @@ export function requestOptimisticRouteCacheEntry(\n     status: EntryStatus.Fulfilled,\n     // This isn't cloned because it's instance-specific\n     blockedTasks: null,\n-    tree: routeWithNoSearchParams.tree,\n-    metadata: routeWithNoSearchParams.metadata,\n+    tree: optimisticRouteTree,\n+    metadata: optimisticMetadataTree,\n     couldBeIntercepted: routeWithNoSearchParams.couldBeIntercepted,\n     isPPREnabled: routeWithNoSearchParams.isPPREnabled,\n \n@@ -654,6 +617,55 @@ export function requestOptimisticRouteCacheEntry(\n   return optimisticEntry\n }\n \n+function createOptimisticRouteTree(\n+  tree: RouteTree,\n+  newRenderedSearch: NormalizedSearch\n+): RouteTree {\n+  // Create a new route tree that identical to the original one except for\n+  // the rendered search string, which is contained in the vary path.\n+\n+  let clonedSlots: Record<string, RouteTree> | null = null\n+  const originalSlots = tree.slots\n+  if (originalSlots !== null) {\n+    clonedSlots = {}\n+    for (const parallelRouteKey in originalSlots) {\n+      const childTree = originalSlots[parallelRouteKey]\n+      clonedSlots[parallelRouteKey] = createOptimisticRouteTree(\n+        childTree,\n+        newRenderedSearch\n+      )\n+    }\n+  }\n+\n+  // We only need to clone the vary path if the route is a page.\n+  if (tree.isPage) {\n+    return {\n+      requestKey: tree.requestKey,\n+      segment: tree.segment,\n+      varyPath: clonePageVaryPathWithNewSearchParams(\n+        tree.varyPath,\n+        newRenderedSearch\n+      ),\n+      isPage: true,\n+      slots: clonedSlots,\n+      isRootLayout: tree.isRootLayout,\n+      hasLoadingBoundary: tree.hasLoadingBoundary,\n+      hasRuntimePrefetch: tree.hasRuntimePrefetch,\n+    }\n+  }\n+\n+  return {\n+    requestKey: tree.requestKey,\n+    segment: tree.segment,\n+    varyPath: tree.varyPath,\n+    isPage: false,\n+    slots: clonedSlots,\n+    isRootLayout: tree.isRootLayout,\n+    hasLoadingBoundary: tree.hasLoadingBoundary,\n+    hasRuntimePrefetch: tree.hasRuntimePrefetch,\n+  }\n+}\n+\n /**\n  * Checks if an entry for a segment exists in the cache. If so, it returns the\n  * entry, If not, it adds an empty entry to the cache and returns it.\n@@ -662,30 +674,30 @@ export function readOrCreateSegmentCacheEntry(\n   now: number,\n   fetchStrategy: FetchStrategy,\n   route: FulfilledRouteCacheEntry,\n-  cacheKey: SegmentCacheKey\n+  tree: RouteTree\n ): SegmentCacheEntry {\n-  const canonicalKeypath = getCanonicalSegmentKeypath(route, cacheKey)\n-  const existingEntry = readSegmentCacheEntry(now, canonicalKeypath)\n+  const existingEntry = readSegmentCacheEntry(now, tree.varyPath)\n   if (existingEntry !== null) {\n     return existingEntry\n   }\n   // Create a pending entry and add it to the cache.\n-  const genericKeypath = getGenericSegmentKeypathFromFetchStrategy(\n-    fetchStrategy,\n-    route,\n-    cacheKey\n-  )\n+  const varyPathForRequest = getSegmentVaryPathForRequest(fetchStrategy, tree)\n   const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt)\n   const isRevalidation = false\n-  setInCacheMap(segmentCacheMap, genericKeypath, pendingEntry, isRevalidation)\n+  setInCacheMap(\n+    segmentCacheMap,\n+    varyPathForRequest,\n+    pendingEntry,\n+    isRevalidation\n+  )\n   return pendingEntry\n }\n \n export function readOrCreateRevalidatingSegmentEntry(\n   now: number,\n   fetchStrategy: FetchStrategy,\n   route: FulfilledRouteCacheEntry,\n-  cacheKey: SegmentCacheKey\n+  tree: RouteTree\n ): SegmentCacheEntry {\n   // This function is called when we've already confirmed that a particular\n   // segment is cached, but we want to perform another request anyway in case it\n@@ -714,45 +726,46 @@ export function readOrCreateRevalidatingSegmentEntry(\n   // return a less generic entry upon revalidation. For now, though, this isn't\n   // a concern because the keypath is based solely on the prefetch strategy,\n   // not on data contained in the response.\n-  const canonicalKeypath = getCanonicalSegmentKeypath(route, cacheKey)\n-  const existingEntry = readRevalidatingSegmentCacheEntry(now, canonicalKeypath)\n+  const existingEntry = readRevalidatingSegmentCacheEntry(now, tree.varyPath)\n   if (existingEntry !== null) {\n     return existingEntry\n   }\n   // Create a pending entry and add it to the cache.\n-  const genericKeypath = getGenericSegmentKeypathFromFetchStrategy(\n-    fetchStrategy,\n-    route,\n-    cacheKey\n-  )\n+  const varyPathForRequest = getSegmentVaryPathForRequest(fetchStrategy, tree)\n   const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt)\n   const isRevalidation = true\n-  setInCacheMap(segmentCacheMap, genericKeypath, pendingEntry, isRevalidation)\n+  setInCacheMap(\n+    segmentCacheMap,\n+    varyPathForRequest,\n+    pendingEntry,\n+    isRevalidation\n+  )\n   return pendingEntry\n }\n \n export function overwriteRevalidatingSegmentCacheEntry(\n   fetchStrategy: FetchStrategy,\n   route: FulfilledRouteCacheEntry,\n-  cacheKey: SegmentCacheKey\n+  tree: RouteTree\n ) {\n   // This function is called when we've already decided to replace an existing\n   // revalidation entry. Create a new entry and write it into the cache,\n   // overwriting the previous value.\n-  const genericKeypath = getGenericSegmentKeypathFromFetchStrategy(\n-    fetchStrategy,\n-    route,\n-    cacheKey\n-  )\n+  const varyPathForRequest = getSegmentVaryPathForRequest(fetchStrategy, tree)\n   const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt)\n   const isRevalidation = true\n-  setInCacheMap(segmentCacheMap, genericKeypath, pendingEntry, isRevalidation)\n+  setInCacheMap(\n+    segmentCacheMap,\n+    varyPathForRequest,\n+    pendingEntry,\n+    isRevalidation\n+  )\n   return pendingEntry\n }\n \n export function upsertSegmentEntry(\n   now: number,\n-  keypath: SegmentCacheKeypath,\n+  varyPath: SegmentVaryPath,\n   candidateEntry: SegmentCacheEntry\n ): SegmentCacheEntry | null {\n   // We have a new entry that has not yet been inserted into the cache. Before\n@@ -767,7 +780,7 @@ export function upsertSegmentEntry(\n     return null\n   }\n \n-  const existingEntry = readSegmentCacheEntry(now, keypath)\n+  const existingEntry = readSegmentCacheEntry(now, varyPath)\n   if (existingEntry !== null) {\n     // Don't replace a more specific segment with a less-specific one. A case where this\n     // might happen is if the existing segment was fetched via\n@@ -801,7 +814,7 @@ export function upsertSegmentEntry(\n   }\n \n   const isRevalidation = false\n-  setInCacheMap(segmentCacheMap, keypath, candidateEntry, isRevalidation)\n+  setInCacheMap(segmentCacheMap, varyPath, candidateEntry, isRevalidation)\n   return candidateEntry\n }\n \n@@ -858,10 +871,10 @@ function pingBlockedTasks(entry: {\n function fulfillRouteCacheEntry(\n   entry: RouteCacheEntry,\n   tree: RouteTree,\n+  metadataVaryPath: PageVaryPath,\n   staleAt: number,\n   couldBeIntercepted: boolean,\n   canonicalUrl: string,\n-  renderedPathname: NormalizedPathname,\n   renderedSearch: NormalizedSearch,\n   isPPREnabled: boolean\n ): FulfilledRouteCacheEntry {\n@@ -870,10 +883,13 @@ function fulfillRouteCacheEntry(\n   // object, so rather than fork the logic in all those places, we use this\n   // \"fake\" one.\n   const metadata: RouteTree = {\n-    cacheKey: createHeadCacheKey(renderedPathname),\n     requestKey: HEAD_REQUEST_KEY,\n     segment: HEAD_REQUEST_KEY,\n-    param: null,\n+    varyPath: metadataVaryPath,\n+    // The metadata isn't really a \"page\" (though it isn't really a \"segment\"\n+    // either) but for the purposes of how this field is used, it behaves like\n+    // one. If this logic ever gets more complex we can change this to an enum.\n+    isPage: true,\n     slots: null,\n     isRootLayout: false,\n     hasLoadingBoundary: HasLoadingBoundary.SubtreeHasNoLoadingBoundary,\n@@ -939,33 +955,41 @@ function rejectSegmentCacheEntry(\n   }\n }\n \n+type RouteTreeAccumulator = {\n+  metadataVaryPath: PageVaryPath | null\n+}\n+\n function convertRootTreePrefetchToRouteTree(\n   rootTree: RootTreePrefetch,\n-  renderedPathname: string\n+  renderedPathname: string,\n+  renderedSearch: NormalizedSearch,\n+  acc: RouteTreeAccumulator\n ) {\n   // Remove trailing and leading slashes\n   const pathnameParts = renderedPathname.split('/').filter((p) => p !== '')\n   const index = 0\n-  const rootSegment = ROOT_SEGMENT_CACHE_KEY\n+  const rootSegment = ROOT_SEGMENT_REQUEST_KEY\n   return convertTreePrefetchToRouteTree(\n     rootTree.tree,\n     rootSegment,\n     null,\n     ROOT_SEGMENT_REQUEST_KEY,\n-    ROOT_SEGMENT_CACHE_KEY,\n     pathnameParts,\n-    index\n+    index,\n+    renderedSearch,\n+    acc\n   )\n }\n \n function convertTreePrefetchToRouteTree(\n   prefetch: TreePrefetch,\n   segment: FlightRouterStateSegment,\n-  param: RouteParam | null,\n+  partialVaryPath: PartialSegmentVaryPath | null,\n   requestKey: SegmentRequestKey,\n-  cacheKey: SegmentCacheKey,\n   pathnameParts: Array<string>,\n-  pathnamePartsIndex: number\n+  pathnamePartsIndex: number,\n+  renderedSearch: NormalizedSearch,\n+  acc: RouteTreeAccumulator\n ): RouteTree {\n   // Converts the route tree sent by the server into the format used by the\n   // cache. The cached version of the tree includes additional fields, such as a\n@@ -974,8 +998,13 @@ function convertTreePrefetchToRouteTree(\n   // request the segment from the server.\n \n   let slots: { [parallelRouteKey: string]: RouteTree } | null = null\n+  let isPage: boolean\n+  let varyPath: SegmentVaryPath\n   const prefetchSlots = prefetch.slots\n   if (prefetchSlots !== null) {\n+    isPage = false\n+    varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n+\n     slots = {}\n     for (let parallelRouteKey in prefetchSlots) {\n       const childPrefetch = prefetchSlots[parallelRouteKey]\n@@ -984,8 +1013,8 @@ function convertTreePrefetchToRouteTree(\n       const childServerSentParamKey = childPrefetch.paramKey\n \n       let childDoesAppearInURL: boolean\n-      let childParam: RouteParam | null = null\n       let childSegment: FlightRouterStateSegment\n+      let childPartialVaryPath: PartialSegmentVaryPath | null\n       if (childParamType !== null) {\n         // This segment is parameterized. Get the param from the pathname.\n         const childParamValue = parseDynamicParamFromURLPart(\n@@ -1004,23 +1033,27 @@ function convertTreePrefetchToRouteTree(\n         // This would clearer if we waited to construct the segment until it's\n         // read from the cache, since that's effectively what we're\n         // doing anyway.\n-        const renderedSearch = '' as NormalizedSearch\n         const childParamKey =\n           // The server omits this field from the prefetch response when\n           // cacheComponents is enabled.\n           childServerSentParamKey !== null\n             ? childServerSentParamKey\n             : // If no param key was sent, use the value parsed on the client.\n-              getCacheKeyForDynamicParam(childParamValue, renderedSearch)\n-\n-        childParam = {\n-          name: childParamName,\n-          value: childParamValue,\n-          type: childParamType,\n-        }\n+              getCacheKeyForDynamicParam(\n+                childParamValue,\n+                '' as NormalizedSearch\n+              )\n+\n+        childPartialVaryPath = appendLayoutVaryPath(\n+          partialVaryPath,\n+          childParamKey\n+        )\n         childSegment = [childParamName, childParamKey, childParamType]\n         childDoesAppearInURL = true\n       } else {\n+        // This segment does not have a param. Inherit the partial vary path of\n+        // the parent.\n+        childPartialVaryPath = partialVaryPath\n         childSegment = childParamName\n         childDoesAppearInURL = doesStaticSegmentAppearInURL(childParamName)\n       }\n@@ -1037,28 +1070,57 @@ function convertTreePrefetchToRouteTree(\n         parallelRouteKey,\n         childRequestKeyPart\n       )\n-      const childCacheKey = appendSegmentCacheKeyPart(\n-        cacheKey,\n-        parallelRouteKey,\n-        createSegmentCacheKeyPart(childRequestKeyPart, childSegment)\n-      )\n       slots[parallelRouteKey] = convertTreePrefetchToRouteTree(\n         childPrefetch,\n         childSegment,\n-        childParam,\n+        childPartialVaryPath,\n         childRequestKey,\n-        childCacheKey,\n         pathnameParts,\n-        childPathnamePartsIndex\n+        childPathnamePartsIndex,\n+        renderedSearch,\n+        acc\n       )\n     }\n+  } else {\n+    if (requestKey.endsWith(PAGE_SEGMENT_KEY)) {\n+      // This is a page segment.\n+      isPage = true\n+      varyPath = finalizePageVaryPath(\n+        requestKey,\n+        renderedSearch,\n+        partialVaryPath\n+      )\n+      // The metadata \"segment\" is not part the route tree, but it has the same\n+      // conceptual params as a page segment. Write the vary path into the\n+      // accumulator object. If there are multiple parallel pages, we use the\n+      // first one. Which page we choose is arbitrary as long as it's\n+      // consistently the same one every time every time. See\n+      // finalizeMetadataVaryPath for more details.\n+      if (acc.metadataVaryPath === null) {\n+        acc.metadataVaryPath = finalizeMetadataVaryPath(\n+          requestKey,\n+          renderedSearch,\n+          partialVaryPath\n+        )\n+      }\n+    } else {\n+      // This is a layout segment.\n+      isPage = false\n+      varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n+    }\n   }\n \n   return {\n-    cacheKey,\n     requestKey,\n     segment,\n-    param,\n+    varyPath,\n+    // TODO: Cheating the type system here a bit because TypeScript can't tell\n+    // that the type of isPage and varyPath are consistent. The fix would be to\n+    // create separate constructors and call the appropriate one from each of\n+    // the branches above. Just seems a bit overkill only for one field so I'll\n+    // leave it as-is for now. If isPage were wrong it would break the behavior\n+    // and we'd catch it quickly, anyway.\n+    isPage: isPage as boolean as any,\n     slots,\n     isRootLayout: prefetch.isRootLayout,\n     // This field is only relevant to dynamic routes. For a PPR/static route,\n@@ -1069,20 +1131,82 @@ function convertTreePrefetchToRouteTree(\n }\n \n function convertRootFlightRouterStateToRouteTree(\n-  flightRouterState: FlightRouterState\n+  flightRouterState: FlightRouterState,\n+  renderedSearch: NormalizedSearch,\n+  acc: RouteTreeAccumulator\n ): RouteTree {\n   return convertFlightRouterStateToRouteTree(\n     flightRouterState,\n-    ROOT_SEGMENT_CACHE_KEY,\n-    ROOT_SEGMENT_REQUEST_KEY\n+    ROOT_SEGMENT_REQUEST_KEY,\n+    null,\n+    renderedSearch,\n+    acc\n   )\n }\n \n function convertFlightRouterStateToRouteTree(\n   flightRouterState: FlightRouterState,\n-  cacheKey: SegmentCacheKey,\n-  requestKey: SegmentRequestKey\n+  requestKey: SegmentRequestKey,\n+  parentPartialVaryPath: PartialSegmentVaryPath | null,\n+  renderedSearch: NormalizedSearch,\n+  acc: RouteTreeAccumulator\n ): RouteTree {\n+  const originalSegment = flightRouterState[0]\n+\n+  let segment: FlightRouterStateSegment\n+  let partialVaryPath: PartialSegmentVaryPath | null\n+  let isPage: boolean\n+  let varyPath: SegmentVaryPath\n+  if (Array.isArray(originalSegment)) {\n+    isPage = false\n+    const paramCacheKey = originalSegment[1]\n+    partialVaryPath = appendLayoutVaryPath(parentPartialVaryPath, paramCacheKey)\n+    varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n+    segment = originalSegment\n+  } else {\n+    // This segment does not have a param. Inherit the partial vary path of\n+    // the parent.\n+    partialVaryPath = parentPartialVaryPath\n+    if (requestKey.endsWith(PAGE_SEGMENT_KEY)) {\n+      // This is a page segment.\n+      isPage = true\n+\n+      // The navigation implementation expects the search params to be included\n+      // in the segment. However, in the case of a static response, the search\n+      // params are omitted. So the client needs to add them back in when reading\n+      // from the Segment Cache.\n+      //\n+      // For consistency, we'll do this for dynamic responses, too.\n+      //\n+      // TODO: We should move search params out of FlightRouterState and handle\n+      // them entirely on the client, similar to our plan for dynamic params.\n+      segment = PAGE_SEGMENT_KEY\n+      varyPath = finalizePageVaryPath(\n+        requestKey,\n+        renderedSearch,\n+        partialVaryPath\n+      )\n+      // The metadata \"segment\" is not part the route tree, but it has the same\n+      // conceptual params as a page segment. Write the vary path into the\n+      // accumulator object. If there are multiple parallel pages, we use the\n+      // first one. Which page we choose is arbitrary as long as it's\n+      // consistently the same one every time every time. See\n+      // finalizeMetadataVaryPath for more details.\n+      if (acc.metadataVaryPath === null) {\n+        acc.metadataVaryPath = finalizeMetadataVaryPath(\n+          requestKey,\n+          renderedSearch,\n+          partialVaryPath\n+        )\n+      }\n+    } else {\n+      // This is a layout segment.\n+      isPage = false\n+      segment = originalSegment\n+      varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n+    }\n+  }\n+\n   let slots: { [parallelRouteKey: string]: RouteTree } | null = null\n \n   const parallelRoutes = flightRouterState[1]\n@@ -1098,15 +1222,12 @@ function convertFlightRouterStateToRouteTree(\n       parallelRouteKey,\n       childRequestKeyPart\n     )\n-    const childCacheKey = appendSegmentCacheKeyPart(\n-      cacheKey,\n-      parallelRouteKey,\n-      createSegmentCacheKeyPart(childRequestKeyPart, childSegment)\n-    )\n     const childTree = convertFlightRouterStateToRouteTree(\n       childRouterState,\n-      childCacheKey,\n-      childRequestKey\n+      childRequestKey,\n+      partialVaryPath,\n+      renderedSearch,\n+      acc\n     )\n     if (slots === null) {\n       slots = {\n@@ -1116,42 +1237,18 @@ function convertFlightRouterStateToRouteTree(\n       slots[parallelRouteKey] = childTree\n     }\n   }\n-  const originalSegment = flightRouterState[0]\n-\n-  let segment: FlightRouterStateSegment\n-  let param: RouteParam | null = null\n-  if (Array.isArray(originalSegment)) {\n-    const paramCacheKey = originalSegment[1]\n-    const paramType = originalSegment[2]\n-    const paramValue = getParamValueFromCacheKey(paramCacheKey, paramType)\n-    param = {\n-      name: originalSegment[0],\n-      value: paramValue === undefined ? null : paramValue,\n-      type: originalSegment[2] as DynamicParamTypesShort,\n-    }\n-    segment = originalSegment\n-  } else {\n-    // The navigation implementation expects the search params to be included\n-    // in the segment. However, in the case of a static response, the search\n-    // params are omitted. So the client needs to add them back in when reading\n-    // from the Segment Cache.\n-    //\n-    // For consistency, we'll do this for dynamic responses, too.\n-    //\n-    // TODO: We should move search params out of FlightRouterState and handle\n-    // them entirely on the client, similar to our plan for dynamic params.\n-    segment =\n-      typeof originalSegment === 'string' &&\n-      originalSegment.startsWith(PAGE_SEGMENT_KEY)\n-        ? PAGE_SEGMENT_KEY\n-        : originalSegment\n-  }\n \n   return {\n-    cacheKey,\n     requestKey,\n     segment,\n-    param,\n+    varyPath,\n+    // TODO: Cheating the type system here a bit because TypeScript can't tell\n+    // that the type of isPage and varyPath are consistent. The fix would be to\n+    // create separate constructors and call the appropriate one from each of\n+    // the branches above. Just seems a bit overkill only for one field so I'll\n+    // leave it as-is for now. If isPage were wrong it would break the behavior\n+    // and we'd catch it quickly, anyway.\n+    isPage: isPage as boolean as any,\n     slots,\n     isRootLayout: flightRouterState[4] === true,\n     hasLoadingBoundary:\n@@ -1347,19 +1444,32 @@ export async function fetchRouteOnCacheMiss(\n       const renderedPathname = getRenderedPathname(response)\n       const renderedSearch = getRenderedSearch(response)\n \n+      // Convert the server-sent data into the RouteTree format used by the\n+      // client cache.\n+      //\n+      // During this traversal, we accumulate additional data into this\n+      // \"accumulator\" object.\n+      const acc: RouteTreeAccumulator = { metadataVaryPath: null }\n       const routeTree = convertRootTreePrefetchToRouteTree(\n         serverData,\n-        renderedPathname\n+        renderedPathname,\n+        renderedSearch,\n+        acc\n       )\n+      const metadataVaryPath = acc.metadataVaryPath\n+      if (metadataVaryPath === null) {\n+        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n+        return null\n+      }\n \n       const staleTimeMs = getStaleTimeMs(serverData.staleTime)\n       fulfillRouteCacheEntry(\n         entry,\n         routeTree,\n+        metadataVaryPath,\n         Date.now() + staleTimeMs,\n         couldBeIntercepted,\n         canonicalUrl,\n-        renderedPathname,\n         renderedSearch,\n         routeIsPPREnabled\n       )\n@@ -1419,9 +1529,14 @@ export async function fetchRouteOnCacheMiss(\n       // TODO: Treat this as an upsert — should check if an entry already\n       // exists at the new keypath, and if so, whether we should keep that\n       // one instead.\n-      const newKeypath: RouteCacheKeypath = [pathname, search, Fallback]\n+      const fulfilledVaryPath: RouteVaryPath = getFulfilledRouteVaryPath(\n+        pathname,\n+        search,\n+        nextUrl,\n+        couldBeIntercepted\n+      )\n       const isRevalidation = false\n-      setInCacheMap(routeCacheMap, newKeypath, entry, isRevalidation)\n+      setInCacheMap(routeCacheMap, fulfilledVaryPath, entry, isRevalidation)\n     }\n     // Return a promise that resolves when the network connection closes, so\n     // the scheduler can track the number of concurrent network connections.\n@@ -1559,15 +1674,15 @@ export async function fetchSegmentPrefetchesUsingDynamicRequest(\n     | FetchStrategy.PPRRuntime\n     | FetchStrategy.Full,\n   dynamicRequestTree: FlightRouterState,\n-  spawnedEntries: Map<SegmentCacheKey, PendingSegmentCacheEntry>\n+  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>\n ): Promise<PrefetchSubtaskResult<null> | null> {\n   const key = task.key\n   const url = new URL(route.canonicalUrl, location.origin)\n   const nextUrl = key.nextUrl\n \n   if (\n     spawnedEntries.size === 1 &&\n-    spawnedEntries.has(route.metadata.cacheKey)\n+    spawnedEntries.has(route.metadata.requestKey)\n   ) {\n     // The only thing pending is the head. Instruct the server to\n     // skip over everything else.\n@@ -1698,7 +1813,6 @@ function writeDynamicTreeResponseIntoCache(\n ) {\n   // Get the URL that was used to render the target page. This may be different\n   // from the URL in the request URL, if the page was rewritten.\n-  const renderedPathname = getRenderedPathname(response)\n   const renderedSearch = getRenderedSearch(response)\n \n   const normalizedFlightDataResult = normalizeFlightData(serverData.f)\n@@ -1736,13 +1850,30 @@ function writeDynamicTreeResponseIntoCache(\n   const isResponsePartial =\n     response.headers.get(NEXT_DID_POSTPONE_HEADER) === '1'\n \n+  // Convert the server-sent data into the RouteTree format used by the\n+  // client cache.\n+  //\n+  // During this traversal, we accumulate additional data into this\n+  // \"accumulator\" object.\n+  const acc: RouteTreeAccumulator = { metadataVaryPath: null }\n+  const routeTree = convertRootFlightRouterStateToRouteTree(\n+    flightRouterState,\n+    renderedSearch,\n+    acc\n+  )\n+  const metadataVaryPath = acc.metadataVaryPath\n+  if (metadataVaryPath === null) {\n+    rejectRouteCacheEntry(entry, now + 10 * 1000)\n+    return\n+  }\n+\n   const fulfilledEntry = fulfillRouteCacheEntry(\n     entry,\n-    convertRootFlightRouterStateToRouteTree(flightRouterState),\n+    routeTree,\n+    metadataVaryPath,\n     now + staleTimeMs,\n     couldBeIntercepted,\n     canonicalUrl,\n-    renderedPathname,\n     renderedSearch,\n     routeIsPPREnabled\n   )\n@@ -1769,7 +1900,7 @@ function writeDynamicTreeResponseIntoCache(\n }\n \n function rejectSegmentEntriesIfStillPending(\n-  entries: Map<SegmentCacheKey, SegmentCacheEntry>,\n+  entries: Map<SegmentRequestKey, SegmentCacheEntry>,\n   staleAt: number\n ): Array<FulfilledSegmentCacheEntry> {\n   const fulfilledEntries = []\n@@ -1794,7 +1925,7 @@ function writeDynamicRenderResponseIntoCache(\n   serverData: NavigationFlightResponse,\n   isResponsePartial: boolean,\n   route: FulfilledRouteCacheEntry,\n-  spawnedEntries: Map<SegmentCacheKey, PendingSegmentCacheEntry> | null\n+  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry> | null\n ): Array<FulfilledSegmentCacheEntry> | null {\n   if (serverData.b !== getAppBuildId()) {\n     // The server build does not match the client. Treat as a 404. During\n@@ -1837,35 +1968,28 @@ function writeDynamicRenderResponseIntoCache(\n       //\n       //   [string, Segment, string, Segment, string, Segment, ...]\n       const segmentPath = flightData.segmentPath\n-      let requestKey = ROOT_SEGMENT_REQUEST_KEY\n-      let cacheKey = ROOT_SEGMENT_CACHE_KEY\n+      let tree = route.tree\n       for (let i = 0; i < segmentPath.length; i += 2) {\n         const parallelRouteKey: string = segmentPath[i]\n-        const segment: FlightRouterStateSegment = segmentPath[i + 1]\n-        const requestKeyPart = createSegmentRequestKeyPart(segment)\n-        requestKey = appendSegmentRequestKeyPart(\n-          requestKey,\n-          parallelRouteKey,\n-          requestKeyPart\n-        )\n-        cacheKey = appendSegmentCacheKeyPart(\n-          cacheKey,\n-          parallelRouteKey,\n-          createSegmentCacheKeyPart(requestKeyPart, segment)\n-        )\n+        if (tree?.slots?.[parallelRouteKey] !== undefined) {\n+          tree = tree.slots[parallelRouteKey]\n+        } else {\n+          if (spawnedEntries !== null) {\n+            rejectSegmentEntriesIfStillPending(spawnedEntries, now + 10 * 1000)\n+          }\n+          return null\n+        }\n       }\n \n       writeSeedDataIntoCache(\n         now,\n         task,\n         fetchStrategy,\n         route,\n+        tree,\n         staleAt,\n-        flightData.tree,\n         seedData,\n         isResponsePartial,\n-        cacheKey,\n-        requestKey,\n         spawnedEntries\n       )\n     }\n@@ -1880,7 +2004,7 @@ function writeDynamicRenderResponseIntoCache(\n         null,\n         flightData.isHeadPartial,\n         staleAt,\n-        route.metadata.cacheKey,\n+        route.metadata,\n         spawnedEntries\n       )\n     }\n@@ -1911,14 +2035,12 @@ function writeSeedDataIntoCache(\n     | FetchStrategy.PPRRuntime\n     | FetchStrategy.Full,\n   route: FulfilledRouteCacheEntry,\n+  tree: RouteTree,\n   staleAt: number,\n-  flightRouterState: FlightRouterState,\n   seedData: CacheNodeSeedData,\n   isResponsePartial: boolean,\n-  cacheKey: SegmentCacheKey,\n-  requestKey: SegmentRequestKey,\n   entriesOwnedByCurrentTask: Map<\n-    SegmentCacheKey,\n+    SegmentRequestKey,\n     PendingSegmentCacheEntry\n   > | null\n ) {\n@@ -1935,43 +2057,31 @@ function writeSeedDataIntoCache(\n     loading,\n     isPartial,\n     staleAt,\n-    cacheKey,\n+    tree,\n     entriesOwnedByCurrentTask\n   )\n \n   // Recursively write the child data into the cache.\n-  const flightRouterStateChildren = flightRouterState[1]\n-  const seedDataChildren = seedData[1]\n-  for (const parallelRouteKey in flightRouterStateChildren) {\n-    const childFlightRouterState = flightRouterStateChildren[parallelRouteKey]\n-    const childSeedData: CacheNodeSeedData | null | void =\n-      seedDataChildren[parallelRouteKey]\n-    if (childSeedData !== null && childSeedData !== undefined) {\n-      const childSegment = childFlightRouterState[0]\n-      const childRequestKeyPart = createSegmentRequestKeyPart(childSegment)\n-      const childRequestKey = appendSegmentRequestKeyPart(\n-        requestKey,\n-        parallelRouteKey,\n-        childRequestKeyPart\n-      )\n-      const childCacheKey = appendSegmentCacheKeyPart(\n-        cacheKey,\n-        parallelRouteKey,\n-        createSegmentCacheKeyPart(childRequestKeyPart, childSegment)\n-      )\n-      writeSeedDataIntoCache(\n-        now,\n-        task,\n-        fetchStrategy,\n-        route,\n-        staleAt,\n-        childFlightRouterState,\n-        childSeedData,\n-        isResponsePartial,\n-        childCacheKey,\n-        childRequestKey,\n-        entriesOwnedByCurrentTask\n-      )\n+  const slots = tree.slots\n+  if (slots !== null) {\n+    const seedDataChildren = seedData[1]\n+    for (const parallelRouteKey in slots) {\n+      const childTree = slots[parallelRouteKey]\n+      const childSeedData: CacheNodeSeedData | null | void =\n+        seedDataChildren[parallelRouteKey]\n+      if (childSeedData !== null && childSeedData !== undefined) {\n+        writeSeedDataIntoCache(\n+          now,\n+          task,\n+          fetchStrategy,\n+          route,\n+          childTree,\n+          staleAt,\n+          childSeedData,\n+          isResponsePartial,\n+          entriesOwnedByCurrentTask\n+        )\n+      }\n     }\n   }\n }\n@@ -1987,9 +2097,9 @@ function fulfillEntrySpawnedByRuntimePrefetch(\n   loading: LoadingModuleData | Promise<LoadingModuleData>,\n   isPartial: boolean,\n   staleAt: number,\n-  cacheKey: SegmentCacheKey,\n+  tree: RouteTree,\n   entriesOwnedByCurrentTask: Map<\n-    SegmentCacheKey,\n+    SegmentRequestKey,\n     PendingSegmentCacheEntry\n   > | null\n ) {\n@@ -1998,7 +2108,7 @@ function fulfillEntrySpawnedByRuntimePrefetch(\n   // created by a different task, because that causes data races.\n   const ownedEntry =\n     entriesOwnedByCurrentTask !== null\n-      ? entriesOwnedByCurrentTask.get(cacheKey)\n+      ? entriesOwnedByCurrentTask.get(tree.requestKey)\n       : undefined\n   if (ownedEntry !== undefined) {\n     fulfillSegmentCacheEntry(ownedEntry, rsc, loading, staleAt, isPartial)\n@@ -2008,7 +2118,7 @@ function fulfillEntrySpawnedByRuntimePrefetch(\n       now,\n       fetchStrategy,\n       route,\n-      cacheKey\n+      tree\n     )\n     if (possiblyNewEntry.status === EntryStatus.Empty) {\n       // Confirmed this is a new entry. We can fulfill it.\n@@ -2035,11 +2145,7 @@ function fulfillEntrySpawnedByRuntimePrefetch(\n       )\n       upsertSegmentEntry(\n         now,\n-        getGenericSegmentKeypathFromFetchStrategy(\n-          fetchStrategy,\n-          route,\n-          cacheKey\n-        ),\n+        getSegmentVaryPathForRequest(fetchStrategy, tree),\n         newEntry\n       )\n     }"
        },
        {
            "sha": "a8a278d080a70d30ad699c965545badbab1850c4",
            "filename": "packages/next/src/client/components/segment-cache/lru.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/20c76e7155d9205e01543f40713d0b22c856b3f9/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Flru.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/20c76e7155d9205e01543f40713d0b22c856b3f9/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Flru.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Flru.ts?ref=20c76e7155d9205e01543f40713d0b22c856b3f9",
            "patch": "@@ -7,7 +7,7 @@ import { deleteFromCacheMap } from './cache-map'\n // The MapEntry type is used as an LRU node, too. We choose this one instead of\n // the inner cache entry type (RouteCacheEntry, SegmentCacheEntry) because it's\n // monomorphic and can be optimized by the VM.\n-type LRUNode = MapEntry<any, any>\n+type LRUNode = MapEntry<any>\n \n let head: LRUNode | null = null\n let didScheduleCleanup: boolean = false"
        },
        {
            "sha": "aedd120a8f40a7870508d3486f4e3b614fef9d60",
            "filename": "packages/next/src/client/components/segment-cache/navigation.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 11,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/20c76e7155d9205e01543f40713d0b22c856b3f9/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fnavigation.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/20c76e7155d9205e01543f40713d0b22c856b3f9/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fnavigation.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fnavigation.ts?ref=20c76e7155d9205e01543f40713d0b22c856b3f9",
            "patch": "@@ -19,7 +19,6 @@ import { createHrefFromUrl } from '../router-reducer/create-href-from-url'\n import {\n   EntryStatus,\n   readRouteCacheEntry,\n-  getCanonicalSegmentKeypath,\n   readSegmentCacheEntry,\n   waitForSegmentCacheEntry,\n   requestOptimisticRouteCacheEntry,\n@@ -347,11 +346,7 @@ function readRenderSnapshotFromCache(\n   let loading: LoadingModuleData | Promise<LoadingModuleData> = null\n   let isPartial: boolean = true\n \n-  const canonicalSegmentKeypath = getCanonicalSegmentKeypath(\n-    route,\n-    tree.cacheKey\n-  )\n-  const segmentEntry = readSegmentCacheEntry(now, canonicalSegmentKeypath)\n+  const segmentEntry = readSegmentCacheEntry(now, tree.varyPath)\n   if (segmentEntry !== null) {\n     switch (segmentEntry.status) {\n       case EntryStatus.Fulfilled: {\n@@ -423,11 +418,7 @@ function readHeadSnapshotFromCache(\n   // Same as readRenderSnapshotFromCache, but for the head\n   let rsc: React.ReactNode | null = null\n   let isPartial: boolean = true\n-  const canonicalSegmentKeypath = getCanonicalSegmentKeypath(\n-    route,\n-    route.metadata.cacheKey\n-  )\n-  const segmentEntry = readSegmentCacheEntry(now, canonicalSegmentKeypath)\n+  const segmentEntry = readSegmentCacheEntry(now, route.metadata.varyPath)\n   if (segmentEntry !== null) {\n     switch (segmentEntry.status) {\n       case EntryStatus.Fulfilled: {"
        },
        {
            "sha": "c2fa13a9d664b852a30c2b9bc18ef4945296884c",
            "filename": "packages/next/src/client/components/segment-cache/scheduler.ts",
            "status": "modified",
            "additions": 29,
            "deletions": 42,
            "changes": 71,
            "blob_url": "https://github.com/vercel/next.js/blob/20c76e7155d9205e01543f40713d0b22c856b3f9/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fscheduler.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/20c76e7155d9205e01543f40713d0b22c856b3f9/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fscheduler.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fscheduler.ts?ref=20c76e7155d9205e01543f40713d0b22c856b3f9",
            "patch": "@@ -24,10 +24,9 @@ import {\n   upgradeToPendingSegment,\n   waitForSegmentCacheEntry,\n   overwriteRevalidatingSegmentCacheEntry,\n-  getGenericSegmentKeypathFromFetchStrategy,\n   canNewFetchStrategyProvideMoreContent,\n-  type SegmentCacheKeypath,\n } from './cache'\n+import { getSegmentVaryPathForRequest, type SegmentVaryPath } from './vary-path'\n import type { RouteCacheKey } from './cache-key'\n import { createCacheKey } from './cache-key'\n import {\n@@ -40,7 +39,7 @@ import {\n   addSearchParamsIfPageSegment,\n   PAGE_SEGMENT_KEY,\n } from '../../../shared/lib/segment'\n-import type { SegmentCacheKey } from '../../../shared/lib/segment-cache/segment-value-encoding'\n+import type { SegmentRequestKey } from '../../../shared/lib/segment-cache/segment-value-encoding'\n \n const scheduleMicrotask =\n   typeof queueMicrotask === 'function'\n@@ -122,7 +121,7 @@ export type PrefetchTask = {\n    * They are reset after each iteration of the task queue.\n    */\n   hasBackgroundWork: boolean\n-  spawnedRuntimePrefetches: Set<SegmentCacheKey> | null\n+  spawnedRuntimePrefetches: Set<SegmentRequestKey> | null\n \n   /**\n    * True if the prefetch was cancelled.\n@@ -691,7 +690,7 @@ function pingRootRouteTree(\n             // During the first pass, we discovered segments that require a\n             // runtime prefetch. Do a second pass to construct a request tree.\n             const spawnedEntries = new Map<\n-              SegmentCacheKey,\n+              SegmentRequestKey,\n               PendingSegmentCacheEntry\n             >()\n             pingRuntimeHead(\n@@ -737,7 +736,7 @@ function pingRootRouteTree(\n           // really that much duplication, just would be nice to remove one of\n           // these codepaths.\n           const spawnedEntries = new Map<\n-            SegmentCacheKey,\n+            SegmentRequestKey,\n             PendingSegmentCacheEntry\n           >()\n           pingRuntimeHead(now, task, route, spawnedEntries, fetchStrategy)\n@@ -792,7 +791,7 @@ function pingStaticHead(\n       now,\n       FetchStrategy.PPR,\n       route,\n-      route.metadata.cacheKey\n+      route.metadata\n     ),\n     task.key,\n     route.metadata\n@@ -803,7 +802,7 @@ function pingRuntimeHead(\n   now: number,\n   task: PrefetchTask,\n   route: FulfilledRouteCacheEntry,\n-  spawnedEntries: Map<string, PendingSegmentCacheEntry>,\n+  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>,\n   fetchStrategy:\n     | FetchStrategy.Full\n     | FetchStrategy.PPRRuntime\n@@ -849,7 +848,7 @@ function pingSharedPartOfCacheComponentsTree(\n     now,\n     task.fetchStrategy,\n     route,\n-    newTree.cacheKey\n+    newTree\n   )\n   pingStaticSegmentData(now, task, route, segment, task.key, newTree)\n \n@@ -937,9 +936,9 @@ function pingNewPartOfCacheComponentsTree(\n     // This will signal to the outer task queue that a second traversal is\n     // required to construct a request tree.\n     if (task.spawnedRuntimePrefetches === null) {\n-      task.spawnedRuntimePrefetches = new Set([tree.cacheKey])\n+      task.spawnedRuntimePrefetches = new Set([tree.requestKey])\n     } else {\n-      task.spawnedRuntimePrefetches.add(tree.cacheKey)\n+      task.spawnedRuntimePrefetches.add(tree.requestKey)\n     }\n     // Then exit the traversal without prefetching anything further.\n     return PrefetchTaskExitStatus.Done\n@@ -950,7 +949,7 @@ function pingNewPartOfCacheComponentsTree(\n     now,\n     task.fetchStrategy,\n     route,\n-    tree.cacheKey\n+    tree\n   )\n   pingStaticSegmentData(now, task, route, segment, task.key, tree)\n   if (tree.slots !== null) {\n@@ -983,7 +982,7 @@ function diffRouteTreeAgainstCurrent(\n   route: FulfilledRouteCacheEntry,\n   oldTree: FlightRouterState,\n   newTree: RouteTree,\n-  spawnedEntries: Map<string, PendingSegmentCacheEntry>,\n+  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>,\n   fetchStrategy:\n     | FetchStrategy.Full\n     | FetchStrategy.PPRRuntime\n@@ -1130,7 +1129,7 @@ function pingPPRDisabledRouteTreeUpToLoadingBoundary(\n   route: FulfilledRouteCacheEntry,\n   tree: RouteTree,\n   refetchMarkerContext: 'refetch' | 'inside-shared-layout' | null,\n-  spawnedEntries: Map<string, PendingSegmentCacheEntry>\n+  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>\n ): FlightRouterState {\n   // This function is similar to pingRouteTreeAndIncludeDynamicData, except the\n   // server is only going to return a minimal loading state — it will stop\n@@ -1150,7 +1149,7 @@ function pingPPRDisabledRouteTreeUpToLoadingBoundary(\n     now,\n     task.fetchStrategy,\n     route,\n-    tree.cacheKey\n+    tree\n   )\n   switch (segment.status) {\n     case EntryStatus.Empty: {\n@@ -1164,7 +1163,7 @@ function pingPPRDisabledRouteTreeUpToLoadingBoundary(\n \n       // Add the pending cache entry to the result map.\n       spawnedEntries.set(\n-        tree.cacheKey,\n+        tree.requestKey,\n         upgradeToPendingSegment(\n           segment,\n           // Set the fetch strategy to LoadingBoundary to indicate that the server\n@@ -1243,7 +1242,7 @@ function pingRouteTreeAndIncludeDynamicData(\n   route: FulfilledRouteCacheEntry,\n   tree: RouteTree,\n   isInsideRefetchingParent: boolean,\n-  spawnedEntries: Map<string, PendingSegmentCacheEntry>,\n+  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>,\n   fetchStrategy: FetchStrategy.Full | FetchStrategy.PPRRuntime\n ): FlightRouterState {\n   // The tree we're constructing is the same shape as the tree we're navigating\n@@ -1263,7 +1262,7 @@ function pingRouteTreeAndIncludeDynamicData(\n     // entries that include search params.\n     fetchStrategy,\n     route,\n-    tree.cacheKey\n+    tree\n   )\n \n   let spawnedSegment: PendingSegmentCacheEntry | null = null\n@@ -1338,7 +1337,7 @@ function pingRouteTreeAndIncludeDynamicData(\n \n   if (spawnedSegment !== null) {\n     // Add the pending entry to the result map.\n-    spawnedEntries.set(tree.cacheKey, spawnedSegment)\n+    spawnedEntries.set(tree.requestKey, spawnedSegment)\n   }\n \n   // Don't bother to add a refetch marker if one is already present in a parent.\n@@ -1360,16 +1359,16 @@ function pingRuntimePrefetches(\n   task: PrefetchTask,\n   route: FulfilledRouteCacheEntry,\n   tree: RouteTree,\n-  spawnedRuntimePrefetches: Set<SegmentCacheKey>,\n-  spawnedEntries: Map<string, PendingSegmentCacheEntry>\n+  spawnedRuntimePrefetches: Set<SegmentRequestKey>,\n+  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>\n ): FlightRouterState {\n   // Construct a request tree (FlightRouterState) for a runtime prefetch. If\n   // a segment is part of the runtime prefetch, the tree is constructed by\n   // diffing against what's already in the prefetch cache. Otherwise, we send\n   // a regular FlightRouterState with no special markers.\n   //\n   // See pingRouteTreeAndIncludeDynamicData for details.\n-  if (spawnedRuntimePrefetches.has(tree.cacheKey)) {\n+  if (spawnedRuntimePrefetches.has(tree.requestKey)) {\n     // This segment needs a runtime prefetch.\n     return pingRouteTreeAndIncludeDynamicData(\n       now,\n@@ -1502,7 +1501,7 @@ function pingPPRSegmentRevalidation(\n     now,\n     FetchStrategy.PPR,\n     route,\n-    tree.cacheKey\n+    tree\n   )\n   switch (revalidatingSegment.status) {\n     case EntryStatus.Empty:\n@@ -1517,11 +1516,7 @@ function pingPPRSegmentRevalidation(\n             tree\n           )\n         ),\n-        getGenericSegmentKeypathFromFetchStrategy(\n-          FetchStrategy.PPR,\n-          route,\n-          tree.cacheKey\n-        )\n+        getSegmentVaryPathForRequest(FetchStrategy.PPR, tree)\n       )\n       break\n     case EntryStatus.Pending:\n@@ -1548,7 +1543,7 @@ function pingFullSegmentRevalidation(\n     now,\n     fetchStrategy,\n     route,\n-    tree.cacheKey\n+    tree\n   )\n   if (revalidatingSegment.status === EntryStatus.Empty) {\n     // During a Full/PPRRuntime prefetch, a single dynamic request is made for all the\n@@ -1562,11 +1557,7 @@ function pingFullSegmentRevalidation(\n     )\n     upsertSegmentOnCompletion(\n       waitForSegmentCacheEntry(pendingSegment),\n-      getGenericSegmentKeypathFromFetchStrategy(\n-        fetchStrategy,\n-        route,\n-        tree.cacheKey\n-      )\n+      getSegmentVaryPathForRequest(fetchStrategy, tree)\n     )\n     return pendingSegment\n   } else {\n@@ -1583,19 +1574,15 @@ function pingFullSegmentRevalidation(\n       const emptySegment = overwriteRevalidatingSegmentCacheEntry(\n         fetchStrategy,\n         route,\n-        tree.cacheKey\n+        tree\n       )\n       const pendingSegment = upgradeToPendingSegment(\n         emptySegment,\n         fetchStrategy\n       )\n       upsertSegmentOnCompletion(\n         waitForSegmentCacheEntry(pendingSegment),\n-        getGenericSegmentKeypathFromFetchStrategy(\n-          fetchStrategy,\n-          route,\n-          tree.cacheKey\n-        )\n+        getSegmentVaryPathForRequest(fetchStrategy, tree)\n       )\n       return pendingSegment\n     }\n@@ -1620,13 +1607,13 @@ const noop = () => {}\n \n function upsertSegmentOnCompletion(\n   promise: Promise<FulfilledSegmentCacheEntry | null>,\n-  keypath: SegmentCacheKeypath\n+  varyPath: SegmentVaryPath\n ) {\n   // Wait for a segment to finish loading, then upsert it into the cache\n   promise.then((fulfilled) => {\n     if (fulfilled !== null) {\n       // Received new data. Attempt to replace the existing entry in the cache.\n-      upsertSegmentEntry(Date.now(), keypath, fulfilled)\n+      upsertSegmentEntry(Date.now(), varyPath, fulfilled)\n     }\n   }, noop)\n }"
        },
        {
            "sha": "b54a5f04989c71a26dce678c2d3ebbe40be925ce",
            "filename": "packages/next/src/client/components/segment-cache/vary-path.ts",
            "status": "added",
            "additions": 279,
            "deletions": 0,
            "changes": 279,
            "blob_url": "https://github.com/vercel/next.js/blob/20c76e7155d9205e01543f40713d0b22c856b3f9/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fvary-path.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/20c76e7155d9205e01543f40713d0b22c856b3f9/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fvary-path.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fvary-path.ts?ref=20c76e7155d9205e01543f40713d0b22c856b3f9",
            "patch": "@@ -0,0 +1,279 @@\n+import { FetchStrategy } from './types'\n+import type {\n+  NormalizedPathname,\n+  NormalizedSearch,\n+  NormalizedNextUrl,\n+} from './cache-key'\n+import type { RouteTree } from './cache'\n+import { Fallback, type FallbackType } from './cache-map'\n+import { HEAD_REQUEST_KEY } from '../../../shared/lib/segment-cache/segment-value-encoding'\n+\n+type Opaque<T, K> = T & { __brand: K }\n+\n+/**\n+ * A linked-list of all the params (or other param-like) inputs that a cache\n+ * entry may vary by. This is used by the CacheMap module to reuse cache entries\n+ * across different param values. If a param has a value of Fallback, it means\n+ * the cache entry is reusable for all possible values of that param. See\n+ * cache-map.ts for details.\n+ *\n+ * A segment's vary path is a pure function of a segment's position in a\n+ * particular route tree and the (post-rewrite) URL that is being queried. More\n+ * concretely, successive queries of the cache for the same segment always use\n+ * the same vary path.\n+ *\n+ * A route's vary path is simpler: it's comprised of the pathname, search\n+ * string, and Next-URL header.\n+ */\n+export type VaryPath = {\n+  value: string | null | FallbackType\n+  parent: VaryPath | null\n+}\n+\n+// Because it's so important for vary paths to line up across cache accesses,\n+// we use opaque type aliases to ensure these are only created within\n+// this module.\n+\n+// requestKey -> searchParams -> nextUrl\n+export type RouteVaryPath = Opaque<\n+  {\n+    value: NormalizedPathname\n+    parent: {\n+      value: NormalizedSearch\n+      parent: {\n+        value: NormalizedNextUrl | null | FallbackType\n+        parent: null\n+      }\n+    }\n+  },\n+  'RouteVaryPath'\n+>\n+\n+// requestKey -> pathParams\n+export type LayoutVaryPath = Opaque<\n+  {\n+    value: string\n+    parent: PartialSegmentVaryPath | null\n+  },\n+  'LayoutVaryPath'\n+>\n+\n+// requestKey -> searchParams -> pathParams\n+export type PageVaryPath = Opaque<\n+  {\n+    value: string\n+    parent: {\n+      value: NormalizedSearch | FallbackType\n+      parent: PartialSegmentVaryPath | null\n+    }\n+  },\n+  'PageVaryPath'\n+>\n+\n+export type SegmentVaryPath = LayoutVaryPath | PageVaryPath\n+\n+// Intermediate type used when building a vary path during a recursive traversal\n+// of the route tree.\n+export type PartialSegmentVaryPath = Opaque<VaryPath, 'PartialSegmentVaryPath'>\n+\n+export function getRouteVaryPath(\n+  pathname: NormalizedPathname,\n+  search: NormalizedSearch,\n+  nextUrl: NormalizedNextUrl | null\n+): RouteVaryPath {\n+  // requestKey -> searchParams -> nextUrl\n+  const varyPath: VaryPath = {\n+    value: pathname,\n+    parent: {\n+      value: search,\n+      parent: {\n+        value: nextUrl,\n+        parent: null,\n+      },\n+    },\n+  }\n+  return varyPath as RouteVaryPath\n+}\n+\n+export function getFulfilledRouteVaryPath(\n+  pathname: NormalizedPathname,\n+  search: NormalizedSearch,\n+  nextUrl: NormalizedNextUrl | null,\n+  couldBeIntercepted: boolean\n+): RouteVaryPath {\n+  // This is called when a route's data is fulfilled. The cache entry will be\n+  // re-keyed based on which inputs the response varies by.\n+  // requestKey -> searchParams -> nextUrl\n+  const varyPath: VaryPath = {\n+    value: pathname,\n+    parent: {\n+      value: search,\n+      parent: {\n+        value: couldBeIntercepted ? nextUrl : Fallback,\n+        parent: null,\n+      },\n+    },\n+  }\n+  return varyPath as RouteVaryPath\n+}\n+\n+export function appendLayoutVaryPath(\n+  parentPath: PartialSegmentVaryPath | null,\n+  cacheKey: string\n+): PartialSegmentVaryPath {\n+  const varyPathPart: VaryPath = {\n+    value: cacheKey,\n+    parent: parentPath,\n+  }\n+  return varyPathPart as PartialSegmentVaryPath\n+}\n+\n+export function finalizeLayoutVaryPath(\n+  requestKey: string,\n+  varyPath: PartialSegmentVaryPath | null\n+): LayoutVaryPath {\n+  const layoutVaryPath: VaryPath = {\n+    value: requestKey,\n+    parent: varyPath,\n+  }\n+  return layoutVaryPath as LayoutVaryPath\n+}\n+\n+export function finalizePageVaryPath(\n+  requestKey: string,\n+  renderedSearch: NormalizedSearch,\n+  varyPath: PartialSegmentVaryPath | null\n+): PageVaryPath {\n+  // Unlike layouts, a page segment's vary path also includes the search string.\n+  // requestKey -> searchParams -> pathParams\n+  const pageVaryPath: VaryPath = {\n+    value: requestKey,\n+    parent: {\n+      value: renderedSearch,\n+      parent: varyPath,\n+    },\n+  }\n+  return pageVaryPath as PageVaryPath\n+}\n+\n+export function finalizeMetadataVaryPath(\n+  pageRequestKey: string,\n+  renderedSearch: NormalizedSearch,\n+  varyPath: PartialSegmentVaryPath | null\n+): PageVaryPath {\n+  // The metadata \"segment\" is not a real segment because it doesn't exist in\n+  // the normal structure of the route tree, but in terms of caching, it\n+  // behaves like a page segment because it varies by all the same params as\n+  // a page.\n+  //\n+  // To keep the protocol for querying the server simple, the request key for\n+  // the metadata does not include any path information. It's unnecessary from\n+  // the server's perspective, because unlike page segments, there's only one\n+  // metadata response per URL, i.e. there's no need to distinguish multiple\n+  // parallel pages.\n+  //\n+  // However, this means the metadata request key is insufficient for\n+  // caching the the metadata in the client cache, because on the client we\n+  // use the request key to distinguish the metadata entry from all other\n+  // page's metadata entries.\n+  //\n+  // So instead we create a simulated request key based on the page segment.\n+  // Conceptually this is equivalent to the request key the server would have\n+  // assigned the metadata segment if it treated it as part of the actual\n+  // route structure.\n+\n+  // If there are multiple parallel pages, we use whichever is the first one.\n+  // This is fine because the only difference between request keys for\n+  // different parallel pages are things like route groups and parallel\n+  // route slots. As long as it's always the same one, it doesn't matter.\n+  const pageVaryPath: VaryPath = {\n+    // Append the actual metadata request key to the page request key. Note\n+    // that we're not using a separate vary path part; it's unnecessary because\n+    // these are not conceptually separate inputs.\n+    value: pageRequestKey + HEAD_REQUEST_KEY,\n+    parent: {\n+      value: renderedSearch,\n+      parent: varyPath,\n+    },\n+  }\n+  return pageVaryPath as PageVaryPath\n+}\n+\n+export function getSegmentVaryPathForRequest(\n+  fetchStrategy: FetchStrategy,\n+  tree: RouteTree\n+): SegmentVaryPath {\n+  // This is used for storing pending requests in the cache. We want to choose\n+  // the most generic vary path based on the strategy used to fetch it, i.e.\n+  // static/PPR versus runtime prefetching, so that it can be reused as much\n+  // as possible.\n+  //\n+  // We may be able to re-key the response to something even more generic once\n+  // we receive it — for example, if the server tells us that the response\n+  // doesn't vary on a particular param — but even before we send the request,\n+  // we know some params are reusable based on the fetch strategy alone. For\n+  // example, a static prefetch will never vary on search params.\n+  //\n+  // The original vary path with all the params filled in is stored on the\n+  // route tree object. We will clone this one to create a new vary path\n+  // where certain params are replaced with Fallback.\n+  //\n+  // This result of this function is not stored anywhere. It's only used to\n+  // access the cache a single time.\n+  //\n+  // TODO: Rather than create a new list object just to access the cache, the\n+  // plan is to add the concept of a \"vary mask\". This will represent all the\n+  // params that can be treated as Fallback. (Or perhaps the inverse.)\n+  const originalVaryPath = tree.varyPath\n+\n+  // Only page segments (and the special \"metadata\" segment, which is treated\n+  // like a page segment for the purposes of caching) may contain search\n+  // params. There's no reason to include them in the vary path otherwise.\n+  if (tree.isPage) {\n+    // Only a runtime prefetch will include search params in the vary path.\n+    // Static prefetches never include search params, so they can be reused\n+    // across all possible search param values.\n+    const doesVaryOnSearchParams =\n+      fetchStrategy === FetchStrategy.Full ||\n+      fetchStrategy === FetchStrategy.PPRRuntime\n+\n+    if (!doesVaryOnSearchParams) {\n+      // The response from the the server will not vary on search params. Clone\n+      // the end of the original vary path to replace the search params\n+      // with Fallback.\n+      //\n+      // requestKey -> searchParams -> pathParams\n+      //               ^ This part gets replaced with Fallback\n+      const searchParamsVaryPath = (originalVaryPath as PageVaryPath).parent\n+      const pathParamsVaryPath = searchParamsVaryPath.parent\n+      const patchedVaryPath: VaryPath = {\n+        value: originalVaryPath.value,\n+        parent: {\n+          value: Fallback,\n+          parent: pathParamsVaryPath,\n+        },\n+      }\n+      return patchedVaryPath as SegmentVaryPath\n+    }\n+  }\n+\n+  // The request does vary on search params. We don't need to modify anything.\n+  return originalVaryPath as SegmentVaryPath\n+}\n+\n+export function clonePageVaryPathWithNewSearchParams(\n+  originalVaryPath: PageVaryPath,\n+  newSearch: NormalizedSearch\n+): PageVaryPath {\n+  // requestKey -> searchParams -> pathParams\n+  //               ^ This part gets replaced with newSearch\n+  const searchParamsVaryPath = originalVaryPath.parent\n+  const clonedVaryPath: VaryPath = {\n+    value: originalVaryPath.value,\n+    parent: {\n+      value: newSearch,\n+      parent: searchParamsVaryPath.parent,\n+    },\n+  }\n+  return clonedVaryPath as PageVaryPath\n+}"
        },
        {
            "sha": "e29e54b8944570b8427a3ce1178bac5b7ea10461",
            "filename": "packages/next/src/client/route-params.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 6,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/20c76e7155d9205e01543f40713d0b22c856b3f9/packages%2Fnext%2Fsrc%2Fclient%2Froute-params.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/20c76e7155d9205e01543f40713d0b22c856b3f9/packages%2Fnext%2Fsrc%2Fclient%2Froute-params.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Froute-params.ts?ref=20c76e7155d9205e01543f40713d0b22c856b3f9",
            "patch": "@@ -19,12 +19,6 @@ import type { ParsedUrlQuery } from 'querystring'\n \n export type RouteParamValue = string | Array<string> | null\n \n-export type RouteParam = {\n-  name: string\n-  value: RouteParamValue\n-  type: DynamicParamTypesShort\n-}\n-\n export function getRenderedSearch(\n   response: RSCResponse<unknown> | Response\n ): NormalizedSearch {"
        },
        {
            "sha": "54e0ba95f0c6c867da8bf73c2b9f865825ffbcfa",
            "filename": "packages/next/src/shared/lib/segment-cache/segment-value-encoding.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 46,
            "changes": 46,
            "blob_url": "https://github.com/vercel/next.js/blob/20c76e7155d9205e01543f40713d0b22c856b3f9/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fsegment-cache%2Fsegment-value-encoding.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/20c76e7155d9205e01543f40713d0b22c856b3f9/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fsegment-cache%2Fsegment-value-encoding.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fsegment-cache%2Fsegment-value-encoding.ts?ref=20c76e7155d9205e01543f40713d0b22c856b3f9",
            "patch": "@@ -1,17 +1,13 @@\n import { PAGE_SEGMENT_KEY } from '../segment'\n import type { Segment as FlightRouterStateSegment } from '../app-router-types'\n-import type { NormalizedPathname } from '../../../client/components/segment-cache/cache-key'\n \n // TypeScript trick to simulate opaque types, like in Flow.\n type Opaque<K, T> = T & { __brand: K }\n \n export type SegmentRequestKeyPart = Opaque<'SegmentRequestKeyPart', string>\n export type SegmentRequestKey = Opaque<'SegmentRequestKey', string>\n-export type SegmentCacheKeyPart = Opaque<'SegmentCacheKeyPart', string>\n-export type SegmentCacheKey = Opaque<'SegmentCacheKey', string>\n \n export const ROOT_SEGMENT_REQUEST_KEY = '' as SegmentRequestKey\n-export const ROOT_SEGMENT_CACHE_KEY = '' as SegmentCacheKey\n \n export const HEAD_REQUEST_KEY = '/_head' as SegmentRequestKey\n \n@@ -71,48 +67,6 @@ export function appendSegmentRequestKeyPart(\n   return (parentRequestKey + '/' + slotKey) as SegmentRequestKey\n }\n \n-export function createSegmentCacheKeyPart(\n-  requestKeyPart: SegmentRequestKeyPart,\n-  segment: FlightRouterStateSegment\n-): SegmentCacheKeyPart {\n-  if (typeof segment === 'string') {\n-    return requestKeyPart as any as SegmentCacheKeyPart\n-  }\n-  const paramValue = segment[1]\n-  const safeValue = encodeToFilesystemAndURLSafeString(paramValue)\n-  return (requestKeyPart + '$' + safeValue) as SegmentCacheKeyPart\n-}\n-\n-export function appendSegmentCacheKeyPart(\n-  parentSegmentKey: SegmentCacheKey,\n-  parallelRouteKey: string,\n-  childCacheKeyPart: SegmentCacheKeyPart\n-): SegmentCacheKey {\n-  const slotKey =\n-    parallelRouteKey === 'children'\n-      ? childCacheKeyPart\n-      : `@${encodeToFilesystemAndURLSafeString(parallelRouteKey)}/${childCacheKeyPart}`\n-  return (parentSegmentKey + '/' + slotKey) as SegmentCacheKey\n-}\n-\n-export function createHeadCacheKey(\n-  renderedPathname: NormalizedPathname\n-): SegmentCacheKey {\n-  // The \"head\" segment doesn't exist in the normal hierarchy of the page,\n-  // but it needs to vary on all the route params. So we append the entire\n-  // rendered pathname.\n-  // TODO: Eventually, cache entries will only vary on params if they were\n-  // actually accessed during server rendering. We'll do that by creating a\n-  // separate key part for each of the route params (see: cache-map.ts). The\n-  // same technique will also be used for the head segment.\n-  return ('/_head/' +\n-    encodeToFilesystemAndURLSafeString(renderedPathname)) as SegmentCacheKey\n-}\n-\n-export function isHeadCacheKey(cacheKey: SegmentCacheKey): boolean {\n-  return cacheKey.startsWith('/_head/')\n-}\n-\n // Define a regex pattern to match the most common characters found in a route\n // param. It excludes anything that might not be cross-platform filesystem\n // compatible, like |. It does not need to be precise because the fallback is to"
        }
    ],
    "stats": {
        "total": 1216,
        "additions": 756,
        "deletions": 460
    }
}