{
    "author": "wyattjoh",
    "message": "fix: add cache tags to segment prefetch responses (#77846)\n\nAdds the cache tags to the segment prefetch requests so that they can be\ninvalidated correctly.\n<!-- Thanks for opening a PR! Your contribution is much appreciated.\nTo make sure your PR is handled as smoothly as possible we request that\nyou follow the checklist sections below.\nChoose the right checklist for the change(s) that you're making:\n\n## For Contributors\n\n### Improving Documentation\n\n- Run `pnpm prettier-fix` to fix formatting issues before opening the\nPR.\n- Read the Docs Contribution Guide to ensure your contribution follows\nthe docs guidelines:\nhttps://nextjs.org/docs/community/contribution-guide\n\n### Adding or Updating Examples\n\n- The \"examples guidelines\" are followed from our contributing doc\nhttps://github.com/vercel/next.js/blob/canary/contributing/examples/adding-examples.md\n- Make sure the linting passes by running `pnpm build && pnpm lint`. See\nhttps://github.com/vercel/next.js/blob/canary/contributing/repository/linting.md\n\n### Fixing a bug\n\n- Related issues linked using `fixes #number`\n- Tests added. See:\nhttps://github.com/vercel/next.js/blob/canary/contributing/core/testing.md#writing-tests-for-nextjs\n- Errors have a helpful link attached, see\nhttps://github.com/vercel/next.js/blob/canary/contributing.md\n\n### Adding a feature\n\n- Implements an existing feature request or RFC. Make sure the feature\nrequest has been accepted for implementation before opening a PR. (A\ndiscussion must be opened, see\nhttps://github.com/vercel/next.js/discussions/new?category=ideas)\n- Related issues/discussions are linked using `fixes #number`\n- e2e tests added\n(https://github.com/vercel/next.js/blob/canary/contributing/core/testing.md#writing-tests-for-nextjs)\n- Documentation added\n- Telemetry added. In case of a feature if it's used or not.\n- Errors have a helpful link attached, see\nhttps://github.com/vercel/next.js/blob/canary/contributing.md\n\n\n## For Maintainers\n\n- Minimal description (aim for explaining to someone not on the team to\nunderstand the PR)\n- When linking to a Slack thread, you might want to share details of the\nconclusion\n- Link both the Linear (Fixes NEXT-xxx) and the GitHub issues\n- Add review comments if necessary to explain to the reviewer the logic\nbehind a change\n\n### What?\n\n### Why?\n\n### How?\n\nCloses NEXT-\nFixes #\n\n-->",
    "sha": "328708622b7bad24941b8d8c8073808538a33f95",
    "files": [
        {
            "sha": "65cfdb92950996f774c5bc3c55124962ffae8954",
            "filename": "packages/next/src/server/base-server.ts",
            "status": "modified",
            "additions": 55,
            "deletions": 52,
            "changes": 107,
            "blob_url": "https://github.com/vercel/next.js/blob/328708622b7bad24941b8d8c8073808538a33f95/packages%2Fnext%2Fsrc%2Fserver%2Fbase-server.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/328708622b7bad24941b8d8c8073808538a33f95/packages%2Fnext%2Fsrc%2Fserver%2Fbase-server.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fbase-server.ts?ref=328708622b7bad24941b8d8c8073808538a33f95",
            "patch": "@@ -3256,49 +3256,6 @@ export default abstract class Server<\n \n     const { value: cachedData } = cacheEntry\n \n-    if (\n-      typeof segmentPrefetchHeader === 'string' &&\n-      cachedData?.kind === CachedRouteKind.APP_PAGE &&\n-      cachedData.segmentData\n-    ) {\n-      // This is a prefetch request issued by the client Segment Cache. These\n-      // should never reach the application layer (lambda). We should either\n-      // respond from the cache (HIT) or respond with 204 No Content (MISS).\n-\n-      // Set a header to indicate that PPR is enabled for this route. This\n-      // lets the client distinguish between a regular cache miss and a cache\n-      // miss due to PPR being disabled. In other contexts this header is used\n-      // to indicate that the response contains dynamic data, but here we're\n-      // only using it to indicate that the feature is enabled — the segment\n-      // response itself contains whether the data is dynamic.\n-      res.setHeader(NEXT_DID_POSTPONE_HEADER, '2')\n-\n-      const matchedSegment = cachedData.segmentData.get(segmentPrefetchHeader)\n-      if (matchedSegment !== undefined) {\n-        // Cache hit\n-        return {\n-          type: 'rsc',\n-          body: RenderResult.fromStatic(matchedSegment),\n-          // TODO: Eventually this should use cache control of the individual\n-          // segment, not the whole page.\n-          cacheControl: cacheEntry.cacheControl,\n-        }\n-      }\n-\n-      // Cache miss. Either a cache entry for this route has not been generated\n-      // (which technically should not be possible when PPR is enabled, because\n-      // at a minimum there should always be a fallback entry) or there's no\n-      // match for the requested segment. Respond with a 204 No Content. We\n-      // don't bother to respond with 404, because these requests are only\n-      // issued as part of a prefetch.\n-      res.statusCode = 204\n-      return {\n-        type: 'rsc',\n-        body: RenderResult.fromStatic(''),\n-        cacheControl: cacheEntry?.cacheControl,\n-      }\n-    }\n-\n     // If the cache value is an image, we should error early.\n     if (cachedData?.kind === CachedRouteKind.IMAGE) {\n       throw new InvariantError('SSG should not return an image cache value')\n@@ -3379,6 +3336,56 @@ export default abstract class Server<\n \n     cacheEntry.cacheControl = cacheControl\n \n+    if (\n+      typeof segmentPrefetchHeader === 'string' &&\n+      cachedData?.kind === CachedRouteKind.APP_PAGE &&\n+      cachedData.segmentData\n+    ) {\n+      // This is a prefetch request issued by the client Segment Cache. These\n+      // should never reach the application layer (lambda). We should either\n+      // respond from the cache (HIT) or respond with 204 No Content (MISS).\n+\n+      // Set a header to indicate that PPR is enabled for this route. This\n+      // lets the client distinguish between a regular cache miss and a cache\n+      // miss due to PPR being disabled. In other contexts this header is used\n+      // to indicate that the response contains dynamic data, but here we're\n+      // only using it to indicate that the feature is enabled — the segment\n+      // response itself contains whether the data is dynamic.\n+      res.setHeader(NEXT_DID_POSTPONE_HEADER, '2')\n+\n+      // Add the cache tags header to the response if it exists and we're in\n+      // minimal mode while rendering a static page.\n+      const tags = cachedData.headers?.[NEXT_CACHE_TAGS_HEADER]\n+      if (this.minimalMode && isSSG && tags && typeof tags === 'string') {\n+        res.setHeader(NEXT_CACHE_TAGS_HEADER, tags)\n+      }\n+\n+      const matchedSegment = cachedData.segmentData.get(segmentPrefetchHeader)\n+      if (matchedSegment !== undefined) {\n+        // Cache hit\n+        return {\n+          type: 'rsc',\n+          body: RenderResult.fromStatic(matchedSegment),\n+          // TODO: Eventually this should use cache control of the individual\n+          // segment, not the whole page.\n+          cacheControl: cacheEntry.cacheControl,\n+        }\n+      }\n+\n+      // Cache miss. Either a cache entry for this route has not been generated\n+      // (which technically should not be possible when PPR is enabled, because\n+      // at a minimum there should always be a fallback entry) or there's no\n+      // match for the requested segment. Respond with a 204 No Content. We\n+      // don't bother to respond with 404, because these requests are only\n+      // issued as part of a prefetch.\n+      res.statusCode = 204\n+      return {\n+        type: 'rsc',\n+        body: RenderResult.fromStatic(''),\n+        cacheControl: cacheEntry?.cacheControl,\n+      }\n+    }\n+\n     // If there's a callback for `onCacheEntry`, call it with the cache entry\n     // and the revalidate options.\n     const onCacheEntry = getRequestMeta(req, 'onCacheEntry')\n@@ -3520,15 +3527,11 @@ export default abstract class Server<\n         }\n       }\n \n-      if (\n-        this.minimalMode &&\n-        isSSG &&\n-        cachedData.headers?.[NEXT_CACHE_TAGS_HEADER]\n-      ) {\n-        res.setHeader(\n-          NEXT_CACHE_TAGS_HEADER,\n-          cachedData.headers[NEXT_CACHE_TAGS_HEADER] as string\n-        )\n+      // Add the cache tags header to the response if it exists and we're in\n+      // minimal mode while rendering a static page.\n+      const tags = cachedData.headers?.[NEXT_CACHE_TAGS_HEADER]\n+      if (this.minimalMode && isSSG && tags && typeof tags === 'string') {\n+        res.setHeader(NEXT_CACHE_TAGS_HEADER, tags)\n       }\n \n       // If the request is a data request, then we shouldn't set the status code"
        }
    ],
    "stats": {
        "total": 107,
        "additions": 55,
        "deletions": 52
    }
}