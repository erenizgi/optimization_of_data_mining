{
    "author": "lukesandberg",
    "message": "[turbopack] Add support for partial glob matches (#82906)\n\n### What\n\nAdd a `contains` option to our Glob API that is compatible with the [`picomatch`](https://www.npmjs.com/package/picomatch/v/4.0.3) `contains` option\n\n### Why\n\nThis is the default behavior of the globs passed to NFT configuration options in next, and so we need this feature to be compatible in our rewrite.\n\n### How\n\nJust drop `$` and `^` from the generated regexes when `contains` is set.\n\nFor the nft globs we set `contains:true` which is compatible with the current behavior in [`collect-build-traces.ts`](https://github.com/vercel/next.js/blob/b56d1e1af1ad37f96e1905662b15ac5f4707726b/packages/next/src/build/collect-build-traces.ts#L189-L192)\n\nCloses PACK-5305",
    "sha": "64e9c8046e4a8e3f8f3a7ac8e1341ad0cbdf0e53",
    "files": [
        {
            "sha": "c92624ec4b8761c1de0c16e2a6027e97545ce7ad",
            "filename": "crates/next-api/src/nft_json.rs",
            "status": "modified",
            "additions": 17,
            "deletions": 4,
            "changes": 21,
            "blob_url": "https://github.com/vercel/next.js/blob/64e9c8046e4a8e3f8f3a7ac8e1341ad0cbdf0e53/crates%2Fnext-api%2Fsrc%2Fnft_json.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/64e9c8046e4a8e3f8f3a7ac8e1341ad0cbdf0e53/crates%2Fnext-api%2Fsrc%2Fnft_json.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fnft_json.rs?ref=64e9c8046e4a8e3f8f3a7ac8e1341ad0cbdf0e53",
            "patch": "@@ -7,7 +7,10 @@ use turbo_tasks::{\n     FxIndexMap, ReadRef, ResolvedVc, TryFlatJoinIterExt, TryJoinIterExt, Vc,\n     graph::{AdjacencyMap, GraphTraversal},\n };\n-use turbo_tasks_fs::{DirectoryEntry, File, FileSystem, FileSystemPath, glob::Glob};\n+use turbo_tasks_fs::{\n+    DirectoryEntry, File, FileSystem, FileSystemPath,\n+    glob::{Glob, GlobOptions},\n+};\n use turbopack_core::{\n     asset::{Asset, AssetContent},\n     output::{OutputAsset, OutputAssets},\n@@ -174,7 +177,11 @@ impl Asset for NftJsonAsset {\n                 if let Some(excludes_obj) = excludes_config.as_object() {\n                     for (glob_pattern, exclude_patterns) in excludes_obj {\n                         // Check if the route matches the glob pattern\n-                        let glob = Glob::new(RcStr::from(glob_pattern.clone())).await?;\n+                        let glob = Glob::new(\n+                            RcStr::from(glob_pattern.clone()),\n+                            GlobOptions { contains: true },\n+                        )\n+                        .await?;\n                         if glob.matches(route)\n                             && let Some(patterns) = exclude_patterns.as_array()\n                         {\n@@ -207,6 +214,7 @@ impl Asset for NftJsonAsset {\n                                 .join(\",\")\n                         )\n                         .into(),\n+                        GlobOptions { contains: true },\n                     );\n \n                     Some(glob)\n@@ -289,7 +297,9 @@ impl Asset for NftJsonAsset {\n             {\n                 for (glob_pattern, include_patterns) in includes_obj {\n                     // Check if the route matches the glob pattern\n-                    let glob = Glob::new(glob_pattern.as_str().into()).await?;\n+                    let glob =\n+                        Glob::new(glob_pattern.as_str().into(), GlobOptions { contains: true })\n+                            .await?;\n                     if glob.matches(route)\n                         && let Some(patterns) = include_patterns.as_array()\n                     {\n@@ -311,7 +321,10 @@ impl Asset for NftJsonAsset {\n             let includes = combined_includes_by_root\n                 .into_iter()\n                 .map(|(root, globs)| {\n-                    let glob = Glob::new(format!(\"{{{}}}\", globs.join(\",\")).into());\n+                    let glob = Glob::new(\n+                        format!(\"{{{}}}\", globs.join(\",\")).into(),\n+                        GlobOptions { contains: true },\n+                    );\n                     apply_includes(root, glob, &ident_folder_in_project_fs)\n                 })\n                 .try_join()"
        },
        {
            "sha": "a69f76db428f3798d9e005eeec096792fce790d2",
            "filename": "crates/next-core/src/next_font/local/mod.rs",
            "status": "modified",
            "additions": 7,
            "deletions": 4,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/64e9c8046e4a8e3f8f3a7ac8e1341ad0cbdf0e53/crates%2Fnext-core%2Fsrc%2Fnext_font%2Flocal%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/64e9c8046e4a8e3f8f3a7ac8e1341ad0cbdf0e53/crates%2Fnext-core%2Fsrc%2Fnext_font%2Flocal%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_font%2Flocal%2Fmod.rs?ref=64e9c8046e4a8e3f8f3a7ac8e1341ad0cbdf0e53",
            "patch": "@@ -5,7 +5,9 @@ use serde::{Deserialize, Serialize};\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{ResolvedVc, Vc};\n use turbo_tasks_fs::{\n-    FileContent, FileSystemPath, glob::Glob, json::parse_json_with_source_context,\n+    FileContent, FileSystemPath,\n+    glob::{Glob, GlobOptions},\n+    json::parse_json_with_source_context,\n };\n use turbopack_core::{\n     asset::AssetContent,\n@@ -68,9 +70,10 @@ impl NextFontLocalResolvePlugin {\n impl BeforeResolvePlugin for NextFontLocalResolvePlugin {\n     #[turbo_tasks::function]\n     fn before_resolve_condition(&self) -> Vc<BeforeResolvePluginCondition> {\n-        BeforeResolvePluginCondition::from_request_glob(Glob::new(rcstr!(\n-            \"{next,@vercel/turbopack-next/internal}/font/local/*\"\n-        )))\n+        BeforeResolvePluginCondition::from_request_glob(Glob::new(\n+            rcstr!(\"{next,@vercel/turbopack-next/internal}/font/local/*\"),\n+            GlobOptions::default(),\n+        ))\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "ca6611c1e10df3be014d086953d414e104d73138",
            "filename": "crates/next-core/src/next_server/resolve.rs",
            "status": "modified",
            "additions": 16,
            "deletions": 5,
            "changes": 21,
            "blob_url": "https://github.com/vercel/next.js/blob/64e9c8046e4a8e3f8f3a7ac8e1341ad0cbdf0e53/crates%2Fnext-core%2Fsrc%2Fnext_server%2Fresolve.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/64e9c8046e4a8e3f8f3a7ac8e1341ad0cbdf0e53/crates%2Fnext-core%2Fsrc%2Fnext_server%2Fresolve.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_server%2Fresolve.rs?ref=64e9c8046e4a8e3f8f3a7ac8e1341ad0cbdf0e53",
            "patch": "@@ -5,7 +5,10 @@ use regex::Regex;\n use serde::{Deserialize, Serialize};\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{NonLocalValue, ResolvedVc, Vc, trace::TraceRawVcs};\n-use turbo_tasks_fs::{self, FileJsonContent, FileSystemPath, glob::Glob};\n+use turbo_tasks_fs::{\n+    self, FileJsonContent, FileSystemPath,\n+    glob::{Glob, GlobOptions},\n+};\n use turbopack_core::{\n     issue::{Issue, IssueExt, IssueSeverity, IssueStage, OptionStyledString, StyledString},\n     reference_type::{EcmaScriptModulesReferenceSubType, ReferenceType},\n@@ -67,7 +70,10 @@ impl ExternalCjsModulesResolvePlugin {\n \n #[turbo_tasks::function]\n fn condition(root: FileSystemPath) -> Vc<AfterResolvePluginCondition> {\n-    AfterResolvePluginCondition::new(root, Glob::new(rcstr!(\"**/node_modules/**\")))\n+    AfterResolvePluginCondition::new(\n+        root,\n+        Glob::new(rcstr!(\"**/node_modules/**\"), GlobOptions::default()),\n+    )\n }\n \n #[turbo_tasks::value_impl]\n@@ -441,9 +447,14 @@ async fn packages_glob(packages: Vc<Vec<RcStr>>) -> Result<Vc<OptionPackagesGlob\n     if packages.is_empty() {\n         return Ok(Vc::cell(None));\n     }\n-    let path_glob = Glob::new(format!(\"**/node_modules/{{{}}}/**\", packages.join(\",\")).into());\n-    let request_glob =\n-        Glob::new(format!(\"{{{},{}/**}}\", packages.join(\",\"), packages.join(\"/**,\")).into());\n+    let path_glob = Glob::new(\n+        format!(\"**/node_modules/{{{}}}/**\", packages.join(\",\")).into(),\n+        GlobOptions::default(),\n+    );\n+    let request_glob = Glob::new(\n+        format!(\"{{{},{}/**}}\", packages.join(\",\"), packages.join(\"/**,\")).into(),\n+        GlobOptions::default(),\n+    );\n     Ok(Vc::cell(Some(PackagesGlobs {\n         path_glob: path_glob.to_resolved().await?,\n         request_glob: request_glob.to_resolved().await?,"
        },
        {
            "sha": "04156bf3766c436f6840fee88fa606a8a2d86b23",
            "filename": "crates/next-core/src/next_shared/resolve.rs",
            "status": "modified",
            "additions": 16,
            "deletions": 6,
            "changes": 22,
            "blob_url": "https://github.com/vercel/next.js/blob/64e9c8046e4a8e3f8f3a7ac8e1341ad0cbdf0e53/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fresolve.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/64e9c8046e4a8e3f8f3a7ac8e1341ad0cbdf0e53/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fresolve.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fresolve.rs?ref=64e9c8046e4a8e3f8f3a7ac8e1341ad0cbdf0e53",
            "patch": "@@ -4,7 +4,10 @@ use anyhow::Result;\n use rustc_hash::FxHashMap;\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{ResolvedVc, Vc};\n-use turbo_tasks_fs::{FileSystemPath, glob::Glob};\n+use turbo_tasks_fs::{\n+    FileSystemPath,\n+    glob::{Glob, GlobOptions},\n+};\n use turbopack_core::{\n     diagnostics::DiagnosticExt,\n     file_source::FileSource,\n@@ -223,9 +226,10 @@ impl AfterResolvePlugin for NextExternalResolvePlugin {\n     async fn after_resolve_condition(&self) -> Result<Vc<AfterResolvePluginCondition>> {\n         Ok(AfterResolvePluginCondition::new(\n             self.project_path.root().owned().await?,\n-            Glob::new(rcstr!(\n-                \"**/next/dist/**/*.{external,runtime.dev,runtime.prod}.js\"\n-            )),\n+            Glob::new(\n+                rcstr!(\"**/next/dist/**/*.{external,runtime.dev,runtime.prod}.js\"),\n+                GlobOptions::default(),\n+            ),\n         ))\n     }\n \n@@ -279,7 +283,10 @@ impl AfterResolvePlugin for NextNodeSharedRuntimeResolvePlugin {\n     async fn after_resolve_condition(&self) -> Result<Vc<AfterResolvePluginCondition>> {\n         Ok(AfterResolvePluginCondition::new(\n             self.root.root().owned().await?,\n-            Glob::new(rcstr!(\"**/next/dist/**/*.shared-runtime.js\")),\n+            Glob::new(\n+                rcstr!(\"**/next/dist/**/*.shared-runtime.js\"),\n+                GlobOptions::default(),\n+            ),\n         ))\n     }\n \n@@ -404,7 +411,10 @@ impl AfterResolvePlugin for NextSharedRuntimeResolvePlugin {\n     async fn after_resolve_condition(&self) -> Result<Vc<AfterResolvePluginCondition>> {\n         Ok(AfterResolvePluginCondition::new(\n             self.root.root().owned().await?,\n-            Glob::new(rcstr!(\"**/next/dist/esm/**/*.shared-runtime.js\")),\n+            Glob::new(\n+                rcstr!(\"**/next/dist/esm/**/*.shared-runtime.js\"),\n+                GlobOptions::default(),\n+            ),\n         ))\n     }\n "
        },
        {
            "sha": "00d147159ec5b1b923ed2bcc46b95aed5b27fdf5",
            "filename": "turbopack/crates/turbo-tasks-fs/examples/hash_glob.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/64e9c8046e4a8e3f8f3a7ac8e1341ad0cbdf0e53/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fexamples%2Fhash_glob.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/64e9c8046e4a8e3f8f3a7ac8e1341ad0cbdf0e53/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fexamples%2Fhash_glob.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fexamples%2Fhash_glob.rs?ref=64e9c8046e4a8e3f8f3a7ac8e1341ad0cbdf0e53",
            "patch": "@@ -15,7 +15,8 @@ use turbo_tasks::{ReadConsistency, TurboTasks, UpdateInfo, Vc, util::FormatDurat\n use turbo_tasks_backend::{BackendOptions, TurboTasksBackend, noop_backing_storage};\n use turbo_tasks_fs::{\n     DirectoryEntry, DiskFileSystem, FileContent, FileSystem, FileSystemPath, ReadGlobResult,\n-    glob::Glob, register,\n+    glob::{Glob, GlobOptions},\n+    register,\n };\n \n #[tokio::main]\n@@ -38,7 +39,7 @@ async fn main() -> Result<()> {\n             // Smart Pointer cast\n             let fs: Vc<Box<dyn FileSystem>> = Vc::upcast(disk_fs);\n             let input = fs.root().await?.join(\"crates\")?;\n-            let glob = Glob::new(rcstr!(\"**/*.rs\"));\n+            let glob = Glob::new(rcstr!(\"**/*.rs\"), GlobOptions::default());\n             let glob_result = input.read_glob(glob);\n             let dir_hash = hash_glob_result(glob_result);\n             print_hash(dir_hash).await?;"
        },
        {
            "sha": "2f866202efc390b36680039e3e95f50f5f3a4a3b",
            "filename": "turbopack/crates/turbo-tasks-fs/src/glob.rs",
            "status": "modified",
            "additions": 81,
            "deletions": 18,
            "changes": 99,
            "blob_url": "https://github.com/vercel/next.js/blob/64e9c8046e4a8e3f8f3a7ac8e1341ad0cbdf0e53/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fglob.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/64e9c8046e4a8e3f8f3a7ac8e1341ad0cbdf0e53/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fglob.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fglob.rs?ref=64e9c8046e4a8e3f8f3a7ac8e1341ad0cbdf0e53",
            "patch": "@@ -1,10 +1,10 @@\n use std::fmt::Display;\n \n-use anyhow::Result;\n+use anyhow::{Result, bail};\n use regex::bytes::{Regex, RegexBuilder};\n use serde::{Deserialize, Serialize};\n use turbo_rcstr::{RcStr, rcstr};\n-use turbo_tasks::Vc;\n+use turbo_tasks::{TaskInput, Vc, trace::TraceRawVcs};\n \n use crate::globset::parse;\n \n@@ -26,6 +26,8 @@ use crate::globset::parse;\n pub struct Glob {\n     glob: String,\n     #[turbo_tasks(trace_ignore)]\n+    opts: GlobOptions,\n+    #[turbo_tasks(trace_ignore)]\n     regex: Regex,\n     #[turbo_tasks(trace_ignore)]\n     directory_match_regex: Regex,\n@@ -42,22 +44,35 @@ impl Display for Glob {\n         write!(f, \"Glob({})\", self.glob)\n     }\n }\n+#[derive(\n+    Serialize, Deserialize, Copy, Clone, PartialEq, Eq, Hash, Default, TaskInput, TraceRawVcs, Debug,\n+)]\n+pub struct GlobOptions {\n+    /// Whether the glob is a partial match.\n+    /// Allows glob to match any part of the given string(s).\n+    /// NOTE: this means that a pattern like `node_modules/package_name` with `contains:true` will\n+    /// match `foo_node_modules/package_name_bar` If you want to match a _directory_ named\n+    /// `node_modules/package_name` you should use `**/node_modules/package_name/**`\n+    pub contains: bool,\n+}\n \n #[derive(Serialize, Deserialize)]\n-#[serde(transparent)]\n-#[repr(transparent)]\n struct GlobForm {\n     glob: String,\n+    opts: GlobOptions,\n }\n impl From<Glob> for GlobForm {\n     fn from(value: Glob) -> Self {\n-        Self { glob: value.glob }\n+        Self {\n+            glob: value.glob,\n+            opts: value.opts,\n+        }\n     }\n }\n impl TryFrom<GlobForm> for Glob {\n     type Error = anyhow::Error;\n     fn try_from(value: GlobForm) -> Result<Self, Self::Error> {\n-        Glob::parse(&value.glob)\n+        Glob::parse(&value.glob, value.opts)\n     }\n }\n \n@@ -77,13 +92,14 @@ impl Glob {\n         self.directory_match_regex.is_match(path.as_bytes())\n     }\n \n-    pub fn parse(input: &str) -> Result<Glob> {\n-        let (glob_re, directory_match_re) = parse(input)?;\n+    pub fn parse(input: &str, opts: GlobOptions) -> Result<Glob> {\n+        let (glob_re, directory_match_re) = parse(input, opts)?;\n         let regex = new_regex(glob_re.as_str());\n         let directory_match_regex = new_regex(directory_match_re.as_str());\n \n         Ok(Glob {\n             glob: input.to_string(),\n+            opts,\n             regex,\n             directory_match_regex,\n         })\n@@ -94,33 +110,46 @@ impl TryFrom<&str> for Glob {\n     type Error = anyhow::Error;\n \n     fn try_from(value: &str) -> Result<Self, Self::Error> {\n-        Glob::parse(value)\n+        Glob::parse(value, GlobOptions::default())\n     }\n }\n \n #[turbo_tasks::value_impl]\n impl Glob {\n     #[turbo_tasks::function]\n-    pub fn new(glob: RcStr) -> Result<Vc<Self>> {\n-        Ok(Self::cell(Glob::parse(glob.as_str())?))\n+    pub fn new(glob: RcStr, opts: GlobOptions) -> Result<Vc<Self>> {\n+        Ok(Self::cell(Glob::parse(glob.as_str(), opts)?))\n     }\n \n     #[turbo_tasks::function]\n     pub async fn alternatives(globs: Vec<Vc<Glob>>) -> Result<Vc<Self>> {\n         match globs.len() {\n-            0 => Ok(Glob::new(rcstr!(\"\"))),\n+            0 => Ok(Glob::new(rcstr!(\"\"), GlobOptions::default())),\n             1 => Ok(globs.into_iter().next().unwrap()),\n             _ => {\n                 let mut new_glob = String::new();\n                 new_glob.push('{');\n+                let mut opts = None;\n                 for (index, glob) in globs.iter().enumerate() {\n                     if index > 0 {\n                         new_glob.push(',');\n                     }\n-                    new_glob.push_str(&glob.await?.glob);\n+                    let glob = &*glob.await?;\n+                    if let Some(old_opts) = opts {\n+                        if old_opts != glob.opts {\n+                            bail!(\n+                                \"Cannot compose globs with different options via the \\\n+                                 `alternatives` function.\"\n+                            )\n+                        }\n+                    } else {\n+                        opts = Some(glob.opts);\n+                    }\n+                    new_glob.push_str(&glob.glob);\n                 }\n                 new_glob.push('}');\n-                Ok(Glob::new(new_glob.into()))\n+                // The loop must have iterated at least once, so the options must be initialized.\n+                Ok(Glob::new(new_glob.into(), opts.unwrap()))\n             }\n         }\n     }\n@@ -138,6 +167,7 @@ mod tests {\n     use rstest::*;\n \n     use super::Glob;\n+    use crate::glob::GlobOptions;\n \n     #[rstest]\n     #[case::file(\"file.js\", \"file.js\")]\n@@ -153,6 +183,9 @@ mod tests {\n     #[case::globstar(\"**/*.js\", \"dir/sub/file.js\")]\n     #[case::globstar(\"**/**/*.js\", \"file.js\")]\n     #[case::globstar(\"**/**/*.js\", \"dir/sub/file.js\")]\n+    #[case::globstar(\"**\", \"/foo\")]\n+    #[case::globstar(\"**\", \"foo\")]\n+    #[case::star(\"*\", \"foo\")]\n     #[case::globstar_in_dir(\"dir/**/sub/file.js\", \"dir/sub/file.js\")]\n     #[case::globstar_in_dir(\"dir/**/sub/file.js\", \"dir/a/sub/file.js\")]\n     #[case::globstar_in_dir(\"dir/**/sub/file.js\", \"dir/a/b/sub/file.js\")]\n@@ -205,7 +238,7 @@ mod tests {\n     #[case::alternatives_empty2(\"react{,-dom}\", \"react-dom\")]\n     #[case::alternatives_chars(\"[abc]\", \"b\")]\n     fn glob_match(#[case] glob: &str, #[case] path: &str) {\n-        let glob = Glob::parse(glob).unwrap();\n+        let glob = Glob::parse(glob, GlobOptions::default()).unwrap();\n \n         println!(\"{glob:?} {path}\");\n \n@@ -218,8 +251,9 @@ mod tests {\n         \"**/next/dist/esm/*.shared-runtime.js\",\n         \"next/dist/shared/lib/app-router-context.shared-runtime.js\"\n     )]\n+    #[case::star(\"*\", \"/foo\")]\n     fn glob_not_matching(#[case] glob: &str, #[case] path: &str) {\n-        let glob = Glob::parse(glob).unwrap();\n+        let glob = Glob::parse(glob, GlobOptions::default()).unwrap();\n \n         println!(\"{glob:?} {path}\");\n \n@@ -238,7 +272,7 @@ mod tests {\n     #[case::globstar_in_dir_partial(\"dir/**/sub/file.js\", \"dir/a/b/sub\")]\n     #[case::globstar_in_dir_partial(\"dir/**/sub/file.js\", \"dir/a/b/sub/file.js\")]\n     fn glob_can_match_directory(#[case] glob: &str, #[case] path: &str) {\n-        let glob = Glob::parse(glob).unwrap();\n+        let glob = Glob::parse(glob, GlobOptions::default()).unwrap();\n \n         println!(\"{glob:?} {path}\");\n \n@@ -248,10 +282,39 @@ mod tests {\n     #[case::dir_and_file_partial(\"dir/file.js\", \"dir/file.js\")] // even if there was a dir, named `file.js` we know the glob wasn't intended to match it.\n     #[case::alternatives_chars(\"[abc]\", \"b\")]\n     fn glob_not_can_match_directory(#[case] glob: &str, #[case] path: &str) {\n-        let glob = Glob::parse(glob).unwrap();\n+        let glob = Glob::parse(glob, GlobOptions::default()).unwrap();\n \n         println!(\"{glob:?} {path}\");\n \n         assert!(!glob.can_match_in_directory(path));\n     }\n+\n+    #[rstest]\n+    #[case::star(\"*\", \"/foo\")]\n+    #[case::star(\"*\", \"foo\")]\n+    #[case::star(\"*\", \"foo/bar\")]\n+    #[case::prefix(\"foo/*\", \"bar/foo/baz\")]\n+    // This is a possibly surprising case.\n+    #[case::dir_match(\"node_modules/foo\", \"my_node_modules/foobar\")]\n+    fn partial_glob_match(#[case] glob: &str, #[case] path: &str) {\n+        let glob = Glob::parse(glob, GlobOptions { contains: true }).unwrap();\n+\n+        println!(\"{glob:?} {path}\");\n+\n+        assert!(glob.matches(path));\n+    }\n+\n+    #[rstest]\n+    #[case::literal(\"foo\", \"bar\")]\n+    #[case::suffix(\"*.js\", \"foo.ts\")]\n+    #[case::prefix(\"foo/*\", \"bar\")]\n+    // This is a possibly surprising case\n+    #[case::dir_match(\"/node_modules/\", \"node_modules/\")]\n+    fn partial_glob_not_matching(#[case] glob: &str, #[case] path: &str) {\n+        let glob = Glob::parse(glob, GlobOptions { contains: true }).unwrap();\n+\n+        println!(\"{glob:?} {path}\");\n+\n+        assert!(!glob.matches(path));\n+    }\n }"
        },
        {
            "sha": "4541803abc3383b6b92cb1cf4b379ef1b97275bd",
            "filename": "turbopack/crates/turbo-tasks-fs/src/globset.rs",
            "status": "modified",
            "additions": 29,
            "deletions": 16,
            "changes": 45,
            "blob_url": "https://github.com/vercel/next.js/blob/64e9c8046e4a8e3f8f3a7ac8e1341ad0cbdf0e53/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fglobset.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/64e9c8046e4a8e3f8f3a7ac8e1341ad0cbdf0e53/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fglobset.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fglobset.rs?ref=64e9c8046e4a8e3f8f3a7ac8e1341ad0cbdf0e53",
            "patch": "@@ -28,6 +28,8 @@\n /// of regexes and those are mostly preserved.\n use anyhow::Error;\n \n+use crate::glob::GlobOptions;\n+\n /// The parsed tokens of a glob pattern.\n #[derive(Clone, Debug, Default, Eq, PartialEq)]\n #[repr(transparent)]\n@@ -72,8 +74,8 @@ impl Tokens {\n     /// Convert this pattern to a string that is guaranteed to be a valid\n     /// regular expression and will represent the matching semantics of this\n     /// glob pattern and the options given.\n-    fn to_regex(&self) -> String {\n-        self.to_regex_impl(Self::tokens_to_regex)\n+    fn to_regex(&self, opts: GlobOptions) -> String {\n+        self.to_regex_impl(Self::tokens_to_regex, opts)\n     }\n \n     /// Convert this pattern to a string that is guaranteed to be a valid\n@@ -84,24 +86,34 @@ impl Tokens {\n     /// The basic strategy is to add 'early exits' to the regex at `/` boundaries.\n     /// e.g. `foo/bar/baz` -> `foo(?:/bar(?:/baz(?:/.*)?)?)?`\n     /// that way 'foo' will match but foo/baz will not\n-    fn to_directory_match_regex(&self) -> String {\n-        self.to_regex_impl(Self::tokens_to_directory_match_regex)\n+    fn to_directory_match_regex(&self, opts: GlobOptions) -> String {\n+        self.to_regex_impl(Self::tokens_to_directory_match_regex, opts)\n     }\n \n-    fn to_regex_impl(&self, tokens_to_regex_fn: fn(&[Token], &mut String)) -> String {\n+    fn to_regex_impl(\n+        &self,\n+        tokens_to_regex_fn: fn(&[Token], &mut String),\n+        opts: GlobOptions,\n+    ) -> String {\n         let mut re = String::new();\n-        // Our patterns are always anchored to the beginning and end of the string and we care not\n-        // for unicode correctness.  Paths do not require this and if the caller does they can\n-        // simply take care to pass us valid utf8 themselves.\n-        re.push_str(\"(?-u)^\");\n+        // We don't care care about for unicode correctness.  Paths do not require this and if the\n+        // caller does they can simply take care to pass us valid utf8 themselves.\n+        re.push_str(\"(?-u)\");\n+\n+        // Enable anchored matches unless\n+        if !opts.contains {\n+            re.push('^');\n+        }\n         // Special case. If the entire glob is just `**`, then it should match\n         // everything.\n         if self.len() == 1 && self[0] == Token::RecursivePrefix {\n-            re.push_str(\".*$\");\n-            return re;\n+            re.push_str(\".*\");\n+        } else {\n+            tokens_to_regex_fn(self, &mut re);\n+        }\n+        if !opts.contains {\n+            re.push('$');\n         }\n-        tokens_to_regex_fn(self, &mut re);\n-        re.push('$');\n         re\n     }\n \n@@ -340,9 +352,9 @@ impl ErrorKind {\n // The directory match regex is guaranteed to be valid and will match the same\n // semantics as the glob when used to check if a directory path might contain files that match\n // this glob. This means we care about matching prefixes that are bounded by `/` characters.\n-pub(crate) fn parse(glob: &str) -> Result<(String, String), Error> {\n+pub(crate) fn parse(glob: &str, opts: GlobOptions) -> Result<(String, String), Error> {\n     let tokens = Parser::new(glob).parse()?;\n-    Ok((tokens.to_regex(), tokens.to_directory_match_regex()))\n+    Ok((tokens.to_regex(opts), tokens.to_directory_match_regex(opts)))\n }\n \n struct Parser<'a> {\n@@ -624,6 +636,7 @@ mod tests {\n     use rstest::*;\n \n     use super::parse;\n+    use crate::glob::GlobOptions;\n \n     #[rstest]\n     #[case::literal(\"dir/file.js\", \"dir/file\\\\.js\", \"dir\")]\n@@ -644,7 +657,7 @@ mod tests {\n         #[case] glob_regex: &str,\n         #[case] directory_match_regex: &str,\n     ) {\n-        let (glob_re, directory_match_re) = parse(glob).unwrap();\n+        let (glob_re, directory_match_re) = parse(glob, GlobOptions::default()).unwrap();\n         // All our regexes come with a fixed prefix and suffix, just assert and drop them\n         fn strip_overhead(s: String) -> String {\n             assert!(s.starts_with(\"(?-u)^\"));"
        },
        {
            "sha": "c36025f96f11a939cb16494074c075e23ebd3d9f",
            "filename": "turbopack/crates/turbo-tasks-fs/src/read_glob.rs",
            "status": "modified",
            "additions": 20,
            "deletions": 10,
            "changes": 30,
            "blob_url": "https://github.com/vercel/next.js/blob/64e9c8046e4a8e3f8f3a7ac8e1341ad0cbdf0e53/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fread_glob.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/64e9c8046e4a8e3f8f3a7ac8e1341ad0cbdf0e53/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fread_glob.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fread_glob.rs?ref=64e9c8046e4a8e3f8f3a7ac8e1341ad0cbdf0e53",
            "patch": "@@ -237,7 +237,8 @@ pub mod tests {\n     use turbo_tasks_backend::{BackendOptions, TurboTasksBackend, noop_backing_storage};\n \n     use crate::{\n-        DirectoryEntry, DiskFileSystem, FileContent, FileSystem, FileSystemPath, glob::Glob,\n+        DirectoryEntry, DiskFileSystem, FileContent, FileSystem, FileSystemPath,\n+        glob::{Glob, GlobOptions},\n     };\n \n     #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n@@ -265,7 +266,10 @@ pub mod tests {\n         tt.run_once(async {\n             let fs = DiskFileSystem::new(rcstr!(\"temp\"), path);\n             let root = fs.root().await?;\n-            let read_dir = root.read_glob(Glob::new(rcstr!(\"**\"))).await.unwrap();\n+            let read_dir = root\n+                .read_glob(Glob::new(rcstr!(\"**\"), GlobOptions::default()))\n+                .await\n+                .unwrap();\n             assert_eq!(read_dir.results.len(), 2);\n             assert_eq!(\n                 read_dir.results.get(\"foo\"),\n@@ -285,7 +289,10 @@ pub mod tests {\n             assert_eq!(inner.inner.len(), 0);\n \n             // Now with a more specific pattern\n-            let read_dir = root.read_glob(Glob::new(rcstr!(\"**/bar\"))).await.unwrap();\n+            let read_dir = root\n+                .read_glob(Glob::new(rcstr!(\"**/bar\"), GlobOptions::default()))\n+                .await\n+                .unwrap();\n             assert_eq!(read_dir.results.len(), 0);\n             assert_eq!(read_dir.inner.len(), 1);\n             let inner = &*read_dir.inner.get(\"sub\").unwrap().await?;\n@@ -340,7 +347,10 @@ pub mod tests {\n             let fs = DiskFileSystem::new(rcstr!(\"temp\"), path);\n             let root = fs.root().await?;\n             // Symlinked files\n-            let read_dir = root.read_glob(Glob::new(rcstr!(\"sub/*.js\"))).await.unwrap();\n+            let read_dir = root\n+                .read_glob(Glob::new(rcstr!(\"sub/*.js\"), GlobOptions::default()))\n+                .await\n+                .unwrap();\n             assert_eq!(read_dir.results.len(), 0);\n             let inner = &*read_dir.inner.get(\"sub\").unwrap().await?;\n             assert_eq!(\n@@ -364,7 +374,7 @@ pub mod tests {\n \n             // A symlinked folder\n             let read_dir = root\n-                .read_glob(Glob::new(rcstr!(\"sub/dir/*\")))\n+                .read_glob(Glob::new(rcstr!(\"sub/dir/*\"), GlobOptions::default()))\n                 .await\n                 .unwrap();\n             assert_eq!(read_dir.results.len(), 0);\n@@ -403,7 +413,7 @@ pub mod tests {\n \n     #[turbo_tasks::function(operation)]\n     pub fn track_star_star_glob(path: FileSystemPath) -> Vc<Completion> {\n-        path.track_glob(Glob::new(rcstr!(\"**\")), false)\n+        path.track_glob(Glob::new(rcstr!(\"**\"), GlobOptions::default()), false)\n     }\n \n     #[cfg(unix)]\n@@ -523,7 +533,7 @@ pub mod tests {\n             let err = fs\n                 .root()\n                 .await?\n-                .track_glob(Glob::new(rcstr!(\"**\")), false)\n+                .track_glob(Glob::new(rcstr!(\"**\"), GlobOptions::default()), false)\n                 .await\n                 .expect_err(\"Should have detected an infinite loop\");\n \n@@ -536,7 +546,7 @@ pub mod tests {\n             let err = fs\n                 .root()\n                 .await?\n-                .track_glob(Glob::new(rcstr!(\"**\")), false)\n+                .track_glob(Glob::new(rcstr!(\"**\"), GlobOptions::default()), false)\n                 .await\n                 .expect_err(\"Should have detected an infinite loop\");\n \n@@ -579,7 +589,7 @@ pub mod tests {\n             let err = fs\n                 .root()\n                 .await?\n-                .read_glob(Glob::new(rcstr!(\"**\")))\n+                .read_glob(Glob::new(rcstr!(\"**\"), GlobOptions::default()))\n                 .await\n                 .expect_err(\"Should have detected an infinite loop\");\n \n@@ -592,7 +602,7 @@ pub mod tests {\n             let err = fs\n                 .root()\n                 .await?\n-                .track_glob(Glob::new(rcstr!(\"**\")), false)\n+                .track_glob(Glob::new(rcstr!(\"**\"), GlobOptions::default()), false)\n                 .await\n                 .expect_err(\"Should have detected an infinite loop\");\n "
        },
        {
            "sha": "6da2aaaed1239fb4597751112dcc845f4917c007",
            "filename": "turbopack/crates/turbopack-ecmascript/src/chunk/placeable.rs",
            "status": "modified",
            "additions": 9,
            "deletions": 2,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/64e9c8046e4a8e3f8f3a7ac8e1341ad0cbdf0e53/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fchunk%2Fplaceable.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/64e9c8046e4a8e3f8f3a7ac8e1341ad0cbdf0e53/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fchunk%2Fplaceable.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fchunk%2Fplaceable.rs?ref=64e9c8046e4a8e3f8f3a7ac8e1341ad0cbdf0e53",
            "patch": "@@ -1,7 +1,10 @@\n use anyhow::Result;\n use turbo_rcstr::rcstr;\n use turbo_tasks::{ResolvedVc, TryFlatJoinIterExt, Vc};\n-use turbo_tasks_fs::{FileJsonContent, FileSystemPath, glob::Glob};\n+use turbo_tasks_fs::{\n+    FileJsonContent, FileSystemPath,\n+    glob::{Glob, GlobOptions},\n+};\n use turbopack_core::{\n     asset::Asset,\n     chunk::ChunkableModule,\n@@ -66,9 +69,13 @@ async fn side_effects_from_package_json(\n                         if side_effect.contains('/') {\n                             Some(Glob::new(\n                                 side_effect.strip_prefix(\"./\").unwrap_or(side_effect).into(),\n+                                GlobOptions::default(),\n                             ))\n                         } else {\n-                            Some(Glob::new(format!(\"**/{side_effect}\").into()))\n+                            Some(Glob::new(\n+                                format!(\"**/{side_effect}\").into(),\n+                                GlobOptions::default(),\n+                            ))\n                         }\n                     } else {\n                         SideEffectsInPackageJsonIssue {"
        },
        {
            "sha": "54aaea0bf25fe947e3a71318f26bdbcab7b152c9",
            "filename": "turbopack/crates/turbopack-node/src/transforms/webpack.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 2,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/64e9c8046e4a8e3f8f3a7ac8e1341ad0cbdf0e53/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Fwebpack.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/64e9c8046e4a8e3f8f3a7ac8e1341ad0cbdf0e53/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Fwebpack.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Fwebpack.rs?ref=64e9c8046e4a8e3f8f3a7ac8e1341ad0cbdf0e53",
            "patch": "@@ -15,7 +15,10 @@ use turbo_tasks::{\n use turbo_tasks_bytes::stream::SingleValue;\n use turbo_tasks_env::ProcessEnv;\n use turbo_tasks_fs::{\n-    File, FileContent, FileSystemPath, glob::Glob, json::parse_json_with_source_context, rope::Rope,\n+    File, FileContent, FileSystemPath,\n+    glob::{Glob, GlobOptions},\n+    json::parse_json_with_source_context,\n+    rope::Rope,\n };\n use turbopack_core::{\n     asset::{Asset, AssetContent},\n@@ -513,7 +516,7 @@ impl EvaluateContext for WebpackLoaderContext {\n                     .map(|(dir, glob)| async move {\n                         self.cwd\n                             .join(dir)?\n-                            .track_glob(Glob::new(glob.clone()), false)\n+                            .track_glob(Glob::new(glob.clone(), GlobOptions::default()), false)\n                             .await\n                     })\n                     .try_join();"
        },
        {
            "sha": "43c1e64fb2dedeb3a504aa081e514f26ad79e7e2",
            "filename": "turbopack/crates/turbopack/src/lib.rs",
            "status": "modified",
            "additions": 10,
            "deletions": 8,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/64e9c8046e4a8e3f8f3a7ac8e1341ad0cbdf0e53/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/64e9c8046e4a8e3f8f3a7ac8e1341ad0cbdf0e53/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Flib.rs?ref=64e9c8046e4a8e3f8f3a7ac8e1341ad0cbdf0e53",
            "patch": "@@ -26,7 +26,10 @@ use module_options::{ModuleOptions, ModuleOptionsContext, ModuleRuleEffect, Modu\n use tracing::{Instrument, field::Empty};\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{ResolvedVc, ValueToString, Vc};\n-use turbo_tasks_fs::{FileSystemPath, glob::Glob};\n+use turbo_tasks_fs::{\n+    FileSystemPath,\n+    glob::{Glob, GlobOptions},\n+};\n pub use turbopack_core::condition;\n use turbopack_core::{\n     asset::Asset,\n@@ -895,15 +898,14 @@ impl AssetContext for ModuleAssetContext {\n \n     #[turbo_tasks::function]\n     async fn side_effect_free_packages(&self) -> Result<Vc<Glob>> {\n-        let pkgs = &*self.module_options_context.await?.side_effect_free_packages;\n-\n-        let mut globs = Vec::with_capacity(pkgs.len());\n+        let pkgs = &self.module_options_context.await?.side_effect_free_packages;\n \n-        for pkg in pkgs {\n-            globs.push(Glob::new(format!(\"**/node_modules/{{{pkg}}}/**\").into()));\n-        }\n+        let mut globs = String::new();\n+        globs.push_str(\"**/node_modules/{\");\n+        globs.push_str(&pkgs.join(\",\"));\n+        globs.push_str(\"}/**\");\n \n-        Ok(Glob::alternatives(globs))\n+        Ok(Glob::new(globs.into(), GlobOptions::default()))\n     }\n }\n "
        },
        {
            "sha": "85c2e8761926e67f63806aff4a7e24aa54208480",
            "filename": "turbopack/crates/turbopack/src/module_options/mod.rs",
            "status": "modified",
            "additions": 8,
            "deletions": 5,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/64e9c8046e4a8e3f8f3a7ac8e1341ad0cbdf0e53/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/64e9c8046e4a8e3f8f3a7ac8e1341ad0cbdf0e53/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Fmod.rs?ref=64e9c8046e4a8e3f8f3a7ac8e1341ad0cbdf0e53",
            "patch": "@@ -12,7 +12,10 @@ pub use module_rule::*;\n pub use rule_condition::*;\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{ResolvedVc, Vc};\n-use turbo_tasks_fs::{FileSystemPath, glob::Glob};\n+use turbo_tasks_fs::{\n+    FileSystemPath,\n+    glob::{Glob, GlobOptions},\n+};\n use turbopack_core::{\n     chunk::SourceMapsType,\n     ident::Layer,\n@@ -510,11 +513,11 @@ impl ModuleOptions {\n                             if glob.contains('/') {\n                                 rule_conditions.push(RuleCondition::ResourcePathGlob {\n                                     base: execution_context.project_path().owned().await?,\n-                                    glob: Glob::new(glob.clone()).await?,\n+                                    glob: Glob::new(glob.clone(), GlobOptions::default()).await?,\n                                 });\n                             } else {\n                                 rule_conditions.push(RuleCondition::ResourceBasePathGlob(\n-                                    Glob::new(glob.clone()).await?,\n+                                    Glob::new(glob.clone(), GlobOptions::default()).await?,\n                                 ));\n                             }\n                         }\n@@ -529,11 +532,11 @@ impl ModuleOptions {\n                 } else if key.contains('/') {\n                     rule_conditions.push(RuleCondition::ResourcePathGlob {\n                         base: execution_context.project_path().owned().await?,\n-                        glob: Glob::new(key.clone()).await?,\n+                        glob: Glob::new(key.clone(), GlobOptions::default()).await?,\n                     });\n                 } else {\n                     rule_conditions.push(RuleCondition::ResourceBasePathGlob(\n-                        Glob::new(key.clone()).await?,\n+                        Glob::new(key.clone(), GlobOptions::default()).await?,\n                     ));\n                 };\n                 rule_conditions.push(RuleCondition::not(RuleCondition::ResourceIsVirtualSource));"
        }
    ],
    "stats": {
        "total": 303,
        "additions": 221,
        "deletions": 82
    }
}