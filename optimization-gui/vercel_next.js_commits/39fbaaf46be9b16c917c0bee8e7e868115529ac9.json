{
    "author": "delbaoliveira",
    "message": "Docs IA 2.0: Move examples to route.js API reference (#80360)\n\nPart of:\nhttps://linear.app/vercel/issue/DOC-4686/clean-up-routing-section\n\n---------\n\nCo-authored-by: graphite-app[bot] <96075541+graphite-app[bot]@users.noreply.github.com>",
    "sha": "39fbaaf46be9b16c917c0bee8e7e868115529ac9",
    "files": [
        {
            "sha": "4f1a10b0c7899ef5cfa473a426c571e073f5a8d0",
            "filename": "docs/01-app/02-guides/index.mdx",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/39fbaaf46be9b16c917c0bee8e7e868115529ac9/docs%2F01-app%2F02-guides%2Findex.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/39fbaaf46be9b16c917c0bee8e7e868115529ac9/docs%2F01-app%2F02-guides%2Findex.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F02-guides%2Findex.mdx?ref=39fbaaf46be9b16c917c0bee8e7e868115529ac9",
            "patch": "@@ -34,7 +34,7 @@ description: Learn how to implement common UI patterns and use cases using Next.\n \n ### Metadata\n \n-- [Creating an RSS feed](/docs/app/building-your-application/routing/route-handlers#non-ui-responses)\n+- [Creating an RSS feed](/docs/app/api-reference/file-conventions/route#non-ui-responses)\n - [Creating an Open Graph image](/docs/app/api-reference/file-conventions/metadata/opengraph-image)\n - [Creating a sitemap](/docs/app/api-reference/file-conventions/metadata/sitemap)\n - [Creating a robots.txt file](/docs/app/api-reference/file-conventions/metadata/robots)"
        },
        {
            "sha": "481fd8d066886d42dc1d22b85646e127ed7faa82",
            "filename": "docs/01-app/03-building-your-application/01-routing/13-route-handlers.mdx",
            "status": "modified",
            "additions": 0,
            "deletions": 493,
            "changes": 493,
            "blob_url": "https://github.com/vercel/next.js/blob/39fbaaf46be9b16c917c0bee8e7e868115529ac9/docs%2F01-app%2F03-building-your-application%2F01-routing%2F13-route-handlers.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/39fbaaf46be9b16c917c0bee8e7e868115529ac9/docs%2F01-app%2F03-building-your-application%2F01-routing%2F13-route-handlers.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-building-your-application%2F01-routing%2F13-route-handlers.mdx?ref=39fbaaf46be9b16c917c0bee8e7e868115529ac9",
            "patch": "@@ -120,496 +120,3 @@ export default function Page() {\n // `app/route.js`\n export async function POST(request) {}\n ```\n-\n-## Examples\n-\n-The following examples show how to combine Route Handlers with other Next.js APIs and features.\n-\n-### Revalidating Cached Data\n-\n-You can [revalidate cached data](/docs/app/guides/incremental-static-regeneration) using Incremental Static Regeneration (ISR):\n-\n-```ts filename=\"app/posts/route.ts\" switcher\n-export const revalidate = 60\n-\n-export async function GET() {\n-  const data = await fetch('https://api.vercel.app/blog')\n-  const posts = await data.json()\n-\n-  return Response.json(posts)\n-}\n-```\n-\n-```js filename=\"app/posts/route.js\" switcher\n-export const revalidate = 60\n-\n-export async function GET() {\n-  const data = await fetch('https://api.vercel.app/blog')\n-  const posts = await data.json()\n-\n-  return Response.json(posts)\n-}\n-```\n-\n-### Cookies\n-\n-You can read or set cookies with [`cookies`](/docs/app/api-reference/functions/cookies) from `next/headers`. This server function can be called directly in a Route Handler, or nested inside of another function.\n-\n-Alternatively, you can return a new `Response` using the [`Set-Cookie`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Set-Cookie) header.\n-\n-```ts filename=\"app/api/route.ts\" switcher\n-import { cookies } from 'next/headers'\n-\n-export async function GET(request: Request) {\n-  const cookieStore = await cookies()\n-  const token = cookieStore.get('token')\n-\n-  return new Response('Hello, Next.js!', {\n-    status: 200,\n-    headers: { 'Set-Cookie': `token=${token.value}` },\n-  })\n-}\n-```\n-\n-```js filename=\"app/api/route.js\" switcher\n-import { cookies } from 'next/headers'\n-\n-export async function GET(request) {\n-  const cookieStore = await cookies()\n-  const token = cookieStore.get('token')\n-\n-  return new Response('Hello, Next.js!', {\n-    status: 200,\n-    headers: { 'Set-Cookie': `token=${token}` },\n-  })\n-}\n-```\n-\n-You can also use the underlying Web APIs to read cookies from the request ([`NextRequest`](/docs/app/api-reference/functions/next-request)):\n-\n-```ts filename=\"app/api/route.ts\" switcher\n-import { type NextRequest } from 'next/server'\n-\n-export async function GET(request: NextRequest) {\n-  const token = request.cookies.get('token')\n-}\n-```\n-\n-```js filename=\"app/api/route.js\" switcher\n-export async function GET(request) {\n-  const token = request.cookies.get('token')\n-}\n-```\n-\n-### Headers\n-\n-You can read headers with [`headers`](/docs/app/api-reference/functions/headers) from `next/headers`. This server function can be called directly in a Route Handler, or nested inside of another function.\n-\n-This `headers` instance is read-only. To set headers, you need to return a new `Response` with new `headers`.\n-\n-```ts filename=\"app/api/route.ts\" switcher\n-import { headers } from 'next/headers'\n-\n-export async function GET(request: Request) {\n-  const headersList = await headers()\n-  const referer = headersList.get('referer')\n-\n-  return new Response('Hello, Next.js!', {\n-    status: 200,\n-    headers: { referer: referer },\n-  })\n-}\n-```\n-\n-```js filename=\"app/api/route.js\" switcher\n-import { headers } from 'next/headers'\n-\n-export async function GET(request) {\n-  const headersList = await headers()\n-  const referer = headersList.get('referer')\n-\n-  return new Response('Hello, Next.js!', {\n-    status: 200,\n-    headers: { referer: referer },\n-  })\n-}\n-```\n-\n-You can also use the underlying Web APIs to read headers from the request ([`NextRequest`](/docs/app/api-reference/functions/next-request)):\n-\n-```ts filename=\"app/api/route.ts\" switcher\n-import { type NextRequest } from 'next/server'\n-\n-export async function GET(request: NextRequest) {\n-  const requestHeaders = new Headers(request.headers)\n-}\n-```\n-\n-```js filename=\"app/api/route.js\" switcher\n-export async function GET(request) {\n-  const requestHeaders = new Headers(request.headers)\n-}\n-```\n-\n-### Redirects\n-\n-```ts filename=\"app/api/route.ts\" switcher\n-import { redirect } from 'next/navigation'\n-\n-export async function GET(request: Request) {\n-  redirect('https://nextjs.org/')\n-}\n-```\n-\n-```js filename=\"app/api/route.js\" switcher\n-import { redirect } from 'next/navigation'\n-\n-export async function GET(request) {\n-  redirect('https://nextjs.org/')\n-}\n-```\n-\n-### Dynamic Route Segments\n-\n-Route Handlers can use [Dynamic Segments](/docs/app/api-reference/file-conventions/dynamic-routes) to create request handlers from dynamic data.\n-\n-```ts filename=\"app/items/[slug]/route.ts\" switcher\n-export async function GET(\n-  request: Request,\n-  { params }: { params: Promise<{ slug: string }> }\n-) {\n-  const { slug } = await params // 'a', 'b', or 'c'\n-}\n-```\n-\n-```js filename=\"app/items/[slug]/route.js\" switcher\n-export async function GET(request, { params }) {\n-  const { slug } = await params // 'a', 'b', or 'c'\n-}\n-```\n-\n-| Route                       | Example URL | `params`                 |\n-| --------------------------- | ----------- | ------------------------ |\n-| `app/items/[slug]/route.js` | `/items/a`  | `Promise<{ slug: 'a' }>` |\n-| `app/items/[slug]/route.js` | `/items/b`  | `Promise<{ slug: 'b' }>` |\n-| `app/items/[slug]/route.js` | `/items/c`  | `Promise<{ slug: 'c' }>` |\n-\n-### URL Query Parameters\n-\n-The request object passed to the Route Handler is a `NextRequest` instance, which includes [some additional convenience methods](/docs/app/api-reference/functions/next-request#nexturl), such as those for more easily handling query parameters.\n-\n-```ts filename=\"app/api/search/route.ts\" switcher\n-import { type NextRequest } from 'next/server'\n-\n-export function GET(request: NextRequest) {\n-  const searchParams = request.nextUrl.searchParams\n-  const query = searchParams.get('query')\n-  // query is \"hello\" for /api/search?query=hello\n-}\n-```\n-\n-```js filename=\"app/api/search/route.js\" switcher\n-export function GET(request) {\n-  const searchParams = request.nextUrl.searchParams\n-  const query = searchParams.get('query')\n-  // query is \"hello\" for /api/search?query=hello\n-}\n-```\n-\n-### Streaming\n-\n-Streaming is commonly used in combination with Large Language Models (LLMs), such as OpenAI, for AI-generated content. Learn more about the [AI SDK](https://sdk.vercel.ai/docs/introduction).\n-\n-```ts filename=\"app/api/chat/route.ts\" switcher\n-import { openai } from '@ai-sdk/openai'\n-import { StreamingTextResponse, streamText } from 'ai'\n-\n-export async function POST(req: Request) {\n-  const { messages } = await req.json()\n-  const result = await streamText({\n-    model: openai('gpt-4-turbo'),\n-    messages,\n-  })\n-\n-  return new StreamingTextResponse(result.toAIStream())\n-}\n-```\n-\n-```js filename=\"app/api/chat/route.js\" switcher\n-import { openai } from '@ai-sdk/openai'\n-import { StreamingTextResponse, streamText } from 'ai'\n-\n-export async function POST(req) {\n-  const { messages } = await req.json()\n-  const result = await streamText({\n-    model: openai('gpt-4-turbo'),\n-    messages,\n-  })\n-\n-  return new StreamingTextResponse(result.toAIStream())\n-}\n-```\n-\n-These abstractions use the Web APIs to create a stream. You can also use the underlying Web APIs directly.\n-\n-```ts filename=\"app/api/route.ts\" switcher\n-// https://developer.mozilla.org/docs/Web/API/ReadableStream#convert_async_iterator_to_stream\n-function iteratorToStream(iterator: any) {\n-  return new ReadableStream({\n-    async pull(controller) {\n-      const { value, done } = await iterator.next()\n-\n-      if (done) {\n-        controller.close()\n-      } else {\n-        controller.enqueue(value)\n-      }\n-    },\n-  })\n-}\n-\n-function sleep(time: number) {\n-  return new Promise((resolve) => {\n-    setTimeout(resolve, time)\n-  })\n-}\n-\n-const encoder = new TextEncoder()\n-\n-async function* makeIterator() {\n-  yield encoder.encode('<p>One</p>')\n-  await sleep(200)\n-  yield encoder.encode('<p>Two</p>')\n-  await sleep(200)\n-  yield encoder.encode('<p>Three</p>')\n-}\n-\n-export async function GET() {\n-  const iterator = makeIterator()\n-  const stream = iteratorToStream(iterator)\n-\n-  return new Response(stream)\n-}\n-```\n-\n-```js filename=\"app/api/route.js\" switcher\n-// https://developer.mozilla.org/docs/Web/API/ReadableStream#convert_async_iterator_to_stream\n-function iteratorToStream(iterator) {\n-  return new ReadableStream({\n-    async pull(controller) {\n-      const { value, done } = await iterator.next()\n-\n-      if (done) {\n-        controller.close()\n-      } else {\n-        controller.enqueue(value)\n-      }\n-    },\n-  })\n-}\n-\n-function sleep(time) {\n-  return new Promise((resolve) => {\n-    setTimeout(resolve, time)\n-  })\n-}\n-\n-const encoder = new TextEncoder()\n-\n-async function* makeIterator() {\n-  yield encoder.encode('<p>One</p>')\n-  await sleep(200)\n-  yield encoder.encode('<p>Two</p>')\n-  await sleep(200)\n-  yield encoder.encode('<p>Three</p>')\n-}\n-\n-export async function GET() {\n-  const iterator = makeIterator()\n-  const stream = iteratorToStream(iterator)\n-\n-  return new Response(stream)\n-}\n-```\n-\n-### Request Body\n-\n-You can read the `Request` body using the standard Web API methods:\n-\n-```ts filename=\"app/items/route.ts\" switcher\n-export async function POST(request: Request) {\n-  const res = await request.json()\n-  return Response.json({ res })\n-}\n-```\n-\n-```js filename=\"app/items/route.js\" switcher\n-export async function POST(request) {\n-  const res = await request.json()\n-  return Response.json({ res })\n-}\n-```\n-\n-### Request Body FormData\n-\n-You can read the `FormData` using the `request.formData()` function:\n-\n-```ts filename=\"app/items/route.ts\" switcher\n-export async function POST(request: Request) {\n-  const formData = await request.formData()\n-  const name = formData.get('name')\n-  const email = formData.get('email')\n-  return Response.json({ name, email })\n-}\n-```\n-\n-```js filename=\"app/items/route.js\" switcher\n-export async function POST(request) {\n-  const formData = await request.formData()\n-  const name = formData.get('name')\n-  const email = formData.get('email')\n-  return Response.json({ name, email })\n-}\n-```\n-\n-Since `formData` data are all strings, you may want to use [`zod-form-data`](https://www.npmjs.com/zod-form-data) to validate the request and retrieve data in the format you prefer (e.g. `number`).\n-\n-### CORS\n-\n-You can set CORS headers for a specific Route Handler using the standard Web API methods:\n-\n-```ts filename=\"app/api/route.ts\" switcher\n-export async function GET(request: Request) {\n-  return new Response('Hello, Next.js!', {\n-    status: 200,\n-    headers: {\n-      'Access-Control-Allow-Origin': '*',\n-      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\n-      'Access-Control-Allow-Headers': 'Content-Type, Authorization',\n-    },\n-  })\n-}\n-```\n-\n-```js filename=\"app/api/route.js\" switcher\n-export async function GET(request) {\n-  return new Response('Hello, Next.js!', {\n-    status: 200,\n-    headers: {\n-      'Access-Control-Allow-Origin': '*',\n-      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\n-      'Access-Control-Allow-Headers': 'Content-Type, Authorization',\n-    },\n-  })\n-}\n-```\n-\n-> **Good to know**:\n->\n-> - To add CORS headers to multiple Route Handlers, you can use [Middleware](/docs/app/building-your-application/routing/middleware#cors) or the [`next.config.js` file](/docs/app/api-reference/config/next-config-js/headers#cors).\n-> - Alternatively, see our [CORS example](https://github.com/vercel/examples/blob/main/edge-functions/cors/lib/cors.ts) package.\n-\n-### Webhooks\n-\n-You can use a Route Handler to receive webhooks from third-party services:\n-\n-```ts filename=\"app/api/route.ts\" switcher\n-export async function POST(request: Request) {\n-  try {\n-    const text = await request.text()\n-    // Process the webhook payload\n-  } catch (error) {\n-    return new Response(`Webhook error: ${error.message}`, {\n-      status: 400,\n-    })\n-  }\n-\n-  return new Response('Success!', {\n-    status: 200,\n-  })\n-}\n-```\n-\n-```js filename=\"app/api/route.js\" switcher\n-export async function POST(request) {\n-  try {\n-    const text = await request.text()\n-    // Process the webhook payload\n-  } catch (error) {\n-    return new Response(`Webhook error: ${error.message}`, {\n-      status: 400,\n-    })\n-  }\n-\n-  return new Response('Success!', {\n-    status: 200,\n-  })\n-}\n-```\n-\n-Notably, unlike API Routes with the Pages Router, you do not need to use `bodyParser` to use any additional configuration.\n-\n-### Non-UI Responses\n-\n-You can use Route Handlers to return non-UI content. Note that [`sitemap.xml`](/docs/app/api-reference/file-conventions/metadata/sitemap#generating-a-sitemap-using-code-js-ts), [`robots.txt`](/docs/app/api-reference/file-conventions/metadata/robots#generate-a-robots-file), [`app icons`](/docs/app/api-reference/file-conventions/metadata/app-icons#generate-icons-using-code-js-ts-tsx), and [open graph images](/docs/app/api-reference/file-conventions/metadata/opengraph-image) all have built-in support.\n-\n-```ts filename=\"app/rss.xml/route.ts\" switcher\n-export async function GET() {\n-  return new Response(\n-    `<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n-<rss version=\"2.0\">\n-\n-<channel>\n-  <title>Next.js Documentation</title>\n-  <link>https://nextjs.org/docs</link>\n-  <description>The React Framework for the Web</description>\n-</channel>\n-\n-</rss>`,\n-    {\n-      headers: {\n-        'Content-Type': 'text/xml',\n-      },\n-    }\n-  )\n-}\n-```\n-\n-```js filename=\"app/rss.xml/route.js\" switcher\n-export async function GET() {\n-  return new Response(`<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n-<rss version=\"2.0\">\n-\n-<channel>\n-  <title>Next.js Documentation</title>\n-  <link>https://nextjs.org/docs</link>\n-  <description>The React Framework for the Web</description>\n-</channel>\n-\n-</rss>`)\n-}\n-```\n-\n-### Segment Config Options\n-\n-Route Handlers use the same [route segment configuration](/docs/app/api-reference/file-conventions/route-segment-config) as pages and layouts.\n-\n-```ts filename=\"app/items/route.ts\" switcher\n-export const dynamic = 'auto'\n-export const dynamicParams = true\n-export const revalidate = false\n-export const fetchCache = 'auto'\n-export const runtime = 'nodejs'\n-export const preferredRegion = 'auto'\n-```\n-\n-```js filename=\"app/items/route.js\" switcher\n-export const dynamic = 'auto'\n-export const dynamicParams = true\n-export const revalidate = false\n-export const fetchCache = 'auto'\n-export const runtime = 'nodejs'\n-export const preferredRegion = 'auto'\n-```\n-\n-See the [API reference](/docs/app/api-reference/file-conventions/route-segment-config) for more details."
        },
        {
            "sha": "e138ca25e1e4795fbfeb3869fcd59dd5df5fe885",
            "filename": "docs/01-app/03-building-your-application/01-routing/14-middleware.mdx",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/39fbaaf46be9b16c917c0bee8e7e868115529ac9/docs%2F01-app%2F03-building-your-application%2F01-routing%2F14-middleware.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/39fbaaf46be9b16c917c0bee8e7e868115529ac9/docs%2F01-app%2F03-building-your-application%2F01-routing%2F14-middleware.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-building-your-application%2F01-routing%2F14-middleware.mdx?ref=39fbaaf46be9b16c917c0bee8e7e868115529ac9",
            "patch": "@@ -441,7 +441,7 @@ export const config = {\n \n <AppOnly>\n \n-> **Good to know:** You can configure CORS headers for individual routes in [Route Handlers](/docs/app/building-your-application/routing/route-handlers#cors).\n+> **Good to know:** You can configure CORS headers for individual routes in [Route Handlers](/docs/app/api-reference/file-conventions/route#cors).\n \n </AppOnly>\n "
        },
        {
            "sha": "99c9de92930b43a01c0ee0b19e489d5b77449dea",
            "filename": "docs/01-app/05-api-reference/03-file-conventions/route.mdx",
            "status": "modified",
            "additions": 507,
            "deletions": 1,
            "changes": 508,
            "blob_url": "https://github.com/vercel/next.js/blob/39fbaaf46be9b16c917c0bee8e7e868115529ac9/docs%2F01-app%2F05-api-reference%2F03-file-conventions%2Froute.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/39fbaaf46be9b16c917c0bee8e7e868115529ac9/docs%2F01-app%2F05-api-reference%2F03-file-conventions%2Froute.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F05-api-reference%2F03-file-conventions%2Froute.mdx?ref=39fbaaf46be9b16c917c0bee8e7e868115529ac9",
            "patch": "@@ -104,7 +104,9 @@ export async function GET(request, { params }) {\n \n ## Examples\n \n-### Handling cookies\n+### Cookies\n+\n+You can read or set cookies with [`cookies`](/docs/app/api-reference/functions/cookies) from `next/headers`.\n \n ```ts filename=\"route.ts\" switcher\n import { cookies } from 'next/headers'\n@@ -130,6 +132,510 @@ export async function GET(request) {\n }\n ```\n \n+Alternatively, you can return a new `Response` using the [`Set-Cookie`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Set-Cookie) header.\n+\n+```ts filename=\"app/api/route.ts\" switcher\n+import { cookies } from 'next/headers'\n+\n+export async function GET(request: Request) {\n+  const cookieStore = await cookies()\n+  const token = cookieStore.get('token')\n+\n+  return new Response('Hello, Next.js!', {\n+    status: 200,\n+    headers: { 'Set-Cookie': `token=${token.value}` },\n+  })\n+}\n+```\n+\n+```js filename=\"app/api/route.js\" switcher\n+import { cookies } from 'next/headers'\n+\n+export async function GET(request) {\n+  const cookieStore = await cookies()\n+  const token = cookieStore.get('token')\n+\n+  return new Response('Hello, Next.js!', {\n+    status: 200,\n+    headers: { 'Set-Cookie': `token=${token.value}` },\n+  })\n+}\n+```\n+\n+You can also use the underlying Web APIs to read cookies from the request ([`NextRequest`](/docs/app/api-reference/functions/next-request)):\n+\n+```ts filename=\"app/api/route.ts\" switcher\n+import { type NextRequest } from 'next/server'\n+\n+export async function GET(request: NextRequest) {\n+  const token = request.cookies.get('token')\n+}\n+```\n+\n+```js filename=\"app/api/route.js\" switcher\n+export async function GET(request) {\n+  const token = request.cookies.get('token')\n+}\n+```\n+\n+### Headers\n+\n+You can read headers with [`headers`](/docs/app/api-reference/functions/headers) from `next/headers`.\n+\n+```ts filename=\"route.ts\" switcher\n+import { headers } from 'next/headers'\n+import type { NextRequest } from 'next/server'\n+\n+export async function GET(request: NextRequest) {\n+  const headersList = await headers()\n+  const referer = headersList.get('referer')\n+}\n+```\n+\n+```js filename=\"route.js\" switcher\n+import { headers } from 'next/headers'\n+\n+export async function GET(request) {\n+  const headersList = await headers()\n+  const referer = headersList.get('referer')\n+}\n+```\n+\n+This `headers` instance is read-only. To set headers, you need to return a new `Response` with new `headers`.\n+\n+```ts filename=\"app/api/route.ts\" switcher\n+import { headers } from 'next/headers'\n+\n+export async function GET(request: Request) {\n+  const headersList = await headers()\n+  const referer = headersList.get('referer')\n+\n+  return new Response('Hello, Next.js!', {\n+    status: 200,\n+    headers: { referer: referer },\n+  })\n+}\n+```\n+\n+```js filename=\"app/api/route.js\" switcher\n+import { headers } from 'next/headers'\n+\n+export async function GET(request) {\n+  const headersList = await headers()\n+  const referer = headersList.get('referer')\n+\n+  return new Response('Hello, Next.js!', {\n+    status: 200,\n+    headers: { referer: referer },\n+  })\n+}\n+```\n+\n+You can also use the underlying Web APIs to read headers from the request ([`NextRequest`](/docs/app/api-reference/functions/next-request)):\n+\n+```ts filename=\"app/api/route.ts\" switcher\n+import { type NextRequest } from 'next/server'\n+\n+export async function GET(request: NextRequest) {\n+  const requestHeaders = new Headers(request.headers)\n+}\n+```\n+\n+```js filename=\"app/api/route.js\" switcher\n+export async function GET(request) {\n+  const requestHeaders = new Headers(request.headers)\n+}\n+```\n+\n+### Revalidating Cached Data\n+\n+You can [revalidate cached data](/docs/app/guides/incremental-static-regeneration) using the `revalidate` route segment config option.\n+\n+```ts filename=\"app/posts/route.ts\" switcher\n+export const revalidate = 60\n+\n+export async function GET() {\n+  const data = await fetch('https://api.vercel.app/blog')\n+  const posts = await data.json()\n+\n+  return Response.json(posts)\n+}\n+```\n+\n+```js filename=\"app/posts/route.js\" switcher\n+export const revalidate = 60\n+\n+export async function GET() {\n+  const data = await fetch('https://api.vercel.app/blog')\n+  const posts = await data.json()\n+\n+  return Response.json(posts)\n+}\n+```\n+\n+### Redirects\n+\n+```ts filename=\"app/api/route.ts\" switcher\n+import { redirect } from 'next/navigation'\n+\n+export async function GET(request: Request) {\n+  redirect('https://nextjs.org/')\n+}\n+```\n+\n+```js filename=\"app/api/route.js\" switcher\n+import { redirect } from 'next/navigation'\n+\n+export async function GET(request) {\n+  redirect('https://nextjs.org/')\n+}\n+```\n+\n+### Dynamic Route Segments\n+\n+Route Handlers can use [Dynamic Segments](/docs/app/api-reference/file-conventions/dynamic-routes) to create request handlers from dynamic data.\n+\n+```ts filename=\"app/items/[slug]/route.ts\" switcher\n+export async function GET(\n+  request: Request,\n+  { params }: { params: Promise<{ slug: string }> }\n+) {\n+  const { slug } = await params // 'a', 'b', or 'c'\n+}\n+```\n+\n+```js filename=\"app/items/[slug]/route.js\" switcher\n+export async function GET(request, { params }) {\n+  const { slug } = await params // 'a', 'b', or 'c'\n+}\n+```\n+\n+| Route                       | Example URL | `params`                 |\n+| --------------------------- | ----------- | ------------------------ |\n+| `app/items/[slug]/route.js` | `/items/a`  | `Promise<{ slug: 'a' }>` |\n+| `app/items/[slug]/route.js` | `/items/b`  | `Promise<{ slug: 'b' }>` |\n+| `app/items/[slug]/route.js` | `/items/c`  | `Promise<{ slug: 'c' }>` |\n+\n+### URL Query Parameters\n+\n+The request object passed to the Route Handler is a `NextRequest` instance, which includes [some additional convenience methods](/docs/app/api-reference/functions/next-request#nexturl), such as those for more easily handling query parameters.\n+\n+```ts filename=\"app/api/search/route.ts\" switcher\n+import { type NextRequest } from 'next/server'\n+\n+export function GET(request: NextRequest) {\n+  const searchParams = request.nextUrl.searchParams\n+  const query = searchParams.get('query')\n+  // query is \"hello\" for /api/search?query=hello\n+}\n+```\n+\n+```js filename=\"app/api/search/route.js\" switcher\n+export function GET(request) {\n+  const searchParams = request.nextUrl.searchParams\n+  const query = searchParams.get('query')\n+  // query is \"hello\" for /api/search?query=hello\n+}\n+```\n+\n+### Streaming\n+\n+Streaming is commonly used in combination with Large Language Models (LLMs), such as OpenAI, for AI-generated content. Learn more about the [AI SDK](https://sdk.vercel.ai/docs/introduction).\n+\n+```ts filename=\"app/api/chat/route.ts\" switcher\n+import { openai } from '@ai-sdk/openai'\n+import { StreamingTextResponse, streamText } from 'ai'\n+\n+export async function POST(req: Request) {\n+  const { messages } = await req.json()\n+  const result = await streamText({\n+    model: openai('gpt-4-turbo'),\n+    messages,\n+  })\n+\n+  return new StreamingTextResponse(result.toAIStream())\n+}\n+```\n+\n+```js filename=\"app/api/chat/route.js\" switcher\n+import { openai } from '@ai-sdk/openai'\n+import { StreamingTextResponse, streamText } from 'ai'\n+\n+export async function POST(req) {\n+  const { messages } = await req.json()\n+  const result = await streamText({\n+    model: openai('gpt-4-turbo'),\n+    messages,\n+  })\n+\n+  return new StreamingTextResponse(result.toAIStream())\n+}\n+```\n+\n+These abstractions use the Web APIs to create a stream. You can also use the underlying Web APIs directly.\n+\n+```ts filename=\"app/api/route.ts\" switcher\n+// https://developer.mozilla.org/docs/Web/API/ReadableStream#convert_async_iterator_to_stream\n+function iteratorToStream(iterator: any) {\n+  return new ReadableStream({\n+    async pull(controller) {\n+      const { value, done } = await iterator.next()\n+\n+      if (done) {\n+        controller.close()\n+      } else {\n+        controller.enqueue(value)\n+      }\n+    },\n+  })\n+}\n+\n+function sleep(time: number) {\n+  return new Promise((resolve) => {\n+    setTimeout(resolve, time)\n+  })\n+}\n+\n+const encoder = new TextEncoder()\n+\n+async function* makeIterator() {\n+  yield encoder.encode('<p>One</p>')\n+  await sleep(200)\n+  yield encoder.encode('<p>Two</p>')\n+  await sleep(200)\n+  yield encoder.encode('<p>Three</p>')\n+}\n+\n+export async function GET() {\n+  const iterator = makeIterator()\n+  const stream = iteratorToStream(iterator)\n+\n+  return new Response(stream)\n+}\n+```\n+\n+```js filename=\"app/api/route.js\" switcher\n+// https://developer.mozilla.org/docs/Web/API/ReadableStream#convert_async_iterator_to_stream\n+function iteratorToStream(iterator) {\n+  return new ReadableStream({\n+    async pull(controller) {\n+      const { value, done } = await iterator.next()\n+\n+      if (done) {\n+        controller.close()\n+      } else {\n+        controller.enqueue(value)\n+      }\n+    },\n+  })\n+}\n+\n+function sleep(time) {\n+  return new Promise((resolve) => {\n+    setTimeout(resolve, time)\n+  })\n+}\n+\n+const encoder = new TextEncoder()\n+\n+async function* makeIterator() {\n+  yield encoder.encode('<p>One</p>')\n+  await sleep(200)\n+  yield encoder.encode('<p>Two</p>')\n+  await sleep(200)\n+  yield encoder.encode('<p>Three</p>')\n+}\n+\n+export async function GET() {\n+  const iterator = makeIterator()\n+  const stream = iteratorToStream(iterator)\n+\n+  return new Response(stream)\n+}\n+```\n+\n+### Request Body\n+\n+You can read the `Request` body using the standard Web API methods:\n+\n+```ts filename=\"app/items/route.ts\" switcher\n+export async function POST(request: Request) {\n+  const res = await request.json()\n+  return Response.json({ res })\n+}\n+```\n+\n+```js filename=\"app/items/route.js\" switcher\n+export async function POST(request) {\n+  const res = await request.json()\n+  return Response.json({ res })\n+}\n+```\n+\n+### Request Body FormData\n+\n+You can read the `FormData` using the `request.formData()` function:\n+\n+```ts filename=\"app/items/route.ts\" switcher\n+export async function POST(request: Request) {\n+  const formData = await request.formData()\n+  const name = formData.get('name')\n+  const email = formData.get('email')\n+  return Response.json({ name, email })\n+}\n+```\n+\n+```js filename=\"app/items/route.js\" switcher\n+export async function POST(request) {\n+  const formData = await request.formData()\n+  const name = formData.get('name')\n+  const email = formData.get('email')\n+  return Response.json({ name, email })\n+}\n+```\n+\n+Since `formData` data are all strings, you may want to use [`zod-form-data`](https://www.npmjs.com/zod-form-data) to validate the request and retrieve data in the format you prefer (e.g. `number`).\n+\n+### CORS\n+\n+You can set CORS headers for a specific Route Handler using the standard Web API methods:\n+\n+```ts filename=\"app/api/route.ts\" switcher\n+export async function GET(request: Request) {\n+  return new Response('Hello, Next.js!', {\n+    status: 200,\n+    headers: {\n+      'Access-Control-Allow-Origin': '*',\n+      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\n+      'Access-Control-Allow-Headers': 'Content-Type, Authorization',\n+    },\n+  })\n+}\n+```\n+\n+```js filename=\"app/api/route.js\" switcher\n+export async function GET(request) {\n+  return new Response('Hello, Next.js!', {\n+    status: 200,\n+    headers: {\n+      'Access-Control-Allow-Origin': '*',\n+      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\n+      'Access-Control-Allow-Headers': 'Content-Type, Authorization',\n+    },\n+  })\n+}\n+```\n+\n+> **Good to know**:\n+>\n+> - To add CORS headers to multiple Route Handlers, you can use [Middleware](/docs/app/building-your-application/routing/middleware#cors) or the [`next.config.js` file](/docs/app/api-reference/config/next-config-js/headers#cors).\n+> - Alternatively, see our [CORS example](https://github.com/vercel/examples/blob/main/edge-functions/cors/lib/cors.ts) package.\n+\n+### Webhooks\n+\n+You can use a Route Handler to receive webhooks from third-party services:\n+\n+```ts filename=\"app/api/route.ts\" switcher\n+export async function POST(request: Request) {\n+  try {\n+    const text = await request.text()\n+    // Process the webhook payload\n+  } catch (error) {\n+    return new Response(`Webhook error: ${error.message}`, {\n+      status: 400,\n+    })\n+  }\n+\n+  return new Response('Success!', {\n+    status: 200,\n+  })\n+}\n+```\n+\n+```js filename=\"app/api/route.js\" switcher\n+export async function POST(request) {\n+  try {\n+    const text = await request.text()\n+    // Process the webhook payload\n+  } catch (error) {\n+    return new Response(`Webhook error: ${error.message}`, {\n+      status: 400,\n+    })\n+  }\n+\n+  return new Response('Success!', {\n+    status: 200,\n+  })\n+}\n+```\n+\n+Notably, unlike API Routes with the Pages Router, you do not need to use `bodyParser` to use any additional configuration.\n+\n+### Non-UI Responses\n+\n+You can use Route Handlers to return non-UI content. Note that [`sitemap.xml`](/docs/app/api-reference/file-conventions/metadata/sitemap#generating-a-sitemap-using-code-js-ts), [`robots.txt`](/docs/app/api-reference/file-conventions/metadata/robots#generate-a-robots-file), [`app icons`](/docs/app/api-reference/file-conventions/metadata/app-icons#generate-icons-using-code-js-ts-tsx), and [open graph images](/docs/app/api-reference/file-conventions/metadata/opengraph-image) all have built-in support.\n+\n+```ts filename=\"app/rss.xml/route.ts\" switcher\n+export async function GET() {\n+  return new Response(\n+    `<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n+<rss version=\"2.0\">\n+\n+<channel>\n+  <title>Next.js Documentation</title>\n+  <link>https://nextjs.org/docs</link>\n+  <description>The React Framework for the Web</description>\n+</channel>\n+\n+</rss>`,\n+    {\n+      headers: {\n+        'Content-Type': 'text/xml',\n+      },\n+    }\n+  )\n+}\n+```\n+\n+```js filename=\"app/rss.xml/route.js\" switcher\n+export async function GET() {\n+  return new Response(`<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n+<rss version=\"2.0\">\n+\n+<channel>\n+  <title>Next.js Documentation</title>\n+  <link>https://nextjs.org/docs</link>\n+  <description>The React Framework for the Web</description>\n+</channel>\n+\n+</rss>`)\n+}\n+```\n+\n+### Segment Config Options\n+\n+Route Handlers use the same [route segment configuration](/docs/app/api-reference/file-conventions/route-segment-config) as pages and layouts.\n+\n+```ts filename=\"app/items/route.ts\" switcher\n+export const dynamic = 'auto'\n+export const dynamicParams = true\n+export const revalidate = false\n+export const fetchCache = 'auto'\n+export const runtime = 'nodejs'\n+export const preferredRegion = 'auto'\n+```\n+\n+```js filename=\"app/items/route.js\" switcher\n+export const dynamic = 'auto'\n+export const dynamicParams = true\n+export const revalidate = false\n+export const fetchCache = 'auto'\n+export const runtime = 'nodejs'\n+export const preferredRegion = 'auto'\n+```\n+\n+See the [API reference](/docs/app/api-reference/file-conventions/route-segment-config) for more details.\n+\n ## Version History\n \n | Version      | Changes                                                                                              |"
        }
    ],
    "stats": {
        "total": 1005,
        "additions": 509,
        "deletions": 496
    }
}