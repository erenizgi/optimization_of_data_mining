{
    "author": "bgw",
    "message": "Turbopack: Add `turbo-frozenmap` crate with `FrozenMap` and `FrozenSet` implementations (#87042)\n\nThis implements a `FrozenMap` type as a flat sorted boxed slice of `(K, V)` tuples.\n\nThis is intended to be used with `TaskInput`s and `turbo_task::Value`s, where the data is stored immutably, and where we already try to call `shrink_to_fit`.\n\nThis map is smaller than `HashMap` or `BTreeMap`, and provides `O(log n)` lookups with excellent cache locality (so it's probably faster than `HashMap` in most cases).\n\nSince the map is sorted, equality doesn't care about order, so this is a better implementation of `Eq` for our use-cases than what `IndexMap` provides.\n\nIt has a variety of ways it can be constructed: A `HashMap`, a `Vec<(K, V)>`, a `BTreeMap`, etc. There are pros and cons of all of these:\n- `Vec<(K, V)>` is good if you don't need lookups until after freezing, and you don't expect many duplicates, since sorting at the end is cheaper than maintaining a map.\n- A `BTreeMap` is good if you need a real map, because we can avoid a sort at the end.\n- `HashMap`/`IndexMap` are okay if you're getting this data structure from somewhere else.\n\n`IndexSet` is also provided as a thin wrapper around `IndexMap`.\n\n## Remaining Issues\n\nThis can't be used with `ResolvedVc` as keys, because `ResolvedVc` does not implement `Ord`. I think it should be okay to do that because it's no worse than our current implementations of `Eq` and `Hash`, but I know this is contentious, so I'm leaving it out of this PR.\n\n## Implementation Strategy\n\nI used Claude Code to write most of this:\n\n- Provided it rust's stdlib implementation of BTreeMap.\n- Asked it to extract the public interface into a separate file, excluding nightly-only features.\n- Asked it to remove all `&mut` methods.\n- Asked it to implement `FrozenMap` with the same API.\n\nThen I did a bunch of manual cleanup:\n- Replaced a bunch of manual trait implementations with derives.\n- Added bincode and serde traits.\n- Added various `turbo-tasks` trait implementations.\n- Added some methods/impls for getting the underlying slice.\n- Optimized a bunch of the constructors.\n\nThen I asked Claude Code to implement the Set version, and did another round of cleanup:\n\n- Removed bunch of unsafe code where it was trying to transmute `(T, ())` to `T`. The memory layout of a tuple is technically undefined, so this wasn't safe, and the APIs it was trying to create doing this weren't really needed either.\n- Replaced some of the iterator newtype wrappers with simpler type aliases. The newtype was overkill for our use-case.",
    "sha": "2ff2a7aadfcbccde8f2ea47a7dc72785f8e5b783",
    "files": [
        {
            "sha": "eee8af542a74b270b19a864d56daccb10183c9bb",
            "filename": "Cargo.lock",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/2ff2a7aadfcbccde8f2ea47a7dc72785f8e5b783/Cargo.lock",
            "raw_url": "https://github.com/vercel/next.js/raw/2ff2a7aadfcbccde8f2ea47a7dc72785f8e5b783/Cargo.lock",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/Cargo.lock?ref=2ff2a7aadfcbccde8f2ea47a7dc72785f8e5b783",
            "patch": "@@ -9129,6 +9129,15 @@ dependencies = [\n  \"turbo-tasks\",\n ]\n \n+[[package]]\n+name = \"turbo-frozenmap\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"bincode 2.0.1\",\n+ \"indexmap 2.9.0\",\n+ \"serde\",\n+]\n+\n [[package]]\n name = \"turbo-persistence\"\n version = \"0.1.0\"\n@@ -9242,6 +9251,7 @@ dependencies = [\n  \"triomphe 0.1.12\",\n  \"turbo-bincode\",\n  \"turbo-dyn-eq-hash\",\n+ \"turbo-frozenmap\",\n  \"turbo-rcstr\",\n  \"turbo-tasks-hash\",\n  \"turbo-tasks-macros\","
        },
        {
            "sha": "d802ae61f7611462021c42e73b59206d51e21b3a",
            "filename": "Cargo.toml",
            "status": "modified",
            "additions": 5,
            "deletions": 4,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/2ff2a7aadfcbccde8f2ea47a7dc72785f8e5b783/Cargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/2ff2a7aadfcbccde8f2ea47a7dc72785f8e5b783/Cargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/Cargo.toml?ref=2ff2a7aadfcbccde8f2ea47a7dc72785f8e5b783",
            "patch": "@@ -294,13 +294,12 @@ next-taskless = { path = \"crates/next-taskless\" }\n # Turbopack\n auto-hash-map = { path = \"turbopack/crates/turbo-tasks-auto-hash-map\" }\n turbo-bincode = { path = \"turbopack/crates/turbo-bincode\" }\n-turbo-prehash = { path = \"turbopack/crates/turbo-prehash\" }\n-turbo-rcstr = { path = \"turbopack/crates/turbo-rcstr\" }\n turbo-dyn-eq-hash = { path = \"turbopack/crates/turbo-dyn-eq-hash\" }\n turbo-esregex = { path = \"turbopack/crates/turbo-esregex\" }\n+turbo-frozenmap = { path = \"turbopack/crates/turbo-frozenmap\" }\n turbo-persistence = { path = \"turbopack/crates/turbo-persistence\" }\n-turbo-unix-path = { path = \"turbopack/crates/turbo-unix-path\" }\n-turbo-tasks-malloc = { path = \"turbopack/crates/turbo-tasks-malloc\", default-features = false }\n+turbo-prehash = { path = \"turbopack/crates/turbo-prehash\" }\n+turbo-rcstr = { path = \"turbopack/crates/turbo-rcstr\" }\n turbo-tasks = { path = \"turbopack/crates/turbo-tasks\" }\n turbo-tasks-backend = { path = \"turbopack/crates/turbo-tasks-backend\" }\n turbo-tasks-bytes = { path = \"turbopack/crates/turbo-tasks-bytes\" }\n@@ -309,7 +308,9 @@ turbo-tasks-fetch = { path = \"turbopack/crates/turbo-tasks-fetch\" }\n turbo-tasks-fs = { path = \"turbopack/crates/turbo-tasks-fs\" }\n turbo-tasks-hash = { path = \"turbopack/crates/turbo-tasks-hash\" }\n turbo-tasks-macros = { path = \"turbopack/crates/turbo-tasks-macros\" }\n+turbo-tasks-malloc = { path = \"turbopack/crates/turbo-tasks-malloc\", default-features = false }\n turbo-tasks-testing = { path = \"turbopack/crates/turbo-tasks-testing\" }\n+turbo-unix-path = { path = \"turbopack/crates/turbo-unix-path\" }\n turbopack = { path = \"turbopack/crates/turbopack\" }\n turbopack-bench = { path = \"turbopack/crates/turbopack-bench\" }\n turbopack-nodejs = { path = \"turbopack/crates/turbopack-nodejs\" }"
        },
        {
            "sha": "9691b90a4d2de3cdff49fcea673aaf055c54e418",
            "filename": "turbopack/crates/turbo-frozenmap/Cargo.toml",
            "status": "added",
            "additions": 15,
            "deletions": 0,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/2ff2a7aadfcbccde8f2ea47a7dc72785f8e5b783/turbopack%2Fcrates%2Fturbo-frozenmap%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/2ff2a7aadfcbccde8f2ea47a7dc72785f8e5b783/turbopack%2Fcrates%2Fturbo-frozenmap%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-frozenmap%2FCargo.toml?ref=2ff2a7aadfcbccde8f2ea47a7dc72785f8e5b783",
            "patch": "@@ -0,0 +1,15 @@\n+[package]\n+name = \"turbo-frozenmap\"\n+version = \"0.1.0\"\n+edition = \"2024\"\n+license = \"MIT\"\n+\n+[dependencies]\n+bincode = { workspace = true }\n+indexmap = { workspace = true }\n+serde = { workspace = true }\n+\n+[dev-dependencies]\n+\n+[lints]\n+workspace = true"
        },
        {
            "sha": "89984e3cdee9f44602ff71cfec2290d2f5b560df",
            "filename": "turbopack/crates/turbo-frozenmap/src/lib.rs",
            "status": "added",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/2ff2a7aadfcbccde8f2ea47a7dc72785f8e5b783/turbopack%2Fcrates%2Fturbo-frozenmap%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2ff2a7aadfcbccde8f2ea47a7dc72785f8e5b783/turbopack%2Fcrates%2Fturbo-frozenmap%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-frozenmap%2Fsrc%2Flib.rs?ref=2ff2a7aadfcbccde8f2ea47a7dc72785f8e5b783",
            "patch": "@@ -0,0 +1,6 @@\n+//! A frozen (immutable) ordered map and set implementation.\n+\n+pub mod map;\n+pub mod set;\n+\n+pub use crate::{map::FrozenMap, set::FrozenSet};"
        },
        {
            "sha": "1a876984b155139cbde19bfc0b191b51c16412c7",
            "filename": "turbopack/crates/turbo-frozenmap/src/map.rs",
            "status": "added",
            "additions": 915,
            "deletions": 0,
            "changes": 915,
            "blob_url": "https://github.com/vercel/next.js/blob/2ff2a7aadfcbccde8f2ea47a7dc72785f8e5b783/turbopack%2Fcrates%2Fturbo-frozenmap%2Fsrc%2Fmap.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2ff2a7aadfcbccde8f2ea47a7dc72785f8e5b783/turbopack%2Fcrates%2Fturbo-frozenmap%2Fsrc%2Fmap.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-frozenmap%2Fsrc%2Fmap.rs?ref=2ff2a7aadfcbccde8f2ea47a7dc72785f8e5b783",
            "patch": "@@ -0,0 +1,915 @@\n+use std::{\n+    borrow::Borrow,\n+    collections::{BTreeMap, HashMap},\n+    fmt::{self, Debug},\n+    hash::BuildHasher,\n+    iter::FusedIterator,\n+    ops::{Bound, Index, RangeBounds},\n+};\n+\n+use bincode::{BorrowDecode, Decode, Encode};\n+use indexmap::IndexMap;\n+use serde::{Deserialize, Serialize};\n+\n+/// A compact frozen (immutable) ordered map backed by a sorted boxed slice.\n+///\n+/// This is a read-only map that stores key-value pairs in a contiguous, sorted array. It provides\n+/// efficient sorted iteration and binary search lookups, but cannot be modified after construction.\n+///\n+/// # Construction\n+///\n+/// If you're building a new map, and you don't expect many overlapping keys, consider pushing\n+/// entries into a [`Vec<(K, V)>`] and calling [`FrozenMap::from`]. It is typically cheaper to\n+/// collect into a [`Vec`] and sort the entries once at the end than it is to maintain a temporary\n+/// map data structure.\n+///\n+/// If you already have a map, need to perform lookups during construction, or you have many\n+/// overlapping keys that you don't want to temporarily hold onto, you can use the provided [`From`]\n+/// trait implementations to create a [`FrozenMap`] from one of many common collections. You should\n+/// prefer using a [`BTreeMap`], as it matches the sorted iteration order of [`FrozenMap`] and\n+/// avoids a sort operation during conversion.\n+///\n+/// If you don't have an existing collection, you can use the [`FromIterator<(K, V)>`] trait\n+/// implementation to [`.collect()`][Iterator::collect] tuples into a [`FrozenMap`].\n+///\n+/// Finally, if you have a list of pre-sorted tuples with unique keys, you can use the advanced\n+/// [`FrozenMap::from_unique_sorted_box`] or [`FrozenMap::from_unique_sorted_box_unchecked`]\n+/// constructors, which provide the cheapest possible construction.\n+///\n+/// Overlapping keys encountered during construction preserve the last overlapping entry, matching\n+/// similar behavior for other maps in the standard library.\n+#[derive(Clone, PartialEq, Eq, Hash, PartialOrd, Ord, Encode, Decode, Serialize, Deserialize)]\n+#[rustfmt::skip] // rustfmt breaks bincode's proc macro string processing\n+#[bincode(\n+    decode_bounds = \"K: Decode<__Context> + 'static, V: Decode<__Context> + 'static\",\n+    borrow_decode_bounds = \"K: BorrowDecode<'__de, __Context> + '__de, V: BorrowDecode<'__de, __Context> + '__de\"\n+)]\n+pub struct FrozenMap<K, V> {\n+    /// Invariant: entries are sorted by key in ascending order with no overlapping keys.\n+    pub(crate) entries: Box<[(K, V)]>,\n+}\n+\n+impl<K, V> FrozenMap<K, V> {\n+    /// Creates an empty [`FrozenMap`]. Does not perform any heap allocations.\n+    pub fn new() -> Self {\n+        FrozenMap {\n+            // Box does not perform heap allocations for zero-sized types.\n+            // In theory this could even be `const` using `Unique::dangling`, but there's no way to\n+            // construct a `Box` from a pointer during `const`.\n+            entries: Box::from([]),\n+        }\n+    }\n+}\n+\n+impl<K, V> FrozenMap<K, V>\n+where\n+    K: Ord,\n+{\n+    /// Creates a [`FrozenMap`] from a pre-sorted boxed slice with unique keys.\n+    ///\n+    /// Panics if the keys in `entries` are not unique and sorted.\n+    pub fn from_unique_sorted_box(entries: Box<[(K, V)]>) -> Self {\n+        assert_unique_sorted(&entries);\n+        FrozenMap { entries }\n+    }\n+\n+    /// Creates a [`FrozenMap`] from a pre-sorted boxed slice with unique keys.\n+    ///\n+    /// # Correctness\n+    ///\n+    /// The caller must ensure that:\n+    /// - The entries are sorted by key in ascending order according to [`K: Ord`][Ord]\n+    /// - There are no overlapping keys\n+    ///\n+    /// If these invariants are not upheld, the map will behave incorrectly (e.g.,\n+    /// [`FrozenMap::get`] may fail to find keys that are present), but no memory unsafety will\n+    /// occur.\n+    ///\n+    /// When `debug_assertions` is enabled, this will panic if an invariant is not upheld.\n+    pub fn from_unique_sorted_box_unchecked(entries: Box<[(K, V)]>) -> Self {\n+        debug_assert_unique_sorted(&entries);\n+        FrozenMap { entries }\n+    }\n+\n+    /// Helper: Sorts keys before constructing. Does not perform any assertions.\n+    ///\n+    /// The caller of this helper should provide a fast-path for empty collections.\n+    pub(crate) fn from_unique_box_inner(mut entries: Box<[(K, V)]>) -> Self {\n+        entries.sort_unstable_by(|a, b| a.0.cmp(&b.0));\n+        Self::from_unique_sorted_box_unchecked(entries)\n+    }\n+\n+    /// Helper: Sorts and deduplicates keys before constructing. Does not perform any assertions.\n+    ///\n+    /// The caller of this helper should provide a fast-path for empty collections.\n+    pub(crate) fn from_vec_inner(mut entries: Vec<(K, V)>) -> Self {\n+        // stable sort preserves insertion order for overlapping keys\n+        entries.sort_by(|a, b| a.0.cmp(&b.0));\n+        // Deduplicate, keeping the last value for each key.\n+        // `dedup_by` removes the first argument when returning true, so we swap to keep the later\n+        // (last) value in the earlier slot.\n+        entries.dedup_by(|later, earlier| {\n+            if later.0 == earlier.0 {\n+                std::mem::swap(later, earlier);\n+                true\n+            } else {\n+                false\n+            }\n+        });\n+        Self::from_unique_sorted_box_unchecked(entries.into_boxed_slice())\n+    }\n+}\n+\n+#[track_caller]\n+fn assert_unique_sorted<K: Ord, V>(entries: &[(K, V)]) {\n+    assert!(\n+        entries.is_sorted_by(|a, b| a.0 < b.0),\n+        \"FrozenMap entries must be unique and sorted\",\n+    )\n+}\n+\n+#[track_caller]\n+fn debug_assert_unique_sorted<K: Ord, V>(entries: &[(K, V)]) {\n+    debug_assert!(\n+        entries.is_sorted_by(|a, b| a.0 < b.0),\n+        \"FrozenMap entries must be unique and sorted\",\n+    )\n+}\n+\n+impl<K: Ord, V> FromIterator<(K, V)> for FrozenMap<K, V> {\n+    /// Creates a [`FrozenMap`] from an iterator of key-value pairs.\n+    ///\n+    /// If there are overlapping keys, the last entry for each key is kept.\n+    fn from_iter<T: IntoIterator<Item = (K, V)>>(entries: T) -> Self {\n+        let entries: Vec<_> = entries.into_iter().collect();\n+        Self::from(entries)\n+    }\n+}\n+\n+impl<K, V> From<BTreeMap<K, V>> for FrozenMap<K, V> {\n+    /// Creates a [`FrozenMap`] from a [`BTreeMap`].\n+    ///\n+    /// This is more efficient than `From<HashMap<K, V>>` because [`BTreeMap`] already iterates in\n+    /// sorted order, so no re-sorting is needed.\n+    fn from(map: BTreeMap<K, V>) -> Self {\n+        if map.is_empty() {\n+            return Self::new();\n+        }\n+        FrozenMap {\n+            entries: map.into_iter().collect(),\n+        }\n+    }\n+}\n+\n+impl<K, V, S> From<HashMap<K, V, S>> for FrozenMap<K, V>\n+where\n+    K: Ord,\n+    S: BuildHasher,\n+{\n+    /// Creates a [`FrozenMap`] from a [`HashMap`].\n+    ///\n+    /// The entries are sorted by key during construction.\n+    fn from(map: HashMap<K, V, S>) -> Self {\n+        if map.is_empty() {\n+            return Self::new();\n+        }\n+        Self::from_unique_box_inner(map.into_iter().collect())\n+    }\n+}\n+\n+impl<K, V, S> From<IndexMap<K, V, S>> for FrozenMap<K, V>\n+where\n+    K: Ord,\n+    S: BuildHasher,\n+{\n+    /// Creates a [`FrozenMap`] from an [`IndexMap`].\n+    ///\n+    /// The entries are sorted by key during construction.\n+    fn from(map: IndexMap<K, V, S>) -> Self {\n+        if map.is_empty() {\n+            return Self::new();\n+        }\n+        Self::from_unique_box_inner(map.into_iter().collect())\n+    }\n+}\n+\n+impl<K: Ord, V> From<Vec<(K, V)>> for FrozenMap<K, V> {\n+    /// Creates a [`FrozenMap`] from a [`Vec`] of key-value pairs.\n+    ///\n+    /// If there are overlapping keys, the last entry for each key is kept.\n+    fn from(entries: Vec<(K, V)>) -> Self {\n+        if entries.is_empty() {\n+            return Self::new();\n+        }\n+        Self::from_vec_inner(entries)\n+    }\n+}\n+\n+impl<K: Ord, V> From<Box<[(K, V)]>> for FrozenMap<K, V> {\n+    /// Creates a [`FrozenMap`] from a boxed slice of key-value pairs.\n+    ///\n+    /// If there are overlapping keys, the last entry for each key is kept.\n+    fn from(entries: Box<[(K, V)]>) -> Self {\n+        if entries.is_empty() {\n+            return Self::new();\n+        }\n+        Self::from_vec_inner(Vec::from(entries))\n+    }\n+}\n+\n+impl<K, V> From<&[(K, V)]> for FrozenMap<K, V>\n+where\n+    K: Ord + Clone,\n+    V: Clone,\n+{\n+    /// Creates a [`FrozenMap`] from a slice of key-value pairs. Keys and values are cloned.\n+    ///\n+    /// If there are overlapping keys, the last entry for each key is kept.\n+    fn from(entries: &[(K, V)]) -> Self {\n+        if entries.is_empty() {\n+            return Self::new();\n+        }\n+        Self::from_vec_inner(Vec::from(entries))\n+    }\n+}\n+\n+impl<K: Ord, V, const N: usize> From<[(K, V); N]> for FrozenMap<K, V> {\n+    /// Creates a [`FrozenMap`] from an owned array of key-value pairs.\n+    ///\n+    /// If there are overlapping keys, the last entry for each key is kept.\n+    fn from(entries: [(K, V); N]) -> Self {\n+        if entries.is_empty() {\n+            return Self::new();\n+        }\n+        Self::from_vec_inner(Vec::from(entries))\n+    }\n+}\n+\n+impl<K, V> FrozenMap<K, V> {\n+    /// Returns the number of elements in the map.\n+    pub const fn len(&self) -> usize {\n+        self.entries.len()\n+    }\n+\n+    /// Returns `true` if the map contains no elements.\n+    pub const fn is_empty(&self) -> bool {\n+        self.entries.is_empty()\n+    }\n+\n+    /// Returns a reference to the underlying sorted slice.\n+    pub const fn as_slice(&self) -> &[(K, V)] {\n+        &self.entries\n+    }\n+\n+    /// Returns a reference to the value corresponding to the key.\n+    pub fn get<Q>(&self, key: &Q) -> Option<&V>\n+    where\n+        K: Borrow<Q> + Ord,\n+        Q: Ord + ?Sized,\n+    {\n+        self.get_key_value(key).map(|(_, v)| v)\n+    }\n+\n+    /// Returns the key-value pair corresponding to the supplied key.\n+    pub fn get_key_value<Q>(&self, key: &Q) -> Option<(&K, &V)>\n+    where\n+        K: Borrow<Q> + Ord,\n+        Q: Ord + ?Sized,\n+    {\n+        let idx = self\n+            .entries\n+            .binary_search_by(|(k, _)| k.borrow().cmp(key))\n+            .ok()?;\n+        let (k, v) = &self.entries[idx];\n+        Some((k, v))\n+    }\n+\n+    /// Returns `true` if the map contains a value for the specified key.\n+    pub fn contains_key<Q>(&self, key: &Q) -> bool\n+    where\n+        K: Borrow<Q> + Ord,\n+        Q: Ord + ?Sized,\n+    {\n+        self.entries\n+            .binary_search_by(|(k, _)| k.borrow().cmp(key))\n+            .is_ok()\n+    }\n+\n+    /// Returns the first key-value pair in the map.\n+    pub fn first_key_value(&self) -> Option<(&K, &V)> {\n+        self.entries.first().map(|(k, v)| (k, v))\n+    }\n+\n+    /// Returns the last key-value pair in the map.\n+    pub fn last_key_value(&self) -> Option<(&K, &V)> {\n+        self.entries.last().map(|(k, v)| (k, v))\n+    }\n+\n+    /// Gets an iterator over the entries of the map, sorted by key.\n+    pub fn iter(&self) -> Iter<'_, K, V> {\n+        Iter {\n+            inner: self.entries.iter(),\n+        }\n+    }\n+\n+    /// Gets an iterator over the keys of the map, in sorted order.\n+    pub fn keys(&self) -> Keys<'_, K, V> {\n+        Keys { inner: self.iter() }\n+    }\n+\n+    /// Gets an iterator over the values of the map, in order by key.\n+    pub fn values(&self) -> Values<'_, K, V> {\n+        Values { inner: self.iter() }\n+    }\n+\n+    /// Creates a consuming iterator visiting all the keys, in sorted order.\n+    pub fn into_keys(self) -> IntoKeys<K, V> {\n+        IntoKeys {\n+            inner: self.into_iter(),\n+        }\n+    }\n+\n+    /// Creates a consuming iterator visiting all the values, in order by key.\n+    pub fn into_values(self) -> IntoValues<K, V> {\n+        IntoValues {\n+            inner: self.into_iter(),\n+        }\n+    }\n+\n+    /// Constructs a double-ended iterator over a sub-range of entries in the map.\n+    pub fn range<T, R>(&self, range: R) -> Range<'_, K, V>\n+    where\n+        T: Ord + ?Sized,\n+        K: Borrow<T> + Ord,\n+        R: RangeBounds<T>,\n+    {\n+        let start = match range.start_bound() {\n+            Bound::Included(key) => self\n+                .entries\n+                .binary_search_by(|(k, _)| k.borrow().cmp(key))\n+                .unwrap_or_else(|i| i),\n+            Bound::Excluded(key) => {\n+                match self.entries.binary_search_by(|(k, _)| k.borrow().cmp(key)) {\n+                    Ok(i) => i + 1,\n+                    Err(i) => i,\n+                }\n+            }\n+            Bound::Unbounded => 0,\n+        };\n+\n+        let end = match range.end_bound() {\n+            Bound::Included(key) => {\n+                match self.entries.binary_search_by(|(k, _)| k.borrow().cmp(key)) {\n+                    Ok(i) => i + 1,\n+                    Err(i) => i,\n+                }\n+            }\n+            Bound::Excluded(key) => self\n+                .entries\n+                .binary_search_by(|(k, _)| k.borrow().cmp(key))\n+                .unwrap_or_else(|i| i),\n+            Bound::Unbounded => self.entries.len(),\n+        };\n+\n+        let slice = if start <= end && end <= self.entries.len() {\n+            &self.entries[start..end]\n+        } else {\n+            &[]\n+        };\n+\n+        Range {\n+            inner: slice.iter(),\n+        }\n+    }\n+}\n+\n+// Manual implementation because the derive would add unnecessary `K: Default, V: Default` bounds.\n+impl<K, V> Default for FrozenMap<K, V> {\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\n+\n+impl<K: Debug, V: Debug> Debug for FrozenMap<K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_map().entries(self.iter()).finish()\n+    }\n+}\n+\n+impl<K, Q: ?Sized, V> Index<&Q> for FrozenMap<K, V>\n+where\n+    K: Borrow<Q> + Ord,\n+    Q: Ord,\n+{\n+    type Output = V;\n+\n+    fn index(&self, key: &Q) -> &V {\n+        self.get(key).expect(\"no entry found for key\")\n+    }\n+}\n+\n+impl<K, V> AsRef<[(K, V)]> for FrozenMap<K, V> {\n+    fn as_ref(&self) -> &[(K, V)] {\n+        self.as_slice()\n+    }\n+}\n+\n+impl<K, V> From<FrozenMap<K, V>> for Box<[(K, V)]> {\n+    fn from(map: FrozenMap<K, V>) -> Self {\n+        map.entries\n+    }\n+}\n+\n+impl<'a, K, V> IntoIterator for &'a FrozenMap<K, V> {\n+    type Item = (&'a K, &'a V);\n+    type IntoIter = Iter<'a, K, V>;\n+\n+    fn into_iter(self) -> Iter<'a, K, V> {\n+        self.iter()\n+    }\n+}\n+\n+impl<K, V> IntoIterator for FrozenMap<K, V> {\n+    type Item = (K, V);\n+    type IntoIter = IntoIter<K, V>;\n+\n+    fn into_iter(self) -> IntoIter<K, V> {\n+        IntoIter {\n+            inner: self.entries.into_vec().into_iter(),\n+        }\n+    }\n+}\n+\n+/// An iterator over the entries of a [`FrozenMap`].\n+pub struct Iter<'a, K, V> {\n+    inner: std::slice::Iter<'a, (K, V)>,\n+}\n+\n+impl<K: Debug, V: Debug> Debug for Iter<'_, K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_list()\n+            .entries(self.inner.clone().map(|(k, v)| (k, v)))\n+            .finish()\n+    }\n+}\n+\n+impl<'a, K, V> Iterator for Iter<'a, K, V> {\n+    type Item = (&'a K, &'a V);\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.inner.next().map(|(k, v)| (k, v))\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n+\n+    fn last(mut self) -> Option<Self::Item> {\n+        self.next_back()\n+    }\n+\n+    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        self.inner.nth(n).map(|(k, v)| (k, v))\n+    }\n+\n+    fn count(self) -> usize {\n+        self.inner.len()\n+    }\n+}\n+\n+impl<K, V> DoubleEndedIterator for Iter<'_, K, V> {\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        self.inner.next_back().map(|(k, v)| (k, v))\n+    }\n+\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        self.inner.nth_back(n).map(|(k, v)| (k, v))\n+    }\n+}\n+\n+impl<K, V> ExactSizeIterator for Iter<'_, K, V> {\n+    fn len(&self) -> usize {\n+        self.inner.len()\n+    }\n+}\n+\n+impl<K, V> FusedIterator for Iter<'_, K, V> {}\n+\n+// Manual implementation because the derive would add unnecessary `K: Clone, V: Clone` type bounds.\n+impl<K, V> Clone for Iter<'_, K, V> {\n+    fn clone(&self) -> Self {\n+        Self {\n+            inner: self.inner.clone(),\n+        }\n+    }\n+}\n+\n+/// An owning iterator over the entries of a [`FrozenMap`].\n+pub struct IntoIter<K, V> {\n+    inner: std::vec::IntoIter<(K, V)>,\n+}\n+\n+impl<K: Debug, V: Debug> Debug for IntoIter<K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_list().entries(self.inner.as_slice()).finish()\n+    }\n+}\n+\n+impl<K, V> Iterator for IntoIter<K, V> {\n+    type Item = (K, V);\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.inner.next()\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n+\n+    fn count(self) -> usize {\n+        self.inner.len()\n+    }\n+}\n+\n+impl<K, V> DoubleEndedIterator for IntoIter<K, V> {\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        self.inner.next_back()\n+    }\n+}\n+\n+impl<K, V> ExactSizeIterator for IntoIter<K, V> {\n+    fn len(&self) -> usize {\n+        self.inner.len()\n+    }\n+}\n+\n+impl<K, V> FusedIterator for IntoIter<K, V> {}\n+\n+/// An iterator over the keys of a [`FrozenMap`].\n+pub struct Keys<'a, K, V> {\n+    inner: Iter<'a, K, V>,\n+}\n+\n+impl<K: Debug, V> Debug for Keys<'_, K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_list()\n+            .entries(self.inner.inner.clone().map(|(k, _)| k))\n+            .finish()\n+    }\n+}\n+\n+impl<'a, K, V> Iterator for Keys<'a, K, V> {\n+    type Item = &'a K;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.inner.next().map(|(k, _)| k)\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n+\n+    fn last(mut self) -> Option<Self::Item> {\n+        self.next_back()\n+    }\n+\n+    fn count(self) -> usize {\n+        self.inner.len()\n+    }\n+}\n+\n+impl<K, V> DoubleEndedIterator for Keys<'_, K, V> {\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        self.inner.next_back().map(|(k, _)| k)\n+    }\n+}\n+\n+impl<K, V> ExactSizeIterator for Keys<'_, K, V> {\n+    fn len(&self) -> usize {\n+        self.inner.len()\n+    }\n+}\n+\n+impl<K, V> FusedIterator for Keys<'_, K, V> {}\n+\n+// Manual implementation because the derive would add unnecessary `K: Clone, V: Clone` type bounds.\n+impl<K, V> Clone for Keys<'_, K, V> {\n+    fn clone(&self) -> Self {\n+        Self {\n+            inner: self.inner.clone(),\n+        }\n+    }\n+}\n+\n+/// An iterator over the values of a [`FrozenMap`].\n+pub struct Values<'a, K, V> {\n+    inner: Iter<'a, K, V>,\n+}\n+\n+impl<K, V: Debug> Debug for Values<'_, K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_list()\n+            .entries(self.inner.inner.clone().map(|(_, v)| v))\n+            .finish()\n+    }\n+}\n+\n+impl<'a, K, V> Iterator for Values<'a, K, V> {\n+    type Item = &'a V;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.inner.next().map(|(_, v)| v)\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n+\n+    fn last(mut self) -> Option<Self::Item> {\n+        self.next_back()\n+    }\n+\n+    fn count(self) -> usize {\n+        self.inner.len()\n+    }\n+}\n+\n+impl<K, V> DoubleEndedIterator for Values<'_, K, V> {\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        self.inner.next_back().map(|(_, v)| v)\n+    }\n+}\n+\n+impl<K, V> ExactSizeIterator for Values<'_, K, V> {\n+    fn len(&self) -> usize {\n+        self.inner.len()\n+    }\n+}\n+\n+impl<K, V> FusedIterator for Values<'_, K, V> {}\n+\n+// Manual implementation because the derive would add unnecessary `K: Clone, V: Clone` type bounds.\n+impl<K, V> Clone for Values<'_, K, V> {\n+    fn clone(&self) -> Self {\n+        Self {\n+            inner: self.inner.clone(),\n+        }\n+    }\n+}\n+\n+/// An owning iterator over the keys of a [`FrozenMap`].\n+pub struct IntoKeys<K, V> {\n+    inner: IntoIter<K, V>,\n+}\n+\n+impl<K: Debug, V> Debug for IntoKeys<K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_list()\n+            .entries(self.inner.inner.as_slice().iter().map(|(k, _)| k))\n+            .finish()\n+    }\n+}\n+\n+impl<K, V> Iterator for IntoKeys<K, V> {\n+    type Item = K;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.inner.next().map(|(k, _)| k)\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n+\n+    fn count(self) -> usize {\n+        self.inner.len()\n+    }\n+}\n+\n+impl<K, V> DoubleEndedIterator for IntoKeys<K, V> {\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        self.inner.next_back().map(|(k, _)| k)\n+    }\n+}\n+\n+impl<K, V> ExactSizeIterator for IntoKeys<K, V> {\n+    fn len(&self) -> usize {\n+        self.inner.len()\n+    }\n+}\n+\n+impl<K, V> FusedIterator for IntoKeys<K, V> {}\n+\n+/// An owning iterator over the values of a [`FrozenMap`].\n+pub struct IntoValues<K, V> {\n+    inner: IntoIter<K, V>,\n+}\n+\n+impl<K, V: Debug> Debug for IntoValues<K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_list()\n+            .entries(self.inner.inner.as_slice().iter().map(|(_, v)| v))\n+            .finish()\n+    }\n+}\n+\n+impl<K, V> Iterator for IntoValues<K, V> {\n+    type Item = V;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.inner.next().map(|(_, v)| v)\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n+\n+    fn count(self) -> usize {\n+        self.inner.len()\n+    }\n+}\n+\n+impl<K, V> DoubleEndedIterator for IntoValues<K, V> {\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        self.inner.next_back().map(|(_, v)| v)\n+    }\n+}\n+\n+impl<K, V> ExactSizeIterator for IntoValues<K, V> {\n+    fn len(&self) -> usize {\n+        self.inner.len()\n+    }\n+}\n+\n+impl<K, V> FusedIterator for IntoValues<K, V> {}\n+\n+/// An iterator over a sub-range of entries in a [`FrozenMap`].\n+pub struct Range<'a, K, V> {\n+    inner: std::slice::Iter<'a, (K, V)>,\n+}\n+\n+impl<K: Debug, V: Debug> Debug for Range<'_, K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_list().entries(self.clone()).finish()\n+    }\n+}\n+\n+impl<'a, K, V> Iterator for Range<'a, K, V> {\n+    type Item = (&'a K, &'a V);\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.inner.next().map(|(k, v)| (k, v))\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n+\n+    fn last(mut self) -> Option<Self::Item> {\n+        self.next_back()\n+    }\n+\n+    fn count(self) -> usize {\n+        self.inner.len()\n+    }\n+}\n+\n+impl<K, V> DoubleEndedIterator for Range<'_, K, V> {\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        self.inner.next_back().map(|(k, v)| (k, v))\n+    }\n+}\n+\n+impl<K, V> ExactSizeIterator for Range<'_, K, V> {\n+    fn len(&self) -> usize {\n+        self.inner.len()\n+    }\n+}\n+\n+impl<K, V> FusedIterator for Range<'_, K, V> {}\n+\n+// Manual implementation because the derive would add unnecessary `K: Clone, V: Clone` type bounds.\n+impl<K, V> Clone for Range<'_, K, V> {\n+    fn clone(&self) -> Self {\n+        Self {\n+            inner: self.inner.clone(),\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn test_empty() {\n+        let map = FrozenMap::<i32, i32>::new();\n+        assert!(map.is_empty());\n+        assert_eq!(map.len(), 0);\n+        assert_eq!(map.get(&1), None);\n+    }\n+\n+    #[test]\n+    fn test_from_btreemap() {\n+        let mut btree = BTreeMap::new();\n+        btree.insert(3, \"c\");\n+        btree.insert(1, \"a\");\n+        btree.insert(2, \"b\");\n+\n+        let frozen = FrozenMap::from(btree);\n+        assert_eq!(frozen.len(), 3);\n+        assert_eq!(frozen.get(&1), Some(&\"a\"));\n+        assert_eq!(frozen.get(&2), Some(&\"b\"));\n+        assert_eq!(frozen.get(&3), Some(&\"c\"));\n+\n+        let keys: Vec<_> = frozen.keys().copied().collect();\n+        assert_eq!(keys, vec![1, 2, 3]);\n+    }\n+\n+    #[test]\n+    fn test_from_overlapping_vec() {\n+        let frozen = FrozenMap::from(vec![(1, \"a\"), (1, \"b\"), (2, \"c\")]);\n+        assert_eq!(frozen.len(), 2);\n+        // Last value wins for overlapping keys\n+        assert_eq!(frozen.get(&1), Some(&\"b\"));\n+        assert_eq!(frozen.get(&2), Some(&\"c\"));\n+    }\n+\n+    #[test]\n+    fn test_range() {\n+        let frozen = FrozenMap::from([(1, \"a\"), (2, \"b\"), (3, \"c\"), (4, \"d\"), (5, \"e\")]);\n+\n+        let range: Vec<_> = frozen.range(2..4).collect();\n+        assert_eq!(range, vec![(&2, &\"b\"), (&3, &\"c\")]);\n+\n+        let range: Vec<_> = frozen.range(2..=4).collect();\n+        assert_eq!(range, vec![(&2, &\"b\"), (&3, &\"c\"), (&4, &\"d\")]);\n+\n+        let range: Vec<_> = frozen.range(..3).collect();\n+        assert_eq!(range, vec![(&1, &\"a\"), (&2, &\"b\")]);\n+    }\n+\n+    #[test]\n+    fn test_index() {\n+        let frozen = FrozenMap::from([(1, \"a\"), (2, \"b\")]);\n+        assert_eq!(frozen[&1], \"a\");\n+        assert_eq!(frozen[&2], \"b\");\n+    }\n+\n+    #[test]\n+    #[should_panic(expected = \"no entry found for key\")]\n+    fn test_index_missing() {\n+        let frozen = FrozenMap::from([(1, \"a\")]);\n+        let _ = frozen[&2];\n+    }\n+\n+    #[test]\n+    fn test_first_last() {\n+        let frozen = FrozenMap::from([(2, \"b\"), (1, \"a\"), (3, \"c\")]);\n+        assert_eq!(frozen.first_key_value(), Some((&1, &\"a\")));\n+        assert_eq!(frozen.last_key_value(), Some((&3, &\"c\")));\n+\n+        let empty = FrozenMap::<i32, i32>::new();\n+        assert_eq!(empty.first_key_value(), None);\n+        assert_eq!(empty.last_key_value(), None);\n+    }\n+\n+    #[test]\n+    fn test_as_ref() {\n+        let frozen = FrozenMap::from([(2, \"b\"), (1, \"a\"), (3, \"c\")]);\n+        let slice: &[(i32, &str)] = frozen.as_ref();\n+        assert_eq!(slice, &[(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n+\n+        let empty = FrozenMap::<i32, i32>::new();\n+        let empty_slice: &[(i32, i32)] = empty.as_ref();\n+        assert_eq!(empty_slice, &[]);\n+    }\n+\n+    #[test]\n+    fn test_from_hashmap() {\n+        let mut map = HashMap::new();\n+        map.insert(3, \"c\");\n+        map.insert(1, \"a\");\n+        map.insert(2, \"b\");\n+\n+        let frozen = FrozenMap::from(map);\n+        assert_eq!(frozen.len(), 3);\n+        assert_eq!(frozen.get(&1), Some(&\"a\"));\n+        let keys: Vec<_> = frozen.keys().copied().collect();\n+        assert_eq!(keys, vec![1, 2, 3]);\n+    }\n+\n+    #[test]\n+    fn test_from_unique_sorted_box() {\n+        let frozen = FrozenMap::from_unique_sorted_box(Box::from([(1, \"a\"), (2, \"b\")]));\n+        assert_eq!(frozen.len(), 2);\n+        assert_eq!(frozen.get(&1), Some(&\"a\"));\n+        assert_eq!(frozen.get(&2), Some(&\"b\"));\n+    }\n+\n+    #[test]\n+    #[should_panic(expected = \"FrozenMap entries must be unique and sorted\")]\n+    fn test_from_unique_sorted_box_panics() {\n+        let _ = FrozenMap::from_unique_sorted_box(Box::from([(1, \"a\"), (1, \"b\")]));\n+    }\n+}"
        },
        {
            "sha": "30e12dea888fed4694db5bdf6e452f0f9ccf65a5",
            "filename": "turbopack/crates/turbo-frozenmap/src/set.rs",
            "status": "added",
            "additions": 485,
            "deletions": 0,
            "changes": 485,
            "blob_url": "https://github.com/vercel/next.js/blob/2ff2a7aadfcbccde8f2ea47a7dc72785f8e5b783/turbopack%2Fcrates%2Fturbo-frozenmap%2Fsrc%2Fset.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2ff2a7aadfcbccde8f2ea47a7dc72785f8e5b783/turbopack%2Fcrates%2Fturbo-frozenmap%2Fsrc%2Fset.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-frozenmap%2Fsrc%2Fset.rs?ref=2ff2a7aadfcbccde8f2ea47a7dc72785f8e5b783",
            "patch": "@@ -0,0 +1,485 @@\n+use std::{\n+    borrow::Borrow,\n+    collections::{BTreeSet, HashSet},\n+    fmt::{self, Debug},\n+    hash::BuildHasher,\n+    iter::FusedIterator,\n+    ops::RangeBounds,\n+};\n+\n+use bincode::{BorrowDecode, Decode, Encode};\n+use indexmap::IndexSet;\n+use serde::{Deserialize, Serialize};\n+\n+use crate::map::{self, FrozenMap};\n+\n+/// A compact frozen (immutable) ordered set backed by a [`FrozenMap<T, ()>`].\n+///\n+/// This is a read-only set that stores elements in a contiguous, sorted array. It provides\n+/// efficient binary search lookups and iteration, but cannot be modified after construction.\n+///\n+/// # Construction\n+///\n+/// If you're building a new set, and you don't expect many overlapping items, consider pushing\n+/// items into a [`Vec`] and calling [`FrozenSet::from`] or using the [`FromIterator`]\n+/// implementation via [`Iterator::collect`]. It is typically cheaper to collect into a [`Vec`] and\n+/// sort the items once at the end than it is to maintain a temporary set data structure.\n+///\n+/// If you already have a set, or you have many overlapping items that you don't want to temporarily\n+/// hold onto, you can use the [`From`] or [`Into`] traits to create a [`FrozenSet`] from one of\n+/// many common collections. You should prefer using a [`BTreeSet`], as it matches the sorted\n+/// semantics of [`FrozenSet`] and avoids a sort operation during conversion.\n+///\n+/// Overlapping items encountered during construction preserve the last overlapping item, matching\n+/// similar behavior for other sets in the standard library.\n+///\n+/// Similar to the API of [`BTreeSet`], there are no convenience methods for constructing from a\n+/// [`Vec`] or boxed slice. Because of limitations of the internal representation and Rust's memory\n+/// layout rules, the most efficient way to convert from these data structures is via an\n+/// [`Iterator`].\n+#[derive(Clone, PartialEq, Eq, Hash, PartialOrd, Ord, Encode, Decode, Serialize, Deserialize)]\n+#[bincode(\n+    decode_bounds = \"T: Decode<__Context> + 'static\",\n+    borrow_decode_bounds = \"T: BorrowDecode<'__de, __Context> + '__de\"\n+)]\n+pub struct FrozenSet<T> {\n+    map: FrozenMap<T, ()>,\n+}\n+\n+impl<T> FrozenSet<T> {\n+    /// Creates an empty [`FrozenSet`]. Does not perform any heap allocations.\n+    pub fn new() -> Self {\n+        FrozenSet {\n+            map: FrozenMap::new(),\n+        }\n+    }\n+}\n+\n+impl<T> FrozenSet<T>\n+where\n+    T: Ord,\n+{\n+    /// Creates a [`FrozenSet`] from a pre-sorted iterator with unique items.\n+    ///\n+    /// This is more efficient than [`Iterator::collect`] or [`FromIterator::from_iter`] if you know\n+    /// that the iterator is sorted and has no overlapping items.\n+    ///\n+    /// Panics if the `items` are not unique and sorted.\n+    pub fn from_unique_sorted_iter(items: impl IntoIterator<Item = T>) -> Self {\n+        FrozenSet {\n+            map: FrozenMap::from_unique_sorted_box(items.into_iter().map(|t| (t, ())).collect()),\n+        }\n+    }\n+\n+    /// Creates a [`FrozenSet`] from a pre-sorted iterator with unique items.\n+    ///\n+    /// This is more efficient than [`Iterator::collect`] or [`FromIterator::from_iter`] if you know\n+    /// that the iterator is sorted and has no overlapping items.\n+    ///\n+    /// # Correctness\n+    ///\n+    /// The caller must ensure that:\n+    /// - The iterator yields items in ascending order according to [`T: Ord`][Ord]\n+    /// - There are no overlapping items\n+    ///\n+    /// If these invariants are not upheld, the set will behave incorrectly (e.g.,\n+    /// [`FrozenSet::contains`] may fail to find items that are present), but no memory unsafety\n+    /// will occur.\n+    ///\n+    /// When `debug_assertions` is enabled, this will panic if an invariant is not upheld.\n+    pub fn from_unique_sorted_iter_unchecked(items: impl IntoIterator<Item = T>) -> Self {\n+        FrozenSet {\n+            map: FrozenMap::from_unique_sorted_box_unchecked(\n+                items.into_iter().map(|t| (t, ())).collect(),\n+            ),\n+        }\n+    }\n+}\n+\n+impl<T: Ord> FromIterator<T> for FrozenSet<T> {\n+    /// Creates a [`FrozenSet`] from an iterator of items. If there are overlapping items, only the\n+    /// last copy is kept.\n+    fn from_iter<I: IntoIterator<Item = T>>(items: I) -> Self {\n+        FrozenSet {\n+            map: FrozenMap::from_iter(items.into_iter().map(|t| (t, ()))),\n+        }\n+    }\n+}\n+\n+impl<T> From<BTreeSet<T>> for FrozenSet<T> {\n+    /// Creates a [`FrozenSet`] from a [`BTreeSet`].\n+    ///\n+    /// This is more efficient than `From<HashSet<T>>` because [`BTreeSet`] already iterates in\n+    /// sorted order, so no re-sorting is needed.\n+    fn from(set: BTreeSet<T>) -> Self {\n+        if set.is_empty() {\n+            return Self::new();\n+        }\n+        FrozenSet {\n+            map: FrozenMap {\n+                entries: set.into_iter().map(|t| (t, ())).collect(),\n+            },\n+        }\n+    }\n+}\n+\n+impl<T, S> From<HashSet<T, S>> for FrozenSet<T>\n+where\n+    T: Ord,\n+    S: BuildHasher,\n+{\n+    /// Creates a [`FrozenSet`] from a [`HashSet`].\n+    ///\n+    /// The items are sorted during construction.\n+    fn from(set: HashSet<T, S>) -> Self {\n+        if set.is_empty() {\n+            return Self::new();\n+        }\n+        FrozenSet {\n+            map: FrozenMap::from_unique_box_inner(set.into_iter().map(|t| (t, ())).collect()),\n+        }\n+    }\n+}\n+\n+impl<T, S> From<IndexSet<T, S>> for FrozenSet<T>\n+where\n+    T: Ord,\n+    S: BuildHasher,\n+{\n+    /// Creates a [`FrozenSet`] from an [`IndexSet`].\n+    ///\n+    /// The items are sorted during construction.\n+    fn from(set: IndexSet<T, S>) -> Self {\n+        if set.is_empty() {\n+            return Self::new();\n+        }\n+        FrozenSet {\n+            map: FrozenMap::from_unique_box_inner(set.into_iter().map(|t| (t, ())).collect()),\n+        }\n+    }\n+}\n+\n+impl<T: Ord, const N: usize> From<[T; N]> for FrozenSet<T> {\n+    /// Creates a [`FrozenSet`] from an array of items. If there are overlapping items, the last\n+    /// copy is kept.\n+    ///\n+    /// The items are sorted during construction.\n+    fn from(items: [T; N]) -> Self {\n+        Self::from_iter(items)\n+    }\n+}\n+\n+impl<T> FrozenSet<T> {\n+    /// Returns the number of elements in the set.\n+    pub const fn len(&self) -> usize {\n+        self.map.len()\n+    }\n+\n+    /// Returns `true` if the set contains no elements.\n+    pub const fn is_empty(&self) -> bool {\n+        self.map.is_empty()\n+    }\n+\n+    /// Returns `true` if the set contains an element equal to the value.\n+    pub fn contains<Q>(&self, value: &Q) -> bool\n+    where\n+        T: Borrow<Q> + Ord,\n+        Q: Ord + ?Sized,\n+    {\n+        self.map.contains_key(value)\n+    }\n+\n+    /// Returns a reference to the element in the set, if any, that is equal to the value.\n+    pub fn get<Q>(&self, value: &Q) -> Option<&T>\n+    where\n+        T: Borrow<Q> + Ord,\n+        Q: Ord + ?Sized,\n+    {\n+        self.map.get_key_value(value).map(|(t, _)| t)\n+    }\n+\n+    /// Returns a reference to the first element in the set, if any. This element is always the\n+    /// minimum of all elements in the set.\n+    pub fn first(&self) -> Option<&T> {\n+        self.map.first_key_value().map(|(t, _)| t)\n+    }\n+\n+    /// Returns a reference to the last element in the set, if any. This element is always the\n+    /// maximum of all elements in the set.\n+    pub fn last(&self) -> Option<&T> {\n+        self.map.last_key_value().map(|(t, _)| t)\n+    }\n+\n+    /// Gets an iterator that visits the elements in the [`FrozenSet`] in ascending order.\n+    pub fn iter(&self) -> Iter<'_, T> {\n+        self.map.keys()\n+    }\n+\n+    /// Constructs a double-ended iterator over a sub-range of elements in the set.\n+    pub fn range<Q, R>(&self, range: R) -> Range<'_, T>\n+    where\n+        Q: Ord + ?Sized,\n+        T: Borrow<Q> + Ord,\n+        R: RangeBounds<Q>,\n+    {\n+        Range {\n+            inner: self.map.range(range),\n+        }\n+    }\n+\n+    /// Returns `true` if `self` has no elements in common with `other`. This is equivalent to\n+    /// checking for an empty intersection.\n+    pub fn is_disjoint(&self, other: &Self) -> bool\n+    where\n+        T: Ord,\n+    {\n+        if self.len() <= other.len() {\n+            self.iter().all(|v| !other.contains(v))\n+        } else {\n+            other.iter().all(|v| !self.contains(v))\n+        }\n+    }\n+\n+    /// Returns `true` if the set is a subset of another, i.e., `other` contains at least all the\n+    /// elements in `self`.\n+    pub fn is_subset(&self, other: &Self) -> bool\n+    where\n+        T: Ord,\n+    {\n+        if self.len() > other.len() {\n+            return false;\n+        }\n+        self.iter().all(|v| other.contains(v))\n+    }\n+\n+    /// Returns `true` if the set is a superset of another, i.e., `self` contains at least all the\n+    /// elements in `other`.\n+    pub fn is_superset(&self, other: &Self) -> bool\n+    where\n+        T: Ord,\n+    {\n+        other.is_subset(self)\n+    }\n+}\n+\n+// Manual implementation because the derive would add unnecessary `T: Default` bounds.\n+impl<T> Default for FrozenSet<T> {\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\n+\n+impl<T: Debug> Debug for FrozenSet<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_set().entries(self.iter()).finish()\n+    }\n+}\n+\n+impl<'a, T> IntoIterator for &'a FrozenSet<T> {\n+    type Item = &'a T;\n+    type IntoIter = Iter<'a, T>;\n+\n+    fn into_iter(self) -> Iter<'a, T> {\n+        self.iter()\n+    }\n+}\n+\n+impl<T> IntoIterator for FrozenSet<T> {\n+    type Item = T;\n+    type IntoIter = IntoIter<T>;\n+\n+    fn into_iter(self) -> IntoIter<T> {\n+        self.map.into_keys()\n+    }\n+}\n+\n+// These could be newtype wrappers (BTreeSet does this), but type aliases are simpler to implement.\n+pub type Iter<'a, T> = map::Keys<'a, T, ()>;\n+pub type IntoIter<T> = map::IntoKeys<T, ()>;\n+\n+/// An iterator over a sub-range of elements in a [`FrozenSet`].\n+pub struct Range<'a, T> {\n+    inner: map::Range<'a, T, ()>,\n+}\n+\n+impl<T: Debug> Debug for Range<'_, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_list().entries(self.clone()).finish()\n+    }\n+}\n+\n+impl<'a, T> Iterator for Range<'a, T> {\n+    type Item = &'a T;\n+\n+    fn next(&mut self) -> Option<&'a T> {\n+        self.inner.next().map(|(t, _)| t)\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n+\n+    fn last(self) -> Option<&'a T> {\n+        self.inner.last().map(|(t, _)| t)\n+    }\n+\n+    fn count(self) -> usize {\n+        self.inner.len()\n+    }\n+}\n+\n+impl<'a, T> DoubleEndedIterator for Range<'a, T> {\n+    fn next_back(&mut self) -> Option<&'a T> {\n+        self.inner.next_back().map(|(t, _)| t)\n+    }\n+}\n+\n+impl<T> ExactSizeIterator for Range<'_, T> {\n+    fn len(&self) -> usize {\n+        self.inner.len()\n+    }\n+}\n+\n+impl<T> FusedIterator for Range<'_, T> {}\n+\n+// Manual implementation because the derive would add an unnecessary `T: Clone` type bound.\n+impl<T> Clone for Range<'_, T> {\n+    fn clone(&self) -> Self {\n+        Self {\n+            inner: self.inner.clone(),\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn test_empty() {\n+        let set = FrozenSet::<i32>::new();\n+        assert!(set.is_empty());\n+        assert_eq!(set.len(), 0);\n+        assert!(!set.contains(&1));\n+    }\n+\n+    #[test]\n+    fn test_from_btreeset() {\n+        let mut btree = BTreeSet::new();\n+        btree.insert(3);\n+        btree.insert(1);\n+        btree.insert(2);\n+\n+        let frozen = FrozenSet::from(btree);\n+        assert_eq!(frozen.len(), 3);\n+        assert!(frozen.contains(&1));\n+        assert!(frozen.contains(&2));\n+        assert!(frozen.contains(&3));\n+\n+        let elements: Vec<_> = frozen.iter().copied().collect();\n+        assert_eq!(elements, vec![1, 2, 3]);\n+    }\n+\n+    #[test]\n+    fn test_from_array() {\n+        let frozen = FrozenSet::from([3, 1, 2]);\n+        assert_eq!(frozen.len(), 3);\n+        assert!(frozen.contains(&1));\n+\n+        let elements: Vec<_> = frozen.iter().copied().collect();\n+        assert_eq!(elements, vec![1, 2, 3]);\n+    }\n+\n+    #[test]\n+    fn test_from_iter_with_duplicates() {\n+        let frozen: FrozenSet<_> = [1, 1, 2].into_iter().collect();\n+        assert_eq!(frozen.len(), 2);\n+        assert!(frozen.contains(&1));\n+        assert!(frozen.contains(&2));\n+    }\n+\n+    #[test]\n+    fn test_range() {\n+        let frozen = FrozenSet::from([1, 2, 3, 4, 5]);\n+\n+        let range: Vec<_> = frozen.range(2..4).copied().collect();\n+        assert_eq!(range, vec![2, 3]);\n+\n+        let range: Vec<_> = frozen.range(2..=4).copied().collect();\n+        assert_eq!(range, vec![2, 3, 4]);\n+\n+        let range: Vec<_> = frozen.range(..3).copied().collect();\n+        assert_eq!(range, vec![1, 2]);\n+    }\n+\n+    #[test]\n+    fn test_first_last() {\n+        let frozen = FrozenSet::from([2, 1, 3]);\n+        assert_eq!(frozen.first(), Some(&1));\n+        assert_eq!(frozen.last(), Some(&3));\n+\n+        let empty = FrozenSet::<i32>::new();\n+        assert_eq!(empty.first(), None);\n+        assert_eq!(empty.last(), None);\n+    }\n+\n+    #[test]\n+    fn test_is_disjoint() {\n+        let a = FrozenSet::from([1, 2, 3]);\n+        let b = FrozenSet::from([4, 5, 6]);\n+        let c = FrozenSet::from([3, 4, 5]);\n+\n+        assert!(a.is_disjoint(&b));\n+        assert!(!a.is_disjoint(&c));\n+    }\n+\n+    #[test]\n+    fn test_is_subset() {\n+        let a = FrozenSet::from([1, 2]);\n+        let b = FrozenSet::from([1, 2, 3]);\n+        let c = FrozenSet::from([2, 3, 4]);\n+\n+        assert!(a.is_subset(&b));\n+        assert!(!a.is_subset(&c));\n+        assert!(a.is_subset(&a));\n+    }\n+\n+    #[test]\n+    fn test_is_superset() {\n+        let a = FrozenSet::from([1, 2, 3]);\n+        let b = FrozenSet::from([1, 2]);\n+        let c = FrozenSet::from([2, 3, 4]);\n+\n+        assert!(a.is_superset(&b));\n+        assert!(!a.is_superset(&c));\n+        assert!(a.is_superset(&a));\n+    }\n+\n+    #[test]\n+    fn test_from_hashset() {\n+        let mut set = HashSet::new();\n+        set.insert(3);\n+        set.insert(1);\n+        set.insert(2);\n+\n+        let frozen = FrozenSet::from(set);\n+        assert_eq!(frozen.len(), 3);\n+        assert!(frozen.contains(&1));\n+        let elements: Vec<_> = frozen.iter().copied().collect();\n+        assert_eq!(elements, vec![1, 2, 3]);\n+    }\n+\n+    #[test]\n+    fn test_from_unique_sorted_iter() {\n+        let frozen = FrozenSet::from_unique_sorted_iter([1, 2]);\n+        assert_eq!(frozen.len(), 2);\n+        assert!(frozen.contains(&1));\n+        assert!(frozen.contains(&2));\n+    }\n+\n+    #[test]\n+    #[should_panic(expected = \"FrozenMap entries must be unique and sorted\")]\n+    fn test_from_unique_sorted_iter_panics() {\n+        let _ = FrozenSet::from_unique_sorted_iter([1, 1, 2]);\n+    }\n+}"
        },
        {
            "sha": "cf06e32437e27deb5a998df726ddf617193313ec",
            "filename": "turbopack/crates/turbo-tasks/Cargo.toml",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/2ff2a7aadfcbccde8f2ea47a7dc72785f8e5b783/turbopack%2Fcrates%2Fturbo-tasks%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/2ff2a7aadfcbccde8f2ea47a7dc72785f8e5b783/turbopack%2Fcrates%2Fturbo-tasks%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2FCargo.toml?ref=2ff2a7aadfcbccde8f2ea47a7dc72785f8e5b783",
            "patch": "@@ -51,6 +51,7 @@ tracing = { workspace = true }\n triomphe = { workspace = true, features = [\"unsize\", \"unstable\"] }\n turbo-bincode = { workspace = true }\n turbo-dyn-eq-hash = { workspace = true }\n+turbo-frozenmap = { workspace = true }\n turbo-rcstr = { workspace = true }\n turbo-tasks-hash = { workspace = true }\n turbo-tasks-macros = { workspace = true }"
        },
        {
            "sha": "bffb8fd08c3866fd57f344466cc9d229022679c0",
            "filename": "turbopack/crates/turbo-tasks/src/marker_trait.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/2ff2a7aadfcbccde8f2ea47a7dc72785f8e5b783/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmarker_trait.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2ff2a7aadfcbccde8f2ea47a7dc72785f8e5b783/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmarker_trait.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmarker_trait.rs?ref=2ff2a7aadfcbccde8f2ea47a7dc72785f8e5b783",
            "patch": "@@ -55,11 +55,13 @@ macro_rules! impl_auto_marker_trait {\n         unsafe impl<T: $trait, S, const I: usize> $trait for ::auto_hash_map::AutoSet<T, S, I> {}\n         unsafe impl<T: $trait> $trait for ::std::collections::BTreeSet<T> {}\n         unsafe impl<T: $trait, S> $trait for ::indexmap::IndexSet<T, S> {}\n+        unsafe impl<T: $trait> $trait for ::turbo_frozenmap::FrozenSet<T> {}\n         unsafe impl<K: $trait, V: $trait, S> $trait for ::std::collections::HashMap<K, V, S> {}\n         unsafe impl<K: $trait, V: $trait, S, const I: usize> $trait\n             for ::auto_hash_map::AutoMap<K, V, S, I> {}\n         unsafe impl<K: $trait, V: $trait> $trait for ::std::collections::BTreeMap<K, V> {}\n         unsafe impl<K: $trait, V: $trait, S> $trait for ::indexmap::IndexMap<K, V, S> {}\n+        unsafe impl<K: $trait, V: $trait> $trait for ::turbo_frozenmap::FrozenMap<K, V> {}\n         unsafe impl<T: $trait + ?Sized> $trait for ::std::boxed::Box<T> {}\n         unsafe impl<T: $trait + ?Sized> $trait for ::std::sync::Arc<T> {}\n         unsafe impl<B: $trait + ::std::borrow::ToOwned + ?Sized> $trait"
        },
        {
            "sha": "285c08b44d726a981bfdafe3b4b329f0563f6b2b",
            "filename": "turbopack/crates/turbo-tasks/src/task/task_input.rs",
            "status": "modified",
            "additions": 53,
            "deletions": 3,
            "changes": 56,
            "blob_url": "https://github.com/vercel/next.js/blob/2ff2a7aadfcbccde8f2ea47a7dc72785f8e5b783/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask%2Ftask_input.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2ff2a7aadfcbccde8f2ea47a7dc72785f8e5b783/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask%2Ftask_input.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask%2Ftask_input.rs?ref=2ff2a7aadfcbccde8f2ea47a7dc72785f8e5b783",
            "patch": "@@ -16,6 +16,7 @@ use bincode::{\n     error::{DecodeError, EncodeError},\n };\n use either::Either;\n+use turbo_frozenmap::{FrozenMap, FrozenSet};\n use turbo_rcstr::RcStr;\n \n // This import is necessary for derive macros to work, as their expansion refers to the crate\n@@ -284,11 +285,60 @@ where\n     T: TaskInput + Ord,\n {\n     async fn resolve_input(&self) -> Result<Self> {\n-        let mut new_map = BTreeSet::new();\n+        let mut new_set = BTreeSet::new();\n         for value in self {\n-            new_map.insert(TaskInput::resolve_input(value).await?);\n+            new_set.insert(TaskInput::resolve_input(value).await?);\n         }\n-        Ok(new_map)\n+        Ok(new_set)\n+    }\n+\n+    fn is_resolved(&self) -> bool {\n+        self.iter().all(TaskInput::is_resolved)\n+    }\n+\n+    fn is_transient(&self) -> bool {\n+        self.iter().any(TaskInput::is_transient)\n+    }\n+}\n+\n+impl<K, V> TaskInput for FrozenMap<K, V>\n+where\n+    K: TaskInput + Ord + 'static,\n+    V: TaskInput + 'static,\n+{\n+    async fn resolve_input(&self) -> Result<Self> {\n+        let mut new_entries = Vec::with_capacity(self.len());\n+        for (k, v) in self {\n+            new_entries.push((\n+                TaskInput::resolve_input(k).await?,\n+                TaskInput::resolve_input(v).await?,\n+            ));\n+        }\n+        // note: resolving might deduplicate `Vc`s in keys\n+        Ok(Self::from(new_entries))\n+    }\n+\n+    fn is_resolved(&self) -> bool {\n+        self.iter()\n+            .all(|(k, v)| TaskInput::is_resolved(k) && TaskInput::is_resolved(v))\n+    }\n+\n+    fn is_transient(&self) -> bool {\n+        self.iter()\n+            .any(|(k, v)| TaskInput::is_transient(k) || TaskInput::is_transient(v))\n+    }\n+}\n+\n+impl<T> TaskInput for FrozenSet<T>\n+where\n+    T: TaskInput + Ord + 'static,\n+{\n+    async fn resolve_input(&self) -> Result<Self> {\n+        let mut new_set = Vec::with_capacity(self.len());\n+        for value in self {\n+            new_set.push(TaskInput::resolve_input(value).await?);\n+        }\n+        Ok(Self::from_iter(new_set))\n     }\n \n     fn is_resolved(&self) -> bool {"
        },
        {
            "sha": "e0bc148ef58b0139f404bfed467c2a43f58471d9",
            "filename": "turbopack/crates/turbo-tasks/src/trace.rs",
            "status": "modified",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/2ff2a7aadfcbccde8f2ea47a7dc72785f8e5b783/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftrace.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2ff2a7aadfcbccde8f2ea47a7dc72785f8e5b783/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftrace.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftrace.rs?ref=2ff2a7aadfcbccde8f2ea47a7dc72785f8e5b783",
            "patch": "@@ -12,6 +12,7 @@ use auto_hash_map::{AutoMap, AutoSet};\n use either::Either;\n use indexmap::{IndexMap, IndexSet};\n use smallvec::SmallVec;\n+use turbo_frozenmap::{FrozenMap, FrozenSet};\n use turbo_rcstr::RcStr;\n \n use crate::RawVc;\n@@ -200,6 +201,14 @@ impl<T: TraceRawVcs, S> TraceRawVcs for IndexSet<T, S> {\n     }\n }\n \n+impl<T: TraceRawVcs> TraceRawVcs for FrozenSet<T> {\n+    fn trace_raw_vcs(&self, trace_context: &mut TraceRawVcsContext) {\n+        for item in self.iter() {\n+            TraceRawVcs::trace_raw_vcs(item, trace_context);\n+        }\n+    }\n+}\n+\n impl<K: TraceRawVcs, V: TraceRawVcs, S> TraceRawVcs for HashMap<K, V, S> {\n     fn trace_raw_vcs(&self, trace_context: &mut TraceRawVcsContext) {\n         for (key, value) in self.iter() {\n@@ -236,6 +245,15 @@ impl<K: TraceRawVcs, V: TraceRawVcs, S> TraceRawVcs for IndexMap<K, V, S> {\n     }\n }\n \n+impl<K: TraceRawVcs, V: TraceRawVcs> TraceRawVcs for FrozenMap<K, V> {\n+    fn trace_raw_vcs(&self, trace_context: &mut TraceRawVcsContext) {\n+        for (key, value) in self.iter() {\n+            TraceRawVcs::trace_raw_vcs(key, trace_context);\n+            TraceRawVcs::trace_raw_vcs(value, trace_context);\n+        }\n+    }\n+}\n+\n impl<T: TraceRawVcs + ?Sized> TraceRawVcs for Box<T> {\n     fn trace_raw_vcs(&self, trace_context: &mut TraceRawVcsContext) {\n         TraceRawVcs::trace_raw_vcs(&**self, trace_context);"
        }
    ],
    "stats": {
        "total": 1517,
        "additions": 1510,
        "deletions": 7
    }
}