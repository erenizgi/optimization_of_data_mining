{
    "author": "lukesandberg",
    "message": "[turbopack] Rename ClientReferenceSet (#81942)\n\n# Rename ClientReferencesSet to ClientReferenceManifest for better clarity\n\n## What?\n\nCurrently the `ClientReferenceSet` struct tracks information that allows us to efficiently create a manifest of css and js files referenced by entry points and server components.\n\nNaming this is tough because we are really just doing half of an algorithm and the structures are dictated by the other half.",
    "sha": "ae2d1099eafbde1091ef77750897cc025f790716",
    "files": [
        {
            "sha": "40da860fc3891f7d22407c42bfdca309b0470785",
            "filename": "crates/next-api/src/client_references.rs",
            "status": "modified",
            "additions": 21,
            "deletions": 19,
            "changes": 40,
            "blob_url": "https://github.com/vercel/next.js/blob/ae2d1099eafbde1091ef77750897cc025f790716/crates%2Fnext-api%2Fsrc%2Fclient_references.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/ae2d1099eafbde1091ef77750897cc025f790716/crates%2Fnext-api%2Fsrc%2Fclient_references.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fclient_references.rs?ref=ae2d1099eafbde1091ef77750897cc025f790716",
            "patch": "@@ -22,7 +22,7 @@ use turbopack_core::{\n #[derive(\n     Copy, Clone, Serialize, Deserialize, Eq, PartialEq, TraceRawVcs, ValueDebugFormat, NonLocalValue,\n )]\n-pub enum ClientReferenceMapType {\n+pub enum ClientManifestEntryType {\n     EcmascriptClientReference {\n         module: ResolvedVc<EcmascriptClientReferenceModule>,\n         ssr_module: ResolvedVc<Box<dyn Module>>,\n@@ -31,9 +31,11 @@ pub enum ClientReferenceMapType {\n     ServerComponent(ResolvedVc<NextServerComponentModule>),\n }\n \n+/// Tracks information about all the css and js client references in the graph as well as how server\n+/// components depend on them.\n #[turbo_tasks::value]\n-pub struct ClientReferencesSet {\n-    pub client_references: FxHashMap<ResolvedVc<Box<dyn Module>>, ClientReferenceMapType>,\n+pub struct ClientReferenceManifest {\n+    pub manifest: FxHashMap<ResolvedVc<Box<dyn Module>>, ClientManifestEntryType>,\n     // All the server components in the graph.\n     server_components: FxIndexSet<ResolvedVc<NextServerComponentModule>>,\n     // All the server components that depend on each module\n@@ -43,7 +45,7 @@ pub struct ClientReferencesSet {\n         FxHashMap<ResolvedVc<Box<dyn Module>>, RoaringBitmapWrapper>,\n }\n \n-impl ClientReferencesSet {\n+impl ClientReferenceManifest {\n     /// Returns all the server components that depend on the given client reference\n     pub fn server_components_for_client_reference(\n         &self,\n@@ -64,9 +66,9 @@ impl ClientReferencesSet {\n #[turbo_tasks::function]\n pub async fn map_client_references(\n     graph: Vc<SingleModuleGraph>,\n-) -> Result<Vc<ClientReferencesSet>> {\n+) -> Result<Vc<ClientReferenceManifest>> {\n     let graph = graph.await?;\n-    let client_references = graph\n+    let manifest = graph\n         .iter_nodes()\n         .map(|node| async move {\n             let module = node.module;\n@@ -76,7 +78,7 @@ pub async fn map_client_references(\n             {\n                 Ok(Some((\n                     module,\n-                    ClientReferenceMapType::EcmascriptClientReference {\n+                    ClientManifestEntryType::EcmascriptClientReference {\n                         module: client_reference_module,\n                         ssr_module: ResolvedVc::upcast(client_reference_module.await?.ssr_module),\n                     },\n@@ -86,7 +88,7 @@ pub async fn map_client_references(\n             {\n                 Ok(Some((\n                     module,\n-                    ClientReferenceMapType::CssClientReference(\n+                    ClientManifestEntryType::CssClientReference(\n                         client_reference_module.await?.client_module,\n                     ),\n                 )))\n@@ -95,7 +97,7 @@ pub async fn map_client_references(\n             {\n                 Ok(Some((\n                     module,\n-                    ClientReferenceMapType::ServerComponent(server_component),\n+                    ClientManifestEntryType::ServerComponent(server_component),\n                 )))\n             } else {\n                 Ok(None)\n@@ -108,19 +110,19 @@ pub async fn map_client_references(\n \n     let mut server_components = FxIndexSet::default();\n     let mut module_to_server_component_bits = FxHashMap::default();\n-    if !client_references.is_empty() {\n+    if !manifest.is_empty() {\n         graph.traverse_edges_from_entries_fixed_point(\n             graph.entry_modules(),\n             |parent_info, node| {\n                 let module = node.module();\n-                let module_type = client_references.get(&module);\n+                let module_type = manifest.get(&module);\n                 let mut should_visit_children = match module_to_server_component_bits.entry(module)\n                 {\n                     std::collections::hash_map::Entry::Occupied(_) => false,\n                     std::collections::hash_map::Entry::Vacant(vacant_entry) => {\n                         // only do this the first time we visit the node.\n                         let bits = vacant_entry.insert(RoaringBitmap::new());\n-                        if let Some(ClientReferenceMapType::ServerComponent(\n+                        if let Some(ClientManifestEntryType::ServerComponent(\n                             server_component_module,\n                         )) = module_type\n                         {\n@@ -159,8 +161,8 @@ pub async fn map_client_references(\n \n                 Ok(match module_type {\n                     Some(\n-                        ClientReferenceMapType::EcmascriptClientReference { .. }\n-                        | ClientReferenceMapType::CssClientReference { .. },\n+                        ClientManifestEntryType::EcmascriptClientReference { .. }\n+                        | ClientManifestEntryType::CssClientReference { .. },\n                     ) => {\n                         // No need to explore these subgraphs ever, these are the leaves in the\n                         // server component graph\n@@ -183,17 +185,17 @@ pub async fn map_client_references(\n     // Filter down to just the client reference modules to reduce datastructure size\n     let server_components_for_client_references = module_to_server_component_bits\n         .into_iter()\n-        .filter_map(|(k, v)| match client_references.get(&k) {\n+        .filter_map(|(k, v)| match manifest.get(&k) {\n             Some(\n-                ClientReferenceMapType::CssClientReference(_)\n-                | ClientReferenceMapType::EcmascriptClientReference { .. },\n+                ClientManifestEntryType::CssClientReference(_)\n+                | ClientManifestEntryType::EcmascriptClientReference { .. },\n             ) => Some((k, RoaringBitmapWrapper(v))),\n             _ => None,\n         })\n         .collect();\n \n-    Ok(ClientReferencesSet::cell(ClientReferencesSet {\n-        client_references,\n+    Ok(ClientReferenceManifest::cell(ClientReferenceManifest {\n+        manifest,\n         server_components,\n         server_components_for_client_references,\n     }))"
        },
        {
            "sha": "f33447667e70ae2a0c904d2020640ee9f4afe73f",
            "filename": "crates/next-api/src/module_graph.rs",
            "status": "modified",
            "additions": 11,
            "deletions": 11,
            "changes": 22,
            "blob_url": "https://github.com/vercel/next.js/blob/ae2d1099eafbde1091ef77750897cc025f790716/crates%2Fnext-api%2Fsrc%2Fmodule_graph.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/ae2d1099eafbde1091ef77750897cc025f790716/crates%2Fnext-api%2Fsrc%2Fmodule_graph.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fmodule_graph.rs?ref=ae2d1099eafbde1091ef77750897cc025f790716",
            "patch": "@@ -27,7 +27,7 @@ use turbopack_core::{\n };\n \n use crate::{\n-    client_references::{ClientReferenceMapType, ClientReferencesSet, map_client_references},\n+    client_references::{ClientManifestEntryType, ClientReferenceManifest, map_client_references},\n     dynamic_imports::{DynamicImportEntries, DynamicImportEntriesMapType, map_next_dynamic},\n     server_actions::{AllActions, AllModuleActions, map_server_actions, to_rsc_context},\n };\n@@ -243,7 +243,7 @@ pub struct ClientReferencesGraph {\n     is_single_page: bool,\n     graph: ResolvedVc<SingleModuleGraph>,\n     /// List of client references (modules that entries into the client graph)\n-    data: ResolvedVc<ClientReferencesSet>,\n+    data: ResolvedVc<ClientReferenceManifest>,\n }\n \n #[turbo_tasks::value_impl]\n@@ -315,15 +315,15 @@ impl ClientReferencesGraph {\n             // components for each module.\n             graph.traverse_edges_from_entries_dfs(\n                 entries,\n-                // state_map is `module -> ParentType` to tracke whether the module is reachable\n+                // state_map is `module -> ParentType` to track whether the module is reachable\n                 // directly from an entry point.\n                 &mut FxHashMap::default(),\n                 |parent_info, node, state_map| {\n                     let module = node.module();\n-                    let module_type = data.client_references.get(&module);\n+                    let module_type = data.manifest.get(&module);\n \n                     let parent_type =\n-                        if let Some(ClientReferenceMapType::ServerComponent(_)) = module_type {\n+                        if let Some(ClientManifestEntryType::ServerComponent(_)) = module_type {\n                             ParentType::ServerComponent\n                         } else if let Some((parent_node, _)) = parent_info {\n                             *state_map.get(&parent_node.module).unwrap()\n@@ -347,27 +347,27 @@ impl ClientReferencesGraph {\n \n                     Ok(match module_type {\n                         Some(\n-                            ClientReferenceMapType::EcmascriptClientReference { .. }\n-                            | ClientReferenceMapType::CssClientReference { .. },\n+                            ClientManifestEntryType::EcmascriptClientReference { .. }\n+                            | ClientManifestEntryType::CssClientReference { .. },\n                         ) => GraphTraversalAction::Skip,\n                         _ => GraphTraversalAction::Continue,\n                     })\n                 },\n                 |_, node, state_map| {\n                     let module = node.module();\n-                    let Some(module_type) = data.client_references.get(&module) else {\n+                    let Some(module_type) = data.manifest.get(&module) else {\n                         return Ok(());\n                     };\n \n                     let ty = match module_type {\n-                        ClientReferenceMapType::EcmascriptClientReference {\n+                        ClientManifestEntryType::EcmascriptClientReference {\n                             module,\n                             ssr_module: _,\n                         } => ClientReferenceType::EcmascriptClientReference(*module),\n-                        ClientReferenceMapType::CssClientReference(module) => {\n+                        ClientManifestEntryType::CssClientReference(module) => {\n                             ClientReferenceType::CssClientReference(*module)\n                         }\n-                        ClientReferenceMapType::ServerComponent(sc) => {\n+                        ClientManifestEntryType::ServerComponent(sc) => {\n                             server_components.insert(*sc);\n                             return Ok(());\n                         }"
        }
    ],
    "stats": {
        "total": 62,
        "additions": 32,
        "deletions": 30
    }
}