{
    "author": "lukesandberg",
    "message": "[turbopack] Conditionally collect affecting sources (#83921)\n\nThe `affecting_sources` field on `ResolveResult` and `ModuleResolveResult`  are used for file tracing, but not for normal builds.  So make tracking this information conditional.\n\nThis will be a minor performance win for a few reasons\n* no allocations to store these lists\n* no storing this data in the PC database\n* changes to affecting sources won't invalidate resolution results.\n\nCloses PACK-5438",
    "sha": "380fe8c22afb178b3d8f33922d2a324f8b1ef293",
    "files": [
        {
            "sha": "a4ab3a0cf9dad4ba49a9c690a0b9a661c38ef7fb",
            "filename": "crates/next-api/src/project.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/380fe8c22afb178b3d8f33922d2a324f8b1ef293/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/380fe8c22afb178b3d8f33922d2a324f8b1ef293/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fproject.rs?ref=380fe8c22afb178b3d8f33922d2a324f8b1ef293",
            "patch": "@@ -1411,6 +1411,8 @@ impl Project {\n         Ok(find_context_file(\n             self.project_path().owned().await?,\n             middleware_files(self.next_config().page_extensions()),\n+            // our callers do not care about affecting sources\n+            false,\n         ))\n     }\n \n@@ -1570,6 +1572,8 @@ impl Project {\n         Ok(find_context_file(\n             self.project_path().owned().await?,\n             instrumentation_files(self.next_config().page_extensions()),\n+            // our callers do not care about affecting sources\n+            false,\n         ))\n     }\n "
        },
        {
            "sha": "9e6c15cea4c2173f9720c6e1b352a451d1b8b78d",
            "filename": "crates/next-core/src/next_server/resolve.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/380fe8c22afb178b3d8f33922d2a324f8b1ef293/crates%2Fnext-core%2Fsrc%2Fnext_server%2Fresolve.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/380fe8c22afb178b3d8f33922d2a324f8b1ef293/crates%2Fnext-core%2Fsrc%2Fnext_server%2Fresolve.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_server%2Fresolve.rs?ref=380fe8c22afb178b3d8f33922d2a324f8b1ef293",
            "patch": "@@ -182,7 +182,7 @@ impl AfterResolvePlugin for ExternalCjsModulesResolvePlugin {\n                     // for .js extension in cjs context, we need to check the actual module type via\n                     // package.json\n                     let FindContextFileResult::Found(package_json, _) =\n-                        &*find_context_file(fs_path.parent(), package_json()).await?\n+                        &*find_context_file(fs_path.parent(), package_json(), false).await?\n                     else {\n                         // can't find package.json\n                         return Ok(FileType::CommonJs);\n@@ -283,10 +283,11 @@ impl AfterResolvePlugin for ExternalCjsModulesResolvePlugin {\n \n         if result_from_original_location != result {\n             let package_json_file =\n-                find_context_file(result.ident().path().await?.parent(), package_json());\n+                find_context_file(result.ident().path().await?.parent(), package_json(), false);\n             let package_json_from_original_location = find_context_file(\n                 result_from_original_location.ident().path().await?.parent(),\n                 package_json(),\n+                false,\n             );\n             let FindContextFileResult::Found(package_json_file, _) = &*package_json_file.await?\n             else {"
        },
        {
            "sha": "491da4a7b66360dbb9cb1911202ada321623a442",
            "filename": "crates/next-core/src/transform_options.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/380fe8c22afb178b3d8f33922d2a324f8b1ef293/crates%2Fnext-core%2Fsrc%2Ftransform_options.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/380fe8c22afb178b3d8f33922d2a324f8b1ef293/crates%2Fnext-core%2Fsrc%2Ftransform_options.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Ftransform_options.rs?ref=380fe8c22afb178b3d8f33922d2a324f8b1ef293",
            "patch": "@@ -33,7 +33,7 @@ async fn get_typescript_options(\n \n         Ok(tsconfigs)\n     } else {\n-        let tsconfig = find_context_file(project_path, tsconfig());\n+        let tsconfig = find_context_file(project_path, tsconfig(), false);\n         Ok(match tsconfig.await.ok().as_deref() {\n             Some(FindContextFileResult::Found(path, _)) => read_tsconfigs(\n                 path.read(),"
        },
        {
            "sha": "14b22842bdd70c1faf1bfbc0fcdf89fc8c48d342",
            "filename": "turbopack/crates/turbopack-core/src/resolve/mod.rs",
            "status": "modified",
            "additions": 212,
            "deletions": 265,
            "changes": 477,
            "blob_url": "https://github.com/vercel/next.js/blob/380fe8c22afb178b3d8f33922d2a324f8b1ef293/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/380fe8c22afb178b3d8f33922d2a324f8b1ef293/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fmod.rs?ref=380fe8c22afb178b3d8f33922d2a324f8b1ef293",
            "patch": "@@ -13,7 +13,7 @@ use tracing::{Instrument, Level};\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{\n     FxIndexMap, FxIndexSet, NonLocalValue, ReadRef, ResolvedVc, SliceMap, TaskInput,\n-    TryJoinIterExt, ValueToString, Vc, trace::TraceRawVcs,\n+    TryFlatJoinIterExt, TryJoinIterExt, ValueToString, Vc, trace::TraceRawVcs,\n };\n use turbo_tasks_fs::{FileSystemEntryType, FileSystemPath};\n use turbo_unix_path::normalize_request;\n@@ -146,6 +146,8 @@ impl ExportUsage {\n #[derive(Clone)]\n pub struct ModuleResolveResult {\n     pub primary: SliceMap<RequestKey, ModuleResolveResultItem>,\n+    /// Affecting sources are other files that influence the resolve result.  For example,\n+    /// traversed symlinks\n     pub affecting_sources: Box<[ResolvedVc<Box<dyn Source>>]>,\n }\n \n@@ -158,16 +160,6 @@ impl ModuleResolveResult {\n         .resolved_cell()\n     }\n \n-    pub fn unresolvable_with_affecting_sources(\n-        affecting_sources: Vec<ResolvedVc<Box<dyn Source>>>,\n-    ) -> ResolvedVc<Self> {\n-        ModuleResolveResult {\n-            primary: Default::default(),\n-            affecting_sources: affecting_sources.into_boxed_slice(),\n-        }\n-        .resolved_cell()\n-    }\n-\n     pub fn module(module: ResolvedVc<Box<dyn Module>>) -> ResolvedVc<Self> {\n         Self::module_with_key(RequestKey::default(), module)\n     }\n@@ -292,61 +284,6 @@ impl ModuleResolveResultBuilder {\n \n #[turbo_tasks::value_impl]\n impl ModuleResolveResult {\n-    #[turbo_tasks::function]\n-    pub fn with_affecting_source(&self, source: ResolvedVc<Box<dyn Source>>) -> Result<Vc<Self>> {\n-        Ok(Self {\n-            primary: self.primary.clone(),\n-            affecting_sources: self\n-                .affecting_sources\n-                .iter()\n-                .copied()\n-                .chain(std::iter::once(source))\n-                .collect(),\n-        }\n-        .cell())\n-    }\n-\n-    #[turbo_tasks::function]\n-    pub fn with_affecting_sources(\n-        &self,\n-        sources: Vec<ResolvedVc<Box<dyn Source>>>,\n-    ) -> Result<Vc<Self>> {\n-        Ok(Self {\n-            primary: self.primary.clone(),\n-            affecting_sources: self\n-                .affecting_sources\n-                .iter()\n-                .copied()\n-                .chain(sources)\n-                .collect(),\n-        }\n-        .cell())\n-    }\n-\n-    /// Returns the first [ModuleResolveResult] that is not\n-    /// [ModuleResolveResult::Unresolvable] in the given list, while keeping\n-    /// track of all the affecting_sources in all the [ModuleResolveResult]s.\n-    #[turbo_tasks::function]\n-    async fn select_first(results: Vec<Vc<ModuleResolveResult>>) -> Result<Vc<Self>> {\n-        let mut affecting_sources = vec![];\n-        for result in &results {\n-            affecting_sources.extend(result.await?.affecting_sources_iter());\n-        }\n-        for result in results {\n-            let result_ref = result.await?;\n-            if !result_ref.is_unresolvable_ref() {\n-                return Ok(Self {\n-                    primary: result_ref.primary.clone(),\n-                    affecting_sources: affecting_sources.into_boxed_slice(),\n-                }\n-                .cell());\n-            }\n-        }\n-        Ok(*ModuleResolveResult::unresolvable_with_affecting_sources(\n-            affecting_sources,\n-        ))\n-    }\n-\n     #[turbo_tasks::function]\n     pub async fn alternatives(results: Vec<Vc<ModuleResolveResult>>) -> Result<Vc<Self>> {\n         if results.len() == 1 {\n@@ -366,38 +303,6 @@ impl ModuleResolveResult {\n         }\n     }\n \n-    #[turbo_tasks::function]\n-    async fn alternatives_with_affecting_sources(\n-        results: Vec<Vc<ModuleResolveResult>>,\n-        affecting_sources: Vec<ResolvedVc<Box<dyn Source>>>,\n-    ) -> Result<Vc<Self>> {\n-        if affecting_sources.is_empty() {\n-            return Ok(Self::alternatives(results));\n-        }\n-        if results.len() == 1 {\n-            return Ok(results\n-                .into_iter()\n-                .next()\n-                .unwrap()\n-                .with_affecting_sources(affecting_sources.into_iter().map(|src| *src).collect()));\n-        }\n-        let mut iter = results.into_iter().try_join().await?.into_iter();\n-        if let Some(current) = iter.next() {\n-            let mut current: ModuleResolveResultBuilder = ReadRef::into_owned(current).into();\n-            for result in iter {\n-                // For clippy -- This explicit deref is necessary\n-                let other = &*result;\n-                current.merge_alternatives(other);\n-            }\n-            current.affecting_sources.extend(affecting_sources);\n-            Ok(Self::cell(current.into()))\n-        } else {\n-            Ok(*ModuleResolveResult::unresolvable_with_affecting_sources(\n-                affecting_sources,\n-            ))\n-        }\n-    }\n-\n     #[turbo_tasks::function]\n     pub fn is_unresolvable(&self) -> Vc<bool> {\n         Vc::cell(self.is_unresolvable_ref())\n@@ -563,6 +468,8 @@ impl RequestKey {\n #[derive(Clone)]\n pub struct ResolveResult {\n     pub primary: SliceMap<RequestKey, ResolveResultItem>,\n+    /// Affecting sources are other files that influence the resolve result.  For example,\n+    /// traversed symlinks\n     pub affecting_sources: Box<[ResolvedVc<Box<dyn Source>>]>,\n }\n \n@@ -696,6 +603,8 @@ impl ResolveResult {\n }\n \n impl ResolveResult {\n+    /// Returns the affecting sources for this result. Will be empty if affecting sources are\n+    /// disabled for this result.\n     pub fn get_affecting_sources(&self) -> impl Iterator<Item = ResolvedVc<Box<dyn Source>>> + '_ {\n         self.affecting_sources.iter().copied()\n     }\n@@ -865,20 +774,6 @@ impl ResolveResult {\n             .cell())\n     }\n \n-    #[turbo_tasks::function]\n-    fn with_affecting_source(&self, source: ResolvedVc<Box<dyn Source>>) -> Result<Vc<Self>> {\n-        Ok(Self {\n-            primary: self.primary.clone(),\n-            affecting_sources: self\n-                .affecting_sources\n-                .iter()\n-                .copied()\n-                .chain(std::iter::once(source))\n-                .collect(),\n-        }\n-        .cell())\n-    }\n-\n     #[turbo_tasks::function]\n     fn with_affecting_sources(\n         &self,\n@@ -896,30 +791,6 @@ impl ResolveResult {\n         .cell())\n     }\n \n-    /// Returns the first [ResolveResult] that is not\n-    /// [ResolveResult::Unresolvable] in the given list, while keeping track\n-    /// of all the affecting_sources in all the [ResolveResult]s.\n-    #[turbo_tasks::function]\n-    async fn select_first(results: Vec<Vc<ResolveResult>>) -> Result<Vc<Self>> {\n-        let mut affecting_sources = vec![];\n-        for result in &results {\n-            affecting_sources.extend(result.await?.get_affecting_sources());\n-        }\n-        for result in results {\n-            let result_ref = result.await?;\n-            if !result_ref.is_unresolvable_ref() {\n-                return Ok(Self {\n-                    primary: result_ref.primary.clone(),\n-                    affecting_sources: affecting_sources.into_boxed_slice(),\n-                }\n-                .cell());\n-            }\n-        }\n-        Ok(*ResolveResult::unresolvable_with_affecting_sources(\n-            affecting_sources,\n-        ))\n-    }\n-\n     #[turbo_tasks::function]\n     async fn alternatives(results: Vec<Vc<ResolveResult>>) -> Result<Vc<Self>> {\n         if results.len() == 1 {\n@@ -944,9 +815,10 @@ impl ResolveResult {\n         results: Vec<Vc<ResolveResult>>,\n         affecting_sources: Vec<ResolvedVc<Box<dyn Source>>>,\n     ) -> Result<Vc<Self>> {\n-        if affecting_sources.is_empty() {\n-            return Ok(Self::alternatives(results));\n-        }\n+        debug_assert!(\n+            !affecting_sources.is_empty(),\n+            \"Caller should not call this function if there are no affecting sources\"\n+        );\n         if results.len() == 1 {\n             return Ok(results\n                 .into_iter()\n@@ -1143,22 +1015,22 @@ impl ResolveResultOption {\n \n async fn exists(\n     fs_path: &FileSystemPath,\n-    refs: &mut Vec<ResolvedVc<Box<dyn Source>>>,\n+    refs: Option<&mut Vec<ResolvedVc<Box<dyn Source>>>>,\n ) -> Result<Option<FileSystemPath>> {\n     type_exists(fs_path, FileSystemEntryType::File, refs).await\n }\n \n async fn dir_exists(\n     fs_path: &FileSystemPath,\n-    refs: &mut Vec<ResolvedVc<Box<dyn Source>>>,\n+    refs: Option<&mut Vec<ResolvedVc<Box<dyn Source>>>>,\n ) -> Result<Option<FileSystemPath>> {\n     type_exists(fs_path, FileSystemEntryType::Directory, refs).await\n }\n \n async fn type_exists(\n     fs_path: &FileSystemPath,\n     ty: FileSystemEntryType,\n-    refs: &mut Vec<ResolvedVc<Box<dyn Source>>>,\n+    refs: Option<&mut Vec<ResolvedVc<Box<dyn Source>>>>,\n ) -> Result<Option<FileSystemPath>> {\n     let path = realpath(fs_path, refs).await?;\n     Ok(if *path.get_type().await? == ty {\n@@ -1170,21 +1042,23 @@ async fn type_exists(\n \n async fn realpath(\n     fs_path: &FileSystemPath,\n-    refs: &mut Vec<ResolvedVc<Box<dyn Source>>>,\n+    refs: Option<&mut Vec<ResolvedVc<Box<dyn Source>>>>,\n ) -> Result<FileSystemPath> {\n     let result = fs_path.realpath_with_links().await?;\n-    refs.extend(\n-        result\n-            .symlinks\n-            .iter()\n-            .map(|path| async move {\n-                Ok(ResolvedVc::upcast(\n-                    FileSource::new(path.clone()).to_resolved().await?,\n-                ))\n-            })\n-            .try_join()\n-            .await?,\n-    );\n+    if let Some(refs) = refs {\n+        refs.extend(\n+            result\n+                .symlinks\n+                .iter()\n+                .map(|path| async move {\n+                    Ok(ResolvedVc::upcast(\n+                        FileSource::new(path.clone()).to_resolved().await?,\n+                    ))\n+                })\n+                .try_join()\n+                .await?,\n+        );\n+    }\n     match &result.path_result {\n         Ok(path) => Ok(path.clone()),\n         Err(e) => bail!(e.as_error_message(fs_path, &result)),\n@@ -1240,7 +1114,8 @@ enum ImportsFieldResult {\n /// into an appropriate [AliasMap] for lookups.\n #[turbo_tasks::function]\n async fn imports_field(lookup_path: FileSystemPath) -> Result<Vc<ImportsFieldResult>> {\n-    let package_json_context = find_context_file(lookup_path, package_json()).await?;\n+    // We don't need to collect affecting sources here because we don't use them\n+    let package_json_context = find_context_file(lookup_path, package_json(), false).await?;\n     let FindContextFileResult::Found(package_json_path, _refs) = &*package_json_context else {\n         return Ok(ImportsFieldResult::None.cell());\n     };\n@@ -1287,11 +1162,21 @@ pub enum FindContextFileResult {\n pub async fn find_context_file(\n     lookup_path: FileSystemPath,\n     names: Vc<Vec<RcStr>>,\n+    collect_affecting_sources: bool,\n ) -> Result<Vc<FindContextFileResult>> {\n     let mut refs = Vec::new();\n     for name in &*names.await? {\n         let fs_path = lookup_path.join(name)?;\n-        if let Some(fs_path) = exists(&fs_path, &mut refs).await? {\n+        if let Some(fs_path) = exists(\n+            &fs_path,\n+            if collect_affecting_sources {\n+                Some(&mut refs)\n+            } else {\n+                None\n+            },\n+        )\n+        .await?\n+        {\n             return Ok(FindContextFileResult::Found(fs_path, refs).cell());\n         }\n     }\n@@ -1301,13 +1186,13 @@ pub async fn find_context_file(\n     if refs.is_empty() {\n         // Tailcall\n         Ok(find_context_file(\n-            // Hot codepath optimization: resolve all arguments to avoid an automatically-created\n-            // intermediate task\n             lookup_path.parent(),\n             names,\n+            collect_affecting_sources,\n         ))\n     } else {\n-        let parent_result = find_context_file(lookup_path.parent(), names).await?;\n+        let parent_result =\n+            find_context_file(lookup_path.parent(), names, collect_affecting_sources).await?;\n         Ok(match &*parent_result {\n             FindContextFileResult::Found(p, r) => {\n                 refs.extend(r.iter().copied());\n@@ -1323,47 +1208,32 @@ pub async fn find_context_file(\n }\n \n // Same as find_context_file, but also stop for package.json with the specified key\n+// This function never collects affecting sources\n #[turbo_tasks::function]\n pub async fn find_context_file_or_package_key(\n     lookup_path: FileSystemPath,\n     names: Vc<Vec<RcStr>>,\n     package_key: RcStr,\n ) -> Result<Vc<FindContextFileResult>> {\n-    let mut refs = Vec::new();\n     let package_json_path = lookup_path.join(\"package.json\")?;\n-    if let Some(package_json_path) = exists(&package_json_path, &mut refs).await?\n+    if let Some(package_json_path) = exists(&package_json_path, None).await?\n         && let Some(json) =\n             &*read_package_json(Vc::upcast(FileSource::new(package_json_path.clone()))).await?\n         && json.get(&*package_key).is_some()\n     {\n-        return Ok(FindContextFileResult::Found(package_json_path, refs).into());\n+        return Ok(FindContextFileResult::Found(package_json_path, Vec::new()).into());\n     }\n     for name in &*names.await? {\n         let fs_path = lookup_path.join(name)?;\n-        if let Some(fs_path) = exists(&fs_path, &mut refs).await? {\n-            return Ok(FindContextFileResult::Found(fs_path, refs).into());\n+        if let Some(fs_path) = exists(&fs_path, None).await? {\n+            return Ok(FindContextFileResult::Found(fs_path, Vec::new()).into());\n         }\n     }\n     if lookup_path.is_root() {\n-        return Ok(FindContextFileResult::NotFound(refs).into());\n-    }\n-    if refs.is_empty() {\n-        // Tailcall\n-        Ok(find_context_file(lookup_path.parent(), names))\n-    } else {\n-        let parent_result = find_context_file(lookup_path.parent(), names).await?;\n-        Ok(match &*parent_result {\n-            FindContextFileResult::Found(p, r) => {\n-                refs.extend(r.iter().copied());\n-                FindContextFileResult::Found(p.clone(), refs)\n-            }\n-            FindContextFileResult::NotFound(r) => {\n-                refs.extend(r.iter().copied());\n-                FindContextFileResult::NotFound(refs)\n-            }\n-        }\n-        .into())\n+        return Ok(FindContextFileResult::NotFound(Vec::new()).into());\n     }\n+\n+    Ok(find_context_file(lookup_path.parent(), names, false))\n }\n \n #[derive(Clone, PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, Debug, NonLocalValue)]\n@@ -1376,6 +1246,7 @@ enum FindPackageItem {\n #[derive(Debug)]\n struct FindPackageResult {\n     packages: Vec<FindPackageItem>,\n+    // Only populated if collect_affecting_sources is true\n     affecting_sources: Vec<ResolvedVc<Box<dyn Source>>>,\n }\n \n@@ -1384,6 +1255,7 @@ async fn find_package(\n     lookup_path: FileSystemPath,\n     package_name: Pattern,\n     options: Vc<ResolveModulesOptions>,\n+    collect_affecting_sources: bool,\n ) -> Result<Vc<FindPackageResult>> {\n     let mut packages = vec![];\n     let mut affecting_sources = vec![];\n@@ -1406,15 +1278,25 @@ async fn find_package(\n                 while lookup_path_value.is_inside_ref(root) {\n                     for name in names.iter() {\n                         let fs_path = lookup_path.join(name)?;\n-                        if let Some(fs_path) = dir_exists(&fs_path, &mut affecting_sources).await? {\n+                        if let Some(fs_path) = dir_exists(\n+                            &fs_path,\n+                            collect_affecting_sources.then_some(&mut affecting_sources),\n+                        )\n+                        .await?\n+                        {\n                             let matches =\n                                 read_matches(fs_path.clone(), rcstr!(\"\"), true, package_name_cell)\n                                     .await?;\n                             for m in &*matches {\n                                 if let PatternMatch::Directory(_, package_dir) = m {\n                                     packages.push(FindPackageItem::PackageDirectory {\n                                         name: get_package_name(&fs_path, package_dir)?,\n-                                        dir: realpath(package_dir, &mut affecting_sources).await?,\n+                                        dir: realpath(\n+                                            package_dir,\n+                                            collect_affecting_sources\n+                                                .then_some(&mut affecting_sources),\n+                                        )\n+                                        .await?,\n                                     });\n                                 }\n                             }\n@@ -1439,13 +1321,21 @@ async fn find_package(\n                         PatternMatch::Directory(_, package_dir) => {\n                             packages.push(FindPackageItem::PackageDirectory {\n                                 name: get_package_name(dir, package_dir)?,\n-                                dir: realpath(package_dir, &mut affecting_sources).await?,\n+                                dir: realpath(\n+                                    package_dir,\n+                                    collect_affecting_sources.then_some(&mut affecting_sources),\n+                                )\n+                                .await?,\n                             });\n                         }\n                         PatternMatch::File(_, package_file) => {\n                             packages.push(FindPackageItem::PackageFile {\n                                 name: get_package_name(dir, package_file)?,\n-                                file: realpath(package_file, &mut affecting_sources).await?,\n+                                file: realpath(\n+                                    package_file,\n+                                    collect_affecting_sources.then_some(&mut affecting_sources),\n+                                )\n+                                .await?,\n                             });\n                         }\n                     }\n@@ -1470,7 +1360,11 @@ async fn find_package(\n                     if let PatternMatch::File(_, package_file) = m {\n                         packages.push(FindPackageItem::PackageFile {\n                             name: get_package_name(dir, package_file)?,\n-                            file: realpath(package_file, &mut affecting_sources).await?,\n+                            file: realpath(\n+                                package_file,\n+                                collect_affecting_sources.then_some(&mut affecting_sources),\n+                            )\n+                            .await?,\n                         });\n                     }\n                 }\n@@ -1512,32 +1406,60 @@ fn merge_results_with_affecting_sources(\n     }\n }\n \n+// Resolves the pattern\n #[turbo_tasks::function]\n pub async fn resolve_raw(\n     lookup_dir: FileSystemPath,\n     path: Vc<Pattern>,\n+    collect_affecting_sources: bool,\n     force_in_lookup_dir: bool,\n ) -> Result<Vc<ResolveResult>> {\n-    async fn to_result(request: RcStr, path: FileSystemPath) -> Result<Vc<ResolveResult>> {\n+    async fn to_result(\n+        request: RcStr,\n+        path: FileSystemPath,\n+        collect_affecting_sources: bool,\n+    ) -> Result<Vc<ResolveResult>> {\n         let result = &*path.realpath_with_links().await?;\n         let path = match &result.path_result {\n             Ok(path) => path,\n             Err(e) => bail!(e.as_error_message(&path, result)),\n         };\n-        Ok(*ResolveResult::source_with_affecting_sources(\n-            RequestKey::new(request),\n-            ResolvedVc::upcast(FileSource::new(path.clone()).to_resolved().await?),\n-            result\n-                .symlinks\n-                .iter()\n-                .map(|symlink| async move {\n-                    anyhow::Ok(ResolvedVc::upcast(\n-                        FileSource::new(symlink.clone()).to_resolved().await?,\n-                    ))\n+        let request_key = RequestKey::new(request);\n+        let source = ResolvedVc::upcast(FileSource::new(path.clone()).to_resolved().await?);\n+        Ok(*if collect_affecting_sources {\n+            ResolveResult::source_with_affecting_sources(\n+                request_key,\n+                source,\n+                result\n+                    .symlinks\n+                    .iter()\n+                    .map(|symlink| {\n+                        Vc::upcast::<Box<dyn Source>>(FileSource::new(symlink.clone()))\n+                            .to_resolved()\n+                    })\n+                    .try_join()\n+                    .await?,\n+            )\n+        } else {\n+            ResolveResult::source_with_key(request_key, source)\n+        })\n+    }\n+\n+    async fn collect_matches(\n+        matches: &[PatternMatch],\n+        collect_affecting_sources: bool,\n+    ) -> Result<Vec<Vc<ResolveResult>>> {\n+        matches\n+            .iter()\n+            .map(|m| async move {\n+                Ok(if let PatternMatch::File(request, path) = m {\n+                    Some(to_result(request.clone(), path.clone(), collect_affecting_sources).await?)\n+                } else {\n+                    None\n                 })\n-                .try_join()\n-                .await?,\n-        ))\n+            })\n+            .try_flat_join()\n+            .await\n     }\n \n     let mut results = Vec::new();\n@@ -1565,11 +1487,11 @@ pub async fn resolve_raw(\n                 matches.len()\n             );\n         } else {\n-            for m in matches.iter() {\n-                if let PatternMatch::File(request, path) = m {\n-                    results.push(to_result(request.clone(), path.clone()).await?);\n-                }\n-            }\n+            results.extend(\n+                collect_matches(&matches, collect_affecting_sources)\n+                    .await?\n+                    .into_iter(),\n+            );\n         }\n     }\n \n@@ -1583,11 +1505,11 @@ pub async fn resolve_raw(\n                 matches.len()\n             );\n         }\n-        for m in matches.iter() {\n-            if let PatternMatch::File(request, path) = m {\n-                results.push(to_result(request.clone(), path.clone()).await?);\n-            }\n-        }\n+        results.extend(\n+            collect_matches(&matches, collect_affecting_sources)\n+                .await?\n+                .into_iter(),\n+        );\n     }\n \n     Ok(merge_results(results))\n@@ -1664,19 +1586,23 @@ pub async fn url_resolve(\n     );\n     let result = if *rel_result.is_unresolvable().await? && rel_request.resolve().await? != request\n     {\n-        resolve(\n+        let result = resolve(\n             origin.origin_path().await?.parent(),\n             reference_type.clone(),\n             request,\n             resolve_options,\n-        )\n-        .with_affecting_sources(\n-            rel_result\n-                .await?\n-                .get_affecting_sources()\n-                .map(|src| *src)\n-                .collect(),\n-        )\n+        );\n+        if resolve_options.await?.collect_affecting_sources {\n+            result.with_affecting_sources(\n+                rel_result\n+                    .await?\n+                    .get_affecting_sources()\n+                    .map(|src| *src)\n+                    .collect(),\n+            )\n+        } else {\n+            result\n+        }\n     } else {\n         rel_result\n     };\n@@ -2146,8 +2072,15 @@ async fn resolve_into_folder(\n     let options_value = options.await?;\n \n     let mut affecting_sources = vec![];\n-    if let Some(package_json_path) =\n-        exists(&package_path.join(\"package.json\")?, &mut affecting_sources).await?\n+    if let Some(package_json_path) = exists(\n+        &package_path.join(\"package.json\")?,\n+        if options_value.collect_affecting_sources {\n+            Some(&mut affecting_sources)\n+        } else {\n+            None\n+        },\n+    )\n+    .await?\n     {\n         for resolve_into_package in options_value.into_package.iter() {\n             match resolve_into_package {\n@@ -2181,10 +2114,12 @@ async fn resolve_into_folder(\n                         if !result.is_unresolvable_ref() {\n                             let mut result: ResolveResultBuilder =\n                                 result.with_request_ref(rcstr!(\".\")).into();\n-                            result.affecting_sources.push(ResolvedVc::upcast(\n-                                FileSource::new(package_json_path).to_resolved().await?,\n-                            ));\n-                            result.affecting_sources.extend(affecting_sources);\n+                            if options_value.collect_affecting_sources {\n+                                result.affecting_sources.push(ResolvedVc::upcast(\n+                                    FileSource::new(package_json_path).to_resolved().await?,\n+                                ));\n+                                result.affecting_sources.extend(affecting_sources);\n+                            }\n                             return Ok(ResolveResult::from(result).cell());\n                         }\n                     };\n@@ -2217,13 +2152,15 @@ async fn resolve_into_folder(\n     };\n \n     let request = Request::parse(pattern);\n+    let result = resolve_internal_inline(package_path.clone(), request, options)\n+        .await?\n+        .with_request(rcstr!(\".\"));\n \n-    Ok(\n-        resolve_internal_inline(package_path.clone(), request, options)\n-            .await?\n-            .with_request(rcstr!(\".\"))\n-            .with_affecting_sources(ResolvedVc::deref_vec(affecting_sources)),\n-    )\n+    Ok(if !affecting_sources.is_empty() {\n+        result.with_affecting_sources(ResolvedVc::deref_vec(affecting_sources))\n+    } else {\n+        result\n+    })\n }\n \n #[tracing::instrument(level = Level::TRACE, skip_all)]\n@@ -2449,8 +2386,12 @@ async fn apply_in_package(\n             continue;\n         };\n \n-        let FindContextFileResult::Found(package_json_path, refs) =\n-            &*find_context_file(lookup_path.clone(), package_json().resolve().await?).await?\n+        let FindContextFileResult::Found(package_json_path, refs) = &*find_context_file(\n+            lookup_path.clone(),\n+            package_json().resolve().await?,\n+            options_value.collect_affecting_sources,\n+        )\n+        .await?\n         else {\n             continue;\n         };\n@@ -2498,17 +2439,18 @@ async fn apply_in_package(\n                 // This would be a cycle, so we ignore it\n                 return Ok(None);\n             }\n-            return Ok(Some(\n-                resolve_internal(\n-                    package_path,\n-                    Request::parse(Pattern::Constant(value.into()))\n-                        .with_query(query.clone())\n-                        .with_fragment(fragment.clone()),\n-                    options,\n-                )\n-                .with_replaced_request_key(value.into(), request_key)\n-                .with_affecting_sources(refs.into_iter().map(|src| *src).collect()),\n-            ));\n+            let mut result = resolve_internal(\n+                package_path,\n+                Request::parse(Pattern::Constant(value.into()))\n+                    .with_query(query.clone())\n+                    .with_fragment(fragment.clone()),\n+                options,\n+            )\n+            .with_replaced_request_key(value.into(), request_key);\n+            if options_value.collect_affecting_sources && !refs.is_empty() {\n+                result = result.with_affecting_sources(refs.into_iter().map(|src| *src).collect());\n+            }\n+            return Ok(Some(result));\n         }\n \n         ResolvingIssue {\n@@ -2547,7 +2489,7 @@ enum FindSelfReferencePackageResult {\n async fn find_self_reference(\n     lookup_path: FileSystemPath,\n ) -> Result<Vc<FindSelfReferencePackageResult>> {\n-    let package_json_context = find_context_file(lookup_path, package_json()).await?;\n+    let package_json_context = find_context_file(lookup_path, package_json(), false).await?;\n     if let FindContextFileResult::Found(package_json_path, _refs) = &*package_json_context {\n         let read =\n             read_package_json(Vc::upcast(FileSource::new(package_json_path.clone()))).await?;\n@@ -2618,6 +2560,7 @@ async fn resolve_module_request(\n         lookup_path.clone(),\n         module.clone(),\n         resolve_modules_options(options).resolve().await?,\n+        options_value.collect_affecting_sources,\n     )\n     .await?;\n \n@@ -2912,25 +2855,29 @@ async fn resolved(\n             return Ok(result);\n         }\n     }\n-\n-    Ok(*ResolveResult::source_with_affecting_sources(\n-        request_key,\n-        ResolvedVc::upcast(\n-            FileSource::new_with_query_and_fragment(path.clone(), query, fragment)\n-                .to_resolved()\n-                .await?,\n-        ),\n-        result\n-            .symlinks\n-            .iter()\n-            .map(|symlink| async move {\n-                anyhow::Ok(ResolvedVc::upcast(\n-                    FileSource::new(symlink.clone()).to_resolved().await?,\n-                ))\n-            })\n-            .try_join()\n+    let source = ResolvedVc::upcast(\n+        FileSource::new_with_query_and_fragment(path.clone(), query, fragment)\n+            .to_resolved()\n             .await?,\n-    ))\n+    );\n+    if options_value.collect_affecting_sources {\n+        Ok(*ResolveResult::source_with_affecting_sources(\n+            request_key,\n+            source,\n+            result\n+                .symlinks\n+                .iter()\n+                .map(|symlink| async move {\n+                    anyhow::Ok(ResolvedVc::upcast(\n+                        FileSource::new(symlink.clone()).to_resolved().await?,\n+                    ))\n+                })\n+                .try_join()\n+                .await?,\n+        ))\n+    } else {\n+        Ok(*ResolveResult::source_with_key(request_key, source))\n+    }\n }\n \n async fn handle_exports_imports_field("
        },
        {
            "sha": "68520241d523266363ed8ecde8bbbfa1f1ec176a",
            "filename": "turbopack/crates/turbopack-core/src/resolve/options.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/380fe8c22afb178b3d8f33922d2a324f8b1ef293/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Foptions.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/380fe8c22afb178b3d8f33922d2a324f8b1ef293/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Foptions.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Foptions.rs?ref=380fe8c22afb178b3d8f33922d2a324f8b1ef293",
            "patch": "@@ -621,6 +621,8 @@ pub struct ResolveOptions {\n     pub enable_typescript_with_output_extension: bool,\n     /// Warn instead of error for resolve errors\n     pub loose_errors: bool,\n+    /// Collect affecting sources for each resolve result.  Useful for tracing.\n+    pub collect_affecting_sources: bool,\n     /// Whether to parse data URIs into modules (as opposed to keeping them as externals)\n     pub parse_data_uris: bool,\n "
        },
        {
            "sha": "63e6ce6edb4e57dba5008f04519b533d9944d854",
            "filename": "turbopack/crates/turbopack-ecmascript/src/chunk/placeable.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/380fe8c22afb178b3d8f33922d2a324f8b1ef293/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fchunk%2Fplaceable.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/380fe8c22afb178b3d8f33922d2a324f8b1ef293/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fchunk%2Fplaceable.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fchunk%2Fplaceable.rs?ref=380fe8c22afb178b3d8f33922d2a324f8b1ef293",
            "patch": "@@ -198,7 +198,7 @@ pub async fn is_marked_as_side_effect_free(\n         return Ok(Vc::cell(true));\n     }\n \n-    let find_package_json = find_context_file(path.parent(), package_json()).await?;\n+    let find_package_json = find_context_file(path.parent(), package_json(), false).await?;\n \n     if let FindContextFileResult::Found(package_json, _) = &*find_package_json {\n         match *side_effects_from_package_json(package_json.clone()).await? {"
        },
        {
            "sha": "11b335b10c0d797067d1c444e497032db97ea766",
            "filename": "turbopack/crates/turbopack-ecmascript/src/lib.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/380fe8c22afb178b3d8f33922d2a324f8b1ef293/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/380fe8c22afb178b3d8f33922d2a324f8b1ef293/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs?ref=380fe8c22afb178b3d8f33922d2a324f8b1ef293",
            "patch": "@@ -582,7 +582,7 @@ async fn determine_module_type_for_directory(\n     context_path: FileSystemPath,\n ) -> Result<Vc<ModuleTypeResult>> {\n     let find_package_json =\n-        find_context_file(context_path, package_json().resolve().await?).await?;\n+        find_context_file(context_path, package_json().resolve().await?, false).await?;\n     let FindContextFileResult::Found(package_json, _) = &*find_package_json else {\n         return Ok(ModuleTypeResult::new(SpecifiedModuleType::Automatic));\n     };"
        },
        {
            "sha": "ac050882237d5a3f0964af4a0911de0ae50ecdda",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/mod.rs",
            "status": "modified",
            "additions": 24,
            "deletions": 10,
            "changes": 34,
            "blob_url": "https://github.com/vercel/next.js/blob/380fe8c22afb178b3d8f33922d2a324f8b1ef293/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/380fe8c22afb178b3d8f33922d2a324f8b1ef293/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fmod.rs?ref=380fe8c22afb178b3d8f33922d2a324f8b1ef293",
            "patch": "@@ -440,6 +440,9 @@ struct AnalysisState<'a> {\n     ignore_dynamic_requests: bool,\n     url_rewrite_behavior: Option<UrlRewriteBehavior>,\n     free_var_references: ReadRef<FreeVarReferencesIndividual>,\n+    // Whether we should collect affecting sources from referenced files. Only usedful when\n+    // tracing.\n+    collect_affecting_sources: bool,\n }\n \n impl AnalysisState<'_> {\n@@ -513,7 +516,6 @@ pub async fn analyze_ecmascript_module_internal(\n     let analyze_mode = options.analyze_mode;\n \n     let origin = ResolvedVc::upcast::<Box<dyn ResolveOrigin>>(module);\n-\n     let mut analysis = AnalyzeEcmascriptModuleResultBuilder::new(analyze_mode);\n     let path = &*origin.origin_path().await?;\n \n@@ -554,7 +556,7 @@ pub async fn analyze_ecmascript_module_internal(\n     if analyze_types {\n         let span = tracing::info_span!(\"tsconfig reference\");\n         async {\n-            match &*find_context_file(path.parent(), tsconfig()).await? {\n+            match &*find_context_file(path.parent(), tsconfig(), false).await? {\n                 FindContextFileResult::Found(tsconfig, _) => {\n                     analysis.add_reference(\n                         TsConfigReference::new(*origin, tsconfig.clone())\n@@ -974,6 +976,7 @@ pub async fn analyze_ecmascript_module_internal(\n                 .free_var_references\n                 .individual()\n                 .await?,\n+            collect_affecting_sources: options.analyze_mode.is_tracing(),\n         };\n \n         enum Action {\n@@ -1603,6 +1606,7 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n         compile_time_info,\n         ignore_dynamic_requests,\n         url_rewrite_behavior,\n+        collect_affecting_sources,\n         ..\n     } = state;\n     fn explain_args(args: &[JsValue]) -> (String, String) {\n@@ -1948,7 +1952,7 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                     }\n                 }\n                 analysis.add_reference(\n-                    FileSourceReference::new(*source, Pattern::new(pat))\n+                    FileSourceReference::new(*source, Pattern::new(pat), collect_affecting_sources)\n                         .to_resolved()\n                         .await?,\n                 );\n@@ -1997,7 +2001,7 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                 }\n             }\n             analysis.add_reference(\n-                FileSourceReference::new(*source, Pattern::new(pat))\n+                FileSourceReference::new(*source, Pattern::new(pat), collect_affecting_sources)\n                     .to_resolved()\n                     .await?,\n             );\n@@ -2086,9 +2090,13 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                 }\n                 if !dynamic || !ignore_dynamic_requests {\n                     analysis.add_reference(\n-                        FileSourceReference::new(*source, Pattern::new(pat))\n-                            .to_resolved()\n-                            .await?,\n+                        FileSourceReference::new(\n+                            *source,\n+                            Pattern::new(pat),\n+                            collect_affecting_sources,\n+                        )\n+                        .to_resolved()\n+                        .await?,\n                     );\n                 }\n                 if show_dynamic_warning {\n@@ -2179,6 +2187,7 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                         origin.origin_path().await?.parent(),\n                         Pattern::new(pat),\n                         compile_time_info.environment().compile_target(),\n+                        collect_affecting_sources,\n                     )\n                     .to_resolved()\n                     .await?,\n@@ -2218,6 +2227,7 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                     analysis.add_reference(\n                         NodeGypBuildReference::new(\n                             current_context,\n+                            collect_affecting_sources,\n                             compile_time_info.environment().compile_target(),\n                         )\n                         .to_resolved()\n@@ -2249,9 +2259,13 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                     .await?;\n                 if let Some(s) = first_arg.as_str() {\n                     analysis.add_reference(\n-                        NodeBindingsReference::new(origin.origin_path().owned().await?, s.into())\n-                            .to_resolved()\n-                            .await?,\n+                        NodeBindingsReference::new(\n+                            origin.origin_path().owned().await?,\n+                            s.into(),\n+                            collect_affecting_sources,\n+                        )\n+                        .to_resolved()\n+                        .await?,\n                     );\n                     return Ok(());\n                 }"
        },
        {
            "sha": "54a96b2a72aa82c359d1eacdb79551490d3d5727",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/node.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 8,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/380fe8c22afb178b3d8f33922d2a324f8b1ef293/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fnode.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/380fe8c22afb178b3d8f33922d2a324f8b1ef293/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fnode.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fnode.rs?ref=380fe8c22afb178b3d8f33922d2a324f8b1ef293",
            "patch": "@@ -70,7 +70,6 @@ impl DirAssetReference {\n     }\n }\n \n-#[turbo_tasks::function]\n async fn resolve_reference_from_dir(\n     parent_path: FileSystemPath,\n     path: Vc<Pattern>,\n@@ -155,13 +154,9 @@ impl ModuleReference for DirAssetReference {\n             \"trace directory\",\n             pattern = display(self.path.to_string().await?)\n         );\n-        async {\n-            resolve_reference_from_dir(parent_path, *self.path)\n-                .resolve()\n-                .await\n-        }\n-        .instrument(span)\n-        .await\n+        resolve_reference_from_dir(parent_path, *self.path)\n+            .instrument(span)\n+            .await\n     }\n }\n "
        },
        {
            "sha": "d736d4e83401ee997c91623c69a6bc5a4b70c6af",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/raw.rs",
            "status": "modified",
            "additions": 20,
            "deletions": 6,
            "changes": 26,
            "blob_url": "https://github.com/vercel/next.js/blob/380fe8c22afb178b3d8f33922d2a324f8b1ef293/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fraw.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/380fe8c22afb178b3d8f33922d2a324f8b1ef293/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fraw.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fraw.rs?ref=380fe8c22afb178b3d8f33922d2a324f8b1ef293",
            "patch": "@@ -14,13 +14,22 @@ use turbopack_core::{\n pub struct FileSourceReference {\n     pub source: ResolvedVc<Box<dyn Source>>,\n     pub path: ResolvedVc<Pattern>,\n+    pub collect_affecting_sources: bool,\n }\n \n #[turbo_tasks::value_impl]\n impl FileSourceReference {\n     #[turbo_tasks::function]\n-    pub fn new(source: ResolvedVc<Box<dyn Source>>, path: ResolvedVc<Pattern>) -> Vc<Self> {\n-        Self::cell(FileSourceReference { source, path })\n+    pub fn new(\n+        source: ResolvedVc<Box<dyn Source>>,\n+        path: ResolvedVc<Pattern>,\n+        collect_affecting_sources: bool,\n+    ) -> Vc<Self> {\n+        Self::cell(FileSourceReference {\n+            source,\n+            path,\n+            collect_affecting_sources,\n+        })\n     }\n }\n \n@@ -35,10 +44,15 @@ impl ModuleReference for FileSourceReference {\n             pattern = display(self.path.to_string().await?)\n         );\n         async {\n-            resolve_raw(context_dir, *self.path, false)\n-                .as_raw_module_result()\n-                .resolve()\n-                .await\n+            resolve_raw(\n+                context_dir,\n+                *self.path,\n+                self.collect_affecting_sources,\n+                false,\n+            )\n+            .as_raw_module_result()\n+            .resolve()\n+            .await\n         }\n         .instrument(span)\n         .await"
        },
        {
            "sha": "c1a435f2e879a49043fc59cef92212b5dc37f74c",
            "filename": "turbopack/crates/turbopack-nft/src/nft.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/380fe8c22afb178b3d8f33922d2a324f8b1ef293/turbopack%2Fcrates%2Fturbopack-nft%2Fsrc%2Fnft.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/380fe8c22afb178b3d8f33922d2a324f8b1ef293/turbopack%2Fcrates%2Fturbopack-nft%2Fsrc%2Fnft.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-nft%2Fsrc%2Fnft.rs?ref=380fe8c22afb178b3d8f33922d2a324f8b1ef293",
            "patch": "@@ -105,6 +105,7 @@ async fn node_file_trace_operation(\n             enable_node_modules: Some(input_dir.clone()),\n             custom_conditions: vec![rcstr!(\"node\")],\n             loose_errors: true,\n+            collect_affecting_sources: true,\n             ..Default::default()\n         }\n         .cell(),"
        },
        {
            "sha": "bf0dc0ce6ad63823bc21ddcfe47f8b98094aa95b",
            "filename": "turbopack/crates/turbopack-resolve/src/node_native_binding.rs",
            "status": "modified",
            "additions": 67,
            "deletions": 22,
            "changes": 89,
            "blob_url": "https://github.com/vercel/next.js/blob/380fe8c22afb178b3d8f33922d2a324f8b1ef293/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Fnode_native_binding.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/380fe8c22afb178b3d8f33922d2a324f8b1ef293/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Fnode_native_binding.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Fnode_native_binding.rs?ref=380fe8c22afb178b3d8f33922d2a324f8b1ef293",
            "patch": "@@ -37,6 +37,7 @@ pub struct NodePreGypConfigReference {\n     pub context_dir: FileSystemPath,\n     pub config_file_pattern: ResolvedVc<Pattern>,\n     pub compile_target: ResolvedVc<CompileTarget>,\n+    pub collect_affecting_sources: bool,\n }\n \n #[turbo_tasks::value_impl]\n@@ -46,24 +47,28 @@ impl NodePreGypConfigReference {\n         context_dir: FileSystemPath,\n         config_file_pattern: ResolvedVc<Pattern>,\n         compile_target: ResolvedVc<CompileTarget>,\n+        collect_affecting_sources: bool,\n     ) -> Vc<Self> {\n         Self::cell(NodePreGypConfigReference {\n             context_dir,\n             config_file_pattern,\n             compile_target,\n+            collect_affecting_sources,\n         })\n     }\n }\n \n #[turbo_tasks::value_impl]\n impl ModuleReference for NodePreGypConfigReference {\n     #[turbo_tasks::function]\n-    fn resolve_reference(&self) -> Vc<ModuleResolveResult> {\n+    async fn resolve_reference(&self) -> Result<Vc<ModuleResolveResult>> {\n         resolve_node_pre_gyp_files(\n             self.context_dir.clone(),\n             *self.config_file_pattern,\n             *self.compile_target,\n+            self.collect_affecting_sources,\n         )\n+        .await\n     }\n }\n \n@@ -81,11 +86,11 @@ impl ValueToString for NodePreGypConfigReference {\n     }\n }\n \n-#[turbo_tasks::function]\n-pub async fn resolve_node_pre_gyp_files(\n+async fn resolve_node_pre_gyp_files(\n     context_dir: FileSystemPath,\n     config_file_pattern: Vc<Pattern>,\n     compile_target: Vc<CompileTarget>,\n+    collect_affecting_sources: bool,\n ) -> Result<Vc<ModuleResolveResult>> {\n     static NAPI_VERSION_TEMPLATE: LazyLock<Regex> = LazyLock::new(|| {\n         Regex::new(r\"\\{(napi_build_version|node_napi_label)\\}\")\n@@ -97,9 +102,14 @@ pub async fn resolve_node_pre_gyp_files(\n         LazyLock::new(|| Regex::new(r\"\\{arch\\}\").expect(\"create node_arch regex failed\"));\n     static LIBC_TEMPLATE: LazyLock<Regex> =\n         LazyLock::new(|| Regex::new(r\"\\{libc\\}\").expect(\"create node_libc regex failed\"));\n-    let config = resolve_raw(context_dir, config_file_pattern, true)\n-        .first_source()\n-        .await?;\n+    let config = resolve_raw(\n+        context_dir,\n+        config_file_pattern,\n+        collect_affecting_sources,\n+        true,\n+    )\n+    .first_source()\n+    .await?;\n     let compile_target = compile_target.await?;\n     if let Some(config_asset) = *config\n         && let AssetContent::File(file) = &*config_asset.content().await?\n@@ -222,15 +232,21 @@ pub async fn resolve_node_pre_gyp_files(\n #[derive(Hash, Clone, Debug)]\n pub struct NodeGypBuildReference {\n     pub context_dir: FileSystemPath,\n+    collect_affecting_sources: bool,\n     pub compile_target: ResolvedVc<CompileTarget>,\n }\n \n #[turbo_tasks::value_impl]\n impl NodeGypBuildReference {\n     #[turbo_tasks::function]\n-    pub fn new(context_dir: FileSystemPath, compile_target: ResolvedVc<CompileTarget>) -> Vc<Self> {\n+    pub fn new(\n+        context_dir: FileSystemPath,\n+        collect_affecting_sources: bool,\n+        compile_target: ResolvedVc<CompileTarget>,\n+    ) -> Vc<Self> {\n         Self::cell(NodeGypBuildReference {\n             context_dir,\n+            collect_affecting_sources,\n             compile_target,\n         })\n     }\n@@ -239,8 +255,13 @@ impl NodeGypBuildReference {\n #[turbo_tasks::value_impl]\n impl ModuleReference for NodeGypBuildReference {\n     #[turbo_tasks::function]\n-    fn resolve_reference(&self) -> Vc<ModuleResolveResult> {\n-        resolve_node_gyp_build_files(self.context_dir.clone(), *self.compile_target)\n+    async fn resolve_reference(&self) -> Result<Vc<ModuleResolveResult>> {\n+        resolve_node_gyp_build_files(\n+            self.context_dir.clone(),\n+            self.collect_affecting_sources,\n+            self.compile_target,\n+        )\n+        .await\n     }\n }\n \n@@ -256,21 +277,29 @@ impl ValueToString for NodeGypBuildReference {\n     }\n }\n \n-#[turbo_tasks::function]\n-pub async fn resolve_node_gyp_build_files(\n+async fn resolve_node_gyp_build_files(\n     context_dir: FileSystemPath,\n-    compile_target: Vc<CompileTarget>,\n+    collect_affecting_sources: bool,\n+    compile_target: ResolvedVc<CompileTarget>,\n ) -> Result<Vc<ModuleResolveResult>> {\n     // TODO Proper parser\n     static GYP_BUILD_TARGET_NAME: LazyLock<Regex> = LazyLock::new(|| {\n         Regex::new(r#\"['\"]target_name['\"]\\s*:\\s*(?:\"(.*?)\"|'(.*?)')\"#)\n             .expect(\"create napi_build_version regex failed\")\n     });\n     let binding_gyp_pat = Pattern::new(Pattern::Constant(rcstr!(\"binding.gyp\")));\n-    let gyp_file = resolve_raw(context_dir.clone(), binding_gyp_pat, true);\n+    let gyp_file = resolve_raw(\n+        context_dir.clone(),\n+        binding_gyp_pat,\n+        collect_affecting_sources,\n+        true,\n+    );\n     if let [binding_gyp] = &gyp_file.primary_sources().await?[..] {\n-        let mut merged_affecting_sources =\n-            gyp_file.await?.get_affecting_sources().collect::<Vec<_>>();\n+        let mut merged_affecting_sources = if collect_affecting_sources {\n+            gyp_file.await?.get_affecting_sources().collect::<Vec<_>>()\n+        } else {\n+            Vec::new()\n+        };\n         if let AssetContent::File(file) = &*binding_gyp.content().await?\n             && let FileContent::Content(config_file) = &*file.await?\n             && let Some(captured) = GYP_BUILD_TARGET_NAME.captures(&config_file.content().to_str()?)\n@@ -283,15 +312,18 @@ pub async fn resolve_node_gyp_build_files(\n                 let resolved_prebuilt_file = resolve_raw(\n                     target_path,\n                     Pattern::new(Pattern::Constant(format!(\"{name}.node\").into())),\n+                    collect_affecting_sources,\n                     true,\n                 )\n                 .await?;\n                 if let Some((_, ResolveResultItem::Source(source))) =\n                     resolved_prebuilt_file.primary.first()\n                 {\n                     resolved.insert(format!(\"build/Release/{name}.node\").into(), *source);\n-                    merged_affecting_sources\n-                        .extend(resolved_prebuilt_file.affecting_sources.iter().copied());\n+                    if collect_affecting_sources {\n+                        merged_affecting_sources\n+                            .extend(resolved_prebuilt_file.affecting_sources.iter().copied());\n+                    }\n                 }\n             }\n             if !resolved.is_empty() {\n@@ -323,6 +355,7 @@ pub async fn resolve_node_gyp_build_files(\n             Pattern::Dynamic,\n             Pattern::Constant(rcstr!(\".node\")),\n         ])),\n+        collect_affecting_sources,\n         true,\n     )\n     .as_raw_module_result())\n@@ -333,24 +366,35 @@ pub async fn resolve_node_gyp_build_files(\n pub struct NodeBindingsReference {\n     pub context_dir: FileSystemPath,\n     pub file_name: RcStr,\n+    pub collect_affecting_sources: bool,\n }\n \n #[turbo_tasks::value_impl]\n impl NodeBindingsReference {\n     #[turbo_tasks::function]\n-    pub fn new(context_dir: FileSystemPath, file_name: RcStr) -> Vc<Self> {\n+    pub fn new(\n+        context_dir: FileSystemPath,\n+        file_name: RcStr,\n+        collect_affecting_sources: bool,\n+    ) -> Vc<Self> {\n         Self::cell(NodeBindingsReference {\n             context_dir,\n             file_name,\n+            collect_affecting_sources,\n         })\n     }\n }\n \n #[turbo_tasks::value_impl]\n impl ModuleReference for NodeBindingsReference {\n     #[turbo_tasks::function]\n-    fn resolve_reference(&self) -> Vc<ModuleResolveResult> {\n-        resolve_node_bindings_files(self.context_dir.clone(), self.file_name.clone())\n+    async fn resolve_reference(&self) -> Result<Vc<ModuleResolveResult>> {\n+        resolve_node_bindings_files(\n+            self.context_dir.clone(),\n+            self.file_name.clone(),\n+            self.collect_affecting_sources,\n+        )\n+        .await\n     }\n }\n \n@@ -364,10 +408,10 @@ impl ValueToString for NodeBindingsReference {\n     }\n }\n \n-#[turbo_tasks::function]\n-pub async fn resolve_node_bindings_files(\n+async fn resolve_node_bindings_files(\n     context_dir: FileSystemPath,\n     file_name: RcStr,\n+    collect_affecting_sources: bool,\n ) -> Result<Vc<ModuleResolveResult>> {\n     static BINDINGS_TRY: LazyLock<[&'static str; 5]> = LazyLock::new(|| {\n         [\n@@ -383,6 +427,7 @@ pub async fn resolve_node_bindings_files(\n         let resolved = resolve_raw(\n             root_context_dir.clone(),\n             Pattern::new(Pattern::Constant(rcstr!(\"package.json\"))),\n+            collect_affecting_sources,\n             true,\n         )\n         .first_source()"
        },
        {
            "sha": "befa2318f4e3fa2866d3791c29f9ff7062213f8a",
            "filename": "turbopack/crates/turbopack-resolve/src/resolve.rs",
            "status": "modified",
            "additions": 7,
            "deletions": 1,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/380fe8c22afb178b3d8f33922d2a324f8b1ef293/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Fresolve.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/380fe8c22afb178b3d8f33922d2a324f8b1ef293/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Fresolve.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Fresolve.rs?ref=380fe8c22afb178b3d8f33922d2a324f8b1ef293",
            "patch": "@@ -204,6 +204,7 @@ async fn base_resolve_options(\n         after_resolve_plugins: opt.after_resolve_plugins.clone(),\n         before_resolve_plugins: opt.before_resolve_plugins.clone(),\n         loose_errors: opt.loose_errors,\n+        collect_affecting_sources: opt.collect_affecting_sources,\n         ..Default::default()\n     }\n     .into())\n@@ -228,7 +229,12 @@ pub async fn resolve_options(\n     let resolve_options = if options_context_value.enable_typescript {\n         let find_tsconfig = async || {\n             // Otherwise, attempt to find a tsconfig up the file tree\n-            let tsconfig = find_context_file(resolve_path.clone(), tsconfig()).await?;\n+            let tsconfig = find_context_file(\n+                resolve_path.clone(),\n+                tsconfig(),\n+                options_context_value.collect_affecting_sources,\n+            )\n+            .await?;\n             anyhow::Ok::<Vc<ResolveOptions>>(match &*tsconfig {\n                 FindContextFileResult::Found(path, _) => apply_tsconfig_resolve_options(\n                     resolve_options,"
        },
        {
            "sha": "2401a42ad590ee42f61a739259aae85e44168ed9",
            "filename": "turbopack/crates/turbopack-resolve/src/resolve_options_context.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/380fe8c22afb178b3d8f33922d2a324f8b1ef293/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Fresolve_options_context.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/380fe8c22afb178b3d8f33922d2a324f8b1ef293/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Fresolve_options_context.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Fresolve_options_context.rs?ref=380fe8c22afb178b3d8f33922d2a324f8b1ef293",
            "patch": "@@ -79,6 +79,8 @@ pub struct ResolveOptionsContext {\n     pub before_resolve_plugins: Vec<ResolvedVc<Box<dyn BeforeResolvePlugin>>>,\n     /// Warn instead of error for resolve errors\n     pub loose_errors: bool,\n+    /// Collect affecting sources for each resolve result.  Useful for tracing.\n+    pub collect_affecting_sources: bool,\n \n     #[serde(default)]\n     pub placeholder_for_future_extensions: (),"
        },
        {
            "sha": "1ae10ce2ce0e23f3367321c67f059f26ed9f9a16",
            "filename": "turbopack/crates/turbopack-tracing/benches/node_file_trace.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/380fe8c22afb178b3d8f33922d2a324f8b1ef293/turbopack%2Fcrates%2Fturbopack-tracing%2Fbenches%2Fnode_file_trace.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/380fe8c22afb178b3d8f33922d2a324f8b1ef293/turbopack%2Fcrates%2Fturbopack-tracing%2Fbenches%2Fnode_file_trace.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tracing%2Fbenches%2Fnode_file_trace.rs?ref=380fe8c22afb178b3d8f33922d2a324f8b1ef293",
            "patch": "@@ -108,6 +108,7 @@ fn bench_emit(b: &mut Bencher, bench_input: &BenchInput) {\n                         emulate_environment: Some(\n                             compile_time_info.environment().to_resolved().await?,\n                         ),\n+                        collect_affecting_sources: true,\n                         ..Default::default()\n                     }\n                     .cell(),"
        },
        {
            "sha": "7f62cffa417fd38d63513eb227eaab2e7b8f4545",
            "filename": "turbopack/crates/turbopack-tracing/tests/node-file-trace.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/380fe8c22afb178b3d8f33922d2a324f8b1ef293/turbopack%2Fcrates%2Fturbopack-tracing%2Ftests%2Fnode-file-trace.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/380fe8c22afb178b3d8f33922d2a324f8b1ef293/turbopack%2Fcrates%2Fturbopack-tracing%2Ftests%2Fnode-file-trace.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tracing%2Ftests%2Fnode-file-trace.rs?ref=380fe8c22afb178b3d8f33922d2a324f8b1ef293",
            "patch": "@@ -383,6 +383,7 @@ async fn node_file_trace_operation(\n             enable_node_native_modules: true,\n             enable_node_modules: Some(input_dir.clone()),\n             custom_conditions: vec![rcstr!(\"node\")],\n+            collect_affecting_sources: true,\n             ..Default::default()\n         }\n         .cell(),"
        },
        {
            "sha": "69c8761fe4919dd50e1515300b62966d5c9194ef",
            "filename": "turbopack/crates/turbopack/src/lib.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/380fe8c22afb178b3d8f33922d2a324f8b1ef293/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/380fe8c22afb178b3d8f33922d2a324f8b1ef293/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Flib.rs?ref=380fe8c22afb178b3d8f33922d2a324f8b1ef293",
            "patch": "@@ -688,6 +688,7 @@ pub async fn externals_tracing_module_context(\n         enable_node_native_modules: true,\n         emulate_environment: Some(compile_time_info.await?.environment),\n         loose_errors: true,\n+        collect_affecting_sources: true,\n         custom_conditions: match ty {\n             ExternalType::CommonJs => vec![rcstr!(\"require\"), rcstr!(\"node\")],\n             ExternalType::EcmaScriptModule => vec![rcstr!(\"import\"), rcstr!(\"node\")],"
        }
    ],
    "stats": {
        "total": 668,
        "additions": 351,
        "deletions": 317
    }
}