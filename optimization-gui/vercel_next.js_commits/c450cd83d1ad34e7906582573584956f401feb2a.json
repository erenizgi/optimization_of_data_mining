{
    "author": "lukesandberg",
    "message": "[turbopack] Remove a vec clone from `primary_chunkable_referenced_modules`  (#81206)\n\nRemove a vec clone when resolving module primary references.  Since it is stored in a turbotask we can just pass around a ReadRef to the Vec.\n\nBy avoiding the copy we make the `ModulesWithRefData` type a little smaller and should speed up the loop, the cost is some additional indirection when iterating, however all callers only iterate once so this ends up as a win in all cases.",
    "sha": "c450cd83d1ad34e7906582573584956f401feb2a",
    "files": [
        {
            "sha": "c77d06407d4b8c8f0c77dc7a9493dd590b9bd0bf",
            "filename": "turbopack/crates/turbopack-core/src/reference/mod.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 5,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/c450cd83d1ad34e7906582573584956f401feb2a/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Freference%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c450cd83d1ad34e7906582573584956f401feb2a/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Freference%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Freference%2Fmod.rs?ref=c450cd83d1ad34e7906582573584956f401feb2a",
            "patch": "@@ -3,7 +3,7 @@ use std::collections::HashSet;\n use anyhow::Result;\n use turbo_rcstr::RcStr;\n use turbo_tasks::{\n-    FxIndexSet, ResolvedVc, TryFlatJoinIterExt, TryJoinIterExt, ValueToString, Vc,\n+    FxIndexSet, ReadRef, ResolvedVc, TryFlatJoinIterExt, TryJoinIterExt, ValueToString, Vc,\n     graph::{AdjacencyMap, GraphTraversal},\n };\n \n@@ -285,9 +285,8 @@ pub async fn primary_referenced_modules(module: Vc<Box<dyn Module>>) -> Result<V\n     Ok(Vc::cell(modules))\n }\n \n-type ModulesVec = Vec<ResolvedVc<Box<dyn Module>>>;\n #[turbo_tasks::value(transparent)]\n-pub struct ModulesWithRefData(Vec<(ChunkingType, ExportUsage, ModulesVec)>);\n+pub struct ModulesWithRefData(Vec<(ChunkingType, ExportUsage, ReadRef<Modules>)>);\n \n /// Aggregates all primary [Module]s referenced by an [Module] via [ChunkableModuleReference]s.\n /// This does not include transitively referenced [Module]s, only includes\n@@ -296,7 +295,7 @@ pub struct ModulesWithRefData(Vec<(ChunkingType, ExportUsage, ModulesVec)>);\n /// [Module]: crate::module::Module\n #[turbo_tasks::function]\n pub async fn primary_chunkable_referenced_modules(\n-    module: Vc<Box<dyn Module>>,\n+    module: ResolvedVc<Box<dyn Module>>,\n     include_traced: bool,\n ) -> Result<Vc<ModulesWithRefData>> {\n     let modules = module\n@@ -317,7 +316,6 @@ pub async fn primary_chunkable_referenced_modules(\n                     .resolve()\n                     .await?\n                     .primary_modules()\n-                    .owned()\n                     .await?;\n                 let export = reference.export_usage().owned().await?;\n "
        }
    ],
    "stats": {
        "total": 8,
        "additions": 3,
        "deletions": 5
    }
}