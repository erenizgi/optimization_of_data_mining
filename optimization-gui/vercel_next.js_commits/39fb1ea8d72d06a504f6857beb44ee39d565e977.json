{
    "author": "mischnic",
    "message": "Turbopack: support requests with dynamic part in module name (#82401)\n\nTurbopack fails to resolve this\n```js\nfunction requireOrgPkg(s) {\n  return require(`@org/pkg-${s}`)\n}\n```\nwhich is needed for the case of\n```js\nrequire(`@img/sharp-${currentArch()}/sharp.node`)\n```",
    "sha": "39fb1ea8d72d06a504f6857beb44ee39d565e977",
    "files": [
        {
            "sha": "3feaa1fcde013ffba1122c337ee82ed57eec5f66",
            "filename": "crates/next-core/src/next_edge/unsupported.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 5,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/39fb1ea8d72d06a504f6857beb44ee39d565e977/crates%2Fnext-core%2Fsrc%2Fnext_edge%2Funsupported.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/39fb1ea8d72d06a504f6857beb44ee39d565e977/crates%2Fnext-core%2Fsrc%2Fnext_edge%2Funsupported.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_edge%2Funsupported.rs?ref=39fb1ea8d72d06a504f6857beb44ee39d565e977",
            "patch": "@@ -1,6 +1,5 @@\n use anyhow::Result;\n use indoc::formatdoc;\n-use turbo_rcstr::RcStr;\n use turbo_tasks::{ResolvedVc, Vc};\n use turbo_tasks_fs::{File, FileSystemPath};\n use turbopack_core::{\n@@ -61,18 +60,20 @@ impl ImportMappingReplacement for NextEdgeUnsupportedModuleReplacer {\n }\n \n #[turbo_tasks::function]\n-fn unsupported_module_source(root_path: FileSystemPath, module: RcStr) -> Vc<VirtualSource> {\n+fn unsupported_module_source(root_path: FileSystemPath, module: Pattern) -> Vc<VirtualSource> {\n     // packages/next/src/server/web/globals.ts augments global with\n     // `__import_unsupported` and necessary functions.\n     let code = formatdoc! {\n         r#\"\n         {TURBOPACK_EXPORT_NAMESPACE}(__import_unsupported(`{module}`));\n-        \"#\n+        \"#,\n+        module = module.as_constant_string().map(ToString::to_string).unwrap_or_else(|| module.describe_as_string()),\n     };\n     let content = AssetContent::file(File::from(code).into());\n     VirtualSource::new_with_ident(\n-        AssetIdent::from_path(root_path)\n-            .with_modifier(format!(\"unsupported edge import {module}\").into()),\n+        AssetIdent::from_path(root_path).with_modifier(\n+            format!(\"unsupported edge import {}\", module.describe_as_string()).into(),\n+        ),\n         content,\n     )\n }"
        },
        {
            "sha": "c6f8ed108c87f06a14330a1a1a340feb1c6e52df",
            "filename": "crates/next-core/src/next_server/resolve.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/39fb1ea8d72d06a504f6857beb44ee39d565e977/crates%2Fnext-core%2Fsrc%2Fnext_server%2Fresolve.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/39fb1ea8d72d06a504f6857beb44ee39d565e977/crates%2Fnext-core%2Fsrc%2Fnext_server%2Fresolve.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_server%2Fresolve.rs?ref=39fb1ea8d72d06a504f6857beb44ee39d565e977",
            "patch": "@@ -100,7 +100,9 @@ impl AfterResolvePlugin for ExternalCjsModulesResolvePlugin {\n             Regex::new(\"^(?:private-next-pages\\\\/|next\\\\/(?:dist\\\\/pages\\\\/|(?:app|cache|document|link|form|head|image|legacy\\\\/image|constants|dynamic|script|navigation|headers|router|compat\\\\/router|server)$)|string-hash|private-next-rsc-action-validate|private-next-rsc-action-client-wrapper|private-next-rsc-server-reference|private-next-rsc-cache-wrapper$)\").unwrap()\n         });\n \n-        let Pattern::Constant(package_subpath) = package_subpath else {\n+        let (Pattern::Constant(package), Pattern::Constant(package_subpath)) =\n+            (package, package_subpath)\n+        else {\n             return Ok(ResolveResultOption::none());\n         };\n         let request_str: RcStr = format!(\"{package}{package_subpath}\").into();"
        },
        {
            "sha": "62d412d890af01a58d2f66c49f38733a6ccc8ffe",
            "filename": "crates/next-core/src/next_shared/resolve.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/39fb1ea8d72d06a504f6857beb44ee39d565e977/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fresolve.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/39fb1ea8d72d06a504f6857beb44ee39d565e977/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fresolve.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fresolve.rs?ref=39fb1ea8d72d06a504f6857beb44ee39d565e977",
            "patch": "@@ -13,6 +13,7 @@ use turbopack_core::{\n     resolve::{\n         ExternalTraced, ExternalType, ResolveResult, ResolveResultItem, ResolveResultOption,\n         parse::Request,\n+        pattern::Pattern,\n         plugin::{\n             AfterResolvePlugin, AfterResolvePluginCondition, BeforeResolvePlugin,\n             BeforeResolvePluginCondition,\n@@ -39,7 +40,7 @@ static FEATURE_MODULES: LazyLock<FxHashMap<&'static str, Vec<&'static str>>> =\n                     \"/font/local\",\n                 ],\n             ),\n-            (\"@next\", vec![\"/font/google\", \"/font/local\"]),\n+            (\"@next/font\", vec![\"/google\", \"/local\"]),\n         ])\n     });\n \n@@ -360,7 +361,7 @@ impl BeforeResolvePlugin for ModuleFeatureReportResolvePlugin {\n         request: Vc<Request>,\n     ) -> Result<Vc<ResolveResultOption>> {\n         if let Request::Module {\n-            module,\n+            module: Pattern::Constant(module),\n             path,\n             query: _,\n             fragment: _,"
        },
        {
            "sha": "29fbcd83e24aee9f20fa48166b9412e3cce92fc8",
            "filename": "turbopack/crates/turbopack-cli/src/build/mod.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fbuild%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fbuild%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fbuild%2Fmod.rs?ref=39fb1ea8d72d06a504f6857beb44ee39d565e977",
            "patch": "@@ -268,7 +268,7 @@ async fn build_internal(\n                     false,\n                 ),\n                 EntryRequest::Module(m, p) => Request::module(\n-                    m.clone(),\n+                    m.clone().into(),\n                     p.clone().into(),\n                     Default::default(),\n                     Default::default(),"
        },
        {
            "sha": "38574551867fa6535d4a4777f090c232460c1ce7",
            "filename": "turbopack/crates/turbopack-cli/src/dev/mod.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fdev%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fdev%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fdev%2Fmod.rs?ref=39fb1ea8d72d06a504f6857beb44ee39d565e977",
            "patch": "@@ -305,7 +305,7 @@ async fn source(\n                 false,\n             ),\n             EntryRequest::Module(m, p) => Request::module(\n-                m.clone(),\n+                m.clone().into(),\n                 p.clone().into(),\n                 Default::default(),\n                 Default::default(),"
        },
        {
            "sha": "f6b5cf463c78537f7eff8e3ddc96e0f8ed4983c9",
            "filename": "turbopack/crates/turbopack-core/src/resolve/alias_map.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Falias_map.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Falias_map.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Falias_map.rs?ref=39fb1ea8d72d06a504f6857beb44ee39d565e977",
            "patch": "@@ -497,12 +497,12 @@ where\n                     }\n                     AliasKey::Wildcard { suffix } => {\n                         let mut remaining = self.request.clone();\n-                        remaining.strip_prefix(prefix.len());\n+                        remaining.strip_prefix_len(prefix.len());\n                         let remaining_suffix = remaining.constant_suffix();\n                         if !remaining_suffix.ends_with(&**suffix) {\n                             continue;\n                         }\n-                        remaining.strip_suffix(suffix.len());\n+                        remaining.strip_suffix_len(suffix.len());\n \n                         let output = template.replace(&remaining);\n                         return Some(AliasMatch::Replaced(output));"
        },
        {
            "sha": "6f03a4f5b586e4d51700205e7ad68b87f42cff4a",
            "filename": "turbopack/crates/turbopack-core/src/resolve/mod.rs",
            "status": "modified",
            "additions": 131,
            "deletions": 99,
            "changes": 230,
            "blob_url": "https://github.com/vercel/next.js/blob/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fmod.rs?ref=39fb1ea8d72d06a504f6857beb44ee39d565e977",
            "patch": "@@ -1035,6 +1035,32 @@ impl ResolveResult {\n         .into())\n     }\n \n+    /// Returns a new [ResolveResult] where all [RequestKey]s are updated. The prefix is removed\n+    /// from all [RequestKey]s. It's not expected that the [ResolveResult] contains [RequestKey]s\n+    /// without the prefix, but if there are still some, they are discarded.\n+    #[turbo_tasks::function]\n+    fn with_stripped_request_key_prefix(&self, prefix: RcStr) -> Result<Vc<Self>> {\n+        let new_primary = self\n+            .primary\n+            .iter()\n+            .filter_map(|(k, v)| {\n+                let remaining = k.request.as_ref()?.strip_prefix(&*prefix)?;\n+                Some((\n+                    RequestKey {\n+                        request: Some(remaining.into()),\n+                        conditions: k.conditions.clone(),\n+                    },\n+                    v.clone(),\n+                ))\n+            })\n+            .collect();\n+        Ok(ResolveResult {\n+            primary: new_primary,\n+            affecting_sources: self.affecting_sources.clone(),\n+        }\n+        .into())\n+    }\n+\n     /// Returns a new [ResolveResult] where all [RequestKey]s are updated. All keys matching\n     /// `old_request_key` are rewritten according to `request_key`. It's not expected that the\n     /// [ResolveResult] contains [RequestKey]s that do not match the `old_request_key` prefix, but\n@@ -1114,49 +1140,36 @@ impl ResolveResultOption {\n }\n \n async fn exists(\n-    fs_path: FileSystemPath,\n+    fs_path: &FileSystemPath,\n     refs: &mut Vec<ResolvedVc<Box<dyn Source>>>,\n ) -> Result<Option<FileSystemPath>> {\n     type_exists(fs_path, FileSystemEntryType::File, refs).await\n }\n \n async fn dir_exists(\n-    fs_path: FileSystemPath,\n+    fs_path: &FileSystemPath,\n     refs: &mut Vec<ResolvedVc<Box<dyn Source>>>,\n ) -> Result<Option<FileSystemPath>> {\n     type_exists(fs_path, FileSystemEntryType::Directory, refs).await\n }\n \n async fn type_exists(\n-    fs_path: FileSystemPath,\n+    fs_path: &FileSystemPath,\n     ty: FileSystemEntryType,\n     refs: &mut Vec<ResolvedVc<Box<dyn Source>>>,\n ) -> Result<Option<FileSystemPath>> {\n-    let result = fs_path.realpath_with_links().owned().await?;\n-    refs.extend(\n-        result\n-            .symlinks\n-            .into_iter()\n-            .map(|path| async move {\n-                Ok(ResolvedVc::upcast(\n-                    FileSource::new(path).to_resolved().await?,\n-                ))\n-            })\n-            .try_join()\n-            .await?,\n-    );\n-    let path = result.path;\n+    let path = realpath(fs_path, refs).await?;\n     Ok(if *path.get_type().await? == ty {\n         Some(path)\n     } else {\n         None\n     })\n }\n \n-async fn any_exists(\n-    fs_path: FileSystemPath,\n+async fn realpath(\n+    fs_path: &FileSystemPath,\n     refs: &mut Vec<ResolvedVc<Box<dyn Source>>>,\n-) -> Result<Option<(FileSystemEntryType, FileSystemPath)>> {\n+) -> Result<FileSystemPath> {\n     let result = fs_path.realpath_with_links().owned().await?;\n     refs.extend(\n         result\n@@ -1170,18 +1183,7 @@ async fn any_exists(\n             .try_join()\n             .await?,\n     );\n-    let path = result.path;\n-    let ty = *path.get_type().await?;\n-    Ok(\n-        if matches!(\n-            ty,\n-            FileSystemEntryType::NotFound | FileSystemEntryType::Error\n-        ) {\n-            None\n-        } else {\n-            Some((ty, path))\n-        },\n-    )\n+    Ok(result.path)\n }\n \n #[turbo_tasks::value(shared)]\n@@ -1284,7 +1286,7 @@ pub async fn find_context_file(\n     let mut refs = Vec::new();\n     for name in &*names.await? {\n         let fs_path = lookup_path.join(name)?;\n-        if let Some(fs_path) = exists(fs_path, &mut refs).await? {\n+        if let Some(fs_path) = exists(&fs_path, &mut refs).await? {\n             return Ok(FindContextFileResult::Found(fs_path, refs).cell());\n         }\n     }\n@@ -1324,7 +1326,7 @@ pub async fn find_context_file_or_package_key(\n ) -> Result<Vc<FindContextFileResult>> {\n     let mut refs = Vec::new();\n     let package_json_path = lookup_path.join(\"package.json\")?;\n-    if let Some(package_json_path) = exists(package_json_path, &mut refs).await?\n+    if let Some(package_json_path) = exists(&package_json_path, &mut refs).await?\n         && let Some(json) =\n             &*read_package_json(Vc::upcast(FileSource::new(package_json_path.clone()))).await?\n         && json.get(&*package_key).is_some()\n@@ -1333,7 +1335,7 @@ pub async fn find_context_file_or_package_key(\n     }\n     for name in &*names.await? {\n         let fs_path = lookup_path.join(name)?;\n-        if let Some(fs_path) = exists(fs_path, &mut refs).await? {\n+        if let Some(fs_path) = exists(&fs_path, &mut refs).await? {\n             return Ok(FindContextFileResult::Found(fs_path, refs).into());\n         }\n     }\n@@ -1361,11 +1363,12 @@ pub async fn find_context_file_or_package_key(\n \n #[derive(Clone, PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, Debug, NonLocalValue)]\n enum FindPackageItem {\n-    PackageDirectory(FileSystemPath),\n-    PackageFile(FileSystemPath),\n+    PackageDirectory { name: RcStr, dir: FileSystemPath },\n+    PackageFile { name: RcStr, file: FileSystemPath },\n }\n \n #[turbo_tasks::value]\n+#[derive(Debug)]\n struct FindPackageResult {\n     packages: Vec<FindPackageItem>,\n     affecting_sources: Vec<ResolvedVc<Box<dyn Source>>>,\n@@ -1374,28 +1377,41 @@ struct FindPackageResult {\n #[turbo_tasks::function]\n async fn find_package(\n     lookup_path: FileSystemPath,\n-    package_name: RcStr,\n+    package_name: Pattern,\n     options: Vc<ResolveModulesOptions>,\n ) -> Result<Vc<FindPackageResult>> {\n     let mut packages = vec![];\n     let mut affecting_sources = vec![];\n     let options = options.await?;\n+    let package_name_cell = Pattern::new(package_name.clone());\n+\n+    fn get_package_name(basepath: &FileSystemPath, package_dir: &FileSystemPath) -> Result<RcStr> {\n+        if let Some(name) = basepath.get_path_to(package_dir) {\n+            Ok(name.into())\n+        } else {\n+            bail!(\"Package directory {package_dir} is not inside the lookup path {basepath}\");\n+        }\n+    }\n+\n     for resolve_modules in &options.modules {\n         match resolve_modules {\n-            ResolveModules::Nested(root_vc, names) => {\n+            ResolveModules::Nested(root, names) => {\n                 let mut lookup_path = lookup_path.clone();\n                 let mut lookup_path_value = lookup_path.clone();\n-                // For clippy -- This explicit deref is necessary\n-                let root = root_vc.clone();\n-                while lookup_path_value.is_inside_ref(&root) {\n+                while lookup_path_value.is_inside_ref(root) {\n                     for name in names.iter() {\n                         let fs_path = lookup_path.join(name)?;\n-                        if let Some(fs_path) = dir_exists(fs_path, &mut affecting_sources).await? {\n-                            let fs_path = fs_path.join(&package_name)?;\n-                            if let Some(fs_path) =\n-                                dir_exists(fs_path.clone(), &mut affecting_sources).await?\n-                            {\n-                                packages.push(FindPackageItem::PackageDirectory(fs_path));\n+                        if let Some(fs_path) = dir_exists(&fs_path, &mut affecting_sources).await? {\n+                            let matches =\n+                                read_matches(fs_path.clone(), rcstr!(\"\"), true, package_name_cell)\n+                                    .await?;\n+                            for m in &*matches {\n+                                if let PatternMatch::Directory(_, package_dir) = m {\n+                                    packages.push(FindPackageItem::PackageDirectory {\n+                                        name: get_package_name(&fs_path, package_dir)?,\n+                                        dir: realpath(package_dir, &mut affecting_sources).await?,\n+                                    });\n+                                }\n                             }\n                         }\n                     }\n@@ -1411,29 +1427,46 @@ async fn find_package(\n                 dir,\n                 excluded_extensions,\n             } => {\n-                let excluded_extensions = excluded_extensions.await?;\n-                let package_dir = dir.join(&package_name)?;\n-                if let Some((ty, package_dir)) =\n-                    any_exists(package_dir.clone(), &mut affecting_sources).await?\n-                {\n-                    match ty {\n-                        FileSystemEntryType::Directory => {\n-                            packages.push(FindPackageItem::PackageDirectory(package_dir.clone()));\n+                let matches =\n+                    read_matches(dir.clone(), rcstr!(\"\"), true, package_name_cell).await?;\n+                for m in &*matches {\n+                    match m {\n+                        PatternMatch::Directory(_, package_dir) => {\n+                            packages.push(FindPackageItem::PackageDirectory {\n+                                name: get_package_name(dir, package_dir)?,\n+                                dir: realpath(package_dir, &mut affecting_sources).await?,\n+                            });\n                         }\n-                        FileSystemEntryType::File => {\n-                            packages.push(FindPackageItem::PackageFile(package_dir.clone()));\n+                        PatternMatch::File(_, package_file) => {\n+                            packages.push(FindPackageItem::PackageFile {\n+                                name: get_package_name(dir, package_file)?,\n+                                file: realpath(package_file, &mut affecting_sources).await?,\n+                            });\n                         }\n-                        _ => {}\n                     }\n                 }\n-                for extension in &options.extensions {\n-                    if excluded_extensions.contains(extension) {\n-                        continue;\n-                    }\n-                    let package_file = package_dir.append(extension)?;\n-                    if let Some(package_file) = exists(package_file, &mut affecting_sources).await?\n-                    {\n-                        packages.push(FindPackageItem::PackageFile(package_file));\n+\n+                let excluded_extensions = excluded_extensions.await?;\n+                let mut package_name_with_extensions = package_name.clone();\n+                package_name_with_extensions.push(Pattern::alternatives(\n+                    options\n+                        .extensions\n+                        .iter()\n+                        .filter(|ext| !excluded_extensions.contains(*ext))\n+                        .cloned()\n+                        .map(Pattern::from),\n+                ));\n+                let package_name_with_extensions = Pattern::new(package_name_with_extensions);\n+\n+                let matches =\n+                    read_matches(dir.clone(), rcstr!(\"\"), true, package_name_with_extensions)\n+                        .await?;\n+                for m in matches {\n+                    if let PatternMatch::File(_, package_file) = m {\n+                        packages.push(FindPackageItem::PackageFile {\n+                            name: get_package_name(dir, package_file)?,\n+                            file: realpath(package_file, &mut affecting_sources).await?,\n+                        });\n                     }\n                 }\n             }\n@@ -1535,7 +1568,7 @@ pub async fn resolve_raw(\n         if matches.len() > 10000 {\n             println!(\n                 \"WARN: resolving pattern {} in {} leads to {} results\",\n-                pat,\n+                pat.describe_as_string(),\n                 lookup_dir_str,\n                 matches.len()\n             );\n@@ -2047,7 +2080,7 @@ async fn resolve_internal_inline(\n                 if !has_alias {\n                     ResolvingIssue {\n                         severity: error_severity(options).await?,\n-                        request_type: format!(\"unknown import: `{path}`\"),\n+                        request_type: format!(\"unknown import: `{}`\", path.describe_as_string()),\n                         request: request.to_resolved().await?,\n                         file_path: lookup_path.clone(),\n                         resolve_options: options.to_resolved().await?,\n@@ -2184,7 +2217,7 @@ async fn resolve_relative_request(\n         options,\n         options_value,\n         |package_path| {\n-            let request = path_pattern.as_string()?;\n+            let request = path_pattern.as_constant_string()?;\n             let prefix_path = package_path.get_path_to(&lookup_path_ref)?;\n             let request = normalize_request(&format!(\"./{prefix_path}/{request}\"));\n             Some(request.into())\n@@ -2511,7 +2544,7 @@ async fn resolve_module_request(\n     request: Vc<Request>,\n     options: Vc<ResolveOptions>,\n     options_value: &ResolveOptions,\n-    module: &RcStr,\n+    module: &Pattern,\n     path: &Pattern,\n     query: RcStr,\n     fragment: RcStr,\n@@ -2522,8 +2555,8 @@ async fn resolve_module_request(\n         options,\n         options_value,\n         |_| {\n-            let full_pattern = Pattern::concat([module.clone().into(), path.clone()]);\n-            full_pattern.into_string()\n+            let full_pattern = Pattern::concat([module.clone(), path.clone()]);\n+            full_pattern.as_constant_string().cloned()\n         },\n         query.clone(),\n         fragment.clone(),\n@@ -2533,12 +2566,14 @@ async fn resolve_module_request(\n         return Ok(result);\n     }\n \n+    let mut results = vec![];\n+\n     // Self references, if the nearest package.json has the name of the requested\n     // module. This should match only using the exports field and no other\n     // fields/fallbacks.\n     if let FindSelfReferencePackageResult::Found { name, package_path } =\n         &*find_self_reference(lookup_path.clone()).await?\n-        && module == name\n+        && module.is_match(name)\n     {\n         let result = resolve_into_package(\n             path.clone(),\n@@ -2565,54 +2600,52 @@ async fn resolve_module_request(\n         ));\n     }\n \n-    let mut results = vec![];\n-\n     // There may be more than one package with the same name. For instance, in a\n     // TypeScript project, `compilerOptions.baseUrl` can declare a path where to\n     // resolve packages. A request to \"foo/bar\" might resolve to either\n     // \"[baseUrl]/foo/bar\" or \"[baseUrl]/node_modules/foo/bar\", and we'll need to\n     // try both.\n     for item in &result.packages {\n         match item {\n-            FindPackageItem::PackageDirectory(package_path) => {\n-                results.push(resolve_into_package(\n-                    path.clone(),\n-                    package_path.clone(),\n-                    query.clone(),\n-                    fragment.clone(),\n-                    options,\n-                ));\n+            FindPackageItem::PackageDirectory { name, dir } => {\n+                results.push(\n+                    resolve_into_package(\n+                        path.clone(),\n+                        dir.clone(),\n+                        query.clone(),\n+                        fragment.clone(),\n+                        options,\n+                    )\n+                    .with_replaced_request_key(rcstr!(\".\"), RequestKey::new(name.clone())),\n+                );\n             }\n-            FindPackageItem::PackageFile(package_path) => {\n+            FindPackageItem::PackageFile { name, file } => {\n                 if path.is_match(\"\") {\n                     let resolved = resolved(\n                         RequestKey::new(rcstr!(\".\")),\n-                        package_path.clone(),\n+                        file.clone(),\n                         lookup_path.clone(),\n                         request,\n                         options_value,\n                         options,\n                         query.clone(),\n                         fragment.clone(),\n                     )\n-                    .await?;\n+                    .await?\n+                    .with_replaced_request_key(rcstr!(\".\"), RequestKey::new(name.clone()));\n                     results.push(resolved)\n                 }\n             }\n         }\n     }\n \n     let module_result =\n-        merge_results_with_affecting_sources(results, result.affecting_sources.clone())\n-            .with_replaced_request_key(rcstr!(\".\"), RequestKey::new(module.clone()));\n+        merge_results_with_affecting_sources(results, result.affecting_sources.clone());\n \n     if options_value.prefer_relative {\n-        let module_prefix: RcStr = format!(\"./{module}\").into();\n-        let pattern = Pattern::concat([\n-            module_prefix.clone().into(),\n-            rcstr!(\"/\").into(),\n-            path.clone(),\n-        ]);\n+        let mut module_prefixed = module.clone();\n+        module_prefixed.push_front(rcstr!(\"./\").into());\n+        let pattern = Pattern::concat([module_prefixed.clone(), rcstr!(\"/\").into(), path.clone()]);\n         let relative = Request::relative(pattern, query, fragment, true)\n             .to_resolved()\n             .await?;\n@@ -2622,8 +2655,7 @@ async fn resolve_module_request(\n             options,\n         ))\n         .await?;\n-        let relative_result = relative_result\n-            .with_replaced_request_key(module_prefix, RequestKey::new(module.clone()));\n+        let relative_result = relative_result.with_stripped_request_key_prefix(rcstr!(\"./\"));\n \n         Ok(merge_results(vec![relative_result, module_result]))\n     } else {\n@@ -2660,11 +2692,11 @@ async fn resolve_into_package(\n                     continue;\n                 };\n \n-                let Some(path) = path.clone().into_string() else {\n+                let Some(path) = path.as_constant_string() else {\n                     todo!(\"pattern into an exports field is not implemented yet\");\n                 };\n \n-                let path = if &*path == \"/\" {\n+                let path = if path == \"/\" {\n                     rcstr!(\".\")\n                 } else {\n                     format!(\".{path}\").into()"
        },
        {
            "sha": "d01564f123d8176145c6c5994ec4697fbe754c71",
            "filename": "turbopack/crates/turbopack-core/src/resolve/options.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Foptions.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Foptions.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Foptions.rs?ref=39fb1ea8d72d06a504f6857beb44ee39d565e977",
            "patch": "@@ -234,7 +234,7 @@ impl AliasTemplate for Vc<ImportMapping> {\n                 ImportMapping::External(name, ty, traced) => {\n                     if let Some(name) = name {\n                         ReplacedImportMapping::External(\n-                            capture.spread_into_star(name).as_string().map(|s| s.into()),\n+                            capture.spread_into_star(name).as_constant_string().cloned(),\n                             *ty,\n                             *traced,\n                         )\n@@ -250,7 +250,7 @@ impl AliasTemplate for Vc<ImportMapping> {\n                 } => {\n                     if let Some(name) = name {\n                         ReplacedImportMapping::PrimaryAlternativeExternal {\n-                            name: capture.spread_into_star(name).as_string().map(|s| s.into()),\n+                            name: capture.spread_into_star(name).as_constant_string().cloned(),\n                             ty: *ty,\n                             traced: *traced,\n                             lookup_dir: lookup_dir.clone(),"
        },
        {
            "sha": "d564eab9d2e149afb1cac4fb6948fb691f8e282c",
            "filename": "turbopack/crates/turbopack-core/src/resolve/parse.rs",
            "status": "modified",
            "additions": 162,
            "deletions": 20,
            "changes": 182,
            "blob_url": "https://github.com/vercel/next.js/blob/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fparse.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fparse.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fparse.rs?ref=39fb1ea8d72d06a504f6857beb44ee39d565e977",
            "patch": "@@ -23,7 +23,7 @@ pub enum Request {\n         fragment: RcStr,\n     },\n     Module {\n-        module: RcStr,\n+        module: Pattern,\n         path: Pattern,\n         query: RcStr,\n         fragment: RcStr,\n@@ -100,8 +100,10 @@ static MODULE_PATH: LazyLock<Regex> =\n impl Request {\n     /// Turns the request into a string.\n     ///\n-    /// Note that this is only returns something for the most basic and\n-    /// fully constant patterns.\n+    /// This is not only used for printing the request to the user, but also for matching inner\n+    /// assets.\n+    ///\n+    /// Note that this is only returns something for the most basic and fully constant patterns.\n     pub fn request(&self) -> Option<RcStr> {\n         Some(match self {\n             Request::Raw {\n@@ -113,7 +115,7 @@ impl Request {\n                 ..\n             } => path.clone(),\n             Request::Module {\n-                module,\n+                module: Pattern::Constant(module),\n                 path: Pattern::Constant(path),\n                 ..\n             } => format!(\"{module}{path}\").into(),\n@@ -146,7 +148,7 @@ impl Request {\n     /// recursively. Most users should call [Self::parse] instead.\n     fn parse_ref(request: Pattern) -> Self {\n         match request {\n-            Pattern::Dynamic => Request::Dynamic,\n+            Pattern::Dynamic | Pattern::DynamicNoSlash => Request::Dynamic,\n             Pattern::Constant(r) => Request::parse_constant_pattern(r),\n             Pattern::Concatenation(list) => Request::parse_concatenation_pattern(list),\n             Pattern::Alternatives(_) => panic!(\n@@ -236,7 +238,7 @@ impl Request {\n             let (path, query, fragment) = split_off_query_fragment(path.as_str());\n \n             return Request::Module {\n-                module: module.as_str().into(),\n+                module: RcStr::from(module.as_str()).into(),\n                 path,\n                 query,\n                 fragment,\n@@ -263,7 +265,17 @@ impl Request {\n                 Request::Relative { path, .. } => {\n                     path.push(item);\n                 }\n-                Request::Module { path, .. } => {\n+                Request::Module { module, path, .. } => {\n+                    if path.is_empty() && matches!(item, Pattern::Dynamic) {\n+                        // TODO ideally this would be more general (i.e. support also\n+                        // `module-part<dynamic>more-module/subpath`) and not just handle\n+                        // Pattern::Dynamic, but this covers the common case of\n+                        // `require('@img/sharp-' + arch + '/sharp.node')`\n+\n+                        // Insert dynamic between module and path (by adding it to both of them,\n+                        // because both could happen).\n+                        module.push(Pattern::DynamicNoSlash);\n+                    }\n                     path.push(item);\n                 }\n                 Request::ServerRelative { path, .. } => {\n@@ -358,7 +370,7 @@ impl Request {\n     }\n \n     #[turbo_tasks::function]\n-    pub fn module(module: RcStr, path: Pattern, query: RcStr, fragment: RcStr) -> Vc<Self> {\n+    pub fn module(module: Pattern, path: Pattern, query: RcStr, fragment: RcStr) -> Vc<Self> {\n         Self::cell(Request::Module {\n             module,\n             path,\n@@ -385,7 +397,8 @@ impl Request {\n                 query: _,\n                 fragment: _,\n             } => {\n-                let mut pat = Pattern::Constant(format!(\"./{module}\").into());\n+                let mut pat = module.clone();\n+                pat.push_front(rcstr!(\"./\").into());\n                 pat.push(path.clone());\n                 // TODO add query\n                 Self::parse(pat)\n@@ -692,7 +705,7 @@ impl Request {\n             Request::Relative { path, .. } => path.clone(),\n             Request::Module { module, path, .. } => {\n                 let mut path = path.clone();\n-                path.push_front(Pattern::Constant(module.clone()));\n+                path.push_front(module.clone());\n                 path.normalize();\n                 path\n             }\n@@ -740,9 +753,9 @@ impl ValueToString for Request {\n                 ..\n             } => {\n                 if *force_in_lookup_dir {\n-                    format!(\"in-lookup-dir {path}\").into()\n+                    format!(\"in-lookup-dir {}\", path.describe_as_string()).into()\n                 } else {\n-                    format!(\"{path}\").into()\n+                    path.describe_as_string().into()\n                 }\n             }\n             Request::Relative {\n@@ -751,22 +764,33 @@ impl ValueToString for Request {\n                 ..\n             } => {\n                 if *force_in_lookup_dir {\n-                    format!(\"relative-in-lookup-dir {path}\").into()\n+                    format!(\"relative-in-lookup-dir {}\", path.describe_as_string()).into()\n                 } else {\n-                    format!(\"relative {path}\").into()\n+                    format!(\"relative {}\", path.describe_as_string()).into()\n                 }\n             }\n             Request::Module { module, path, .. } => {\n                 if path.could_match_others(\"\") {\n-                    format!(\"module \\\"{module}\\\" with subpath {path}\").into()\n+                    format!(\n+                        \"module {} with subpath {}\",\n+                        module.describe_as_string(),\n+                        path.describe_as_string()\n+                    )\n+                    .into()\n                 } else {\n-                    format!(\"module \\\"{module}\\\"\").into()\n+                    format!(\"module \\\"{}\\\"\", module.describe_as_string()).into()\n                 }\n             }\n-            Request::ServerRelative { path, .. } => format!(\"server relative {path}\").into(),\n-            Request::Windows { path, .. } => format!(\"windows {path}\").into(),\n+            Request::ServerRelative { path, .. } => {\n+                format!(\"server relative {}\", path.describe_as_string()).into()\n+            }\n+            Request::Windows { path, .. } => {\n+                format!(\"windows {}\", path.describe_as_string()).into()\n+            }\n             Request::Empty => rcstr!(\"empty\"),\n-            Request::PackageInternal { path } => format!(\"package internal {path}\").into(),\n+            Request::PackageInternal { path } => {\n+                format!(\"package internal {}\", path.describe_as_string()).into()\n+            }\n             Request::DataUri {\n                 media_type,\n                 encoding,\n@@ -781,7 +805,7 @@ impl ValueToString for Request {\n                 remainder,\n                 ..\n             } => format!(\"uri \\\"{protocol}\\\" \\\"{remainder}\\\"\").into(),\n-            Request::Unknown { path } => format!(\"unknown {path}\").into(),\n+            Request::Unknown { path } => format!(\"unknown {}\", path.describe_as_string()).into(),\n             Request::Dynamic => rcstr!(\"dynamic\"),\n             Request::Alternatives { requests } => {\n                 let vec = requests.iter().map(|i| i.to_string()).try_join().await?;\n@@ -811,6 +835,124 @@ pub async fn stringify_data_uri(\n mod tests {\n     use super::*;\n \n+    #[test]\n+    fn test_parse_module() {\n+        assert_eq!(\n+            Request::Module {\n+                module: rcstr!(\"foo\").into(),\n+                path: rcstr!(\"\").into(),\n+                query: rcstr!(\"\"),\n+                fragment: rcstr!(\"\"),\n+            },\n+            Request::parse_ref(rcstr!(\"foo\").into())\n+        );\n+        assert_eq!(\n+            Request::Module {\n+                module: rcstr!(\"@org/foo\").into(),\n+                path: rcstr!(\"\").into(),\n+                query: rcstr!(\"\"),\n+                fragment: rcstr!(\"\"),\n+            },\n+            Request::parse_ref(rcstr!(\"@org/foo\").into())\n+        );\n+\n+        assert_eq!(\n+            Request::Module {\n+                module: Pattern::Concatenation(vec![\n+                    Pattern::Constant(rcstr!(\"foo-\")),\n+                    Pattern::DynamicNoSlash,\n+                ]),\n+                path: Pattern::Dynamic,\n+                query: rcstr!(\"\"),\n+                fragment: rcstr!(\"\"),\n+            },\n+            Request::parse_ref(Pattern::Concatenation(vec![\n+                Pattern::Constant(rcstr!(\"foo-\")),\n+                Pattern::Dynamic,\n+            ]))\n+        );\n+\n+        assert_eq!(\n+            Request::Module {\n+                module: Pattern::Concatenation(vec![\n+                    Pattern::Constant(rcstr!(\"foo-\")),\n+                    Pattern::DynamicNoSlash,\n+                ]),\n+                path: Pattern::Concatenation(vec![\n+                    Pattern::Dynamic,\n+                    Pattern::Constant(rcstr!(\"/file\")),\n+                ]),\n+                query: rcstr!(\"\"),\n+                fragment: rcstr!(\"\"),\n+            },\n+            Request::parse_ref(Pattern::Concatenation(vec![\n+                Pattern::Constant(rcstr!(\"foo-\")),\n+                Pattern::Dynamic,\n+                Pattern::Constant(rcstr!(\"/file\")),\n+            ]))\n+        );\n+        assert_eq!(\n+            Request::Module {\n+                module: Pattern::Concatenation(vec![\n+                    Pattern::Constant(rcstr!(\"foo-\")),\n+                    Pattern::DynamicNoSlash,\n+                ]),\n+                path: Pattern::Concatenation(vec![\n+                    Pattern::Dynamic,\n+                    Pattern::Constant(rcstr!(\"/file\")),\n+                    Pattern::Dynamic,\n+                    Pattern::Constant(rcstr!(\"sub\")),\n+                ]),\n+                query: rcstr!(\"\"),\n+                fragment: rcstr!(\"\"),\n+            },\n+            Request::parse_ref(Pattern::Concatenation(vec![\n+                Pattern::Constant(rcstr!(\"foo-\")),\n+                Pattern::Dynamic,\n+                Pattern::Constant(rcstr!(\"/file\")),\n+                Pattern::Dynamic,\n+                Pattern::Constant(rcstr!(\"sub\")),\n+            ]))\n+        );\n+\n+        // TODO see parse_concatenation_pattern\n+        // assert_eq!(\n+        //     Request::Alternatives {\n+        //         requests: vec![\n+        //             Request::Module {\n+        //                 module: Pattern::Concatenation(vec![\n+        //                     Pattern::Constant(rcstr!(\"prefix\")),\n+        //                     Pattern::Dynamic,\n+        //                     Pattern::Constant(rcstr!(\"suffix\")),\n+        //                 ]),\n+        //                 path: rcstr!(\"subpath\").into(),\n+        //                 query: rcstr!(\"\"),\n+        //                 fragment: rcstr!(\"\"),\n+        //             }\n+        //             .resolved_cell(),\n+        //             Request::Module {\n+        //                 module: Pattern::Concatenation(vec![\n+        //                     Pattern::Constant(rcstr!(\"prefix\")),\n+        //                     Pattern::Dynamic,\n+        //                 ]),\n+        //                 path: Pattern::Concatenation(vec![\n+        //                     Pattern::Dynamic,\n+        //                     Pattern::Constant(rcstr!(\"suffix/subpath\")),\n+        //                 ]),\n+        //                 query: rcstr!(\"\"),\n+        //                 fragment: rcstr!(\"\"),\n+        //             }\n+        //             .resolved_cell()\n+        //         ]\n+        //     },\n+        //     Request::parse_ref(Pattern::Concatenation(vec![\n+        //         Pattern::Constant(rcstr!(\"prefix\")),\n+        //         Pattern::Dynamic,\n+        //         Pattern::Constant(rcstr!(\"suffix/subpath\")),\n+        //     ]))\n+        // );\n+    }\n+\n     #[test]\n     fn test_split_query_fragment() {\n         assert_eq!("
        },
        {
            "sha": "5cb025c0702697470ab1c972b55c41b08b6b313a",
            "filename": "turbopack/crates/turbopack-core/src/resolve/pattern.rs",
            "status": "modified",
            "additions": 129,
            "deletions": 53,
            "changes": 182,
            "blob_url": "https://github.com/vercel/next.js/blob/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fpattern.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fpattern.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fpattern.rs?ref=39fb1ea8d72d06a504f6857beb44ee39d565e977",
            "patch": "@@ -1,6 +1,5 @@\n use std::{\n     collections::{VecDeque, hash_map::Entry},\n-    fmt::Display,\n     mem::take,\n     sync::LazyLock,\n };\n@@ -25,6 +24,7 @@ pub enum Pattern {\n     Constant(RcStr),\n     #[default]\n     Dynamic,\n+    DynamicNoSlash,\n     Alternatives(Vec<Pattern>),\n     Concatenation(Vec<Pattern>),\n }\n@@ -117,26 +117,19 @@ fn longest_common_suffix<'a>(strings: &[&'a str]) -> &'a str {\n \n impl Pattern {\n     // TODO this should be removed in favor of pattern resolving\n-    pub fn into_string(self) -> Option<RcStr> {\n+    pub fn as_constant_string(&self) -> Option<&RcStr> {\n         match self {\n             Pattern::Constant(str) => Some(str),\n             _ => None,\n         }\n     }\n \n-    pub fn as_string(&self) -> Option<&str> {\n-        match self {\n-            Pattern::Constant(str) => Some(str.as_str()),\n-            _ => None,\n-        }\n-    }\n-\n     /// Whether the pattern has any significant constant parts (everything except `/`).\n     /// E.g. `<dynamic>/<dynamic>` doesn't really have constant parts\n     pub fn has_constant_parts(&self) -> bool {\n         match self {\n             Pattern::Constant(str) => str != \"/\",\n-            Pattern::Dynamic => false,\n+            Pattern::Dynamic | Pattern::DynamicNoSlash => false,\n             Pattern::Alternatives(list) | Pattern::Concatenation(list) => {\n                 list.iter().any(|p| p.has_constant_parts())\n             }\n@@ -146,7 +139,7 @@ impl Pattern {\n     pub fn has_dynamic_parts(&self) -> bool {\n         match self {\n             Pattern::Constant(_) => false,\n-            Pattern::Dynamic => true,\n+            Pattern::Dynamic | Pattern::DynamicNoSlash => true,\n             Pattern::Alternatives(list) | Pattern::Concatenation(list) => {\n                 list.iter().any(|p| p.has_dynamic_parts())\n             }\n@@ -171,7 +164,7 @@ impl Pattern {\n                 Pattern::Alternatives(_) => {\n                     panic!(\"for constant_prefix a Pattern must be normalized\");\n                 }\n-                Pattern::Dynamic => {}\n+                Pattern::Dynamic | Pattern::DynamicNoSlash => {}\n             }\n         }\n \n@@ -185,7 +178,7 @@ impl Pattern {\n                     collect_constant_prefix(c, &mut strings);\n                 }\n             }\n-            Pattern::Dynamic => {}\n+            Pattern::Dynamic | Pattern::DynamicNoSlash => {}\n         }\n         longest_common_prefix(&strings)\n     }\n@@ -208,7 +201,7 @@ impl Pattern {\n                 Pattern::Alternatives(_) => {\n                     panic!(\"for constant_suffix a Pattern must be normalized\");\n                 }\n-                Pattern::Dynamic => {}\n+                Pattern::Dynamic | Pattern::DynamicNoSlash => {}\n             }\n         }\n \n@@ -222,12 +215,22 @@ impl Pattern {\n                     collect_constant_suffix(c, &mut strings);\n                 }\n             }\n-            Pattern::Dynamic => {}\n+            Pattern::Dynamic | Pattern::DynamicNoSlash => {}\n         }\n         longest_common_suffix(&strings)\n     }\n \n-    pub fn strip_prefix(&mut self, len: usize) {\n+    pub fn strip_prefix(&self, prefix: &str) -> Option<Self> {\n+        if self.must_match(prefix) {\n+            let mut pat = self.clone();\n+            pat.strip_prefix_len(prefix.len());\n+            Some(pat)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    pub fn strip_prefix_len(&mut self, len: usize) {\n         fn strip_prefix_internal(pattern: &mut Pattern, chars_to_strip: &mut usize) {\n             match pattern {\n                 Pattern::Constant(c) => {\n@@ -249,7 +252,7 @@ impl Pattern {\n                 Pattern::Alternatives(_) => {\n                     panic!(\"for strip_prefix a Pattern must be normalized\");\n                 }\n-                Pattern::Dynamic => {\n+                Pattern::Dynamic | Pattern::DynamicNoSlash => {\n                     panic!(\"strip_prefix prefix is too long\");\n                 }\n             }\n@@ -266,7 +269,7 @@ impl Pattern {\n                     strip_prefix_internal(c, &mut len_local);\n                 }\n             }\n-            Pattern::Dynamic => {\n+            Pattern::Dynamic | Pattern::DynamicNoSlash => {\n                 if len > 0 {\n                     panic!(\"strip_prefix prefix is too long\");\n                 }\n@@ -276,7 +279,7 @@ impl Pattern {\n         self.normalize()\n     }\n \n-    pub fn strip_suffix(&mut self, len: usize) {\n+    pub fn strip_suffix_len(&mut self, len: usize) {\n         fn strip_suffix_internal(pattern: &mut Pattern, chars_to_strip: &mut usize) {\n             match pattern {\n                 Pattern::Constant(c) => {\n@@ -298,7 +301,7 @@ impl Pattern {\n                 Pattern::Alternatives(_) => {\n                     panic!(\"for strip_suffix a Pattern must be normalized\");\n                 }\n-                Pattern::Dynamic => {\n+                Pattern::Dynamic | Pattern::DynamicNoSlash => {\n                     panic!(\"strip_suffix suffix is too long\");\n                 }\n             }\n@@ -315,7 +318,7 @@ impl Pattern {\n                     strip_suffix_internal(c, &mut len_local);\n                 }\n             }\n-            Pattern::Dynamic => {\n+            Pattern::Dynamic | Pattern::DynamicNoSlash => {\n                 if len > 0 {\n                     panic!(\"strip_suffix suffix is too long\");\n                 }\n@@ -378,6 +381,14 @@ impl Pattern {\n \n     /// Appends something to end the pattern.\n     pub fn push(&mut self, pat: Pattern) {\n+        if let Pattern::Constant(this) = &*self\n+            && this.is_empty()\n+        {\n+            // Short-circuit to replace empty constants with the appended pattern\n+            *self = pat;\n+            return;\n+        }\n+\n         match (self, pat) {\n             (Pattern::Concatenation(list), Pattern::Concatenation(more)) => {\n                 concatenation_extend_or_merge_items(list, more.into_iter());\n@@ -463,7 +474,7 @@ impl Pattern {\n                     *c = RcStr::from(normalize_path(normalized.as_str())?);\n                     Some(())\n                 }\n-                Pattern::Dynamic => Some(()),\n+                Pattern::Dynamic | Pattern::DynamicNoSlash => Some(()),\n                 Pattern::Concatenation(list) => {\n                     let mut segments = Vec::new();\n                     for segment in list.iter() {\n@@ -484,12 +495,12 @@ impl Pattern {\n                                     segments.push(vec![]);\n                                 }\n                             }\n-                            Pattern::Dynamic => {\n+                            Pattern::Dynamic | Pattern::DynamicNoSlash => {\n                                 if segments.is_empty() {\n                                     segments.push(vec![]);\n                                 }\n                                 let last = segments.last_mut().unwrap();\n-                                last.push(Pattern::Dynamic);\n+                                last.push(segment.clone());\n                             }\n                             Pattern::Alternatives(_) | Pattern::Concatenation(_) => {\n                                 panic!(\"for with_normalized_path the Pattern must be normalized\");\n@@ -521,7 +532,7 @@ impl Pattern {\n                     normalize_path_internal(c)?;\n                 }\n             }\n-            Pattern::Dynamic => {}\n+            Pattern::Dynamic | Pattern::DynamicNoSlash => {}\n         }\n \n         new.normalize();\n@@ -532,7 +543,7 @@ impl Pattern {\n     /// Merge when possible\n     pub fn normalize(&mut self) {\n         match self {\n-            Pattern::Dynamic | Pattern::Constant(_) => {\n+            Pattern::Dynamic | Pattern::DynamicNoSlash | Pattern::Constant(_) => {\n                 // already normalized\n             }\n             Pattern::Alternatives(list) => {\n@@ -641,12 +652,21 @@ impl Pattern {\n                                     }\n                                 }\n                                 Pattern::Dynamic => {\n-                                    if let Some(Pattern::Dynamic) = new_parts.last() {\n+                                    if let Some(Pattern::Dynamic | Pattern::DynamicNoSlash) =\n+                                        new_parts.last()\n+                                    {\n                                         // do nothing\n                                     } else {\n                                         new_parts.push(Pattern::Dynamic);\n                                     }\n                                 }\n+                                Pattern::DynamicNoSlash => {\n+                                    if let Some(Pattern::DynamicNoSlash) = new_parts.last() {\n+                                        // do nothing\n+                                    } else {\n+                                        new_parts.push(Pattern::DynamicNoSlash);\n+                                    }\n+                                }\n                                 Pattern::Concatenation(parts) => {\n                                     for part in parts {\n                                         add_part(part, new_parts);\n@@ -668,6 +688,15 @@ impl Pattern {\n         }\n     }\n \n+    pub fn is_empty(&self) -> bool {\n+        match self {\n+            Pattern::Constant(s) => s.is_empty(),\n+            Pattern::Dynamic | Pattern::DynamicNoSlash => false,\n+            Pattern::Concatenation(parts) => parts.iter().all(|p| p.is_empty()),\n+            Pattern::Alternatives(parts) => parts.iter().all(|p| p.is_empty()),\n+        }\n+    }\n+\n     pub fn filter_could_match(&self, value: &str) -> Option<Pattern> {\n         if let Pattern::Alternatives(list) = self {\n             let new_list = list\n@@ -844,7 +873,7 @@ impl Pattern {\n                     MatchResult::None\n                 }\n             }\n-            Pattern::Dynamic => {\n+            Pattern::Dynamic | Pattern::DynamicNoSlash => {\n                 static FORBIDDEN: LazyLock<Regex> = LazyLock::new(|| {\n                     Regex::new(r\"(/|^)(ROOT|\\.|/|(node_modules|__tests?__)(/|$))\").unwrap()\n                 });\n@@ -860,9 +889,13 @@ impl Pattern {\n                 } else if ignore_dynamic {\n                     MatchResult::None\n                 } else {\n+                    let match_length = matches!(self, Pattern::DynamicNoSlash)\n+                        .then(|| value.find(\"/\"))\n+                        .flatten()\n+                        .unwrap_or(value.len());\n                     MatchResult::Consumed {\n                         remaining: value,\n-                        any_offset: Some(value.len()),\n+                        any_offset: Some(match_length),\n                     }\n                 }\n             }\n@@ -930,7 +963,7 @@ impl Pattern {\n                     MatchResult::None\n                 }\n             }\n-            Pattern::Dynamic => {\n+            Pattern::Dynamic | Pattern::DynamicNoSlash => {\n                 static FORBIDDEN: LazyLock<Regex> = LazyLock::new(|| {\n                     Regex::new(r\"(/|^)(ROOT|\\.|/|(node_modules|__tests?__)(/|$))\").unwrap()\n                 });\n@@ -944,9 +977,13 @@ impl Pattern {\n                 } else if FORBIDDEN_MATCH.find(value).is_some() {\n                     MatchResult::Partial\n                 } else {\n+                    let match_length = matches!(self, Pattern::DynamicNoSlash)\n+                        .then(|| value.find(\"/\"))\n+                        .flatten()\n+                        .unwrap_or(value.len());\n                     MatchResult::Consumed {\n                         remaining: value,\n-                        any_offset: Some(value.len()),\n+                        any_offset: Some(match_length),\n                     }\n                 }\n             }\n@@ -1044,7 +1081,7 @@ impl Pattern {\n                     NextConstantUntilResult::NoMatch\n                 }\n             }\n-            Pattern::Dynamic => {\n+            Pattern::Dynamic | Pattern::DynamicNoSlash => {\n                 static FORBIDDEN: LazyLock<Regex> = LazyLock::new(|| {\n                     Regex::new(r\"(/|^)(\\.|(node_modules|__tests?__)(/|$))\").unwrap()\n                 });\n@@ -1108,7 +1145,7 @@ impl Pattern {\n                     replaced = true;\n                 }\n             }\n-            Pattern::Dynamic => {}\n+            Pattern::Dynamic | Pattern::DynamicNoSlash => {}\n             Pattern::Alternatives(list) => {\n                 for i in list {\n                     replaced = i.replace_final_constants(cb) || replaced;\n@@ -1123,6 +1160,27 @@ impl Pattern {\n         replaced\n     }\n \n+    /// Calls `cb` on all constants and replaces the them with the returned pattern. Returns true if\n+    /// replacements were performed.\n+    pub fn replace_constants(&mut self, cb: &impl Fn(&RcStr) -> Option<Pattern>) -> bool {\n+        let mut replaced = false;\n+        match self {\n+            Pattern::Constant(c) => {\n+                if let Some(replacement) = cb(c) {\n+                    *self = replacement;\n+                    replaced = true;\n+                }\n+            }\n+            Pattern::Dynamic | Pattern::DynamicNoSlash => {}\n+            Pattern::Concatenation(list) | Pattern::Alternatives(list) => {\n+                for i in list {\n+                    replaced = i.replace_constants(cb) || replaced;\n+                }\n+            }\n+        }\n+        replaced\n+    }\n+\n     /// Matches the given string against self, and applies the match onto the target pattern.\n     ///\n     /// The two patterns should have a similar structure (same number of alternatives and dynamics)\n@@ -1155,12 +1213,14 @@ impl Pattern {\n         let mut result = \"\".to_string();\n         match target {\n             Pattern::Constant(c) => result.push_str(c),\n-            Pattern::Dynamic => result.push_str(dynamics.pop_front()?),\n+            Pattern::Dynamic | Pattern::DynamicNoSlash => result.push_str(dynamics.pop_front()?),\n             Pattern::Concatenation(list) => {\n                 for c in list {\n                     match c {\n                         Pattern::Constant(c) => result.push_str(c),\n-                        Pattern::Dynamic => result.push_str(dynamics.pop_front()?),\n+                        Pattern::Dynamic | Pattern::DynamicNoSlash => {\n+                            result.push_str(dynamics.pop_front()?)\n+                        }\n                         Pattern::Alternatives(_) | Pattern::Concatenation(_) => {\n                             panic!(\"Pattern must be normalized\")\n                         }\n@@ -1280,27 +1340,24 @@ impl From<RcStr> for Pattern {\n     }\n }\n \n-impl Display for Pattern {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+impl Pattern {\n+    pub fn describe_as_string(&self) -> String {\n         match self {\n-            Pattern::Constant(c) => write!(f, \"'{c}'\"),\n-            Pattern::Dynamic => write!(f, \"<dynamic>\"),\n-            Pattern::Alternatives(list) => write!(\n-                f,\n+            Pattern::Constant(c) => format!(\"'{c}'\"),\n+            Pattern::Dynamic => \"<dynamic>\".to_string(),\n+            Pattern::DynamicNoSlash => \"<dynamic no slash>\".to_string(),\n+            Pattern::Alternatives(list) => format!(\n                 \"({})\",\n                 list.iter()\n-                    .map(|i| i.to_string())\n+                    .map(|i| i.describe_as_string())\n                     .collect::<Vec<_>>()\n                     .join(\" | \")\n             ),\n-            Pattern::Concatenation(list) => write!(\n-                f,\n-                \"{}\",\n-                list.iter()\n-                    .map(|i| i.to_string())\n-                    .collect::<Vec<_>>()\n-                    .join(\" \")\n-            ),\n+            Pattern::Concatenation(list) => list\n+                .iter()\n+                .map(|i| i.describe_as_string())\n+                .collect::<Vec<_>>()\n+                .join(\" \"),\n         }\n     }\n }\n@@ -1309,7 +1366,7 @@ impl Display for Pattern {\n impl ValueToString for Pattern {\n     #[turbo_tasks::function]\n     fn to_string(&self) -> Vc<RcStr> {\n-        Vc::cell(self.to_string().into())\n+        Vc::cell(self.describe_as_string().into())\n     }\n }\n \n@@ -1891,6 +1948,8 @@ mod tests {\n         assert!(!pat.is_match(\"./\"));\n         assert!(pat.is_match(\"./index.js\"));\n         assert!(!pat.is_match(\"./index\"));\n+        assert!(pat.is_match(\"./foo/index.js\"));\n+        assert!(pat.is_match(\"./foo/bar/index.js\"));\n \n         // forbidden:\n         assert!(!pat.is_match(\"./../index.js\"));\n@@ -1907,6 +1966,23 @@ mod tests {\n         assert!(!pat.could_match(\"./inner/.git/\"));\n     }\n \n+    #[test]\n+    fn is_match_dynamic_no_slash() {\n+        let pat = Pattern::Concatenation(vec![\n+            Pattern::Constant(rcstr!(\".\")),\n+            Pattern::Constant(rcstr!(\"/\")),\n+            Pattern::DynamicNoSlash,\n+            Pattern::Constant(rcstr!(\".js\")),\n+        ]);\n+        assert!(pat.could_match(\"\"));\n+        assert!(pat.could_match(\"./\"));\n+        assert!(!pat.is_match(\"./\"));\n+        assert!(pat.is_match(\"./index.js\"));\n+        assert!(!pat.is_match(\"./index\"));\n+        assert!(!pat.is_match(\"./foo/index.js\"));\n+        assert!(!pat.is_match(\"./foo/bar/index.js\"));\n+    }\n+\n     #[test]\n     fn constant_prefix() {\n         assert_eq!(\n@@ -1944,7 +2020,7 @@ mod tests {\n     #[test]\n     fn strip_prefix() {\n         fn strip(mut pat: Pattern, n: usize) -> Pattern {\n-            pat.strip_prefix(n);\n+            pat.strip_prefix_len(n);\n             pat\n         }\n \n@@ -1985,7 +2061,7 @@ mod tests {\n     #[test]\n     fn strip_suffix() {\n         fn strip(mut pat: Pattern, n: usize) -> Pattern {\n-            pat.strip_suffix(n);\n+            pat.strip_suffix_len(n);\n             pat\n         }\n "
        },
        {
            "sha": "66d0c7a614927a239d4276491073d2b8e7b52a02",
            "filename": "turbopack/crates/turbopack-core/src/resolve/plugin.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fplugin.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fplugin.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fplugin.rs?ref=39fb1ea8d72d06a504f6857beb44ee39d565e977",
            "patch": "@@ -71,7 +71,7 @@ impl BeforeResolvePluginCondition {\n             },\n             BeforeResolvePluginCondition::Modules(modules) => {\n                 if let Request::Module { module, .. } = &*request.await? {\n-                    modules.contains(module)\n+                    modules.iter().any(|m| module.is_match(m))\n                 } else {\n                     false\n                 }"
        },
        {
            "sha": "256bf1365d805dbd3942635c83e8f8d418d67487",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/esm/base.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fbase.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fbase.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fbase.rs?ref=39fb1ea8d72d06a504f6857beb44ee39d565e977",
            "patch": "@@ -419,7 +419,7 @@ impl ModuleReference for EsmAssetReference {\n         }\n \n         if let Request::Module { module, .. } = &*self.request.await?\n-            && module == TURBOPACK_PART_IMPORT_SOURCE\n+            && module.is_match(TURBOPACK_PART_IMPORT_SOURCE)\n         {\n             if let Some(part) = &self.export_name {\n                 let module: ResolvedVc<crate::EcmascriptModuleAsset> ="
        },
        {
            "sha": "de7379fdebc1733b0e3ef2c6400c37ab5c7e9d9b",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/typescript.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Ftypescript.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Ftypescript.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Ftypescript.rs?ref=39fb1ea8d72d06a504f6857beb44ee39d565e977",
            "patch": "@@ -128,7 +128,7 @@ impl ModuleReference for TsReferenceTypeAssetReference {\n         type_resolve(\n             *self.origin,\n             Request::module(\n-                self.module.clone(),\n+                self.module.clone().into(),\n                 RcStr::default().into(),\n                 RcStr::default(),\n                 RcStr::default(),"
        },
        {
            "sha": "687d343509e859f31563e1a5d7210130094ebeea",
            "filename": "turbopack/crates/turbopack-ecmascript/src/typescript/mod.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftypescript%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftypescript%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftypescript%2Fmod.rs?ref=39fb1ea8d72d06a504f6857beb44ee39d565e977",
            "patch": "@@ -160,7 +160,7 @@ impl Module for TsConfigModuleAsset {\n                     TsConfigTypesReference::new(\n                         *self.origin,\n                         Request::module(\n-                            name,\n+                            name.into(),\n                             RcStr::default().into(),\n                             RcStr::default(),\n                             RcStr::default(),"
        },
        {
            "sha": "de980e3430143cca10fbfa776b594e86d575a1cc",
            "filename": "turbopack/crates/turbopack-resolve/src/typescript.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 3,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Ftypescript.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Ftypescript.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Ftypescript.rs?ref=39fb1ea8d72d06a504f6857beb44ee39d565e977",
            "patch": "@@ -426,13 +426,15 @@ pub async fn type_resolve(\n         fragment: _,\n     } = &*request.await?\n     {\n-        let m = if let Some(stripped) = m.strip_prefix('@') {\n-            stripped.replace('/', \"__\").into()\n+        let mut m = if let Some(mut stripped) = m.strip_prefix(\"@\") {\n+            stripped.replace_constants(&|c| Some(Pattern::Constant(c.replace(\"/\", \"__\").into())));\n+            stripped\n         } else {\n             m.clone()\n         };\n+        m.push_front(rcstr!(\"@types/\").into());\n         Some(Request::module(\n-            format!(\"@types/{m}\").into(),\n+            m,\n             p.clone(),\n             RcStr::default(),\n             RcStr::default(),"
        },
        {
            "sha": "270520663029ca7199a4b378b5325b39924a1a50",
            "filename": "turbopack/crates/turbopack-tests/tests/execution/turbopack/resolving/dynamic-module/input/index.js",
            "status": "added",
            "additions": 17,
            "deletions": 0,
            "changes": 17,
            "blob_url": "https://github.com/vercel/next.js/blob/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fresolving%2Fdynamic-module%2Finput%2Findex.js",
            "raw_url": "https://github.com/vercel/next.js/raw/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fresolving%2Fdynamic-module%2Finput%2Findex.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fresolving%2Fdynamic-module%2Finput%2Findex.js?ref=39fb1ea8d72d06a504f6857beb44ee39d565e977",
            "patch": "@@ -0,0 +1,17 @@\n+function requirePkg(s) {\n+  return require(`pkg-${s}`)\n+}\n+function requireOrgPkg(s) {\n+  return require(`@org/pkg-${s}`)\n+}\n+\n+it('should correctly handle dynamic parts in regular package name', () => {\n+  expect(requirePkg('a').default).toBe('pkg-a')\n+  expect(requirePkg('b').default).toBe('pkg-b')\n+  expect(requirePkg('c').default).toBe('pkg-c')\n+})\n+it('should correctly handle dynamic parts in namespaced package name', () => {\n+  expect(requireOrgPkg('a').default).toBe('org/pkg-a')\n+  expect(requireOrgPkg('b').default).toBe('org/pkg-b')\n+  expect(requireOrgPkg('c').default).toBe('org/pkg-c')\n+})"
        },
        {
            "sha": "f2788e456e0ab9e4554b07dae8320ad7c663fdff",
            "filename": "turbopack/crates/turbopack-tests/tests/execution/turbopack/resolving/dynamic-module/input/node_modules/@org/pkg-a/index.js",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fresolving%2Fdynamic-module%2Finput%2Fnode_modules%2F%40org%2Fpkg-a%2Findex.js",
            "raw_url": "https://github.com/vercel/next.js/raw/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fresolving%2Fdynamic-module%2Finput%2Fnode_modules%2F%40org%2Fpkg-a%2Findex.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fresolving%2Fdynamic-module%2Finput%2Fnode_modules%2F%40org%2Fpkg-a%2Findex.js?ref=39fb1ea8d72d06a504f6857beb44ee39d565e977",
            "patch": "@@ -0,0 +1 @@\n+export default 'org/pkg-a'"
        },
        {
            "sha": "0967ef424bce6791893e9a57bb952f80fd536e93",
            "filename": "turbopack/crates/turbopack-tests/tests/execution/turbopack/resolving/dynamic-module/input/node_modules/@org/pkg-a/package.json",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fresolving%2Fdynamic-module%2Finput%2Fnode_modules%2F%40org%2Fpkg-a%2Fpackage.json",
            "raw_url": "https://github.com/vercel/next.js/raw/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fresolving%2Fdynamic-module%2Finput%2Fnode_modules%2F%40org%2Fpkg-a%2Fpackage.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fresolving%2Fdynamic-module%2Finput%2Fnode_modules%2F%40org%2Fpkg-a%2Fpackage.json?ref=39fb1ea8d72d06a504f6857beb44ee39d565e977",
            "patch": "@@ -0,0 +1 @@\n+{}"
        },
        {
            "sha": "65b95a47a3584e8773453a346420309b99cfecfb",
            "filename": "turbopack/crates/turbopack-tests/tests/execution/turbopack/resolving/dynamic-module/input/node_modules/@org/pkg-b/index.js",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fresolving%2Fdynamic-module%2Finput%2Fnode_modules%2F%40org%2Fpkg-b%2Findex.js",
            "raw_url": "https://github.com/vercel/next.js/raw/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fresolving%2Fdynamic-module%2Finput%2Fnode_modules%2F%40org%2Fpkg-b%2Findex.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fresolving%2Fdynamic-module%2Finput%2Fnode_modules%2F%40org%2Fpkg-b%2Findex.js?ref=39fb1ea8d72d06a504f6857beb44ee39d565e977",
            "patch": "@@ -0,0 +1 @@\n+export default 'org/pkg-b'"
        },
        {
            "sha": "0967ef424bce6791893e9a57bb952f80fd536e93",
            "filename": "turbopack/crates/turbopack-tests/tests/execution/turbopack/resolving/dynamic-module/input/node_modules/@org/pkg-b/package.json",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fresolving%2Fdynamic-module%2Finput%2Fnode_modules%2F%40org%2Fpkg-b%2Fpackage.json",
            "raw_url": "https://github.com/vercel/next.js/raw/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fresolving%2Fdynamic-module%2Finput%2Fnode_modules%2F%40org%2Fpkg-b%2Fpackage.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fresolving%2Fdynamic-module%2Finput%2Fnode_modules%2F%40org%2Fpkg-b%2Fpackage.json?ref=39fb1ea8d72d06a504f6857beb44ee39d565e977",
            "patch": "@@ -0,0 +1 @@\n+{}"
        },
        {
            "sha": "876a8fb811f57b8e1b05fe012924b3a23a77f7a3",
            "filename": "turbopack/crates/turbopack-tests/tests/execution/turbopack/resolving/dynamic-module/input/node_modules/@org/pkg-c/index.js",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fresolving%2Fdynamic-module%2Finput%2Fnode_modules%2F%40org%2Fpkg-c%2Findex.js",
            "raw_url": "https://github.com/vercel/next.js/raw/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fresolving%2Fdynamic-module%2Finput%2Fnode_modules%2F%40org%2Fpkg-c%2Findex.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fresolving%2Fdynamic-module%2Finput%2Fnode_modules%2F%40org%2Fpkg-c%2Findex.js?ref=39fb1ea8d72d06a504f6857beb44ee39d565e977",
            "patch": "@@ -0,0 +1 @@\n+export default 'org/pkg-c'"
        },
        {
            "sha": "0967ef424bce6791893e9a57bb952f80fd536e93",
            "filename": "turbopack/crates/turbopack-tests/tests/execution/turbopack/resolving/dynamic-module/input/node_modules/@org/pkg-c/package.json",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fresolving%2Fdynamic-module%2Finput%2Fnode_modules%2F%40org%2Fpkg-c%2Fpackage.json",
            "raw_url": "https://github.com/vercel/next.js/raw/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fresolving%2Fdynamic-module%2Finput%2Fnode_modules%2F%40org%2Fpkg-c%2Fpackage.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fresolving%2Fdynamic-module%2Finput%2Fnode_modules%2F%40org%2Fpkg-c%2Fpackage.json?ref=39fb1ea8d72d06a504f6857beb44ee39d565e977",
            "patch": "@@ -0,0 +1 @@\n+{}"
        },
        {
            "sha": "163d59cae0114616c6132d6578305874c7042f14",
            "filename": "turbopack/crates/turbopack-tests/tests/execution/turbopack/resolving/dynamic-module/input/node_modules/pkg-a/index.js",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fresolving%2Fdynamic-module%2Finput%2Fnode_modules%2Fpkg-a%2Findex.js",
            "raw_url": "https://github.com/vercel/next.js/raw/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fresolving%2Fdynamic-module%2Finput%2Fnode_modules%2Fpkg-a%2Findex.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fresolving%2Fdynamic-module%2Finput%2Fnode_modules%2Fpkg-a%2Findex.js?ref=39fb1ea8d72d06a504f6857beb44ee39d565e977",
            "patch": "@@ -0,0 +1 @@\n+export default 'pkg-a'"
        },
        {
            "sha": "0967ef424bce6791893e9a57bb952f80fd536e93",
            "filename": "turbopack/crates/turbopack-tests/tests/execution/turbopack/resolving/dynamic-module/input/node_modules/pkg-a/package.json",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fresolving%2Fdynamic-module%2Finput%2Fnode_modules%2Fpkg-a%2Fpackage.json",
            "raw_url": "https://github.com/vercel/next.js/raw/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fresolving%2Fdynamic-module%2Finput%2Fnode_modules%2Fpkg-a%2Fpackage.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fresolving%2Fdynamic-module%2Finput%2Fnode_modules%2Fpkg-a%2Fpackage.json?ref=39fb1ea8d72d06a504f6857beb44ee39d565e977",
            "patch": "@@ -0,0 +1 @@\n+{}"
        },
        {
            "sha": "6b482c24472de903d23c58ad0190be1f680bd041",
            "filename": "turbopack/crates/turbopack-tests/tests/execution/turbopack/resolving/dynamic-module/input/node_modules/pkg-b/index.js",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fresolving%2Fdynamic-module%2Finput%2Fnode_modules%2Fpkg-b%2Findex.js",
            "raw_url": "https://github.com/vercel/next.js/raw/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fresolving%2Fdynamic-module%2Finput%2Fnode_modules%2Fpkg-b%2Findex.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fresolving%2Fdynamic-module%2Finput%2Fnode_modules%2Fpkg-b%2Findex.js?ref=39fb1ea8d72d06a504f6857beb44ee39d565e977",
            "patch": "@@ -0,0 +1 @@\n+export default 'pkg-b'"
        },
        {
            "sha": "0967ef424bce6791893e9a57bb952f80fd536e93",
            "filename": "turbopack/crates/turbopack-tests/tests/execution/turbopack/resolving/dynamic-module/input/node_modules/pkg-b/package.json",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fresolving%2Fdynamic-module%2Finput%2Fnode_modules%2Fpkg-b%2Fpackage.json",
            "raw_url": "https://github.com/vercel/next.js/raw/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fresolving%2Fdynamic-module%2Finput%2Fnode_modules%2Fpkg-b%2Fpackage.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fresolving%2Fdynamic-module%2Finput%2Fnode_modules%2Fpkg-b%2Fpackage.json?ref=39fb1ea8d72d06a504f6857beb44ee39d565e977",
            "patch": "@@ -0,0 +1 @@\n+{}"
        },
        {
            "sha": "bc451be006857a3a6561fa44b8c90147f2265cde",
            "filename": "turbopack/crates/turbopack-tests/tests/execution/turbopack/resolving/dynamic-module/input/node_modules/pkg-c/index.js",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fresolving%2Fdynamic-module%2Finput%2Fnode_modules%2Fpkg-c%2Findex.js",
            "raw_url": "https://github.com/vercel/next.js/raw/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fresolving%2Fdynamic-module%2Finput%2Fnode_modules%2Fpkg-c%2Findex.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fresolving%2Fdynamic-module%2Finput%2Fnode_modules%2Fpkg-c%2Findex.js?ref=39fb1ea8d72d06a504f6857beb44ee39d565e977",
            "patch": "@@ -0,0 +1 @@\n+export default 'pkg-c'"
        },
        {
            "sha": "0967ef424bce6791893e9a57bb952f80fd536e93",
            "filename": "turbopack/crates/turbopack-tests/tests/execution/turbopack/resolving/dynamic-module/input/node_modules/pkg-c/package.json",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fresolving%2Fdynamic-module%2Finput%2Fnode_modules%2Fpkg-c%2Fpackage.json",
            "raw_url": "https://github.com/vercel/next.js/raw/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fresolving%2Fdynamic-module%2Finput%2Fnode_modules%2Fpkg-c%2Fpackage.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fresolving%2Fdynamic-module%2Finput%2Fnode_modules%2Fpkg-c%2Fpackage.json?ref=39fb1ea8d72d06a504f6857beb44ee39d565e977",
            "patch": "@@ -0,0 +1 @@\n+{}"
        },
        {
            "sha": "0a452abd81ddf762fd8d91613aac225d6b7214ba",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/imports/resolve_error_cjs/issues/__l___Module not found____c__ Can't resolve __c_'d-90ac85.txt",
            "status": "renamed",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fimports%2Fresolve_error_cjs%2Fissues%2F__l___Module%20not%20found____c__%20Can't%20resolve%20__c_'d-90ac85.txt",
            "raw_url": "https://github.com/vercel/next.js/raw/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fimports%2Fresolve_error_cjs%2Fissues%2F__l___Module%20not%20found____c__%20Can't%20resolve%20__c_'d-90ac85.txt",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fimports%2Fresolve_error_cjs%2Fissues%2F__l___Module%20not%20found____c__%20Can't%20resolve%20__c_'d-90ac85.txt?ref=39fb1ea8d72d06a504f6857beb44ee39d565e977",
            "patch": "@@ -10,7 +10,7 @@ error - [resolve] /turbopack/crates/turbopack-tests/tests/snapshot/imports/resol\n   \n   \n   | It was not possible to find the requested file.\n-  | Parsed request as written in source code: module \"does-not-exist\" with subpath '/path'\n+  | Parsed request as written in source code: module 'does-not-exist' with subpath '/path'\n   | Path where resolving has started: [project]/turbopack/crates/turbopack-tests/tests/snapshot/imports/resolve_error_cjs/input/index.js\n   | Type of request: commonjs request\n   |\n\\ No newline at end of file",
            "previous_filename": "turbopack/crates/turbopack-tests/tests/snapshot/imports/resolve_error_cjs/issues/__l___Module not found____c__ Can't resolve __c_'d-e13f50.txt"
        },
        {
            "sha": "5256331c48f9edbe625beaaa61f3db3ac33aec39",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/imports/resolve_error_esm/issues/__l___Module not found____c__ Can't resolve __c_'d-851545.txt",
            "status": "renamed",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fimports%2Fresolve_error_esm%2Fissues%2F__l___Module%20not%20found____c__%20Can't%20resolve%20__c_'d-851545.txt",
            "raw_url": "https://github.com/vercel/next.js/raw/39fb1ea8d72d06a504f6857beb44ee39d565e977/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fimports%2Fresolve_error_esm%2Fissues%2F__l___Module%20not%20found____c__%20Can't%20resolve%20__c_'d-851545.txt",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fimports%2Fresolve_error_esm%2Fissues%2F__l___Module%20not%20found____c__%20Can't%20resolve%20__c_'d-851545.txt?ref=39fb1ea8d72d06a504f6857beb44ee39d565e977",
            "patch": "@@ -11,7 +11,7 @@ error - [resolve] /turbopack/crates/turbopack-tests/tests/snapshot/imports/resol\n   \n   \n   | It was not possible to find the requested file.\n-  | Parsed request as written in source code: module \"does-not-exist\" with subpath '/path'\n+  | Parsed request as written in source code: module 'does-not-exist' with subpath '/path'\n   | Path where resolving has started: [project]/turbopack/crates/turbopack-tests/tests/snapshot/imports/resolve_error_esm/input/index.js\n   | Type of request: EcmaScript Modules (part) request\n   |\n\\ No newline at end of file",
            "previous_filename": "turbopack/crates/turbopack-tests/tests/snapshot/imports/resolve_error_esm/issues/__l___Module not found____c__ Can't resolve __c_'d-d12847.txt"
        }
    ],
    "stats": {
        "total": 675,
        "additions": 480,
        "deletions": 195
    }
}