{
    "author": "sokra",
    "message": "Turbopack: improve error handling when DB read/deserialization fails (#79545)\n\n### What?\n\nInstead of only printing on DB read errors, panic instead of continuing with a corrupted graph.\n\nAlso improve the error message to be more clear about deserialization errors:\n\nBefore:\n\n```\nLooking up data for TaskId 3 failed: missing field `type`\n[Error: Cell CellId { type_id: ValueTypeId { id: 548, name: \"next-core@TODO::::next_config::NextConfig\" }, index: 0 } no longer exists in task NextConfig::from_string (no cell of this type exists)\n\nDebug info:\n- Execution of TaskId { id: 2147483648 } transient failed\n- Execution of ProjectContainer::project failed\n- Cell CellId { type_id: ValueTypeId { id: 548, name: \"next-core@TODO::::next_config::NextConfig\" }, index: 0 } no longer exists in task NextConfig::from_string (no cell of this type exists)] {\n  code: 'GenericFailure'\n}\n```\n\nAfter:\n\n```\nthread 'tokio-runtime-worker' panicked at /Users/sokra/Repos/next.js/turbopack/crates/turbo-tasks-backend/src/backend/operation/mod.rs:177:17:\nFailed to restore task data: Data for NextConfig::from_string (TaskId 3))\n\nCaused by:\n    0: Looking up data for TaskId 3 from database failed\n    1: Deserialization failed\n    2: [71].CellData.value[1].turbopack.conditions.#next-mdx.path: missing field `type`\n```",
    "sha": "c0104dcf55a1b70b7e307a96328f5d48b4bbc2a3",
    "files": [
        {
            "sha": "8d35a8889085e20909f98f7682e5576d23669cc1",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 12,
            "deletions": 3,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/c0104dcf55a1b70b7e307a96328f5d48b4bbc2a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c0104dcf55a1b70b7e307a96328f5d48b4bbc2a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=c0104dcf55a1b70b7e307a96328f5d48b4bbc2a3",
            "patch": "@@ -220,9 +220,13 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         Self {\n             options,\n             start_time: Instant::now(),\n-            session_id: backing_storage.next_session_id(),\n+            session_id: backing_storage\n+                .next_session_id()\n+                .expect(\"Failed get session id\"),\n             persisted_task_id_factory: IdFactoryWithReuse::new(\n-                backing_storage.next_free_task_id(),\n+                backing_storage\n+                    .next_free_task_id()\n+                    .expect(\"Failed to get task id\"),\n                 TaskId::try_from(TRANSIENT_TASK_BIT - 1).unwrap(),\n             ),\n             transient_task_id_factory: IdFactoryWithReuse::new(\n@@ -780,6 +784,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             if let Some(task_type) = unsafe {\n                 self.backing_storage\n                     .reverse_lookup_task_cache(None, task_id)\n+                    .expect(\"Failed to lookup task type\")\n             } {\n                 let _ = self.task_cache.try_insert(task_type.clone(), task_id);\n                 return Some(task_type);\n@@ -969,7 +974,10 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             // Continue all uncompleted operations\n             // They can't be interrupted by a snapshot since the snapshotting job has not been\n             // scheduled yet.\n-            let uncompleted_operations = self.backing_storage.uncompleted_operations();\n+            let uncompleted_operations = self\n+                .backing_storage\n+                .uncompleted_operations()\n+                .expect(\"Failed to get uncompleted operations\");\n             if !uncompleted_operations.is_empty() {\n                 let mut ctx = self.execute_context(turbo_tasks);\n                 for op in uncompleted_operations {\n@@ -1057,6 +1065,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             if let Some(task_id) = unsafe {\n                 self.backing_storage\n                     .forward_lookup_task_cache(tx.as_ref(), &task_type)\n+                    .expect(\"Failed to lookup task id\")\n             } {\n                 let _ = self.task_cache.try_insert(Arc::new(task_type), task_id);\n                 task_id"
        },
        {
            "sha": "4fdfcc98c843f41a7ce4d7ee32aec165ab7438f4",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/mod.rs",
            "status": "modified",
            "additions": 11,
            "deletions": 1,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/c0104dcf55a1b70b7e307a96328f5d48b4bbc2a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c0104dcf55a1b70b7e307a96328f5d48b4bbc2a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs?ref=c0104dcf55a1b70b7e307a96328f5d48b4bbc2a3",
            "patch": "@@ -165,10 +165,20 @@ where\n         category: TaskDataCategory,\n     ) -> Vec<CachedDataItem> {\n         // Safety: `transaction` is a valid transaction from `self.backend.backing_storage`.\n-        unsafe {\n+        let result = unsafe {\n             self.backend\n                 .backing_storage\n                 .lookup_data(self.transaction(), task_id, category)\n+        };\n+        match result {\n+            Ok(data) => data,\n+            Err(e) => {\n+                let task_name = self.backend.get_task_description(task_id);\n+                panic!(\n+                    \"Failed to restore task data (corrupted database or bug): {:?}\",\n+                    e.context(format!(\"{category:?} for {task_name} ({task_id}))\"))\n+                )\n+            }\n         }\n     }\n }"
        },
        {
            "sha": "8708e028fbf44f079d59904cfce7be4f83666aca",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backing_storage.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/c0104dcf55a1b70b7e307a96328f5d48b4bbc2a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbacking_storage.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c0104dcf55a1b70b7e307a96328f5d48b4bbc2a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbacking_storage.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbacking_storage.rs?ref=c0104dcf55a1b70b7e307a96328f5d48b4bbc2a3",
            "patch": "@@ -15,9 +15,9 @@ pub trait BackingStorage: 'static + Send + Sync {\n     fn lower_read_transaction<'l: 'i + 'r, 'i: 'r, 'r>(\n         tx: &'r Self::ReadTransaction<'l>,\n     ) -> &'r Self::ReadTransaction<'i>;\n-    fn next_free_task_id(&self) -> TaskId;\n-    fn next_session_id(&self) -> SessionId;\n-    fn uncompleted_operations(&self) -> Vec<AnyOperation>;\n+    fn next_free_task_id(&self) -> Result<TaskId>;\n+    fn next_session_id(&self) -> Result<SessionId>;\n+    fn uncompleted_operations(&self) -> Result<Vec<AnyOperation>>;\n     #[allow(clippy::ptr_arg)]\n     fn serialize(task: TaskId, data: &Vec<CachedDataItem>) -> Result<SmallVec<[u8; 16]>>;\n     fn save_snapshot<I>(\n@@ -44,15 +44,15 @@ pub trait BackingStorage: 'static + Send + Sync {\n         &self,\n         tx: Option<&Self::ReadTransaction<'_>>,\n         key: &CachedTaskType,\n-    ) -> Option<TaskId>;\n+    ) -> Result<Option<TaskId>>;\n     /// # Safety\n     ///\n     /// `tx` must be a transaction from this BackingStorage instance.\n     unsafe fn reverse_lookup_task_cache(\n         &self,\n         tx: Option<&Self::ReadTransaction<'_>>,\n         task_id: TaskId,\n-    ) -> Option<Arc<CachedTaskType>>;\n+    ) -> Result<Option<Arc<CachedTaskType>>>;\n     /// # Safety\n     ///\n     /// `tx` must be a transaction from this BackingStorage instance.\n@@ -61,7 +61,7 @@ pub trait BackingStorage: 'static + Send + Sync {\n         tx: Option<&Self::ReadTransaction<'_>>,\n         task_id: TaskId,\n         category: TaskDataCategory,\n-    ) -> Vec<CachedDataItem>;\n+    ) -> Result<Vec<CachedDataItem>>;\n \n     fn shutdown(&self) -> Result<()> {\n         Ok(())"
        },
        {
            "sha": "5705e67aba956cf7de3ed460152ead577d55b39a",
            "filename": "turbopack/crates/turbo-tasks-backend/src/kv_backing_storage.rs",
            "status": "modified",
            "additions": 46,
            "deletions": 37,
            "changes": 83,
            "blob_url": "https://github.com/vercel/next.js/blob/c0104dcf55a1b70b7e307a96328f5d48b4bbc2a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fkv_backing_storage.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c0104dcf55a1b70b7e307a96328f5d48b4bbc2a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fkv_backing_storage.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fkv_backing_storage.rs?ref=c0104dcf55a1b70b7e307a96328f5d48b4bbc2a3",
            "patch": "@@ -2,7 +2,7 @@ use std::{borrow::Borrow, cmp::max, sync::Arc};\n \n use anyhow::{Context, Result, anyhow};\n use rayon::iter::{IndexedParallelIterator, IntoParallelIterator, ParallelIterator};\n-use serde::Serialize;\n+use serde::{Deserialize, Serialize};\n use smallvec::SmallVec;\n use tracing::Span;\n use turbo_tasks::{SessionId, TaskId, backend::CachedTaskType, turbo_tasks_scope};\n@@ -53,7 +53,6 @@ fn pot_ser_symbol_map() -> pot::ser::SymbolMap {\n     pot::ser::SymbolMap::new().with_compatibility(pot::Compatibility::V4)\n }\n \n-#[cfg(feature = \"verify_serialization\")]\n fn pot_de_symbol_list<'l>() -> pot::de::SymbolList<'l> {\n     pot::de::SymbolList::new()\n }\n@@ -106,14 +105,12 @@ impl<T: KeyValueDatabase> KeyValueDatabaseBackingStorage<T> {\n     }\n }\n \n-fn get_infra_u32(database: &impl KeyValueDatabase, key: u32) -> Option<u32> {\n-    let tx = database.begin_read_transaction().ok()?;\n-    let value = database\n-        .get(&tx, KeySpace::Infra, IntKey::new(key).as_ref())\n-        .ok()?\n-        .map(as_u32)?\n-        .ok()?;\n-    Some(value)\n+fn get_infra_u32(database: &impl KeyValueDatabase, key: u32) -> Result<Option<u32>> {\n+    let tx = database.begin_read_transaction()?;\n+    database\n+        .get(&tx, KeySpace::Infra, IntKey::new(key).as_ref())?\n+        .map(as_u32)\n+        .transpose()\n }\n \n impl<T: KeyValueDatabase + Send + Sync + 'static> BackingStorage\n@@ -127,17 +124,24 @@ impl<T: KeyValueDatabase + Send + Sync + 'static> BackingStorage\n         T::lower_read_transaction(tx)\n     }\n \n-    fn next_free_task_id(&self) -> TaskId {\n-        TaskId::try_from(get_infra_u32(&self.database, META_KEY_NEXT_FREE_TASK_ID).unwrap_or(1))\n-            .unwrap()\n+    fn next_free_task_id(&self) -> Result<TaskId> {\n+        Ok(TaskId::try_from(\n+            get_infra_u32(&self.database, META_KEY_NEXT_FREE_TASK_ID)\n+                .context(\"Unable to read next free task id from database\")?\n+                .unwrap_or(1),\n+        )?)\n     }\n \n-    fn next_session_id(&self) -> SessionId {\n-        SessionId::try_from(get_infra_u32(&self.database, META_KEY_SESSION_ID).unwrap_or(0) + 1)\n-            .unwrap()\n+    fn next_session_id(&self) -> Result<SessionId> {\n+        Ok(SessionId::try_from(\n+            get_infra_u32(&self.database, META_KEY_SESSION_ID)\n+                .context(\"Unable to read session id from database\")?\n+                .unwrap_or(0)\n+                + 1,\n+        )?)\n     }\n \n-    fn uncompleted_operations(&self) -> Vec<AnyOperation> {\n+    fn uncompleted_operations(&self) -> Result<Vec<AnyOperation>> {\n         fn get(database: &impl KeyValueDatabase) -> Result<Vec<AnyOperation>> {\n             let tx = database.begin_read_transaction()?;\n             let Some(operations) = database.get(\n@@ -148,10 +152,10 @@ impl<T: KeyValueDatabase + Send + Sync + 'static> BackingStorage\n             else {\n                 return Ok(Vec::new());\n             };\n-            let operations = POT_CONFIG.deserialize(operations.borrow())?;\n+            let operations = deserialize_with_good_error(operations.borrow())?;\n             Ok(operations)\n         }\n-        get(&self.database).unwrap_or_default()\n+        get(&self.database).context(\"Unable to read uncompleted operations from database\")\n     }\n \n     fn serialize(task: TaskId, data: &Vec<CachedDataItem>) -> Result<SmallVec<[u8; 16]>> {\n@@ -360,7 +364,7 @@ impl<T: KeyValueDatabase + Send + Sync + 'static> BackingStorage\n         &self,\n         tx: Option<&T::ReadTransaction<'_>>,\n         task_type: &CachedTaskType,\n-    ) -> Option<TaskId> {\n+    ) -> Result<Option<TaskId>> {\n         fn lookup<D: KeyValueDatabase>(\n             database: &D,\n             tx: &D::ReadTransaction<'_>,\n@@ -377,20 +381,17 @@ impl<T: KeyValueDatabase + Send + Sync + 'static> BackingStorage\n         if self.database.is_empty() {\n             // Checking if the database is empty is a performance optimization\n             // to avoid serializing the task type.\n-            return None;\n+            return Ok(None);\n         }\n-        let id = self\n-            .with_tx(tx, |tx| lookup(&self.database, tx, task_type))\n-            .inspect_err(|err| println!(\"Looking up task id for {task_type:?} failed: {err:?}\"))\n-            .ok()??;\n-        Some(id)\n+        self.with_tx(tx, |tx| lookup(&self.database, tx, task_type))\n+            .with_context(|| format!(\"Looking up task id for {task_type:?} from database failed\"))\n     }\n \n     unsafe fn reverse_lookup_task_cache(\n         &self,\n         tx: Option<&T::ReadTransaction<'_>>,\n         task_id: TaskId,\n-    ) -> Option<Arc<CachedTaskType>> {\n+    ) -> Result<Option<Arc<CachedTaskType>>> {\n         fn lookup<D: KeyValueDatabase>(\n             database: &D,\n             tx: &D::ReadTransaction<'_>,\n@@ -404,21 +405,18 @@ impl<T: KeyValueDatabase + Send + Sync + 'static> BackingStorage\n             else {\n                 return Ok(None);\n             };\n-            Ok(Some(POT_CONFIG.deserialize(bytes.borrow())?))\n+            Ok(Some(deserialize_with_good_error(bytes.borrow())?))\n         }\n-        let result = self\n-            .with_tx(tx, |tx| lookup(&self.database, tx, task_id))\n-            .inspect_err(|err| println!(\"Looking up task type for {task_id} failed: {err:?}\"))\n-            .ok()??;\n-        Some(result)\n+        self.with_tx(tx, |tx| lookup(&self.database, tx, task_id))\n+            .with_context(|| format!(\"Looking up task type for {task_id} from database failed\"))\n     }\n \n     unsafe fn lookup_data(\n         &self,\n         tx: Option<&T::ReadTransaction<'_>>,\n         task_id: TaskId,\n         category: TaskDataCategory,\n-    ) -> Vec<CachedDataItem> {\n+    ) -> Result<Vec<CachedDataItem>> {\n         fn lookup<D: KeyValueDatabase>(\n             database: &D,\n             tx: &D::ReadTransaction<'_>,\n@@ -437,12 +435,11 @@ impl<T: KeyValueDatabase + Send + Sync + 'static> BackingStorage\n             else {\n                 return Ok(Vec::new());\n             };\n-            let result: Vec<CachedDataItem> = POT_CONFIG.deserialize(bytes.borrow())?;\n+            let result: Vec<CachedDataItem> = deserialize_with_good_error(bytes.borrow())?;\n             Ok(result)\n         }\n         self.with_tx(tx, |tx| lookup(&self.database, tx, task_id, category))\n-            .inspect_err(|err| println!(\"Looking up data for {task_id} failed: {err:?}\"))\n-            .unwrap_or_default()\n+            .with_context(|| format!(\"Looking up data for {task_id} from database failed\"))\n     }\n \n     fn shutdown(&self) -> Result<()> {\n@@ -647,3 +644,15 @@ fn serialize(task: TaskId, data: &Vec<CachedDataItem>) -> Result<SmallVec<[u8; 1\n         }\n     })\n }\n+\n+fn deserialize_with_good_error<'de, T: Deserialize<'de>>(data: &'de [u8]) -> Result<T> {\n+    match POT_CONFIG.deserialize(data) {\n+        Ok(value) => Ok(value),\n+        Err(error) => serde_path_to_error::deserialize::<'_, _, T>(\n+            &mut pot_de_symbol_list().deserializer_for_slice(data)?,\n+        )\n+        .map_err(anyhow::Error::from)\n+        .and(Err(error.into()))\n+        .context(\"Deserialization failed\"),\n+    }\n+}"
        }
    ],
    "stats": {
        "total": 122,
        "additions": 75,
        "deletions": 47
    }
}