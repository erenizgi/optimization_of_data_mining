{
    "author": "eps1lon",
    "message": "Fix crash when suspending in Components using `useActionQueue` (#85459)",
    "sha": "a986e1731d60ed02749ab0fb64fe581dc35e04a5",
    "files": [
        {
            "sha": "daacdc445ef3d0d7a2f79efd4496965331a310ab",
            "filename": "packages/next/src/client/components/use-action-queue.ts",
            "status": "modified",
            "additions": 26,
            "deletions": 8,
            "changes": 34,
            "blob_url": "https://github.com/vercel/next.js/blob/a986e1731d60ed02749ab0fb64fe581dc35e04a5/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fuse-action-queue.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/a986e1731d60ed02749ab0fb64fe581dc35e04a5/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fuse-action-queue.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fuse-action-queue.ts?ref=a986e1731d60ed02749ab0fb64fe581dc35e04a5",
            "patch": "@@ -22,6 +22,12 @@ export function dispatchAppRouterAction(action: ReducerActions) {\n   dispatch(action)\n }\n \n+const __DEV__ = process.env.NODE_ENV !== 'production'\n+const promisesWithDebugInfo: WeakMap<\n+  Promise<AppRouterState>,\n+  Promise<AppRouterState> & { _debugInfo?: Array<unknown> }\n+> = __DEV__ ? new WeakMap() : (null as any)\n+\n export function useActionQueue(\n   actionQueue: AppRouterActionQueue\n ): AppRouterState {\n@@ -56,15 +62,27 @@ export function useActionQueue(\n   // passed to React (via `use`) so that the latency is accurately represented\n   // in the React DevTools.\n   const stateWithDebugInfo = useMemo(() => {\n+    if (!__DEV__) {\n+      return state\n+    }\n+\n     if (isThenable(state)) {\n-      const debugInfo: Array<unknown> = []\n-      const promiseWithDebugInfo = Promise.resolve(state).then((asyncState) => {\n-        if (asyncState.debugInfo !== null) {\n-          debugInfo.push(...asyncState.debugInfo)\n-        }\n-        return asyncState\n-      }) as Promise<AppRouterState> & { _debugInfo?: Array<unknown> }\n-      promiseWithDebugInfo._debugInfo = debugInfo\n+      // useMemo can't be used to cache a Promise since the memoized value is thrown\n+      // away when we suspend. So we use a WeakMap to cache the Promise with debug info.\n+      let promiseWithDebugInfo = promisesWithDebugInfo.get(state)\n+      if (promiseWithDebugInfo === undefined) {\n+        const debugInfo: Array<unknown> = []\n+        promiseWithDebugInfo = Promise.resolve(state).then((asyncState) => {\n+          if (asyncState.debugInfo !== null) {\n+            debugInfo.push(...asyncState.debugInfo)\n+          }\n+          return asyncState\n+        }) as Promise<AppRouterState> & { _debugInfo?: Array<unknown> }\n+        promiseWithDebugInfo._debugInfo = debugInfo\n+\n+        promisesWithDebugInfo.set(state, promiseWithDebugInfo)\n+      }\n+\n       return promiseWithDebugInfo\n     }\n     return state"
        }
    ],
    "stats": {
        "total": 34,
        "additions": 26,
        "deletions": 8
    }
}