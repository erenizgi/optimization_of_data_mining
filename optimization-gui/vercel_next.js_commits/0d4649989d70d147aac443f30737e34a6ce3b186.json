{
    "author": "ztanner",
    "message": "next/image: support custom cache handlers (#88248)\n\nWhen self-hosting Next.js, it's possible to customize a cache handler\nfor ISR. Self-hosted Next.js also makes use of a similar cache interface\nfor `next/image`, but there's no way to customize this cache handler.\n\nThis plugs into the [existing\nability](https://nextjs.org/docs/app/api-reference/config/next-config-js/incrementalCacheHandlerPath)\nto customize a `cacheHandler` to support the `IMAGE` type. This lets you\nimplement whatever constraints you might have on your self-hosted\nenvironment, eg the need for an LRU cache, or storing optimized images\noutside of disk.\n\nThis is currently opt-in because it's a breaking change for cache\nhandlers to start receiving `IMAGE` cache types, which we'll make\ndefault in the next major.",
    "sha": "0d4649989d70d147aac443f30737e34a6ce3b186",
    "files": [
        {
            "sha": "9511a5f9799d540e0a65f45d194230454c082e61",
            "filename": "docs/01-app/03-api-reference/05-config/01-next-config-js/incrementalCacheHandlerPath.mdx",
            "status": "modified",
            "additions": 29,
            "deletions": 4,
            "changes": 33,
            "blob_url": "https://github.com/vercel/next.js/blob/0d4649989d70d147aac443f30737e34a6ce3b186/docs%2F01-app%2F03-api-reference%2F05-config%2F01-next-config-js%2FincrementalCacheHandlerPath.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/0d4649989d70d147aac443f30737e34a6ce3b186/docs%2F01-app%2F03-api-reference%2F05-config%2F01-next-config-js%2FincrementalCacheHandlerPath.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-api-reference%2F05-config%2F01-next-config-js%2FincrementalCacheHandlerPath.mdx?ref=0d4649989d70d147aac443f30737e34a6ce3b186",
            "patch": "@@ -6,7 +6,7 @@ description: Configure the Next.js cache used for storing and revalidating data\n \n You can configure the Next.js cache location if you want to persist cached pages and data to durable storage, or share the cache across multiple containers or instances of your Next.js application.\n \n-> **Good to know**: The `cacheHandler` (singular) configuration is specifically used by Next.js for server cache operations such as storing and revalidating ISR and route handler responses. It is **not** used by `'use cache'` directives. For `'use cache'` directives, use [`cacheHandlers`](/docs/app/api-reference/config/next-config-js/cacheHandlers) (plural) instead.\n+> **Good to know**: The `cacheHandler` (singular) configuration is specifically used by Next.js for server cache operations such as storing and revalidating ISR, route handler responses, and optimized images. It is **not** used by `'use cache'` directives. For `'use cache'` directives, use [`cacheHandlers`](/docs/app/api-reference/config/next-config-js/cacheHandlers) (plural) instead.\n \n ```js filename=\"next.config.js\"\n module.exports = {\n@@ -23,9 +23,12 @@ The cache handler can implement the following methods: `get`, `set`, `revalidate\n \n ### `get()`\n \n-| Parameter | Type     | Description                  |\n-| --------- | -------- | ---------------------------- |\n-| `key`     | `string` | The key to the cached value. |\n+| Parameter | Type     | Description                             |\n+| --------- | -------- | --------------------------------------- |\n+| `key`     | `string` | The key to the cached value.            |\n+| `ctx`     | `object` | Context including the cache entry kind. |\n+\n+The `ctx` parameter contains a `kind` property that indicates the type of cache entry being retrieved. Possible values include `'APP_PAGE'`, `'APP_ROUTE'`, `'PAGES'`, `'FETCH'`, and `'IMAGE'`.\n \n Returns the cached value or `null` if not found.\n \n@@ -37,6 +40,8 @@ Returns the cached value or `null` if not found.\n | `data`    | Data or `null` | The data to be cached.           |\n | `ctx`     | `{ tags: [] }` | The cache tags provided.         |\n \n+The `data` object contains a `kind` property that indicates the type of cache entry. For image optimization, `kind` will be `'IMAGE'` and the data will include properties like `buffer`, `etag`, `extension`, and `revalidate`.\n+\n Returns `Promise<void>`.\n \n ### `revalidateTag()`\n@@ -57,6 +62,25 @@ Returns `void`.\n \n - `revalidatePath` is a convenience layer on top of cache tags. Calling `revalidatePath` will call your `revalidateTag` function, which you can then choose if you want to tag cache keys based on the path.\n \n+## Image Optimization Caching\n+\n+The `cacheHandler` can also be used for caching optimized images from `next/image`. To enable this, set `images.customCacheHandler` to `true` in your `next.config.js`:\n+\n+```js filename=\"next.config.js\"\n+module.exports = {\n+  cacheHandler: require.resolve('./cache-handler.js'),\n+  images: {\n+    customCacheHandler: true,\n+  },\n+}\n+```\n+\n+> **Good to know**: This opt-in flag will become the default behavior in the next major version. Setting it now allows you to prepare your cache handler for image optimization entries.\n+\n+You can use the `kind` property to differentiate between cache entry types and handle images separately if needed, for example to implement an eviction policy or store images in a different location.\n+\n+When handling image cache entries, the `kind` will be `'IMAGE'` and the data will include `buffer`, `etag`, `extension`, and `revalidate` properties.\n+\n ## Platform Support\n \n | Deployment Option                                                   | Supported         |\n@@ -72,6 +96,7 @@ Learn how to [configure ISR](/docs/app/guides/self-hosting#caching-and-isr) when\n \n | Version   | Changes                                                      |\n | --------- | ------------------------------------------------------------ |\n+| `v16.2.0` | `cacheHandler` support for image optimization caching.       |\n | `v14.1.0` | Renamed to `cacheHandler` and became stable.                 |\n | `v13.4.0` | `incrementalCacheHandlerPath` support for `revalidateTag`.   |\n | `v13.4.0` | `incrementalCacheHandlerPath` support for standalone output. |"
        },
        {
            "sha": "265a38199358fa9b0757d54a275a00e4cf5b64e0",
            "filename": "packages/next/src/server/config-schema.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/0d4649989d70d147aac443f30737e34a6ce3b186/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-schema.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/0d4649989d70d147aac443f30737e34a6ce3b186/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-schema.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-schema.ts?ref=0d4649989d70d147aac443f30737e34a6ce3b186",
            "patch": "@@ -568,6 +568,7 @@ export const configSchema: zod.ZodType<NextConfig> = z.lazy(() =>\n           .max(50)\n           .optional(),\n         unoptimized: z.boolean().optional(),\n+        customCacheHandler: z.boolean().optional(),\n         contentSecurityPolicy: z.string().optional(),\n         contentDispositionType: z.enum(['inline', 'attachment']).optional(),\n         dangerouslyAllowSVG: z.boolean().optional(),"
        },
        {
            "sha": "17fa8d1bc0e06ae21d63bc5ceb80d715bd407d58",
            "filename": "packages/next/src/server/image-optimizer.ts",
            "status": "modified",
            "additions": 75,
            "deletions": 4,
            "changes": 79,
            "blob_url": "https://github.com/vercel/next.js/blob/0d4649989d70d147aac443f30737e34a6ce3b186/packages%2Fnext%2Fsrc%2Fserver%2Fimage-optimizer.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/0d4649989d70d147aac443f30737e34a6ce3b186/packages%2Fnext%2Fsrc%2Fserver%2Fimage-optimizer.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fimage-optimizer.ts?ref=0d4649989d70d147aac443f30737e34a6ce3b186",
            "patch": "@@ -18,11 +18,13 @@ import { createRequestResponseMocks } from './lib/mock-request'\n import type { NextUrlWithParsedQuery } from './request-meta'\n import {\n   CachedRouteKind,\n+  IncrementalCacheKind,\n   type CachedImageValue,\n   type IncrementalCacheEntry,\n   type IncrementalCacheValue,\n   type IncrementalResponseCacheEntry,\n } from './response-cache'\n+import type { CacheHandler } from './lib/incremental-cache'\n import { sendEtagResponse } from './send-payload'\n import { getContentType, getExtension } from './serve-static'\n import * as Log from '../build/output/log'\n@@ -315,6 +317,7 @@ export async function detectContentType(\n export class ImageOptimizerCache {\n   private cacheDir: string\n   private nextConfig: NextConfigRuntime\n+  private cacheHandler?: CacheHandler\n \n   static validateParams(\n     req: IncomingMessage,\n@@ -495,15 +498,58 @@ export class ImageOptimizerCache {\n   constructor({\n     distDir,\n     nextConfig,\n+    cacheHandler,\n   }: {\n     distDir: string\n     nextConfig: NextConfigRuntime\n+    cacheHandler?: CacheHandler\n   }) {\n     this.cacheDir = join(/* turbopackIgnore: true */ distDir, 'cache', 'images')\n     this.nextConfig = nextConfig\n+    this.cacheHandler = cacheHandler\n   }\n \n   async get(cacheKey: string): Promise<IncrementalResponseCacheEntry | null> {\n+    // If a custom cache handler is provided, use it\n+    if (this.cacheHandler) {\n+      try {\n+        const cacheData = await this.cacheHandler.get(cacheKey, {\n+          kind: IncrementalCacheKind.IMAGE,\n+          isFallback: false,\n+        })\n+\n+        if (!cacheData?.value) {\n+          return null\n+        }\n+\n+        if (cacheData.value.kind !== CachedRouteKind.IMAGE) {\n+          return null\n+        }\n+\n+        const now = Date.now()\n+        const lastModified = cacheData.lastModified || now\n+        const revalidate =\n+          typeof cacheData.value.revalidate === 'number'\n+            ? cacheData.value.revalidate\n+            : this.nextConfig.images.minimumCacheTTL\n+        const revalidateAfter =\n+          Math.max(revalidate, this.nextConfig.images.minimumCacheTTL) * 1000 +\n+          lastModified\n+        const isStale = revalidateAfter < now\n+\n+        return {\n+          value: cacheData.value,\n+          revalidateAfter,\n+          cacheControl: { revalidate, expire: undefined },\n+          isStale,\n+        }\n+      } catch (_) {\n+        // failed to get from custom cache handler, treat as cache miss\n+      }\n+      return null\n+    }\n+\n+    // Fall back to filesystem cache\n     try {\n       const cacheDir = join(/* turbopackIgnore: true */ this.cacheDir, cacheKey)\n       const files = await promises.readdir(cacheDir)\n@@ -550,10 +596,6 @@ export class ImageOptimizerCache {\n       cacheControl?: CacheControl\n     }\n   ) {\n-    if (!this.nextConfig.experimental.isrFlushToDisk) {\n-      return\n-    }\n-\n     if (value?.kind !== CachedRouteKind.IMAGE) {\n       throw new Error('invariant attempted to set non-image to image-cache')\n     }\n@@ -564,6 +606,35 @@ export class ImageOptimizerCache {\n       throw new InvariantError('revalidate must be a number for image-cache')\n     }\n \n+    // If a custom cache handler is provided, use it\n+    if (this.cacheHandler) {\n+      try {\n+        // Apply minimumCacheTTL at write time, similar to the implementation in the fallback filesystem cache\n+        const effectiveRevalidate = Math.max(\n+          revalidate,\n+          this.nextConfig.images.minimumCacheTTL\n+        )\n+        const valueWithRevalidate = {\n+          ...value,\n+          revalidate: effectiveRevalidate,\n+        }\n+        await this.cacheHandler.set(cacheKey, valueWithRevalidate, {\n+          cacheControl: {\n+            revalidate: effectiveRevalidate,\n+            expire: cacheControl?.expire,\n+          },\n+        })\n+      } catch (err) {\n+        Log.error(`Failed to write image to custom cache ${cacheKey}`, err)\n+      }\n+      return\n+    }\n+\n+    // Fall back to filesystem cache\n+    if (!this.nextConfig.experimental.isrFlushToDisk) {\n+      return\n+    }\n+\n     const expireAt =\n       Math.max(revalidate, this.nextConfig.images.minimumCacheTTL) * 1000 +\n       Date.now()"
        },
        {
            "sha": "1f48abccfb5646dbfad079133fbe9c1e8b86a1f2",
            "filename": "packages/next/src/server/next-server.ts",
            "status": "modified",
            "additions": 30,
            "deletions": 1,
            "changes": 31,
            "blob_url": "https://github.com/vercel/next.js/blob/0d4649989d70d147aac443f30737e34a6ce3b186/packages%2Fnext%2Fsrc%2Fserver%2Fnext-server.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/0d4649989d70d147aac443f30737e34a6ce3b186/packages%2Fnext%2Fsrc%2Fserver%2Fnext-server.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fnext-server.ts?ref=0d4649989d70d147aac443f30737e34a6ce3b186",
            "patch": "@@ -84,7 +84,10 @@ import ResponseCache, {\n   CachedRouteKind,\n   type IncrementalResponseCacheEntry,\n } from './response-cache'\n-import { IncrementalCache } from './lib/incremental-cache'\n+import {\n+  IncrementalCache,\n+  type CacheHandler as ICacheHandler,\n+} from './lib/incremental-cache'\n import { normalizeAppPath } from '../shared/lib/router/utils/app-paths'\n \n import { setHttpClientAndAgentOptions } from './setup-http-agent-env'\n@@ -257,6 +260,7 @@ export default class NextNodeServer extends BaseServer<\n   protected middlewareManifestPath: string\n   private _serverDistDir: string | undefined\n   private imageResponseCache?: ResponseCache\n+  private imageCacheHandler?: ICacheHandler\n   protected renderWorkersPromises?: Promise<void>\n   protected dynamicRoutes?: {\n     match: import('../shared/lib/router/utils/route-matcher').RouteMatchFn\n@@ -987,9 +991,34 @@ export default class NextNodeServer extends BaseServer<\n       const { ImageOptimizerCache } =\n         require('./image-optimizer') as typeof import('./image-optimizer')\n \n+      // Load custom cache handler if configured and opt-in via images.customCacheHandler\n+      // Cache the handler instance to preserve state across requests\n+      if (\n+        !this.imageCacheHandler &&\n+        this.nextConfig.images.customCacheHandler\n+      ) {\n+        const { cacheHandler } = this.nextConfig\n+        if (cacheHandler) {\n+          const CacheHandler = interopDefault(\n+            await dynamicImportEsmDefault(\n+              formatDynamicImportPath(this.distDir, cacheHandler)\n+            )\n+          )\n+          this.imageCacheHandler = new CacheHandler({\n+            dev: !!this.renderOpts.dev,\n+            flushToDisk: this.nextConfig.experimental.isrFlushToDisk,\n+            serverDistDir: this.serverDistDir,\n+            maxMemoryCacheSize: this.nextConfig.cacheMaxMemorySize,\n+            revalidatedTags: [],\n+            _requestHeaders: {},\n+          })\n+        }\n+      }\n+\n       const imageOptimizerCache = new ImageOptimizerCache({\n         distDir: this.distDir,\n         nextConfig: this.nextConfig,\n+        cacheHandler: this.imageCacheHandler,\n       })\n \n       const { sendResponse, ImageError } ="
        },
        {
            "sha": "11296b22791ea30c5f54631a4a7d79f0984bd8db",
            "filename": "packages/next/src/server/response-cache/types.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/0d4649989d70d147aac443f30737e34a6ce3b186/packages%2Fnext%2Fsrc%2Fserver%2Fresponse-cache%2Ftypes.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/0d4649989d70d147aac443f30737e34a6ce3b186/packages%2Fnext%2Fsrc%2Fserver%2Fresponse-cache%2Ftypes.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fresponse-cache%2Ftypes.ts?ref=0d4649989d70d147aac443f30737e34a6ce3b186",
            "patch": "@@ -105,6 +105,7 @@ export interface CachedImageValue {\n   upstreamEtag: string\n   buffer: Buffer\n   extension: string\n+  revalidate?: number\n   isMiss?: boolean\n   isStale?: boolean\n }"
        },
        {
            "sha": "5bcd3f37b47b6a43361d67dade757ea0932091ab",
            "filename": "packages/next/src/shared/lib/image-config.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/0d4649989d70d147aac443f30737e34a6ce3b186/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fimage-config.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/0d4649989d70d147aac443f30737e34a6ce3b186/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fimage-config.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fimage-config.ts?ref=0d4649989d70d147aac443f30737e34a6ce3b186",
            "patch": "@@ -132,6 +132,13 @@ export type ImageConfigComplete = {\n \n   /** @see [Unoptimized](https://nextjs.org/docs/api-reference/next/image#unoptimized) */\n   unoptimized: boolean\n+\n+  /**\n+   * When true, the `cacheHandler` configured in next.config.js will also be used\n+   * for caching optimized images. When false, images use the default filesystem cache.\n+   * @see [Image Optimization Caching](https://nextjs.org/docs/app/api-reference/config/next-config-js/cacheHandler#image-optimization-caching)\n+   */\n+  customCacheHandler: boolean\n }\n \n export type ImageConfig = Partial<ImageConfigComplete>\n@@ -159,4 +166,5 @@ export const imageConfigDefault: ImageConfigComplete = {\n   remotePatterns: [], // default: allow no remote images\n   qualities: [75],\n   unoptimized: false,\n+  customCacheHandler: false,\n }"
        },
        {
            "sha": "888614deda3ba5d744d1a7e5dac131038dba2b12",
            "filename": "test/e2e/custom-cache-handler-image/app/layout.tsx",
            "status": "added",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/0d4649989d70d147aac443f30737e34a6ce3b186/test%2Fe2e%2Fcustom-cache-handler-image%2Fapp%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/0d4649989d70d147aac443f30737e34a6ce3b186/test%2Fe2e%2Fcustom-cache-handler-image%2Fapp%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fcustom-cache-handler-image%2Fapp%2Flayout.tsx?ref=0d4649989d70d147aac443f30737e34a6ce3b186",
            "patch": "@@ -0,0 +1,8 @@\n+import { ReactNode } from 'react'\n+export default function Root({ children }: { children: ReactNode }) {\n+  return (\n+    <html>\n+      <body>{children}</body>\n+    </html>\n+  )\n+}"
        },
        {
            "sha": "39a312aeee433ed9529daf1d3d261ee1db343810",
            "filename": "test/e2e/custom-cache-handler-image/app/page.tsx",
            "status": "added",
            "additions": 34,
            "deletions": 0,
            "changes": 34,
            "blob_url": "https://github.com/vercel/next.js/blob/0d4649989d70d147aac443f30737e34a6ce3b186/test%2Fe2e%2Fcustom-cache-handler-image%2Fapp%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/0d4649989d70d147aac443f30737e34a6ce3b186/test%2Fe2e%2Fcustom-cache-handler-image%2Fapp%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fcustom-cache-handler-image%2Fapp%2Fpage.tsx?ref=0d4649989d70d147aac443f30737e34a6ce3b186",
            "patch": "@@ -0,0 +1,34 @@\n+import Image from 'next/image'\n+\n+export default function Page() {\n+  return (\n+    <div>\n+      <p>hello world</p>\n+      {/* Each unique width/quality combination creates a separate cache entry */}\n+      <Image\n+        id=\"image-small\"\n+        src=\"/test.png\"\n+        width={100}\n+        height={100}\n+        quality={75}\n+        alt=\"small image\"\n+      />\n+      <Image\n+        id=\"image-medium\"\n+        src=\"/test.png\"\n+        width={200}\n+        height={200}\n+        quality={75}\n+        alt=\"medium image\"\n+      />\n+      <Image\n+        id=\"image-large\"\n+        src=\"/test.png\"\n+        width={400}\n+        height={400}\n+        quality={75}\n+        alt=\"large image\"\n+      />\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "b165c60d186e24418dd577cc2d039ec610811859",
            "filename": "test/e2e/custom-cache-handler-image/cache-handler.js",
            "status": "added",
            "additions": 105,
            "deletions": 0,
            "changes": 105,
            "blob_url": "https://github.com/vercel/next.js/blob/0d4649989d70d147aac443f30737e34a6ce3b186/test%2Fe2e%2Fcustom-cache-handler-image%2Fcache-handler.js",
            "raw_url": "https://github.com/vercel/next.js/raw/0d4649989d70d147aac443f30737e34a6ce3b186/test%2Fe2e%2Fcustom-cache-handler-image%2Fcache-handler.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fcustom-cache-handler-image%2Fcache-handler.js?ref=0d4649989d70d147aac443f30737e34a6ce3b186",
            "patch": "@@ -0,0 +1,105 @@\n+/**\n+ * Simple LRU cache handler with max entries eviction policy.\n+ * When the cache exceeds maxEntries, the least recently used entries are evicted.\n+ */\n+\n+const MAX_IMAGE_ENTRIES = parseInt(\n+  process.env.MAX_IMAGE_CACHE_ENTRIES || '2',\n+  10\n+)\n+\n+class LRUCache {\n+  constructor(maxEntries) {\n+    this.maxEntries = maxEntries\n+    this.cache = new Map()\n+  }\n+\n+  get(key) {\n+    if (!this.cache.has(key)) {\n+      return undefined\n+    }\n+    // Move to end (most recently used)\n+    const value = this.cache.get(key)\n+    this.cache.delete(key)\n+    this.cache.set(key, value)\n+    return value\n+  }\n+\n+  set(key, value) {\n+    // If key exists, delete it first (will be re-added at end)\n+    if (this.cache.has(key)) {\n+      this.cache.delete(key)\n+    }\n+    // Evict oldest entries if at capacity\n+    while (this.cache.size >= this.maxEntries) {\n+      const oldestKey = this.cache.keys().next().value\n+      console.log('cache-handler evicting', oldestKey)\n+      this.cache.delete(oldestKey)\n+    }\n+    this.cache.set(key, value)\n+  }\n+\n+  has(key) {\n+    return this.cache.has(key)\n+  }\n+\n+  get size() {\n+    return this.cache.size\n+  }\n+\n+  keys() {\n+    return Array.from(this.cache.keys())\n+  }\n+}\n+\n+// Separate caches for different kinds\n+const imageCache = new LRUCache(MAX_IMAGE_ENTRIES)\n+const pageCache = new LRUCache(100) // Higher limit for pages\n+\n+class CacheHandler {\n+  constructor(options) {\n+    this.options = options\n+    console.log('initialized custom cache-handler')\n+    console.log('max image cache entries:', MAX_IMAGE_ENTRIES)\n+  }\n+\n+  async get(key, ctx) {\n+    const kind = ctx?.kind\n+    console.log('cache-handler get', key, 'kind:', kind)\n+\n+    const cache = kind === 'IMAGE' ? imageCache : pageCache\n+    const entry = cache.get(key)\n+\n+    if (entry) {\n+      console.log('cache-handler hit', key)\n+      return entry\n+    }\n+    console.log('cache-handler miss', key)\n+    return null\n+  }\n+\n+  async set(key, data, ctx) {\n+    const kind = data?.kind\n+    console.log('cache-handler set', key, 'kind:', kind)\n+\n+    const cache = kind === 'IMAGE' ? imageCache : pageCache\n+    cache.set(key, {\n+      value: data,\n+      lastModified: Date.now(),\n+    })\n+\n+    if (kind === 'IMAGE') {\n+      console.log('cache-handler image cache size:', imageCache.size)\n+      console.log(\n+        'cache-handler image cache keys:',\n+        imageCache.keys().join(', ')\n+      )\n+    }\n+  }\n+\n+  async revalidateTag(tags) {\n+    console.log('cache-handler revalidateTag', tags)\n+  }\n+}\n+\n+module.exports = CacheHandler"
        },
        {
            "sha": "1b6d43068446d3dd5687d0f28d7a928a83ec9131",
            "filename": "test/e2e/custom-cache-handler-image/custom-cache-handler-image.test.ts",
            "status": "added",
            "additions": 101,
            "deletions": 0,
            "changes": 101,
            "blob_url": "https://github.com/vercel/next.js/blob/0d4649989d70d147aac443f30737e34a6ce3b186/test%2Fe2e%2Fcustom-cache-handler-image%2Fcustom-cache-handler-image.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/0d4649989d70d147aac443f30737e34a6ce3b186/test%2Fe2e%2Fcustom-cache-handler-image%2Fcustom-cache-handler-image.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fcustom-cache-handler-image%2Fcustom-cache-handler-image.test.ts?ref=0d4649989d70d147aac443f30737e34a6ce3b186",
            "patch": "@@ -0,0 +1,101 @@\n+import { nextTestSetup } from 'e2e-utils'\n+import { retry } from 'next-test-utils'\n+\n+describe('custom-cache-handler-image', () => {\n+  const { next, skipped } = nextTestSetup({\n+    files: __dirname,\n+    skipDeployment: true,\n+    env: {\n+      // Set max cache entries to 2 to easily test eviction\n+      MAX_IMAGE_CACHE_ENTRIES: '2',\n+    },\n+  })\n+\n+  if (skipped) {\n+    return\n+  }\n+\n+  it('should use custom cache handler for image optimization', async () => {\n+    // First, render the page to get the image URLs\n+    const $ = await next.render$('/')\n+    expect($('p').text()).toBe('hello world')\n+\n+    const smallImgSrc = $('#image-small').attr('src')\n+    expect(smallImgSrc).toContain('/_next/image')\n+\n+    // Fetch the optimized image to trigger cache handler\n+    const imageRes = await next.fetch(smallImgSrc)\n+    expect(imageRes.status).toBe(200)\n+\n+    // Verify cache handler was called for the image\n+    await retry(() => {\n+      expect(next.cliOutput).toContain('initialized custom cache-handler')\n+      expect(next.cliOutput).toContain('cache-handler set')\n+      expect(next.cliOutput).toMatch(/kind:.*IMAGE/)\n+    })\n+  })\n+\n+  it('should evict oldest entries when cache exceeds max size', async () => {\n+    const $ = await next.render$('/')\n+\n+    const smallImgSrc = $('#image-small').attr('src')\n+    const mediumImgSrc = $('#image-medium').attr('src')\n+    const largeImgSrc = $('#image-large').attr('src')\n+\n+    // Request all three images sequentially\n+    // With MAX_IMAGE_CACHE_ENTRIES=2, the first image should be evicted\n+    // when the third one is added\n+\n+    // Request image 1 (small)\n+    await next.fetch(smallImgSrc)\n+    await retry(() => {\n+      expect(next.cliOutput).toContain('cache-handler image cache size: 1')\n+    })\n+\n+    // Request image 2 (medium)\n+    await next.fetch(mediumImgSrc)\n+    await retry(() => {\n+      expect(next.cliOutput).toContain('cache-handler image cache size: 2')\n+    })\n+\n+    // Request image 3 (large) - this should trigger eviction of image 1\n+    await next.fetch(largeImgSrc)\n+    await retry(() => {\n+      expect(next.cliOutput).toContain('cache-handler evicting')\n+      // Cache size should still be 2 after eviction\n+      const sizeMatches = next.cliOutput.match(\n+        /cache-handler image cache size: (\\d+)/g\n+      )\n+      const lastSize = sizeMatches?.[sizeMatches.length - 1]\n+      expect(lastSize).toContain('size: 2')\n+    })\n+  })\n+\n+  it('should miss cache for evicted entries', async () => {\n+    const $ = await next.render$('/')\n+\n+    const smallImgSrc = $('#image-small').attr('src')\n+    const mediumImgSrc = $('#image-medium').attr('src')\n+    const largeImgSrc = $('#image-large').attr('src')\n+\n+    // Fill the cache and cause eviction\n+    await next.fetch(smallImgSrc) // Entry 1\n+    await next.fetch(mediumImgSrc) // Entry 2\n+    await next.fetch(largeImgSrc) // Entry 3, evicts entry 1\n+\n+    // Clear output to make assertions cleaner\n+    const outputBefore = next.cliOutput\n+\n+    // Request the evicted image again - should be a cache miss\n+    await next.fetch(smallImgSrc)\n+\n+    await retry(() => {\n+      // Get output after the last request\n+      const newOutput = next.cliOutput.slice(outputBefore.length)\n+      // Should have a cache miss for the small image (it was evicted)\n+      expect(newOutput).toContain('cache-handler miss')\n+      // Should set it again\n+      expect(newOutput).toContain('cache-handler set')\n+    })\n+  })\n+})"
        },
        {
            "sha": "dbbd95ec394473a8d651b0e2f86f605bdae57fa9",
            "filename": "test/e2e/custom-cache-handler-image/next.config.js",
            "status": "added",
            "additions": 12,
            "deletions": 0,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/0d4649989d70d147aac443f30737e34a6ce3b186/test%2Fe2e%2Fcustom-cache-handler-image%2Fnext.config.js",
            "raw_url": "https://github.com/vercel/next.js/raw/0d4649989d70d147aac443f30737e34a6ce3b186/test%2Fe2e%2Fcustom-cache-handler-image%2Fnext.config.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fcustom-cache-handler-image%2Fnext.config.js?ref=0d4649989d70d147aac443f30737e34a6ce3b186",
            "patch": "@@ -0,0 +1,12 @@\n+/**\n+ * @type {import('next').NextConfig}\n+ */\n+const nextConfig = {\n+  cacheHandler: process.cwd() + '/cache-handler.js',\n+  images: {\n+    imageSizes: [100, 200, 400],\n+    customCacheHandler: true,\n+  },\n+}\n+\n+module.exports = nextConfig"
        },
        {
            "sha": "e14fafc5cf3bc63b70914ad20467f40f7fecd572",
            "filename": "test/e2e/custom-cache-handler-image/public/test.png",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/vercel/next.js/blob/0d4649989d70d147aac443f30737e34a6ce3b186/test%2Fe2e%2Fcustom-cache-handler-image%2Fpublic%2Ftest.png",
            "raw_url": "https://github.com/vercel/next.js/raw/0d4649989d70d147aac443f30737e34a6ce3b186/test%2Fe2e%2Fcustom-cache-handler-image%2Fpublic%2Ftest.png",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fcustom-cache-handler-image%2Fpublic%2Ftest.png?ref=0d4649989d70d147aac443f30737e34a6ce3b186"
        },
        {
            "sha": "39721d880c9421dde68ec3af1d11fe5ba0fade69",
            "filename": "test/integration/next-image-new/app-dir-localpatterns/test/index.test.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/0d4649989d70d147aac443f30737e34a6ce3b186/test%2Fintegration%2Fnext-image-new%2Fapp-dir-localpatterns%2Ftest%2Findex.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/0d4649989d70d147aac443f30737e34a6ce3b186/test%2Fintegration%2Fnext-image-new%2Fapp-dir-localpatterns%2Ftest%2Findex.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fintegration%2Fnext-image-new%2Fapp-dir-localpatterns%2Ftest%2Findex.test.ts?ref=0d4649989d70d147aac443f30737e34a6ce3b186",
            "patch": "@@ -107,6 +107,7 @@ function runTests(mode: 'dev' | 'server') {\n             256, 384,\n           ],\n           unoptimized: false,\n+          customCacheHandler: false,\n         },\n       })\n     })"
        },
        {
            "sha": "18d4d6435c70d1a1c8d1ba24cd125e0f851520e6",
            "filename": "test/integration/next-image-new/app-dir-qualities/test/index.test.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/0d4649989d70d147aac443f30737e34a6ce3b186/test%2Fintegration%2Fnext-image-new%2Fapp-dir-qualities%2Ftest%2Findex.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/0d4649989d70d147aac443f30737e34a6ce3b186/test%2Fintegration%2Fnext-image-new%2Fapp-dir-qualities%2Ftest%2Findex.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fintegration%2Fnext-image-new%2Fapp-dir-qualities%2Ftest%2Findex.test.ts?ref=0d4649989d70d147aac443f30737e34a6ce3b186",
            "patch": "@@ -119,6 +119,7 @@ function runTests(mode: 'dev' | 'server') {\n             256, 384,\n           ],\n           unoptimized: false,\n+          customCacheHandler: false,\n         },\n       })\n     })"
        },
        {
            "sha": "3dc4554aa7af7963e4e363bb88ef39dabaab5516",
            "filename": "test/integration/next-image-new/app-dir/test/index.test.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/0d4649989d70d147aac443f30737e34a6ce3b186/test%2Fintegration%2Fnext-image-new%2Fapp-dir%2Ftest%2Findex.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/0d4649989d70d147aac443f30737e34a6ce3b186/test%2Fintegration%2Fnext-image-new%2Fapp-dir%2Ftest%2Findex.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fintegration%2Fnext-image-new%2Fapp-dir%2Ftest%2Findex.test.ts?ref=0d4649989d70d147aac443f30737e34a6ce3b186",
            "patch": "@@ -1805,6 +1805,7 @@ function runTests(mode: 'dev' | 'server') {\n             256, 384,\n           ],\n           unoptimized: false,\n+          customCacheHandler: false,\n         },\n       })\n     })"
        },
        {
            "sha": "953db9f2704537717a801c3e665db2cfd4687d18",
            "filename": "test/integration/next-image-new/unicode/test/index.test.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/0d4649989d70d147aac443f30737e34a6ce3b186/test%2Fintegration%2Fnext-image-new%2Funicode%2Ftest%2Findex.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/0d4649989d70d147aac443f30737e34a6ce3b186/test%2Fintegration%2Fnext-image-new%2Funicode%2Ftest%2Findex.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fintegration%2Fnext-image-new%2Funicode%2Ftest%2Findex.test.ts?ref=0d4649989d70d147aac443f30737e34a6ce3b186",
            "patch": "@@ -112,6 +112,7 @@ function runTests(mode: 'server' | 'dev') {\n             256, 384,\n           ],\n           unoptimized: false,\n+          customCacheHandler: false,\n         },\n       })\n     })"
        },
        {
            "sha": "293e0b7d1c83311a89fde62aba2656568281a5d3",
            "filename": "test/integration/next-image-new/unoptimized/test/index.test.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/0d4649989d70d147aac443f30737e34a6ce3b186/test%2Fintegration%2Fnext-image-new%2Funoptimized%2Ftest%2Findex.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/0d4649989d70d147aac443f30737e34a6ce3b186/test%2Fintegration%2Fnext-image-new%2Funoptimized%2Ftest%2Findex.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fintegration%2Fnext-image-new%2Funoptimized%2Ftest%2Findex.test.ts?ref=0d4649989d70d147aac443f30737e34a6ce3b186",
            "patch": "@@ -127,6 +127,7 @@ function runTests(url: string, mode: 'dev' | 'server') {\n             256, 384,\n           ],\n           unoptimized: true,\n+          customCacheHandler: false,\n         },\n       })\n     })"
        }
    ],
    "stats": {
        "total": 418,
        "additions": 409,
        "deletions": 9
    }
}