{
    "author": "lukesandberg",
    "message": "[turbopack] Simplify take_issues and peek issues (#84199)\n\n* don't construct a `cell` just use an `Arc`\n   * this will make it possible to call `peek_issues` in a top level transient task\n   * This required making `AutoSet` `TaskInput` compatible.  The downside is that a few tasks get a more complicated hash/eq implementation for their inputs but the `DelegatingInputTracer` value is generally very small so this should be fine.\n* these functions are no longer async or failable, so simplify the signature",
    "sha": "2a11fc33e7c4e25f4bf02b419febb61caba79691",
    "files": [
        {
            "sha": "2eebcd45db85bd72339a5450f55b047ec7cdf355",
            "filename": "crates/napi/src/next_api/utils.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/2a11fc33e7c4e25f4bf02b419febb61caba79691/crates%2Fnapi%2Fsrc%2Fnext_api%2Futils.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2a11fc33e7c4e25f4bf02b419febb61caba79691/crates%2Fnapi%2Fsrc%2Fnext_api%2Futils.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnapi%2Fsrc%2Fnext_api%2Futils.rs?ref=2a11fc33e7c4e25f4bf02b419febb61caba79691",
            "patch": "@@ -102,8 +102,7 @@ pub fn root_task_dispose(\n }\n \n pub async fn get_issues<T: Send>(source: OperationVc<T>) -> Result<Arc<Vec<ReadRef<PlainIssue>>>> {\n-    let issues = source.peek_issues().await?;\n-    Ok(Arc::new(issues.get_plain_issues().await?))\n+    Ok(Arc::new(source.peek_issues().get_plain_issues().await?))\n }\n \n /// Reads the [turbopack_core::diagnostics::Diagnostic] held"
        },
        {
            "sha": "5ad2784e172df02a2a1a1efc92447950d64c1f47",
            "filename": "crates/next-api/src/operation.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/2a11fc33e7c4e25f4bf02b419febb61caba79691/crates%2Fnext-api%2Fsrc%2Foperation.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2a11fc33e7c4e25f4bf02b419febb61caba79691/crates%2Fnext-api%2Fsrc%2Foperation.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Foperation.rs?ref=2a11fc33e7c4e25f4bf02b419febb61caba79691",
            "patch": "@@ -38,7 +38,7 @@ async fn entrypoints_without_collectibles_operation(\n ) -> Result<Vc<Entrypoints>> {\n     let _ = entrypoints.resolve_strongly_consistent().await?;\n     let _ = entrypoints.take_collectibles::<Box<dyn Diagnostic>>();\n-    let _ = entrypoints.take_issues().await?;\n+    let _ = entrypoints.take_issues();\n     let _ = get_effects(entrypoints).await?;\n     Ok(entrypoints.connect())\n }"
        },
        {
            "sha": "a82e34c95386885d9decee537589891fdbad5944",
            "filename": "crates/next-api/src/project.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/2a11fc33e7c4e25f4bf02b419febb61caba79691/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2a11fc33e7c4e25f4bf02b419febb61caba79691/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fproject.rs?ref=2a11fc33e7c4e25f4bf02b419febb61caba79691",
            "patch": "@@ -981,7 +981,7 @@ impl Project {\n         async move {\n             let module_graphs_op = whole_app_module_graph_operation(self);\n             let module_graphs_vc = module_graphs_op.resolve_strongly_consistent().await?;\n-            let _ = module_graphs_op.take_issues().await?;\n+            let _ = module_graphs_op.take_issues();\n \n             // At this point all modules have been computed and we can get rid of the node.js\n             // process pools"
        },
        {
            "sha": "4ed59d622c1ff068cc077e8f5b15aacb23d8a15a",
            "filename": "turbopack/crates/turbo-tasks-auto-hash-map/src/map.rs",
            "status": "modified",
            "additions": 27,
            "deletions": 0,
            "changes": 27,
            "blob_url": "https://github.com/vercel/next.js/blob/2a11fc33e7c4e25f4bf02b419febb61caba79691/turbopack%2Fcrates%2Fturbo-tasks-auto-hash-map%2Fsrc%2Fmap.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2a11fc33e7c4e25f4bf02b419febb61caba79691/turbopack%2Fcrates%2Fturbo-tasks-auto-hash-map%2Fsrc%2Fmap.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-auto-hash-map%2Fsrc%2Fmap.rs?ref=2a11fc33e7c4e25f4bf02b419febb61caba79691",
            "patch": "@@ -840,6 +840,33 @@ where\n {\n }\n \n+impl<K: Eq + Hash, V: Eq + Hash, MH: BuildHasher, const I: usize> Hash for AutoMap<K, V, MH, I> {\n+    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {\n+        // Hash the length first to distinguish maps of different sizes\n+        self.len().hash(state);\n+\n+        // Use a commutative approach to ensure equal maps have equal hashes\n+        // regardless of iteration order\n+        let mut combined_hash = 0u64;\n+\n+        for (k, v) in self.iter() {\n+            use std::{collections::hash_map::DefaultHasher, hash::Hasher};\n+\n+            // Hash each key-value pair independently\n+            let mut entry_hasher = DefaultHasher::new();\n+            k.hash(&mut entry_hasher);\n+            v.hash(&mut entry_hasher);\n+            let entry_hash = entry_hasher.finish();\n+\n+            // Combine using XOR to make it order-independent\n+            combined_hash ^= entry_hash;\n+        }\n+\n+        // Hash the combined result\n+        combined_hash.hash(state);\n+    }\n+}\n+\n impl<K, V, H, const I: usize> FromIterator<(K, V)> for AutoMap<K, V, H, I>\n where\n     K: Eq + Hash,"
        },
        {
            "sha": "24ada04c5eaba5ef1ab941aeaf1e57612472f09c",
            "filename": "turbopack/crates/turbo-tasks-auto-hash-map/src/set.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/2a11fc33e7c4e25f4bf02b419febb61caba79691/turbopack%2Fcrates%2Fturbo-tasks-auto-hash-map%2Fsrc%2Fset.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2a11fc33e7c4e25f4bf02b419febb61caba79691/turbopack%2Fcrates%2Fturbo-tasks-auto-hash-map%2Fsrc%2Fset.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-auto-hash-map%2Fsrc%2Fset.rs?ref=2a11fc33e7c4e25f4bf02b419febb61caba79691",
            "patch": "@@ -219,6 +219,12 @@ impl<K: Eq + Hash, H: BuildHasher, const I: usize> PartialEq for AutoSet<K, H, I\n \n impl<K: Eq + Hash, H: BuildHasher, const I: usize> Eq for AutoSet<K, H, I> {}\n \n+impl<K: Eq + Hash, SH: BuildHasher, const I: usize> Hash for AutoSet<K, SH, I> {\n+    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {\n+        self.map.hash(state);\n+    }\n+}\n+\n impl<K, H, const I: usize> FromIterator<K> for AutoSet<K, H, I>\n where\n     K: Hash + Eq,"
        },
        {
            "sha": "21865951e8513bb0d75eca74cae3dee82d46d825",
            "filename": "turbopack/crates/turbo-tasks/src/task/task_input.rs",
            "status": "modified",
            "additions": 13,
            "deletions": 0,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/2a11fc33e7c4e25f4bf02b419febb61caba79691/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask%2Ftask_input.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2a11fc33e7c4e25f4bf02b419febb61caba79691/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask%2Ftask_input.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask%2Ftask_input.rs?ref=2a11fc33e7c4e25f4bf02b419febb61caba79691",
            "patch": "@@ -332,6 +332,19 @@ where\n     }\n }\n \n+impl<T> TaskInput for auto_hash_map::AutoSet<T>\n+where\n+    T: TaskInput,\n+{\n+    fn is_resolved(&self) -> bool {\n+        self.iter().all(TaskInput::is_resolved)\n+    }\n+\n+    fn is_transient(&self) -> bool {\n+        self.iter().any(TaskInput::is_transient)\n+    }\n+}\n+\n macro_rules! tuple_impls {\n     ( $( $name:ident )+ ) => {\n         impl<$($name: TaskInput),+> TaskInput for ($($name,)+)"
        },
        {
            "sha": "02a3d659493843e7e62d87139b3b8a939fe40e58",
            "filename": "turbopack/crates/turbopack-core/src/issue/mod.rs",
            "status": "modified",
            "additions": 27,
            "deletions": 29,
            "changes": 56,
            "blob_url": "https://github.com/vercel/next.js/blob/2a11fc33e7c4e25f4bf02b419febb61caba79691/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fissue%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2a11fc33e7c4e25f4bf02b419febb61caba79691/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fissue%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fissue%2Fmod.rs?ref=2a11fc33e7c4e25f4bf02b419febb61caba79691",
            "patch": "@@ -6,6 +6,7 @@ pub mod resolve;\n use std::{\n     cmp::min,\n     fmt::{Display, Formatter},\n+    sync::Arc,\n };\n \n use anyhow::{Result, anyhow};\n@@ -163,8 +164,9 @@ pub trait ImportTracer {\n     fn get_traces(self: Vc<Self>, path: FileSystemPath) -> Vc<ImportTraces>;\n }\n \n-#[turbo_tasks::value(shared)]\n-#[derive(Debug)]\n+#[derive(\n+    Debug, Clone, TaskInput, TraceRawVcs, Hash, Eq, PartialEq, Serialize, Deserialize, NonLocalValue,\n+)]\n pub struct DelegatingImportTracer {\n     delegates: AutoSet<ResolvedVc<Box<dyn ImportTracer>>>,\n }\n@@ -218,7 +220,7 @@ pub struct Issues(Vec<ResolvedVc<Box<dyn Issue>>>);\n #[derive(Debug)]\n pub struct CapturedIssues {\n     issues: AutoSet<ResolvedVc<Box<dyn Issue>>>,\n-    tracer: ResolvedVc<DelegatingImportTracer>,\n+    tracer: Arc<DelegatingImportTracer>,\n }\n \n #[turbo_tasks::value_impl]\n@@ -248,12 +250,14 @@ impl CapturedIssues {\n \n     // Returns all the issues as formatted `PlainIssues`.\n     pub async fn get_plain_issues(&self) -> Result<Vec<ReadRef<PlainIssue>>> {\n-        let mut list = self\n-            .issues\n-            .iter()\n-            .map(|issue| async move { PlainIssue::from_issue(**issue, Some(*self.tracer)).await })\n-            .try_join()\n-            .await?;\n+        let mut list =\n+            self.issues\n+                .iter()\n+                .map(|issue| async move {\n+                    PlainIssue::from_issue(**issue, Some(self.tracer.clone())).await\n+                })\n+                .try_join()\n+                .await?;\n         list.sort();\n         Ok(list)\n     }\n@@ -712,7 +716,7 @@ impl PlainIssue {\n     #[turbo_tasks::function]\n     pub async fn from_issue(\n         issue: ResolvedVc<Box<dyn Issue>>,\n-        import_tracer: Option<ResolvedVc<DelegatingImportTracer>>,\n+        import_tracer: Option<Arc<DelegatingImportTracer>>,\n     ) -> Result<Vc<Self>> {\n         let description: Option<StyledString> = match *issue.description().await? {\n             Some(description) => Some(description.owned().await?),\n@@ -743,13 +747,8 @@ impl PlainIssue {\n             },\n             import_traces: match import_tracer {\n                 Some(tracer) => {\n-                    into_plain_trace(\n-                        tracer\n-                            .await?\n-                            .get_traces(issue.file_path().owned().await?)\n-                            .await?,\n-                    )\n-                    .await?\n+                    into_plain_trace(tracer.get_traces(issue.file_path().owned().await?).await?)\n+                        .await?\n                 }\n                 None => vec![],\n             },\n@@ -812,45 +811,44 @@ pub trait IssueReporter {\n     ) -> Vc<bool>;\n }\n \n-#[async_trait]\n pub trait CollectibleIssuesExt\n where\n     Self: Sized,\n {\n     /// Returns all issues from `source` in a list with their associated\n     /// processing path.\n-    async fn peek_issues(self) -> Result<CapturedIssues>;\n+    fn peek_issues(self) -> CapturedIssues;\n \n     /// Returns all issues from `source` in a list with their associated\n     /// processing path.\n     ///\n     /// This unemits the issues. They will not propagate up.\n-    async fn take_issues(self) -> Result<CapturedIssues>;\n+    fn take_issues(self) -> CapturedIssues;\n }\n \n #[async_trait]\n impl<T> CollectibleIssuesExt for T\n where\n     T: CollectiblesSource + Copy + Send,\n {\n-    async fn peek_issues(self) -> Result<CapturedIssues> {\n-        Ok(CapturedIssues {\n+    fn peek_issues(self) -> CapturedIssues {\n+        CapturedIssues {\n             issues: self.peek_collectibles(),\n \n-            tracer: DelegatingImportTracer::resolved_cell(DelegatingImportTracer {\n+            tracer: Arc::new(DelegatingImportTracer {\n                 delegates: self.peek_collectibles(),\n             }),\n-        })\n+        }\n     }\n \n-    async fn take_issues(self) -> Result<CapturedIssues> {\n-        Ok(CapturedIssues {\n+    fn take_issues(self) -> CapturedIssues {\n+        CapturedIssues {\n             issues: self.take_collectibles(),\n \n-            tracer: DelegatingImportTracer::resolved_cell(DelegatingImportTracer {\n+            tracer: Arc::new(DelegatingImportTracer {\n                 delegates: self.take_collectibles(),\n             }),\n-        })\n+        }\n     }\n }\n \n@@ -863,7 +861,7 @@ pub async fn handle_issues<T: Send>(\n ) -> Result<()> {\n     let source_vc = source_op.connect();\n     let _ = source_op.resolve_strongly_consistent().await?;\n-    let issues = source_op.peek_issues().await?;\n+    let issues = source_op.peek_issues();\n \n     let has_fatal = issue_reporter.report_issues(\n         TransientInstance::new(issues),"
        },
        {
            "sha": "cbd23aed6e3df46449358247da15beab345cc925",
            "filename": "turbopack/crates/turbopack-dev-server/src/update/stream.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/2a11fc33e7c4e25f4bf02b419febb61caba79691/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fupdate%2Fstream.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2a11fc33e7c4e25f4bf02b419febb61caba79691/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fupdate%2Fstream.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fupdate%2Fstream.rs?ref=2a11fc33e7c4e25f4bf02b419febb61caba79691",
            "patch": "@@ -88,7 +88,7 @@ impl GetContentFn {\n }\n \n async fn peek_issues<T: Send>(source: OperationVc<T>) -> Result<Vec<ReadRef<PlainIssue>>> {\n-    let captured = source.peek_issues().await?;\n+    let captured = source.peek_issues();\n \n     captured.get_plain_issues().await\n }"
        },
        {
            "sha": "764c7f447261c4242b3fed7f0a302f81967005a6",
            "filename": "turbopack/crates/turbopack-tests/tests/execution.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 3,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/2a11fc33e7c4e25f4bf02b419febb61caba79691/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2a11fc33e7c4e25f4bf02b419febb61caba79691/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution.rs?ref=2a11fc33e7c4e25f4bf02b419febb61caba79691",
            "patch": "@@ -563,9 +563,7 @@ async fn snapshot_issues(\n     let PreparedTest { path, .. } = &*prepared_test.await?;\n     let _ = run_result_op.resolve_strongly_consistent().await;\n \n-    let captured_issues = run_result_op.peek_issues().await?;\n-\n-    let plain_issues = captured_issues.get_plain_issues().await?;\n+    let plain_issues = run_result_op.peek_issues().get_plain_issues().await?;\n \n     turbopack_test_utils::snapshot::snapshot_issues(plain_issues, path.join(\"issues\")?, &REPO_ROOT)\n         .await"
        },
        {
            "sha": "8b25ca366bd4c87b5bec71b8deb46c0ef86c20d8",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/2a11fc33e7c4e25f4bf02b419febb61caba79691/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2a11fc33e7c4e25f4bf02b419febb61caba79691/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot.rs?ref=2a11fc33e7c4e25f4bf02b419febb61caba79691",
            "patch": "@@ -219,9 +219,8 @@ async fn run(resource: PathBuf) -> Result<()> {\n async fn run_inner_operation(resource: RcStr) -> Result<()> {\n     let out_op = run_test_operation(resource);\n     let out_vc = out_op.resolve_strongly_consistent().await?.owned().await?;\n-    let captured_issues = out_op.peek_issues().await?;\n \n-    let plain_issues = captured_issues.get_plain_issues().await?;\n+    let plain_issues = out_op.peek_issues().get_plain_issues().await?;\n \n     snapshot_issues(plain_issues, out_vc.join(\"issues\")?, &REPO_ROOT)\n         .await"
        }
    ],
    "stats": {
        "total": 118,
        "additions": 79,
        "deletions": 39
    }
}