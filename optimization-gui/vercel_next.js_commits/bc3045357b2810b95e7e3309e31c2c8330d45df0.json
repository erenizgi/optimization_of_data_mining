{
    "author": "gnoff",
    "message": "[dynamicIO] reimplement dynamicIO validation on prerender (#79414)\n\nThis updates the dynamic validation implementation to more closely\nfollow the pattern used in prerenders for dynamicIO + PPR. Now that PPR\nis the only way to use dynamicIO we only have one implementation and the\nvalidation should match it as much as possible.",
    "sha": "bc3045357b2810b95e7e3309e31c2c8330d45df0",
    "files": [
        {
            "sha": "c8c61e63683584b833e8062ee807cf8613a49298",
            "filename": "packages/next/src/server/app-render/app-render-prerender-utils.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 155,
            "changes": 155,
            "blob_url": "https://github.com/vercel/next.js/blob/bc3045357b2810b95e7e3309e31c2c8330d45df0/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render-prerender-utils.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/bc3045357b2810b95e7e3309e31c2c8330d45df0/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render-prerender-utils.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render-prerender-utils.ts?ref=bc3045357b2810b95e7e3309e31c2c8330d45df0",
            "patch": "@@ -1,5 +1,4 @@\n import { InvariantError } from '../../shared/lib/invariant-error'\n-import { isPrerenderInterruptedError } from './dynamic-rendering'\n \n /**\n  * This is a utility function to make scheduling sequential tasks that run back to back easier.\n@@ -32,95 +31,6 @@ export function prerenderAndAbortInSequentialTasks<R>(\n   }\n }\n \n-export function prerenderServerWithPhases(\n-  signal: AbortSignal,\n-  render: () => ReadableStream<Uint8Array>,\n-  finalPhase: () => void\n-): Promise<ServerPrerenderStreamResult>\n-export function prerenderServerWithPhases(\n-  signal: AbortSignal,\n-  render: () => ReadableStream<Uint8Array>,\n-  secondPhase: () => void,\n-  finalPhase: () => void\n-): Promise<ServerPrerenderStreamResult>\n-export function prerenderServerWithPhases(\n-  signal: AbortSignal,\n-  render: () => ReadableStream<Uint8Array>,\n-  secondPhase: () => void,\n-  thirdPhase: () => void,\n-  ...remainingPhases: Array<() => void>\n-): Promise<ServerPrerenderStreamResult>\n-export function prerenderServerWithPhases(\n-  signal: AbortSignal,\n-  render: () => ReadableStream<Uint8Array>,\n-  ...remainingPhases: Array<() => void>\n-): Promise<ServerPrerenderStreamResult> {\n-  if (process.env.NEXT_RUNTIME === 'edge') {\n-    throw new InvariantError(\n-      '`prerenderAndAbortInSequentialTasks` should not be called in edge runtime.'\n-    )\n-  } else {\n-    return new Promise((resolve, reject) => {\n-      let result: ServerPrerenderStreamResult\n-\n-      signal.addEventListener(\n-        'abort',\n-        () => {\n-          if (isPrerenderInterruptedError(signal.reason)) {\n-            result.markInterrupted()\n-          } else {\n-            result.markComplete()\n-          }\n-        },\n-        {\n-          once: true,\n-        }\n-      )\n-\n-      setImmediate(() => {\n-        try {\n-          result = new ServerPrerenderStreamResult(render())\n-        } catch (err) {\n-          reject(err)\n-        }\n-      })\n-\n-      function runFinalTask(this: () => void) {\n-        try {\n-          if (result) {\n-            result.markComplete()\n-            this()\n-          }\n-          resolve(result)\n-        } catch (err) {\n-          reject(err)\n-        }\n-      }\n-\n-      function runNextTask(this: () => void) {\n-        try {\n-          if (result) {\n-            result.markPhase()\n-            this()\n-          }\n-        } catch (err) {\n-          reject(err)\n-        }\n-      }\n-\n-      let i = 0\n-      for (; i < remainingPhases.length - 1; i++) {\n-        const phase = remainingPhases[i]\n-        setImmediate(runNextTask.bind(phase))\n-      }\n-      if (remainingPhases[i]) {\n-        const finalPhase = remainingPhases[i]\n-        setImmediate(runFinalTask.bind(finalPhase))\n-      }\n-    })\n-  }\n-}\n-\n const PENDING = 0\n const COMPLETE = 1\n const INTERRUPTED = 2\n@@ -283,71 +193,6 @@ class PhasedStream<T> extends ReadableStream<T> {\n   }\n }\n \n-export function prerenderClientWithPhases<T>(\n-  render: () => Promise<T>,\n-  finalPhase: () => void\n-): Promise<T>\n-export function prerenderClientWithPhases<T>(\n-  render: () => Promise<T>,\n-  secondPhase: () => void,\n-  finalPhase: () => void\n-): Promise<T>\n-export function prerenderClientWithPhases<T>(\n-  render: () => Promise<T>,\n-  secondPhase: () => void,\n-  thirdPhase: () => void,\n-  ...remainingPhases: Array<() => void>\n-): Promise<T>\n-export function prerenderClientWithPhases<T>(\n-  render: () => Promise<T>,\n-  ...remainingPhases: Array<() => void>\n-): Promise<T> {\n-  if (process.env.NEXT_RUNTIME === 'edge') {\n-    throw new InvariantError(\n-      '`prerenderAndAbortInSequentialTasks` should not be called in edge runtime.'\n-    )\n-  } else {\n-    return new Promise((resolve, reject) => {\n-      let pendingResult: Promise<T>\n-      setImmediate(() => {\n-        try {\n-          pendingResult = render()\n-          pendingResult.catch((err) => reject(err))\n-        } catch (err) {\n-          reject(err)\n-        }\n-      })\n-\n-      function runFinalTask(this: () => void) {\n-        try {\n-          this()\n-          resolve(pendingResult)\n-        } catch (err) {\n-          reject(err)\n-        }\n-      }\n-\n-      function runNextTask(this: () => void) {\n-        try {\n-          this()\n-        } catch (err) {\n-          reject(err)\n-        }\n-      }\n-\n-      let i = 0\n-      for (; i < remainingPhases.length - 1; i++) {\n-        const phase = remainingPhases[i]\n-        setImmediate(runNextTask.bind(phase))\n-      }\n-      if (remainingPhases[i]) {\n-        const finalPhase = remainingPhases[i]\n-        setImmediate(runFinalTask.bind(finalPhase))\n-      }\n-    })\n-  }\n-}\n-\n // React's RSC prerender function will emit an incomplete flight stream when using `prerender`. If the connection\n // closes then whatever hanging chunks exist will be errored. This is because prerender (an experimental feature)\n // has not yet implemented a concept of resume. For now we will simulate a paused connection by wrapping the stream"
        },
        {
            "sha": "f42d917d6440d5388a137d01cfe4d91e35d4539f",
            "filename": "packages/next/src/server/app-render/app-render.tsx",
            "status": "modified",
            "additions": 284,
            "deletions": 217,
            "changes": 501,
            "blob_url": "https://github.com/vercel/next.js/blob/bc3045357b2810b95e7e3309e31c2c8330d45df0/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/bc3045357b2810b95e7e3309e31c2c8330d45df0/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx?ref=bc3045357b2810b95e7e3309e31c2c8330d45df0",
            "patch": "@@ -162,8 +162,6 @@ import {\n   createReactServerPrerenderResult,\n   createReactServerPrerenderResultFromRender,\n   prerenderAndAbortInSequentialTasks,\n-  prerenderServerWithPhases,\n-  prerenderClientWithPhases,\n } from './app-render-prerender-utils'\n import { printDebugThrownValueForProspectiveRender } from './prospective-render-utils'\n import { scheduleInSequentialTasks } from './app-render-render-utils'\n@@ -2233,6 +2231,12 @@ function createValidationOutlet() {\n   return [resolveValidation!, outlet] as const\n }\n \n+/**\n+ * This function is a fork of prerenderToStream dynamicIO branch.\n+ * While it doesn't return a stream we want it to have identical\n+ * prerender semantics to prerenderToStream and should update it\n+ * in conjunction with any changes to that function.\n+ */\n async function spawnDynamicValidationInDev(\n   resolveValidation: (validatingElement: React.ReactNode) => void,\n   tree: LoaderTree,\n@@ -2249,9 +2253,14 @@ async function spawnDynamicValidationInDev(\n     renderOpts,\n     workStore,\n   } = ctx\n-\n   const { botType } = renderOpts\n \n+  // These values are placeholder values for this validating render\n+  // that are provided during the actual prerenderToStream.\n+  const preinitScripts = () => {}\n+  const { ServerInsertedHTMLProvider } = createServerInsertedHTML()\n+  const { ServerInsertedMetadataProvider } = createServerInsertedMetadata(nonce)\n+\n   const rootParams = getRootParams(\n     ComponentMod.tree,\n     getDynamicParamFromSegment\n@@ -2272,7 +2281,14 @@ async function spawnDynamicValidationInDev(\n   // because we don't want to end the react render until all caches are filled.\n   const initialServerRenderController = new AbortController()\n \n+  // The cacheSignal helps us track whether caches are still filling or we are ready\n+  // to cut the render off.\n   const cacheSignal = new CacheSignal()\n+\n+  // The resume data cache here should use a fresh instance as it's\n+  // performing a fresh prerender. If we get to implementing the\n+  // prerendering of an already prerendered page, we should use the passed\n+  // resume data cache instead.\n   const prerenderResumeDataCache = createPrerenderResumeDataCache()\n   const initialServerPrerenderStore: PrerenderStore = {\n     type: 'prerender',\n@@ -2281,80 +2297,92 @@ async function spawnDynamicValidationInDev(\n     implicitTags,\n     renderSignal: initialServerRenderController.signal,\n     controller: initialServerPrerenderController,\n+    // During the initial prerender we need to track all cache reads to ensure\n+    // we render long enough to fill every cache it is possible to visit during\n+    // the final prerender.\n     cacheSignal,\n     dynamicTracking: null,\n     revalidate: INFINITE_CACHE,\n     expire: INFINITE_CACHE,\n     stale: INFINITE_CACHE,\n-    tags: [],\n-    prerenderResumeDataCache,\n-    hmrRefreshHash,\n-  }\n-\n-  const initialClientController = new AbortController()\n-  const initialClientPrerenderStore: PrerenderStore = {\n-    type: 'prerender',\n-    phase: 'render',\n-    rootParams,\n-    implicitTags,\n-    renderSignal: initialClientController.signal,\n-    controller: initialClientController,\n-    cacheSignal,\n-    dynamicTracking: null,\n-    revalidate: INFINITE_CACHE,\n-    expire: INFINITE_CACHE,\n-    stale: INFINITE_CACHE,\n-    tags: [],\n+    tags: [...implicitTags.tags],\n     prerenderResumeDataCache,\n     hmrRefreshHash,\n   }\n \n   // We're not going to use the result of this render because the only time it could be used\n   // is if it completes in a microtask and that's likely very rare for any non-trivial app\n-  const firstAttemptRSCPayload = await workUnitAsyncStorage.run(\n+  const initialServerPayload = await workUnitAsyncStorage.run(\n     initialServerPrerenderStore,\n     getRSCPayload,\n     tree,\n     ctx,\n     isNotFound\n   )\n \n-  let initialServerStream\n-  try {\n-    initialServerStream = workUnitAsyncStorage.run(\n-      initialServerPrerenderStore,\n-      ComponentMod.renderToReadableStream,\n-      firstAttemptRSCPayload,\n-      clientReferenceManifest.clientModules,\n-      {\n-        onError: (err) => {\n-          const digest = getDigestForWellKnownError(err)\n+  const pendingInitialServerResult = workUnitAsyncStorage.run(\n+    initialServerPrerenderStore,\n+    ComponentMod.prerender,\n+    initialServerPayload,\n+    clientReferenceManifest.clientModules,\n+    {\n+      onError: (err) => {\n+        const digest = getDigestForWellKnownError(err)\n \n-          if (digest) {\n-            return digest\n-          }\n+        if (digest) {\n+          return digest\n+        }\n \n-          if (\n-            initialServerPrerenderController.signal.aborted ||\n-            initialServerRenderController.signal.aborted\n-          ) {\n-            // The render aborted before this error was handled which indicates\n-            // the error is caused by unfinished components within the render\n-            return\n-          } else if (\n-            process.env.NEXT_DEBUG_BUILD ||\n-            process.env.__NEXT_VERBOSE_LOGGING\n-          ) {\n-            printDebugThrownValueForProspectiveRender(err, workStore.route)\n-          }\n-        },\n-        signal: initialServerRenderController.signal,\n-      }\n+        if (initialServerPrerenderController.signal.aborted) {\n+          // The render aborted before this error was handled which indicates\n+          // the error is caused by unfinished components within the render\n+          return\n+        } else if (\n+          process.env.NEXT_DEBUG_BUILD ||\n+          process.env.__NEXT_VERBOSE_LOGGING\n+        ) {\n+          printDebugThrownValueForProspectiveRender(err, workStore.route)\n+        }\n+      },\n+      // we don't care to track postpones during the prospective render because we need\n+      // to always do a final render anyway\n+      onPostpone: undefined,\n+      // We don't want to stop rendering until the cacheSignal is complete so we pass\n+      // a different signal to this render call than is used by dynamic APIs to signify\n+      // transitioning out of the prerender environment\n+      signal: initialServerRenderController.signal,\n+    }\n+  )\n+\n+  // Wait for all caches to be finished filling and for async imports to resolve\n+  trackPendingModules(cacheSignal)\n+  await cacheSignal.cacheReady()\n+\n+  initialServerRenderController.abort()\n+  initialServerPrerenderController.abort()\n+\n+  // We don't need to continue the prerender process if we already\n+  // detected invalid dynamic usage in the initial prerender phase.\n+  if (workStore.invalidDynamicUsageError) {\n+    resolveValidation(\n+      <LogSafely\n+        fn={() => {\n+          console.error(workStore.invalidDynamicUsageError)\n+        }}\n+      />\n+    )\n+    return\n+  }\n+\n+  let initialServerResult\n+  try {\n+    initialServerResult = await createReactServerPrerenderResult(\n+      pendingInitialServerResult\n     )\n-  } catch (err: unknown) {\n+  } catch (err) {\n     if (\n-      initialServerPrerenderController.signal.aborted ||\n-      initialServerRenderController.signal.aborted\n+      initialServerRenderController.signal.aborted ||\n+      initialServerPrerenderController.signal.aborted\n     ) {\n       // These are expected errors that might error the prerender. we ignore them.\n     } else if (\n@@ -2367,18 +2395,35 @@ async function spawnDynamicValidationInDev(\n     }\n   }\n \n-  const { ServerInsertedHTMLProvider } = createServerInsertedHTML()\n-  const { ServerInsertedMetadataProvider } = createServerInsertedMetadata(nonce)\n+  if (initialServerResult) {\n+    const initialClientController = new AbortController()\n+    const initialClientPrerenderStore: PrerenderStore = {\n+      type: 'prerender',\n+      phase: 'render',\n+      rootParams,\n+      implicitTags,\n+      renderSignal: initialClientController.signal,\n+      controller: initialClientController,\n+      // For HTML Generation the only cache tracked activity\n+      // is module loading, which has it's own cache signal\n+      cacheSignal: null,\n+      dynamicTracking: null,\n+      revalidate: INFINITE_CACHE,\n+      expire: INFINITE_CACHE,\n+      stale: INFINITE_CACHE,\n+      tags: [...implicitTags.tags],\n+      prerenderResumeDataCache,\n+      hmrRefreshHash: undefined,\n+    }\n \n-  if (initialServerStream) {\n     const prerender = require('react-dom/static.edge')\n       .prerender as (typeof import('react-dom/static.edge'))['prerender']\n     const pendingInitialClientResult = workUnitAsyncStorage.run(\n       initialClientPrerenderStore,\n       prerender,\n       <App\n-        reactServerStream={initialServerStream}\n-        preinitScripts={() => {}}\n+        reactServerStream={initialServerResult.asUnclosingStream()}\n+        preinitScripts={preinitScripts}\n         clientReferenceManifest={clientReferenceManifest}\n         ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n         ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n@@ -2405,36 +2450,38 @@ async function spawnDynamicValidationInDev(\n             printDebugThrownValueForProspectiveRender(err, workStore.route)\n           }\n         },\n+        // We don't need bootstrap scripts in this prerender\n+        // bootstrapScripts: [bootstrapScript],\n       }\n     )\n-    pendingInitialClientResult.catch((err: unknown) => {\n-      if (initialClientController.signal.aborted) {\n-        // We aborted the render normally and can ignore this error\n-      } else {\n-        // We're going to retry to so we normally would suppress this error but\n-        // when verbose logging is on we print it\n-        if (process.env.__NEXT_VERBOSE_LOGGING) {\n-          printDebugThrownValueForProspectiveRender(err, workStore.route)\n-        }\n+\n+    pendingInitialClientResult.catch((err) => {\n+      if (\n+        initialServerRenderController.signal.aborted ||\n+        isPrerenderInterruptedError(err)\n+      ) {\n+        // These are expected errors that might error the prerender. we ignore them.\n+      } else if (\n+        process.env.NEXT_DEBUG_BUILD ||\n+        process.env.__NEXT_VERBOSE_LOGGING\n+      ) {\n+        // We don't normally log these errors because we are going to retry anyway but\n+        // it can be useful for debugging Next.js itself to get visibility here when needed\n+        printDebugThrownValueForProspectiveRender(err, workStore.route)\n       }\n     })\n-  }\n-\n-  // Wait for all caches to be finished filling and for async imports to resolve\n-  trackPendingModules(cacheSignal)\n-  await cacheSignal.cacheReady()\n-\n-  // It is important that we abort the SSR render first to avoid\n-  // connection closed errors from having an incomplete RSC stream\n-  initialClientController.abort()\n-  initialServerRenderController.abort()\n-  initialServerPrerenderController.abort()\n \n-  // We've now filled caches and triggered any inadvertent sync bailouts\n-  // due to lazy module initialization. We can restart our render to capture results\n+    // This is mostly needed for dynamic `import()`s in client components.\n+    // Promises passed to client were already awaited above (assuming that they came from cached functions)\n+    trackPendingModules(cacheSignal)\n+    await cacheSignal.cacheReady()\n+    initialClientController.abort()\n+  }\n \n   const finalServerController = new AbortController()\n-  const serverDynamicTracking = createDynamicTrackingState(false)\n+  const serverDynamicTracking = createDynamicTrackingState(\n+    false // isDebugDynamicAccesses\n+  )\n \n   const finalServerPrerenderStore: PrerenderStore = {\n     type: 'prerender',\n@@ -2443,163 +2490,178 @@ async function spawnDynamicValidationInDev(\n     implicitTags,\n     renderSignal: finalServerController.signal,\n     controller: finalServerController,\n-    // During the final prerender we don't need to track cache access so we omit the signal\n+    // All caches we could read must already be filled so no tracking is necessary\n     cacheSignal: null,\n     dynamicTracking: serverDynamicTracking,\n     revalidate: INFINITE_CACHE,\n     expire: INFINITE_CACHE,\n     stale: INFINITE_CACHE,\n-    tags: [],\n+    tags: [...implicitTags.tags],\n     prerenderResumeDataCache,\n     hmrRefreshHash,\n   }\n \n-  const finalClientController = new AbortController()\n-  const clientDynamicTracking = createDynamicTrackingState(false)\n-  const dynamicValidation = createDynamicValidationState()\n+  const finalAttemptRSCPayload = await workUnitAsyncStorage.run(\n+    finalServerPrerenderStore,\n+    getRSCPayload,\n+    tree,\n+    ctx,\n+    isNotFound\n+  )\n+  const reactServerResult = await createReactServerPrerenderResult(\n+    prerenderAndAbortInSequentialTasks(\n+      async () => {\n+        const prerenderResult = await workUnitAsyncStorage.run(\n+          // The store to scope\n+          finalServerPrerenderStore,\n+          // The function to run\n+          ComponentMod.prerender,\n+          // ... the arguments for the function to run\n+          finalAttemptRSCPayload,\n+          clientReferenceManifest.clientModules,\n+          {\n+            onError: (err: unknown) => {\n+              if (\n+                finalServerController.signal.aborted &&\n+                isPrerenderInterruptedError(err)\n+              ) {\n+                return err.digest\n+              }\n+\n+              return getDigestForWellKnownError(err)\n+            },\n+            signal: finalServerController.signal,\n+          }\n+        )\n+        return prerenderResult\n+      },\n+      () => {\n+        finalServerController.abort()\n+      }\n+    )\n+  )\n \n+  const clientDynamicTracking = createDynamicTrackingState(\n+    false //isDebugDynamicAccesses\n+  )\n+  const finalClientController = new AbortController()\n   const finalClientPrerenderStore: PrerenderStore = {\n     type: 'prerender',\n     phase: 'render',\n     rootParams,\n     implicitTags,\n     renderSignal: finalClientController.signal,\n     controller: finalClientController,\n-    // During the final prerender we don't need to track cache access so we omit the signal\n+    // No APIs require a cacheSignal through the workUnitStore during the HTML prerender\n     cacheSignal: null,\n     dynamicTracking: clientDynamicTracking,\n     revalidate: INFINITE_CACHE,\n     expire: INFINITE_CACHE,\n     stale: INFINITE_CACHE,\n-    tags: [],\n+    tags: [...implicitTags.tags],\n     prerenderResumeDataCache,\n     hmrRefreshHash,\n   }\n \n-  const finalServerPayload = await workUnitAsyncStorage.run(\n-    finalServerPrerenderStore,\n-    getRSCPayload,\n-    tree,\n-    ctx,\n-    isNotFound\n-  )\n-\n-  const serverPrerenderStreamResult = await prerenderServerWithPhases(\n-    finalServerController.signal,\n-    () =>\n-      workUnitAsyncStorage.run(\n-        finalServerPrerenderStore,\n-        ComponentMod.renderToReadableStream,\n-        finalServerPayload,\n-        clientReferenceManifest.clientModules,\n-        {\n-          onError: (err) => {\n-            if (\n-              finalServerController.signal.aborted &&\n-              isPrerenderInterruptedError(err)\n-            ) {\n-              return err.digest\n-            }\n-\n-            return getDigestForWellKnownError(err)\n-          },\n-          signal: finalServerController.signal,\n-        }\n-      ),\n-    () => {\n-      finalServerController.abort()\n-    }\n-  )\n+  let dynamicValidation = createDynamicValidationState()\n \n-  let rootDidError = false\n-  const serverPhasedStream = serverPrerenderStreamResult.asPhasedStream()\n-  let preludeIsEmpty = false\n   try {\n     const prerender = require('react-dom/static.edge')\n       .prerender as (typeof import('react-dom/static.edge'))['prerender']\n-    const { prelude: unprocessedPrelude } = await prerenderClientWithPhases(\n-      () =>\n-        workUnitAsyncStorage.run(\n-          finalClientPrerenderStore,\n-          prerender,\n-          <App\n-            reactServerStream={serverPhasedStream}\n-            preinitScripts={() => {}}\n-            clientReferenceManifest={clientReferenceManifest}\n-            ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n-            ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n-            gracefullyDegrade={!!botType}\n-            nonce={nonce}\n-          />,\n-          {\n-            signal: finalClientController.signal,\n-            onError: (err, errorInfo) => {\n-              if (\n-                isPrerenderInterruptedError(err) ||\n-                finalClientController.signal.aborted\n-              ) {\n-                if (!rootDidError) {\n-                  // If the root errored before we observe this error then it wasn't caused by something dynamic.\n-                  // If the root did not error or is erroring because of a sync dynamic API or a prerender interrupt error\n-                  // then we are a dynamic route.\n-                  requestStore.usedDynamic = true\n+    let { prelude: unprocessedPrelude } =\n+      await prerenderAndAbortInSequentialTasks(\n+        () =>\n+          workUnitAsyncStorage.run(\n+            finalClientPrerenderStore,\n+            prerender,\n+            <App\n+              reactServerStream={reactServerResult.asUnclosingStream()}\n+              preinitScripts={preinitScripts}\n+              clientReferenceManifest={clientReferenceManifest}\n+              ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n+              ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n+              gracefullyDegrade={!!botType}\n+              nonce={nonce}\n+            />,\n+            {\n+              signal: finalClientController.signal,\n+              onError: (err: unknown, errorInfo: ErrorInfo) => {\n+                if (\n+                  isPrerenderInterruptedError(err) ||\n+                  finalClientController.signal.aborted\n+                ) {\n+                  const componentStack = errorInfo.componentStack\n+                  if (typeof componentStack === 'string') {\n+                    trackAllowedDynamicAccess(\n+                      workStore.route,\n+                      componentStack,\n+                      dynamicValidation\n+                    )\n+                  }\n+                  return\n                 }\n \n-                const componentStack = errorInfo.componentStack\n-                if (typeof componentStack === 'string') {\n-                  trackAllowedDynamicAccess(\n-                    workStore.route,\n-                    componentStack,\n-                    dynamicValidation\n-                  )\n-                }\n-                return\n-              }\n+                return getDigestForWellKnownError(err)\n+              },\n+              // We don't need bootstrap scripts in this prerender\n+              // bootstrapScripts: [bootstrapScript],\n+            }\n+          ),\n+        () => {\n+          finalClientController.abort()\n+        }\n+      )\n \n-              return getDigestForWellKnownError(err)\n-            },\n-          }\n-        ),\n-      () => {\n-        finalClientController.abort()\n-        serverPhasedStream.assertExhausted()\n-      }\n+    const { preludeIsEmpty } = await processPrelude(unprocessedPrelude)\n+\n+    resolveValidation(\n+      <LogSafely\n+        fn={throwIfDisallowedDynamic.bind(\n+          null,\n+          workStore,\n+          preludeIsEmpty,\n+          dynamicValidation,\n+          serverDynamicTracking,\n+          clientDynamicTracking\n+        )}\n+      />\n     )\n-    preludeIsEmpty = (await processPrelude(unprocessedPrelude)).preludeIsEmpty\n-  } catch (err) {\n-    rootDidError = true\n-    preludeIsEmpty = true\n-    if (\n-      isPrerenderInterruptedError(err) ||\n-      finalClientController.signal.aborted\n-    ) {\n-      // we don't have a root because the abort errored in the root. We can just ignore this error\n-    } else {\n-      // If an error is thrown in the root before prerendering is aborted, we\n-      // don't want to rethrow it here, otherwise this would lead to a hanging\n-      // response and unhandled rejection. We also don't want to log it, because\n-      // it's most likely already logged as part of the normal render. So we\n-      // just fall through here, to make sure `resolveValidation` is called.\n+  } catch (thrownValue) {\n+    // Even if the root errors we still want to report any dynamic IO errors\n+    // that were discovered before the root errored.\n+\n+    const preludeIsEmpty = true\n+    let loggingFunction = throwIfDisallowedDynamic.bind(\n+      null,\n+      workStore,\n+      preludeIsEmpty,\n+      dynamicValidation,\n+      serverDynamicTracking,\n+      clientDynamicTracking\n+    )\n+\n+    if (process.env.NEXT_DEBUG_BUILD || process.env.__NEXT_VERBOSE_LOGGING) {\n+      // We don't normally log these errors because we are going to retry anyway but\n+      // it can be useful for debugging Next.js itself to get visibility here when needed\n+      const originalLoggingFunction = loggingFunction\n+      loggingFunction = () => {\n+        console.error(\n+          'During dynamic validation the root of the page errored. The next logged error is the thrown value. It may be a duplicate of errors reported during the normal development mode render.'\n+        )\n+        console.error(thrownValue)\n+        originalLoggingFunction()\n+      }\n     }\n-  }\n \n-  function LogDynamicValidation() {\n-    try {\n-      // If we've disabled throwing on empty static shell, then we don't need to\n-      // track any dynamic access that occurs above the suspense boundary because\n-      // we'll do so in the route shell.\n-      throwIfDisallowedDynamic(\n-        workStore,\n-        preludeIsEmpty,\n-        dynamicValidation,\n-        serverDynamicTracking,\n-        clientDynamicTracking\n-      )\n-    } catch {}\n-    return null\n+    resolveValidation(<LogSafely fn={loggingFunction} />)\n   }\n+}\n \n-  resolveValidation(<LogDynamicValidation />)\n+async function LogSafely({ fn }: { fn: () => unknown }) {\n+  try {\n+    await fn()\n+  } catch {}\n+  return null\n }\n \n type PrerenderToStreamResult = {\n@@ -2818,6 +2880,9 @@ async function prerenderToStream(\n         implicitTags,\n         renderSignal: initialServerRenderController.signal,\n         controller: initialServerPrerenderController,\n+        // During the initial prerender we need to track all cache reads to ensure\n+        // we render long enough to fill every cache it is possible to visit during\n+        // the final prerender.\n         cacheSignal,\n         dynamicTracking: null,\n         revalidate: INFINITE_CACHE,\n@@ -2938,7 +3003,9 @@ async function prerenderToStream(\n           implicitTags,\n           renderSignal: initialClientController.signal,\n           controller: initialClientController,\n-          cacheSignal,\n+          // For HTML Generation the only cache tracked activity\n+          // is module loading, which has it's own cache signal\n+          cacheSignal: null,\n           dynamicTracking: null,\n           revalidate: INFINITE_CACHE,\n           expire: INFINITE_CACHE,\n@@ -3015,14 +3082,14 @@ async function prerenderToStream(\n         isDebugDynamicAccesses\n       )\n \n-      const finalRenderPrerenderStore: PrerenderStore = (prerenderStore = {\n+      const finalServerPrerenderStore: PrerenderStore = (prerenderStore = {\n         type: 'prerender',\n         phase: 'render',\n         rootParams,\n         implicitTags,\n         renderSignal: finalServerController.signal,\n         controller: finalServerController,\n-        // During the final prerender we don't need to track cache access so we omit the signal\n+        // All caches we could read must already be filled so no tracking is necessary\n         cacheSignal: null,\n         dynamicTracking: serverDynamicTracking,\n         revalidate: INFINITE_CACHE,\n@@ -3034,7 +3101,7 @@ async function prerenderToStream(\n       })\n \n       const finalAttemptRSCPayload = await workUnitAsyncStorage.run(\n-        finalRenderPrerenderStore,\n+        finalServerPrerenderStore,\n         getRSCPayload,\n         tree,\n         ctx,\n@@ -3047,7 +3114,7 @@ async function prerenderToStream(\n             async () => {\n               const prerenderResult = await workUnitAsyncStorage.run(\n                 // The store to scope\n-                finalRenderPrerenderStore,\n+                finalServerPrerenderStore,\n                 // The function to run\n                 ComponentMod.prerender,\n                 // ... the arguments for the function to run\n@@ -3092,7 +3159,7 @@ async function prerenderToStream(\n         implicitTags,\n         renderSignal: finalClientController.signal,\n         controller: finalClientController,\n-        // For HTML Generation we don't need to track cache reads (RSC only)\n+        // No APIs require a cacheSignal through the workUnitStore during the HTML prerender\n         cacheSignal: null,\n         dynamicTracking: clientDynamicTracking,\n         revalidate: INFINITE_CACHE,\n@@ -3189,7 +3256,7 @@ async function prerenderToStream(\n       metadata.flightData = flightData\n       metadata.segmentData = await collectSegmentData(\n         flightData,\n-        finalRenderPrerenderStore,\n+        finalServerPrerenderStore,\n         ComponentMod,\n         renderOpts,\n         fallbackRouteParams\n@@ -3222,10 +3289,10 @@ async function prerenderToStream(\n             clientDynamicTracking\n           ),\n           // TODO: Should this include the SSR pass?\n-          collectedRevalidate: finalRenderPrerenderStore.revalidate,\n-          collectedExpire: finalRenderPrerenderStore.expire,\n-          collectedStale: selectStaleTime(finalRenderPrerenderStore.stale),\n-          collectedTags: finalRenderPrerenderStore.tags,\n+          collectedRevalidate: finalServerPrerenderStore.revalidate,\n+          collectedExpire: finalServerPrerenderStore.expire,\n+          collectedStale: selectStaleTime(finalServerPrerenderStore.stale),\n+          collectedTags: finalServerPrerenderStore.tags,\n         }\n       } else {\n         // Static case\n@@ -3285,10 +3352,10 @@ async function prerenderToStream(\n             clientDynamicTracking\n           ),\n           // TODO: Should this include the SSR pass?\n-          collectedRevalidate: finalRenderPrerenderStore.revalidate,\n-          collectedExpire: finalRenderPrerenderStore.expire,\n-          collectedStale: selectStaleTime(finalRenderPrerenderStore.stale),\n-          collectedTags: finalRenderPrerenderStore.tags,\n+          collectedRevalidate: finalServerPrerenderStore.revalidate,\n+          collectedExpire: finalServerPrerenderStore.expire,\n+          collectedStale: selectStaleTime(finalServerPrerenderStore.stale),\n+          collectedTags: finalServerPrerenderStore.tags,\n         }\n       }\n     } else if (experimental.isRoutePPREnabled) {"
        },
        {
            "sha": "64772ad1431c08a04b9141359c323226d8bc1d29",
            "filename": "test/development/app-dir/dynamic-io-dev-errors/dynamic-io-dev-errors.test.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/bc3045357b2810b95e7e3309e31c2c8330d45df0/test%2Fdevelopment%2Fapp-dir%2Fdynamic-io-dev-errors%2Fdynamic-io-dev-errors.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/bc3045357b2810b95e7e3309e31c2c8330d45df0/test%2Fdevelopment%2Fapp-dir%2Fdynamic-io-dev-errors%2Fdynamic-io-dev-errors.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Fapp-dir%2Fdynamic-io-dev-errors%2Fdynamic-io-dev-errors.test.ts?ref=bc3045357b2810b95e7e3309e31c2c8330d45df0",
            "patch": "@@ -23,7 +23,7 @@ describe('Dynamic IO Dev Errors', () => {\n          \"stack\": [\n            \"Page app/error/page.tsx (2:23)\",\n            \"JSON.parse <anonymous> (0:0)\",\n-           \"<unknown> <anonymous> (0:0)\",\n+           \"LogSafely <anonymous> (0:0)\",\n          ],\n        }\n       `)\n@@ -49,7 +49,7 @@ describe('Dynamic IO Dev Errors', () => {\n          \"stack\": [\n            \"Page app/error/page.tsx (2:23)\",\n            \"JSON.parse <anonymous> (0:0)\",\n-           \"<unknown> <anonymous> (0:0)\",\n+           \"LogSafely <anonymous> (0:0)\",\n          ],\n        }\n       `)\n@@ -111,7 +111,7 @@ describe('Dynamic IO Dev Errors', () => {\n            \"html <anonymous> (2:1)\",\n            \"Root [Server] <anonymous> (2:1)\",\n            \"JSON.parse <anonymous> (0:0)\",\n-           \"<unknown> <anonymous> (0:0)\",\n+           \"LogSafely <anonymous> (0:0)\",\n          ],\n        }\n       `)"
        }
    ],
    "stats": {
        "total": 662,
        "additions": 287,
        "deletions": 375
    }
}