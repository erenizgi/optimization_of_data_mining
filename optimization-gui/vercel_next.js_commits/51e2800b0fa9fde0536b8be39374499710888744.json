{
    "author": "sokra",
    "message": "Turbopack: limit compaction merging by size instead of count (#78669)\n\n### What?\n\nInstead of only limiting the number of files to merge during a compaction step, limit the number of bytes to merge. That should be more aligned with the performance cost of the merging step, which we want to limit",
    "sha": "51e2800b0fa9fde0536b8be39374499710888744",
    "files": [
        {
            "sha": "df0707db93fb28323fd643ebc6029f1a065bc7ba",
            "filename": "turbopack/crates/turbo-persistence/src/compaction/selector.rs",
            "status": "modified",
            "additions": 57,
            "deletions": 4,
            "changes": 61,
            "blob_url": "https://github.com/vercel/next.js/blob/51e2800b0fa9fde0536b8be39374499710888744/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fcompaction%2Fselector.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/51e2800b0fa9fde0536b8be39374499710888744/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fcompaction%2Fselector.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fcompaction%2Fselector.rs?ref=51e2800b0fa9fde0536b8be39374499710888744",
            "patch": "@@ -19,6 +19,9 @@ type Range = (u64, u64);\n pub trait Compactable {\n     /// Returns the range of the compactable.\n     fn range(&self) -> Range;\n+\n+    /// Returns the size of the compactable.\n+    fn size(&self) -> usize;\n }\n \n fn is_overlapping(a: &Range, b: &Range) -> bool {\n@@ -55,11 +58,14 @@ pub fn total_coverage<T: Compactable>(compactables: &[T], full_range: Range) ->\n \n /// Configuration for the compaction algorithm.\n pub struct CompactConfig {\n+    /// The minimum number of files to merge at once.\n+    pub min_merge: usize,\n+\n     /// The maximum number of files to merge at once.\n     pub max_merge: usize,\n \n-    /// The minimum number of files to merge at once.\n-    pub min_merge: usize,\n+    /// The maximum size of all files to merge at once.\n+    pub max_merge_size: usize,\n }\n \n /// For a list of compactables, computes merge and move jobs that are expected to perform best.\n@@ -102,6 +108,7 @@ fn get_compaction_jobs_internal<T: Compactable>(\n         let start_range = compactables[start].range();\n         let mut range = start_range;\n \n+        let mut merge_job_size = compactables[start].size();\n         let mut merge_job = Vec::new();\n         merge_job.push(start);\n         let mut merge_job_input_spread = spread(&start_range) as f32;\n@@ -116,8 +123,13 @@ fn get_compaction_jobs_internal<T: Compactable>(\n                     if is_overlapping(&range, &range_for_i) {\n                         let mut extended_range = range;\n                         if !extend_range(&mut extended_range, &range_for_i) {\n+                            let size = compactables[i].size();\n+                            if merge_job_size + size > config.max_merge_size {\n+                                break 'outer;\n+                            }\n                             used_compactables[i] = true;\n                             merge_job.push(i);\n+                            merge_job_size += compactables[i].size();\n                             merge_job_input_spread += spread(&range_for_i) as f32;\n                         } else {\n                             let s = spread(&range);\n@@ -216,22 +228,32 @@ mod tests {\n \n     struct TestCompactable {\n         range: Range,\n+        size: usize,\n     }\n \n     impl Compactable for TestCompactable {\n         fn range(&self) -> Range {\n             self.range\n         }\n+\n+        fn size(&self) -> usize {\n+            self.size\n+        }\n     }\n \n-    fn compact<const N: usize>(ranges: [(u64, u64); N], max_merge: usize) -> CompactionJobs {\n+    fn compact<const N: usize>(\n+        ranges: [(u64, u64); N],\n+        max_merge: usize,\n+        max_merge_size: usize,\n+    ) -> CompactionJobs {\n         let compactables = ranges\n             .iter()\n-            .map(|&range| TestCompactable { range })\n+            .map(|&range| TestCompactable { range, size: 100 })\n             .collect::<Vec<_>>();\n         let config = CompactConfig {\n             max_merge,\n             min_merge: 2,\n+            max_merge_size,\n         };\n         get_compaction_jobs(&compactables, &config)\n     }\n@@ -255,6 +277,32 @@ mod tests {\n                 (30, 40),\n             ],\n             3,\n+            usize::MAX,\n+        );\n+        assert_eq!(merge_jobs, vec![vec![0, 1, 2], vec![4, 5, 6]]);\n+        assert_eq!(move_jobs, vec![3, 8]);\n+    }\n+\n+    #[test]\n+    fn test_compaction_jobs_by_size() {\n+        let CompactionJobs {\n+            merge_jobs,\n+            move_jobs,\n+            ..\n+        } = compact(\n+            [\n+                (0, 10),\n+                (10, 30),\n+                (9, 13),\n+                (0, 30),\n+                (40, 44),\n+                (41, 42),\n+                (41, 47),\n+                (90, 100),\n+                (30, 40),\n+            ],\n+            usize::MAX,\n+            300,\n         );\n         assert_eq!(merge_jobs, vec![vec![0, 1, 2], vec![4, 5, 6]]);\n         assert_eq!(move_jobs, vec![3, 8]);\n@@ -293,6 +341,7 @@ mod tests {\n                 let config = CompactConfig {\n                     max_merge: 4,\n                     min_merge: 2,\n+                    max_merge_size: usize::MAX,\n                 };\n                 let jobs = get_compaction_jobs(&containers, &config);\n                 if !jobs.is_empty() {\n@@ -337,6 +386,10 @@ mod tests {\n         fn range(&self) -> Range {\n             (self.keys[0], *self.keys.last().unwrap())\n         }\n+\n+        fn size(&self) -> usize {\n+            self.keys.len()\n+        }\n     }\n \n     impl Debug for Container {"
        },
        {
            "sha": "5f9f72d72f5147551600b16bd6c62622c7abc5e0",
            "filename": "turbopack/crates/turbo-persistence/src/db.rs",
            "status": "modified",
            "additions": 23,
            "deletions": 4,
            "changes": 27,
            "blob_url": "https://github.com/vercel/next.js/blob/51e2800b0fa9fde0536b8be39374499710888744/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fdb.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/51e2800b0fa9fde0536b8be39374499710888744/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fdb.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fdb.rs?ref=51e2800b0fa9fde0536b8be39374499710888744",
            "patch": "@@ -534,15 +534,20 @@ impl TurboPersistence {\n     /// Runs a full compaction on the database. This will rewrite all SST files, removing all\n     /// duplicate keys and separating all key ranges into unique files.\n     pub fn full_compact(&self) -> Result<()> {\n-        self.compact(0.0, usize::MAX)?;\n+        self.compact(0.0, usize::MAX, usize::MAX)?;\n         Ok(())\n     }\n \n     /// Runs a (partial) compaction. Compaction will only be performed if the coverage of the SST\n     /// files is above the given threshold. The coverage is the average number of SST files that\n     /// need to be read to find a key. It also limits the maximum number of SST files that are\n     /// merged at once, which is the main factor for the runtime of the compaction.\n-    pub fn compact(&self, max_coverage: f32, max_merge_sequence: usize) -> Result<()> {\n+    pub fn compact(\n+        &self,\n+        max_coverage: f32,\n+        max_merge_sequence: usize,\n+        max_merge_size: usize,\n+    ) -> Result<()> {\n         if self\n             .active_write_operation\n             .compare_exchange(false, true, Ordering::AcqRel, Ordering::Acquire)\n@@ -568,6 +573,7 @@ impl TurboPersistence {\n                 &mut indicies_to_delete,\n                 max_coverage,\n                 max_merge_sequence,\n+                max_merge_size,\n             )?;\n         }\n \n@@ -594,6 +600,7 @@ impl TurboPersistence {\n         indicies_to_delete: &mut Vec<usize>,\n         max_coverage: f32,\n         max_merge_sequence: usize,\n+        max_merge_size: usize,\n     ) -> Result<()> {\n         if static_sorted_files.is_empty() {\n             return Ok(());\n@@ -602,18 +609,29 @@ impl TurboPersistence {\n         struct SstWithRange {\n             index: usize,\n             range: StaticSortedFileRange,\n+            size: usize,\n         }\n \n         impl Compactable for SstWithRange {\n             fn range(&self) -> (u64, u64) {\n                 (self.range.min_hash, self.range.max_hash)\n             }\n+\n+            fn size(&self) -> usize {\n+                self.size\n+            }\n         }\n \n         let ssts_with_ranges = static_sorted_files\n             .iter()\n             .enumerate()\n-            .flat_map(|(index, sst)| sst.range().ok().map(|range| SstWithRange { index, range }))\n+            .flat_map(|(index, sst)| {\n+                sst.range().ok().map(|range| SstWithRange {\n+                    index,\n+                    range,\n+                    size: sst.size(),\n+                })\n+            })\n             .collect::<Vec<_>>();\n \n         let families = ssts_with_ranges\n@@ -651,8 +669,9 @@ impl TurboPersistence {\n                 } = get_compaction_jobs(\n                     &ssts_with_ranges,\n                     &CompactConfig {\n-                        max_merge: max_merge_sequence,\n                         min_merge: 2,\n+                        max_merge: max_merge_sequence,\n+                        max_merge_size,\n                     },\n                 );\n "
        },
        {
            "sha": "f74adf6e95ffd3c34d98d63f3fb02349abf53f9a",
            "filename": "turbopack/crates/turbo-persistence/src/tests.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/51e2800b0fa9fde0536b8be39374499710888744/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Ftests.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/51e2800b0fa9fde0536b8be39374499710888744/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Ftests.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Ftests.rs?ref=51e2800b0fa9fde0536b8be39374499710888744",
            "patch": "@@ -433,7 +433,7 @@ fn persist_changes() -> Result<()> {\n     {\n         let db = TurboPersistence::open(path.to_path_buf())?;\n \n-        db.compact(1.0, 3)?;\n+        db.compact(1.0, 3, usize::MAX)?;\n \n         check(&db, 1, 13)?;\n         check(&db, 2, 22)?;"
        },
        {
            "sha": "5a90e3e4bf6630d81ab7c5d97fb9700cd5a6174a",
            "filename": "turbopack/crates/turbo-tasks-backend/src/database/turbo.rs",
            "status": "modified",
            "additions": 16,
            "deletions": 5,
            "changes": 21,
            "blob_url": "https://github.com/vercel/next.js/blob/51e2800b0fa9fde0536b8be39374499710888744/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdatabase%2Fturbo.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/51e2800b0fa9fde0536b8be39374499710888744/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdatabase%2Fturbo.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdatabase%2Fturbo.rs?ref=51e2800b0fa9fde0536b8be39374499710888744",
            "patch": "@@ -14,7 +14,8 @@ use crate::database::{\n };\n \n const COMPACT_MAX_COVERAGE: f32 = 10.0;\n-const COMPACT_MAX_MERGE_SEQUENCE: usize = 8;\n+const COMPACT_MAX_MERGE_SEQUENCE: usize = 16;\n+const COMPACT_MAX_MERGE_SIZE: usize = 512 * 1024 * 1024; // 512 MiB\n \n pub struct TurboKeyValueDatabase {\n     db: Arc<TurboPersistence>,\n@@ -30,8 +31,13 @@ impl TurboKeyValueDatabase {\n         };\n         // start compaction in background if the database is not empty\n         if !db.is_empty() {\n-            let handle =\n-                spawn(move || db.compact(COMPACT_MAX_COVERAGE, COMPACT_MAX_MERGE_SEQUENCE));\n+            let handle = spawn(move || {\n+                db.compact(\n+                    COMPACT_MAX_COVERAGE,\n+                    COMPACT_MAX_MERGE_SEQUENCE,\n+                    COMPACT_MAX_MERGE_SIZE,\n+                )\n+            });\n             this.compact_join_handle.get_mut().replace(handle);\n         }\n         Ok(this)\n@@ -131,8 +137,13 @@ impl<'a> BaseWriteBatch<'a> for TurboWriteBatch<'a> {\n         if !self.initial_write {\n             // Start a new compaction in the background\n             let db = self.db.clone();\n-            let handle =\n-                spawn(move || db.compact(COMPACT_MAX_COVERAGE, COMPACT_MAX_MERGE_SEQUENCE));\n+            let handle = spawn(move || {\n+                db.compact(\n+                    COMPACT_MAX_COVERAGE,\n+                    COMPACT_MAX_MERGE_SEQUENCE,\n+                    COMPACT_MAX_MERGE_SIZE,\n+                )\n+            });\n             self.compact_join_handle.lock().replace(handle);\n         }\n "
        }
    ],
    "stats": {
        "total": 111,
        "additions": 97,
        "deletions": 14
    }
}