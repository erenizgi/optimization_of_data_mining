{
    "author": "lukesandberg",
    "message": "[turbopack] Remove the implementation of `TaskInput` from `AutoSet` (#84867)\n\nTaskInputs should have deterministic serialization and that isn't really possible with `AutoSet`\n\nThis was only used as part of the `CapturedIssues` api, so that is modified to wrap the autoset in a `cell` instead of an `Arc`.  Originally the `Arc` was used to make it possible to call `peek_issues` from top level `run_once` tasks.  So to fix that, I audited callsites and moved one call of `peek_issues` from `handle_issues` into the `IssueReporter`.\n\nAs part of the audit, I changed the API of `take_issues` to `drop_issues` since that is the only usecase for this function.",
    "sha": "299fe7409eacaeeffaa6aa280114495bea7c1643",
    "files": [
        {
            "sha": "6879e2c94fa37326476a5c5b0fcb234314386621",
            "filename": "crates/next-api/src/operation.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/299fe7409eacaeeffaa6aa280114495bea7c1643/crates%2Fnext-api%2Fsrc%2Foperation.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/299fe7409eacaeeffaa6aa280114495bea7c1643/crates%2Fnext-api%2Fsrc%2Foperation.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Foperation.rs?ref=299fe7409eacaeeffaa6aa280114495bea7c1643",
            "patch": "@@ -38,7 +38,7 @@ async fn entrypoints_without_collectibles_operation(\n ) -> Result<Vc<Entrypoints>> {\n     let _ = entrypoints.resolve_strongly_consistent().await?;\n     let _ = entrypoints.take_collectibles::<Box<dyn Diagnostic>>();\n-    let _ = entrypoints.take_issues();\n+    entrypoints.drop_issues();\n     let _ = get_effects(entrypoints).await?;\n     Ok(entrypoints.connect())\n }"
        },
        {
            "sha": "1147b1df2d2c36d56cd922dcb28ddb5a96dfa587",
            "filename": "crates/next-api/src/project.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/299fe7409eacaeeffaa6aa280114495bea7c1643/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/299fe7409eacaeeffaa6aa280114495bea7c1643/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fproject.rs?ref=299fe7409eacaeeffaa6aa280114495bea7c1643",
            "patch": "@@ -991,7 +991,7 @@ impl Project {\n                 // In development mode, we need to to take and drop the issues, otherwise every\n                 // route will report all issues.\n                 let vc = module_graphs_op.resolve_strongly_consistent().await?;\n-                let _ = module_graphs_op.take_issues();\n+                module_graphs_op.drop_issues();\n                 *vc\n             };\n "
        },
        {
            "sha": "f981e51bacb969044a2eb8d2106795ed1af47c1c",
            "filename": "turbopack/crates/turbo-tasks/src/task/task_input.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 13,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/299fe7409eacaeeffaa6aa280114495bea7c1643/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask%2Ftask_input.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/299fe7409eacaeeffaa6aa280114495bea7c1643/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask%2Ftask_input.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask%2Ftask_input.rs?ref=299fe7409eacaeeffaa6aa280114495bea7c1643",
            "patch": "@@ -19,6 +19,9 @@ use crate::{\n \n /// Trait to implement in order for a type to be accepted as a\n /// [`#[turbo_tasks::function]`][crate::function] argument.\n+///\n+/// Serialization must be deterministic and compatible with `eq` comparisons.  If two `TaskInputs`\n+/// compare equal they must also serialize to the same bytes.\n pub trait TaskInput: Send + Sync + Clone + Debug + PartialEq + Eq + Hash + TraceRawVcs {\n     fn resolve_input(&self) -> impl Future<Output = Result<Self>> + Send + '_ {\n         async { Ok(self.clone()) }\n@@ -332,19 +335,6 @@ where\n     }\n }\n \n-impl<T> TaskInput for auto_hash_map::AutoSet<T>\n-where\n-    T: TaskInput,\n-{\n-    fn is_resolved(&self) -> bool {\n-        self.iter().all(TaskInput::is_resolved)\n-    }\n-\n-    fn is_transient(&self) -> bool {\n-        self.iter().any(TaskInput::is_transient)\n-    }\n-}\n-\n macro_rules! tuple_impls {\n     ( $( $name:ident )+ ) => {\n         impl<$($name: TaskInput),+> TaskInput for ($($name,)+)"
        },
        {
            "sha": "52bcda13b2c27d1a2eeafad538bb55c339b60abe",
            "filename": "turbopack/crates/turbopack-cli-utils/src/issue.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 4,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/299fe7409eacaeeffaa6aa280114495bea7c1643/turbopack%2Fcrates%2Fturbopack-cli-utils%2Fsrc%2Fissue.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/299fe7409eacaeeffaa6aa280114495bea7c1643/turbopack%2Fcrates%2Fturbopack-cli-utils%2Fsrc%2Fissue.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-cli-utils%2Fsrc%2Fissue.rs?ref=299fe7409eacaeeffaa6aa280114495bea7c1643",
            "patch": "@@ -15,8 +15,8 @@ use turbo_rcstr::RcStr;\n use turbo_tasks::{RawVc, TransientInstance, TransientValue, Vc};\n use turbo_tasks_fs::{FileLinesContent, source_context::get_source_context};\n use turbopack_core::issue::{\n-    CapturedIssues, IssueReporter, IssueSeverity, PlainIssue, PlainIssueSource, PlainTraceItem,\n-    StyledString,\n+    CollectibleIssuesExt, IssueReporter, IssueSeverity, PlainIssue, PlainIssueSource,\n+    PlainTraceItem, StyledString,\n };\n \n use crate::source_context::format_source_context_lines;\n@@ -357,11 +357,10 @@ impl IssueReporter for ConsoleUi {\n     #[turbo_tasks::function]\n     async fn report_issues(\n         &self,\n-        issues: TransientInstance<CapturedIssues>,\n         source: TransientValue<RawVc>,\n         min_failing_severity: IssueSeverity,\n     ) -> Result<Vc<bool>> {\n-        let issues = &*issues;\n+        let issues = source.peek_issues();\n         let LogOptions {\n             ref current_dir,\n             ref project_dir,"
        },
        {
            "sha": "7cee8e7df075ecc83113f418460257aecee57f1c",
            "filename": "turbopack/crates/turbopack-core/src/issue/mod.rs",
            "status": "modified",
            "additions": 34,
            "deletions": 41,
            "changes": 75,
            "blob_url": "https://github.com/vercel/next.js/blob/299fe7409eacaeeffaa6aa280114495bea7c1643/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fissue%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/299fe7409eacaeeffaa6aa280114495bea7c1643/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fissue%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fissue%2Fmod.rs?ref=299fe7409eacaeeffaa6aa280114495bea7c1643",
            "patch": "@@ -6,18 +6,16 @@ pub mod resolve;\n use std::{\n     cmp::min,\n     fmt::{Display, Formatter},\n-    sync::Arc,\n };\n \n use anyhow::{Result, anyhow};\n-use async_trait::async_trait;\n use auto_hash_map::AutoSet;\n use serde::{Deserialize, Serialize};\n use turbo_rcstr::RcStr;\n use turbo_tasks::{\n     CollectiblesSource, IntoTraitRef, NonLocalValue, OperationVc, RawVc, ReadRef, ResolvedVc,\n-    TaskInput, TransientInstance, TransientValue, TryJoinIterExt, Upcast, ValueDefault,\n-    ValueToString, Vc, emit, trace::TraceRawVcs,\n+    TaskInput, TransientValue, TryJoinIterExt, Upcast, ValueDefault, ValueToString, Vc, emit,\n+    trace::TraceRawVcs,\n };\n use turbo_tasks_fs::{FileContent, FileLine, FileLinesContent, FileSystem, FileSystemPath};\n use turbo_tasks_hash::{DeterministicHash, Xxh3Hash64Hasher};\n@@ -164,9 +162,8 @@ pub trait ImportTracer {\n     fn get_traces(self: Vc<Self>, path: FileSystemPath) -> Vc<ImportTraces>;\n }\n \n-#[derive(\n-    Debug, Clone, TaskInput, TraceRawVcs, Hash, Eq, PartialEq, Serialize, Deserialize, NonLocalValue,\n-)]\n+#[turbo_tasks::value]\n+#[derive(Debug)]\n pub struct DelegatingImportTracer {\n     delegates: AutoSet<ResolvedVc<Box<dyn ImportTracer>>>,\n }\n@@ -220,7 +217,7 @@ pub struct Issues(Vec<ResolvedVc<Box<dyn Issue>>>);\n #[derive(Debug)]\n pub struct CapturedIssues {\n     issues: AutoSet<ResolvedVc<Box<dyn Issue>>>,\n-    tracer: Arc<DelegatingImportTracer>,\n+    tracer: ResolvedVc<DelegatingImportTracer>,\n }\n \n #[turbo_tasks::value_impl]\n@@ -250,14 +247,12 @@ impl CapturedIssues {\n \n     // Returns all the issues as formatted `PlainIssues`.\n     pub async fn get_plain_issues(&self) -> Result<Vec<ReadRef<PlainIssue>>> {\n-        let mut list =\n-            self.issues\n-                .iter()\n-                .map(|issue| async move {\n-                    PlainIssue::from_issue(**issue, Some(self.tracer.clone())).await\n-                })\n-                .try_join()\n-                .await?;\n+        let mut list = self\n+            .issues\n+            .iter()\n+            .map(|issue| async move { PlainIssue::from_issue(**issue, Some(*self.tracer)).await })\n+            .try_join()\n+            .await?;\n         list.sort();\n         Ok(list)\n     }\n@@ -716,7 +711,7 @@ impl PlainIssue {\n     #[turbo_tasks::function]\n     pub async fn from_issue(\n         issue: ResolvedVc<Box<dyn Issue>>,\n-        import_tracer: Option<Arc<DelegatingImportTracer>>,\n+        import_tracer: Option<ResolvedVc<DelegatingImportTracer>>,\n     ) -> Result<Vc<Self>> {\n         let description: Option<StyledString> = match *issue.description().await? {\n             Some(description) => Some(description.owned().await?),\n@@ -747,8 +742,13 @@ impl PlainIssue {\n             },\n             import_traces: match import_tracer {\n                 Some(tracer) => {\n-                    into_plain_trace(tracer.get_traces(issue.file_path().owned().await?).await?)\n-                        .await?\n+                    into_plain_trace(\n+                        tracer\n+                            .await?\n+                            .get_traces(issue.file_path().owned().await?)\n+                            .await?,\n+                    )\n+                    .await?\n                 }\n                 None => vec![],\n             },\n@@ -796,16 +796,14 @@ pub trait IssueReporter {\n     ///\n     /// # Arguments:\n     ///\n-    /// * `issues` - A [ReadRef] of [CapturedIssues]. Typically obtained with\n-    ///   `source.peek_issues()`.\n     /// * `source` - The root [Vc] from which issues are traced. Can be used by implementers to\n-    ///   determine which issues are new.\n+    ///   determine which issues are new.  This must be derived from the OperationVc so issues can\n+    ///   be collected.\n     /// * `min_failing_severity` - The minimum Vc<[IssueSeverity]>\n     ///  The minimum issue severity level considered to fatally end the program.\n     #[turbo_tasks::function]\n     fn report_issues(\n         self: Vc<Self>,\n-        issues: TransientInstance<CapturedIssues>,\n         source: TransientValue<RawVc>,\n         min_failing_severity: IssueSeverity,\n     ) -> Vc<bool>;\n@@ -815,18 +813,17 @@ pub trait CollectibleIssuesExt\n where\n     Self: Sized,\n {\n-    /// Returns all issues from `source` in a list with their associated\n-    /// processing path.\n+    /// Returns all issues from `source`\n+    ///\n+    /// Must be called in a turbo-task as this constructs a `cell`\n     fn peek_issues(self) -> CapturedIssues;\n \n-    /// Returns all issues from `source` in a list with their associated\n-    /// processing path.\n+    /// Drops all issues from `source`\n     ///\n     /// This unemits the issues. They will not propagate up.\n-    fn take_issues(self) -> CapturedIssues;\n+    fn drop_issues(self);\n }\n \n-#[async_trait]\n impl<T> CollectibleIssuesExt for T\n where\n     T: CollectiblesSource + Copy + Send,\n@@ -835,23 +832,21 @@ where\n         CapturedIssues {\n             issues: self.peek_collectibles(),\n \n-            tracer: Arc::new(DelegatingImportTracer {\n+            tracer: DelegatingImportTracer {\n                 delegates: self.peek_collectibles(),\n-            }),\n+            }\n+            .resolved_cell(),\n         }\n     }\n \n-    fn take_issues(self) -> CapturedIssues {\n-        CapturedIssues {\n-            issues: self.take_collectibles(),\n-\n-            tracer: Arc::new(DelegatingImportTracer {\n-                delegates: self.take_collectibles(),\n-            }),\n-        }\n+    fn drop_issues(self) {\n+        let _ = self.take_collectibles::<Box<dyn Issue>>();\n     }\n }\n \n+/// A helper function to print out issues to the console.\n+///\n+/// Must be called in a turbo-task as this constructs a `cell`\n pub async fn handle_issues<T: Send>(\n     source_op: OperationVc<T>,\n     issue_reporter: Vc<Box<dyn IssueReporter>>,\n@@ -861,10 +856,8 @@ pub async fn handle_issues<T: Send>(\n ) -> Result<()> {\n     let source_vc = source_op.connect();\n     let _ = source_op.resolve_strongly_consistent().await?;\n-    let issues = source_op.peek_issues();\n \n     let has_fatal = issue_reporter.report_issues(\n-        TransientInstance::new(issues),\n         TransientValue::new(Vc::into_raw(source_vc)),\n         min_failing_severity,\n     );"
        }
    ],
    "stats": {
        "total": 102,
        "additions": 42,
        "deletions": 60
    }
}