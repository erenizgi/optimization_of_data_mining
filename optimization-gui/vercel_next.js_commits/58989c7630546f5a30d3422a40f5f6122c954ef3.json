{
    "author": "acdlite",
    "message": "Await initial Flight response before hydrating (#85124)\n\nWhen hydrating on the client, we can await the promise for the initial\nFlight response before we call hydrateRoot. Previously we would unwrap\nthis promise inside a component with `use`, which caused it to be\ntreated as a suspense \"dependency\" in the Suspense DevTools panel. This\nis unnecessary noise because the latency of the initial Flight data is\nalready encoded into the Flight data itself, as opposed to the promise\nthat resolves to the Flight data.\n\nThis removes an unnecessary piece of debug information from the Suspense\nDevTools panel.",
    "sha": "58989c7630546f5a30d3422a40f5f6122c954ef3",
    "files": [
        {
            "sha": "0282ffd099b466c7e3186bad0347d2652b97bf4e",
            "filename": "packages/next/src/client/app-index.tsx",
            "status": "modified",
            "additions": 24,
            "deletions": 40,
            "changes": 64,
            "blob_url": "https://github.com/vercel/next.js/blob/58989c7630546f5a30d3422a40f5f6122c954ef3/packages%2Fnext%2Fsrc%2Fclient%2Fapp-index.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/58989c7630546f5a30d3422a40f5f6122c954ef3/packages%2Fnext%2Fsrc%2Fclient%2Fapp-index.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fapp-index.tsx?ref=58989c7630546f5a30d3422a40f5f6122c954ef3",
            "patch": "@@ -1,6 +1,6 @@\n import './app-globals'\n import ReactDOMClient from 'react-dom/client'\n-import React, { use } from 'react'\n+import React from 'react'\n // TODO: Explicitly import from client.browser\n // eslint-disable-next-line import/no-extraneous-dependencies\n import { createFromReadableStream as createFromReadableStreamBrowser } from 'react-server-dom-webpack/client'\n@@ -179,17 +179,16 @@ const initialServerResponse = createFromReadableStream<InitialRSCPayload>(\n )\n \n function ServerRoot({\n-  pendingActionQueue,\n+  initialRSCPayload,\n+  actionQueue,\n   webSocket,\n   staticIndicatorState,\n }: {\n-  pendingActionQueue: Promise<AppRouterActionQueue>\n+  initialRSCPayload: InitialRSCPayload\n+  actionQueue: AppRouterActionQueue\n   webSocket: WebSocket | undefined\n   staticIndicatorState: StaticIndicatorState | undefined\n }): React.ReactNode {\n-  const initialRSCPayload = use(initialServerResponse)\n-  const actionQueue = use<AppRouterActionQueue>(pendingActionQueue)\n-\n   const router = (\n     <AppRouter\n       actionQueue={actionQueue}\n@@ -249,7 +248,7 @@ export type ClientInstrumentationHooks = {\n   ) => void\n }\n \n-export function hydrate(\n+export async function hydrate(\n   instrumentationHooks: ClientInstrumentationHooks | null,\n   assetPrefix: string\n ) {\n@@ -263,46 +262,31 @@ export function hydrate(\n     staticIndicatorState = { pathname: null, appIsrManifest: null }\n     webSocket = createWebSocket(assetPrefix, staticIndicatorState)\n   }\n-\n-  // React overrides `.then` and doesn't return a new promise chain,\n-  // so we wrap the action queue in a promise to ensure that its value\n-  // is defined when the promise resolves.\n-  // https://github.com/facebook/react/blob/163365a07872337e04826c4f501565d43dbd2fd4/packages/react-client/src/ReactFlightClient.js#L189-L190\n-  const pendingActionQueue: Promise<AppRouterActionQueue> = new Promise(\n-    (resolve, reject) => {\n-      initialServerResponse.then(\n-        (initialRSCPayload) => {\n-          // setAppBuildId should be called only once, during JS initialization\n-          // and before any components have hydrated.\n-          setAppBuildId(initialRSCPayload.b)\n-\n-          const initialTimestamp = Date.now()\n-\n-          resolve(\n-            createMutableActionQueue(\n-              createInitialRouterState({\n-                navigatedAt: initialTimestamp,\n-                initialFlightData: initialRSCPayload.f,\n-                initialCanonicalUrlParts: initialRSCPayload.c,\n-                initialRenderedSearch: initialRSCPayload.q,\n-                initialParallelRoutes: new Map(),\n-                location: window.location,\n-              }),\n-              instrumentationHooks\n-            )\n-          )\n-        },\n-        (err: Error) => reject(err)\n-      )\n-    }\n+  const initialRSCPayload = await initialServerResponse\n+  // setAppBuildId should be called only once, during JS initialization\n+  // and before any components have hydrated.\n+  setAppBuildId(initialRSCPayload.b)\n+\n+  const initialTimestamp = Date.now()\n+  const actionQueue: AppRouterActionQueue = createMutableActionQueue(\n+    createInitialRouterState({\n+      navigatedAt: initialTimestamp,\n+      initialFlightData: initialRSCPayload.f,\n+      initialCanonicalUrlParts: initialRSCPayload.c,\n+      initialRenderedSearch: initialRSCPayload.q,\n+      initialParallelRoutes: new Map(),\n+      location: window.location,\n+    }),\n+    instrumentationHooks\n   )\n \n   const reactEl = (\n     <StrictModeIfEnabled>\n       <HeadManagerContext.Provider value={{ appDir: true }}>\n         <Root>\n           <ServerRoot\n-            pendingActionQueue={pendingActionQueue}\n+            initialRSCPayload={initialRSCPayload}\n+            actionQueue={actionQueue}\n             webSocket={webSocket}\n             staticIndicatorState={staticIndicatorState}\n           />"
        }
    ],
    "stats": {
        "total": 64,
        "additions": 24,
        "deletions": 40
    }
}