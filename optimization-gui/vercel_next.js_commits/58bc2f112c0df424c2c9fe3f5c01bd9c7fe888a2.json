{
    "author": "ijjk",
    "message": "Migrate usage of web-server in edge-ssr (#80915)\n\nThis continues the work for the `handlers` interface for the edge\nruntime and re-uses the existing `route-module` interface we have\ninstead of initializing and using `web-server`/`base-server`.\n\nValidated against our deploy tests\nhttps://github.com/vercel/vercel/actions/runs/15987684940/job/45095833866?pr=13505\nhttps://github.com/vercel/next.js/actions/runs/15987664161/job/45095390463",
    "sha": "58bc2f112c0df424c2c9fe3f5c01bd9c7fe888a2",
    "files": [
        {
            "sha": "c84a102ba4f014a56a7789416e4c56a4cbb1670c",
            "filename": "crates/next-core/src/next_pages/page_entry.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 15,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/58bc2f112c0df424c2c9fe3f5c01bd9c7fe888a2/crates%2Fnext-core%2Fsrc%2Fnext_pages%2Fpage_entry.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/58bc2f112c0df424c2c9fe3f5c01bd9c7fe888a2/crates%2Fnext-core%2Fsrc%2Fnext_pages%2Fpage_entry.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_pages%2Fpage_entry.rs?ref=58bc2f112c0df424c2c9fe3f5c01bd9c7fe888a2",
            "patch": "@@ -14,7 +14,6 @@ use turbopack_core::{\n     source::Source,\n     virtual_source::VirtualSource,\n };\n-use turbopack_ecmascript::utils::StringifyJs;\n \n use crate::{\n     next_config::NextConfig,\n@@ -213,17 +212,6 @@ async fn wrap_edge_page(\n \n     let next_config_val = &*next_config.await?;\n \n-    // TODO(WEB-1824): add build support\n-    let dev = true;\n-\n-    let sri_enabled = !dev\n-        && next_config\n-            .experimental_sri()\n-            .await?\n-            .as_ref()\n-            .map(|sri| sri.algorithm.as_ref())\n-            .is_some();\n-\n     let source = load_next_js_template(\n         \"edge-ssr.js\",\n         project_root.clone(),\n@@ -235,12 +223,9 @@ async fn wrap_edge_page(\n             \"VAR_MODULE_GLOBAL_ERROR\" => INNER_ERROR.into(),\n         },\n         fxindexmap! {\n-            \"pagesType\" => StringifyJs(\"pages\").to_string().into(),\n-            \"sriEnabled\" => serde_json::Value::Bool(sri_enabled).to_string().into(),\n             // TODO do we really need to pass the entire next config here?\n             // This is bad for invalidation as any config change will invalidate this\n             \"nextConfig\" => serde_json::to_string(next_config_val)?.into(),\n-            \"dev\" => serde_json::Value::Bool(dev).to_string().into(),\n             \"pageRouteModuleOptions\" => serde_json::to_string(&get_route_module_options(page.clone(), pathname.clone()))?.into(),\n             \"errorRouteModuleOptions\" => serde_json::to_string(&get_route_module_options(rcstr!(\"/_error\"), rcstr!(\"/_error\")))?.into(),\n             \"user500RouteModuleOptions\" => serde_json::to_string(&get_route_module_options(rcstr!(\"/500\"), rcstr!(\"/500\")))?.into(),"
        },
        {
            "sha": "d311966731ad2ae74a4252b40b572f6eee5eaef6",
            "filename": "packages/next/errors.json",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/58bc2f112c0df424c2c9fe3f5c01bd9c7fe888a2/packages%2Fnext%2Ferrors.json",
            "raw_url": "https://github.com/vercel/next.js/raw/58bc2f112c0df424c2c9fe3f5c01bd9c7fe888a2/packages%2Fnext%2Ferrors.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Ferrors.json?ref=58bc2f112c0df424c2c9fe3f5c01bd9c7fe888a2",
            "patch": "@@ -715,5 +715,6 @@\n   \"714\": \"cannot run loadNative when `NEXT_TEST_WASM` is set\",\n   \"715\": \"Server Action \\\"%s\\\" was not found on the server. \\\\nRead more: https://nextjs.org/docs/messages/failed-to-find-server-action\",\n   \"716\": \"NEXT_DEVTOOLS_SIMULATED_ERROR\",\n-  \"717\": \"Unsupported environment condition \\\"%s\\\" and react condition \\\"%s\\\". This is a bug in Next.js.\"\n+  \"717\": \"Unsupported environment condition \\\"%s\\\" and react condition \\\"%s\\\". This is a bug in Next.js.\",\n+  \"718\": \"Invariant: projectDir is required for node runtime\"\n }"
        },
        {
            "sha": "e010f52534721985d9db013a53c4b1ad993dbf27",
            "filename": "packages/next/src/build/define-env.ts",
            "status": "modified",
            "additions": 19,
            "deletions": 1,
            "changes": 20,
            "blob_url": "https://github.com/vercel/next.js/blob/58bc2f112c0df424c2c9fe3f5c01bd9c7fe888a2/packages%2Fnext%2Fsrc%2Fbuild%2Fdefine-env.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/58bc2f112c0df424c2c9fe3f5c01bd9c7fe888a2/packages%2Fnext%2Fsrc%2Fbuild%2Fdefine-env.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fdefine-env.ts?ref=58bc2f112c0df424c2c9fe3f5c01bd9c7fe888a2",
            "patch": "@@ -1,5 +1,10 @@\n-import type { I18NDomains, NextConfigComplete } from '../server/config-shared'\n+import type {\n+  I18NConfig,\n+  I18NDomains,\n+  NextConfigComplete,\n+} from '../server/config-shared'\n import type { MiddlewareMatcher } from './analysis/get-page-static-info'\n+import type { Rewrite } from '../lib/load-custom-routes'\n import path from 'node:path'\n import { needsExperimentalReact } from '../lib/needs-experimental-react'\n import { checkIsAppPPREnabled } from '../server/lib/experimental/ppr'\n@@ -29,6 +34,11 @@ export interface DefineEnvOptions {\n   isNodeServer: boolean\n   middlewareMatchers: MiddlewareMatcher[] | undefined\n   omitNonDeterministic?: boolean\n+  rewrites: {\n+    beforeFiles: Rewrite[]\n+    afterFiles: Rewrite[]\n+    fallback: Rewrite[]\n+  }\n }\n \n interface DefineEnv {\n@@ -40,6 +50,7 @@ interface DefineEnv {\n     | BloomFilter\n     | Partial<NextConfigComplete['images']>\n     | I18NDomains\n+    | I18NConfig\n }\n \n interface SerializedDefineEnv {\n@@ -99,6 +110,7 @@ export function getDefineEnv({\n   isNodeServer,\n   middlewareMatchers,\n   omitNonDeterministic,\n+  rewrites,\n }: DefineEnvOptions): SerializedDefineEnv {\n   const nextPublicEnv = getNextPublicEnvironmentVariables()\n   const nextConfigEnv = getNextConfigEnv(config)\n@@ -220,6 +232,11 @@ export function getDefineEnv({\n             : projectPath,\n         }\n       : {}),\n+    'process.env.__NEXT_BASE_PATH': config.basePath,\n+    'process.env.__NEXT_CASE_SENSITIVE_ROUTES': Boolean(\n+      config.experimental.caseSensitiveRoutes\n+    ),\n+    'process.env.__NEXT_REWRITES': rewrites as any,\n     'process.env.__NEXT_TRAILING_SLASH': config.trailingSlash,\n     'process.env.__NEXT_DEV_INDICATOR': config.devIndicators !== false,\n     'process.env.__NEXT_DEV_INDICATOR_POSITION':\n@@ -245,6 +262,7 @@ export function getDefineEnv({\n     'process.env.__NEXT_CONFIG_OUTPUT': config.output,\n     'process.env.__NEXT_I18N_SUPPORT': !!config.i18n,\n     'process.env.__NEXT_I18N_DOMAINS': config.i18n?.domains ?? false,\n+    'process.env.__NEXT_I18N_CONFIG': config.i18n || '',\n     'process.env.__NEXT_NO_MIDDLEWARE_URL_NORMALIZE':\n       config.skipMiddlewareUrlNormalize,\n     'process.env.__NEXT_EXTERNAL_MIDDLEWARE_REWRITE_RESOLVE':"
        },
        {
            "sha": "540d667978637b1177cda9b822c04a7acb501e9e",
            "filename": "packages/next/src/build/swc/index.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/58bc2f112c0df424c2c9fe3f5c01bd9c7fe888a2/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Findex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/58bc2f112c0df424c2c9fe3f5c01bd9c7fe888a2/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Findex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Findex.ts?ref=58bc2f112c0df424c2c9fe3f5c01bd9c7fe888a2",
            "patch": "@@ -411,6 +411,7 @@ export function createDefineEnv({\n   fetchCacheKeyPrefix,\n   hasRewrites,\n   middlewareMatchers,\n+  rewrites,\n }: Omit<\n   DefineEnvOptions,\n   'isClient' | 'isNodeOrEdgeCompilation' | 'isEdgeServer' | 'isNodeServer'\n@@ -436,6 +437,7 @@ export function createDefineEnv({\n         isEdgeServer: variant === 'edge',\n         isNodeServer: variant === 'nodejs',\n         middlewareMatchers,\n+        rewrites,\n       })\n     )\n   }"
        },
        {
            "sha": "b9017cc4293b4cb4fce423d558e19e0fbfbed019",
            "filename": "packages/next/src/build/templates/edge-ssr.ts",
            "status": "modified",
            "additions": 291,
            "deletions": 43,
            "changes": 334,
            "blob_url": "https://github.com/vercel/next.js/blob/58bc2f112c0df424c2c9fe3f5c01bd9c7fe888a2/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fedge-ssr.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/58bc2f112c0df424c2c9fe3f5c01bd9c7fe888a2/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fedge-ssr.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fedge-ssr.ts?ref=58bc2f112c0df424c2c9fe3f5c01bd9c7fe888a2",
            "patch": "@@ -1,6 +1,5 @@\n import '../../server/web/globals'\n-import { adapter } from '../../server/web/adapter'\n-import { getRender } from '../webpack/loaders/next-edge-ssr-loader/render'\n+import { adapter, type NextRequestHint } from '../../server/web/adapter'\n import { IncrementalCache } from '../../server/lib/incremental-cache'\n import { initializeCacheHandlers } from '../../server/use-cache/handlers'\n \n@@ -17,25 +16,24 @@ declare const incrementalCacheHandler: any\n // TODO: re-enable this once we've refactored to use implicit matches\n // const renderToHTML = undefined\n \n-import { renderToHTML } from '../../server/render'\n-import RouteModule from '../../server/route-modules/pages/module'\n+import RouteModule, {\n+  type PagesRouteHandlerContext,\n+} from '../../server/route-modules/pages/module'\n+import { WebNextRequest, WebNextResponse } from '../../server/base-http/web'\n \n import type { RequestData } from '../../server/web/types'\n-import type { BuildManifest } from '../../server/get-page-files'\n import type { NextConfigComplete } from '../../server/config-shared'\n-import type { PAGE_TYPES } from '../../lib/page-types'\n+import type { NextFetchEvent } from '../../server/web/spec-extension/fetch-event'\n+import type RenderResult from '../../server/render-result'\n+import type { RenderResultMetadata } from '../../server/render-result'\n+import { getTracer, SpanKind, type Span } from '../../server/lib/trace/tracer'\n+import { BaseServerSpan } from '../../server/lib/trace/constants'\n \n // injected by the loader afterwards.\n-declare const pagesType: PAGE_TYPES\n-declare const sriEnabled: boolean\n-declare const dev: boolean\n declare const nextConfig: NextConfigComplete\n declare const pageRouteModuleOptions: any\n declare const errorRouteModuleOptions: any\n declare const user500RouteModuleOptions: any\n-// INJECT:pagesType\n-// INJECT:sriEnabled\n-// INJECT:dev\n // INJECT:nextConfig\n // INJECT:pageRouteModuleOptions\n // INJECT:errorRouteModuleOptions\n@@ -44,6 +42,9 @@ declare const user500RouteModuleOptions: any\n // Initialize the cache handlers interface.\n initializeCacheHandlers()\n \n+// expose this for the route-module\n+;(globalThis as any).nextConfig = nextConfig\n+\n const pageMod = {\n   ...userlandPage,\n   routeModule: new RouteModule({\n@@ -83,42 +84,289 @@ const error500Mod = userland500Page\n     }\n   : null\n \n-const maybeJSONParse = (str?: string) => (str ? JSON.parse(str) : undefined)\n-\n-const buildManifest: BuildManifest = self.__BUILD_MANIFEST as any\n-const reactLoadableManifest = maybeJSONParse(self.__REACT_LOADABLE_MANIFEST)\n-const dynamicCssManifest = maybeJSONParse(self.__DYNAMIC_CSS_MANIFEST)\n-const subresourceIntegrityManifest = sriEnabled\n-  ? maybeJSONParse(self.__SUBRESOURCE_INTEGRITY_MANIFEST)\n-  : undefined\n-const nextFontManifest = maybeJSONParse(self.__NEXT_FONT_MANIFEST)\n-\n-const render = getRender({\n-  pagesType,\n-  dev,\n-  page: 'VAR_PAGE',\n-  appMod,\n-  pageMod,\n-  errorMod,\n-  error500Mod,\n-  Document,\n-  buildManifest,\n-  renderToHTML,\n-  reactLoadableManifest,\n-  dynamicCssManifest,\n-  subresourceIntegrityManifest,\n-  config: nextConfig,\n-  buildId: process.env.__NEXT_BUILD_ID!,\n-  nextFontManifest,\n-  incrementalCacheHandler,\n-})\n-\n export const ComponentMod = pageMod\n \n+async function requestHandler(\n+  req: NextRequestHint,\n+  _event: NextFetchEvent\n+): Promise<Response> {\n+  let srcPage = 'VAR_PAGE'\n+\n+  const relativeUrl = `${req.nextUrl.pathname}${req.nextUrl.search}`\n+  const baseReq = new WebNextRequest(req)\n+  const pageRouteModule = pageMod.routeModule as RouteModule\n+  const prepareResult = await pageRouteModule.prepare(baseReq, null, {\n+    srcPage,\n+    multiZoneDraftMode: false,\n+  })\n+\n+  if (!prepareResult) {\n+    return new Response('Bad Request', {\n+      status: 400,\n+    })\n+  }\n+  const {\n+    query,\n+    params,\n+    buildId,\n+    isNextDataRequest,\n+    buildManifest,\n+    prerenderManifest,\n+    reactLoadableManifest,\n+    clientReferenceManifest,\n+    subresourceIntegrityManifest,\n+    dynamicCssManifest,\n+  } = prepareResult\n+\n+  const renderContext: PagesRouteHandlerContext = {\n+    page: srcPage,\n+    query,\n+    params,\n+\n+    sharedContext: {\n+      buildId,\n+      deploymentId: process.env.NEXT_DEPLOYMENT_ID,\n+      customServer: undefined,\n+    },\n+\n+    renderContext: {\n+      isFallback: false,\n+      isDraftMode: false,\n+      developmentNotFoundSourcePage: undefined,\n+    },\n+\n+    renderOpts: {\n+      params,\n+      page: srcPage,\n+      supportsDynamicResponse: true,\n+      Component: pageMod.Component,\n+      ComponentMod: pageMod,\n+      pageConfig: pageMod.pageConfig,\n+      routeModule: pageMod.routeModule,\n+      strictNextHead: nextConfig.experimental.strictNextHead ?? true,\n+      canonicalBase: nextConfig.amp.canonicalBase || '',\n+      previewProps: prerenderManifest.preview,\n+      ampOptimizerConfig: nextConfig.experimental.amp?.optimizer,\n+      basePath: nextConfig.basePath,\n+      assetPrefix: nextConfig.assetPrefix,\n+      images: nextConfig.images,\n+      optimizeCss: nextConfig.experimental.optimizeCss,\n+      nextConfigOutput: nextConfig.output,\n+      nextScriptWorkers: nextConfig.experimental.nextScriptWorkers,\n+      disableOptimizedLoading: nextConfig.experimental.disableOptimizedLoading,\n+      domainLocales: nextConfig.i18n?.domains,\n+      distDir: '',\n+      crossOrigin: nextConfig.crossOrigin ? nextConfig.crossOrigin : undefined,\n+      largePageDataBytes: nextConfig.experimental.largePageDataBytes,\n+      // Only the `publicRuntimeConfig` key is exposed to the client side\n+      // It'll be rendered as part of __NEXT_DATA__ on the client side\n+      runtimeConfig:\n+        Object.keys(nextConfig.publicRuntimeConfig).length > 0\n+          ? nextConfig.publicRuntimeConfig\n+          : undefined,\n+\n+      isExperimentalCompile: nextConfig.experimental.isExperimentalCompile,\n+      // `htmlLimitedBots` is passed to server as serialized config in string format\n+      experimental: {\n+        clientTraceMetadata: nextConfig.experimental.clientTraceMetadata,\n+      },\n+\n+      buildManifest,\n+      subresourceIntegrityManifest,\n+      reactLoadableManifest,\n+      clientReferenceManifest,\n+      dynamicCssManifest,\n+    },\n+  }\n+  let finalStatus = 200\n+\n+  const renderResultToResponse = (\n+    result: RenderResult<RenderResultMetadata>\n+  ): Response => {\n+    // Handle null responses\n+    if (result.isNull) {\n+      finalStatus = 500\n+      return new Response(null, { status: 500 })\n+    }\n+\n+    // Extract metadata\n+    const { metadata } = result\n+    finalStatus = metadata.statusCode || 200\n+    const headers = new Headers()\n+\n+    // Set content type\n+    const contentType = result.contentType || 'text/html; charset=utf-8'\n+    headers.set('Content-Type', contentType)\n+\n+    // Add metadata headers\n+    if (metadata.headers) {\n+      for (const [key, value] of Object.entries(metadata.headers)) {\n+        if (value !== undefined) {\n+          if (Array.isArray(value)) {\n+            // Handle multiple header values\n+            for (const v of value) {\n+              headers.append(key, String(v))\n+            }\n+          } else {\n+            headers.set(key, String(value))\n+          }\n+        }\n+      }\n+    }\n+\n+    // Handle static response\n+    if (!result.isDynamic) {\n+      const body = result.toUnchunkedString()\n+      headers.set(\n+        'Content-Length',\n+        String(new TextEncoder().encode(body).length)\n+      )\n+      return new Response(body, {\n+        status: finalStatus,\n+        headers,\n+      })\n+    }\n+\n+    // Handle dynamic/streaming response\n+    // For edge runtime, we need to create a readable stream that pipes from the result\n+    const { readable, writable } = new TransformStream()\n+\n+    // Start piping the result to the writable stream\n+    // This is done asynchronously to avoid blocking the response creation\n+    result.pipeTo(writable).catch((err) => {\n+      console.error('Error piping RenderResult to response:', err)\n+    })\n+\n+    return new Response(readable, {\n+      status: finalStatus,\n+      headers,\n+    })\n+  }\n+\n+  const invokeRender = async (span?: Span): Promise<Response> => {\n+    try {\n+      const result = await pageRouteModule\n+        .render(\n+          // @ts-expect-error we don't type this for edge\n+          baseReq,\n+          new WebNextResponse(undefined),\n+          {\n+            ...renderContext,\n+            renderOpts: {\n+              ...renderContext.renderOpts,\n+              getServerSideProps: pageMod.getServerSideProps,\n+              Component: pageMod.default || pageMod,\n+              ComponentMod: pageMod,\n+              pageConfig: pageMod.config,\n+              isNextDataRequest,\n+            },\n+          }\n+        )\n+        .finally(() => {\n+          if (!span) return\n+\n+          span.setAttributes({\n+            'http.status_code': finalStatus,\n+            'next.rsc': false,\n+          })\n+\n+          const rootSpanAttributes = tracer.getRootSpanAttributes()\n+          // We were unable to get attributes, probably OTEL is not enabled\n+          if (!rootSpanAttributes) {\n+            return\n+          }\n+\n+          if (\n+            rootSpanAttributes.get('next.span_type') !==\n+            BaseServerSpan.handleRequest\n+          ) {\n+            console.warn(\n+              `Unexpected root span type '${rootSpanAttributes.get(\n+                'next.span_type'\n+              )}'. Please report this Next.js issue https://github.com/vercel/next.js`\n+            )\n+            return\n+          }\n+\n+          const route = rootSpanAttributes.get('next.route')\n+          if (route) {\n+            const name = `${req.method} ${route}`\n+\n+            span.setAttributes({\n+              'next.route': route,\n+              'http.route': route,\n+              'next.span_name': name,\n+            })\n+            span.updateName(name)\n+          } else {\n+            span.updateName(`${req.method} ${relativeUrl}`)\n+          }\n+        })\n+\n+      return renderResultToResponse(result)\n+    } catch (err) {\n+      const errModule = error500Mod || errorMod\n+      const errRouteModule = errModule.routeModule as RouteModule\n+\n+      if (errRouteModule.isDev) {\n+        throw err\n+      }\n+\n+      await errRouteModule.onRequestError(baseReq, err, {\n+        routerKind: 'Pages Router',\n+        routePath: srcPage,\n+        routeType: 'render',\n+        revalidateReason: undefined,\n+      })\n+\n+      const errResult = await errRouteModule.render(\n+        // @ts-expect-error we don't type this for edge\n+        baseReq,\n+        new WebNextResponse(undefined),\n+        {\n+          ...renderContext,\n+          page: error500Mod ? '/500' : '/_error',\n+          renderOpts: {\n+            ...renderContext.renderOpts,\n+            getServerSideProps: errModule.getServerSideProps,\n+            Component: errModule.default || errModule,\n+            ComponentMod: errModule,\n+            pageConfig: errModule.config,\n+          },\n+        }\n+      )\n+\n+      return renderResultToResponse(errResult)\n+    }\n+  }\n+\n+  const tracer = getTracer()\n+\n+  // TODO: activeSpan code path is for when wrapped by\n+  // next-server can be removed when this is no longer used\n+  return tracer.withPropagatedContext(req.headers, () =>\n+    tracer.trace(\n+      BaseServerSpan.handleRequest,\n+      {\n+        spanName: `${req.method} ${relativeUrl}`,\n+        kind: SpanKind.SERVER,\n+        attributes: {\n+          'http.method': req.method,\n+          'http.target': relativeUrl,\n+          'http.route': srcPage,\n+        },\n+      },\n+      invokeRender\n+    )\n+  )\n+}\n+\n export default function nHandler(opts: { page: string; request: RequestData }) {\n   return adapter({\n     ...opts,\n     IncrementalCache,\n-    handler: render,\n+    handler: requestHandler,\n+    incrementalCacheHandler,\n+    bypassNextUrl: true,\n   })\n }"
        },
        {
            "sha": "a9e9673d22b207719bb511cc4aa8331309d230f1",
            "filename": "packages/next/src/build/turbopack-build/impl.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/58bc2f112c0df424c2c9fe3f5c01bd9c7fe888a2/packages%2Fnext%2Fsrc%2Fbuild%2Fturbopack-build%2Fimpl.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/58bc2f112c0df424c2c9fe3f5c01bd9c7fe888a2/packages%2Fnext%2Fsrc%2Fbuild%2Fturbopack-build%2Fimpl.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fturbopack-build%2Fimpl.ts?ref=58bc2f112c0df424c2c9fe3f5c01bd9c7fe888a2",
            "patch": "@@ -75,6 +75,7 @@ export async function turbopackBuild(): Promise<{\n         hasRewrites,\n         // Implemented separately in Turbopack, doesn't have to be passed here.\n         middlewareMatchers: undefined,\n+        rewrites,\n       }),\n       buildId,\n       encryptionKey,"
        },
        {
            "sha": "1541165b5ee3762fd93234ee45d59da110ec50f5",
            "filename": "packages/next/src/build/webpack-config.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/58bc2f112c0df424c2c9fe3f5c01bd9c7fe888a2/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack-config.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/58bc2f112c0df424c2c9fe3f5c01bd9c7fe888a2/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack-config.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack-config.ts?ref=58bc2f112c0df424c2c9fe3f5c01bd9c7fe888a2",
            "patch": "@@ -1988,6 +1988,7 @@ export default async function getBaseWebpackConfig(\n           isNodeServer,\n           middlewareMatchers,\n           omitNonDeterministic: isCompileMode,\n+          rewrites,\n         })\n       ),\n       isClient &&"
        },
        {
            "sha": "b828c9b5fe2e732faa071473dc6e6919dcf70501",
            "filename": "packages/next/src/build/webpack/loaders/next-edge-ssr-loader/index.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 3,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/58bc2f112c0df424c2c9fe3f5c01bd9c7fe888a2/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack%2Floaders%2Fnext-edge-ssr-loader%2Findex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/58bc2f112c0df424c2c9fe3f5c01bd9c7fe888a2/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack%2Floaders%2Fnext-edge-ssr-loader%2Findex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack%2Floaders%2Fnext-edge-ssr-loader%2Findex.ts?ref=58bc2f112c0df424c2c9fe3f5c01bd9c7fe888a2",
            "patch": "@@ -182,10 +182,7 @@ const edgeSSRLoader: webpack.LoaderDefinitionFunction<EdgeSSRLoaderQuery> =\n           VAR_MODULE_GLOBAL_ERROR: errorPath,\n         },\n         {\n-          pagesType: JSON.stringify(pagesType),\n-          sriEnabled: JSON.stringify(sriEnabled),\n           nextConfig: stringifiedConfig,\n-          dev: JSON.stringify(dev),\n           pageRouteModuleOptions: JSON.stringify(getRouteModuleOptions(page)),\n           errorRouteModuleOptions: JSON.stringify(\n             getRouteModuleOptions('/_error')"
        },
        {
            "sha": "dd2ea272507e53e6b157e85797a32edfcd1c0c3e",
            "filename": "packages/next/src/server/dev/hot-reloader-turbopack.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/58bc2f112c0df424c2c9fe3f5c01bd9c7fe888a2/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fhot-reloader-turbopack.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/58bc2f112c0df424c2c9fe3f5c01bd9c7fe888a2/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fhot-reloader-turbopack.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fhot-reloader-turbopack.ts?ref=58bc2f112c0df424c2c9fe3f5c01bd9c7fe888a2",
            "patch": "@@ -235,6 +235,7 @@ export async function createHotReloaderTurbopack(\n         hasRewrites,\n         // TODO: Implement\n         middlewareMatchers: undefined,\n+        rewrites: opts.fsChecker.rewrites,\n       }),\n       buildId,\n       encryptionKey,"
        },
        {
            "sha": "f94d2bda8196fb428cc3fb2e21d48331cc10fc7f",
            "filename": "packages/next/src/server/lib/router-utils/setup-dev-bundler.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/58bc2f112c0df424c2c9fe3f5c01bd9c7fe888a2/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Fsetup-dev-bundler.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/58bc2f112c0df424c2c9fe3f5c01bd9c7fe888a2/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Fsetup-dev-bundler.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Fsetup-dev-bundler.ts?ref=58bc2f112c0df424c2c9fe3f5c01bd9c7fe888a2",
            "patch": "@@ -677,6 +677,7 @@ async function startWatcher(\n               // TODO: Implement\n               middlewareMatchers: undefined,\n               projectPath: opts.dir,\n+              rewrites: opts.fsChecker.rewrites,\n             }),\n           })\n         }\n@@ -752,6 +753,7 @@ async function startWatcher(\n                   isNodeServer,\n                   middlewareMatchers: undefined,\n                   projectPath: opts.dir,\n+                  rewrites: opts.fsChecker.rewrites,\n                 })\n \n                 Object.keys(plugin.definitions).forEach((key) => {"
        },
        {
            "sha": "1be9ccd2de5dcf30e1bba4ed4011614c0a248287",
            "filename": "packages/next/src/server/route-modules/route-module.ts",
            "status": "modified",
            "additions": 312,
            "deletions": 231,
            "changes": 543,
            "blob_url": "https://github.com/vercel/next.js/blob/58bc2f112c0df424c2c9fe3f5c01bd9c7fe888a2/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Froute-module.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/58bc2f112c0df424c2c9fe3f5c01bd9c7fe888a2/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Froute-module.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Froute-module.ts?ref=58bc2f112c0df424c2c9fe3f5c01bd9c7fe888a2",
            "patch": "@@ -16,6 +16,7 @@ import {\n   BUILD_ID_FILE,\n   BUILD_MANIFEST,\n   CLIENT_REFERENCE_MANIFEST,\n+  DYNAMIC_CSS_MANIFEST,\n   NEXT_FONT_MANIFEST,\n   PRERENDER_MANIFEST,\n   REACT_LOADABLE_MANIFEST,\n@@ -48,7 +49,8 @@ import { IncrementalCache } from '../lib/incremental-cache'\n import { initializeCacheHandlers, setCacheHandler } from '../use-cache/handlers'\n import { interopDefault } from '../app-render/interop-default'\n import type { RouteKind } from '../route-kind'\n-import type { NextConfigComplete } from '../config-shared'\n+import type { BaseNextRequest } from '../base-http'\n+import type { I18NConfig, NextConfigComplete } from '../config-shared'\n import ResponseCache, { type ResponseGenerator } from '../response-cache'\n import {\n   RouterServerContextSymbol,\n@@ -135,12 +137,17 @@ export abstract class RouteModule<\n   }\n \n   public async instrumentationOnRequestError(\n-    req: IncomingMessage,\n+    req: IncomingMessage | BaseNextRequest,\n     ...args: Parameters<InstrumentationOnRequestError>\n   ) {\n-    // this is only handled here for node, for edge it\n-    // is handled in the adapter/loader instead\n-    if (process.env.NEXT_RUNTIME !== 'edge') {\n+    if (process.env.NEXT_RUNTIME === 'edge') {\n+      const { getEdgeInstrumentationModule } = await import('../web/globals')\n+      const instrumentation = await getEdgeInstrumentationModule()\n+\n+      if (instrumentation) {\n+        await instrumentation.onRequestError?.(...args)\n+      }\n+    } else {\n       const { join } = require('node:path') as typeof import('node:path')\n       const absoluteProjectDir =\n         getRequestMeta(req, 'projectDir') ||\n@@ -158,8 +165,72 @@ export abstract class RouteModule<\n     }\n   }\n \n-  private loadManifests(projectDir: string, srcPage: string) {\n-    if (process.env.NEXT_RUNTIME !== 'edge') {\n+  private loadManifests(\n+    srcPage: string,\n+    projectDir?: string\n+  ): {\n+    buildId: string\n+    buildManifest: BuildManifest\n+    routesManifest: DeepReadonly<DevRoutesManifest>\n+    nextFontManifest: DeepReadonly<NextFontManifest>\n+    prerenderManifest: DeepReadonly<PrerenderManifest>\n+    serverFilesManifest: RequiredServerFilesManifest\n+    reactLoadableManifest: DeepReadonly<ReactLoadableManifest>\n+    subresourceIntegrityManifest: any\n+    clientReferenceManifest: any\n+    serverActionsManifest: any\n+    dynamicCssManifest: any\n+  } {\n+    if (process.env.NEXT_RUNTIME === 'edge') {\n+      const { getEdgePreviewProps } =\n+        require('../web/get-edge-preview-props') as typeof import('../web/get-edge-preview-props')\n+\n+      const maybeJSONParse = (str?: string) =>\n+        str ? JSON.parse(str) : undefined\n+\n+      return {\n+        buildId: process.env.__NEXT_BUILD_ID || '',\n+        buildManifest: self.__BUILD_MANIFEST as any,\n+        reactLoadableManifest: maybeJSONParse(self.__REACT_LOADABLE_MANIFEST),\n+        nextFontManifest: maybeJSONParse(self.__NEXT_FONT_MANIFEST),\n+        prerenderManifest: {\n+          routes: {},\n+          dynamicRoutes: {},\n+          notFoundRoutes: [],\n+          version: 4,\n+          preview: getEdgePreviewProps(),\n+        },\n+        routesManifest: {\n+          version: 4,\n+          caseSensitive: Boolean(process.env.__NEXT_CASE_SENSITIVE_ROUTES),\n+          basePath: process.env.__NEXT_BASE_PATH || '',\n+          rewrites: (process.env.__NEXT_REWRITES as any) || {\n+            beforeFiles: [],\n+            afterFiles: [],\n+            fallback: [],\n+          },\n+          redirects: [],\n+          headers: [],\n+          i18n:\n+            (process.env.__NEXT_I18N_CONFIG as any as I18NConfig) || undefined,\n+          skipMiddlewareUrlNormalize: Boolean(\n+            process.env.__NEXT_NO_MIDDLEWARE_URL_NORMALIZE\n+          ),\n+        },\n+        serverFilesManifest: {\n+          config: (globalThis as any).nextConfig || {},\n+        } as any,\n+        clientReferenceManifest: self.__RSC_MANIFEST?.[srcPage],\n+        serverActionsManifest: maybeJSONParse(self.__RSC_SERVER_MANIFEST),\n+        subresourceIntegrityManifest: maybeJSONParse(\n+          self.__SUBRESOURCE_INTEGRITY_MANIFEST\n+        ),\n+        dynamicCssManifest: maybeJSONParse(self.__DYNAMIC_CSS_MANIFEST),\n+      }\n+    } else {\n+      if (!projectDir) {\n+        throw new Error('Invariant: projectDir is required for node runtime')\n+      }\n       const { loadManifestFromRelativePath } =\n         require('../load-manifest.external') as typeof import('../load-manifest.external')\n       const normalizedPagePath = normalizePagePath(srcPage)\n@@ -175,6 +246,7 @@ export abstract class RouteModule<\n         subresourceIntegrityManifest,\n         serverFilesManifest,\n         buildId,\n+        dynamicCssManifest,\n       ] = [\n         loadManifestFromRelativePath<DevRoutesManifest>({\n           projectDir,\n@@ -250,6 +322,12 @@ export abstract class RouteModule<\n               manifest: BUILD_ID_FILE,\n               skipParse: true,\n             }),\n+        loadManifestFromRelativePath<any>({\n+          projectDir,\n+          distDir: this.distDir,\n+          manifest: DYNAMIC_CSS_MANIFEST,\n+          handleMissing: true,\n+        }),\n       ]\n \n       return {\n@@ -264,9 +342,9 @@ export abstract class RouteModule<\n           ?.__RSC_MANIFEST?.[srcPage.replace(/%5F/g, '_')],\n         serverActionsManifest,\n         subresourceIntegrityManifest,\n+        dynamicCssManifest,\n       }\n     }\n-    throw new Error('Invariant: loadManifests called for edge runtime')\n   }\n \n   public async loadCustomCacheHandlers(\n@@ -358,7 +436,7 @@ export abstract class RouteModule<\n   }\n \n   public async onRequestError(\n-    req: IncomingMessage,\n+    req: IncomingMessage | BaseNextRequest,\n     err: unknown,\n     errorContext: RequestErrorContext,\n     routerServerContext?: RouterServerContext[string]\n@@ -381,8 +459,8 @@ export abstract class RouteModule<\n   }\n \n   public async prepare(\n-    req: IncomingMessage,\n-    res: ServerResponse,\n+    req: IncomingMessage | BaseNextRequest,\n+    res: ServerResponse | null,\n     {\n       srcPage,\n       multiZoneDraftMode,\n@@ -416,6 +494,7 @@ export abstract class RouteModule<\n         // our pre-compiled types\n         clientReferenceManifest?: any\n         serverActionsManifest?: any\n+        dynamicCssManifest?: any\n         subresourceIntegrityManifest?: DeepReadonly<Record<string, string>>\n         isOnDemandRevalidate: boolean\n         revalidateOnlyGenerated: boolean\n@@ -424,13 +503,14 @@ export abstract class RouteModule<\n       }\n     | undefined\n   > {\n-    // \"prepare\" is only needed for node runtime currently\n-    // if we want to share the normalizing logic here\n-    // we will need to allow passing in the i18n and similar info\n+    let projectDir: string | undefined\n+\n+    // edge runtime handles loading instrumentation at the edge adapter level\n     if (process.env.NEXT_RUNTIME !== 'edge') {\n       const { join, relative } =\n         require('node:path') as typeof import('node:path')\n-      const projectDir =\n+\n+      projectDir =\n         getRequestMeta(req, 'projectDir') ||\n         join(process.cwd(), this.projectDir)\n \n@@ -445,218 +525,219 @@ export abstract class RouteModule<\n       // ensure instrumentation is registered and pass\n       // onRequestError below\n       ensureInstrumentationRegistered(projectDir, this.distDir)\n+    }\n+    const manifests = await this.loadManifests(srcPage, projectDir)\n+    const { routesManifest, prerenderManifest, serverFilesManifest } = manifests\n \n-      const manifests = await this.loadManifests(projectDir, srcPage)\n-      const { routesManifest, prerenderManifest, serverFilesManifest } =\n-        manifests\n-\n-      const { basePath, i18n, rewrites } = routesManifest\n+    const { basePath, i18n, rewrites } = routesManifest\n \n-      if (basePath) {\n-        req.url = removePathPrefix(req.url || '/', basePath)\n-      }\n+    if (basePath) {\n+      req.url = removePathPrefix(req.url || '/', basePath)\n+    }\n \n-      const parsedUrl = parseReqUrl(req.url || '/')\n-      // if we couldn't parse the URL we can't continue\n-      if (!parsedUrl) {\n-        return\n-      }\n-      let isNextDataRequest = false\n+    const parsedUrl = parseReqUrl(req.url || '/')\n+    // if we couldn't parse the URL we can't continue\n+    if (!parsedUrl) {\n+      return\n+    }\n+    let isNextDataRequest = false\n \n-      if (pathHasPrefix(parsedUrl.pathname || '/', '/_next/data')) {\n-        isNextDataRequest = true\n-        parsedUrl.pathname = normalizeDataPath(parsedUrl.pathname || '/')\n-      }\n-      let originalPathname = parsedUrl.pathname || '/'\n-      const originalQuery = { ...parsedUrl.query }\n-      const pageIsDynamic = isDynamicRoute(srcPage)\n+    if (pathHasPrefix(parsedUrl.pathname || '/', '/_next/data')) {\n+      isNextDataRequest = true\n+      parsedUrl.pathname = normalizeDataPath(parsedUrl.pathname || '/')\n+    }\n+    let originalPathname = parsedUrl.pathname || '/'\n+    const originalQuery = { ...parsedUrl.query }\n+    const pageIsDynamic = isDynamicRoute(srcPage)\n \n-      let localeResult: PathLocale | undefined\n-      let detectedLocale: string | undefined\n+    let localeResult: PathLocale | undefined\n+    let detectedLocale: string | undefined\n \n-      if (i18n) {\n-        localeResult = normalizeLocalePath(\n-          parsedUrl.pathname || '/',\n-          i18n.locales\n-        )\n+    if (i18n) {\n+      localeResult = normalizeLocalePath(\n+        parsedUrl.pathname || '/',\n+        i18n.locales\n+      )\n \n-        if (localeResult.detectedLocale) {\n-          req.url = `${localeResult.pathname}${parsedUrl.search}`\n-          originalPathname = localeResult.pathname\n+      if (localeResult.detectedLocale) {\n+        req.url = `${localeResult.pathname}${parsedUrl.search}`\n+        originalPathname = localeResult.pathname\n \n-          if (!detectedLocale) {\n-            detectedLocale = localeResult.detectedLocale\n-          }\n+        if (!detectedLocale) {\n+          detectedLocale = localeResult.detectedLocale\n         }\n       }\n+    }\n \n-      const serverUtils = getServerUtils({\n-        page: srcPage,\n-        i18n,\n-        basePath,\n-        rewrites,\n-        pageIsDynamic,\n-        trailingSlash: process.env.__NEXT_TRAILING_SLASH as any as boolean,\n-        caseSensitive: Boolean(routesManifest.caseSensitive),\n-      })\n+    const serverUtils = getServerUtils({\n+      page: srcPage,\n+      i18n,\n+      basePath,\n+      rewrites,\n+      pageIsDynamic,\n+      trailingSlash: process.env.__NEXT_TRAILING_SLASH as any as boolean,\n+      caseSensitive: Boolean(routesManifest.caseSensitive),\n+    })\n \n-      const domainLocale = detectDomainLocale(\n-        i18n?.domains,\n-        getHostname(parsedUrl, req.headers),\n-        detectedLocale\n-      )\n-      addRequestMeta(req, 'isLocaleDomain', Boolean(domainLocale))\n+    const domainLocale = detectDomainLocale(\n+      i18n?.domains,\n+      getHostname(parsedUrl, req.headers),\n+      detectedLocale\n+    )\n+    addRequestMeta(req, 'isLocaleDomain', Boolean(domainLocale))\n \n-      const defaultLocale = domainLocale?.defaultLocale || i18n?.defaultLocale\n+    const defaultLocale = domainLocale?.defaultLocale || i18n?.defaultLocale\n \n-      // Ensure parsedUrl.pathname includes locale before processing\n-      // rewrites or they won't match correctly.\n-      if (defaultLocale && !detectedLocale) {\n-        parsedUrl.pathname = `/${defaultLocale}${parsedUrl.pathname === '/' ? '' : parsedUrl.pathname}`\n-      }\n-      const locale =\n-        getRequestMeta(req, 'locale') || detectedLocale || defaultLocale\n+    // Ensure parsedUrl.pathname includes locale before processing\n+    // rewrites or they won't match correctly.\n+    if (defaultLocale && !detectedLocale) {\n+      parsedUrl.pathname = `/${defaultLocale}${parsedUrl.pathname === '/' ? '' : parsedUrl.pathname}`\n+    }\n+    const locale =\n+      getRequestMeta(req, 'locale') || detectedLocale || defaultLocale\n \n-      const rewriteParamKeys = Object.keys(\n-        serverUtils.handleRewrites(req, parsedUrl)\n-      )\n+    const rewriteParamKeys = Object.keys(\n+      serverUtils.handleRewrites(req, parsedUrl)\n+    )\n \n-      // after processing rewrites we want to remove locale\n-      // from parsedUrl pathname\n-      if (i18n) {\n-        parsedUrl.pathname = normalizeLocalePath(\n-          parsedUrl.pathname || '/',\n-          i18n.locales\n-        ).pathname\n-      }\n+    // after processing rewrites we want to remove locale\n+    // from parsedUrl pathname\n+    if (i18n) {\n+      parsedUrl.pathname = normalizeLocalePath(\n+        parsedUrl.pathname || '/',\n+        i18n.locales\n+      ).pathname\n+    }\n \n-      let params: Record<string, undefined | string | string[]> | undefined =\n-        getRequestMeta(req, 'params')\n+    let params: Record<string, undefined | string | string[]> | undefined =\n+      getRequestMeta(req, 'params')\n \n-      // attempt parsing from pathname\n-      if (!params && serverUtils.dynamicRouteMatcher) {\n-        const paramsMatch = serverUtils.dynamicRouteMatcher(\n-          normalizeDataPath(localeResult?.pathname || parsedUrl.pathname || '/')\n-        )\n-        const paramsResult = serverUtils.normalizeDynamicRouteParams(\n-          paramsMatch || {},\n-          true\n-        )\n+    // attempt parsing from pathname\n+    if (!params && serverUtils.dynamicRouteMatcher) {\n+      const paramsMatch = serverUtils.dynamicRouteMatcher(\n+        normalizeDataPath(localeResult?.pathname || parsedUrl.pathname || '/')\n+      )\n+      const paramsResult = serverUtils.normalizeDynamicRouteParams(\n+        paramsMatch || {},\n+        true\n+      )\n \n-        if (paramsResult.hasValidParams) {\n-          params = paramsResult.params\n-        }\n+      if (paramsResult.hasValidParams) {\n+        params = paramsResult.params\n       }\n+    }\n \n-      // Local \"next start\" expects the routing parsed query values\n-      // to not be present in the URL although when deployed proxies\n-      // will add query values from resolving the routes to pass to function.\n-\n-      // TODO: do we want to change expectations for \"next start\"\n-      // to include these query values in the URL which affects asPath\n-      // but would match deployed behavior, e.g. a rewrite from middleware\n-      // that adds a query param would be in asPath as query but locally\n-      // it won't be in the asPath but still available in the query object\n-      const query = getRequestMeta(req, 'query') || {\n-        ...parsedUrl.query,\n-      }\n+    // Local \"next start\" expects the routing parsed query values\n+    // to not be present in the URL although when deployed proxies\n+    // will add query values from resolving the routes to pass to function.\n+\n+    // TODO: do we want to change expectations for \"next start\"\n+    // to include these query values in the URL which affects asPath\n+    // but would match deployed behavior, e.g. a rewrite from middleware\n+    // that adds a query param would be in asPath as query but locally\n+    // it won't be in the asPath but still available in the query object\n+    const query = getRequestMeta(req, 'query') || {\n+      ...parsedUrl.query,\n+    }\n \n-      const routeParamKeys = new Set<string>()\n-      const combinedParamKeys = [...routeParamKeys]\n-\n-      for (const key of rewriteParamKeys) {\n-        // We only want to filter rewrite param keys from the URL\n-        // if they are matches from the URL e.g. the key/value matches\n-        // before and after applying the rewrites /:path for /hello and\n-        // { path: 'hello' } but not for { path: 'another' } and /hello\n-        // TODO: we should prefix rewrite param keys the same as we do\n-        // for dynamic routes so we can identify them properly\n-        const originalValue = Array.isArray(originalQuery[key])\n-          ? originalQuery[key].join('')\n-          : originalQuery[key]\n-\n-        const queryValue = Array.isArray(query[key])\n-          ? query[key].join('')\n-          : query[key]\n-\n-        if (!(key in originalQuery) || originalValue === queryValue) {\n-          combinedParamKeys.push(key)\n-        }\n+    const routeParamKeys = new Set<string>()\n+    const combinedParamKeys = [...routeParamKeys]\n+\n+    for (const key of rewriteParamKeys) {\n+      // We only want to filter rewrite param keys from the URL\n+      // if they are matches from the URL e.g. the key/value matches\n+      // before and after applying the rewrites /:path for /hello and\n+      // { path: 'hello' } but not for { path: 'another' } and /hello\n+      // TODO: we should prefix rewrite param keys the same as we do\n+      // for dynamic routes so we can identify them properly\n+      const originalValue = Array.isArray(originalQuery[key])\n+        ? originalQuery[key].join('')\n+        : originalQuery[key]\n+\n+      const queryValue = Array.isArray(query[key])\n+        ? query[key].join('')\n+        : query[key]\n+\n+      if (!(key in originalQuery) || originalValue === queryValue) {\n+        combinedParamKeys.push(key)\n       }\n+    }\n \n-      serverUtils.normalizeCdnUrl(req, combinedParamKeys)\n-      serverUtils.normalizeQueryParams(query, routeParamKeys)\n-      serverUtils.filterInternalQuery(originalQuery, combinedParamKeys)\n+    serverUtils.normalizeCdnUrl(req, combinedParamKeys)\n+    serverUtils.normalizeQueryParams(query, routeParamKeys)\n+    serverUtils.filterInternalQuery(originalQuery, combinedParamKeys)\n \n-      if (pageIsDynamic) {\n-        const queryResult = serverUtils.normalizeDynamicRouteParams(query, true)\n+    if (pageIsDynamic) {\n+      const queryResult = serverUtils.normalizeDynamicRouteParams(query, true)\n \n-        const paramsResult = serverUtils.normalizeDynamicRouteParams(\n-          params || {},\n-          true\n-        )\n-        const paramsToInterpolate: ParsedUrlQuery =\n-          paramsResult.hasValidParams && params\n-            ? params\n-            : queryResult.hasValidParams\n-              ? query\n-              : {}\n-\n-        req.url = serverUtils.interpolateDynamicPath(\n-          req.url || '/',\n-          paramsToInterpolate\n-        )\n-        parsedUrl.pathname = serverUtils.interpolateDynamicPath(\n-          parsedUrl.pathname || '/',\n-          paramsToInterpolate\n-        )\n-        originalPathname = serverUtils.interpolateDynamicPath(\n-          originalPathname,\n-          paramsToInterpolate\n-        )\n+      const paramsResult = serverUtils.normalizeDynamicRouteParams(\n+        params || {},\n+        true\n+      )\n+      const paramsToInterpolate: ParsedUrlQuery =\n+        paramsResult.hasValidParams && params\n+          ? params\n+          : queryResult.hasValidParams\n+            ? query\n+            : {}\n+\n+      req.url = serverUtils.interpolateDynamicPath(\n+        req.url || '/',\n+        paramsToInterpolate\n+      )\n+      parsedUrl.pathname = serverUtils.interpolateDynamicPath(\n+        parsedUrl.pathname || '/',\n+        paramsToInterpolate\n+      )\n+      originalPathname = serverUtils.interpolateDynamicPath(\n+        originalPathname,\n+        paramsToInterpolate\n+      )\n \n-        // try pulling from query if valid\n-        if (!params) {\n-          if (queryResult.hasValidParams) {\n-            params = Object.assign({}, queryResult.params)\n-\n-            // If we pulled from query remove it so it's\n-            // only in params\n-            for (const key in serverUtils.defaultRouteMatches) {\n-              delete query[key]\n-            }\n-          } else {\n-            // use final params from URL matching\n-            const paramsMatch = serverUtils.dynamicRouteMatcher?.(\n-              normalizeDataPath(\n-                localeResult?.pathname || parsedUrl.pathname || '/'\n-              )\n+      // try pulling from query if valid\n+      if (!params) {\n+        if (queryResult.hasValidParams) {\n+          params = Object.assign({}, queryResult.params)\n+\n+          // If we pulled from query remove it so it's\n+          // only in params\n+          for (const key in serverUtils.defaultRouteMatches) {\n+            delete query[key]\n+          }\n+        } else {\n+          // use final params from URL matching\n+          const paramsMatch = serverUtils.dynamicRouteMatcher?.(\n+            normalizeDataPath(\n+              localeResult?.pathname || parsedUrl.pathname || '/'\n             )\n-            // we don't normalize these as they are allowed to be\n-            // the literal slug matches here e.g. /blog/[slug]\n-            // actually being requested\n-            if (paramsMatch) {\n-              params = Object.assign({}, paramsMatch)\n-            }\n+          )\n+          // we don't normalize these as they are allowed to be\n+          // the literal slug matches here e.g. /blog/[slug]\n+          // actually being requested\n+          if (paramsMatch) {\n+            params = Object.assign({}, paramsMatch)\n           }\n         }\n       }\n+    }\n \n-      // Remove any normalized params from the query if they\n-      // weren't present as non-prefixed query key e.g.\n-      // ?search=1&nxtPsearch=hello we don't delete search\n-      for (const key of routeParamKeys) {\n-        if (!(key in originalQuery)) {\n-          delete query[key]\n-        }\n+    // Remove any normalized params from the query if they\n+    // weren't present as non-prefixed query key e.g.\n+    // ?search=1&nxtPsearch=hello we don't delete search\n+    for (const key of routeParamKeys) {\n+      if (!(key in originalQuery)) {\n+        delete query[key]\n       }\n+    }\n \n-      const { isOnDemandRevalidate, revalidateOnlyGenerated } =\n-        checkIsOnDemandRevalidate(req, prerenderManifest.preview)\n+    const { isOnDemandRevalidate, revalidateOnlyGenerated } =\n+      checkIsOnDemandRevalidate(req, prerenderManifest.preview)\n \n-      let isDraftMode = false\n-      let previewData: PreviewData\n+    let isDraftMode = false\n+    let previewData: PreviewData\n \n+    // preview data relies on non-edge utils\n+    if (process.env.NEXT_RUNTIME !== 'edge' && res) {\n       const { tryGetPreviewData } =\n         require('../api-utils/node/try-get-preview-data') as typeof import('../api-utils/node/try-get-preview-data')\n \n@@ -667,50 +748,50 @@ export abstract class RouteModule<\n         Boolean(multiZoneDraftMode)\n       )\n       isDraftMode = previewData !== false\n+    }\n \n-      const routerServerContext =\n-        routerServerGlobal[RouterServerContextSymbol]?.[this.projectDir]\n-      const nextConfig =\n-        routerServerContext?.nextConfig || serverFilesManifest.config\n+    const routerServerContext =\n+      routerServerGlobal[RouterServerContextSymbol]?.[this.projectDir]\n+    const nextConfig =\n+      routerServerContext?.nextConfig || serverFilesManifest.config\n \n-      const normalizedSrcPage = normalizeAppPath(srcPage)\n-      let resolvedPathname =\n-        getRequestMeta(req, 'rewroteURL') || normalizedSrcPage\n+    const normalizedSrcPage = normalizeAppPath(srcPage)\n+    let resolvedPathname =\n+      getRequestMeta(req, 'rewroteURL') || normalizedSrcPage\n \n-      if (isDynamicRoute(resolvedPathname) && params) {\n-        resolvedPathname = serverUtils.interpolateDynamicPath(\n-          resolvedPathname,\n-          params\n-        )\n-      }\n-\n-      if (resolvedPathname === '/index') {\n-        resolvedPathname = '/'\n-      }\n-      resolvedPathname = decodePathParams(resolvedPathname)\n-\n-      return {\n-        query,\n-        originalQuery,\n-        originalPathname,\n-        params,\n-        parsedUrl,\n-        locale,\n-        isNextDataRequest,\n-        locales: i18n?.locales,\n-        defaultLocale,\n-        isDraftMode,\n-        previewData,\n-        pageIsDynamic,\n+    if (isDynamicRoute(resolvedPathname) && params) {\n+      resolvedPathname = serverUtils.interpolateDynamicPath(\n         resolvedPathname,\n-        isOnDemandRevalidate,\n-        revalidateOnlyGenerated,\n-        ...manifests,\n-        serverActionsManifest: manifests.serverActionsManifest,\n-        clientReferenceManifest: manifests.clientReferenceManifest,\n-        nextConfig,\n-        routerServerContext,\n-      }\n+        params\n+      )\n+    }\n+\n+    if (resolvedPathname === '/index') {\n+      resolvedPathname = '/'\n+    }\n+    resolvedPathname = decodePathParams(resolvedPathname)\n+\n+    return {\n+      query,\n+      originalQuery,\n+      originalPathname,\n+      params,\n+      parsedUrl,\n+      locale,\n+      isNextDataRequest,\n+      locales: i18n?.locales,\n+      defaultLocale,\n+      isDraftMode,\n+      previewData,\n+      pageIsDynamic,\n+      resolvedPathname,\n+      isOnDemandRevalidate,\n+      revalidateOnlyGenerated,\n+      ...manifests,\n+      serverActionsManifest: manifests.serverActionsManifest,\n+      clientReferenceManifest: manifests.clientReferenceManifest,\n+      nextConfig,\n+      routerServerContext,\n     }\n   }\n "
        },
        {
            "sha": "fa01da5ec3b714da764fde6f21ff2e3d0cd2f83b",
            "filename": "packages/next/src/server/web/adapter.ts",
            "status": "modified",
            "additions": 18,
            "deletions": 9,
            "changes": 27,
            "blob_url": "https://github.com/vercel/next.js/blob/58bc2f112c0df424c2c9fe3f5c01bd9c7fe888a2/packages%2Fnext%2Fsrc%2Fserver%2Fweb%2Fadapter.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/58bc2f112c0df424c2c9fe3f5c01bd9c7fe888a2/packages%2Fnext%2Fsrc%2Fserver%2Fweb%2Fadapter.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fweb%2Fadapter.ts?ref=58bc2f112c0df424c2c9fe3f5c01bd9c7fe888a2",
            "patch": "@@ -71,6 +71,8 @@ export type AdapterOptions = {\n   page: string\n   request: RequestData\n   IncrementalCache?: typeof import('../lib/incremental-cache').IncrementalCache\n+  incrementalCacheHandler?: typeof import('../lib/incremental-cache').CacheHandler\n+  bypassNextUrl?: boolean\n }\n \n let propagator: <T>(request: NextRequestHint, fn: () => T) => T = (\n@@ -108,10 +110,12 @@ export async function adapter(\n \n   params.request.url = normalizeRscURL(params.request.url)\n \n-  const requestURL = new NextURL(params.request.url, {\n-    headers: params.request.headers,\n-    nextConfig: params.request.nextConfig,\n-  })\n+  const requestURL = params.bypassNextUrl\n+    ? new URL(params.request.url)\n+    : new NextURL(params.request.url, {\n+        headers: params.request.headers,\n+        nextConfig: params.request.nextConfig,\n+      })\n \n   // Iterator uses an index to keep track of the current iteration. Because of deleting and appending below we can't just use the iterator.\n   // Instead we use the keys before iteration.\n@@ -130,8 +134,11 @@ export async function adapter(\n   }\n \n   // Ensure users only see page requests, never data requests.\n-  const buildId = requestURL.buildId\n-  requestURL.buildId = ''\n+  let buildId = process.env.__NEXT_BUILD_ID || ''\n+  if ('buildId' in requestURL) {\n+    buildId = (requestURL as NextURL).buildId || ''\n+    requestURL.buildId = ''\n+  }\n \n   const requestHeaders = fromNodeOutgoingHttpHeaders(params.request.headers)\n   const isNextDataRequest = requestHeaders.has('x-nextjs-data')\n@@ -192,14 +199,16 @@ export async function adapter(\n     (params as any).IncrementalCache\n   ) {\n     ;(globalThis as any).__incrementalCache = new (\n-      params as any\n+      params as {\n+        IncrementalCache: typeof import('../lib/incremental-cache').IncrementalCache\n+      }\n     ).IncrementalCache({\n-      appDir: true,\n-      fetchCache: true,\n+      CurCacheHandler: params.incrementalCacheHandler,\n       minimalMode: process.env.NODE_ENV !== 'development',\n       fetchCacheKeyPrefix: process.env.__NEXT_FETCH_CACHE_KEY_PREFIX,\n       dev: process.env.NODE_ENV === 'development',\n       requestHeaders: params.request.headers as any,\n+\n       getPrerenderManifest: () => {\n         return {\n           version: -1 as any, // letting us know this doesn't conform to spec"
        },
        {
            "sha": "714b8b1cf8c3715f4782a9a616d492cca4fe62fa",
            "filename": "test/development/basic/next-rs-api.test.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/58bc2f112c0df424c2c9fe3f5c01bd9c7fe888a2/test%2Fdevelopment%2Fbasic%2Fnext-rs-api.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/58bc2f112c0df424c2c9fe3f5c01bd9c7fe888a2/test%2Fdevelopment%2Fbasic%2Fnext-rs-api.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Fbasic%2Fnext-rs-api.test.ts?ref=58bc2f112c0df424c2c9fe3f5c01bd9c7fe888a2",
            "patch": "@@ -221,6 +221,11 @@ describe('next.rs api', () => {\n         fetchCacheKeyPrefix: undefined,\n         hasRewrites: false,\n         middlewareMatchers: undefined,\n+        rewrites: {\n+          beforeFiles: [],\n+          afterFiles: [],\n+          fallback: [],\n+        },\n       }),\n       buildId: 'development',\n       encryptionKey: '12345',"
        }
    ],
    "stats": {
        "total": 957,
        "additions": 654,
        "deletions": 303
    }
}