{
    "author": "eps1lon",
    "message": "[test] Use new Redbox matchers in pages/ hydration-error test (#76350)",
    "sha": "d5cefb260671508391b0508b9187a79cb5b8a766",
    "files": [
        {
            "sha": "702ae09184a15f81ee5bfab2c9833e86a1f2071a",
            "filename": "test/development/acceptance/hydration-error.test.ts",
            "status": "modified",
            "additions": 311,
            "deletions": 307,
            "changes": 618,
            "blob_url": "https://github.com/vercel/next.js/blob/d5cefb260671508391b0508b9187a79cb5b8a766/test%2Fdevelopment%2Facceptance%2Fhydration-error.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d5cefb260671508391b0508b9187a79cb5b8a766/test%2Fdevelopment%2Facceptance%2Fhydration-error.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Facceptance%2Fhydration-error.test.ts?ref=d5cefb260671508391b0508b9187a79cb5b8a766",
            "patch": "@@ -8,7 +8,7 @@ const isReact18 = parseInt(process.env.NEXT_TEST_REACT_VERSION) === 18\n // https://github.com/facebook/react/blob/main/packages/react-dom/src/__tests__/ReactDOMHydrationDiff-test.js used as a reference\n \n describe('Error overlay for hydration errors in Pages router', () => {\n-  const { next, isTurbopack } = nextTestSetup({\n+  const { next } = nextTestSetup({\n     files: new FileRef(path.join(__dirname, 'fixtures', 'default-template')),\n     skipStart: true,\n   })\n@@ -73,52 +73,27 @@ describe('Error overlay for hydration errors in Pages router', () => {\n     )\n     const { session, browser } = sandbox\n \n-    await session.assertHasRedbox()\n-    expect(await getRedboxTotalErrorCount(browser)).toBe(isReact18 ? 2 : 1)\n-\n-    if (isReact18) {\n-      expect(await session.getRedboxDescription()).toMatchInlineSnapshot(\n-        `\"Text content did not match. Server: \"server\" Client: \"client\"\"`\n-      )\n-    } else {\n-      expect(await session.getRedboxDescription()).toMatchInlineSnapshot(\n-        `\"Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\"`\n-      )\n-    }\n-\n-    if (isReact18) {\n-      expect(await session.getRedboxDescriptionWarning()).toMatchInlineSnapshot(\n-        `null`\n-      )\n-    } else {\n-      expect(await session.getRedboxDescriptionWarning())\n-        .toMatchInlineSnapshot(`\n-          \"- A server/client branch \\`if (typeof window !== 'undefined')\\`.\n-          - Variable input such as \\`Date.now()\\` or \\`Math.random()\\` which changes each time it's called.\n-          - Date formatting in a user's locale which doesn't match the server.\n-          - External changing data without sending a snapshot of it along with the HTML.\n-          - Invalid HTML tag nesting.\n-\n-          It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\"\n-        `)\n-    }\n-    expect(await session.getRedboxErrorLink()).toMatchInlineSnapshot(\n-      `\"See more info here: https://nextjs.org/docs/messages/react-hydration-error\"`\n-    )\n-\n-    const pseudoHtml = await session.getRedboxComponentStack()\n-\n+    // Pages Router uses React version without Owner Stacks hence the empty `stack`\n     if (isReact18) {\n-      expect(pseudoHtml).toMatchInlineSnapshot(`\n-       \"<Mismatch>\n+      await expect(browser).toDisplayRedbox(`\n+       {\n+         \"componentStack\": \"<Mismatch>\n            <div>\n              <main>\n        +       \"server\"\n-       -       \"client\"\"\n+       -       \"client\"\",\n+         \"count\": 2,\n+         \"description\": \"Text content did not match. Server: \"server\" Client: \"client\"\",\n+         \"environmentLabel\": null,\n+         \"label\": \"Unhandled Runtime Error\",\n+         \"source\": undefined,\n+         \"stack\": [],\n+       }\n       `)\n     } else {\n-      expect(pseudoHtml).toMatchInlineSnapshot(`\n-       \"...\n+      await expect(browser).toDisplayRedbox(`\n+       {\n+         \"componentStack\": \"...\n            <AppContainer>\n              <Container fn={function fn}>\n                <PagesDevOverlay>\n@@ -131,9 +106,17 @@ describe('Error overlay for hydration errors in Pages router', () => {\n        +                     client\n        -                     server\n                      ...\n-                 ...\"\n+                 ...\",\n+         \"count\": 1,\n+         \"description\": \"Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\",\n+         \"environmentLabel\": null,\n+         \"label\": \"Unhandled Runtime Error\",\n+         \"source\": undefined,\n+         \"stack\": [],\n+       }\n       `)\n     }\n+\n     await session.patch(\n       'index.js',\n       outdent`\n@@ -171,24 +154,30 @@ describe('Error overlay for hydration errors in Pages router', () => {\n         ],\n       ])\n     )\n-    const { session, browser } = sandbox\n-    await session.assertHasRedbox()\n+    const { browser } = sandbox\n+\n     await retry(async () => {\n-      await expect(await getRedboxTotalErrorCount(browser)).toBe(\n-        isReact18 ? 3 : 1\n-      )\n+      expect(await getRedboxTotalErrorCount(browser)).toBe(isReact18 ? 3 : 1)\n     })\n \n-    const pseudoHtml = await session.getRedboxComponentStack()\n     if (isReact18) {\n-      expect(pseudoHtml).toMatchInlineSnapshot(`\n-       \"<Mismatch>\n+      await expect(browser).toDisplayRedbox(`\n+       {\n+         \"componentStack\": \"<Mismatch>\n        >   <div>\n-       >     <main>\"\n+       >     <main>\",\n+         \"count\": 3,\n+         \"description\": \"Expected server HTML to contain a matching <main> in <div>.\",\n+         \"environmentLabel\": null,\n+         \"label\": \"Unhandled Runtime Error\",\n+         \"source\": undefined,\n+         \"stack\": [],\n+       }\n       `)\n     } else {\n-      expect(pseudoHtml).toMatchInlineSnapshot(`\n-       \"...\n+      await expect(browser).toDisplayRedbox(`\n+       {\n+         \"componentStack\": \"...\n            <AppContainer>\n              <Container fn={function fn}>\n                <PagesDevOverlay>\n@@ -199,19 +188,16 @@ describe('Error overlay for hydration errors in Pages router', () => {\n                          <div className=\"parent\">\n        +                   <main className=\"only\">\n                      ...\n-                 ...\"\n+                 ...\",\n+         \"count\": 1,\n+         \"description\": \"Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\",\n+         \"environmentLabel\": null,\n+         \"label\": \"Unhandled Runtime Error\",\n+         \"source\": undefined,\n+         \"stack\": [],\n+       }\n       `)\n     }\n-\n-    if (isReact18) {\n-      expect(await session.getRedboxDescription()).toMatchInlineSnapshot(\n-        `\"Expected server HTML to contain a matching <main> in <div>.\"`\n-      )\n-    } else {\n-      expect(await session.getRedboxDescription()).toMatchInlineSnapshot(\n-        `\"Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\"`\n-      )\n-    }\n   })\n \n   it('should show correct hydration error when client renders an extra text node', async () => {\n@@ -235,25 +221,31 @@ describe('Error overlay for hydration errors in Pages router', () => {\n         ],\n       ])\n     )\n-    const { session, browser } = sandbox\n-    await session.assertHasRedbox()\n+    const { browser } = sandbox\n+\n     await retry(async () => {\n-      await expect(await getRedboxTotalErrorCount(browser)).toBe(\n-        isReact18 ? 3 : 1\n-      )\n+      expect(await getRedboxTotalErrorCount(browser)).toBe(isReact18 ? 3 : 1)\n     })\n \n-    const pseudoHtml = await session.getRedboxComponentStack()\n     if (isReact18) {\n-      expect(pseudoHtml).toMatchInlineSnapshot(`\n-       \"<Mismatch>\n+      await expect(browser).toDisplayRedbox(`\n+       {\n+         \"componentStack\": \"<Mismatch>\n            <div>\n        >     <div>\n-       >       \"second\"\"\n+       >       \"second\"\",\n+         \"count\": 3,\n+         \"description\": \"Expected server HTML to contain a matching text node for \"second\" in <div>.\",\n+         \"environmentLabel\": null,\n+         \"label\": \"Unhandled Runtime Error\",\n+         \"source\": undefined,\n+         \"stack\": [],\n+       }\n       `)\n     } else {\n-      expect(pseudoHtml).toMatchInlineSnapshot(`\n-       \"...\n+      await expect(browser).toDisplayRedbox(`\n+       {\n+         \"componentStack\": \"...\n            <AppContainer>\n              <Container fn={function fn}>\n                <PagesDevOverlay>\n@@ -267,19 +259,16 @@ describe('Error overlay for hydration errors in Pages router', () => {\n        -                   <footer className=\"3\">\n                            ...\n                      ...\n-                 ...\"\n+                 ...\",\n+         \"count\": 1,\n+         \"description\": \"Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\",\n+         \"environmentLabel\": null,\n+         \"label\": \"Unhandled Runtime Error\",\n+         \"source\": undefined,\n+         \"stack\": [],\n+       }\n       `)\n     }\n-\n-    if (isReact18) {\n-      expect(await session.getRedboxDescription()).toMatchInlineSnapshot(\n-        `\"Expected server HTML to contain a matching text node for \"second\" in <div>.\"`\n-      )\n-    } else {\n-      expect(await session.getRedboxDescription()).toMatchInlineSnapshot(\n-        `\"Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\"`\n-      )\n-    }\n   })\n \n   it('should show correct hydration error when server renders an extra element', async () => {\n@@ -301,19 +290,25 @@ describe('Error overlay for hydration errors in Pages router', () => {\n         ],\n       ])\n     )\n-    const { session, browser } = sandbox\n-    await session.assertHasRedbox()\n-    expect(await getRedboxTotalErrorCount(browser)).toBe(isReact18 ? 2 : 1)\n+    const { browser } = sandbox\n \n-    const pseudoHtml = await session.getRedboxComponentStack()\n     if (isReact18) {\n-      expect(pseudoHtml).toMatchInlineSnapshot(`\n-       \"<Mismatch>\n-       >   <div>\"\n+      await expect(browser).toDisplayRedbox(`\n+       {\n+         \"componentStack\": \"<Mismatch>\n+       >   <div>\",\n+         \"count\": 2,\n+         \"description\": \"Did not expect server HTML to contain a <main> in <div>.\",\n+         \"environmentLabel\": null,\n+         \"label\": \"Unhandled Runtime Error\",\n+         \"source\": undefined,\n+         \"stack\": [],\n+       }\n       `)\n     } else {\n-      expect(pseudoHtml).toMatchInlineSnapshot(`\n-       \"<Root callbacks={[...]}>\n+      await expect(browser).toDisplayRedbox(`\n+       {\n+         \"componentStack\": \"<Root callbacks={[...]}>\n            <Head>\n            <AppContainer>\n              <Container fn={function fn}>\n@@ -325,19 +320,16 @@ describe('Error overlay for hydration errors in Pages router', () => {\n                          <div className=\"parent\">\n        -                   <main className=\"only\">\n                      ...\n-                 ...\"\n+                 ...\",\n+         \"count\": 1,\n+         \"description\": \"Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\",\n+         \"environmentLabel\": null,\n+         \"label\": \"Unhandled Runtime Error\",\n+         \"source\": undefined,\n+         \"stack\": [],\n+       }\n       `)\n     }\n-\n-    if (isReact18) {\n-      expect(await session.getRedboxDescription()).toMatchInlineSnapshot(\n-        `\"Did not expect server HTML to contain a <main> in <div>.\"`\n-      )\n-    } else {\n-      expect(await session.getRedboxDescription()).toMatchInlineSnapshot(\n-        `\"Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\"`\n-      )\n-    }\n   })\n \n   it('should show correct hydration error when server renders an extra text node', async () => {\n@@ -355,32 +347,27 @@ describe('Error overlay for hydration errors in Pages router', () => {\n         ],\n       ])\n     )\n-    const { session, browser } = sandbox\n-    await session.assertHasRedbox()\n-    expect(await getRedboxTotalErrorCount(browser)).toBe(isReact18 ? 2 : 1)\n-\n-    if (isReact18) {\n-      expect(await session.getRedboxDescription()).toMatchInlineSnapshot(\n-        `\"Did not expect server HTML to contain the text node \"only\" in <div>.\"`\n-      )\n-    } else {\n-      expect(await session.getRedboxDescription()).toMatchInlineSnapshot(\n-        `\"Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\"`\n-      )\n-    }\n-\n-    const pseudoHtml = await session.getRedboxComponentStack()\n+    const { browser } = sandbox\n \n     if (isReact18) {\n-      expect(pseudoHtml).toMatchInlineSnapshot(`\n-       \"<Mismatch>\n+      await expect(browser).toDisplayRedbox(`\n+       {\n+         \"componentStack\": \"<Mismatch>\n            <div>\n        >     <div>\n-       >       \"only\"\"\n+       >       \"only\"\",\n+         \"count\": 2,\n+         \"description\": \"Did not expect server HTML to contain the text node \"only\" in <div>.\",\n+         \"environmentLabel\": null,\n+         \"label\": \"Unhandled Runtime Error\",\n+         \"source\": undefined,\n+         \"stack\": [],\n+       }\n       `)\n     } else {\n-      expect(pseudoHtml).toMatchInlineSnapshot(`\n-       \"<Root callbacks={[...]}>\n+      await expect(browser).toDisplayRedbox(`\n+       {\n+         \"componentStack\": \"<Root callbacks={[...]}>\n            <Head>\n            <AppContainer>\n              <Container fn={function fn}>\n@@ -392,7 +379,14 @@ describe('Error overlay for hydration errors in Pages router', () => {\n                          <div className=\"parent\">\n        -                   only\n                      ...\n-                 ...\"\n+                 ...\",\n+         \"count\": 1,\n+         \"description\": \"Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\",\n+         \"environmentLabel\": null,\n+         \"label\": \"Unhandled Runtime Error\",\n+         \"source\": undefined,\n+         \"stack\": [],\n+       }\n       `)\n     }\n   })\n@@ -417,11 +411,10 @@ describe('Error overlay for hydration errors in Pages router', () => {\n         ],\n       ])\n     )\n-    const { session, browser } = sandbox\n-    await session.assertHasRedbox()\n+    const { browser } = sandbox\n \n     await retry(async () => {\n-      await expect(await getRedboxTotalErrorCount(browser)).toBe(\n+      expect(await getRedboxTotalErrorCount(browser)).toBe(\n         isReact18\n           ? 3\n           : // FIXME: Should be 2\n@@ -430,25 +423,22 @@ describe('Error overlay for hydration errors in Pages router', () => {\n     })\n \n     if (isReact18) {\n-      expect(await session.getRedboxDescription()).toMatchInlineSnapshot(\n-        `\"Expected server HTML to contain a matching <table> in <div>.\"`\n-      )\n-    } else {\n-      // FIXME: should show \"Expected server HTML to contain a matching <table> in <div>.\" first\n-      expect(await session.getRedboxDescription()).toMatchInlineSnapshot(\n-        `\"Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\"`\n-      )\n-    }\n-\n-    const pseudoHtml = await session.getRedboxComponentStack()\n-    if (isReact18) {\n-      expect(pseudoHtml).toMatchInlineSnapshot(`\n-       \"<Page>\n-       >   <table>\"\n+      await expect(browser).toDisplayRedbox(`\n+       {\n+         \"componentStack\": \"<Page>\n+       >   <table>\",\n+         \"count\": 3,\n+         \"description\": \"Expected server HTML to contain a matching <table> in <div>.\",\n+         \"environmentLabel\": null,\n+         \"label\": \"Unhandled Runtime Error\",\n+         \"source\": undefined,\n+         \"stack\": [],\n+       }\n       `)\n     } else {\n-      expect(pseudoHtml).toMatchInlineSnapshot(`\n-       \"<Root callbacks={[...]}>\n+      await expect(browser).toDisplayRedbox(`\n+       {\n+         \"componentStack\": \"<Root callbacks={[...]}>\n            <Head>\n            <AppContainer>\n              <Container fn={function fn}>\n@@ -460,7 +450,14 @@ describe('Error overlay for hydration errors in Pages router', () => {\n        +                 <table>\n        -                 test\n                      ...\n-                 ...\"\n+                 ...\",\n+         \"count\": 1,\n+         \"description\": \"Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\",\n+         \"environmentLabel\": null,\n+         \"label\": \"Unhandled Runtime Error\",\n+         \"source\": undefined,\n+         \"stack\": [],\n+       }\n       `)\n     }\n   })\n@@ -484,62 +481,49 @@ describe('Error overlay for hydration errors in Pages router', () => {\n         ],\n       ])\n     )\n-    const { session, browser } = sandbox\n+    const { browser } = sandbox\n \n-    await session.assertHasRedbox()\n+    await retry(async () => {\n+      expect(await getRedboxTotalErrorCount(browser)).toBe(isReact18 ? 3 : 1)\n+    })\n \n     if (isReact18) {\n-      expect(await session.getRedboxDescription()).toMatchInlineSnapshot(\n-        `\"Expected server HTML to contain a matching <table> in <div>.\"`\n-      )\n-\n-      const pseudoHtml = await session.getRedboxComponentStack()\n-      expect(pseudoHtml).toMatchInlineSnapshot(`\n-       \"<Page>\n-       >   <table>\"\n+      await expect(browser).toDisplayRedbox(`\n+       {\n+         \"componentStack\": \"<Page>\n+       >   <table>\",\n+         \"count\": 3,\n+         \"description\": \"Expected server HTML to contain a matching <table> in <div>.\",\n+         \"environmentLabel\": null,\n+         \"label\": \"Unhandled Runtime Error\",\n+         \"source\": undefined,\n+         \"stack\": [],\n+       }\n       `)\n-\n-      expect(await getRedboxTotalErrorCount(browser)).toBe(3)\n     } else {\n-      expect(await session.getRedboxDescription()).toMatchInlineSnapshot(\n-        `\"Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\"`\n-      )\n-\n-      const pseudoHtml = await session.getRedboxComponentStack()\n-      if (isTurbopack) {\n-        expect(pseudoHtml).toMatchInlineSnapshot(`\n-         \"<Root callbacks={[...]}>\n-             <Head>\n-             <AppContainer>\n-               <Container fn={function fn}>\n-                 <PagesDevOverlay>\n-                   <PagesDevOverlayErrorBoundary onError={function usePagesDevOverlay.useCallback[onComponentError]}>\n-                     <PathnameContextProviderAdapter router={{sdc:{},sbc:{}, ...}} isAutoExport={true}>\n-                       <App pageProps={{}} Component={function Page} err={undefined} router={{sdc:{},sbc:{}, ...}}>\n-                         <Page>\n-         +                 <table>\n-         -                 {\" 123\"}\n-                       ...\n-                   ...\"\n-        `)\n-      } else {\n-        expect(pseudoHtml).toMatchInlineSnapshot(`\n-         \"<Root callbacks={[...]}>\n-             <Head>\n-             <AppContainer>\n-               <Container fn={function fn}>\n-                 <PagesDevOverlay>\n-                   <PagesDevOverlayErrorBoundary onError={function usePagesDevOverlay.useCallback[onComponentError]}>\n-                     <PathnameContextProviderAdapter router={{sdc:{},sbc:{}, ...}} isAutoExport={true}>\n-                       <App pageProps={{}} Component={function Page} err={undefined} router={{sdc:{},sbc:{}, ...}}>\n-                         <Page>\n-         +                 <table>\n-         -                 {\" 123\"}\n-                       ...\n-                   ...\"\n-        `)\n-      }\n-      expect(await getRedboxTotalErrorCount(browser)).toBe(1)\n+      await expect(browser).toDisplayRedbox(`\n+       {\n+         \"componentStack\": \"<Root callbacks={[...]}>\n+           <Head>\n+           <AppContainer>\n+             <Container fn={function fn}>\n+               <PagesDevOverlay>\n+                 <PagesDevOverlayErrorBoundary onError={function usePagesDevOverlay.useCallback[onComponentError]}>\n+                   <PathnameContextProviderAdapter router={{sdc:{},sbc:{}, ...}} isAutoExport={true}>\n+                     <App pageProps={{}} Component={function Page} err={undefined} router={{sdc:{},sbc:{}, ...}}>\n+                       <Page>\n+       +                 <table>\n+       -                 {\" 123\"}\n+                     ...\n+                 ...\",\n+         \"count\": 1,\n+         \"description\": \"Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\",\n+         \"environmentLabel\": null,\n+         \"label\": \"Unhandled Runtime Error\",\n+         \"source\": undefined,\n+         \"stack\": [],\n+       }\n+      `)\n     }\n   })\n \n@@ -567,19 +551,31 @@ describe('Error overlay for hydration errors in Pages router', () => {\n         ],\n       ])\n     )\n-    const { session } = sandbox\n-    await session.assertHasRedbox()\n-    const pseudoHtml = await session.getRedboxComponentStack()\n+    const { browser } = sandbox\n+\n+    await retry(async () => {\n+      expect(await getRedboxTotalErrorCount(browser)).toBe(isReact18 ? 3 : 1)\n+    })\n+\n     if (isReact18) {\n-      expect(pseudoHtml).toMatchInlineSnapshot(`\n-       \"<Mismatch>\n+      await expect(browser).toDisplayRedbox(`\n+       {\n+         \"componentStack\": \"<Mismatch>\n        >   <div>\n              <Suspense>\n-       >       <main>\"\n+       >       <main>\",\n+         \"count\": 3,\n+         \"description\": \"Expected server HTML to contain a matching <main> in <div>.\",\n+         \"environmentLabel\": null,\n+         \"label\": \"Unhandled Runtime Error\",\n+         \"source\": undefined,\n+         \"stack\": [],\n+       }\n       `)\n     } else {\n-      expect(pseudoHtml).toMatchInlineSnapshot(`\n-       \"...\n+      await expect(browser).toDisplayRedbox(`\n+       {\n+         \"componentStack\": \"...\n            <PagesDevOverlay>\n              <PagesDevOverlayErrorBoundary onError={function usePagesDevOverlay.useCallback[onComponentError]}>\n                <PathnameContextProviderAdapter router={{sdc:{},sbc:{}, ...}} isAutoExport={true}>\n@@ -592,19 +588,16 @@ describe('Error overlay for hydration errors in Pages router', () => {\n        -                 <footer className=\"3\">\n                          ...\n                  ...\n-             ...\"\n+             ...\",\n+         \"count\": 1,\n+         \"description\": \"Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\",\n+         \"environmentLabel\": null,\n+         \"label\": \"Unhandled Runtime Error\",\n+         \"source\": undefined,\n+         \"stack\": [],\n+       }\n       `)\n     }\n-\n-    if (isReact18) {\n-      expect(await session.getRedboxDescription()).toMatchInlineSnapshot(\n-        `\"Expected server HTML to contain a matching <main> in <div>.\"`\n-      )\n-    } else {\n-      expect(await session.getRedboxDescription()).toMatchInlineSnapshot(\n-        `\"Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\"`\n-      )\n-    }\n   })\n \n   it('should not show a hydration error when using `useId` in a client component', async () => {\n@@ -658,36 +651,30 @@ describe('Error overlay for hydration errors in Pages router', () => {\n         ],\n       ])\n     )\n-    const { session, browser } = sandbox\n-    await session.assertHasRedbox()\n+    const { browser } = sandbox\n+\n     await retry(async () => {\n       expect(await getRedboxTotalErrorCount(browser)).toBe(isReact18 ? 3 : 1)\n     })\n \n-    const description = await session.getRedboxDescription()\n-    if (isReact18) {\n-      expect(description).toMatchInlineSnapshot(\n-        `\"Expected server HTML to contain a matching <p> in <p>.\"`\n-      )\n-    } else {\n-      expect(description).toMatchInlineSnapshot(`\n-        \"In HTML, <p> cannot be a descendant of <p>.\n-        This will cause a hydration error.\"\n-      `)\n-    }\n-\n-    await session.assertHasRedbox()\n-    const pseudoHtml = await session.getRedboxComponentStack()\n-\n     if (isReact18) {\n-      expect(pseudoHtml).toMatchInlineSnapshot(`\n-       \"<Page>\n+      await expect(browser).toDisplayRedbox(`\n+       {\n+         \"componentStack\": \"<Page>\n        >   <p>\n-       >     <p>\"\n+       >     <p>\",\n+         \"count\": 3,\n+         \"description\": \"Expected server HTML to contain a matching <p> in <p>.\",\n+         \"environmentLabel\": null,\n+         \"label\": \"Unhandled Runtime Error\",\n+         \"source\": undefined,\n+         \"stack\": [],\n+       }\n       `)\n     } else {\n-      expect(pseudoHtml).toMatchInlineSnapshot(`\n-       \"<Root callbacks={[...]}>\n+      await expect(browser).toDisplayRedbox(`\n+       {\n+         \"componentStack\": \"<Root callbacks={[...]}>\n            <Head>\n            <AppContainer>\n              <Container fn={function fn}>\n@@ -699,7 +686,15 @@ describe('Error overlay for hydration errors in Pages router', () => {\n        >                 <p>\n        >                   <p>\n                      ...\n-                 ...\"\n+                 ...\",\n+         \"count\": 1,\n+         \"description\": \"In HTML, <p> cannot be a descendant of <p>.\n+       This will cause a hydration error.\",\n+         \"environmentLabel\": null,\n+         \"label\": \"Unhandled Runtime Error\",\n+         \"source\": undefined,\n+         \"stack\": [],\n+       }\n       `)\n     }\n   })\n@@ -726,37 +721,32 @@ describe('Error overlay for hydration errors in Pages router', () => {\n         ],\n       ])\n     )\n-    const { session, browser } = sandbox\n-    await session.assertHasRedbox()\n+    const { browser } = sandbox\n+\n     await retry(async () => {\n       expect(await getRedboxTotalErrorCount(browser)).toBe(isReact18 ? 3 : 1)\n     })\n \n-    const description = await session.getRedboxDescription()\n     if (isReact18) {\n-      expect(description).toMatchInlineSnapshot(\n-        `\"Expected server HTML to contain a matching <div> in <p>.\"`\n-      )\n-    } else {\n-      expect(description).toMatchInlineSnapshot(`\n-        \"In HTML, <div> cannot be a descendant of <p>.\n-        This will cause a hydration error.\"\n-      `)\n-    }\n-\n-    const pseudoHtml = await session.getRedboxComponentStack()\n-\n-    if (isReact18) {\n-      expect(pseudoHtml).toMatchInlineSnapshot(`\n-       \"<Page>\n+      await expect(browser).toDisplayRedbox(`\n+       {\n+         \"componentStack\": \"<Page>\n            <div>\n              <div>\n        >       <p>\n-       >         <div>\"\n+       >         <div>\",\n+         \"count\": 3,\n+         \"description\": \"Expected server HTML to contain a matching <div> in <p>.\",\n+         \"environmentLabel\": null,\n+         \"label\": \"Unhandled Runtime Error\",\n+         \"source\": undefined,\n+         \"stack\": [],\n+       }\n       `)\n     } else {\n-      expect(pseudoHtml).toMatchInlineSnapshot(`\n-       \"...\n+      await expect(browser).toDisplayRedbox(`\n+       {\n+         \"componentStack\": \"...\n            <Container fn={function fn}>\n              <PagesDevOverlay>\n                <PagesDevOverlayErrorBoundary onError={function usePagesDevOverlay.useCallback[onComponentError]}>\n@@ -768,7 +758,15 @@ describe('Error overlay for hydration errors in Pages router', () => {\n        >                   <p>\n        >                     <div>\n                    ...\n-               ...\"\n+               ...\",\n+         \"count\": 1,\n+         \"description\": \"In HTML, <div> cannot be a descendant of <p>.\n+       This will cause a hydration error.\",\n+         \"environmentLabel\": null,\n+         \"label\": \"Unhandled Runtime Error\",\n+         \"source\": undefined,\n+         \"stack\": [],\n+       }\n       `)\n     }\n   })\n@@ -787,35 +785,30 @@ describe('Error overlay for hydration errors in Pages router', () => {\n         ],\n       ])\n     )\n-    const { session, browser } = sandbox\n-    await session.assertHasRedbox()\n+    const { browser } = sandbox\n+\n     await retry(async () => {\n       expect(await getRedboxTotalErrorCount(browser)).toBe(isReact18 ? 3 : 1)\n     })\n \n-    const description = await session.getRedboxDescription()\n     if (isReact18) {\n-      expect(description).toMatchInlineSnapshot(\n-        `\"Expected server HTML to contain a matching <tr> in <div>.\"`\n-      )\n-    } else {\n-      expect(description).toMatchInlineSnapshot(`\n-        \"In HTML, <tr> cannot be a child of <div>.\n-        This will cause a hydration error.\"\n-      `)\n-    }\n-\n-    const pseudoHtml = await session.getRedboxComponentStack()\n-\n-    if (isReact18) {\n-      expect(pseudoHtml).toMatchInlineSnapshot(`\n-       \"<Page>\n+      await expect(browser).toDisplayRedbox(`\n+       {\n+         \"componentStack\": \"<Page>\n        >   <div>\n-       >     <tr>\"\n+       >     <tr>\",\n+         \"count\": 3,\n+         \"description\": \"Expected server HTML to contain a matching <tr> in <div>.\",\n+         \"environmentLabel\": null,\n+         \"label\": \"Unhandled Runtime Error\",\n+         \"source\": undefined,\n+         \"stack\": [],\n+       }\n       `)\n     } else {\n-      expect(pseudoHtml).toMatchInlineSnapshot(`\n-       \"<Root callbacks={[...]}>\n+      await expect(browser).toDisplayRedbox(`\n+       {\n+         \"componentStack\": \"<Root callbacks={[...]}>\n            <Head>\n            <AppContainer>\n              <Container fn={function fn}>\n@@ -827,7 +820,15 @@ describe('Error overlay for hydration errors in Pages router', () => {\n        >                 <div>\n        >                   <tr>\n                      ...\n-                 ...\"\n+                 ...\",\n+         \"count\": 1,\n+         \"description\": \"In HTML, <tr> cannot be a child of <div>.\n+       This will cause a hydration error.\",\n+         \"environmentLabel\": null,\n+         \"label\": \"Unhandled Runtime Error\",\n+         \"source\": undefined,\n+         \"stack\": [],\n+       }\n       `)\n     }\n   })\n@@ -848,39 +849,34 @@ describe('Error overlay for hydration errors in Pages router', () => {\n         ],\n       ])\n     )\n-    const { session, browser } = sandbox\n-    await session.assertHasRedbox()\n+    const { browser } = sandbox\n+\n     await retry(async () => {\n       expect(await getRedboxTotalErrorCount(browser)).toBe(isReact18 ? 3 : 1)\n     })\n \n-    const description = await session.getRedboxDescription()\n-    if (isReact18) {\n-      expect(description).toMatchInlineSnapshot(\n-        `\"Expected server HTML to contain a matching <p> in <span>.\"`\n-      )\n-    } else {\n-      expect(description).toMatchInlineSnapshot(`\n-        \"In HTML, <p> cannot be a descendant of <p>.\n-        This will cause a hydration error.\"\n-      `)\n-    }\n-\n-    const pseudoHtml = await session.getRedboxComponentStack()\n-\n     if (isReact18) {\n-      expect(pseudoHtml).toMatchInlineSnapshot(`\n-       \"<Page>\n+      await expect(browser).toDisplayRedbox(`\n+       {\n+         \"componentStack\": \"<Page>\n            <p>\n              <span>\n                <span>\n                  <span>\n        >           <span>\n-       >             <p>\"\n+       >             <p>\",\n+         \"count\": 3,\n+         \"description\": \"Expected server HTML to contain a matching <p> in <span>.\",\n+         \"environmentLabel\": null,\n+         \"label\": \"Unhandled Runtime Error\",\n+         \"source\": undefined,\n+         \"stack\": [],\n+       }\n       `)\n     } else {\n-      expect(pseudoHtml).toMatchInlineSnapshot(`\n-       \"<Root callbacks={[...]}>\n+      await expect(browser).toDisplayRedbox(`\n+       {\n+         \"componentStack\": \"<Root callbacks={[...]}>\n            <Head>\n            <AppContainer>\n              <Container fn={function fn}>\n@@ -896,7 +892,15 @@ describe('Error overlay for hydration errors in Pages router', () => {\n                                  <span>\n        >                           <p>\n                      ...\n-                 ...\"\n+                 ...\",\n+         \"count\": 1,\n+         \"description\": \"In HTML, <p> cannot be a descendant of <p>.\n+       This will cause a hydration error.\",\n+         \"environmentLabel\": null,\n+         \"label\": \"Unhandled Runtime Error\",\n+         \"source\": undefined,\n+         \"stack\": [],\n+       }\n       `)\n     }\n   })"
        },
        {
            "sha": "124d37495a81d1b7bc231210583d678117d3eacf",
            "filename": "test/lib/add-redbox-matchers.ts",
            "status": "modified",
            "additions": 28,
            "deletions": 10,
            "changes": 38,
            "blob_url": "https://github.com/vercel/next.js/blob/d5cefb260671508391b0508b9187a79cb5b8a766/test%2Flib%2Fadd-redbox-matchers.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d5cefb260671508391b0508b9187a79cb5b8a766/test%2Flib%2Fadd-redbox-matchers.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Flib%2Fadd-redbox-matchers.ts?ref=d5cefb260671508391b0508b9187a79cb5b8a766",
            "patch": "@@ -3,6 +3,7 @@ import { toMatchInlineSnapshot } from 'jest-snapshot'\n import {\n   assertHasRedbox,\n   getRedboxCallStack,\n+  getRedboxComponentStack,\n   getRedboxDescription,\n   getRedboxEnvironmentLabel,\n   getRedboxSource,\n@@ -51,6 +52,7 @@ interface RedboxSnapshot {\n   environmentLabel: string\n   label: string\n   description: string\n+  componentStack?: string\n   source: string\n   stack: string[]\n   count: number\n@@ -59,15 +61,23 @@ interface RedboxSnapshot {\n async function createRedboxSnapshot(\n   browser: BrowserInterface\n ): Promise<RedboxSnapshot> {\n-  const [label, environmentLabel, description, source, stack, count] =\n-    await Promise.all([\n-      getRedboxLabel(browser),\n-      getRedboxEnvironmentLabel(browser),\n-      getRedboxDescription(browser),\n-      getRedboxSource(browser),\n-      getRedboxCallStack(browser),\n-      getRedboxTotalErrorCount(browser),\n-    ])\n+  const [\n+    label,\n+    environmentLabel,\n+    description,\n+    source,\n+    stack,\n+    componentStack,\n+    count,\n+  ] = await Promise.all([\n+    getRedboxLabel(browser),\n+    getRedboxEnvironmentLabel(browser),\n+    getRedboxDescription(browser),\n+    getRedboxSource(browser),\n+    getRedboxCallStack(browser),\n+    getRedboxComponentStack(browser),\n+    getRedboxTotalErrorCount(browser),\n+  ])\n \n   // We don't need to test the codeframe logic everywhere.\n   // Here we focus on the cursor position of the top most frame\n@@ -111,7 +121,7 @@ async function createRedboxSnapshot(\n     }\n   }\n \n-  return {\n+  const snapshot: RedboxSnapshot = {\n     environmentLabel,\n     label,\n     description,\n@@ -120,6 +130,14 @@ async function createRedboxSnapshot(\n     // TODO(newDevOverlay): Always return `count`. Normalizing currently to avoid assertion forks.\n     count: label === 'Build Error' && count === -1 ? 1 : count,\n   }\n+\n+  // Hydration diffs are only relevant to some specific errors\n+  // so we hide them from the snapshots unless they are present.\n+  if (componentStack !== null) {\n+    snapshot.componentStack = componentStack\n+  }\n+\n+  return snapshot\n }\n \n expect.extend({"
        }
    ],
    "stats": {
        "total": 656,
        "additions": 339,
        "deletions": 317
    }
}