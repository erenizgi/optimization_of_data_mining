{
    "author": "bgw",
    "message": "Turbopack: Share entrypoint template logic between Turbopack/webpack (#82385)\n\n## Goal\n\nWith three different bundlers, we're often forced to duplicate next.js-specific logic and configuration across two or three different bundlers.\n\nE.g. https://github.com/SyMind/next-rspack-binding/ would cause us to duplicate our current externals logic across all three.\n\nTo help, we'd like to have a shared crate that can be used in a few different ways:\n\n- Via turbopack (which is itself called through native napi bindings)\n- Via direct native napi bindings to JS for webpack\n- Via wasm bindings to JS for webpack [*(note: ideally these would be replaced with napi's recent wasm support, but it doesn't make sense to do that until after the napi v3 migration is done)*](https://napi.rs/blog/announce-v3#webassembly)\n- Via Rspack (we'd build a custom binary)\n\nThe wasm bindings (in their current state) and Rspack cannot (or should not) depend on `turbo-tasks`. However, all of the current `next-*` crates depend on `turbo-tasks`.\n\nThis introduces a `next-taskless` crate for code that can be isolated from performing IO and that does not need to depend on `turbo-tasks`. Code in this crate can be used from wasm or Rspack.\n\n## This PR\n\nAs a proof-of-concept, this deduplicates our next.js entrypoint templating logic across webpack and Turbopack. It's a large function that doesn't need to directly depend on file IO.\n\nSome path manipulation had to be moved out of `turbo-tasks-fs` to support this, so that code is in `turbo-unix-path`.\n\nI'm happy to accept different bikeshedded crate names.\n\n## Testing\n\nTested wasm with:\n\n```\npnpm i\npnpm swc-build-wasm --target nodejs\npnpm build\nNODE_TEST_MODE=start NEXT_TEST_WASM=true NEXT_SKIP_NATIVE_POSTINSTALL=1 NEXT_TEST_PREFER_OFFLINE=1 node run-tests.js test/production/pages-dir/production/test/index.test.ts\n```\n\nTested turbopack with:\n\n```\npnpm i\npnpm swc-build-native\npnpm build\npnpm test-start-turbo test/production/pages-dir/production/test/index.test.ts\n```\n\nTested webpack with:\n\n```\npnpm i\npnpm swc-build-native\npnpm build\npnpm test-start test/production/pages-dir/production/test/index.test.ts\n```",
    "sha": "4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f",
    "files": [
        {
            "sha": "906b1ae992c702bbf2f904bc5d05706c9b8f8e75",
            "filename": "Cargo.lock",
            "status": "modified",
            "additions": 26,
            "deletions": 0,
            "changes": 26,
            "blob_url": "https://github.com/vercel/next.js/blob/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/Cargo.lock",
            "raw_url": "https://github.com/vercel/next.js/raw/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/Cargo.lock",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/Cargo.lock?ref=4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f",
            "patch": "@@ -4280,6 +4280,7 @@ dependencies = [\n  \"turbo-tasks-env\",\n  \"turbo-tasks-fs\",\n  \"turbo-tasks-malloc\",\n+ \"turbo-unix-path\",\n  \"turbopack\",\n  \"turbopack-browser\",\n  \"turbopack-core\",\n@@ -4340,6 +4341,7 @@ dependencies = [\n  \"mime_guess\",\n  \"modularize_imports\",\n  \"next-custom-transforms\",\n+ \"next-taskless\",\n  \"once_cell\",\n  \"percent-encoding\",\n  \"qstring\",\n@@ -4431,6 +4433,7 @@ dependencies = [\n  \"next-build\",\n  \"next-core\",\n  \"next-custom-transforms\",\n+ \"next-taskless\",\n  \"once_cell\",\n  \"owo-colors 3.5.0\",\n  \"rand 0.9.0\",\n@@ -4450,6 +4453,7 @@ dependencies = [\n  \"turbo-tasks-build\",\n  \"turbo-tasks-fs\",\n  \"turbo-tasks-malloc\",\n+ \"turbo-unix-path\",\n  \"turbopack-core\",\n  \"turbopack-ecmascript-hmr-protocol\",\n  \"turbopack-ecmascript-plugins\",\n@@ -4460,6 +4464,16 @@ dependencies = [\n  \"vergen-gitcl\",\n ]\n \n+[[package]]\n+name = \"next-taskless\"\n+version = \"0.0.1\"\n+dependencies = [\n+ \"anyhow\",\n+ \"regex\",\n+ \"serde_json\",\n+ \"turbo-unix-path\",\n+]\n+\n [[package]]\n name = \"nix\"\n version = \"0.26.4\"\n@@ -9372,6 +9386,7 @@ dependencies = [\n  \"turbo-tasks-build\",\n  \"turbo-tasks-hash\",\n  \"turbo-tasks-testing\",\n+ \"turbo-unix-path\",\n  \"urlencoding\",\n ]\n \n@@ -9455,6 +9470,13 @@ dependencies = [\n  \"turbo-tasks\",\n ]\n \n+[[package]]\n+name = \"turbo-unix-path\"\n+version = \"0.0.1\"\n+dependencies = [\n+ \"rstest\",\n+]\n+\n [[package]]\n name = \"turbopack\"\n version = \"0.1.0\"\n@@ -9638,6 +9660,7 @@ dependencies = [\n  \"turbo-tasks-fs\",\n  \"turbo-tasks-hash\",\n  \"turbo-tasks-testing\",\n+ \"turbo-unix-path\",\n  \"urlencoding\",\n ]\n \n@@ -10011,6 +10034,7 @@ dependencies = [\n  \"turbo-tasks-bytes\",\n  \"turbo-tasks-env\",\n  \"turbo-tasks-fs\",\n+ \"turbo-unix-path\",\n  \"turbopack\",\n  \"turbopack-browser\",\n  \"turbopack-core\",\n@@ -10567,6 +10591,8 @@ dependencies = [\n  \"js-sys\",\n  \"mdxjs\",\n  \"next-custom-transforms\",\n+ \"next-taskless\",\n+ \"rustc-hash 2.1.1\",\n  \"serde-wasm-bindgen 0.4.5\",\n  \"serde_json\",\n  \"swc_core\","
        },
        {
            "sha": "f599d4285db99bddac3dc6e603012ae02d7660be",
            "filename": "Cargo.toml",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/Cargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/Cargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/Cargo.toml?ref=4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f",
            "patch": "@@ -10,6 +10,7 @@ members = [\n   \"crates/next-build\",\n   \"crates/next-core\",\n   \"crates/next-custom-transforms\",\n+  \"crates/next-taskless\",\n   \"turbopack/crates/*\",\n   \"turbopack/crates/*/fuzz\",\n   \"turbopack/xtask\",\n@@ -252,6 +253,7 @@ next-api = { path = \"crates/next-api\" }\n next-build = { path = \"crates/next-build\" }\n next-core = { path = \"crates/next-core\" }\n next-custom-transforms = { path = \"crates/next-custom-transforms\" }\n+next-taskless = { path = \"crates/next-taskless\" }\n \n # Turbopack\n auto-hash-map = { path = \"turbopack/crates/turbo-tasks-auto-hash-map\" }\n@@ -260,6 +262,7 @@ turbo-rcstr = { path = \"turbopack/crates/turbo-rcstr\" }\n turbo-dyn-eq-hash = { path = \"turbopack/crates/turbo-dyn-eq-hash\" }\n turbo-esregex = { path = \"turbopack/crates/turbo-esregex\" }\n turbo-persistence = { path = \"turbopack/crates/turbo-persistence\" }\n+turbo-unix-path = { path = \"turbopack/crates/turbo-unix-path\" }\n turbo-tasks-malloc = { path = \"turbopack/crates/turbo-tasks-malloc\", default-features = false }\n turbo-tasks = { path = \"turbopack/crates/turbo-tasks\" }\n turbo-tasks-backend = { path = \"turbopack/crates/turbo-tasks-backend\" }"
        },
        {
            "sha": "9251ebd6b5c23965799bcf6e007140646b351887",
            "filename": "crates/napi/Cargo.toml",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/crates%2Fnapi%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/crates%2Fnapi%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnapi%2FCargo.toml?ref=4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f",
            "patch": "@@ -64,6 +64,7 @@ owo-colors = { workspace = true }\n napi = { workspace = true }\n napi-derive = \"2\"\n next-custom-transforms = { workspace = true }\n+next-taskless = { workspace = true }\n rand = { workspace = true }\n rustc-hash = { workspace = true }\n serde = \"1\"\n@@ -105,6 +106,7 @@ turbo-rcstr = { workspace = true, features = [\"napi\"] }\n turbo-tasks = { workspace = true }\n turbo-tasks-backend = { workspace = true }\n turbo-tasks-fs = { workspace = true }\n+turbo-unix-path = { workspace = true }\n next-api = { workspace = true }\n next-build = { workspace = true }\n next-core = { workspace = true }"
        },
        {
            "sha": "11a90598997503c765f3b2ef469bbd53a9ea4833",
            "filename": "crates/napi/src/next_api/project.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs?ref=4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f",
            "patch": "@@ -39,9 +39,9 @@ use turbo_tasks::{\n };\n use turbo_tasks_backend::{BackingStorage, db_invalidation::invalidation_reasons};\n use turbo_tasks_fs::{\n-    DiskFileSystem, FileContent, FileSystem, FileSystemPath, get_relative_path_to,\n-    util::uri_from_file,\n+    DiskFileSystem, FileContent, FileSystem, FileSystemPath, util::uri_from_file,\n };\n+use turbo_unix_path::get_relative_path_to;\n use turbopack_core::{\n     PROJECT_FILESYSTEM_NAME, SOURCE_URL_PROTOCOL,\n     diagnostics::PlainDiagnostic,"
        },
        {
            "sha": "e48bf12ddc9014d993876fe8c6b348520ec59416",
            "filename": "crates/napi/src/next_api/utils.rs",
            "status": "modified",
            "additions": 23,
            "deletions": 1,
            "changes": 24,
            "blob_url": "https://github.com/vercel/next.js/blob/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/crates%2Fnapi%2Fsrc%2Fnext_api%2Futils.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/crates%2Fnapi%2Fsrc%2Fnext_api%2Futils.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnapi%2Fsrc%2Fnext_api%2Futils.rs?ref=4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f",
            "patch": "@@ -4,7 +4,7 @@ use anyhow::{Context, Result, anyhow};\n use futures_util::TryFutureExt;\n use napi::{\n     JsFunction, JsObject, JsUnknown, NapiRaw, NapiValue, Status,\n-    bindgen_prelude::{External, ToNapiValue},\n+    bindgen_prelude::{Buffer, External, ToNapiValue},\n     threadsafe_function::{ThreadSafeCallContext, ThreadsafeFunction, ThreadsafeFunctionCallMode},\n };\n use rustc_hash::FxHashMap;\n@@ -380,3 +380,25 @@ pub async fn strongly_consistent_catch_collectables<R: VcValueType + Send>(\n \n     Ok((result, issues, diagnostics, effects))\n }\n+\n+#[napi]\n+pub fn expand_next_js_template(\n+    content: Buffer,\n+    template_path: String,\n+    next_package_dir_path: String,\n+    #[napi(ts_arg_type = \"Record<string, string>\")] replacements: FxHashMap<String, String>,\n+    #[napi(ts_arg_type = \"Record<string, string>\")] injections: FxHashMap<String, String>,\n+    #[napi(ts_arg_type = \"Record<string, string | null>\")] imports: FxHashMap<\n+        String,\n+        Option<String>,\n+    >,\n+) -> napi::Result<String> {\n+    Ok(next_taskless::expand_next_js_template(\n+        str::from_utf8(&content).context(\"template content must be valid utf-8\")?,\n+        &template_path,\n+        &next_package_dir_path,\n+        replacements.iter().map(|(k, v)| (&**k, &**v)),\n+        injections.iter().map(|(k, v)| (&**k, &**v)),\n+        imports.iter().map(|(k, v)| (&**k, v.as_deref())),\n+    )?)\n+}"
        },
        {
            "sha": "c7252a901e90e87d87f6b3afeece072694a4494b",
            "filename": "crates/next-api/Cargo.toml",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/crates%2Fnext-api%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/crates%2Fnext-api%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2FCargo.toml?ref=4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f",
            "patch": "@@ -33,6 +33,7 @@ turbo-rcstr = { workspace = true }\n turbo-tasks = { workspace = true, features = [\"non_operation_vc_strongly_consistent\"] }\n turbo-tasks-env = { workspace = true }\n turbo-tasks-fs = { workspace = true }\n+turbo-unix-path = { workspace = true }\n turbopack = { workspace = true }\n turbopack-browser = { workspace = true }\n turbopack-core = { workspace = true }"
        },
        {
            "sha": "156976a48785bc5a3f639b625b46f382d38a90c1",
            "filename": "crates/next-api/src/project.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 4,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fproject.rs?ref=4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f",
            "patch": "@@ -36,10 +36,8 @@ use turbo_tasks::{\n     trace::TraceRawVcs,\n };\n use turbo_tasks_env::{EnvMap, ProcessEnv};\n-use turbo_tasks_fs::{\n-    DiskFileSystem, FileSystem, FileSystemPath, VirtualFileSystem, invalidation,\n-    util::{join_path, unix_to_sys},\n-};\n+use turbo_tasks_fs::{DiskFileSystem, FileSystem, FileSystemPath, VirtualFileSystem, invalidation};\n+use turbo_unix_path::{join_path, unix_to_sys};\n use turbopack::{\n     ModuleAssetContext, evaluate_context::node_build_environment,\n     global_module_ids::get_global_module_id_strategy, transition::TransitionOptions,"
        },
        {
            "sha": "4259bcda777477bc78c6d0083d90c41f4c43abfe",
            "filename": "crates/next-core/Cargo.toml",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/crates%2Fnext-core%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/crates%2Fnext-core%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2FCargo.toml?ref=4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f",
            "patch": "@@ -16,7 +16,6 @@ anyhow = { workspace = true }\n async-trait = { workspace = true }\n base64 = \"0.21.0\"\n either = { workspace = true }\n-next-custom-transforms = { workspace = true }\n once_cell = { workspace = true }\n qstring = { workspace = true }\n regex = { workspace = true }\n@@ -55,6 +54,9 @@ swc_core = { workspace = true, features = [\n ] }\n modularize_imports = { workspace = true }\n \n+next-custom-transforms = { workspace = true }\n+next-taskless = { workspace = true }\n+\n turbo-rcstr = { workspace = true }\n turbo-esregex = { workspace = true }\n turbo-tasks = { workspace = true }"
        },
        {
            "sha": "fa505c10a8ce2e58c7aea816c37ccb7ed2a6b0f3",
            "filename": "crates/next-core/src/middleware.rs",
            "status": "modified",
            "additions": 9,
            "deletions": 9,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/crates%2Fnext-core%2Fsrc%2Fmiddleware.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/crates%2Fnext-core%2Fsrc%2Fmiddleware.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fmiddleware.rs?ref=4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f",
            "patch": "@@ -1,6 +1,6 @@\n use anyhow::Result;\n use turbo_rcstr::{RcStr, rcstr};\n-use turbo_tasks::{FxIndexMap, ResolvedVc, Vc, fxindexmap};\n+use turbo_tasks::{ResolvedVc, Vc, fxindexmap};\n use turbo_tasks_fs::FileSystemPath;\n use turbopack_core::{context::AssetContext, module::Module, reference_type::ReferenceType};\n \n@@ -27,23 +27,23 @@ pub async fn get_middleware_module(\n     project_root: FileSystemPath,\n     userland_module: ResolvedVc<Box<dyn Module>>,\n ) -> Result<Vc<Box<dyn Module>>> {\n-    let inner = rcstr!(\"INNER_MIDDLEWARE_MODULE\");\n+    const INNER: &str = \"INNER_MIDDLEWARE_MODULE\";\n \n     // Load the file from the next.js codebase.\n     let source = load_next_js_template(\n         \"middleware.js\",\n         project_root,\n-        fxindexmap! {\n-            \"VAR_USERLAND\" => inner.clone(),\n-            \"VAR_DEFINITION_PAGE\" => rcstr!(\"/middleware\"),\n-        },\n-        FxIndexMap::default(),\n-        FxIndexMap::default(),\n+        &[\n+            (\"VAR_USERLAND\", INNER),\n+            (\"VAR_DEFINITION_PAGE\", \"/middleware\"),\n+        ],\n+        &[],\n+        &[],\n     )\n     .await?;\n \n     let inner_assets = fxindexmap! {\n-        inner => userland_module\n+        rcstr!(INNER) => userland_module\n     };\n \n     let module = asset_context"
        },
        {
            "sha": "89089e781133178fcb9390007236b581d95ebe56",
            "filename": "crates/next-core/src/next_app/app_page_entry.rs",
            "status": "modified",
            "additions": 25,
            "deletions": 27,
            "changes": 52,
            "blob_url": "https://github.com/vercel/next.js/blob/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fapp_page_entry.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fapp_page_entry.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fapp_page_entry.rs?ref=4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f",
            "patch": "@@ -1,7 +1,7 @@\n use std::io::Write;\n \n use anyhow::Result;\n-use turbo_rcstr::{RcStr, rcstr};\n+use turbo_rcstr::RcStr;\n use turbo_tasks::{ResolvedVc, TryJoinIterExt, Vc, fxindexmap};\n use turbo_tasks_fs::{self, File, FileSystemPath, rope::RopeBuilder};\n use turbopack::ModuleAssetContext;\n@@ -86,22 +86,25 @@ pub async fn get_app_page_entry(\n     let source = load_next_js_template(\n         \"app-page.js\",\n         project_root.clone(),\n-        fxindexmap! {\n-            \"VAR_DEFINITION_PAGE\" => page.to_string().into(),\n-            \"VAR_DEFINITION_PATHNAME\" => pathname.clone(),\n-            \"VAR_MODULE_GLOBAL_ERROR\" => if inner_assets.contains_key(GLOBAL_ERROR) {\n-                GLOBAL_ERROR.into()\n-             } else {\n-                rcstr!(\"next/dist/client/components/builtin/global-error\")\n-            },\n-        },\n-        fxindexmap! {\n-            \"tree\" => loader_tree_code,\n-            \"pages\" => StringifyJs(&pages).to_string().into(),\n-            \"__next_app_require__\" => TURBOPACK_REQUIRE.bound().into(),\n-            \"__next_app_load_chunk__\" => TURBOPACK_LOAD.bound().into(),\n-        },\n-        fxindexmap! {},\n+        &[\n+            (\"VAR_DEFINITION_PAGE\", &*page.to_string()),\n+            (\"VAR_DEFINITION_PATHNAME\", &pathname),\n+            (\n+                \"VAR_MODULE_GLOBAL_ERROR\",\n+                if inner_assets.contains_key(GLOBAL_ERROR) {\n+                    GLOBAL_ERROR\n+                } else {\n+                    \"next/dist/client/components/builtin/global-error\"\n+                },\n+            ),\n+        ],\n+        &[\n+            (\"tree\", &*loader_tree_code),\n+            (\"pages\", &StringifyJs(&pages).to_string()),\n+            (\"__next_app_require__\", &TURBOPACK_REQUIRE.bound()),\n+            (\"__next_app_load_chunk__\", &TURBOPACK_LOAD.bound()),\n+        ],\n+        &[],\n     )\n     .await?;\n \n@@ -158,18 +161,13 @@ async fn wrap_edge_page(\n     let source = load_next_js_template(\n         \"edge-ssr-app.js\",\n         project_root.clone(),\n-        fxindexmap! {\n-            \"VAR_USERLAND\" => INNER.into(),\n-            \"VAR_PAGE\" => page.to_string().into(),\n-        },\n-        fxindexmap! {\n+        &[(\"VAR_USERLAND\", INNER), (\"VAR_PAGE\", &page.to_string())],\n+        &[\n             // TODO do we really need to pass the entire next config here?\n             // This is bad for invalidation as any config change will invalidate this\n-            \"nextConfig\" => serde_json::to_string(next_config_val)?.into(),\n-        },\n-        fxindexmap! {\n-            \"incrementalCacheHandler\" => None,\n-        },\n+            (\"nextConfig\", &*serde_json::to_string(next_config_val)?),\n+        ],\n+        &[(\"incrementalCacheHandler\", None)],\n     )\n     .await?;\n "
        },
        {
            "sha": "c81dffe28a76341aa383409312d593b40a8c81f8",
            "filename": "crates/next-core/src/next_app/app_route_entry.rs",
            "status": "modified",
            "additions": 17,
            "deletions": 24,
            "changes": 41,
            "blob_url": "https://github.com/vercel/next.js/blob/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fapp_route_entry.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fapp_route_entry.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fapp_route_entry.rs?ref=4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f",
            "patch": "@@ -59,33 +59,31 @@ pub async fn get_app_route_entry(\n \n     let inner = rcstr!(\"INNER_APP_ROUTE\");\n \n-    let output_type: RcStr = next_config\n+    let output_type: &str = next_config\n         .await?\n         .output\n         .as_ref()\n         .map(|o| match o {\n-            OutputType::Standalone => rcstr!(\"\\\"standalone\\\"\"),\n-            OutputType::Export => rcstr!(\"\\\"export\\\"\"),\n+            OutputType::Standalone => \"\\\"standalone\\\"\",\n+            OutputType::Export => \"\\\"export\\\"\",\n         })\n-        .unwrap_or(rcstr!(\"\\\"\\\"\"));\n+        .unwrap_or(\"\\\"\\\"\");\n \n     // Load the file from the next.js codebase.\n     let virtual_source = load_next_js_template(\n         \"app-route.js\",\n         project_root.clone(),\n-        fxindexmap! {\n-            \"VAR_DEFINITION_PAGE\" => page.to_string().into(),\n-            \"VAR_DEFINITION_PATHNAME\" => pathname.clone(),\n-            \"VAR_DEFINITION_FILENAME\" => path.file_stem().unwrap().into(),\n+        &[\n+            (\"VAR_DEFINITION_PAGE\", &*page.to_string()),\n+            (\"VAR_DEFINITION_PATHNAME\", &pathname),\n+            (\"VAR_DEFINITION_FILENAME\", path.file_stem().unwrap()),\n             // TODO(alexkirsz) Is this necessary?\n-            \"VAR_DEFINITION_BUNDLE_PATH\" => \"\".to_string().into(),\n-            \"VAR_RESOLVED_PAGE_PATH\" => path.value_to_string().owned().await?,\n-            \"VAR_USERLAND\" => inner.clone(),\n-        },\n-        fxindexmap! {\n-            \"nextConfigOutput\" => output_type\n-        },\n-        fxindexmap! {},\n+            (\"VAR_DEFINITION_BUNDLE_PATH\", \"\"),\n+            (\"VAR_RESOLVED_PAGE_PATH\", &path.value_to_string().await?),\n+            (\"VAR_USERLAND\", &inner),\n+        ],\n+        &[(\"nextConfigOutput\", output_type)],\n+        &[],\n     )\n     .await?;\n \n@@ -143,14 +141,9 @@ async fn wrap_edge_route(\n     let source = load_next_js_template(\n         \"edge-app-route.js\",\n         project_root.clone(),\n-        fxindexmap! {\n-            \"VAR_USERLAND\" => inner.clone(),\n-            \"VAR_PAGE\" => page.to_string().into(),\n-        },\n-        fxindexmap! {\n-            \"nextConfig\" => serde_json::to_string(next_config)?.into(),\n-        },\n-        fxindexmap! {},\n+        &[(\"VAR_USERLAND\", &*inner), (\"VAR_PAGE\", &page.to_string())],\n+        &[(\"nextConfig\", &*serde_json::to_string(next_config)?)],\n+        &[],\n     )\n     .await?;\n "
        },
        {
            "sha": "cbc79537c130069b42ab9b6a7165796191cf50a7",
            "filename": "crates/next-core/src/next_pages/page_entry.rs",
            "status": "modified",
            "additions": 42,
            "deletions": 33,
            "changes": 75,
            "blob_url": "https://github.com/vercel/next.js/blob/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/crates%2Fnext-core%2Fsrc%2Fnext_pages%2Fpage_entry.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/crates%2Fnext-core%2Fsrc%2Fnext_pages%2Fpage_entry.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_pages%2Fpage_entry.rs?ref=4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f",
            "patch": "@@ -3,7 +3,7 @@ use std::io::Write;\n use anyhow::{Result, bail};\n use serde::Serialize;\n use turbo_rcstr::{RcStr, rcstr};\n-use turbo_tasks::{FxIndexMap, ResolvedVc, Vc, fxindexmap};\n+use turbo_tasks::{ResolvedVc, Vc, fxindexmap};\n use turbo_tasks_fs::{File, FileSystemPath, rope::RopeBuilder};\n use turbopack_core::{\n     asset::{Asset, AssetContent},\n@@ -71,26 +71,20 @@ pub async fn create_page_ssr_entry_module(\n     let inner_document = rcstr!(\"INNER_DOCUMENT\");\n     let inner_app = rcstr!(\"INNER_APP\");\n \n-    let mut replacements = fxindexmap! {\n-        \"VAR_DEFINITION_PAGE\" => definition_page.clone(),\n-        \"VAR_DEFINITION_PATHNAME\" => definition_pathname.clone(),\n-        \"VAR_USERLAND\" => inner.clone(),\n-    };\n+    let mut replacements = vec![\n+        (\"VAR_DEFINITION_PAGE\", &*definition_page),\n+        (\"VAR_DEFINITION_PATHNAME\", &definition_pathname),\n+        (\"VAR_USERLAND\", &inner),\n+    ];\n \n     if reference_type == ReferenceType::Entry(EntryReferenceSubType::Page) {\n-        replacements.insert(\"VAR_MODULE_DOCUMENT\", inner_document.clone());\n-        replacements.insert(\"VAR_MODULE_APP\", inner_app.clone());\n+        replacements.push((\"VAR_MODULE_DOCUMENT\", &inner_document));\n+        replacements.push((\"VAR_MODULE_APP\", &inner_app));\n     }\n \n     // Load the file from the next.js codebase.\n-    let mut source = load_next_js_template(\n-        template_file,\n-        project_root.clone(),\n-        replacements,\n-        FxIndexMap::default(),\n-        FxIndexMap::default(),\n-    )\n-    .await?;\n+    let mut source =\n+        load_next_js_template(template_file, project_root.clone(), &replacements, &[], &[]).await?;\n \n     // When we're building the instrumentation page (only when the\n     // instrumentation file conflicts with a page also labeled\n@@ -215,26 +209,41 @@ async fn wrap_edge_page(\n     let source = load_next_js_template(\n         \"edge-ssr.js\",\n         project_root.clone(),\n-        fxindexmap! {\n-            \"VAR_USERLAND\" => INNER.into(),\n-            \"VAR_PAGE\" => pathname.clone(),\n-            \"VAR_MODULE_DOCUMENT\" => INNER_DOCUMENT.into(),\n-            \"VAR_MODULE_APP\" => INNER_APP.into(),\n-            \"VAR_MODULE_GLOBAL_ERROR\" => INNER_ERROR.into(),\n-        },\n-        fxindexmap! {\n+        &[\n+            (\"VAR_USERLAND\", INNER),\n+            (\"VAR_PAGE\", &pathname),\n+            (\"VAR_MODULE_DOCUMENT\", INNER_DOCUMENT),\n+            (\"VAR_MODULE_APP\", INNER_APP),\n+            (\"VAR_MODULE_GLOBAL_ERROR\", INNER_ERROR),\n+        ],\n+        &[\n             // TODO do we really need to pass the entire next config here?\n             // This is bad for invalidation as any config change will invalidate this\n-            \"nextConfig\" => serde_json::to_string(next_config_val)?.into(),\n-            \"pageRouteModuleOptions\" => serde_json::to_string(&get_route_module_options(page.clone(), pathname.clone()))?.into(),\n-            \"errorRouteModuleOptions\" => serde_json::to_string(&get_route_module_options(rcstr!(\"/_error\"), rcstr!(\"/_error\")))?.into(),\n-            \"user500RouteModuleOptions\" => serde_json::to_string(&get_route_module_options(rcstr!(\"/500\"), rcstr!(\"/500\")))?.into(),\n-        },\n-        fxindexmap! {\n+            (\"nextConfig\", &*serde_json::to_string(next_config_val)?),\n+            (\n+                \"pageRouteModuleOptions\",\n+                &serde_json::to_string(&get_route_module_options(page.clone(), pathname.clone()))?,\n+            ),\n+            (\n+                \"errorRouteModuleOptions\",\n+                &serde_json::to_string(&get_route_module_options(\n+                    rcstr!(\"/_error\"),\n+                    rcstr!(\"/_error\"),\n+                ))?,\n+            ),\n+            (\n+                \"user500RouteModuleOptions\",\n+                &serde_json::to_string(&get_route_module_options(rcstr!(\"/500\"), rcstr!(\"/500\")))?,\n+            ),\n+        ],\n+        &[\n             // TODO\n-            \"incrementalCacheHandler\" => None,\n-            \"userland500Page\" => pages_structure.await?.error_500.map(|_| INNER_ERROR_500.into()),\n-        },\n+            (\"incrementalCacheHandler\", None),\n+            (\n+                \"userland500Page\",\n+                pages_structure.await?.error_500.map(|_| INNER_ERROR_500),\n+            ),\n+        ],\n     )\n     .await?;\n "
        },
        {
            "sha": "a96cd87b550d20e90ac996f90d22a74857aa7036",
            "filename": "crates/next-core/src/util.rs",
            "status": "modified",
            "additions": 25,
            "deletions": 245,
            "changes": 270,
            "blob_url": "https://github.com/vercel/next.js/blob/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/crates%2Fnext-core%2Fsrc%2Futil.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/crates%2Fnext-core%2Fsrc%2Futil.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Futil.rs?ref=4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f",
            "patch": "@@ -1,20 +1,20 @@\n-use std::{str::FromStr, sync::LazyLock};\n+use std::{future::Future, str::FromStr};\n \n-use anyhow::{Context, Result, bail};\n-use regex::Regex;\n+use anyhow::{Result, bail};\n+use next_taskless::expand_next_js_template;\n use serde::{Deserialize, Serialize, de::DeserializeOwned};\n use swc_core::{\n     common::{GLOBALS, Spanned, source_map::SmallPos},\n     ecma::ast::{Expr, Lit, Program},\n };\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{\n-    FxIndexMap, FxIndexSet, NonLocalValue, ResolvedVc, TaskInput, ValueDefault, Vc,\n-    trace::TraceRawVcs, util::WrapFuture,\n+    FxIndexMap, NonLocalValue, ResolvedVc, TaskInput, ValueDefault, Vc, trace::TraceRawVcs,\n+    util::WrapFuture,\n };\n use turbo_tasks_fs::{\n     self, File, FileContent, FileSystem, FileSystemPath, json::parse_json_rope_with_source_context,\n-    rope::Rope, util::join_path,\n+    rope::Rope,\n };\n use turbopack_core::{\n     asset::AssetContent,\n@@ -32,7 +32,6 @@ use turbopack_ecmascript::{\n     EcmascriptParsable,\n     analyzer::{ConstantValue, JsValue, ObjectPart},\n     parse::ParseResult,\n-    utils::StringifyJs,\n };\n \n use crate::{\n@@ -725,250 +724,31 @@ async fn parse_config_from_js_value(\n /// Loads a next.js template, replaces `replacements` and `injections` and makes\n /// sure there are none left over.\n pub async fn load_next_js_template(\n-    path: &str,\n+    template_path: &str,\n     project_path: FileSystemPath,\n-    replacements: FxIndexMap<&'static str, RcStr>,\n-    injections: FxIndexMap<&'static str, RcStr>,\n-    imports: FxIndexMap<&'static str, Option<RcStr>>,\n+    replacements: &[(&str, &str)],\n+    injections: &[(&str, &str)],\n+    imports: &[(&str, Option<&str>)],\n ) -> Result<Vc<Box<dyn Source>>> {\n-    let path = virtual_next_js_template_path(project_path.clone(), path.to_string()).await?;\n-\n-    let content = &*file_content_rope(path.read()).await?;\n-    let content = content.to_str()?.into_owned();\n-\n-    let parent_path = path.parent();\n-    let parent_path_value = parent_path.clone();\n-\n-    let package_root = get_next_package(project_path).await?.parent();\n-    let package_root_value = package_root.clone();\n-\n-    /// See [regex::Regex::replace_all].\n-    fn replace_all<E>(\n-        re: &regex::Regex,\n-        haystack: &str,\n-        mut replacement: impl FnMut(&regex::Captures) -> Result<String, E>,\n-    ) -> Result<String, E> {\n-        let mut new = String::with_capacity(haystack.len());\n-        let mut last_match = 0;\n-        for caps in re.captures_iter(haystack) {\n-            let m = caps.get(0).unwrap();\n-            new.push_str(&haystack[last_match..m.start()]);\n-            new.push_str(&replacement(&caps)?);\n-            last_match = m.end();\n-        }\n-        new.push_str(&haystack[last_match..]);\n-        Ok(new)\n-    }\n-\n-    // Update the relative imports to be absolute. This will update any relative\n-    // imports to be relative to the root of the `next` package.\n-    static IMPORT_PATH_RE: LazyLock<Regex> =\n-        LazyLock::new(|| Regex::new(\"(?:from '(\\\\..*)'|import '(\\\\..*)')\").unwrap());\n-\n-    let mut count = 0;\n-    let mut content = replace_all(&IMPORT_PATH_RE, &content, |caps| {\n-        let from_request = caps.get(1).map_or(\"\", |c| c.as_str());\n-        let import_request = caps.get(2).map_or(\"\", |c| c.as_str());\n-\n-        count += 1;\n-        let is_from_request = !from_request.is_empty();\n-\n-        let imported = FileSystemPath {\n-            fs: package_root_value.fs,\n-            path: join_path(\n-                &parent_path_value.path,\n-                if is_from_request {\n-                    from_request\n-                } else {\n-                    import_request\n-                },\n-            )\n-            .context(\"path should not leave the fs\")?\n-            .into(),\n-        };\n-\n-        let relative = package_root_value\n-            .get_relative_path_to(&imported)\n-            .context(\"path has to be relative to package root\")?;\n-\n-        if !relative.starts_with(\"./next/\") {\n-            bail!(\n-                \"Invariant: Expected relative import to start with \\\"./next/\\\", found \\\"{}\\\"\",\n-                relative\n-            )\n-        }\n+    let template_path = virtual_next_js_template_path(project_path.clone(), template_path).await?;\n \n-        let relative = relative\n-            .strip_prefix(\"./\")\n-            .context(\"should be able to strip the prefix\")?;\n-\n-        Ok(if is_from_request {\n-            format!(\"from {}\", StringifyJs(relative))\n-        } else {\n-            format!(\"import {}\", StringifyJs(relative))\n-        })\n-    })\n-    .context(\"replacing imports failed\")?;\n-\n-    // Verify that at least one import was replaced. It's the case today where\n-    // every template file has at least one import to update, so this ensures that\n-    // we don't accidentally remove the import replacement code or use the wrong\n-    // template file.\n-    if count == 0 {\n-        bail!(\"Invariant: Expected to replace at least one import\")\n-    }\n-\n-    // Replace all the template variables with the actual values. If a template\n-    // variable is missing, throw an error.\n-    let mut replaced = FxIndexSet::default();\n-    for (key, replacement) in &replacements {\n-        let full = format!(\"'{key}'\");\n-\n-        if content.contains(&full) {\n-            replaced.insert(*key);\n-            content = content.replace(&full, &StringifyJs(&replacement).to_string());\n-        }\n-    }\n+    let content = file_content_rope(template_path.read()).await?;\n+    let content = content.to_str()?;\n \n-    // Check to see if there's any remaining template variables.\n-    static TEMPLATE_VAR_RE: LazyLock<Regex> = LazyLock::new(|| Regex::new(\"VAR_[A-Z_]+\").unwrap());\n-    let mut matches = TEMPLATE_VAR_RE.find_iter(&content).peekable();\n-\n-    if matches.peek().is_some() {\n-        bail!(\n-            \"Invariant: Expected to replace all template variables, found {}\",\n-            matches.map(|m| m.as_str()).collect::<Vec<_>>().join(\", \"),\n-        )\n-    }\n-\n-    // Check to see if any template variable was provided but not used.\n-    if replaced.len() != replacements.len() {\n-        // Find the difference between the provided replacements and the replaced\n-        // template variables. This will let us notify the user of any template\n-        // variables that were not used but were provided.\n-        let difference = replacements\n-            .keys()\n-            .filter(|k| !replaced.contains(*k))\n-            .copied()\n-            .collect::<Vec<_>>();\n-\n-        bail!(\n-            \"Invariant: Expected to replace all template variables, missing {} in template\",\n-            difference.join(\", \"),\n-        )\n-    }\n-\n-    // Replace the injections.\n-    let mut injected = FxIndexSet::default();\n-    for (key, injection) in &injections {\n-        let full = format!(\"// INJECT:{key}\");\n-\n-        if content.contains(&full) {\n-            // Track all the injections to ensure that we're not missing any.\n-            injected.insert(*key);\n-            content = content.replace(&full, &format!(\"const {key} = {injection}\"));\n-        }\n-    }\n+    let package_root = &*get_next_package(project_path).await?;\n \n-    // Check to see if there's any remaining injections.\n-    static INJECT_RE: LazyLock<Regex> =\n-        LazyLock::new(|| Regex::new(\"// INJECT:[A-Za-z0-9_]+\").unwrap());\n-    let mut matches = INJECT_RE.find_iter(&content).peekable();\n-\n-    if matches.peek().is_some() {\n-        bail!(\n-            \"Invariant: Expected to inject all injections, found {}\",\n-            matches.map(|m| m.as_str()).collect::<Vec<_>>().join(\", \"),\n-        )\n-    }\n-\n-    // Check to see if any injection was provided but not used.\n-    if injected.len() != injections.len() {\n-        // Find the difference between the provided replacements and the replaced\n-        // template variables. This will let us notify the user of any template\n-        // variables that were not used but were provided.\n-        let difference = injections\n-            .keys()\n-            .filter(|k| !injected.contains(*k))\n-            .copied()\n-            .collect::<Vec<_>>();\n-\n-        bail!(\n-            \"Invariant: Expected to inject all injections, missing {} in template\",\n-            difference.join(\", \"),\n-        )\n-    }\n-\n-    // Replace the optional imports.\n-    let mut imports_added = FxIndexSet::default();\n-    for (key, import_path) in &imports {\n-        let mut full = format!(\"// OPTIONAL_IMPORT:{key}\");\n-        let namespace = if !content.contains(&full) {\n-            full = format!(\"// OPTIONAL_IMPORT:* as {key}\");\n-            if content.contains(&full) {\n-                true\n-            } else {\n-                continue;\n-            }\n-        } else {\n-            false\n-        };\n-\n-        // Track all the imports to ensure that we're not missing any.\n-        imports_added.insert(*key);\n-\n-        if let Some(path) = import_path {\n-            content = content.replace(\n-                &full,\n-                &format!(\n-                    \"import {}{} from {}\",\n-                    if namespace { \"* as \" } else { \"\" },\n-                    key,\n-                    &StringifyJs(&path).to_string()\n-                ),\n-            );\n-        } else {\n-            content = content.replace(&full, &format!(\"const {key} = null\"));\n-        }\n-    }\n-\n-    // Check to see if there's any remaining imports.\n-    static OPTIONAL_IMPORT_RE: LazyLock<Regex> =\n-        LazyLock::new(|| Regex::new(\"// OPTIONAL_IMPORT:(\\\\* as )?[A-Za-z0-9_]+\").unwrap());\n-    let mut matches = OPTIONAL_IMPORT_RE.find_iter(&content).peekable();\n-\n-    if matches.peek().is_some() {\n-        bail!(\n-            \"Invariant: Expected to inject all imports, found {}\",\n-            matches.map(|m| m.as_str()).collect::<Vec<_>>().join(\", \"),\n-        )\n-    }\n-\n-    // Check to see if any import was provided but not used.\n-    if imports_added.len() != imports.len() {\n-        // Find the difference between the provided imports and the injected\n-        // imports. This will let us notify the user of any imports that were\n-        // not used but were provided.\n-        let difference = imports\n-            .keys()\n-            .filter(|k| !imports_added.contains(*k))\n-            .cloned()\n-            .collect::<Vec<_>>();\n-\n-        bail!(\n-            \"Invariant: Expected to inject all imports, missing {} in template\",\n-            difference.join(\", \"),\n-        )\n-    }\n-\n-    // Ensure that the last line is a newline.\n-    if !content.ends_with('\\n') {\n-        content.push('\\n');\n-    }\n+    let content = expand_next_js_template(\n+        &content,\n+        &template_path.path,\n+        &package_root.path,\n+        replacements.iter().copied(),\n+        injections.iter().copied(),\n+        imports.iter().copied(),\n+    )?;\n \n     let file = File::from(content);\n \n-    let source = VirtualSource::new(path, AssetContent::file(file.into()));\n+    let source = VirtualSource::new(template_path, AssetContent::file(file.into()));\n \n     Ok(Vc::upcast(source))\n }\n@@ -984,9 +764,9 @@ pub async fn file_content_rope(content: Vc<FileContent>) -> Result<Vc<Rope>> {\n     Ok(file.content().to_owned().cell())\n }\n \n-pub async fn virtual_next_js_template_path(\n+async fn virtual_next_js_template_path(\n     project_path: FileSystemPath,\n-    file: String,\n+    file: &str,\n ) -> Result<FileSystemPath> {\n     debug_assert!(!file.contains('/'));\n     get_next_package(project_path)"
        },
        {
            "sha": "b3a929cf6ef8077eaa38e01f35c8a6500d216fef",
            "filename": "crates/next-taskless/Cargo.toml",
            "status": "added",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/crates%2Fnext-taskless%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/crates%2Fnext-taskless%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-taskless%2FCargo.toml?ref=4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f",
            "patch": "@@ -0,0 +1,18 @@\n+[package]\n+name = \"next-taskless\"\n+version = \"0.0.1\"\n+description = \"TBD\"\n+license = \"MIT\"\n+edition = \"2024\"\n+\n+[lib]\n+bench = false\n+\n+[lints]\n+workspace = true\n+\n+[dependencies]\n+anyhow = { workspace = true }\n+regex = { workspace = true }\n+serde_json = { workspace = true }\n+turbo-unix-path = { workspace = true }"
        },
        {
            "sha": "da965b21c07ce51f5c4b766279bc15ace73f9ed9",
            "filename": "crates/next-taskless/README.md",
            "status": "added",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/crates%2Fnext-taskless%2FREADME.md",
            "raw_url": "https://github.com/vercel/next.js/raw/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/crates%2Fnext-taskless%2FREADME.md",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-taskless%2FREADME.md?ref=4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f",
            "patch": "@@ -0,0 +1,7 @@\n+Utilities for Next.js written without a dependency on turbo-tasks, allowing them to be shared with\n+webpack and/or rspack codepaths. This crate must be compilable to WASM, so that it works in\n+environments where no native bindings are available.\n+\n+These utilities should not perform file IO directly, but instead accept files they depend on as\n+arguments (preferred) or via async trait methods or callbacks (acceptable). Follow \"sans-io\"\n+patterns where possible."
        },
        {
            "sha": "8571dda9894de57e36fa681252d697e50e271661",
            "filename": "crates/next-taskless/src/lib.rs",
            "status": "added",
            "additions": 265,
            "deletions": 0,
            "changes": 265,
            "blob_url": "https://github.com/vercel/next.js/blob/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/crates%2Fnext-taskless%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/crates%2Fnext-taskless%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-taskless%2Fsrc%2Flib.rs?ref=4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f",
            "patch": "@@ -0,0 +1,265 @@\n+#![doc = include_str!(\"../README.md\")]\n+\n+use std::sync::LazyLock;\n+\n+use anyhow::{Context, Result, bail};\n+use regex::Regex;\n+use turbo_unix_path::{get_parent_path, get_relative_path_to, join_path, normalize_path};\n+\n+/// Given a next.js template file's contents, replaces `replacements` and `injections` and makes\n+/// sure there are none left over.\n+///\n+/// See `packages/next/src/build/templates/` for examples.\n+///\n+/// Paths should be unix or node.js-style paths where `/` is used as the path separator. They should\n+/// not be windows-style paths.\n+pub fn expand_next_js_template<'a>(\n+    content: &str,\n+    template_path: &str,\n+    next_package_dir_path: &str,\n+    replacements: impl IntoIterator<Item = (&'a str, &'a str)>,\n+    injections: impl IntoIterator<Item = (&'a str, &'a str)>,\n+    imports: impl IntoIterator<Item = (&'a str, Option<&'a str>)>,\n+) -> Result<String> {\n+    let template_parent_path = normalize_path(get_parent_path(template_path))\n+        .context(\"failed to normalize template path\")?;\n+    let next_package_dir_parent_path = normalize_path(get_parent_path(next_package_dir_path))\n+        .context(\"failed to normalize package dir path\")?;\n+\n+    /// See [regex::Regex::replace_all].\n+    fn replace_all<E>(\n+        re: &regex::Regex,\n+        haystack: &str,\n+        mut replacement: impl FnMut(&regex::Captures) -> Result<String, E>,\n+    ) -> Result<String, E> {\n+        let mut new = String::with_capacity(haystack.len());\n+        let mut last_match = 0;\n+        for caps in re.captures_iter(haystack) {\n+            let m = caps.get(0).unwrap();\n+            new.push_str(&haystack[last_match..m.start()]);\n+            new.push_str(&replacement(&caps)?);\n+            last_match = m.end();\n+        }\n+        new.push_str(&haystack[last_match..]);\n+        Ok(new)\n+    }\n+\n+    // Update the relative imports to be absolute. This will update any relative imports to be\n+    // relative to the root of the `next` package.\n+    static IMPORT_PATH_RE: LazyLock<Regex> =\n+        LazyLock::new(|| Regex::new(\"(?:from '(\\\\..*)'|import '(\\\\..*)')\").unwrap());\n+\n+    let mut count = 0;\n+    let mut content = replace_all(&IMPORT_PATH_RE, content, |caps| {\n+        let from_request = caps.get(1).map_or(\"\", |c| c.as_str());\n+        count += 1;\n+        let is_from_request = !from_request.is_empty();\n+\n+        let imported_path = join_path(\n+            &template_parent_path,\n+            if is_from_request {\n+                from_request\n+            } else {\n+                caps.get(2).context(\"import path must exist\")?.as_str()\n+            },\n+        )\n+        .context(\"path should not leave the fs\")?;\n+\n+        let relative = get_relative_path_to(&next_package_dir_parent_path, &imported_path);\n+\n+        if !relative.starts_with(\"./next/\") {\n+            bail!(\n+                \"Invariant: Expected relative import to start with \\\"./next/\\\", found \\\n+                 {relative:?}. Path computed from {next_package_dir_parent_path:?} to \\\n+                 {imported_path:?}.\",\n+            )\n+        }\n+\n+        let relative = relative\n+            .strip_prefix(\"./\")\n+            .context(\"should be able to strip the prefix\")?;\n+\n+        Ok(if is_from_request {\n+            format!(\"from {}\", serde_json::to_string(relative).unwrap())\n+        } else {\n+            format!(\"import {}\", serde_json::to_string(relative).unwrap())\n+        })\n+    })\n+    .context(\"replacing imports failed\")?;\n+\n+    // Verify that at least one import was replaced. It's the case today where every template file\n+    // has at least one import to update, so this ensures that we don't accidentally remove the\n+    // import replacement code or use the wrong template file.\n+    if count == 0 {\n+        bail!(\"Invariant: Expected to replace at least one import\")\n+    }\n+\n+    // Replace all the template variables with the actual values. If a template variable is missing,\n+    // throw an error.\n+    let mut missing_replacements = Vec::new();\n+    for (key, replacement) in replacements {\n+        let full = format!(\"'{key}'\");\n+\n+        if content.contains(&full) {\n+            content = content.replace(&full, &serde_json::to_string(&replacement).unwrap());\n+        } else {\n+            missing_replacements.push(key)\n+        }\n+    }\n+\n+    // Check to see if there's any remaining template variables.\n+    static TEMPLATE_VAR_RE: LazyLock<Regex> = LazyLock::new(|| Regex::new(\"VAR_[A-Z_]+\").unwrap());\n+    let mut matches = TEMPLATE_VAR_RE.find_iter(&content).peekable();\n+\n+    if matches.peek().is_some() {\n+        bail!(\n+            \"Invariant: Expected to replace all template variables, found {}\",\n+            matches.map(|m| m.as_str()).collect::<Vec<_>>().join(\", \"),\n+        )\n+    }\n+\n+    // Check to see if any template variable was provided but not used.\n+    if !missing_replacements.is_empty() {\n+        bail!(\n+            \"Invariant: Expected to replace all template variables, missing {} in template\",\n+            missing_replacements.join(\", \"),\n+        )\n+    }\n+\n+    // Replace the injections.\n+    let mut missing_injections = Vec::new();\n+    for (key, injection) in injections {\n+        let full = format!(\"// INJECT:{key}\");\n+\n+        if content.contains(&full) {\n+            content = content.replace(&full, &format!(\"const {key} = {injection}\"));\n+        } else {\n+            missing_injections.push(key);\n+        }\n+    }\n+\n+    // Check to see if there's any remaining injections.\n+    static INJECT_RE: LazyLock<Regex> =\n+        LazyLock::new(|| Regex::new(\"// INJECT:[A-Za-z0-9_]+\").unwrap());\n+    let mut matches = INJECT_RE.find_iter(&content).peekable();\n+\n+    if matches.peek().is_some() {\n+        bail!(\n+            \"Invariant: Expected to inject all injections, found {}\",\n+            matches.map(|m| m.as_str()).collect::<Vec<_>>().join(\", \"),\n+        )\n+    }\n+\n+    // Check to see if any injection was provided but not used.\n+    if !missing_injections.is_empty() {\n+        bail!(\n+            \"Invariant: Expected to inject all injections, missing {} in template\",\n+            missing_injections.join(\", \"),\n+        )\n+    }\n+\n+    // Replace the optional imports.\n+    let mut missing_imports = Vec::new();\n+    for (key, import_path) in imports {\n+        let mut full = format!(\"// OPTIONAL_IMPORT:{key}\");\n+        let namespace = if !content.contains(&full) {\n+            full = format!(\"// OPTIONAL_IMPORT:* as {key}\");\n+            if content.contains(&full) {\n+                true\n+            } else {\n+                missing_imports.push(key);\n+                continue;\n+            }\n+        } else {\n+            false\n+        };\n+\n+        if let Some(path) = import_path {\n+            content = content.replace(\n+                &full,\n+                &format!(\n+                    \"import {}{} from {}\",\n+                    if namespace { \"* as \" } else { \"\" },\n+                    key,\n+                    serde_json::to_string(&path).unwrap(),\n+                ),\n+            );\n+        } else {\n+            content = content.replace(&full, &format!(\"const {key} = null\"));\n+        }\n+    }\n+\n+    // Check to see if there's any remaining imports.\n+    static OPTIONAL_IMPORT_RE: LazyLock<Regex> =\n+        LazyLock::new(|| Regex::new(\"// OPTIONAL_IMPORT:(\\\\* as )?[A-Za-z0-9_]+\").unwrap());\n+    let mut matches = OPTIONAL_IMPORT_RE.find_iter(&content).peekable();\n+\n+    if matches.peek().is_some() {\n+        bail!(\n+            \"Invariant: Expected to inject all imports, found {}\",\n+            matches.map(|m| m.as_str()).collect::<Vec<_>>().join(\", \"),\n+        )\n+    }\n+\n+    // Check to see if any import was provided but not used.\n+    if !missing_imports.is_empty() {\n+        bail!(\n+            \"Invariant: Expected to inject all imports, missing {} in template\",\n+            missing_imports.join(\", \"),\n+        )\n+    }\n+\n+    // Ensure that the last line is a newline.\n+    if !content.ends_with('\\n') {\n+        content.push('\\n');\n+    }\n+\n+    Ok(content)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn test_expand_next_js_template() {\n+        let input = r#\"\n+            import '../../foo/bar';\n+            import * as userlandPage from 'VAR_USERLAND'\n+            // OPTIONAL_IMPORT:* as userland500Page\n+            // OPTIONAL_IMPORT:incrementalCacheHandler\n+\n+            // INJECT:nextConfig\n+            const srcPage = 'VAR_PAGE'\n+        \"#;\n+\n+        let expected = r#\"\n+            import \"next/src/foo/bar\";\n+            import * as userlandPage from \"INNER_PAGE_ENTRY\"\n+            import * as userland500Page from \"INNER_ERROR_500\"\n+            const incrementalCacheHandler = null\n+\n+            const nextConfig = {}\n+            const srcPage = \"./some/path.js\"\n+        \"#;\n+\n+        let output = expand_next_js_template(\n+            input,\n+            \"project/node_modules/next/src/build/templates/test-case.js\",\n+            \"project/node_modules/next\",\n+            [\n+                (\"VAR_USERLAND\", \"INNER_PAGE_ENTRY\"),\n+                (\"VAR_PAGE\", \"./some/path.js\"),\n+            ],\n+            [(\"nextConfig\", \"{}\")],\n+            [\n+                (\"incrementalCacheHandler\", None),\n+                (\"userland500Page\", Some(\"INNER_ERROR_500\")),\n+            ],\n+        )\n+        .unwrap();\n+        println!(\"{output}\");\n+\n+        assert_eq!(output.trim_end(), expected.trim_end());\n+    }\n+}"
        },
        {
            "sha": "bf44ee5da4e2e522632a3a806102f835bfaa5121",
            "filename": "crates/wasm/Cargo.toml",
            "status": "modified",
            "additions": 6,
            "deletions": 4,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/crates%2Fwasm%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/crates%2Fwasm%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fwasm%2FCargo.toml?ref=4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f",
            "patch": "@@ -17,15 +17,17 @@ plugin = [\"swc_core/plugin_transform_host_js\"]\n workspace = true\n \n [dependencies]\n-anyhow = \"1.0.66\"\n+anyhow = { workspace = true }\n console_error_panic_hook = \"0.1.6\"\n+getrandom = { version = \"0.3\", default-features = false, features = [\"wasm_js\"] }\n+js-sys = \"0.3.59\"\n next-custom-transforms = { workspace = true }\n+next-taskless = { workspace = true }\n+rustc-hash = { workspace = true }\n+serde-wasm-bindgen = \"0.4.3\"\n serde_json = \"1\"\n wasm-bindgen = { version = \"0.2\", features = [\"enable-interning\"] }\n wasm-bindgen-futures = \"0.4.8\"\n-getrandom = { version = \"0.3\", default-features = false, features = [\"wasm_js\"] }\n-js-sys = \"0.3.59\"\n-serde-wasm-bindgen = \"0.4.3\"\n \n swc_core = { workspace = true, features = [\n   \"common\","
        },
        {
            "sha": "f5cb641afc3181ffe497e0722d1b0a2f21082a90",
            "filename": "crates/wasm/src/lib.rs",
            "status": "modified",
            "additions": 35,
            "deletions": 8,
            "changes": 43,
            "blob_url": "https://github.com/vercel/next.js/blob/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/crates%2Fwasm%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/crates%2Fwasm%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fwasm%2Fsrc%2Flib.rs?ref=4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f",
            "patch": "@@ -1,8 +1,9 @@\n-use std::sync::Arc;\n+use std::{fmt::Debug, sync::Arc};\n \n-use anyhow::{Context, Error};\n+use anyhow::Context;\n use js_sys::JsString;\n use next_custom_transforms::chain_transforms::{custom_before_pass, TransformOptions};\n+use rustc_hash::FxHashMap;\n use swc_core::{\n     base::{\n         config::{JsMinifyOptions, ParseOptions},\n@@ -20,8 +21,8 @@ use wasm_bindgen_futures::future_to_promise;\n \n pub mod mdx;\n \n-fn convert_err(err: Error) -> JsValue {\n-    format!(\"{err:?}\").into()\n+fn convert_err(err: impl Debug) -> JsError {\n+    JsError::new(&format!(\"{err:?}\"))\n }\n \n #[wasm_bindgen(js_name = \"minifySync\")]\n@@ -63,7 +64,7 @@ pub fn minify(s: JsString, opts: JsValue) -> js_sys::Promise {\n }\n \n #[wasm_bindgen(js_name = \"transformSync\")]\n-pub fn transform_sync(s: JsValue, opts: JsValue) -> Result<JsValue, JsValue> {\n+pub fn transform_sync(s: JsValue, opts: JsValue) -> Result<JsValue, JsError> {\n     console_error_panic_hook::set_once();\n \n     let c = compiler();\n@@ -136,11 +137,11 @@ pub fn transform_sync(s: JsValue, opts: JsValue) -> Result<JsValue, JsValue> {\n pub fn transform(s: JsValue, opts: JsValue) -> js_sys::Promise {\n     // TODO: This'll be properly scheduled once wasm have standard backed thread\n     // support.\n-    future_to_promise(async { transform_sync(s, opts) })\n+    future_to_promise(async { Ok(transform_sync(s, opts)?) })\n }\n \n #[wasm_bindgen(js_name = \"parseSync\")]\n-pub fn parse_sync(s: JsString, opts: JsValue) -> Result<JsValue, JsValue> {\n+pub fn parse_sync(s: JsString, opts: JsValue) -> Result<JsValue, JsError> {\n     console_error_panic_hook::set_once();\n \n     let c = swc_core::base::Compiler::new(Arc::new(SourceMap::new(FilePathMapping::empty())));\n@@ -188,7 +189,7 @@ pub fn parse_sync(s: JsString, opts: JsValue) -> Result<JsValue, JsValue> {\n pub fn parse(s: JsString, opts: JsValue) -> js_sys::Promise {\n     // TODO: This'll be properly scheduled once wasm have standard backed thread\n     // support.\n-    future_to_promise(async { parse_sync(s, opts) })\n+    future_to_promise(async { Ok(parse_sync(s, opts)?) })\n }\n \n /// Get global sourcemap\n@@ -197,3 +198,29 @@ fn compiler() -> Arc<Compiler> {\n \n     Arc::new(Compiler::new(cm))\n }\n+\n+#[wasm_bindgen(js_name = \"expandNextJsTemplate\")]\n+pub fn expand_next_js_template(\n+    content: Box<[u8]>,\n+    template_path: &str,\n+    next_package_dir_path: &str,\n+    replacements: JsValue,\n+    injections: JsValue,\n+    imports: JsValue,\n+) -> Result<String, JsError> {\n+    next_taskless::expand_next_js_template(\n+        str::from_utf8(&content).map_err(convert_err)?,\n+        template_path,\n+        next_package_dir_path,\n+        serde_wasm_bindgen::from_value::<FxHashMap<String, String>>(replacements)?\n+            .iter()\n+            .map(|(k, v)| (&**k, &**v)),\n+        serde_wasm_bindgen::from_value::<FxHashMap<String, String>>(injections)?\n+            .iter()\n+            .map(|(k, v)| (&**k, &**v)),\n+        serde_wasm_bindgen::from_value::<FxHashMap<String, Option<String>>>(imports)?\n+            .iter()\n+            .map(|(k, v)| (&**k, v.as_deref())),\n+    )\n+    .map_err(convert_err)\n+}"
        },
        {
            "sha": "db02a4d68e7b5b4715d1ee9e0e8a46e1cb0f5451",
            "filename": "packages/next/src/build/load-entrypoint.ts",
            "status": "modified",
            "additions": 16,
            "deletions": 190,
            "changes": 206,
            "blob_url": "https://github.com/vercel/next.js/blob/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/packages%2Fnext%2Fsrc%2Fbuild%2Fload-entrypoint.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/packages%2Fnext%2Fsrc%2Fbuild%2Fload-entrypoint.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fload-entrypoint.ts?ref=4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f",
            "patch": "@@ -1,9 +1,10 @@\n import fs from 'fs/promises'\n import path from 'path'\n+import { loadBindings } from './swc'\n \n // NOTE: this should be updated if this loader file is moved.\n-const PACKAGE_ROOT = path.normalize(path.join(__dirname, '../../..'))\n-const TEMPLATE_FOLDER = path.join(__dirname, 'templates')\n+const PACKAGE_ROOT = path.normalize(path.join(__dirname, '../..'))\n+const TEMPLATE_SRC_FOLDER = path.normalize(path.join(__dirname, './templates'))\n const TEMPLATES_ESM_FOLDER = path.normalize(\n   path.join(__dirname, '../../dist/esm/build/templates')\n )\n@@ -38,195 +39,20 @@ export async function loadEntrypoint(\n   injections?: Record<string, string>,\n   imports?: Record<string, string | null>\n ): Promise<string> {\n-  const filepath = path.resolve(\n+  let bindings = await loadBindings()\n+\n+  const templatePath = path.resolve(\n     path.join(TEMPLATES_ESM_FOLDER, `${entrypoint}.js`)\n   )\n-\n-  let file = await fs.readFile(filepath, 'utf8')\n-\n-  // Update the relative imports to be absolute. This will update any relative\n-  // imports to be relative to the root of the `next` package.\n-  let count = 0\n-  file = file.replaceAll(\n-    /from '(\\..*)'|import '(\\..*)'/g,\n-    function (_, fromRequest, importRequest) {\n-      count++\n-\n-      const relative = path\n-        .relative(\n-          PACKAGE_ROOT,\n-          path.resolve(TEMPLATE_FOLDER, fromRequest ?? importRequest)\n-        )\n-        // Ensure that we use linux style path separators for node.\n-        .replace(/\\\\/g, '/')\n-\n-      // Verify that the relative import is relative to the `next` package. This\n-      // will catch cases where the constants at the top of the file were not\n-      // updated after the file was moved.\n-      if (!relative.startsWith('next/')) {\n-        throw new Error(\n-          `Invariant: Expected relative import to start with \"next/\", found \"${relative}\"`\n-        )\n-      }\n-\n-      return fromRequest\n-        ? `from ${JSON.stringify(relative)}`\n-        : `import ${JSON.stringify(relative)}`\n-    }\n+  let content = await fs.readFile(templatePath)\n+\n+  return bindings.expandNextJsTemplate(\n+    content,\n+    // Ensure that we use unix-style path separators for the import paths\n+    path.join(TEMPLATE_SRC_FOLDER, `${entrypoint}.js`).replace(/\\\\/g, '/'),\n+    PACKAGE_ROOT.replace(/\\\\/g, '/'),\n+    replacements,\n+    injections ?? {},\n+    imports ?? {}\n   )\n-\n-  // Verify that at least one import was replaced. It's the case today where\n-  // every template file has at least one import to update, so this ensures that\n-  // we don't accidentally remove the import replacement code or use the wrong\n-  // template file.\n-  if (count === 0) {\n-    throw new Error('Invariant: Expected to replace at least one import')\n-  }\n-\n-  const replaced = new Set<string>()\n-\n-  // Replace all the template variables with the actual values. If a template\n-  // variable is missing, throw an error.\n-  file = file.replaceAll(\n-    new RegExp(\n-      `${Object.keys(replacements)\n-        .map((k) => `'${k}'`)\n-        .join('|')}`,\n-      'g'\n-    ),\n-    (match) => {\n-      const key = JSON.parse(match.replace(/'/g, `\"`))\n-\n-      if (!(key in replacements)) {\n-        throw new Error(`Invariant: Unexpected template variable ${key}`)\n-      }\n-\n-      replaced.add(key)\n-\n-      return JSON.stringify(replacements[key])\n-    }\n-  )\n-\n-  // Check to see if there's any remaining template variables.\n-  let matches = file.match(/VAR_[A-Z_]+/g)\n-  if (matches) {\n-    throw new Error(\n-      `Invariant: Expected to replace all template variables, found ${matches.join(\n-        ', '\n-      )}`\n-    )\n-  }\n-\n-  // Check to see if any template variable was provided but not used.\n-  if (replaced.size !== Object.keys(replacements).length) {\n-    // Find the difference between the provided replacements and the replaced\n-    // template variables. This will let us notify the user of any template\n-    // variables that were not used but were provided.\n-    const difference = Object.keys(replacements).filter(\n-      (key) => !replaced.has(key)\n-    )\n-\n-    throw new Error(\n-      `Invariant: Expected to replace all template variables, missing ${difference.join(\n-        ', '\n-      )} in template`\n-    )\n-  }\n-\n-  // Replace the injections.\n-  const injected = new Set<string>()\n-  if (injections) {\n-    // Track all the injections to ensure that we're not missing any.\n-    file = file.replaceAll(\n-      new RegExp(`// INJECT:(${Object.keys(injections).join('|')})`, 'g'),\n-      (_, key) => {\n-        if (!(key in injections)) {\n-          throw new Error(`Invariant: Unexpected injection ${key}`)\n-        }\n-\n-        injected.add(key)\n-\n-        return `const ${key} = ${injections[key]}`\n-      }\n-    )\n-  }\n-\n-  // Check to see if there's any remaining injections.\n-  matches = file.match(/\\/\\/ INJECT:[A-Za-z0-9_]+/g)\n-  if (matches) {\n-    throw new Error(\n-      `Invariant: Expected to inject all injections, found ${matches.join(\n-        ', '\n-      )}`\n-    )\n-  }\n-\n-  // Check to see if any injection was provided but not used.\n-  if (injected.size !== Object.keys(injections ?? {}).length) {\n-    // Find the difference between the provided injections and the injected\n-    // injections. This will let us notify the user of any injections that were\n-    // not used but were provided.\n-    const difference = Object.keys(injections ?? {}).filter(\n-      (key) => !injected.has(key)\n-    )\n-\n-    throw new Error(\n-      `Invariant: Expected to inject all injections, missing ${difference.join(\n-        ', '\n-      )} in template`\n-    )\n-  }\n-\n-  // Replace the optional imports.\n-  const importsAdded = new Set<string>()\n-  if (imports) {\n-    // Track all the imports to ensure that we're not missing any.\n-    file = file.replaceAll(\n-      new RegExp(\n-        `// OPTIONAL_IMPORT:(\\\\* as )?(${Object.keys(imports).join('|')})`,\n-        'g'\n-      ),\n-      (_, asNamespace = '', key) => {\n-        if (!(key in imports)) {\n-          throw new Error(`Invariant: Unexpected optional import ${key}`)\n-        }\n-\n-        importsAdded.add(key)\n-\n-        if (imports[key]) {\n-          return `import ${asNamespace}${key} from ${JSON.stringify(\n-            imports[key]\n-          )}`\n-        } else {\n-          return `const ${key} = null`\n-        }\n-      }\n-    )\n-  }\n-\n-  // Check to see if there's any remaining imports.\n-  matches = file.match(/\\/\\/ OPTIONAL_IMPORT:(\\* as )?[A-Za-z0-9_]+/g)\n-  if (matches) {\n-    throw new Error(\n-      `Invariant: Expected to inject all imports, found ${matches.join(', ')}`\n-    )\n-  }\n-\n-  // Check to see if any import was provided but not used.\n-  if (importsAdded.size !== Object.keys(imports ?? {}).length) {\n-    // Find the difference between the provided imports and the injected\n-    // imports. This will let us notify the user of any imports that were\n-    // not used but were provided.\n-    const difference = Object.keys(imports ?? {}).filter(\n-      (key) => !importsAdded.has(key)\n-    )\n-\n-    throw new Error(\n-      `Invariant: Expected to inject all imports, missing ${difference.join(\n-        ', '\n-      )} in template`\n-    )\n-  }\n-\n-  return file\n }"
        },
        {
            "sha": "5fbae2c21dace5beddc6858e0326515b7a4d3a6a",
            "filename": "packages/next/src/build/swc/generated-native.d.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Fgenerated-native.d.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Fgenerated-native.d.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Fgenerated-native.d.ts?ref=4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f",
            "patch": "@@ -424,6 +424,14 @@ export interface NapiDiagnostic {\n   name: string\n   payload: Record<string, string>\n }\n+export declare function expandNextJsTemplate(\n+  content: Buffer,\n+  templatePath: string,\n+  nextPackageDirPath: string,\n+  replacements: Record<string, string>,\n+  injections: Record<string, string>,\n+  imports: Record<string, string | null>\n+): string\n export declare function parse(\n   src: string,\n   options: Buffer,"
        },
        {
            "sha": "ca6e7525317a3fcd4345bfef68662a818e18ad9a",
            "filename": "packages/next/src/build/swc/generated-wasm.d.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Fgenerated-wasm.d.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Fgenerated-wasm.d.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Fgenerated-wasm.d.ts?ref=4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f",
            "patch": "@@ -11,3 +11,11 @@ export function transformSync(s: any, opts: any): any\n export function transform(s: any, opts: any): Promise<any>\n export function parseSync(s: string, opts: any): any\n export function parse(s: string, opts: any): Promise<any>\n+export function expandNextJsTemplate(\n+  content: Uint8Array,\n+  template_path: string,\n+  next_package_dir_path: string,\n+  replacements: any,\n+  injections: any,\n+  imports: any\n+): string"
        },
        {
            "sha": "5401d14a2a833fa92be54c5a1d50b4fcda39df08",
            "filename": "packages/next/src/build/swc/index.ts",
            "status": "modified",
            "additions": 34,
            "deletions": 0,
            "changes": 34,
            "blob_url": "https://github.com/vercel/next.js/blob/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Findex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Findex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Findex.ts?ref=4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f",
            "patch": "@@ -1238,6 +1238,23 @@ async function loadWasm(importPath = '') {\n         )\n       },\n     },\n+    expandNextJsTemplate(\n+      content: Buffer,\n+      templatePath: string,\n+      nextPackageDirPath: string,\n+      replacements: Record<`VAR_${string}`, string>,\n+      injections: Record<string, string>,\n+      imports: Record<string, string | null>\n+    ): string {\n+      return rawBindings.expandNextJsTemplate(\n+        content,\n+        templatePath,\n+        nextPackageDirPath,\n+        replacements,\n+        injections,\n+        imports\n+      )\n+    },\n   }\n   return wasmBindings\n }\n@@ -1420,6 +1437,23 @@ function loadNative(importPath?: string) {\n           return bindings.warnForEdgeRuntime(source, isProduction)\n         },\n       },\n+      expandNextJsTemplate(\n+        content: Buffer,\n+        templatePath: string,\n+        nextPackageDirPath: string,\n+        replacements: Record<`VAR_${string}`, string>,\n+        injections: Record<string, string>,\n+        imports: Record<string, string | null>\n+      ): string {\n+        return bindings.expandNextJsTemplate(\n+          content,\n+          templatePath,\n+          nextPackageDirPath,\n+          replacements,\n+          injections,\n+          imports\n+        )\n+      },\n     }\n     return nativeBindings\n   }"
        },
        {
            "sha": "63b5d04e3e5cf372d9cc3effd736480352bf49ff",
            "filename": "packages/next/src/build/swc/types.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Ftypes.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Ftypes.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Ftypes.ts?ref=4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f",
            "patch": "@@ -52,6 +52,14 @@ export interface Binding {\n       isProduction: boolean\n     ): Promise<NapiSourceDiagnostic[]>\n   }\n+  expandNextJsTemplate(\n+    content: Buffer,\n+    templatePath: string,\n+    nextPackageDirPath: string,\n+    replacements: Record<`VAR_${string}`, string>,\n+    injections: Record<string, string>,\n+    imports: Record<string, string | null>\n+  ): string\n }\n \n export type StyledString ="
        },
        {
            "sha": "c6f58165bd7d84bd6813aba3703fcd105287f7b4",
            "filename": "turbopack/crates/turbo-tasks-fs/Cargo.toml",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/turbopack%2Fcrates%2Fturbo-tasks-fs%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/turbopack%2Fcrates%2Fturbo-tasks-fs%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2FCargo.toml?ref=4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f",
            "patch": "@@ -50,6 +50,7 @@ triomphe = { workspace = true }\n turbo-rcstr = { workspace = true }\n turbo-tasks = { workspace = true }\n turbo-tasks-hash = { workspace = true }\n+turbo-unix-path = { workspace = true }\n urlencoding = { workspace = true }\n \n [dev-dependencies]"
        },
        {
            "sha": "7c5de10c0d31b35bfc6bc5818bc54b763bcb66bd",
            "filename": "turbopack/crates/turbo-tasks-fs/src/lib.rs",
            "status": "modified",
            "additions": 8,
            "deletions": 40,
            "changes": 48,
            "blob_url": "https://github.com/vercel/next.js/blob/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs?ref=4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f",
            "patch": "@@ -59,16 +59,21 @@ use turbo_tasks::{\n     mark_session_dependent, mark_stateful, trace::TraceRawVcs,\n };\n use turbo_tasks_hash::{DeterministicHash, DeterministicHasher, hash_xxh3_hash64};\n+use turbo_unix_path::{\n+    get_parent_path, get_relative_path_to, join_path, normalize_path, sys_to_unix, unix_to_sys,\n+};\n \n-use self::{invalidation::Write, json::UnparsableJson, mutex_map::MutexMap};\n use crate::{\n     attach::AttachedFileSystem,\n     glob::Glob,\n+    invalidation::Write,\n     invalidator_map::{InvalidatorMap, WriteContent},\n+    json::UnparsableJson,\n+    mutex_map::MutexMap,\n     read_glob::{read_glob, track_glob},\n     retry::retry_blocking,\n     rope::{Rope, RopeReader},\n-    util::{extract_disk_access, join_path, normalize_path, sys_to_unix, unix_to_sys},\n+    util::extract_disk_access,\n     watcher::DiskWatcher,\n };\n pub use crate::{read_glob::ReadGlobResult, virtual_fs::VirtualFileSystem};\n@@ -1000,39 +1005,6 @@ impl ValueToString for DiskFileSystem {\n     }\n }\n \n-/// Note: this only works for Unix-style paths (with `/` as a separator).\n-pub fn get_relative_path_to(path: &str, other_path: &str) -> String {\n-    fn split(s: &str) -> impl Iterator<Item = &str> {\n-        let empty = s.is_empty();\n-        let mut iterator = s.split('/');\n-        if empty {\n-            iterator.next();\n-        }\n-        iterator\n-    }\n-\n-    let mut self_segments = split(path).peekable();\n-    let mut other_segments = split(other_path).peekable();\n-    while self_segments.peek() == other_segments.peek() {\n-        self_segments.next();\n-        if other_segments.next().is_none() {\n-            return \".\".to_string();\n-        }\n-    }\n-    let mut result = Vec::new();\n-    if self_segments.peek().is_none() {\n-        result.push(\".\");\n-    } else {\n-        while self_segments.next().is_some() {\n-            result.push(\"..\");\n-        }\n-    }\n-    for segment in other_segments {\n-        result.push(segment);\n-    }\n-    result.join(\"/\")\n-}\n-\n #[turbo_tasks::value(shared)]\n #[derive(Debug, Clone, Hash, TaskInput)]\n pub struct FileSystemPath {\n@@ -1456,11 +1428,7 @@ impl FileSystemPath {\n         if path.is_empty() {\n             return self.clone();\n         }\n-        let p = match str::rfind(path, '/') {\n-            Some(index) => path[..index].to_string(),\n-            None => \"\".to_string(),\n-        };\n-        FileSystemPath::new_normalized(self.fs, p.into())\n+        FileSystemPath::new_normalized(self.fs, RcStr::from(get_parent_path(path)))\n     }\n \n     // It is important that get_type uses read_dir and not stat/metadata."
        },
        {
            "sha": "2cca572ddd23607a07dc4320760b6e440f61e9c0",
            "filename": "turbopack/crates/turbo-tasks-fs/src/util.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 149,
            "changes": 151,
            "blob_url": "https://github.com/vercel/next.js/blob/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Futil.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Futil.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Futil.rs?ref=4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f",
            "patch": "@@ -1,5 +1,4 @@\n use std::{\n-    borrow::Cow,\n     io::{self, ErrorKind},\n     path::Path,\n };\n@@ -9,123 +8,6 @@ use turbo_tasks::Vc;\n \n use crate::{DiskFileSystem, FileSystemPath};\n \n-/// Joins two /-separated paths into a normalized path.\n-/// Paths are concatenated with /.\n-///\n-/// see also [normalize_path] for normalization.\n-pub fn join_path(fs_path: &str, join: &str) -> Option<String> {\n-    // Paths that we join are written as source code (eg, `join_path(fs_path,\n-    // \"foo/bar.js\")`) and it's expected that they will never contain a\n-    // backslash.\n-    debug_assert!(\n-        !join.contains('\\\\'),\n-        \"joined path {join} must not contain a Windows directory '\\\\', it must be normalized to \\\n-         Unix '/'\"\n-    );\n-\n-    // TODO: figure out why this freezes the benchmarks.\n-    // // an absolute path would leave the file system root\n-    // if Path::new(join).is_absolute() {\n-    //     return None;\n-    // }\n-\n-    if fs_path.is_empty() {\n-        normalize_path(join)\n-    } else if join.is_empty() {\n-        normalize_path(fs_path)\n-    } else {\n-        normalize_path(&[fs_path, \"/\", join].concat())\n-    }\n-}\n-\n-/// Converts System paths into Unix paths. This is a noop on Unix systems, and\n-/// replaces backslash directory separators with forward slashes on Windows.\n-#[inline]\n-pub fn sys_to_unix(path: &str) -> Cow<'_, str> {\n-    #[cfg(not(target_family = \"windows\"))]\n-    {\n-        Cow::from(path)\n-    }\n-    #[cfg(target_family = \"windows\")]\n-    {\n-        Cow::Owned(path.replace(std::path::MAIN_SEPARATOR_STR, \"/\"))\n-    }\n-}\n-\n-/// Converts Unix paths into System paths. This is a noop on Unix systems, and\n-/// replaces forward slash directory separators with backslashes on Windows.\n-#[inline]\n-pub fn unix_to_sys(path: &str) -> Cow<'_, str> {\n-    #[cfg(not(target_family = \"windows\"))]\n-    {\n-        Cow::from(path)\n-    }\n-    #[cfg(target_family = \"windows\")]\n-    {\n-        Cow::Owned(path.replace('/', std::path::MAIN_SEPARATOR_STR))\n-    }\n-}\n-\n-/// Normalizes a /-separated path into a form that contains no leading /, no\n-/// double /, no \".\" segment, no \"..\" segment.\n-///\n-/// Returns None if the path would need to start with \"..\" to be equal.\n-pub fn normalize_path(str: &str) -> Option<String> {\n-    let mut segments = Vec::new();\n-    for segment in str.split('/') {\n-        match segment {\n-            \".\" | \"\" => {}\n-            \"..\" => {\n-                segments.pop()?;\n-            }\n-            segment => {\n-                segments.push(segment);\n-            }\n-        }\n-    }\n-    Some(segments.join(\"/\"))\n-}\n-\n-/// Normalizes a /-separated request into a form that contains no leading /, no\n-/// double /, and no \".\" or \"..\" segments in the middle of the request.\n-///\n-/// A request might only start with a single \".\" segment and no \"..\" segments, or\n-/// any positive number of \"..\" segments but no \".\" segment.\n-pub fn normalize_request(str: &str) -> String {\n-    let mut segments = vec![\".\"];\n-    // Keeps track of our directory depth so that we can pop directories when\n-    // encountering a \"..\". If this is positive, then we're inside a directory\n-    // and we can pop that. If it's 0, then we can't pop the directory and we must\n-    // keep the \"..\" in our segments. This is not the same as the segments.len(),\n-    // because we cannot pop a kept \"..\" when encountering another \"..\".\n-    let mut depth = 0;\n-    let mut popped_dot = false;\n-    for segment in str.split('/') {\n-        match segment {\n-            \".\" => {}\n-            \"..\" => {\n-                if depth > 0 {\n-                    depth -= 1;\n-                    segments.pop();\n-                } else {\n-                    // The first time we push a \"..\", we need to remove the \".\" we include by\n-                    // default.\n-                    if !popped_dot {\n-                        popped_dot = true;\n-                        segments.pop();\n-                    }\n-                    segments.push(segment);\n-                }\n-            }\n-            segment => {\n-                segments.push(segment);\n-                depth += 1;\n-            }\n-        }\n-    }\n-    segments.join(\"/\")\n-}\n-\n /// Converts a disk access Result<T> into a Result<Some<T>>, where a NotFound\n /// error results in a None value. This is purely to reduce boilerplate code\n /// comparing NotFound errors against all other errors.\n@@ -139,6 +21,8 @@ pub fn extract_disk_access<T>(value: io::Result<T>, path: &Path) -> Result<Optio\n \n #[cfg(not(target_os = \"windows\"))]\n pub async fn uri_from_file(root: FileSystemPath, path: Option<&str>) -> Result<String> {\n+    use turbo_unix_path::sys_to_unix;\n+\n     let root_fs = root.fs();\n     let root_fs = &*Vc::try_resolve_downcast_type::<DiskFileSystem>(root_fs)\n         .await?\n@@ -190,34 +74,3 @@ pub async fn uri_from_file(root: FileSystemPath, path: Option<&str>) -> Result<S\n \n     Ok(uri)\n }\n-\n-#[cfg(test)]\n-mod tests {\n-\n-    use rstest::*;\n-\n-    use crate::util::normalize_path;\n-\n-    #[rstest]\n-    #[case(\"file.js\")]\n-    #[case(\"a/b/c/d/e/file.js\")]\n-    fn test_normalize_path_no_op(#[case] path: &str) {\n-        assert_eq!(path, normalize_path(path).unwrap());\n-    }\n-\n-    #[rstest]\n-    #[case(\"/file.js\", \"file.js\")]\n-    #[case(\"./file.js\", \"file.js\")]\n-    #[case(\"././file.js\", \"file.js\")]\n-    #[case(\"a/../c/../file.js\", \"file.js\")]\n-    fn test_normalize_path(#[case] path: &str, #[case] normalized: &str) {\n-        assert_eq!(normalized, normalize_path(path).unwrap());\n-    }\n-\n-    #[rstest]\n-    #[case(\"../file.js\")]\n-    #[case(\"a/../../file.js\")]\n-    fn test_normalize_path_invalid(#[case] path: &str) {\n-        assert_eq!(None, normalize_path(path));\n-    }\n-}"
        },
        {
            "sha": "3815c1158141f6e2a7d982ec96d413a71e9769e6",
            "filename": "turbopack/crates/turbo-unix-path/Cargo.toml",
            "status": "added",
            "additions": 17,
            "deletions": 0,
            "changes": 17,
            "blob_url": "https://github.com/vercel/next.js/blob/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/turbopack%2Fcrates%2Fturbo-unix-path%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/turbopack%2Fcrates%2Fturbo-unix-path%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-unix-path%2FCargo.toml?ref=4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f",
            "patch": "@@ -0,0 +1,17 @@\n+[package]\n+name = \"turbo-unix-path\"\n+version = \"0.0.1\"\n+description = \"TBD\"\n+license = \"MIT\"\n+edition = \"2024\"\n+\n+[lib]\n+bench = false\n+\n+[lints]\n+workspace = true\n+\n+[dependencies]\n+\n+[dev-dependencies]\n+rstest = { workspace = true }"
        },
        {
            "sha": "c8b857d35d0978229235683e2ea54b52391557aa",
            "filename": "turbopack/crates/turbo-unix-path/README.md",
            "status": "added",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/turbopack%2Fcrates%2Fturbo-unix-path%2FREADME.md",
            "raw_url": "https://github.com/vercel/next.js/raw/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/turbopack%2Fcrates%2Fturbo-unix-path%2FREADME.md",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-unix-path%2FREADME.md?ref=4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f",
            "patch": "@@ -0,0 +1,8 @@\n+Utilities for lexical manipulation of unix-style (`/`-separated) paths represented as unicode\n+strings.\n+\n+These paths types are frequently used for JS imports, and are used within Turbopack to represent\n+platform-agnostic relative paths.\n+\n+This crate does not perform any IO, and does not depend on turbo-tasks. Most users should prefer the\n+`turbo-tasks-fs` crate."
        },
        {
            "sha": "e00caf7eba27dbafa8268e9337278ad374a93de8",
            "filename": "turbopack/crates/turbo-unix-path/src/lib.rs",
            "status": "added",
            "additions": 188,
            "deletions": 0,
            "changes": 188,
            "blob_url": "https://github.com/vercel/next.js/blob/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/turbopack%2Fcrates%2Fturbo-unix-path%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/turbopack%2Fcrates%2Fturbo-unix-path%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-unix-path%2Fsrc%2Flib.rs?ref=4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f",
            "patch": "@@ -0,0 +1,188 @@\n+#![doc = include_str!(\"../README.md\")]\n+\n+use std::borrow::Cow;\n+\n+/// Converts system paths into Unix paths. This is a noop on Unix systems, and replaces backslash\n+/// directory separators with forward slashes on Windows.\n+#[inline]\n+pub fn sys_to_unix(path: &str) -> Cow<'_, str> {\n+    #[cfg(not(target_family = \"windows\"))]\n+    {\n+        Cow::from(path)\n+    }\n+    #[cfg(target_family = \"windows\")]\n+    {\n+        Cow::Owned(path.replace(std::path::MAIN_SEPARATOR_STR, \"/\"))\n+    }\n+}\n+\n+/// Converts Unix paths into system paths. This is a noop on Unix systems, and replaces forward\n+/// slash directory separators with backslashes on Windows.\n+#[inline]\n+pub fn unix_to_sys(path: &str) -> Cow<'_, str> {\n+    #[cfg(not(target_family = \"windows\"))]\n+    {\n+        Cow::from(path)\n+    }\n+    #[cfg(target_family = \"windows\")]\n+    {\n+        Cow::Owned(path.replace('/', std::path::MAIN_SEPARATOR_STR))\n+    }\n+}\n+\n+/// Joins two /-separated paths into a normalized path.\n+/// Paths are concatenated with /.\n+///\n+/// see also [normalize_path] for normalization.\n+pub fn join_path(fs_path: &str, join: &str) -> Option<String> {\n+    // Paths that we join are written as source code (eg, `join_path(fs_path, \"foo/bar.js\")`) and\n+    // it's expected that they will never contain a backslash.\n+    debug_assert!(\n+        !join.contains('\\\\'),\n+        \"joined path {join} must not contain a Windows directory '\\\\', it must be normalized to \\\n+         Unix '/'\"\n+    );\n+\n+    // TODO: figure out why this freezes the benchmarks.\n+    // // an absolute path would leave the file system root\n+    // if Path::new(join).is_absolute() {\n+    //     return None;\n+    // }\n+\n+    if fs_path.is_empty() {\n+        normalize_path(join)\n+    } else if join.is_empty() {\n+        normalize_path(fs_path)\n+    } else {\n+        normalize_path(&[fs_path, \"/\", join].concat())\n+    }\n+}\n+\n+/// Normalizes a /-separated path into a form that contains no leading /, no double /, no \".\"\n+/// segment, no \"..\" segment.\n+///\n+/// Returns None if the path would need to start with \"..\" to be equal.\n+pub fn normalize_path(str: &str) -> Option<String> {\n+    let mut segments = Vec::new();\n+    for segment in str.split('/') {\n+        match segment {\n+            \".\" | \"\" => {}\n+            \"..\" => {\n+                segments.pop()?;\n+            }\n+            segment => {\n+                segments.push(segment);\n+            }\n+        }\n+    }\n+    Some(segments.join(\"/\"))\n+}\n+\n+/// Normalizes a /-separated request into a form that contains no leading /, no double /, and no \".\"\n+/// or \"..\" segments in the middle of the request.\n+///\n+/// A request might only start with a single \".\" segment and no \"..\" segments, or any positive\n+/// number of \"..\" segments but no \".\" segment.\n+pub fn normalize_request(str: &str) -> String {\n+    let mut segments = vec![\".\"];\n+    // Keeps track of our directory depth so that we can pop directories when encountering a \"..\".\n+    // If this is positive, then we're inside a directory and we can pop that. If it's 0, then we\n+    // can't pop the directory and we must keep the \"..\" in our segments. This is not the same as\n+    // the segments.len(), because we cannot pop a kept \"..\" when encountering another \"..\".\n+    let mut depth = 0;\n+    let mut popped_dot = false;\n+    for segment in str.split('/') {\n+        match segment {\n+            \".\" => {}\n+            \"..\" => {\n+                if depth > 0 {\n+                    depth -= 1;\n+                    segments.pop();\n+                } else {\n+                    // The first time we push a \"..\", we need to remove the \".\" we include by\n+                    // default.\n+                    if !popped_dot {\n+                        popped_dot = true;\n+                        segments.pop();\n+                    }\n+                    segments.push(segment);\n+                }\n+            }\n+            segment => {\n+                segments.push(segment);\n+                depth += 1;\n+            }\n+        }\n+    }\n+    segments.join(\"/\")\n+}\n+\n+pub fn get_relative_path_to(from: &str, target: &str) -> String {\n+    fn split(s: &str) -> impl Iterator<Item = &str> {\n+        let empty = s.is_empty();\n+        let mut iterator = s.split('/');\n+        if empty {\n+            iterator.next();\n+        }\n+        iterator\n+    }\n+\n+    let mut from_segments = split(from).peekable();\n+    let mut target_segments = split(target).peekable();\n+    while from_segments.peek() == target_segments.peek() {\n+        from_segments.next();\n+        if target_segments.next().is_none() {\n+            return \".\".to_string();\n+        }\n+    }\n+    let mut result = Vec::new();\n+    if from_segments.peek().is_none() {\n+        result.push(\".\");\n+    } else {\n+        while from_segments.next().is_some() {\n+            result.push(\"..\");\n+        }\n+    }\n+    for segment in target_segments {\n+        result.push(segment);\n+    }\n+    result.join(\"/\")\n+}\n+\n+pub fn get_parent_path(path: &str) -> &str {\n+    match str::rfind(path, '/') {\n+        Some(index) => &path[..index],\n+        None => \"\",\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+\n+    use rstest::*;\n+\n+    use super::*;\n+\n+    #[rstest]\n+    #[case(\"file.js\")]\n+    #[case(\"a/b/c/d/e/file.js\")]\n+    fn test_normalize_path_no_op(#[case] path: &str) {\n+        assert_eq!(path, normalize_path(path).unwrap());\n+    }\n+\n+    #[rstest]\n+    #[case(\"/file.js\", \"file.js\")]\n+    #[case(\"./file.js\", \"file.js\")]\n+    #[case(\"././file.js\", \"file.js\")]\n+    #[case(\"a/../c/../file.js\", \"file.js\")]\n+    fn test_normalize_path(#[case] path: &str, #[case] normalized: &str) {\n+        assert_eq!(normalized, normalize_path(path).unwrap());\n+    }\n+\n+    #[rstest]\n+    #[case(\"../file.js\")]\n+    #[case(\"a/../../file.js\")]\n+    fn test_normalize_path_invalid(#[case] path: &str) {\n+        assert_eq!(None, normalize_path(path));\n+    }\n+}"
        },
        {
            "sha": "8382ef4ecb6b20138e8c6bcba6d2c17162f2a712",
            "filename": "turbopack/crates/turbopack-core/Cargo.toml",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/turbopack%2Fcrates%2Fturbopack-core%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/turbopack%2Fcrates%2Fturbopack-core%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2FCargo.toml?ref=4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f",
            "patch": "@@ -41,6 +41,7 @@ turbo-tasks = { workspace = true }\n turbo-tasks-env = { workspace = true }\n turbo-tasks-fs = { workspace = true }\n turbo-tasks-hash = { workspace = true }\n+turbo-unix-path = { workspace = true }\n urlencoding = { workspace = true }\n bytes-str = { workspace = true }\n "
        },
        {
            "sha": "0c1f653ccc42d207a6deb10a94343b14de3cbd6a",
            "filename": "turbopack/crates/turbopack-core/src/resolve/mod.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 4,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fmod.rs?ref=4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f",
            "patch": "@@ -15,9 +15,8 @@ use turbo_tasks::{\n     FxIndexMap, FxIndexSet, NonLocalValue, ReadRef, ResolvedVc, SliceMap, TaskInput,\n     TryJoinIterExt, ValueToString, Vc, trace::TraceRawVcs,\n };\n-use turbo_tasks_fs::{\n-    FileSystemEntryType, FileSystemPath, RealPathResult, util::normalize_request,\n-};\n+use turbo_tasks_fs::{FileSystemEntryType, FileSystemPath, RealPathResult};\n+use turbo_unix_path::normalize_request;\n \n use self::{\n     options::{\n@@ -2108,7 +2107,7 @@ async fn resolve_into_folder(\n                         .await?\n                     && let Some(field_value) = package_json[name.as_str()].as_str()\n                 {\n-                    let normalized_request: RcStr = normalize_request(field_value).into();\n+                    let normalized_request = RcStr::from(normalize_request(field_value));\n                     if normalized_request.is_empty()\n                         || &*normalized_request == \".\"\n                         || &*normalized_request == \"./\""
        },
        {
            "sha": "db01e334655e68190ef8f24bb42f4a50f02d4040",
            "filename": "turbopack/crates/turbopack-core/src/resolve/pattern.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fpattern.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fpattern.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fpattern.rs?ref=4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f",
            "patch": "@@ -16,8 +16,8 @@ use turbo_tasks::{\n };\n use turbo_tasks_fs::{\n     FileSystemPath, LinkContent, LinkType, RawDirectoryContent, RawDirectoryEntry,\n-    util::normalize_path,\n };\n+use turbo_unix_path::normalize_path;\n \n #[turbo_tasks::value]\n #[derive(Hash, Clone, Debug, Default)]\n@@ -460,7 +460,7 @@ impl Pattern {\n             match pattern {\n                 Pattern::Constant(c) => {\n                     let normalized = c.replace('\\\\', \"/\");\n-                    *c = (*(normalize_path(normalized.as_str())?)).into();\n+                    *c = RcStr::from(normalize_path(normalized.as_str())?);\n                     Some(())\n                 }\n                 Pattern::Dynamic => Some(()),"
        },
        {
            "sha": "056d0115414d98d21c5f1f9566f139db4aec5639",
            "filename": "turbopack/crates/turbopack-tests/Cargo.toml",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/turbopack%2Fcrates%2Fturbopack-tests%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/turbopack%2Fcrates%2Fturbopack-tests%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2FCargo.toml?ref=4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f",
            "patch": "@@ -31,6 +31,7 @@ turbo-tasks-bytes = { workspace = true }\n turbo-tasks-env = { workspace = true }\n turbo-tasks-fs = { workspace = true }\n turbo-tasks-backend = { workspace = true }\n+turbo-unix-path = { workspace = true }\n turbopack-browser = { workspace = true, features = [\"test\"] }\n turbopack-core = { workspace = true, features = [\"issue_path\"] }\n turbopack-ecmascript-plugins = { workspace = true, features = ["
        },
        {
            "sha": "a84be6487f6772fc91fa012357f554f0c44aafe7",
            "filename": "turbopack/crates/turbopack-tests/tests/execution.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution.rs?ref=4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f",
            "patch": "@@ -21,8 +21,9 @@ use turbo_tasks_bytes::stream::SingleValue;\n use turbo_tasks_env::CommandLineProcessEnv;\n use turbo_tasks_fs::{\n     DiskFileSystem, FileContent, FileSystem, FileSystemEntryType, FileSystemPath,\n-    json::parse_json_with_source_context, util::sys_to_unix,\n+    json::parse_json_with_source_context,\n };\n+use turbo_unix_path::sys_to_unix;\n use turbopack::{\n     ModuleAssetContext,\n     css::chunk::CssChunkType,\n@@ -290,7 +291,7 @@ async fn prepare_test(resource: RcStr) -> Result<Vc<PreparedTest>> {\n         &*REPO_ROOT,\n         resource_path.display()\n     ))?;\n-    let relative_path: RcStr = sys_to_unix(relative_path.to_str().unwrap()).into();\n+    let relative_path = RcStr::from(sys_to_unix(relative_path.to_str().unwrap()));\n     let path = root_fs.root().await?.join(&relative_path)?;\n     let project_path = project_root.join(&relative_path)?;\n     let tests_path = project_fs"
        },
        {
            "sha": "021861136b101b14c706f5d3a39bbc635ed9e3b2",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot.rs?ref=4eb46d8ea51251ac8bc7ea974ecd059c1890ea5f",
            "patch": "@@ -16,8 +16,8 @@ use turbo_tasks_backend::{BackendOptions, TurboTasksBackend, noop_backing_storag\n use turbo_tasks_env::DotenvProcessEnv;\n use turbo_tasks_fs::{\n     DiskFileSystem, FileSystem, FileSystemPath, json::parse_json_with_source_context,\n-    util::sys_to_unix,\n };\n+use turbo_unix_path::sys_to_unix;\n use turbopack::{\n     ModuleAssetContext,\n     ecmascript::{EcmascriptInputTransform, TreeShakingMode, chunk::EcmascriptChunkType},\n@@ -264,7 +264,7 @@ async fn run_test_operation(resource: RcStr) -> Result<Vc<FileSystemPath>> {\n     let project_root = project_fs.root().owned().await?;\n \n     let relative_path = test_path.strip_prefix(&*REPO_ROOT)?;\n-    let relative_path: RcStr = sys_to_unix(relative_path.to_str().unwrap()).into();\n+    let relative_path = RcStr::from(sys_to_unix(relative_path.to_str().unwrap()));\n     let project_path = project_root.join(&relative_path)?;\n \n     let project_path_to_project_root = project_path"
        }
    ],
    "stats": {
        "total": 1568,
        "additions": 821,
        "deletions": 747
    }
}