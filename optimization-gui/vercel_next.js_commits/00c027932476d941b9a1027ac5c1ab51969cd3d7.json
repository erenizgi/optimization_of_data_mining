{
    "author": "ztanner",
    "message": "Revert \"Include server latency in debug info\" (#84932)\n\nReverts vercel/next.js#84580\n\nThis is failing certain tests in development.\n\nx-ref:\nhttps://github.com/vercel/next.js/actions/runs/18511231838/job/52758196715",
    "sha": "00c027932476d941b9a1027ac5c1ab51969cd3d7",
    "files": [
        {
            "sha": "8205e8eb66d0e64c3aae761c3206b4945704f8c3",
            "filename": "packages/next/src/client/components/router-reducer/create-initial-router-state.test.tsx",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/00c027932476d941b9a1027ac5c1ab51969cd3d7/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fcreate-initial-router-state.test.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/00c027932476d941b9a1027ac5c1ab51969cd3d7/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fcreate-initial-router-state.test.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fcreate-initial-router-state.test.tsx?ref=00c027932476d941b9a1027ac5c1ab51969cd3d7",
            "patch": "@@ -139,7 +139,6 @@ describe('createInitialRouterState', () => {\n       cache: expectedCache,\n       nextUrl: '/linking',\n       previousNextUrl: null,\n-      debugInfo: null,\n     }\n \n     expect(state).toMatchObject(expected)"
        },
        {
            "sha": "10e011496661832900c3737c0e965dc6d20f2d5a",
            "filename": "packages/next/src/client/components/router-reducer/create-initial-router-state.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/00c027932476d941b9a1027ac5c1ab51969cd3d7/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fcreate-initial-router-state.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/00c027932476d941b9a1027ac5c1ab51969cd3d7/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fcreate-initial-router-state.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fcreate-initial-router-state.ts?ref=00c027932476d941b9a1027ac5c1ab51969cd3d7",
            "patch": "@@ -111,7 +111,6 @@ export function createInitialRouterState({\n       (extractPathFromFlightRouterState(initialTree) || location?.pathname) ??\n       null,\n     previousNextUrl: null,\n-    debugInfo: null,\n   }\n \n   if (process.env.NODE_ENV !== 'development' && location) {\n@@ -147,7 +146,6 @@ export function createInitialRouterState({\n           prerendered && !process.env.__NEXT_CLIENT_SEGMENT_CACHE\n             ? STATIC_STALETIME_MS\n             : -1,\n-        debugInfo: null,\n       },\n       tree: initialState.tree,\n       prefetchCache: initialState.prefetchCache,"
        },
        {
            "sha": "3d19250610da2191b86d23021805d7087767526a",
            "filename": "packages/next/src/client/components/router-reducer/fetch-server-response.ts",
            "status": "modified",
            "additions": 21,
            "deletions": 84,
            "changes": 105,
            "blob_url": "https://github.com/vercel/next.js/blob/00c027932476d941b9a1027ac5c1ab51969cd3d7/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Ffetch-server-response.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/00c027932476d941b9a1027ac5c1ab51969cd3d7/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Ffetch-server-response.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Ffetch-server-response.ts?ref=00c027932476d941b9a1027ac5c1ab51969cd3d7",
            "patch": "@@ -2,10 +2,7 @@\n \n // TODO: Explicitly import from client.browser\n // eslint-disable-next-line import/no-extraneous-dependencies\n-import {\n-  createFromReadableStream as createFromReadableStreamBrowser,\n-  createFromFetch as createFromFetchBrowser,\n-} from 'react-server-dom-webpack/client'\n+import { createFromReadableStream as createFromReadableStreamBrowser } from 'react-server-dom-webpack/client'\n \n import type {\n   FlightRouterState,\n@@ -40,8 +37,6 @@ import { urlToUrlWithoutFlightMarker } from '../../route-params'\n \n const createFromReadableStream =\n   createFromReadableStreamBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromReadableStream']\n-const createFromFetch =\n-  createFromFetchBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromFetch']\n \n let createDebugChannel:\n   | typeof import('../../dev/debug-channel').createDebugChannel\n@@ -70,7 +65,6 @@ export type FetchServerResponseResult = {\n   prerendered: boolean\n   postponed: boolean\n   staleTime: number\n-  debugInfo: Array<any> | null\n }\n \n export type RequestHeaders = {\n@@ -97,7 +91,6 @@ function doMpaNavigation(url: string): FetchServerResponseResult {\n     prerendered: false,\n     postponed: false,\n     staleTime: -1,\n-    debugInfo: null,\n   }\n }\n \n@@ -182,17 +175,10 @@ export async function fetchServerResponse(\n       }\n     }\n \n-    // Typically, during a navigation, we decode the response using Flight's\n-    // `createFromFetch` API, which accepts a `fetch` promise.\n-    // TODO: Remove this check once the old PPR flag is removed\n-    const isLegacyPPR =\n-      process.env.__NEXT_PPR && !process.env.__NEXT_CACHE_COMPONENTS\n-    const shouldImmediatelyDecode = !isLegacyPPR\n-    const res = await createFetch<NavigationFlightResponse>(\n+    const res = await createFetch(\n       url,\n       headers,\n       fetchPriority,\n-      shouldImmediatelyDecode,\n       abortController.signal\n     )\n \n@@ -240,37 +226,26 @@ export async function fetchServerResponse(\n       ).waitForWebpackRuntimeHotUpdate()\n     }\n \n-    let flightResponsePromise = res.flightResponse\n-    if (flightResponsePromise === null) {\n-      // Typically, `createFetch` would have already started decoding the\n-      // Flight response. If it hasn't, though, we need to decode it now.\n-      // TODO: This should only be reachable if legacy PPR is enabled (i.e. PPR\n-      // without Cache Components). Remove this branch once legacy PPR\n-      // is deleted.\n-      const flightStream = postponed\n-        ? createUnclosingPrefetchStream(res.body)\n-        : res.body\n-      flightResponsePromise =\n-        createFromNextReadableStream<NavigationFlightResponse>(\n-          flightStream,\n-          headers\n-        )\n-    }\n-\n-    const flightResponse = await flightResponsePromise\n+    // Handle the `fetch` readable stream that can be unwrapped by `React.use`.\n+    const flightStream = postponed\n+      ? createUnclosingPrefetchStream(res.body)\n+      : res.body\n+    const response = await (createFromNextReadableStream(\n+      flightStream,\n+      headers\n+    ) as Promise<NavigationFlightResponse>)\n \n-    if (getAppBuildId() !== flightResponse.b) {\n+    if (getAppBuildId() !== response.b) {\n       return doMpaNavigation(res.url)\n     }\n \n     return {\n-      flightData: normalizeFlightData(flightResponse.f),\n+      flightData: normalizeFlightData(response.f),\n       canonicalUrl: canonicalUrl,\n       couldBeIntercepted: interception,\n-      prerendered: flightResponse.S,\n+      prerendered: response.S,\n       postponed,\n       staleTime,\n-      debugInfo: flightResponsePromise._debugInfo ?? null,\n     }\n   } catch (err) {\n     if (!abortController.signal.aborted) {\n@@ -290,7 +265,6 @@ export async function fetchServerResponse(\n       prerendered: false,\n       postponed: false,\n       staleTime: -1,\n-      debugInfo: null,\n     }\n   }\n }\n@@ -300,23 +274,21 @@ export async function fetchServerResponse(\n // the codebase. For example, there's some custom logic for manually following\n // redirects, so \"redirected\" in this type could be a composite of multiple\n // browser fetch calls; however, this fact should not leak to the caller.\n-export type RSCResponse<T> = {\n+export type RSCResponse = {\n   ok: boolean\n   redirected: boolean\n   headers: Headers\n   body: ReadableStream<Uint8Array> | null\n   status: number\n   url: string\n-  flightResponse: (Promise<T> & { _debugInfo?: Array<any> }) | null\n }\n \n-export async function createFetch<T>(\n+export async function createFetch(\n   url: URL,\n   headers: RequestHeaders,\n   fetchPriority: 'auto' | 'high' | 'low' | null,\n-  shouldImmediatelyDecode: boolean,\n   signal?: AbortSignal\n-): Promise<RSCResponse<T>> {\n+): Promise<RSCResponse> {\n   // TODO: In output: \"export\" mode, the headers do nothing. Omit them (and the\n   // cache busting search param) from the request so they're\n   // maximally cacheable.\n@@ -354,21 +326,7 @@ export async function createFetch<T>(\n   // track them separately.\n   let fetchUrl = new URL(url)\n   setCacheBustingSearchParam(fetchUrl, headers)\n-  let fetchPromise = fetch(fetchUrl, fetchOptions)\n-  // Immediately pass the fetch promise to the Flight client so that the debug\n-  // info includes the latency from the client to the server. The internal timer\n-  // in React starts as soon as `createFromFetch` is called.\n-  //\n-  // The only case where we don't do this is during a prefetch, because we have\n-  // to do some extra processing of the response stream (see\n-  // `createUnclosingPrefetchStream`). But this is fine, because a top-level\n-  // prefetch response never blocks a navigation; if it hasn't already been\n-  // written into the cache by the time the navigation happens, the router will\n-  // go straight to a dynamic request.\n-  let flightResponsePromise = shouldImmediatelyDecode\n-    ? createFromNextFetch<T>(fetchPromise, headers)\n-    : null\n-  let browserResponse = await fetchPromise\n+  let browserResponse = await fetch(fetchUrl, fetchOptions)\n \n   // If the server responds with a redirect (e.g. 307), and the redirected\n   // location does not contain the cache busting search param set in the\n@@ -421,14 +379,9 @@ export async function createFetch<T>(\n       //\n       // Append the cache busting search param to the redirected URL and\n       // fetch again.\n-      // TODO: We should abort the previous request.\n       fetchUrl = new URL(responseUrl)\n       setCacheBustingSearchParam(fetchUrl, headers)\n-      fetchPromise = fetch(fetchUrl, fetchOptions)\n-      flightResponsePromise = shouldImmediatelyDecode\n-        ? createFromNextFetch<T>(fetchPromise, headers)\n-        : null\n-      browserResponse = await fetchPromise\n+      browserResponse = await fetch(fetchUrl, fetchOptions)\n       // We just performed a manual redirect, so this is now true.\n       redirected = true\n     }\n@@ -439,7 +392,7 @@ export async function createFetch<T>(\n   const responseUrl = new URL(browserResponse.url, fetchUrl)\n   responseUrl.searchParams.delete(NEXT_RSC_UNION_QUERY)\n \n-  const rscResponse: RSCResponse<T> = {\n+  const rscResponse: RSCResponse = {\n     url: responseUrl.href,\n \n     // This is true if any redirects occurred, either automatically by the\n@@ -455,38 +408,22 @@ export async function createFetch<T>(\n     headers: browserResponse.headers,\n     body: browserResponse.body,\n     status: browserResponse.status,\n-\n-    // This is the exact promise returned by `createFromFetch`. It contains\n-    // debug information that we need to transfer to any derived promises that\n-    // are later rendered by React.\n-    flightResponse: flightResponsePromise,\n   }\n \n   return rscResponse\n }\n \n-export function createFromNextReadableStream<T>(\n+export function createFromNextReadableStream(\n   flightStream: ReadableStream<Uint8Array>,\n   requestHeaders: RequestHeaders\n-): Promise<T> {\n+): Promise<unknown> {\n   return createFromReadableStream(flightStream, {\n     callServer,\n     findSourceMapURL,\n     debugChannel: createDebugChannel && createDebugChannel(requestHeaders),\n   })\n }\n \n-function createFromNextFetch<T>(\n-  promiseForResponse: Promise<Response>,\n-  requestHeaders: RequestHeaders\n-): Promise<T> & { _debugInfo?: Array<any> } {\n-  return createFromFetch(promiseForResponse, {\n-    callServer,\n-    findSourceMapURL,\n-    debugChannel: createDebugChannel && createDebugChannel(requestHeaders),\n-  })\n-}\n-\n function createUnclosingPrefetchStream(\n   originalFlightStream: ReadableStream<Uint8Array>\n ): ReadableStream<Uint8Array> {"
        },
        {
            "sha": "aae3287998b4823781d3cccddbcc682e7b8f9b3a",
            "filename": "packages/next/src/client/components/router-reducer/handle-mutable.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/00c027932476d941b9a1027ac5c1ab51969cd3d7/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fhandle-mutable.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/00c027932476d941b9a1027ac5c1ab51969cd3d7/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fhandle-mutable.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fhandle-mutable.ts?ref=00c027932476d941b9a1027ac5c1ab51969cd3d7",
            "patch": "@@ -87,6 +87,5 @@ export function handleMutable(\n       : state.tree,\n     nextUrl,\n     previousNextUrl: previousNextUrl,\n-    debugInfo: mutable.collectedDebugInfo ?? null,\n   }\n }"
        },
        {
            "sha": "b88dc0ba9ded13332a0f8558e7908b17b1d50195",
            "filename": "packages/next/src/client/components/router-reducer/ppr-navigations.ts",
            "status": "modified",
            "additions": 33,
            "deletions": 74,
            "changes": 107,
            "blob_url": "https://github.com/vercel/next.js/blob/00c027932476d941b9a1027ac5c1ab51969cd3d7/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fppr-navigations.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/00c027932476d941b9a1027ac5c1ab51969cd3d7/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fppr-navigations.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fppr-navigations.ts?ref=00c027932476d941b9a1027ac5c1ab51969cd3d7",
            "patch": "@@ -790,7 +790,7 @@ export function listenForDynamicRequest(\n   responsePromise: Promise<FetchServerResponseResult>\n ) {\n   responsePromise.then(\n-    ({ flightData, debugInfo }: FetchServerResponseResult) => {\n+    ({ flightData }: FetchServerResponseResult) => {\n       if (typeof flightData === 'string') {\n         // Happens when navigating to page in `pages` from `app`. We shouldn't\n         // get here because should have already handled this during\n@@ -817,19 +817,18 @@ export function listenForDynamicRequest(\n           segmentPath,\n           serverRouterState,\n           dynamicData,\n-          dynamicHead,\n-          debugInfo\n+          dynamicHead\n         )\n       }\n \n       // Now that we've exhausted all the data we received from the server, if\n       // there are any remaining pending tasks in the tree, abort them now.\n       // If there's any missing data, it will trigger a lazy fetch.\n-      abortTask(task, null, debugInfo)\n+      abortTask(task, null)\n     },\n     (error: any) => {\n       // This will trigger an error during render\n-      abortTask(task, error, null)\n+      abortTask(task, error)\n     }\n   )\n }\n@@ -839,8 +838,7 @@ function writeDynamicDataIntoPendingTask(\n   segmentPath: FlightSegmentPath,\n   serverRouterState: FlightRouterState,\n   dynamicData: CacheNodeSeedData,\n-  dynamicHead: HeadData,\n-  debugInfo: Array<any> | null\n+  dynamicHead: HeadData\n ) {\n   // The data sent by the server represents only a subtree of the app. We need\n   // to find the part of the task tree that matches the server response, and\n@@ -879,17 +877,15 @@ function writeDynamicDataIntoPendingTask(\n     task,\n     serverRouterState,\n     dynamicData,\n-    dynamicHead,\n-    debugInfo\n+    dynamicHead\n   )\n }\n \n function finishTaskUsingDynamicDataPayload(\n   task: SPANavigationTask,\n   serverRouterState: FlightRouterState,\n   dynamicData: CacheNodeSeedData,\n-  dynamicHead: HeadData,\n-  debugInfo: Array<any> | null\n+  dynamicHead: HeadData\n ) {\n   if (task.dynamicRequestTree === null) {\n     // Everything in this subtree is already complete. Bail out.\n@@ -910,8 +906,7 @@ function finishTaskUsingDynamicDataPayload(\n         task.route,\n         serverRouterState,\n         dynamicData,\n-        dynamicHead,\n-        debugInfo\n+        dynamicHead\n       )\n       // Set this to null to indicate that this task is now complete.\n       task.dynamicRequestTree = null\n@@ -942,8 +937,7 @@ function finishTaskUsingDynamicDataPayload(\n           taskChild,\n           serverRouterStateChild,\n           dynamicDataChild,\n-          dynamicHead,\n-          debugInfo\n+          dynamicHead\n         )\n       }\n     }\n@@ -1043,8 +1037,7 @@ function finishPendingCacheNode(\n   taskState: FlightRouterState,\n   serverState: FlightRouterState,\n   dynamicData: CacheNodeSeedData,\n-  dynamicHead: HeadData,\n-  debugInfo: Array<any> | null\n+  dynamicHead: HeadData\n ): void {\n   // Writes a dynamic response into an existing Cache Node tree. This does _not_\n   // create a new tree, it updates the existing tree in-place. So it must follow\n@@ -1093,20 +1086,19 @@ function finishPendingCacheNode(\n             taskStateChild,\n             serverStateChild,\n             dataChild,\n-            dynamicHead,\n-            debugInfo\n+            dynamicHead\n           )\n         } else {\n           // The server never returned data for this segment. Trigger a lazy\n           // fetch during render. This shouldn't happen because the Route Tree\n           // and the Seed Data tree sent by the server should always be the same\n           // shape when part of the same server response.\n-          abortPendingCacheNode(taskStateChild, cacheNodeChild, null, debugInfo)\n+          abortPendingCacheNode(taskStateChild, cacheNodeChild, null)\n         }\n       } else {\n         // The server never returned data for this segment. Trigger a lazy\n         // fetch during render.\n-        abortPendingCacheNode(taskStateChild, cacheNodeChild, null, debugInfo)\n+        abortPendingCacheNode(taskStateChild, cacheNodeChild, null)\n       }\n     } else {\n       // The server response matches what was expected to receive, but there's\n@@ -1128,7 +1120,7 @@ function finishPendingCacheNode(\n     // This is a deferred RSC promise. We can fulfill it with the data we just\n     // received from the server. If it was already resolved by a different\n     // navigation, then this does nothing because we can't overwrite data.\n-    rsc.resolve(dynamicSegmentData, debugInfo)\n+    rsc.resolve(dynamicSegmentData)\n   } else {\n     // This is not a deferred RSC promise, nor is it empty, so it must have\n     // been populated by a different navigation. We must not overwrite it.\n@@ -1139,23 +1131,19 @@ function finishPendingCacheNode(\n   const loading = cacheNode.loading\n   if (isDeferredRsc(loading)) {\n     const dynamicLoading = dynamicData[3]\n-    loading.resolve(dynamicLoading, debugInfo)\n+    loading.resolve(dynamicLoading)\n   }\n \n   // Check if this is a leaf segment. If so, it will have a `head` property with\n   // a pending promise that needs to be resolved with the dynamic head from\n   // the server.\n   const head = cacheNode.head\n   if (isDeferredRsc(head)) {\n-    head.resolve(dynamicHead, debugInfo)\n+    head.resolve(dynamicHead)\n   }\n }\n \n-export function abortTask(\n-  task: SPANavigationTask,\n-  error: any,\n-  debugInfo: Array<any> | null\n-): void {\n+export function abortTask(task: SPANavigationTask, error: any): void {\n   const cacheNode = task.node\n   if (cacheNode === null) {\n     // This indicates the task is already complete.\n@@ -1166,13 +1154,13 @@ export function abortTask(\n   if (taskChildren === null) {\n     // Reached the leaf task node. This is the root of a pending cache\n     // node tree.\n-    abortPendingCacheNode(task.route, cacheNode, error, debugInfo)\n+    abortPendingCacheNode(task.route, cacheNode, error)\n   } else {\n     // This is an intermediate task node. Keep traversing until we reach a\n     // task node with no children. That will be the root of the cache node tree\n     // that needs to be resolved.\n     for (const taskChild of taskChildren.values()) {\n-      abortTask(taskChild, error, debugInfo)\n+      abortTask(taskChild, error)\n     }\n   }\n \n@@ -1183,8 +1171,7 @@ export function abortTask(\n function abortPendingCacheNode(\n   routerState: FlightRouterState,\n   cacheNode: CacheNode,\n-  error: any,\n-  debugInfo: Array<any> | null\n+  error: any\n ): void {\n   // For every pending segment in the tree, resolve its `rsc` promise to `null`\n   // to trigger a lazy fetch during render.\n@@ -1205,7 +1192,7 @@ function abortPendingCacheNode(\n     const segmentKeyChild = createRouterCacheKey(segmentChild)\n     const cacheNodeChild = segmentMapChild.get(segmentKeyChild)\n     if (cacheNodeChild !== undefined) {\n-      abortPendingCacheNode(routerStateChild, cacheNodeChild, error, debugInfo)\n+      abortPendingCacheNode(routerStateChild, cacheNodeChild, error)\n     } else {\n       // This shouldn't happen because we're traversing the same tree that was\n       // used to construct the cache nodes in the first place.\n@@ -1216,16 +1203,16 @@ function abortPendingCacheNode(\n   if (isDeferredRsc(rsc)) {\n     if (error === null) {\n       // This will trigger a lazy fetch during render.\n-      rsc.resolve(null, debugInfo)\n+      rsc.resolve(null)\n     } else {\n       // This will trigger an error during rendering.\n-      rsc.reject(error, debugInfo)\n+      rsc.reject(error)\n     }\n   }\n \n   const loading = cacheNode.loading\n   if (isDeferredRsc(loading)) {\n-    loading.resolve(null, debugInfo)\n+    loading.resolve(null)\n   }\n \n   // Check if this is a leaf segment. If so, it will have a `head` property with\n@@ -1234,7 +1221,7 @@ function abortPendingCacheNode(\n   // the app. We want the segment to error, not the entire app.\n   const head = cacheNode.head\n   if (isDeferredRsc(head)) {\n-    head.resolve(null, debugInfo)\n+    head.resolve(null)\n   }\n }\n \n@@ -1306,28 +1293,25 @@ const DEFERRED = Symbol()\n \n type PendingDeferredRsc<T> = Promise<T> & {\n   status: 'pending'\n-  resolve: (value: T, debugInfo: Array<any> | null) => void\n-  reject: (error: any, debugInfo: Array<any> | null) => void\n+  resolve: (value: T) => void\n+  reject: (error: any) => void\n   tag: Symbol\n-  _debugInfo: Array<any>\n }\n \n type FulfilledDeferredRsc<T> = Promise<T> & {\n   status: 'fulfilled'\n   value: T\n-  resolve: (value: T, debugInfo: Array<any> | null) => void\n-  reject: (error: any, debugInfo: Array<any> | null) => void\n+  resolve: (value: T) => void\n+  reject: (error: any) => void\n   tag: Symbol\n-  _debugInfo: Array<any>\n }\n \n type RejectedDeferredRsc<T> = Promise<T> & {\n   status: 'rejected'\n   reason: any\n-  resolve: (value: T, debugInfo: Array<any> | null) => void\n-  reject: (error: any, debugInfo: Array<any> | null) => void\n+  resolve: (value: T) => void\n+  reject: (error: any) => void\n   tag: Symbol\n-  _debugInfo: Array<any>\n }\n \n type DeferredRsc<T extends React.ReactNode = React.ReactNode> =\n@@ -1346,54 +1330,29 @@ function isDeferredRsc(value: any): value is DeferredRsc {\n function createDeferredRsc<\n   T extends React.ReactNode = React.ReactNode,\n >(): PendingDeferredRsc<T> {\n-  // Create an unresolved promise that represents data derived from a Flight\n-  // response. The promise will be resolved later as soon as we start receiving\n-  // data from the server, i.e. as soon as the Flight client decodes and returns\n-  // the top-level response object.\n-\n-  // The `_debugInfo` field contains profiling information. Promises that are\n-  // created by Flight already have this info added by React; for any derived\n-  // promise created by the router, we need to transfer the Flight debug info\n-  // onto the derived promise.\n-  //\n-  // The debug info represents the latency between the start of the navigation\n-  // and the start of rendering. (It does not represent the time it takes for\n-  // whole stream to finish.)\n-  const debugInfo: Array<any> = []\n-\n   let resolve: any\n   let reject: any\n   const pendingRsc = new Promise<T>((res, rej) => {\n     resolve = res\n     reject = rej\n   }) as PendingDeferredRsc<T>\n   pendingRsc.status = 'pending'\n-  pendingRsc.resolve = (value: T, responseDebugInfo: Array<any> | null) => {\n+  pendingRsc.resolve = (value: T) => {\n     if (pendingRsc.status === 'pending') {\n       const fulfilledRsc: FulfilledDeferredRsc<T> = pendingRsc as any\n       fulfilledRsc.status = 'fulfilled'\n       fulfilledRsc.value = value\n-      if (responseDebugInfo !== null) {\n-        // Transfer the debug info to the derived promise.\n-        debugInfo.push.apply(debugInfo, responseDebugInfo)\n-      }\n       resolve(value)\n     }\n   }\n-  pendingRsc.reject = (error: any, responseDebugInfo: Array<any> | null) => {\n+  pendingRsc.reject = (error: any) => {\n     if (pendingRsc.status === 'pending') {\n       const rejectedRsc: RejectedDeferredRsc<T> = pendingRsc as any\n       rejectedRsc.status = 'rejected'\n       rejectedRsc.reason = error\n-      if (responseDebugInfo !== null) {\n-        // Transfer the debug info to the derived promise.\n-        debugInfo.push.apply(debugInfo, responseDebugInfo)\n-      }\n       reject(error)\n     }\n   }\n   pendingRsc.tag = DEFERRED\n-  pendingRsc._debugInfo = debugInfo\n-\n   return pendingRsc\n }"
        },
        {
            "sha": "454e627d46eb7dca1babe8fe50e66565abbfe0e9",
            "filename": "packages/next/src/client/components/router-reducer/reducers/navigate-reducer.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/00c027932476d941b9a1027ac5c1ab51969cd3d7/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fnavigate-reducer.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/00c027932476d941b9a1027ac5c1ab51969cd3d7/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fnavigate-reducer.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fnavigate-reducer.ts?ref=00c027932476d941b9a1027ac5c1ab51969cd3d7",
            "patch": "@@ -210,8 +210,7 @@ export function navigateReducer(\n       state.cache,\n       state.tree,\n       state.nextUrl,\n-      shouldScroll,\n-      mutable\n+      shouldScroll\n     )\n     return handleNavigationResult(url, state, mutable, pendingPush, result)\n   }"
        },
        {
            "sha": "1fbfd3e08d51487dc259fbc5384da5422b317c30",
            "filename": "packages/next/src/client/components/router-reducer/reducers/restore-reducer.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/00c027932476d941b9a1027ac5c1ab51969cd3d7/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Frestore-reducer.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/00c027932476d941b9a1027ac5c1ab51969cd3d7/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Frestore-reducer.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Frestore-reducer.ts?ref=00c027932476d941b9a1027ac5c1ab51969cd3d7",
            "patch": "@@ -46,6 +46,5 @@ export function restoreReducer(\n     tree: treeToRestore,\n     nextUrl: extractPathFromFlightRouterState(treeToRestore) ?? url.pathname,\n     previousNextUrl: null,\n-    debugInfo: null,\n   }\n }"
        },
        {
            "sha": "2acc1752f48f68344a6459e539c8e2cd1031e64e",
            "filename": "packages/next/src/client/components/router-reducer/reducers/server-action-reducer.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/00c027932476d941b9a1027ac5c1ab51969cd3d7/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fserver-action-reducer.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/00c027932476d941b9a1027ac5c1ab51969cd3d7/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fserver-action-reducer.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fserver-action-reducer.ts?ref=00c027932476d941b9a1027ac5c1ab51969cd3d7",
            "patch": "@@ -439,7 +439,6 @@ export function serverActionReducer(\n               // TODO: We should be able to set this if the server action\n               // returned a fully static response.\n               staleTime: -1,\n-              debugInfo: null,\n             },\n             tree: state.tree,\n             prefetchCache: state.prefetchCache,"
        },
        {
            "sha": "3930fd037eeb0b2751de24da59147e907507b6c2",
            "filename": "packages/next/src/client/components/router-reducer/router-reducer-types.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 6,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/00c027932476d941b9a1027ac5c1ab51969cd3d7/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Frouter-reducer-types.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/00c027932476d941b9a1027ac5c1ab51969cd3d7/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Frouter-reducer-types.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Frouter-reducer-types.ts?ref=00c027932476d941b9a1027ac5c1ab51969cd3d7",
            "patch": "@@ -35,7 +35,6 @@ export interface Mutable {\n   shouldScroll?: boolean\n   preserveCustomHistoryState?: boolean\n   onlyHashChange?: boolean\n-  collectedDebugInfo?: Array<unknown>\n }\n \n export interface ServerActionMutable extends Mutable {\n@@ -260,14 +259,10 @@ export type AppRouterState = {\n    * The previous next-url that was used previous to a dynamic navigation.\n    */\n   previousNextUrl: string | null\n-\n-  debugInfo: Array<unknown> | null\n }\n \n export type ReadonlyReducerState = Readonly<AppRouterState>\n-export type ReducerState =\n-  | (Promise<AppRouterState> & { _debugInfo?: Array<unknown> })\n-  | AppRouterState\n+export type ReducerState = Promise<AppRouterState> | AppRouterState\n export type ReducerActions = Readonly<\n   | RefreshAction\n   | NavigateAction"
        },
        {
            "sha": "5b156707deeab247fedf24c5a1ee8a6d52816e0e",
            "filename": "packages/next/src/client/components/segment-cache-impl/cache.ts",
            "status": "modified",
            "additions": 13,
            "deletions": 24,
            "changes": 37,
            "blob_url": "https://github.com/vercel/next.js/blob/00c027932476d941b9a1027ac5c1ab51969cd3d7/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/00c027932476d941b9a1027ac5c1ab51969cd3d7/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts?ref=00c027932476d941b9a1027ac5c1ab51969cd3d7",
            "patch": "@@ -1450,10 +1450,10 @@ export async function fetchRouteOnCacheMiss(\n           routeCacheLru.updateSize(entry, size)\n         }\n       )\n-      const serverData = await createFromNextReadableStream<RootTreePrefetch>(\n+      const serverData = await (createFromNextReadableStream(\n         prefetchStream,\n         headers\n-      )\n+      ) as Promise<RootTreePrefetch>)\n       if (serverData.buildId !== getAppBuildId()) {\n         // The server build does not match the client. Treat as a 404. During\n         // an actual navigation, the router will trigger an MPA navigation.\n@@ -1502,11 +1502,10 @@ export async function fetchRouteOnCacheMiss(\n           routeCacheLru.updateSize(entry, size)\n         }\n       )\n-      const serverData =\n-        await createFromNextReadableStream<NavigationFlightResponse>(\n-          prefetchStream,\n-          headers\n-        )\n+      const serverData = await (createFromNextReadableStream(\n+        prefetchStream,\n+        headers\n+      ) as Promise<NavigationFlightResponse>)\n       if (serverData.b !== getAppBuildId()) {\n         // The server build does not match the client. Treat as a 404. During\n         // an actual navigation, the router will trigger an MPA navigation.\n@@ -1524,7 +1523,7 @@ export async function fetchRouteOnCacheMiss(\n         // The non-PPR response format is what we'd get if we prefetched these segments\n         // using the LoadingBoundary fetch strategy, so mark their cache entries accordingly.\n         FetchStrategy.LoadingBoundary,\n-        response as RSCResponse<NavigationFlightResponse>,\n+        response,\n         serverData,\n         entry,\n         couldBeIntercepted,\n@@ -1788,7 +1787,7 @@ export async function fetchSegmentPrefetchesUsingDynamicRequest(\n       Date.now(),\n       task,\n       fetchStrategy,\n-      response as RSCResponse<NavigationFlightResponse>,\n+      response,\n       serverData,\n       isResponsePartial,\n       route,\n@@ -1811,7 +1810,7 @@ function writeDynamicTreeResponseIntoCache(\n     | FetchStrategy.LoadingBoundary\n     | FetchStrategy.PPRRuntime\n     | FetchStrategy.Full,\n-  response: RSCResponse<NavigationFlightResponse>,\n+  response: RSCResponse,\n   serverData: NavigationFlightResponse,\n   entry: PendingRouteCacheEntry,\n   couldBeIntercepted: boolean,\n@@ -1916,7 +1915,7 @@ function writeDynamicRenderResponseIntoCache(\n     | FetchStrategy.LoadingBoundary\n     | FetchStrategy.PPRRuntime\n     | FetchStrategy.Full,\n-  response: RSCResponse<NavigationFlightResponse>,\n+  response: RSCResponse,\n   serverData: NavigationFlightResponse,\n   isResponsePartial: boolean,\n   route: FulfilledRouteCacheEntry,\n@@ -2140,22 +2139,12 @@ function writeSeedDataIntoCache(\n   }\n }\n \n-async function fetchPrefetchResponse<T>(\n+async function fetchPrefetchResponse(\n   url: URL,\n   headers: RequestHeaders\n-): Promise<RSCResponse<T> | null> {\n+): Promise<RSCResponse | null> {\n   const fetchPriority = 'low'\n-  // When issuing a prefetch request, don't immediately decode the response; we\n-  // use the lower level `createFromResponse` API instead because we need to do\n-  // some extra processing of the response stream. See\n-  // `createPrefetchResponseStream` for more details.\n-  const shouldImmediatelyDecode = false\n-  const response = await createFetch<T>(\n-    url,\n-    headers,\n-    fetchPriority,\n-    shouldImmediatelyDecode\n-  )\n+  const response = await createFetch(url, headers, fetchPriority)\n   if (!response.ok) {\n     return null\n   }"
        },
        {
            "sha": "591a4576efc8d11777631329ce6eb51c0d865ea6",
            "filename": "packages/next/src/client/components/segment-cache-impl/navigation.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 19,
            "changes": 24,
            "blob_url": "https://github.com/vercel/next.js/blob/00c027932476d941b9a1027ac5c1ab51969cd3d7/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fnavigation.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/00c027932476d941b9a1027ac5c1ab51969cd3d7/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fnavigation.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fnavigation.ts?ref=00c027932476d941b9a1027ac5c1ab51969cd3d7",
            "patch": "@@ -81,8 +81,7 @@ export function navigate(\n   currentCacheNode: CacheNode,\n   currentFlightRouterState: FlightRouterState,\n   nextUrl: string | null,\n-  shouldScroll: boolean,\n-  accumulation: { collectedDebugInfo?: Array<unknown> }\n+  shouldScroll: boolean\n ): NavigationResult {\n   const now = Date.now()\n   const href = url.href\n@@ -184,10 +183,6 @@ export function navigate(\n   }\n \n   // There's no matching prefetch for this route in the cache.\n-  let collectedDebugInfo = accumulation.collectedDebugInfo ?? []\n-  if (accumulation.collectedDebugInfo === undefined) {\n-    collectedDebugInfo = accumulation.collectedDebugInfo = []\n-  }\n   return {\n     tag: NavigationResultTag.Async,\n     data: navigateDynamicallyWithNoPrefetch(\n@@ -199,8 +194,7 @@ export function navigate(\n       currentCacheNode,\n       currentFlightRouterState,\n       shouldScroll,\n-      url.hash,\n-      collectedDebugInfo\n+      url.hash\n     ),\n   }\n }\n@@ -410,8 +404,7 @@ async function navigateDynamicallyWithNoPrefetch(\n   currentCacheNode: CacheNode,\n   currentFlightRouterState: FlightRouterState,\n   shouldScroll: boolean,\n-  hash: string,\n-  collectedDebugInfo: Array<unknown>\n+  hash: string\n ): Promise<\n   MPANavigationResult | SuccessfulNavigationResult | NoOpNavigationResult\n > {\n@@ -431,15 +424,8 @@ async function navigateDynamicallyWithNoPrefetch(\n     flightRouterState: currentFlightRouterState,\n     nextUrl,\n   })\n-  const {\n-    flightData,\n-    canonicalUrl: canonicalUrlOverride,\n-    debugInfo: debugInfoFromResponse,\n-  } = await promiseForDynamicServerResponse\n-\n-  if (debugInfoFromResponse !== null) {\n-    collectedDebugInfo.push(...debugInfoFromResponse)\n-  }\n+  const { flightData, canonicalUrl: canonicalUrlOverride } =\n+    await promiseForDynamicServerResponse\n \n   if (typeof flightData === 'string') {\n     // This is an MPA navigation."
        },
        {
            "sha": "04c8ebc292622a2b7c2ece66c82b43324b29ee76",
            "filename": "packages/next/src/client/components/use-action-queue.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 24,
            "changes": 26,
            "blob_url": "https://github.com/vercel/next.js/blob/00c027932476d941b9a1027ac5c1ab51969cd3d7/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fuse-action-queue.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/00c027932476d941b9a1027ac5c1ab51969cd3d7/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fuse-action-queue.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fuse-action-queue.ts?ref=00c027932476d941b9a1027ac5c1ab51969cd3d7",
            "patch": "@@ -1,5 +1,5 @@\n import type { Dispatch } from 'react'\n-import React, { use, useMemo } from 'react'\n+import React, { use } from 'react'\n import { isThenable } from '../../shared/lib/is-thenable'\n import type { AppRouterActionQueue } from './app-router-instance'\n import type {\n@@ -50,27 +50,5 @@ export function useActionQueue(\n       actionQueue.dispatch(action, setState)\n   }\n \n-  // When navigating to a non-prefetched route, then App Router state will be\n-  // blocked until the server responds. We need to transfer the `_debugInfo`\n-  // from the underlying Flight response onto the top-level promise that is\n-  // passed to React (via `use`) so that the latency is accurately represented\n-  // in the React DevTools.\n-  const stateWithDebugInfo = useMemo(() => {\n-    if (isThenable(state)) {\n-      const debugInfo: Array<unknown> = []\n-      const promiseWithDebugInfo = Promise.resolve(state).then((asyncState) => {\n-        if (asyncState.debugInfo !== null) {\n-          debugInfo.push(...asyncState.debugInfo)\n-        }\n-        return asyncState\n-      }) as Promise<AppRouterState> & { _debugInfo?: Array<unknown> }\n-      promiseWithDebugInfo._debugInfo = debugInfo\n-      return promiseWithDebugInfo\n-    }\n-    return state\n-  }, [state])\n-\n-  return isThenable(stateWithDebugInfo)\n-    ? use(stateWithDebugInfo)\n-    : stateWithDebugInfo\n+  return isThenable(state) ? use(state) : state\n }"
        },
        {
            "sha": "7050501ecf28eb62c6369eff56d0c45b95420180",
            "filename": "packages/next/src/client/route-params.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 4,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/00c027932476d941b9a1027ac5c1ab51969cd3d7/packages%2Fnext%2Fsrc%2Fclient%2Froute-params.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/00c027932476d941b9a1027ac5c1ab51969cd3d7/packages%2Fnext%2Fsrc%2Fclient%2Froute-params.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Froute-params.ts?ref=00c027932476d941b9a1027ac5c1ab51969cd3d7",
            "patch": "@@ -21,9 +21,7 @@ export type RouteParam = {\n   type: DynamicParamTypesShort\n }\n \n-export function getRenderedSearch(\n-  response: RSCResponse<unknown>\n-): NormalizedSearch {\n+export function getRenderedSearch(response: RSCResponse): NormalizedSearch {\n   // If the server performed a rewrite, the search params used to render the\n   // page will be different from the params in the request URL. In this case,\n   // the response will include a header that gives the rewritten search query.\n@@ -39,7 +37,7 @@ export function getRenderedSearch(\n     .search as NormalizedSearch\n }\n \n-export function getRenderedPathname(response: RSCResponse<unknown>): string {\n+export function getRenderedPathname(response: RSCResponse): string {\n   // If the server performed a rewrite, the pathname used to render the\n   // page will be different from the pathname in the request URL. In this case,\n   // the response will include a header that gives the rewritten pathname."
        }
    ],
    "stats": {
        "total": 321,
        "additions": 78,
        "deletions": 243
    }
}