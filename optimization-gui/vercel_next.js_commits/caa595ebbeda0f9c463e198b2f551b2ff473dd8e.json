{
    "author": "sokra",
    "message": "Turbopack: handle removed routes (#77890)\n\n### Why?\r\n\r\nBefore `get_endpoints` gives you a lot of `Vc<Endpoint>`, which we keep around and subscribe to. That is a problem as endpoint can also vanish at any time. e. g. when the folder is removed.\r\n`Vc<Endpoint>` was not able to represent this state. The subscription throw an error as the Vc is no longer existant. So the error was technically correct here (not a bug in turbo-tasks).\r\nBut in practice we don't want to have this error. We want to have a clean end of the subscription without any error. That's why I change it to `Vc<Option<Endpoint>>`, which allows to represent the non-existance of an endpoint.\r\nThis can (resp. need to be) handled in subscriptions, which can report e. g. a `NotFound` result or a change event (for server_changed).\r\n\r\n### What?\r\n\r\navoid having inactive Vcs when routes are removed.\r\n\r\ninstead use an `Option<Endpoint>` to allow respresenting removed endpoints and handle these in subscriptions correctly.",
    "sha": "caa595ebbeda0f9c463e198b2f551b2ff473dd8e",
    "files": [
        {
            "sha": "9aa75aa661d60b1b7ecb7977d44d7bd0ec61d71b",
            "filename": "crates/napi/src/next_api/endpoint.rs",
            "status": "modified",
            "additions": 8,
            "deletions": 14,
            "changes": 22,
            "blob_url": "https://github.com/vercel/next.js/blob/caa595ebbeda0f9c463e198b2f551b2ff473dd8e/crates%2Fnapi%2Fsrc%2Fnext_api%2Fendpoint.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/caa595ebbeda0f9c463e198b2f551b2ff473dd8e/crates%2Fnapi%2Fsrc%2Fnext_api%2Fendpoint.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnapi%2Fsrc%2Fnext_api%2Fendpoint.rs?ref=caa595ebbeda0f9c463e198b2f551b2ff473dd8e",
            "patch": "@@ -3,10 +3,11 @@ use std::{ops::Deref, sync::Arc};\n use anyhow::Result;\n use napi::{bindgen_prelude::External, JsFunction};\n use next_api::{\n+    operation::OptionEndpoint,\n     paths::ServerPath,\n     route::{\n-        endpoint_server_changed_operation, endpoint_write_to_disk_operation, Endpoint,\n-        EndpointOutputPaths,\n+        endpoint_client_changed_operation, endpoint_server_changed_operation,\n+        endpoint_write_to_disk_operation, EndpointOutputPaths,\n     },\n };\n use tracing::Instrument;\n@@ -71,7 +72,7 @@ impl From<Option<EndpointOutputPaths>> for NapiWrittenEndpoint {\n                 server_paths: server_paths.into_iter().map(From::from).collect(),\n                 ..Default::default()\n             },\n-            None => Self {\n+            Some(EndpointOutputPaths::NotFound) | None => Self {\n                 r#type: \"none\".to_string(),\n                 ..Default::default()\n             },\n@@ -85,10 +86,10 @@ impl From<Option<EndpointOutputPaths>> for NapiWrittenEndpoint {\n //    some async functions (in this case `endpoint_write_to_disk`) can cause\n //    higher-ranked lifetime errors. See https://github.com/rust-lang/rust/issues/102211\n // 2. the type_complexity clippy lint.\n-pub struct ExternalEndpoint(pub VcArc<Box<dyn Endpoint>>);\n+pub struct ExternalEndpoint(pub VcArc<OptionEndpoint>);\n \n impl Deref for ExternalEndpoint {\n-    type Target = VcArc<Box<dyn Endpoint>>;\n+    type Target = VcArc<OptionEndpoint>;\n \n     fn deref(&self) -> &Self::Target {\n         &self.0\n@@ -105,7 +106,7 @@ struct WrittenEndpointWithIssues {\n \n #[turbo_tasks::function(operation)]\n async fn get_written_endpoint_with_issues_operation(\n-    endpoint_op: OperationVc<Box<dyn Endpoint>>,\n+    endpoint_op: OperationVc<OptionEndpoint>,\n ) -> Result<Vc<WrittenEndpointWithIssues>> {\n     let write_to_disk_op = endpoint_write_to_disk_operation(endpoint_op);\n     let (written, issues, diagnostics, effects) =\n@@ -214,7 +215,7 @@ impl Eq for EndpointIssuesAndDiags {}\n \n #[turbo_tasks::function(operation)]\n async fn subscribe_issues_and_diags_operation(\n-    endpoint_op: OperationVc<Box<dyn Endpoint>>,\n+    endpoint_op: OperationVc<OptionEndpoint>,\n     should_include_issues: bool,\n ) -> Result<Vc<EndpointIssuesAndDiags>> {\n     let changed_op = endpoint_server_changed_operation(endpoint_op);\n@@ -241,13 +242,6 @@ async fn subscribe_issues_and_diags_operation(\n     }\n }\n \n-#[turbo_tasks::function(operation)]\n-fn endpoint_client_changed_operation(\n-    endpoint_op: OperationVc<Box<dyn Endpoint>>,\n-) -> Vc<Completion> {\n-    endpoint_op.connect().client_changed()\n-}\n-\n #[napi(ts_return_type = \"{ __napiType: \\\"RootTask\\\" }\")]\n pub fn endpoint_client_changed_subscribe(\n     #[napi(ts_arg_type = \"{ __napiType: \\\"Endpoint\\\" }\")] endpoint: External<ExternalEndpoint>,"
        },
        {
            "sha": "155bbb70b58318624da43d59ea2d585acdc3ea48",
            "filename": "crates/napi/src/next_api/project.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/caa595ebbeda0f9c463e198b2f551b2ff473dd8e/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/caa595ebbeda0f9c463e198b2f551b2ff473dd8e/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs?ref=caa595ebbeda0f9c463e198b2f551b2ff473dd8e",
            "patch": "@@ -9,7 +9,8 @@ use napi::{\n use next_api::{\n     entrypoints::Entrypoints,\n     operation::{\n-        EntrypointsOperation, InstrumentationOperation, MiddlewareOperation, RouteOperation,\n+        EntrypointsOperation, InstrumentationOperation, MiddlewareOperation, OptionEndpoint,\n+        RouteOperation,\n     },\n     project::{\n         DefineEnv, DraftModeOptions, PartialProjectOptions, Project, ProjectContainer,\n@@ -580,7 +581,7 @@ pub struct NapiRoute {\n \n impl NapiRoute {\n     fn from_route(pathname: String, value: RouteOperation, turbo_tasks: &NextTurboTasks) -> Self {\n-        let convert_endpoint = |endpoint: OperationVc<Box<dyn Endpoint>>| {\n+        let convert_endpoint = |endpoint: OperationVc<OptionEndpoint>| {\n             Some(External::new(ExternalEndpoint(VcArc::new(\n                 turbo_tasks.clone(),\n                 endpoint,"
        },
        {
            "sha": "ad9c28667d015a08e7530891f91a04392bb8f84f",
            "filename": "crates/next-api/src/operation.rs",
            "status": "modified",
            "additions": 132,
            "deletions": 47,
            "changes": 179,
            "blob_url": "https://github.com/vercel/next.js/blob/caa595ebbeda0f9c463e198b2f551b2ff473dd8e/crates%2Fnext-api%2Fsrc%2Foperation.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/caa595ebbeda0f9c463e198b2f551b2ff473dd8e/crates%2Fnext-api%2Fsrc%2Foperation.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Foperation.rs?ref=caa595ebbeda0f9c463e198b2f551b2ff473dd8e",
            "patch": "@@ -3,7 +3,7 @@ use serde::{Deserialize, Serialize};\n use turbo_rcstr::RcStr;\n use turbo_tasks::{\n     debug::ValueDebugFormat, get_effects, trace::TraceRawVcs, CollectiblesSource, FxIndexMap,\n-    NonLocalValue, OperationVc, ResolvedVc, Vc,\n+    NonLocalValue, OperationValue, OperationVc, ResolvedVc, TaskInput, Vc,\n };\n use turbopack_core::{diagnostics::Diagnostic, issue::IssueDescriptionExt};\n \n@@ -25,9 +25,9 @@ pub struct EntrypointsOperation {\n     pub routes: FxIndexMap<RcStr, RouteOperation>,\n     pub middleware: Option<MiddlewareOperation>,\n     pub instrumentation: Option<InstrumentationOperation>,\n-    pub pages_document_endpoint: OperationVc<Box<dyn Endpoint>>,\n-    pub pages_app_endpoint: OperationVc<Box<dyn Endpoint>>,\n-    pub pages_error_endpoint: OperationVc<Box<dyn Endpoint>>,\n+    pub pages_document_endpoint: OperationVc<OptionEndpoint>,\n+    pub pages_app_endpoint: OperationVc<OptionEndpoint>,\n+    pub pages_error_endpoint: OperationVc<OptionEndpoint>,\n }\n \n /// Removes diagnostics, issues, and effects from the top-level `entrypoints` operation so that\n@@ -53,96 +53,181 @@ impl EntrypointsOperation {\n             routes: e\n                 .routes\n                 .iter()\n-                .map(|(k, v)| (k.clone(), wrap_route(v, entrypoints)))\n+                .map(|(k, v)| (k.clone(), pick_route(entrypoints, k.clone(), v)))\n                 .collect(),\n-            middleware: e.middleware.as_ref().map(|m| MiddlewareOperation {\n-                endpoint: wrap(m.endpoint, entrypoints),\n+            middleware: e.middleware.as_ref().map(|_| MiddlewareOperation {\n+                endpoint: pick_endpoint(entrypoints, EndpointSelector::Middleware),\n             }),\n             instrumentation: e\n                 .instrumentation\n                 .as_ref()\n-                .map(|i| InstrumentationOperation {\n-                    node_js: wrap(i.node_js, entrypoints),\n-                    edge: wrap(i.edge, entrypoints),\n+                .map(|_| InstrumentationOperation {\n+                    node_js: pick_endpoint(entrypoints, EndpointSelector::InstrumentationNodeJs),\n+                    edge: pick_endpoint(entrypoints, EndpointSelector::InstrumentationEdge),\n                 }),\n-            pages_document_endpoint: wrap(e.pages_document_endpoint, entrypoints),\n-            pages_app_endpoint: wrap(e.pages_app_endpoint, entrypoints),\n-            pages_error_endpoint: wrap(e.pages_error_endpoint, entrypoints),\n+            pages_document_endpoint: pick_endpoint(entrypoints, EndpointSelector::PagesDocument),\n+            pages_app_endpoint: pick_endpoint(entrypoints, EndpointSelector::PagesApp),\n+            pages_error_endpoint: pick_endpoint(entrypoints, EndpointSelector::PagesError),\n         }\n         .cell())\n     }\n }\n \n-fn wrap_route(route: &Route, entrypoints: OperationVc<Entrypoints>) -> RouteOperation {\n+fn pick_route(entrypoints: OperationVc<Entrypoints>, key: RcStr, route: &Route) -> RouteOperation {\n     match route {\n-        Route::Page {\n-            html_endpoint,\n-            data_endpoint,\n-        } => RouteOperation::Page {\n-            html_endpoint: wrap(*html_endpoint, entrypoints),\n-            data_endpoint: wrap(*data_endpoint, entrypoints),\n+        Route::Page { .. } => RouteOperation::Page {\n+            html_endpoint: pick_endpoint(entrypoints, EndpointSelector::RoutePageHtml(key.clone())),\n+            data_endpoint: pick_endpoint(entrypoints, EndpointSelector::RoutePageData(key)),\n         },\n-        Route::PageApi { endpoint } => RouteOperation::PageApi {\n-            endpoint: wrap(*endpoint, entrypoints),\n+        Route::PageApi { .. } => RouteOperation::PageApi {\n+            endpoint: pick_endpoint(entrypoints, EndpointSelector::RoutePageApi(key)),\n         },\n         Route::AppPage(pages) => RouteOperation::AppPage(\n             pages\n                 .iter()\n-                .map(|p| AppPageRouteOperation {\n+                .enumerate()\n+                .map(|(i, p)| AppPageRouteOperation {\n                     original_name: p.original_name.clone(),\n-                    html_endpoint: wrap(p.html_endpoint, entrypoints),\n-                    rsc_endpoint: wrap(p.rsc_endpoint, entrypoints),\n+                    html_endpoint: pick_endpoint(\n+                        entrypoints,\n+                        EndpointSelector::RouteAppPageHtml(key.clone(), i),\n+                    ),\n+                    rsc_endpoint: pick_endpoint(\n+                        entrypoints,\n+                        EndpointSelector::RouteAppPageRsc(key.clone(), i),\n+                    ),\n                 })\n                 .collect(),\n         ),\n-        Route::AppRoute {\n-            original_name,\n-            endpoint,\n-        } => RouteOperation::AppRoute {\n+        Route::AppRoute { original_name, .. } => RouteOperation::AppRoute {\n             original_name: original_name.clone(),\n-            endpoint: wrap(*endpoint, entrypoints),\n+            endpoint: pick_endpoint(entrypoints, EndpointSelector::RouteAppRoute(key)),\n         },\n         Route::Conflict => RouteOperation::Conflict,\n     }\n }\n \n-/// Given a resolved `Endpoint` and the `Entrypoints` operation that it comes from, connect the\n-/// operation and return a `OperationVc` of the `Entrypoint`. This `Endpoint` operation will keep\n-/// the entire `Entrypoints` operation alive.\n+#[derive(\n+    Debug,\n+    Clone,\n+    TaskInput,\n+    Serialize,\n+    Deserialize,\n+    TraceRawVcs,\n+    PartialEq,\n+    Eq,\n+    Hash,\n+    ValueDebugFormat,\n+    NonLocalValue,\n+    OperationValue,\n+)]\n+enum EndpointSelector {\n+    RoutePageHtml(RcStr),\n+    RoutePageData(RcStr),\n+    RoutePageApi(RcStr),\n+    RouteAppPageHtml(RcStr, usize),\n+    RouteAppPageRsc(RcStr, usize),\n+    RouteAppRoute(RcStr),\n+    InstrumentationNodeJs,\n+    InstrumentationEdge,\n+    Middleware,\n+    PagesDocument,\n+    PagesApp,\n+    PagesError,\n+}\n+\n+#[turbo_tasks::value(transparent)]\n+pub struct OptionEndpoint(Option<ResolvedVc<Box<dyn Endpoint>>>);\n+\n+/// Given a selector and the `Entrypoints` operation that it comes from, connect the operation and\n+/// return an `OperationVc` containing the selected value. The returned operation will keep the\n+/// entire `Entrypoints` operation alive.\n #[turbo_tasks::function(operation)]\n-fn wrap(\n-    endpoint: ResolvedVc<Box<dyn Endpoint>>,\n+async fn pick_endpoint(\n     op: OperationVc<Entrypoints>,\n-) -> Vc<Box<dyn Endpoint>> {\n-    let _ = op.connect();\n-    *endpoint\n+    selector: EndpointSelector,\n+) -> Result<Vc<OptionEndpoint>> {\n+    let endpoints = op.connect().strongly_consistent().await?;\n+    let endpoint = match selector {\n+        EndpointSelector::InstrumentationNodeJs => {\n+            endpoints.instrumentation.as_ref().map(|i| i.node_js)\n+        }\n+        EndpointSelector::InstrumentationEdge => endpoints.instrumentation.as_ref().map(|i| i.edge),\n+        EndpointSelector::Middleware => endpoints.middleware.as_ref().map(|m| m.endpoint),\n+        EndpointSelector::PagesDocument => Some(endpoints.pages_document_endpoint),\n+        EndpointSelector::PagesApp => Some(endpoints.pages_app_endpoint),\n+        EndpointSelector::PagesError => Some(endpoints.pages_error_endpoint),\n+        EndpointSelector::RoutePageHtml(name) => {\n+            if let Some(Route::Page { html_endpoint, .. }) = endpoints.routes.get(&name) {\n+                Some(*html_endpoint)\n+            } else {\n+                None\n+            }\n+        }\n+        EndpointSelector::RoutePageData(name) => {\n+            if let Some(Route::Page { data_endpoint, .. }) = endpoints.routes.get(&name) {\n+                Some(*data_endpoint)\n+            } else {\n+                None\n+            }\n+        }\n+        EndpointSelector::RoutePageApi(name) => {\n+            if let Some(Route::PageApi { endpoint }) = endpoints.routes.get(&name) {\n+                Some(*endpoint)\n+            } else {\n+                None\n+            }\n+        }\n+        EndpointSelector::RouteAppPageHtml(name, i) => {\n+            if let Some(Route::AppPage(pages)) = endpoints.routes.get(&name) {\n+                pages.get(i).as_ref().map(|p| p.html_endpoint)\n+            } else {\n+                None\n+            }\n+        }\n+        EndpointSelector::RouteAppPageRsc(name, i) => {\n+            if let Some(Route::AppPage(pages)) = endpoints.routes.get(&name) {\n+                pages.get(i).as_ref().map(|p| p.rsc_endpoint)\n+            } else {\n+                None\n+            }\n+        }\n+        EndpointSelector::RouteAppRoute(name) => {\n+            if let Some(Route::AppRoute { endpoint, .. }) = endpoints.routes.get(&name) {\n+                Some(*endpoint)\n+            } else {\n+                None\n+            }\n+        }\n+    };\n+    Ok(Vc::cell(endpoint))\n }\n \n #[derive(Serialize, Deserialize, TraceRawVcs, PartialEq, Eq, ValueDebugFormat, NonLocalValue)]\n pub struct InstrumentationOperation {\n-    pub node_js: OperationVc<Box<dyn Endpoint>>,\n-    pub edge: OperationVc<Box<dyn Endpoint>>,\n+    pub node_js: OperationVc<OptionEndpoint>,\n+    pub edge: OperationVc<OptionEndpoint>,\n }\n \n #[derive(Serialize, Deserialize, TraceRawVcs, PartialEq, Eq, ValueDebugFormat, NonLocalValue)]\n pub struct MiddlewareOperation {\n-    pub endpoint: OperationVc<Box<dyn Endpoint>>,\n+    pub endpoint: OperationVc<OptionEndpoint>,\n }\n \n #[turbo_tasks::value(shared)]\n #[derive(Clone, Debug)]\n pub enum RouteOperation {\n     Page {\n-        html_endpoint: OperationVc<Box<dyn Endpoint>>,\n-        data_endpoint: OperationVc<Box<dyn Endpoint>>,\n+        html_endpoint: OperationVc<OptionEndpoint>,\n+        data_endpoint: OperationVc<OptionEndpoint>,\n     },\n     PageApi {\n-        endpoint: OperationVc<Box<dyn Endpoint>>,\n+        endpoint: OperationVc<OptionEndpoint>,\n     },\n     AppPage(Vec<AppPageRouteOperation>),\n     AppRoute {\n         original_name: RcStr,\n-        endpoint: OperationVc<Box<dyn Endpoint>>,\n+        endpoint: OperationVc<OptionEndpoint>,\n     },\n     Conflict,\n }\n@@ -160,6 +245,6 @@ pub enum RouteOperation {\n )]\n pub struct AppPageRouteOperation {\n     pub original_name: RcStr,\n-    pub html_endpoint: OperationVc<Box<dyn Endpoint>>,\n-    pub rsc_endpoint: OperationVc<Box<dyn Endpoint>>,\n+    pub html_endpoint: OperationVc<OptionEndpoint>,\n+    pub rsc_endpoint: OperationVc<OptionEndpoint>,\n }"
        },
        {
            "sha": "c6baa51efd4655aa82b91e7ce789ebdb4be8d10a",
            "filename": "crates/next-api/src/route.rs",
            "status": "modified",
            "additions": 29,
            "deletions": 9,
            "changes": 38,
            "blob_url": "https://github.com/vercel/next.js/blob/caa595ebbeda0f9c463e198b2f551b2ff473dd8e/crates%2Fnext-api%2Fsrc%2Froute.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/caa595ebbeda0f9c463e198b2f551b2ff473dd8e/crates%2Fnext-api%2Fsrc%2Froute.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Froute.rs?ref=caa595ebbeda0f9c463e198b2f551b2ff473dd8e",
            "patch": "@@ -10,7 +10,7 @@ use turbopack_core::{\n     output::OutputAssets,\n };\n \n-use crate::{paths::ServerPath, project::Project};\n+use crate::{operation::OptionEndpoint, paths::ServerPath, project::Project};\n \n #[derive(\n     TraceRawVcs,\n@@ -97,17 +97,36 @@ async fn endpoint_output_assets_operation(\n }\n \n #[turbo_tasks::function(operation)]\n-pub fn endpoint_write_to_disk_operation(\n-    endpoint: OperationVc<Box<dyn Endpoint>>,\n-) -> Vc<EndpointOutputPaths> {\n-    endpoint_write_to_disk(endpoint.connect())\n+pub async fn endpoint_write_to_disk_operation(\n+    endpoint: OperationVc<OptionEndpoint>,\n+) -> Result<Vc<EndpointOutputPaths>> {\n+    Ok(if let Some(endpoint) = *endpoint.connect().await? {\n+        endpoint_write_to_disk(*endpoint)\n+    } else {\n+        EndpointOutputPaths::NotFound.cell()\n+    })\n+}\n+\n+#[turbo_tasks::function(operation)]\n+pub async fn endpoint_server_changed_operation(\n+    endpoint: OperationVc<OptionEndpoint>,\n+) -> Result<Vc<Completion>> {\n+    Ok(if let Some(endpoint) = *endpoint.connect().await? {\n+        endpoint.server_changed()\n+    } else {\n+        Completion::new()\n+    })\n }\n \n #[turbo_tasks::function(operation)]\n-pub fn endpoint_server_changed_operation(\n-    endpoint: OperationVc<Box<dyn Endpoint>>,\n-) -> Vc<Completion> {\n-    endpoint.connect().server_changed()\n+pub async fn endpoint_client_changed_operation(\n+    endpoint: OperationVc<OptionEndpoint>,\n+) -> Result<Vc<Completion>> {\n+    Ok(if let Some(endpoint) = *endpoint.connect().await? {\n+        endpoint.client_changed()\n+    } else {\n+        Completion::new()\n+    })\n }\n \n #[turbo_tasks::value(shared)]\n@@ -131,6 +150,7 @@ pub enum EndpointOutputPaths {\n         server_paths: Vec<ServerPath>,\n         client_paths: Vec<RcStr>,\n     },\n+    NotFound,\n }\n \n /// The routes as map from pathname to route. (pathname includes the leading"
        },
        {
            "sha": "0da35d0bb65d86784e37cb80903e296049cb391f",
            "filename": "test/development/app-hmr/hmr.test.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 6,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/caa595ebbeda0f9c463e198b2f551b2ff473dd8e/test%2Fdevelopment%2Fapp-hmr%2Fhmr.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/caa595ebbeda0f9c463e198b2f551b2ff473dd8e/test%2Fdevelopment%2Fapp-hmr%2Fhmr.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Fapp-hmr%2Fhmr.test.ts?ref=caa595ebbeda0f9c463e198b2f551b2ff473dd8e",
            "patch": "@@ -50,6 +50,8 @@ describe(`app-dir-hmr`, () => {\n         // The new page should be rendered\n         const newHTML = await next.render('/folder-renamed')\n         expect(newHTML).toContain('Hello')\n+\n+        expect(next.cliOutput).not.toContain('FATAL')\n       } finally {\n         // Rename it back\n         await next.renameFolder('app/folder-renamed', 'app/folder')\n@@ -89,7 +91,6 @@ describe(`app-dir-hmr`, () => {\n         // details are unimportant.\n         expect(fastRefreshLogs).toEqual(\n           expect.arrayContaining([\n-            { source: 'log', message: '[Fast Refresh] rebuilding' },\n             {\n               source: 'log',\n               message: expect.stringContaining('[Fast Refresh] done in '),\n@@ -102,6 +103,8 @@ describe(`app-dir-hmr`, () => {\n       await retry(async () => {\n         expect(await browser.elementByCss('p').text()).toBe('mac')\n       })\n+\n+      expect(next.cliOutput).not.toContain('FATAL')\n     })\n \n     it.each(['node', 'node-module-var', 'edge', 'edge-module-var'])(\n@@ -118,7 +121,7 @@ describe(`app-dir-hmr`, () => {\n             expect(logs).toEqual(\n               expect.arrayContaining([\n                 expect.objectContaining({\n-                  message: '[Fast Refresh] rebuilding',\n+                  message: expect.stringContaining('[Fast Refresh] done'),\n                   source: 'log',\n                 }),\n               ])\n@@ -143,6 +146,8 @@ describe(`app-dir-hmr`, () => {\n         await retry(async () => {\n           expect(await browser.elementByCss('p').text()).toBe('mac')\n         })\n+\n+        expect(next.cliOutput).not.toContain('FATAL')\n       }\n     )\n \n@@ -168,10 +173,6 @@ describe(`app-dir-hmr`, () => {\n       // TODO: Should assert on all logs but these are cluttered with logs from our test utils (e.g. playwright tracing or webdriver)\n       expect(logs).toEqual(\n         expect.arrayContaining([\n-          {\n-            message: '[Fast Refresh] rebuilding',\n-            source: 'log',\n-          },\n           {\n             message: expect.stringContaining('[Fast Refresh] done in'),\n             source: 'log',\n@@ -187,6 +188,8 @@ describe(`app-dir-hmr`, () => {\n       )\n       // No MPA navigation triggered\n       expect(await browser.eval('window.__TEST_NO_RELOAD')).toEqual(true)\n+\n+      expect(next.cliOutput).not.toContain('FATAL')\n     })\n   })\n })"
        }
    ],
    "stats": {
        "total": 259,
        "additions": 181,
        "deletions": 78
    }
}