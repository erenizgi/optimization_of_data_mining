{
    "author": "bgw",
    "message": "Turbopack: Add a custom serde_self_describing Serializer/Deserializer (#86885)\n\nImplements a minimal custom serde `Serializer` and `Deserializer` on top of bincode with a custom self-describing format. The API is exposed as functions that can be used in `#[bincode(with = \"...\")]` attributes.\n\nThis doesn't encode as efficiently as `pot`, but it lets us get rid of that dependency entirely. It also gives us a more efficient option than `serde_json` for certain values.",
    "sha": "b26b2b71792eebad4ade5362281a5bee68cd059e",
    "files": [
        {
            "sha": "9aefeb617573a9edfd4e37b2c1894700423ecd80",
            "filename": "Cargo.lock",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/b26b2b71792eebad4ade5362281a5bee68cd059e/Cargo.lock",
            "raw_url": "https://github.com/vercel/next.js/raw/b26b2b71792eebad4ade5362281a5bee68cd059e/Cargo.lock",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/Cargo.lock?ref=b26b2b71792eebad4ade5362281a5bee68cd059e",
            "patch": "@@ -9108,7 +9108,6 @@ dependencies = [\n  \"mime\",\n  \"ringmap\",\n  \"serde\",\n- \"serde_json\",\n  \"smallvec\",\n  \"unty\",\n ]\n@@ -9135,6 +9134,7 @@ name = \"turbo-persistence\"\n version = \"0.1.0\"\n dependencies = [\n  \"anyhow\",\n+ \"bincode 2.0.1\",\n  \"bitfield\",\n  \"byteorder\",\n  \"dashmap 6.1.0\",\n@@ -9154,6 +9154,7 @@ dependencies = [\n  \"tempfile\",\n  \"thread_local\",\n  \"tracing\",\n+ \"turbo-bincode\",\n  \"twox-hash 2.1.0\",\n  \"zstd\",\n ]\n@@ -9227,7 +9228,6 @@ dependencies = [\n  \"once_cell\",\n  \"parking_lot\",\n  \"pin-project-lite\",\n- \"pot\",\n  \"rayon\",\n  \"regex\",\n  \"rustc-hash 2.1.1\","
        },
        {
            "sha": "4a5c543f779dc426ca33a2c3a853e324268120c6",
            "filename": "crates/next-core/src/next_config.rs",
            "status": "modified",
            "additions": 19,
            "deletions": 19,
            "changes": 38,
            "blob_url": "https://github.com/vercel/next.js/blob/b26b2b71792eebad4ade5362281a5bee68cd059e/crates%2Fnext-core%2Fsrc%2Fnext_config.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b26b2b71792eebad4ade5362281a5bee68cd059e/crates%2Fnext-core%2Fsrc%2Fnext_config.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_config.rs?ref=b26b2b71792eebad4ade5362281a5bee68cd059e",
            "patch": "@@ -92,7 +92,7 @@ pub struct NextConfig {\n     cache_handler: Option<RcStr>,\n     #[bincode(with_serde)]\n     cache_handlers: Option<FxIndexMap<RcStr, RcStr>>,\n-    #[bincode(with = \"turbo_bincode::serde_json\")]\n+    #[bincode(with = \"turbo_bincode::serde_self_describing\")]\n     env: FxIndexMap<String, JsonValue>,\n     experimental: ExperimentalConfig,\n     images: ImageConfig,\n@@ -101,12 +101,12 @@ pub struct NextConfig {\n     react_production_profiling: Option<bool>,\n     react_strict_mode: Option<bool>,\n     transpile_packages: Option<Vec<RcStr>>,\n-    #[bincode(with = \"turbo_bincode::serde_json\")]\n+    #[bincode(with = \"turbo_bincode::serde_self_describing\")]\n     modularize_imports: Option<FxIndexMap<String, ModularizeImportPackageConfig>>,\n     dist_dir: RcStr,\n     dist_dir_root: RcStr,\n     deployment_id: Option<RcStr>,\n-    #[bincode(with = \"turbo_bincode::serde_json\")]\n+    #[bincode(with = \"turbo_bincode::serde_self_describing\")]\n     sass_options: Option<serde_json::Value>,\n     trailing_slash: Option<bool>,\n     asset_prefix: Option<RcStr>,\n@@ -119,9 +119,9 @@ pub struct NextConfig {\n     output: Option<OutputType>,\n     turbopack: Option<TurbopackConfig>,\n     production_browser_source_maps: bool,\n-    #[bincode(with = \"turbo_bincode::serde_json\")]\n+    #[bincode(with = \"turbo_bincode::serde_self_describing\")]\n     output_file_tracing_includes: Option<serde_json::Value>,\n-    #[bincode(with = \"turbo_bincode::serde_json\")]\n+    #[bincode(with = \"turbo_bincode::serde_self_describing\")]\n     output_file_tracing_excludes: Option<serde_json::Value>,\n     // TODO: This option is not respected, it uses Turbopack's root instead.\n     output_file_tracing_root: Option<RcStr>,\n@@ -154,9 +154,9 @@ pub struct NextConfig {\n     http_agent_options: HttpAgentConfig,\n     on_demand_entries: OnDemandEntriesConfig,\n     powered_by_header: bool,\n-    #[bincode(with = \"turbo_bincode::serde_json\")]\n+    #[bincode(with = \"turbo_bincode::serde_self_describing\")]\n     public_runtime_config: FxIndexMap<String, serde_json::Value>,\n-    #[bincode(with = \"turbo_bincode::serde_json\")]\n+    #[bincode(with = \"turbo_bincode::serde_self_describing\")]\n     server_runtime_config: FxIndexMap<String, serde_json::Value>,\n     static_page_generation_timeout: f64,\n     target: Option<String>,\n@@ -686,9 +686,9 @@ pub enum RemotePatternProtocol {\n )]\n #[serde(rename_all = \"camelCase\")]\n pub struct TurbopackConfig {\n-    #[bincode(with = \"turbo_bincode::serde_json\")]\n+    #[bincode(with = \"turbo_bincode::serde_self_describing\")]\n     pub rules: Option<FxIndexMap<RcStr, RuleConfigCollection>>,\n-    #[bincode(with = \"turbo_bincode::serde_json\")]\n+    #[bincode(with = \"turbo_bincode::serde_self_describing\")]\n     pub resolve_alias: Option<FxIndexMap<RcStr, JsonValue>>,\n     pub resolve_extensions: Option<Vec<RcStr>>,\n     pub debug_ids: Option<bool>,\n@@ -955,7 +955,7 @@ pub struct ExperimentalConfig {\n     /// @see [api reference](https://nextjs.org/docs/app/api-reference/next-config-js/mdxRs)\n     mdx_rs: Option<MdxRsOptions>,\n     strict_next_head: Option<bool>,\n-    #[bincode(with = \"turbo_bincode::serde_json\")]\n+    #[bincode(with = \"turbo_bincode::serde_self_describing\")]\n     swc_plugins: Option<Vec<(RcStr, serde_json::Value)>>,\n     external_middleware_rewrites_resolve: Option<bool>,\n     scroll_restoration: Option<bool>,\n@@ -964,7 +964,7 @@ pub struct ExperimentalConfig {\n     middleware_prefetch: Option<MiddlewarePrefetchType>,\n     /// optimizeCss can be boolean or critters' option object\n     /// Use Record<string, unknown> as critters doesn't export its Option type ([link](https://github.com/GoogleChromeLabs/critters/blob/a590c05f9197b656d2aeaae9369df2483c26b072/packages/critters/src/index.d.ts))\n-    #[bincode(with = \"turbo_bincode::serde_json\")]\n+    #[bincode(with = \"turbo_bincode::serde_self_describing\")]\n     optimize_css: Option<serde_json::Value>,\n     next_script_workers: Option<bool>,\n     web_vitals_attribution: Option<Vec<RcStr>>,\n@@ -982,15 +982,15 @@ pub struct ExperimentalConfig {\n     adjust_font_fallbacks_with_size_adjust: Option<bool>,\n     after: Option<bool>,\n     app_document_preloading: Option<bool>,\n-    #[bincode(with = \"turbo_bincode::serde_json\")]\n+    #[bincode(with = \"turbo_bincode::serde_self_describing\")]\n     cache_life: Option<FxIndexMap<String, CacheLifeProfile>>,\n     case_sensitive_routes: Option<bool>,\n     cpus: Option<f64>,\n     cra_compat: Option<bool>,\n     disable_optimized_loading: Option<bool>,\n     disable_postcss_preset_env: Option<bool>,\n     esm_externals: Option<EsmExternals>,\n-    #[bincode(with = \"turbo_bincode::serde_json\")]\n+    #[bincode(with = \"turbo_bincode::serde_self_describing\")]\n     extension_alias: Option<serde_json::Value>,\n     external_dir: Option<bool>,\n     /// If set to `false`, webpack won't fall back to polyfill Node.js modules\n@@ -1005,7 +1005,7 @@ pub struct ExperimentalConfig {\n     instrumentation_hook: Option<bool>,\n     client_trace_metadata: Option<Vec<String>>,\n     large_page_data_bytes: Option<f64>,\n-    #[bincode(with = \"turbo_bincode::serde_json\")]\n+    #[bincode(with = \"turbo_bincode::serde_self_describing\")]\n     logging: Option<serde_json::Value>,\n     memory_based_workers_count: Option<bool>,\n     /// Optimize React APIs for server builds.\n@@ -1024,7 +1024,7 @@ pub struct ExperimentalConfig {\n     /// @internal Used by the Next.js internals only.\n     trust_host_header: Option<bool>,\n \n-    #[bincode(with = \"turbo_bincode::serde_json\")]\n+    #[bincode(with = \"turbo_bincode::serde_self_describing\")]\n     url_imports: Option<serde_json::Value>,\n     /// This option is to enable running the Webpack build in a worker thread\n     /// (doesn't apply to Turbopack).\n@@ -1397,7 +1397,7 @@ pub struct ResolveExtensions(Option<Vec<RcStr>>);\n \n #[turbo_tasks::value(transparent)]\n pub struct SwcPlugins(\n-    #[bincode(with = \"turbo_bincode::serde_json\")] Vec<(RcStr, serde_json::Value)>,\n+    #[bincode(with = \"turbo_bincode::serde_self_describing\")] Vec<(RcStr, serde_json::Value)>,\n );\n \n #[turbo_tasks::value(transparent)]\n@@ -1415,7 +1415,7 @@ pub struct OptionServerActions(Option<ServerActions>);\n \n #[turbo_tasks::value(transparent)]\n pub struct OptionJsonValue(\n-    #[bincode(with = \"turbo_bincode::serde_json\")] pub Option<serde_json::Value>,\n+    #[bincode(with = \"turbo_bincode::serde_self_describing\")] pub Option<serde_json::Value>,\n );\n \n fn turbopack_config_documentation_link() -> RcStr {\n@@ -1468,7 +1468,7 @@ impl Issue for InvalidLoaderRuleRenameAsIssue {\n \n #[turbo_tasks::value(shared)]\n struct InvalidLoaderRuleConditionIssue {\n-    #[bincode(with = \"turbo_bincode::serde_json\")]\n+    #[bincode(with = \"turbo_bincode::serde_self_describing\")]\n     condition: ConfigConditionItem,\n     config_file_path: FileSystemPath,\n }\n@@ -2218,7 +2218,7 @@ impl NextConfig {\n #[derive(Clone, Debug, Default, PartialEq, Serialize, Deserialize, Encode, Decode)]\n #[serde(rename_all = \"camelCase\")]\n pub struct JsConfig {\n-    #[bincode(with = \"turbo_bincode::serde_json\")]\n+    #[bincode(with = \"turbo_bincode::serde_self_describing\")]\n     compiler_options: Option<serde_json::Value>,\n }\n "
        },
        {
            "sha": "d556b550099312cebe3949de19984d3fdadcbb4f",
            "filename": "turbopack/crates/turbo-bincode/Cargo.toml",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/b26b2b71792eebad4ade5362281a5bee68cd059e/turbopack%2Fcrates%2Fturbo-bincode%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/b26b2b71792eebad4ade5362281a5bee68cd059e/turbopack%2Fcrates%2Fturbo-bincode%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-bincode%2FCargo.toml?ref=b26b2b71792eebad4ade5362281a5bee68cd059e",
            "patch": "@@ -17,6 +17,5 @@ indexmap = { workspace = true }\n mime = { workspace = true }\n ringmap = { workspace = true }\n serde = { workspace = true }\n-serde_json = { workspace = true }\n smallvec = { workspace = true }\n unty = { workspace = true }"
        },
        {
            "sha": "a70a3a71f02d0b63286aa464fca88f35dbc7f2da",
            "filename": "turbopack/crates/turbo-bincode/src/lib.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 70,
            "changes": 71,
            "blob_url": "https://github.com/vercel/next.js/blob/b26b2b71792eebad4ade5362281a5bee68cd059e/turbopack%2Fcrates%2Fturbo-bincode%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b26b2b71792eebad4ade5362281a5bee68cd059e/turbopack%2Fcrates%2Fturbo-bincode%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-bincode%2Fsrc%2Flib.rs?ref=b26b2b71792eebad4ade5362281a5bee68cd059e",
            "patch": "@@ -1,5 +1,6 @@\n #[doc(hidden)]\n pub mod macro_helpers;\n+pub mod serde_self_describing;\n \n use std::{any::Any, ptr::copy_nonoverlapping};\n \n@@ -472,76 +473,6 @@ pub mod mime_option {\n     }\n }\n \n-/// Encode/decode as a serialized string encoded using `serde_json`.\n-///\n-/// This encodes less efficiently than `#[bincode(with_serde)]` would, but avoids [bincode's known\n-/// compatibility issues][serde-issues]. Use this for infrequently-serialized types and when you're\n-/// unsure if the underlying type may trigger a serde compatibility issue.\n-///\n-/// In the future this could be replaced with a more efficient serde-compatible self-describing\n-/// format with a compact binary representation (e.g. pot or MessagePack), but `serde_json` is\n-/// convenient because it avoids introducing additional dependencies.\n-///\n-/// [serde-issues]: https://docs.rs/bincode/latest/bincode/serde/index.html#known-issues\n-pub mod serde_json {\n-    use super::*;\n-\n-    pub fn encode<E: Encoder, T: serde::Serialize>(\n-        value: &T,\n-        encoder: &mut E,\n-    ) -> Result<(), EncodeError> {\n-        let json_str =\n-            ::serde_json::to_string(value).map_err(|e| EncodeError::OtherString(e.to_string()))?;\n-        Encode::encode(&json_str, encoder)\n-    }\n-\n-    pub fn decode<Context, D: Decoder<Context = Context>, T: serde::de::DeserializeOwned>(\n-        decoder: &mut D,\n-    ) -> Result<T, DecodeError> {\n-        let json_str: String = Decode::decode(decoder)?;\n-        ::serde_json::from_str(&json_str).map_err(|e| DecodeError::OtherString(e.to_string()))\n-    }\n-\n-    pub fn borrow_decode<\n-        'de,\n-        Context,\n-        D: BorrowDecoder<'de, Context = Context>,\n-        T: serde::de::Deserialize<'de>,\n-    >(\n-        decoder: &mut D,\n-    ) -> Result<T, DecodeError> {\n-        let json_str: &str = BorrowDecode::borrow_decode(decoder)?;\n-        ::serde_json::from_str(json_str).map_err(|e| DecodeError::OtherString(e.to_string()))\n-    }\n-\n-    #[cfg(test)]\n-    mod tests {\n-        use ::serde_json::{Value, json};\n-        use bincode::{decode_from_slice, encode_to_vec};\n-\n-        use super::*;\n-\n-        #[test]\n-        fn test_roundtrip() {\n-            let cfg = bincode::config::standard();\n-\n-            #[derive(Encode, Decode)]\n-            struct Wrapper(#[bincode(with = \"crate::serde_json\")] Value);\n-\n-            let value1 = Wrapper(json!({\n-                \"key1\": [1, 2, 3],\n-                \"key2\": [4, 5, 6]\n-            }));\n-\n-            let value2: Wrapper = decode_from_slice(&encode_to_vec(&value1, cfg).unwrap(), cfg)\n-                .unwrap()\n-                .0;\n-\n-            assert_eq!(value1.0, value2.0);\n-        }\n-    }\n-}\n-\n pub mod either {\n     use ::either::Either;\n "
        },
        {
            "sha": "18acd4b1ddce136bd6e2b6f50fda5c892d5c4c52",
            "filename": "turbopack/crates/turbo-bincode/src/serde_self_describing/de.rs",
            "status": "added",
            "additions": 393,
            "deletions": 0,
            "changes": 393,
            "blob_url": "https://github.com/vercel/next.js/blob/b26b2b71792eebad4ade5362281a5bee68cd059e/turbopack%2Fcrates%2Fturbo-bincode%2Fsrc%2Fserde_self_describing%2Fde.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b26b2b71792eebad4ade5362281a5bee68cd059e/turbopack%2Fcrates%2Fturbo-bincode%2Fsrc%2Fserde_self_describing%2Fde.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-bincode%2Fsrc%2Fserde_self_describing%2Fde.rs?ref=b26b2b71792eebad4ade5362281a5bee68cd059e",
            "patch": "@@ -0,0 +1,393 @@\n+use std::{\n+    error::Error as StdError,\n+    fmt::{self, Display},\n+};\n+\n+use bincode::{Decode, de::Decoder, error::DecodeError};\n+use serde::{\n+    Deserializer,\n+    de::{DeserializeSeed, EnumAccess, MapAccess, SeqAccess, VariantAccess, Visitor},\n+};\n+\n+use crate::serde_self_describing::TypeTag;\n+\n+#[derive(Debug)]\n+pub struct Error(pub DecodeError);\n+\n+impl serde::de::Error for Error {\n+    fn custom<T>(msg: T) -> Self\n+    where\n+        T: Display,\n+    {\n+        Self(DecodeError::OtherString(msg.to_string()))\n+    }\n+}\n+\n+impl StdError for Error {\n+    fn source(&self) -> Option<&(dyn StdError + 'static)> {\n+        Some(&self.0)\n+    }\n+}\n+\n+impl Display for Error {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n+impl From<DecodeError> for Error {\n+    fn from(err: DecodeError) -> Self {\n+        Self(err)\n+    }\n+}\n+\n+type Result<T, E = Error> = std::result::Result<T, E>;\n+\n+fn decode_tag(decoder: &mut impl Decoder) -> Result<TypeTag> {\n+    let tag_byte: u8 = Decode::decode(decoder)?;\n+    Ok(TypeTag::try_from(tag_byte)?)\n+}\n+\n+pub struct BincodeDeserializer<'a, D> {\n+    decoder: &'a mut D,\n+}\n+\n+impl<'a, D> BincodeDeserializer<'a, D> {\n+    pub fn new(decoder: &'a mut D) -> Self {\n+        Self { decoder }\n+    }\n+}\n+\n+impl<'a, 'de, D: Decoder> Deserializer<'de> for BincodeDeserializer<'a, D> {\n+    type Error = Error;\n+\n+    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value>\n+    where\n+        V: Visitor<'de>,\n+    {\n+        let tag = decode_tag(self.decoder)?;\n+        BincodeTaggedDeserializer {\n+            tag,\n+            decoder: self.decoder,\n+        }\n+        .deserialize_any(visitor)\n+    }\n+\n+    serde::forward_to_deserialize_any! {\n+        bool i8 i16 i32 i64 u8 u16 u32 u64 f32 f64 char str string bytes\n+        byte_buf option unit unit_struct newtype_struct seq tuple\n+        tuple_struct map struct enum identifier ignored_any\n+    }\n+}\n+\n+/// Helper type used when we have already consumed the type tag\n+struct BincodeTaggedDeserializer<'a, D> {\n+    tag: TypeTag,\n+    decoder: &'a mut D,\n+}\n+\n+impl<'a, D> BincodeTaggedDeserializer<'a, D> {\n+    fn new(tag: TypeTag, decoder: &'a mut D) -> Self {\n+        Self { tag, decoder }\n+    }\n+}\n+\n+impl<'a, 'de, D: Decoder> Deserializer<'de> for BincodeTaggedDeserializer<'a, D> {\n+    type Error = Error;\n+\n+    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value>\n+    where\n+        V: Visitor<'de>,\n+    {\n+        match self.tag {\n+            TypeTag::BoolTrue => visitor.visit_bool(true),\n+            TypeTag::BoolFalse => visitor.visit_bool(false),\n+            TypeTag::U8 => visitor.visit_u8(Decode::decode(self.decoder)?),\n+            TypeTag::U16 => visitor.visit_u16(Decode::decode(self.decoder)?),\n+            TypeTag::U32 => visitor.visit_u32(Decode::decode(self.decoder)?),\n+            TypeTag::U64 => visitor.visit_u64(Decode::decode(self.decoder)?),\n+            TypeTag::I8 => visitor.visit_i8(Decode::decode(self.decoder)?),\n+            TypeTag::I16 => visitor.visit_i16(Decode::decode(self.decoder)?),\n+            TypeTag::I32 => visitor.visit_i32(Decode::decode(self.decoder)?),\n+            TypeTag::I64 => visitor.visit_i64(Decode::decode(self.decoder)?),\n+            TypeTag::F32 => visitor.visit_f32(Decode::decode(self.decoder)?),\n+            TypeTag::F64 => visitor.visit_f64(Decode::decode(self.decoder)?),\n+            TypeTag::Char => visitor.visit_char(Decode::decode(self.decoder)?),\n+            TypeTag::String => visitor.visit_string(Decode::decode(self.decoder)?),\n+            TypeTag::Bytes => visitor.visit_byte_buf(Decode::decode(self.decoder)?),\n+            TypeTag::OptionNone => visitor.visit_none(),\n+            TypeTag::OptionSome => visitor.visit_some(BincodeDeserializer::new(self.decoder)),\n+            TypeTag::Unit | TypeTag::UnitStruct => visitor.visit_unit(),\n+            TypeTag::NewtypeStruct => {\n+                visitor.visit_newtype_struct(BincodeDeserializer::new(self.decoder))\n+            }\n+            TypeTag::SeqSized | TypeTag::Tuple | TypeTag::TupleStruct => {\n+                let len = Decode::decode(self.decoder)?;\n+                visitor.visit_seq(BincodeSizedAccess::new(self.decoder, len))\n+            }\n+            TypeTag::SeqUnsizedStart => visitor.visit_seq(BincodeUnsizedAccess::new(self.decoder)),\n+            TypeTag::MapSized => {\n+                let len = Decode::decode(self.decoder)?;\n+                visitor.visit_map(BincodeSizedAccess::new(self.decoder, len))\n+            }\n+            TypeTag::MapUnsizedStart => visitor.visit_map(BincodeUnsizedAccess::new(self.decoder)),\n+            TypeTag::Struct => {\n+                let len = Decode::decode(self.decoder)?;\n+                visitor.visit_map(BincodeStructAccess::new(self.decoder, len))\n+            }\n+            TypeTag::UnitVariant\n+            | TypeTag::NewtypeVariant\n+            | TypeTag::TupleVariant\n+            | TypeTag::StructVariant => {\n+                visitor.visit_enum(BincodeEnumAccess::new(self.decoder, self.tag))\n+            }\n+            TypeTag::CollectionEnd => {\n+                Err(DecodeError::Other(\"unexpected CollectionEnd tag\").into())\n+            }\n+        }\n+    }\n+\n+    serde::forward_to_deserialize_any! {\n+        bool i8 i16 i32 i64 u8 u16 u32 u64 f32 f64 char str string bytes\n+        byte_buf option unit unit_struct newtype_struct seq tuple\n+        tuple_struct map struct enum identifier ignored_any\n+    }\n+}\n+\n+struct BincodeSizedAccess<'a, D> {\n+    decoder: &'a mut D,\n+    remaining: usize,\n+}\n+\n+impl<'a, D> BincodeSizedAccess<'a, D> {\n+    fn new(decoder: &'a mut D, len: usize) -> Self {\n+        Self {\n+            decoder,\n+            remaining: len,\n+        }\n+    }\n+}\n+\n+impl<'a, 'de, D: Decoder> SeqAccess<'de> for BincodeSizedAccess<'a, D> {\n+    type Error = Error;\n+\n+    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>>\n+    where\n+        T: DeserializeSeed<'de>,\n+    {\n+        if self.remaining > 0 {\n+            self.remaining -= 1;\n+            Ok(Some(\n+                seed.deserialize(BincodeDeserializer::new(self.decoder))?,\n+            ))\n+        } else {\n+            Ok(None)\n+        }\n+    }\n+\n+    fn size_hint(&self) -> Option<usize> {\n+        Some(self.remaining)\n+    }\n+}\n+\n+impl<'a, 'de, D: Decoder> MapAccess<'de> for BincodeSizedAccess<'a, D> {\n+    type Error = Error;\n+\n+    fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>>\n+    where\n+        K: DeserializeSeed<'de>,\n+    {\n+        // behaves the same as `SeqAccess`\n+        SeqAccess::next_element_seed(self, seed)\n+    }\n+\n+    fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value>\n+    where\n+        V: DeserializeSeed<'de>,\n+    {\n+        // we already decremented `remaining` in `next_key_seed`, just decode the value\n+        seed.deserialize(BincodeDeserializer::new(self.decoder))\n+    }\n+\n+    fn size_hint(&self) -> Option<usize> {\n+        Some(self.remaining)\n+    }\n+}\n+\n+struct BincodeUnsizedAccess<'a, D> {\n+    decoder: &'a mut D,\n+}\n+\n+impl<'a, D> BincodeUnsizedAccess<'a, D> {\n+    fn new(decoder: &'a mut D) -> Self {\n+        Self { decoder }\n+    }\n+}\n+\n+impl<'a, 'de, D: Decoder> SeqAccess<'de> for BincodeUnsizedAccess<'a, D> {\n+    type Error = Error;\n+\n+    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>>\n+    where\n+        T: DeserializeSeed<'de>,\n+    {\n+        let tag = decode_tag(self.decoder)?;\n+        if tag == TypeTag::CollectionEnd {\n+            return Ok(None);\n+        }\n+        Ok(Some(seed.deserialize(BincodeTaggedDeserializer::new(\n+            tag,\n+            self.decoder,\n+        ))?))\n+    }\n+}\n+\n+impl<'a, 'de, D: Decoder> MapAccess<'de> for BincodeUnsizedAccess<'a, D> {\n+    type Error = Error;\n+\n+    fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>>\n+    where\n+        K: DeserializeSeed<'de>,\n+    {\n+        // behaves the same as `SeqAccess`\n+        SeqAccess::next_element_seed(self, seed)\n+    }\n+\n+    fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value>\n+    where\n+        V: DeserializeSeed<'de>,\n+    {\n+        seed.deserialize(BincodeDeserializer::new(self.decoder))\n+    }\n+}\n+\n+struct BincodeStructAccess<'a, D> {\n+    decoder: &'a mut D,\n+    remaining: usize,\n+}\n+\n+impl<'a, D> BincodeStructAccess<'a, D> {\n+    fn new(decoder: &'a mut D, len: usize) -> Self {\n+        Self {\n+            decoder,\n+            remaining: len,\n+        }\n+    }\n+}\n+\n+impl<'a, 'de, D: Decoder> MapAccess<'de> for BincodeStructAccess<'a, D> {\n+    type Error = Error;\n+\n+    fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>>\n+    where\n+        K: DeserializeSeed<'de>,\n+    {\n+        if self.remaining > 0 {\n+            self.remaining -= 1;\n+            Ok(Some(seed.deserialize(BincodeTaggedDeserializer::new(\n+                TypeTag::String,\n+                self.decoder,\n+            ))?))\n+        } else {\n+            Ok(None)\n+        }\n+    }\n+\n+    fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value>\n+    where\n+        V: DeserializeSeed<'de>,\n+    {\n+        seed.deserialize(BincodeDeserializer::new(self.decoder))\n+    }\n+\n+    fn size_hint(&self) -> Option<usize> {\n+        Some(self.remaining)\n+    }\n+}\n+\n+struct BincodeEnumAccess<'a, D> {\n+    decoder: &'a mut D,\n+    tag: TypeTag,\n+}\n+\n+impl<'a, D> BincodeEnumAccess<'a, D> {\n+    fn new(decoder: &'a mut D, tag: TypeTag) -> Self {\n+        Self { decoder, tag }\n+    }\n+}\n+\n+impl<'a, 'de, D: Decoder> EnumAccess<'de> for BincodeEnumAccess<'a, D> {\n+    type Error = Error;\n+    type Variant = Self;\n+\n+    fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self::Variant)>\n+    where\n+        V: DeserializeSeed<'de>,\n+    {\n+        let variant_name = seed.deserialize(BincodeTaggedDeserializer::new(\n+            TypeTag::String,\n+            self.decoder,\n+        ))?;\n+        Ok((variant_name, self))\n+    }\n+}\n+\n+impl<'a, 'de, D: Decoder> VariantAccess<'de> for BincodeEnumAccess<'a, D> {\n+    type Error = Error;\n+\n+    fn unit_variant(self) -> Result<()> {\n+        match self.tag {\n+            TypeTag::UnitVariant => Ok(()),\n+            _ => Err(DecodeError::Other(\"expected unit variant\").into()),\n+        }\n+    }\n+\n+    fn newtype_variant_seed<T>(self, seed: T) -> Result<T::Value>\n+    where\n+        T: DeserializeSeed<'de>,\n+    {\n+        match self.tag {\n+            TypeTag::NewtypeVariant => seed.deserialize(BincodeDeserializer::new(self.decoder)),\n+            _ => Err(DecodeError::Other(\"expected newtype variant\").into()),\n+        }\n+    }\n+\n+    fn tuple_variant<V>(self, expected_len: usize, visitor: V) -> Result<V::Value>\n+    where\n+        V: Visitor<'de>,\n+    {\n+        match self.tag {\n+            TypeTag::TupleVariant => {\n+                let len: usize = Decode::decode(self.decoder)?;\n+                if len != expected_len {\n+                    return Err(DecodeError::OtherString(format!(\n+                        \"tuple variant length mismatch: expected {expected_len}, got {len}\"\n+                    ))\n+                    .into());\n+                }\n+                visitor.visit_seq(BincodeSizedAccess::new(self.decoder, len))\n+            }\n+            _ => Err(DecodeError::Other(\"expected tuple variant\").into()),\n+        }\n+    }\n+\n+    fn struct_variant<V>(self, fields: &'static [&'static str], visitor: V) -> Result<V::Value>\n+    where\n+        V: Visitor<'de>,\n+    {\n+        match self.tag {\n+            TypeTag::StructVariant => {\n+                let len: usize = Decode::decode(self.decoder)?;\n+                if len != fields.len() {\n+                    return Err(DecodeError::OtherString(format!(\n+                        \"struct variant field count mismatch: expected {}, got {len}\",\n+                        fields.len()\n+                    ))\n+                    .into());\n+                }\n+                visitor.visit_map(BincodeStructAccess::new(self.decoder, len))\n+            }\n+            _ => Err(DecodeError::Other(\"expected struct variant\").into()),\n+        }\n+    }\n+}"
        },
        {
            "sha": "a8486a10eb3736decc45933665bda133479f237d",
            "filename": "turbopack/crates/turbo-bincode/src/serde_self_describing/mod.rs",
            "status": "added",
            "additions": 327,
            "deletions": 0,
            "changes": 327,
            "blob_url": "https://github.com/vercel/next.js/blob/b26b2b71792eebad4ade5362281a5bee68cd059e/turbopack%2Fcrates%2Fturbo-bincode%2Fsrc%2Fserde_self_describing%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b26b2b71792eebad4ade5362281a5bee68cd059e/turbopack%2Fcrates%2Fturbo-bincode%2Fsrc%2Fserde_self_describing%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-bincode%2Fsrc%2Fserde_self_describing%2Fmod.rs?ref=b26b2b71792eebad4ade5362281a5bee68cd059e",
            "patch": "@@ -0,0 +1,327 @@\n+//! Helpers for serializing serde-compatible types inside of a bincode [`Encode`] or [`Decode`]\n+//! implementation using a self-describing format. This works with [types that\n+//! `#[bincode(serde)]` does not support][bincode::serde#known-issues].\n+//!\n+//! These helper functions can be used in the [`Encode`] and [`Decode`] derive macros with the\n+//! `#[bincode(with = \"turbo_bincode]` attribute.\n+//!\n+//! [`Encode`]: bincode::Encode\n+//! [`Decode`]: bincode::Decode\n+\n+use bincode::{\n+    de::{BorrowDecoder, Decoder},\n+    enc::Encoder,\n+    error::{DecodeError, EncodeError},\n+};\n+use serde::{Serialize, de::DeserializeOwned};\n+\n+mod de;\n+mod ser;\n+\n+/// Uses a u8 representation, which is slightly more efficient than bincode's default u32 varint\n+/// approach for enum discriminants:\n+/// https://docs.rs/bincode/latest/bincode/spec/index.html#discriminant-representation\n+#[derive(Copy, Clone, PartialEq, Eq)]\n+#[repr(u8)]\n+enum TypeTag {\n+    BoolTrue = 1,\n+    BoolFalse,\n+    U8,\n+    U16,\n+    U32,\n+    U64,\n+    I8,\n+    I16,\n+    I32,\n+    I64,\n+    F32,\n+    F64,\n+    Char,\n+    String,\n+    Bytes,\n+    OptionNone,\n+    OptionSome,\n+    Unit,\n+    UnitStruct,\n+    UnitVariant,\n+    NewtypeStruct,\n+    NewtypeVariant,\n+    SeqSized,\n+    SeqUnsizedStart,\n+    Tuple,\n+    TupleStruct,\n+    TupleVariant,\n+    MapSized,\n+    MapUnsizedStart,\n+    Struct,\n+    StructVariant,\n+    CollectionEnd,\n+}\n+\n+impl TryFrom<u8> for TypeTag {\n+    type Error = DecodeError;\n+\n+    fn try_from(num: u8) -> Result<Self, DecodeError> {\n+        let tag = match num {\n+            1 => TypeTag::BoolTrue,\n+            2 => TypeTag::BoolFalse,\n+            3 => TypeTag::U8,\n+            4 => TypeTag::U16,\n+            5 => TypeTag::U32,\n+            6 => TypeTag::U64,\n+            7 => TypeTag::I8,\n+            8 => TypeTag::I16,\n+            9 => TypeTag::I32,\n+            10 => TypeTag::I64,\n+            11 => TypeTag::F32,\n+            12 => TypeTag::F64,\n+            13 => TypeTag::Char,\n+            14 => TypeTag::String,\n+            15 => TypeTag::Bytes,\n+            16 => TypeTag::OptionNone,\n+            17 => TypeTag::OptionSome,\n+            18 => TypeTag::Unit,\n+            19 => TypeTag::UnitStruct,\n+            20 => TypeTag::UnitVariant,\n+            21 => TypeTag::NewtypeStruct,\n+            22 => TypeTag::NewtypeVariant,\n+            23 => TypeTag::SeqSized,\n+            24 => TypeTag::SeqUnsizedStart,\n+            25 => TypeTag::Tuple,\n+            26 => TypeTag::TupleStruct,\n+            27 => TypeTag::TupleVariant,\n+            28 => TypeTag::MapSized,\n+            29 => TypeTag::MapUnsizedStart,\n+            30 => TypeTag::Struct,\n+            31 => TypeTag::StructVariant,\n+            32 => TypeTag::CollectionEnd,\n+            _ => {\n+                return Err(DecodeError::OtherString(format!(\"invalid type tag: {num}\")));\n+            }\n+        };\n+        debug_assert_eq!(tag as u8, num);\n+        Ok(tag)\n+    }\n+}\n+\n+pub fn encode<E: Encoder, T: Serialize>(value: &T, encoder: &mut E) -> Result<(), EncodeError> {\n+    value\n+        .serialize(&mut ser::BincodeSerializer::new(encoder))\n+        .map_err(|e| e.0)\n+}\n+\n+pub fn decode<Context, D: Decoder<Context = Context>, T: DeserializeOwned>(\n+    decoder: &mut D,\n+) -> Result<T, DecodeError> {\n+    T::deserialize(de::BincodeDeserializer::new(decoder)).map_err(|e| e.0)\n+}\n+\n+pub fn borrow_decode<\n+    'de,\n+    Context,\n+    D: BorrowDecoder<'de, Context = Context>,\n+    T: serde::de::Deserialize<'de>,\n+>(\n+    decoder: &mut D,\n+) -> Result<T, DecodeError> {\n+    T::deserialize(de::BincodeDeserializer::new(decoder)).map_err(|e| e.0)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use std::{collections::HashMap, fmt::Debug};\n+\n+    use bincode::{Decode, Encode, decode_from_slice, encode_to_vec};\n+    use serde::{Deserialize, Serialize, de::DeserializeOwned};\n+\n+    fn round_trip<T: Serialize + DeserializeOwned + PartialEq + Debug>(value: T) -> T {\n+        #[derive(Encode)]\n+        #[bincode(encode_bounds = \"T: Serialize\")]\n+        struct EncodeWrapper<'a, T>(#[bincode(with = \"crate::serde_self_describing\")] &'a T);\n+\n+        #[derive(Decode)]\n+        #[bincode(\n+            decode_bounds = \"T: DeserializeOwned\",\n+            borrow_decode_bounds = \"T: Deserialize<'__de>\"\n+        )]\n+        struct DecodeWrapper<T>(#[bincode(with = \"crate::serde_self_describing\")] T);\n+\n+        let config = bincode::config::standard();\n+\n+        let encoded = encode_to_vec(EncodeWrapper(&value), config).unwrap();\n+        let (DecodeWrapper(decoded), len) = decode_from_slice(&encoded, config).unwrap();\n+        assert_eq!(value, decoded);\n+        assert_eq!(len, encoded.len(), \"the entire buffer must be decoded\");\n+        decoded\n+    }\n+\n+    #[test]\n+    fn test_primitives() {\n+        round_trip(true);\n+        round_trip(false);\n+        round_trip(42u8);\n+        round_trip(42u16);\n+        round_trip(42u32);\n+        round_trip(42u64);\n+        round_trip(-42i8);\n+        round_trip(-42i16);\n+        round_trip(-42i32);\n+        round_trip(-42i64);\n+        round_trip(1.23f32);\n+        round_trip(1.23f64);\n+        round_trip('a');\n+    }\n+\n+    #[test]\n+    fn test_string() {\n+        round_trip(String::new());\n+        round_trip(String::from(\"hello world\"));\n+    }\n+\n+    #[test]\n+    fn test_option() {\n+        round_trip(Option::<i32>::None);\n+        round_trip(Some(42));\n+        round_trip(Some(String::from(\"hello\")));\n+        round_trip(Some(Some(42)));\n+    }\n+\n+    #[test]\n+    fn test_vec() {\n+        round_trip(Vec::<i32>::new());\n+        round_trip(vec![String::from(\"a\"), String::from(\"b\")]);\n+        round_trip(vec![vec![1, 2], vec![3, 4]]);\n+        round_trip(b\"abc\\0def\".to_vec());\n+    }\n+\n+    #[test]\n+    fn test_tuple() {\n+        round_trip(());\n+        round_trip((vec![1, 2], \"hello\".to_string(), Some(42), false, true));\n+    }\n+\n+    #[test]\n+    fn test_hashmap() {\n+        let mut map = HashMap::new();\n+        map.insert(\"key1\".to_string(), 1);\n+        map.insert(\"key2\".to_string(), 2);\n+        round_trip(map);\n+\n+        let empty: HashMap<String, i32> = HashMap::new();\n+        round_trip(empty);\n+    }\n+\n+    #[test]\n+    fn test_struct() {\n+        #[derive(Debug, PartialEq, Serialize, Deserialize)]\n+        struct Struct {\n+            a: String,\n+            b: Option<i32>,\n+            #[serde(flatten)]\n+            flattened: Flattened,\n+        }\n+\n+        #[derive(Debug, PartialEq, Serialize, Deserialize)]\n+        struct Flattened {\n+            d: i32,\n+        }\n+\n+        round_trip(Struct {\n+            a: \"hello\".to_string(),\n+            b: None,\n+            flattened: Flattened { d: 42 },\n+        });\n+        round_trip(Struct {\n+            a: \"hello\".to_string(),\n+            b: Some(42),\n+            flattened: Flattened { d: 43 },\n+        });\n+    }\n+\n+    #[test]\n+    fn test_unit_struct() {\n+        #[derive(Debug, PartialEq, Serialize, Deserialize)]\n+        struct UnitStruct;\n+\n+        round_trip(UnitStruct);\n+    }\n+\n+    #[test]\n+    fn test_newtype_struct() {\n+        #[derive(Debug, PartialEq, Serialize, Deserialize)]\n+        struct NewtypeStruct(i32);\n+\n+        round_trip(NewtypeStruct(42));\n+    }\n+\n+    #[test]\n+    fn test_tuple_struct() {\n+        #[derive(Debug, PartialEq, Serialize, Deserialize)]\n+        struct TupleStruct(i32, String, bool);\n+\n+        round_trip(TupleStruct(42, \"hello\".to_string(), true));\n+    }\n+\n+    #[test]\n+    fn test_enum_unit_variants() {\n+        #[derive(Debug, PartialEq, Serialize, Deserialize)]\n+        enum Color {\n+            Red,\n+            Green,\n+            Blue,\n+        }\n+\n+        round_trip(Color::Red);\n+        round_trip(Color::Green);\n+        round_trip(Color::Blue);\n+    }\n+\n+    #[test]\n+    fn test_enum_newtype_variants() {\n+        #[derive(Debug, PartialEq, Serialize, Deserialize)]\n+        enum Value {\n+            #[allow(unused)]\n+            #[serde(skip)]\n+            Empty(()),\n+            Int(i32),\n+            Text(String),\n+        }\n+\n+        round_trip(Value::Int(42));\n+        round_trip(Value::Text(\"hello\".to_string()));\n+    }\n+\n+    #[test]\n+    fn test_enum_tuple_variants() {\n+        #[derive(Debug, PartialEq, Serialize, Deserialize)]\n+        enum Point {\n+            TwoD(i32, i32),\n+            ThreeD(i32, i32, i32),\n+        }\n+\n+        round_trip(Point::TwoD(1, 2));\n+        round_trip(Point::ThreeD(1, 2, 3));\n+    }\n+\n+    #[test]\n+    fn test_enum_struct_variants() {\n+        #[derive(Debug, PartialEq, Serialize, Deserialize)]\n+        enum Message {\n+            Request { id: u32, method: String },\n+            Response { id: u32, result: Option<String> },\n+        }\n+\n+        round_trip(Message::Request {\n+            id: 1,\n+            method: \"get\".to_string(),\n+        });\n+        round_trip(Message::Response {\n+            id: 1,\n+            result: Some(\"ok\".to_string()),\n+        });\n+        round_trip(Message::Response {\n+            id: 2,\n+            result: None,\n+        });\n+    }\n+}"
        },
        {
            "sha": "8fcb7375d0a5f8a35e22029b1ac323657a85ce17",
            "filename": "turbopack/crates/turbo-bincode/src/serde_self_describing/ser.rs",
            "status": "added",
            "additions": 422,
            "deletions": 0,
            "changes": 422,
            "blob_url": "https://github.com/vercel/next.js/blob/b26b2b71792eebad4ade5362281a5bee68cd059e/turbopack%2Fcrates%2Fturbo-bincode%2Fsrc%2Fserde_self_describing%2Fser.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b26b2b71792eebad4ade5362281a5bee68cd059e/turbopack%2Fcrates%2Fturbo-bincode%2Fsrc%2Fserde_self_describing%2Fser.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-bincode%2Fsrc%2Fserde_self_describing%2Fser.rs?ref=b26b2b71792eebad4ade5362281a5bee68cd059e",
            "patch": "@@ -0,0 +1,422 @@\n+use std::{\n+    error::Error as StdError,\n+    fmt::{self, Display},\n+};\n+\n+use bincode::{Encode, enc::Encoder, error::EncodeError};\n+use serde::{\n+    Serialize, Serializer,\n+    ser::{\n+        self, SerializeSeq, SerializeStruct, SerializeStructVariant, SerializeTuple,\n+        SerializeTupleStruct,\n+    },\n+};\n+\n+use crate::serde_self_describing::TypeTag;\n+\n+#[derive(Debug)]\n+pub struct Error(pub EncodeError);\n+\n+impl serde::ser::Error for Error {\n+    fn custom<T>(msg: T) -> Self\n+    where\n+        T: Display,\n+    {\n+        Self(EncodeError::OtherString(msg.to_string()))\n+    }\n+}\n+\n+impl StdError for Error {\n+    fn source(&self) -> Option<&(dyn StdError + 'static)> {\n+        Some(&self.0)\n+    }\n+}\n+\n+impl Display for Error {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n+impl From<EncodeError> for Error {\n+    fn from(err: EncodeError) -> Self {\n+        Self(err)\n+    }\n+}\n+\n+type Result<T, E = Error> = std::result::Result<T, E>;\n+\n+pub struct BincodeSerializer<E> {\n+    encoder: E,\n+}\n+\n+impl<E> BincodeSerializer<E> {\n+    pub fn new(encoder: E) -> Self {\n+        Self { encoder }\n+    }\n+}\n+\n+impl<E: Encoder> BincodeSerializer<E> {\n+    fn encode_tag(&mut self, tag: TypeTag) -> Result<()> {\n+        Ok(Encode::encode(&(tag as u8), &mut self.encoder)?)\n+    }\n+\n+    fn encode_primitive<T: Encode>(&mut self, value: T) -> Result<()> {\n+        Ok(Encode::encode(&value, &mut self.encoder)?)\n+    }\n+}\n+\n+impl<'a, E: Encoder> Serializer for &'a mut BincodeSerializer<E> {\n+    type Ok = ();\n+    type Error = Error;\n+\n+    type SerializeSeq = BincodeCollectionSerializer<'a, E>;\n+    type SerializeTuple = BincodeCollectionSerializer<'a, E>;\n+    type SerializeTupleStruct = BincodeCollectionSerializer<'a, E>;\n+    type SerializeTupleVariant = BincodeCollectionSerializer<'a, E>;\n+    type SerializeMap = BincodeCollectionSerializer<'a, E>;\n+    type SerializeStruct = BincodeCollectionSerializer<'a, E>;\n+    type SerializeStructVariant = BincodeCollectionSerializer<'a, E>;\n+\n+    fn serialize_bool(self, v: bool) -> Result<()> {\n+        if v {\n+            self.encode_tag(TypeTag::BoolTrue)\n+        } else {\n+            self.encode_tag(TypeTag::BoolFalse)\n+        }\n+    }\n+\n+    fn serialize_u8(self, v: u8) -> Result<()> {\n+        self.encode_tag(TypeTag::U8)?;\n+        self.encode_primitive(v)\n+    }\n+\n+    fn serialize_u16(self, v: u16) -> Result<()> {\n+        self.encode_tag(TypeTag::U16)?;\n+        self.encode_primitive(v)\n+    }\n+\n+    fn serialize_u32(self, v: u32) -> Result<()> {\n+        self.encode_tag(TypeTag::U32)?;\n+        self.encode_primitive(v)\n+    }\n+\n+    fn serialize_u64(self, v: u64) -> Result<()> {\n+        self.encode_tag(TypeTag::U64)?;\n+        self.encode_primitive(v)\n+    }\n+\n+    fn serialize_i8(self, v: i8) -> Result<()> {\n+        self.encode_tag(TypeTag::I8)?;\n+        self.encode_primitive(v)\n+    }\n+\n+    fn serialize_i16(self, v: i16) -> Result<()> {\n+        self.encode_tag(TypeTag::I16)?;\n+        self.encode_primitive(v)\n+    }\n+\n+    fn serialize_i32(self, v: i32) -> Result<()> {\n+        self.encode_tag(TypeTag::I32)?;\n+        self.encode_primitive(v)\n+    }\n+\n+    fn serialize_i64(self, v: i64) -> Result<()> {\n+        self.encode_tag(TypeTag::I64)?;\n+        self.encode_primitive(v)\n+    }\n+\n+    fn serialize_f32(self, v: f32) -> Result<()> {\n+        self.encode_tag(TypeTag::F32)?;\n+        self.encode_primitive(v)\n+    }\n+\n+    fn serialize_f64(self, v: f64) -> Result<()> {\n+        self.encode_tag(TypeTag::F64)?;\n+        self.encode_primitive(v)\n+    }\n+\n+    fn serialize_char(self, v: char) -> Result<()> {\n+        self.encode_tag(TypeTag::Char)?;\n+        self.encode_primitive(v)\n+    }\n+\n+    fn serialize_str(self, v: &str) -> Result<()> {\n+        self.encode_tag(TypeTag::String)?;\n+        self.encode_primitive(v)\n+    }\n+\n+    fn serialize_bytes(self, v: &[u8]) -> Result<()> {\n+        self.encode_tag(TypeTag::Bytes)?;\n+        self.encode_primitive(v)\n+    }\n+\n+    fn serialize_none(self) -> Result<()> {\n+        self.encode_tag(TypeTag::OptionNone)\n+    }\n+\n+    fn serialize_some<T>(self, value: &T) -> Result<()>\n+    where\n+        T: ?Sized + Serialize,\n+    {\n+        self.encode_tag(TypeTag::OptionSome)?;\n+        value.serialize(self)\n+    }\n+\n+    fn serialize_unit(self) -> Result<()> {\n+        self.encode_tag(TypeTag::Unit)\n+    }\n+\n+    fn serialize_unit_struct(self, _name: &'static str) -> Result<()> {\n+        self.encode_tag(TypeTag::UnitStruct)\n+    }\n+\n+    fn serialize_unit_variant(\n+        self,\n+        _name: &'static str,\n+        _variant_index: u32,\n+        variant: &'static str,\n+    ) -> Result<()> {\n+        // We must store enum variants by name, otherwise there's a bug in serde that skipped\n+        // variants are deserialized with the wrong index:\n+        // - https://github.com/serde-rs/serde/issues/2614\n+        // - https://github.com/bincode-org/bincode/issues/184\n+        self.encode_tag(TypeTag::UnitVariant)?;\n+        self.encode_primitive(variant)\n+    }\n+\n+    fn serialize_newtype_struct<T>(self, _name: &'static str, value: &T) -> Result<()>\n+    where\n+        T: ?Sized + Serialize,\n+    {\n+        self.encode_tag(TypeTag::NewtypeStruct)?;\n+        value.serialize(self)\n+    }\n+\n+    fn serialize_newtype_variant<T>(\n+        self,\n+        _name: &'static str,\n+        _variant_index: u32,\n+        variant: &'static str,\n+        value: &T,\n+    ) -> Result<()>\n+    where\n+        T: ?Sized + Serialize,\n+    {\n+        self.encode_tag(TypeTag::NewtypeVariant)?;\n+        self.encode_primitive(variant)?;\n+        value.serialize(self)\n+    }\n+\n+    fn serialize_seq(self, len: Option<usize>) -> Result<Self::SerializeSeq> {\n+        if let Some(len) = len {\n+            self.encode_tag(TypeTag::SeqSized)?;\n+            self.encode_primitive(len)?;\n+            Ok(BincodeCollectionSerializer::new(self, false))\n+        } else {\n+            self.encode_tag(TypeTag::SeqUnsizedStart)?;\n+            Ok(BincodeCollectionSerializer::new(self, true))\n+        }\n+    }\n+\n+    fn serialize_tuple(self, len: usize) -> Result<Self::SerializeTuple> {\n+        self.encode_tag(TypeTag::Tuple)?;\n+        self.encode_primitive(len)?;\n+        Ok(BincodeCollectionSerializer::new(self, false))\n+    }\n+\n+    fn serialize_tuple_struct(\n+        self,\n+        _name: &'static str,\n+        len: usize,\n+    ) -> Result<Self::SerializeTupleStruct> {\n+        self.encode_tag(TypeTag::TupleStruct)?;\n+        self.encode_primitive(len)?;\n+        Ok(BincodeCollectionSerializer::new(self, false))\n+    }\n+\n+    fn serialize_tuple_variant(\n+        self,\n+        _name: &'static str,\n+        _variant_index: u32,\n+        variant: &'static str,\n+        len: usize,\n+    ) -> Result<Self::SerializeTupleVariant> {\n+        self.encode_tag(TypeTag::TupleVariant)?;\n+        self.encode_primitive(variant)?;\n+        self.encode_primitive(len)?;\n+        Ok(BincodeCollectionSerializer::new(self, false))\n+    }\n+\n+    fn serialize_map(self, len: Option<usize>) -> Result<Self::SerializeMap> {\n+        if let Some(len) = len {\n+            self.encode_tag(TypeTag::MapSized)?;\n+            self.encode_primitive(len)?;\n+            Ok(BincodeCollectionSerializer::new(self, false))\n+        } else {\n+            self.encode_tag(TypeTag::MapUnsizedStart)?;\n+            Ok(BincodeCollectionSerializer::new(self, true))\n+        }\n+    }\n+\n+    fn serialize_struct(self, _name: &'static str, len: usize) -> Result<Self::SerializeStruct> {\n+        self.encode_tag(TypeTag::Struct)?;\n+        self.encode_primitive(len)?;\n+        Ok(BincodeCollectionSerializer::new(self, false))\n+    }\n+\n+    fn serialize_struct_variant(\n+        self,\n+        _name: &'static str,\n+        _variant_index: u32,\n+        variant: &'static str,\n+        len: usize,\n+    ) -> Result<Self::SerializeStructVariant> {\n+        self.encode_tag(TypeTag::StructVariant)?;\n+        self.encode_primitive(variant)?;\n+        self.encode_primitive(len)?;\n+        Ok(BincodeCollectionSerializer::new(self, false))\n+    }\n+}\n+\n+pub struct BincodeCollectionSerializer<'a, E> {\n+    inner: &'a mut BincodeSerializer<E>,\n+    emit_end_tag: bool,\n+}\n+\n+impl<'a, E: Encoder> BincodeCollectionSerializer<'a, E> {\n+    fn new(inner: &'a mut BincodeSerializer<E>, emit_end_tag: bool) -> Self {\n+        Self {\n+            inner,\n+            emit_end_tag,\n+        }\n+    }\n+\n+    fn maybe_emit_end(&mut self) -> Result<()> {\n+        if self.emit_end_tag {\n+            self.inner.encode_tag(TypeTag::CollectionEnd)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl<E: Encoder> SerializeSeq for BincodeCollectionSerializer<'_, E> {\n+    type Ok = ();\n+    type Error = Error;\n+\n+    fn serialize_element<T>(&mut self, value: &T) -> Result<()>\n+    where\n+        T: ?Sized + Serialize,\n+    {\n+        value.serialize(&mut *self.inner)\n+    }\n+\n+    fn end(mut self) -> Result<()> {\n+        self.maybe_emit_end()\n+    }\n+}\n+\n+impl<E: Encoder> SerializeTuple for BincodeCollectionSerializer<'_, E> {\n+    type Ok = ();\n+    type Error = Error;\n+\n+    fn serialize_element<T>(&mut self, value: &T) -> Result<()>\n+    where\n+        T: ?Sized + Serialize,\n+    {\n+        value.serialize(&mut *self.inner)\n+    }\n+\n+    fn end(mut self) -> Result<()> {\n+        self.maybe_emit_end()\n+    }\n+}\n+\n+impl<E: Encoder> SerializeTupleStruct for BincodeCollectionSerializer<'_, E> {\n+    type Ok = ();\n+    type Error = Error;\n+\n+    fn serialize_field<T>(&mut self, value: &T) -> Result<()>\n+    where\n+        T: ?Sized + Serialize,\n+    {\n+        value.serialize(&mut *self.inner)\n+    }\n+\n+    fn end(mut self) -> Result<()> {\n+        self.maybe_emit_end()\n+    }\n+}\n+\n+impl<E: Encoder> ser::SerializeTupleVariant for BincodeCollectionSerializer<'_, E> {\n+    type Ok = ();\n+    type Error = Error;\n+\n+    fn serialize_field<T>(&mut self, value: &T) -> Result<()>\n+    where\n+        T: ?Sized + Serialize,\n+    {\n+        value.serialize(&mut *self.inner)\n+    }\n+\n+    fn end(mut self) -> Result<()> {\n+        self.maybe_emit_end()\n+    }\n+}\n+\n+impl<E: Encoder> ser::SerializeMap for BincodeCollectionSerializer<'_, E> {\n+    type Ok = ();\n+    type Error = Error;\n+\n+    fn serialize_key<T>(&mut self, key: &T) -> Result<()>\n+    where\n+        T: ?Sized + Serialize,\n+    {\n+        key.serialize(&mut *self.inner)\n+    }\n+\n+    fn serialize_value<T>(&mut self, value: &T) -> Result<()>\n+    where\n+        T: ?Sized + Serialize,\n+    {\n+        value.serialize(&mut *self.inner)\n+    }\n+\n+    fn end(mut self) -> Result<()> {\n+        self.maybe_emit_end()\n+    }\n+}\n+\n+impl<E: Encoder> SerializeStruct for BincodeCollectionSerializer<'_, E> {\n+    type Ok = ();\n+    type Error = Error;\n+\n+    fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<()>\n+    where\n+        T: ?Sized + Serialize,\n+    {\n+        self.inner.encode_primitive(key)?;\n+        value.serialize(&mut *self.inner)\n+    }\n+\n+    fn end(mut self) -> Result<()> {\n+        self.maybe_emit_end()\n+    }\n+}\n+\n+impl<E: Encoder> SerializeStructVariant for BincodeCollectionSerializer<'_, E> {\n+    type Ok = ();\n+    type Error = Error;\n+\n+    fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<()>\n+    where\n+        T: ?Sized + Serialize,\n+    {\n+        self.inner.encode_primitive(key)?;\n+        value.serialize(&mut *self.inner)\n+    }\n+\n+    fn end(mut self) -> Result<()> {\n+        self.maybe_emit_end()\n+    }\n+}"
        },
        {
            "sha": "f7da512015cd966475ff7d5f6d06d9b5e122ad65",
            "filename": "turbopack/crates/turbo-persistence/Cargo.toml",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/b26b2b71792eebad4ade5362281a5bee68cd059e/turbopack%2Fcrates%2Fturbo-persistence%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/b26b2b71792eebad4ade5362281a5bee68cd059e/turbopack%2Fcrates%2Fturbo-persistence%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-persistence%2FCargo.toml?ref=b26b2b71792eebad4ade5362281a5bee68cd059e",
            "patch": "@@ -14,22 +14,24 @@ verbose_log = []\n \n [dependencies]\n anyhow = { workspace = true }\n+bincode = { workspace = true }\n bitfield = { workspace = true }\n+byteorder = { workspace = true }\n dashmap = { workspace = true}\n either = { workspace = true }\n-pot = \"3.0.0\"\n-byteorder = { workspace = true }\n jiff = \"0.2.10\"\n lzzzz = \"1.1.0\"\n memmap2 = \"0.9.5\"\n nohash-hasher = { workspace = true }\n parking_lot = { workspace = true }\n+pot = \"3.0.0\"\n qfilter = { version = \"0.2.4\", features = [\"serde\"] }\n quick_cache = { workspace = true }\n rustc-hash = { workspace = true }\n smallvec = { workspace = true }\n thread_local = { workspace = true }\n tracing = { workspace = true }\n+turbo-bincode= { workspace = true }\n twox-hash = { workspace = true }\n zstd = { version = \"0.13.2\", features = [\"zdict_builder\"] }\n "
        },
        {
            "sha": "f75f4ffca4912d13ec1028b7e7144d996094a514",
            "filename": "turbopack/crates/turbo-persistence/src/meta_file.rs",
            "status": "modified",
            "additions": 19,
            "deletions": 7,
            "changes": 26,
            "blob_url": "https://github.com/vercel/next.js/blob/b26b2b71792eebad4ade5362281a5bee68cd059e/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fmeta_file.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b26b2b71792eebad4ade5362281a5bee68cd059e/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fmeta_file.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fmeta_file.rs?ref=b26b2b71792eebad4ade5362281a5bee68cd059e",
            "patch": "@@ -9,12 +9,14 @@ use std::{\n };\n \n use anyhow::{Context, Result, bail};\n+use bincode::{Decode, Encode};\n use bitfield::bitfield;\n use byteorder::{BE, ReadBytesExt};\n use either::Either;\n use memmap2::{Mmap, MmapOptions};\n use quick_cache::sync::GuardResult;\n use rustc_hash::FxHasher;\n+use turbo_bincode::turbo_bincode_decode;\n \n use crate::{\n     QueryKey,\n@@ -62,6 +64,14 @@ impl Display for MetaEntryFlags {\n     }\n }\n \n+/// A wrapper around [`qfilter::Filter`] that implements [`Encode`] and [`Decode`].\n+#[derive(Encode, Decode)]\n+pub struct AmqfBincodeWrapper(\n+    // this annotation can be replaced with `#[bincode(serde)]` once\n+    // <https://github.com/arthurprs/qfilter/issues/13> is resolved\n+    #[bincode(with = \"turbo_bincode::serde_self_describing\")] pub qfilter::Filter,\n+);\n+\n pub struct MetaEntry {\n     /// The metadata for the static sorted file.\n     sst_data: StaticSortedFileMetaData,\n@@ -113,13 +123,15 @@ impl MetaEntry {\n \n     pub fn deserialize_amqf(&self, meta: &MetaFile) -> Result<qfilter::Filter> {\n         let amqf = self.raw_amqf(meta.amqf_data());\n-        pot::from_slice(amqf).with_context(|| {\n-            format!(\n-                \"Failed to deserialize AMQF from {:08}.meta for {:08}.sst\",\n-                meta.sequence_number,\n-                self.sequence_number()\n-            )\n-        })\n+        Ok(turbo_bincode_decode::<AmqfBincodeWrapper>(amqf)\n+            .with_context(|| {\n+                format!(\n+                    \"Failed to deserialize AMQF from {:08}.meta for {:08}.sst\",\n+                    meta.sequence_number,\n+                    self.sequence_number()\n+                )\n+            })?\n+            .0)\n     }\n \n     pub fn amqf("
        },
        {
            "sha": "c105c8484c32590192e9181f593cf4cdfde94984",
            "filename": "turbopack/crates/turbo-persistence/src/static_sorted_file_builder.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 4,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/b26b2b71792eebad4ade5362281a5bee68cd059e/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fstatic_sorted_file_builder.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b26b2b71792eebad4ade5362281a5bee68cd059e/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fstatic_sorted_file_builder.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fstatic_sorted_file_builder.rs?ref=b26b2b71792eebad4ade5362281a5bee68cd059e",
            "patch": "@@ -8,10 +8,11 @@ use std::{\n \n use anyhow::{Context, Result};\n use byteorder::{BE, ByteOrder, WriteBytesExt};\n+use turbo_bincode::{TurboBincodeBuffer, turbo_bincode_encode};\n \n use crate::{\n     compression::compress_into_buffer,\n-    meta_file::MetaEntryFlags,\n+    meta_file::{AmqfBincodeWrapper, MetaEntryFlags},\n     static_sorted_file::{\n         BLOCK_TYPE_INDEX, BLOCK_TYPE_KEY, KEY_BLOCK_ENTRY_TYPE_BLOB, KEY_BLOCK_ENTRY_TYPE_DELETED,\n         KEY_BLOCK_ENTRY_TYPE_MEDIUM, KEY_BLOCK_ENTRY_TYPE_SMALL,\n@@ -141,7 +142,7 @@ pub fn write_static_stored_file<E: Entry>(\n     let meta = StaticSortedFileBuilderMeta {\n         min_hash,\n         max_hash,\n-        amqf: Cow::Owned(amqf),\n+        amqf: Cow::Owned(amqf.into_vec()),\n         key_compression_dictionary_length: key_dict.len().try_into().unwrap(),\n         block_count,\n         size: file.stream_position()?,\n@@ -395,7 +396,7 @@ fn write_key_blocks_and_compute_amqf(\n     key_compression_dictionary: &[u8],\n     writer: &mut BlockWriter<'_>,\n     buffer: &mut Vec<u8>,\n-) -> Result<Vec<u8>> {\n+) -> Result<TurboBincodeBuffer> {\n     let mut filter = qfilter::Filter::new(entries.len() as u64, AMQF_FALSE_POSITIVE_RATE)\n         // This won't fail as we limit the number of entries per SST file\n         .expect(\"Filter can't be constructed\");\n@@ -502,7 +503,7 @@ fn write_key_blocks_and_compute_amqf(\n     writer.write_index_block(buffer, key_compression_dictionary)?;\n     buffer.clear();\n \n-    Ok(pot::to_vec(&filter).expect(\"AMQF serialization failed\"))\n+    Ok(turbo_bincode_encode(&AmqfBincodeWrapper(filter)).expect(\"AMQF serialization failed\"))\n }\n \n /// Builder for a single key block"
        },
        {
            "sha": "b48e6a0bd6e8f35b7434364bd7e41694523bb901",
            "filename": "turbopack/crates/turbo-tasks/Cargo.toml",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/b26b2b71792eebad4ade5362281a5bee68cd059e/turbopack%2Fcrates%2Fturbo-tasks%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/b26b2b71792eebad4ade5362281a5bee68cd059e/turbopack%2Fcrates%2Fturbo-tasks%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2FCargo.toml?ref=b26b2b71792eebad4ade5362281a5bee68cd059e",
            "patch": "@@ -56,7 +56,6 @@ turbo-tasks-hash = { workspace = true }\n turbo-tasks-macros = { workspace = true }\n turbo-tasks-malloc = { workspace = true }\n unsize = { workspace = true }\n-pot = \"3.0.0\"\n \n [dev-dependencies]\n criterion = { workspace = true, features = [\"async_tokio\"] }"
        },
        {
            "sha": "123d456792b602dde4b6882396a1e312593a8c79",
            "filename": "turbopack/crates/turbo-tasks/src/primitives.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/b26b2b71792eebad4ade5362281a5bee68cd059e/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fprimitives.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b26b2b71792eebad4ade5362281a5bee68cd059e/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fprimitives.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fprimitives.rs?ref=b26b2b71792eebad4ade5362281a5bee68cd059e",
            "patch": "@@ -56,7 +56,7 @@ impl ManualEncodeWrapper for JsonValueEncodeWrapper<'_> {\n \n impl Encode for JsonValueEncodeWrapper<'_> {\n     fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {\n-        turbo_bincode::serde_json::encode(self.0, encoder)\n+        turbo_bincode::serde_self_describing::encode(self.0, encoder)\n     }\n }\n \n@@ -72,6 +72,6 @@ impl ManualDecodeWrapper for JsonValueDecodeWrapper {\n \n impl<Context> Decode<Context> for JsonValueDecodeWrapper {\n     fn decode<D: Decoder<Context = Context>>(decoder: &mut D) -> Result<Self, DecodeError> {\n-        Ok(Self(turbo_bincode::serde_json::decode(decoder)?))\n+        Ok(Self(turbo_bincode::serde_self_describing::decode(decoder)?))\n     }\n }"
        },
        {
            "sha": "d58d555a296496a9319252742e6dfeb033b65419",
            "filename": "turbopack/crates/turbopack-node/src/transforms/util.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/b26b2b71792eebad4ade5362281a5bee68cd059e/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Futil.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b26b2b71792eebad4ade5362281a5bee68cd059e/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Futil.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Futil.rs?ref=b26b2b71792eebad4ade5362281a5bee68cd059e",
            "patch": "@@ -18,7 +18,7 @@ use turbopack_core::{\n pub struct EmittedAsset {\n     file: RcStr,\n     content: RcStr,\n-    #[bincode(with = \"turbo_bincode::serde_json\")]\n+    #[bincode(with = \"turbo_bincode::serde_self_describing\")]\n     source_map: Option<JsonValue>,\n }\n "
        },
        {
            "sha": "13e4516c2c245d67d0d0a9f33bbaad0095d75e64",
            "filename": "turbopack/crates/turbopack-node/src/transforms/webpack.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/b26b2b71792eebad4ade5362281a5bee68cd059e/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Fwebpack.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b26b2b71792eebad4ade5362281a5bee68cd059e/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Fwebpack.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Fwebpack.rs?ref=b26b2b71792eebad4ade5362281a5bee68cd059e",
            "patch": "@@ -98,7 +98,7 @@ struct WebpackLoadersProcessingResult {\n pub struct WebpackLoaderItem {\n     pub loader: RcStr,\n     #[serde(default)]\n-    #[bincode(with = \"turbo_bincode::serde_json\")]\n+    #[bincode(with = \"turbo_bincode::serde_self_describing\")]\n     pub options: serde_json::Map<String, serde_json::Value>,\n }\n \n@@ -364,7 +364,7 @@ enum LogType {\n pub struct LogInfo {\n     time: u64,\n     log_type: LogType,\n-    #[bincode(with = \"turbo_bincode::serde_json\")]\n+    #[bincode(with = \"turbo_bincode::serde_self_describing\")]\n     args: Vec<JsonValue>,\n     trace: Option<Vec<StackFrame<'static>>>,\n }"
        }
    ],
    "stats": {
        "total": 1308,
        "additions": 1197,
        "deletions": 111
    }
}