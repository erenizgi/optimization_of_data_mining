{
    "author": "lukesandberg",
    "message": "Add a new `fs` method to track a glob. (#78686)\n\nThis will ensure that the caller is invalidated whenever any directory or file matching the glob changes.\n\nHappy for feedback on the name!\n\nIn addition to creating this fast path for the webpack.rs loader, also optimize the way paths are constructed in `read_dir` to use `new_normalized` instead of `join`.  This allows us to skip some cpu intensive string manipulation that is unneeded when composing paths returned from a `readdir` operation.\n\nBefore:\n\n![before.png](https://graphite-user-uploaded-assets-prod.s3.amazonaws.com/AwJ29EfoPcPdLSwCZxAz/6e0ce683-da94-40ad-aeec-99e381d8dc26.png)\n\nWe can see the `read_glob` and `dir_dependency` calls which happened sequentially.\n\nAfter:\n\n![after.png](https://graphite-user-uploaded-assets-prod.s3.amazonaws.com/AwJ29EfoPcPdLSwCZxAz/988ed4ca-78a4-4849-b070-445981f018de.png)\n\nWe can see the same time spent in `read file` but we have saved a lot of time in `FileSystemPath::join` (eliminated!) and we eliminated the redundant traversal of `dir_dependency`.",
    "sha": "e22f3f80a0c6855f3b9b8d0a666ef7bd78a9b420",
    "files": [
        {
            "sha": "23f125873ee9855018260b18ae36c8f6c0ffa30c",
            "filename": "Cargo.lock",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/e22f3f80a0c6855f3b9b8d0a666ef7bd78a9b420/Cargo.lock",
            "raw_url": "https://github.com/vercel/next.js/raw/e22f3f80a0c6855f3b9b8d0a666ef7bd78a9b420/Cargo.lock",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/Cargo.lock?ref=e22f3f80a0c6855f3b9b8d0a666ef7bd78a9b420",
            "patch": "@@ -9549,6 +9549,7 @@ dependencies = [\n  \"triomphe 0.1.12\",\n  \"turbo-rcstr\",\n  \"turbo-tasks\",\n+ \"turbo-tasks-backend\",\n  \"turbo-tasks-build\",\n  \"turbo-tasks-hash\",\n  \"turbo-tasks-memory\","
        },
        {
            "sha": "172a5805df11d8d667b831ca68757e2b9be880dd",
            "filename": "turbopack/crates/turbo-tasks-fs/Cargo.toml",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/e22f3f80a0c6855f3b9b8d0a666ef7bd78a9b420/turbopack%2Fcrates%2Fturbo-tasks-fs%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/e22f3f80a0c6855f3b9b8d0a666ef7bd78a9b420/turbopack%2Fcrates%2Fturbo-tasks-fs%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2FCargo.toml?ref=e22f3f80a0c6855f3b9b8d0a666ef7bd78a9b420",
            "patch": "@@ -63,6 +63,7 @@ sha2 = \"0.10.2\"\n tempfile = { workspace = true }\n turbo-tasks-memory = { workspace = true }\n turbo-tasks-testing = { workspace = true }\n+turbo-tasks-backend = { workspace = true }\n \n [build-dependencies]\n turbo-tasks-build = { workspace = true }"
        },
        {
            "sha": "568053781886ca358f8a08336292d1b3b97a73bf",
            "filename": "turbopack/crates/turbo-tasks-fs/src/attach.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 6,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/e22f3f80a0c6855f3b9b8d0a666ef7bd78a9b420/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fattach.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e22f3f80a0c6855f3b9b8d0a666ef7bd78a9b420/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fattach.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fattach.rs?ref=e22f3f80a0c6855f3b9b8d0a666ef7bd78a9b420",
            "patch": "@@ -1,6 +1,6 @@\n use anyhow::{bail, Result};\n use turbo_rcstr::RcStr;\n-use turbo_tasks::{Completion, ResolvedVc, ValueToString, Vc};\n+use turbo_tasks::{ResolvedVc, ValueToString, Vc};\n \n use crate::{FileContent, FileMeta, FileSystem, FileSystemPath, LinkContent, RawDirectoryContent};\n \n@@ -133,11 +133,6 @@ impl FileSystem for AttachedFileSystem {\n         self.get_inner_fs_path(path).raw_read_dir()\n     }\n \n-    #[turbo_tasks::function(fs)]\n-    fn track(self: Vc<Self>, path: Vc<FileSystemPath>) -> Vc<Completion> {\n-        self.get_inner_fs_path(path).track()\n-    }\n-\n     #[turbo_tasks::function(fs)]\n     fn write(self: Vc<Self>, path: Vc<FileSystemPath>, content: Vc<FileContent>) -> Vc<()> {\n         self.get_inner_fs_path(path).write(content)"
        },
        {
            "sha": "694e287948fd701375eaa11907c8f7beb3fb4f46",
            "filename": "turbopack/crates/turbo-tasks-fs/src/embed/fs.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 6,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/e22f3f80a0c6855f3b9b8d0a666ef7bd78a9b420/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fembed%2Ffs.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e22f3f80a0c6855f3b9b8d0a666ef7bd78a9b420/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fembed%2Ffs.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fembed%2Ffs.rs?ref=e22f3f80a0c6855f3b9b8d0a666ef7bd78a9b420",
            "patch": "@@ -2,7 +2,7 @@ use anyhow::{bail, Result};\n use auto_hash_map::AutoMap;\n use include_dir::{Dir, DirEntry};\n use turbo_rcstr::RcStr;\n-use turbo_tasks::{Completion, ValueToString, Vc};\n+use turbo_tasks::{ValueToString, Vc};\n \n use crate::{\n     File, FileContent, FileMeta, FileSystem, FileSystemPath, LinkContent, RawDirectoryContent,\n@@ -69,11 +69,6 @@ impl FileSystem for EmbeddedFileSystem {\n         Ok(RawDirectoryContent::new(converted_entries))\n     }\n \n-    #[turbo_tasks::function]\n-    fn track(&self, _path: Vc<FileSystemPath>) -> Vc<Completion> {\n-        Completion::immutable()\n-    }\n-\n     #[turbo_tasks::function]\n     fn write(&self, _path: Vc<FileSystemPath>, _content: Vc<FileContent>) -> Result<Vc<()>> {\n         bail!(\"Writing is not possible to the embedded filesystem\")"
        },
        {
            "sha": "b6448d110709cc07d9e47aee2a99475f2bc7cf16",
            "filename": "turbopack/crates/turbo-tasks-fs/src/glob.rs",
            "status": "modified",
            "additions": 23,
            "deletions": 9,
            "changes": 32,
            "blob_url": "https://github.com/vercel/next.js/blob/e22f3f80a0c6855f3b9b8d0a666ef7bd78a9b420/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fglob.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e22f3f80a0c6855f3b9b8d0a666ef7bd78a9b420/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fglob.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fglob.rs?ref=e22f3f80a0c6855f3b9b8d0a666ef7bd78a9b420",
            "patch": "@@ -50,21 +50,33 @@ pub struct Glob {\n \n impl Glob {\n     pub fn execute(&self, path: &str) -> bool {\n+        // TODO(lukesandberg): deprecate this implicit behavior\n         let match_partial = path.ends_with('/');\n         self.iter_matches(path, true, match_partial)\n             .any(|result| matches!(result, (\"\", _)))\n     }\n \n+    // Returns true if the glob could match a filename underneath this `path` where the path\n+    // represents a directory.\n+    pub fn match_in_directory(&self, path: &str) -> bool {\n+        debug_assert!(!path.ends_with('/'));\n+        // TODO(lukesandberg): see if we can avoid this allocation by changing the matching\n+        // algorithm\n+        let path = format!(\"{path}/\");\n+        self.iter_matches(&path, true, true)\n+            .any(|result| matches!(result, (\"\", _)))\n+    }\n+\n     fn iter_matches<'a>(\n         &'a self,\n         path: &'a str,\n         previous_part_is_path_separator_equivalent: bool,\n-        match_partial: bool,\n+        match_in_directory: bool,\n     ) -> GlobMatchesIterator<'a> {\n         GlobMatchesIterator {\n             current: path,\n             glob: self,\n-            match_partial,\n+            match_in_directory,\n             is_path_separator_equivalent: previous_part_is_path_separator_equivalent,\n             stack: Vec::new(),\n             index: 0,\n@@ -89,7 +101,9 @@ impl Glob {\n struct GlobMatchesIterator<'a> {\n     current: &'a str,\n     glob: &'a Glob,\n-    match_partial: bool,\n+    // In this mode we are checking if the glob might match something in the directory represented\n+    // by this path.\n+    match_in_directory: bool,\n     is_path_separator_equivalent: bool,\n     stack: Vec<GlobPartMatchesIterator<'a>>,\n     index: usize,\n@@ -107,7 +121,7 @@ impl<'a> Iterator for GlobMatchesIterator<'a> {\n                     let iter = part.iter_matches(\n                         self.current,\n                         self.is_path_separator_equivalent,\n-                        self.match_partial,\n+                        self.match_in_directory,\n                     );\n                     self.stack.push(iter);\n                     self.stack.last_mut().unwrap()\n@@ -118,7 +132,7 @@ impl<'a> Iterator for GlobMatchesIterator<'a> {\n \n                     self.index += 1;\n \n-                    if self.match_partial && self.current.is_empty() {\n+                    if self.match_in_directory && self.current.is_empty() {\n                         return Some((\"\", self.is_path_separator_equivalent));\n                     }\n                 } else {\n@@ -152,12 +166,12 @@ impl GlobPart {\n         &'a self,\n         path: &'a str,\n         previous_part_is_path_separator_equivalent: bool,\n-        match_partial: bool,\n+        match_in_directory: bool,\n     ) -> GlobPartMatchesIterator<'a> {\n         GlobPartMatchesIterator {\n             path,\n             part: self,\n-            match_partial,\n+            match_in_directory,\n             previous_part_is_path_separator_equivalent,\n             cursor: GraphemeCursor::new(0, path.len(), true),\n             index: 0,\n@@ -256,7 +270,7 @@ impl GlobPart {\n struct GlobPartMatchesIterator<'a> {\n     path: &'a str,\n     part: &'a GlobPart,\n-    match_partial: bool,\n+    match_in_directory: bool,\n     previous_part_is_path_separator_equivalent: bool,\n     cursor: GraphemeCursor,\n     index: usize,\n@@ -375,7 +389,7 @@ impl<'a> Iterator for GlobPartMatchesIterator<'a> {\n                     self.glob_iterator = Some(Box::new(alternative.iter_matches(\n                         self.path,\n                         self.previous_part_is_path_separator_equivalent,\n-                        self.match_partial,\n+                        self.match_in_directory,\n                     )));\n                 } else {\n                     return None;"
        },
        {
            "sha": "27839318b679774850972eaa7d7ada599f0d9ca5",
            "filename": "turbopack/crates/turbo-tasks-fs/src/lib.rs",
            "status": "modified",
            "additions": 41,
            "deletions": 35,
            "changes": 76,
            "blob_url": "https://github.com/vercel/next.js/blob/e22f3f80a0c6855f3b9b8d0a666ef7bd78a9b420/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e22f3f80a0c6855f3b9b8d0a666ef7bd78a9b420/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs?ref=e22f3f80a0c6855f3b9b8d0a666ef7bd78a9b420",
            "patch": "@@ -46,8 +46,8 @@ use invalidator_map::InvalidatorMap;\n use jsonc_parser::{parse_to_serde_value, ParseOptions};\n use mime::Mime;\n use rayon::iter::{IntoParallelIterator, ParallelIterator};\n-use read_glob::read_glob;\n pub use read_glob::ReadGlobResult;\n+use read_glob::{read_glob, track_glob};\n use serde::{Deserialize, Serialize};\n use serde_json::Value;\n use tokio::{\n@@ -203,7 +203,6 @@ pub trait FileSystem: ValueToString {\n     fn read(self: Vc<Self>, fs_path: Vc<FileSystemPath>) -> Vc<FileContent>;\n     fn read_link(self: Vc<Self>, fs_path: Vc<FileSystemPath>) -> Vc<LinkContent>;\n     fn raw_read_dir(self: Vc<Self>, fs_path: Vc<FileSystemPath>) -> Vc<RawDirectoryContent>;\n-    fn track(self: Vc<Self>, fs_path: Vc<FileSystemPath>) -> Vc<Completion>;\n     fn write(self: Vc<Self>, fs_path: Vc<FileSystemPath>, content: Vc<FileContent>) -> Vc<()>;\n     fn write_link(self: Vc<Self>, fs_path: Vc<FileSystemPath>, target: Vc<LinkContent>) -> Vc<()>;\n     fn metadata(self: Vc<Self>, fs_path: Vc<FileSystemPath>) -> Vc<FileMeta>;\n@@ -686,14 +685,6 @@ impl FileSystem for DiskFileSystem {\n         .cell())\n     }\n \n-    #[turbo_tasks::function(fs)]\n-    async fn track(&self, fs_path: Vc<FileSystemPath>) -> Result<Vc<Completion>> {\n-        mark_session_dependent();\n-        let full_path = self.to_sys_path(fs_path).await?;\n-        self.inner.register_read_invalidator(&full_path)?;\n-        Ok(Completion::new())\n-    }\n-\n     #[turbo_tasks::function(fs)]\n     async fn write(&self, fs_path: Vc<FileSystemPath>, content: Vc<FileContent>) -> Result<()> {\n         mark_session_dependent();\n@@ -1328,6 +1319,13 @@ impl FileSystemPath {\n         read_glob(self, glob, include_dot_files)\n     }\n \n+    // Tracks all files and directories matching the glob\n+    // Follows symlinks as though they were part of the original hierarchy.\n+    #[turbo_tasks::function]\n+    pub fn track_glob(self: Vc<Self>, glob: Vc<Glob>, include_dot_files: bool) -> Vc<Completion> {\n+        track_glob(self, glob, include_dot_files)\n+    }\n+\n     #[turbo_tasks::function]\n     pub fn root(self: Vc<Self>) -> Vc<Self> {\n         self.fs().root()\n@@ -1466,10 +1464,6 @@ impl FileSystemPath {\n         self.fs().raw_read_dir(self)\n     }\n \n-    pub fn track(self: Vc<Self>) -> Vc<Completion> {\n-        self.fs().track(self)\n-    }\n-\n     pub fn write(self: Vc<Self>, content: Vc<FileContent>) -> Vc<()> {\n         self.fs().write(self, content)\n     }\n@@ -1503,24 +1497,29 @@ impl FileSystemPath {\n     /// depend on the order.\n     #[turbo_tasks::function]\n     pub async fn read_dir(self: Vc<Self>) -> Result<Vc<DirectoryContent>> {\n-        match &*self.await?.fs.raw_read_dir(self).await? {\n+        let this = self.await?;\n+        let fs = this.fs;\n+        match &*fs.raw_read_dir(self).await? {\n             RawDirectoryContent::NotFound => Ok(DirectoryContent::not_found()),\n             RawDirectoryContent::Entries(entries) => {\n                 let mut normalized_entries = AutoMap::new();\n+                let dir_path = &this.path;\n                 for (name, entry) in entries {\n+                    // Construct the path directly instead of going through `join`.\n+                    // We do not need to normalize since the `name` is guaranteed to be a simple\n+                    // path segment.\n+                    let path = if dir_path.is_empty() {\n+                        name.clone()\n+                    } else {\n+                        RcStr::from(format!(\"{dir_path}/{name}\"))\n+                    };\n+\n+                    let entry_path = Self::new_normalized(*fs, path).to_resolved().await?;\n                     let entry = match entry {\n-                        RawDirectoryEntry::File => {\n-                            DirectoryEntry::File(self.join(name.clone()).to_resolved().await?)\n-                        }\n-                        RawDirectoryEntry::Directory => {\n-                            DirectoryEntry::Directory(self.join(name.clone()).to_resolved().await?)\n-                        }\n-                        RawDirectoryEntry::Symlink => {\n-                            DirectoryEntry::Symlink(self.join(name.clone()).to_resolved().await?)\n-                        }\n-                        RawDirectoryEntry::Other => {\n-                            DirectoryEntry::Other(self.join(name.clone()).to_resolved().await?)\n-                        }\n+                        RawDirectoryEntry::File => DirectoryEntry::File(entry_path),\n+                        RawDirectoryEntry::Directory => DirectoryEntry::Directory(entry_path),\n+                        RawDirectoryEntry::Symlink => DirectoryEntry::Symlink(entry_path),\n+                        RawDirectoryEntry::Other => DirectoryEntry::Other(entry_path),\n                         RawDirectoryEntry::Error => DirectoryEntry::Error,\n                     };\n                     normalized_entries.insert(name.clone(), entry);\n@@ -2305,10 +2304,10 @@ pub enum DirectoryEntry {\n     Error,\n }\n \n-/// Handles the `DirectoryEntry::Symlink` variant by checking the symlink target\n-/// type and replacing it with `DirectoryEntry::File` or\n-/// `DirectoryEntry::Directory`.\n impl DirectoryEntry {\n+    /// Handles the `DirectoryEntry::Symlink` variant by checking the symlink target\n+    /// type and replacing it with `DirectoryEntry::File` or\n+    /// `DirectoryEntry::Directory`.\n     pub async fn resolve_symlink(self) -> Result<Self> {\n         if let DirectoryEntry::Symlink(symlink) = self {\n             let real_path = symlink.realpath().to_resolved().await?;\n@@ -2321,6 +2320,16 @@ impl DirectoryEntry {\n             Ok(self)\n         }\n     }\n+\n+    pub fn path(self) -> Option<ResolvedVc<FileSystemPath>> {\n+        match self {\n+            DirectoryEntry::File(path)\n+            | DirectoryEntry::Directory(path)\n+            | DirectoryEntry::Symlink(path)\n+            | DirectoryEntry::Other(path) => Some(path),\n+            DirectoryEntry::Error => None,\n+        }\n+    }\n }\n \n #[turbo_tasks::value]\n@@ -2384,6 +2393,8 @@ impl From<&RawDirectoryEntry> for FileSystemEntryType {\n #[turbo_tasks::value]\n #[derive(Debug)]\n pub enum RawDirectoryContent {\n+    // The entry keys are the directory relative file names\n+    // e.g. for `/bar/foo`, it will be `foo`\n     Entries(AutoMap<RcStr, RawDirectoryEntry>),\n     NotFound,\n }\n@@ -2435,11 +2446,6 @@ impl FileSystem for NullFileSystem {\n         RawDirectoryContent::not_found()\n     }\n \n-    #[turbo_tasks::function]\n-    fn track(&self, _fs_path: Vc<FileSystemPath>) -> Vc<Completion> {\n-        Completion::immutable()\n-    }\n-\n     #[turbo_tasks::function]\n     fn write(&self, _fs_path: Vc<FileSystemPath>, _content: Vc<FileContent>) -> Vc<()> {\n         Vc::default()"
        },
        {
            "sha": "4168c64bee11ef2fed624b4f79b3542e97d538b0",
            "filename": "turbopack/crates/turbo-tasks-fs/src/read_glob.rs",
            "status": "modified",
            "additions": 421,
            "deletions": 23,
            "changes": 444,
            "blob_url": "https://github.com/vercel/next.js/blob/e22f3f80a0c6855f3b9b8d0a666ef7bd78a9b420/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fread_glob.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e22f3f80a0c6855f3b9b8d0a666ef7bd78a9b420/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fread_glob.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fread_glob.rs?ref=e22f3f80a0c6855f3b9b8d0a666ef7bd78a9b420",
            "patch": "@@ -1,9 +1,10 @@\n-use anyhow::Result;\n+use anyhow::{bail, Result};\n+use futures::try_join;\n use rustc_hash::FxHashMap;\n use turbo_rcstr::RcStr;\n-use turbo_tasks::{ResolvedVc, Vc};\n+use turbo_tasks::{Completion, ResolvedVc, TryJoinIterExt, Vc};\n \n-use crate::{glob::Glob, DirectoryContent, DirectoryEntry, FileSystemPath};\n+use crate::{glob::Glob, DirectoryContent, DirectoryEntry, FileSystem, FileSystemPath};\n \n #[turbo_tasks::value]\n #[derive(Default, Debug)]\n@@ -35,6 +36,7 @@ async fn read_glob_inner(\n     Ok(*read_glob_internal(&prefix, directory, glob, include_dot_files).await?)\n }\n \n+// The `prefix` represents the relative directory path where symlinks are not resolve.\n async fn read_glob_internal(\n     prefix: &str,\n     directory: Vc<FileSystemPath>,\n@@ -50,35 +52,431 @@ async fn read_glob_internal(\n                 if !include_dot_files && segment.starts_with('.') {\n                     continue;\n                 }\n-                let entry = entry.resolve_symlink().await?;\n-                match entry {\n+                // This is redundant with logic inside of `read_dir` but here we track it separately\n+                // so we don't follow symlinks.\n+                let entry_path: RcStr = if prefix.is_empty() {\n+                    segment.clone()\n+                } else {\n+                    format!(\"{prefix}/{segment}\").into()\n+                };\n+                let entry = resolve_symlink_safely(entry).await?;\n+                if glob_value.execute(&entry_path) {\n+                    result.results.insert(entry_path.to_string(), entry);\n+                }\n+                if let DirectoryEntry::Directory(path) = entry {\n+                    if glob_value.match_in_directory(&entry_path) {\n+                        result.inner.insert(\n+                            entry_path.to_string(),\n+                            read_glob_inner(entry_path, *path, glob, include_dot_files)\n+                                .to_resolved()\n+                                .await?,\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+        DirectoryContent::NotFound => {}\n+    }\n+    Ok(ReadGlobResult::resolved_cell(result))\n+}\n+\n+// Resolve a symlink checking for recursion.\n+async fn resolve_symlink_safely(entry: &DirectoryEntry) -> Result<DirectoryEntry> {\n+    let resolved_entry = entry.resolve_symlink().await?;\n+    if resolved_entry != *entry && matches!(&resolved_entry, DirectoryEntry::Directory(_)) {\n+        // We followed a symlink to a directory\n+        // To prevent an infinite loop, which in the case of turbo-tasks would simply\n+        // exhaust RAM or go into an infinite loop with the GC we need to check for a\n+        // recursive symlink, we need to check for recursion.\n+\n+        // Recursion can only occur if the symlink is a directory and points to an\n+        // ancestor of the current path, which can be detected via a simple prefix\n+        // match.\n+        let source_path = entry.path().unwrap();\n+        if *source_path\n+            .is_inside_or_equal(*resolved_entry.path().unwrap())\n+            .await?\n+        {\n+            bail!(\n+                \"'{}' is a symlink causes that causes an infinite loop!\",\n+                source_path.await?.path.to_string()\n+            )\n+        }\n+    }\n+    Ok(resolved_entry)\n+}\n+\n+/// Traverses all directories that match the given `glob`.\n+///\n+/// This ensures that the calling task will be invalidated\n+/// whenever the directories or contents of the directories change,\n+///  but unlike read_glob doesn't accumulate data.\n+#[turbo_tasks::function(fs)]\n+pub async fn track_glob(\n+    directory: Vc<FileSystemPath>,\n+    glob: Vc<Glob>,\n+    include_dot_files: bool,\n+) -> Result<Vc<Completion>> {\n+    track_glob_internal(\"\", directory, glob, include_dot_files).await\n+}\n+\n+#[turbo_tasks::function(fs)]\n+async fn track_glob_inner(\n+    prefix: RcStr,\n+    directory: Vc<FileSystemPath>,\n+    glob: Vc<Glob>,\n+    include_dot_files: bool,\n+) -> Result<Vc<Completion>> {\n+    track_glob_internal(&prefix, directory, glob, include_dot_files).await\n+}\n+\n+async fn track_glob_internal(\n+    prefix: &str,\n+    directory: Vc<FileSystemPath>,\n+    glob: Vc<Glob>,\n+    include_dot_files: bool,\n+) -> Result<Vc<Completion>> {\n+    let dir = directory.read_dir().await?;\n+    let glob_value = glob.await?;\n+    let fs = directory.fs().to_resolved().await?;\n+    let mut reads = Vec::new();\n+    let mut completions = Vec::new();\n+    let mut types = Vec::new();\n+    match &*dir {\n+        DirectoryContent::Entries(entries) => {\n+            for (segment, entry) in entries.iter() {\n+                if !include_dot_files && segment.starts_with('.') {\n+                    continue;\n+                }\n+                // This is redundant with logic inside of `read_dir` but here we track it separately\n+                // so we don't follow symlinks.\n+                let entry_path = if prefix.is_empty() {\n+                    segment.clone()\n+                } else {\n+                    format!(\"{prefix}/{segment}\").into()\n+                };\n+\n+                match resolve_symlink_safely(entry).await? {\n                     DirectoryEntry::Directory(path) => {\n-                        let full_path = format!(\"{prefix}{segment}\");\n-                        let full_path_prefix: RcStr = format!(\"{full_path}/\").into();\n-                        if glob_value.execute(&full_path) {\n-                            result\n-                                .results\n-                                .insert(full_path.clone(), DirectoryEntry::Directory(path));\n+                        if glob_value.match_in_directory(&entry_path) {\n+                            completions.push(track_glob_inner(\n+                                entry_path,\n+                                *path,\n+                                glob,\n+                                include_dot_files,\n+                            ));\n                         }\n-                        if glob_value.execute(&full_path_prefix) {\n-                            result.inner.insert(\n-                                full_path,\n-                                read_glob_inner(full_path_prefix, *path, glob, include_dot_files)\n-                                    .to_resolved()\n-                                    .await?,\n-                            );\n+                    }\n+                    DirectoryEntry::File(path) => {\n+                        if glob_value.execute(&entry_path) {\n+                            reads.push(fs.read(*path))\n                         }\n                     }\n-                    entry => {\n-                        let full_path = format!(\"{prefix}{segment}\");\n-                        if glob_value.execute(&full_path) {\n-                            result.results.insert(full_path, entry);\n+                    DirectoryEntry::Symlink(_) => panic!(\"we already resolved symlinks\"),\n+                    DirectoryEntry::Other(path) => {\n+                        if glob_value.execute(&entry_path) {\n+                            types.push(path.get_type())\n                         }\n                     }\n+                    DirectoryEntry::Error => {}\n                 }\n             }\n         }\n         DirectoryContent::NotFound => {}\n     }\n-    Ok(ReadGlobResult::resolved_cell(result))\n+    try_join!(\n+        reads.iter().try_join(),\n+        types.iter().try_join(),\n+        completions.iter().try_join()\n+    )?;\n+    Ok(Completion::new())\n+}\n+\n+#[cfg(test)]\n+pub mod tests {\n+\n+    use std::{\n+        fs::{create_dir, File},\n+        io::prelude::*,\n+    };\n+\n+    use turbo_rcstr::RcStr;\n+    use turbo_tasks::{apply_effects, Completion, ReadRef, ResolvedVc, Vc};\n+    use turbo_tasks_backend::{noop_backing_storage, BackendOptions, TurboTasksBackend};\n+\n+    use crate::{\n+        glob::Glob, DirectoryEntry, DiskFileSystem, FileContent, FileSystem, FileSystemPath,\n+    };\n+\n+    #[tokio::test]\n+    async fn read_glob_basic() {\n+        crate::register();\n+        let scratch = tempfile::tempdir().unwrap();\n+        {\n+            // Create a simple directory with 2 files, a subdirectory and a dotfile\n+            let path = scratch.path();\n+            File::create_new(path.join(\"foo\"))\n+                .unwrap()\n+                .write_all(b\"foo\")\n+                .unwrap();\n+            create_dir(path.join(\"sub\")).unwrap();\n+            File::create_new(path.join(\"sub/bar\"))\n+                .unwrap()\n+                .write_all(b\"bar\")\n+                .unwrap();\n+            // Add a dotfile\n+            File::create_new(path.join(\"sub/.gitignore\"))\n+                .unwrap()\n+                .write_all(b\"ignore\")\n+                .unwrap();\n+        }\n+        let tt = turbo_tasks::TurboTasks::new(TurboTasksBackend::new(\n+            BackendOptions::default(),\n+            noop_backing_storage(),\n+        ));\n+        let path: RcStr = scratch.path().to_str().unwrap().into();\n+        tt.run_once(async {\n+            let fs = Vc::upcast::<Box<dyn FileSystem>>(DiskFileSystem::new(\n+                \"temp\".into(),\n+                path,\n+                Vec::new(),\n+            ));\n+            let read_dir = fs\n+                .root()\n+                .read_glob(Glob::new(\"**\".into()), false)\n+                .await\n+                .unwrap();\n+            assert_eq!(read_dir.results.len(), 2);\n+            assert_eq!(\n+                read_dir.results.get(\"foo\"),\n+                Some(&DirectoryEntry::File(\n+                    fs.root().join(\"foo\".into()).to_resolved().await?\n+                ))\n+            );\n+            assert_eq!(\n+                read_dir.results.get(\"sub\"),\n+                Some(&DirectoryEntry::Directory(\n+                    fs.root().join(\"sub\".into()).to_resolved().await?\n+                ))\n+            );\n+            assert_eq!(read_dir.inner.len(), 1);\n+            let inner = &*read_dir.inner.get(\"sub\").unwrap().await?;\n+            assert_eq!(inner.results.len(), 1);\n+            assert_eq!(\n+                inner.results.get(\"sub/bar\"),\n+                Some(&DirectoryEntry::File(\n+                    fs.root().join(\"sub/bar\".into()).to_resolved().await?\n+                ))\n+            );\n+            assert_eq!(inner.inner.len(), 0);\n+\n+            // Now with a more specific pattern\n+            let read_dir = fs\n+                .root()\n+                .read_glob(Glob::new(\"**/bar\".into()), false)\n+                .await\n+                .unwrap();\n+            assert_eq!(read_dir.results.len(), 0);\n+            assert_eq!(read_dir.inner.len(), 1);\n+            let inner = &*read_dir.inner.get(\"sub\").unwrap().await?;\n+            assert_eq!(inner.results.len(), 1);\n+            assert_eq!(\n+                inner.results.get(\"sub/bar\"),\n+                Some(&DirectoryEntry::File(\n+                    fs.root().join(\"sub/bar\".into()).to_resolved().await?\n+                ))\n+            );\n+            assert_eq!(inner.inner.len(), 0);\n+\n+            anyhow::Ok(())\n+        })\n+        .await\n+        .unwrap();\n+    }\n+\n+    #[cfg(unix)]\n+    #[tokio::test]\n+    async fn read_glob_symlinks() {\n+        crate::register();\n+        let scratch = tempfile::tempdir().unwrap();\n+        {\n+            use std::os::unix::fs::symlink;\n+\n+            // Create a simple directory with 1 file and a symlink pointing at at a file in a\n+            // subdirectory\n+            let path = scratch.path();\n+            create_dir(path.join(\"sub\")).unwrap();\n+            let foo = path.join(\"sub/foo.js\");\n+            File::create_new(&foo).unwrap().write_all(b\"foo\").unwrap();\n+            symlink(&foo, path.join(\"link.js\")).unwrap();\n+        }\n+        let tt = turbo_tasks::TurboTasks::new(TurboTasksBackend::new(\n+            BackendOptions::default(),\n+            noop_backing_storage(),\n+        ));\n+        let path: RcStr = scratch.path().to_str().unwrap().into();\n+        tt.run_once(async {\n+            let fs = Vc::upcast::<Box<dyn FileSystem>>(DiskFileSystem::new(\n+                \"temp\".into(),\n+                path,\n+                Vec::new(),\n+            ));\n+            let read_dir = fs\n+                .root()\n+                .read_glob(Glob::new(\"*.js\".into()), false)\n+                .await\n+                .unwrap();\n+            assert_eq!(read_dir.results.len(), 1);\n+            assert_eq!(\n+                read_dir.results.get(\"link.js\"),\n+                Some(&DirectoryEntry::File(\n+                    fs.root().join(\"sub/foo.js\".into()).to_resolved().await?\n+                ))\n+            );\n+            assert_eq!(read_dir.inner.len(), 0);\n+\n+            anyhow::Ok(())\n+        })\n+        .await\n+        .unwrap();\n+    }\n+\n+    #[turbo_tasks::function(operation)]\n+    pub async fn delete(path: ResolvedVc<FileSystemPath>) -> anyhow::Result<()> {\n+        path.write(FileContent::NotFound.cell()).await?;\n+        Ok(())\n+    }\n+\n+    #[turbo_tasks::function(operation)]\n+    pub async fn track_star_star_glob(path: ResolvedVc<FileSystemPath>) -> Vc<Completion> {\n+        path.track_glob(Glob::new(\"**\".into()), false)\n+    }\n+\n+    #[tokio::test]\n+    async fn track_glob_invalidations() {\n+        crate::register();\n+        let scratch = tempfile::tempdir().unwrap();\n+\n+        // Create a simple directory with 2 files, a subdirectory and a dotfile\n+        let path = scratch.path();\n+        File::create_new(path.join(\"foo\"))\n+            .unwrap()\n+            .write_all(b\"foo\")\n+            .unwrap();\n+        create_dir(path.join(\"sub\")).unwrap();\n+        File::create_new(path.join(\"sub/bar\"))\n+            .unwrap()\n+            .write_all(b\"bar\")\n+            .unwrap();\n+        // Add a dotfile\n+        create_dir(path.join(\"sub/.vim\")).unwrap();\n+        let gitignore = path.join(\"sub/.vim/.gitignore\");\n+        File::create_new(&gitignore)\n+            .unwrap()\n+            .write_all(b\"ignore\")\n+            .unwrap();\n+\n+        let tt = turbo_tasks::TurboTasks::new(TurboTasksBackend::new(\n+            BackendOptions::default(),\n+            noop_backing_storage(),\n+        ));\n+        let path: RcStr = scratch.path().to_str().unwrap().into();\n+        tt.run_once(async {\n+            let fs = Vc::upcast::<Box<dyn FileSystem>>(DiskFileSystem::new(\n+                \"temp\".into(),\n+                path,\n+                Vec::new(),\n+            ));\n+            let read_dir = track_star_star_glob(fs.root().to_resolved().await?)\n+                .read_strongly_consistent()\n+                .await?;\n+\n+            // Delete a file that we shouldn't be tracking\n+            let delete_result = delete(\n+                fs.root()\n+                    .join(\"sub/.vim/.gitignore\".into())\n+                    .to_resolved()\n+                    .await?,\n+            );\n+            delete_result.read_strongly_consistent().await?;\n+            apply_effects(delete_result).await?;\n+\n+            let read_dir2 = track_star_star_glob(fs.root().to_resolved().await?)\n+                .read_strongly_consistent()\n+                .await?;\n+            assert!(ReadRef::ptr_eq(&read_dir, &read_dir2));\n+\n+            // Delete a file that we should be tracking\n+            let delete_result = delete(fs.root().join(\"foo\".into()).to_resolved().await?);\n+            delete_result.read_strongly_consistent().await?;\n+            apply_effects(delete_result).await?;\n+\n+            let read_dir2 = track_star_star_glob(fs.root().to_resolved().await?)\n+                .read_strongly_consistent()\n+                .await?;\n+\n+            assert!(!ReadRef::ptr_eq(&read_dir, &read_dir2));\n+            anyhow::Ok(())\n+        })\n+        .await\n+        .unwrap();\n+    }\n+\n+    #[cfg(unix)]\n+    #[tokio::test]\n+    async fn read_glob_symlinks_loop() {\n+        crate::register();\n+        let scratch = tempfile::tempdir().unwrap();\n+        {\n+            use std::os::unix::fs::symlink;\n+\n+            // Create a simple directory with 1 file and a symlink pointing at at a file in a\n+            // subdirectory\n+            let path = scratch.path();\n+            let sub = &path.join(\"sub\");\n+            create_dir(sub).unwrap();\n+            let foo = sub.join(\"foo.js\");\n+            File::create_new(&foo).unwrap().write_all(b\"foo\").unwrap();\n+            // put a link in sub that points back at its parent director\n+            symlink(sub, sub.join(\"link\")).unwrap();\n+        }\n+        let tt = turbo_tasks::TurboTasks::new(TurboTasksBackend::new(\n+            BackendOptions::default(),\n+            noop_backing_storage(),\n+        ));\n+        let path: RcStr = scratch.path().to_str().unwrap().into();\n+        tt.run_once(async {\n+            let fs = Vc::upcast::<Box<dyn FileSystem>>(DiskFileSystem::new(\n+                \"temp\".into(),\n+                path,\n+                Vec::new(),\n+            ));\n+            let err = fs\n+                .root()\n+                .read_glob(Glob::new(\"**\".into()), false)\n+                .await\n+                .expect_err(\"Should have detected an infinite loop\");\n+\n+            assert_eq!(\n+                \"'sub/link' is a symlink causes that causes an infinite loop!\",\n+                format!(\"{}\", err.root_cause())\n+            );\n+\n+            // Same when calling track glob\n+            let err = fs\n+                .root()\n+                .track_glob(Glob::new(\"**\".into()), false)\n+                .await\n+                .expect_err(\"Should have detected an infinite loop\");\n+\n+            assert_eq!(\n+                \"'sub/link' is a symlink causes that causes an infinite loop!\",\n+                format!(\"{}\", err.root_cause())\n+            );\n+\n+            anyhow::Ok(())\n+        })\n+        .await\n+        .unwrap();\n+    }\n }"
        },
        {
            "sha": "ce5e2286885a355fb975ee19369bfd7520bede14",
            "filename": "turbopack/crates/turbo-tasks-fs/src/virtual_fs.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 6,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/e22f3f80a0c6855f3b9b8d0a666ef7bd78a9b420/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fvirtual_fs.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e22f3f80a0c6855f3b9b8d0a666ef7bd78a9b420/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fvirtual_fs.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fvirtual_fs.rs?ref=e22f3f80a0c6855f3b9b8d0a666ef7bd78a9b420",
            "patch": "@@ -1,6 +1,6 @@\n use anyhow::{bail, Result};\n use turbo_rcstr::RcStr;\n-use turbo_tasks::{Completion, ValueDefault, ValueToString, Vc};\n+use turbo_tasks::{ValueDefault, ValueToString, Vc};\n \n use super::{FileContent, FileMeta, FileSystem, FileSystemPath, LinkContent};\n use crate::RawDirectoryContent;\n@@ -61,11 +61,6 @@ impl FileSystem for VirtualFileSystem {\n         bail!(\"Reading is not possible on the virtual file system\")\n     }\n \n-    #[turbo_tasks::function]\n-    fn track(&self, _fs_path: Vc<FileSystemPath>) -> Result<Vc<Completion>> {\n-        bail!(\"Tracking is not possible on the virtual file system\")\n-    }\n-\n     #[turbo_tasks::function]\n     fn write(&self, _fs_path: Vc<FileSystemPath>, _content: Vc<FileContent>) -> Result<Vc<()>> {\n         bail!(\"Writing is not possible on the virtual file system\")"
        },
        {
            "sha": "ecab9470a8113e44d5b2951b22f0bcf3e0754aca",
            "filename": "turbopack/crates/turbo-tasks-fuzz/src/main.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/e22f3f80a0c6855f3b9b8d0a666ef7bd78a9b420/turbopack%2Fcrates%2Fturbo-tasks-fuzz%2Fsrc%2Fmain.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e22f3f80a0c6855f3b9b8d0a666ef7bd78a9b420/turbopack%2Fcrates%2Fturbo-tasks-fuzz%2Fsrc%2Fmain.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fuzz%2Fsrc%2Fmain.rs?ref=e22f3f80a0c6855f3b9b8d0a666ef7bd78a9b420",
            "patch": "@@ -157,7 +157,7 @@ async fn read_path(\n ) -> anyhow::Result<()> {\n     let path_str = path.await?.path.clone();\n     invalidations.0.lock().unwrap().insert(path_str);\n-    let _ = path.track().await?;\n+    let _ = path.read().await?;\n     Ok(())\n }\n "
        },
        {
            "sha": "ea23b56f34498367d6db339f96b2d6889dcca762",
            "filename": "turbopack/crates/turbopack-core/src/server_fs.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 6,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/e22f3f80a0c6855f3b9b8d0a666ef7bd78a9b420/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fserver_fs.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e22f3f80a0c6855f3b9b8d0a666ef7bd78a9b420/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fserver_fs.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fserver_fs.rs?ref=e22f3f80a0c6855f3b9b8d0a666ef7bd78a9b420",
            "patch": "@@ -1,6 +1,6 @@\n use anyhow::{bail, Result};\n use turbo_rcstr::RcStr;\n-use turbo_tasks::{Completion, ValueToString, Vc};\n+use turbo_tasks::{ValueToString, Vc};\n use turbo_tasks_fs::{\n     FileContent, FileMeta, FileSystem, FileSystemPath, LinkContent, RawDirectoryContent,\n };\n@@ -33,11 +33,6 @@ impl FileSystem for ServerFileSystem {\n         bail!(\"Reading is not possible from the marker filesystem for the server\")\n     }\n \n-    #[turbo_tasks::function]\n-    fn track(&self, _fs_path: Vc<FileSystemPath>) -> Result<Vc<Completion>> {\n-        bail!(\"Tracking is not possible to the marker filesystem for the server\")\n-    }\n-\n     #[turbo_tasks::function]\n     fn write(&self, _fs_path: Vc<FileSystemPath>, _content: Vc<FileContent>) -> Result<Vc<()>> {\n         bail!(\"Writing is not possible to the marker filesystem for the server\")"
        },
        {
            "sha": "3e0bf00d507a4b4e7d1ece49f2313710d2d2e70e",
            "filename": "turbopack/crates/turbopack-node/src/transforms/webpack.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 50,
            "changes": 54,
            "blob_url": "https://github.com/vercel/next.js/blob/e22f3f80a0c6855f3b9b8d0a666ef7bd78a9b420/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Fwebpack.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e22f3f80a0c6855f3b9b8d0a666ef7bd78a9b420/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Fwebpack.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Fwebpack.rs?ref=e22f3f80a0c6855f3b9b8d0a666ef7bd78a9b420",
            "patch": "@@ -16,8 +16,7 @@ use turbo_tasks::{\n use turbo_tasks_bytes::stream::SingleValue;\n use turbo_tasks_env::ProcessEnv;\n use turbo_tasks_fs::{\n-    glob::Glob, json::parse_json_with_source_context, rope::Rope, DirectoryEntry, File,\n-    FileContent, FileSystemPath, ReadGlobResult,\n+    glob::Glob, json::parse_json_with_source_context, rope::Rope, File, FileContent, FileSystemPath,\n };\n use turbopack_core::{\n     asset::{Asset, AssetContent},\n@@ -510,15 +509,9 @@ impl EvaluateContext for WebpackLoaderContext {\n                 let directory_subscriptions = directories\n                     .iter()\n                     .map(|(dir, glob)| {\n-                        // TODO: there is some redundancy between `dir_dependency` and what\n-                        // `read_glob` does, Introduce a new read_glob\n-                        // option that will track all files the way\n-                        // `dir_dependency` does but in a single traversal.\n-                        dir_dependency(\n-                            self.cwd\n-                                .join(dir.clone())\n-                                .read_glob(Glob::new(glob.clone()), false),\n-                        )\n+                        self.cwd\n+                            .join(dir.clone())\n+                            .track_glob(Glob::new(glob.clone()), false)\n                     })\n                     .try_join();\n                 let build_paths = build_file_paths\n@@ -778,45 +771,6 @@ impl Issue for BuildDependencyIssue {\n     }\n }\n \n-/// A hack to invalidate when any file in a directory changes. Need to be\n-/// awaited before files are accessed.\n-#[turbo_tasks::function]\n-async fn dir_dependency(glob: Vc<ReadGlobResult>) -> Result<Vc<Completion>> {\n-    let shallow = dir_dependency_shallow(glob);\n-    let glob = glob.await?;\n-    glob.inner\n-        .values()\n-        .map(|&inner| dir_dependency(*inner))\n-        .try_join()\n-        .await?;\n-    shallow.await?;\n-    Ok(Completion::new())\n-}\n-\n-#[turbo_tasks::function]\n-async fn dir_dependency_shallow(glob: Vc<ReadGlobResult>) -> Result<Vc<Completion>> {\n-    let glob = glob.await?;\n-    for item in glob.results.values() {\n-        // Reading all files to add itself as dependency\n-        match *item {\n-            DirectoryEntry::File(file) => {\n-                file.read().await?;\n-            }\n-            DirectoryEntry::Directory(dir) => {\n-                dir_dependency(dir.read_glob(Glob::new(\"**\".into()), false)).await?;\n-            }\n-            DirectoryEntry::Symlink(symlink) => {\n-                symlink.read_link().await?;\n-            }\n-            DirectoryEntry::Other(other) => {\n-                other.get_type().await?;\n-            }\n-            DirectoryEntry::Error => {}\n-        }\n-    }\n-    Ok(Completion::new())\n-}\n-\n #[turbo_tasks::value(shared)]\n pub struct EvaluateEmittedErrorIssue {\n     pub file_path: ResolvedVc<FileSystemPath>,"
        }
    ],
    "stats": {
        "total": 638,
        "additions": 496,
        "deletions": 142
    }
}