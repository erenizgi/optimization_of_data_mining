{
    "author": "bgub",
    "message": "feat: Turbopack typed links (#81528)\n\n# Typed Links: Turbopack support\n\nThis PR replaces the old `experimental.typedRoutes` implementation with\na new approach that works on both Turbopack and Webpack.\n\n_Note: a previous version of this PR contained new props for the `Link`\ncomponent: `path`, `params`, and `searchParams`. In the interest of\nbringing typed links support to Turbopack as soon as possible, I've\nremoved that change from this PR and will create a new one later._",
    "sha": "1faf0323e4d0de3650b104ec03c1f85b126bde4b",
    "files": [
        {
            "sha": "cea1e408f901223f4ce6fdebf9d0b8d4a5e22cd1",
            "filename": "packages/next/src/build/index.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/1faf0323e4d0de3650b104ec03c1f85b126bde4b/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1faf0323e4d0de3650b104ec03c1f85b126bde4b/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts?ref=1faf0323e4d0de3650b104ec03c1f85b126bde4b",
            "patch": "@@ -1316,7 +1316,11 @@ export default async function build(\n             rewrites: config.rewrites,\n           })\n \n-          await writeRouteTypesManifest(routeTypesManifest, routeTypesFilePath)\n+          await writeRouteTypesManifest(\n+            routeTypesManifest,\n+            routeTypesFilePath,\n+            config\n+          )\n         })\n \n       // Turbopack already handles conflicting app and page routes."
        },
        {
            "sha": "d5bfae6d13e22d6788e996be0f8085446dc53e06",
            "filename": "packages/next/src/build/webpack-config.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/1faf0323e4d0de3650b104ec03c1f85b126bde4b/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack-config.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1faf0323e4d0de3650b104ec03c1f85b126bde4b/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack-config.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack-config.ts?ref=1faf0323e4d0de3650b104ec03c1f85b126bde4b",
            "patch": "@@ -389,7 +389,6 @@ export default async function getBaseWebpackConfig(\n \n   const hasAppDir = !!appDir\n   const disableOptimizedLoading = true\n-  const enableTypedRoutes = !!config.experimental.typedRoutes && hasAppDir\n   const bundledReactChannel = needsExperimentalReact(config)\n     ? '-experimental'\n     : ''\n@@ -2152,7 +2151,6 @@ export default async function getBaseWebpackConfig(\n           dev,\n           isEdgeServer,\n           pageExtensions: config.pageExtensions,\n-          typedRoutes: enableTypedRoutes,\n           cacheLifeConfig: config.experimental.cacheLife,\n           originalRewrites,\n           originalRedirects,"
        },
        {
            "sha": "3262aa3188279192878d6a37e7b82a33dadccf92",
            "filename": "packages/next/src/build/webpack/plugins/next-types-plugin/index.test.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 3,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/1faf0323e4d0de3650b104ec03c1f85b126bde4b/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack%2Fplugins%2Fnext-types-plugin%2Findex.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1faf0323e4d0de3650b104ec03c1f85b126bde4b/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack%2Fplugins%2Fnext-types-plugin%2Findex.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack%2Fplugins%2Fnext-types-plugin%2Findex.test.ts?ref=1faf0323e4d0de3650b104ec03c1f85b126bde4b",
            "patch": "@@ -11,7 +11,6 @@ describe('next-types-plugin', () => {\n       dev: false,\n       isEdgeServer: false,\n       pageExtensions: ['tsx', 'ts', 'jsx', 'js'],\n-      typedRoutes: false,\n       cacheLifeConfig: undefined,\n       originalRewrites: undefined,\n       originalRedirects: undefined,\n@@ -40,7 +39,6 @@ describe('next-types-plugin', () => {\n       dev: false,\n       isEdgeServer: false,\n       pageExtensions: ['tsx', 'ts', 'jsx', 'js'],\n-      typedRoutes: false,\n       cacheLifeConfig: undefined,\n       originalRewrites: undefined,\n       originalRedirects: undefined,\n@@ -61,7 +59,6 @@ describe('next-types-plugin', () => {\n       dev: false,\n       isEdgeServer: false,\n       pageExtensions: ['tsx', 'ts', 'jsx', 'js'],\n-      typedRoutes: false,\n       cacheLifeConfig: undefined,\n       originalRewrites: undefined,\n       originalRedirects: undefined,"
        },
        {
            "sha": "e6e9079359862a28450a5db2c60f396b16843fca",
            "filename": "packages/next/src/build/webpack/plugins/next-types-plugin/index.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 292,
            "changes": 292,
            "blob_url": "https://github.com/vercel/next.js/blob/1faf0323e4d0de3650b104ec03c1f85b126bde4b/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack%2Fplugins%2Fnext-types-plugin%2Findex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1faf0323e4d0de3650b104ec03c1f85b126bde4b/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack%2Fplugins%2Fnext-types-plugin%2Findex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack%2Fplugins%2Fnext-types-plugin%2Findex.ts?ref=1faf0323e4d0de3650b104ec03c1f85b126bde4b",
            "patch": "@@ -1,9 +1,7 @@\n import type { Rewrite, Redirect } from '../../../../lib/load-custom-routes'\n-import type { Token } from 'next/dist/compiled/path-to-regexp'\n \n import fs from 'fs/promises'\n import { webpack, sources } from 'next/dist/compiled/webpack/webpack'\n-import { parse } from 'next/dist/compiled/path-to-regexp'\n import path from 'path'\n \n import { WEBPACK_LAYERS } from '../../../../lib/constants'\n@@ -15,7 +13,6 @@ import { isDynamicRoute } from '../../../../shared/lib/router/utils'\n import { normalizeAppPath } from '../../../../shared/lib/router/utils/app-paths'\n import { getPageFromPath } from '../../../entries'\n import type { PageExtensions } from '../../../page-extensions-type'\n-import { devPageFiles } from './shared'\n import { getProxiedPluginState } from '../../../build-context'\n import type { CacheLife } from '../../../../server/use-cache/cache-life'\n \n@@ -34,7 +31,6 @@ interface Options {\n   dev: boolean\n   isEdgeServer: boolean\n   pageExtensions: PageExtensions\n-  typedRoutes: boolean\n   cacheLifeConfig: undefined | { [profile: string]: CacheLife }\n   originalRewrites: Rewrites | undefined\n   originalRedirects: Redirect[] | undefined\n@@ -285,266 +281,6 @@ function formatRouteToRouteType(route: string) {\n   }\n }\n \n-// Whether redirects and rewrites have been converted into routeTypes or not.\n-let redirectsRewritesTypesProcessed = false\n-\n-// Convert redirects and rewrites into routeTypes.\n-function addRedirectsRewritesRouteTypes(\n-  rewrites: Rewrites | undefined,\n-  redirects: Redirect[] | undefined\n-) {\n-  function addExtraRoute(source: string) {\n-    let tokens: Token[] | undefined\n-    try {\n-      tokens = parse(source)\n-    } catch {\n-      // Ignore invalid routes - they will be handled by other checks.\n-    }\n-\n-    if (Array.isArray(tokens)) {\n-      const possibleNormalizedRoutes = ['']\n-      let slugCnt = 1\n-\n-      function append(suffix: string) {\n-        for (let i = 0; i < possibleNormalizedRoutes.length; i++) {\n-          possibleNormalizedRoutes[i] += suffix\n-        }\n-      }\n-\n-      function fork(suffix: string) {\n-        const currentLength = possibleNormalizedRoutes.length\n-        for (let i = 0; i < currentLength; i++) {\n-          possibleNormalizedRoutes.push(possibleNormalizedRoutes[i] + suffix)\n-        }\n-      }\n-\n-      for (const token of tokens) {\n-        if (typeof token === 'object') {\n-          // Make sure the slug is always named.\n-          const slug =\n-            token.name || (slugCnt++ === 1 ? 'slug' : `slug${slugCnt}`)\n-\n-          if (token.modifier === '*') {\n-            append(`${token.prefix}[[...${slug}]]`)\n-          } else if (token.modifier === '+') {\n-            append(`${token.prefix}[...${slug}]`)\n-          } else if (token.modifier === '') {\n-            if (token.pattern === '[^\\\\/#\\\\?]+?') {\n-              // A safe slug\n-              append(`${token.prefix}[${slug}]`)\n-            } else if (token.pattern === '.*') {\n-              // An optional catch-all slug\n-              append(`${token.prefix}[[...${slug}]]`)\n-            } else if (token.pattern === '.+') {\n-              // A catch-all slug\n-              append(`${token.prefix}[...${slug}]`)\n-            } else {\n-              // Other regex patterns are not supported. Skip this route.\n-              return\n-            }\n-          } else if (token.modifier === '?') {\n-            if (/^[a-zA-Z0-9_/]*$/.test(token.pattern)) {\n-              // An optional slug with plain text only, fork the route.\n-              append(token.prefix)\n-              fork(token.pattern)\n-            } else {\n-              // Optional modifier `?` and regex patterns are not supported.\n-              return\n-            }\n-          }\n-        } else if (typeof token === 'string') {\n-          append(token)\n-        }\n-      }\n-\n-      for (const normalizedRoute of possibleNormalizedRoutes) {\n-        const { isDynamic, routeType } = formatRouteToRouteType(normalizedRoute)\n-        pluginState.routeTypes.extra[isDynamic ? 'dynamic' : 'static'].push(\n-          routeType\n-        )\n-      }\n-    }\n-  }\n-\n-  if (rewrites) {\n-    for (const rewrite of rewrites.beforeFiles) {\n-      addExtraRoute(rewrite.source)\n-    }\n-    for (const rewrite of rewrites.afterFiles) {\n-      addExtraRoute(rewrite.source)\n-    }\n-    for (const rewrite of rewrites.fallback) {\n-      addExtraRoute(rewrite.source)\n-    }\n-  }\n-\n-  if (redirects) {\n-    for (const redirect of redirects) {\n-      // Skip internal redirects\n-      // https://github.com/vercel/next.js/blob/8ff3d7ff57836c24088474175d595b4d50b3f857/packages/next/src/lib/load-custom-routes.ts#L704-L710\n-      if (!('internal' in redirect)) {\n-        addExtraRoute(redirect.source)\n-      }\n-    }\n-  }\n-}\n-\n-function serializeRouteTypes(routeTypes: string[]) {\n-  // route collection is not deterministic, this makes the output of the file deterministic\n-  return routeTypes\n-    .sort()\n-    .map((route) => `\\n    | \\`${route}\\``)\n-    .join('')\n-}\n-\n-function createRouteDefinitions() {\n-  let staticRouteTypes = []\n-  let dynamicRouteTypes = []\n-\n-  for (const type of ['edge', 'node', 'extra'] as const) {\n-    staticRouteTypes.push(...pluginState.routeTypes[type].static)\n-    dynamicRouteTypes.push(...pluginState.routeTypes[type].dynamic)\n-  }\n-\n-  const serializedStaticRouteTypes = serializeRouteTypes(staticRouteTypes)\n-  const serializedDynamicRouteTypes = serializeRouteTypes(dynamicRouteTypes)\n-\n-  // If both StaticRoutes and DynamicRoutes are empty, fallback to type 'string & {}'.\n-  const routeTypesFallback =\n-    !serializedStaticRouteTypes && !serializedDynamicRouteTypes\n-      ? 'string & {}'\n-      : ''\n-\n-  return `// Type definitions for Next.js routes\n-\n-/**\n- * Internal types used by the Next.js router and Link component.\n- * These types are not meant to be used directly.\n- * @internal\n- */\n-declare namespace __next_route_internal_types__ {\n-  type SearchOrHash = \\`?\\${string}\\` | \\`#\\${string}\\`\n-  type WithProtocol = \\`\\${string}:\\${string}\\`\n-\n-  type Suffix = '' | SearchOrHash\n-\n-  type SafeSlug<S extends string> = S extends \\`\\${string}/\\${string}\\`\n-    ? never\n-    : S extends \\`\\${string}\\${SearchOrHash}\\`\n-    ? never\n-    : S extends ''\n-    ? never\n-    : S\n-\n-  type CatchAllSlug<S extends string> = S extends \\`\\${string}\\${SearchOrHash}\\`\n-    ? never\n-    : S extends ''\n-    ? never\n-    : S\n-\n-  type OptionalCatchAllSlug<S extends string> =\n-    S extends \\`\\${string}\\${SearchOrHash}\\` ? never : S\n-\n-  type StaticRoutes = ${serializedStaticRouteTypes || 'never'}\n-  type DynamicRoutes<T extends string = string> = ${\n-    serializedDynamicRouteTypes || 'never'\n-  }\n-\n-  type RouteImpl<T> = ${\n-    routeTypesFallback ||\n-    `\n-    ${\n-      // This keeps autocompletion working for static routes.\n-      '| StaticRoutes'\n-    }\n-    | SearchOrHash\n-    | WithProtocol\n-    | \\`\\${StaticRoutes}\\${SearchOrHash}\\`\n-    | (T extends \\`\\${DynamicRoutes<infer _>}\\${Suffix}\\` ? T : never)\n-    `\n-  }\n-}\n-\n-declare module 'next' {\n-  export { default } from 'next/types.js'\n-  export * from 'next/types.js'\n-\n-  export type Route<T extends string = string> =\n-    __next_route_internal_types__.RouteImpl<T>\n-}\n-\n-declare module 'next/link' {\n-  import type { LinkProps as OriginalLinkProps } from 'next/dist/client/link.js'\n-  import type { AnchorHTMLAttributes, DetailedHTMLProps } from 'react'\n-  import type { UrlObject } from 'url'\n-\n-  type LinkRestProps = Omit<\n-    Omit<\n-      DetailedHTMLProps<\n-        AnchorHTMLAttributes<HTMLAnchorElement>,\n-        HTMLAnchorElement\n-      >,\n-      keyof OriginalLinkProps\n-    > &\n-      OriginalLinkProps,\n-    'href'\n-  >\n-\n-  export type LinkProps<RouteInferType> = LinkRestProps & {\n-    /**\n-     * The path or URL to navigate to. This is the only required prop. It can also be an object.\n-     * @see https://nextjs.org/docs/api-reference/next/link\n-     */\n-    href: __next_route_internal_types__.RouteImpl<RouteInferType> | UrlObject\n-  }\n-\n-  export default function Link<RouteType>(props: LinkProps<RouteType>): JSX.Element\n-}\n-\n-declare module 'next/navigation' {\n-  export * from 'next/dist/client/components/navigation.js'\n-\n-  import type { NavigateOptions, AppRouterInstance as OriginalAppRouterInstance } from 'next/dist/shared/lib/app-router-context.shared-runtime.js'\n-  interface AppRouterInstance extends OriginalAppRouterInstance {\n-    /**\n-     * Navigate to the provided href.\n-     * Pushes a new history entry.\n-     */\n-    push<RouteType>(href: __next_route_internal_types__.RouteImpl<RouteType>, options?: NavigateOptions): void\n-    /**\n-     * Navigate to the provided href.\n-     * Replaces the current history entry.\n-     */\n-    replace<RouteType>(href: __next_route_internal_types__.RouteImpl<RouteType>, options?: NavigateOptions): void\n-    /**\n-     * Prefetch the provided href.\n-     */\n-    prefetch<RouteType>(href: __next_route_internal_types__.RouteImpl<RouteType>): void\n-  }\n-\n-  export function useRouter(): AppRouterInstance;\n-}\n-\n-declare module 'next/form' {\n-  import type { FormProps as OriginalFormProps } from 'next/dist/client/form.js'\n-\n-  type FormRestProps = Omit<OriginalFormProps, 'action'>\n-\n-  export type FormProps<RouteInferType> = {\n-    /**\n-     * \\`action\\` can be either a \\`string\\` or a function.\n-     * - If \\`action\\` is a string, it will be interpreted as a path or URL to navigate to when the form is submitted.\n-     *   The path will be prefetched when the form becomes visible.\n-     * - If \\`action\\` is a function, it will be called when the form is submitted. See the [React docs](https://react.dev/reference/react-dom/components/form#props) for more.\n-     */\n-    action: __next_route_internal_types__.RouteImpl<RouteInferType> | ((formData: FormData) => void)\n-  } & FormRestProps\n-\n-  export default function Form<RouteType>(props: FormProps<RouteType>): JSX.Element\n-}\n-`\n-}\n-\n function formatTimespan(seconds: number): string {\n   if (seconds > 0) {\n     if (seconds === 18748800) {\n@@ -826,7 +562,6 @@ export class NextTypesPlugin {\n   isEdgeServer: boolean\n   pageExtensions: string[]\n   pagesDir: string\n-  typedRoutes: boolean\n   cacheLifeConfig: undefined | { [profile: string]: CacheLife }\n   distDirAbsolutePath: string\n \n@@ -838,16 +573,8 @@ export class NextTypesPlugin {\n     this.isEdgeServer = options.isEdgeServer\n     this.pageExtensions = options.pageExtensions\n     this.pagesDir = path.join(this.appDir, '..', 'pages')\n-    this.typedRoutes = options.typedRoutes\n     this.cacheLifeConfig = options.cacheLifeConfig\n     this.distDirAbsolutePath = path.join(this.dir, this.distDir)\n-    if (this.typedRoutes && !redirectsRewritesTypesProcessed) {\n-      redirectsRewritesTypesProcessed = true\n-      addRedirectsRewritesRouteTypes(\n-        options.originalRewrites,\n-        options.originalRedirects\n-      )\n-    }\n   }\n \n   getRelativePathFromAppTypesDir(moduleRelativePathToAppDir: string) {\n@@ -869,8 +596,6 @@ export class NextTypesPlugin {\n   }\n \n   collectPage(filePath: string) {\n-    if (!this.typedRoutes) return\n-\n     const isApp = filePath.startsWith(this.appDir + path.sep)\n     const isPages = !isApp && filePath.startsWith(this.pagesDir + path.sep)\n \n@@ -1109,23 +834,6 @@ export class NextTypesPlugin {\n             ) as unknown as webpack.sources.RawSource\n           )\n \n-          if (this.typedRoutes) {\n-            if (this.dev && !this.isEdgeServer) {\n-              devPageFiles.forEach((file) => {\n-                this.collectPage(file)\n-              })\n-            }\n-\n-            const linkAssetPath = path.join(assetDirRelative, 'types/link.d.ts')\n-\n-            compilation.emitAsset(\n-              linkAssetPath,\n-              new sources.RawSource(\n-                createRouteDefinitions()\n-              ) as unknown as webpack.sources.RawSource\n-            )\n-          }\n-\n           if (this.cacheLifeConfig) {\n             const cacheLifeAssetPath = path.join(\n               assetDirRelative,"
        },
        {
            "sha": "7e3bff47421a505abb5ef5d4d2904d1a07bed5e6",
            "filename": "packages/next/src/cli/next-typegen.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/1faf0323e4d0de3650b104ec03c1f85b126bde4b/packages%2Fnext%2Fsrc%2Fcli%2Fnext-typegen.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1faf0323e4d0de3650b104ec03c1f85b126bde4b/packages%2Fnext%2Fsrc%2Fcli%2Fnext-typegen.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcli%2Fnext-typegen.ts?ref=1faf0323e4d0de3650b104ec03c1f85b126bde4b",
            "patch": "@@ -129,7 +129,11 @@ const nextTypegen = async (\n     rewrites: nextConfig.rewrites,\n   })\n \n-  await writeRouteTypesManifest(routeTypesManifest, routeTypesFilePath)\n+  await writeRouteTypesManifest(\n+    routeTypesManifest,\n+    routeTypesFilePath,\n+    nextConfig\n+  )\n \n   console.log('âœ“ Route types generated successfully')\n }"
        },
        {
            "sha": "054350bafad95a6151934413756dd9daca77138d",
            "filename": "packages/next/src/lib/turbopack-warning.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/1faf0323e4d0de3650b104ec03c1f85b126bde4b/packages%2Fnext%2Fsrc%2Flib%2Fturbopack-warning.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1faf0323e4d0de3650b104ec03c1f85b126bde4b/packages%2Fnext%2Fsrc%2Flib%2Fturbopack-warning.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Flib%2Fturbopack-warning.ts?ref=1faf0323e4d0de3650b104ec03c1f85b126bde4b",
            "patch": "@@ -35,7 +35,6 @@ const unsupportedTurbopackNextConfigOptions = [\n \n   'experimental.sri.algorithm',\n   'experimental.swcTraceProfiling',\n-  'experimental.typedRoutes',\n \n   // Left to be implemented (Might not be needed for Turbopack)\n   'experimental.craCompat',"
        },
        {
            "sha": "97838a7533a32ea4b4ad51df4420cf46f118b9bb",
            "filename": "packages/next/src/server/lib/router-utils/route-types-utils.ts",
            "status": "modified",
            "additions": 74,
            "deletions": 38,
            "changes": 112,
            "blob_url": "https://github.com/vercel/next.js/blob/1faf0323e4d0de3650b104ec03c1f85b126bde4b/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Froute-types-utils.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1faf0323e4d0de3650b104ec03c1f85b126bde4b/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Froute-types-utils.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Froute-types-utils.ts?ref=1faf0323e4d0de3650b104ec03c1f85b126bde4b",
            "patch": "@@ -6,7 +6,7 @@ import {\n import type { NextConfigComplete } from '../../config-shared'\n import { isParallelRouteSegment } from '../../../shared/lib/segment'\n import fs from 'fs'\n-import { generateRouteTypesFile } from './typegen'\n+import { generateRouteTypesFile, generateLinkTypesFile } from './typegen'\n import { tryToParsePath } from '../../../lib/try-to-parse-path'\n \n interface RouteInfo {\n@@ -27,46 +27,71 @@ export interface RouteTypesManifest {\n // Convert a custom-route source string (`/blog/:slug`, `/docs/:path*`, ...)\n // into the bracket-syntax used by other Next.js route helpers so that we can\n // reuse `getRouteRegex()` to extract groups.\n-export function convertCustomRouteSource(source: string): string {\n+export function convertCustomRouteSource(source: string): string[] {\n   const parseResult = tryToParsePath(source)\n \n   if (parseResult.error || !parseResult.tokens) {\n     // Fallback to original source if parsing fails\n-    return source.startsWith('/') ? source : '/' + source\n+    return source.startsWith('/') ? [source] : ['/' + source]\n   }\n \n-  let result = ''\n+  const possibleNormalizedRoutes = ['']\n+  let slugCnt = 1\n+\n+  function append(suffix: string) {\n+    for (let i = 0; i < possibleNormalizedRoutes.length; i++) {\n+      possibleNormalizedRoutes[i] += suffix\n+    }\n+  }\n+\n+  function fork(suffix: string) {\n+    const currentLength = possibleNormalizedRoutes.length\n+    for (let i = 0; i < currentLength; i++) {\n+      possibleNormalizedRoutes.push(possibleNormalizedRoutes[i] + suffix)\n+    }\n+  }\n \n   for (const token of parseResult.tokens) {\n-    if (typeof token === 'string') {\n-      // Literal path segment\n-      result += token\n-    } else {\n-      // Parameter token\n-      const { name, modifier, prefix } = token\n-\n-      // Add the prefix (usually '/')\n-      result += prefix\n-\n-      if (modifier === '*') {\n-        // Catch-all zero or more: :param* -> [[...param]]\n-        result += `[[...${name}]]`\n-      } else if (modifier === '+') {\n-        // Catch-all one or more: :param+ -> [...param]\n-        result += `[...${name}]`\n-      } else if (modifier === '?') {\n-        // Optional catch-all: :param? -> [[...param]]\n-        result += `[[...${name}]]`\n-      } else {\n-        // Standard dynamic segment: :param -> [param]\n-        result += `[${name}]`\n+    if (typeof token === 'object') {\n+      // Make sure the slug is always named.\n+      const slug = token.name || (slugCnt++ === 1 ? 'slug' : `slug${slugCnt}`)\n+      if (token.modifier === '*') {\n+        append(`${token.prefix}[[...${slug}]]`)\n+      } else if (token.modifier === '+') {\n+        append(`${token.prefix}[...${slug}]`)\n+      } else if (token.modifier === '') {\n+        if (token.pattern === '[^\\\\/#\\\\?]+?') {\n+          // A safe slug\n+          append(`${token.prefix}[${slug}]`)\n+        } else if (token.pattern === '.*') {\n+          // An optional catch-all slug\n+          append(`${token.prefix}[[...${slug}]]`)\n+        } else if (token.pattern === '.+') {\n+          // A catch-all slug\n+          append(`${token.prefix}[...${slug}]`)\n+        } else {\n+          // Other regex patterns are not supported. Skip this route.\n+          return []\n+        }\n+      } else if (token.modifier === '?') {\n+        if (/^[a-zA-Z0-9_/]*$/.test(token.pattern)) {\n+          // An optional slug with plain text only, fork the route.\n+          append(token.prefix)\n+          fork(token.pattern)\n+        } else {\n+          // Optional modifier `?` and regex patterns are not supported.\n+          return []\n+        }\n       }\n+    } else if (typeof token === 'string') {\n+      append(token)\n     }\n   }\n \n   // Ensure leading slash\n-  if (!result.startsWith('/')) result = '/' + result\n-  return result\n+  return possibleNormalizedRoutes.map((route) =>\n+    route.startsWith('/') ? route : '/' + route\n+  )\n }\n \n /**\n@@ -165,11 +190,12 @@ export async function createRouteTypesManifest({\n     const rd = await redirects()\n \n     for (const item of rd) {\n-      const source = convertCustomRouteSource(item.source)\n-\n-      manifest.redirectRoutes[source] = {\n-        path: source,\n-        groups: extractRouteParams(source),\n+      const possibleRoutes = convertCustomRouteSource(item.source)\n+      for (const route of possibleRoutes) {\n+        manifest.redirectRoutes[route] = {\n+          path: route,\n+          groups: extractRouteParams(route),\n+        }\n       }\n     }\n   }\n@@ -187,10 +213,12 @@ export async function createRouteTypesManifest({\n         ]\n \n     for (const item of allSources) {\n-      const source = convertCustomRouteSource(item.source)\n-      manifest.rewriteRoutes[source] = {\n-        path: source,\n-        groups: extractRouteParams(source),\n+      const possibleRoutes = convertCustomRouteSource(item.source)\n+      for (const route of possibleRoutes) {\n+        manifest.rewriteRoutes[route] = {\n+          path: route,\n+          groups: extractRouteParams(route),\n+        }\n       }\n     }\n   }\n@@ -200,13 +228,21 @@ export async function createRouteTypesManifest({\n \n export async function writeRouteTypesManifest(\n   manifest: RouteTypesManifest,\n-  filePath: string\n+  filePath: string,\n+  config: NextConfigComplete\n ) {\n   const dirname = path.dirname(filePath)\n \n   if (!fs.existsSync(dirname)) {\n     await fs.promises.mkdir(dirname, { recursive: true })\n   }\n \n+  // Write the main routes.d.ts file\n   await fs.promises.writeFile(filePath, generateRouteTypesFile(manifest))\n+\n+  // Write the link.d.ts file if typedRoutes is enabled\n+  if (config.experimental?.typedRoutes === true) {\n+    const linkTypesPath = path.join(dirname, 'link.d.ts')\n+    await fs.promises.writeFile(linkTypesPath, generateLinkTypesFile(manifest))\n+  }\n }"
        },
        {
            "sha": "df62fd8a704518fb9a979e1f06180d3c8d8c9a55",
            "filename": "packages/next/src/server/lib/router-utils/setup-dev-bundler.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 2,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/1faf0323e4d0de3650b104ec03c1f85b126bde4b/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Fsetup-dev-bundler.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1faf0323e4d0de3650b104ec03c1f85b126bde4b/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Fsetup-dev-bundler.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Fsetup-dev-bundler.ts?ref=1faf0323e4d0de3650b104ec03c1f85b126bde4b",
            "patch": "@@ -222,7 +222,8 @@ async function startWatcher(\n       redirectRoutes: {},\n       rewriteRoutes: {},\n     },\n-    path.join(distTypesDir, 'routes.d.ts')\n+    path.join(distTypesDir, 'routes.d.ts'),\n+    opts.nextConfig\n   )\n \n   const usingTypeScript = await verifyTypeScript(opts)\n@@ -1023,7 +1024,11 @@ async function startWatcher(\n             rewrites: opts.nextConfig.rewrites,\n           })\n \n-          await writeRouteTypesManifest(routeTypesManifest, routeTypesFilePath)\n+          await writeRouteTypesManifest(\n+            routeTypesManifest,\n+            routeTypesFilePath,\n+            opts.nextConfig\n+          )\n         }\n \n         if (!resolved) {"
        },
        {
            "sha": "052c167ef4320f226d1ddf5c883f5fd50899cdf7",
            "filename": "packages/next/src/server/lib/router-utils/typegen.ts",
            "status": "modified",
            "additions": 204,
            "deletions": 0,
            "changes": 204,
            "blob_url": "https://github.com/vercel/next.js/blob/1faf0323e4d0de3650b104ec03c1f85b126bde4b/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Ftypegen.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1faf0323e4d0de3650b104ec03c1f85b126bde4b/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Ftypegen.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Ftypegen.ts?ref=1faf0323e4d0de3650b104ec03c1f85b126bde4b",
            "patch": "@@ -136,6 +136,210 @@ function generateLayoutSlotMap(routesManifest: RouteTypesManifest): string {\n   return slotMap\n }\n \n+// Helper function to format routes to route types (matches the plugin logic exactly)\n+function formatRouteToRouteType(route: string) {\n+  const isDynamic = isDynamicRoute(route)\n+  if (isDynamic) {\n+    route = route\n+      .split('/')\n+      .map((part) => {\n+        if (part.startsWith('[') && part.endsWith(']')) {\n+          if (part.startsWith('[...')) {\n+            // /[...slug]\n+            return `\\${CatchAllSlug<T>}`\n+          } else if (part.startsWith('[[...') && part.endsWith(']]')) {\n+            // /[[...slug]]\n+            return `\\${OptionalCatchAllSlug<T>}`\n+          }\n+          // /[slug]\n+          return `\\${SafeSlug<T>}`\n+        }\n+        return part\n+      })\n+      .join('/')\n+  }\n+\n+  return {\n+    isDynamic,\n+    routeType: route,\n+  }\n+}\n+\n+// Helper function to serialize route types (matches the plugin logic exactly)\n+function serializeRouteTypes(routeTypes: string[]) {\n+  // route collection is not deterministic, this makes the output of the file deterministic\n+  return routeTypes\n+    .sort()\n+    .map((route) => `\\n    | \\`${route}\\``)\n+    .join('')\n+}\n+\n+export function generateLinkTypesFile(\n+  routesManifest: RouteTypesManifest\n+): string {\n+  // Generate serialized static and dynamic routes for the internal namespace\n+  const allRoutes = {\n+    ...routesManifest.appRoutes,\n+    ...routesManifest.pageRoutes,\n+    ...routesManifest.redirectRoutes,\n+    ...routesManifest.rewriteRoutes,\n+  }\n+\n+  const staticRouteTypes: string[] = []\n+  const dynamicRouteTypes: string[] = []\n+\n+  // Process each route using the same logic as the plugin\n+  for (const route of Object.keys(allRoutes)) {\n+    const { isDynamic, routeType } = formatRouteToRouteType(route)\n+    if (isDynamic) {\n+      dynamicRouteTypes.push(routeType)\n+    } else {\n+      staticRouteTypes.push(routeType)\n+    }\n+  }\n+\n+  const serializedStaticRouteTypes = serializeRouteTypes(staticRouteTypes)\n+  const serializedDynamicRouteTypes = serializeRouteTypes(dynamicRouteTypes)\n+\n+  // If both StaticRoutes and DynamicRoutes are empty, fallback to type 'string & {}'.\n+  const routeTypesFallback =\n+    !serializedStaticRouteTypes && !serializedDynamicRouteTypes\n+      ? 'string & {}'\n+      : ''\n+\n+  return `// This file is generated automatically by Next.js\n+// Do not edit this file manually\n+\n+// Type definitions for Next.js routes\n+\n+/**\n+ * Internal types used by the Next.js router and Link component.\n+ * These types are not meant to be used directly.\n+ * @internal\n+ */\n+declare namespace __next_route_internal_types__ {\n+  type SearchOrHash = \\`?\\${string}\\` | \\`#\\${string}\\`\n+  type WithProtocol = \\`\\${string}:\\${string}\\`\n+\n+  type Suffix = '' | SearchOrHash\n+\n+  type SafeSlug<S extends string> = S extends \\`\\${string}/\\${string}\\`\n+    ? never\n+    : S extends \\`\\${string}\\${SearchOrHash}\\`\n+    ? never\n+    : S extends ''\n+    ? never\n+    : S\n+\n+  type CatchAllSlug<S extends string> = S extends \\`\\${string}\\${SearchOrHash}\\`\n+    ? never\n+    : S extends ''\n+    ? never\n+    : S\n+\n+  type OptionalCatchAllSlug<S extends string> =\n+    S extends \\`\\${string}\\${SearchOrHash}\\` ? never : S\n+\n+  type StaticRoutes = ${serializedStaticRouteTypes || 'never'}\n+  type DynamicRoutes<T extends string = string> = ${\n+    serializedDynamicRouteTypes || 'never'\n+  }\n+\n+  type RouteImpl<T> = ${\n+    routeTypesFallback ||\n+    `\n+    ${\n+      // This keeps autocompletion working for static routes.\n+      '| StaticRoutes'\n+    }\n+    | SearchOrHash\n+    | WithProtocol\n+    | \\`\\${StaticRoutes}\\${SearchOrHash}\\`\n+    | (T extends \\`\\${DynamicRoutes<infer _>}\\${Suffix}\\` ? T : never)\n+    `\n+  }\n+}\n+\n+declare module 'next' {\n+  export { default } from 'next/types.js'\n+  export * from 'next/types.js'\n+\n+  export type Route<T extends string = string> =\n+    __next_route_internal_types__.RouteImpl<T>\n+}\n+\n+declare module 'next/link' {\n+  import type { LinkProps as OriginalLinkProps } from 'next/dist/client/link.js'\n+  import type { AnchorHTMLAttributes, DetailedHTMLProps } from 'react'\n+  import type { UrlObject } from 'url'\n+\n+  type LinkRestProps = Omit<\n+    Omit<\n+      DetailedHTMLProps<\n+        AnchorHTMLAttributes<HTMLAnchorElement>,\n+        HTMLAnchorElement\n+      >,\n+      keyof OriginalLinkProps\n+    > &\n+      OriginalLinkProps,\n+    'href'\n+  >\n+\n+  export type LinkProps<RouteInferType> = LinkRestProps & {\n+    /**\n+     * The path or URL to navigate to. This is the only required prop. It can also be an object.\n+     * @see https://nextjs.org/docs/api-reference/next/link\n+     */\n+    href: __next_route_internal_types__.RouteImpl<RouteInferType> | UrlObject\n+  }\n+\n+  export default function Link<RouteType>(props: LinkProps<RouteType>): JSX.Element\n+}\n+\n+declare module 'next/navigation' {\n+  export * from 'next/dist/client/components/navigation.js'\n+\n+  import type { NavigateOptions, AppRouterInstance as OriginalAppRouterInstance } from 'next/dist/shared/lib/app-router-context.shared-runtime.js'\n+  interface AppRouterInstance extends OriginalAppRouterInstance {\n+    /**\n+     * Navigate to the provided href.\n+     * Pushes a new history entry.\n+     */\n+    push<RouteType>(href: __next_route_internal_types__.RouteImpl<RouteType>, options?: NavigateOptions): void\n+    /**\n+     * Navigate to the provided href.\n+     * Replaces the current history entry.\n+     */\n+    replace<RouteType>(href: __next_route_internal_types__.RouteImpl<RouteType>, options?: NavigateOptions): void\n+    /**\n+     * Prefetch the provided href.\n+     */\n+    prefetch<RouteType>(href: __next_route_internal_types__.RouteImpl<RouteType>): void\n+  }\n+\n+  export function useRouter(): AppRouterInstance;\n+}\n+\n+declare module 'next/form' {\n+  import type { FormProps as OriginalFormProps } from 'next/dist/client/form.js'\n+\n+  type FormRestProps = Omit<OriginalFormProps, 'action'>\n+\n+  export type FormProps<RouteInferType> = {\n+    /**\n+     * \\`action\\` can be either a \\`string\\` or a function.\n+     * - If \\`action\\` is a string, it will be interpreted as a path or URL to navigate to when the form is submitted.\n+     *   The path will be prefetched when the form becomes visible.\n+     * - If \\`action\\` is a function, it will be called when the form is submitted. See the [React docs](https://react.dev/reference/react-dom/components/form#props) for more.\n+     */\n+    action: __next_route_internal_types__.RouteImpl<RouteInferType> | ((formData: FormData) => void)\n+  } & FormRestProps\n+\n+  export default function Form<RouteType>(props: FormProps<RouteType>): JSX.Element\n+}\n+`\n+}\n+\n export function generateRouteTypesFile(\n   routesManifest: RouteTypesManifest\n ): string {"
        },
        {
            "sha": "f7598c6d9329c556b8baed1d558044e1639a6465",
            "filename": "test/e2e/app-dir/typed-routes/app/page.tsx",
            "status": "modified",
            "additions": 17,
            "deletions": 1,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/1faf0323e4d0de3650b104ec03c1f85b126bde4b/test%2Fe2e%2Fapp-dir%2Ftyped-routes%2Fapp%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1faf0323e4d0de3650b104ec03c1f85b126bde4b/test%2Fe2e%2Fapp-dir%2Ftyped-routes%2Fapp%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Ftyped-routes%2Fapp%2Fpage.tsx?ref=1faf0323e4d0de3650b104ec03c1f85b126bde4b",
            "patch": "@@ -1,3 +1,19 @@\n+import Link from 'next/link'\n+\n export default function Page() {\n-  return <p>hello world</p>\n+  return (\n+    <div>\n+      <p>hello world</p>\n+      <div>\n+        <Link href=\"/\">Simple Route</Link>\n+        <Link href=\"/dashboard\">Simple Route</Link>\n+        <Link href=\"/project/123\">Dynamic Route</Link>\n+        <Link href=\"/gallery/photo/some-slug\">Dynamic Route</Link>\n+        <Link href=\"/_shop/\">Optional Catchall Route</Link>\n+        <Link href=\"/docs/some/thing\">Catchall Route</Link>\n+        <Link href=\"/api-legacy/v1/testing\">Rewrite Route</Link>\n+        <Link href=\"/blog/category/testing\">Redirect Route</Link>\n+      </div>\n+    </div>\n+  )\n }"
        },
        {
            "sha": "92bd1f7b3e0fcc42c1d8b43c92ec84dcb3367714",
            "filename": "test/e2e/app-dir/typed-routes/next.config.js",
            "status": "modified",
            "additions": 3,
            "deletions": 5,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/1faf0323e4d0de3650b104ec03c1f85b126bde4b/test%2Fe2e%2Fapp-dir%2Ftyped-routes%2Fnext.config.js",
            "raw_url": "https://github.com/vercel/next.js/raw/1faf0323e4d0de3650b104ec03c1f85b126bde4b/test%2Fe2e%2Fapp-dir%2Ftyped-routes%2Fnext.config.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Ftyped-routes%2Fnext.config.js?ref=1faf0323e4d0de3650b104ec03c1f85b126bde4b",
            "patch": "@@ -2,6 +2,9 @@\n  * @type {import('next').NextConfig}\n  */\n const nextConfig = {\n+  experimental: {\n+    typedRoutes: true,\n+  },\n   async redirects() {\n     return [\n       {\n@@ -14,11 +17,6 @@ const nextConfig = {\n         destination: '/posts/:category/:slug*',\n         permanent: false,\n       },\n-      {\n-        source: '/optional/:param?',\n-        destination: '/fallback',\n-        permanent: false,\n-      },\n     ]\n   },\n   async rewrites() {"
        },
        {
            "sha": "c64e20b02941d4326dbba9227610877b1b8f39e5",
            "filename": "test/e2e/app-dir/typed-routes/typed-links.test.ts",
            "status": "added",
            "additions": 93,
            "deletions": 0,
            "changes": 93,
            "blob_url": "https://github.com/vercel/next.js/blob/1faf0323e4d0de3650b104ec03c1f85b126bde4b/test%2Fe2e%2Fapp-dir%2Ftyped-routes%2Ftyped-links.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1faf0323e4d0de3650b104ec03c1f85b126bde4b/test%2Fe2e%2Fapp-dir%2Ftyped-routes%2Ftyped-links.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Ftyped-routes%2Ftyped-links.test.ts?ref=1faf0323e4d0de3650b104ec03c1f85b126bde4b",
            "patch": "@@ -0,0 +1,93 @@\n+import { nextTestSetup } from 'e2e-utils'\n+\n+describe('typed-links', () => {\n+  const { next, isNextStart, skipped } = nextTestSetup({\n+    files: __dirname,\n+    skipDeployment: true,\n+  })\n+\n+  if (skipped) {\n+    return\n+  }\n+\n+  it('should generate types for next/link', async () => {\n+    const dts = await next.readFile('.next/types/link.d.ts')\n+    expect(dts).toContain(`declare module 'next/link'`)\n+  })\n+\n+  if (isNextStart) {\n+    it('should pass type checking with valid routes', async () => {\n+      await next.stop()\n+      await next.patchFile(\n+        'app/valid-links.tsx',\n+        `\n+import Link from 'next/link'\n+\n+export default function ValidLinks() {\n+  return (\n+    <div>\n+      <Link href=\"/\">Simple Route</Link>\n+      <Link href=\"/dashboard\">Simple Route</Link>\n+      <Link href=\"/project/123\">Dynamic Route</Link>\n+      <Link href=\"/gallery/photo/some-slug\">Dynamic Route</Link>\n+      <Link href=\"/_shop/\">Optional Catchall Route</Link>\n+      <Link href=\"/docs/some/thing\">Catchall Route</Link>\n+      <Link href=\"/api-legacy/v1/testing\">Rewrite Route</Link>\n+      <Link href=\"/blog/category/testing\">Redirect Route</Link>\n+    </div>\n+  )\n+}\n+`\n+      )\n+\n+      const { exitCode } = await next.build()\n+      expect(exitCode).toBe(0)\n+    })\n+\n+    it('should work with Route type casting', async () => {\n+      await next.stop()\n+      await next.patchFile(\n+        'app/route-casting.tsx',\n+        `\n+import type { Route } from 'next'\n+import Link from 'next/link'\n+\n+export default function RouteCasting() {\n+  const dynamicPath = '/dynamic-path'\n+  \n+  return (\n+    <Link href={dynamicPath as Route}>Casted Route</Link>\n+  )\n+}\n+`\n+      )\n+\n+      const { exitCode } = await next.build()\n+      expect(exitCode).toBe(0)\n+    })\n+\n+    it('should fail type checking with invalid routes', async () => {\n+      await next.stop()\n+      await next.patchFile(\n+        'app/invalid-links.tsx',\n+        `\n+import Link from 'next/link'\n+\n+export default function InvalidLinks() {\n+  return (\n+    <div>\n+      <Link href=\"/invalid-route\">Invalid</Link>\n+    </div>\n+  )\n+}\n+`\n+      )\n+\n+      const { exitCode, cliOutput } = await next.build()\n+      expect(exitCode).toBe(1)\n+      expect(cliOutput).toContain(\n+        `Type error: \"/invalid-route\" is not an existing route. If it is intentional, please type it explicitly with \\`as Route\\`.`\n+      )\n+    })\n+  }\n+})"
        },
        {
            "sha": "13609c3dba162602e03713f3b1aae3f8041b75f0",
            "filename": "test/e2e/app-dir/typed-routes/typed-routes.test.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 4,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/1faf0323e4d0de3650b104ec03c1f85b126bde4b/test%2Fe2e%2Fapp-dir%2Ftyped-routes%2Ftyped-routes.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1faf0323e4d0de3650b104ec03c1f85b126bde4b/test%2Fe2e%2Fapp-dir%2Ftyped-routes%2Ftyped-routes.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Ftyped-routes%2Ftyped-routes.test.ts?ref=1faf0323e4d0de3650b104ec03c1f85b126bde4b",
            "patch": "@@ -4,7 +4,7 @@ const expectedDts = `\n type AppRoutes = \"/\" | \"/_shop/[[...category]]\" | \"/dashboard\" | \"/dashboard/settings\" | \"/docs/[...slug]\" | \"/gallery/photo/[id]\" | \"/project/[slug]\"\n type PageRoutes = \"/about\" | \"/users/[id]\"\n type LayoutRoutes = \"/\" | \"/dashboard\"\n-type RedirectRoutes = \"/blog/[category]/[[...slug]]\" | \"/optional/[[...param]]\" | \"/project/[slug]\"\n+type RedirectRoutes = \"/blog/[category]/[[...slug]]\" | \"/project/[slug]\"\n type RewriteRoutes = \"/api-legacy/[version]/[[...endpoint]]\" | \"/docs-old/[...path]\"\n type Routes = AppRoutes | PageRoutes | LayoutRoutes | RedirectRoutes | RewriteRoutes\n `\n@@ -36,9 +36,6 @@ describe('typed-routes', () => {\n     // Test catch-all zero-or-more: :slug* -> [[...slug]]\n     expect(dts).toContain('\"/blog/[category]/[[...slug]]\"')\n     expect(dts).toContain('\"/api-legacy/[version]/[[...endpoint]]\"')\n-\n-    // Test optional parameter: :param? -> [[...param]]\n-    expect(dts).toContain('\"/optional/[[...param]]\"')\n   })\n \n   if (isNextDev) {"
        },
        {
            "sha": "111f6093c31459e59b187dfda349b63bdf3c87dc",
            "filename": "test/integration/app-types/app-types.test.js",
            "status": "modified",
            "additions": 111,
            "deletions": 120,
            "changes": 231,
            "blob_url": "https://github.com/vercel/next.js/blob/1faf0323e4d0de3650b104ec03c1f85b126bde4b/test%2Fintegration%2Fapp-types%2Fapp-types.test.js",
            "raw_url": "https://github.com/vercel/next.js/raw/1faf0323e4d0de3650b104ec03c1f85b126bde4b/test%2Fintegration%2Fapp-types%2Fapp-types.test.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fintegration%2Fapp-types%2Fapp-types.test.js?ref=1faf0323e4d0de3650b104ec03c1f85b126bde4b",
            "patch": "@@ -7,125 +7,116 @@ import { nextBuild } from 'next-test-utils'\n const appDir = __dirname\n \n // Turbopack doesn't support additional experimental features in the first version\n-;(process.env.IS_TURBOPACK_TEST ? describe.skip : describe)(\n-  'app type checking',\n-  () => {\n-    ;(process.env.TURBOPACK_DEV ? describe.skip : describe)(\n-      'production mode',\n-      () => {\n-        let stderr, errors\n-        beforeAll(async () => {\n-          stderr = (await nextBuild(appDir, [], { stderr: true })).stderr\n-\n-          errors = stderr.match(\n-            /===== TS errors =====(.+)===== TS errors =====/s\n-          )?.[1]\n-        })\n-\n-        it('should generate route types correctly and report link error', async () => {\n-          // Make sure the d.ts file is generated\n-          const dts = (\n-            await fs.readFile(path.join(appDir, '.next', 'types', 'link.d.ts'))\n-          ).toString()\n-          expect(dts.includes('`/dashboard/user/')).toBeTruthy()\n-          expect(dts.includes('`/dashboard/another')).toBeTruthy()\n-\n-          // Check type checking errors\n-          expect(errors).toContain(\n-            'Type error: \"/(newroot)/dashboard/another\" is not an existing route. If it is intentional, please type it explicitly with `as Route`.'\n-          )\n-\n-          // Make sure all errors were reported and other links passed type checking\n-          const errorLines = [\n-            ...errors.matchAll(\n-              /\\.\\/src\\/app\\/type-checks\\/link\\/page\\.tsx:(\\d+):/g\n-            ),\n-          ].map(([, line]) => +line)\n-\n-          const ST = 18\n-          const ED = 35\n-          expect(errorLines).toEqual(\n-            Array.from({ length: ED - ST + 1 }, (_, i) => i + ST)\n-          )\n-        })\n-\n-        it('should generate route types correctly and report router API errors', async () => {\n-          // Make sure all errors were reported and other links passed type checking\n-          const errorLines = [\n-            ...errors.matchAll(\n-              /\\.\\/src\\/app\\/type-checks\\/router\\/page\\.tsx:(\\d+):/g\n-            ),\n-          ].map(([, line]) => +line)\n-\n-          const ST = 11\n-          const ED = 13\n-          expect(errorLines).toEqual(\n-            Array.from({ length: ED - ST + 1 }, (_, i) => i + ST)\n-          )\n-        })\n-\n-        it('should generate route types correctly and report form errors', async () => {\n-          // Make sure all errors were reported and other Forms passed type checking\n-          const errorLines = [\n-            ...errors.matchAll(\n-              /\\.\\/src\\/app\\/type-checks\\/form\\/page\\.tsx:(\\d+):/g\n-            ),\n-          ].map(([, line]) => +line)\n-\n-          const ST = 8\n-          const ED = 10\n-          expect(errorLines).toEqual(\n-            Array.from({ length: ED - ST + 1 }, (_, i) => i + ST)\n-          )\n-        })\n-\n-        it('should type check invalid entry exports', () => {\n-          // Can't export arbitrary things.\n-          expect(errors).toContain(`\"foo\" is not a valid Page export field.`)\n-\n-          // Can't export invalid fields.\n-          expect(errors).toMatch(\n-            /Invalid configuration \"revalidate\":\\s+Expected \"false | number (>= 0)\", got \"-1\"/\n-          )\n-\n-          // Avoid invalid argument types for exported functions.\n-          expect(errors).toMatch(\n-            /Page \"src\\/app\\/type-checks\\/config\\/page\\.tsx\" has an invalid \"default\" export:\\s+Type \"{ foo: string; }\" is not valid/\n-          )\n-          expect(errors).toMatch(\n-            /Page \"src\\/app\\/type-checks\\/config\\/page\\.tsx\" has an invalid \"generateMetadata\" export:\\s+Type \"{ s: number; }\" is not valid/\n-          )\n-          expect(errors).toMatch(\n-            /Page \"src\\/app\\/type-checks\\/config\\/page\\.tsx\" has an invalid \"generateStaticParams\" export:\\s+Type \"string\" is not valid/\n-          )\n-\n-          // Avoid invalid return types for exported functions.\n-          expect(errors).toContain(\n-            `\"Promise<number>\" is not a valid generateStaticParams return type`\n-          )\n-\n-          // Can't export arbitrary things.\n-          expect(errors).toContain(`\"bar\" is not a valid Route export field.`)\n-\n-          // Can't export invalid fields.\n-          expect(errors).toMatch(\n-            /Invalid configuration \"revalidate\":\\s+Expected \"false | number (>= 0)\", got \"-1\"/\n-          )\n-\n-          // Avoid invalid argument types for exported functions.\n-          expect(errors).toMatch(\n-            /Route \"src\\/app\\/type-checks\\/route-handlers\\/route\\.ts\" has an invalid \"GET\" export:\\s+Type \"boolean\" is not a valid type for the function's first argument/\n-          )\n-          expect(errors).toMatch(\n-            /Route \"src\\/app\\/type-checks\\/route-handlers\\/route\\.ts\" has an invalid \"generateStaticParams\" export:\\s+Type \"string\" is not valid/\n-          )\n-\n-          // Avoid invalid return types for exported functions.\n-          expect(errors).toContain(\n-            `\"Promise<boolean>\" is not a valid generateStaticParams return type`\n-          )\n-        })\n-      }\n+describe('app type checking - production mode', () => {\n+  let stderr, errors\n+  beforeAll(async () => {\n+    stderr = (await nextBuild(appDir, [], { stderr: true })).stderr\n+\n+    errors = stderr.match(\n+      /===== TS errors =====(.+)===== TS errors =====/s\n+    )?.[1]\n+  })\n+\n+  it('should report link errors', async () => {\n+    // Make sure the d.ts file is generated\n+    const dts = (\n+      await fs.readFile(path.join(appDir, '.next', 'types', 'link.d.ts'))\n+    ).toString()\n+    expect(dts.includes('`/dashboard/user/')).toBeTruthy()\n+    expect(dts.includes('`/dashboard/another')).toBeTruthy()\n+\n+    // Check type checking errors\n+    expect(errors).toContain(\n+      'Type error: \"/(newroot)/dashboard/another\" is not an existing route. If it is intentional, please type it explicitly with `as Route`.'\n     )\n+\n+    // Make sure all errors were reported and other links passed type checking\n+    const errorLines = [\n+      ...errors.matchAll(/\\.\\/src\\/app\\/type-checks\\/link\\/page\\.tsx:(\\d+):/g),\n+    ].map(([, line]) => +line)\n+\n+    const ST = 18\n+    const ED = 35\n+    expect(errorLines).toEqual(\n+      Array.from({ length: ED - ST + 1 }, (_, i) => i + ST)\n+    )\n+  })\n+\n+  it('should generate route types correctly and report router API errors', async () => {\n+    // Make sure all errors were reported and other links passed type checking\n+    const errorLines = [\n+      ...errors.matchAll(\n+        /\\.\\/src\\/app\\/type-checks\\/router\\/page\\.tsx:(\\d+):/g\n+      ),\n+    ].map(([, line]) => +line)\n+\n+    const ST = 11\n+    const ED = 13\n+    expect(errorLines).toEqual(\n+      Array.from({ length: ED - ST + 1 }, (_, i) => i + ST)\n+    )\n+  })\n+\n+  it('should generate route types correctly and report form errors', async () => {\n+    // Make sure all errors were reported and other Forms passed type checking\n+    const errorLines = [\n+      ...errors.matchAll(/\\.\\/src\\/app\\/type-checks\\/form\\/page\\.tsx:(\\d+):/g),\n+    ].map(([, line]) => +line)\n+\n+    const ST = 8\n+    const ED = 10\n+    expect(errorLines).toEqual(\n+      Array.from({ length: ED - ST + 1 }, (_, i) => i + ST)\n+    )\n+  })\n+\n+  // Type validation is not supported in Turbopack yet.\n+  if (!process.env.IS_TURBOPACK_TEST && !process.env.TURBOPACK_DEV) {\n+    it('should type check invalid entry exports', () => {\n+      // Can't export arbitrary things.\n+      expect(errors).toContain(`\"foo\" is not a valid Page export field.`)\n+\n+      // Can't export invalid fields.\n+      expect(errors).toMatch(\n+        /Invalid configuration \"revalidate\":\\s+Expected \"false | number (>= 0)\", got \"-1\"/\n+      )\n+\n+      // Avoid invalid argument types for exported functions.\n+      expect(errors).toMatch(\n+        /Page \"src\\/app\\/type-checks\\/config\\/page\\.tsx\" has an invalid \"default\" export:\\s+Type \"{ foo: string; }\" is not valid/\n+      )\n+      expect(errors).toMatch(\n+        /Page \"src\\/app\\/type-checks\\/config\\/page\\.tsx\" has an invalid \"generateMetadata\" export:\\s+Type \"{ s: number; }\" is not valid/\n+      )\n+      expect(errors).toMatch(\n+        /Page \"src\\/app\\/type-checks\\/config\\/page\\.tsx\" has an invalid \"generateStaticParams\" export:\\s+Type \"string\" is not valid/\n+      )\n+\n+      // Avoid invalid return types for exported functions.\n+      expect(errors).toContain(\n+        `\"Promise<number>\" is not a valid generateStaticParams return type`\n+      )\n+\n+      // Can't export arbitrary things.\n+      expect(errors).toContain(`\"bar\" is not a valid Route export field.`)\n+\n+      // Can't export invalid fields.\n+      expect(errors).toMatch(\n+        /Invalid configuration \"revalidate\":\\s+Expected \"false | number (>= 0)\", got \"-1\"/\n+      )\n+\n+      // Avoid invalid argument types for exported functions.\n+      expect(errors).toMatch(\n+        /Route \"src\\/app\\/type-checks\\/route-handlers\\/route\\.ts\" has an invalid \"GET\" export:\\s+Type \"boolean\" is not a valid type for the function's first argument/\n+      )\n+      expect(errors).toMatch(\n+        /Route \"src\\/app\\/type-checks\\/route-handlers\\/route\\.ts\" has an invalid \"generateStaticParams\" export:\\s+Type \"string\" is not valid/\n+      )\n+\n+      // Avoid invalid return types for exported functions.\n+      expect(errors).toContain(\n+        `\"Promise<boolean>\" is not a valid generateStaticParams return type`\n+      )\n+    })\n   }\n-)\n+})"
        }
    ],
    "stats": {
        "total": 990,
        "additions": 520,
        "deletions": 470
    }
}