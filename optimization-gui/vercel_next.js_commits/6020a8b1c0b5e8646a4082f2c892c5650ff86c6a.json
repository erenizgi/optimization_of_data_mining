{
    "author": "delbaoliveira",
    "message": "Docs IA 2.0: Reorder PPR page and fix some nits (#79282)\n\nCo-authored-by: Joseph <joseph.chamochumbi@vercel.com>",
    "sha": "6020a8b1c0b5e8646a4082f2c892c5650ff86c6a",
    "files": [
        {
            "sha": "5a06add95d7332ed15b204bcfd2dda78eebe206e",
            "filename": "docs/01-app/01-getting-started/04-images.mdx",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/6020a8b1c0b5e8646a4082f2c892c5650ff86c6a/docs%2F01-app%2F01-getting-started%2F04-images.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/6020a8b1c0b5e8646a4082f2c892c5650ff86c6a/docs%2F01-app%2F01-getting-started%2F04-images.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F01-getting-started%2F04-images.mdx?ref=6020a8b1c0b5e8646a4082f2c892c5650ff86c6a",
            "patch": "@@ -125,7 +125,7 @@ Since Next.js does not have access to remote files during the build process, you\n To safely allow images from remote servers, you need to define a list of supported URL patterns in [`next.config.js`](/docs/app/api-reference/config/next-config-js). Be as specific as possible to prevent malicious usage. For example, the following configuration will only allow images from a specific AWS S3 bucket:\n \n ```ts filename=\"next.config.ts\" switcher\n-import { NextConfig } from 'next'\n+import type { NextConfig } from 'next'\n \n const config: NextConfig = {\n   images: {"
        },
        {
            "sha": "a8132b8e1d643434057deef4a364460500974fca",
            "filename": "docs/01-app/01-getting-started/07-server-and-client-components.mdx",
            "status": "modified",
            "additions": 52,
            "deletions": 43,
            "changes": 95,
            "blob_url": "https://github.com/vercel/next.js/blob/6020a8b1c0b5e8646a4082f2c892c5650ff86c6a/docs%2F01-app%2F01-getting-started%2F07-server-and-client-components.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/6020a8b1c0b5e8646a4082f2c892c5650ff86c6a/docs%2F01-app%2F01-getting-started%2F07-server-and-client-components.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F01-getting-started%2F07-server-and-client-components.mdx?ref=6020a8b1c0b5e8646a4082f2c892c5650ff86c6a",
            "patch": "@@ -7,52 +7,15 @@ related:\n   description: Learn more about the APIs mentioned in this page.\n   links:\n     - app/api-reference/directives/use-client\n-    - app/api-reference/file-conventions/route\n ---\n \n By default, layouts and pages are [Server Components](https://react.dev/reference/rsc/server-components), which lets you fetch data and render parts of your UI on the server, optionally cache the result, and stream it to the client. When you need interactivity or browser APIs, you can use [Client Components](https://react.dev/reference/rsc/use-client) to layer in functionality.\n \n-This page explains how Server and Client Components work in Next.js, when to use them, and how to compose them together in your application.\n-\n-## How do Server and Client Components work in Next.js?\n-\n-### On the server\n-\n-On the server, Next.js uses React's APIs to orchestrate rendering. The rendering work is split into chunks, by individual route segments ([layouts and pages](/docs/app/getting-started/layouts-and-pages)):\n-\n-- **Server Components** are rendered into a special data format called the React Server Component Payload (RSC Payload).\n-- **Client Components** and the RSC Payload are used to [prerender](/docs/app/getting-started/partial-prerendering#how-does-partial-prerendering-work) HTML.\n-\n-> **What is the React Server Component Payload (RSC)?**\n->\n-> The RSC Payload is a compact binary representation of the rendered React Server Components tree. It's used by React on the client to update the browser's DOM. The RSC Payload contains:\n->\n-> - The rendered result of Server Components\n-> - Placeholders for where Client Components should be rendered and references to their JavaScript files\n-> - Any props passed from a Server Component to a Client Component\n-\n-### On the client (first load)\n-\n-Then, on the client:\n-\n-1. **HTML** is used to immediately show a fast non-interactive preview of the route to the user.\n-2. **RSC Payload** is used to reconcile the Client and Server Component trees.\n-3. **JavaScript** is used to hydrate Client Components and make the application interactive.\n-\n-> **What is hydration?**\n->\n-> Hydration is React's process for attaching [event handlers](https://react.dev/learn/responding-to-events) to the DOM, to make the static HTML interactive.\n-\n-### Subsequent Navigations\n-\n-On subsequent navigations:\n-\n-- The **RSC Payload** is prefetched and cached for instant navigation.\n-- **Client Components** are rendered entirely on the client, without the server-rendered HTML.\n+This page explains how Server and Client Components work in Next.js and when to use them, with examples of how to compose them together in your application.\n \n ## When to use Server and Client Components?\n \n-The client and server environments have different capabilities. Server and Client components allow you to run logic in each environment, and compose them together in the same application.\n+The client and server environments have different capabilities. Server and Client components allow you to run logic in each environment depending on your use case.\n \n Use **Client Components** when you need:\n \n@@ -128,6 +91,42 @@ export default function LikeButton({ likes }) {\n }\n ```\n \n+## How do Server and Client Components work in Next.js?\n+\n+### On the server\n+\n+On the server, Next.js uses React's APIs to orchestrate rendering. The rendering work is split into chunks, by individual route segments ([layouts and pages](/docs/app/getting-started/layouts-and-pages)):\n+\n+- **Server Components** are rendered into a special data format called the React Server Component Payload (RSC Payload).\n+- **Client Components** and the RSC Payload are used to [prerender](/docs/app/getting-started/partial-prerendering#how-does-partial-prerendering-work) HTML.\n+\n+> **What is the React Server Component Payload (RSC)?**\n+>\n+> The RSC Payload is a compact binary representation of the rendered React Server Components tree. It's used by React on the client to update the browser's DOM. The RSC Payload contains:\n+>\n+> - The rendered result of Server Components\n+> - Placeholders for where Client Components should be rendered and references to their JavaScript files\n+> - Any props passed from a Server Component to a Client Component\n+\n+### On the client (first load)\n+\n+Then, on the client:\n+\n+1. **HTML** is used to immediately show a fast non-interactive preview of the route to the user.\n+2. **RSC Payload** is used to reconcile the Client and Server Component trees.\n+3. **JavaScript** is used to hydrate Client Components and make the application interactive.\n+\n+> **What is hydration?**\n+>\n+> Hydration is React's process for attaching [event handlers](https://react.dev/learn/responding-to-events) to the DOM, to make the static HTML interactive.\n+\n+### Subsequent Navigations\n+\n+On subsequent navigations:\n+\n+- The **RSC Payload** is prefetched and cached for instant navigation.\n+- **Client Components** are rendered entirely on the client, without the server-rendered HTML.\n+\n ## Examples\n \n ### Using Client Components\n@@ -186,7 +185,7 @@ export default function Search() {\n }\n ```\n \n-```tsx filename=\"app/ui/search.tsx\" highlight={1} switcher\n+```jsx filename=\"app/ui/search.js\" highlight={1} switcher\n 'use client'\n \n export default function Search() {\n@@ -508,9 +507,19 @@ export default function Page() {\n \n ### Preventing environment poisoning\n \n-JavaScript modules can be shared between both Server and Client Components modules. This means it's possible to accidentanlly import server-only code into the client.\n+JavaScript modules can be shared between both Server and Client Components modules. This means it's possible to accidentanlly import server-only code into the client. For example, consider the following function:\n \n-For example, take the following function:\n+```ts filename=\"lib/data.ts\" switcher\n+export async function getData() {\n+  const res = await fetch('https://external-service.com/data', {\n+    headers: {\n+      authorization: process.env.API_KEY,\n+    },\n+  })\n+\n+  return res.json()\n+}\n+```\n \n ```js filename=\"lib/data.js\" switcher\n export async function getData() {\n@@ -554,4 +563,4 @@ export async function getData() {\n \n Now, if you try to import the module into a Client Component, there will be a build-time error.\n \n-> **Good to know**: The corresponding [`client-only` package](https://www.npmjs.com/package/client-only) can be used to mark modules that contain client-only code â€“ for example, code that accesses the `window` object.\n+> **Good to know**: The corresponding [`client-only` package](https://www.npmjs.com/package/client-only) can be used to mark modules that contain client-only logic like code that accesses the `window` object."
        },
        {
            "sha": "fb25402b713c130d800205d158520fad27593524",
            "filename": "docs/01-app/01-getting-started/08-fetching-data.mdx",
            "status": "renamed",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/6020a8b1c0b5e8646a4082f2c892c5650ff86c6a/docs%2F01-app%2F01-getting-started%2F08-fetching-data.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/6020a8b1c0b5e8646a4082f2c892c5650ff86c6a/docs%2F01-app%2F01-getting-started%2F08-fetching-data.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F01-getting-started%2F08-fetching-data.mdx?ref=6020a8b1c0b5e8646a4082f2c892c5650ff86c6a",
            "patch": "@@ -177,7 +177,7 @@ export default function Posts({ posts }) {\n }\n ```\n \n-In the example above, you need to wrap the `<Posts />` component in a [`<Suspense>` boundary](https://react.dev/reference/react/Suspense). This means the fallback will be shown while the promise is being resolved. Learn more about [streaming](#streaming).\n+In the example above, the `<Posts>` component is wrapped in a [`<Suspense>` boundary](https://react.dev/reference/react/Suspense). This means the fallback will be shown while the promise is being resolved. Learn more about [streaming](#streaming).\n \n #### Community libraries\n \n@@ -238,7 +238,7 @@ export default function BlogPage() {\n \n > **Warning:** The content below assumes the [`dynamicIO` config option](/docs/app/api-reference/config/next-config-js/dynamicIO) is enabled in your application. The flag was introduced in Next.js 15 canary.\n \n-When using `async/await` in Server Components, Next.js will opt into **dynamic rendering**. This means the data will be fetched and rendered on the server for every user request. If there are any slow data requests, the whole route will be blocked from rendering.\n+When using `async/await` in Server Components, Next.js will opt into [dynamic rendering](/docs/app/getting-started/partial-prerendering#dynamic-rendering). This means the data will be fetched and rendered on the server for every user request. If there are any slow data requests, the whole route will be blocked from rendering.\n \n To improve the initial load time and user experience, you can use streaming to break up the page's HTML into smaller chunks and progressively send those chunks from the server to the client.\n \n@@ -252,8 +252,8 @@ To improve the initial load time and user experience, you can use streaming to b\n \n There are two ways you can implement streaming in your application:\n \n-1. With the [`loading.js` file](#with-loadingjs)\n-2. With React's [`<Suspense>` component](#with-suspense)\n+1. Wrapping a page with a [`loading.js` file](#with-loadingjs)\n+2. Wrapping a component with [`<Suspense>`](#with-suspense)\n \n ### With `loading.js`\n ",
            "previous_filename": "docs/01-app/01-getting-started/09-fetching-data.mdx"
        },
        {
            "sha": "19c92b2749699d45763824159cbc43ccee0b00a5",
            "filename": "docs/01-app/01-getting-started/09-updating-data.mdx",
            "status": "renamed",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/vercel/next.js/blob/6020a8b1c0b5e8646a4082f2c892c5650ff86c6a/docs%2F01-app%2F01-getting-started%2F09-updating-data.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/6020a8b1c0b5e8646a4082f2c892c5650ff86c6a/docs%2F01-app%2F01-getting-started%2F09-updating-data.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F01-getting-started%2F09-updating-data.mdx?ref=6020a8b1c0b5e8646a4082f2c892c5650ff86c6a",
            "previous_filename": "docs/01-app/01-getting-started/10-updating-data.mdx"
        },
        {
            "sha": "afd9d21c8ecd412030c55b982ffe2901ff07a1b0",
            "filename": "docs/01-app/01-getting-started/10-error-handling.mdx",
            "status": "renamed",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/vercel/next.js/blob/6020a8b1c0b5e8646a4082f2c892c5650ff86c6a/docs%2F01-app%2F01-getting-started%2F10-error-handling.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/6020a8b1c0b5e8646a4082f2c892c5650ff86c6a/docs%2F01-app%2F01-getting-started%2F10-error-handling.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F01-getting-started%2F10-error-handling.mdx?ref=6020a8b1c0b5e8646a4082f2c892c5650ff86c6a",
            "previous_filename": "docs/01-app/01-getting-started/11-error-handling.mdx"
        },
        {
            "sha": "efff30506b18e9344fabdb61697a0cb8c466cbf2",
            "filename": "docs/01-app/01-getting-started/11-partial-prerendering.mdx",
            "status": "renamed",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/6020a8b1c0b5e8646a4082f2c892c5650ff86c6a/docs%2F01-app%2F01-getting-started%2F11-partial-prerendering.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/6020a8b1c0b5e8646a4082f2c892c5650ff86c6a/docs%2F01-app%2F01-getting-started%2F11-partial-prerendering.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F01-getting-started%2F11-partial-prerendering.mdx?ref=6020a8b1c0b5e8646a4082f2c892c5650ff86c6a",
            "patch": "@@ -52,7 +52,7 @@ A component becomes dynamic if it uses the following APIs:\n - [`unstable_noStore`](/docs/app/api-reference/functions/unstable_noStore)\n - [`fetch`](/docs/app/api-reference/functions/fetch) with `{ cache: 'no-store' }`\n \n-In Partial Prerendering, using the APIs throws a special React error that informs Next.js the component cannot be statically rendered, causing a build error. You can use [Suspense](#suspense) to defer rendering until runtime.\n+In Partial Prerendering, using these APIs throws a special React error that informs Next.js the component cannot be statically rendered, causing a build error. You can use a [Suspense](#suspense) boundary to wrap your component to defer rendering until runtime.\n \n ### Suspense\n ",
            "previous_filename": "docs/01-app/01-getting-started/08-partial-prerendering.mdx"
        }
    ],
    "stats": {
        "total": 107,
        "additions": 58,
        "deletions": 49
    }
}