{
    "author": "devin-ai-integration[bot]",
    "message": "docs: Improve Content Security Policy documentation (#80580)\n\n# Improve Content Security Policy Documentation\n\nThis PR comprehensively improves the Next.js Content Security Policy\n(CSP) documentation to address community feedback from Reddit and GitHub\ndiscussions about gaps in the current documentation.\n\n## Changes Made\n\n### 1. Enhanced Nonce Flow Explanation\n- Added detailed section explaining how Next.js automatically detects\nand applies nonces during server-side rendering\n- Clarified the 3-step process: middleware generation → Next.js\nextraction → automatic application\n- Explained that developers don't need to manually add nonces to every\nscript tag\n\n### 2. Static vs Dynamic Rendering Documentation\n- Added comprehensive section explaining performance implications of\nusing nonces\n- Documented that nonces force all pages into dynamic rendering\n- Explained trade-offs: slower page loads, increased server load, no CDN\ncaching\n- Added guidance on when to use nonces vs alternatives\n\n### 3. Experimental SRI (Subresource Integrity) Documentation\n- Documented the experimental `sri.algorithm` configuration option\n- Explained hash-based CSP as an alternative to nonces that preserves\nstatic generation\n- Included configuration examples and benefits/limitations\n- Noted that SRI is webpack-only, App Router only, and experimental\n\n### 4. Development vs Production Considerations\n- Added section addressing environment-specific CSP requirements\n- Documented need for `'unsafe-eval'` in development for HMR\n- Provided conditional CSP examples based on NODE_ENV\n\n### 5. Comprehensive Troubleshooting Section\n- Added solutions for error pages that don't work with strict CSP\n- Documented third-party script integration with CSP\n- Included common CSP violation fixes\n- Added examples for both App Router and Pages Router\n\n### 6. Practical Examples\n- Static site with hash-based CSP using SRI\n- Dynamic site with nonce-based CSP\n- Mixed approach for different page types\n- Environment-aware CSP configuration\n\n### 7. Enhanced Pages Router Documentation\n- Added `_document.tsx` nonce access example\n- Improved `getServerSideProps` examples\n- Added third-party script integration examples\n\n## Community Feedback Addressed\n\nThis PR directly addresses the Reddit thread feedback about:\n- ❌ \"it is not clear that the nonce is then picked up by the rest of the\npages\" → ✅ Added detailed nonce flow explanation\n- ❌ \"it is not clear that the pages therefore are not statically\ngenerated anymore\" → ✅ Added static vs dynamic rendering section\n- ❌ \"The solution of being able to provide the sha256 hashes... is not\nsupported, and it is not mentioned in the documentation\" → ✅ Added\nexperimental SRI documentation\n- ❌ Poor documentation of strict CSP implementation → ✅ Added\ncomprehensive examples and troubleshooting\n\n## Technical Details\n\n- **File Modified**: `docs/01-app/02-guides/content-security-policy.mdx`\n- **Lines Added**: 642 insertions\n- **Maintains**: Existing documentation structure and Next.js\nconventions\n- **Supports**: Both App Router and Pages Router with appropriate\nswitcher components\n\n## Testing\n\n- Verified all code examples use correct Next.js APIs and patterns\n- Ensured documentation follows existing Next.js docs structure\n- Confirmed all referenced configuration options exist in the codebase\n- Validated that experimental features are properly marked as such\n\n---\n\n**Link to Devin run**:\nhttps://app.devin.ai/sessions/e7e5fa95dc0146b3ab79aac72c53ed13\n**Requested by**: lee@vercel.com\n\n---------\n\nCo-authored-by: Devin AI <158243242+devin-ai-integration[bot]@users.noreply.github.com>\nCo-authored-by: lee@vercel.com <lee@vercel.com>\nCo-authored-by: Joseph Chamochumbi <joseph.chamochumbi@vercel.com>",
    "sha": "9d3069adc7bf452eaaf13075c3a7f321b1c36d4e",
    "files": [
        {
            "sha": "b3ce7043c5b059d74acfae545926f02642b1add5",
            "filename": "docs/01-app/02-guides/content-security-policy.mdx",
            "status": "modified",
            "additions": 425,
            "deletions": 2,
            "changes": 427,
            "blob_url": "https://github.com/vercel/next.js/blob/9d3069adc7bf452eaaf13075c3a7f321b1c36d4e/docs%2F01-app%2F02-guides%2Fcontent-security-policy.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/9d3069adc7bf452eaaf13075c3a7f321b1c36d4e/docs%2F01-app%2F02-guides%2Fcontent-security-policy.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F02-guides%2Fcontent-security-policy.mdx?ref=9d3069adc7bf452eaaf13075c3a7f321b1c36d4e",
            "patch": "@@ -27,7 +27,9 @@ A [nonce](https://developer.mozilla.org/docs/Web/HTML/Global_attributes/nonce) i\n \n ### Why use a nonce?\n \n-Even though CSPs are designed to block malicious scripts, there are legitimate scenarios where inline scripts are necessary. In such cases, nonces offer a way to allow these scripts to execute if they have the correct nonce.\n+CSP can block both inline and external scripts to prevent attacks. A nonce lets you safely allow specific scripts to run—only if they include the matching nonce value.\n+\n+If an attacker wanted to load a script into your page, they'd need to guess the nonce value. That's why the nonce must be unpredictable and unique for every request.\n \n ### Adding a nonce with Middleware\n \n@@ -170,6 +172,46 @@ export const config = {\n }\n ```\n \n+### How nonces work in Next.js\n+\n+To use a nonce, your page must be **dynamically rendered**. This is because Next.js applies nonces during **server-side rendering**, based on the CSP header present in the request. Static pages are generated at build time, when no request or response headers exist—so no nonce can be injected.\n+\n+Here’s how nonce support works in a dynamically rendered page:\n+\n+1. **Middleware generates a nonce**: Your middleware creates a unique nonce for the request, adds it to your `Content-Security-Policy` header, and also sets it in a custom `x-nonce` header.\n+2. **Next.js extracts the nonce**: During rendering, Next.js parses the `Content-Security-Policy` header and extracts the nonce using the `'nonce-{value}'` pattern.\n+3. **Nonce is applied automatically**: Next.js attaches the nonce to:\n+   - Framework scripts (React, Next.js runtime)\n+   - Page-specific JavaScript bundles\n+   - Inline styles and scripts generated by Next.js\n+   - Any `<Script>` components using the `nonce` prop\n+\n+Because of this automatic behavior, you don’t need to manually add a nonce to each tag.\n+\n+### Forcing dynamic rendering\n+\n+If you're using nonces, you may need to explicitly opt pages into dynamic rendering:\n+\n+```tsx filename=\"app/page.tsx\" switcher\n+import { connection } from 'next/server'\n+\n+export default async function Page() {\n+  // wait for an incoming request to render this page\n+  await connection()\n+  // Your page content\n+}\n+```\n+\n+```jsx filename=\"app/page.jsx\" switcher\n+import { connection } from 'next/server'\n+\n+export default async function Page() {\n+  // wait for an incoming request to render this page\n+  await connection()\n+  // Your page content\n+}\n+```\n+\n ### Reading the nonce\n \n <PagesOnly>\n@@ -215,6 +257,85 @@ export async function getServerSideProps({ req }) {\n }\n ```\n \n+You can also access the nonce in `_document.tsx` for Pages Router applications:\n+\n+```tsx filename=\"pages/_document.tsx\" switcher\n+import Document, {\n+  Html,\n+  Head,\n+  Main,\n+  NextScript,\n+  DocumentContext,\n+  DocumentInitialProps,\n+} from 'next/document'\n+\n+interface ExtendedDocumentProps extends DocumentInitialProps {\n+  nonce?: string\n+}\n+\n+class MyDocument extends Document<ExtendedDocumentProps> {\n+  static async getInitialProps(\n+    ctx: DocumentContext\n+  ): Promise<ExtendedDocumentProps> {\n+    const initialProps = await Document.getInitialProps(ctx)\n+    const nonce = ctx.req?.headers?.['x-nonce'] as string | undefined\n+\n+    return {\n+      ...initialProps,\n+      nonce,\n+    }\n+  }\n+\n+  render() {\n+    const { nonce } = this.props\n+\n+    return (\n+      <Html lang=\"en\">\n+        <Head nonce={nonce} />\n+        <body>\n+          <Main />\n+          <NextScript nonce={nonce} />\n+        </body>\n+      </Html>\n+    )\n+  }\n+}\n+\n+export default MyDocument\n+```\n+\n+```jsx filename=\"pages/_document.jsx\" switcher\n+import Document, { Html, Head, Main, NextScript } from 'next/document'\n+\n+class MyDocument extends Document {\n+  static async getInitialProps(ctx) {\n+    const initialProps = await Document.getInitialProps(ctx)\n+    const nonce = ctx.req?.headers?.['x-nonce']\n+\n+    return {\n+      ...initialProps,\n+      nonce,\n+    }\n+  }\n+\n+  render() {\n+    const { nonce } = this.props\n+\n+    return (\n+      <Html lang=\"en\">\n+        <Head nonce={nonce} />\n+        <body>\n+          <Main />\n+          <NextScript nonce={nonce} />\n+        </body>\n+      </Html>\n+    )\n+  }\n+}\n+\n+export default MyDocument\n+```\n+\n </PagesOnly>\n \n <AppOnly>\n@@ -257,6 +378,38 @@ export default async function Page() {\n \n </AppOnly>\n \n+## Static vs Dynamic Rendering with CSP\n+\n+Using nonces has important implications for how your Next.js application renders:\n+\n+### Dynamic Rendering Requirement\n+\n+When you use nonces in your CSP, **all pages must be dynamically rendered**. This means:\n+\n+- Pages will build successfully but may encounter runtime errors if not properly configured for dynamic rendering\n+- Each request generates a fresh page with a new nonce\n+- Static optimization and Incremental Static Regeneration (ISR) are disabled\n+- Pages cannot be cached by CDNs without additional configuration\n+- **Partial Prerendering (PPR) is incompatible** with nonce-based CSP since static shell scripts won't have access to the nonce\n+\n+### Performance Implications\n+\n+The shift from static to dynamic rendering affects performance:\n+\n+- **Slower initial page loads**: Pages must be generated on each request\n+- **Increased server load**: Every request requires server-side rendering\n+- **No CDN caching**: Dynamic pages cannot be cached at the edge by default\n+- **Higher hosting costs**: More server resources needed for dynamic rendering\n+\n+### When to use nonces\n+\n+Consider nonces when:\n+\n+- You have strict security requirements that prohibit `'unsafe-inline'`\n+- Your application handles sensitive data\n+- You need to allow specific inline scripts while blocking others\n+- Compliance requirements mandate strict CSP\n+\n ## Without Nonces\n \n For applications that do not require nonces, you can set the CSP header directly in your [`next.config.js`](/docs/app/api-reference/config/next-config-js) file:\n@@ -292,6 +445,276 @@ module.exports = {\n }\n ```\n \n+<AppOnly>\n+\n+## Hash-based CSP with Subresource Integrity (Experimental)\n+\n+As an alternative to nonces, Next.js offers experimental support for hash-based CSP using Subresource Integrity (SRI). This approach allows you to maintain static generation while still having a strict CSP.\n+\n+> **Warning**: This feature is experimental and only available with webpack bundler in App Router applications.\n+\n+### How SRI works\n+\n+Instead of using nonces, SRI generates cryptographic hashes of your JavaScript and CSS files at build time. These hashes are then used in your CSP policy to allow specific scripts and styles.\n+\n+### Enabling SRI\n+\n+Add the experimental SRI configuration to your `next.config.js`:\n+\n+```js filename=\"next.config.js\"\n+/** @type {import('next').NextConfig} */\n+const nextConfig = {\n+  experimental: {\n+    sri: {\n+      algorithm: 'sha256', // or 'sha384' or 'sha512'\n+    },\n+  },\n+}\n+\n+module.exports = nextConfig\n+```\n+\n+### Using SRI with CSP\n+\n+When SRI is enabled, you can use hash-based CSP policies:\n+\n+```js filename=\"next.config.js\"\n+const cspHeader = `\n+    default-src 'self';\n+    script-src 'self'; /* Next.js will automatically add hashes */\n+    style-src 'self'; /* Next.js will automatically add hashes */\n+    img-src 'self' blob: data:;\n+    font-src 'self';\n+    object-src 'none';\n+    base-uri 'self';\n+    form-action 'self';\n+    frame-ancestors 'none';\n+    upgrade-insecure-requests;\n+`\n+\n+module.exports = {\n+  experimental: {\n+    sri: {\n+      algorithm: 'sha256',\n+    },\n+  },\n+  async headers() {\n+    return [\n+      {\n+        source: '/(.*)',\n+        headers: [\n+          {\n+            key: 'Content-Security-Policy',\n+            value: cspHeader.replace(/\\n/g, ''),\n+          },\n+        ],\n+      },\n+    ]\n+  },\n+}\n+```\n+\n+### Benefits of SRI over nonces\n+\n+- **Static generation**: Pages can be statically generated and cached\n+- **CDN compatibility**: Static pages work with CDN caching\n+- **Better performance**: No server-side rendering required for each request\n+- **Build-time security**: Hashes are generated at build time, ensuring integrity\n+\n+### Limitations of SRI\n+\n+- **Experimental**: Feature may change or be removed\n+- **Webpack only**: Not available with Turbopack\n+- **App Router only**: Not supported in Pages Router\n+- **Build-time only**: Cannot handle dynamically generated scripts\n+\n+</AppOnly>\n+\n+## Development vs Production Considerations\n+\n+CSP implementation differs between development and production environments:\n+\n+### Development Environment\n+\n+In development, you will need to enable `'unsafe-eval'` to support APIs that provide additional debugging information:\n+\n+```ts filename=\"middleware.ts\" switcher\n+export function middleware(request: NextRequest) {\n+  const nonce = Buffer.from(crypto.randomUUID()).toString('base64')\n+  const isDev = process.env.NODE_ENV === 'development'\n+\n+  const cspHeader = `\n+    default-src 'self';\n+    script-src 'self' 'nonce-${nonce}' 'strict-dynamic' ${isDev ? \"'unsafe-eval'\" : ''};\n+    style-src 'self' 'nonce-${nonce}' ${isDev ? \"'unsafe-inline'\" : ''};\n+    img-src 'self' blob: data:;\n+    font-src 'self';\n+    object-src 'none';\n+    base-uri 'self';\n+    form-action 'self';\n+    frame-ancestors 'none';\n+    upgrade-insecure-requests;\n+`\n+\n+  // Rest of middleware implementation\n+}\n+```\n+\n+```js filename=\"middleware.js\" switcher\n+export function middleware(request) {\n+  const nonce = Buffer.from(crypto.randomUUID()).toString('base64')\n+  const isDev = process.env.NODE_ENV === 'development'\n+\n+  const cspHeader = `\n+    default-src 'self';\n+    script-src 'self' 'nonce-${nonce}' 'strict-dynamic' ${isDev ? \"'unsafe-eval'\" : ''};\n+    style-src 'self' 'nonce-${nonce}' ${isDev ? \"'unsafe-inline'\" : ''};\n+    img-src 'self' blob: data:;\n+    font-src 'self';\n+    object-src 'none';\n+    base-uri 'self';\n+    form-action 'self';\n+    frame-ancestors 'none';\n+    upgrade-insecure-requests;\n+`\n+\n+  // Rest of middleware implementation\n+}\n+```\n+\n+### Production Deployment\n+\n+Common issues in production:\n+\n+- **Nonce not applied**: Ensure your middleware runs on all necessary routes\n+- **Static assets blocked**: Verify your CSP allows Next.js static assets\n+- **Third-party scripts**: Add necessary domains to your CSP policy\n+\n+## Troubleshooting\n+\n+### Third-party Scripts\n+\n+<AppOnly>\n+\n+When using third-party scripts with CSP:\n+\n+```tsx filename=\"app/layout.tsx\" switcher\n+import { GoogleTagManager } from '@next/third-parties/google'\n+import { headers } from 'next/headers'\n+\n+export default async function RootLayout({\n+  children,\n+}: {\n+  children: React.ReactNode\n+}) {\n+  const nonce = (await headers()).get('x-nonce')\n+\n+  return (\n+    <html lang=\"en\">\n+      <body>\n+        {children}\n+        <GoogleTagManager gtmId=\"GTM-XYZ\" nonce={nonce} />\n+      </body>\n+    </html>\n+  )\n+}\n+```\n+\n+```jsx filename=\"app/layout.jsx\" switcher\n+import { GoogleTagManager } from '@next/third-parties/google'\n+import { headers } from 'next/headers'\n+\n+export default async function RootLayout({ children }) {\n+  const nonce = (await headers()).get('x-nonce')\n+\n+  return (\n+    <html lang=\"en\">\n+      <body>\n+        {children}\n+        <GoogleTagManager gtmId=\"GTM-XYZ\" nonce={nonce} />\n+      </body>\n+    </html>\n+  )\n+}\n+```\n+\n+</AppOnly>\n+\n+<PagesOnly>\n+\n+When using third-party scripts with CSP, ensure you add the necessary domains and pass the nonce:\n+\n+```tsx filename=\"pages/_app.tsx\" switcher\n+import type { AppProps } from 'next/app'\n+import Script from 'next/script'\n+\n+export default function App({ Component, pageProps }: AppProps) {\n+  const nonce = pageProps.nonce\n+\n+  return (\n+    <>\n+      <Component {...pageProps} />\n+      <Script\n+        src=\"https://www.googletagmanager.com/gtag/js\"\n+        strategy=\"afterInteractive\"\n+        nonce={nonce}\n+      />\n+    </>\n+  )\n+}\n+```\n+\n+```jsx filename=\"pages/_app.jsx\" switcher\n+import Script from 'next/script'\n+\n+export default function App({ Component, pageProps }) {\n+  const nonce = pageProps.nonce\n+\n+  return (\n+    <>\n+      <Component {...pageProps} />\n+      <Script\n+        src=\"https://www.googletagmanager.com/gtag/js\"\n+        strategy=\"afterInteractive\"\n+        nonce={nonce}\n+      />\n+    </>\n+  )\n+}\n+```\n+\n+</PagesOnly>\n+\n+Update your CSP to allow third-party domains:\n+\n+```ts filename=\"middleware.ts\" switcher\n+const cspHeader = `\n+  default-src 'self';\n+  script-src 'self' 'nonce-${nonce}' 'strict-dynamic' https://www.googletagmanager.com;\n+  connect-src 'self' https://www.google-analytics.com;\n+  img-src 'self' data: https://www.google-analytics.com;\n+`\n+```\n+\n+```js filename=\"middleware.js\" switcher\n+const cspHeader = `\n+  default-src 'self';\n+  script-src 'self' 'nonce-${nonce}' 'strict-dynamic' https://www.googletagmanager.com;\n+  connect-src 'self' https://www.google-analytics.com;\n+  img-src 'self' data: https://www.google-analytics.com;\n+`\n+```\n+\n+### Common CSP Violations\n+\n+1. **Inline styles**: Use CSS-in-JS libraries that support nonces or move styles to external files\n+2. **Dynamic imports**: Ensure dynamic imports are allowed in your script-src policy\n+3. **WebAssembly**: Add `'wasm-unsafe-eval'` if using WebAssembly\n+4. **Service workers**: Add appropriate policies for service worker scripts\n+\n ## Version History\n \n-We recommend using `v13.4.20+` of Next.js to properly handle and apply nonces.\n+| Version    | Changes                                                       |\n+| ---------- | ------------------------------------------------------------- |\n+| `v14.0.0`  | Experimental SRI support added for hash-based CSP             |\n+| `v13.4.20` | Recommended for proper nonce handling and CSP header parsing. |"
        },
        {
            "sha": "94b8eb4b01a96b1d51e463c8146897b2333d9ec5",
            "filename": "examples/with-strict-csp/app/page.js",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/9d3069adc7bf452eaaf13075c3a7f321b1c36d4e/examples%2Fwith-strict-csp%2Fapp%2Fpage.js",
            "raw_url": "https://github.com/vercel/next.js/raw/9d3069adc7bf452eaaf13075c3a7f321b1c36d4e/examples%2Fwith-strict-csp%2Fapp%2Fpage.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/examples%2Fwith-strict-csp%2Fapp%2Fpage.js?ref=9d3069adc7bf452eaaf13075c3a7f321b1c36d4e",
            "patch": "@@ -1,8 +1,9 @@\n import { headers } from \"next/headers\";\n import Script from \"next/script\";\n \n-export default function Page() {\n-  const nonce = headers().get(\"x-nonce\");\n+export default async function Page() {\n+  const headerStore = await headers();\n+  const nonce = headerStore.get(\"x-nonce\");\n \n   return <Script src=\"https://...\" strategy=\"afterInteractive\" nonce={nonce} />;\n }"
        }
    ],
    "stats": {
        "total": 432,
        "additions": 428,
        "deletions": 4
    }
}