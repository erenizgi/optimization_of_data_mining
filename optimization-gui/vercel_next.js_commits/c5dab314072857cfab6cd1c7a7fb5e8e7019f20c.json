{
    "author": "gnoff",
    "message": "Ignore unhandledRejection events for promises that reject after a React render aborts (#83590)\n\nCurrently we only abort React renders that are prerendered so this\nchange in practice only affects prerendering. The intent is to not\nreport unhandledRejections that are downstream of an abort because the\nsignal these errors provide is very limited. If you do have unrelated\nunhandled rejections they'll usually show up before aborting or in a\ndynamic page render so even if they are incidentally supressed in the\nprerender context you should still be able to observe them.\n\nArguably we should go further and never report unhandled rejections\nbecause there are still valid patterns where you initiate work\nprospectively and then abandon it by choosing a fork or by returning\nearly (i.e. notFound()). This change doesn't attempt to cover every\npossible case.\n\nThe implementation is a bit intense. We need the ability to stop\npropagating the event which is not natively supported with Node's\nEventEmitter interface. Instead we patch the listener methods to\ndelegate the filtering to an inner listener queue. If you add/remove or\notherwise manipulate the listener list we always ensure our listener is\nfirst and can opt to omit propagating the event. If you want to\nuninstall the this patch you just need to unregister this listener\nspecifically which can be accessing used\n`process.listeners('unhandledRejection')[0]`\n\nThis patch only exists for the node environment because we do not do any\nprerendering in edge runtimes. In the future if we add aborting to\nenvironments like edge runtime we may need an alternative solution to\nthis problem",
    "sha": "c5dab314072857cfab6cd1c7a7fb5e8e7019f20c",
    "files": [
        {
            "sha": "51f333d273d5b6ca3294cfe3d4e27d0ebed18644",
            "filename": "packages/next/src/server/node-environment-extensions/unhandled-rejection.tsx",
            "status": "added",
            "additions": 388,
            "deletions": 0,
            "changes": 388,
            "blob_url": "https://github.com/vercel/next.js/blob/c5dab314072857cfab6cd1c7a7fb5e8e7019f20c/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Funhandled-rejection.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/c5dab314072857cfab6cd1c7a7fb5e8e7019f20c/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Funhandled-rejection.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Funhandled-rejection.tsx?ref=c5dab314072857cfab6cd1c7a7fb5e8e7019f20c",
            "patch": "@@ -0,0 +1,388 @@\n+/**\n+ * Manages unhandled rejection listeners to intelligently filter rejections\n+ * from aborted prerenders when cache components are enabled.\n+ *\n+ * THE PROBLEM:\n+ * When we abort prerenders we expect to find numerous unhandled promise rejections due to\n+ * things like awaiting Request data like `headers()`. The rejections are fine and should\n+ * not be construed as problematic so we need to avoid the appearance of a problem by\n+ * omitting them from the logged output.\n+ *\n+ * THE STRATEGY:\n+ * 1. Install a filtering unhandled rejection handler\n+ * 2. Intercept process event methods to capture new handlers in our internal queue\n+ * 3. For each rejection, check if it comes from an aborted prerender context\n+ * 4. If yes, suppress it. If no, delegate to all handlers in our queue\n+ * 5. This provides precise filtering without time-based windows\n+ *\n+ * This ensures we suppress noisy prerender-related rejections while preserving\n+ * normal error logging for genuine unhandled rejections.\n+ */\n+\n+import { workUnitAsyncStorage } from '../app-render/work-unit-async-storage.external'\n+\n+type ListenerMetadata = {\n+  listener: NodeJS.UnhandledRejectionListener\n+  once: boolean\n+}\n+\n+let filterInstalled = false\n+\n+// We store the proxied listeners for unhandled rejections here.\n+let underlyingListeners: Array<NodeJS.UnhandledRejectionListener> = []\n+// We store a unique pointer to each event listener registration to track\n+// details like whether the listener is a once listener.\n+let listenerMetadata: Array<ListenerMetadata> = []\n+\n+let originalProcessOn: typeof process.on\n+let originalProcessAddListener: typeof process.addListener\n+let originalProcessOnce: typeof process.once\n+let originalProcessRemoveListener: typeof process.removeListener\n+let originalProcessRemoveAllListeners: typeof process.removeAllListeners\n+let originalProcessListeners: typeof process.listeners\n+let originalProcessPrependListener: typeof process.prependListener\n+let originalProcessPrependOnceListener: typeof process.prependOnceListener\n+let originalProcessOff: typeof process.off\n+\n+let didWarnPrepend = false\n+let didWarnRemoveAll = false\n+\n+/**\n+ * Installs a filtering unhandled rejection handler that intelligently suppresses\n+ * rejections from aborted prerender contexts.\n+ *\n+ * This should be called once during server startup to install the global filter.\n+ */\n+function installUnhandledRejectionFilter(): void {\n+  if (filterInstalled) {\n+    return\n+  }\n+\n+  // Capture existing handlers\n+  underlyingListeners = Array.from(process.listeners('unhandledRejection'))\n+  // We assume all existing handlers are not \"once\"\n+  listenerMetadata = underlyingListeners.map((l) => ({\n+    listener: l,\n+    once: false,\n+  }))\n+\n+  // Store the original process methods\n+  originalProcessOn = process.on\n+  originalProcessAddListener = process.addListener\n+  originalProcessOnce = process.once\n+  originalProcessOff = process.off\n+  originalProcessRemoveListener = process.removeListener\n+  originalProcessRemoveAllListeners = process.removeAllListeners\n+  originalProcessListeners = process.listeners\n+  originalProcessPrependListener = process.prependListener\n+  originalProcessPrependOnceListener = process.prependOnceListener\n+\n+  // Helper function to create a patched method that preserves toString behavior\n+  function patchMethod<T extends Function>(original: T, patchedImpl: T): T {\n+    // Preserve the original toString behavior\n+    Object.defineProperty(patchedImpl, 'toString', {\n+      value: original.toString.bind(original),\n+      writable: true,\n+      configurable: true,\n+    })\n+    return patchedImpl\n+  }\n+\n+  // Intercept process.on to capture new unhandled rejection handlers\n+  process.on = patchMethod(originalProcessOn, function (\n+    event: string | symbol,\n+    listener: (...args: any[]) => void\n+  ) {\n+    if (event === 'unhandledRejection') {\n+      // Add new handlers to our internal queue instead of the process\n+      underlyingListeners.push(listener as NodeJS.UnhandledRejectionListener)\n+      listenerMetadata.push({ listener, once: false })\n+      return process\n+    }\n+    // For other events, use the original method\n+    return originalProcessOn.call(process, event, listener)\n+  } as typeof process.on)\n+\n+  // Intercept process.addListener (alias for process.on)\n+  process.addListener = patchMethod(\n+    originalProcessAddListener,\n+    process.on as typeof originalProcessAddListener\n+  )\n+\n+  // Intercept process.once for one-time handlers\n+  process.once = patchMethod(originalProcessOnce, function (\n+    event: string | symbol,\n+    listener: (...args: any[]) => void\n+  ) {\n+    if (event === 'unhandledRejection') {\n+      underlyingListeners.push(listener)\n+      listenerMetadata.push({ listener, once: true })\n+      return process\n+    }\n+    // For other events, use the original method\n+    return originalProcessOnce.call(process, event, listener)\n+  } as typeof process.once)\n+\n+  // Intercept process.prependListener for handlers that should go first\n+  process.prependListener = patchMethod(\n+    originalProcessPrependListener,\n+    function (event: string | symbol, listener: (...args: any[]) => void) {\n+      if (event === 'unhandledRejection') {\n+        if (didWarnPrepend === false) {\n+          didWarnPrepend = true\n+          console.warn(\n+            'Warning: `prependListener(\"unhandledRejection\")` called, but Next.js maintains the first listener ' +\n+              'which filters out unnecessary events from aborted prerenders. Your handler will be second.'\n+          )\n+        }\n+        // Add new handlers to the beginning of our internal queue\n+        underlyingListeners.unshift(\n+          listener as NodeJS.UnhandledRejectionListener\n+        )\n+        listenerMetadata.unshift({ listener, once: false })\n+        return process\n+      }\n+      // For other events, use the original method\n+      return originalProcessPrependListener.call(\n+        process,\n+        event as any,\n+        listener\n+      )\n+    } as typeof process.prependListener\n+  )\n+\n+  // Intercept process.prependOnceListener for one-time handlers that should go first\n+  process.prependOnceListener = patchMethod(\n+    originalProcessPrependOnceListener,\n+    function (event: string | symbol, listener: (...args: any[]) => void) {\n+      if (event === 'unhandledRejection') {\n+        if (didWarnPrepend === false) {\n+          didWarnPrepend = true\n+          console.warn(\n+            'Warning: `prependOnceListener(\"unhandledRejection\")` called, but Next.js maintains the first listener ' +\n+              'which filters out unnecessary events from aborted prerenders. Your handler will be second.'\n+          )\n+        }\n+        // Add to the beginning of our internal queue\n+        underlyingListeners.unshift(listener)\n+        listenerMetadata.unshift({ listener, once: true })\n+        return process\n+      }\n+      // For other events, use the original method\n+      return originalProcessPrependOnceListener.call(\n+        process,\n+        event as any,\n+        listener\n+      )\n+    } as typeof process.prependOnceListener\n+  )\n+\n+  // Intercept process.removeListener\n+  process.removeListener = patchMethod(originalProcessRemoveListener, function (\n+    event: string | symbol,\n+    listener: (...args: any[]) => void\n+  ) {\n+    if (event === 'unhandledRejection') {\n+      // Check if they're trying to remove our filtering handler\n+      if (listener === filteringUnhandledRejectionHandler) {\n+        uninstallUnhandledRejectionFilter()\n+        return process\n+      }\n+\n+      const index = underlyingListeners.lastIndexOf(listener)\n+      if (index > -1) {\n+        underlyingListeners.splice(index, 1)\n+        listenerMetadata.splice(index, 1)\n+      }\n+      return process\n+    }\n+    // For other events, use the original method\n+    return originalProcessRemoveListener.call(process, event, listener)\n+  } as typeof process.removeListener)\n+\n+  // Intercept process.off (alias for process.removeListener)\n+  process.off = patchMethod(\n+    originalProcessOff,\n+    process.removeListener as typeof originalProcessOff\n+  )\n+\n+  // Intercept process.removeAllListeners\n+  process.removeAllListeners = patchMethod(\n+    originalProcessRemoveAllListeners,\n+    function (event?: string | symbol) {\n+      if (event === 'unhandledRejection') {\n+        if (didWarnRemoveAll === false) {\n+          didWarnRemoveAll = true\n+          console.warn(\n+            'Warning: `removeAllListeners(\"unhandledRejection\")` called. Next.js maintains an `unhandledRejection` listener ' +\n+              'to filter out unnecessary rejection warnings caused by aborting prerenders early. It is not recommended that you ' +\n+              'uninstall this behavior, but if you want to you must call `process.removeListener(\"unhandledRejection\", listener)`. ' +\n+              'You can acquire the listener from `process.listeners(\"unhandledRejection\")[0]`.'\n+          )\n+        }\n+        underlyingListeners.length = 0\n+        listenerMetadata.length = 0\n+        return process\n+      }\n+\n+      // For other specific events, use the original method\n+      if (event !== undefined) {\n+        return originalProcessRemoveAllListeners.call(process, event)\n+      }\n+\n+      // If no event specified (removeAllListeners()), uninstall our patch completely\n+      console.warn(\n+        'Warning: `removeAllListeners()` called - uninstalling Next.js unhandled rejection filter. ' +\n+          'You will observe `unhandledRejection` logs from prerendering which are not problematic.'\n+      )\n+      uninstallUnhandledRejectionFilter()\n+      return originalProcessRemoveAllListeners.call(process)\n+    } as typeof process.removeAllListeners\n+  )\n+\n+  // Intercept process.listeners to return our internal handlers for unhandled rejection\n+  process.listeners = patchMethod(originalProcessListeners, function (\n+    event: string | symbol\n+  ) {\n+    if (event === 'unhandledRejection') {\n+      return [filteringUnhandledRejectionHandler, ...underlyingListeners]\n+    }\n+    return originalProcessListeners.call(process, event as any)\n+  } as typeof process.listeners)\n+\n+  // Remove all existing handlers\n+  originalProcessRemoveAllListeners.call(process, 'unhandledRejection')\n+\n+  // Install our filtering handler\n+  originalProcessOn.call(\n+    process,\n+    'unhandledRejection',\n+    filteringUnhandledRejectionHandler\n+  )\n+\n+  originalProcessOn.call(process, 'rejectionHandled', noopRejectionHandled)\n+\n+  filterInstalled = true\n+}\n+\n+/**\n+ * Uninstalls the unhandled rejection filter and restores original process methods.\n+ * This is called when someone explicitly removes our filtering handler.\n+ * @internal\n+ */\n+function uninstallUnhandledRejectionFilter(): void {\n+  if (!filterInstalled) {\n+    return\n+  }\n+\n+  // Restore original process methods\n+  process.on = originalProcessOn\n+  process.addListener = originalProcessAddListener\n+  process.once = originalProcessOnce\n+  process.prependListener = originalProcessPrependListener\n+  process.prependOnceListener = originalProcessPrependOnceListener\n+  process.removeListener = originalProcessRemoveListener\n+  process.off = originalProcessOff\n+  process.removeAllListeners = originalProcessRemoveAllListeners\n+  process.listeners = originalProcessListeners\n+\n+  // Remove our filtering handler\n+  originalProcessRemoveListener.call(\n+    process,\n+    'unhandledRejection',\n+    filteringUnhandledRejectionHandler\n+  )\n+\n+  originalProcessRemoveListener.call(\n+    process,\n+    'rejectionHandled',\n+    noopRejectionHandled\n+  )\n+\n+  // Re-register all the handlers that were in our internal queue\n+  for (const meta of listenerMetadata) {\n+    if (meta.once) {\n+      originalProcessOnce.call(process, 'unhandledRejection', meta.listener)\n+    } else {\n+      originalProcessOn.call(process, 'unhandledRejection', meta.listener)\n+    }\n+  }\n+\n+  // Reset state\n+  filterInstalled = false\n+  underlyingListeners.length = 0\n+  listenerMetadata.length = 0\n+}\n+\n+/**\n+ * The filtering handler that decides whether to suppress or delegate unhandled rejections.\n+ */\n+function filteringUnhandledRejectionHandler(\n+  reason: any,\n+  promise: Promise<any>\n+): void {\n+  const capturedListenerMetadata = Array.from(listenerMetadata)\n+\n+  const workUnitStore = workUnitAsyncStorage.getStore()\n+\n+  if (workUnitStore) {\n+    switch (workUnitStore.type) {\n+      case 'prerender':\n+      case 'prerender-client':\n+      case 'prerender-runtime': {\n+        const signal = workUnitStore.renderSignal\n+        if (signal.aborted) {\n+          // This unhandledRejection is from async work spawned in a now\n+          // aborted prerender. We don't need to report this.\n+          return\n+        }\n+        break\n+      }\n+      case 'prerender-ppr':\n+      case 'prerender-legacy':\n+      case 'request':\n+      case 'cache':\n+      case 'private-cache':\n+      case 'unstable-cache':\n+        break\n+      default:\n+        workUnitStore satisfies never\n+    }\n+  }\n+\n+  // Not from an aborted prerender, delegate to original handlers\n+  if (capturedListenerMetadata.length === 0) {\n+    // We need to log something because the default behavior when there is\n+    // no event handler installed is to trigger an Unhandled Exception.\n+    // We don't do that here b/c we don't want to rely on this implicit default\n+    // to kill the process since it can be disabled by installing a userland listener\n+    // and you may also choose to run Next.js with args such that unhandled rejections\n+    // do not automatically terminate the process.\n+    console.error('Unhandled Rejection:', reason)\n+  } else {\n+    try {\n+      for (const meta of capturedListenerMetadata) {\n+        if (meta.once) {\n+          // This is a once listener. we remove it from our set before we call it\n+          const index = listenerMetadata.indexOf(meta)\n+          if (index !== -1) {\n+            underlyingListeners.splice(index, 1)\n+            listenerMetadata.splice(index, 1)\n+          }\n+        }\n+        const listener = meta.listener\n+        listener(reason, promise)\n+      }\n+    } catch (error) {\n+      // If any handlers error we produce an Uncaught Exception\n+      setImmediate(() => {\n+        throw error\n+      })\n+    }\n+  }\n+}\n+\n+function noopRejectionHandled() {}\n+\n+// Install the filter when this module is imported\n+installUnhandledRejectionFilter()"
        },
        {
            "sha": "36d51223432679f4069eb68ab281d06b4b0aabdb",
            "filename": "packages/next/src/server/node-environment.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/c5dab314072857cfab6cd1c7a7fb5e8e7019f20c/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/c5dab314072857cfab6cd1c7a7fb5e8e7019f20c/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment.ts?ref=c5dab314072857cfab6cd1c7a7fb5e8e7019f20c",
            "patch": "@@ -5,6 +5,7 @@ import './node-environment-baseline'\n // Import as early as possible so that unexpected errors in other extensions are properly formatted.\n // Has to come after baseline since error-inspect requires AsyncLocalStorage that baseline provides.\n import './node-environment-extensions/error-inspect'\n+import './node-environment-extensions/unhandled-rejection'\n import './node-environment-extensions/random'\n import './node-environment-extensions/date'\n import './node-environment-extensions/web-crypto'"
        },
        {
            "sha": "45fdd9213235546018bfe946975695a06322e97a",
            "filename": "test/e2e/app-dir/cache-components-errors/cache-components-errors.test.ts",
            "status": "modified",
            "additions": 85,
            "deletions": 0,
            "changes": 85,
            "blob_url": "https://github.com/vercel/next.js/blob/c5dab314072857cfab6cd1c7a7fb5e8e7019f20c/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Fcache-components-errors.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/c5dab314072857cfab6cd1c7a7fb5e8e7019f20c/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Fcache-components-errors.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Fcache-components-errors.test.ts?ref=c5dab314072857cfab6cd1c7a7fb5e8e7019f20c",
            "patch": "@@ -5074,5 +5074,90 @@ describe('Cache Components Errors', () => {\n         })\n       }\n     })\n+\n+    describe('Unhandled Rejection Suppression', () => {\n+      const pathname = '/unhandled-rejection'\n+\n+      if (isNextDev) {\n+        it('should suppress unhandled rejections during prerender validation in dev', async () => {\n+          const browser = await next.browser(pathname)\n+\n+          await expect(browser).toDisplayCollapsedRedbox(`\n+           [\n+             {\n+               \"description\": \"BOOM\",\n+               \"environmentLabel\": \"Prerender\",\n+               \"label\": \"Console Error\",\n+               \"source\": null,\n+               \"stack\": [\n+                 \"Page <anonymous>\",\n+               ],\n+             },\n+             {\n+               \"description\": \" тип \"unhandledRejection:\" \"BOOM\"\",\n+               \"environmentLabel\": \"Prerender\",\n+               \"label\": \"Console Error\",\n+               \"source\": null,\n+               \"stack\": [\n+                 \"Page <anonymous>\",\n+               ],\n+             },\n+             {\n+               \"description\": \" тип \"unhandledRejection: \" \"BOOM\"\",\n+               \"environmentLabel\": \"Prerender\",\n+               \"label\": \"Console Error\",\n+               \"source\": null,\n+               \"stack\": [\n+                 \"Page <anonymous>\",\n+               ],\n+             },\n+             {\n+               \"description\": \"BAM\",\n+               \"environmentLabel\": \"Server\",\n+               \"label\": \"Console Error\",\n+               \"source\": null,\n+               \"stack\": [\n+                 \"Page <anonymous>\",\n+               ],\n+             },\n+             {\n+               \"description\": \" тип \"unhandledRejection:\" \"BAM\"\",\n+               \"environmentLabel\": \"Server\",\n+               \"label\": \"Console Error\",\n+               \"source\": null,\n+               \"stack\": [\n+                 \"Page <anonymous>\",\n+               ],\n+             },\n+             {\n+               \"description\": \" тип \"unhandledRejection: \" \"BAM\"\",\n+               \"environmentLabel\": \"Server\",\n+               \"label\": \"Console Error\",\n+               \"source\": null,\n+               \"stack\": [\n+                 \"Page <anonymous>\",\n+               ],\n+             },\n+           ]\n+          `)\n+        })\n+      } else {\n+        it('should suppress unhandled rejections after prerender abort', async () => {\n+          try {\n+            await prerender(pathname)\n+          } catch {}\n+\n+          const output = getPrerenderOutput(\n+            next.cliOutput.slice(cliOutputLength),\n+            { isMinified: !isDebugPrerender }\n+          )\n+\n+          expect(output).toMatchInlineSnapshot(`\n+             \"BOOM\n+             BOOM\"\n+            `)\n+        })\n+      }\n+    })\n   })\n })"
        },
        {
            "sha": "1346c451cc6f89f781582251f9d9e5c5c2785feb",
            "filename": "test/e2e/app-dir/cache-components-errors/fixtures/default/app/unhandled-rejection/layout.tsx",
            "status": "added",
            "additions": 13,
            "deletions": 0,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/c5dab314072857cfab6cd1c7a7fb5e8e7019f20c/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Ffixtures%2Fdefault%2Fapp%2Funhandled-rejection%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/c5dab314072857cfab6cd1c7a7fb5e8e7019f20c/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Ffixtures%2Fdefault%2Fapp%2Funhandled-rejection%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Ffixtures%2Fdefault%2Fapp%2Funhandled-rejection%2Flayout.tsx?ref=c5dab314072857cfab6cd1c7a7fb5e8e7019f20c",
            "patch": "@@ -0,0 +1,13 @@\n+import { Suspense } from 'react'\n+\n+export default function Root({ children }: { children: React.ReactNode }) {\n+  return (\n+    <html>\n+      <body>\n+        <main>\n+          <Suspense>{children}</Suspense>\n+        </main>\n+      </body>\n+    </html>\n+  )\n+}"
        },
        {
            "sha": "d0a6f723ddce99d87cf09ecdcd5751dad2e1938b",
            "filename": "test/e2e/app-dir/cache-components-errors/fixtures/default/app/unhandled-rejection/page.tsx",
            "status": "added",
            "additions": 22,
            "deletions": 0,
            "changes": 22,
            "blob_url": "https://github.com/vercel/next.js/blob/c5dab314072857cfab6cd1c7a7fb5e8e7019f20c/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Ffixtures%2Fdefault%2Fapp%2Funhandled-rejection%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/c5dab314072857cfab6cd1c7a7fb5e8e7019f20c/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Ffixtures%2Fdefault%2Fapp%2Funhandled-rejection%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Ffixtures%2Fdefault%2Fapp%2Funhandled-rejection%2Fpage.tsx?ref=c5dab314072857cfab6cd1c7a7fb5e8e7019f20c",
            "patch": "@@ -0,0 +1,22 @@\n+export default async function Page() {\n+  // This promise will reject before we abort during prerendering\n+  Promise.reject('BOOM')\n+\n+  // This promise will reject after we abort during prerendering\n+  setTimeout(() => {\n+    Promise.reject('BAM')\n+  }, 0)\n+\n+  return (\n+    <>\n+      <p>\n+        This page tests unhandled rejection suppression after prerender abort.\n+      </p>\n+      <p>\n+        With cache components enabled, this page produces a partial static shell\n+        and it has one early rejection \"BOOM\" which will show up but two late\n+        rejections which should not\n+      </p>\n+    </>\n+  )\n+}"
        },
        {
            "sha": "00e00e46f3be8ab4ca8fdb982d4adeca228ce167",
            "filename": "test/e2e/app-dir/cache-components-errors/utils.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 1,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/c5dab314072857cfab6cd1c7a7fb5e8e7019f20c/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Futils.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/c5dab314072857cfab6cd1c7a7fb5e8e7019f20c/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Futils.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Futils.ts?ref=c5dab314072857cfab6cd1c7a7fb5e8e7019f20c",
            "patch": "@@ -1,7 +1,11 @@\n // Used to deterministically stub out minified local names in stack traces.\n const abc = 'abcdefghijklmnopqrstuvwxyz'\n const hostElementsUsedInFixtures = ['html', 'body', 'main', 'div']\n-const ignoredLines = ['Generating static pages', 'Inlining static env']\n+const ignoredLines = [\n+  'Generating static pages',\n+  'Inlining static env',\n+  'Finalizing page optimization',\n+]\n \n /**\n  * Converts a module function sequence expression, e.g.:\n@@ -50,6 +54,10 @@ export function getPrerenderOutput(\n       break\n     }\n \n+    if (line.includes('Route (app)')) {\n+      break\n+    }\n+\n     if (\n       foundPrerenderingLine &&\n       !ignoredLines.some((ignoredLine) => line.includes(ignoredLine))"
        },
        {
            "sha": "93331c2cf388960dae2e36f231f020814aae646e",
            "filename": "test/e2e/app-dir/cache-components-request-apis/fixtures/reject-hanging-promises-dynamic/app/[slug]/page.tsx",
            "status": "modified",
            "additions": 10,
            "deletions": 10,
            "changes": 20,
            "blob_url": "https://github.com/vercel/next.js/blob/c5dab314072857cfab6cd1c7a7fb5e8e7019f20c/test%2Fe2e%2Fapp-dir%2Fcache-components-request-apis%2Ffixtures%2Freject-hanging-promises-dynamic%2Fapp%2F%5Bslug%5D%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/c5dab314072857cfab6cd1c7a7fb5e8e7019f20c/test%2Fe2e%2Fapp-dir%2Fcache-components-request-apis%2Ffixtures%2Freject-hanging-promises-dynamic%2Fapp%2F%5Bslug%5D%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fcache-components-request-apis%2Ffixtures%2Freject-hanging-promises-dynamic%2Fapp%2F%5Bslug%5D%2Fpage.tsx?ref=c5dab314072857cfab6cd1c7a7fb5e8e7019f20c",
            "patch": "@@ -5,16 +5,12 @@ export default async function Page(props: {\n   params: Promise<{}>\n   searchParams: Promise<{}>\n }) {\n-  setTimeout(async () => await props.params)\n-  setTimeout(async () => await props.searchParams)\n-  let pendingCookies = cookies()\n-  setTimeout(async () => await pendingCookies)\n-  let pendingHeaders = headers()\n-  setTimeout(async () => await pendingHeaders)\n-  let pendingDraftMode = draftMode()\n-  setTimeout(async () => await pendingDraftMode)\n-  let pendingConnection = connection()\n-  setTimeout(async () => await pendingConnection)\n+  props.params.catch(logReason)\n+  props.searchParams.catch(logReason)\n+  cookies().catch(logReason)\n+  headers().catch(logReason)\n+  draftMode().catch(logReason)\n+  connection().catch(logReason)\n   return (\n     <>\n       <p>\n@@ -31,6 +27,10 @@ export default async function Page(props: {\n   )\n }\n \n+function logReason(reason: any) {\n+  console.log('Reason:', reason)\n+}\n+\n async function TriggerSyncDynamic() {\n   await new Promise((r) => process.nextTick(r))\n   return Math.random()"
        },
        {
            "sha": "b7e4fecbeac02c936d1726a2ff4175bea7d6a709",
            "filename": "test/e2e/app-dir/cache-components-request-apis/fixtures/reject-hanging-promises-static/app/[slug]/page.tsx",
            "status": "modified",
            "additions": 10,
            "deletions": 10,
            "changes": 20,
            "blob_url": "https://github.com/vercel/next.js/blob/c5dab314072857cfab6cd1c7a7fb5e8e7019f20c/test%2Fe2e%2Fapp-dir%2Fcache-components-request-apis%2Ffixtures%2Freject-hanging-promises-static%2Fapp%2F%5Bslug%5D%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/c5dab314072857cfab6cd1c7a7fb5e8e7019f20c/test%2Fe2e%2Fapp-dir%2Fcache-components-request-apis%2Ffixtures%2Freject-hanging-promises-static%2Fapp%2F%5Bslug%5D%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fcache-components-request-apis%2Ffixtures%2Freject-hanging-promises-static%2Fapp%2F%5Bslug%5D%2Fpage.tsx?ref=c5dab314072857cfab6cd1c7a7fb5e8e7019f20c",
            "patch": "@@ -5,16 +5,12 @@ export default async function Page(props: {\n   params: Promise<{}>\n   searchParams: Promise<{}>\n }) {\n-  setTimeout(async () => await props.params)\n-  setTimeout(async () => await props.searchParams)\n-  let pendingCookies = cookies()\n-  setTimeout(async () => await pendingCookies)\n-  let pendingHeaders = headers()\n-  setTimeout(async () => await pendingHeaders)\n-  let pendingDraftMode = draftMode()\n-  setTimeout(async () => await pendingDraftMode)\n-  let pendingConnection = connection()\n-  setTimeout(async () => await pendingConnection)\n+  props.params.catch(logReason)\n+  props.searchParams.catch(logReason)\n+  cookies().catch(logReason)\n+  headers().catch(logReason)\n+  draftMode().catch(logReason)\n+  connection().catch(logReason)\n   return (\n     <>\n       <p>\n@@ -26,3 +22,7 @@ export default async function Page(props: {\n     </>\n   )\n }\n+\n+function logReason(reason: any) {\n+  console.log('Reason:', reason)\n+}"
        }
    ],
    "stats": {
        "total": 559,
        "additions": 538,
        "deletions": 21
    }
}