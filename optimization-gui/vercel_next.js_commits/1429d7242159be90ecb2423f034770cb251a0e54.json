{
    "author": "mischnic",
    "message": "Upgrade rust version to 2025-06-04 (#80200)\n\nAll code changes come from `cargo clippy --fix` to collapse ifs",
    "sha": "1429d7242159be90ecb2423f034770cb251a0e54",
    "files": [
        {
            "sha": "71fef339dcac79124e52c0e3741da596b7dc58b2",
            "filename": "crates/napi/src/util.rs",
            "status": "modified",
            "additions": 36,
            "deletions": 36,
            "changes": 72,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/crates%2Fnapi%2Fsrc%2Futil.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/crates%2Fnapi%2Fsrc%2Futil.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnapi%2Fsrc%2Futil.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -70,49 +70,49 @@ pub fn log_internal_error_and_inform(internal_error: &anyhow::Error) {\n \n     // hold open this mutex guard to prevent concurrent writes to the file!\n     let mut last_error_time = LOG_THROTTLE.lock().unwrap();\n-    if let Some(last_error_time) = last_error_time.as_ref() {\n-        if last_error_time.elapsed().as_secs() < 1 {\n-            // Throttle panic logging to once per second\n-            return;\n-        }\n+    if let Some(last_error_time) = last_error_time.as_ref()\n+        && last_error_time.elapsed().as_secs() < 1\n+    {\n+        // Throttle panic logging to once per second\n+        return;\n     }\n     *last_error_time = Some(Instant::now());\n \n     let size = std::fs::metadata(PANIC_LOG.as_path()).map(|m| m.len());\n-    if let Ok(size) = size {\n-        if size > 512 * 1024 {\n-            // Truncate the earliest error from log file if it's larger than 512KB\n-            let new_lines = {\n-                let log_read = OpenOptions::new()\n-                    .read(true)\n-                    .open(PANIC_LOG.as_path())\n-                    .unwrap_or_else(|_| panic!(\"Failed to open {}\", PANIC_LOG.to_string_lossy()));\n-\n-                io::BufReader::new(&log_read)\n-                    .lines()\n-                    .skip(1)\n-                    .skip_while(|line| match line {\n-                        Ok(line) => !line.starts_with(LOG_DIVIDER),\n-                        Err(_) => false,\n-                    })\n-                    .collect::<Vec<_>>()\n-            };\n-\n-            let mut log_write = OpenOptions::new()\n-                .create(true)\n-                .truncate(true)\n-                .write(true)\n+    if let Ok(size) = size\n+        && size > 512 * 1024\n+    {\n+        // Truncate the earliest error from log file if it's larger than 512KB\n+        let new_lines = {\n+            let log_read = OpenOptions::new()\n+                .read(true)\n                 .open(PANIC_LOG.as_path())\n                 .unwrap_or_else(|_| panic!(\"Failed to open {}\", PANIC_LOG.to_string_lossy()));\n \n-            for line in new_lines {\n-                match line {\n-                    Ok(line) => {\n-                        writeln!(log_write, \"{line}\").unwrap();\n-                    }\n-                    Err(_) => {\n-                        break;\n-                    }\n+            io::BufReader::new(&log_read)\n+                .lines()\n+                .skip(1)\n+                .skip_while(|line| match line {\n+                    Ok(line) => !line.starts_with(LOG_DIVIDER),\n+                    Err(_) => false,\n+                })\n+                .collect::<Vec<_>>()\n+        };\n+\n+        let mut log_write = OpenOptions::new()\n+            .create(true)\n+            .truncate(true)\n+            .write(true)\n+            .open(PANIC_LOG.as_path())\n+            .unwrap_or_else(|_| panic!(\"Failed to open {}\", PANIC_LOG.to_string_lossy()));\n+\n+        for line in new_lines {\n+            match line {\n+                Ok(line) => {\n+                    writeln!(log_write, \"{line}\").unwrap();\n+                }\n+                Err(_) => {\n+                    break;\n                 }\n             }\n         }"
        },
        {
            "sha": "c4a24586806ca66ff0ce91940da52f2401f77364",
            "filename": "crates/next-api/src/dynamic_imports.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 8,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/crates%2Fnext-api%2Fsrc%2Fdynamic_imports.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/crates%2Fnext-api%2Fsrc%2Fdynamic_imports.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fdynamic_imports.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -133,15 +133,13 @@ pub async fn map_next_dynamic(graph: Vc<SingleModuleGraph>) -> Result<Vc<Dynamic\n                 .layer\n                 .as_ref()\n                 .is_some_and(|layer| *layer == \"app-client\" || *layer == \"client\")\n-            {\n-                if let Some(dynamic_entry_module) =\n+                && let Some(dynamic_entry_module) =\n                     ResolvedVc::try_downcast_type::<NextDynamicEntryModule>(*module)\n-                {\n-                    return Ok(Some((\n-                        *module,\n-                        DynamicImportEntriesMapType::DynamicEntry(dynamic_entry_module),\n-                    )));\n-                }\n+            {\n+                return Ok(Some((\n+                    *module,\n+                    DynamicImportEntriesMapType::DynamicEntry(dynamic_entry_module),\n+                )));\n             }\n             // TODO add this check once these modules have the correct layer\n             // if layer.is_some_and(|layer| &**layer == \"app-rsc\") {"
        },
        {
            "sha": "b27026d38c72acf28b0d5d60e4dbc7307fa22bc7",
            "filename": "crates/next-api/src/pages.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 7,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/crates%2Fnext-api%2Fsrc%2Fpages.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/crates%2Fnext-api%2Fsrc%2Fpages.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fpages.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -736,13 +736,12 @@ impl PageEndpoint {\n         if matches!(\n             *this.pages_project.project().next_mode().await?,\n             NextMode::Development\n-        ) {\n-            if let Some(chunkable) = Vc::try_resolve_downcast(page_loader).await? {\n-                return Ok(Vc::upcast(HmrEntryModule::new(\n-                    AssetIdent::from_path(*this.page.await?.base_path),\n-                    chunkable,\n-                )));\n-            }\n+        ) && let Some(chunkable) = Vc::try_resolve_downcast(page_loader).await?\n+        {\n+            return Ok(Vc::upcast(HmrEntryModule::new(\n+                AssetIdent::from_path(*this.page.await?.base_path),\n+                chunkable,\n+            )));\n         }\n         Ok(page_loader)\n     }"
        },
        {
            "sha": "34186c916e7ed6885289d17fa9203dcfc39b3ec6",
            "filename": "crates/next-api/src/server_actions.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 5,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/crates%2Fnext-api%2Fsrc%2Fserver_actions.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/crates%2Fnext-api%2Fsrc%2Fserver_actions.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fserver_actions.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -253,13 +253,12 @@ async fn parse_actions(module: Vc<Box<dyn Module>>) -> Result<Vc<OptionActionMap\n     };\n \n     if let Some(module) = Vc::try_resolve_downcast_type::<EcmascriptModulePartAsset>(module).await?\n-    {\n-        if matches!(\n+        && matches!(\n             module.await?.part,\n             ModulePart::Evaluation | ModulePart::Facade\n-        ) {\n-            return Ok(Vc::cell(None));\n-        }\n+        )\n+    {\n+        return Ok(Vc::cell(None));\n     }\n \n     let original_parsed = ecmascript_asset.parse_original().resolve().await?;"
        },
        {
            "sha": "1e3d8d9a5f6a60ae326948381448987b9998a2da",
            "filename": "crates/next-api/src/versioned_content_map.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 3,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/crates%2Fnext-api%2Fsrc%2Fversioned_content_map.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/crates%2Fnext-api%2Fsrc%2Fversioned_content_map.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fversioned_content_map.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -211,10 +211,9 @@ impl VersionedContentMap {\n             assets_operation: _,\n             path_to_asset,\n         }) = &*result\n+            && let Some(&asset) = path_to_asset.get(&path)\n         {\n-            if let Some(&asset) = path_to_asset.get(&path) {\n-                return Ok(Vc::cell(Some(asset)));\n-            }\n+            return Ok(Vc::cell(Some(asset)));\n         }\n \n         Ok(Vc::cell(None))"
        },
        {
            "sha": "4af16d79d56f958981e72914291e8246b1c3f4d6",
            "filename": "crates/next-core/src/app_structure.rs",
            "status": "modified",
            "additions": 31,
            "deletions": 32,
            "changes": 63,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/crates%2Fnext-core%2Fsrc%2Fapp_structure.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/crates%2Fnext-core%2Fsrc%2Fapp_structure.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fapp_structure.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -324,23 +324,23 @@ async fn get_directory_tree_internal(\n                 if basename.ends_with(\".d.ts\") {\n                     continue;\n                 }\n-                if let Some((stem, ext)) = basename.split_once('.') {\n-                    if page_extensions_value.iter().any(|e| e == ext) {\n-                        match stem {\n-                            \"page\" => modules.page = Some(file),\n-                            \"layout\" => modules.layout = Some(file),\n-                            \"error\" => modules.error = Some(file),\n-                            \"global-error\" => modules.global_error = Some(file),\n-                            \"global-not-found\" => modules.global_not_found = Some(file),\n-                            \"loading\" => modules.loading = Some(file),\n-                            \"template\" => modules.template = Some(file),\n-                            \"forbidden\" => modules.forbidden = Some(file),\n-                            \"unauthorized\" => modules.unauthorized = Some(file),\n-                            \"not-found\" => modules.not_found = Some(file),\n-                            \"default\" => modules.default = Some(file),\n-                            \"route\" => modules.route = Some(file),\n-                            _ => {}\n-                        }\n+                if let Some((stem, ext)) = basename.split_once('.')\n+                    && page_extensions_value.iter().any(|e| e == ext)\n+                {\n+                    match stem {\n+                        \"page\" => modules.page = Some(file),\n+                        \"layout\" => modules.layout = Some(file),\n+                        \"error\" => modules.error = Some(file),\n+                        \"global-error\" => modules.global_error = Some(file),\n+                        \"global-not-found\" => modules.global_not_found = Some(file),\n+                        \"loading\" => modules.loading = Some(file),\n+                        \"template\" => modules.template = Some(file),\n+                        \"forbidden\" => modules.forbidden = Some(file),\n+                        \"unauthorized\" => modules.unauthorized = Some(file),\n+                        \"not-found\" => modules.not_found = Some(file),\n+                        \"default\" => modules.default = Some(file),\n+                        \"route\" => modules.route = Some(file),\n+                        _ => {}\n                     }\n                 }\n \n@@ -834,18 +834,17 @@ async fn check_duplicate(\n ) -> Result<()> {\n     let page_path = page_path_except_parallel(loader_tree);\n \n-    if let Some(page_path) = page_path {\n-        if let Some(prev) = duplicate.insert(AppPath::from(page_path.clone()), page_path.clone()) {\n-            if prev != page_path {\n-                DuplicateParallelRouteIssue {\n-                    app_dir: app_dir.to_resolved().await?,\n-                    previously_inserted_page: prev.clone(),\n-                    page: loader_tree.page.clone(),\n-                }\n-                .resolved_cell()\n-                .emit();\n-            }\n+    if let Some(page_path) = page_path\n+        && let Some(prev) = duplicate.insert(AppPath::from(page_path.clone()), page_path.clone())\n+        && prev != page_path\n+    {\n+        DuplicateParallelRouteIssue {\n+            app_dir: app_dir.to_resolved().await?,\n+            previously_inserted_page: prev.clone(),\n+            page: loader_tree.page.clone(),\n         }\n+        .resolved_cell()\n+        .emit();\n     }\n \n     Ok(())\n@@ -1415,10 +1414,10 @@ async fn directory_tree_to_entrypoints_internal_untraced(\n             )\n             .await?;\n \n-            if let Some(illegal_path) = illegal_path {\n-                if !map.is_empty() {\n-                    return Err(illegal_path);\n-                }\n+            if let Some(illegal_path) = illegal_path\n+                && !map.is_empty()\n+            {\n+                return Err(illegal_path);\n             }\n \n             let mut loader_trees = Vec::new();"
        },
        {
            "sha": "5335d2532a49abf7f3f70c572d8238a24c9a7d26",
            "filename": "crates/next-core/src/next_font/google/options.rs",
            "status": "modified",
            "additions": 11,
            "deletions": 11,
            "changes": 22,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/crates%2Fnext-core%2Fsrc%2Fnext_font%2Fgoogle%2Foptions.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/crates%2Fnext-core%2Fsrc%2Fnext_font%2Fgoogle%2Foptions.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_font%2Fgoogle%2Foptions.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -182,18 +182,18 @@ pub(super) fn options_from_request(\n         )\n     }\n \n-    if let Some(axes) = argument.axes.as_ref() {\n-        if !axes.is_empty() {\n-            if !supports_variable_weight {\n-                anyhow::bail!(\"Axes can only be defined for variable fonts.\")\n-            }\n+    if let Some(axes) = argument.axes.as_ref()\n+        && !axes.is_empty()\n+    {\n+        if !supports_variable_weight {\n+            anyhow::bail!(\"Axes can only be defined for variable fonts.\")\n+        }\n \n-            if weights != FontWeights::Variable {\n-                anyhow::bail!(\n-                    \"Axes can only be defined for variable fonts when the weight property is \\\n-                     nonexistent or set to `variable`.\"\n-                )\n-            }\n+        if weights != FontWeights::Variable {\n+            anyhow::bail!(\n+                \"Axes can only be defined for variable fonts when the weight property is \\\n+                 nonexistent or set to `variable`.\"\n+            )\n         }\n     }\n "
        },
        {
            "sha": "1db384705027df291369de906683bab2b6d52c2b",
            "filename": "crates/next-core/src/next_font/google/util.rs",
            "status": "modified",
            "additions": 13,
            "deletions": 13,
            "changes": 26,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/crates%2Fnext-core%2Fsrc%2Fnext_font%2Fgoogle%2Futil.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/crates%2Fnext-core%2Fsrc%2Fnext_font%2Fgoogle%2Futil.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_font%2Fgoogle%2Futil.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -88,13 +88,13 @@ pub(super) fn get_font_axes(\n             for axis in defineable_axes {\n                 if axis.tag == \"wght\" {\n                     weight_axis = Some(format!(\"{}..{}\", axis.min, axis.max).into());\n-                } else if let Some(selected_variable_axes) = selected_variable_axes {\n-                    if selected_variable_axes.contains(&axis.tag) {\n-                        variable_axes.push((\n-                            axis.tag.clone(),\n-                            format!(\"{}..{}\", axis.min, axis.max).into(),\n-                        ));\n-                    }\n+                } else if let Some(selected_variable_axes) = selected_variable_axes\n+                    && selected_variable_axes.contains(&axis.tag)\n+                {\n+                    variable_axes.push((\n+                        axis.tag.clone(),\n+                        format!(\"{}..{}\", axis.min, axis.max).into(),\n+                    ));\n                 }\n             }\n \n@@ -168,13 +168,13 @@ pub(super) fn get_stylesheet_url(\n \n     if weights.is_empty() {\n         let mut variant = vec![];\n-        if let Some(variable_axes) = &axes.variable_axes {\n-            if !variable_axes.is_empty() {\n-                for (key, val) in variable_axes {\n-                    variant.push((key.as_str(), VariantValue::String(val.clone())));\n-                }\n-                variants.push(variant);\n+        if let Some(variable_axes) = &axes.variable_axes\n+            && !variable_axes.is_empty()\n+        {\n+            for (key, val) in variable_axes {\n+                variant.push((key.as_str(), VariantValue::String(val.clone())));\n             }\n+            variants.push(variant);\n         }\n     } else {\n         for wght in &weights {"
        },
        {
            "sha": "ff2b82188fadfd3b56770afb49e81f52a1c841e3",
            "filename": "crates/next-core/src/next_shared/transforms/next_page_static_info.rs",
            "status": "modified",
            "additions": 22,
            "deletions": 23,
            "changes": 45,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Ftransforms%2Fnext_page_static_info.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Ftransforms%2Fnext_page_static_info.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Ftransforms%2Fnext_page_static_info.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -96,33 +96,32 @@ impl CustomTransformer for NextPageStaticInfo {\n                 }\n             }\n \n-            if is_app_page {\n-                if let Some(Const::Value(Value::Object(config_obj))) = properties_to_extract.config\n-                {\n-                    let mut messages = vec![format!(\n-                        \"Page config in {} is deprecated. Replace `export const config=…` with \\\n-                         the following:\",\n-                        ctx.file_path_str\n-                    )];\n-\n-                    if let Some(runtime) = config_obj.get(\"runtime\") {\n-                        messages.push(format!(\"- `export const runtime = {runtime}`\"));\n-                    }\n+            if is_app_page\n+                && let Some(Const::Value(Value::Object(config_obj))) = properties_to_extract.config\n+            {\n+                let mut messages = vec![format!(\n+                    \"Page config in {} is deprecated. Replace `export const config=…` with the \\\n+                     following:\",\n+                    ctx.file_path_str\n+                )];\n+\n+                if let Some(runtime) = config_obj.get(\"runtime\") {\n+                    messages.push(format!(\"- `export const runtime = {runtime}`\"));\n+                }\n \n-                    if let Some(regions) = config_obj.get(\"regions\") {\n-                        messages.push(format!(\"- `export const preferredRegion = {regions}`\"));\n-                    }\n+                if let Some(regions) = config_obj.get(\"regions\") {\n+                    messages.push(format!(\"- `export const preferredRegion = {regions}`\"));\n+                }\n \n-                    messages.push(\"Visit https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config for more information.\".to_string());\n+                messages.push(\"Visit https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config for more information.\".to_string());\n \n-                    PageStaticInfoIssue {\n-                        file_path: ctx.file_path,\n-                        messages,\n-                        severity: IssueSeverity::Warning,\n-                    }\n-                    .resolved_cell()\n-                    .emit();\n+                PageStaticInfoIssue {\n+                    file_path: ctx.file_path,\n+                    messages,\n+                    severity: IssueSeverity::Warning,\n                 }\n+                .resolved_cell()\n+                .emit();\n             }\n \n             if collected_exports.directives.contains(&atom!(\"client\"))"
        },
        {
            "sha": "c1d776bdb543f10a02cbe5bcabff474e6eef9e5a",
            "filename": "crates/next-core/src/util.rs",
            "status": "modified",
            "additions": 82,
            "deletions": 88,
            "changes": 170,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/crates%2Fnext-core%2Fsrc%2Futil.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/crates%2Fnext-core%2Fsrc%2Futil.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Futil.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -435,112 +435,106 @@ pub async fn parse_config_from_source(\n     default_runtime: NextRuntime,\n ) -> Result<Vc<NextSourceConfig>> {\n     if let Some(ecmascript_asset) = ResolvedVc::try_sidecast::<Box<dyn EcmascriptParsable>>(module)\n-    {\n-        if let ParseResult::Ok {\n+        && let ParseResult::Ok {\n             program: Program::Module(module_ast),\n             globals,\n             eval_context,\n             ..\n         } = &*ecmascript_asset.parse_original().await?\n-        {\n-            for item in &module_ast.body {\n-                if let Some(decl) = item\n-                    .as_module_decl()\n-                    .and_then(|mod_decl| mod_decl.as_export_decl())\n-                    .and_then(|export_decl| export_decl.decl.as_var())\n-                {\n-                    for decl in &decl.decls {\n-                        let decl_ident = decl.name.as_ident();\n-\n-                        // Check if there is exported config object `export const config = {...}`\n-                        // https://nextjs.org/docs/app/building-your-application/routing/middleware#matcher\n-                        if decl_ident\n-                            .map(|ident| &*ident.sym == \"config\")\n-                            .unwrap_or_default()\n-                        {\n-                            if let Some(init) = decl.init.as_ref() {\n-                                return WrapFuture::new(\n-                                    async {\n-                                        let value = eval_context.eval(init);\n-                                        Ok(parse_config_from_js_value(\n-                                            *module,\n-                                            &value,\n-                                            default_runtime,\n-                                        )\n+    {\n+        for item in &module_ast.body {\n+            if let Some(decl) = item\n+                .as_module_decl()\n+                .and_then(|mod_decl| mod_decl.as_export_decl())\n+                .and_then(|export_decl| export_decl.decl.as_var())\n+            {\n+                for decl in &decl.decls {\n+                    let decl_ident = decl.name.as_ident();\n+\n+                    // Check if there is exported config object `export const config = {...}`\n+                    // https://nextjs.org/docs/app/building-your-application/routing/middleware#matcher\n+                    if decl_ident\n+                        .map(|ident| &*ident.sym == \"config\")\n+                        .unwrap_or_default()\n+                    {\n+                        if let Some(init) = decl.init.as_ref() {\n+                            return WrapFuture::new(\n+                                async {\n+                                    let value = eval_context.eval(init);\n+                                    Ok(parse_config_from_js_value(*module, &value, default_runtime)\n                                         .await?\n                                         .cell())\n-                                    },\n-                                    |f, ctx| GLOBALS.set(globals, || f.poll(ctx)),\n-                                )\n-                                .await;\n-                            } else {\n-                                NextSourceConfigParsingIssue::new(\n-                                    module.ident(),\n-                                    StyledString::Text(\n-                                        \"The exported config object must contain an variable \\\n-                                         initializer.\"\n-                                            .into(),\n-                                    )\n-                                    .cell(),\n-                                )\n-                                .to_resolved()\n-                                .await?\n-                                .emit();\n-                            }\n-                        }\n-                        // Or, check if there is segment runtime option\n-                        // https://nextjs.org/docs/app/building-your-application/rendering/edge-and-nodejs-runtimes#segment-runtime-Option\n-                        else if decl_ident\n-                            .map(|ident| &*ident.sym == \"runtime\")\n-                            .unwrap_or_default()\n-                        {\n-                            let runtime_value_issue = NextSourceConfigParsingIssue::new(\n+                                },\n+                                |f, ctx| GLOBALS.set(globals, || f.poll(ctx)),\n+                            )\n+                            .await;\n+                        } else {\n+                            NextSourceConfigParsingIssue::new(\n                                 module.ident(),\n                                 StyledString::Text(\n-                                    \"The runtime property must be either \\\"nodejs\\\" or \\\"edge\\\".\"\n+                                    \"The exported config object must contain an variable \\\n+                                     initializer.\"\n                                         .into(),\n                                 )\n                                 .cell(),\n                             )\n                             .to_resolved()\n-                            .await?;\n-                            if let Some(init) = decl.init.as_ref() {\n-                                // skipping eval and directly read the expr's value, as we know it\n-                                // should be a const string\n-                                if let Expr::Lit(Lit::Str(str_value)) = &**init {\n-                                    let mut config = NextSourceConfig::default();\n-\n-                                    let runtime = str_value.value.to_string();\n-                                    match runtime.as_str() {\n-                                        \"edge\" | \"experimental-edge\" => {\n-                                            config.runtime = NextRuntime::Edge;\n-                                        }\n-                                        \"nodejs\" => {\n-                                            config.runtime = NextRuntime::NodeJs;\n-                                        }\n-                                        _ => {\n-                                            runtime_value_issue.emit();\n-                                        }\n+                            .await?\n+                            .emit();\n+                        }\n+                    }\n+                    // Or, check if there is segment runtime option\n+                    // https://nextjs.org/docs/app/building-your-application/rendering/edge-and-nodejs-runtimes#segment-runtime-Option\n+                    else if decl_ident\n+                        .map(|ident| &*ident.sym == \"runtime\")\n+                        .unwrap_or_default()\n+                    {\n+                        let runtime_value_issue = NextSourceConfigParsingIssue::new(\n+                            module.ident(),\n+                            StyledString::Text(\n+                                \"The runtime property must be either \\\"nodejs\\\" or \\\"edge\\\".\"\n+                                    .into(),\n+                            )\n+                            .cell(),\n+                        )\n+                        .to_resolved()\n+                        .await?;\n+                        if let Some(init) = decl.init.as_ref() {\n+                            // skipping eval and directly read the expr's value, as we know it\n+                            // should be a const string\n+                            if let Expr::Lit(Lit::Str(str_value)) = &**init {\n+                                let mut config = NextSourceConfig::default();\n+\n+                                let runtime = str_value.value.to_string();\n+                                match runtime.as_str() {\n+                                    \"edge\" | \"experimental-edge\" => {\n+                                        config.runtime = NextRuntime::Edge;\n+                                    }\n+                                    \"nodejs\" => {\n+                                        config.runtime = NextRuntime::NodeJs;\n+                                    }\n+                                    _ => {\n+                                        runtime_value_issue.emit();\n                                     }\n-\n-                                    return Ok(config.cell());\n-                                } else {\n-                                    runtime_value_issue.emit();\n                                 }\n+\n+                                return Ok(config.cell());\n                             } else {\n-                                NextSourceConfigParsingIssue::new(\n-                                    module.ident(),\n-                                    StyledString::Text(\n-                                        \"The exported segment runtime option must contain an \\\n-                                         variable initializer.\"\n-                                            .into(),\n-                                    )\n-                                    .cell(),\n-                                )\n-                                .to_resolved()\n-                                .await?\n-                                .emit();\n+                                runtime_value_issue.emit();\n                             }\n+                        } else {\n+                            NextSourceConfigParsingIssue::new(\n+                                module.ident(),\n+                                StyledString::Text(\n+                                    \"The exported segment runtime option must contain an variable \\\n+                                     initializer.\"\n+                                        .into(),\n+                                )\n+                                .cell(),\n+                            )\n+                            .to_resolved()\n+                            .await?\n+                            .emit();\n                         }\n                     }\n                 }"
        },
        {
            "sha": "506aba1aaff629cc62505abcbddc665a6f243b4c",
            "filename": "rust-toolchain.toml",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/rust-toolchain.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/rust-toolchain.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/rust-toolchain.toml?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -1,4 +1,4 @@\n [toolchain]\n-channel = \"nightly-2025-05-12\"\n+channel = \"nightly-2025-06-04\"\n components = [\"rustfmt\", \"clippy\", \"rust-analyzer\"]\n profile = \"minimal\""
        },
        {
            "sha": "13d426b9971e48fa62f241d29bbbd79c3295d9da",
            "filename": "turbopack/crates/turbo-persistence/src/db.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fdb.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fdb.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fdb.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -417,12 +417,12 @@ impl TurboPersistence {\n             );\n         }\n         let current = self.inner.read().current_sequence_number;\n-        if let Some((ty, any)) = self.idle_write_batch.lock().take() {\n-            if ty == TypeId::of::<WriteBatch<K, FAMILIES>>() {\n-                let mut write_batch = *any.downcast::<WriteBatch<K, FAMILIES>>().unwrap();\n-                write_batch.reset(current);\n-                return Ok(write_batch);\n-            }\n+        if let Some((ty, any)) = self.idle_write_batch.lock().take()\n+            && ty == TypeId::of::<WriteBatch<K, FAMILIES>>()\n+        {\n+            let mut write_batch = *any.downcast::<WriteBatch<K, FAMILIES>>().unwrap();\n+            write_batch.reset(current);\n+            return Ok(write_batch);\n         }\n         Ok(WriteBatch::new(self.path.clone(), current))\n     }"
        },
        {
            "sha": "05d540496526ff00eb86f563111a0f3244122ef6",
            "filename": "turbopack/crates/turbo-persistence/src/static_sorted_file_builder.rs",
            "status": "modified",
            "additions": 15,
            "deletions": 16,
            "changes": 31,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fstatic_sorted_file_builder.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fstatic_sorted_file_builder.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fstatic_sorted_file_builder.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -165,22 +165,21 @@ impl StaticSortedFileBuilder {\n             let entry = &entries[i];\n             let value_remaining = value_compression_samples_size - value_samples.len();\n             let key_remaining = key_compression_samples_size - key_samples.len();\n-            if value_remaining > 0 {\n-                if let EntryValue::Small { value } | EntryValue::Medium { value } = entry.value() {\n-                    let value = if value.len() <= COMPRESSION_DICTIONARY_SAMPLE_PER_ENTRY {\n-                        value\n-                    } else {\n-                        j = (j + 12345678)\n-                            % (value.len() - COMPRESSION_DICTIONARY_SAMPLE_PER_ENTRY);\n-                        &value[j..j + COMPRESSION_DICTIONARY_SAMPLE_PER_ENTRY]\n-                    };\n-                    if value.len() <= value_remaining {\n-                        value_sample_sizes.push(value.len());\n-                        value_samples.extend_from_slice(value);\n-                    } else {\n-                        value_sample_sizes.push(value_remaining);\n-                        value_samples.extend_from_slice(&value[..value_remaining]);\n-                    }\n+            if value_remaining > 0\n+                && let EntryValue::Small { value } | EntryValue::Medium { value } = entry.value()\n+            {\n+                let value = if value.len() <= COMPRESSION_DICTIONARY_SAMPLE_PER_ENTRY {\n+                    value\n+                } else {\n+                    j = (j + 12345678) % (value.len() - COMPRESSION_DICTIONARY_SAMPLE_PER_ENTRY);\n+                    &value[j..j + COMPRESSION_DICTIONARY_SAMPLE_PER_ENTRY]\n+                };\n+                if value.len() <= value_remaining {\n+                    value_sample_sizes.push(value.len());\n+                    value_samples.extend_from_slice(value);\n+                } else {\n+                    value_sample_sizes.push(value_remaining);\n+                    value_samples.extend_from_slice(&value[..value_remaining]);\n                 }\n             }\n             if key_remaining > 0 {"
        },
        {
            "sha": "a4c687056c6de704b7027040b7c0b2edb37aab67",
            "filename": "turbopack/crates/turbo-persistence/src/write_batch.rs",
            "status": "modified",
            "additions": 8,
            "deletions": 8,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fwrite_batch.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fwrite_batch.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fwrite_batch.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -250,10 +250,10 @@ impl<K: StoreKey + Send + Sync, const FAMILIES: usize> WriteBatch<K, FAMILIES> {\n         let mut collectors = Vec::new();\n         for cell in self.thread_locals.iter() {\n             let state = unsafe { &mut *cell.get() };\n-            if let Some(collector) = state.collectors[usize_from_u32(family)].take() {\n-                if !collector.is_empty() {\n-                    collectors.push(collector);\n-                }\n+            if let Some(collector) = state.collectors[usize_from_u32(family)].take()\n+                && !collector.is_empty()\n+            {\n+                collectors.push(collector);\n             }\n         }\n \n@@ -313,10 +313,10 @@ impl<K: StoreKey + Send + Sync, const FAMILIES: usize> WriteBatch<K, FAMILIES> {\n                 let state = cell.get_mut();\n                 new_blob_files.append(&mut state.new_blob_files);\n                 for (family, thread_local_collector) in state.collectors.iter_mut().enumerate() {\n-                    if let Some(collector) = thread_local_collector.take() {\n-                        if !collector.is_empty() {\n-                            collectors[family].push(collector);\n-                        }\n+                    if let Some(collector) = thread_local_collector.take()\n+                        && !collector.is_empty()\n+                    {\n+                        collectors[family].push(collector);\n                     }\n                 }\n             }"
        },
        {
            "sha": "e6b260c9e65fa2fccc3d22892b8f4f8f1cc11f2c",
            "filename": "turbopack/crates/turbo-static/src/visitor.rs",
            "status": "modified",
            "additions": 9,
            "deletions": 10,
            "changes": 19,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbo-static%2Fsrc%2Fvisitor.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbo-static%2Fsrc%2Fvisitor.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-static%2Fsrc%2Fvisitor.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -215,16 +215,15 @@ impl Visit<'_> for CallingStyleVisitor {\n \n     fn visit_expr_call(&mut self, i: &'_ syn::ExprCall) {\n         syn::visit::visit_expr_call(self, i);\n-        if let Expr::Path(p) = i.func.as_ref() {\n-            if let Some(last) = p.path.segments.last() {\n-                if is_match(\n-                    &self.reference.identifier,\n-                    &last.ident,\n-                    &self.reference.references,\n-                ) {\n-                    self.halt = true;\n-                }\n-            }\n+        if let Expr::Path(p) = i.func.as_ref()\n+            && let Some(last) = p.path.segments.last()\n+            && is_match(\n+                &self.reference.identifier,\n+                &last.ident,\n+                &self.reference.references,\n+            )\n+        {\n+            self.halt = true;\n         }\n     }\n "
        },
        {
            "sha": "6bd41d33f002f87fad2e245f21c22eca2555c8b0",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 36,
            "deletions": 37,
            "changes": 73,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -578,24 +578,24 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                     )))\n                 }\n             };\n-            if self.should_track_dependencies() {\n-                if let Some(reader) = reader {\n-                    let _ = task.add(CachedDataItem::OutputDependent {\n-                        task: reader,\n+            if self.should_track_dependencies()\n+                && let Some(reader) = reader\n+            {\n+                let _ = task.add(CachedDataItem::OutputDependent {\n+                    task: reader,\n+                    value: (),\n+                });\n+                drop(task);\n+\n+                let mut reader_task = ctx.task(reader, TaskDataCategory::Data);\n+                if reader_task\n+                    .remove(&CachedDataItemKey::OutdatedOutputDependency { target: task_id })\n+                    .is_none()\n+                {\n+                    let _ = reader_task.add(CachedDataItem::OutputDependency {\n+                        target: task_id,\n                         value: (),\n                     });\n-                    drop(task);\n-\n-                    let mut reader_task = ctx.task(reader, TaskDataCategory::Data);\n-                    if reader_task\n-                        .remove(&CachedDataItemKey::OutdatedOutputDependency { target: task_id })\n-                        .is_none()\n-                    {\n-                        let _ = reader_task.add(CachedDataItem::OutputDependency {\n-                            target: task_id,\n-                            value: (),\n-                        });\n-                    }\n                 }\n             }\n \n@@ -786,15 +786,16 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         if let Some(task_type) = self.task_cache.lookup_reverse(&task_id) {\n             return Some(task_type);\n         }\n-        if self.should_restore() && !task_id.is_transient() {\n-            if let Some(task_type) = unsafe {\n+        if self.should_restore()\n+            && !task_id.is_transient()\n+            && let Some(task_type) = unsafe {\n                 self.backing_storage\n                     .reverse_lookup_task_cache(None, task_id)\n                     .expect(\"Failed to lookup task type\")\n-            } {\n-                let _ = self.task_cache.try_insert(task_type.clone(), task_id);\n-                return Some(task_type);\n             }\n+        {\n+            let _ = self.task_cache.try_insert(task_type.clone(), task_id);\n+            return Some(task_type);\n         }\n         None\n     }\n@@ -1701,16 +1702,14 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                         if cell_counters\n                             .get(&cell.type_id)\n                             .is_none_or(|start_index| cell.index >= *start_index)\n+                            && let Some(old_counter) = old_counters.get(&cell.type_id)\n+                            && cell.index < *old_counter\n                         {\n-                            if let Some(old_counter) = old_counters.get(&cell.type_id) {\n-                                if cell.index < *old_counter {\n-                                    return Some(OutdatedEdge::RemovedCellDependent {\n-                                        task_id: task,\n-                                        #[cfg(feature = \"trace_task_dirty\")]\n-                                        value_type_id: cell.type_id,\n-                                    });\n-                                }\n-                            }\n+                            return Some(OutdatedEdge::RemovedCellDependent {\n+                                task_id: task,\n+                                #[cfg(feature = \"trace_task_dirty\")]\n+                                value_type_id: cell.type_id,\n+                            });\n                         }\n                         None\n                     },\n@@ -1867,13 +1866,13 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                     (Some(old), Some(new)) => dirty_containers.replace_dirty_state(&old, &new),\n                 };\n                 if !aggregated_update.is_zero() {\n-                    if aggregated_update.get(self.session_id) < 0 {\n-                        if let Some(root_state) = get_mut!(task, Activeness) {\n-                            root_state.all_clean_event.notify(usize::MAX);\n-                            root_state.unset_active_until_clean();\n-                            if root_state.is_empty() {\n-                                task.remove(&CachedDataItemKey::Activeness {});\n-                            }\n+                    if aggregated_update.get(self.session_id) < 0\n+                        && let Some(root_state) = get_mut!(task, Activeness)\n+                    {\n+                        root_state.all_clean_event.notify(usize::MAX);\n+                        root_state.unset_active_until_clean();\n+                        if root_state.is_empty() {\n+                            task.remove(&CachedDataItemKey::Activeness {});\n                         }\n                     }\n                     AggregationUpdateJob::data_update("
        },
        {
            "sha": "eb998f8ee9a6835688ff0c57749c20824c51495b",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/aggregation_update.rs",
            "status": "modified",
            "additions": 10,
            "deletions": 10,
            "changes": 20,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Faggregation_update.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Faggregation_update.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Faggregation_update.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -338,16 +338,16 @@ impl AggregatedDataUpdate {\n                     }\n                     (!new.is_zero()).then_some(new)\n                 });\n-                if let Some((_, count)) = result.dirty_container_update.as_ref() {\n-                    if count.get(session_id) < 0 {\n-                        // When the current task is no longer dirty, we need to fire the\n-                        // aggregate root events and do some cleanup\n-                        if let Some(root_state) = get_mut!(task, Activeness) {\n-                            root_state.all_clean_event.notify(usize::MAX);\n-                            root_state.unset_active_until_clean();\n-                            if root_state.is_empty() {\n-                                task.remove(&CachedDataItemKey::Activeness {});\n-                            }\n+                if let Some((_, count)) = result.dirty_container_update.as_ref()\n+                    && count.get(session_id) < 0\n+                {\n+                    // When the current task is no longer dirty, we need to fire the\n+                    // aggregate root events and do some cleanup\n+                    if let Some(root_state) = get_mut!(task, Activeness) {\n+                        root_state.all_clean_event.notify(usize::MAX);\n+                        root_state.unset_active_until_clean();\n+                        if root_state.is_empty() {\n+                            task.remove(&CachedDataItemKey::Activeness {});\n                         }\n                     }\n                 }"
        },
        {
            "sha": "30f1f2fcc3bfaa883a3811116477e1a7dbb9e40b",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/invalidate.rs",
            "status": "modified",
            "additions": 12,
            "deletions": 14,
            "changes": 26,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Finvalidate.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Finvalidate.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Finvalidate.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -197,21 +197,19 @@ pub fn make_task_dirty_internal(\n     queue: &mut AggregationUpdateQueue,\n     ctx: &impl ExecuteContext,\n ) {\n-    if make_stale {\n-        if let Some(InProgressState::InProgress(box InProgressStateInner { stale, .. })) =\n+    if make_stale\n+        && let Some(InProgressState::InProgress(box InProgressStateInner { stale, .. })) =\n             get_mut!(task, InProgress)\n-        {\n-            if !*stale {\n-                #[cfg(feature = \"trace_task_dirty\")]\n-                let _span = tracing::trace_span!(\n-                    \"make task stale\",\n-                    name = ctx.get_task_description(task_id),\n-                    cause = %TaskDirtyCauseInContext::new(&cause, ctx)\n-                )\n-                .entered();\n-                *stale = true;\n-            }\n-        }\n+        && !*stale\n+    {\n+        #[cfg(feature = \"trace_task_dirty\")]\n+        let _span = tracing::trace_span!(\n+            \"make task stale\",\n+            name = ctx.get_task_description(task_id),\n+            cause = %TaskDirtyCauseInContext::new(&cause, ctx)\n+        )\n+        .entered();\n+        *stale = true;\n     }\n     let old = task.insert(CachedDataItem::Dirty {\n         value: DirtyState {"
        },
        {
            "sha": "e18d00529d158afed0f49b8bc5a2e5dc818a03d3",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/update_output.rs",
            "status": "modified",
            "additions": 11,
            "deletions": 11,
            "changes": 22,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fupdate_output.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fupdate_output.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fupdate_output.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -69,10 +69,10 @@ impl UpdateOutputOperation {\n         let current_output = get!(task, Output);\n         let output_value = match output {\n             Ok(RawVc::TaskOutput(output_task_id)) => {\n-                if let Some(OutputValue::Output(current_task_id)) = current_output {\n-                    if *current_task_id == output_task_id {\n-                        return;\n-                    }\n+                if let Some(OutputValue::Output(current_task_id)) = current_output\n+                    && *current_task_id == output_task_id\n+                {\n+                    return;\n                 }\n                 OutputValue::Output(output_task_id)\n             }\n@@ -81,10 +81,10 @@ impl UpdateOutputOperation {\n                     task: current_task_id,\n                     cell: current_cell,\n                 })) = current_output\n+                    && *current_task_id == output_task_id\n+                    && *current_cell == cell\n                 {\n-                    if *current_task_id == output_task_id && *current_cell == cell {\n-                        return;\n-                    }\n+                    return;\n                 }\n                 OutputValue::Cell(CellRef {\n                     task: output_task_id,\n@@ -95,10 +95,10 @@ impl UpdateOutputOperation {\n                 panic!(\"Non-local tasks must not return a local Vc\");\n             }\n             Err(err) => {\n-                if let Some(OutputValue::Error(old_error)) = current_output {\n-                    if old_error == &err {\n-                        return;\n-                    }\n+                if let Some(OutputValue::Error(old_error)) = current_output\n+                    && old_error == &err\n+                {\n+                    return;\n                 }\n                 OutputValue::Error(err)\n             }"
        },
        {
            "sha": "ceb368f03ff92b808d754de7421ce8cde305b3d5",
            "filename": "turbopack/crates/turbo-tasks-backend/src/data.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdata.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdata.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdata.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -176,10 +176,10 @@ impl DirtyContainerCount {\n     /// Get the count for a specific session. It's only expected to be asked for the current\n     /// session, since old session counts might be dropped.\n     pub fn get(&self, session: SessionId) -> i32 {\n-        if let Some((s, count)) = self.count_in_session {\n-            if s == session {\n-                return count;\n-            }\n+        if let Some((s, count)) = self.count_in_session\n+            && s == session\n+        {\n+            return count;\n         }\n         self.count\n     }"
        },
        {
            "sha": "26b27644c32a4517693c15760358a3113033c250",
            "filename": "turbopack/crates/turbo-tasks-backend/src/data_storage.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdata_storage.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdata_storage.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdata_storage.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -104,10 +104,10 @@ impl<V> Storage for OptionStorage<V> {\n     where\n         F: for<'a, 'b> FnMut(&'a Self::K, &'b mut Self::V) -> bool + 'l,\n     {\n-        if let Some(value) = self.value.as_mut() {\n-            if f(&(), value) {\n-                return self.value.take().map(|v| ((), v)).into_iter();\n-            }\n+        if let Some(value) = self.value.as_mut()\n+            && f(&(), value)\n+        {\n+            return self.value.take().map(|v| ((), v)).into_iter();\n         }\n         None.into_iter()\n     }"
        },
        {
            "sha": "8230a328ccd8022e458d4b722f78f9029b5e6b78",
            "filename": "turbopack/crates/turbo-tasks-backend/src/utils/chunked_vec.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Futils%2Fchunked_vec.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Futils%2Fchunked_vec.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Futils%2Fchunked_vec.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -24,11 +24,11 @@ impl<T> ChunkedVec<T> {\n     }\n \n     pub fn push(&mut self, item: T) {\n-        if let Some(chunk) = self.chunks.last_mut() {\n-            if chunk.len() < chunk.capacity() {\n-                chunk.push(item);\n-                return;\n-            }\n+        if let Some(chunk) = self.chunks.last_mut()\n+            && chunk.len() < chunk.capacity()\n+        {\n+            chunk.push(item);\n+            return;\n         }\n         let mut chunk = Vec::with_capacity(chunk_size(self.chunks.len()));\n         chunk.push(item);"
        },
        {
            "sha": "768a445b184197dbbbc13ac97cbf43ee2c507aed",
            "filename": "turbopack/crates/turbo-tasks-fs/src/lib.rs",
            "status": "modified",
            "additions": 24,
            "deletions": 28,
            "changes": 52,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -759,16 +759,14 @@ impl FileSystem for DiskFileSystem {\n             match &*content {\n                 FileContent::Content(..) => {\n                     let create_directory = compare == FileComparison::Create;\n-                    if create_directory {\n-                        if let Some(parent) = full_path.parent() {\n-                            inner.create_directory(parent).await.with_context(|| {\n-                                format!(\n-                                    \"failed to create directory {} for write to {}\",\n-                                    parent.display(),\n-                                    full_path.display()\n-                                )\n-                            })?;\n-                        }\n+                    if create_directory && let Some(parent) = full_path.parent() {\n+                        inner.create_directory(parent).await.with_context(|| {\n+                            format!(\n+                                \"failed to create directory {} for write to {}\",\n+                                parent.display(),\n+                                full_path.display()\n+                            )\n+                        })?;\n                     }\n \n                     let full_path_to_write = full_path.clone();\n@@ -893,16 +891,14 @@ impl FileSystem for DiskFileSystem {\n             match &*content {\n                 LinkContent::Link { target, link_type } => {\n                     let create_directory = old_content.is_none();\n-                    if create_directory {\n-                        if let Some(parent) = full_path.parent() {\n-                            inner.create_directory(parent).await.with_context(|| {\n-                                format!(\n-                                    \"failed to create directory {} for write link to {}\",\n-                                    parent.display(),\n-                                    full_path.display()\n-                                )\n-                            })?;\n-                        }\n+                    if create_directory && let Some(parent) = full_path.parent() {\n+                        inner.create_directory(parent).await.with_context(|| {\n+                            format!(\n+                                \"failed to create directory {} for write link to {}\",\n+                                parent.display(),\n+                                full_path.display()\n+                            )\n+                        })?;\n                     }\n \n                     let link_type = *link_type;\n@@ -1254,14 +1250,14 @@ impl FileSystemPath {\n     /// None when the joined path would leave the current path.\n     #[turbo_tasks::function]\n     pub async fn try_join_inside(&self, path: RcStr) -> Result<Vc<FileSystemPathOption>> {\n-        if let Some(path) = join_path(&self.path, &path) {\n-            if path.starts_with(&*self.path) {\n-                return Ok(Vc::cell(Some(\n-                    Self::new_normalized(*self.fs, path.into())\n-                        .to_resolved()\n-                        .await?,\n-                )));\n-            }\n+        if let Some(path) = join_path(&self.path, &path)\n+            && path.starts_with(&*self.path)\n+        {\n+            return Ok(Vc::cell(Some(\n+                Self::new_normalized(*self.fs, path.into())\n+                    .to_resolved()\n+                    .await?,\n+            )));\n         }\n         Ok(FileSystemPathOption::none())\n     }"
        },
        {
            "sha": "7bd96f14aac3d0639c4e79c43d7ad9b15793ce95",
            "filename": "turbopack/crates/turbo-tasks-fs/src/watcher.rs",
            "status": "modified",
            "additions": 9,
            "deletions": 9,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fwatcher.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fwatcher.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fwatcher.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -118,10 +118,10 @@ impl DiskWatcher {\n         // https://github.com/notify-rs/notify/pull/611, it seems like there's still some case where\n         // it can occur with inotify on Linux.\n         fn map_notify_err(mut err: notify::Error) -> notify::Error {\n-            if let notify::ErrorKind::Io(io_err) = &err.kind {\n-                if io_err.kind() == std::io::ErrorKind::NotFound {\n-                    err.kind = notify::ErrorKind::PathNotFound;\n-                }\n+            if let notify::ErrorKind::Io(io_err) = &err.kind\n+                && io_err.kind() == std::io::ErrorKind::NotFound\n+            {\n+                err.kind = notify::ErrorKind::PathNotFound;\n             }\n             err\n         }\n@@ -544,11 +544,11 @@ fn invalidate(\n     path: &Path,\n     invalidator: Invalidator,\n ) {\n-    if report_invalidation_reason {\n-        if let Some(path) = format_absolute_fs_path(path, &inner.name, inner.root_path()) {\n-            invalidator.invalidate_with_reason(WatchChange { path });\n-            return;\n-        }\n+    if report_invalidation_reason\n+        && let Some(path) = format_absolute_fs_path(path, &inner.name, inner.root_path())\n+    {\n+        invalidator.invalidate_with_reason(WatchChange { path });\n+        return;\n     }\n     invalidator.invalidate();\n }"
        },
        {
            "sha": "3ff4aa3d477caf6c4552a5b67e0dee2b19719868",
            "filename": "turbopack/crates/turbo-tasks-macros-shared/src/self_filter.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbo-tasks-macros-shared%2Fsrc%2Fself_filter.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbo-tasks-macros-shared%2Fsrc%2Fself_filter.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros-shared%2Fsrc%2Fself_filter.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -26,11 +26,11 @@ impl Visit<'_> for SelfFinder {\n             return;\n         }\n \n-        if let syn::Expr::Path(path) = expr {\n-            if path.path.is_ident(\"self\") {\n-                self.found = true;\n-                return;\n-            }\n+        if let syn::Expr::Path(path) = expr\n+            && path.path.is_ident(\"self\")\n+        {\n+            self.found = true;\n+            return;\n         }\n \n         visit_expr(self, expr);"
        },
        {
            "sha": "fc036cac6a3abc5b57583bdc2f20a99dad561d39",
            "filename": "turbopack/crates/turbo-tasks-macros/src/func.rs",
            "status": "modified",
            "additions": 9,
            "deletions": 10,
            "changes": 19,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Ffunc.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Ffunc.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Ffunc.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -855,17 +855,16 @@ fn expand_task_input_type(orig_input: &Type) -> Cow<'_, Type> {\n                     if let PathArguments::AngleBracketed(\n                         bracketed_args @ AngleBracketedGenericArguments { args, .. },\n                     ) = &last_segment.arguments\n+                        && let Some(GenericArgument::Type(first_arg)) = args.first()\n                     {\n-                        if let Some(GenericArgument::Type(first_arg)) = args.first() {\n-                            match expand_task_input_type(first_arg) {\n-                                Cow::Borrowed(_) => {} // was not transformed\n-                                Cow::Owned(first_arg) => {\n-                                    let mut bracketed_args = bracketed_args.clone();\n-                                    *bracketed_args.args.first_mut().expect(\"non-empty\") =\n-                                        GenericArgument::Type(first_arg);\n-                                    segments.to_mut().last_mut().expect(\"non-empty\").arguments =\n-                                        PathArguments::AngleBracketed(bracketed_args);\n-                                }\n+                        match expand_task_input_type(first_arg) {\n+                            Cow::Borrowed(_) => {} // was not transformed\n+                            Cow::Owned(first_arg) => {\n+                                let mut bracketed_args = bracketed_args.clone();\n+                                *bracketed_args.args.first_mut().expect(\"non-empty\") =\n+                                    GenericArgument::Type(first_arg);\n+                                segments.to_mut().last_mut().expect(\"non-empty\").arguments =\n+                                    PathArguments::AngleBracketed(bracketed_args);\n                             }\n                         }\n                     }"
        },
        {
            "sha": "7954144209b22a67ce47992d0975eb992f022ce0",
            "filename": "turbopack/crates/turbo-tasks-macros/src/generic_type_macro.rs",
            "status": "modified",
            "additions": 11,
            "deletions": 12,
            "changes": 23,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fgeneric_type_macro.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fgeneric_type_macro.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fgeneric_type_macro.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -111,18 +111,17 @@ struct ReplaceGenericsVisitor<'a> {\n \n impl VisitMut for ReplaceGenericsVisitor<'_> {\n     fn visit_type_mut(&mut self, node: &mut Type) {\n-        if let Type::Path(type_path) = node {\n-            if type_path.qself.is_none()\n-                && type_path.path.segments.len() == 1\n-                && type_path.path.segments[0].arguments.is_none()\n-                && self\n-                    .generics\n-                    .contains(&type_path.path.segments[0].ident.to_string())\n-            {\n-                // Replace the whole path with ()\n-                *node = syn::parse_quote! { () };\n-                return;\n-            }\n+        if let Type::Path(type_path) = node\n+            && type_path.qself.is_none()\n+            && type_path.path.segments.len() == 1\n+            && type_path.path.segments[0].arguments.is_none()\n+            && self\n+                .generics\n+                .contains(&type_path.path.segments[0].ident.to_string())\n+        {\n+            // Replace the whole path with ()\n+            *node = syn::parse_quote! { () };\n+            return;\n         }\n \n         syn::visit_mut::visit_type_mut(self, node);"
        },
        {
            "sha": "505a7057250caa6aff76aac273a17d9b863f87ca",
            "filename": "turbopack/crates/turbo-tasks-macros/src/value_macro.rs",
            "status": "modified",
            "additions": 29,
            "deletions": 31,
            "changes": 60,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_macro.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_macro.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_macro.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -230,38 +230,36 @@ pub fn value(args: TokenStream, input: TokenStream) -> TokenStream {\n             fields: Fields::Unnamed(FieldsUnnamed { unnamed, .. }),\n             ..\n         }) = &mut item\n+            && unnamed.len() == 1\n         {\n-            if unnamed.len() == 1 {\n-                let field = unnamed.iter().next().unwrap();\n-                inner_type = Some(field.ty.clone());\n-\n-                // generate a type string to add to the docs\n-                let inner_type_string = inner_type.to_token_stream().to_string();\n-\n-                // HACK: proc_macro2 inserts whitespace between every token. It's ugly, so\n-                // remove it, assuming these whitespace aren't syntatically important. Using\n-                // prettyplease (or similar) would be more correct, but slower and add another\n-                // dependency.\n-                static WHITESPACE_RE: OnceLock<Regex> = OnceLock::new();\n-                // Remove whitespace, as long as there is a non-word character (e.g. `>` or `,`)\n-                // on either side. Try not to remove whitespace between `dyn Trait`.\n-                let whitespace_re = WHITESPACE_RE.get_or_init(|| {\n-                    Regex::new(r\"\\b \\B|\\B \\b|\\B \\B\").expect(\"WHITESPACE_RE is valid\")\n-                });\n-                let inner_type_string = whitespace_re.replace_all(&inner_type_string, \"\");\n-\n-                // Add a couple blank lines in case there's already a doc comment we're\n-                // effectively appending to. If there's not, rustdoc will strip\n-                // the leading whitespace.\n-                let doc_str = format!(\n-                    \"\\n\\nThis is a [transparent value type][turbo_tasks::value#transparent] \\\n-                     wrapping [`{inner_type_string}`].\",\n-                );\n-\n-                attrs.push(parse_quote! {\n-                    #[doc = #doc_str]\n-                });\n-            }\n+            let field = unnamed.iter().next().unwrap();\n+            inner_type = Some(field.ty.clone());\n+\n+            // generate a type string to add to the docs\n+            let inner_type_string = inner_type.to_token_stream().to_string();\n+\n+            // HACK: proc_macro2 inserts whitespace between every token. It's ugly, so\n+            // remove it, assuming these whitespace aren't syntatically important. Using\n+            // prettyplease (or similar) would be more correct, but slower and add another\n+            // dependency.\n+            static WHITESPACE_RE: OnceLock<Regex> = OnceLock::new();\n+            // Remove whitespace, as long as there is a non-word character (e.g. `>` or `,`)\n+            // on either side. Try not to remove whitespace between `dyn Trait`.\n+            let whitespace_re = WHITESPACE_RE\n+                .get_or_init(|| Regex::new(r\"\\b \\B|\\B \\b|\\B \\B\").expect(\"WHITESPACE_RE is valid\"));\n+            let inner_type_string = whitespace_re.replace_all(&inner_type_string, \"\");\n+\n+            // Add a couple blank lines in case there's already a doc comment we're\n+            // effectively appending to. If there's not, rustdoc will strip\n+            // the leading whitespace.\n+            let doc_str = format!(\n+                \"\\n\\nThis is a [transparent value type][turbo_tasks::value#transparent] wrapping \\\n+                 [`{inner_type_string}`].\",\n+            );\n+\n+            attrs.push(parse_quote! {\n+                #[doc = #doc_str]\n+            });\n         }\n         if inner_type.is_none() {\n             item.span()"
        },
        {
            "sha": "d5e05b27f83234c65e21e8c26bb71254a85fd81b",
            "filename": "turbopack/crates/turbo-tasks/src/lib.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -31,7 +31,6 @@\n #![feature(thread_local)]\n #![feature(try_trait_v2)]\n #![deny(unsafe_op_in_unsafe_fn)]\n-#![feature(result_flattening)]\n #![feature(error_generic_member_access)]\n #![feature(arbitrary_self_types)]\n #![feature(arbitrary_self_types_pointers)]"
        },
        {
            "sha": "3c499c1fe4466a8e7c1ab2c693507bac60be1d34",
            "filename": "turbopack/crates/turbo-tasks/src/manager.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -1926,10 +1926,10 @@ impl CurrentCellRef {\n         T: PartialEq + VcValueType,\n     {\n         self.conditional_update(|old_value| {\n-            if let Some(old_value) = old_value {\n-                if old_value == &new_value {\n-                    return None;\n-                }\n+            if let Some(old_value) = old_value\n+                && old_value == &new_value\n+            {\n+                return None;\n             }\n             Some(new_value)\n         });"
        },
        {
            "sha": "4b998baa29e1a9f0b54d0c80f7000f3374008063",
            "filename": "turbopack/crates/turbopack-cli-utils/src/issue.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-cli-utils%2Fsrc%2Fissue.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-cli-utils%2Fsrc%2Fissue.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-cli-utils%2Fsrc%2Fissue.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -79,12 +79,12 @@ fn severity_to_style(severity: IssueSeverity) -> Style {\n }\n \n fn format_source_content(source: &PlainIssueSource, formatted_issue: &mut String) {\n-    if let FileLinesContent::Lines(lines) = source.asset.content.lines_ref() {\n-        if let Some((start, end)) = source.range {\n-            let lines = lines.iter().map(|l| l.content.as_str());\n-            let ctx = get_source_context(lines, start.line, start.column, end.line, end.column);\n-            format_source_context_lines(&ctx, formatted_issue);\n-        }\n+    if let FileLinesContent::Lines(lines) = source.asset.content.lines_ref()\n+        && let Some((start, end)) = source.range\n+    {\n+        let lines = lines.iter().map(|l| l.content.as_str());\n+        let ctx = get_source_context(lines, start.line, start.column, end.line, end.column);\n+        format_source_context_lines(&ctx, formatted_issue);\n     }\n }\n "
        },
        {
            "sha": "dba8271089e80350311a74b9052eaafc2fa55d62",
            "filename": "turbopack/crates/turbopack-cli/src/dev/mod.rs",
            "status": "modified",
            "additions": 24,
            "deletions": 23,
            "changes": 47,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fdev%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fdev%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fdev%2Fmod.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -159,29 +159,30 @@ impl TurbopackDevServerBuilder {\n             let addr = SocketAddr::new(host, current_port);\n             let listen_result = DevServer::listen(addr);\n \n-            if let Err(e) = &listen_result {\n-                if self.allow_retry && attempts < max_attempts {\n-                    // Returned error from `listen` is not `std::io::Error` but `anyhow::Error`,\n-                    // so we need to access its source to check if it is\n-                    // `std::io::ErrorKind::AddrInUse`.\n-                    let should_retry = e\n-                        .source()\n-                        .and_then(|e| {\n-                            e.downcast_ref::<std::io::Error>()\n-                                .map(|e| e.kind() == std::io::ErrorKind::AddrInUse)\n-                        })\n-                        .unwrap_or(false);\n-\n-                    if should_retry {\n-                        println!(\n-                            \"{} - Port {} is in use, trying {} instead\",\n-                            \"warn \".yellow(),\n-                            current_port,\n-                            current_port + 1\n-                        );\n-                        attempts += 1;\n-                        continue;\n-                    }\n+            if let Err(e) = &listen_result\n+                && self.allow_retry\n+                && attempts < max_attempts\n+            {\n+                // Returned error from `listen` is not `std::io::Error` but `anyhow::Error`,\n+                // so we need to access its source to check if it is\n+                // `std::io::ErrorKind::AddrInUse`.\n+                let should_retry = e\n+                    .source()\n+                    .and_then(|e| {\n+                        e.downcast_ref::<std::io::Error>()\n+                            .map(|e| e.kind() == std::io::ErrorKind::AddrInUse)\n+                    })\n+                    .unwrap_or(false);\n+\n+                if should_retry {\n+                    println!(\n+                        \"{} - Port {} is in use, trying {} instead\",\n+                        \"warn \".yellow(),\n+                        current_port,\n+                        current_port + 1\n+                    );\n+                    attempts += 1;\n+                    continue;\n                 }\n             }\n "
        },
        {
            "sha": "472f289a22ed04c33d54e3d94bdd60d1af0c8b85",
            "filename": "turbopack/crates/turbopack-core/src/ident.rs",
            "status": "modified",
            "additions": 8,
            "deletions": 8,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fident.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fident.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fident.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -274,10 +274,10 @@ impl AssetIdent {\n             has_hash = true;\n         }\n         for modifier in modifiers.iter() {\n-            if let Some(default_modifier) = default_modifier {\n-                if *modifier == default_modifier {\n-                    continue;\n-                }\n+            if let Some(default_modifier) = default_modifier\n+                && *modifier == default_modifier\n+            {\n+                continue;\n             }\n             3_u8.deterministic_hash(&mut hasher);\n             modifier.deterministic_hash(&mut hasher);\n@@ -349,10 +349,10 @@ impl AssetIdent {\n         const MAX_FILENAME: usize = 80;\n         if name.len() - i > MAX_FILENAME {\n             i = name.len() - MAX_FILENAME;\n-            if let Some(j) = name[i..].find('_') {\n-                if j < 20 {\n-                    i += j + 1;\n-                }\n+            if let Some(j) = name[i..].find('_')\n+                && j < 20\n+            {\n+                i += j + 1;\n             }\n         }\n         if i > 0 {"
        },
        {
            "sha": "f8b539be2c6ad55ea185b94d1120f6f3fb46d873",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/module_batches.rs",
            "status": "modified",
            "additions": 28,
            "deletions": 31,
            "changes": 59,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmodule_batches.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmodule_batches.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmodule_batches.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -590,19 +590,17 @@ pub async fn compute_module_batches(\n                         &pre_batches,\n                         batches_with_item_index[0].0,\n                         batches_with_item_index[0].1 + selected_items,\n-                    ) {\n-                        if parallel_module_to_pre_batch.get(next_module).unwrap().len()\n-                            == batches.len()\n-                            && batches_with_item_index[1..]\n-                                .iter()\n-                                .all(|&(batch_idx, item_idx)| {\n-                                    get_item_at(&pre_batches, batch_idx, item_idx + selected_items)\n-                                        == Some(&PreBatchItem::ParallelModule(*next_module))\n-                                })\n-                        {\n-                            selected_items += 1;\n-                            continue;\n-                        }\n+                    ) && parallel_module_to_pre_batch.get(next_module).unwrap().len()\n+                        == batches.len()\n+                        && batches_with_item_index[1..]\n+                            .iter()\n+                            .all(|&(batch_idx, item_idx)| {\n+                                get_item_at(&pre_batches, batch_idx, item_idx + selected_items)\n+                                    == Some(&PreBatchItem::ParallelModule(*next_module))\n+                            })\n+                    {\n+                        selected_items += 1;\n+                        continue;\n                     }\n                     break;\n                 }\n@@ -867,19 +865,18 @@ pub async fn compute_module_batches(\n                         );\n                     }\n                     PreBatchItem::NonParallelEdge(ty, module) => {\n-                        if let Some(chunkable_module) = ResolvedVc::try_downcast(module) {\n-                            if let Some(batch) = pre_batches.entries.get(&chunkable_module).copied()\n-                            {\n-                                graph.add_edge(\n-                                    index,\n-                                    batch_indicies[batch],\n-                                    ModuleBatchesGraphEdge {\n-                                        ty,\n-                                        module: Some(module),\n-                                    },\n-                                );\n-                                continue;\n-                            }\n+                        if let Some(chunkable_module) = ResolvedVc::try_downcast(module)\n+                            && let Some(batch) = pre_batches.entries.get(&chunkable_module).copied()\n+                        {\n+                            graph.add_edge(\n+                                index,\n+                                batch_indicies[batch],\n+                                ModuleBatchesGraphEdge {\n+                                    ty,\n+                                    module: Some(module),\n+                                },\n+                            );\n+                            continue;\n                         }\n                         let idx = pre_batches\n                             .single_module_entries\n@@ -907,11 +904,11 @@ pub async fn compute_module_batches(\n         let mut entries = FxHashMap::default();\n         for chunk_group in &chunk_group_info.chunk_groups {\n             for module in chunk_group.entries() {\n-                if let Some(chunkable_module) = ResolvedVc::try_downcast(module) {\n-                    if let Some(batch) = pre_batches.entries.get(&chunkable_module).copied() {\n-                        entries.insert(module, batch_indicies[batch]);\n-                        continue;\n-                    }\n+                if let Some(chunkable_module) = ResolvedVc::try_downcast(module)\n+                    && let Some(batch) = pre_batches.entries.get(&chunkable_module).copied()\n+                {\n+                    entries.insert(module, batch_indicies[batch]);\n+                    continue;\n                 }\n                 let idx = pre_batches\n                     .single_module_entries"
        },
        {
            "sha": "0e03cb2c4b7936c0c790d0d09108afbae1677eb1",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/style_groups.rs",
            "status": "modified",
            "additions": 14,
            "deletions": 14,
            "changes": 28,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fstyle_groups.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fstyle_groups.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fstyle_groups.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -97,10 +97,10 @@ pub async fn compute_style_groups(\n             entries.iter().copied(),\n             &mut (),\n             |parent_info, module, _| {\n-                if let Some((_, ModuleBatchesGraphEdge { ty, .. })) = parent_info {\n-                    if !ty.is_parallel() {\n-                        return Ok(GraphTraversalAction::Exclude);\n-                    }\n+                if let Some((_, ModuleBatchesGraphEdge { ty, .. })) = parent_info\n+                    && !ty.is_parallel()\n+                {\n+                    return Ok(GraphTraversalAction::Exclude);\n                 }\n                 if visited.insert(module) {\n                     Ok(GraphTraversalAction::Continue)\n@@ -109,10 +109,10 @@ pub async fn compute_style_groups(\n                 }\n             },\n             |parent_info, item, _| {\n-                if let Some((_, ModuleBatchesGraphEdge { ty, .. })) = parent_info {\n-                    if !ty.is_parallel() {\n-                        return;\n-                    }\n+                if let Some((_, ModuleBatchesGraphEdge { ty, .. })) = parent_info\n+                    && !ty.is_parallel()\n+                {\n+                    return;\n                 }\n                 items_in_postorder.insert(*item);\n             },\n@@ -315,12 +315,12 @@ pub async fn compute_style_groups(\n                     continue;\n                 }\n                 // In loose mode we only check if the dependencies are not violated\n-                if let Some(dependents) = module_dependents.get(&module) {\n-                    if dependents.iter().any(|m| new_chunk_modules.contains(m)) {\n-                        // A dependent of the module is already in the chunk, which would violate\n-                        // the order\n-                        continue;\n-                    }\n+                if let Some(dependents) = module_dependents.get(&module)\n+                    && dependents.iter().any(|m| new_chunk_modules.contains(m))\n+                {\n+                    // A dependent of the module is already in the chunk, which would violate\n+                    // the order\n+                    continue;\n                 }\n \n                 // Global CSS must not leak into unrelated chunks"
        },
        {
            "sha": "c3883b280ed70a88a230aac1a3d3b293bd76aba2",
            "filename": "turbopack/crates/turbopack-core/src/reference/mod.rs",
            "status": "modified",
            "additions": 12,
            "deletions": 13,
            "changes": 25,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Freference%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Freference%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Freference%2Fmod.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -291,21 +291,20 @@ pub async fn primary_chunkable_referenced_modules(\n         .map(|reference| async {\n             if let Some(reference) =\n                 ResolvedVc::try_downcast::<Box<dyn ChunkableModuleReference>>(*reference)\n+                && let Some(chunking_type) = &*reference.chunking_type().await?\n             {\n-                if let Some(chunking_type) = &*reference.chunking_type().await? {\n-                    if !include_traced && matches!(chunking_type, ChunkingType::Traced) {\n-                        return Ok(None);\n-                    }\n-\n-                    let resolved = reference\n-                        .resolve_reference()\n-                        .resolve()\n-                        .await?\n-                        .primary_modules()\n-                        .owned()\n-                        .await?;\n-                    return Ok(Some((chunking_type.clone(), resolved)));\n+                if !include_traced && matches!(chunking_type, ChunkingType::Traced) {\n+                    return Ok(None);\n                 }\n+\n+                let resolved = reference\n+                    .resolve_reference()\n+                    .resolve()\n+                    .await?\n+                    .primary_modules()\n+                    .owned()\n+                    .await?;\n+                return Ok(Some((chunking_type.clone(), resolved)));\n             }\n             Ok(None)\n         })"
        },
        {
            "sha": "8c91ce18ed58b945790b948191f23d6bc70b2a9a",
            "filename": "turbopack/crates/turbopack-core/src/reference/source_map.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Freference%2Fsource_map.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Freference%2Fsource_map.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Freference%2Fsource_map.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -30,10 +30,10 @@ impl SourceMapReference {\n impl SourceMapReference {\n     async fn get_file(&self) -> Option<Vc<FileSystemPath>> {\n         let file_type = self.file.get_type().await;\n-        if let Ok(file_type_result) = file_type.as_ref() {\n-            if let FileSystemEntryType::File = &**file_type_result {\n-                return Some(*self.file);\n-            }\n+        if let Ok(file_type_result) = file_type.as_ref()\n+            && let FileSystemEntryType::File = &**file_type_result\n+        {\n+            return Some(*self.file);\n         }\n         None\n     }"
        },
        {
            "sha": "ff8665b6e891281440bebe46e5f14bf1f0908b30",
            "filename": "turbopack/crates/turbopack-core/src/reference_type.rs",
            "status": "modified",
            "additions": 12,
            "deletions": 12,
            "changes": 24,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Freference_type.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Freference_type.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Freference_type.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -133,30 +133,30 @@ impl ImportContext {\n \n         let layers = {\n             let mut layers = this.layers.clone();\n-            if let Some(attr_layer) = attr_layer {\n-                if !layers.contains(&attr_layer) {\n-                    layers.push(attr_layer);\n-                }\n+            if let Some(attr_layer) = attr_layer\n+                && !layers.contains(&attr_layer)\n+            {\n+                layers.push(attr_layer);\n             }\n             layers\n         };\n \n         let media = {\n             let mut media = this.media.clone();\n-            if let Some(attr_media) = attr_media {\n-                if !media.contains(&attr_media) {\n-                    media.push(attr_media);\n-                }\n+            if let Some(attr_media) = attr_media\n+                && !media.contains(&attr_media)\n+            {\n+                media.push(attr_media);\n             }\n             media\n         };\n \n         let supports = {\n             let mut supports = this.supports.clone();\n-            if let Some(attr_supports) = attr_supports {\n-                if !supports.contains(&attr_supports) {\n-                    supports.push(attr_supports);\n-                }\n+            if let Some(attr_supports) = attr_supports\n+                && !supports.contains(&attr_supports)\n+            {\n+                supports.push(attr_supports);\n             }\n             supports\n         };"
        },
        {
            "sha": "34a7475688eb932f9a8ef4eaa0f02c15ae54659a",
            "filename": "turbopack/crates/turbopack-core/src/resolve/mod.rs",
            "status": "modified",
            "additions": 83,
            "deletions": 88,
            "changes": 171,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fmod.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -1327,12 +1327,11 @@ pub async fn find_context_file_or_package_key(\n ) -> Result<Vc<FindContextFileResult>> {\n     let mut refs = Vec::new();\n     let package_json_path = lookup_path.join(rcstr!(\"package.json\"));\n-    if let Some(package_json_path) = exists(package_json_path, &mut refs).await? {\n-        if let Some(json) = &*read_package_json(*package_json_path).await? {\n-            if json.get(&**package_key).is_some() {\n-                return Ok(FindContextFileResult::Found(package_json_path, refs).into());\n-            }\n-        }\n+    if let Some(package_json_path) = exists(package_json_path, &mut refs).await?\n+        && let Some(json) = &*read_package_json(*package_json_path).await?\n+        && json.get(&**package_key).is_some()\n+    {\n+        return Ok(FindContextFileResult::Found(package_json_path, refs).into());\n     }\n     for name in &*names.await? {\n         let fs_path = lookup_path.join(name.clone());\n@@ -1695,13 +1694,12 @@ async fn handle_after_resolve_plugins(\n     ) -> Result<Option<Vc<ResolveResult>>> {\n         for plugin in &options.await?.after_resolve_plugins {\n             let after_resolve_condition = plugin.after_resolve_condition().resolve().await?;\n-            if *after_resolve_condition.matches(path).await? {\n-                if let Some(result) = *plugin\n+            if *after_resolve_condition.matches(path).await?\n+                && let Some(result) = *plugin\n                     .after_resolve(path, lookup_path, reference_type.clone(), request)\n                     .await?\n-                {\n-                    return Ok(Some(*result));\n-                }\n+            {\n+                return Ok(Some(*result));\n             }\n         }\n         Ok(None)\n@@ -1804,10 +1802,10 @@ async fn resolve_internal_inline(\n                     // would also match a request to \"@emotion/core\". Here, we follow what the\n                     // Typescript resolution algorithm does in case an alias match\n                     // doesn't resolve to anything: fall back to resolving the request normally.\n-                    if let Some(result) = resolved_result {\n-                        if !*result.is_unresolvable().await? {\n-                            return Ok(result);\n-                        }\n+                    if let Some(result) = resolved_result\n+                        && !*result.is_unresolvable().await?\n+                    {\n+                        return Ok(result);\n                     }\n                 }\n             }\n@@ -1873,8 +1871,8 @@ async fn resolve_internal_inline(\n                 force_in_lookup_dir,\n                 fragment,\n             } => {\n-                if !fragment.is_empty() {\n-                    if let Ok(result) = resolve_relative_request(\n+                if !fragment.is_empty()\n+                    && let Ok(result) = resolve_relative_request(\n                         lookup_path,\n                         request,\n                         options,\n@@ -1885,9 +1883,8 @@ async fn resolve_internal_inline(\n                         fragment.clone(),\n                     )\n                     .await\n-                    {\n-                        return Ok(result);\n-                    }\n+                {\n+                    return Ok(result);\n                 }\n                 // Resolve without fragment\n                 resolve_relative_request(\n@@ -2069,23 +2066,23 @@ async fn resolve_internal_inline(\n         };\n \n         // Apply fallback import mappings if provided\n-        if let Some(import_map) = &options_value.fallback_import_map {\n-            if *result.is_unresolvable().await? {\n-                let result = import_map.await?.lookup(lookup_path, request).await?;\n-                let resolved_result = resolve_import_map_result(\n-                    &result,\n-                    lookup_path,\n-                    lookup_path,\n-                    request,\n-                    options,\n-                    request.query().owned().await?,\n-                )\n-                .await?;\n-                if let Some(result) = resolved_result {\n-                    if !*result.is_unresolvable().await? {\n-                        return Ok(result);\n-                    }\n-                }\n+        if let Some(import_map) = &options_value.fallback_import_map\n+            && *result.is_unresolvable().await?\n+        {\n+            let result = import_map.await?.lookup(lookup_path, request).await?;\n+            let resolved_result = resolve_import_map_result(\n+                &result,\n+                lookup_path,\n+                lookup_path,\n+                request,\n+                options,\n+                request.query().owned().await?,\n+            )\n+            .await?;\n+            if let Some(result) = resolved_result\n+                && !*result.is_unresolvable().await?\n+            {\n+                return Ok(result);\n             }\n         }\n \n@@ -2106,38 +2103,38 @@ async fn resolve_into_folder(\n     for resolve_into_package in options_value.into_package.iter() {\n         match resolve_into_package {\n             ResolveIntoPackage::MainField { field: name } => {\n-                if let Some(package_json) = &*read_package_json(package_json_path).await? {\n-                    if let Some(field_value) = package_json[name.as_str()].as_str() {\n-                        let normalized_request: RcStr = normalize_request(field_value).into();\n-                        if normalized_request.is_empty()\n-                            || &*normalized_request == \".\"\n-                            || &*normalized_request == \"./\"\n-                        {\n-                            continue;\n-                        }\n-                        let request = Request::parse(Value::new(normalized_request.into()))\n-                            .to_resolved()\n-                            .await?;\n+                if let Some(package_json) = &*read_package_json(package_json_path).await?\n+                    && let Some(field_value) = package_json[name.as_str()].as_str()\n+                {\n+                    let normalized_request: RcStr = normalize_request(field_value).into();\n+                    if normalized_request.is_empty()\n+                        || &*normalized_request == \".\"\n+                        || &*normalized_request == \"./\"\n+                    {\n+                        continue;\n+                    }\n+                    let request = Request::parse(Value::new(normalized_request.into()))\n+                        .to_resolved()\n+                        .await?;\n \n-                        // main field will always resolve not fully specified\n-                        let options = if options_value.fully_specified {\n-                            options.with_fully_specified(false).resolve().await?\n-                        } else {\n-                            options\n-                        };\n-                        let result = &*resolve_internal_inline(*package_path, *request, options)\n-                            .await?\n-                            .await?;\n-                        // we are not that strict when a main field fails to resolve\n-                        // we continue to try other alternatives\n-                        if !result.is_unresolvable_ref() {\n-                            let mut result: ResolveResultBuilder =\n-                                result.with_request_ref(rcstr!(\".\")).into();\n-                            result.affecting_sources.push(ResolvedVc::upcast(\n-                                FileSource::new(package_json_path).to_resolved().await?,\n-                            ));\n-                            return Ok(ResolveResult::from(result).cell());\n-                        }\n+                    // main field will always resolve not fully specified\n+                    let options = if options_value.fully_specified {\n+                        options.with_fully_specified(false).resolve().await?\n+                    } else {\n+                        options\n+                    };\n+                    let result = &*resolve_internal_inline(*package_path, *request, options)\n+                        .await?\n+                        .await?;\n+                    // we are not that strict when a main field fails to resolve\n+                    // we continue to try other alternatives\n+                    if !result.is_unresolvable_ref() {\n+                        let mut result: ResolveResultBuilder =\n+                            result.with_request_ref(rcstr!(\".\")).into();\n+                        result.affecting_sources.push(ResolvedVc::upcast(\n+                            FileSource::new(package_json_path).to_resolved().await?,\n+                        ));\n+                        return Ok(ResolveResult::from(result).cell());\n                     }\n                 };\n             }\n@@ -2490,16 +2487,15 @@ async fn find_self_reference(\n     let package_json_context = find_context_file(lookup_path, package_json()).await?;\n     if let FindContextFileResult::Found(package_json_path, _refs) = &*package_json_context {\n         let read = read_package_json(**package_json_path).await?;\n-        if let Some(json) = &*read {\n-            if json.get(\"exports\").is_some() {\n-                if let Some(name) = json[\"name\"].as_str() {\n-                    return Ok(FindSelfReferencePackageResult::Found {\n-                        name: name.to_string(),\n-                        package_path: package_json_path.parent().to_resolved().await?,\n-                    }\n-                    .cell());\n-                }\n+        if let Some(json) = &*read\n+            && json.get(\"exports\").is_some()\n+            && let Some(name) = json[\"name\"].as_str()\n+        {\n+            return Ok(FindSelfReferencePackageResult::Found {\n+                name: name.to_string(),\n+                package_path: package_json_path.parent().to_resolved().await?,\n             }\n+            .cell());\n         }\n     }\n     Ok(FindSelfReferencePackageResult::NotFound.cell())\n@@ -2538,18 +2534,17 @@ async fn resolve_module_request(\n     // fields/fallbacks.\n     if let FindSelfReferencePackageResult::Found { name, package_path } =\n         &*find_self_reference(lookup_path).await?\n+        && name == module\n     {\n-        if name == module {\n-            let result = resolve_into_package(\n-                Value::new(path.clone()),\n-                **package_path,\n-                query.clone(),\n-                fragment.clone(),\n-                options,\n-            );\n-            if !(*result.is_unresolvable().await?) {\n-                return Ok(result);\n-            }\n+        let result = resolve_into_package(\n+            Value::new(path.clone()),\n+            **package_path,\n+            query.clone(),\n+            fragment.clone(),\n+            options,\n+        );\n+        if !(*result.is_unresolvable().await?) {\n+            return Ok(result);\n         }\n     }\n "
        },
        {
            "sha": "a040f819989b6801979f6390e68f250b55949432",
            "filename": "turbopack/crates/turbopack-core/src/resolve/options.rs",
            "status": "modified",
            "additions": 10,
            "deletions": 10,
            "changes": 20,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Foptions.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Foptions.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Foptions.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -556,16 +556,16 @@ impl ResolvedMap {\n         let resolved = resolved.await?;\n         for (root, glob, mapping) in self.by_glob.iter() {\n             let root = root.await?;\n-            if let Some(path) = root.get_path_to(&resolved) {\n-                if glob.await?.matches(path) {\n-                    return Ok(import_mapping_to_result(\n-                        *mapping.convert().await?,\n-                        lookup_path,\n-                        request,\n-                    )\n-                    .await?\n-                    .into());\n-                }\n+            if let Some(path) = root.get_path_to(&resolved)\n+                && glob.await?.matches(path)\n+            {\n+                return Ok(import_mapping_to_result(\n+                    *mapping.convert().await?,\n+                    lookup_path,\n+                    request,\n+                )\n+                .await?\n+                .into());\n             }\n         }\n         Ok(ImportMapResult::NoEntry.into())"
        },
        {
            "sha": "cd46256be7dc086c33400312cde1444fae01a14c",
            "filename": "turbopack/crates/turbopack-core/src/resolve/parse.rs",
            "status": "modified",
            "additions": 19,
            "deletions": 19,
            "changes": 38,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fparse.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fparse.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fparse.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -202,27 +202,27 @@ impl Request {\n             });\n         }\n \n-        if let Some(caps) = URI_PATH.captures(&r) {\n-            if let (Some(protocol), Some(remainder)) = (caps.get(1), caps.get(2)) {\n-                if let Some(caps) = DATA_URI_REMAINDER.captures(remainder.as_str()) {\n-                    let media_type = caps.get(1).map_or(\"\", |m| m.as_str()).into();\n-                    let encoding = caps.get(2).map_or(\"\", |e| e.as_str()).into();\n-                    let data = caps.get(3).map_or(\"\", |d| d.as_str()).into();\n-\n-                    return Ok(Request::DataUri {\n-                        media_type,\n-                        encoding,\n-                        data: ResolvedVc::cell(data),\n-                    });\n-                }\n-\n-                return Ok(Request::Uri {\n-                    protocol: protocol.as_str().into(),\n-                    remainder: remainder.as_str().into(),\n-                    query: RcStr::default(),\n-                    fragment: RcStr::default(),\n+        if let Some(caps) = URI_PATH.captures(&r)\n+            && let (Some(protocol), Some(remainder)) = (caps.get(1), caps.get(2))\n+        {\n+            if let Some(caps) = DATA_URI_REMAINDER.captures(remainder.as_str()) {\n+                let media_type = caps.get(1).map_or(\"\", |m| m.as_str()).into();\n+                let encoding = caps.get(2).map_or(\"\", |e| e.as_str()).into();\n+                let data = caps.get(3).map_or(\"\", |d| d.as_str()).into();\n+\n+                return Ok(Request::DataUri {\n+                    media_type,\n+                    encoding,\n+                    data: ResolvedVc::cell(data),\n                 });\n             }\n+\n+            return Ok(Request::Uri {\n+                protocol: protocol.as_str().into(),\n+                remainder: remainder.as_str().into(),\n+                query: RcStr::default(),\n+                fragment: RcStr::default(),\n+            });\n         }\n \n         if let Some((module, path)) = MODULE_PATH"
        },
        {
            "sha": "280ff2f1890a9d74f86059c52554574da1a17767",
            "filename": "turbopack/crates/turbopack-core/src/resolve/pattern.rs",
            "status": "modified",
            "additions": 21,
            "deletions": 29,
            "changes": 50,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fpattern.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fpattern.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fpattern.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -31,13 +31,13 @@ pub enum Pattern {\n }\n \n fn concatenation_push_or_merge_item(list: &mut Vec<Pattern>, pat: Pattern) {\n-    if let Pattern::Constant(ref s) = pat {\n-        if let Some(Pattern::Constant(last)) = list.last_mut() {\n-            let mut buf = last.to_string();\n-            buf.push_str(s);\n-            *last = buf.into();\n-            return;\n-        }\n+    if let Pattern::Constant(ref s) = pat\n+        && let Some(Pattern::Constant(last)) = list.last_mut()\n+    {\n+        let mut buf = last.to_string();\n+        buf.push_str(s);\n+        *last = buf.into();\n+        return;\n     }\n     list.push(pat);\n }\n@@ -959,10 +959,10 @@ impl Pattern {\n                         }\n                     }\n                 }\n-                if let Some(offset) = any_offset {\n-                    if offset == value.len() {\n-                        dynamics.push_back(value);\n-                    }\n+                if let Some(offset) = any_offset\n+                    && offset == value.len()\n+                {\n+                    dynamics.push_back(value);\n                 }\n                 MatchResult::Consumed {\n                     remaining: value,\n@@ -1648,33 +1648,25 @@ pub async fn read_matches(\n                                         lookup_dir.join(key.clone()).to_resolved().await?;\n                                     if let LinkContent::Link { link_type, .. } =\n                                         &*fs_path.read_link().await?\n+                                        && link_type.contains(LinkType::DIRECTORY)\n                                     {\n-                                        if link_type.contains(LinkType::DIRECTORY) {\n-                                            results.push((\n-                                                pos,\n-                                                PatternMatch::Directory(\n-                                                    prefix.clone().into(),\n-                                                    fs_path,\n-                                                ),\n-                                            ));\n-                                        }\n+                                        results.push((\n+                                            pos,\n+                                            PatternMatch::Directory(prefix.clone().into(), fs_path),\n+                                        ));\n                                     }\n                                 }\n                                 if let Some(pos) = pat.could_match_position(&prefix) {\n                                     let fs_path =\n                                         lookup_dir.join(key.clone()).to_resolved().await?;\n                                     if let LinkContent::Link { link_type, .. } =\n                                         &*fs_path.read_link().await?\n+                                        && link_type.contains(LinkType::DIRECTORY)\n                                     {\n-                                        if link_type.contains(LinkType::DIRECTORY) {\n-                                            results.push((\n-                                                pos,\n-                                                PatternMatch::Directory(\n-                                                    prefix.clone().into(),\n-                                                    fs_path,\n-                                                ),\n-                                            ));\n-                                        }\n+                                        results.push((\n+                                            pos,\n+                                            PatternMatch::Directory(prefix.clone().into(), fs_path),\n+                                        ));\n                                     }\n                                 }\n                                 prefix.truncate(len)"
        },
        {
            "sha": "e013e0c945ffc3048b5f125c4db42dc7bf7489c2",
            "filename": "turbopack/crates/turbopack-core/src/resolve/plugin.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fplugin.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fplugin.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fplugin.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -30,10 +30,10 @@ impl AfterResolvePluginCondition {\n \n         let path = fs_path.await?;\n \n-        if let Some(path) = root.get_path_to(&path) {\n-            if glob.matches(path) {\n-                return Ok(Vc::cell(true));\n-            }\n+        if let Some(path) = root.get_path_to(&path)\n+            && glob.matches(path)\n+        {\n+            return Ok(Vc::cell(true));\n         }\n \n         Ok(Vc::cell(false))"
        },
        {
            "sha": "c79a6698710fc26e6001ab775ee158aa666ab78d",
            "filename": "turbopack/crates/turbopack-core/src/source_map/mod.rs",
            "status": "modified",
            "additions": 21,
            "deletions": 21,
            "changes": 42,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fsource_map%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fsource_map%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fsource_map%2Fmod.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -314,11 +314,12 @@ impl SourceMap {\n         let mut sections = sections.into_iter().peekable();\n \n         let mut first = sections.next();\n-        if let Some((offset, map)) = &mut first {\n-            if sections.peek().is_none() && *offset == (0, 0) {\n-                // There is just a single sourcemap that starts at the beginning of the file.\n-                return Ok(std::mem::take(map));\n-            }\n+        if let Some((offset, map)) = &mut first\n+            && sections.peek().is_none()\n+            && *offset == (0, 0)\n+        {\n+            // There is just a single sourcemap that starts at the beginning of the file.\n+            return Ok(std::mem::take(map));\n         }\n \n         // My kingdom for a decent dedent macro with interpolation!\n@@ -569,27 +570,26 @@ impl SourceMap {\n                     guessed_original_file,\n                     ..\n                 }) = &mut token\n+                    && let DecodedMap::Regular(map) = &map.map.0\n+                    && map.get_source_count() == 1\n                 {\n-                    if let DecodedMap::Regular(map) = &map.map.0 {\n-                        if map.get_source_count() == 1 {\n-                            let source = map.sources().next().unwrap();\n-                            *guessed_original_file = Some(RcStr::from(source));\n-                        }\n-                    }\n+                    let source = map.sources().next().unwrap();\n+                    *guessed_original_file = Some(RcStr::from(source));\n                 }\n \n-                if need_source_content && content.is_none() {\n-                    if let Some(map) = map.map.as_regular_source_map() {\n-                        content = tok.and_then(|tok| {\n-                            let src_id = tok.get_src_id();\n+                if need_source_content\n+                    && content.is_none()\n+                    && let Some(map) = map.map.as_regular_source_map()\n+                {\n+                    content = tok.and_then(|tok| {\n+                        let src_id = tok.get_src_id();\n \n-                            let name = map.get_source(src_id);\n-                            let content = map.get_source_contents(src_id);\n+                        let name = map.get_source(src_id);\n+                        let content = map.get_source_contents(src_id);\n \n-                            let (name, content) = name.zip(content)?;\n-                            Some(sourcemap_content_source(name.into(), content.into()))\n-                        });\n-                    }\n+                        let (name, content) = name.zip(content)?;\n+                        Some(sourcemap_content_source(name.into(), content.into()))\n+                    });\n                 }\n \n                 token"
        },
        {
            "sha": "9f43260931db55bf484db2d41ce0dcac43718bf2",
            "filename": "turbopack/crates/turbopack-core/src/source_map/utils.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fsource_map%2Futils.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fsource_map%2Futils.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fsource_map%2Futils.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -176,10 +176,10 @@ pub async fn fileify_source_map(\n     let prefix = format!(\"{}///[{}]/\", SOURCE_URL_PROTOCOL, context_fs.name());\n \n     let transform_source = async |src: &mut Option<String>| {\n-        if let Some(src) = src {\n-            if let Some(src_rest) = src.strip_prefix(&prefix) {\n-                *src = uri_from_file(context_path, Some(src_rest)).await?;\n-            }\n+        if let Some(src) = src\n+            && let Some(src_rest) = src.strip_prefix(&prefix)\n+        {\n+            *src = uri_from_file(context_path, Some(src_rest)).await?;\n         }\n         anyhow::Ok(())\n     };"
        },
        {
            "sha": "039723ed6fa22c95de27900ea3b9762e284f7880",
            "filename": "turbopack/crates/turbopack-css/src/references/url.rs",
            "status": "modified",
            "additions": 10,
            "deletions": 11,
            "changes": 21,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Freferences%2Furl.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Freferences%2Furl.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Freferences%2Furl.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -54,17 +54,16 @@ impl UrlAssetReference {\n         self: Vc<Self>,\n         chunking_context: Vc<Box<dyn ChunkingContext>>,\n     ) -> Result<Vc<ReferencedAsset>> {\n-        if let Some(module) = *self.resolve_reference().first_module().await? {\n-            if let Some(embeddable) = Vc::try_resolve_downcast::<Box<dyn CssEmbed>>(*module).await?\n-            {\n-                return Ok(ReferencedAsset::Some(\n-                    embeddable\n-                        .embedded_asset(chunking_context)\n-                        .to_resolved()\n-                        .await?,\n-                )\n-                .into());\n-            }\n+        if let Some(module) = *self.resolve_reference().first_module().await?\n+            && let Some(embeddable) = Vc::try_resolve_downcast::<Box<dyn CssEmbed>>(*module).await?\n+        {\n+            return Ok(ReferencedAsset::Some(\n+                embeddable\n+                    .embedded_asset(chunking_context)\n+                    .to_resolved()\n+                    .await?,\n+            )\n+            .into());\n         }\n         Ok(ReferencedAsset::cell(ReferencedAsset::None))\n     }"
        },
        {
            "sha": "cec41b9e70eee96ad5003e026aa7991c0336f53a",
            "filename": "turbopack/crates/turbopack-dev-server/src/update/stream.rs",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fupdate%2Fstream.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fupdate%2Fstream.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fupdate%2Fstream.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -181,14 +181,14 @@ async fn get_update_stream_item_operation(\n             extend_issues(&mut plain_issues, peek_issues(proxy_result_op).await?);\n \n             let from = from.get();\n-            if let Some(from) = Vc::try_resolve_downcast_type::<ProxyResult>(from).await? {\n-                if from.await? == proxy_result_value {\n-                    return Ok(UpdateStreamItem::Found {\n-                        update: Update::None.cell().await?,\n-                        issues: plain_issues,\n-                    }\n-                    .cell());\n+            if let Some(from) = Vc::try_resolve_downcast_type::<ProxyResult>(from).await?\n+                && from.await? == proxy_result_value\n+            {\n+                return Ok(UpdateStreamItem::Found {\n+                    update: Update::None.cell().await?,\n+                    issues: plain_issues,\n                 }\n+                .cell());\n             }\n \n             Ok(UpdateStreamItem::Found {"
        },
        {
            "sha": "df3c3f09a1779b1795f7845f959e74f3bb51e4c7",
            "filename": "turbopack/crates/turbopack-ecmascript/src/analyzer/builtin.rs",
            "status": "modified",
            "additions": 9,
            "deletions": 9,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fanalyzer%2Fbuiltin.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fanalyzer%2Fbuiltin.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fanalyzer%2Fbuiltin.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -444,16 +444,16 @@ pub fn replace_builtin(value: &mut JsValue) -> bool {\n             }\n \n             // matching calls on strings like `\"dayjs/locale/\".concat(userLocale, \".js\")`\n-            if obj.is_string() == Some(true) {\n-                if let Some(str) = prop.as_str() {\n-                    // The String.prototype.concat method\n-                    if str == \"concat\" {\n-                        let mut values = vec![take(obj)];\n-                        values.extend(take(args));\n+            if obj.is_string() == Some(true)\n+                && let Some(str) = prop.as_str()\n+            {\n+                // The String.prototype.concat method\n+                if str == \"concat\" {\n+                    let mut values = vec![take(obj)];\n+                    values.extend(take(args));\n \n-                        *value = JsValue::concat(values);\n-                        return true;\n-                    }\n+                    *value = JsValue::concat(values);\n+                    return true;\n                 }\n             }\n "
        },
        {
            "sha": "214f27e011bd6b40fefc40e4dc433e5c544a2dd7",
            "filename": "turbopack/crates/turbopack-ecmascript/src/analyzer/graph.rs",
            "status": "modified",
            "additions": 75,
            "deletions": 80,
            "changes": 155,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fanalyzer%2Fgraph.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fanalyzer%2Fgraph.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fanalyzer%2Fgraph.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -896,10 +896,10 @@ impl Analyzer<'_> {\n                         self.visit_opt_ident(ident, &mut ast_path);\n \n                         // We cannot analyze recursive IIFE\n-                        if let Some(ident) = ident {\n-                            if contains_ident_ref(&function.body, &ident.to_id()) {\n-                                return false;\n-                            }\n+                        if let Some(ident) = ident\n+                            && contains_ident_ref(&function.body, &ident.to_id())\n+                        {\n+                            return false;\n                         }\n                     }\n \n@@ -1389,23 +1389,22 @@ impl VisitAstPath for Analyzer<'_> {\n         ast_path: &mut AstNodePath<AstParentNodeRef<'r>>,\n     ) {\n         // We handle `define(function (require) {})` here.\n-        if let Callee::Expr(callee) = &n.callee {\n-            if n.args.len() == 1 {\n-                if let Some(require_var_id) = extract_var_from_umd_factory(callee, &n.args) {\n-                    self.add_value(\n-                        require_var_id,\n-                        JsValue::unknown_if(\n-                            self.eval_context\n-                                .imports\n-                                .get_attributes(n.callee.span())\n-                                .ignore,\n-                            JsValue::WellKnownFunction(WellKnownFunctionKind::Require),\n-                            true,\n-                            \"ignored require\",\n-                        ),\n-                    );\n-                }\n-            }\n+        if let Callee::Expr(callee) = &n.callee\n+            && n.args.len() == 1\n+            && let Some(require_var_id) = extract_var_from_umd_factory(callee, &n.args)\n+        {\n+            self.add_value(\n+                require_var_id,\n+                JsValue::unknown_if(\n+                    self.eval_context\n+                        .imports\n+                        .get_attributes(n.callee.span())\n+                        .ignore,\n+                    JsValue::WellKnownFunction(WellKnownFunctionKind::Require),\n+                    true,\n+                    \"ignored require\",\n+                ),\n+            );\n         }\n \n         if self.check_iife(n, ast_path) {\n@@ -1646,30 +1645,30 @@ impl VisitAstPath for Analyzer<'_> {\n         n: &'ast VarDeclarator,\n         ast_path: &mut AstNodePath<AstParentNodeRef<'r>>,\n     ) {\n-        if self.var_decl_kind.is_some() {\n-            if let Some(init) = &n.init {\n-                // For case like\n-                //\n-                // if (shouldRun()) {\n-                //   var x = true;\n-                // }\n-                // if (x) {\n-                // }\n-                //\n-                // The variable `x` is undefined\n-\n-                let should_include_undefined = matches!(self.var_decl_kind, Some(VarDeclKind::Var))\n-                    && is_lexically_block_scope(ast_path);\n-                let init_value = self.eval_context.eval(init);\n-                self.current_value = Some(if should_include_undefined {\n-                    JsValue::alternatives(vec![\n-                        init_value,\n-                        JsValue::Constant(ConstantValue::Undefined),\n-                    ])\n-                } else {\n-                    init_value\n-                });\n-            }\n+        if self.var_decl_kind.is_some()\n+            && let Some(init) = &n.init\n+        {\n+            // For case like\n+            //\n+            // if (shouldRun()) {\n+            //   var x = true;\n+            // }\n+            // if (x) {\n+            // }\n+            //\n+            // The variable `x` is undefined\n+\n+            let should_include_undefined = matches!(self.var_decl_kind, Some(VarDeclKind::Var))\n+                && is_lexically_block_scope(ast_path);\n+            let init_value = self.eval_context.eval(init);\n+            self.current_value = Some(if should_include_undefined {\n+                JsValue::alternatives(vec![\n+                    init_value,\n+                    JsValue::Constant(ConstantValue::Undefined),\n+                ])\n+            } else {\n+                init_value\n+            });\n         }\n         {\n             let mut ast_path =\n@@ -1878,21 +1877,20 @@ impl VisitAstPath for Analyzer<'_> {\n                         ))\n                     );\n \n-                    if !is_lhs {\n-                        if let Some(prop) = self.eval_context.eval_member_prop(&member.prop) {\n-                            if let Some(prop_str) = prop.as_str() {\n-                                // a namespace member access like\n-                                // `import * as ns from \"...\"; ns.exportName`\n-                                self.add_effect(Effect::ImportedBinding {\n-                                    esm_reference_index,\n-                                    export: Some(prop_str.into()),\n-                                    ast_path: as_parent_path_skip(ast_path, 1),\n-                                    span: member.span(),\n-                                    in_try: is_in_try(ast_path),\n-                                });\n-                                return;\n-                            }\n-                        }\n+                    if !is_lhs\n+                        && let Some(prop) = self.eval_context.eval_member_prop(&member.prop)\n+                        && let Some(prop_str) = prop.as_str()\n+                    {\n+                        // a namespace member access like\n+                        // `import * as ns from \"...\"; ns.exportName`\n+                        self.add_effect(Effect::ImportedBinding {\n+                            esm_reference_index,\n+                            export: Some(prop_str.into()),\n+                            ast_path: as_parent_path_skip(ast_path, 1),\n+                            span: member.span(),\n+                            in_try: is_in_try(ast_path),\n+                        });\n+                        return;\n                     }\n                 }\n             }\n@@ -2432,16 +2430,15 @@ impl Analyzer<'_> {\n fn extract_var_from_umd_factory(callee: &Expr, args: &[ExprOrSpread]) -> Option<Id> {\n     match unparen(callee) {\n         Expr::Ident(Ident { sym, .. }) => {\n-            if &**sym == \"define\" {\n-                if let Expr::Fn(FnExpr { function, .. }) = &*args[0].expr {\n-                    let params = &*function.params;\n-                    if params.len() == 1 {\n-                        if let Pat::Ident(param) = &params[0].pat {\n-                            if &*param.id.sym == \"require\" {\n-                                return Some(param.to_id());\n-                            }\n-                        }\n-                    }\n+            if &**sym == \"define\"\n+                && let Expr::Fn(FnExpr { function, .. }) = &*args[0].expr\n+            {\n+                let params = &*function.params;\n+                if params.len() == 1\n+                    && let Pat::Ident(param) = &params[0].pat\n+                    && &*param.id.sym == \"require\"\n+                {\n+                    return Some(param.to_id());\n                 }\n             }\n         }\n@@ -2454,18 +2451,16 @@ fn extract_var_from_umd_factory(callee: &Expr, args: &[ExprOrSpread]) -> Option<\n         // treated as a well-known require.\n         Expr::Fn(FnExpr { function, .. }) => {\n             let params = &*function.params;\n-            if params.len() == 1 {\n-                if let Some(FnExpr { function, .. }) =\n+            if params.len() == 1\n+                && let Some(FnExpr { function, .. }) =\n                     args.first().and_then(|arg| arg.expr.as_fn_expr())\n+            {\n+                let params = &*function.params;\n+                if !params.is_empty()\n+                    && let Pat::Ident(param) = &params[0].pat\n+                    && &*param.id.sym == \"require\"\n                 {\n-                    let params = &*function.params;\n-                    if !params.is_empty() {\n-                        if let Pat::Ident(param) = &params[0].pat {\n-                            if &*param.id.sym == \"require\" {\n-                                return Some(param.to_id());\n-                            }\n-                        }\n-                    }\n+                    return Some(param.to_id());\n                 }\n             }\n         }"
        },
        {
            "sha": "1d2332fa79a2f944b15f2f471f8838ef25c7c09b",
            "filename": "turbopack/crates/turbopack-ecmascript/src/analyzer/imports.rs",
            "status": "modified",
            "additions": 24,
            "deletions": 24,
            "changes": 48,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fanalyzer%2Fimports.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fanalyzer%2Fimports.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fanalyzer%2Fimports.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -362,11 +362,11 @@ struct StarImportAnalyzer<'a> {\n \n impl Visit for StarImportAnalyzer<'_> {\n     fn visit_expr(&mut self, node: &Expr) {\n-        if let Expr::Ident(i) = node {\n-            if let Some(module_path) = self.candidates.get(&i.to_id()) {\n-                self.full_star_imports.insert(module_path.clone());\n-                return;\n-            }\n+        if let Expr::Ident(i) = node\n+            && let Some(module_path) = self.candidates.get(&i.to_id())\n+        {\n+            self.full_star_imports.insert(module_path.clone());\n+            return;\n         }\n \n         node.visit_children_with(self);\n@@ -391,22 +391,22 @@ impl Visit for StarImportAnalyzer<'_> {\n     }\n \n     fn visit_pat(&mut self, pat: &Pat) {\n-        if let Pat::Ident(i) = pat {\n-            if let Some(module_path) = self.candidates.get(&i.to_id()) {\n-                self.full_star_imports.insert(module_path.clone());\n-                return;\n-            }\n+        if let Pat::Ident(i) = pat\n+            && let Some(module_path) = self.candidates.get(&i.to_id())\n+        {\n+            self.full_star_imports.insert(module_path.clone());\n+            return;\n         }\n \n         pat.visit_children_with(self);\n     }\n \n     fn visit_simple_assign_target(&mut self, node: &SimpleAssignTarget) {\n-        if let SimpleAssignTarget::Ident(i) = node {\n-            if let Some(module_path) = self.candidates.get(&i.to_id()) {\n-                self.full_star_imports.insert(module_path.clone());\n-                return;\n-            }\n+        if let SimpleAssignTarget::Ident(i) = node\n+            && let Some(module_path) = self.candidates.get(&i.to_id())\n+        {\n+            self.full_star_imports.insert(module_path.clone());\n+            return;\n         }\n \n         node.visit_children_with(self);\n@@ -502,15 +502,15 @@ impl Visit for Analyzer<'_> {\n \n             self.data.imports.insert(local, (i, orig_sym));\n         }\n-        if import.specifiers.is_empty() {\n-            if let Some(internal_symbol) = internal_symbol {\n-                self.ensure_reference(\n-                    import.span,\n-                    import.src.value.clone(),\n-                    internal_symbol,\n-                    annotations,\n-                );\n-            }\n+        if import.specifiers.is_empty()\n+            && let Some(internal_symbol) = internal_symbol\n+        {\n+            self.ensure_reference(\n+                import.span,\n+                import.src.value.clone(),\n+                internal_symbol,\n+                annotations,\n+            );\n         }\n     }\n "
        },
        {
            "sha": "fd935c80a125caafb14109bfc9b205d7a708d8af",
            "filename": "turbopack/crates/turbopack-ecmascript/src/analyzer/mod.rs",
            "status": "modified",
            "additions": 22,
            "deletions": 22,
            "changes": 44,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fanalyzer%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fanalyzer%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fanalyzer%2Fmod.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -2007,31 +2007,31 @@ impl JsValue {\n         >,\n         prop: &DefineableNameSegment,\n     ) -> Option<&'a T> {\n-        if let Some(def_name_len) = self.get_defineable_name_len() {\n-            if let Some(references) = free_var_references.get(prop) {\n-                for (name, value) in references {\n-                    if name.len() != def_name_len {\n-                        continue;\n-                    }\n+        if let Some(def_name_len) = self.get_defineable_name_len()\n+            && let Some(references) = free_var_references.get(prop)\n+        {\n+            for (name, value) in references {\n+                if name.len() != def_name_len {\n+                    continue;\n+                }\n \n-                    let name_rev_it = name.iter().map(Cow::Borrowed).rev();\n-                    if name_rev_it.eq(self.iter_defineable_name_rev()) {\n-                        if let Some(var_graph) = var_graph {\n-                            if let DefineableNameSegment::Name(first_str) = name.first().unwrap() {\n-                                let first_str: &str = first_str;\n-                                if var_graph\n-                                    .free_var_ids\n-                                    .get(&first_str.into())\n-                                    .is_some_and(|id| var_graph.values.contains_key(id))\n-                                {\n-                                    // `typeof foo...` but `foo` was reassigned\n-                                    return None;\n-                                }\n-                            }\n+                let name_rev_it = name.iter().map(Cow::Borrowed).rev();\n+                if name_rev_it.eq(self.iter_defineable_name_rev()) {\n+                    if let Some(var_graph) = var_graph\n+                        && let DefineableNameSegment::Name(first_str) = name.first().unwrap()\n+                    {\n+                        let first_str: &str = first_str;\n+                        if var_graph\n+                            .free_var_ids\n+                            .get(&first_str.into())\n+                            .is_some_and(|id| var_graph.values.contains_key(id))\n+                        {\n+                            // `typeof foo...` but `foo` was reassigned\n+                            return None;\n                         }\n-\n-                        return Some(value);\n                     }\n+\n+                    return Some(value);\n                 }\n             }\n         }"
        },
        {
            "sha": "bbcab937181e8c1204ce2f069d2b88fcd1f7c2fe",
            "filename": "turbopack/crates/turbopack-ecmascript/src/analyzer/well_known.rs",
            "status": "modified",
            "additions": 21,
            "deletions": 25,
            "changes": 46,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fanalyzer%2Fwell_known.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fanalyzer%2Fwell_known.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fanalyzer%2Fwell_known.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -29,10 +29,10 @@ pub async fn replace_well_known(\n         JsValue::Call(usize, callee, args) => {\n             // var fs = require('fs'), fs = __importStar(fs);\n             // TODO(WEB-552) this is not correct and has many false positives!\n-            if args.len() == 1 {\n-                if let JsValue::WellKnownObject(_) = &args[0] {\n-                    return Ok((args[0].clone(), true));\n-                }\n+            if args.len() == 1\n+                && let JsValue::WellKnownObject(_) = &args[0]\n+            {\n+                return Ok((args[0].clone(), true));\n             }\n             (JsValue::Call(usize, callee, args), false)\n         }\n@@ -120,16 +120,15 @@ pub async fn well_known_function_call(\n pub fn object_assign(args: Vec<JsValue>) -> JsValue {\n     if args.iter().all(|arg| matches!(arg, JsValue::Object { .. })) {\n         if let Some(mut merged_object) = args.into_iter().reduce(|mut acc, cur| {\n-            if let JsValue::Object { parts, mutable, .. } = &mut acc {\n-                if let JsValue::Object {\n+            if let JsValue::Object { parts, mutable, .. } = &mut acc\n+                && let JsValue::Object {\n                     parts: next_parts,\n                     mutable: next_mutable,\n                     ..\n                 } = &cur\n-                {\n-                    parts.extend_from_slice(next_parts);\n-                    *mutable |= *next_mutable;\n-                }\n+            {\n+                parts.extend_from_slice(next_parts);\n+                *mutable |= *next_mutable;\n             }\n             acc\n         }) {\n@@ -226,12 +225,11 @@ pub fn path_resolve(cwd: JsValue, mut args: Vec<JsValue>) -> JsValue {\n \n     // path.resolve stops at the string starting with `/`\n     for (idx, arg) in args.iter().enumerate().rev() {\n-        if idx != 0 {\n-            if let Some(str) = arg.as_str() {\n-                if str.starts_with('/') {\n-                    return path_resolve(cwd, args.drain(idx..).collect());\n-                }\n-            }\n+        if idx != 0\n+            && let Some(str) = arg.as_str()\n+            && str.starts_with('/')\n+        {\n+            return path_resolve(cwd, args.drain(idx..).collect());\n         }\n     }\n \n@@ -295,15 +293,13 @@ pub fn path_dirname(mut args: Vec<JsValue>) -> JsValue {\n             } else {\n                 return JsValue::Constant(ConstantValue::Str(\"\".into()));\n             }\n-        } else if let JsValue::Concat(_, items) = arg {\n-            if let Some(last) = items.last_mut() {\n-                if let Some(str) = last.as_str() {\n-                    if let Some(i) = str.rfind('/') {\n-                        *last = JsValue::Constant(ConstantValue::Str(str[..i].to_string().into()));\n-                        return take(arg);\n-                    }\n-                }\n-            }\n+        } else if let JsValue::Concat(_, items) = arg\n+            && let Some(last) = items.last_mut()\n+            && let Some(str) = last.as_str()\n+            && let Some(i) = str.rfind('/')\n+        {\n+            *last = JsValue::Constant(ConstantValue::Str(str[..i].to_string().into()));\n+            return take(arg);\n         }\n     }\n     JsValue::unknown("
        },
        {
            "sha": "91a505ca57021ce1250145facb12ddc50751ae93",
            "filename": "turbopack/crates/turbopack-ecmascript/src/async_chunk/chunk_item.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 3,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fasync_chunk%2Fchunk_item.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fasync_chunk%2Fchunk_item.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fasync_chunk%2Fchunk_item.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -45,10 +45,9 @@ impl AsyncLoaderChunkItem {\n             let module_or_batch = batches.get_entry(inner_module).await?;\n             if let Some(chunkable_module_or_batch) =\n                 ChunkableModuleOrBatch::from_module_or_batch(module_or_batch)\n+                && *chunk_items.get(chunkable_module_or_batch).await?\n             {\n-                if *chunk_items.get(chunkable_module_or_batch).await? {\n-                    return Ok(Vc::cell(vec![]));\n-                }\n+                return Ok(Vc::cell(vec![]));\n             }\n         }\n         Ok(self.chunking_context.chunk_group_assets("
        },
        {
            "sha": "1cc918484d19fac96d86488404142d840fe8f7d0",
            "filename": "turbopack/crates/turbopack-ecmascript/src/chunk/placeable.rs",
            "status": "modified",
            "additions": 62,
            "deletions": 63,
            "changes": 125,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fchunk%2Fplaceable.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fchunk%2Fplaceable.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fchunk%2Fplaceable.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -41,30 +41,53 @@ enum SideEffectsValue {\n async fn side_effects_from_package_json(\n     package_json: ResolvedVc<FileSystemPath>,\n ) -> Result<Vc<SideEffectsValue>> {\n-    if let FileJsonContent::Content(content) = &*package_json.read_json().await? {\n-        if let Some(side_effects) = content.get(\"sideEffects\") {\n-            if let Some(side_effects) = side_effects.as_bool() {\n-                return Ok(SideEffectsValue::Constant(side_effects).cell());\n-            } else if let Some(side_effects) = side_effects.as_array() {\n-                let globs = side_effects\n-                    .iter()\n-                    .filter_map(|side_effect| {\n-                        if let Some(side_effect) = side_effect.as_str() {\n-                            if side_effect.contains('/') {\n-                                Some(Glob::new(\n-                                    side_effect.strip_prefix(\"./\").unwrap_or(side_effect).into(),\n-                                ))\n-                            } else {\n-                                Some(Glob::new(format!(\"**/{side_effect}\").into()))\n-                            }\n+    if let FileJsonContent::Content(content) = &*package_json.read_json().await?\n+        && let Some(side_effects) = content.get(\"sideEffects\")\n+    {\n+        if let Some(side_effects) = side_effects.as_bool() {\n+            return Ok(SideEffectsValue::Constant(side_effects).cell());\n+        } else if let Some(side_effects) = side_effects.as_array() {\n+            let globs = side_effects\n+                .iter()\n+                .filter_map(|side_effect| {\n+                    if let Some(side_effect) = side_effect.as_str() {\n+                        if side_effect.contains('/') {\n+                            Some(Glob::new(\n+                                side_effect.strip_prefix(\"./\").unwrap_or(side_effect).into(),\n+                            ))\n                         } else {\n+                            Some(Glob::new(format!(\"**/{side_effect}\").into()))\n+                        }\n+                    } else {\n+                        SideEffectsInPackageJsonIssue {\n+                            path: package_json,\n+                            description: Some(\n+                                StyledString::Text(\n+                                    format!(\n+                                        \"Each element in sideEffects must be a string, but found \\\n+                                         {side_effect:?}\"\n+                                    )\n+                                    .into(),\n+                                )\n+                                .resolved_cell(),\n+                            ),\n+                        }\n+                        .resolved_cell()\n+                        .emit();\n+                        None\n+                    }\n+                })\n+                .map(|glob| async move {\n+                    match glob.resolve().await {\n+                        Ok(glob) => Ok(Some(glob)),\n+                        Err(err) => {\n                             SideEffectsInPackageJsonIssue {\n                                 path: package_json,\n                                 description: Some(\n                                     StyledString::Text(\n                                         format!(\n-                                            \"Each element in sideEffects must be a string, but \\\n-                                             found {side_effect:?}\"\n+                                            \"Invalid glob in sideEffects: {}\",\n+                                            PrettyPrintError(&err)\n                                         )\n                                         .into(),\n                                     )\n@@ -73,54 +96,30 @@ async fn side_effects_from_package_json(\n                             }\n                             .resolved_cell()\n                             .emit();\n-                            None\n+                            Ok(None)\n                         }\n-                    })\n-                    .map(|glob| async move {\n-                        match glob.resolve().await {\n-                            Ok(glob) => Ok(Some(glob)),\n-                            Err(err) => {\n-                                SideEffectsInPackageJsonIssue {\n-                                    path: package_json,\n-                                    description: Some(\n-                                        StyledString::Text(\n-                                            format!(\n-                                                \"Invalid glob in sideEffects: {}\",\n-                                                PrettyPrintError(&err)\n-                                            )\n-                                            .into(),\n-                                        )\n-                                        .resolved_cell(),\n-                                    ),\n-                                }\n-                                .resolved_cell()\n-                                .emit();\n-                                Ok(None)\n-                            }\n-                        }\n-                    })\n-                    .try_flat_join()\n-                    .await?;\n-                return Ok(\n-                    SideEffectsValue::Glob(Glob::alternatives(globs).to_resolved().await?).cell(),\n-                );\n-            } else {\n-                SideEffectsInPackageJsonIssue {\n-                    path: package_json,\n-                    description: Some(\n-                        StyledString::Text(\n-                            format!(\n-                                \"sideEffects must be a boolean or an array, but found \\\n-                                 {side_effects:?}\"\n-                            )\n-                            .into(),\n+                    }\n+                })\n+                .try_flat_join()\n+                .await?;\n+            return Ok(\n+                SideEffectsValue::Glob(Glob::alternatives(globs).to_resolved().await?).cell(),\n+            );\n+        } else {\n+            SideEffectsInPackageJsonIssue {\n+                path: package_json,\n+                description: Some(\n+                    StyledString::Text(\n+                        format!(\n+                            \"sideEffects must be a boolean or an array, but found {side_effects:?}\"\n                         )\n-                        .resolved_cell(),\n-                    ),\n-                }\n-                .resolved_cell()\n-                .emit();\n+                        .into(),\n+                    )\n+                    .resolved_cell(),\n+                ),\n             }\n+            .resolved_cell()\n+            .emit();\n         }\n     }\n     Ok(SideEffectsValue::None.cell())"
        },
        {
            "sha": "51d8ef45bfebfc947611cbe77c2efbf7dddd581f",
            "filename": "turbopack/crates/turbopack-ecmascript/src/lib.rs",
            "status": "modified",
            "additions": 11,
            "deletions": 11,
            "changes": 22,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -476,17 +476,17 @@ async fn determine_module_type_for_directory(\n     };\n \n     // analysis.add_reference(PackageJsonReference::new(package_json));\n-    if let FileJsonContent::Content(content) = &*package_json.read_json().await? {\n-        if let Some(r#type) = content.get(\"type\") {\n-            return Ok(ModuleTypeResult::new_with_package_json(\n-                match r#type.as_str() {\n-                    Some(\"module\") => SpecifiedModuleType::EcmaScript,\n-                    Some(\"commonjs\") => SpecifiedModuleType::CommonJs,\n-                    _ => SpecifiedModuleType::Automatic,\n-                },\n-                *package_json,\n-            ));\n-        }\n+    if let FileJsonContent::Content(content) = &*package_json.read_json().await?\n+        && let Some(r#type) = content.get(\"type\")\n+    {\n+        return Ok(ModuleTypeResult::new_with_package_json(\n+            match r#type.as_str() {\n+                Some(\"module\") => SpecifiedModuleType::EcmaScript,\n+                Some(\"commonjs\") => SpecifiedModuleType::CommonJs,\n+                _ => SpecifiedModuleType::Automatic,\n+            },\n+            *package_json,\n+        ));\n     }\n \n     Ok(ModuleTypeResult::new_with_package_json("
        },
        {
            "sha": "0369619e1adabb75f98a85b7a6049e258fafcc9e",
            "filename": "turbopack/crates/turbopack-ecmascript/src/manifest/chunk_asset.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 3,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fmanifest%2Fchunk_asset.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fmanifest%2Fchunk_asset.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fmanifest%2Fchunk_asset.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -76,10 +76,9 @@ impl ManifestAsyncModule {\n             let module_or_batch = batches.get_entry(inner_module).await?;\n             if let Some(chunkable_module_or_batch) =\n                 ChunkableModuleOrBatch::from_module_or_batch(module_or_batch)\n+                && *chunk_items.get(chunkable_module_or_batch).await?\n             {\n-                if *chunk_items.get(chunkable_module_or_batch).await? {\n-                    return Ok(Vc::cell(vec![]));\n-                }\n+                return Ok(Vc::cell(vec![]));\n             }\n         }\n         Ok(this.chunking_context.chunk_group_assets("
        },
        {
            "sha": "3f91188d6ffa4592afdd8bab0464de4beaa8513a",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/esm/base.rs",
            "status": "modified",
            "additions": 24,
            "deletions": 24,
            "changes": 48,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fbase.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fbase.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fbase.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -204,22 +204,22 @@ impl ModuleReference for EsmAssetReference {\n             }\n         }\n \n-        if let Request::Module { module, .. } = &*self.request.await? {\n-            if module == TURBOPACK_PART_IMPORT_SOURCE {\n-                if let Some(part) = &self.export_name {\n-                    let module: ResolvedVc<crate::EcmascriptModuleAsset> =\n-                        ResolvedVc::try_downcast_type(self.origin)\n-                            .expect(\"EsmAssetReference origin should be a EcmascriptModuleAsset\");\n-\n-                    return Ok(*ModuleResolveResult::module(ResolvedVc::upcast(\n-                        EcmascriptModulePartAsset::select_part(*module, part.clone())\n-                            .to_resolved()\n-                            .await?,\n-                    )));\n-                }\n-\n-                bail!(\"export_name is required for part import\")\n+        if let Request::Module { module, .. } = &*self.request.await?\n+            && module == TURBOPACK_PART_IMPORT_SOURCE\n+        {\n+            if let Some(part) = &self.export_name {\n+                let module: ResolvedVc<crate::EcmascriptModuleAsset> =\n+                    ResolvedVc::try_downcast_type(self.origin)\n+                        .expect(\"EsmAssetReference origin should be a EcmascriptModuleAsset\");\n+\n+                return Ok(*ModuleResolveResult::module(ResolvedVc::upcast(\n+                    EcmascriptModulePartAsset::select_part(*module, part.clone())\n+                        .to_resolved()\n+                        .await?,\n+                )));\n             }\n+\n+            bail!(\"export_name is required for part import\")\n         }\n \n         let result = esm_resolve(\n@@ -233,16 +233,16 @@ impl ModuleReference for EsmAssetReference {\n \n         if let Some(ModulePart::Export(export_name)) = &self.export_name {\n             for &module in result.primary_modules().await? {\n-                if let Some(module) = ResolvedVc::try_downcast(module) {\n-                    if *is_export_missing(*module, export_name.clone()).await? {\n-                        InvalidExport {\n-                            export: export_name.clone(),\n-                            module,\n-                            source: self.issue_source.clone(),\n-                        }\n-                        .resolved_cell()\n-                        .emit();\n+                if let Some(module) = ResolvedVc::try_downcast(module)\n+                    && *is_export_missing(*module, export_name.clone()).await?\n+                {\n+                    InvalidExport {\n+                        export: export_name.clone(),\n+                        module,\n+                        source: self.issue_source.clone(),\n                     }\n+                    .resolved_cell()\n+                    .emit();\n                 }\n             }\n         }"
        },
        {
            "sha": "ed99a85d181ac9c5700fb2c13de8e3721f0b1ef5",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/esm/export.rs",
            "status": "modified",
            "additions": 15,
            "deletions": 19,
            "changes": 34,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fexport.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fexport.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fexport.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -285,23 +285,20 @@ async fn find_export_from_reexports(\n ) -> Result<Vc<FindExportFromReexportsResult>> {\n     if let Some(module) =\n         Vc::try_resolve_downcast_type::<EcmascriptModulePartAsset>(*module).await?\n+        && matches!(module.await?.part, ModulePart::Exports)\n     {\n-        if matches!(module.await?.part, ModulePart::Exports) {\n-            let module_part = EcmascriptModulePartAsset::select_part(\n-                *module.await?.full_module,\n-                ModulePart::export(export_name.clone()),\n-            );\n-\n-            // If we apply this logic to EcmascriptModuleAsset, we will resolve everything in the\n-            // target module.\n-            if (Vc::try_resolve_downcast_type::<EcmascriptModuleAsset>(module_part).await?)\n-                .is_none()\n-            {\n-                return Ok(find_export_from_reexports(\n-                    Vc::upcast(module_part),\n-                    export_name,\n-                ));\n-            }\n+        let module_part = EcmascriptModulePartAsset::select_part(\n+            *module.await?.full_module,\n+            ModulePart::export(export_name.clone()),\n+        );\n+\n+        // If we apply this logic to EcmascriptModuleAsset, we will resolve everything in the\n+        // target module.\n+        if (Vc::try_resolve_downcast_type::<EcmascriptModuleAsset>(module_part).await?).is_none() {\n+            return Ok(find_export_from_reexports(\n+                Vc::upcast(module_part),\n+                export_name,\n+            ));\n         }\n     }\n \n@@ -395,10 +392,9 @@ pub async fn expand_star_exports(\n                 for esm_ref in exports.star_exports.iter() {\n                     if let ReferencedAsset::Some(asset) =\n                         &*ReferencedAsset::from_resolve_result(esm_ref.resolve_reference()).await?\n+                        && checked_modules.insert(**asset)\n                     {\n-                        if checked_modules.insert(**asset) {\n-                            queue.push((**asset, asset.get_exports()));\n-                        }\n+                        queue.push((**asset, asset.get_exports()));\n                     }\n                 }\n             }"
        },
        {
            "sha": "d9a0a2b62cca21cd241b258b83e2277f225a36f8",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/esm/url.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 3,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Furl.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Furl.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Furl.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -309,11 +309,10 @@ impl UrlAssetReferenceCodeGen {\n                                     *expr = request.as_str().into()\n                                 }\n \n-                                if let Some(rewrite) = &rewrite_url_base {\n-                                    if let Some(ExprOrSpread { box expr, spread: None }) = args.get_mut(1) {\n+                                if let Some(rewrite) = &rewrite_url_base\n+                                    && let Some(ExprOrSpread { box expr, spread: None }) = args.get_mut(1) {\n                                         *expr = rewrite.clone();\n                                     }\n-                                }\n                             }\n                         }));\n                     }"
        },
        {
            "sha": "ea19c7c3d081d77b0eb071972fdab840bee91d38",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/mod.rs",
            "status": "modified",
            "additions": 256,
            "deletions": 279,
            "changes": 535,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fmod.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -386,15 +386,15 @@ impl AnalyzeEcmascriptModuleResultBuilder {\n                         .flat_map(|m| m.values().copied()),\n                 );\n             }\n-            if let Some(esm_evaluation_references) = &mut esm_evaluation_references {\n-                if self.esm_evaluation_references.contains(&i) {\n-                    esm_evaluation_references.push(*reference);\n-                }\n+            if let Some(esm_evaluation_references) = &mut esm_evaluation_references\n+                && self.esm_evaluation_references.contains(&i)\n+            {\n+                esm_evaluation_references.push(*reference);\n             }\n-            if let Some(esm_reexport_references) = &mut esm_reexport_references {\n-                if self.esm_reexport_references.contains(&i) {\n-                    esm_reexport_references.push(*reference);\n-                }\n+            if let Some(esm_reexport_references) = &mut esm_reexport_references\n+                && self.esm_reexport_references.contains(&i)\n+            {\n+                esm_reexport_references.push(*reference);\n             }\n         }\n \n@@ -711,12 +711,11 @@ pub(crate) async fn analyse_ecmascript_module_internal(\n                     source_map_from_comment = true;\n                 }\n             }\n-            if !source_map_from_comment {\n-                if let Some(generate_source_map) =\n+            if !source_map_from_comment\n+                && let Some(generate_source_map) =\n                     ResolvedVc::try_sidecast::<Box<dyn GenerateSourceMap>>(source)\n-                {\n-                    analysis.set_source_map(generate_source_map);\n-                }\n+            {\n+                analysis.set_source_map(generate_source_map);\n             }\n             anyhow::Ok(())\n         }\n@@ -1219,10 +1218,10 @@ pub(crate) async fn analyse_ecmascript_module_internal(\n                     in_try,\n                     new,\n                 } => {\n-                    if let Some(ignored) = &ignore_effect_span {\n-                        if *ignored == span {\n-                            continue;\n-                        }\n+                    if let Some(ignored) = &ignore_effect_span\n+                        && *ignored == span\n+                    {\n+                        continue;\n                     }\n \n                     let func = analysis_state\n@@ -1252,10 +1251,10 @@ pub(crate) async fn analyse_ecmascript_module_internal(\n                     in_try,\n                     new,\n                 } => {\n-                    if let Some(ignored) = &ignore_effect_span {\n-                        if *ignored == span {\n-                            continue;\n-                        }\n+                    if let Some(ignored) = &ignore_effect_span\n+                        && *ignored == span\n+                    {\n+                        continue;\n                     }\n                     let mut obj = analysis_state\n                         .link_value(*obj, ImportAttributes::empty_ref())\n@@ -1264,38 +1263,35 @@ pub(crate) async fn analyse_ecmascript_module_internal(\n                         .link_value(*prop, ImportAttributes::empty_ref())\n                         .await?;\n \n-                    if !new {\n-                        if let JsValue::Array {\n+                    if !new\n+                        && let JsValue::Array {\n                             items: ref mut values,\n                             mutable,\n                             ..\n                         } = obj\n-                        {\n-                            if matches!(prop.as_str(), Some(\"map\" | \"forEach\" | \"filter\")) {\n-                                if let [EffectArg::Closure(value, block)] = &mut args[..] {\n-                                    *value = analysis_state\n-                                        .link_value(take(value), ImportAttributes::empty_ref())\n-                                        .await?;\n-                                    if let JsValue::Function(_, func_ident, _) = value {\n-                                        let mut closure_arg = JsValue::alternatives(take(values));\n-                                        if mutable {\n-                                            closure_arg.add_unknown_mutations(true);\n-                                        }\n-                                        analysis_state\n-                                            .fun_args_values\n-                                            .get_mut()\n-                                            .insert(*func_ident, vec![closure_arg]);\n-                                        queue_stack.get_mut().push(Action::LeaveScope(*func_ident));\n-                                        queue_stack.get_mut().extend(\n-                                            take(&mut block.effects)\n-                                                .into_iter()\n-                                                .map(Action::Effect)\n-                                                .rev(),\n-                                        );\n-                                        continue;\n-                                    }\n-                                }\n+                        && matches!(prop.as_str(), Some(\"map\" | \"forEach\" | \"filter\"))\n+                        && let [EffectArg::Closure(value, block)] = &mut args[..]\n+                    {\n+                        *value = analysis_state\n+                            .link_value(take(value), ImportAttributes::empty_ref())\n+                            .await?;\n+                        if let JsValue::Function(_, func_ident, _) = value {\n+                            let mut closure_arg = JsValue::alternatives(take(values));\n+                            if mutable {\n+                                closure_arg.add_unknown_mutations(true);\n                             }\n+                            analysis_state\n+                                .fun_args_values\n+                                .get_mut()\n+                                .insert(*func_ident, vec![closure_arg]);\n+                            queue_stack.get_mut().push(Action::LeaveScope(*func_ident));\n+                            queue_stack.get_mut().extend(\n+                                take(&mut block.effects)\n+                                    .into_iter()\n+                                    .map(Action::Effect)\n+                                    .rev(),\n+                            );\n+                            continue;\n                         }\n                     }\n \n@@ -1375,30 +1371,31 @@ pub(crate) async fn analyse_ecmascript_module_internal(\n                             Some(TreeShakingMode::ReexportsOnly)\n                         ) {\n                             let r_ref = r.await?;\n-                            if r_ref.export_name.is_none() && export.is_some() {\n-                                if let Some(export) = export {\n-                                    let r = analysis.add_esm_reference_namespace_resolved(\n-                                        esm_reference_index,\n-                                        export.clone(),\n-                                        || {\n-                                            EsmAssetReference::new(\n-                                                r_ref.origin,\n-                                                r_ref.request,\n-                                                r_ref.issue_source.clone(),\n-                                                Value::new(r_ref.annotations.clone()),\n-                                                Some(ModulePart::export(export.clone())),\n-                                                r_ref.import_externals,\n-                                            )\n-                                            .resolved_cell()\n-                                        },\n-                                    );\n-                                    analysis.add_code_gen(EsmBinding::new(\n-                                        r,\n-                                        Some(export),\n-                                        ast_path.into(),\n-                                    ));\n-                                    continue;\n-                                }\n+                            if r_ref.export_name.is_none()\n+                                && export.is_some()\n+                                && let Some(export) = export\n+                            {\n+                                let r = analysis.add_esm_reference_namespace_resolved(\n+                                    esm_reference_index,\n+                                    export.clone(),\n+                                    || {\n+                                        EsmAssetReference::new(\n+                                            r_ref.origin,\n+                                            r_ref.request,\n+                                            r_ref.issue_source.clone(),\n+                                            Value::new(r_ref.annotations.clone()),\n+                                            Some(ModulePart::export(export.clone())),\n+                                            r_ref.import_externals,\n+                                        )\n+                                        .resolved_cell()\n+                                    },\n+                                );\n+                                analysis.add_code_gen(EsmBinding::new(\n+                                    r,\n+                                    Some(export),\n+                                    ast_path.into(),\n+                                ));\n+                                continue;\n                             }\n                         }\n \n@@ -1608,35 +1605,34 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                         box JsValue::Constant(super::analyzer::ConstantValue::Str(meta_prop)),\n                     ),\n                 ] = &args[..]\n+                    && meta_prop.as_str() == \"url\"\n                 {\n-                    if meta_prop.as_str() == \"url\" {\n-                        let pat = js_value_to_pattern(url);\n-                        if !pat.has_constant_parts() {\n-                            let (args, hints) = explain_args(&args);\n-                            handler.span_warn_with_code(\n-                                span,\n-                                &format!(\"new URL({args}) is very dynamic{hints}\",),\n-                                DiagnosticId::Lint(\n-                                    errors::failed_to_analyse::ecmascript::NEW_URL_IMPORT_META\n-                                        .to_string(),\n-                                ),\n-                            );\n-                            if ignore_dynamic_requests {\n-                                return Ok(());\n-                            }\n-                        }\n-                        analysis.add_reference_code_gen(\n-                            UrlAssetReference::new(\n-                                origin,\n-                                Request::parse(Value::new(pat)).to_resolved().await?,\n-                                *compile_time_info.environment().rendering().await?,\n-                                issue_source(source, span),\n-                                in_try,\n-                                url_rewrite_behavior.unwrap_or(UrlRewriteBehavior::Relative),\n+                    let pat = js_value_to_pattern(url);\n+                    if !pat.has_constant_parts() {\n+                        let (args, hints) = explain_args(&args);\n+                        handler.span_warn_with_code(\n+                            span,\n+                            &format!(\"new URL({args}) is very dynamic{hints}\",),\n+                            DiagnosticId::Lint(\n+                                errors::failed_to_analyse::ecmascript::NEW_URL_IMPORT_META\n+                                    .to_string(),\n                             ),\n-                            ast_path.to_vec().into(),\n                         );\n+                        if ignore_dynamic_requests {\n+                            return Ok(());\n+                        }\n                     }\n+                    analysis.add_reference_code_gen(\n+                        UrlAssetReference::new(\n+                            origin,\n+                            Request::parse(Value::new(pat)).to_resolved().await?,\n+                            *compile_time_info.environment().rendering().await?,\n+                            issue_source(source, span),\n+                            in_try,\n+                            url_rewrite_behavior.unwrap_or(UrlRewriteBehavior::Relative),\n+                        ),\n+                        ast_path.to_vec().into(),\n+                    );\n                 }\n                 return Ok(());\n             }\n@@ -1721,10 +1717,9 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                                     JsValue::Constant(super::analyzer::ConstantValue::Str(key)),\n                                     value,\n                                 ) = part\n+                                    && key.as_str() == \"with\"\n                                 {\n-                                    if key.as_str() == \"with\" {\n-                                        return Some(value);\n-                                    }\n+                                    return Some(value);\n                                 }\n                                 None\n                             })\n@@ -2218,72 +2213,72 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n         }\n         JsValue::WellKnownFunction(WellKnownFunctionKind::NodeExpressSet) => {\n             let args = linked_args(args).await?;\n-            if args.len() == 2 {\n-                if let Some(s) = args.first().and_then(|arg| arg.as_str()) {\n-                    let pkg_or_dir = args.get(1).unwrap();\n-                    let pat = js_value_to_pattern(pkg_or_dir);\n-                    if !pat.has_constant_parts() {\n-                        let (args, hints) = explain_args(&args);\n-                        handler.span_warn_with_code(\n-                            span,\n-                            &format!(\"require('express')().set({args}) is very dynamic{hints}\",),\n-                            DiagnosticId::Lint(\n-                                errors::failed_to_analyse::ecmascript::NODE_EXPRESS.to_string(),\n-                            ),\n-                        );\n-                        // Always ignore this dynamic request\n-                        return Ok(());\n+            if args.len() == 2\n+                && let Some(s) = args.first().and_then(|arg| arg.as_str())\n+            {\n+                let pkg_or_dir = args.get(1).unwrap();\n+                let pat = js_value_to_pattern(pkg_or_dir);\n+                if !pat.has_constant_parts() {\n+                    let (args, hints) = explain_args(&args);\n+                    handler.span_warn_with_code(\n+                        span,\n+                        &format!(\"require('express')().set({args}) is very dynamic{hints}\",),\n+                        DiagnosticId::Lint(\n+                            errors::failed_to_analyse::ecmascript::NODE_EXPRESS.to_string(),\n+                        ),\n+                    );\n+                    // Always ignore this dynamic request\n+                    return Ok(());\n+                }\n+                match s {\n+                    \"views\" => {\n+                        if let Pattern::Constant(p) = &pat {\n+                            let abs_pattern = if p.starts_with(\"/ROOT/\") {\n+                                pat\n+                            } else {\n+                                let linked_func_call = state\n+                                    .link_value(\n+                                        JsValue::call(\n+                                            Box::new(JsValue::WellKnownFunction(\n+                                                WellKnownFunctionKind::PathJoin,\n+                                            )),\n+                                            vec![\n+                                                JsValue::FreeVar(\"__dirname\".into()),\n+                                                pkg_or_dir.clone(),\n+                                            ],\n+                                        ),\n+                                        ImportAttributes::empty_ref(),\n+                                    )\n+                                    .await?;\n+                                js_value_to_pattern(&linked_func_call)\n+                            };\n+                            analysis.add_reference(\n+                                DirAssetReference::new(*source, Pattern::new(abs_pattern))\n+                                    .to_resolved()\n+                                    .await?,\n+                            );\n+                            return Ok(());\n+                        }\n                     }\n-                    match s {\n-                        \"views\" => {\n-                            if let Pattern::Constant(p) = &pat {\n-                                let abs_pattern = if p.starts_with(\"/ROOT/\") {\n-                                    pat\n-                                } else {\n-                                    let linked_func_call = state\n-                                        .link_value(\n-                                            JsValue::call(\n-                                                Box::new(JsValue::WellKnownFunction(\n-                                                    WellKnownFunctionKind::PathJoin,\n-                                                )),\n-                                                vec![\n-                                                    JsValue::FreeVar(\"__dirname\".into()),\n-                                                    pkg_or_dir.clone(),\n-                                                ],\n-                                            ),\n-                                            ImportAttributes::empty_ref(),\n-                                        )\n-                                        .await?;\n-                                    js_value_to_pattern(&linked_func_call)\n-                                };\n+                    \"view engine\" => {\n+                        if let Some(pkg) = pkg_or_dir.as_str() {\n+                            if pkg != \"html\" {\n+                                let pat = js_value_to_pattern(pkg_or_dir);\n                                 analysis.add_reference(\n-                                    DirAssetReference::new(*source, Pattern::new(abs_pattern))\n-                                        .to_resolved()\n-                                        .await?,\n+                                    CjsAssetReference::new(\n+                                        *origin,\n+                                        Request::parse(Value::new(pat)),\n+                                        issue_source(source, span),\n+                                        in_try,\n+                                    )\n+                                    .to_resolved()\n+                                    .await?,\n                                 );\n-                                return Ok(());\n-                            }\n-                        }\n-                        \"view engine\" => {\n-                            if let Some(pkg) = pkg_or_dir.as_str() {\n-                                if pkg != \"html\" {\n-                                    let pat = js_value_to_pattern(pkg_or_dir);\n-                                    analysis.add_reference(\n-                                        CjsAssetReference::new(\n-                                            *origin,\n-                                            Request::parse(Value::new(pat)),\n-                                            issue_source(source, span),\n-                                            in_try,\n-                                        )\n-                                        .to_resolved()\n-                                        .await?,\n-                                    );\n-                                }\n-                                return Ok(());\n                             }\n+                            return Ok(());\n                         }\n-                        _ => {}\n                     }\n+                    _ => {}\n                 }\n             }\n             let (args, hints) = explain_args(&args);\n@@ -2363,36 +2358,33 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n         }\n         JsValue::WellKnownFunction(WellKnownFunctionKind::NodeProtobufLoad) => {\n             let args = linked_args(args).await?;\n-            if args.len() == 2 {\n-                if let Some(JsValue::Object { parts, .. }) = args.get(1) {\n-                    let resolved_dirs = parts\n-                        .iter()\n-                        .filter_map(|object_part| match object_part {\n-                            ObjectPart::KeyValue(\n-                                JsValue::Constant(key),\n-                                JsValue::Array { items: dirs, .. },\n-                            ) if key.as_str() == Some(\"includeDirs\") => {\n-                                Some(dirs.iter().filter_map(|dir| dir.as_str()))\n-                            }\n-                            _ => None,\n-                        })\n-                        .flatten()\n-                        .map(|dir| {\n-                            DirAssetReference::new(\n-                                *source,\n-                                Pattern::new(Pattern::Constant(dir.into())),\n-                            )\n+            if args.len() == 2\n+                && let Some(JsValue::Object { parts, .. }) = args.get(1)\n+            {\n+                let resolved_dirs = parts\n+                    .iter()\n+                    .filter_map(|object_part| match object_part {\n+                        ObjectPart::KeyValue(\n+                            JsValue::Constant(key),\n+                            JsValue::Array { items: dirs, .. },\n+                        ) if key.as_str() == Some(\"includeDirs\") => {\n+                            Some(dirs.iter().filter_map(|dir| dir.as_str()))\n+                        }\n+                        _ => None,\n+                    })\n+                    .flatten()\n+                    .map(|dir| {\n+                        DirAssetReference::new(*source, Pattern::new(Pattern::Constant(dir.into())))\n                             .to_resolved()\n-                        })\n-                        .try_join()\n-                        .await?;\n-\n-                    for resolved_dir_ref in resolved_dirs {\n-                        analysis.add_reference(resolved_dir_ref);\n-                    }\n+                    })\n+                    .try_join()\n+                    .await?;\n \n-                    return Ok(());\n+                for resolved_dir_ref in resolved_dirs {\n+                    analysis.add_reference(resolved_dir_ref);\n                 }\n+\n+                return Ok(());\n             }\n             let (args, hints) = explain_args(&args);\n             handler.span_warn_with_code(\n@@ -2463,12 +2455,11 @@ async fn handle_member(\n             }\n         }\n \n-        if is_prop_cache {\n-            if let JsValue::WellKnownFunction(WellKnownFunctionKind::Require) =\n+        if is_prop_cache\n+            && let JsValue::WellKnownFunction(WellKnownFunctionKind::Require) =\n                 obj.as_ref().unwrap()\n-            {\n-                analysis.add_code_gen(CjsRequireCacheAccess::new(ast_path.to_vec().into()));\n-            }\n+        {\n+            analysis.add_code_gen(CjsRequireCacheAccess::new(ast_path.to_vec().into()));\n         }\n     }\n \n@@ -2882,14 +2873,14 @@ async fn value_visitor_inner(\n     // This check is just an optimization\n     if v.get_defineable_name_len().is_some() {\n         let compile_time_info = compile_time_info.await?;\n-        if let JsValue::TypeOf(_, arg) = &v {\n-            if let Some(value) = arg.match_free_var_reference(\n+        if let JsValue::TypeOf(_, arg) = &v\n+            && let Some(value) = arg.match_free_var_reference(\n                 Some(var_graph),\n                 free_var_references,\n                 &DefineableNameSegment::TypeOf,\n-            ) {\n-                return Ok(((&*value.await?).into(), true));\n-            }\n+            )\n+        {\n+            return Ok(((&*value.await?).into(), true));\n         }\n \n         if let Some(value) = v.match_define(&*compile_time_info.defines.individual().await?) {\n@@ -3433,26 +3424,18 @@ impl VisitAstPath for ModuleReferencesVisitor<'_> {\n         decl: &'ast VarDeclarator,\n         ast_path: &mut AstNodePath<AstParentNodeRef<'r>>,\n     ) {\n-        if let Some(ident) = decl.name.as_ident() {\n-            if &*ident.id.sym == \"__webpack_require__\" {\n-                if let Some(init) = &decl.init {\n-                    if let Some(call) = init.as_call() {\n-                        if let Some(expr) = call.callee.as_expr() {\n-                            if let Some(ident) = expr.as_ident() {\n-                                if &*ident.sym == \"require\" {\n-                                    if let [ExprOrSpread { spread: None, expr }] = &call.args[..] {\n-                                        if let Some(Lit::Str(str)) = expr.as_lit() {\n-                                            self.webpack_runtime =\n-                                                Some((str.value.as_str().into(), call.span));\n-                                            return;\n-                                        }\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n+        if let Some(ident) = decl.name.as_ident()\n+            && &*ident.id.sym == \"__webpack_require__\"\n+            && let Some(init) = &decl.init\n+            && let Some(call) = init.as_call()\n+            && let Some(expr) = call.callee.as_expr()\n+            && let Some(ident) = expr.as_ident()\n+            && &*ident.sym == \"require\"\n+            && let [ExprOrSpread { spread: None, expr }] = &call.args[..]\n+            && let Some(Lit::Str(str)) = expr.as_lit()\n+        {\n+            self.webpack_runtime = Some((str.value.as_str().into(), call.span));\n+            return;\n         }\n         decl.visit_children_with_ast_path(self, ast_path);\n     }\n@@ -3462,39 +3445,38 @@ impl VisitAstPath for ModuleReferencesVisitor<'_> {\n         call: &'ast CallExpr,\n         ast_path: &mut AstNodePath<AstParentNodeRef<'r>>,\n     ) {\n-        if let Callee::Expr(expr) = &call.callee {\n-            if let StaticExpr::FreeVar(var) = self.old_analyser.evaluate_expr(expr) {\n-                match &var[..] {\n-                    [webpack_require, property]\n-                        if webpack_require == \"__webpack_require__\" && property == \"C\" =>\n-                    {\n-                        self.webpack_entry = true;\n-                    }\n-                    [webpack_require, property]\n-                        if webpack_require == \"__webpack_require__\" && property == \"X\" =>\n+        if let Callee::Expr(expr) = &call.callee\n+            && let StaticExpr::FreeVar(var) = self.old_analyser.evaluate_expr(expr)\n+        {\n+            match &var[..] {\n+                [webpack_require, property]\n+                    if webpack_require == \"__webpack_require__\" && property == \"C\" =>\n+                {\n+                    self.webpack_entry = true;\n+                }\n+                [webpack_require, property]\n+                    if webpack_require == \"__webpack_require__\" && property == \"X\" =>\n+                {\n+                    if let [\n+                        _,\n+                        ExprOrSpread {\n+                            spread: None,\n+                            expr: chunk_ids,\n+                        },\n+                        _,\n+                    ] = &call.args[..]\n+                        && let Some(array) = chunk_ids.as_array()\n                     {\n-                        if let [\n-                            _,\n-                            ExprOrSpread {\n-                                spread: None,\n-                                expr: chunk_ids,\n-                            },\n-                            _,\n-                        ] = &call.args[..]\n-                        {\n-                            if let Some(array) = chunk_ids.as_array() {\n-                                for elem in array.elems.iter().flatten() {\n-                                    if let ExprOrSpread { spread: None, expr } = elem {\n-                                        if let Some(lit) = expr.as_lit() {\n-                                            self.webpack_chunks.push(lit.clone());\n-                                        }\n-                                    }\n-                                }\n+                        for elem in array.elems.iter().flatten() {\n+                            if let ExprOrSpread { spread: None, expr } = elem\n+                                && let Some(lit) = expr.as_lit()\n+                            {\n+                                self.webpack_chunks.push(lit.clone());\n                             }\n                         }\n                     }\n-                    _ => {}\n                 }\n+                _ => {}\n             }\n         }\n         call.visit_children_with_ast_path(self, ast_path);\n@@ -3621,25 +3603,23 @@ fn detect_dynamic_export(p: &Program) -> DetectedDynamicExportType {\n                 return;\n             }\n \n-            if let Expr::Member(member) = n {\n-                if member.obj.is_ident_ref_to(\"__turbopack_context__\") {\n-                    if let MemberProp::Ident(prop) = &member.prop {\n-                        const TURBOPACK_EXPORT_VALUE_SHORTCUT: &str =\n-                            TURBOPACK_EXPORT_VALUE.shortcut;\n-                        const TURBOPACK_EXPORT_NAMESPACE_SHORTCUT: &str =\n-                            TURBOPACK_EXPORT_NAMESPACE.shortcut;\n-                        match &*prop.sym {\n-                            TURBOPACK_EXPORT_VALUE_SHORTCUT => {\n-                                self.value = true;\n-                                self.found = true;\n-                            }\n-                            TURBOPACK_EXPORT_NAMESPACE_SHORTCUT => {\n-                                self.namespace = true;\n-                                self.found = true;\n-                            }\n-                            _ => {}\n-                        }\n+            if let Expr::Member(member) = n\n+                && member.obj.is_ident_ref_to(\"__turbopack_context__\")\n+                && let MemberProp::Ident(prop) = &member.prop\n+            {\n+                const TURBOPACK_EXPORT_VALUE_SHORTCUT: &str = TURBOPACK_EXPORT_VALUE.shortcut;\n+                const TURBOPACK_EXPORT_NAMESPACE_SHORTCUT: &str =\n+                    TURBOPACK_EXPORT_NAMESPACE.shortcut;\n+                match &*prop.sym {\n+                    TURBOPACK_EXPORT_VALUE_SHORTCUT => {\n+                        self.value = true;\n+                        self.found = true;\n+                    }\n+                    TURBOPACK_EXPORT_NAMESPACE_SHORTCUT => {\n+                        self.namespace = true;\n+                        self.found = true;\n                     }\n+                    _ => {}\n                 }\n             }\n \n@@ -3689,27 +3669,24 @@ fn is_invoking_node_process_eval(args: &[JsValue]) -> bool {\n         ) = (obj, constant)\n         {\n             // Is it specifically `process.argv[0]`?\n-            if num.is_zero() {\n-                if let JsValue::Array {\n+            if num.is_zero()\n+                && let JsValue::Array {\n                     total_nodes: _,\n                     items,\n                     mutable: _,\n                 } = &args[1]\n-                {\n-                    // Is `-e` one of the arguments passed to the program?\n-                    if items.iter().any(|e| {\n-                        if let JsValue::Constant(JsConstantValue::Str(ConstantString::Atom(arg))) =\n-                            e\n-                        {\n-                            arg == \"-e\"\n-                        } else {\n-                            false\n-                        }\n-                    }) {\n-                        // If so, this is likely spawning node to evaluate a string, and\n-                        // does not need to be statically analyzed.\n-                        return true;\n+            {\n+                // Is `-e` one of the arguments passed to the program?\n+                if items.iter().any(|e| {\n+                    if let JsValue::Constant(JsConstantValue::Str(ConstantString::Atom(arg))) = e {\n+                        arg == \"-e\"\n+                    } else {\n+                        false\n                     }\n+                }) {\n+                    // If so, this is likely spawning node to evaluate a string, and\n+                    // does not need to be statically analyzed.\n+                    return true;\n                 }\n             }\n         }"
        },
        {
            "sha": "3f098a389317e3871569679fb0fc5a07e99dea5a",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/require_context.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Frequire_context.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Frequire_context.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Frequire_context.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -90,10 +90,10 @@ impl DirList {\n         for (_, entry) in entries.iter().flat_map(|m| m.iter()) {\n             match entry {\n                 DirectoryEntry::File(path) => {\n-                    if let Some(relative_path) = root_val.get_relative_path_to(&*path.await?) {\n-                        if regex.is_match(&relative_path) {\n-                            list.insert(relative_path, DirListEntry::File(*path));\n-                        }\n+                    if let Some(relative_path) = root_val.get_relative_path_to(&*path.await?)\n+                        && regex.is_match(&relative_path)\n+                    {\n+                        list.insert(relative_path, DirListEntry::File(*path));\n                     }\n                 }\n                 DirectoryEntry::Directory(path) if recursive => {"
        },
        {
            "sha": "64adf11523a3a4f5fbc3cf6e87d216f45d7663a2",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/worker.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 4,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fworker.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fworker.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fworker.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -157,15 +157,13 @@ impl WorkerAssetReferenceCodeGen {\n                                 item_id: Expr = item_id\n                             );\n \n-                            if let Some(opts) = args.get_mut(1) {\n-                                if opts.spread.is_none(){\n+                            if let Some(opts) = args.get_mut(1)\n+                                && opts.spread.is_none(){\n                                     *opts.expr = *quote_expr!(\n                                         \"{...$opts, type: undefined}\",\n                                         opts: Expr = (*opts.expr).take()\n                                     );\n                                 }\n-\n-                            }\n                             return;\n                         }\n                         // These are SWC bugs: https://github.com/swc-project/swc/issues/5394"
        },
        {
            "sha": "2cd4244ddd0c07e17cfd428857d87f519d7a8331",
            "filename": "turbopack/crates/turbopack-ecmascript/src/tree_shake/chunk_item.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fchunk_item.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fchunk_item.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fchunk_item.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -130,10 +130,10 @@ impl EcmascriptChunkItem for SideEffectsModuleChunkItem {\n         for &side_effect in self.module.await?.side_effects.iter() {\n             let need_await = 'need_await: {\n                 let async_module = *side_effect.get_async_module().await?;\n-                if let Some(async_module) = async_module {\n-                    if async_module.await?.has_top_level_await {\n-                        break 'need_await true;\n-                    }\n+                if let Some(async_module) = async_module\n+                    && async_module.await?.has_top_level_await\n+                {\n+                    break 'need_await true;\n                 }\n                 false\n             };"
        },
        {
            "sha": "3afc6b5fde4213a45496efc39ecfcd491e691334",
            "filename": "turbopack/crates/turbopack-ecmascript/src/tree_shake/graph.rs",
            "status": "modified",
            "additions": 48,
            "deletions": 52,
            "changes": 100,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fgraph.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fgraph.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fgraph.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -334,10 +334,9 @@ impl DepGraph {\n                     src,\n                     ..\n                 })) = &item.content\n+                    && specifiers.is_empty()\n                 {\n-                    if specifiers.is_empty() {\n-                        importer.insert(src.value.clone(), ix as u32);\n-                    }\n+                    importer.insert(src.value.clone(), ix as u32);\n                 }\n             }\n         }\n@@ -391,30 +390,28 @@ impl DepGraph {\n                     src,\n                     ..\n                 })) = &data.content\n+                    && !specifiers.is_empty()\n+                    && let Some(dep) = importer.get(&src.value)\n+                    && *dep != ix as u32\n+                    && part_deps_done.insert(*dep)\n                 {\n-                    if !specifiers.is_empty() {\n-                        if let Some(dep) = importer.get(&src.value) {\n-                            if *dep != ix as u32 && part_deps_done.insert(*dep) {\n-                                part_deps\n-                                    .entry(ix as u32)\n-                                    .or_default()\n-                                    .push(PartId::Internal(*dep, true));\n-\n-                                chunk.body.push(ModuleItem::ModuleDecl(ModuleDecl::Import(\n-                                    ImportDecl {\n-                                        span: DUMMY_SP,\n-                                        specifiers: vec![],\n-                                        src: Box::new(TURBOPACK_PART_IMPORT_SOURCE.into()),\n-                                        type_only: false,\n-                                        with: Some(Box::new(create_turbopack_part_id_assert(\n-                                            PartId::Internal(*dep, true),\n-                                        ))),\n-                                        phase: Default::default(),\n-                                    },\n-                                )));\n-                            }\n-                        }\n-                    }\n+                    part_deps\n+                        .entry(ix as u32)\n+                        .or_default()\n+                        .push(PartId::Internal(*dep, true));\n+\n+                    chunk\n+                        .body\n+                        .push(ModuleItem::ModuleDecl(ModuleDecl::Import(ImportDecl {\n+                            span: DUMMY_SP,\n+                            specifiers: vec![],\n+                            src: Box::new(TURBOPACK_PART_IMPORT_SOURCE.into()),\n+                            type_only: false,\n+                            with: Some(Box::new(create_turbopack_part_id_assert(\n+                                PartId::Internal(*dep, true),\n+                            ))),\n+                            phase: Default::default(),\n+                        })));\n                 }\n             }\n \n@@ -533,26 +530,26 @@ impl DepGraph {\n                         // Preserve the order of the side effects by importing the\n                         // side-effect-import fragment first.\n \n-                        if let Some(import_dep) = importer.get(&module_specifier.value) {\n-                            if *import_dep != ix as u32 {\n-                                part_deps\n-                                    .entry(ix as u32)\n-                                    .or_default()\n-                                    .push(PartId::Internal(*import_dep, true));\n+                        if let Some(import_dep) = importer.get(&module_specifier.value)\n+                            && *import_dep != ix as u32\n+                        {\n+                            part_deps\n+                                .entry(ix as u32)\n+                                .or_default()\n+                                .push(PartId::Internal(*import_dep, true));\n \n-                                chunk.body.push(ModuleItem::ModuleDecl(ModuleDecl::Import(\n-                                    ImportDecl {\n-                                        span: DUMMY_SP,\n-                                        specifiers: vec![],\n-                                        src: Box::new(TURBOPACK_PART_IMPORT_SOURCE.into()),\n-                                        type_only: false,\n-                                        with: Some(Box::new(create_turbopack_part_id_assert(\n-                                            PartId::Internal(*import_dep, true),\n-                                        ))),\n-                                        phase: Default::default(),\n-                                    },\n-                                )));\n-                            }\n+                            chunk.body.push(ModuleItem::ModuleDecl(ModuleDecl::Import(\n+                                ImportDecl {\n+                                    span: DUMMY_SP,\n+                                    specifiers: vec![],\n+                                    src: Box::new(TURBOPACK_PART_IMPORT_SOURCE.into()),\n+                                    type_only: false,\n+                                    with: Some(Box::new(create_turbopack_part_id_assert(\n+                                        PartId::Internal(*import_dep, true),\n+                                    ))),\n+                                    phase: Default::default(),\n+                                },\n+                            )));\n                         }\n \n                         let specifiers = vec![import_specifier.clone()];\n@@ -644,10 +641,9 @@ impl DepGraph {\n                     expr: box Expr::Lit(Lit::Str(s)),\n                     ..\n                 })) = &data[g].content\n+                    && s.value.starts_with(\"use \")\n                 {\n-                    if s.value.starts_with(\"use \") {\n-                        continue;\n-                    }\n+                    continue;\n                 }\n \n                 // Do not store export * in internal part fragments.\n@@ -1573,10 +1569,10 @@ impl DepGraph {\n \n             let item_id = self.g.graph_ix.get_index(*ix as _).unwrap();\n \n-            if let ItemId::Group(ItemIdGroupKind::Export(v, name)) = item_id {\n-                if name.starts_with(\"$$RSC_SERVER_\") {\n-                    server_action_exports.insert(v.0.clone(), node);\n-                }\n+            if let ItemId::Group(ItemIdGroupKind::Export(v, name)) = item_id\n+                && name.starts_with(\"$$RSC_SERVER_\")\n+            {\n+                server_action_exports.insert(v.0.clone(), node);\n             }\n \n             let item_data = &data[item_id];"
        },
        {
            "sha": "0586b86fe2e80d0cb368a2d5509f6eb70c10625c",
            "filename": "turbopack/crates/turbopack-ecmascript/src/tree_shake/mod.rs",
            "status": "modified",
            "additions": 33,
            "deletions": 34,
            "changes": 67,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fmod.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -97,10 +97,10 @@ impl Analyzer<'_> {\n \n     fn handle_explicit_deps(&mut self) {\n         for item_id in self.item_ids.iter() {\n-            if let Some(item) = self.items.get(item_id) {\n-                if !item.explicit_deps.is_empty() {\n-                    self.g.add_strong_deps(item_id, item.explicit_deps.iter());\n-                }\n+            if let Some(item) = self.items.get(item_id)\n+                && !item.explicit_deps.is_empty()\n+            {\n+                self.g.add_strong_deps(item_id, item.explicit_deps.iter());\n             }\n         }\n     }\n@@ -170,12 +170,12 @@ impl Analyzer<'_> {\n                     let state = self.vars.entry(id.clone()).or_default();\n                     self.g.add_strong_deps(item_id, state.last_writes.iter());\n \n-                    if let Some(declarator) = &state.declarator {\n-                        if declarator != item_id {\n-                            // A read also depends on the declaration.\n-                            self.g\n-                                .add_strong_deps(item_id, [declarator].iter().copied());\n-                        }\n+                    if let Some(declarator) = &state.declarator\n+                        && declarator != item_id\n+                    {\n+                        // A read also depends on the declaration.\n+                        self.g\n+                            .add_strong_deps(item_id, [declarator].iter().copied());\n                     }\n \n                     if state.last_op == Some(VarOp::Write) && !item.write_vars.contains(id) {\n@@ -194,11 +194,11 @@ impl Analyzer<'_> {\n                     let state = self.vars.entry(id.clone()).or_default();\n                     self.g.add_weak_deps(item_id, state.last_reads.iter());\n \n-                    if let Some(declarator) = &state.declarator {\n-                        if declarator != item_id {\n-                            // A write also depends on the declaration.\n-                            self.g.add_strong_deps(item_id, [declarator]);\n-                        }\n+                    if let Some(declarator) = &state.declarator\n+                        && declarator != item_id\n+                    {\n+                        // A write also depends on the declaration.\n+                        self.g.add_strong_deps(item_id, [declarator]);\n                     }\n \n                     if !item.read_vars.contains(id) {\n@@ -317,11 +317,11 @@ impl Analyzer<'_> {\n                     let state = self.vars.entry(id.clone()).or_default();\n                     self.g.add_strong_deps(item_id, state.last_writes.iter());\n \n-                    if let Some(declarator) = &state.declarator {\n-                        if declarator != item_id {\n-                            // A read also depends on the declaration.\n-                            self.g.add_strong_deps(item_id, [declarator]);\n-                        }\n+                    if let Some(declarator) = &state.declarator\n+                        && declarator != item_id\n+                    {\n+                        // A read also depends on the declaration.\n+                        self.g.add_strong_deps(item_id, [declarator]);\n                     }\n                 }\n \n@@ -334,11 +334,11 @@ impl Analyzer<'_> {\n \n                     self.g.add_weak_deps(item_id, state.last_reads.iter());\n \n-                    if let Some(declarator) = &state.declarator {\n-                        if declarator != item_id {\n-                            // A write also depends on the declaration.\n-                            self.g.add_strong_deps(item_id, [declarator]);\n-                        }\n+                    if let Some(declarator) = &state.declarator\n+                        && declarator != item_id\n+                    {\n+                        // A write also depends on the declaration.\n+                        self.g.add_strong_deps(item_id, [declarator]);\n                     }\n                 }\n \n@@ -351,10 +351,10 @@ impl Analyzer<'_> {\n     /// Phase 4: Exports\n     fn handle_exports(&mut self, _module: &Module) {\n         // We use the last side effect as a module evaluation\n-        if let Some(last) = self.last_side_effects.last() {\n-            if let Some(item) = self.items.get_mut(last) {\n-                item.is_module_evaluation = true;\n-            }\n+        if let Some(last) = self.last_side_effects.last()\n+            && let Some(item) = self.items.get_mut(last)\n+        {\n+            item.is_module_evaluation = true;\n         }\n \n         for item_id in self.item_ids.iter() {\n@@ -407,13 +407,12 @@ async fn get_part_id(result: &SplitResult, part: &ModulePart) -> Result<u32> {\n     }\n \n     // This is required to handle `export * from 'foo'`\n-    if let ModulePart::Export(..) = part {\n-        if let Some(&v) = entrypoints\n+    if let ModulePart::Export(..) = part\n+        && let Some(&v) = entrypoints\n             .get(&Key::StarExports)\n             .or_else(|| entrypoints.get(&Key::Exports))\n-        {\n-            return Ok(v);\n-        }\n+    {\n+        return Ok(v);\n     }\n \n     let mut dump = String::new();"
        },
        {
            "sha": "36ee476c4635a96d43eee28095096ce6b65e5f9d",
            "filename": "turbopack/crates/turbopack-ecmascript/src/tree_shake/optimizations.rs",
            "status": "modified",
            "additions": 9,
            "deletions": 10,
            "changes": 19,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Foptimizations.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Foptimizations.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Foptimizations.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -173,18 +173,17 @@ impl GraphOptimizer<'_> {\n             }\n \n             // If this node is reachable from exactly one starting node, add it to that group\n-            if let Some(reachable_from) = reachability.get(&node) {\n-                if reachable_from.len() == 1 {\n-                    let start = *reachable_from.iter().next().unwrap();\n-\n-                    // Don't merge if the starting node should not be merged\n-                    if self.should_not_merge_iter(g.node_weight(start).expect(\"Node should exist\"))\n-                    {\n-                        continue;\n-                    }\n+            if let Some(reachable_from) = reachability.get(&node)\n+                && reachable_from.len() == 1\n+            {\n+                let start = *reachable_from.iter().next().unwrap();\n \n-                    merge_groups.entry(start).or_default().push(node);\n+                // Don't merge if the starting node should not be merged\n+                if self.should_not_merge_iter(g.node_weight(start).expect(\"Node should exist\")) {\n+                    continue;\n                 }\n+\n+                merge_groups.entry(start).or_default().push(node);\n             }\n         }\n "
        },
        {
            "sha": "e81b02249cd3d5f8b9b90d4e862c845c8628ba8c",
            "filename": "turbopack/crates/turbopack-ecmascript/src/tree_shake/util.rs",
            "status": "modified",
            "additions": 16,
            "deletions": 18,
            "changes": 34,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Futil.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Futil.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Futil.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -359,10 +359,10 @@ impl Visit for TopLevelBindingCollector {\n     fn visit_pat(&mut self, node: &Pat) {\n         node.visit_children_with(self);\n \n-        if self.is_pat_decl {\n-            if let Pat::Ident(i) = node {\n-                self.add(&i.id)\n-            }\n+        if self.is_pat_decl\n+            && let Pat::Ident(i) = node\n+        {\n+            self.add(&i.id)\n         }\n     }\n \n@@ -423,10 +423,10 @@ pub fn should_skip_tree_shaking(m: &Program) -> bool {\n \n                 // TODO(PACK-3150): Tree shaking has a bug related to ModuleExportName::Str\n                 for s in specifiers.iter() {\n-                    if let ImportSpecifier::Named(is) = s {\n-                        if matches!(is.imported, Some(ModuleExportName::Str(..))) {\n-                            return true;\n-                        }\n+                    if let ImportSpecifier::Named(is) = s\n+                        && matches!(is.imported, Some(ModuleExportName::Str(..)))\n+                    {\n+                        return true;\n                     }\n                 }\n             }\n@@ -438,12 +438,11 @@ pub fn should_skip_tree_shaking(m: &Program) -> bool {\n                 ..\n             })) => {\n                 for s in specifiers {\n-                    if let ExportSpecifier::Named(es) = s {\n-                        if matches!(es.orig, ModuleExportName::Str(..))\n-                            || matches!(es.exported, Some(ModuleExportName::Str(..)))\n-                        {\n-                            return true;\n-                        }\n+                    if let ExportSpecifier::Named(es) = s\n+                        && (matches!(es.orig, ModuleExportName::Str(..))\n+                            || matches!(es.exported, Some(ModuleExportName::Str(..))))\n+                    {\n+                        return true;\n                     }\n                 }\n             }\n@@ -480,11 +479,10 @@ impl Visit for ShouldSkip {\n             callee: Callee::Expr(expr),\n             ..\n         }) = &*n.arg\n+            && expr.is_ident_ref_to(\"__turbopack_wasm_module__\")\n         {\n-            if expr.is_ident_ref_to(\"__turbopack_wasm_module__\") {\n-                self.skip = true;\n-                return;\n-            }\n+            self.skip = true;\n+            return;\n         }\n \n         n.visit_children_with(self);"
        },
        {
            "sha": "c306dc6b15af85b5093c0823717b1e7bc34dc5ee",
            "filename": "turbopack/crates/turbopack-ecmascript/src/webpack/parse.rs",
            "status": "modified",
            "additions": 76,
            "deletions": 88,
            "changes": 164,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fwebpack%2Fparse.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fwebpack%2Fparse.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fwebpack%2Fparse.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -37,18 +37,17 @@ pub enum WebpackRuntime {\n }\n \n fn iife(stmt: &Stmt) -> Option<&Vec<Stmt>> {\n-    if let Stmt::Expr(ExprStmt { expr, .. }) = &stmt {\n-        if let Expr::Call(CallExpr {\n+    if let Stmt::Expr(ExprStmt { expr, .. }) = &stmt\n+        && let Expr::Call(CallExpr {\n             callee: Callee::Expr(callee),\n             args,\n             ..\n         }) = unparen(expr)\n-        {\n-            if !args.is_empty() {\n-                return None;\n-            }\n-            return get_fn_body(callee);\n+    {\n+        if !args.is_empty() {\n+            return None;\n         }\n+        return get_fn_body(callee);\n     }\n     None\n }\n@@ -70,10 +69,10 @@ fn program_iife(program: &Program) -> Option<&Vec<Stmt>> {\n }\n \n fn is_webpack_require_decl(stmt: &Stmt) -> bool {\n-    if let Some(decl) = stmt.as_decl() {\n-        if let Some(fn_decl) = decl.as_fn_decl() {\n-            return &*fn_decl.ident.sym == \"__webpack_require__\";\n-        }\n+    if let Some(decl) = stmt.as_decl()\n+        && let Some(fn_decl) = decl.as_fn_decl()\n+    {\n+        return &*fn_decl.ident.sym == \"__webpack_require__\";\n     }\n     false\n }\n@@ -82,10 +81,10 @@ fn get_assign_target_identifier(expr: &AssignTarget) -> Option<Cow<'_, str>> {\n     match expr.as_simple()? {\n         SimpleAssignTarget::Ident(ident) => Some(Cow::Borrowed(&*ident.sym)),\n         SimpleAssignTarget::Member(member) => {\n-            if let Some(obj_name) = get_expr_identifier(&member.obj) {\n-                if let Some(ident) = member.prop.as_ident() {\n-                    return Some(Cow::Owned(obj_name.into_owned() + \".\" + &*ident.sym));\n-                }\n+            if let Some(obj_name) = get_expr_identifier(&member.obj)\n+                && let Some(ident) = member.prop.as_ident()\n+            {\n+                return Some(Cow::Owned(obj_name.into_owned() + \".\" + &*ident.sym));\n             }\n             None\n         }\n@@ -100,62 +99,56 @@ fn get_expr_identifier(expr: &Expr) -> Option<Cow<'_, str>> {\n     if let Some(ident) = expr.as_ident() {\n         return Some(Cow::Borrowed(&*ident.sym));\n     }\n-    if let Some(member) = expr.as_member() {\n-        if let Some(ident) = member.prop.as_ident() {\n-            if let Some(obj_name) = get_expr_identifier(&member.obj) {\n-                return Some(Cow::Owned(obj_name.into_owned() + \".\" + &*ident.sym));\n-            }\n-        }\n+    if let Some(member) = expr.as_member()\n+        && let Some(ident) = member.prop.as_ident()\n+        && let Some(obj_name) = get_expr_identifier(&member.obj)\n+    {\n+        return Some(Cow::Owned(obj_name.into_owned() + \".\" + &*ident.sym));\n     }\n     None\n }\n \n fn get_assignment<'a>(stmts: &'a Vec<Stmt>, property: &str) -> Option<&'a Expr> {\n     for stmt in stmts {\n-        if let Some(stmts) = iife(stmt) {\n-            if let Some(result) = get_assignment(stmts, property) {\n-                return Some(result);\n-            }\n+        if let Some(stmts) = iife(stmt)\n+            && let Some(result) = get_assignment(stmts, property)\n+        {\n+            return Some(result);\n         }\n-        if let Some(expr_stmt) = stmt.as_expr() {\n-            if let Some(assign) = unparen(&expr_stmt.expr).as_assign() {\n-                if assign.op == AssignOp::Assign {\n-                    if let Some(name) = get_assign_target_identifier(&assign.left) {\n-                        if name == property {\n-                            return Some(unparen(&assign.right));\n-                        }\n-                    }\n-                }\n-            }\n+        if let Some(expr_stmt) = stmt.as_expr()\n+            && let Some(assign) = unparen(&expr_stmt.expr).as_assign()\n+            && assign.op == AssignOp::Assign\n+            && let Some(name) = get_assign_target_identifier(&assign.left)\n+            && name == property\n+        {\n+            return Some(unparen(&assign.right));\n         }\n     }\n     None\n }\n \n fn get_fn_body(expr: &Expr) -> Option<&Vec<Stmt>> {\n     let expr = unparen(expr);\n-    if let Some(FnExpr { function, .. }) = expr.as_fn_expr() {\n-        if let Some(body) = &function.body {\n-            return Some(&body.stmts);\n-        }\n+    if let Some(FnExpr { function, .. }) = expr.as_fn_expr()\n+        && let Some(body) = &function.body\n+    {\n+        return Some(&body.stmts);\n     }\n-    if let Some(ArrowExpr { body, .. }) = expr.as_arrow() {\n-        if let Some(block) = body.as_block_stmt() {\n-            return Some(&block.stmts);\n-        }\n+    if let Some(ArrowExpr { body, .. }) = expr.as_arrow()\n+        && let Some(block) = body.as_block_stmt()\n+    {\n+        return Some(&block.stmts);\n     }\n     None\n }\n \n fn get_javascript_chunk_filename(stmts: &Vec<Stmt>, eval_context: &EvalContext) -> Option<JsValue> {\n-    if let Some(expr) = get_assignment(stmts, \"__webpack_require__.u\") {\n-        if let Some(stmts) = get_fn_body(expr) {\n-            if let Some(ret) = stmts.iter().find_map(|stmt| stmt.as_return_stmt()) {\n-                if let Some(expr) = &ret.arg {\n-                    return Some(eval_context.eval(expr));\n-                }\n-            }\n-        }\n+    if let Some(expr) = get_assignment(stmts, \"__webpack_require__.u\")\n+        && let Some(stmts) = get_fn_body(expr)\n+        && let Some(ret) = stmts.iter().find_map(|stmt| stmt.as_return_stmt())\n+        && let Some(expr) = &ret.arg\n+    {\n+        return Some(eval_context.eval(expr));\n     }\n     None\n }\n@@ -166,22 +159,18 @@ struct RequirePrefixVisitor {\n \n impl Visit for RequirePrefixVisitor {\n     fn visit_call_expr(&mut self, call: &CallExpr) {\n-        if let Some(expr) = call.callee.as_expr() {\n-            if let Some(name) = get_expr_identifier(expr) {\n-                if name == \"require\" {\n-                    if let [ExprOrSpread { spread: None, expr }] = &call.args[..] {\n-                        if let Some(BinExpr {\n-                            op: BinaryOp::Add,\n-                            left,\n-                            ..\n-                        }) = expr.as_bin()\n-                        {\n-                            self.result = left.as_lit().cloned();\n-                            return;\n-                        }\n-                    }\n-                }\n-            }\n+        if let Some(expr) = call.callee.as_expr()\n+            && let Some(name) = get_expr_identifier(expr)\n+            && name == \"require\"\n+            && let [ExprOrSpread { spread: None, expr }] = &call.args[..]\n+            && let Some(BinExpr {\n+                op: BinaryOp::Add,\n+                left,\n+                ..\n+            }) = expr.as_bin()\n+        {\n+            self.result = left.as_lit().cloned();\n+            return;\n         }\n         call.visit_children_with(self);\n     }\n@@ -214,28 +203,27 @@ pub async fn webpack_runtime(\n             globals,\n             ..\n         } => {\n-            if let Some(stmts) = program_iife(program) {\n-                if stmts.iter().any(is_webpack_require_decl) {\n-                    // extract webpack/runtime/get javascript chunk filename\n-                    let chunk_filename = GLOBALS.set(globals, || {\n-                        get_javascript_chunk_filename(stmts, eval_context)\n-                    });\n-\n-                    let prefix_path = get_require_prefix(stmts);\n-\n-                    if let (Some(chunk_filename), Some(prefix_path)) = (chunk_filename, prefix_path)\n-                    {\n-                        let value = JsValue::concat(vec![\n-                            JsValue::Constant(prefix_path.into()),\n-                            chunk_filename,\n-                        ]);\n-\n-                        return Ok(WebpackRuntime::Webpack5 {\n-                            chunk_request_expr: value,\n-                            context_path: source.ident().path().parent().to_resolved().await?,\n-                        }\n-                        .into());\n+            if let Some(stmts) = program_iife(program)\n+                && stmts.iter().any(is_webpack_require_decl)\n+            {\n+                // extract webpack/runtime/get javascript chunk filename\n+                let chunk_filename = GLOBALS.set(globals, || {\n+                    get_javascript_chunk_filename(stmts, eval_context)\n+                });\n+\n+                let prefix_path = get_require_prefix(stmts);\n+\n+                if let (Some(chunk_filename), Some(prefix_path)) = (chunk_filename, prefix_path) {\n+                    let value = JsValue::concat(vec![\n+                        JsValue::Constant(prefix_path.into()),\n+                        chunk_filename,\n+                    ]);\n+\n+                    return Ok(WebpackRuntime::Webpack5 {\n+                        chunk_request_expr: value,\n+                        context_path: source.ident().path().parent().to_resolved().await?,\n                     }\n+                    .into());\n                 }\n             }\n         }"
        },
        {
            "sha": "038ce072d1b278f3d817a3a716d92eb23a636196",
            "filename": "turbopack/crates/turbopack-ecmascript/src/webpack/references.rs",
            "status": "modified",
            "additions": 14,
            "deletions": 16,
            "changes": 30,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fwebpack%2Freferences.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fwebpack%2Freferences.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fwebpack%2Freferences.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -68,23 +68,21 @@ struct ModuleReferencesVisitor<'a> {\n \n impl Visit for ModuleReferencesVisitor<'_> {\n     fn visit_call_expr(&mut self, call: &CallExpr) {\n-        if let Some(member) = call.callee.as_expr().and_then(|e| e.as_member()) {\n-            if let (Some(obj), Some(prop)) = (member.obj.as_ident(), member.prop.as_ident()) {\n-                if &*obj.sym == \"__webpack_require__\" && &*prop.sym == \"e\" {\n-                    if let [ExprOrSpread { spread: None, expr }] = &call.args[..] {\n-                        if let Expr::Lit(lit) = &**expr {\n-                            self.references.push(ResolvedVc::upcast(\n-                                WebpackChunkAssetReference {\n-                                    chunk_id: lit.clone(),\n-                                    runtime: self.runtime,\n-                                    transforms: self.transforms,\n-                                }\n-                                .resolved_cell(),\n-                            ));\n-                        }\n-                    }\n+        if let Some(member) = call.callee.as_expr().and_then(|e| e.as_member())\n+            && let (Some(obj), Some(prop)) = (member.obj.as_ident(), member.prop.as_ident())\n+            && &*obj.sym == \"__webpack_require__\"\n+            && &*prop.sym == \"e\"\n+            && let [ExprOrSpread { spread: None, expr }] = &call.args[..]\n+            && let Expr::Lit(lit) = &**expr\n+        {\n+            self.references.push(ResolvedVc::upcast(\n+                WebpackChunkAssetReference {\n+                    chunk_id: lit.clone(),\n+                    runtime: self.runtime,\n+                    transforms: self.transforms,\n                 }\n-            }\n+                .resolved_cell(),\n+            ));\n         }\n         call.visit_children_with(self);\n     }"
        },
        {
            "sha": "850921bf7631f52e8b53dc09b435c653c09c4916",
            "filename": "turbopack/crates/turbopack-image/src/process/mod.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 7,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-image%2Fsrc%2Fprocess%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-image%2Fsrc%2Fprocess%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-image%2Fsrc%2Fprocess%2Fmod.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -145,13 +145,12 @@ fn load_image_internal(\n         .with_guessed_format()\n         .context(\"unable to determine image format from file content\")?;\n     let mut format = reader.format();\n-    if format.is_none() {\n-        if let Some(extension) = extension {\n-            if let Some(new_format) = extension_to_image_format(extension) {\n-                format = Some(new_format);\n-                reader.set_format(new_format);\n-            }\n-        }\n+    if format.is_none()\n+        && let Some(extension) = extension\n+        && let Some(new_format) = extension_to_image_format(extension)\n+    {\n+        format = Some(new_format);\n+        reader.set_format(new_format);\n     }\n \n     // [NOTE]"
        },
        {
            "sha": "2e55c80e2eb66757acde346807e13b849994c3d3",
            "filename": "turbopack/crates/turbopack-node/src/lib.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 3,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Flib.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -90,10 +90,9 @@ async fn internal_assets_for_source_mapping(\n     for asset in internal_assets.iter() {\n         if let Some(generate_source_map) =\n             ResolvedVc::try_sidecast::<Box<dyn GenerateSourceMap>>(*asset)\n+            && let Some(path) = intermediate_output_path.get_path_to(&*asset.path().await?)\n         {\n-            if let Some(path) = intermediate_output_path.get_path_to(&*asset.path().await?) {\n-                internal_assets_for_source_mapping.insert(path.to_string(), generate_source_map);\n-            }\n+            internal_assets_for_source_mapping.insert(path.to_string(), generate_source_map);\n         }\n     }\n     Ok(Vc::cell(internal_assets_for_source_mapping))"
        },
        {
            "sha": "538f23579c51bbc3707d6aadc749448c1b3b24b6",
            "filename": "turbopack/crates/turbopack-node/src/render/issue.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Fissue.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Fissue.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Fissue.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -36,12 +36,12 @@ impl Issue for RenderingIssue {\n     async fn detail(&self) -> Vc<OptionStyledString> {\n         let mut details = vec![];\n \n-        if let Some(status) = self.status {\n-            if status != 0 {\n-                details.push(StyledString::Text(\n-                    format!(\"Node.js exit code: {status}\").into(),\n-                ));\n-            }\n+        if let Some(status) = self.status\n+            && status != 0\n+        {\n+            details.push(StyledString::Text(\n+                format!(\"Node.js exit code: {status}\").into(),\n+            ));\n         }\n \n         Vc::cell(Some(StyledString::Stack(details).resolved_cell()))"
        },
        {
            "sha": "3552a979abb7eb03bd4e06d71dc4eee338599196",
            "filename": "turbopack/crates/turbopack-node/src/source_map/mod.rs",
            "status": "modified",
            "additions": 13,
            "deletions": 13,
            "changes": 26,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fsource_map%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fsource_map%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fsource_map%2Fmod.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -159,21 +159,21 @@ fn write_resolved(\n             let (line, column) = frame.get_pos().unwrap_or((0, 0));\n             let line = line.saturating_sub(1);\n             let column = column.saturating_sub(1);\n-            if let FileLinesContent::Lines(lines) = &*lines {\n-                if *visible_code_frames < MAX_CODE_FRAMES {\n-                    let lines = lines.iter().map(|l| l.content.as_str());\n-                    let ctx = get_source_context(lines, line, column, line, column);\n-                    match formatting_mode {\n-                        FormattingMode::Plain => {\n-                            write!(writable, \"\\n{ctx}\")?;\n-                        }\n-                        FormattingMode::AnsiColors => {\n-                            writable.write_char('\\n')?;\n-                            format_source_context_lines(&ctx, writable);\n-                        }\n+            if let FileLinesContent::Lines(lines) = &*lines\n+                && *visible_code_frames < MAX_CODE_FRAMES\n+            {\n+                let lines = lines.iter().map(|l| l.content.as_str());\n+                let ctx = get_source_context(lines, line, column, line, column);\n+                match formatting_mode {\n+                    FormattingMode::Plain => {\n+                        write!(writable, \"\\n{ctx}\")?;\n+                    }\n+                    FormattingMode::AnsiColors => {\n+                        writable.write_char('\\n')?;\n+                        format_source_context_lines(&ctx, writable);\n                     }\n-                    *visible_code_frames += 1;\n                 }\n+                *visible_code_frames += 1;\n             }\n         }\n     }"
        },
        {
            "sha": "347f8c3c928914be59c8385cb168977a25127b94",
            "filename": "turbopack/crates/turbopack-node/src/transforms/postcss.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 5,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Fpostcss.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Fpostcss.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Fpostcss.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -430,16 +430,15 @@ async fn find_config_in_location(\n         return Ok(Some(*config_path));\n     }\n \n-    if matches!(location, PostCssConfigLocation::ProjectPathOrLocalPath) {\n-        if let FindContextFileResult::Found(config_path, _) = *find_context_file_or_package_key(\n+    if matches!(location, PostCssConfigLocation::ProjectPathOrLocalPath)\n+        && let FindContextFileResult::Found(config_path, _) = *find_context_file_or_package_key(\n             source.ident().path().parent(),\n             postcss_configs(),\n             Value::new(rcstr!(\"postcss\")),\n         )\n         .await?\n-        {\n-            return Ok(Some(*config_path));\n-        }\n+    {\n+        return Ok(Some(*config_path));\n     }\n \n     Ok(None)"
        },
        {
            "sha": "571122f89d8fecb6771ce9fd9225db523a2f9f21",
            "filename": "turbopack/crates/turbopack-resolve/src/node_native_binding.rs",
            "status": "modified",
            "additions": 142,
            "deletions": 151,
            "changes": 293,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Fnode_native_binding.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Fnode_native_binding.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Fnode_native_binding.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -101,120 +101,117 @@ pub async fn resolve_node_pre_gyp_files(\n         .first_source()\n         .await?;\n     let compile_target = compile_target.await?;\n-    if let Some(config_asset) = *config {\n-        if let AssetContent::File(file) = &*config_asset.content().await? {\n-            if let FileContent::Content(config_file) = &*file.await? {\n-                let config_file_path = config_asset.ident().path();\n-                let mut affecting_paths = vec![config_file_path];\n-                let config_file_dir = config_file_path.parent();\n-                let node_pre_gyp_config: NodePreGypConfigJson =\n-                    parse_json_rope_with_source_context(config_file.content())?;\n-                let mut sources: FxIndexMap<RcStr, Vc<Box<dyn Source>>> = FxIndexMap::default();\n-                for version in node_pre_gyp_config.binary.napi_versions.iter() {\n-                    let native_binding_path = NAPI_VERSION_TEMPLATE.replace(\n-                        node_pre_gyp_config.binary.module_path.as_str(),\n-                        format!(\"{version}\"),\n-                    );\n-                    let platform = compile_target.platform;\n-                    let native_binding_path =\n-                        PLATFORM_TEMPLATE.replace(&native_binding_path, platform.as_str());\n-                    let native_binding_path =\n-                        ARCH_TEMPLATE.replace(&native_binding_path, compile_target.arch.as_str());\n-                    let native_binding_path: RcStr = LIBC_TEMPLATE\n-                        .replace(\n-                            &native_binding_path,\n-                            // node-pre-gyp only cares about libc on linux\n-                            if platform == Platform::Linux {\n-                                compile_target.libc.as_str()\n-                            } else {\n-                                \"unknown\"\n-                            },\n-                        )\n-                        .into();\n+    if let Some(config_asset) = *config\n+        && let AssetContent::File(file) = &*config_asset.content().await?\n+        && let FileContent::Content(config_file) = &*file.await?\n+    {\n+        let config_file_path = config_asset.ident().path();\n+        let mut affecting_paths = vec![config_file_path];\n+        let config_file_dir = config_file_path.parent();\n+        let node_pre_gyp_config: NodePreGypConfigJson =\n+            parse_json_rope_with_source_context(config_file.content())?;\n+        let mut sources: FxIndexMap<RcStr, Vc<Box<dyn Source>>> = FxIndexMap::default();\n+        for version in node_pre_gyp_config.binary.napi_versions.iter() {\n+            let native_binding_path = NAPI_VERSION_TEMPLATE.replace(\n+                node_pre_gyp_config.binary.module_path.as_str(),\n+                format!(\"{version}\"),\n+            );\n+            let platform = compile_target.platform;\n+            let native_binding_path =\n+                PLATFORM_TEMPLATE.replace(&native_binding_path, platform.as_str());\n+            let native_binding_path =\n+                ARCH_TEMPLATE.replace(&native_binding_path, compile_target.arch.as_str());\n+            let native_binding_path: RcStr = LIBC_TEMPLATE\n+                .replace(\n+                    &native_binding_path,\n+                    // node-pre-gyp only cares about libc on linux\n+                    if platform == Platform::Linux {\n+                        compile_target.libc.as_str()\n+                    } else {\n+                        \"unknown\"\n+                    },\n+                )\n+                .into();\n \n-                    // Find all dynamic libraries in the given directory.\n-                    if let DirectoryContent::Entries(entries) = &*config_file_dir\n-                        .join(native_binding_path.clone())\n-                        .read_dir()\n-                        .await?\n-                    {\n-                        let extension = compile_target.dylib_ext();\n-                        for (key, entry) in entries.iter().filter(|(k, _)| k.ends_with(extension)) {\n-                            if let &DirectoryEntry::File(dylib) | &DirectoryEntry::Symlink(dylib) =\n-                                entry\n-                            {\n-                                sources.insert(\n-                                    format!(\"{native_binding_path}/{key}\").into(),\n-                                    Vc::upcast(FileSource::new(*dylib)),\n-                                );\n-                            }\n-                        }\n+            // Find all dynamic libraries in the given directory.\n+            if let DirectoryContent::Entries(entries) = &*config_file_dir\n+                .join(native_binding_path.clone())\n+                .read_dir()\n+                .await?\n+            {\n+                let extension = compile_target.dylib_ext();\n+                for (key, entry) in entries.iter().filter(|(k, _)| k.ends_with(extension)) {\n+                    if let &DirectoryEntry::File(dylib) | &DirectoryEntry::Symlink(dylib) = entry {\n+                        sources.insert(\n+                            format!(\"{native_binding_path}/{key}\").into(),\n+                            Vc::upcast(FileSource::new(*dylib)),\n+                        );\n                     }\n+                }\n+            }\n \n-                    let node_file_path: RcStr = format!(\n-                        \"{}/{}.node\",\n-                        native_binding_path, node_pre_gyp_config.binary.module_name\n-                    )\n-                    .into();\n-                    let resolved_file_vc = config_file_dir.join(node_file_path.clone());\n-                    if *resolved_file_vc.get_type().await? == FileSystemEntryType::File {\n+            let node_file_path: RcStr = format!(\n+                \"{}/{}.node\",\n+                native_binding_path, node_pre_gyp_config.binary.module_name\n+            )\n+            .into();\n+            let resolved_file_vc = config_file_dir.join(node_file_path.clone());\n+            if *resolved_file_vc.get_type().await? == FileSystemEntryType::File {\n+                sources.insert(\n+                    node_file_path,\n+                    Vc::upcast(FileSource::new(resolved_file_vc)),\n+                );\n+            }\n+        }\n+        if let DirectoryContent::Entries(entries) = &*config_file_dir\n+            // TODO\n+            // read the dependencies path from `bindings.gyp`\n+            .join(rcstr!(\"deps/lib\"))\n+            .read_dir()\n+            .await?\n+        {\n+            for (key, entry) in entries.iter() {\n+                match *entry {\n+                    DirectoryEntry::File(dylib) => {\n                         sources.insert(\n-                            node_file_path,\n-                            Vc::upcast(FileSource::new(resolved_file_vc)),\n+                            format!(\"deps/lib/{key}\").into(),\n+                            Vc::upcast(FileSource::new(*dylib)),\n                         );\n                     }\n-                }\n-                if let DirectoryContent::Entries(entries) = &*config_file_dir\n-                    // TODO\n-                    // read the dependencies path from `bindings.gyp`\n-                    .join(rcstr!(\"deps/lib\"))\n-                    .read_dir()\n-                    .await?\n-                {\n-                    for (key, entry) in entries.iter() {\n-                        match *entry {\n-                            DirectoryEntry::File(dylib) => {\n-                                sources.insert(\n-                                    format!(\"deps/lib/{key}\").into(),\n-                                    Vc::upcast(FileSource::new(*dylib)),\n-                                );\n-                            }\n-                            DirectoryEntry::Symlink(dylib) => {\n-                                let realpath_with_links = dylib.realpath_with_links().await?;\n-                                for &symlink in realpath_with_links.symlinks.iter() {\n-                                    affecting_paths.push(*symlink);\n-                                }\n-                                sources.insert(\n-                                    format!(\"deps/lib/{key}\").into(),\n-                                    Vc::upcast(FileSource::new(*realpath_with_links.path)),\n-                                );\n-                            }\n-                            _ => {}\n+                    DirectoryEntry::Symlink(dylib) => {\n+                        let realpath_with_links = dylib.realpath_with_links().await?;\n+                        for &symlink in realpath_with_links.symlinks.iter() {\n+                            affecting_paths.push(*symlink);\n                         }\n+                        sources.insert(\n+                            format!(\"deps/lib/{key}\").into(),\n+                            Vc::upcast(FileSource::new(*realpath_with_links.path)),\n+                        );\n                     }\n+                    _ => {}\n                 }\n-                return Ok(*ModuleResolveResult::modules_with_affecting_sources(\n-                    sources\n-                        .into_iter()\n-                        .map(|(key, source)| async move {\n-                            Ok((\n-                                RequestKey::new(key),\n-                                ResolvedVc::upcast(RawModule::new(source).to_resolved().await?),\n-                            ))\n-                        })\n-                        .try_join()\n-                        .await?,\n-                    affecting_paths\n-                        .into_iter()\n-                        .map(|p| async move {\n-                            anyhow::Ok(ResolvedVc::upcast(FileSource::new(p).to_resolved().await?))\n-                        })\n-                        .try_join()\n-                        .await?,\n-                ));\n             }\n-        };\n-    }\n+        }\n+        return Ok(*ModuleResolveResult::modules_with_affecting_sources(\n+            sources\n+                .into_iter()\n+                .map(|(key, source)| async move {\n+                    Ok((\n+                        RequestKey::new(key),\n+                        ResolvedVc::upcast(RawModule::new(source).to_resolved().await?),\n+                    ))\n+                })\n+                .try_join()\n+                .await?,\n+            affecting_paths\n+                .into_iter()\n+                .map(|p| async move {\n+                    anyhow::Ok(ResolvedVc::upcast(FileSource::new(p).to_resolved().await?))\n+                })\n+                .try_join()\n+                .await?,\n+        ));\n+    };\n     Ok(*ModuleResolveResult::unresolvable())\n }\n \n@@ -275,50 +272,45 @@ pub async fn resolve_node_gyp_build_files(\n     if let [binding_gyp] = &gyp_file.primary_sources().await?[..] {\n         let mut merged_affecting_sources =\n             gyp_file.await?.get_affecting_sources().collect::<Vec<_>>();\n-        if let AssetContent::File(file) = &*binding_gyp.content().await? {\n-            if let FileContent::Content(config_file) = &*file.await? {\n-                if let Some(captured) =\n-                    GYP_BUILD_TARGET_NAME.captures(&config_file.content().to_str()?)\n+        if let AssetContent::File(file) = &*binding_gyp.content().await?\n+            && let FileContent::Content(config_file) = &*file.await?\n+            && let Some(captured) = GYP_BUILD_TARGET_NAME.captures(&config_file.content().to_str()?)\n+        {\n+            let mut resolved: FxIndexMap<RcStr, ResolvedVc<Box<dyn Source>>> =\n+                FxIndexMap::with_capacity_and_hasher(captured.len(), Default::default());\n+            for found in captured.iter().skip(1).flatten() {\n+                let name = found.as_str();\n+                let target_path = context_dir.join(rcstr!(\"build/Release\"));\n+                let resolved_prebuilt_file = resolve_raw(\n+                    target_path,\n+                    Pattern::new(Pattern::Constant(format!(\"{name}.node\").into())),\n+                    true,\n+                )\n+                .await?;\n+                if let Some((_, ResolveResultItem::Source(source))) =\n+                    resolved_prebuilt_file.primary.first()\n                 {\n-                    let mut resolved: FxIndexMap<RcStr, ResolvedVc<Box<dyn Source>>> =\n-                        FxIndexMap::with_capacity_and_hasher(captured.len(), Default::default());\n-                    for found in captured.iter().skip(1).flatten() {\n-                        let name = found.as_str();\n-                        let target_path = context_dir.join(rcstr!(\"build/Release\"));\n-                        let resolved_prebuilt_file = resolve_raw(\n-                            target_path,\n-                            Pattern::new(Pattern::Constant(format!(\"{name}.node\").into())),\n-                            true,\n-                        )\n-                        .await?;\n-                        if let Some((_, ResolveResultItem::Source(source))) =\n-                            resolved_prebuilt_file.primary.first()\n-                        {\n-                            resolved.insert(format!(\"build/Release/{name}.node\").into(), *source);\n-                            merged_affecting_sources\n-                                .extend(resolved_prebuilt_file.affecting_sources.iter().copied());\n-                        }\n-                    }\n-                    if !resolved.is_empty() {\n-                        return Ok(*ModuleResolveResult::modules_with_affecting_sources(\n-                            resolved\n-                                .into_iter()\n-                                .map(|(key, source)| async move {\n-                                    Ok((\n-                                        RequestKey::new(key),\n-                                        ResolvedVc::upcast(\n-                                            RawModule::new(*source).to_resolved().await?,\n-                                        ),\n-                                    ))\n-                                })\n-                                .try_join()\n-                                .await?\n-                                .into_iter(),\n-                            merged_affecting_sources,\n-                        ));\n-                    }\n+                    resolved.insert(format!(\"build/Release/{name}.node\").into(), *source);\n+                    merged_affecting_sources\n+                        .extend(resolved_prebuilt_file.affecting_sources.iter().copied());\n                 }\n             }\n+            if !resolved.is_empty() {\n+                return Ok(*ModuleResolveResult::modules_with_affecting_sources(\n+                    resolved\n+                        .into_iter()\n+                        .map(|(key, source)| async move {\n+                            Ok((\n+                                RequestKey::new(key),\n+                                ResolvedVc::upcast(RawModule::new(*source).to_resolved().await?),\n+                            ))\n+                        })\n+                        .try_join()\n+                        .await?\n+                        .into_iter(),\n+                    merged_affecting_sources,\n+                ));\n+            }\n         }\n     }\n     let compile_target = compile_target.await?;\n@@ -396,12 +388,11 @@ pub async fn resolve_node_bindings_files(\n         )\n         .first_source()\n         .await?;\n-        if let Some(asset) = *resolved {\n-            if let AssetContent::File(file) = &*asset.content().await? {\n-                if let FileContent::Content(_) = &*file.await? {\n-                    break;\n-                }\n-            }\n+        if let Some(asset) = *resolved\n+            && let AssetContent::File(file) = &*asset.content().await?\n+            && let FileContent::Content(_) = &*file.await?\n+        {\n+            break;\n         };\n         let current_context = root_context_dir.await?;\n         let parent = root_context_dir.parent();"
        },
        {
            "sha": "f1f243d91be01bbec9ec77fd25a7b663766cea5e",
            "filename": "turbopack/crates/turbopack-resolve/src/typescript.rs",
            "status": "modified",
            "additions": 54,
            "deletions": 54,
            "changes": 108,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Ftypescript.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Ftypescript.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Ftypescript.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -55,10 +55,10 @@ pub async fn read_tsconfigs(\n     let resolve_options = json_only(resolve_options);\n     loop {\n         // tsc ignores empty config files.\n-        if let FileContent::Content(file) = &*data.await? {\n-            if file.content().is_empty() {\n-                break;\n-            }\n+        if let FileContent::Content(file) = &*data.await?\n+            && file.content().is_empty()\n+        {\n+            break;\n         }\n \n         let parsed_data = data.parse_json_with_comments();\n@@ -202,10 +202,10 @@ pub async fn read_from_tsconfigs<T>(\n     accessor: impl Fn(&JsonValue, ResolvedVc<Box<dyn Source>>) -> Option<T>,\n ) -> Result<Option<T>> {\n     for (config, source) in configs.iter() {\n-        if let FileJsonContent::Content(json) = &*config.await? {\n-            if let Some(result) = accessor(json, *source) {\n-                return Ok(Some(result));\n-            }\n+        if let FileJsonContent::Content(json) = &*config.await?\n+            && let Some(result) = accessor(json, *source)\n+        {\n+            return Ok(Some(result));\n         }\n     }\n     Ok(None)\n@@ -258,55 +258,55 @@ pub async fn tsconfig_resolve_options(\n \n     let mut all_paths = HashMap::new();\n     for (content, source) in configs.iter().rev() {\n-        if let FileJsonContent::Content(json) = &*content.await? {\n-            if let JsonValue::Object(paths) = &json[\"compilerOptions\"][\"paths\"] {\n-                let mut context_dir = source.ident().path().parent();\n-                if let Some(base_url) = json[\"compilerOptions\"][\"baseUrl\"].as_str() {\n-                    if let Some(new_context) = *context_dir.try_join(base_url.into()).await? {\n-                        context_dir = *new_context;\n-                    }\n-                };\n-                let context_dir = context_dir.to_resolved().await?;\n-                for (key, value) in paths.iter() {\n-                    if let JsonValue::Array(vec) = value {\n-                        let entries = vec\n-                            .iter()\n-                            .filter_map(|entry| {\n-                                let entry = entry.as_str();\n-\n-                                if entry.map(|e| e.ends_with(\".d.ts\")).unwrap_or_default() {\n-                                    return None;\n+        if let FileJsonContent::Content(json) = &*content.await?\n+            && let JsonValue::Object(paths) = &json[\"compilerOptions\"][\"paths\"]\n+        {\n+            let mut context_dir = source.ident().path().parent();\n+            if let Some(base_url) = json[\"compilerOptions\"][\"baseUrl\"].as_str()\n+                && let Some(new_context) = *context_dir.try_join(base_url.into()).await?\n+            {\n+                context_dir = *new_context;\n+            };\n+            let context_dir = context_dir.to_resolved().await?;\n+            for (key, value) in paths.iter() {\n+                if let JsonValue::Array(vec) = value {\n+                    let entries = vec\n+                        .iter()\n+                        .filter_map(|entry| {\n+                            let entry = entry.as_str();\n+\n+                            if entry.map(|e| e.ends_with(\".d.ts\")).unwrap_or_default() {\n+                                return None;\n+                            }\n+\n+                            entry.map(|s| {\n+                                // tsconfig paths are always relative requests\n+                                if s.starts_with(\"./\") || s.starts_with(\"../\") {\n+                                    s.into()\n+                                } else {\n+                                    format!(\"./{s}\").into()\n                                 }\n-\n-                                entry.map(|s| {\n-                                    // tsconfig paths are always relative requests\n-                                    if s.starts_with(\"./\") || s.starts_with(\"../\") {\n-                                        s.into()\n-                                    } else {\n-                                        format!(\"./{s}\").into()\n-                                    }\n-                                })\n                             })\n-                            .collect();\n-                        all_paths.insert(\n-                            key.to_string(),\n-                            ImportMapping::primary_alternatives(entries, Some(context_dir)),\n-                        );\n-                    } else {\n-                        TsConfigIssue {\n-                            severity: IssueSeverity::Warning.resolved_cell(),\n-                            source_ident: source.ident().to_resolved().await?,\n-                            message: format!(\n-                                \"compilerOptions.paths[{key}] doesn't contains an array as \\\n-                                 expected\\n{key}: {value:#}\",\n-                                key = serde_json::to_string(key)?,\n-                                value = value\n-                            )\n-                            .into(),\n-                        }\n-                        .resolved_cell()\n-                        .emit()\n+                        })\n+                        .collect();\n+                    all_paths.insert(\n+                        key.to_string(),\n+                        ImportMapping::primary_alternatives(entries, Some(context_dir)),\n+                    );\n+                } else {\n+                    TsConfigIssue {\n+                        severity: IssueSeverity::Warning.resolved_cell(),\n+                        source_ident: source.ident().to_resolved().await?,\n+                        message: format!(\n+                            \"compilerOptions.paths[{key}] doesn't contains an array as \\\n+                             expected\\n{key}: {value:#}\",\n+                            key = serde_json::to_string(key)?,\n+                            value = value\n+                        )\n+                        .into(),\n                     }\n+                    .resolved_cell()\n+                    .emit()\n                 }\n             }\n         }"
        },
        {
            "sha": "9b7309ec330f4fcde0541f20bd8ce324399f873b",
            "filename": "turbopack/crates/turbopack-tests/tests/execution.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -282,11 +282,11 @@ async fn prepare_test(resource: RcStr) -> Result<Vc<PreparedTest>> {\n     let options_file = path.join(rcstr!(\"options.json\"));\n \n     let mut options = TestOptions::default();\n-    if matches!(*options_file.get_type().await?, FileSystemEntryType::File) {\n-        if let FileContent::Content(content) = &*options_file.read().await? {\n-            options =\n-                serde_json::from_reader(content.read()).context(\"Unable to parse options.json\")?;\n-        }\n+    if matches!(*options_file.get_type().await?, FileSystemEntryType::File)\n+        && let FileContent::Content(content) = &*options_file.read().await?\n+    {\n+        options =\n+            serde_json::from_reader(content.read()).context(\"Unable to parse options.json\")?;\n     }\n \n     Ok(PreparedTest {"
        },
        {
            "sha": "317e3684b5c5a8e543d030f4c14d951ee8ad75d6",
            "filename": "turbopack/crates/turbopack-trace-server/src/reader/heaptrack.rs",
            "status": "modified",
            "additions": 24,
            "deletions": 24,
            "changes": 48,
            "blob_url": "https://github.com/vercel/next.js/blob/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-trace-server%2Fsrc%2Freader%2Fheaptrack.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1429d7242159be90ecb2423f034770cb251a0e54/turbopack%2Fcrates%2Fturbopack-trace-server%2Fsrc%2Freader%2Fheaptrack.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-trace-server%2Fsrc%2Freader%2Fheaptrack.rs?ref=1429d7242159be90ecb2423f034770cb251a0e54",
            "patch": "@@ -228,12 +228,12 @@ impl TraceFormat for HeaptrackFormat {\n                         .get_index(ip_index)\n                         .context(\"ip not found\")?;\n                     // Try to fix cut-off traces\n-                    if parent_index == 0 {\n-                        if let Some(trace_index) = ip_info.first_trace_of_ip {\n-                            let trace = self.traces.get(trace_index).context(\"trace not found\")?;\n-                            self.traces.push(*trace);\n-                            continue;\n-                        }\n+                    if parent_index == 0\n+                        && let Some(trace_index) = ip_info.first_trace_of_ip\n+                    {\n+                        let trace = self.traces.get(trace_index).context(\"trace not found\")?;\n+                        self.traces.push(*trace);\n+                        continue;\n                     }\n                     // Lookup parent\n                     let parent = if parent_index > 0 {\n@@ -369,24 +369,24 @@ impl TraceFormat for HeaptrackFormat {\n                 }\n                 b'i' => {\n                     let mut ip = InstructionPointer::read(&mut line)?;\n-                    if let Some(frame) = ip.frames.first() {\n-                        if let Some(function) = self.strings.get(frame.function_index) {\n-                            let crate_name = function\n-                                .strip_prefix('<')\n-                                .unwrap_or(function)\n-                                .split(\"::\")\n-                                .next()\n-                                .unwrap()\n-                                .split('[')\n-                                .next()\n-                                .unwrap();\n-                            if self.collapse_crates.contains(crate_name)\n-                                || !self.expand_crates.is_empty()\n-                                    && !self.expand_crates.contains(crate_name)\n-                            {\n-                                ip.frames.clear();\n-                                ip.custom_name = Some(crate_name.to_string());\n-                            }\n+                    if let Some(frame) = ip.frames.first()\n+                        && let Some(function) = self.strings.get(frame.function_index)\n+                    {\n+                        let crate_name = function\n+                            .strip_prefix('<')\n+                            .unwrap_or(function)\n+                            .split(\"::\")\n+                            .next()\n+                            .unwrap()\n+                            .split('[')\n+                            .next()\n+                            .unwrap();\n+                        if self.collapse_crates.contains(crate_name)\n+                            || !self.expand_crates.is_empty()\n+                                && !self.expand_crates.contains(crate_name)\n+                        {\n+                            ip.frames.clear();\n+                            ip.custom_name = Some(crate_name.to_string());\n                         }\n                     }\n                     match self.instruction_pointers.entry(ip) {"
        }
    ],
    "stats": {
        "total": 3518,
        "additions": 1699,
        "deletions": 1819
    }
}