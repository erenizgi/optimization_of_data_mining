{
    "author": "sokra",
    "message": "Turbopack: flush key spaces when done with them (#78776)\n\n### What?\n\nAdd a flushing feature that allows to flush the in memory buffered data to disk when done with a key space. This reduces the memory usage.",
    "sha": "faa6e3d28a9385195ae567b04e601bfa17d83f7f",
    "files": [
        {
            "sha": "8a970397ac972517d92e3cff05de728495854556",
            "filename": "Cargo.lock",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/faa6e3d28a9385195ae567b04e601bfa17d83f7f/Cargo.lock",
            "raw_url": "https://github.com/vercel/next.js/raw/faa6e3d28a9385195ae567b04e601bfa17d83f7f/Cargo.lock",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/Cargo.lock?ref=faa6e3d28a9385195ae567b04e601bfa17d83f7f",
            "patch": "@@ -9334,6 +9334,7 @@ dependencies = [\n  \"smallvec\",\n  \"tempfile\",\n  \"thread_local\",\n+ \"tracing\",\n  \"twox-hash 2.1.0\",\n  \"zstd\",\n ]"
        },
        {
            "sha": "c0ae5159467a8e600a614106f23b3b03be62a74b",
            "filename": "turbopack/crates/turbo-persistence/Cargo.toml",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/faa6e3d28a9385195ae567b04e601bfa17d83f7f/turbopack%2Fcrates%2Fturbo-persistence%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/faa6e3d28a9385195ae567b04e601bfa17d83f7f/turbopack%2Fcrates%2Fturbo-persistence%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-persistence%2FCargo.toml?ref=faa6e3d28a9385195ae567b04e601bfa17d83f7f",
            "patch": "@@ -25,6 +25,7 @@ rustc-hash = { workspace = true }\n serde = { workspace = true }\n smallvec = { workspace = true}\n thread_local = { workspace = true }\n+tracing = { workspace = true }\n twox-hash = { version = \"2.0.1\", features = [\"xxhash64\"] }\n zstd = { version = \"0.13.2\", features = [\"zdict_builder\"] }\n "
        },
        {
            "sha": "a1a75ca7726474842249d8cff5bed247f94ad060",
            "filename": "turbopack/crates/turbo-persistence/src/lib.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/faa6e3d28a9385195ae567b04e601bfa17d83f7f/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/faa6e3d28a9385195ae567b04e601bfa17d83f7f/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Flib.rs?ref=faa6e3d28a9385195ae567b04e601bfa17d83f7f",
            "patch": "@@ -1,6 +1,7 @@\n #![feature(once_cell_try)]\n #![feature(new_zeroed_alloc)]\n #![feature(get_mut_unchecked)]\n+#![feature(sync_unsafe_cell)]\n \n mod arc_slice;\n mod collector;"
        },
        {
            "sha": "08d2bbc1b878feeaf736d3f575faef0ad456d775",
            "filename": "turbopack/crates/turbo-persistence/src/tests.rs",
            "status": "modified",
            "additions": 22,
            "deletions": 0,
            "changes": 22,
            "blob_url": "https://github.com/vercel/next.js/blob/faa6e3d28a9385195ae567b04e601bfa17d83f7f/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Ftests.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/faa6e3d28a9385195ae567b04e601bfa17d83f7f/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Ftests.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Ftests.rs?ref=faa6e3d28a9385195ae567b04e601bfa17d83f7f",
            "patch": "@@ -48,6 +48,28 @@ fn full_cycle() -> Result<()> {\n         },\n     );\n \n+    test_case(\n+        &mut test_cases,\n+        \"Many SST files\",\n+        |batch| {\n+            for i in 10..100u8 {\n+                batch.put(0, vec![i], vec![i].into())?;\n+                unsafe { batch.flush(0)? };\n+            }\n+            Ok(())\n+        },\n+        |db| {\n+            let Some(value) = db.get(0, &[42u8])? else {\n+                panic!(\"Value not found\");\n+            };\n+            assert_eq!(&*value, &[42]);\n+            assert_eq!(db.get(0, &[42u8, 42])?, None);\n+            assert_eq!(db.get(0, &[1u8])?, None);\n+            assert_eq!(db.get(0, &[255u8])?, None);\n+            Ok(())\n+        },\n+    );\n+\n     test_case(\n         &mut test_cases,\n         \"Families\","
        },
        {
            "sha": "2f234d2eac5b781ba9508cd3a515f321a0787762",
            "filename": "turbopack/crates/turbo-persistence/src/write_batch.rs",
            "status": "modified",
            "additions": 75,
            "deletions": 6,
            "changes": 81,
            "blob_url": "https://github.com/vercel/next.js/blob/faa6e3d28a9385195ae567b04e601bfa17d83f7f/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fwrite_batch.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/faa6e3d28a9385195ae567b04e601bfa17d83f7f/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fwrite_batch.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fwrite_batch.rs?ref=faa6e3d28a9385195ae567b04e601bfa17d83f7f",
            "patch": "@@ -1,5 +1,5 @@\n use std::{\n-    cell::UnsafeCell,\n+    cell::SyncUnsafeCell,\n     fs::File,\n     io::Write,\n     mem::{replace, take},\n@@ -17,6 +17,7 @@ use rayon::{\n };\n use smallvec::SmallVec;\n use thread_local::ThreadLocal;\n+use tracing::Span;\n \n use crate::{\n     collector::Collector,\n@@ -68,7 +69,7 @@ pub struct WriteBatch<K: StoreKey + Send, const FAMILIES: usize> {\n     /// The current sequence number counter. Increased for every new SST file or blob file.\n     current_sequence_number: AtomicU32,\n     /// The thread local state.\n-    thread_locals: ThreadLocal<UnsafeCell<ThreadLocalState<K, FAMILIES>>>,\n+    thread_locals: ThreadLocal<SyncUnsafeCell<ThreadLocalState<K, FAMILIES>>>,\n     /// Collectors in use. The thread local collectors flush into these when they are full.\n     collectors: [Mutex<GlobalCollectorState<K>>; FAMILIES],\n     /// The list of new SST files that have been created.\n@@ -109,7 +110,7 @@ impl<K: StoreKey + Send + Sync, const FAMILIES: usize> WriteBatch<K, FAMILIES> {\n     #[allow(clippy::mut_from_ref)]\n     fn thread_local_state(&self) -> &mut ThreadLocalState<K, FAMILIES> {\n         let cell = self.thread_locals.get_or(|| {\n-            UnsafeCell::new(ThreadLocalState {\n+            SyncUnsafeCell::new(ThreadLocalState {\n                 collectors: [const { None }; FAMILIES],\n                 new_blob_files: Vec::new(),\n             })\n@@ -185,7 +186,7 @@ impl<K: StoreKey + Send + Sync, const FAMILIES: usize> WriteBatch<K, FAMILIES> {\n             let sst = self.create_sst_file(family, global_collector.sorted())?;\n             global_collector.clear();\n             self.new_sst_files.lock().push(sst);\n-            self.idle_collectors.lock().push(global_collector);\n+            self.dispose_collector(global_collector);\n         }\n         Ok(())\n     }\n@@ -197,6 +198,14 @@ impl<K: StoreKey + Send + Sync, const FAMILIES: usize> WriteBatch<K, FAMILIES> {\n             .unwrap_or_else(|| Collector::new())\n     }\n \n+    fn dispose_collector(&self, collector: Collector<K>) {\n+        self.idle_collectors.lock().push(collector);\n+    }\n+\n+    fn dispose_thread_local_collector(&self, collector: Collector<K, THREAD_LOCAL_SIZE_SHIFT>) {\n+        self.idle_thread_local_collectors.lock().push(collector);\n+    }\n+\n     /// Puts a key-value pair into the write batch.\n     pub fn put(&self, family: u32, key: K, value: ValueBuffer<'_>) -> Result<()> {\n         let state = self.thread_local_state();\n@@ -219,6 +228,66 @@ impl<K: StoreKey + Send + Sync, const FAMILIES: usize> WriteBatch<K, FAMILIES> {\n         Ok(())\n     }\n \n+    /// Flushes a family of the write batch, reducing the amount of buffered memory used.\n+    /// Does not commit any data persistently.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Caller must ensure that no concurrent put or delete operation is happening on the flushed\n+    /// family.\n+    pub unsafe fn flush(&self, family: u32) -> Result<()> {\n+        // Flush the thread local collectors to the global collector.\n+        let mut collectors = Vec::new();\n+        for cell in self.thread_locals.iter() {\n+            let state = unsafe { &mut *cell.get() };\n+            if let Some(collector) = state.collectors[usize_from_u32(family)].take() {\n+                if !collector.is_empty() {\n+                    collectors.push(collector);\n+                }\n+            }\n+        }\n+\n+        let span = Span::current();\n+        collectors.into_par_iter().try_for_each(|mut collector| {\n+            let _span = span.clone().entered();\n+            self.flush_thread_local_collector(family, &mut collector)?;\n+            self.dispose_thread_local_collector(collector);\n+            anyhow::Ok(())\n+        })?;\n+\n+        // Now we flush the global collector(s).\n+        let mut collector_state = self.collectors[usize_from_u32(family)].lock();\n+        match &mut *collector_state {\n+            GlobalCollectorState::Unsharded(collector) => {\n+                if !collector.is_empty() {\n+                    let sst = self.create_sst_file(family, collector.sorted())?;\n+                    collector.clear();\n+                    self.new_sst_files.lock().push(sst);\n+                }\n+            }\n+            GlobalCollectorState::Sharded(_) => {\n+                let GlobalCollectorState::Sharded(shards) = replace(\n+                    &mut *collector_state,\n+                    GlobalCollectorState::Unsharded(self.get_new_collector()),\n+                ) else {\n+                    unreachable!();\n+                };\n+                shards.into_par_iter().try_for_each(|mut collector| {\n+                    let _span = span.clone().entered();\n+                    if !collector.is_empty() {\n+                        let sst = self.create_sst_file(family, collector.sorted())?;\n+                        collector.clear();\n+                        self.new_sst_files.lock().push(sst);\n+                        self.dispose_collector(collector);\n+                    }\n+                    anyhow::Ok(())\n+                })?;\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n     /// Finishes the write batch by returning the new sequence number and the new SST files. This\n     /// writes all outstanding thread local data to disk.\n     pub(crate) fn finish(&mut self) -> Result<FinishResult> {\n@@ -249,7 +318,7 @@ impl<K: StoreKey + Send + Sync, const FAMILIES: usize> WriteBatch<K, FAMILIES> {\n                         {\n                             *shared_error.lock() = Err(err);\n                         }\n-                        this.idle_thread_local_collectors.lock().push(collector);\n+                        this.dispose_thread_local_collector(collector);\n                     });\n                 }\n             }\n@@ -283,7 +352,7 @@ impl<K: StoreKey + Send + Sync, const FAMILIES: usize> WriteBatch<K, FAMILIES> {\n                 if !collector.is_empty() {\n                     let sst = self.create_sst_file(family, collector.sorted())?;\n                     collector.clear();\n-                    self.idle_collectors.lock().push(collector);\n+                    self.dispose_collector(collector);\n                     shared_new_sst_files.lock().push(sst);\n                 }\n                 anyhow::Ok(())"
        },
        {
            "sha": "fbbd310efbb71539bdea28476383cb4f55484a84",
            "filename": "turbopack/crates/turbo-tasks-backend/src/database/noop_kv.rs",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/faa6e3d28a9385195ae567b04e601bfa17d83f7f/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdatabase%2Fnoop_kv.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/faa6e3d28a9385195ae567b04e601bfa17d83f7f/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdatabase%2Fnoop_kv.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdatabase%2Fnoop_kv.rs?ref=faa6e3d28a9385195ae567b04e601bfa17d83f7f",
            "patch": "@@ -90,6 +90,10 @@ impl SerialWriteBatch<'_> for NoopWriteBatch {\n     fn delete(&mut self, _key_space: KeySpace, _key: WriteBuffer<'_>) -> Result<()> {\n         Ok(())\n     }\n+\n+    fn flush(&mut self, _key_space: KeySpace) -> Result<()> {\n+        Ok(())\n+    }\n }\n \n impl ConcurrentWriteBatch<'_> for NoopWriteBatch {\n@@ -105,4 +109,8 @@ impl ConcurrentWriteBatch<'_> for NoopWriteBatch {\n     fn delete(&self, _key_space: KeySpace, _key: WriteBuffer<'_>) -> Result<()> {\n         Ok(())\n     }\n+\n+    unsafe fn flush(&self, _key_space: KeySpace) -> Result<()> {\n+        Ok(())\n+    }\n }"
        },
        {
            "sha": "1df9d269abf87ab1582ed0c67f878a5e72400c40",
            "filename": "turbopack/crates/turbo-tasks-backend/src/database/turbo.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/faa6e3d28a9385195ae567b04e601bfa17d83f7f/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdatabase%2Fturbo.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/faa6e3d28a9385195ae567b04e601bfa17d83f7f/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdatabase%2Fturbo.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdatabase%2Fturbo.rs?ref=faa6e3d28a9385195ae567b04e601bfa17d83f7f",
            "patch": "@@ -160,6 +160,10 @@ impl<'a> ConcurrentWriteBatch<'a> for TurboWriteBatch<'a> {\n     fn delete(&self, key_space: KeySpace, key: WriteBuffer<'_>) -> Result<()> {\n         self.batch.delete(key_space as u32, key.into_static())\n     }\n+\n+    unsafe fn flush(&self, key_space: KeySpace) -> Result<()> {\n+        self.batch.flush(key_space as u32)\n+    }\n }\n \n impl KeyBase for WriteBuffer<'_> {"
        },
        {
            "sha": "a69f47e8746b0d3a06d7371a6594eef60d705da3",
            "filename": "turbopack/crates/turbo-tasks-backend/src/database/write_batch.rs",
            "status": "modified",
            "additions": 33,
            "deletions": 0,
            "changes": 33,
            "blob_url": "https://github.com/vercel/next.js/blob/faa6e3d28a9385195ae567b04e601bfa17d83f7f/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdatabase%2Fwrite_batch.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/faa6e3d28a9385195ae567b04e601bfa17d83f7f/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdatabase%2Fwrite_batch.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdatabase%2Fwrite_batch.rs?ref=faa6e3d28a9385195ae567b04e601bfa17d83f7f",
            "patch": "@@ -66,11 +66,18 @@ pub trait SerialWriteBatch<'a>: BaseWriteBatch<'a> {\n         value: WriteBuffer<'_>,\n     ) -> Result<()>;\n     fn delete(&mut self, key_space: KeySpace, key: WriteBuffer<'_>) -> Result<()>;\n+    fn flush(&mut self, key_space: KeySpace) -> Result<()>;\n }\n \n pub trait ConcurrentWriteBatch<'a>: BaseWriteBatch<'a> + Sync + Send {\n     fn put(&self, key_space: KeySpace, key: WriteBuffer<'_>, value: WriteBuffer<'_>) -> Result<()>;\n     fn delete(&self, key_space: KeySpace, key: WriteBuffer<'_>) -> Result<()>;\n+    /// Flushes a key space of the write batch, reducing the amount of buffered memory used.\n+    /// Does not commit any data persistently.\n+    ///\n+    /// Safety: Caller must ensure that no concurrent put or delete operation is happening on the\n+    /// flushed key space.\n+    unsafe fn flush(&self, key_space: KeySpace) -> Result<()>;\n }\n \n pub enum WriteBatch<'a, S, C>\n@@ -164,6 +171,16 @@ where\n             WriteBatch::Concurrent(c, _) => c.delete(key_space, key),\n         }\n     }\n+\n+    fn flush(&mut self, key_space: KeySpace) -> Result<()> {\n+        match self {\n+            WriteBatch::Serial(s) => s.flush(key_space),\n+            WriteBatch::Concurrent(c, _) => {\n+                // Safety: the &mut self ensures that no concurrent operation is happening\n+                unsafe { c.flush(key_space) }\n+            }\n+        }\n+    }\n }\n \n pub enum WriteBatchRef<'r, 'a, S, C>\n@@ -241,6 +258,16 @@ where\n             WriteBatchRef::Concurrent(c, _) => c.delete(key_space, key),\n         }\n     }\n+\n+    fn flush(&mut self, key_space: KeySpace) -> Result<()> {\n+        match self {\n+            WriteBatchRef::Serial(s) => s.flush(key_space),\n+            WriteBatchRef::Concurrent(c, _) => {\n+                // Safety: the &mut self ensures that no concurrent operation is happening\n+                unsafe { c.flush(key_space) }\n+            }\n+        }\n+    }\n }\n \n pub struct UnimplementedWriteBatch;\n@@ -275,6 +302,9 @@ impl SerialWriteBatch<'_> for UnimplementedWriteBatch {\n     fn delete(&mut self, _key_space: KeySpace, _key: WriteBuffer<'_>) -> Result<()> {\n         todo!()\n     }\n+    fn flush(&mut self, _key_space: KeySpace) -> Result<()> {\n+        todo!()\n+    }\n }\n \n impl ConcurrentWriteBatch<'_> for UnimplementedWriteBatch {\n@@ -289,4 +319,7 @@ impl ConcurrentWriteBatch<'_> for UnimplementedWriteBatch {\n     fn delete(&self, _key_space: KeySpace, _key: WriteBuffer<'_>) -> Result<()> {\n         todo!()\n     }\n+    unsafe fn flush(&self, _key_space: KeySpace) -> Result<()> {\n+        todo!()\n+    }\n }"
        },
        {
            "sha": "90c3b5c0334be5307e65fcde66176482bc86d467",
            "filename": "turbopack/crates/turbo-tasks-backend/src/kv_backing_storage.rs",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/faa6e3d28a9385195ae567b04e601bfa17d83f7f/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fkv_backing_storage.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/faa6e3d28a9385195ae567b04e601bfa17d83f7f/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fkv_backing_storage.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fkv_backing_storage.rs?ref=faa6e3d28a9385195ae567b04e601bfa17d83f7f",
            "patch": "@@ -184,6 +184,13 @@ impl<T: KeyValueDatabase + Send + Sync + 'static> BackingStorage\n                 {\n                     let _span = tracing::trace_span!(\"update task data\").entered();\n                     process_task_data(snapshots, Some(batch))?;\n+                    [KeySpace::TaskMeta, KeySpace::TaskData]\n+                        .into_par_iter()\n+                        .try_for_each(|key_space| {\n+                            // Safety: We already finished all processing of the task data and task\n+                            // meta\n+                            unsafe { batch.flush(key_space) }\n+                        })?;\n                 }\n \n                 let mut next_task_id = get_next_free_task_id::<\n@@ -500,6 +507,7 @@ where\n             )\n             .with_context(|| anyhow!(\"Unable to write operations\"))?;\n     }\n+    batch.flush(KeySpace::Infra)?;\n     Ok(())\n }\n "
        }
    ],
    "stats": {
        "total": 159,
        "additions": 153,
        "deletions": 6
    }
}