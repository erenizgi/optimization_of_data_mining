{
    "author": "mischnic",
    "message": "Turbopack: improve eventual consistency (#86724)\n\nas always...",
    "sha": "29524c1e22c396c2368ad6bf3bf92f6bee506a41",
    "files": [
        {
            "sha": "adc560e3045e6de32a7a8cf0ca15e19da07bd709",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/merged_modules.rs",
            "status": "modified",
            "additions": 30,
            "deletions": 11,
            "changes": 41,
            "blob_url": "https://github.com/vercel/next.js/blob/29524c1e22c396c2368ad6bf3bf92f6bee506a41/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmerged_modules.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/29524c1e22c396c2368ad6bf3bf92f6bee506a41/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmerged_modules.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmerged_modules.rs?ref=29524c1e22c396c2368ad6bf3bf92f6bee506a41",
            "patch": "@@ -342,14 +342,16 @@ pub async fn compute_merged_modules(module_graph: Vc<ModuleGraph>) -> Result<Vc<\n                                 let module = node;\n                                 let bitmap = module_merged_groups\n                                     .get(&module)\n-                                    .context(\"every module should have a bitmap at this point\")?;\n+                                    .context(\"every module should have a bitmap\")?;\n \n                                 if mergeable.contains(&module) {\n                                     let mergeable_module =\n                                         ResolvedVc::try_downcast::<Box<dyn MergeableModule>>(\n                                             module,\n                                         )\n-                                        .unwrap();\n+                                        .context(\n+                                            \"found mergeable module which is not a MergeableModule\",\n+                                        )?;\n                                     match chunk_lists.entry(bitmap) {\n                                         Entry::Vacant(e) => {\n                                             // New list, insert the module\n@@ -382,8 +384,12 @@ pub async fn compute_merged_modules(module_graph: Vc<ModuleGraph>) -> Result<Vc<\n                                 }\n \n                                 if let Some((parent, _)) = parent_info {\n-                                    let same_bitmap = module_merged_groups.get(&parent).unwrap()\n-                                        == module_merged_groups.get(&module).unwrap();\n+                                    let same_bitmap = module_merged_groups\n+                                        .get(&parent)\n+                                        .context(\"every module should have a bitmap\")?\n+                                        == module_merged_groups\n+                                            .get(&module)\n+                                            .context(\"every module should have a bitmap\")?;\n \n                                     if same_bitmap {\n                                         intra_group_references_rev\n@@ -470,8 +476,12 @@ pub async fn compute_merged_modules(module_graph: Vc<ModuleGraph>) -> Result<Vc<\n                 let module = node;\n \n                 if let Some((parent, _)) = parent_info {\n-                    let same_bitmap = module_merged_groups.get(&parent).unwrap()\n-                        == module_merged_groups.get(&module).unwrap();\n+                    let same_bitmap = module_merged_groups\n+                        .get(&parent)\n+                        .context(\"every module should have a bitmap\")?\n+                        == module_merged_groups\n+                            .get(&module)\n+                            .context(\"every module should have a bitmap\")?;\n \n                     if same_bitmap {\n                         intra_group_references\n@@ -481,10 +491,17 @@ pub async fn compute_merged_modules(module_graph: Vc<ModuleGraph>) -> Result<Vc<\n                     }\n                 }\n \n-                if parent_info.is_none_or(|(parent, _)| {\n-                    module_merged_groups.get(&parent).unwrap()\n-                        != module_merged_groups.get(&module).unwrap()\n-                }) {\n+                if match parent_info {\n+                    None => true,\n+                    Some((parent, _)) => {\n+                        module_merged_groups\n+                            .get(&parent)\n+                            .context(\"every module should have a bitmap\")?\n+                            != module_merged_groups\n+                                .get(&module)\n+                                .context(\"every module should have a bitmap\")?\n+                    }\n+                } {\n                     // This module needs to be exposed:\n                     // - referenced from another group or\n                     // - an entry module (TODO assume it will be required for Node/Edge, but not\n@@ -553,7 +570,9 @@ pub async fn compute_merged_modules(module_graph: Vc<ModuleGraph>) -> Result<Vc<\n             // Insert occurrences for the \"common\" list, skip the first because that is now\n             // guaranteed to exist only once\n             for (i, &m) in common_list.iter().enumerate().skip(1) {\n-                let occurrences = lists_reverse_indices.get_mut(&m).unwrap();\n+                let occurrences = lists_reverse_indices\n+                    .get_mut(&m)\n+                    .context(\"every module should have occurrences\")?;\n                 for common_occurrence in &common_occurrences {\n                     let removed = occurrences.swap_remove(&ListOccurrence {\n                         chunk_group: common_occurrence.chunk_group,"
        }
    ],
    "stats": {
        "total": 41,
        "additions": 30,
        "deletions": 11
    }
}