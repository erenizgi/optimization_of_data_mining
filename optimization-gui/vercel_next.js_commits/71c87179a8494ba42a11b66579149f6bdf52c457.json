{
    "author": "bgw",
    "message": "refactor(turbopack/napi): Add a NextTurbopackContext type, rename VcArc to DetachedVc (#80881)\n\n- Introduce `NextTurbopackContext` for use later in https://github.com/vercel/next.js/pull/81272 . In this PR, it's just a thin single-field wrapper, but we add callbacks to it in the next PR.\n- Wrap all the places we pass around `NextTurboTasks` in this new `NextTurbopackContext` type.\n- `VcArc` was a bit vague of a name, the important thing its that the `Vc` is detached from the turbo-tasks graph. `DetachedVc` matches the prefixed naming of `ResolvedVc` and `OperationVc`.",
    "sha": "71c87179a8494ba42a11b66579149f6bdf52c457",
    "files": [
        {
            "sha": "07a61f8427cda8a63dc67d262f4be76794d72ba5",
            "filename": "crates/napi/src/next_api/endpoint.rs",
            "status": "modified",
            "additions": 10,
            "deletions": 9,
            "changes": 19,
            "blob_url": "https://github.com/vercel/next.js/blob/71c87179a8494ba42a11b66579149f6bdf52c457/crates%2Fnapi%2Fsrc%2Fnext_api%2Fendpoint.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/71c87179a8494ba42a11b66579149f6bdf52c457/crates%2Fnapi%2Fsrc%2Fnext_api%2Fendpoint.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnapi%2Fsrc%2Fnext_api%2Fendpoint.rs?ref=71c87179a8494ba42a11b66579149f6bdf52c457",
            "patch": "@@ -15,7 +15,7 @@ use turbo_tasks::{Completion, Effects, OperationVc, ReadRef, Vc};\n use turbopack_core::{diagnostics::PlainDiagnostic, error::PrettyPrintError, issue::PlainIssue};\n \n use super::utils::{\n-    NapiDiagnostic, NapiIssue, RootTask, TurbopackResult, VcArc,\n+    DetachedVc, NapiDiagnostic, NapiIssue, RootTask, TurbopackResult,\n     strongly_consistent_catch_collectables, subscribe,\n };\n \n@@ -86,10 +86,10 @@ impl From<Option<EndpointOutputPaths>> for NapiWrittenEndpoint {\n //    some async functions (in this case `endpoint_write_to_disk`) can cause\n //    higher-ranked lifetime errors. See https://github.com/rust-lang/rust/issues/102211\n // 2. the type_complexity clippy lint.\n-pub struct ExternalEndpoint(pub VcArc<OptionEndpoint>);\n+pub struct ExternalEndpoint(pub DetachedVc<OptionEndpoint>);\n \n impl Deref for ExternalEndpoint {\n-    type Target = VcArc<OptionEndpoint>;\n+    type Target = DetachedVc<OptionEndpoint>;\n \n     fn deref(&self) -> &Self::Target {\n         &self.0\n@@ -125,9 +125,10 @@ async fn get_written_endpoint_with_issues_operation(\n pub async fn endpoint_write_to_disk(\n     #[napi(ts_arg_type = \"{ __napiType: \\\"Endpoint\\\" }\")] endpoint: External<ExternalEndpoint>,\n ) -> napi::Result<TurbopackResult<NapiWrittenEndpoint>> {\n-    let turbo_tasks = endpoint.turbo_tasks().clone();\n     let endpoint_op = ***endpoint;\n-    let (written, issues, diags) = turbo_tasks\n+    let (written, issues, diags) = endpoint\n+        .turbopack_ctx()\n+        .turbo_tasks()\n         .run_once(async move {\n             let written_entrypoint_with_issues_op =\n                 get_written_endpoint_with_issues_operation(endpoint_op);\n@@ -158,10 +159,10 @@ pub fn endpoint_server_changed_subscribe(\n     issues: bool,\n     func: JsFunction,\n ) -> napi::Result<External<RootTask>> {\n-    let turbo_tasks = endpoint.turbo_tasks().clone();\n+    let turbopack_ctx = endpoint.turbopack_ctx().clone();\n     let endpoint = ***endpoint;\n     subscribe(\n-        turbo_tasks,\n+        turbopack_ctx,\n         func,\n         move || {\n             async move {\n@@ -247,10 +248,10 @@ pub fn endpoint_client_changed_subscribe(\n     #[napi(ts_arg_type = \"{ __napiType: \\\"Endpoint\\\" }\")] endpoint: External<ExternalEndpoint>,\n     func: JsFunction,\n ) -> napi::Result<External<RootTask>> {\n-    let turbo_tasks = endpoint.turbo_tasks().clone();\n+    let turbopack_ctx = endpoint.turbopack_ctx().clone();\n     let endpoint_op = ***endpoint;\n     subscribe(\n-        turbo_tasks,\n+        turbopack_ctx,\n         func,\n         move || {\n             async move {"
        },
        {
            "sha": "4897b2d3bf9ba22ee2f7f231059d889a903f10f0",
            "filename": "crates/napi/src/next_api/mod.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/71c87179a8494ba42a11b66579149f6bdf52c457/crates%2Fnapi%2Fsrc%2Fnext_api%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/71c87179a8494ba42a11b66579149f6bdf52c457/crates%2Fnapi%2Fsrc%2Fnext_api%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnapi%2Fsrc%2Fnext_api%2Fmod.rs?ref=71c87179a8494ba42a11b66579149f6bdf52c457",
            "patch": "@@ -1,3 +1,4 @@\n pub mod endpoint;\n pub mod project;\n+pub mod turbopack_ctx;\n pub mod utils;"
        },
        {
            "sha": "d0f8e2db7c5d2da83e03f49440acecf3d8dbc802",
            "filename": "crates/napi/src/next_api/project.rs",
            "status": "modified",
            "additions": 87,
            "deletions": 74,
            "changes": 161,
            "blob_url": "https://github.com/vercel/next.js/blob/71c87179a8494ba42a11b66579149f6bdf52c457/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/71c87179a8494ba42a11b66579149f6bdf52c457/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs?ref=71c87179a8494ba42a11b66579149f6bdf52c457",
            "patch": "@@ -59,14 +59,18 @@ use turbopack_trace_utils::{\n };\n use url::Url;\n \n-use super::{\n-    endpoint::ExternalEndpoint,\n-    utils::{\n-        NapiDiagnostic, NapiIssue, NextTurboTasks, RootTask, TurbopackResult, VcArc,\n-        create_turbo_tasks, get_diagnostics, get_issues, subscribe,\n+use crate::{\n+    next_api::{\n+        endpoint::ExternalEndpoint,\n+        turbopack_ctx::{NextTurboTasks, NextTurbopackContext, create_turbo_tasks},\n+        utils::{\n+            DetachedVc, NapiDiagnostic, NapiIssue, RootTask, TurbopackResult, get_diagnostics,\n+            get_issues, subscribe,\n+        },\n     },\n+    register,\n+    util::DhatProfilerGuard,\n };\n-use crate::{register, util::DhatProfilerGuard};\n \n /// Used by [`benchmark_file_io`]. This is a noisy benchmark, so set the\n /// threshold high.\n@@ -320,7 +324,7 @@ impl From<NapiDefineEnv> for DefineEnv {\n }\n \n pub struct ProjectInstance {\n-    turbo_tasks: NextTurboTasks,\n+    turbopack_ctx: NextTurbopackContext,\n     container: ResolvedVc<ProjectContainer>,\n     exit_receiver: tokio::sync::Mutex<Option<ExitReceiver>>,\n }\n@@ -447,18 +451,17 @@ pub async fn project_new(\n         .await\n         .map_err(|e| napi::Error::from_reason(PrettyPrintError(&e).to_string()))?;\n \n-    let tasks_ref = turbo_tasks.clone();\n-    turbo_tasks.spawn_once_task(async move {\n-        benchmark_file_io(\n-            tasks_ref,\n-            container.project().node_root().await?.clone_value(),\n-        )\n-        .await\n-        .inspect_err(|err| tracing::warn!(%err, \"failed to benchmark file IO\"))\n+    turbo_tasks.spawn_once_task({\n+        let tt = turbo_tasks.clone();\n+        async move {\n+            benchmark_file_io(tt, container.project().node_root().await?.clone_value())\n+                .await\n+                .inspect_err(|err| tracing::warn!(%err, \"failed to benchmark file IO\"))\n+        }\n     });\n     Ok(External::new_with_size_hint(\n         ProjectInstance {\n-            turbo_tasks,\n+            turbopack_ctx: NextTurbopackContext::new(turbo_tasks),\n             container,\n             exit_receiver: tokio::sync::Mutex::new(Some(exit_receiver)),\n         },\n@@ -568,10 +571,11 @@ pub async fn project_update(\n     #[napi(ts_arg_type = \"{ __napiType: \\\"Project\\\" }\")] project: External<ProjectInstance>,\n     options: NapiPartialProjectOptions,\n ) -> napi::Result<()> {\n-    let turbo_tasks = project.turbo_tasks.clone();\n     let options = options.into();\n     let container = project.container;\n-    turbo_tasks\n+    project\n+        .turbopack_ctx\n+        .turbo_tasks()\n         .run_once(async move {\n             container.update(options).await?;\n             Ok(())\n@@ -591,7 +595,8 @@ pub async fn project_invalidate_persistent_cache(\n         // TODO: Let the JS caller specify a reason? We need to limit the reasons to ones we know\n         // how to generate a message for on the Rust side of the FFI.\n         project\n-            .turbo_tasks\n+            .turbopack_ctx\n+            .turbo_tasks()\n             .backend()\n             .backing_storage()\n             .invalidate(invalidation_reasons::USER_REQUEST)\n@@ -629,7 +634,7 @@ async fn project_on_exit_internal(project: &ProjectInstance) {\n pub async fn project_shutdown(\n     #[napi(ts_arg_type = \"{ __napiType: \\\"Project\\\" }\")] project: External<ProjectInstance>,\n ) {\n-    project.turbo_tasks.stop_and_wait().await;\n+    project.turbopack_ctx.turbo_tasks().stop_and_wait().await;\n     project_on_exit_internal(&project).await;\n }\n \n@@ -664,10 +669,14 @@ pub struct NapiRoute {\n }\n \n impl NapiRoute {\n-    fn from_route(pathname: String, value: RouteOperation, turbo_tasks: &NextTurboTasks) -> Self {\n+    fn from_route(\n+        pathname: String,\n+        value: RouteOperation,\n+        turbopack_ctx: &NextTurbopackContext,\n+    ) -> Self {\n         let convert_endpoint = |endpoint: OperationVc<OptionEndpoint>| {\n-            Some(External::new(ExternalEndpoint(VcArc::new(\n-                turbo_tasks.clone(),\n+            Some(External::new(ExternalEndpoint(DetachedVc::new(\n+                turbopack_ctx.clone(),\n                 endpoint,\n             ))))\n         };\n@@ -728,10 +737,13 @@ pub struct NapiMiddleware {\n }\n \n impl NapiMiddleware {\n-    fn from_middleware(value: &MiddlewareOperation, turbo_tasks: &NextTurboTasks) -> Result<Self> {\n+    fn from_middleware(\n+        value: &MiddlewareOperation,\n+        turbopack_ctx: &NextTurbopackContext,\n+    ) -> Result<Self> {\n         Ok(NapiMiddleware {\n-            endpoint: External::new(ExternalEndpoint(VcArc::new(\n-                turbo_tasks.clone(),\n+            endpoint: External::new(ExternalEndpoint(DetachedVc::new(\n+                turbopack_ctx.clone(),\n                 value.endpoint,\n             ))),\n         })\n@@ -747,15 +759,15 @@ pub struct NapiInstrumentation {\n impl NapiInstrumentation {\n     fn from_instrumentation(\n         value: &InstrumentationOperation,\n-        turbo_tasks: &NextTurboTasks,\n+        turbopack_ctx: &NextTurbopackContext,\n     ) -> Result<Self> {\n         Ok(NapiInstrumentation {\n-            node_js: External::new(ExternalEndpoint(VcArc::new(\n-                turbo_tasks.clone(),\n+            node_js: External::new(ExternalEndpoint(DetachedVc::new(\n+                turbopack_ctx.clone(),\n                 value.node_js,\n             ))),\n-            edge: External::new(ExternalEndpoint(VcArc::new(\n-                turbo_tasks.clone(),\n+            edge: External::new(ExternalEndpoint(DetachedVc::new(\n+                turbopack_ctx.clone(),\n                 value.edge,\n             ))),\n         })\n@@ -775,33 +787,33 @@ pub struct NapiEntrypoints {\n impl NapiEntrypoints {\n     fn from_entrypoints_op(\n         entrypoints: &EntrypointsOperation,\n-        turbo_tasks: &NextTurboTasks,\n+        turbopack_ctx: &NextTurbopackContext,\n     ) -> Result<Self> {\n         let routes = entrypoints\n             .routes\n             .iter()\n-            .map(|(k, v)| NapiRoute::from_route(k.to_string(), v.clone(), turbo_tasks))\n+            .map(|(k, v)| NapiRoute::from_route(k.to_string(), v.clone(), turbopack_ctx))\n             .collect();\n         let middleware = entrypoints\n             .middleware\n             .as_ref()\n-            .map(|m| NapiMiddleware::from_middleware(m, turbo_tasks))\n+            .map(|m| NapiMiddleware::from_middleware(m, turbopack_ctx))\n             .transpose()?;\n         let instrumentation = entrypoints\n             .instrumentation\n             .as_ref()\n-            .map(|i| NapiInstrumentation::from_instrumentation(i, turbo_tasks))\n+            .map(|i| NapiInstrumentation::from_instrumentation(i, turbopack_ctx))\n             .transpose()?;\n-        let pages_document_endpoint = External::new(ExternalEndpoint(VcArc::new(\n-            turbo_tasks.clone(),\n+        let pages_document_endpoint = External::new(ExternalEndpoint(DetachedVc::new(\n+            turbopack_ctx.clone(),\n             entrypoints.pages_document_endpoint,\n         )));\n-        let pages_app_endpoint = External::new(ExternalEndpoint(VcArc::new(\n-            turbo_tasks.clone(),\n+        let pages_app_endpoint = External::new(ExternalEndpoint(DetachedVc::new(\n+            turbopack_ctx.clone(),\n             entrypoints.pages_app_endpoint,\n         )));\n-        let pages_error_endpoint = External::new(ExternalEndpoint(VcArc::new(\n-            turbo_tasks.clone(),\n+        let pages_error_endpoint = External::new(ExternalEndpoint(DetachedVc::new(\n+            turbopack_ctx.clone(),\n             entrypoints.pages_error_endpoint,\n         )));\n         Ok(NapiEntrypoints {\n@@ -864,13 +876,15 @@ pub async fn project_write_all_entrypoints_to_disk(\n     #[napi(ts_arg_type = \"{ __napiType: \\\"Project\\\" }\")] project: External<ProjectInstance>,\n     app_dir_only: bool,\n ) -> napi::Result<TurbopackResult<NapiEntrypoints>> {\n-    let turbo_tasks = project.turbo_tasks.clone();\n-    let compilation_event_sender = turbo_tasks.clone();\n+    let container = project.container;\n+    let tt = project.turbopack_ctx.turbo_tasks().clone();\n \n-    let (entrypoints, issues, diags) = turbo_tasks\n+    let (entrypoints, issues, diags) = project\n+        .turbopack_ctx\n+        .turbo_tasks()\n         .run_once(async move {\n             let entrypoints_with_issues_op =\n-                get_all_written_entrypoints_with_issues_operation(project.container, app_dir_only);\n+                get_all_written_entrypoints_with_issues_operation(container, app_dir_only);\n \n             // Read and compile the files\n             let EntrypointsWithIssues {\n@@ -889,7 +903,7 @@ pub async fn project_write_all_entrypoints_to_disk(\n             effects.apply().await?;\n \n             // Send a compilation event to indicate that the files have been written to disk\n-            compilation_event_sender.send_compilation_event(Arc::new(TimingEvent::new(\n+            tt.send_compilation_event(Arc::new(TimingEvent::new(\n                 \"Finished writing to disk\".to_owned(),\n                 now.elapsed(),\n             )));\n@@ -900,7 +914,7 @@ pub async fn project_write_all_entrypoints_to_disk(\n         .map_err(|e| napi::Error::from_reason(PrettyPrintError(&e).to_string()))?;\n \n     Ok(TurbopackResult {\n-        result: NapiEntrypoints::from_entrypoints_op(&entrypoints, &turbo_tasks)?,\n+        result: NapiEntrypoints::from_entrypoints_op(&entrypoints, &project.turbopack_ctx)?,\n         issues: issues.iter().map(|i| NapiIssue::from(&**i)).collect(),\n         diagnostics: diags.iter().map(|d| NapiDiagnostic::from(d)).collect(),\n     })\n@@ -969,10 +983,10 @@ pub fn project_entrypoints_subscribe(\n     #[napi(ts_arg_type = \"{ __napiType: \\\"Project\\\" }\")] project: External<ProjectInstance>,\n     func: JsFunction,\n ) -> napi::Result<External<RootTask>> {\n-    let turbo_tasks = project.turbo_tasks.clone();\n+    let turbopack_ctx = project.turbopack_ctx.clone();\n     let container = project.container;\n     subscribe(\n-        turbo_tasks.clone(),\n+        turbopack_ctx.clone(),\n         func,\n         move || {\n             async move {\n@@ -994,7 +1008,7 @@ pub fn project_entrypoints_subscribe(\n             let (entrypoints, issues, diags) = ctx.value;\n \n             Ok(vec![TurbopackResult {\n-                result: NapiEntrypoints::from_entrypoints_op(&entrypoints, &turbo_tasks)?,\n+                result: NapiEntrypoints::from_entrypoints_op(&entrypoints, &turbopack_ctx)?,\n                 issues: issues\n                     .iter()\n                     .map(|issue| NapiIssue::from(&**issue))\n@@ -1048,11 +1062,10 @@ pub fn project_hmr_events(\n     identifier: RcStr,\n     func: JsFunction,\n ) -> napi::Result<External<RootTask>> {\n-    let turbo_tasks = project.turbo_tasks.clone();\n-    let project = project.container;\n+    let container = project.container;\n     let session = TransientInstance::new(());\n     subscribe(\n-        turbo_tasks.clone(),\n+        project.turbopack_ctx.clone(),\n         func,\n         {\n             let outer_identifier = identifier.clone();\n@@ -1061,7 +1074,7 @@ pub fn project_hmr_events(\n                 let identifier: RcStr = outer_identifier.clone();\n                 let session = session.clone();\n                 async move {\n-                    let project = project.project().to_resolved().await?;\n+                    let project = container.project().to_resolved().await?;\n                     let state = project\n                         .hmr_version_state(identifier.clone(), session)\n                         .to_resolved()\n@@ -1174,10 +1187,9 @@ pub fn project_hmr_identifiers_subscribe(\n     #[napi(ts_arg_type = \"{ __napiType: \\\"Project\\\" }\")] project: External<ProjectInstance>,\n     func: JsFunction,\n ) -> napi::Result<External<RootTask>> {\n-    let turbo_tasks = project.turbo_tasks.clone();\n     let container = project.container;\n     subscribe(\n-        turbo_tasks.clone(),\n+        project.turbopack_ctx.clone(),\n         func,\n         move || async move {\n             let hmr_identifiers_with_issues_op =\n@@ -1276,10 +1288,10 @@ pub fn project_update_info_subscribe(\n         let message = ctx.value;\n         Ok(vec![NapiUpdateMessage::from(message)])\n     })?;\n-    let turbo_tasks = project.turbo_tasks.clone();\n     tokio::spawn(async move {\n+        let tt = project.turbopack_ctx.turbo_tasks();\n         loop {\n-            let update_info = turbo_tasks\n+            let update_info = tt\n                 .aggregated_update_info(Duration::ZERO, Duration::ZERO)\n                 .await;\n \n@@ -1291,11 +1303,10 @@ pub fn project_update_info_subscribe(\n             let update_info = match update_info {\n                 Some(update_info) => update_info,\n                 None => {\n-                    turbo_tasks\n-                        .get_or_wait_aggregated_update_info(Duration::from_millis(\n-                            aggregation_ms.into(),\n-                        ))\n-                        .await\n+                    tt.get_or_wait_aggregated_update_info(Duration::from_millis(\n+                        aggregation_ms.into(),\n+                    ))\n+                    .await\n                 }\n             };\n \n@@ -1321,7 +1332,6 @@ pub fn project_compilation_events_subscribe(\n     func: JsFunction,\n     event_types: Option<Vec<String>>,\n ) -> napi::Result<()> {\n-    let turbo_tasks = project.turbo_tasks.clone();\n     let tsfn: ThreadsafeFunction<Arc<dyn CompilationEvent>> =\n         func.create_threadsafe_function(0, |ctx| {\n             let event: Arc<dyn CompilationEvent> = ctx.value;\n@@ -1339,7 +1349,8 @@ pub fn project_compilation_events_subscribe(\n         })?;\n \n     tokio::spawn(async move {\n-        let mut receiver = turbo_tasks.subscribe_to_compilation_events(event_types);\n+        let tt = project.turbopack_ctx.turbo_tasks();\n+        let mut receiver = tt.subscribe_to_compilation_events(event_types);\n         while let Some(msg) = receiver.recv().await {\n             let status = tsfn.call(Ok(msg), ThreadsafeFunctionCallMode::Blocking);\n \n@@ -1552,9 +1563,10 @@ pub async fn project_trace_source(\n     frame: StackFrame,\n     current_directory_file_url: String,\n ) -> napi::Result<Option<StackFrame>> {\n-    let turbo_tasks = project.turbo_tasks.clone();\n     let container = project.container;\n-    let traced_frame = turbo_tasks\n+    let traced_frame = project\n+        .turbopack_ctx\n+        .turbo_tasks()\n         .run_once(async move {\n             project_trace_source_operation(\n                 container,\n@@ -1574,11 +1586,12 @@ pub async fn project_get_source_for_asset(\n     #[napi(ts_arg_type = \"{ __napiType: \\\"Project\\\" }\")] project: External<ProjectInstance>,\n     file_path: RcStr,\n ) -> napi::Result<Option<String>> {\n-    let turbo_tasks = project.turbo_tasks.clone();\n-    let source = turbo_tasks\n+    let container = project.container;\n+    let source = project\n+        .turbopack_ctx\n+        .turbo_tasks()\n         .run_once(async move {\n-            let source_content = &*project\n-                .container\n+            let source_content = &*container\n                 .project()\n                 .project_path()\n                 .await?\n@@ -1606,10 +1619,10 @@ pub async fn project_get_source_map(\n     #[napi(ts_arg_type = \"{ __napiType: \\\"Project\\\" }\")] project: External<ProjectInstance>,\n     file_path: RcStr,\n ) -> napi::Result<Option<String>> {\n-    let turbo_tasks = project.turbo_tasks.clone();\n     let container = project.container;\n-\n-    let source_map = turbo_tasks\n+    let source_map = project\n+        .turbopack_ctx\n+        .turbo_tasks()\n         .run_once(async move {\n             let Some(map) = &*get_source_map_rope_operation(container, file_path)\n                 .read_strongly_consistent()"
        },
        {
            "sha": "e4b1ff33c0185bad87fa92f194fe2dac4599cd1d",
            "filename": "crates/napi/src/next_api/turbopack_ctx.rs",
            "status": "added",
            "additions": 122,
            "deletions": 0,
            "changes": 122,
            "blob_url": "https://github.com/vercel/next.js/blob/71c87179a8494ba42a11b66579149f6bdf52c457/crates%2Fnapi%2Fsrc%2Fnext_api%2Fturbopack_ctx.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/71c87179a8494ba42a11b66579149f6bdf52c457/crates%2Fnapi%2Fsrc%2Fnext_api%2Fturbopack_ctx.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnapi%2Fsrc%2Fnext_api%2Fturbopack_ctx.rs?ref=71c87179a8494ba42a11b66579149f6bdf52c457",
            "patch": "@@ -0,0 +1,122 @@\n+//! Utilities for constructing and using the [`NextTurbopackContext`] type.\n+\n+use std::{path::PathBuf, sync::Arc};\n+\n+use anyhow::Result;\n+use either::Either;\n+use serde::Serialize;\n+use turbo_tasks::{\n+    TurboTasks, TurboTasksApi,\n+    message_queue::{CompilationEvent, Severity},\n+};\n+use turbo_tasks_backend::{\n+    BackendOptions, DefaultBackingStorage, GitVersionInfo, NoopBackingStorage, StartupCacheState,\n+    TurboTasksBackend, db_invalidation::invalidation_reasons, default_backing_storage,\n+    noop_backing_storage,\n+};\n+\n+pub type NextTurboTasks =\n+    Arc<TurboTasks<TurboTasksBackend<Either<DefaultBackingStorage, NoopBackingStorage>>>>;\n+\n+/// A value often wrapped in [`napi::bindgen_prelude::External`] that retains the Turbopack instance\n+/// used by Next.js, and various napi helpers that may have been passed to us from JS.\n+///\n+/// This is not a [`turbo_tasks::value`], and should only be used within the top-level napi layer.\n+/// It should not be passed to a [`turbo_tasks::function`]. For serializable information about the\n+/// project, use the [`next_api::project::Project`] type.\n+#[derive(Clone)]\n+pub struct NextTurbopackContext {\n+    inner: Arc<NextTurboContextInner>,\n+}\n+\n+struct NextTurboContextInner {\n+    turbo_tasks: NextTurboTasks,\n+}\n+\n+impl NextTurbopackContext {\n+    pub fn new(turbo_tasks: NextTurboTasks) -> Self {\n+        NextTurbopackContext {\n+            inner: Arc::new(NextTurboContextInner { turbo_tasks }),\n+        }\n+    }\n+\n+    pub fn turbo_tasks(&self) -> &NextTurboTasks {\n+        &self.inner.turbo_tasks\n+    }\n+}\n+\n+pub fn create_turbo_tasks(\n+    output_path: PathBuf,\n+    persistent_caching: bool,\n+    _memory_limit: usize,\n+    dependency_tracking: bool,\n+    is_ci: bool,\n+) -> Result<NextTurboTasks> {\n+    Ok(if persistent_caching {\n+        let version_info = GitVersionInfo {\n+            describe: env!(\"VERGEN_GIT_DESCRIBE\"),\n+            dirty: option_env!(\"CI\").is_none_or(|value| value.is_empty())\n+                && env!(\"VERGEN_GIT_DIRTY\") == \"true\",\n+        };\n+        let (backing_storage, cache_state) =\n+            default_backing_storage(&output_path.join(\"cache/turbopack\"), &version_info, is_ci)?;\n+        let tt = TurboTasks::new(TurboTasksBackend::new(\n+            BackendOptions {\n+                storage_mode: Some(if std::env::var(\"TURBO_ENGINE_READ_ONLY\").is_ok() {\n+                    turbo_tasks_backend::StorageMode::ReadOnly\n+                } else {\n+                    turbo_tasks_backend::StorageMode::ReadWrite\n+                }),\n+                dependency_tracking,\n+                ..Default::default()\n+            },\n+            Either::Left(backing_storage),\n+        ));\n+        if let StartupCacheState::Invalidated { reason_code } = cache_state {\n+            tt.send_compilation_event(Arc::new(StartupCacheInvalidationEvent { reason_code }));\n+        }\n+        tt\n+    } else {\n+        TurboTasks::new(TurboTasksBackend::new(\n+            BackendOptions {\n+                storage_mode: None,\n+                dependency_tracking,\n+                ..Default::default()\n+            },\n+            Either::Right(noop_backing_storage()),\n+        ))\n+    })\n+}\n+\n+#[derive(Serialize)]\n+struct StartupCacheInvalidationEvent {\n+    reason_code: Option<String>,\n+}\n+\n+impl CompilationEvent for StartupCacheInvalidationEvent {\n+    fn type_name(&self) -> &'static str {\n+        \"StartupCacheInvalidationEvent\"\n+    }\n+\n+    fn severity(&self) -> Severity {\n+        Severity::Warning\n+    }\n+\n+    fn message(&self) -> String {\n+        let reason_msg = match self.reason_code.as_deref() {\n+            Some(invalidation_reasons::PANIC) => {\n+                \" because we previously detected an internal error in Turbopack\"\n+            }\n+            Some(invalidation_reasons::USER_REQUEST) => \" as the result of a user request\",\n+            _ => \"\", // ignore unknown reasons\n+        };\n+        format!(\n+            \"Turbopack's persistent cache has been deleted{reason_msg}. Builds or page loads may \\\n+             be slower as a result.\"\n+        )\n+    }\n+\n+    fn to_json(&self) -> String {\n+        serde_json::to_string(self).unwrap()\n+    }\n+}"
        },
        {
            "sha": "5038ec5a8430f7dd299a246e4a2bfe16980bfe0e",
            "filename": "crates/napi/src/next_api/utils.rs",
            "status": "modified",
            "additions": 41,
            "deletions": 109,
            "changes": 150,
            "blob_url": "https://github.com/vercel/next.js/blob/71c87179a8494ba42a11b66579149f6bdf52c457/crates%2Fnapi%2Fsrc%2Fnext_api%2Futils.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/71c87179a8494ba42a11b66579149f6bdf52c457/crates%2Fnapi%2Fsrc%2Fnext_api%2Futils.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnapi%2Fsrc%2Fnext_api%2Futils.rs?ref=71c87179a8494ba42a11b66579149f6bdf52c457",
            "patch": "@@ -1,7 +1,6 @@\n-use std::{future::Future, ops::Deref, path::PathBuf, sync::Arc};\n+use std::{future::Future, ops::Deref, sync::Arc};\n \n use anyhow::{Context, Result, anyhow};\n-use either::Either;\n use napi::{\n     JsFunction, JsObject, JsUnknown, NapiRaw, NapiValue, Status,\n     bindgen_prelude::{External, ToNapiValue},\n@@ -10,14 +9,7 @@ use napi::{\n use rustc_hash::FxHashMap;\n use serde::Serialize;\n use turbo_tasks::{\n-    Effects, OperationVc, ReadRef, TaskId, TryJoinIterExt, TurboTasks, TurboTasksApi, Vc,\n-    VcValueType, get_effects,\n-    message_queue::{CompilationEvent, Severity},\n-};\n-use turbo_tasks_backend::{\n-    DefaultBackingStorage, GitVersionInfo, NoopBackingStorage, StartupCacheState,\n-    TurboTasksBackend, db_invalidation::invalidation_reasons, default_backing_storage,\n-    noop_backing_storage,\n+    Effects, OperationVc, ReadRef, TaskId, TryJoinIterExt, Vc, VcValueType, get_effects,\n };\n use turbo_tasks_fs::FileContent;\n use turbopack_core::{\n@@ -29,107 +21,37 @@ use turbopack_core::{\n     source_pos::SourcePos,\n };\n \n-use crate::util::log_internal_error_and_inform;\n-\n-pub type NextTurboTasks =\n-    Arc<TurboTasks<TurboTasksBackend<Either<DefaultBackingStorage, NoopBackingStorage>>>>;\n-\n-#[derive(Serialize)]\n-struct StartupCacheInvalidationEvent {\n-    reason_code: Option<String>,\n-}\n-\n-impl CompilationEvent for StartupCacheInvalidationEvent {\n-    fn type_name(&self) -> &'static str {\n-        \"StartupCacheInvalidationEvent\"\n-    }\n-\n-    fn severity(&self) -> Severity {\n-        Severity::Warning\n-    }\n-\n-    fn message(&self) -> String {\n-        let reason_msg = match self.reason_code.as_deref() {\n-            Some(invalidation_reasons::PANIC) => {\n-                \" because we previously detected an internal error in Turbopack\"\n-            }\n-            Some(invalidation_reasons::USER_REQUEST) => \" as the result of a user request\",\n-            _ => \"\", // ignore unknown reasons\n-        };\n-        format!(\n-            \"Turbopack's persistent cache has been deleted{reason_msg}. Builds or page loads may \\\n-             be slower as a result.\"\n-        )\n-    }\n-\n-    fn to_json(&self) -> String {\n-        serde_json::to_string(self).unwrap()\n-    }\n-}\n-\n-pub fn create_turbo_tasks(\n-    output_path: PathBuf,\n-    persistent_caching: bool,\n-    _memory_limit: usize,\n-    dependency_tracking: bool,\n-    is_ci: bool,\n-) -> Result<NextTurboTasks> {\n-    Ok(if persistent_caching {\n-        let version_info = GitVersionInfo {\n-            describe: env!(\"VERGEN_GIT_DESCRIBE\"),\n-            dirty: option_env!(\"CI\").is_none_or(|value| value.is_empty())\n-                && env!(\"VERGEN_GIT_DIRTY\") == \"true\",\n-        };\n-        let (backing_storage, cache_state) =\n-            default_backing_storage(&output_path.join(\"cache/turbopack\"), &version_info, is_ci)?;\n-        let tt = TurboTasks::new(TurboTasksBackend::new(\n-            turbo_tasks_backend::BackendOptions {\n-                storage_mode: Some(if std::env::var(\"TURBO_ENGINE_READ_ONLY\").is_ok() {\n-                    turbo_tasks_backend::StorageMode::ReadOnly\n-                } else {\n-                    turbo_tasks_backend::StorageMode::ReadWrite\n-                }),\n-                dependency_tracking,\n-                ..Default::default()\n-            },\n-            Either::Left(backing_storage),\n-        ));\n-        if let StartupCacheState::Invalidated { reason_code } = cache_state {\n-            tt.send_compilation_event(Arc::new(StartupCacheInvalidationEvent { reason_code }));\n-        }\n-        tt\n-    } else {\n-        TurboTasks::new(TurboTasksBackend::new(\n-            turbo_tasks_backend::BackendOptions {\n-                storage_mode: None,\n-                dependency_tracking,\n-                ..Default::default()\n-            },\n-            Either::Right(noop_backing_storage()),\n-        ))\n-    })\n-}\n-\n-/// A helper type to hold both a Vc operation and the TurboTasks root process.\n-/// Without this, we'd need to pass both individually all over the place\n+use crate::{next_api::turbopack_ctx::NextTurbopackContext, util::log_internal_error_and_inform};\n+\n+/// An [`OperationVc`] that can be passed back and forth to JS across the [`napi`][mod@napi]\n+/// boundary via [`External`].\n+///\n+/// It is a helper type to hold both a [`OperationVc`] and the [`NextTurbopackContext`]. Without\n+/// this, we'd need to pass both individually all over the place.\n+///\n+/// This napi-specific abstraction does not implement [`turbo_tasks::NonLocalValue`] or\n+/// [`turbo_tasks::OperationValue`] and should be dereferenced to an [`OperationVc`] before being\n+/// passed to a [`turbo_tasks::function`].\n+//\n+// TODO: If we add a tracing garbage collector to turbo-tasks, this should be tracked as a GC root.\n #[derive(Clone)]\n-pub struct VcArc<T> {\n-    turbo_tasks: NextTurboTasks,\n+pub struct DetachedVc<T> {\n+    turbopack_ctx: NextTurbopackContext,\n     /// The Vc. Must be unresolved, otherwise you are referencing an inactive operation.\n     vc: OperationVc<T>,\n }\n \n-impl<T> VcArc<T> {\n-    pub fn new(turbo_tasks: NextTurboTasks, vc: OperationVc<T>) -> Self {\n-        Self { turbo_tasks, vc }\n+impl<T> DetachedVc<T> {\n+    pub fn new(turbopack_ctx: NextTurbopackContext, vc: OperationVc<T>) -> Self {\n+        Self { turbopack_ctx, vc }\n     }\n \n-    pub fn turbo_tasks(&self) -> &NextTurboTasks {\n-        &self.turbo_tasks\n+    pub fn turbopack_ctx(&self) -> &NextTurbopackContext {\n+        &self.turbopack_ctx\n     }\n }\n \n-impl<T> Deref for VcArc<T> {\n+impl<T> Deref for DetachedVc<T> {\n     type Target = OperationVc<T>;\n \n     fn deref(&self) -> &Self::Target {\n@@ -144,11 +66,18 @@ pub fn serde_enum_to_string<T: Serialize>(value: &T) -> Result<String> {\n         .to_string())\n }\n \n-/// The root of our turbopack computation.\n+/// An opaque handle to the root of a turbo-tasks computation created by\n+/// [`turbo_tasks::TurboTasks::spawn_root_task`] that can be passed back and forth to JS across the\n+/// [`napi`][mod@napi] boundary via [`External`].\n+///\n+/// JavaScript code receiving this value **must** call [`root_task_dispose`] in a `try...finally`\n+/// block to avoid leaking root tasks.\n+///\n+/// This is used by [`subscribe`] to create a computation that re-executes when dependencies change.\n+//\n+// TODO: If we add a tracing garbage collector to turbo-tasks, this should be tracked as a GC root.\n pub struct RootTask {\n-    #[allow(dead_code)]\n-    turbo_tasks: NextTurboTasks,\n-    #[allow(dead_code)]\n+    turbopack_ctx: NextTurbopackContext,\n     task_id: Option<TaskId>,\n }\n \n@@ -163,7 +92,10 @@ pub fn root_task_dispose(\n     #[napi(ts_arg_type = \"{ __napiType: \\\"RootTask\\\" }\")] mut root_task: External<RootTask>,\n ) -> napi::Result<()> {\n     if let Some(task) = root_task.task_id.take() {\n-        root_task.turbo_tasks.dispose_root_task(task);\n+        root_task\n+            .turbopack_ctx\n+            .turbo_tasks()\n+            .dispose_root_task(task);\n     }\n     Ok(())\n }\n@@ -392,13 +324,13 @@ impl<T: ToNapiValue> ToNapiValue for TurbopackResult<T> {\n }\n \n pub fn subscribe<T: 'static + Send + Sync, F: Future<Output = Result<T>> + Send, V: ToNapiValue>(\n-    turbo_tasks: NextTurboTasks,\n+    turbopack_ctx: NextTurbopackContext,\n     func: JsFunction,\n     handler: impl 'static + Sync + Send + Clone + Fn() -> F,\n     mapper: impl 'static + Sync + Send + FnMut(ThreadSafeCallContext<T>) -> napi::Result<Vec<V>>,\n ) -> napi::Result<External<RootTask>> {\n     let func: ThreadsafeFunction<T> = func.create_threadsafe_function(0, mapper)?;\n-    let task_id = turbo_tasks.spawn_root_task(move || {\n+    let task_id = turbopack_ctx.turbo_tasks().spawn_root_task(move || {\n         let handler = handler.clone();\n         let func = func.clone();\n         Box::pin(async move {\n@@ -420,7 +352,7 @@ pub fn subscribe<T: 'static + Send + Sync, F: Future<Output = Result<T>> + Send,\n         })\n     });\n     Ok(External::new(RootTask {\n-        turbo_tasks,\n+        turbopack_ctx,\n         task_id: Some(task_id),\n     }))\n }"
        }
    ],
    "stats": {
        "total": 453,
        "additions": 261,
        "deletions": 192
    }
}