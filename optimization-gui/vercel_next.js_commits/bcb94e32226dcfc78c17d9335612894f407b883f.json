{
    "author": "acdlite",
    "message": "[Segment Cache] Refresh on same-page navigation (#76223)\n\nIt's a common UI pattern for apps to refresh when you click a link to\nthe current page. So when this happens, we refresh the dynamic data in\nthe page segments.\n\nNote that this does not apply if the any part of the hash or search\nquery has changed. This might feel a bit weird but it makes more sense\nwhen you consider that the way to trigger this behavior is to click the\nsame link multiple times.\n\nWe should probably refresh the *entire* route when this case occurs, not\njust the page segments. Essentially treating it the same as a refresh()\ntriggered by an action, which is the more explicit way of modeling the\nUI pattern described above.\n\nAlso note that this only refreshes the dynamic data, not static/cached\ndata. If the page segment is fully static and prefetched, the request is\nskipped. (This is also how refresh() works.)",
    "sha": "bcb94e32226dcfc78c17d9335612894f407b883f",
    "files": [
        {
            "sha": "7fd21ef11c75224897226d100aeb92fc0940bae0",
            "filename": "packages/next/src/client/components/router-reducer/ppr-navigations.ts",
            "status": "modified",
            "additions": 42,
            "deletions": 0,
            "changes": 42,
            "blob_url": "https://github.com/vercel/next.js/blob/bcb94e32226dcfc78c17d9335612894f407b883f/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fppr-navigations.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/bcb94e32226dcfc78c17d9335612894f407b883f/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fppr-navigations.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fppr-navigations.ts?ref=bcb94e32226dcfc78c17d9335612894f407b883f",
            "patch": "@@ -92,6 +92,7 @@ export function startPPRNavigation(\n   prefetchData: CacheNodeSeedData | null,\n   prefetchHead: HeadData | null,\n   isPrefetchHeadPartial: boolean,\n+  isSamePageNavigation: boolean,\n   scrollableSegmentsResult: Array<FlightSegmentPath>\n ): Task | null {\n   const segmentPath: Array<FlightSegmentPath> = []\n@@ -103,6 +104,7 @@ export function startPPRNavigation(\n     prefetchData,\n     prefetchHead,\n     isPrefetchHeadPartial,\n+    isSamePageNavigation,\n     segmentPath,\n     scrollableSegmentsResult\n   )\n@@ -116,6 +118,7 @@ function updateCacheNodeOnNavigation(\n   prefetchData: CacheNodeSeedData | null,\n   prefetchHead: HeadData | null,\n   isPrefetchHeadPartial: boolean,\n+  isSamePageNavigation: boolean,\n   segmentPath: FlightSegmentPath,\n   scrollableSegmentsResult: Array<FlightSegmentPath>\n ): Task | null {\n@@ -234,6 +237,44 @@ function updateCacheNodeOnNavigation(\n           scrollableSegmentsResult\n         )\n       }\n+    } else if (\n+      isSamePageNavigation &&\n+      // Check if this is a page segment.\n+      // TODO: We're not consistent about how we do this check. Some places\n+      // check if the segment starts with PAGE_SEGMENT_KEY, but most seem to\n+      // check if there any any children, which is why I'm doing it here. We\n+      // should probably encode an empty children set as `null` though. Either\n+      // way, we should update all the checks to be consistent.\n+      Object.keys(newRouterStateChild[1]).length === 0\n+    ) {\n+      // We special case navigations to the exact same URL as the current\n+      // location. It's a common UI pattern for apps to refresh when you click a\n+      // link to the current page. So when this happens, we refresh the dynamic\n+      // data in the page segments.\n+      //\n+      // Note that this does not apply if the any part of the hash or search\n+      // query has changed. This might feel a bit weird but it makes more sense\n+      // when you consider that the way to trigger this behavior is to click\n+      // the same link multiple times.\n+      //\n+      // TODO: We should probably refresh the *entire* route when this case\n+      // occurs, not just the page segments. Essentially treating it the same as\n+      // a refresh() triggered by an action, which is the more explicit way of\n+      // modeling the UI pattern described above.\n+      //\n+      // Also note that this only refreshes the dynamic data, not static/\n+      // cached data. If the page segment is fully static and prefetched, the\n+      // request is skipped. (This is also how refresh() works.)\n+      taskChild = beginRenderingNewRouteTree(\n+        oldRouterStateChild,\n+        newRouterStateChild,\n+        didFindRootLayout,\n+        prefetchDataChild !== undefined ? prefetchDataChild : null,\n+        prefetchHead,\n+        isPrefetchHeadPartial,\n+        newSegmentPathChild,\n+        scrollableSegmentsResult\n+      )\n     } else if (\n       oldRouterStateChild !== undefined &&\n       oldSegmentChild !== undefined &&\n@@ -253,6 +294,7 @@ function updateCacheNodeOnNavigation(\n           prefetchDataChild,\n           prefetchHead,\n           isPrefetchHeadPartial,\n+          isSamePageNavigation,\n           newSegmentPathChild,\n           scrollableSegmentsResult\n         )"
        },
        {
            "sha": "b562e47ab780cbeddf4999f4be383458fd80e46f",
            "filename": "packages/next/src/client/components/router-reducer/reducers/navigate-reducer.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/bcb94e32226dcfc78c17d9335612894f407b883f/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fnavigate-reducer.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/bcb94e32226dcfc78c17d9335612894f407b883f/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fnavigate-reducer.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fnavigate-reducer.ts?ref=bcb94e32226dcfc78c17d9335612894f407b883f",
            "patch": "@@ -334,6 +334,7 @@ export function navigateReducer(\n               seedData,\n               head,\n               isHeadPartial,\n+              false,\n               scrollableSegments\n             )\n "
        },
        {
            "sha": "5ed4c4f0661558abb68bb644b98b4b5eae68851b",
            "filename": "packages/next/src/client/components/segment-cache-impl/navigation.ts",
            "status": "modified",
            "additions": 34,
            "deletions": 1,
            "changes": 35,
            "blob_url": "https://github.com/vercel/next.js/blob/bcb94e32226dcfc78c17d9335612894f407b883f/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fnavigation.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/bcb94e32226dcfc78c17d9335612894f407b883f/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fnavigation.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fnavigation.ts?ref=bcb94e32226dcfc78c17d9335612894f407b883f",
            "patch": "@@ -80,8 +80,35 @@ export function navigate(\n   shouldScroll: boolean\n ): NavigationResult {\n   const now = Date.now()\n+  const href = url.href\n \n-  const cacheKey = createCacheKey(url.href, nextUrl)\n+  // We special case navigations to the exact same URL as the current location.\n+  // It's a common UI pattern for apps to refresh when you click a link to the\n+  // current page. So when this happens, we refresh the dynamic data in the page\n+  // segments.\n+  //\n+  // Note that this does not apply if the any part of the hash or search query\n+  // has changed. This might feel a bit weird but it makes more sense when you\n+  // consider that the way to trigger this behavior is to click the same link\n+  // multiple times.\n+  //\n+  // TODO: We should probably refresh the *entire* route when this case occurs,\n+  // not just the page segments. Essentially treating it the same as a refresh()\n+  // triggered by an action, which is the more explicit way of modeling the UI\n+  // pattern described above.\n+  //\n+  // Also note that this only refreshes the dynamic data, not static/ cached\n+  // data. If the page segment is fully static and prefetched, the request is\n+  // skipped. (This is also how refresh() works.)\n+  const isSamePageNavigation =\n+    // TODO: This is not the only place we read from the location, but we should\n+    // consider storing the current URL in the router state instead of reading\n+    // from the location object. In practice I don't think this matters much\n+    // since we keep them in sync anyway, but having two sources of truth can\n+    // lead to subtle bugs and race conditions.\n+    href === window.location.href\n+\n+  const cacheKey = createCacheKey(href, nextUrl)\n   const route = readRouteCacheEntry(now, cacheKey)\n   if (route !== null && route.status === EntryStatus.Fulfilled) {\n     // We have a matching prefetch.\n@@ -94,6 +121,7 @@ export function navigate(\n     return navigateUsingPrefetchedRouteTree(\n       url,\n       nextUrl,\n+      isSamePageNavigation,\n       currentCacheNode,\n       currentFlightRouterState,\n       prefetchFlightRouterState,\n@@ -111,6 +139,7 @@ export function navigate(\n     data: navigateDynamicallyWithNoPrefetch(\n       url,\n       nextUrl,\n+      isSamePageNavigation,\n       currentCacheNode,\n       currentFlightRouterState,\n       shouldScroll,\n@@ -122,6 +151,7 @@ export function navigate(\n function navigateUsingPrefetchedRouteTree(\n   url: URL,\n   nextUrl: string | null,\n+  isSamePageNavigation: boolean,\n   currentCacheNode: CacheNode,\n   currentFlightRouterState: FlightRouterState,\n   prefetchFlightRouterState: FlightRouterState,\n@@ -146,6 +176,7 @@ function navigateUsingPrefetchedRouteTree(\n     prefetchSeedData,\n     prefetchHead,\n     isPrefetchHeadPartial,\n+    isSamePageNavigation,\n     scrollableSegments\n   )\n   if (task !== null) {\n@@ -283,6 +314,7 @@ function readRenderSnapshotFromCache(\n async function navigateDynamicallyWithNoPrefetch(\n   url: URL,\n   nextUrl: string | null,\n+  isSamePageNavigation: boolean,\n   currentCacheNode: CacheNode,\n   currentFlightRouterState: FlightRouterState,\n   shouldScroll: boolean,\n@@ -345,6 +377,7 @@ async function navigateDynamicallyWithNoPrefetch(\n     prefetchSeedData,\n     prefetchHead,\n     isPrefetchHeadPartial,\n+    isSamePageNavigation,\n     scrollableSegments\n   )\n   if (task !== null) {"
        },
        {
            "sha": "6fd4aee5825c1efd0c4459dcdf5920cabdd77de6",
            "filename": "test/e2e/app-dir/segment-cache/basic/app/same-page-nav/layout.tsx",
            "status": "added",
            "additions": 16,
            "deletions": 0,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/bcb94e32226dcfc78c17d9335612894f407b883f/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fbasic%2Fapp%2Fsame-page-nav%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/bcb94e32226dcfc78c17d9335612894f407b883f/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fbasic%2Fapp%2Fsame-page-nav%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fbasic%2Fapp%2Fsame-page-nav%2Flayout.tsx?ref=bcb94e32226dcfc78c17d9335612894f407b883f",
            "patch": "@@ -0,0 +1,16 @@\n+import { Suspense } from 'react'\n+import { connection } from 'next/server'\n+\n+async function Content({ children }: { children: React.ReactNode }) {\n+  // Treat the layout as dynamic so we can detect when it's refreshed\n+  await connection()\n+  return <div id=\"same-page-nav-layout\">{children}</div>\n+}\n+\n+export default function Layout({ children }: { children: React.ReactNode }) {\n+  return (\n+    <Suspense fallback=\"Loading...\">\n+      <Content>{children}</Content>\n+    </Suspense>\n+  )\n+}"
        },
        {
            "sha": "900ccae1f943275d81da174d0dc3364eb4c3ec50",
            "filename": "test/e2e/app-dir/segment-cache/basic/app/same-page-nav/page.tsx",
            "status": "added",
            "additions": 41,
            "deletions": 0,
            "changes": 41,
            "blob_url": "https://github.com/vercel/next.js/blob/bcb94e32226dcfc78c17d9335612894f407b883f/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fbasic%2Fapp%2Fsame-page-nav%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/bcb94e32226dcfc78c17d9335612894f407b883f/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fbasic%2Fapp%2Fsame-page-nav%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fbasic%2Fapp%2Fsame-page-nav%2Fpage.tsx?ref=bcb94e32226dcfc78c17d9335612894f407b883f",
            "patch": "@@ -0,0 +1,41 @@\n+import Link from 'next/link'\n+import { connection } from 'next/server'\n+\n+export default async function SamePageNav() {\n+  // Treat the page as dynamic so we can detect when it's refreshed\n+  await connection()\n+\n+  return (\n+    <>\n+      <p>\n+        Demonstrates that when navigating to the exact same URL as the current\n+        location, we refresh the page segments.\n+      </p>\n+      <p>\n+        Observe that the random number below changes if you click the same link\n+        multiple times, but not when you switch between links.\n+      </p>\n+      <p>\n+        Random number (changes on each refresh):{' '}\n+        <span id=\"random-number\">\n+          {Math.floor(Math.random() * 1_000_000_000)}\n+        </span>\n+      </p>\n+      <ul>\n+        <li>\n+          <Link href=\"/same-page-nav\">Link to current page</Link>\n+        </li>\n+        <li id=\"hash-b\">\n+          <Link href=\"/same-page-nav#hash-a\">\n+            Link to current page with hash fragment <code>#hash-a</code>\n+          </Link>\n+        </li>\n+        <li id=\"hash-a\">\n+          <Link href=\"/same-page-nav#hash-b\">\n+            Link to current page with hash fragment <code>#hash-b</code>\n+          </Link>\n+        </li>\n+      </ul>\n+    </>\n+  )\n+}"
        },
        {
            "sha": "4c42da72d8fdddf364b1306089fe27395dcfac1a",
            "filename": "test/e2e/app-dir/segment-cache/basic/components/link-accordion.tsx",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/bcb94e32226dcfc78c17d9335612894f407b883f/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fbasic%2Fcomponents%2Flink-accordion.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/bcb94e32226dcfc78c17d9335612894f407b883f/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fbasic%2Fcomponents%2Flink-accordion.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fbasic%2Fcomponents%2Flink-accordion.tsx?ref=bcb94e32226dcfc78c17d9335612894f407b883f",
            "patch": "@@ -16,7 +16,7 @@ export function LinkAccordion({ href, children }) {\n       {isVisible ? (\n         <Link href={href}>{children}</Link>\n       ) : (\n-        `${children} (link is hidden)`\n+        <>{children} (link is hidden)</>\n       )}\n     </>\n   )"
        },
        {
            "sha": "1315f28c7b3187cf544941cf644c25dc61e294ae",
            "filename": "test/e2e/app-dir/segment-cache/basic/segment-cache-basic.test.ts",
            "status": "modified",
            "additions": 66,
            "deletions": 0,
            "changes": 66,
            "blob_url": "https://github.com/vercel/next.js/blob/bcb94e32226dcfc78c17d9335612894f407b883f/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fbasic%2Fsegment-cache-basic.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/bcb94e32226dcfc78c17d9335612894f407b883f/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fbasic%2Fsegment-cache-basic.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fbasic%2Fsegment-cache-basic.test.ts?ref=bcb94e32226dcfc78c17d9335612894f407b883f",
            "patch": "@@ -241,4 +241,70 @@ describe('segment cache (basic tests)', () => {\n     const dynamicDiv = await browser.elementById('dynamic-page')\n     expect(await dynamicDiv.innerHTML()).toBe('Dynamic page')\n   })\n+\n+  it('refreshes page segments when navigating to the exact same URL as the current location', async () => {\n+    let act: ReturnType<typeof createRouterAct>\n+    const browser = await next.browser('/same-page-nav', {\n+      beforePageLoad(page: Playwright.Page) {\n+        act = createRouterAct(page)\n+      },\n+    })\n+\n+    const linkWithNoHash = await browser.elementByCss(\n+      'a[href=\"/same-page-nav\"]'\n+    )\n+    const linkWithHashA = await browser.elementByCss(\n+      'a[href=\"/same-page-nav#hash-a\"]'\n+    )\n+    const linkWithHashB = await browser.elementByCss(\n+      'a[href=\"/same-page-nav#hash-b\"]'\n+    )\n+\n+    async function readRandomNumberFromPage() {\n+      const randomNumber = await browser.elementById('random-number')\n+      return await randomNumber.textContent()\n+    }\n+\n+    // Navigating to the same URL should refresh the page\n+    const randomNumber = await readRandomNumberFromPage()\n+    await act(async () => {\n+      await linkWithNoHash.click()\n+    }, [\n+      {\n+        includes: 'random-number',\n+      },\n+      {\n+        // Only the page segments should be refreshed, not the layouts.\n+        // TODO: We plan to change this in the future.\n+        block: 'reject',\n+        includes: 'same-page-nav-layout',\n+      },\n+    ])\n+    const randomNumber2 = await readRandomNumberFromPage()\n+    expect(randomNumber2).not.toBe(randomNumber)\n+\n+    // Navigating to a different hash should *not* refresh the page\n+    await act(async () => {\n+      await linkWithHashA.click()\n+    }, 'no-requests')\n+    expect(await readRandomNumberFromPage()).toBe(randomNumber2)\n+\n+    // Navigating to the same hash again should refresh the page\n+    await act(\n+      async () => {\n+        await linkWithHashA.click()\n+      },\n+      {\n+        includes: 'random-number',\n+      }\n+    )\n+    const randomNumber3 = await readRandomNumberFromPage()\n+    expect(randomNumber3).not.toBe(randomNumber2)\n+\n+    // Navigating to a different hash should *not* refresh the page\n+    await act(async () => {\n+      await linkWithHashB.click()\n+    }, 'no-requests')\n+    expect(await readRandomNumberFromPage()).toBe(randomNumber3)\n+  })\n })"
        }
    ],
    "stats": {
        "total": 203,
        "additions": 201,
        "deletions": 2
    }
}