{
    "author": "mischnic",
    "message": "Turbopack: ChunkGroupType for graph entries (#76235)\n\nPass the `ChunkGroupType::{Entry, Evaluated}` to the graph. We will need this information for the `ChunkGroup`s",
    "sha": "8624a4c1687e9b7bf71c48f0ecab9ff6e468d157",
    "files": [
        {
            "sha": "14a2df95bf9887ad8d1256e5e2450b7d9c8aa497",
            "filename": "Cargo.lock",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/8624a4c1687e9b7bf71c48f0ecab9ff6e468d157/Cargo.lock",
            "raw_url": "https://github.com/vercel/next.js/raw/8624a4c1687e9b7bf71c48f0ecab9ff6e468d157/Cargo.lock",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/Cargo.lock?ref=8624a4c1687e9b7bf71c48f0ecab9ff6e468d157",
            "patch": "@@ -4418,6 +4418,7 @@ version = \"0.1.0\"\n dependencies = [\n  \"anyhow\",\n  \"auto-hash-map\",\n+ \"either\",\n  \"futures\",\n  \"indexmap 2.7.1\",\n  \"next-core\","
        },
        {
            "sha": "7091e19d508dee9251536fcaf864c956cc71f81c",
            "filename": "crates/next-api/Cargo.toml",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/8624a4c1687e9b7bf71c48f0ecab9ff6e468d157/crates%2Fnext-api%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/8624a4c1687e9b7bf71c48f0ecab9ff6e468d157/crates%2Fnext-api%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2FCargo.toml?ref=8624a4c1687e9b7bf71c48f0ecab9ff6e468d157",
            "patch": "@@ -15,6 +15,7 @@ workspace = true\n [dependencies]\n anyhow = { workspace = true, features = [\"backtrace\"] }\n auto-hash-map = { workspace = true }\n+either = { workspace = true }\n futures = { workspace = true }\n indexmap = { workspace = true }\n next-core = { workspace = true }"
        },
        {
            "sha": "93c29a62118ac4c03deb029ff7a80806b782c292",
            "filename": "crates/next-api/src/app.rs",
            "status": "modified",
            "additions": 32,
            "deletions": 21,
            "changes": 53,
            "blob_url": "https://github.com/vercel/next.js/blob/8624a4c1687e9b7bf71c48f0ecab9ff6e468d157/crates%2Fnext-api%2Fsrc%2Fapp.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/8624a4c1687e9b7bf71c48f0ecab9ff6e468d157/crates%2Fnext-api%2Fsrc%2Fapp.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fapp.rs?ref=8624a4c1687e9b7bf71c48f0ecab9ff6e468d157",
            "patch": "@@ -53,13 +53,13 @@ use turbopack::{\n use turbopack_core::{\n     asset::AssetContent,\n     chunk::{\n-        availability_info::AvailabilityInfo, ChunkableModules, ChunkingContext, ChunkingContextExt,\n-        EvaluatableAsset, EvaluatableAssets,\n+        availability_info::AvailabilityInfo, ChunkGroupType, ChunkableModules, ChunkingContext,\n+        ChunkingContextExt, EvaluatableAsset, EvaluatableAssets,\n     },\n     file_source::FileSource,\n     ident::AssetIdent,\n-    module::{Module, Modules},\n-    module_graph::{ModuleGraph, SingleModuleGraph, VisitedModules},\n+    module::Module,\n+    module_graph::{GraphEntries, ModuleGraph, SingleModuleGraph, VisitedModules},\n     output::{OutputAsset, OutputAssets},\n     raw_output::RawOutput,\n     reference_type::{CssReferenceSubType, ReferenceType},\n@@ -817,7 +817,7 @@ impl AppProject {\n         let extra_entries = extra_entries\n             .await?\n             .into_iter()\n-            .map(|m| *ResolvedVc::upcast(*m));\n+            .map(|m| ResolvedVc::upcast(*m));\n \n         if *self.project.per_page_module_graph().await? {\n             // Implements layout segment optimization to compute a graph \"chain\" for each layout\n@@ -831,19 +831,22 @@ impl AppProject {\n                     } = &*find_server_entries(*rsc_entry).await?;\n \n                     let graph = SingleModuleGraph::new_with_entries_visited(\n-                        server_utils\n-                            .iter()\n-                            .map(|m| Vc::upcast(**m))\n-                            .chain(extra_entries)\n-                            .collect(),\n+                        vec![(\n+                            server_utils\n+                                .iter()\n+                                .map(|m| ResolvedVc::upcast(*m))\n+                                .chain(extra_entries)\n+                                .collect(),\n+                            ChunkGroupType::Entry,\n+                        )],\n                         VisitedModules::empty(),\n                     );\n                     graphs.push(graph);\n                     let mut visited_modules = VisitedModules::from_graph(graph);\n \n                     for module in server_component_entries.iter() {\n                         let graph = SingleModuleGraph::new_with_entries_visited(\n-                            vec![Vc::upcast(**module)],\n+                            vec![(vec![ResolvedVc::upcast(*module)], ChunkGroupType::Entry)],\n                             visited_modules,\n                         );\n                         graphs.push(graph);\n@@ -864,22 +867,24 @@ impl AppProject {\n                     visited_modules\n                 } else {\n                     let graph = SingleModuleGraph::new_with_entries_visited(\n-                        extra_entries.collect::<_>(),\n+                        vec![(extra_entries.collect(), ChunkGroupType::Entry)],\n                         VisitedModules::empty(),\n                     );\n                     graphs.push(graph);\n                     VisitedModules::from_graph(graph)\n                 };\n \n-                let graph =\n-                    SingleModuleGraph::new_with_entries_visited(vec![*rsc_entry], visited_modules);\n+                let graph = SingleModuleGraph::new_with_entries_visited(\n+                    vec![(vec![ResolvedVc::upcast(rsc_entry)], ChunkGroupType::Entry)],\n+                    visited_modules,\n+                );\n                 graphs.push(graph);\n                 visited_modules = visited_modules.concatenate(graph);\n \n                 let base = ModuleGraph::from_graphs(graphs.clone());\n-                let additional_entries = endpoint.additional_root_modules(base);\n+                let additional_entries = endpoint.additional_entries(base);\n                 let additional_module_graph = SingleModuleGraph::new_with_entries_visited(\n-                    additional_entries.await?.into_iter().map(|m| **m).collect(),\n+                    additional_entries.owned().await?,\n                     visited_modules,\n                 );\n                 graphs.push(additional_module_graph);\n@@ -1877,15 +1882,18 @@ impl Endpoint for AppEndpoint {\n     }\n \n     #[turbo_tasks::function]\n-    async fn root_modules(self: Vc<Self>) -> Result<Vc<Modules>> {\n-        Ok(Vc::cell(vec![self.app_endpoint_entry().await?.rsc_entry]))\n+    async fn entries(self: Vc<Self>) -> Result<Vc<GraphEntries>> {\n+        Ok(Vc::cell(vec![(\n+            vec![self.app_endpoint_entry().await?.rsc_entry],\n+            ChunkGroupType::Entry,\n+        )]))\n     }\n \n     #[turbo_tasks::function]\n-    async fn additional_root_modules(\n+    async fn additional_entries(\n         self: Vc<Self>,\n         graph: Vc<ModuleGraph>,\n-    ) -> Result<Vc<Modules>> {\n+    ) -> Result<Vc<GraphEntries>> {\n         let this = self.await?;\n         let app_entry = self.app_endpoint_entry().await?;\n         let rsc_entry = app_entry.rsc_entry;\n@@ -1917,7 +1925,10 @@ impl Endpoint for AppEndpoint {\n             .await?,\n         );\n \n-        Ok(Vc::cell(vec![server_actions_loader]))\n+        Ok(Vc::cell(vec![(\n+            vec![server_actions_loader],\n+            ChunkGroupType::Entry,\n+        )]))\n     }\n }\n "
        },
        {
            "sha": "e1565520780f507bf45da71cd5744bfd9012460f",
            "filename": "crates/next-api/src/empty.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/8624a4c1687e9b7bf71c48f0ecab9ff6e468d157/crates%2Fnext-api%2Fsrc%2Fempty.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/8624a4c1687e9b7bf71c48f0ecab9ff6e468d157/crates%2Fnext-api%2Fsrc%2Fempty.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fempty.rs?ref=8624a4c1687e9b7bf71c48f0ecab9ff6e468d157",
            "patch": "@@ -1,6 +1,6 @@\n use anyhow::{bail, Result};\n use turbo_tasks::{Completion, Vc};\n-use turbopack_core::module::Modules;\n+use turbopack_core::module_graph::GraphEntries;\n \n use crate::route::{Endpoint, EndpointOutput};\n \n@@ -33,7 +33,7 @@ impl Endpoint for EmptyEndpoint {\n     }\n \n     #[turbo_tasks::function]\n-    fn root_modules(self: Vc<Self>) -> Vc<Modules> {\n-        Vc::cell(vec![])\n+    fn entries(self: Vc<Self>) -> Vc<GraphEntries> {\n+        GraphEntries::empty()\n     }\n }"
        },
        {
            "sha": "a7e29f98c6bc3ccc909583d0f376bf5a12c02cd7",
            "filename": "crates/next-api/src/instrumentation.rs",
            "status": "modified",
            "additions": 14,
            "deletions": 9,
            "changes": 23,
            "blob_url": "https://github.com/vercel/next.js/blob/8624a4c1687e9b7bf71c48f0ecab9ff6e468d157/crates%2Fnext-api%2Fsrc%2Finstrumentation.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/8624a4c1687e9b7bf71c48f0ecab9ff6e468d157/crates%2Fnext-api%2Fsrc%2Finstrumentation.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Finstrumentation.rs?ref=8624a4c1687e9b7bf71c48f0ecab9ff6e468d157",
            "patch": "@@ -12,11 +12,12 @@ use turbo_tasks_fs::{File, FileContent, FileSystemPath};\n use turbopack_core::{\n     asset::AssetContent,\n     chunk::{\n-        availability_info::AvailabilityInfo, ChunkingContext, ChunkingContextExt,\n+        availability_info::AvailabilityInfo, ChunkGroupType, ChunkingContext, ChunkingContextExt,\n         EntryChunkGroupResult,\n     },\n     context::AssetContext,\n-    module::{Module, Modules},\n+    module::Module,\n+    module_graph::GraphEntries,\n     output::{OutputAsset, OutputAssets},\n     reference_type::{EntryReferenceSubType, ReferenceType},\n     source::Source,\n@@ -109,7 +110,9 @@ impl InstrumentationEndpoint {\n \n         let module = self.core_modules().await?.edge_entry_module;\n \n-        let module_graph = this.project.module_graph(*module);\n+        let module_graph = this\n+            .project\n+            .module_graph(*module, ChunkGroupType::Evaluated);\n \n         let mut evaluatable_assets = get_server_runtime_entries(\n             Value::new(ServerContextType::Instrumentation {\n@@ -152,7 +155,9 @@ impl InstrumentationEndpoint {\n         let chunking_context = this.project.server_chunking_context(false);\n \n         let userland_module = self.core_modules().await?.userland_module;\n-        let module_graph = this.project.module_graph(*userland_module);\n+        let module_graph = this\n+            .project\n+            .module_graph(*userland_module, ChunkGroupType::Entry);\n \n         let Some(module) = ResolvedVc::try_downcast(userland_module) else {\n             bail!(\"Entry module must be evaluatable\");\n@@ -287,11 +292,11 @@ impl Endpoint for InstrumentationEndpoint {\n     }\n \n     #[turbo_tasks::function]\n-    async fn root_modules(self: Vc<Self>) -> Result<Vc<Modules>> {\n+    async fn entries(self: Vc<Self>) -> Result<Vc<GraphEntries>> {\n         let core_modules = self.core_modules().await?;\n-        Ok(Vc::cell(vec![\n-            core_modules.userland_module,\n-            core_modules.edge_entry_module,\n-        ]))\n+        Ok(Vc::cell(vec![(\n+            vec![core_modules.edge_entry_module],\n+            ChunkGroupType::Evaluated,\n+        )]))\n     }\n }"
        },
        {
            "sha": "bcb4fc80df96c36941686c2092d71f6cc0904143",
            "filename": "crates/next-api/src/middleware.rs",
            "status": "modified",
            "additions": 13,
            "deletions": 5,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/8624a4c1687e9b7bf71c48f0ecab9ff6e468d157/crates%2Fnext-api%2Fsrc%2Fmiddleware.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/8624a4c1687e9b7bf71c48f0ecab9ff6e468d157/crates%2Fnext-api%2Fsrc%2Fmiddleware.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fmiddleware.rs?ref=8624a4c1687e9b7bf71c48f0ecab9ff6e468d157",
            "patch": "@@ -15,9 +15,12 @@ use turbo_tasks::{Completion, ResolvedVc, Value, Vc};\n use turbo_tasks_fs::{self, File, FileContent, FileSystemPath};\n use turbopack_core::{\n     asset::AssetContent,\n-    chunk::{availability_info::AvailabilityInfo, ChunkingContextExt, EvaluatableAsset},\n+    chunk::{\n+        availability_info::AvailabilityInfo, ChunkGroupType, ChunkingContextExt, EvaluatableAsset,\n+    },\n     context::AssetContext,\n-    module::{Module, Modules},\n+    module::Module,\n+    module_graph::GraphEntries,\n     output::OutputAssets,\n     reference_type::{EntryReferenceSubType, ReferenceType},\n     source::Source,\n@@ -115,7 +118,9 @@ impl MiddlewareEndpoint {\n         evaluatable_assets.push(evaluatable.to_resolved().await?);\n \n         let evaluatable_assets = Vc::cell(evaluatable_assets);\n-        let module_graph = this.project.module_graph_for_entries(evaluatable_assets);\n+        let module_graph = this\n+            .project\n+            .module_graph_for_entries(evaluatable_assets, ChunkGroupType::Evaluated);\n \n         let edge_chunking_context = this.project.edge_chunking_context(false);\n \n@@ -325,7 +330,10 @@ impl Endpoint for MiddlewareEndpoint {\n     }\n \n     #[turbo_tasks::function]\n-    async fn root_modules(self: Vc<Self>) -> Result<Vc<Modules>> {\n-        Ok(Vc::cell(vec![self.entry_module().to_resolved().await?]))\n+    async fn entries(self: Vc<Self>) -> Result<Vc<GraphEntries>> {\n+        Ok(Vc::cell(vec![(\n+            vec![self.entry_module().to_resolved().await?],\n+            ChunkGroupType::Evaluated,\n+        )]))\n     }\n }"
        },
        {
            "sha": "596146cc27fadc1e70cdf676a804495816d0971d",
            "filename": "crates/next-api/src/module_graph.rs",
            "status": "modified",
            "additions": 10,
            "deletions": 9,
            "changes": 19,
            "blob_url": "https://github.com/vercel/next.js/blob/8624a4c1687e9b7bf71c48f0ecab9ff6e468d157/crates%2Fnext-api%2Fsrc%2Fmodule_graph.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/8624a4c1687e9b7bf71c48f0ecab9ff6e468d157/crates%2Fnext-api%2Fsrc%2Fmodule_graph.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fmodule_graph.rs?ref=8624a4c1687e9b7bf71c48f0ecab9ff6e468d157",
            "patch": "@@ -1,6 +1,7 @@\n use std::borrow::Cow;\n \n use anyhow::Result;\n+use either::Either;\n use next_core::{\n     next_client_reference::{\n         find_server_entries, ClientReference, ClientReferenceGraphResult, ClientReferenceType,\n@@ -101,14 +102,14 @@ impl NextDynamicGraph {\n                 InClientReference(ClientReferenceType),\n             }\n \n-            let entries: &[ResolvedVc<Box<dyn Module>>] = if !self.is_single_page {\n-                if !graph.entries.contains(&entry) {\n+            let entries = if !self.is_single_page {\n+                if !graph.entry_modules().any(|m| m == entry) {\n                     // the graph doesn't contain the entry, e.g. for the additional module graph\n                     return Ok(Vc::cell(vec![]));\n                 }\n-                &[entry]\n+                Either::Left(std::iter::once(entry))\n             } else {\n-                &graph.entries\n+                Either::Right(graph.entry_modules())\n             };\n \n             let mut result = vec![];\n@@ -207,7 +208,7 @@ impl ServerActionsGraph {\n                 // The graph contains the whole app, traverse and collect all reachable imports.\n                 let graph = &*self.graph.await?;\n \n-                if !graph.entries.contains(&entry) {\n+                if !graph.entry_modules().any(|m| m == entry) {\n                     // the graph doesn't contain the entry, e.g. for the additional module graph\n                     return Ok(Vc::cell(Default::default()));\n                 }\n@@ -292,14 +293,14 @@ impl ClientReferencesGraph {\n             let data = &*self.data.await?;\n             let graph = &*self.graph.await?;\n \n-            let entries: &[ResolvedVc<Box<dyn Module>>] = if !self.is_single_page {\n-                if !graph.entries.contains(&entry) {\n+            let entries = if !self.is_single_page {\n+                if !graph.entry_modules().any(|m| m == entry) {\n                     // the graph doesn't contain the entry, e.g. for the additional module graph\n                     return Ok(ClientReferenceGraphResult::default().cell());\n                 }\n-                &[entry]\n+                Either::Left(std::iter::once(entry))\n             } else {\n-                &graph.entries\n+                Either::Right(graph.entry_modules())\n             };\n \n             let mut client_references = FxIndexSet::default();"
        },
        {
            "sha": "1960209c98759a0f197539b124e5d806266dd43b",
            "filename": "crates/next-api/src/pages.rs",
            "status": "modified",
            "additions": 14,
            "deletions": 11,
            "changes": 25,
            "blob_url": "https://github.com/vercel/next.js/blob/8624a4c1687e9b7bf71c48f0ecab9ff6e468d157/crates%2Fnext-api%2Fsrc%2Fpages.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/8624a4c1687e9b7bf71c48f0ecab9ff6e468d157/crates%2Fnext-api%2Fsrc%2Fpages.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fpages.rs?ref=8624a4c1687e9b7bf71c48f0ecab9ff6e468d157",
            "patch": "@@ -45,14 +45,14 @@ use turbopack::{\n use turbopack_core::{\n     asset::AssetContent,\n     chunk::{\n-        availability_info::AvailabilityInfo, ChunkGroupResult, ChunkingContext, ChunkingContextExt,\n-        EntryChunkGroupResult, EvaluatableAsset, EvaluatableAssets,\n+        availability_info::AvailabilityInfo, ChunkGroupResult, ChunkGroupType, ChunkingContext,\n+        ChunkingContextExt, EntryChunkGroupResult, EvaluatableAsset, EvaluatableAssets,\n     },\n     context::AssetContext,\n     file_source::FileSource,\n     ident::AssetIdent,\n-    module::{Module, Modules},\n-    module_graph::ModuleGraph,\n+    module::Module,\n+    module_graph::{GraphEntries, ModuleGraph},\n     output::{OptionOutputAsset, OutputAsset, OutputAssets},\n     reference_type::{EcmaScriptModulesReferenceSubType, EntryReferenceSubType, ReferenceType},\n     resolve::{origin::PlainResolveOrigin, parse::Request, pattern::Pattern},\n@@ -769,7 +769,7 @@ impl PageEndpoint {\n         let this = self.await?;\n         let project = this.pages_project.project();\n         let evaluatable_assets = self.client_evaluatable_assets();\n-        Ok(project.module_graph_for_entries(evaluatable_assets))\n+        Ok(project.module_graph_for_entries(evaluatable_assets, ChunkGroupType::Evaluated))\n     }\n \n     #[turbo_tasks::function]\n@@ -780,9 +780,9 @@ impl PageEndpoint {\n             let project = this.pages_project.project();\n             let client_chunking_context = project.client_chunking_context();\n \n-            let evaluatable_assets = self.client_evaluatable_assets();\n-            let module_graph = project.module_graph_for_entries(evaluatable_assets);\n+            let module_graph = self.client_module_graph();\n \n+            let evaluatable_assets = self.client_evaluatable_assets();\n             let client_chunk_group = client_chunking_context.evaluated_chunk_group(\n                 AssetIdent::from_path(*this.page.await?.base_path),\n                 evaluatable_assets,\n@@ -906,7 +906,7 @@ impl PageEndpoint {\n             } = *self.internal_ssr_chunk_module().await?;\n \n             let project = this.pages_project.project();\n-            let module_graph = project.module_graph(*ssr_module);\n+            let module_graph = project.module_graph(*ssr_module, ChunkGroupType::Entry);\n \n             let next_dynamic_imports = if let PageEndpointType::Html = this.ty {\n                 // The SSR and Client Graphs are not connected in Pages Router.\n@@ -1466,15 +1466,18 @@ impl Endpoint for PageEndpoint {\n     }\n \n     #[turbo_tasks::function]\n-    async fn root_modules(self: Vc<Self>) -> Result<Vc<Modules>> {\n+    async fn entries(self: Vc<Self>) -> Result<Vc<GraphEntries>> {\n         let this = self.await?;\n         let mut modules = vec![];\n \n         let ssr_chunk_module = self.internal_ssr_chunk_module().await?;\n-        modules.push(ssr_chunk_module.ssr_module);\n+        modules.push((vec![ssr_chunk_module.ssr_module], ChunkGroupType::Entry));\n \n         if let PageEndpointType::Html = this.ty {\n-            modules.push(self.client_module().to_resolved().await?);\n+            modules.push((\n+                vec![self.client_module().to_resolved().await?],\n+                ChunkGroupType::Evaluated,\n+            ));\n         }\n \n         Ok(Vc::cell(modules))"
        },
        {
            "sha": "94d0e23bef200bb26f3b98ea0a69638f3d254209",
            "filename": "crates/next-api/src/project.rs",
            "status": "modified",
            "additions": 32,
            "deletions": 33,
            "changes": 65,
            "blob_url": "https://github.com/vercel/next.js/blob/8624a4c1687e9b7bf71c48f0ecab9ff6e468d157/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/8624a4c1687e9b7bf71c48f0ecab9ff6e468d157/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fproject.rs?ref=8624a4c1687e9b7bf71c48f0ecab9ff6e468d157",
            "patch": "@@ -42,7 +42,7 @@ use turbopack_core::{\n     changed::content_changed,\n     chunk::{\n         module_id_strategies::{DevModuleIdStrategy, ModuleIdStrategy},\n-        ChunkingContext, EvaluatableAssets, SourceMapsType,\n+        ChunkGroupType, ChunkingContext, EvaluatableAssets, SourceMapsType,\n     },\n     compile_time_info::CompileTimeInfo,\n     context::AssetContext,\n@@ -52,8 +52,8 @@ use turbopack_core::{\n         Issue, IssueDescriptionExt, IssueExt, IssueSeverity, IssueStage, OptionStyledString,\n         StyledString,\n     },\n-    module::{Module, Modules},\n-    module_graph::{ModuleGraph, SingleModuleGraph, VisitedModules},\n+    module::Module,\n+    module_graph::{GraphEntries, ModuleGraph, SingleModuleGraph, VisitedModules},\n     output::{OutputAsset, OutputAssets},\n     resolve::{find_context_file, FindContextFileResult},\n     source_map::OptionStringifiedSourceMap,\n@@ -846,47 +846,41 @@ impl Project {\n     }\n \n     #[turbo_tasks::function]\n-    pub async fn get_all_entries(self: Vc<Self>) -> Result<Vc<Modules>> {\n-        let mut modules: Vec<ResolvedVc<Box<dyn Module>>> = self\n+    pub async fn get_all_entries(self: Vc<Self>) -> Result<Vc<GraphEntries>> {\n+        let mut modules = self\n             .get_all_endpoints()\n             .await?\n             .iter()\n-            .map(|endpoint| endpoint.root_modules())\n+            .map(async |endpoint| Ok(endpoint.entries().owned().await?))\n             .try_flat_join()\n-            .await?\n-            .into_iter()\n-            .copied()\n-            .collect();\n-        modules.extend(self.client_main_modules().await?.iter().copied());\n+            .await?;\n+        modules.extend(self.client_main_modules().await?.iter().cloned());\n         Ok(Vc::cell(modules))\n     }\n \n     #[turbo_tasks::function]\n     pub async fn get_all_additional_entries(\n         self: Vc<Self>,\n         graphs: Vc<ModuleGraph>,\n-    ) -> Result<Vc<Modules>> {\n-        let mut modules: Vec<ResolvedVc<Box<dyn Module>>> = self\n+    ) -> Result<Vc<GraphEntries>> {\n+        let modules = self\n             .get_all_endpoints()\n             .await?\n             .iter()\n-            .map(|endpoint| endpoint.additional_root_modules(graphs))\n+            .map(async |endpoint| Ok(endpoint.additional_entries(graphs).owned().await?))\n             .try_flat_join()\n-            .await?\n-            .into_iter()\n-            .copied()\n-            .collect();\n-        modules.extend(self.client_main_modules().await?.iter().copied());\n+            .await?;\n         Ok(Vc::cell(modules))\n     }\n \n     #[turbo_tasks::function]\n     pub async fn module_graph(\n         self: Vc<Self>,\n         entry: ResolvedVc<Box<dyn Module>>,\n+        chunk_group_type: ChunkGroupType,\n     ) -> Result<Vc<ModuleGraph>> {\n         Ok(if *self.per_page_module_graph().await? {\n-            ModuleGraph::from_module(*entry)\n+            ModuleGraph::from_module(*entry, chunk_group_type)\n         } else {\n             *self.whole_app_module_graphs().await?.full\n         })\n@@ -896,17 +890,16 @@ impl Project {\n     pub async fn module_graph_for_entries(\n         self: Vc<Self>,\n         evaluatable_assets: Vc<EvaluatableAssets>,\n+        chunk_group_type: ChunkGroupType,\n     ) -> Result<Vc<ModuleGraph>> {\n         Ok(if *self.per_page_module_graph().await? {\n-            let entries = Vc::cell(\n-                evaluatable_assets\n-                    .await?\n-                    .iter()\n-                    .copied()\n-                    .map(ResolvedVc::upcast)\n-                    .collect(),\n-            );\n-            ModuleGraph::from_modules(entries)\n+            let entries = evaluatable_assets\n+                .await?\n+                .iter()\n+                .copied()\n+                .map(ResolvedVc::upcast)\n+                .collect();\n+            ModuleGraph::from_modules(Vc::cell(vec![(entries, chunk_group_type)]))\n         } else {\n             *self.whole_app_module_graphs().await?.full\n         })\n@@ -1597,12 +1590,18 @@ impl Project {\n     }\n \n     #[turbo_tasks::function]\n-    pub async fn client_main_modules(self: Vc<Self>) -> Result<Vc<Modules>> {\n+    pub async fn client_main_modules(self: Vc<Self>) -> Result<Vc<GraphEntries>> {\n         let pages_project = self.pages_project();\n-        let mut modules = vec![pages_project.client_main_module().to_resolved().await?];\n+        let mut modules = vec![(\n+            vec![pages_project.client_main_module().to_resolved().await?],\n+            ChunkGroupType::Evaluated,\n+        )];\n \n         if let Some(app_project) = *self.app_project().await? {\n-            modules.push(app_project.client_main_module().to_resolved().await?);\n+            modules.push((\n+                vec![app_project.client_main_module().to_resolved().await?],\n+                ChunkGroupType::Evaluated,\n+            ));\n         }\n \n         Ok(Vc::cell(modules))\n@@ -1648,7 +1647,7 @@ async fn whole_app_module_graph_operation(\n     let additional_entries = project.get_all_additional_entries(base);\n \n     let additional_module_graph = SingleModuleGraph::new_with_entries_visited(\n-        additional_entries.await?.into_iter().map(|m| **m).collect(),\n+        additional_entries.owned().await?,\n         base_visited_modules,\n     );\n "
        },
        {
            "sha": "987e36a511ad7d50bcd031362a505d9825a0475c",
            "filename": "crates/next-api/src/route.rs",
            "status": "modified",
            "additions": 7,
            "deletions": 4,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/8624a4c1687e9b7bf71c48f0ecab9ff6e468d157/crates%2Fnext-api%2Fsrc%2Froute.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/8624a4c1687e9b7bf71c48f0ecab9ff6e468d157/crates%2Fnext-api%2Fsrc%2Froute.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Froute.rs?ref=8624a4c1687e9b7bf71c48f0ecab9ff6e468d157",
            "patch": "@@ -5,7 +5,10 @@ use turbo_tasks::{\n     debug::ValueDebugFormat, trace::TraceRawVcs, Completion, FxIndexMap, NonLocalValue,\n     OperationVc, ResolvedVc, Vc,\n };\n-use turbopack_core::{module::Modules, module_graph::ModuleGraph, output::OutputAssets};\n+use turbopack_core::{\n+    module_graph::{GraphEntries, ModuleGraph},\n+    output::OutputAssets,\n+};\n \n use crate::{paths::ServerPath, project::Project};\n \n@@ -51,11 +54,11 @@ pub trait Endpoint {\n     fn server_changed(self: Vc<Self>) -> Vc<Completion>;\n     fn client_changed(self: Vc<Self>) -> Vc<Completion>;\n     /// The entry modules for the modules graph.\n-    fn root_modules(self: Vc<Self>) -> Vc<Modules>;\n+    fn entries(self: Vc<Self>) -> Vc<GraphEntries>;\n     /// Additional entry modules for the module graph.\n     /// This may read the module graph and return additional modules.\n-    fn additional_root_modules(self: Vc<Self>, _graph: Vc<ModuleGraph>) -> Vc<Modules> {\n-        Modules::empty()\n+    fn additional_entries(self: Vc<Self>, _graph: Vc<ModuleGraph>) -> Vc<GraphEntries> {\n+        GraphEntries::empty()\n     }\n }\n "
        },
        {
            "sha": "f845aa27e8e1f941c8e091cef0312356f6853b35",
            "filename": "turbopack/crates/turbopack-cli/src/build/mod.rs",
            "status": "modified",
            "additions": 9,
            "deletions": 3,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/8624a4c1687e9b7bf71c48f0ecab9ff6e468d157/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fbuild%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/8624a4c1687e9b7bf71c48f0ecab9ff6e468d157/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fbuild%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fbuild%2Fmod.rs?ref=8624a4c1687e9b7bf71c48f0ecab9ff6e468d157",
            "patch": "@@ -22,8 +22,8 @@ use turbopack_cli_utils::issue::{ConsoleUi, LogOptions};\n use turbopack_core::{\n     asset::Asset,\n     chunk::{\n-        availability_info::AvailabilityInfo, ChunkingConfig, ChunkingContext, EvaluatableAsset,\n-        EvaluatableAssets, MinifyType, SourceMapsType,\n+        availability_info::AvailabilityInfo, ChunkGroupType, ChunkingConfig, ChunkingContext,\n+        EvaluatableAsset, EvaluatableAssets, MinifyType, SourceMapsType,\n     },\n     environment::{BrowserEnvironment, Environment, ExecutionEnvironment, NodeJsEnvironment},\n     ident::AssetIdent,\n@@ -288,7 +288,13 @@ async fn build_internal(\n         .try_join()\n         .await?;\n \n-    let module_graph = ModuleGraph::from_modules(Vc::cell(entries.clone()));\n+    let module_graph = ModuleGraph::from_modules(Vc::cell(vec![(\n+        entries.clone(),\n+        match target {\n+            Target::Browser => ChunkGroupType::Evaluated,\n+            Target::Node => ChunkGroupType::Entry,\n+        },\n+    )]));\n     let module_id_strategy = ResolvedVc::upcast(\n         get_global_module_id_strategy(module_graph)\n             .to_resolved()"
        },
        {
            "sha": "991c09fb6b1df26beeff70ac3f957ce53c222580",
            "filename": "turbopack/crates/turbopack-cli/src/dev/web_entry_source.rs",
            "status": "modified",
            "additions": 15,
            "deletions": 14,
            "changes": 29,
            "blob_url": "https://github.com/vercel/next.js/blob/8624a4c1687e9b7bf71c48f0ecab9ff6e468d157/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fdev%2Fweb_entry_source.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/8624a4c1687e9b7bf71c48f0ecab9ff6e468d157/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fdev%2Fweb_entry_source.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fdev%2Fweb_entry_source.rs?ref=8624a4c1687e9b7bf71c48f0ecab9ff6e468d157",
            "patch": "@@ -6,7 +6,7 @@ use turbo_tasks_fs::FileSystemPath;\n use turbopack_browser::{react_refresh::assert_can_resolve_react_refresh, BrowserChunkingContext};\n use turbopack_cli_utils::runtime_entry::{RuntimeEntries, RuntimeEntry};\n use turbopack_core::{\n-    chunk::{ChunkableModule, ChunkingContext, EvaluatableAsset, SourceMapsType},\n+    chunk::{ChunkGroupType, ChunkableModule, ChunkingContext, EvaluatableAsset, SourceMapsType},\n     environment::Environment,\n     file_source::FileSource,\n     module::Module,\n@@ -145,19 +145,20 @@ pub async fn create_web_entry_source(\n         .try_flat_join()\n         .await?;\n \n-    let all_modules = Vc::cell(\n-        entries\n-            .iter()\n-            .copied()\n-            .chain(\n-                runtime_entries\n-                    .await?\n-                    .iter()\n-                    .map(|&entry| ResolvedVc::upcast(entry)),\n-            )\n-            .collect::<Vec<ResolvedVc<Box<dyn Module>>>>(),\n-    );\n-    let module_graph = ModuleGraph::from_modules(all_modules).to_resolved().await?;\n+    let all_modules = entries\n+        .iter()\n+        .copied()\n+        .chain(\n+            runtime_entries\n+                .await?\n+                .iter()\n+                .map(|&entry| ResolvedVc::upcast(entry)),\n+        )\n+        .collect::<Vec<ResolvedVc<Box<dyn Module>>>>();\n+    let module_graph =\n+        ModuleGraph::from_modules(Vc::cell(vec![(all_modules, ChunkGroupType::Evaluated)]))\n+            .to_resolved()\n+            .await?;\n \n     let entries: Vec<_> = entries\n         .into_iter()"
        },
        {
            "sha": "c6e31a7183542682b516e9a90b813db90496014d",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/async_module_info.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/8624a4c1687e9b7bf71c48f0ecab9ff6e468d157/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fasync_module_info.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/8624a4c1687e9b7bf71c48f0ecab9ff6e468d157/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fasync_module_info.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fasync_module_info.rs?ref=8624a4c1687e9b7bf71c48f0ecab9ff6e468d157",
            "patch": "@@ -75,7 +75,7 @@ async fn compute_async_module_info_single(\n \n     let mut async_modules = self_async_modules;\n     graph.traverse_edges_from_entries_topological(\n-        graph.entries.iter(),\n+        graph.entry_modules(),\n         &mut (),\n         |_, _, _| Ok(GraphTraversalAction::Continue),\n         |parent_info, module, _| {"
        },
        {
            "sha": "e250e2e343f4319c8e6e07b9f46bca462d14542b",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/chunk_group_info.rs",
            "status": "modified",
            "additions": 49,
            "deletions": 26,
            "changes": 75,
            "blob_url": "https://github.com/vercel/next.js/blob/8624a4c1687e9b7bf71c48f0ecab9ff6e468d157/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fchunk_group_info.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/8624a4c1687e9b7bf71c48f0ecab9ff6e468d157/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fchunk_group_info.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fchunk_group_info.rs?ref=8624a4c1687e9b7bf71c48f0ecab9ff6e468d157",
            "patch": "@@ -19,7 +19,7 @@ use turbo_tasks::{\n };\n \n use crate::{\n-    chunk::ChunkingType,\n+    chunk::{ChunkGroupType, ChunkingType},\n     module::Module,\n     module_graph::{\n         get_node, GraphNodeIndex, GraphTraversalAction, ModuleGraph, SingleModuleGraphModuleNode,\n@@ -91,12 +91,14 @@ pub struct ChunkGroupInfo {\n     pub chunk_groups: Vec<ChunkGroup>,\n }\n \n-#[derive(\n-    Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, ValueDebugFormat, NonLocalValue,\n-)]\n+#[turbo_tasks::value(shared)]\n+#[derive(Debug, Clone, Hash)]\n pub enum ChunkGroup {\n     /// e.g. a page\n-    Entry(ResolvedVc<Box<dyn Module>>),\n+    Entry {\n+        entries: Vec<ResolvedVc<Box<dyn Module>>>,\n+        ty: ChunkGroupType,\n+    },\n     /// a module with an incoming async edge\n     Async(ResolvedVc<Box<dyn Module>>),\n     /// a module with an incoming non-merged isolated edge\n@@ -120,11 +122,11 @@ pub enum ChunkGroup {\n impl ChunkGroup {\n     pub fn entries(&self) -> impl Iterator<Item = ResolvedVc<Box<dyn Module>>> + '_ {\n         match self {\n-            ChunkGroup::Entry(e)\n-            | ChunkGroup::Async(e)\n-            | ChunkGroup::Isolated(e)\n-            | ChunkGroup::Shared(e) => Either::Left(std::iter::once(*e)),\n-            ChunkGroup::IsolatedMerged { entries, .. }\n+            ChunkGroup::Async(e) | ChunkGroup::Isolated(e) | ChunkGroup::Shared(e) => {\n+                Either::Left(std::iter::once(*e))\n+            }\n+            ChunkGroup::Entry { entries, .. }\n+            | ChunkGroup::IsolatedMerged { entries, .. }\n             | ChunkGroup::SharedMerged { entries, .. } => Either::Right(entries.iter().copied()),\n         }\n     }\n@@ -133,7 +135,10 @@ impl ChunkGroup {\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n enum ChunkGroupKey {\n     /// e.g. a page\n-    Entry(ResolvedVc<Box<dyn Module>>),\n+    Entry {\n+        entries: Vec<ResolvedVc<Box<dyn Module>>>,\n+        ty: ChunkGroupType,\n+    },\n     /// a module with an incoming async edge\n     Async(ResolvedVc<Box<dyn Module>>),\n     /// a module with an incoming non-merged isolated edge\n@@ -225,26 +230,44 @@ pub async fn compute_chunk_group_info(graph: &ModuleGraph) -> Result<Vc<ChunkGro\n         // use all entries from all graphs\n         let entries = graphs\n             .iter()\n-            .flat_map(|g| g.entries.iter().copied())\n+            .flat_map(|g| g.entries.iter())\n             .collect::<Vec<_>>();\n-        let entries = &entries;\n         graph\n-            .traverse_edges_from_entries_bfs(entries, |parent, node| {\n-                if let Some((parent, _)) = parent {\n-                    let parent_depth = *module_depth.get(&parent.module).unwrap();\n-                    module_depth.entry(node.module).or_insert(parent_depth + 1);\n-                } else {\n-                    module_depth.insert(node.module, 0);\n-                };\n+            .traverse_edges_from_entries_bfs(\n+                entries.iter().flat_map(|(e, _)| e).copied(),\n+                |parent, node| {\n+                    if let Some((parent, _)) = parent {\n+                        let parent_depth = *module_depth.get(&parent.module).unwrap();\n+                        module_depth.entry(node.module).or_insert(parent_depth + 1);\n+                    } else {\n+                        module_depth.insert(node.module, 0);\n+                    };\n \n-                module_chunk_groups.insert(node.module, RoaringBitmapWrapper::default());\n+                    module_chunk_groups.insert(node.module, RoaringBitmapWrapper::default());\n \n-                GraphTraversalAction::Continue\n-            })\n+                    GraphTraversalAction::Continue\n+                },\n+            )\n             .await?;\n \n         // ----\n \n+        let entry_chunk_group_keys = graphs\n+            .iter()\n+            .flat_map(|g| g.entries.iter())\n+            .flat_map(|(entries, ty)| {\n+                entries.iter().map(|e| {\n+                    (\n+                        *e,\n+                        ChunkGroupKey::Entry {\n+                            entries: entries.clone(),\n+                            ty: *ty,\n+                        },\n+                    )\n+                })\n+            })\n+            .collect::<FxHashMap<_, _>>();\n+\n         let mut visitor =\n             |parent_info: Option<(&'_ SingleModuleGraphModuleNode, &'_ ChunkingType)>,\n              node: &'_ SingleModuleGraphModuleNode,\n@@ -310,7 +333,7 @@ pub async fn compute_chunk_group_info(graph: &ModuleGraph) -> Result<Vc<ChunkGro\n                     }\n                 } else {\n                     ChunkGroupInheritance::ChunkGroup(Either::Left(std::iter::once(\n-                        ChunkGroupKey::Entry(node.module),\n+                        entry_chunk_group_keys.get(&node.module).unwrap().clone(),\n                     )))\n                 };\n \n@@ -393,7 +416,7 @@ pub async fn compute_chunk_group_info(graph: &ModuleGraph) -> Result<Vc<ChunkGro\n         {\n             let mut queue_set = FxHashSet::default();\n             let mut queue = BinaryHeap::with_capacity(entries.len());\n-            for e in entries {\n+            for e in entries.iter().flat_map(|(e, _)| e) {\n                 queue.push(NodeWithPriority {\n                     depth: *module_depth.get(e).unwrap(),\n                     chunk_group_len: 0,\n@@ -450,7 +473,7 @@ pub async fn compute_chunk_group_info(graph: &ModuleGraph) -> Result<Vc<ChunkGro\n             chunk_groups: chunk_groups_map\n                 .into_iter()\n                 .map(|(k, (_, isolated_merged_entries))| match k {\n-                    ChunkGroupKey::Entry(module) => ChunkGroup::Entry(module),\n+                    ChunkGroupKey::Entry { entries, ty } => ChunkGroup::Entry { entries, ty },\n                     ChunkGroupKey::Async(module) => ChunkGroup::Async(module),\n                     ChunkGroupKey::Isolated(module) => ChunkGroup::Isolated(module),\n                     ChunkGroupKey::IsolatedMerged { parent, merge_tag } => {"
        },
        {
            "sha": "823245198d75488eac9e8b6ebc6d7120f4281468",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/mod.rs",
            "status": "modified",
            "additions": 46,
            "deletions": 21,
            "changes": 67,
            "blob_url": "https://github.com/vercel/next.js/blob/8624a4c1687e9b7bf71c48f0ecab9ff6e468d157/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/8624a4c1687e9b7bf71c48f0ecab9ff6e468d157/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs?ref=8624a4c1687e9b7bf71c48f0ecab9ff6e468d157",
            "patch": "@@ -20,9 +20,9 @@ use turbo_tasks::{\n };\n \n use crate::{\n-    chunk::{AsyncModuleInfo, ChunkingType},\n+    chunk::{AsyncModuleInfo, ChunkGroupType, ChunkingType},\n     issue::Issue,\n-    module::{Module, Modules},\n+    module::Module,\n     module_graph::{\n         async_module_info::{compute_async_module_info, AsyncModulesInfo},\n         chunk_group_info::{compute_chunk_group_info, ChunkGroupInfo},\n@@ -139,6 +139,18 @@ impl VisitedModules {\n     }\n }\n \n+pub type GraphEntriesT = Vec<(Vec<ResolvedVc<Box<dyn Module>>>, ChunkGroupType)>;\n+\n+#[turbo_tasks::value(transparent)]\n+pub struct GraphEntries(GraphEntriesT);\n+#[turbo_tasks::value_impl]\n+impl GraphEntries {\n+    #[turbo_tasks::function]\n+    pub fn empty() -> Vc<Self> {\n+        Vc::cell(Vec::new())\n+    }\n+}\n+\n #[turbo_tasks::value(cell = \"new\", eq = \"manual\", into = \"new\")]\n #[derive(Clone, Default)]\n pub struct SingleModuleGraph {\n@@ -157,22 +169,23 @@ pub struct SingleModuleGraph {\n     modules: FxHashMap<ResolvedVc<Box<dyn Module>>, NodeIndex>,\n \n     #[turbo_tasks(trace_ignore)]\n-    pub entries: Vec<ResolvedVc<Box<dyn Module>>>,\n+    pub entries: GraphEntriesT,\n }\n \n impl SingleModuleGraph {\n     /// Walks the graph starting from the given entries and collects all reachable nodes, skipping\n     /// nodes listed in `visited_modules`\n     /// The resulting graph's outgoing edges are in reverse order.\n     async fn new_inner(\n-        entries: &Vec<ResolvedVc<Box<dyn Module>>>,\n+        entries: &GraphEntriesT,\n         visited_modules: &FxIndexMap<ResolvedVc<Box<dyn Module>>, GraphNodeIndex>,\n     ) -> Result<Vc<Self>> {\n         let root_edges = entries\n             .iter()\n+            .flat_map(|(e, _)| e.clone())\n             .map(|e| async move {\n                 Ok(SingleModuleGraphBuilderEdge {\n-                    to: SingleModuleGraphBuilderNode::new_module(*e).await?,\n+                    to: SingleModuleGraphBuilderNode::new_module(e).await?,\n                 })\n             })\n             .try_join()\n@@ -328,6 +341,11 @@ impl SingleModuleGraph {\n         })\n     }\n \n+    /// Iterate over all nodes in the graph\n+    pub fn entry_modules(&self) -> impl Iterator<Item = ResolvedVc<Box<dyn Module>>> + '_ {\n+        self.entries.iter().flat_map(|(e, _)| e).copied()\n+    }\n+\n     /// Enumerate all nodes in the graph\n     pub fn enumerate_nodes(\n         &self,\n@@ -366,14 +384,14 @@ impl SingleModuleGraph {\n     ///    - Can return [GraphTraversalAction]s to control the traversal\n     pub fn traverse_edges_from_entries<'a>(\n         &'a self,\n-        entries: impl IntoIterator<Item = &'a ResolvedVc<Box<dyn Module>>>,\n+        entries: impl IntoIterator<Item = ResolvedVc<Box<dyn Module>>>,\n         mut visitor: impl FnMut(\n             Option<(&'a SingleModuleGraphModuleNode, &'a ChunkingType)>,\n             &'a SingleModuleGraphModuleNode,\n         ) -> GraphTraversalAction,\n     ) -> Result<()> {\n         let graph = &self.graph;\n-        let entries = entries.into_iter().map(|e| self.get_module(*e).unwrap());\n+        let entries = entries.into_iter().map(|e| self.get_module(e).unwrap());\n \n         let mut stack = entries.collect::<Vec<_>>();\n         let mut discovered = graph.visit_map();\n@@ -437,6 +455,7 @@ impl SingleModuleGraph {\n         let mut stack: Vec<NodeIndex> = self\n             .entries\n             .iter()\n+            .flat_map(|(e, _)| e)\n             .map(|e| *self.modules.get(e).unwrap())\n             .collect();\n         let mut discovered = graph.visit_map();\n@@ -493,7 +512,7 @@ impl SingleModuleGraph {\n     ///    - Can return [GraphTraversalAction]s to control the traversal\n     pub fn traverse_edges_from_entries_topological<'a, S>(\n         &'a self,\n-        entries: impl IntoIterator<Item = &'a ResolvedVc<Box<dyn Module>>>,\n+        entries: impl IntoIterator<Item = ResolvedVc<Box<dyn Module>>>,\n         state: &mut S,\n         mut visit_preorder: impl FnMut(\n             Option<(&'a SingleModuleGraphModuleNode, &'a ChunkingType)>,\n@@ -507,7 +526,7 @@ impl SingleModuleGraph {\n         ),\n     ) -> Result<()> {\n         let graph = &self.graph;\n-        let entries = entries.into_iter().map(|e| self.get_module(*e).unwrap());\n+        let entries = entries.into_iter().map(|e| self.get_module(e).unwrap());\n \n         enum ReverseTopologicalPass {\n             Visit,\n@@ -595,12 +614,15 @@ impl ModuleGraph {\n     }\n \n     #[turbo_tasks::function]\n-    pub fn from_module(module: ResolvedVc<Box<dyn Module>>) -> Vc<Self> {\n-        Self::from_single_graph(SingleModuleGraph::new_with_entries(Vc::cell(vec![module])))\n+    pub fn from_module(module: ResolvedVc<Box<dyn Module>>, ty: ChunkGroupType) -> Vc<Self> {\n+        Self::from_single_graph(SingleModuleGraph::new_with_entries(Vc::cell(vec![(\n+            vec![module],\n+            ty,\n+        )])))\n     }\n \n     #[turbo_tasks::function]\n-    pub fn from_modules(modules: Vc<Modules>) -> Vc<Self> {\n+    pub fn from_modules(modules: Vc<GraphEntries>) -> Vc<Self> {\n         Self::from_single_graph(SingleModuleGraph::new_with_entries(modules))\n     }\n \n@@ -714,6 +736,7 @@ impl ModuleGraph {\n                 graphs\n                     .iter()\n                     .flat_map(|g| g.entries.iter())\n+                    .flat_map(|(e, _)| e)\n                     .map(|e| e.ident().to_string())\n                     .try_join()\n                     .await?\n@@ -738,21 +761,23 @@ impl ModuleGraph {\n     ///    - Receives (originating &SingleModuleGraphNode, edge &ChunkingType), target\n     ///      &SingleModuleGraphNode, state &S\n     ///    - Can return [GraphTraversalAction]s to control the traversal\n-    pub async fn traverse_edges_from_entries_bfs<'a>(\n+    pub async fn traverse_edges_from_entries_bfs(\n         &self,\n-        entries: impl IntoIterator<Item = &'a ResolvedVc<Box<dyn Module>>>,\n+        entries: impl IntoIterator<Item = ResolvedVc<Box<dyn Module>>>,\n         mut visitor: impl FnMut(\n             Option<(&'_ SingleModuleGraphModuleNode, &'_ ChunkingType)>,\n             &'_ SingleModuleGraphModuleNode,\n         ) -> GraphTraversalAction,\n     ) -> Result<()> {\n         let graphs = self.get_graphs().await?;\n \n-        let entries = entries.into_iter();\n-        let mut queue = VecDeque::with_capacity(entries.size_hint().0);\n-        for e in entries {\n-            queue.push_back(ModuleGraph::get_entry(&graphs, *e).await?);\n-        }\n+        let mut queue = VecDeque::from(\n+            entries\n+                .into_iter()\n+                .map(|e| ModuleGraph::get_entry(&graphs, e))\n+                .try_join()\n+                .await?,\n+        );\n         let mut visited = HashSet::new();\n         for entry_node in &queue {\n             visitor(None, get_node!(graphs, entry_node)?);\n@@ -981,14 +1006,14 @@ impl ModuleGraph {\n #[turbo_tasks::value_impl]\n impl SingleModuleGraph {\n     #[turbo_tasks::function]\n-    pub async fn new_with_entries(entries: Vc<Modules>) -> Result<Vc<Self>> {\n+    pub async fn new_with_entries(entries: Vc<GraphEntries>) -> Result<Vc<Self>> {\n         SingleModuleGraph::new_inner(&*entries.await?, &Default::default()).await\n     }\n \n     #[turbo_tasks::function]\n     pub async fn new_with_entries_visited(\n         // This must not be a Vc<Vec<_>> to ensure layout segment optimization hits the cache\n-        entries: Vec<ResolvedVc<Box<dyn Module>>>,\n+        entries: GraphEntriesT,\n         visited_modules: Vc<VisitedModules>,\n     ) -> Result<Vc<Self>> {\n         SingleModuleGraph::new_inner(&entries, &visited_modules.await?.modules).await"
        },
        {
            "sha": "392eb9e6c1f256bc109716d22d8687376b09b307",
            "filename": "turbopack/crates/turbopack-node/src/evaluate.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 3,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/8624a4c1687e9b7bf71c48f0ecab9ff6e468d157/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fevaluate.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/8624a4c1687e9b7bf71c48f0ecab9ff6e468d157/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fevaluate.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fevaluate.rs?ref=8624a4c1687e9b7bf71c48f0ecab9ff6e468d157",
            "patch": "@@ -22,7 +22,9 @@ use turbo_tasks_fs::{to_sys_path, File, FileSystemPath};\n use turbopack_core::{\n     asset::AssetContent,\n     changed::content_changed,\n-    chunk::{ChunkingContext, ChunkingContextExt, EvaluatableAsset, EvaluatableAssets},\n+    chunk::{\n+        ChunkGroupType, ChunkingContext, ChunkingContextExt, EvaluatableAsset, EvaluatableAssets,\n+    },\n     context::AssetContext,\n     error::PrettyPrintError,\n     file_source::FileSource,\n@@ -154,11 +156,12 @@ async fn emit_evaluate_pool_assets_operation(\n         entries\n     };\n \n-    let module_graph = ModuleGraph::from_modules(Vc::cell(\n+    let module_graph = ModuleGraph::from_modules(Vc::cell(vec![(\n         iter::once(entry_module.to_resolved().await?)\n             .chain(runtime_entries.iter().copied().map(ResolvedVc::upcast))\n             .collect(),\n-    ));\n+        ChunkGroupType::Entry,\n+    )]));\n \n     let bootstrap = chunking_context.root_entry_chunk_group_asset(\n         entrypoint,"
        },
        {
            "sha": "07b1c4fd83fb85aa7138c7b024e5dc80c02fcfe1",
            "filename": "turbopack/crates/turbopack-node/src/lib.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/8624a4c1687e9b7bf71c48f0ecab9ff6e468d157/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/8624a4c1687e9b7bf71c48f0ecab9ff6e468d157/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Flib.rs?ref=8624a4c1687e9b7bf71c48f0ecab9ff6e468d157",
            "patch": "@@ -18,7 +18,7 @@ use turbo_tasks_fs::{to_sys_path, File, FileSystemPath};\n use turbopack_core::{\n     asset::{Asset, AssetContent},\n     changed::content_changed,\n-    chunk::{ChunkingContext, ChunkingContextExt, EvaluatableAssets},\n+    chunk::{ChunkGroupType, ChunkingContext, ChunkingContextExt, EvaluatableAssets},\n     module::Module,\n     module_graph::ModuleGraph,\n     output::{OutputAsset, OutputAssets, OutputAssetsSet},\n@@ -258,7 +258,7 @@ pub fn get_intermediate_asset(\n     Vc::upcast(chunking_context.root_entry_chunk_group_asset(\n         chunking_context.chunk_path(main_entry.ident(), \".js\".into()),\n         main_entry,\n-        ModuleGraph::from_module(main_entry),\n+        ModuleGraph::from_module(main_entry, ChunkGroupType::Entry),\n         OutputAssets::empty(),\n         other_entries,\n     ))"
        },
        {
            "sha": "836192f4ab5cbf7c89961e61c68f6b36c530053a",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot.rs",
            "status": "modified",
            "additions": 16,
            "deletions": 12,
            "changes": 28,
            "blob_url": "https://github.com/vercel/next.js/blob/8624a4c1687e9b7bf71c48f0ecab9ff6e468d157/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/8624a4c1687e9b7bf71c48f0ecab9ff6e468d157/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot.rs?ref=8624a4c1687e9b7bf71c48f0ecab9ff6e468d157",
            "patch": "@@ -33,8 +33,8 @@ use turbopack_browser::BrowserChunkingContext;\n use turbopack_core::{\n     asset::Asset,\n     chunk::{\n-        availability_info::AvailabilityInfo, ChunkableModule, ChunkingContext, ChunkingContextExt,\n-        EvaluatableAsset, EvaluatableAssetExt, EvaluatableAssets, MinifyType,\n+        availability_info::AvailabilityInfo, ChunkGroupType, ChunkableModule, ChunkingContext,\n+        ChunkingContextExt, EvaluatableAsset, EvaluatableAssetExt, EvaluatableAssets, MinifyType,\n     },\n     compile_time_defines,\n     compile_time_info::CompileTimeInfo,\n@@ -391,15 +391,19 @@ async fn run_test_operation(resource: RcStr) -> Result<Vc<FileSystemPath>> {\n         let evaluatable_assets = runtime_entries\n             .unwrap_or_else(EvaluatableAssets::empty)\n             .with_entry(Vc::upcast(ecmascript));\n-        let all_modules = Vc::cell(\n-            evaluatable_assets\n-                .await?\n-                .iter()\n-                .copied()\n-                .map(ResolvedVc::upcast)\n-                .collect(),\n-        );\n-        let module_graph = ModuleGraph::from_modules(all_modules);\n+        let all_modules = evaluatable_assets\n+            .await?\n+            .iter()\n+            .copied()\n+            .map(ResolvedVc::upcast)\n+            .collect();\n+        let module_graph = ModuleGraph::from_modules(Vc::cell(vec![(\n+            all_modules,\n+            match options.runtime {\n+                Runtime::Browser => ChunkGroupType::Evaluated,\n+                Runtime::NodeJs => ChunkGroupType::Entry,\n+            },\n+        )]));\n         // TODO: Load runtime entries from snapshots\n         match options.runtime {\n             Runtime::Browser => chunking_context.evaluated_chunk_group_assets(\n@@ -441,7 +445,7 @@ async fn run_test_operation(resource: RcStr) -> Result<Vc<FileSystemPath>> {\n     } else if let Some(chunkable) =\n         Vc::try_resolve_downcast::<Box<dyn ChunkableModule>>(entry_module).await?\n     {\n-        let module_graph = ModuleGraph::from_module(Vc::upcast(chunkable));\n+        let module_graph = ModuleGraph::from_module(Vc::upcast(chunkable), ChunkGroupType::Entry);\n         chunking_context.root_chunk_group_assets(chunkable, module_graph)\n     } else {\n         // TODO convert into a serve-able asset"
        }
    ],
    "stats": {
        "total": 448,
        "additions": 271,
        "deletions": 177
    }
}