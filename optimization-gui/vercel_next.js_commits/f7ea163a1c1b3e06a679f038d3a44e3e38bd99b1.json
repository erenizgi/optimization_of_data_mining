{
    "author": "sokra",
    "message": "Turbopack: avoid blocking tasks for I/O work (#87661)\n\n### What?\n\navoid using blocking tasks for IO work as we can't control the priority of blocking tasks.\n\n### Why?\n\nWe already control concurrency of fs access via a semaphore which helps to ensure we won't tie up all tokio threads and we are generally suspicious that moving this blocking work to blocking threads is worthwhile",
    "sha": "f7ea163a1c1b3e06a679f038d3a44e3e38bd99b1",
    "files": [
        {
            "sha": "7a63a21eca3cb56918da51a1b29a923a9c34a76b",
            "filename": "turbopack/crates/turbo-tasks-fs/src/lib.rs",
            "status": "modified",
            "additions": 20,
            "deletions": 8,
            "changes": 28,
            "blob_url": "https://github.com/vercel/next.js/blob/f7ea163a1c1b3e06a679f038d3a44e3e38bd99b1/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f7ea163a1c1b3e06a679f038d3a44e3e38bd99b1/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs?ref=f7ea163a1c1b3e06a679f038d3a44e3e38bd99b1",
            "patch": "@@ -493,11 +493,11 @@ impl DiskFileSystemInner {\n         if !already_created {\n             let func = |p: &Path| std::fs::create_dir_all(p);\n             retry_blocking(directory.to_path_buf(), func)\n-                .concurrency_limited(&self.write_semaphore)\n                 .instrument(tracing::info_span!(\n                     \"create directory\",\n                     name = display(directory.display())\n                 ))\n+                .concurrency_limited(&self.write_semaphore)\n                 .await?;\n             ApplyEffectsContext::with(|fs_context: &mut DiskFileSystemApplyContext| {\n                 fs_context\n@@ -708,11 +708,11 @@ impl FileSystem for DiskFileSystem {\n \n         let _lock = self.inner.lock_path(&full_path).await;\n         let content = match retry_blocking(full_path.clone(), |path: &Path| File::from_path(path))\n-            .concurrency_limited(&self.inner.read_semaphore)\n             .instrument(tracing::info_span!(\n                 \"read file\",\n                 name = display(full_path.display())\n             ))\n+            .concurrency_limited(&self.inner.read_semaphore)\n             .await\n         {\n             Ok(file) => FileContent::new(file),\n@@ -834,11 +834,11 @@ impl FileSystem for DiskFileSystem {\n         let _lock = self.inner.lock_path(&full_path).await;\n         let link_path =\n             match retry_blocking(full_path.clone(), |path: &Path| std::fs::read_link(path))\n-                .concurrency_limited(&self.inner.read_semaphore)\n                 .instrument(tracing::info_span!(\n                     \"read symlink\",\n                     name = display(full_path.display())\n                 ))\n+                .concurrency_limited(&self.inner.read_semaphore)\n                 .await\n             {\n                 Ok(res) => res,\n@@ -956,11 +956,11 @@ impl FileSystem for DiskFileSystem {\n             // not wasting cycles.\n             let compare = content\n                 .streaming_compare(&full_path)\n-                .concurrency_limited(&inner.read_semaphore)\n                 .instrument(tracing::info_span!(\n                     \"read file before write\",\n                     name = display(full_path.display())\n                 ))\n+                .concurrency_limited(&inner.read_semaphore)\n                 .await?;\n             if compare == FileComparison::Equal {\n                 if !old_invalidators.is_empty() {\n@@ -1024,23 +1024,23 @@ impl FileSystem for DiskFileSystem {\n                         }\n                         Ok::<(), io::Error>(())\n                     })\n-                    .concurrency_limited(&inner.write_semaphore)\n                     .instrument(tracing::info_span!(\n                         \"write file\",\n                         name = display(full_path.display())\n                     ))\n+                    .concurrency_limited(&inner.write_semaphore)\n                     .await\n                     .with_context(|| format!(\"failed to write to {}\", full_path.display()))?;\n                 }\n                 FileContent::NotFound => {\n                     retry_blocking(full_path.clone().into_owned(), |path| {\n                         std::fs::remove_file(path)\n                     })\n-                    .concurrency_limited(&inner.write_semaphore)\n                     .instrument(tracing::info_span!(\n                         \"remove file\",\n                         name = display(full_path.display())\n                     ))\n+                    .concurrency_limited(&inner.write_semaphore)\n                     .await\n                     .or_else(|err| {\n                         if err.kind() == ErrorKind::NotFound {\n@@ -1139,11 +1139,11 @@ impl FileSystem for DiskFileSystem {\n             let old_content = match retry_blocking(full_path.clone().into_owned(), |path| {\n                 std::fs::read_link(path)\n             })\n-            .concurrency_limited(&inner.read_semaphore)\n             .instrument(tracing::info_span!(\n                 \"read symlink before write\",\n                 name = display(full_path.display())\n             ))\n+            .concurrency_limited(&inner.read_semaphore)\n             .await\n             {\n                 Ok(res) => Some((res.is_absolute(), res)),\n@@ -1195,13 +1195,19 @@ impl FileSystem for DiskFileSystem {\n                         // fails with EEXIST if the link already exists instead of overwriting it.\n                         // Windows has similar behavior with junction points.\n                         remove_symbolic_link_dir_helper(&full_path)\n+                            .instrument(tracing::info_span!(\n+                                \"remove existing symlink before write\",\n+                                name = display(full_path.display())\n+                            ))\n                             .concurrency_limited(&inner.write_semaphore)\n                             .await\n                             .with_context(|| {\n                                 anyhow!(\"removing existing symlink {} failed\", full_path.display())\n                             })?;\n                     }\n \n+                    let span =\n+                        tracing::info_span!(\"create symlink\", name = display(full_path.display()));\n                     retry_blocking(target.clone(), move |target_path| {\n                         let _span = tracing::info_span!(\n                             \"write symlink\",\n@@ -1221,6 +1227,8 @@ impl FileSystem for DiskFileSystem {\n                             }\n                         }\n                     })\n+                    .instrument(span)\n+                    .concurrency_limited(&inner.write_semaphore)\n                     .await\n                     .with_context(|| {\n                         #[cfg(not(windows))]\n@@ -1243,6 +1251,10 @@ impl FileSystem for DiskFileSystem {\n                 }\n                 OsSpecificLinkContent::NotFound => {\n                     remove_symbolic_link_dir_helper(&full_path)\n+                        .instrument(tracing::info_span!(\n+                            \"remove symlink\",\n+                            name = display(full_path.display())\n+                        ))\n                         .concurrency_limited(&inner.write_semaphore)\n                         .await\n                         .with_context(|| anyhow!(\"removing {} failed\", full_path.display()))?;\n@@ -1271,11 +1283,11 @@ impl FileSystem for DiskFileSystem {\n \n         let _lock = self.inner.lock_path(&full_path).await;\n         let meta = retry_blocking(full_path.clone(), |path| std::fs::metadata(path))\n-            .concurrency_limited(&self.inner.read_semaphore)\n             .instrument(tracing::info_span!(\n                 \"read metadata\",\n                 name = display(full_path.display())\n             ))\n+            .concurrency_limited(&self.inner.read_semaphore)\n             .await\n             .with_context(|| format!(\"reading metadata for {}\", full_path.display()))?;\n "
        },
        {
            "sha": "fd29b0f5c26d6967880ab08a5ed603289de2b783",
            "filename": "turbopack/crates/turbo-tasks-fs/src/retry.rs",
            "status": "modified",
            "additions": 14,
            "deletions": 18,
            "changes": 32,
            "blob_url": "https://github.com/vercel/next.js/blob/f7ea163a1c1b3e06a679f038d3a44e3e38bd99b1/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fretry.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f7ea163a1c1b3e06a679f038d3a44e3e38bd99b1/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fretry.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fretry.rs?ref=f7ea163a1c1b3e06a679f038d3a44e3e38bd99b1",
            "patch": "@@ -1,7 +1,6 @@\n use std::{\n     io::{self, ErrorKind},\n     path::{Path, PathBuf},\n-    thread::sleep,\n     time::Duration,\n };\n \n@@ -12,25 +11,22 @@ where\n     F: Fn(&Path) -> io::Result<R> + Send + 'static,\n     R: Send + 'static,\n {\n-    turbo_tasks::spawn_blocking(move || {\n-        let mut attempt = 1;\n+    let mut attempt = 1;\n \n-        loop {\n-            return match func(&path) {\n-                Ok(r) => Ok(r),\n-                Err(err) => {\n-                    if attempt < MAX_RETRY_ATTEMPTS && can_retry(&err) {\n-                        sleep(get_retry_wait_time(attempt));\n-                        attempt += 1;\n-                        continue;\n-                    }\n-\n-                    Err(err)\n+    loop {\n+        return match func(&path) {\n+            Ok(r) => Ok(r),\n+            Err(err) => {\n+                if attempt < MAX_RETRY_ATTEMPTS && can_retry(&err) {\n+                    tokio::time::sleep(get_retry_wait_time(attempt)).await;\n+                    attempt += 1;\n+                    continue;\n                 }\n-            };\n-        }\n-    })\n-    .await\n+\n+                Err(err)\n+            }\n+        };\n+    }\n }\n \n fn can_retry(err: &io::Error) -> bool {"
        }
    ],
    "stats": {
        "total": 60,
        "additions": 34,
        "deletions": 26
    }
}