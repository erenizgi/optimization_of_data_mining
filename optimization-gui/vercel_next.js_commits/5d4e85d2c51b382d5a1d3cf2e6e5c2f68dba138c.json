{
    "author": "sokra",
    "message": "Turbopack: add `turbo_tasks::spawn` (#82634)\n\n### What?\n\nadd a `spawn` method in turbo_tasks that allows to spawn a async tokio task with the right task locals, spans, etc.",
    "sha": "5d4e85d2c51b382d5a1d3cf2e6e5c2f68dba138c",
    "files": [
        {
            "sha": "f2934b3c857adf3a1d034ddb65cc4dba521e6727",
            "filename": "turbopack/crates/turbo-tasks-backend/src/database/turbo/mod.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 7,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/5d4e85d2c51b382d5a1d3cf2e6e5c2f68dba138c/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdatabase%2Fturbo%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5d4e85d2c51b382d5a1d3cf2e6e5c2f68dba138c/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdatabase%2Fturbo%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdatabase%2Fturbo%2Fmod.rs?ref=5d4e85d2c51b382d5a1d3cf2e6e5c2f68dba138c",
            "patch": "@@ -1,15 +1,12 @@\n use std::{cmp::max, path::PathBuf, sync::Arc, thread::available_parallelism};\n \n-use anyhow::Result;\n+use anyhow::{Ok, Result};\n use parking_lot::Mutex;\n-use tokio::{\n-    runtime::Handle,\n-    spawn,\n-    task::{JoinHandle, block_in_place},\n-};\n+use tokio::{runtime::Handle, task::block_in_place};\n use turbo_persistence::{\n     ArcSlice, CompactConfig, KeyBase, StoreKey, TurboPersistence, ValueBuffer,\n };\n+use turbo_tasks::{JoinHandle, spawn};\n \n use crate::database::{\n     key_value_database::{KeySpace, KeyValueDatabase},\n@@ -225,5 +222,5 @@ impl<'l> From<WriteBuffer<'l>> for ValueBuffer<'l> {\n }\n \n fn join(handle: JoinHandle<Result<()>>) -> Result<()> {\n-    block_in_place(|| Handle::current().block_on(handle))?\n+    block_in_place(|| Handle::current().block_on(handle))\n }"
        },
        {
            "sha": "194d2796d843b24f001c41080bf32a7eeccfce2d",
            "filename": "turbopack/crates/turbo-tasks-malloc/src/lib.rs",
            "status": "modified",
            "additions": 34,
            "deletions": 0,
            "changes": 34,
            "blob_url": "https://github.com/vercel/next.js/blob/5d4e85d2c51b382d5a1d3cf2e6e5c2f68dba138c/turbopack%2Fcrates%2Fturbo-tasks-malloc%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5d4e85d2c51b382d5a1d3cf2e6e5c2f68dba138c/turbopack%2Fcrates%2Fturbo-tasks-malloc%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-malloc%2Fsrc%2Flib.rs?ref=5d4e85d2c51b382d5a1d3cf2e6e5c2f68dba138c",
            "patch": "@@ -3,6 +3,7 @@ mod counter;\n use std::{\n     alloc::{GlobalAlloc, Layout},\n     marker::PhantomData,\n+    ops::{Add, AddAssign},\n };\n \n use self::counter::{add, flush, get, remove, update};\n@@ -16,12 +17,45 @@ pub struct AllocationInfo {\n }\n \n impl AllocationInfo {\n+    pub const ZERO: Self = Self {\n+        allocations: 0,\n+        deallocations: 0,\n+        allocation_count: 0,\n+        deallocation_count: 0,\n+    };\n+\n     pub fn is_empty(&self) -> bool {\n         self.allocations == 0\n             && self.deallocations == 0\n             && self.allocation_count == 0\n             && self.deallocation_count == 0\n     }\n+\n+    pub fn memory_usage(&self) -> usize {\n+        self.allocations.saturating_sub(self.deallocations)\n+    }\n+}\n+\n+impl Add<Self> for AllocationInfo {\n+    type Output = Self;\n+\n+    fn add(self, other: Self) -> Self {\n+        Self {\n+            allocations: self.allocations + other.allocations,\n+            deallocations: self.deallocations + other.deallocations,\n+            allocation_count: self.allocation_count + other.allocation_count,\n+            deallocation_count: self.deallocation_count + other.deallocation_count,\n+        }\n+    }\n+}\n+\n+impl AddAssign<Self> for AllocationInfo {\n+    fn add_assign(&mut self, other: Self) {\n+        self.allocations += other.allocations;\n+        self.deallocations += other.deallocations;\n+        self.allocation_count += other.allocation_count;\n+        self.deallocation_count += other.deallocation_count;\n+    }\n }\n \n #[derive(Default, Clone, Debug)]"
        },
        {
            "sha": "4f791869dbab4c2b94f495a923f2c3c737f929cd",
            "filename": "turbopack/crates/turbo-tasks/src/capture_future.rs",
            "status": "modified",
            "additions": 17,
            "deletions": 15,
            "changes": 32,
            "blob_url": "https://github.com/vercel/next.js/blob/5d4e85d2c51b382d5a1d3cf2e6e5c2f68dba138c/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fcapture_future.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5d4e85d2c51b382d5a1d3cf2e6e5c2f68dba138c/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fcapture_future.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fcapture_future.rs?ref=5d4e85d2c51b382d5a1d3cf2e6e5c2f68dba138c",
            "patch": "@@ -31,8 +31,7 @@ pin_project! {\n         #[pin]\n         future: F,\n         duration: Duration,\n-        allocations: usize,\n-        deallocations: usize,\n+        allocations: AllocationInfo,\n     }\n }\n \n@@ -41,8 +40,7 @@ impl<T, F: Future<Output = T>> CaptureFuture<T, F> {\n         Self {\n             future,\n             duration: Duration::ZERO,\n-            allocations: 0,\n-            deallocations: 0,\n+            allocations: AllocationInfo::ZERO,\n         }\n     }\n }\n@@ -77,14 +75,25 @@ pub struct TurboTasksPanic {\n     pub location: Option<String>,\n }\n \n+impl TurboTasksPanic {\n+    pub fn into_panic(self) -> Box<dyn std::any::Any + Send> {\n+        Box::new(format!(\n+            \"{} at {}\",\n+            self.message,\n+            self.location\n+                .unwrap_or_else(|| \"unknown location\".to_string())\n+        ))\n+    }\n+}\n+\n impl Display for TurboTasksPanic {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         write!(f, \"{}\", self.message)\n     }\n }\n \n impl<T, F: Future<Output = T>> Future for CaptureFuture<T, F> {\n-    type Output = (Result<T, TurboTasksPanic>, Duration, usize);\n+    type Output = (Result<T, TurboTasksPanic>, Duration, AllocationInfo);\n \n     fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n         let this = self.project();\n@@ -127,17 +136,10 @@ impl<T, F: Future<Output = T>> Future for CaptureFuture<T, F> {\n         let elapsed = start.elapsed();\n         let allocations = start_allocations.until_now();\n         *this.duration += elapsed + data.duration;\n-        *this.allocations += allocations.allocations + data.allocations;\n-        *this.deallocations += allocations.deallocations + data.deallocations;\n+        *this.allocations += allocations;\n         match result {\n-            Err(err) => {\n-                let memory_usage = this.allocations.saturating_sub(*this.deallocations);\n-                Poll::Ready((Err(err), *this.duration, memory_usage))\n-            }\n-            Ok(Poll::Ready(r)) => {\n-                let memory_usage = this.allocations.saturating_sub(*this.deallocations);\n-                Poll::Ready((Ok(r), *this.duration, memory_usage))\n-            }\n+            Err(err) => Poll::Ready((Err(err), *this.duration, this.allocations.clone())),\n+            Ok(Poll::Ready(r)) => Poll::Ready((Ok(r), *this.duration, this.allocations.clone())),\n             Ok(Poll::Pending) => Poll::Pending,\n         }\n     }"
        },
        {
            "sha": "841e4b1f8c455c7c53f034d76e5b1132160387a3",
            "filename": "turbopack/crates/turbo-tasks/src/lib.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/5d4e85d2c51b382d5a1d3cf2e6e5c2f68dba138c/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5d4e85d2c51b382d5a1d3cf2e6e5c2f68dba138c/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs?ref=5d4e85d2c51b382d5a1d3cf2e6e5c2f68dba138c",
            "patch": "@@ -76,6 +76,7 @@ pub mod registry;\n pub mod scope;\n mod serialization_invalidation;\n pub mod small_duration;\n+mod spawn;\n mod state;\n pub mod task;\n mod task_execution_reason;\n@@ -110,8 +111,7 @@ pub use manager::{\n     CurrentCellRef, ReadConsistency, TaskPersistence, TurboTasks, TurboTasksApi,\n     TurboTasksBackendApi, TurboTasksBackendApiExt, TurboTasksCallApi, Unused, UpdateInfo,\n     dynamic_call, emit, mark_finished, mark_root, mark_session_dependent, mark_stateful,\n-    prevent_gc, run_once, run_once_with_reason, spawn_blocking, spawn_thread, trait_call,\n-    turbo_tasks, turbo_tasks_scope,\n+    prevent_gc, run_once, run_once_with_reason, trait_call, turbo_tasks, turbo_tasks_scope,\n };\n pub use output::OutputContent;\n pub use raw_vc::{CellId, RawVc, ReadRawVcFuture, ResolveTypeError};\n@@ -120,6 +120,7 @@ pub use read_ref::ReadRef;\n use rustc_hash::FxHasher;\n pub use serialization_invalidation::SerializationInvalidator;\n pub use shrink_to_fit::ShrinkToFit;\n+pub use spawn::{JoinHandle, spawn, spawn_blocking, spawn_thread};\n pub use state::{State, TransientState};\n pub use task::{SharedReference, TypedSharedReference, task_input::TaskInput};\n pub use task_execution_reason::TaskExecutionReason;"
        },
        {
            "sha": "393c5224da390a8285d3a6a638474a7023a6cc02",
            "filename": "turbopack/crates/turbo-tasks/src/manager.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 36,
            "changes": 41,
            "blob_url": "https://github.com/vercel/next.js/blob/5d4e85d2c51b382d5a1d3cf2e6e5c2f68dba138c/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5d4e85d2c51b382d5a1d3cf2e6e5c2f68dba138c/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs?ref=5d4e85d2c51b382d5a1d3cf2e6e5c2f68dba138c",
            "patch": "@@ -8,7 +8,6 @@ use std::{\n         Arc, Mutex, RwLock, Weak,\n         atomic::{AtomicBool, AtomicUsize, Ordering},\n     },\n-    thread,\n     time::{Duration, Instant},\n };\n \n@@ -17,10 +16,9 @@ use auto_hash_map::AutoMap;\n use rustc_hash::FxHasher;\n use serde::{Deserialize, Serialize};\n use smallvec::SmallVec;\n-use tokio::{runtime::Handle, select, sync::mpsc::Receiver, task_local};\n+use tokio::{select, sync::mpsc::Receiver, task_local};\n use tokio_util::task::TaskTracker;\n-use tracing::{Instrument, Level, Span, info_span, instrument, trace_span};\n-use turbo_tasks_malloc::TurboMalloc;\n+use tracing::{Instrument, Level, instrument, trace_span};\n \n use crate::{\n     Completion, InvalidationReason, InvalidationReasonSet, OutputContent, ReadCellOptions,\n@@ -30,7 +28,7 @@ use crate::{\n         Backend, CachedTaskType, CellContent, TaskCollectiblesMap, TaskExecutionSpec,\n         TransientTaskType, TurboTasksExecutionError, TypedCellContent,\n     },\n-    capture_future::{self, CaptureFuture},\n+    capture_future::CaptureFuture,\n     event::{Event, EventListener},\n     id::{BackendJobId, ExecutionId, LocalTaskId, TRANSIENT_TASK_BIT, TraitTypeId},\n     id_factory::IdFactoryWithReuse,\n@@ -718,7 +716,7 @@ impl<B: Backend + 'static> TurboTasks<B> {\n                     };\n \n                     async {\n-                        let (result, duration, memory_usage) = CaptureFuture::new(future).await;\n+                        let (result, duration, alloc_info) = CaptureFuture::new(future).await;\n \n                         // wait for all spawned local tasks using `local` to finish\n                         let ltt = CURRENT_TASK_STATE\n@@ -742,7 +740,7 @@ impl<B: Backend + 'static> TurboTasks<B> {\n                         let schedule_again = this.backend.task_execution_completed(\n                             task_id,\n                             duration,\n-                            memory_usage,\n+                            alloc_info.memory_usage(),\n                             &cell_counters,\n                             stateful,\n                             has_invalidator,\n@@ -1794,35 +1792,6 @@ pub fn emit<T: VcValueTrait + ?Sized>(collectible: ResolvedVc<T>) {\n     })\n }\n \n-pub async fn spawn_blocking<T: Send + 'static>(func: impl FnOnce() -> T + Send + 'static) -> T {\n-    let turbo_tasks = turbo_tasks();\n-    let span = Span::current();\n-    let (result, duration, alloc_info) = tokio::task::spawn_blocking(|| {\n-        let _guard = span.entered();\n-        let start = Instant::now();\n-        let start_allocations = TurboMalloc::allocation_counters();\n-        let r = turbo_tasks_scope(turbo_tasks, func);\n-        (r, start.elapsed(), start_allocations.until_now())\n-    })\n-    .await\n-    .unwrap();\n-    capture_future::add_duration(duration);\n-    capture_future::add_allocation_info(alloc_info);\n-    result\n-}\n-\n-pub fn spawn_thread(func: impl FnOnce() + Send + 'static) {\n-    let handle = Handle::current();\n-    let span = info_span!(\"thread\").or_current();\n-    thread::spawn(move || {\n-        let span = span.entered();\n-        let guard = handle.enter();\n-        func();\n-        drop(guard);\n-        drop(span);\n-    });\n-}\n-\n pub(crate) async fn read_task_output(\n     this: &dyn TurboTasksApi,\n     id: TaskId,"
        },
        {
            "sha": "18ddc826f6c44b6cb5126c9d51f8f8a9dee19909",
            "filename": "turbopack/crates/turbo-tasks/src/spawn.rs",
            "status": "added",
            "additions": 89,
            "deletions": 0,
            "changes": 89,
            "blob_url": "https://github.com/vercel/next.js/blob/5d4e85d2c51b382d5a1d3cf2e6e5c2f68dba138c/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fspawn.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5d4e85d2c51b382d5a1d3cf2e6e5c2f68dba138c/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fspawn.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fspawn.rs?ref=5d4e85d2c51b382d5a1d3cf2e6e5c2f68dba138c",
            "patch": "@@ -0,0 +1,89 @@\n+use std::{\n+    panic::resume_unwind,\n+    pin::Pin,\n+    task::{Context, Poll},\n+    thread,\n+    time::{Duration, Instant},\n+};\n+\n+use anyhow::Result;\n+use futures::{FutureExt, ready};\n+use tokio::runtime::Handle;\n+use tracing::{Instrument, Span, info_span};\n+use turbo_tasks_malloc::{AllocationInfo, TurboMalloc};\n+\n+use crate::{\n+    TurboTasksPanic,\n+    capture_future::{self, CaptureFuture},\n+    manager::turbo_tasks_future_scope,\n+    turbo_tasks, turbo_tasks_scope,\n+};\n+\n+pub struct JoinHandle<T> {\n+    join_handle: tokio::task::JoinHandle<(Result<T, TurboTasksPanic>, Duration, AllocationInfo)>,\n+}\n+\n+impl<T> Future for JoinHandle<T> {\n+    type Output = T;\n+\n+    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n+        let this = self.get_mut();\n+        match ready!(this.join_handle.poll_unpin(cx)) {\n+            Ok((res, duration, alloc_info)) => {\n+                capture_future::add_duration(duration);\n+                capture_future::add_allocation_info(alloc_info);\n+                match res {\n+                    Ok(res) => Poll::Ready(res),\n+                    Err(e) => resume_unwind(e.into_panic()),\n+                }\n+            }\n+            Err(e) => resume_unwind(e.into_panic()),\n+        }\n+    }\n+}\n+\n+/// Spawns a future as separate task and returns a JoinHandle which can be used to await the result.\n+/// The future has access to the current TurboTasks context and runs in the same tracing span.\n+/// Allocations and cpu time is accounted to the current turbo-tasks function.\n+pub fn spawn<T: Send + 'static>(future: impl Future<Output = T> + Send + 'static) -> JoinHandle<T> {\n+    let turbo_tasks = turbo_tasks();\n+    let span = Span::current();\n+    let join_handle = tokio::task::spawn(\n+        turbo_tasks_future_scope(turbo_tasks, CaptureFuture::new(future)).instrument(span),\n+    );\n+    JoinHandle { join_handle }\n+}\n+\n+/// Spawns a blocking function in a separate task using the blocking pool and returns a JoinHandle\n+/// which can be used to await the result. The function has access to the current TurboTasks context\n+/// and runs in the same tracing span.\n+/// Allocations and cpu time is accounted to the current turbo-tasks function.\n+pub fn spawn_blocking<T: Send + 'static>(\n+    func: impl FnOnce() -> T + Send + 'static,\n+) -> JoinHandle<T> {\n+    let turbo_tasks = turbo_tasks();\n+    let span = Span::current();\n+    let join_handle = tokio::task::spawn_blocking(|| {\n+        let _guard = span.entered();\n+        let start = Instant::now();\n+        let start_allocations = TurboMalloc::allocation_counters();\n+        let r = turbo_tasks_scope(turbo_tasks, func);\n+        (Ok(r), start.elapsed(), start_allocations.until_now())\n+    });\n+    JoinHandle { join_handle }\n+}\n+\n+/// Spawns a thread which runs in background. It has access to the current TurboTasks context, but\n+/// is not accounted towards the current turbo-tasks function.\n+pub fn spawn_thread(func: impl FnOnce() + Send + 'static) {\n+    let handle = Handle::current();\n+    let span = info_span!(\"thread\").or_current();\n+    let turbo_tasks = turbo_tasks();\n+    thread::spawn(move || {\n+        let _span = span.entered();\n+        turbo_tasks_scope(turbo_tasks, || {\n+            let _guard = handle.enter();\n+            func();\n+        })\n+    });\n+}"
        }
    ],
    "stats": {
        "total": 212,
        "additions": 152,
        "deletions": 60
    }
}