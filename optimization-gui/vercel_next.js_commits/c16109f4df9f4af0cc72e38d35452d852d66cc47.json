{
    "author": "mischnic",
    "message": "Turbopack: speedup module merging (#85043)\n\npreallocate hashmaps",
    "sha": "c16109f4df9f4af0cc72e38d35452d852d66cc47",
    "files": [
        {
            "sha": "084750e671dc8cd2293736e37bb1d2c7b45e9805",
            "filename": "turbopack/crates/turbo-tasks/src/parallel.rs",
            "status": "modified",
            "additions": 27,
            "deletions": 1,
            "changes": 28,
            "blob_url": "https://github.com/vercel/next.js/blob/c16109f4df9f4af0cc72e38d35452d852d66cc47/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fparallel.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c16109f4df9f4af0cc72e38d35452d852d66cc47/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fparallel.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fparallel.rs?ref=c16109f4df9f4af0cc72e38d35452d852d66cc47",
            "patch": "@@ -6,7 +6,7 @@\n \n use crate::{\n     scope::scope_and_block,\n-    util::{good_chunk_size, into_chunks},\n+    util::{Chunk, good_chunk_size, into_chunks},\n };\n \n struct Chunked {\n@@ -231,6 +231,32 @@ where\n     .collect()\n }\n \n+pub fn map_collect_chunked_owned<'l, Item, PerItemResult, Result>(\n+    items: Vec<Item>,\n+    f: impl Fn(Chunk<Item>) -> PerItemResult + Send + Sync,\n+) -> Result\n+where\n+    Item: Send + Sync,\n+    PerItemResult: Send + Sync + 'l,\n+    Result: FromIterator<PerItemResult>,\n+{\n+    let Some(Chunked {\n+        chunk_size,\n+        chunk_count,\n+    }) = get_chunked(items.len())\n+    else {\n+        let len = items.len();\n+        return Result::from_iter(into_chunks(items, len).map(f));\n+    };\n+    let f = &f;\n+    scope_and_block(chunk_count, |scope| {\n+        for chunk in into_chunks(items, chunk_size) {\n+            scope.spawn(move || f(chunk))\n+        }\n+    })\n+    .collect()\n+}\n+\n #[cfg(test)]\n mod tests {\n     use std::{"
        },
        {
            "sha": "2f5e921af9730bf87a783d6b3a4d9983916a9c6f",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/merged_modules.rs",
            "status": "modified",
            "additions": 115,
            "deletions": 86,
            "changes": 201,
            "blob_url": "https://github.com/vercel/next.js/blob/c16109f4df9f4af0cc72e38d35452d852d66cc47/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmerged_modules.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c16109f4df9f4af0cc72e38d35452d852d66cc47/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmerged_modules.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmerged_modules.rs?ref=c16109f4df9f4af0cc72e38d35452d852d66cc47",
            "patch": "@@ -279,8 +279,9 @@ pub async fn compute_merged_modules(module_graph: Vc<ModuleGraph>) -> Result<Vc<\n \n         {\n             struct ChunkGroupResult {\n-                chunk_group_idx: usize,\n-                lists: Vec<Vec<ResolvedVc<Box<dyn MergeableModule>>>>,\n+                first_chunk_group_idx: usize,\n+                #[allow(clippy::type_complexity)]\n+                list_lists: Vec<Vec<Vec<ResolvedVc<Box<dyn MergeableModule>>>>>,\n                 lists_reverse_indices:\n                     FxIndexMap<ResolvedVc<Box<dyn MergeableModule>>, FxIndexSet<ListOccurrence>>,\n                 #[allow(clippy::type_complexity)]\n@@ -289,26 +290,13 @@ pub async fn compute_merged_modules(module_graph: Vc<ModuleGraph>) -> Result<Vc<\n                     FxIndexSet<ResolvedVc<Box<dyn Module>>>,\n                 >,\n             }\n+            let span = tracing::info_span!(\"map chunk groups\").entered();\n \n-            let result = turbo_tasks::parallel::map_collect_owned::<_, _, Result<Vec<_>>>(\n+            let result = turbo_tasks::parallel::map_collect_chunked_owned::<_, _, Result<Vec<_>>>(\n                 // TODO without collect\n                 chunk_group_info.chunk_groups.iter().enumerate().collect(),\n-                |(chunk_group_idx, chunk_group)| {\n-                    // A partition of all modules in the chunk into several execution traces\n-                    // (orderings), stored in the top-level lists and referenced here by\n-                    // index.\n-                    let mut chunk_lists: FxHashMap<&RoaringBitmapWrapper, usize> =\n-                        FxHashMap::with_capacity_and_hasher(\n-                            module_merged_groups.len() / chunk_group_info.chunk_groups.len(),\n-                            Default::default(),\n-                        );\n-\n-                    // This is necessary to have the correct order with cycles: a `a -> b -> a`\n-                    // graph would otherwise be visited as `b->a`, `a->b`,\n-                    // leading to the list `a, b` which is not execution order.\n-                    let mut visited = FxHashSet::default();\n-\n-                    let mut lists = vec![];\n+                |chunk| {\n+                    let mut list_lists = vec![];\n                     let mut lists_reverse_indices: FxIndexMap<\n                         ResolvedVc<Box<dyn MergeableModule>>,\n                         FxIndexSet<ListOccurrence>,\n@@ -319,92 +307,133 @@ pub async fn compute_merged_modules(module_graph: Vc<ModuleGraph>) -> Result<Vc<\n                         FxIndexSet<ResolvedVc<Box<dyn Module>>>,\n                     > = FxIndexMap::default();\n \n-                    module_graph.traverse_edges_from_entries_dfs(\n-                        chunk_group.entries(),\n-                        &mut (),\n-                        |parent_info, node, _| {\n-                            if parent_info.is_none_or(|(_, r)| r.chunking_type.is_parallel())\n-                                && visited.insert(node.module)\n-                            {\n-                                Ok(GraphTraversalAction::Continue)\n-                            } else {\n-                                Ok(GraphTraversalAction::Exclude)\n-                            }\n-                        },\n-                        |parent_info, node, _| {\n-                            let module = node.module;\n-                            let bitmap = module_merged_groups\n-                                .get(&module)\n-                                .context(\"every module should have a bitmap at this point\")?;\n-\n-                            if mergeable.contains(&module) {\n-                                let mergeable_module =\n-                                    ResolvedVc::try_downcast::<Box<dyn MergeableModule>>(module)\n+                    let mut chunk = chunk.peekable();\n+                    let first_chunk_group_idx = chunk.peek().unwrap().0;\n+\n+                    for (chunk_group_idx, chunk_group) in chunk {\n+                        let mut lists = vec![];\n+\n+                        // A partition of all modules in the chunk into several execution traces\n+                        // (orderings), stored in the top-level lists and referenced here by\n+                        // index.\n+                        let mut chunk_lists: FxHashMap<&RoaringBitmapWrapper, usize> =\n+                            FxHashMap::with_capacity_and_hasher(\n+                                module_merged_groups.len() / chunk_group_info.chunk_groups.len(),\n+                                Default::default(),\n+                            );\n+\n+                        // This is necessary to have the correct order with cycles: a `a -> b -> a`\n+                        // graph would otherwise be visited as `b->a`, `a->b`,\n+                        // leading to the list `a, b` which is not execution order.\n+                        let mut visited = FxHashSet::default();\n+\n+                        module_graph.traverse_edges_from_entries_dfs(\n+                            chunk_group.entries(),\n+                            &mut (),\n+                            |parent_info, node, _| {\n+                                if parent_info.is_none_or(|(_, r)| r.chunking_type.is_parallel())\n+                                    && visited.insert(node.module)\n+                                {\n+                                    Ok(GraphTraversalAction::Continue)\n+                                } else {\n+                                    Ok(GraphTraversalAction::Exclude)\n+                                }\n+                            },\n+                            |parent_info, node, _| {\n+                                let module = node.module;\n+                                let bitmap = module_merged_groups\n+                                    .get(&module)\n+                                    .context(\"every module should have a bitmap at this point\")?;\n+\n+                                if mergeable.contains(&module) {\n+                                    let mergeable_module =\n+                                        ResolvedVc::try_downcast::<Box<dyn MergeableModule>>(\n+                                            module,\n+                                        )\n                                         .unwrap();\n-                                match chunk_lists.entry(bitmap) {\n-                                    Entry::Vacant(e) => {\n-                                        // New list, insert the module\n-                                        let idx = lists.len();\n-                                        e.insert(idx);\n-                                        lists.push(vec![mergeable_module]);\n-                                        lists_reverse_indices\n-                                            .entry(mergeable_module)\n-                                            .or_default()\n-                                            .insert(ListOccurrence {\n-                                                chunk_group: chunk_group_idx,\n-                                                list: idx,\n-                                                entry: 0,\n-                                            });\n-                                    }\n-                                    Entry::Occupied(e) => {\n-                                        let list_idx = *e.get();\n-                                        let list = &mut lists[list_idx];\n-                                        list.push(mergeable_module);\n-                                        lists_reverse_indices\n-                                            .entry(mergeable_module)\n-                                            .or_default()\n-                                            .insert(ListOccurrence {\n-                                                chunk_group: chunk_group_idx,\n-                                                list: list_idx,\n-                                                entry: list.len() - 1,\n-                                            });\n+                                    match chunk_lists.entry(bitmap) {\n+                                        Entry::Vacant(e) => {\n+                                            // New list, insert the module\n+                                            let idx = lists.len();\n+                                            e.insert(idx);\n+                                            lists.push(vec![mergeable_module]);\n+                                            lists_reverse_indices\n+                                                .entry(mergeable_module)\n+                                                .or_default()\n+                                                .insert(ListOccurrence {\n+                                                    chunk_group: chunk_group_idx,\n+                                                    list: idx,\n+                                                    entry: 0,\n+                                                });\n+                                        }\n+                                        Entry::Occupied(e) => {\n+                                            let list_idx = *e.get();\n+                                            let list = &mut lists[list_idx];\n+                                            list.push(mergeable_module);\n+                                            lists_reverse_indices\n+                                                .entry(mergeable_module)\n+                                                .or_default()\n+                                                .insert(ListOccurrence {\n+                                                    chunk_group: chunk_group_idx,\n+                                                    list: list_idx,\n+                                                    entry: list.len() - 1,\n+                                                });\n+                                        }\n                                     }\n                                 }\n-                            }\n \n-                            if let Some((parent, _)) = parent_info {\n-                                let same_bitmap = module_merged_groups.get(&parent.module).unwrap()\n-                                    == module_merged_groups.get(&module).unwrap();\n+                                if let Some((parent, _)) = parent_info {\n+                                    let same_bitmap =\n+                                        module_merged_groups.get(&parent.module).unwrap()\n+                                            == module_merged_groups.get(&module).unwrap();\n \n-                                if same_bitmap {\n-                                    intra_group_references_rev\n-                                        .entry(module)\n-                                        .or_default()\n-                                        .insert(parent.module);\n+                                    if same_bitmap {\n+                                        intra_group_references_rev\n+                                            .entry(module)\n+                                            .or_default()\n+                                            .insert(parent.module);\n+                                    }\n                                 }\n-                            }\n-                            Ok(())\n-                        },\n-                    )?;\n+                                Ok(())\n+                            },\n+                        )?;\n+\n+                        list_lists.push(lists);\n+                    }\n                     Ok(ChunkGroupResult {\n-                        chunk_group_idx,\n-                        lists,\n+                        first_chunk_group_idx,\n+                        list_lists,\n                         lists_reverse_indices,\n                         intra_group_references_rev,\n                     })\n                 },\n             )?;\n \n-            lists = vec![Default::default(); result.len() + 1];\n+            drop(span);\n+            let _span = tracing::info_span!(\"merging chunk group lists\").entered();\n+\n+            lists_reverse_indices\n+                .reserve_exact(result.iter().map(|r| r.lists_reverse_indices.len()).sum());\n+            intra_group_references_rev.reserve_exact(\n+                result\n+                    .iter()\n+                    .map(|r| r.intra_group_references_rev.len())\n+                    .sum(),\n+            );\n+\n+            lists = vec![Default::default(); chunk_group_info.chunk_groups.len() + 1];\n             LISTS_COMMON_IDX = result.len();\n             for ChunkGroupResult {\n-                chunk_group_idx,\n-                lists: result_lists,\n+                first_chunk_group_idx,\n+                list_lists: result_lists,\n                 lists_reverse_indices: result_lists_reverse_indices,\n                 intra_group_references_rev: result_intra_group_references_rev,\n             } in result\n             {\n-                lists[chunk_group_idx] = result_lists;\n+                lists.splice(\n+                    first_chunk_group_idx..(first_chunk_group_idx + result_lists.len()),\n+                    result_lists,\n+                );\n                 for (module, occurrences) in result_lists_reverse_indices {\n                     lists_reverse_indices\n                         .entry(module)"
        }
    ],
    "stats": {
        "total": 229,
        "additions": 142,
        "deletions": 87
    }
}