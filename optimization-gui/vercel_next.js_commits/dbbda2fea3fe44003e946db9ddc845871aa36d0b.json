{
    "author": "unstubbable",
    "message": "[Cache Components] Fix caching in `generateMetadata`/`generateViewport` (#84228)\n\nWhen using `'use cache'` in `generateMetadata` or `generateViewport`,\nthe caching did not work correctly, because we didn't apply the same\nspecial handling for the `params` and `searchParams` props that we do\nfor layout and page components. This caused the following issues:\n\n- `generateMetadata`/`generateViewport` for a page without params, or\nwith static params, yielded cache misses when resuming\n- `generateMetadata` for a page/layout with unused params, became\ndynamic when prerendering a fallback shell\n- `generateMetadata` for a page with used search params, produced a\ntimeout error during prerendering\n- `generateViewport` for a page/layout with unused params, produced a\nbuild error (unless opting into fully dynamic rendering)\n\nStill to be done in a follow-up: Omit unused `params` from cache keys,\nand upgrade cache keys when they are used, to avoid unnecessary cache\nmisses when resuming.\n\ncloses NAR-321",
    "sha": "dbbda2fea3fe44003e946db9ddc845871aa36d0b",
    "files": [
        {
            "sha": "5e0341344893144d94926224c8f68cf19825276c",
            "filename": "packages/next/src/lib/client-and-server-references.ts",
            "status": "modified",
            "additions": 16,
            "deletions": 1,
            "changes": 17,
            "blob_url": "https://github.com/vercel/next.js/blob/dbbda2fea3fe44003e946db9ddc845871aa36d0b/packages%2Fnext%2Fsrc%2Flib%2Fclient-and-server-references.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/dbbda2fea3fe44003e946db9ddc845871aa36d0b/packages%2Fnext%2Fsrc%2Flib%2Fclient-and-server-references.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Flib%2Fclient-and-server-references.ts?ref=dbbda2fea3fe44003e946db9ddc845871aa36d0b",
            "patch": "@@ -1,4 +1,7 @@\n-import { extractInfoFromServerReferenceId } from '../shared/lib/server-reference-info'\n+import {\n+  extractInfoFromServerReferenceId,\n+  type ServerReferenceInfo,\n+} from '../shared/lib/server-reference-info'\n \n // Only contains the properties we're interested in.\n export interface ServerReference {\n@@ -27,6 +30,18 @@ export function isUseCacheFunction<T>(\n   return type === 'use-cache'\n }\n \n+export function getUseCacheFunctionInfo<T>(\n+  value: T & Partial<ServerReference>\n+): ServerReferenceInfo | null {\n+  if (!isServerReference(value)) {\n+    return null\n+  }\n+\n+  const info = extractInfoFromServerReferenceId(value.$$id)\n+\n+  return info.type === 'use-cache' ? info : null\n+}\n+\n export function isClientReference(mod: any): boolean {\n   const defaultExport = mod?.default || mod\n   return defaultExport?.$$typeof === Symbol.for('react.client.reference')"
        },
        {
            "sha": "3cc2741e40ab3d54a57940e437e08a71b07efb00",
            "filename": "packages/next/src/lib/metadata/resolve-metadata.test.ts",
            "status": "modified",
            "additions": 15,
            "deletions": 9,
            "changes": 24,
            "blob_url": "https://github.com/vercel/next.js/blob/dbbda2fea3fe44003e946db9ddc845871aa36d0b/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Fresolve-metadata.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/dbbda2fea3fe44003e946db9ddc845871aa36d0b/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Fresolve-metadata.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Fresolve-metadata.test.ts?ref=dbbda2fea3fe44003e946db9ddc845871aa36d0b",
            "patch": "@@ -46,9 +46,13 @@ function mapUrlsToStrings(obj: any) {\n describe('accumulateMetadata', () => {\n   describe('typing', () => {\n     it('should support both sync and async metadata', async () => {\n+      const generateMetadata = () => Promise.resolve({ description: 'child' })\n       const metadataItems: MetadataItems = [\n         [{ description: 'parent' }, null],\n-        [() => Promise.resolve({ description: 'child' }), null],\n+        [\n+          Object.assign(generateMetadata, { $$original: generateMetadata }),\n+          null,\n+        ],\n       ]\n \n       const metadata = await accumulateMetadata(metadataItems)\n@@ -467,16 +471,18 @@ describe('accumulateMetadata', () => {\n         },\n       })\n \n+      function gM2() {\n+        return {\n+          openGraph: {\n+            images: undefined,\n+          },\n+          // twitter is not specified, supposed to merged with openGraph but images should not be picked up\n+        }\n+      }\n+\n       const metadataItems2: MetadataItems = [\n         [\n-          function gM2() {\n-            return {\n-              openGraph: {\n-                images: undefined,\n-              },\n-              // twitter is not specified, supposed to merged with openGraph but images should not be picked up\n-            }\n-          },\n+          Object.assign(gM2, { $$original: gM2 }),\n           // has static metadata files\n           {\n             icon: undefined,"
        },
        {
            "sha": "f64d76c24925394e940015466a8ec1496dce5e00",
            "filename": "packages/next/src/lib/metadata/resolve-metadata.ts",
            "status": "modified",
            "additions": 137,
            "deletions": 67,
            "changes": 204,
            "blob_url": "https://github.com/vercel/next.js/blob/dbbda2fea3fe44003e946db9ddc845871aa36d0b/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Fresolve-metadata.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/dbbda2fea3fe44003e946db9ddc845871aa36d0b/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Fresolve-metadata.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Fresolve-metadata.ts?ref=dbbda2fea3fe44003e946db9ddc845871aa36d0b",
            "patch": "@@ -23,6 +23,7 @@ import type { ParsedUrlQuery } from 'querystring'\n import type { StaticMetadata } from './types/icons'\n import type { WorkStore } from '../../server/app-render/work-async-storage.external'\n import type { Params } from '../../server/request/params'\n+import type { SearchParams } from '../../server/request/search-params'\n \n // eslint-disable-next-line import/no-extraneous-dependencies\n import 'server-only'\n@@ -58,15 +59,31 @@ import { PAGE_SEGMENT_KEY } from '../../shared/lib/segment'\n import * as Log from '../../build/output/log'\n import { createServerParamsForMetadata } from '../../server/request/params'\n import type { MetadataBaseURL } from './resolvers/resolve-url'\n+import {\n+  getUseCacheFunctionInfo,\n+  isUseCacheFunction,\n+} from '../client-and-server-references'\n+import type {\n+  UseCacheLayoutProps,\n+  UseCachePageProps,\n+} from '../../server/use-cache/use-cache-wrapper'\n+import { createLazyResult } from '../../server/lib/lazy-result'\n \n type StaticIcons = Pick<ResolvedIcons, 'icon' | 'apple'>\n \n-type MetadataResolver = (\n-  parent: ResolvingMetadata\n-) => Metadata | Promise<Metadata>\n-type ViewportResolver = (\n-  parent: ResolvingViewport\n-) => Viewport | Promise<Viewport>\n+type Resolved<T> = T extends Metadata ? ResolvedMetadata : ResolvedViewport\n+\n+type InstrumentedResolver<TData> = ((\n+  parent: Promise<Resolved<TData>>\n+) => TData | Promise<TData>) & {\n+  $$original: (\n+    props: unknown,\n+    parent: Promise<Resolved<TData>>\n+  ) => TData | Promise<TData>\n+}\n+\n+type MetadataResolver = InstrumentedResolver<Metadata>\n+type ViewportResolver = InstrumentedResolver<Viewport>\n \n export type MetadataErrorType = 'not-found' | 'forbidden' | 'unauthorized'\n \n@@ -87,13 +104,17 @@ type BuildState = {\n }\n \n type LayoutProps = {\n-  params: { [key: string]: any }\n+  params: Promise<Params>\n }\n+\n type PageProps = {\n-  params: { [key: string]: any }\n-  searchParams: { [key: string]: any }\n+  params: Promise<Params>\n+  searchParams: Promise<SearchParams>\n }\n \n+type SegmentProps = LayoutProps | PageProps\n+type UseCacheSegmentProps = UseCacheLayoutProps | UseCachePageProps\n+\n function isFavicon(icon: IconDescriptor | undefined): boolean {\n   if (!icon) {\n     return false\n@@ -461,51 +482,77 @@ function mergeViewport({\n \n function getDefinedViewport(\n   mod: any,\n-  props: any,\n+  props: SegmentProps,\n   tracingProps: { route: string }\n ): Viewport | ViewportResolver | null {\n   if (typeof mod.generateViewport === 'function') {\n     const { route } = tracingProps\n-    return (parent: ResolvingViewport) =>\n-      getTracer().trace(\n-        ResolveMetadataSpan.generateViewport,\n-        {\n-          spanName: `generateViewport ${route}`,\n-          attributes: {\n-            'next.page': route,\n+    const segmentProps = createSegmentProps(mod.generateViewport, props)\n+\n+    return Object.assign(\n+      (parent: ResolvingViewport) =>\n+        getTracer().trace(\n+          ResolveMetadataSpan.generateViewport,\n+          {\n+            spanName: `generateViewport ${route}`,\n+            attributes: {\n+              'next.page': route,\n+            },\n           },\n-        },\n-        () => mod.generateViewport(props, parent)\n-      )\n+          () => mod.generateViewport(segmentProps, parent)\n+        ),\n+      { $$original: mod.generateViewport }\n+    )\n   }\n   return mod.viewport || null\n }\n \n function getDefinedMetadata(\n   mod: any,\n-  props: any,\n+  props: SegmentProps,\n   tracingProps: { route: string }\n ): Metadata | MetadataResolver | null {\n   if (typeof mod.generateMetadata === 'function') {\n     const { route } = tracingProps\n-    return (parent: ResolvingMetadata) =>\n-      getTracer().trace(\n-        ResolveMetadataSpan.generateMetadata,\n-        {\n-          spanName: `generateMetadata ${route}`,\n-          attributes: {\n-            'next.page': route,\n+    const segmentProps = createSegmentProps(mod.generateMetadata, props)\n+\n+    return Object.assign(\n+      (parent: ResolvingMetadata) =>\n+        getTracer().trace(\n+          ResolveMetadataSpan.generateMetadata,\n+          {\n+            spanName: `generateMetadata ${route}`,\n+            attributes: {\n+              'next.page': route,\n+            },\n           },\n-        },\n-        () => mod.generateMetadata(props, parent)\n-      )\n+          () => mod.generateMetadata(segmentProps, parent)\n+        ),\n+      { $$original: mod.generateMetadata }\n+    )\n   }\n   return mod.metadata || null\n }\n \n+/**\n+ * If `fn` is a `'use cache'` function, we add special markers to the props,\n+ * that the cache wrapper reads and removes, before passing the props to the\n+ * user function.\n+ */\n+function createSegmentProps(\n+  fn: Function,\n+  props: SegmentProps\n+): SegmentProps | UseCacheSegmentProps {\n+  return isUseCacheFunction(fn)\n+    ? 'searchParams' in props\n+      ? { ...props, $$isPage: true }\n+      : { ...props, $$isLayout: true }\n+    : props\n+}\n+\n async function collectStaticImagesFiles(\n   metadata: AppDirModules['metadata'],\n-  props: any,\n+  props: SegmentProps,\n   type: keyof NonNullable<AppDirModules['metadata']>\n ) {\n   if (!metadata?.[type]) return undefined\n@@ -522,7 +569,7 @@ async function collectStaticImagesFiles(\n \n async function resolveStaticMetadata(\n   modules: AppDirModules,\n-  props: any\n+  props: SegmentProps\n ): Promise<StaticMetadata> {\n   const { metadata } = modules\n   if (!metadata) return null\n@@ -557,7 +604,7 @@ async function collectMetadata({\n   tree: LoaderTree\n   metadataItems: MetadataItems\n   errorMetadataItem: MetadataItems[number]\n-  props: any\n+  props: SegmentProps\n   route: string\n   errorConvention?: MetadataErrorType\n }) {\n@@ -608,7 +655,7 @@ async function collectViewport({\n   tree: LoaderTree\n   viewportItems: ViewportItems\n   errorViewportItemRef: ErrorViewportItemRef\n-  props: any\n+  props: SegmentProps\n   route: string\n   errorConvention?: MetadataErrorType\n }) {\n@@ -700,25 +747,14 @@ async function resolveMetadataItemsImpl(\n   }\n \n   const params = createServerParamsForMetadata(currentParams, workStore)\n-\n-  let layerProps: LayoutProps | PageProps\n-  if (isPage) {\n-    layerProps = {\n-      params,\n-      searchParams,\n-    }\n-  } else {\n-    layerProps = {\n-      params,\n-    }\n-  }\n+  const props: SegmentProps = isPage ? { params, searchParams } : { params }\n \n   await collectMetadata({\n     tree,\n     metadataItems,\n     errorMetadataItem,\n     errorConvention,\n-    props: layerProps,\n+    props,\n     route: currentTreePrefix\n       // __PAGE__ shouldn't be shown in a route\n       .filter((s) => s !== PAGE_SEGMENT_KEY)\n@@ -963,7 +999,7 @@ function prerenderMetadata(metadataItems: MetadataItems) {\n   > = []\n   for (let i = 0; i < metadataItems.length; i++) {\n     const metadataExport = metadataItems[i][0]\n-    getResult(resolversAndResults, metadataExport)\n+    getResult<Metadata>(resolversAndResults, metadataExport)\n   }\n   return resolversAndResults\n }\n@@ -977,32 +1013,66 @@ function prerenderViewport(viewportItems: ViewportItems) {\n   > = []\n   for (let i = 0; i < viewportItems.length; i++) {\n     const viewportExport = viewportItems[i]\n-    getResult(resolversAndResults, viewportExport)\n+    getResult<Viewport>(resolversAndResults, viewportExport)\n   }\n   return resolversAndResults\n }\n \n-type Resolved<T> = T extends Metadata ? ResolvedMetadata : ResolvedViewport\n+const noop = () => {}\n \n-function getResult<T extends Metadata | Viewport>(\n-  resolversAndResults: Array<((value: Resolved<T>) => void) | Result<T>>,\n-  exportForResult: null | T | ((parent: Promise<Resolved<T>>) => Result<T>)\n+function getResult<TData extends object>(\n+  resolversAndResults: Array<\n+    ((value: Resolved<TData>) => void) | Result<TData>\n+  >,\n+  exportForResult: null | TData | InstrumentedResolver<TData>\n ) {\n   if (typeof exportForResult === 'function') {\n-    const result = exportForResult(\n-      new Promise<Resolved<T>>((resolve) => resolversAndResults.push(resolve))\n+    // If the function is a 'use cache' function that uses the parent data as\n+    // the second argument, we don't want to eagerly execute it during\n+    // metadata/viewport pre-rendering, as the parent data might also be\n+    // computed from another 'use cache' function. To ensure that the hanging\n+    // input abort signal handling works in this case (i.e. the depending\n+    // function waits for the cached input to resolve while encoding its args),\n+    // they must be called sequentially. This can be accomplished by wrapping\n+    // the call in a lazy promise, so that the original function is only called\n+    // when the result is actually awaited.\n+    const useCacheFunctionInfo = getUseCacheFunctionInfo(\n+      exportForResult.$$original\n     )\n-    resolversAndResults.push(result)\n-    if (result instanceof Promise) {\n-      // since we eager execute generateMetadata and\n-      // they can reject at anytime we need to ensure\n-      // we attach the catch handler right away to\n-      // prevent unhandled rejections crashing the process\n-      result.catch((err) => {\n-        return {\n-          __nextError: err,\n-        }\n-      })\n+    if (useCacheFunctionInfo && useCacheFunctionInfo.usedArgs[1]) {\n+      const promise = new Promise<Resolved<TData>>((resolve) =>\n+        resolversAndResults.push(resolve)\n+      )\n+      resolversAndResults.push(\n+        createLazyResult(async () => exportForResult(promise))\n+      )\n+    } else {\n+      let result: TData | Promise<TData>\n+      if (useCacheFunctionInfo) {\n+        resolversAndResults.push(noop)\n+        // @ts-expect-error We intentionally omit the parent argument, because\n+        // we know from the check above that the 'use cache' function does not\n+        // use it.\n+        result = exportForResult()\n+      } else {\n+        result = exportForResult(\n+          new Promise<Resolved<TData>>((resolve) =>\n+            resolversAndResults.push(resolve)\n+          )\n+        )\n+      }\n+      resolversAndResults.push(result)\n+      if (result instanceof Promise) {\n+        // since we eager execute generateMetadata and\n+        // they can reject at anytime we need to ensure\n+        // we attach the catch handler right away to\n+        // prevent unhandled rejections crashing the process\n+        result.catch((err) => {\n+          return {\n+            __nextError: err,\n+          }\n+        })\n+      }\n     }\n   } else if (typeof exportForResult === 'object') {\n     resolversAndResults.push(exportForResult)"
        },
        {
            "sha": "03421196818488a268c7697ba8f3ca2a300ca3b7",
            "filename": "packages/next/src/lib/metadata/types/metadata-interface.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/dbbda2fea3fe44003e946db9ddc845871aa36d0b/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Ftypes%2Fmetadata-interface.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/dbbda2fea3fe44003e946db9ddc845871aa36d0b/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Ftypes%2Fmetadata-interface.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Ftypes%2Fmetadata-interface.ts?ref=dbbda2fea3fe44003e946db9ddc845871aa36d0b",
            "patch": "@@ -785,13 +785,13 @@ interface Viewport extends ViewportLayout {\n   colorScheme?: null | ColorSchemeEnum | undefined\n }\n \n-type ResolvingViewport = Promise<Viewport>\n-\n interface ResolvedViewport extends ViewportLayout {\n   themeColor: null | ThemeColorDescriptor[]\n   colorScheme: null | ColorSchemeEnum\n }\n \n+type ResolvingViewport = Promise<ResolvedViewport>\n+\n export type {\n   Metadata,\n   ResolvedMetadata,"
        },
        {
            "sha": "5ae8282c07d55bccebe508abe38c6126a27f2dc5",
            "filename": "packages/next/src/server/app-render/create-component-tree.tsx",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/dbbda2fea3fe44003e946db9ddc845871aa36d0b/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcreate-component-tree.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/dbbda2fea3fe44003e946db9ddc845871aa36d0b/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcreate-component-tree.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcreate-component-tree.tsx?ref=dbbda2fea3fe44003e946db9ddc845871aa36d0b",
            "patch": "@@ -25,8 +25,8 @@ import type { Params } from '../request/params'\n import { workUnitAsyncStorage } from './work-unit-async-storage.external'\n import { OUTLET_BOUNDARY_NAME } from '../../lib/framework/boundary-constants'\n import type {\n-  UseCacheLayoutComponentProps,\n-  UseCachePageComponentProps,\n+  UseCacheLayoutProps,\n+  UseCachePageProps,\n } from '../use-cache/use-cache-wrapper'\n import { DEFAULT_SEGMENT_KEY } from '../../shared/lib/segment'\n import {\n@@ -793,14 +793,14 @@ async function createComponentTreeInternal(\n       let searchParams = createServerSearchParamsForServerPage(query, workStore)\n \n       if (isUseCacheFunction(PageComponent)) {\n-        const UseCachePageComponent: React.ComponentType<UseCachePageComponentProps> =\n+        const UseCachePageComponent: React.ComponentType<UseCachePageProps> =\n           PageComponent\n \n         pageElement = (\n           <UseCachePageComponent\n             params={params}\n             searchParams={searchParams}\n-            $$isPageComponent\n+            $$isPage\n           />\n         )\n       } else {\n@@ -951,14 +951,14 @@ async function createComponentTreeInternal(\n       let serverSegment: React.ReactNode\n \n       if (isUseCacheFunction(SegmentComponent)) {\n-        const UseCacheLayoutComponent: React.ComponentType<UseCacheLayoutComponentProps> =\n+        const UseCacheLayoutComponent: React.ComponentType<UseCacheLayoutProps> =\n           SegmentComponent\n \n         serverSegment = (\n           <UseCacheLayoutComponent\n             {...parallelRouteProps}\n             params={params}\n-            $$isLayoutComponent\n+            $$isLayout\n           />\n         )\n       } else {"
        },
        {
            "sha": "ff79577ea9ea629db69d770fd8849469bbf72710",
            "filename": "packages/next/src/server/use-cache/use-cache-wrapper.ts",
            "status": "modified",
            "additions": 88,
            "deletions": 69,
            "changes": 157,
            "blob_url": "https://github.com/vercel/next.js/blob/dbbda2fea3fe44003e946db9ddc845871aa36d0b/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/dbbda2fea3fe44003e946db9ddc845871aa36d0b/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts?ref=dbbda2fea3fe44003e946db9ddc845871aa36d0b",
            "patch": "@@ -91,20 +91,20 @@ type CacheKeyParts =\n   | [buildId: string, id: string, args: unknown[]]\n   | [buildId: string, id: string, args: unknown[], hmrRefreshHash: string]\n \n-interface UseCacheInnerPageComponentProps {\n+interface UseCachePageInnerProps {\n   params: Promise<Params>\n   searchParams?: Promise<SearchParams>\n }\n \n-export interface UseCachePageComponentProps {\n+export interface UseCachePageProps {\n   params: Promise<Params>\n   searchParams: Promise<SearchParams>\n-  $$isPageComponent: true\n+  $$isPage: true\n }\n \n-export type UseCacheLayoutComponentProps = {\n+export type UseCacheLayoutProps = {\n   params: Promise<Params>\n-  $$isLayoutComponent: true\n+  $$isLayout: true\n } & {\n   // The value type should be React.ReactNode. But such an index signature would\n   // be incompatible with the other two props.\n@@ -995,25 +995,29 @@ export function cache(\n         }\n       }\n \n-      let isPageOrLayout = false\n-\n-      // For page and layout components, the cache function is overwritten,\n-      // which allows us to apply special handling for params and searchParams.\n-      // For pages and layouts we're using the outer params prop, and not the\n-      // inner one that was serialized/deserialized. While it's not generally\n-      // true for \"use cache\" args, in the case of `params` the inner and outer\n-      // object are essentially equivalent, so this is safe to do (including\n-      // fallback params that are hanging promises). It allows us to avoid\n-      // waiting for the timeout, when prerendering a fallback shell of a cached\n-      // page or layout that awaits params.\n-      if (isPageComponent(args)) {\n-        isPageOrLayout = true\n-\n-        const [{ params: outerParams, searchParams: outerSearchParams }] = args\n-\n-        const props: UseCacheInnerPageComponentProps = {\n+      let isPageOrLayoutSegmentFunction = false\n+\n+      // For page and layout segment functions (i.e. the page/layout component,\n+      // or generateMetadata/generateViewport), the cache function is\n+      // overwritten, which allows us to apply special handling for params and\n+      // searchParams. For pages and layouts we're using the outer params prop,\n+      // and not the inner one that was serialized/deserialized. While it's not\n+      // generally true for \"use cache\" args, in the case of `params` the inner\n+      // and outer object are essentially equivalent, so this is safe to do\n+      // (including fallback params that are hanging promises). It allows us to\n+      // avoid waiting for the timeout, when prerendering a fallback shell of a\n+      // cached page or layout that awaits params.\n+      if (isPageSegmentFunction(args)) {\n+        isPageOrLayoutSegmentFunction = true\n+\n+        const [\n+          { params: outerParams, searchParams: outerSearchParams },\n+          ...otherOuterArgs\n+        ] = args\n+\n+        const props: UseCachePageInnerProps = {\n           params: outerParams,\n-          // Omit searchParams and $$isPageComponent.\n+          // Omit searchParams and $$isPage.\n         }\n \n         if (isPrivate) {\n@@ -1022,13 +1026,16 @@ export function cache(\n           props.searchParams = outerSearchParams\n         }\n \n-        args = [props]\n+        args = [props, ...otherOuterArgs]\n \n         fn = {\n-          [name]: async ({\n-            params: _innerParams,\n-            searchParams: innerSearchParams,\n-          }: UseCacheInnerPageComponentProps) =>\n+          [name]: async (\n+            {\n+              params: _innerParams,\n+              searchParams: innerSearchParams,\n+            }: UseCachePageInnerProps,\n+            ...otherInnerArgs: unknown[]\n+          ) =>\n             originalFn.apply(null, [\n               {\n                 params: outerParams,\n@@ -1043,22 +1050,36 @@ export function cache(\n                   // need to ensure that an error is shown.\n                   makeErroringSearchParamsForUseCache(workStore),\n               },\n+              ...otherInnerArgs,\n             ]),\n         }[name] as (...args: unknown[]) => Promise<unknown>\n-      } else if (isLayoutComponent(args)) {\n-        isPageOrLayout = true\n+      } else if (isLayoutSegmentFunction(args)) {\n+        isPageOrLayoutSegmentFunction = true\n \n-        const [{ params: outerParams, $$isLayoutComponent, ...outerSlots }] =\n-          args\n-        // Overwrite the props to omit $$isLayoutComponent.\n-        args = [{ params: outerParams, ...outerSlots }]\n+        const [\n+          { params: outerParams, $$isLayout, ...outerSlots },\n+          ...otherOuterArgs\n+        ] = args\n+\n+        // Overwrite the props to omit $$isLayout. Note that slots are only\n+        // passed to the layout component (if any are defined), and not to\n+        // generateMetadata nor generateViewport. For those functions,\n+        // outerSlots/innerSlots is an empty object, which is fine because we're\n+        // just spreading it into the props.\n+        args = [{ params: outerParams, ...outerSlots }, ...otherOuterArgs]\n \n         fn = {\n-          [name]: async ({\n-            params: _innerParams,\n-            ...innerSlots\n-          }: Omit<UseCacheLayoutComponentProps, '$$isLayoutComponent'>) =>\n-            originalFn.apply(null, [{ params: outerParams, ...innerSlots }]),\n+          [name]: async (\n+            {\n+              params: _innerParams,\n+              ...innerSlots\n+            }: Omit<UseCacheLayoutProps, '$$isLayout'>,\n+            ...otherInnerArgs: unknown[]\n+          ) =>\n+            originalFn.apply(null, [\n+              { params: outerParams, ...innerSlots },\n+              ...otherInnerArgs,\n+            ]),\n         }[name] as (...args: unknown[]) => Promise<unknown>\n       }\n \n@@ -1120,14 +1141,14 @@ export function cache(\n         //\n         // fallthrough\n         case 'prerender':\n-          if (!isPageOrLayout) {\n-            // If the \"use cache\" function is not a page or a layout, we need to\n-            // track dynamic access already when encoding the arguments. If\n-            // params are passed explicitly into a \"use cache\" function (as\n-            // opposed to receiving them automatically in a page or layout), we\n-            // assume that the params are also accessed. This allows us to abort\n-            // early, and treat the function as dynamic, instead of waiting for\n-            // the timeout to be reached.\n+          if (!isPageOrLayoutSegmentFunction) {\n+            // If the \"use cache\" function is not a page or layout segment\n+            // function, we need to track dynamic access already when encoding\n+            // the arguments. If params are passed explicitly into a \"use cache\"\n+            // function (as opposed to receiving them automatically in a page or\n+            // layout), we assume that the params are also accessed. This allows\n+            // us to abort early, and treat the function as dynamic, instead of\n+            // waiting for the timeout to be reached.\n             const dynamicAccessAbortController = new AbortController()\n \n             encodedCacheKeyParts = await dynamicAccessAsyncStorage.run(\n@@ -1600,37 +1621,35 @@ export function cache(\n   return React.cache(cachedFn)\n }\n \n-function isPageComponent(\n+/**\n+ * Returns `true` if the `'use cache'` function is the page component itself,\n+ * or `generateMetadata`/`generateViewport` in a page file.\n+ */\n+function isPageSegmentFunction(\n   args: any[]\n-): args is [UseCachePageComponentProps, undefined] {\n-  if (args.length !== 2) {\n-    return false\n-  }\n-\n-  const [props, ref] = args\n+): args is [UseCachePageProps, ...unknown[]] {\n+  const [maybeProps] = args\n \n   return (\n-    ref === undefined && // server components receive an undefined ref arg\n-    props !== null &&\n-    typeof props === 'object' &&\n-    (props as UseCachePageComponentProps).$$isPageComponent\n+    maybeProps !== null &&\n+    typeof maybeProps === 'object' &&\n+    (maybeProps as UseCachePageProps).$$isPage === true\n   )\n }\n \n-function isLayoutComponent(\n+/**\n+ * Returns `true` if the `'use cache'` function is the layout component itself,\n+ * or `generateMetadata`/`generateViewport` in a layout file.\n+ */\n+function isLayoutSegmentFunction(\n   args: any[]\n-): args is [UseCacheLayoutComponentProps, undefined] {\n-  if (args.length !== 2) {\n-    return false\n-  }\n-\n-  const [props, ref] = args\n+): args is [UseCacheLayoutProps, ...unknown[]] {\n+  const [maybeProps] = args\n \n   return (\n-    ref === undefined && // server components receive an undefined ref arg\n-    props !== null &&\n-    typeof props === 'object' &&\n-    (props as UseCacheLayoutComponentProps).$$isLayoutComponent\n+    maybeProps !== null &&\n+    typeof maybeProps === 'object' &&\n+    (maybeProps as UseCacheLayoutProps).$$isLayout === true\n   )\n }\n "
        },
        {
            "sha": "4fabef65c95e3894db3cdf7ddca6b9024e52f7dc",
            "filename": "test/e2e/app-dir/use-cache-search-params/app/search-params-used-generate-metadata/page.tsx",
            "status": "added",
            "additions": 16,
            "deletions": 0,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/dbbda2fea3fe44003e946db9ddc845871aa36d0b/test%2Fe2e%2Fapp-dir%2Fuse-cache-search-params%2Fapp%2Fsearch-params-used-generate-metadata%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/dbbda2fea3fe44003e946db9ddc845871aa36d0b/test%2Fe2e%2Fapp-dir%2Fuse-cache-search-params%2Fapp%2Fsearch-params-used-generate-metadata%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache-search-params%2Fapp%2Fsearch-params-used-generate-metadata%2Fpage.tsx?ref=dbbda2fea3fe44003e946db9ddc845871aa36d0b",
            "patch": "@@ -0,0 +1,16 @@\n+import { Metadata } from 'next'\n+\n+export async function generateMetadata({\n+  searchParams,\n+}: {\n+  searchParams: Promise<Record<string, string | string[] | undefined>>\n+}): Promise<Metadata> {\n+  'use cache'\n+  const title = (await searchParams).title\n+\n+  return { title: String(title) }\n+}\n+\n+export default function Page() {\n+  return null\n+}"
        },
        {
            "sha": "31e9e91a35a004adbd121bfee0252f507481848d",
            "filename": "test/e2e/app-dir/use-cache-search-params/app/search-params-used-generate-viewport/page.tsx",
            "status": "added",
            "additions": 16,
            "deletions": 0,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/dbbda2fea3fe44003e946db9ddc845871aa36d0b/test%2Fe2e%2Fapp-dir%2Fuse-cache-search-params%2Fapp%2Fsearch-params-used-generate-viewport%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/dbbda2fea3fe44003e946db9ddc845871aa36d0b/test%2Fe2e%2Fapp-dir%2Fuse-cache-search-params%2Fapp%2Fsearch-params-used-generate-viewport%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache-search-params%2Fapp%2Fsearch-params-used-generate-viewport%2Fpage.tsx?ref=dbbda2fea3fe44003e946db9ddc845871aa36d0b",
            "patch": "@@ -0,0 +1,16 @@\n+import { Viewport } from 'next'\n+\n+export async function generateViewport({\n+  searchParams,\n+}: {\n+  searchParams: Promise<Record<string, string | string[] | undefined>>\n+}): Promise<Viewport> {\n+  'use cache'\n+  const color = (await searchParams).color\n+\n+  return { themeColor: String(color) }\n+}\n+\n+export default function Page() {\n+  return null\n+}"
        },
        {
            "sha": "76bca9a17a1e42a78c846cf1f93db737107c1daa",
            "filename": "test/e2e/app-dir/use-cache-search-params/use-cache-search-params.test.ts",
            "status": "modified",
            "additions": 40,
            "deletions": 0,
            "changes": 40,
            "blob_url": "https://github.com/vercel/next.js/blob/dbbda2fea3fe44003e946db9ddc845871aa36d0b/test%2Fe2e%2Fapp-dir%2Fuse-cache-search-params%2Fuse-cache-search-params.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/dbbda2fea3fe44003e946db9ddc845871aa36d0b/test%2Fe2e%2Fapp-dir%2Fuse-cache-search-params%2Fuse-cache-search-params.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache-search-params%2Fuse-cache-search-params.test.ts?ref=dbbda2fea3fe44003e946db9ddc845871aa36d0b",
            "patch": "@@ -128,6 +128,46 @@ describe('use-cache-search-params', () => {\n         expect(cliOutput).not.toContain(getExpectedErrorMessage(route))\n       })\n     })\n+\n+    it('should show an error when searchParams are used inside of a cached generateMetadata', async () => {\n+      const browser = await next.browser(\n+        '/search-params-used-generate-metadata?title=foo'\n+      )\n+\n+      await expect(browser).toDisplayRedbox(`\n+       {\n+         \"description\": \"Route /search-params-used-generate-metadata used \\`searchParams\\` inside \"use cache\". Accessing dynamic request data inside a cache scope is not supported. If you need some search params inside a cached function await \\`searchParams\\` outside of the cached function and pass only the required search params as arguments to the cached function. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\",\n+         \"environmentLabel\": null,\n+         \"label\": \"Runtime Error\",\n+         \"source\": \"app/search-params-used-generate-metadata/page.tsx (9:17) @ generateMetadata\n+       >  9 |   const title = (await searchParams).title\n+            |                 ^\",\n+         \"stack\": [\n+           \"generateMetadata app/search-params-used-generate-metadata/page.tsx (9:17)\",\n+         ],\n+       }\n+      `)\n+    })\n+\n+    it('should show an error when searchParams are used inside of a cached generateViewport', async () => {\n+      const browser = await next.browser(\n+        '/search-params-used-generate-viewport?color=red'\n+      )\n+\n+      await expect(browser).toDisplayRedbox(`\n+       {\n+         \"description\": \"Route /search-params-used-generate-viewport used \\`searchParams\\` inside \"use cache\". Accessing dynamic request data inside a cache scope is not supported. If you need some search params inside a cached function await \\`searchParams\\` outside of the cached function and pass only the required search params as arguments to the cached function. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\",\n+         \"environmentLabel\": null,\n+         \"label\": \"Runtime Error\",\n+         \"source\": \"app/search-params-used-generate-viewport/page.tsx (9:17) @ generateViewport\n+       >  9 |   const color = (await searchParams).color\n+            |                 ^\",\n+         \"stack\": [\n+           \"generateViewport app/search-params-used-generate-viewport/page.tsx (9:17)\",\n+         ],\n+       }\n+      `)\n+    })\n   } else {\n     afterEach(async () => {\n       await next.stop()"
        },
        {
            "sha": "74d7ef3ca0aabee43a367d5c2777c4f44225ceeb",
            "filename": "test/e2e/app-dir/use-cache/app/(dynamic)/generate-viewport-resume/params-used/[color]/layout.tsx",
            "status": "added",
            "additions": 34,
            "deletions": 0,
            "changes": 34,
            "blob_url": "https://github.com/vercel/next.js/blob/dbbda2fea3fe44003e946db9ddc845871aa36d0b/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(dynamic)%2Fgenerate-viewport-resume%2Fparams-used%2F%5Bcolor%5D%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/dbbda2fea3fe44003e946db9ddc845871aa36d0b/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(dynamic)%2Fgenerate-viewport-resume%2Fparams-used%2F%5Bcolor%5D%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(dynamic)%2Fgenerate-viewport-resume%2Fparams-used%2F%5Bcolor%5D%2Flayout.tsx?ref=dbbda2fea3fe44003e946db9ddc845871aa36d0b",
            "patch": "@@ -0,0 +1,34 @@\n+import { Viewport } from 'next'\n+\n+export async function generateViewport({\n+  params,\n+}: {\n+  params: Promise<{ color: string }>\n+}): Promise<Viewport> {\n+  'use cache: remote'\n+\n+  // Use `eval` to side step compiler errors for using `arguments` in a 'use\n+  // cache' function.\n+  // eslint-disable-next-line no-eval\n+  const unusedParentArg = eval('arguments')[1]\n+  if (unusedParentArg !== undefined) {\n+    throw new Error(\n+      'Expected the unused parent argument to be omitted. Received: ' +\n+        unusedParentArg\n+    )\n+  }\n+\n+  // We're reading params here. This makes the cache function dynamic during\n+  // prerendering. It also requires suspense above body, so nothing will\n+  // prerendered. The meta tag should still be cached on refreshes though.\n+  const { color } = await params\n+\n+  return {\n+    colorScheme: color === 'white' ? 'light' : 'dark',\n+    maximumScale: 1 + Math.random(),\n+  }\n+}\n+\n+export default function Layout({ children }: { children: React.ReactNode }) {\n+  return <main>{children}</main>\n+}"
        },
        {
            "sha": "977d3ff55df8ef516feaae2a6efb3bed75a1486c",
            "filename": "test/e2e/app-dir/use-cache/app/(dynamic)/generate-viewport-resume/params-used/[color]/page.tsx",
            "status": "added",
            "additions": 43,
            "deletions": 0,
            "changes": 43,
            "blob_url": "https://github.com/vercel/next.js/blob/dbbda2fea3fe44003e946db9ddc845871aa36d0b/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(dynamic)%2Fgenerate-viewport-resume%2Fparams-used%2F%5Bcolor%5D%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/dbbda2fea3fe44003e946db9ddc845871aa36d0b/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(dynamic)%2Fgenerate-viewport-resume%2Fparams-used%2F%5Bcolor%5D%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(dynamic)%2Fgenerate-viewport-resume%2Fparams-used%2F%5Bcolor%5D%2Fpage.tsx?ref=dbbda2fea3fe44003e946db9ddc845871aa36d0b",
            "patch": "@@ -0,0 +1,43 @@\n+import { Viewport } from 'next'\n+import { connection } from 'next/server'\n+import { Suspense } from 'react'\n+\n+export async function generateViewport({\n+  params,\n+}: {\n+  params: Promise<{ color: string }>\n+}): Promise<Viewport> {\n+  'use cache: remote'\n+\n+  // Use `eval` to side step compiler errors for using `arguments` in a 'use\n+  // cache' function.\n+  // eslint-disable-next-line no-eval\n+  const unusedParentArg = eval('arguments')[1]\n+  if (unusedParentArg !== undefined) {\n+    throw new Error(\n+      'Expected the unused parent argument to be omitted. Received: ' +\n+        unusedParentArg\n+    )\n+  }\n+\n+  // We're reading params here. This makes the cache function dynamic during\n+  // prerendering. It also requires suspense above body, so nothing will\n+  // prerendered. The meta tag should still be cached on refreshes though.\n+  const { color } = await params\n+\n+  return { themeColor: color, initialScale: Math.random() }\n+}\n+\n+export default function Page() {\n+  return (\n+    <Suspense fallback={<p>Loading...</p>}>\n+      <Dynamic />\n+    </Suspense>\n+  )\n+}\n+\n+async function Dynamic() {\n+  await connection()\n+\n+  return <p>Dynamic</p>\n+}"
        },
        {
            "sha": "5b49ed1da17d7067be0fc649d851eef5edeb97d8",
            "filename": "test/e2e/app-dir/use-cache/app/(partially-static)/generate-metadata-resume/canonical/[slug]/layout.tsx",
            "status": "added",
            "additions": 24,
            "deletions": 0,
            "changes": 24,
            "blob_url": "https://github.com/vercel/next.js/blob/dbbda2fea3fe44003e946db9ddc845871aa36d0b/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(partially-static)%2Fgenerate-metadata-resume%2Fcanonical%2F%5Bslug%5D%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/dbbda2fea3fe44003e946db9ddc845871aa36d0b/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(partially-static)%2Fgenerate-metadata-resume%2Fcanonical%2F%5Bslug%5D%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(partially-static)%2Fgenerate-metadata-resume%2Fcanonical%2F%5Bslug%5D%2Flayout.tsx?ref=dbbda2fea3fe44003e946db9ddc845871aa36d0b",
            "patch": "@@ -0,0 +1,24 @@\n+import { Metadata, ResolvingMetadata } from 'next'\n+\n+export async function generateMetadata(\n+  _: { params: Promise<{ slug: string }> },\n+  parent: ResolvingMetadata\n+): Promise<Metadata> {\n+  'use cache'\n+\n+  // We're not reading params here, but we do define a canonical URL, which\n+  // leads to the pathname being read under the hood. This should make the\n+  // function dynamic when prerendering the fallback shell, and not lead to a\n+  // timeout error.\n+\n+  const { metadataBase } = await parent\n+\n+  return {\n+    // We can not return a URL instance from a `'use cache'` function.\n+    metadataBase: metadataBase?.replace('/foo', '/bar'),\n+  }\n+}\n+\n+export default function Layout({ children }: { children: React.ReactNode }) {\n+  return <>{children}</>\n+}"
        },
        {
            "sha": "4d8caa167bba646aeb0b406518bf0797314b6e29",
            "filename": "test/e2e/app-dir/use-cache/app/(partially-static)/generate-metadata-resume/canonical/[slug]/page.tsx",
            "status": "added",
            "additions": 36,
            "deletions": 0,
            "changes": 36,
            "blob_url": "https://github.com/vercel/next.js/blob/dbbda2fea3fe44003e946db9ddc845871aa36d0b/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(partially-static)%2Fgenerate-metadata-resume%2Fcanonical%2F%5Bslug%5D%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/dbbda2fea3fe44003e946db9ddc845871aa36d0b/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(partially-static)%2Fgenerate-metadata-resume%2Fcanonical%2F%5Bslug%5D%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(partially-static)%2Fgenerate-metadata-resume%2Fcanonical%2F%5Bslug%5D%2Fpage.tsx?ref=dbbda2fea3fe44003e946db9ddc845871aa36d0b",
            "patch": "@@ -0,0 +1,36 @@\n+import { Metadata, ResolvingMetadata } from 'next'\n+import { connection } from 'next/server'\n+import { Suspense } from 'react'\n+\n+export async function generateMetadata(\n+  _: { params: Promise<{ slug: string }> },\n+  parent: ResolvingMetadata\n+): Promise<Metadata> {\n+  'use cache'\n+\n+  // We're not reading params here, but we do define a canonical URL, which\n+  // leads to the pathname being read under the hood. This should make the\n+  // function dynamic when prerendering the fallback shell, and not lead to a\n+  // timeout error.\n+\n+  const { metadataBase } = await parent\n+\n+  return {\n+    metadataBase: metadataBase?.replace('/bar', '/baz'),\n+    alternates: { canonical: '/qux' },\n+  }\n+}\n+\n+export default function Page() {\n+  return (\n+    <Suspense fallback={<p>Loading...</p>}>\n+      <Dynamic />\n+    </Suspense>\n+  )\n+}\n+\n+async function Dynamic() {\n+  await connection()\n+\n+  return <p>Dynamic</p>\n+}"
        },
        {
            "sha": "b596dd60215f89fb9358f54d21376aca45442bd4",
            "filename": "test/e2e/app-dir/use-cache/app/(partially-static)/generate-metadata-resume/layout.tsx",
            "status": "added",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/dbbda2fea3fe44003e946db9ddc845871aa36d0b/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(partially-static)%2Fgenerate-metadata-resume%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/dbbda2fea3fe44003e946db9ddc845871aa36d0b/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(partially-static)%2Fgenerate-metadata-resume%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(partially-static)%2Fgenerate-metadata-resume%2Flayout.tsx?ref=dbbda2fea3fe44003e946db9ddc845871aa36d0b",
            "patch": "@@ -0,0 +1,9 @@\n+import { Metadata } from 'next'\n+\n+export const metadata: Metadata = {\n+  metadataBase: new URL('https://example.com/foo'),\n+}\n+\n+export default function Layout({ children }: { children: React.ReactNode }) {\n+  return <main>{children}</main>\n+}"
        },
        {
            "sha": "e05ea2f0e83ea42125ffb28bff7c1031c077491e",
            "filename": "test/e2e/app-dir/use-cache/app/(partially-static)/generate-metadata-resume/nested/layout.tsx",
            "status": "added",
            "additions": 20,
            "deletions": 0,
            "changes": 20,
            "blob_url": "https://github.com/vercel/next.js/blob/dbbda2fea3fe44003e946db9ddc845871aa36d0b/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(partially-static)%2Fgenerate-metadata-resume%2Fnested%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/dbbda2fea3fe44003e946db9ddc845871aa36d0b/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(partially-static)%2Fgenerate-metadata-resume%2Fnested%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(partially-static)%2Fgenerate-metadata-resume%2Fnested%2Flayout.tsx?ref=dbbda2fea3fe44003e946db9ddc845871aa36d0b",
            "patch": "@@ -0,0 +1,20 @@\n+import { Metadata, ResolvingMetadata } from 'next'\n+\n+export async function generateMetadata(\n+  _: {},\n+  parent: ResolvingMetadata\n+): Promise<Metadata> {\n+  'use cache'\n+\n+  const { metadataBase } = await parent\n+\n+  return {\n+    description: new Date().toISOString(),\n+    // We can not return a URL instance from a `'use cache'` function.\n+    metadataBase: metadataBase?.replace('/foo', '/bar'),\n+  }\n+}\n+\n+export default function Layout({ children }: { children: React.ReactNode }) {\n+  return <>{children}</>\n+}"
        },
        {
            "sha": "2e1a56a0dff325587bdcdbef5d24577c2df86241",
            "filename": "test/e2e/app-dir/use-cache/app/(partially-static)/generate-metadata-resume/nested/page.tsx",
            "status": "added",
            "additions": 36,
            "deletions": 0,
            "changes": 36,
            "blob_url": "https://github.com/vercel/next.js/blob/dbbda2fea3fe44003e946db9ddc845871aa36d0b/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(partially-static)%2Fgenerate-metadata-resume%2Fnested%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/dbbda2fea3fe44003e946db9ddc845871aa36d0b/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(partially-static)%2Fgenerate-metadata-resume%2Fnested%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(partially-static)%2Fgenerate-metadata-resume%2Fnested%2Fpage.tsx?ref=dbbda2fea3fe44003e946db9ddc845871aa36d0b",
            "patch": "@@ -0,0 +1,36 @@\n+import { Metadata, ResolvingMetadata } from 'next'\n+import { connection } from 'next/server'\n+import { Suspense } from 'react'\n+\n+export async function generateMetadata(\n+  _: { searchParams: Promise<Record<string, string | string[] | undefined>> },\n+  parent: ResolvingMetadata\n+): Promise<Metadata> {\n+  'use cache'\n+\n+  // Explicitly not reading search params here. The search params should be\n+  // omitted from the cache key, so that we ensure a cache hit when resuming the\n+  // partially prerendered page.\n+\n+  const { metadataBase } = await parent\n+\n+  return {\n+    title: new Date().toISOString(),\n+    metadataBase: metadataBase?.replace('/bar', '/baz'),\n+    alternates: { canonical: '/qux' },\n+  }\n+}\n+\n+export default function Page() {\n+  return (\n+    <Suspense fallback={<p>Loading...</p>}>\n+      <Dynamic />\n+    </Suspense>\n+  )\n+}\n+\n+async function Dynamic() {\n+  await connection()\n+\n+  return <p>Dynamic</p>\n+}"
        },
        {
            "sha": "1a3443f66a5dec3ce69c25cfcb07f6c34d88907a",
            "filename": "test/e2e/app-dir/use-cache/app/(partially-static)/generate-metadata-resume/params-unused/[slug]/layout.tsx",
            "status": "added",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/dbbda2fea3fe44003e946db9ddc845871aa36d0b/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(partially-static)%2Fgenerate-metadata-resume%2Fparams-unused%2F%5Bslug%5D%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/dbbda2fea3fe44003e946db9ddc845871aa36d0b/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(partially-static)%2Fgenerate-metadata-resume%2Fparams-unused%2F%5Bslug%5D%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(partially-static)%2Fgenerate-metadata-resume%2Fparams-unused%2F%5Bslug%5D%2Flayout.tsx?ref=dbbda2fea3fe44003e946db9ddc845871aa36d0b",
            "patch": "@@ -0,0 +1,18 @@\n+import { Metadata } from 'next'\n+\n+export async function generateMetadata(_: {\n+  params: Promise<{ slug: string }>\n+}): Promise<Metadata> {\n+  'use cache'\n+\n+  // Explicitly not reading params here. The description should appear in the\n+  // partially prerendered page. TODO: When resuming the page, we should get a\n+  // cache hit (from the RDC), but omitting unused params from cache keys (and\n+  // upgrading cache keys when they are used) is not yet implemented.\n+\n+  return { description: new Date().toISOString() }\n+}\n+\n+export default function Layout({ children }: { children: React.ReactNode }) {\n+  return <>{children}</>\n+}"
        },
        {
            "sha": "22d50c665767f9d1601505a29c2d70ef061836a7",
            "filename": "test/e2e/app-dir/use-cache/app/(partially-static)/generate-metadata-resume/params-unused/[slug]/page.tsx",
            "status": "added",
            "additions": 30,
            "deletions": 0,
            "changes": 30,
            "blob_url": "https://github.com/vercel/next.js/blob/dbbda2fea3fe44003e946db9ddc845871aa36d0b/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(partially-static)%2Fgenerate-metadata-resume%2Fparams-unused%2F%5Bslug%5D%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/dbbda2fea3fe44003e946db9ddc845871aa36d0b/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(partially-static)%2Fgenerate-metadata-resume%2Fparams-unused%2F%5Bslug%5D%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(partially-static)%2Fgenerate-metadata-resume%2Fparams-unused%2F%5Bslug%5D%2Fpage.tsx?ref=dbbda2fea3fe44003e946db9ddc845871aa36d0b",
            "patch": "@@ -0,0 +1,30 @@\n+import { Metadata } from 'next'\n+import { connection } from 'next/server'\n+import { Suspense } from 'react'\n+\n+export async function generateMetadata(_: {\n+  params: Promise<{ slug: string }>\n+}): Promise<Metadata> {\n+  'use cache'\n+\n+  // Explicitly not reading params here. The title should appear in the\n+  // partially prerendered page. TODO: When resuming the page, we should get a\n+  // cache hit (from the RDC), but omitting unused params from cache keys (and\n+  // upgrading cache keys when they are used) is not yet implemented.\n+\n+  return { title: new Date().toISOString() }\n+}\n+\n+export default function Page() {\n+  return (\n+    <Suspense fallback={<p>Loading...</p>}>\n+      <Dynamic />\n+    </Suspense>\n+  )\n+}\n+\n+async function Dynamic() {\n+  await connection()\n+\n+  return <p>Dynamic</p>\n+}"
        },
        {
            "sha": "1c66a9a2fcc7d2883ebad5efab29a873a852a0cd",
            "filename": "test/e2e/app-dir/use-cache/app/(partially-static)/generate-metadata-resume/params-used/[slug]/layout.tsx",
            "status": "added",
            "additions": 31,
            "deletions": 0,
            "changes": 31,
            "blob_url": "https://github.com/vercel/next.js/blob/dbbda2fea3fe44003e946db9ddc845871aa36d0b/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(partially-static)%2Fgenerate-metadata-resume%2Fparams-used%2F%5Bslug%5D%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/dbbda2fea3fe44003e946db9ddc845871aa36d0b/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(partially-static)%2Fgenerate-metadata-resume%2Fparams-used%2F%5Bslug%5D%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(partially-static)%2Fgenerate-metadata-resume%2Fparams-used%2F%5Bslug%5D%2Flayout.tsx?ref=dbbda2fea3fe44003e946db9ddc845871aa36d0b",
            "patch": "@@ -0,0 +1,31 @@\n+import { Metadata } from 'next'\n+\n+export async function generateMetadata({\n+  params,\n+}: {\n+  params: Promise<{ slug: string }>\n+}): Promise<Metadata> {\n+  'use cache: remote'\n+\n+  // Use `eval` to side step compiler errors for using `arguments` in a 'use\n+  // cache' function.\n+  // eslint-disable-next-line no-eval\n+  const unusedParentArg = eval('arguments')[1]\n+  if (unusedParentArg !== undefined) {\n+    throw new Error(\n+      'Expected the unused parent argument to be omitted. Received: ' +\n+        unusedParentArg\n+    )\n+  }\n+\n+  // We're reading params here. This makes the cache function dynamic during\n+  // prerendering, and thus the description should be excluded from the\n+  // partially prerendered page.\n+  const { slug } = await params\n+\n+  return { description: new Date().toISOString(), category: slug }\n+}\n+\n+export default function Layout({ children }: { children: React.ReactNode }) {\n+  return <main>{children}</main>\n+}"
        },
        {
            "sha": "672447adecb1af0df7107134a4f7e032f15c8aa1",
            "filename": "test/e2e/app-dir/use-cache/app/(partially-static)/generate-metadata-resume/params-used/[slug]/page.tsx",
            "status": "added",
            "additions": 43,
            "deletions": 0,
            "changes": 43,
            "blob_url": "https://github.com/vercel/next.js/blob/dbbda2fea3fe44003e946db9ddc845871aa36d0b/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(partially-static)%2Fgenerate-metadata-resume%2Fparams-used%2F%5Bslug%5D%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/dbbda2fea3fe44003e946db9ddc845871aa36d0b/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(partially-static)%2Fgenerate-metadata-resume%2Fparams-used%2F%5Bslug%5D%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(partially-static)%2Fgenerate-metadata-resume%2Fparams-used%2F%5Bslug%5D%2Fpage.tsx?ref=dbbda2fea3fe44003e946db9ddc845871aa36d0b",
            "patch": "@@ -0,0 +1,43 @@\n+import { Metadata } from 'next'\n+import { connection } from 'next/server'\n+import { Suspense } from 'react'\n+\n+export async function generateMetadata({\n+  params,\n+}: {\n+  params: Promise<{ slug: string }>\n+}): Promise<Metadata> {\n+  'use cache: remote'\n+\n+  // Use `eval` to side step compiler errors for using `arguments` in a 'use\n+  // cache' function.\n+  // eslint-disable-next-line no-eval\n+  const unusedParentArg = eval('arguments')[1]\n+  if (unusedParentArg !== undefined) {\n+    throw new Error(\n+      'Expected the unused parent argument to be omitted. Received: ' +\n+        unusedParentArg\n+    )\n+  }\n+\n+  // We're reading params here. This makes the cache function dynamic during\n+  // prerendering, and thus the title should be excluded from the partially\n+  // prerendered page.\n+  const { slug } = await params\n+\n+  return { title: new Date().toISOString(), keywords: [slug] }\n+}\n+\n+export default function Page() {\n+  return (\n+    <Suspense fallback={<p>Loading...</p>}>\n+      <Dynamic />\n+    </Suspense>\n+  )\n+}\n+\n+async function Dynamic() {\n+  await connection()\n+\n+  return <p>Dynamic</p>\n+}"
        },
        {
            "sha": "8d3752b8bfcc6726948f790e60b8fea75b895dd9",
            "filename": "test/e2e/app-dir/use-cache/app/(partially-static)/generate-viewport-resume/page.tsx",
            "status": "added",
            "additions": 31,
            "deletions": 0,
            "changes": 31,
            "blob_url": "https://github.com/vercel/next.js/blob/dbbda2fea3fe44003e946db9ddc845871aa36d0b/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(partially-static)%2Fgenerate-viewport-resume%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/dbbda2fea3fe44003e946db9ddc845871aa36d0b/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(partially-static)%2Fgenerate-viewport-resume%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(partially-static)%2Fgenerate-viewport-resume%2Fpage.tsx?ref=dbbda2fea3fe44003e946db9ddc845871aa36d0b",
            "patch": "@@ -0,0 +1,31 @@\n+import { Viewport } from 'next'\n+import { connection } from 'next/server'\n+import { Suspense } from 'react'\n+\n+export async function generateViewport({\n+  searchParams,\n+}: {\n+  searchParams: Promise<Record<string, string | string[] | undefined>>\n+}): Promise<Viewport> {\n+  'use cache'\n+\n+  // Explicitly not reading search params here. The search params should be\n+  // omitted from the cache key, so that we ensure a cache hit when resuming the\n+  // partially prerendered page.\n+\n+  return { initialScale: Math.random() }\n+}\n+\n+export default function Page() {\n+  return (\n+    <Suspense fallback={<p>Loading...</p>}>\n+      <Dynamic />\n+    </Suspense>\n+  )\n+}\n+\n+async function Dynamic() {\n+  await connection()\n+\n+  return <p>Dynamic</p>\n+}"
        },
        {
            "sha": "37ecda399b1ffe6877fc1515fc45c29ad2b127e1",
            "filename": "test/e2e/app-dir/use-cache/app/(partially-static)/generate-viewport-resume/params-unused/[color]/layout.tsx",
            "status": "added",
            "additions": 20,
            "deletions": 0,
            "changes": 20,
            "blob_url": "https://github.com/vercel/next.js/blob/dbbda2fea3fe44003e946db9ddc845871aa36d0b/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(partially-static)%2Fgenerate-viewport-resume%2Fparams-unused%2F%5Bcolor%5D%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/dbbda2fea3fe44003e946db9ddc845871aa36d0b/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(partially-static)%2Fgenerate-viewport-resume%2Fparams-unused%2F%5Bcolor%5D%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(partially-static)%2Fgenerate-viewport-resume%2Fparams-unused%2F%5Bcolor%5D%2Flayout.tsx?ref=dbbda2fea3fe44003e946db9ddc845871aa36d0b",
            "patch": "@@ -0,0 +1,20 @@\n+import { Viewport } from 'next'\n+\n+export async function generateViewport({\n+  params,\n+}: {\n+  params: Promise<{ color: string }>\n+}): Promise<Viewport> {\n+  'use cache'\n+\n+  // Explicitly not reading params here. The meta tag should appear in the\n+  // partially prerendered page. TODO: When resuming the page, we should get a\n+  // cache hit (from the RDC), but omitting unused params from cache keys (and\n+  // upgrading cache keys when they are used) is not yet implemented.\n+\n+  return { maximumScale: 1 + Math.random() }\n+}\n+\n+export default function Layout({ children }: { children: React.ReactNode }) {\n+  return <main>{children}</main>\n+}"
        },
        {
            "sha": "51e6820e84f416209420f1753f9c2fdb81a444f8",
            "filename": "test/e2e/app-dir/use-cache/app/(partially-static)/generate-viewport-resume/params-unused/[color]/page.tsx",
            "status": "added",
            "additions": 32,
            "deletions": 0,
            "changes": 32,
            "blob_url": "https://github.com/vercel/next.js/blob/dbbda2fea3fe44003e946db9ddc845871aa36d0b/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(partially-static)%2Fgenerate-viewport-resume%2Fparams-unused%2F%5Bcolor%5D%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/dbbda2fea3fe44003e946db9ddc845871aa36d0b/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(partially-static)%2Fgenerate-viewport-resume%2Fparams-unused%2F%5Bcolor%5D%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(partially-static)%2Fgenerate-viewport-resume%2Fparams-unused%2F%5Bcolor%5D%2Fpage.tsx?ref=dbbda2fea3fe44003e946db9ddc845871aa36d0b",
            "patch": "@@ -0,0 +1,32 @@\n+import { Viewport } from 'next'\n+import { connection } from 'next/server'\n+import { Suspense } from 'react'\n+\n+export async function generateViewport({\n+  params,\n+}: {\n+  params: Promise<{ color: string }>\n+}): Promise<Viewport> {\n+  'use cache'\n+\n+  // Explicitly not reading params here. The meta tag should appear in the\n+  // partially prerendered page. TODO: When resuming the page, we should get a\n+  // cache hit (from the RDC), but omitting unused params from cache keys (and\n+  // upgrading cache keys when they are used) is not yet implemented.\n+\n+  return { initialScale: Math.random() }\n+}\n+\n+export default function Page() {\n+  return (\n+    <Suspense fallback={<p>Loading...</p>}>\n+      <Dynamic />\n+    </Suspense>\n+  )\n+}\n+\n+async function Dynamic() {\n+  await connection()\n+\n+  return <p>Dynamic</p>\n+}"
        },
        {
            "sha": "bfb730e6c050fa34192c13e02a3512dbccdcab75",
            "filename": "test/e2e/app-dir/use-cache/use-cache.test.ts",
            "status": "modified",
            "additions": 267,
            "deletions": 1,
            "changes": 268,
            "blob_url": "https://github.com/vercel/next.js/blob/dbbda2fea3fe44003e946db9ddc845871aa36d0b/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fuse-cache.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/dbbda2fea3fe44003e946db9ddc845871aa36d0b/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fuse-cache.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fuse-cache.test.ts?ref=dbbda2fea3fe44003e946db9ddc845871aa36d0b",
            "patch": "@@ -1,5 +1,9 @@\n import { nextTestSetup } from 'e2e-utils'\n-import { assertNoConsoleErrors, retry } from 'next-test-utils'\n+import {\n+  assertNoConsoleErrors,\n+  assertNoErrorToast,\n+  retry,\n+} from 'next-test-utils'\n import stripAnsi from 'strip-ansi'\n import { format } from 'util'\n import { Playwright } from 'next-webdriver'\n@@ -1093,6 +1097,268 @@ describe('use-cache', () => {\n     // the outer 'use cache'), and this expectation needs to be flipped.\n     expect(description).not.toBe(initialDescription)\n   })\n+\n+  if (withCacheComponents) {\n+    it('can resume a cached generateMetadata function', async () => {\n+      // First load the page with JavaScript disabled, to ensure that the\n+      // generateMetadata result was included in the prerendered shell.\n+      let browser = await next.browser('/generate-metadata-resume/nested', {\n+        disableJavaScript: true,\n+      })\n+\n+      // The title must be in the head if it was prerendered.\n+      const title = await browser\n+        .elementByCss('head title', { state: 'attached' })\n+        .text()\n+      expect(title).toBeDateString()\n+\n+      await browser.close()\n+\n+      // Load the page again, now with JavaScript enabled.\n+      browser = await next.browser('/generate-metadata-resume/nested')\n+\n+      // If there was no cache hit from the RDC during the resume, we'd observe\n+      // a different title.\n+      expect(await browser.eval('document.title')).toBe(title)\n+    })\n+\n+    it('can resume a cached generateMetadata function that does not read params', async () => {\n+      // First load the page with JavaScript disabled, to ensure that the\n+      // generateMetadata result was included in the prerendered shell.\n+      let browser = await next.browser(\n+        '/generate-metadata-resume/params-unused/foo',\n+        { disableJavaScript: true }\n+      )\n+\n+      // The metadata must be in the head if it was prerendered.\n+      const title = await browser\n+        .elementByCss('head title', { state: 'attached' })\n+        .text()\n+      expect(title).toBeDateString()\n+      const description = await browser\n+        .elementByCss('head meta[name=\"description\"]', { state: 'attached' })\n+        .getAttribute('content')\n+      expect(description).toBeDateString()\n+\n+      await browser.close()\n+\n+      // Load the page again, now with JavaScript enabled.\n+      browser = await next.browser(\n+        '/generate-metadata-resume/params-unused/foo'\n+      )\n+\n+      // If there was no cache hit from the RDC during the resume, we'd observe\n+      // different metadata.\n+      const title2 = await browser.eval('document.title')\n+      const description2 = await browser\n+        // Select the last meta element, in case another one was added during\n+        // the resume due to a cache miss.\n+        .elementByCss('meta[name=\"description\"]:last-of-type')\n+        .getAttribute('content')\n+\n+      if (isNextDev) {\n+        expect(title2).toBe(title)\n+        expect(description2).toBe(description)\n+      } else {\n+        // TODO: Omitting unused params from cache keys (and upgrading cache\n+        // keys when they are used) is not yet implemented. Remove this else\n+        // branch once it is.\n+        expect(title2).not.toBe(title)\n+        expect(description2).not.toBe(description)\n+      }\n+    })\n+\n+    it('can serialize parent metadata as generateMetadata argument', async () => {\n+      const browser = await next.browser('/generate-metadata-resume/nested')\n+\n+      // The metadata must be in the head if it was prerendered.\n+      const canonicalUrl = await browser\n+        .elementByCss('head link[rel=\"canonical\"]', { state: 'attached' })\n+        .getAttribute('href')\n+\n+      expect(canonicalUrl).toBe('https://example.com/baz/qux')\n+\n+      // There should be no timeout error.\n+      await assertNoErrorToast(browser)\n+    })\n+\n+    it('makes a cached generateMetadata function that implicitly depends on params dynamic during prerendering', async () => {\n+      // First load the page with JavaScript disabled, to ensure that no\n+      // generateMetadata result was included in the prerendered shell.\n+      let browser = await next.browser(\n+        '/generate-metadata-resume/canonical/foo',\n+        { disableJavaScript: true }\n+      )\n+\n+      // The metadata would be in the head if it was prerendered.\n+      expect(\n+        await browser\n+          .elementByCss('head', { state: 'attached' })\n+          .hasElementByCss('link[rel=\"canonical\"]')\n+      ).toBe(false)\n+\n+      // However, it should have been added to the body during the resume.\n+      expect(\n+        await browser.elementByCss('link[rel=\"canonical\"]').getAttribute('href')\n+      ).toBe('https://example.com/baz/qux')\n+\n+      await browser.close()\n+\n+      // Load the page again, now with JavaScript enabled.\n+      browser = await next.browser('/generate-metadata-resume/canonical/foo')\n+\n+      // There should be no timeout error.\n+      await assertNoErrorToast(browser)\n+    })\n+\n+    it('makes a cached generateMetadata function that reads params dynamic during prerendering', async () => {\n+      // First load the page with JavaScript disabled, to ensure that no\n+      // generateMetadata result was included in the prerendered shell.\n+      let browser = await next.browser(\n+        '/generate-metadata-resume/params-used/foo',\n+        { disableJavaScript: true }\n+      )\n+\n+      // The metadata would be in the head if it was prerendered.\n+      expect(\n+        await browser\n+          .elementByCss('head', { state: 'attached' })\n+          .hasElementByCss('title')\n+      ).toBe(false)\n+      expect(\n+        await browser\n+          .elementByCss('head', { state: 'attached' })\n+          .hasElementByCss('meta[name=\"description\"]')\n+      ).toBe(false)\n+\n+      // However, it should have been added to the body during the resume.\n+      const title = await browser.eval('document.title')\n+      expect(title).toBeDefined()\n+      expect(title).toBeDateString()\n+      const description = await browser\n+        .elementByCss('meta[name=\"description\"]')\n+        .getAttribute('content')\n+      expect(description).toBeDateString()\n+\n+      await browser.close()\n+\n+      // Load the page again, now with JavaScript enabled.\n+      browser = await next.browser('/generate-metadata-resume/params-used/foo')\n+\n+      // We should see the same cached metadata again.\n+      expect(await browser.eval('document.title')).toBe(title)\n+      expect(\n+        await browser\n+          .elementByCss('meta[name=\"description\"]')\n+          .getAttribute('content')\n+      ).toBe(description)\n+    })\n+\n+    it('can resume a cached generateViewport function', async () => {\n+      // First load the page with JavaScript disabled, to ensure that the\n+      // generateViewport result was included in the prerendered shell.\n+      let browser = await next.browser('/generate-viewport-resume', {\n+        disableJavaScript: true,\n+      })\n+\n+      // The meta tag must be in the head if it was prerendered.\n+      const viewport = await browser\n+        .elementByCss('head meta[name=\"viewport\"]', { state: 'attached' })\n+        .getAttribute('content')\n+      const [, initialScale] = viewport.match(/initial-scale=([\\d.]+)/) ?? []\n+      expect(Number(initialScale)).toBeNumber()\n+      await browser.close()\n+\n+      // Load the page again, now with JavaScript enabled.\n+      browser = await next.browser('/generate-viewport-resume')\n+\n+      // If there was no cache hit from the RDC during the resume, we'd observe\n+      // a different value.\n+      const viewport2 = await browser\n+        // Select the last meta element, in case another one was added during\n+        // the resume due to a cache miss.\n+        .elementByCss('meta[name=\"viewport\"]:last-of-type', {\n+          state: 'attached',\n+        })\n+        .getAttribute('content')\n+      const [, initialScale2] = viewport2.match(/initial-scale=([\\d.]+)/) ?? []\n+      expect(initialScale2).toBe(initialScale)\n+    })\n+\n+    it('can resume a cached generateViewport function that does not read params', async () => {\n+      // First load the page with JavaScript disabled, to ensure that the\n+      // generateViewport result was included in the prerendered shell.\n+      let browser = await next.browser(\n+        '/generate-viewport-resume/params-unused/red',\n+        { disableJavaScript: true }\n+      )\n+\n+      // The meta tag must be in the head if it was prerendered.\n+      const viewport = await browser\n+        .elementByCss('head meta[name=\"viewport\"]', { state: 'attached' })\n+        .getAttribute('content')\n+      const [, initialScale, maximumScale] =\n+        viewport.match(/initial-scale=([\\d.]+), maximum-scale=([\\d.]+)/) ?? []\n+      expect(Number(initialScale)).toBeNumber()\n+      expect(Number(maximumScale)).toBeNumber()\n+\n+      await browser.close()\n+\n+      // Load the page again, now with JavaScript enabled.\n+      browser = await next.browser(\n+        '/generate-viewport-resume/params-unused/red'\n+      )\n+\n+      // If there was no cache hit from the RDC during the resume, we'd observe\n+      // a different meta tag.\n+      const viewport2 = await browser\n+        // Select the last meta element, in case another one was added during\n+        // the resume due to a cache miss.\n+        .elementByCss('meta[name=\"viewport\"]:last-of-type', {\n+          state: 'attached',\n+        })\n+        .getAttribute('content')\n+      const [, initialScale2, maximumScale2] =\n+        viewport2.match(/initial-scale=([\\d.]+), maximum-scale=([\\d.]+)/) ?? []\n+\n+      if (isNextDev) {\n+        expect(initialScale2).toBe(initialScale)\n+        expect(maximumScale2).toBe(maximumScale)\n+      } else {\n+        // TODO: Omitting unused params from cache keys (and upgrading cache\n+        // keys when they are used) is not yet implemented. Remove this else\n+        // branch once it is.\n+        expect(initialScale2).not.toBe(initialScale)\n+        expect(maximumScale2).not.toBe(maximumScale)\n+      }\n+    })\n+\n+    it('makes a cached generateViewport function that reads params dynamic during prerendering', async () => {\n+      // The page is fully dynamic, so we can only observe that the values are\n+      // cached on subsequent requests.\n+      let browser = await next.browser(\n+        '/generate-viewport-resume/params-used/red'\n+      )\n+\n+      const viewport = await browser\n+        .elementByCss('meta[name=\"viewport\"]', { state: 'attached' })\n+        .getAttribute('content')\n+      const [, initialScale, maximumScale] =\n+        viewport.match(/initial-scale=([\\d.]+), maximum-scale=([\\d.]+)/) ?? []\n+      expect(Number(initialScale)).toBeNumber()\n+      expect(Number(maximumScale)).toBeNumber()\n+\n+      await browser.refresh()\n+\n+      const viewport2 = await browser\n+        .elementByCss('meta[name=\"viewport\"]', { state: 'attached' })\n+        .getAttribute('content')\n+      const [, initialScale2, maximumScale2] =\n+        viewport2.match(/initial-scale=([\\d.]+), maximum-scale=([\\d.]+)/) ?? []\n+      expect(initialScale2).toBe(initialScale)\n+      expect(maximumScale2).toBe(maximumScale)\n+    })\n+  }\n })\n \n async function getSanitizedLogs(browser: Playwright): Promise<string[]> {"
        }
    ],
    "stats": {
        "total": 1165,
        "additions": 1010,
        "deletions": 155
    }
}