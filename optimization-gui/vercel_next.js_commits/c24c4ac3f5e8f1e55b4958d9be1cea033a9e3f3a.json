{
    "author": "gnoff",
    "message": "[dynamicIO] Model invalid dynamic on empty shells (#77270)\n\nDynamic is disallowed unless a Suspense boundary is above it. This now\napplies to metadaata (though this shouldn't matter because it now\nstreams) and viewport. To allow for fully dynamic routes including\nviewport you must put a Suspense boundary around your root layout.",
    "sha": "c24c4ac3f5e8f1e55b4958d9be1cea033a9e3f3a",
    "files": [
        {
            "sha": "0d0df39e32e4cdd85afa243bc32a4f1c3662830b",
            "filename": "errors/next-prerender-dynamic-viewport.mdx",
            "status": "added",
            "additions": 109,
            "deletions": 0,
            "changes": 109,
            "blob_url": "https://github.com/vercel/next.js/blob/c24c4ac3f5e8f1e55b4958d9be1cea033a9e3f3a/errors%2Fnext-prerender-dynamic-viewport.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/c24c4ac3f5e8f1e55b4958d9be1cea033a9e3f3a/errors%2Fnext-prerender-dynamic-viewport.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/errors%2Fnext-prerender-dynamic-viewport.mdx?ref=c24c4ac3f5e8f1e55b4958d9be1cea033a9e3f3a",
            "patch": "@@ -0,0 +1,109 @@\n+---\n+title: Cannot access Request information or uncached data in `generateViewport()`\n+---\n+\n+## Why This Error Occurred\n+\n+When `dynamicIO` is enabled, Next.js requires that `generateViewport()` not depend on uncached data or Request data unless you explicitly opt into having a fully dynamic page. If you encountered this error, it means that `generateViewport` depends on one of these types of data and you have not specifically indicated that the affected route should be entirely dynamic.\n+\n+## Possible Ways to Fix It\n+\n+To fix this issue, you must first determine your goal for the affected route.\n+\n+Normally, the way you indicate to Next.js that you want to allow reading Request data or uncached external data is by performing this data access inside a component with an ancestor Suspense boundary. With Viewport, however, you aren't directly in control of wrapping the location where this metadata will be rendered, and even if you could wrap it in a Suspense boundary, it would not be correct to render it with a fallback. This is because this metadata is critical to properly loading resources such as images and must be part of the initial App Shell (the initial HTML containing the document head as well as the first paintable UI).\n+\n+### If you must access Request Data or your external data is uncacheable\n+\n+The only way to use Request data or uncacheable external data within `generateViewport` is to make this route entirely dynamic. While Next.js can operate in this mode, it does preclude future use of the prerendering capabilities of Next.js, so you should be certain this is necessary for your use case. To indicate the route should be entirely dynamic, you must add a Suspense boundary above where you render the document body.\n+\n+Before:\n+\n+```jsx filename=\"app/layout.tsx\"\n+import { cookies } from 'next/headers'\n+\n+export async function generateViewport() {\n+  const cookieJar = await cookies()\n+  return {\n+    themeColor: cookieJar.get('theme-color'),\n+  }\n+}\n+\n+export default function RootLayout({ children }) {\n+  return (\n+    <html>\n+      <body>{children}</body>\n+    </html>\n+  )\n+}\n+```\n+\n+After:\n+\n+```jsx filename=\"app/layout.tsx\"\n+import { Suspense } from 'react'\n+import { cookies } from 'next/headers'\n+\n+export async function generateViewport() {\n+  const cookieJar = await cookies()\n+  return {\n+    themeColor: cookieJar.get('theme-color'),\n+  }\n+}\n+\n+export default function RootLayout({ children }) {\n+  return (\n+    <Suspense>\n+      <html>\n+        <body>{children}</body>\n+      </html>\n+    </Suspense>\n+  )\n+}\n+```\n+\n+### Caching External Data\n+\n+When external data is cached, Next.js can prerender with it, which ensures that the App Shell always has the complete viewport metadata available. Consider using `\"use cache\"` to mark the function producing the external data as cacheable.\n+\n+Before:\n+\n+```jsx filename=\"app/.../layout.tsx\"\n+import { db } from './db'\n+\n+export async function generateViewport() {\n+  const { width, initialScale } = await db.query('viewport-size')\n+  return {\n+    width,\n+    initialScale,\n+  }\n+}\n+\n+export default async function Layout({ children }) {\n+  return ...\n+}\n+```\n+\n+After:\n+\n+```jsx filename=\"app/.../layout.tsx\"\n+import { db } from './db'\n+\n+export async function generateViewport() {\n+  \"use cache\"\n+  const { width, initialScale } = await db.query('viewport-size')\n+  return {\n+    width,\n+    initialScale,\n+  }\n+}\n+\n+export default async function Layout({ children }) {\n+  return ...\n+}\n+```\n+\n+## Useful Links\n+\n+- [`generateViewport()`](docs/app/api-reference/functions/generate-viewport)\n+- [`cookies()`](docs/app/api-reference/functions/cookies)\n+- [`\"use cache\"`](/docs/app/api-reference/directives/use-cache)"
        },
        {
            "sha": "f0a3a5fd1fbddd91cc2ae0b6f4ddc2b433a86485",
            "filename": "packages/next/errors.json",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/c24c4ac3f5e8f1e55b4958d9be1cea033a9e3f3a/packages%2Fnext%2Ferrors.json",
            "raw_url": "https://github.com/vercel/next.js/raw/c24c4ac3f5e8f1e55b4958d9be1cea033a9e3f3a/packages%2Fnext%2Ferrors.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Ferrors.json?ref=c24c4ac3f5e8f1e55b4958d9be1cea033a9e3f3a",
            "patch": "@@ -671,5 +671,7 @@\n   \"670\": \"Invariant: --turbopack is not set but the build used Turbopack. Add --turbopack to \\\"next start\\\".\",\n   \"671\": \"Specified images.remotePatterns must have protocol \\\"http\\\" or \\\"https\\\" received \\\"%s\\\".\",\n   \"672\": \"Expected `telemetry` to be set in globals\",\n-  \"673\": \"Thrown value was ignored. This is a bug in Next.js.\"\n+  \"673\": \"Thrown value was ignored. This is a bug in Next.js.\",\n+  \"674\": \"Route \\\"%s\\\" has a \\\\`generateViewport\\\\` that depends on Request data (\\\\`cookies()\\\\`, etc...) or uncached external data (\\\\`fetch(...)\\\\`, etc...) without explicitly allowing fully dynamic rendering. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport\",\n+  \"675\": \"Expected `generateMetadata` not to block the application shell but it did.\"\n }"
        },
        {
            "sha": "ddf5ce26d4df30be9d96096bdad16ac14c53764a",
            "filename": "packages/next/src/server/app-render/app-render-prerender-utils.ts",
            "status": "modified",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/c24c4ac3f5e8f1e55b4958d9be1cea033a9e3f3a/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render-prerender-utils.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/c24c4ac3f5e8f1e55b4958d9be1cea033a9e3f3a/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render-prerender-utils.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render-prerender-utils.ts?ref=c24c4ac3f5e8f1e55b4958d9be1cea033a9e3f3a",
            "patch": "@@ -494,3 +494,17 @@ function createClosingStream(\n     },\n   })\n }\n+\n+export async function processPrelude(\n+  unprocessedPrelude: ReadableStream<Uint8Array>\n+) {\n+  const [prelude, peek] = unprocessedPrelude.tee()\n+\n+  const reader = peek.getReader()\n+  const firstResult = await reader.read()\n+  reader.cancel()\n+\n+  const preludeIsEmpty = firstResult.done === true\n+\n+  return { prelude, preludeIsEmpty }\n+}"
        },
        {
            "sha": "5e9d8da2e616bccbf96a057825833af11d1dd2d2",
            "filename": "packages/next/src/server/app-render/app-render.tsx",
            "status": "modified",
            "additions": 96,
            "deletions": 81,
            "changes": 177,
            "blob_url": "https://github.com/vercel/next.js/blob/c24c4ac3f5e8f1e55b4958d9be1cea033a9e3f3a/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/c24c4ac3f5e8f1e55b4958d9be1cea033a9e3f3a/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx?ref=c24c4ac3f5e8f1e55b4958d9be1cea033a9e3f3a",
            "patch": "@@ -132,7 +132,7 @@ import {\n   createDynamicValidationState,\n   getFirstDynamicReason,\n   trackAllowedDynamicAccess,\n-  throwIfDisallowedDynamic,\n+  throwIfDisallowedEmptyShell,\n   consumeDynamicAccess,\n   type DynamicAccess,\n } from './dynamic-rendering'\n@@ -154,7 +154,10 @@ import { getRevalidateReason } from '../instrumentation/utils'\n import { PAGE_SEGMENT_KEY } from '../../shared/lib/segment'\n import type { FallbackRouteParams } from '../request/fallback-params'\n import { DynamicServerError } from '../../client/components/hooks-server-context'\n-import { ServerPrerenderStreamResult } from './app-render-prerender-utils'\n+import {\n+  ServerPrerenderStreamResult,\n+  processPrelude,\n+} from './app-render-prerender-utils'\n import {\n   type ReactServerPrerenderResult,\n   ReactServerResult,\n@@ -2519,10 +2522,11 @@ async function spawnDynamicValidationInDev(\n \n   let rootDidError = false\n   const serverPhasedStream = serverPrerenderStreamResult.asPhasedStream()\n+  let preludeIsEmpty = false\n   try {\n     const prerender = require('react-dom/static.edge')\n       .prerender as (typeof import('react-dom/static.edge'))['prerender']\n-    await prerenderClientWithPhases(\n+    const { prelude: unprocessedPrelude } = await prerenderClientWithPhases(\n       () =>\n         workUnitAsyncStorage.run(\n           finalClientPrerenderStore,\n@@ -2561,9 +2565,7 @@ async function spawnDynamicValidationInDev(\n                   trackAllowedDynamicAccess(\n                     route,\n                     componentStack,\n-                    dynamicValidation,\n-                    serverDynamicTracking,\n-                    clientDynamicTracking\n+                    dynamicValidation\n                   )\n                 }\n                 return\n@@ -2578,8 +2580,10 @@ async function spawnDynamicValidationInDev(\n         serverPhasedStream.assertExhausted()\n       }\n     )\n+    preludeIsEmpty = (await processPrelude(unprocessedPrelude)).preludeIsEmpty\n   } catch (err) {\n     rootDidError = true\n+    preludeIsEmpty = true\n     if (\n       isPrerenderInterruptedError(err) ||\n       finalClientController.signal.aborted\n@@ -2596,12 +2600,14 @@ async function spawnDynamicValidationInDev(\n \n   function LogDynamicValidation() {\n     try {\n-      throwIfDisallowedDynamic(\n-        route,\n-        dynamicValidation,\n-        serverDynamicTracking,\n-        clientDynamicTracking\n-      )\n+      if (preludeIsEmpty) {\n+        throwIfDisallowedEmptyShell(\n+          route,\n+          dynamicValidation,\n+          serverDynamicTracking,\n+          clientDynamicTracking\n+        )\n+      }\n     } catch {}\n     return null\n   }\n@@ -3071,66 +3077,72 @@ async function prerenderToStream(\n \n         const prerender = require('react-dom/static.edge')\n           .prerender as (typeof import('react-dom/static.edge'))['prerender']\n-        let { prelude, postponed } = await prerenderAndAbortInSequentialTasks(\n-          () =>\n-            workUnitAsyncStorage.run(\n-              finalClientPrerenderStore,\n-              prerender,\n-              <App\n-                reactServerStream={reactServerResult.asUnclosingStream()}\n-                preinitScripts={preinitScripts}\n-                clientReferenceManifest={clientReferenceManifest}\n-                ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n-                ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n-                gracefullyDegrade={!!ctx.renderOpts.botType}\n-                nonce={nonce}\n-              />,\n-              {\n-                signal: finalClientController.signal,\n-                onError: (err: unknown, errorInfo: ErrorInfo) => {\n-                  if (\n-                    isPrerenderInterruptedError(err) ||\n-                    finalClientController.signal.aborted\n-                  ) {\n-                    clientIsDynamic = true\n-\n-                    const componentStack: string | undefined = (\n-                      errorInfo as any\n-                    ).componentStack\n-                    if (typeof componentStack === 'string') {\n-                      trackAllowedDynamicAccess(\n-                        workStore.route,\n-                        componentStack,\n-                        dynamicValidation,\n-                        serverDynamicTracking,\n-                        clientDynamicTracking\n-                      )\n-                    }\n-                    return\n+        let { prelude: unprocessedPrelude, postponed } =\n+          await prerenderAndAbortInSequentialTasks(\n+            () =>\n+              workUnitAsyncStorage.run(\n+                finalClientPrerenderStore,\n+                prerender,\n+                <App\n+                  reactServerStream={reactServerResult.asUnclosingStream()}\n+                  preinitScripts={preinitScripts}\n+                  clientReferenceManifest={clientReferenceManifest}\n+                  ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n+                  ServerInsertedMetadataProvider={\n+                    ServerInsertedMetadataProvider\n                   }\n+                  gracefullyDegrade={!!ctx.renderOpts.botType}\n+                  nonce={nonce}\n+                />,\n+                {\n+                  signal: finalClientController.signal,\n+                  onError: (err: unknown, errorInfo: ErrorInfo) => {\n+                    if (\n+                      isPrerenderInterruptedError(err) ||\n+                      finalClientController.signal.aborted\n+                    ) {\n+                      clientIsDynamic = true\n \n-                  return htmlRendererErrorHandler(err, errorInfo)\n-                },\n-                onHeaders: (headers: Headers) => {\n-                  headers.forEach((value, key) => {\n-                    appendHeader(key, value)\n-                  })\n-                },\n-                maxHeadersLength: renderOpts.reactMaxHeadersLength,\n-                bootstrapScripts: [bootstrapScript],\n-              }\n-            ),\n-          () => {\n-            finalClientController.abort()\n-          }\n-        )\n+                      const componentStack: string | undefined = (\n+                        errorInfo as any\n+                      ).componentStack\n+                      if (typeof componentStack === 'string') {\n+                        trackAllowedDynamicAccess(\n+                          workStore.route,\n+                          componentStack,\n+                          dynamicValidation\n+                        )\n+                      }\n+                      return\n+                    }\n \n-        throwIfDisallowedDynamic(\n-          workStore.route,\n-          dynamicValidation,\n-          serverDynamicTracking,\n-          clientDynamicTracking\n-        )\n+                    return htmlRendererErrorHandler(err, errorInfo)\n+                  },\n+                  onHeaders: (headers: Headers) => {\n+                    headers.forEach((value, key) => {\n+                      appendHeader(key, value)\n+                    })\n+                  },\n+                  maxHeadersLength: renderOpts.reactMaxHeadersLength,\n+                  bootstrapScripts: [bootstrapScript],\n+                }\n+              ),\n+            () => {\n+              finalClientController.abort()\n+            }\n+          )\n+\n+        const { prelude, preludeIsEmpty } =\n+          await processPrelude(unprocessedPrelude)\n+\n+        if (preludeIsEmpty) {\n+          throwIfDisallowedEmptyShell(\n+            workStore.route,\n+            dynamicValidation,\n+            serverDynamicTracking,\n+            clientDynamicTracking\n+          )\n+        }\n \n         const getServerInsertedHTML = makeGetServerInsertedHTML({\n           polyfills,\n@@ -3538,7 +3550,7 @@ async function prerenderToStream(\n             }\n           ))\n \n-        let htmlStream\n+        let htmlStream, preludeIsEmpty\n         const serverPhasedStream = serverPrerenderStreamResult.asPhasedStream()\n         try {\n           const prerender = require('react-dom/static.edge')\n@@ -3575,9 +3587,7 @@ async function prerenderToStream(\n                         trackAllowedDynamicAccess(\n                           workStore.route,\n                           componentStack,\n-                          dynamicValidation,\n-                          serverDynamicTracking,\n-                          clientDynamicTracking\n+                          dynamicValidation\n                         )\n                       }\n                       return\n@@ -3593,25 +3603,30 @@ async function prerenderToStream(\n               serverPhasedStream.assertExhausted()\n             }\n           )\n-          htmlStream = result.prelude\n+          const processed = await processPrelude(result.prelude)\n+          htmlStream = processed.prelude\n+          preludeIsEmpty = processed.preludeIsEmpty\n         } catch (err) {\n           if (\n             isPrerenderInterruptedError(err) ||\n             finalClientController.signal.aborted\n           ) {\n-            // we don't have a root because the abort errored in the root. We can just ignore this error\n+            preludeIsEmpty = true\n           } else {\n             // This error is something else and should bubble up\n             throw err\n           }\n         }\n \n-        throwIfDisallowedDynamic(\n-          workStore.route,\n-          dynamicValidation,\n-          serverDynamicTracking,\n-          clientDynamicTracking\n-        )\n+        if (preludeIsEmpty) {\n+          // We don't have a shell because the root errored when we aborted.\n+          throwIfDisallowedEmptyShell(\n+            workStore.route,\n+            dynamicValidation,\n+            serverDynamicTracking,\n+            clientDynamicTracking\n+          )\n+        }\n \n         if (serverIsDynamic || clientIsDynamic) {\n           const dynamicReason = serverIsDynamic"
        },
        {
            "sha": "e06d9901eedd1348b5d4f3108bae01c3ce8325d9",
            "filename": "packages/next/src/server/app-render/dynamic-rendering.ts",
            "status": "modified",
            "additions": 50,
            "deletions": 65,
            "changes": 115,
            "blob_url": "https://github.com/vercel/next.js/blob/c24c4ac3f5e8f1e55b4958d9be1cea033a9e3f3a/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fdynamic-rendering.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/c24c4ac3f5e8f1e55b4958d9be1cea033a9e3f3a/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fdynamic-rendering.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fdynamic-rendering.ts?ref=c24c4ac3f5e8f1e55b4958d9be1cea033a9e3f3a",
            "patch": "@@ -42,6 +42,7 @@ import {\n   OUTLET_BOUNDARY_NAME,\n } from '../../lib/metadata/metadata-constants'\n import { scheduleOnNextTick } from '../../lib/scheduler'\n+import { InvariantError } from '../../shared/lib/invariant-error'\n \n const hasPostpone = typeof React.unstable_postpone === 'function'\n \n@@ -73,16 +74,13 @@ export type DynamicTrackingState = {\n \n   syncDynamicExpression: undefined | string\n   syncDynamicErrorWithStack: null | Error\n-  // Dev only\n-  syncDynamicLogged?: boolean\n }\n \n // Stores dynamic reasons used during an SSR render.\n export type DynamicValidationState = {\n-  hasSuspendedDynamic: boolean\n+  hasSuspenseAboveBody: boolean\n   hasDynamicMetadata: boolean\n   hasDynamicViewport: boolean\n-  hasSyncDynamicErrors: boolean\n   dynamicErrors: Array<Error>\n }\n \n@@ -99,10 +97,9 @@ export function createDynamicTrackingState(\n \n export function createDynamicValidationState(): DynamicValidationState {\n   return {\n-    hasSuspendedDynamic: false,\n+    hasSuspenseAboveBody: false,\n     hasDynamicMetadata: false,\n     hasDynamicViewport: false,\n-    hasSyncDynamicErrors: false,\n     dynamicErrors: [],\n   }\n }\n@@ -333,11 +330,6 @@ export function abortAndThrowOnSynchronousRequestDataAccess(\n       if (dynamicTracking.syncDynamicErrorWithStack === null) {\n         dynamicTracking.syncDynamicExpression = expression\n         dynamicTracking.syncDynamicErrorWithStack = errorWithStack\n-        if (prerenderStore.validating === true) {\n-          // We always log Request Access in dev at the point of calling the function\n-          // So we mark the dynamic validation as not requiring it to be printed\n-          dynamicTracking.syncDynamicLogged = true\n-        }\n       }\n     }\n     abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore)\n@@ -605,6 +597,8 @@ export function useDynamicRouteParams(expression: string) {\n }\n \n const hasSuspenseRegex = /\\n\\s+at Suspense \\(<anonymous>\\)/\n+const hasSuspenseAfterBodyOrHtmlRegex =\n+  /\\n\\s+at (?:body|html) \\(<anonymous>\\)[\\s\\S]*?\\n\\s+at Suspense \\(<anonymous>\\)/\n const hasMetadataRegex = new RegExp(\n   `\\\\n\\\\s+at ${METADATA_BOUNDARY_NAME}[\\\\n\\\\s]`\n )\n@@ -616,9 +610,7 @@ const hasOutletRegex = new RegExp(`\\\\n\\\\s+at ${OUTLET_BOUNDARY_NAME}[\\\\n\\\\s]`)\n export function trackAllowedDynamicAccess(\n   route: string,\n   componentStack: string,\n-  dynamicValidation: DynamicValidationState,\n-  serverDynamic: DynamicTrackingState,\n-  clientDynamic: DynamicTrackingState\n+  dynamicValidation: DynamicValidationState\n ) {\n   if (hasOutletRegex.test(componentStack)) {\n     // We don't need to track that this is dynamic. It is only so when something else is also dynamic.\n@@ -629,14 +621,14 @@ export function trackAllowedDynamicAccess(\n   } else if (hasViewportRegex.test(componentStack)) {\n     dynamicValidation.hasDynamicViewport = true\n     return\n-  } else if (hasSuspenseRegex.test(componentStack)) {\n-    dynamicValidation.hasSuspendedDynamic = true\n+  } else if (hasSuspenseAfterBodyOrHtmlRegex.test(componentStack)) {\n+    // This prerender has a Suspense boundary above the body which\n+    // effectively opts the page into allowing 100% dynamic rendering\n+    dynamicValidation.hasSuspenseAboveBody = true\n     return\n-  } else if (\n-    serverDynamic.syncDynamicErrorWithStack ||\n-    clientDynamic.syncDynamicErrorWithStack\n-  ) {\n-    dynamicValidation.hasSyncDynamicErrors = true\n+  } else if (hasSuspenseRegex.test(componentStack)) {\n+    // this error had a Suspense boundary above it so we don't need to report it as a source\n+    // of disallowed\n     return\n   } else {\n     const message = `Route \"${route}\": A component accessed data, headers, params, searchParams, or a short-lived cache without a Suspense boundary nor a \"use cache\" above it. We don't have the exact line number added to error messages yet but you can see which component in the stack below. See more info: https://nextjs.org/docs/messages/next-prerender-missing-suspense`\n@@ -655,39 +647,46 @@ function createErrorWithComponentStack(\n   return error\n }\n \n-export function throwIfDisallowedDynamic(\n+export function throwIfDisallowedEmptyShell(\n   route: string,\n   dynamicValidation: DynamicValidationState,\n   serverDynamic: DynamicTrackingState,\n   clientDynamic: DynamicTrackingState\n ): void {\n-  let syncError: null | Error\n-  let syncExpression: undefined | string\n-  let syncLogged: boolean\n+  // TODO: Now that metadata is streaming we don't really need to check if it is blocking\n+  // the root. We leave this here for now to ensure we've actually covered all our bases here\n+  // but we can actually remove this in a future update\n+  if (dynamicValidation.hasDynamicMetadata) {\n+    throw new InvariantError(\n+      'Expected `generateMetadata` not to block the application shell but it did.'\n+    )\n+  }\n+\n+  if (dynamicValidation.hasSuspenseAboveBody) {\n+    // This route has opted into allowing fully dynamic rendering\n+    // by including a Suspense boundary above the body. In this case\n+    // a lack of a shell is not considered disallowed so we simply return\n+    return\n+  }\n+\n   if (serverDynamic.syncDynamicErrorWithStack) {\n-    syncError = serverDynamic.syncDynamicErrorWithStack\n-    syncExpression = serverDynamic.syncDynamicExpression!\n-    syncLogged = serverDynamic.syncDynamicLogged === true\n-  } else if (clientDynamic.syncDynamicErrorWithStack) {\n-    syncError = clientDynamic.syncDynamicErrorWithStack\n-    syncExpression = clientDynamic.syncDynamicExpression!\n-    syncLogged = clientDynamic.syncDynamicLogged === true\n-  } else {\n-    syncError = null\n-    syncExpression = undefined\n-    syncLogged = false\n+    // There is no shell and the server did something sync dynamic likely\n+    // leading to an early termination of the prerender before the shell\n+    // could be completed.\n+    console.error(serverDynamic.syncDynamicErrorWithStack)\n+    // We terminate the build/validating render\n+    throw new StaticGenBailoutError()\n   }\n \n-  if (dynamicValidation.hasSyncDynamicErrors && syncError) {\n-    if (!syncLogged) {\n-      // In dev we already log errors about sync dynamic access. But during builds we need to ensure\n-      // the offending sync error is logged before we exit the build\n-      console.error(syncError)\n-    }\n-    // The actual error should have been logged when the sync access ocurred\n+  if (clientDynamic.syncDynamicErrorWithStack) {\n+    // Just like above but within the client render...\n+    console.error(clientDynamic.syncDynamicErrorWithStack)\n     throw new StaticGenBailoutError()\n   }\n \n+  // We didn't have any sync bailouts but there may be user code which\n+  // blocked the root. We would have captured these during the prerender\n+  // and can log them here and then terminate the build/validating render\n   const dynamicErrors = dynamicValidation.dynamicErrors\n   if (dynamicErrors.length) {\n     for (let i = 0; i < dynamicErrors.length; i++) {\n@@ -697,27 +696,13 @@ export function throwIfDisallowedDynamic(\n     throw new StaticGenBailoutError()\n   }\n \n-  if (!dynamicValidation.hasSuspendedDynamic) {\n-    if (dynamicValidation.hasDynamicMetadata) {\n-      if (syncError) {\n-        console.error(syncError)\n-        throw new StaticGenBailoutError(\n-          `Route \"${route}\" has a \\`generateMetadata\\` that could not finish rendering before ${syncExpression} was used. Follow the instructions in the error for this expression to resolve.`\n-        )\n-      }\n-      throw new StaticGenBailoutError(\n-        `Route \"${route}\" has a \\`generateMetadata\\` that depends on Request data (\\`cookies()\\`, etc...) or external data (\\`fetch(...)\\`, etc...) but the rest of the route was static or only used cached data (\\`\"use cache\"\\`). If you expected this route to be prerenderable update your \\`generateMetadata\\` to not use Request data and only use cached external data. Otherwise, add \\`await connection()\\` somewhere within this route to indicate explicitly it should not be prerendered.`\n-      )\n-    } else if (dynamicValidation.hasDynamicViewport) {\n-      if (syncError) {\n-        console.error(syncError)\n-        throw new StaticGenBailoutError(\n-          `Route \"${route}\" has a \\`generateViewport\\` that could not finish rendering before ${syncExpression} was used. Follow the instructions in the error for this expression to resolve.`\n-        )\n-      }\n-      throw new StaticGenBailoutError(\n-        `Route \"${route}\" has a \\`generateViewport\\` that depends on Request data (\\`cookies()\\`, etc...) or external data (\\`fetch(...)\\`, etc...) but the rest of the route was static or only used cached data (\\`\"use cache\"\\`). If you expected this route to be prerenderable update your \\`generateViewport\\` to not use Request data and only use cached external data. Otherwise, add \\`await connection()\\` somewhere within this route to indicate explicitly it should not be prerendered.`\n-      )\n-    }\n+  // If we got this far then the only other thing that could be blocking\n+  // the root is dynamic Viewport. If this is dynamic then\n+  // you need to opt into that by adding a Suspense boundary above the body\n+  // to indicate your are ok with fully dynamic rendering.\n+  if (dynamicValidation.hasDynamicViewport) {\n+    throw new StaticGenBailoutError(\n+      `Route \"${route}\" has a \\`generateViewport\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) without explicitly allowing fully dynamic rendering. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport`\n+    )\n   }\n }"
        },
        {
            "sha": "db8fd037a5c5d1435e927ed902d350098f60bc5a",
            "filename": "packages/next/src/server/app-render/work-unit-async-storage.external.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 6,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/c24c4ac3f5e8f1e55b4958d9be1cea033a9e3f3a/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwork-unit-async-storage.external.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/c24c4ac3f5e8f1e55b4958d9be1cea033a9e3f3a/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwork-unit-async-storage.external.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwork-unit-async-storage.external.ts?ref=c24c4ac3f5e8f1e55b4958d9be1cea033a9e3f3a",
            "patch": "@@ -117,12 +117,6 @@ export interface PrerenderStoreModern extends CommonWorkUnitStore {\n    */\n   prerenderResumeDataCache: PrerenderResumeDataCache | null\n \n-  // DEV ONLY\n-  // When used this flag informs certain APIs to skip logging because we're\n-  // not part of the primary render path and are just prerendering to produce\n-  // validation results\n-  validating?: boolean\n-\n   /**\n    * The HMR refresh hash is only provided in dev mode. It is needed for the dev\n    * warmup render to ensure that the cache keys will be identical for the"
        },
        {
            "sha": "020fa2c77d338f97edbb8934d5af786edbe5489c",
            "filename": "test/e2e/app-dir/dynamic-io-errors/dynamic-io-errors.test.ts",
            "status": "modified",
            "additions": 30,
            "deletions": 21,
            "changes": 51,
            "blob_url": "https://github.com/vercel/next.js/blob/c24c4ac3f5e8f1e55b4958d9be1cea033a9e3f3a/test%2Fe2e%2Fapp-dir%2Fdynamic-io-errors%2Fdynamic-io-errors.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/c24c4ac3f5e8f1e55b4958d9be1cea033a9e3f3a/test%2Fe2e%2Fapp-dir%2Fdynamic-io-errors%2Fdynamic-io-errors.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fdynamic-io-errors%2Fdynamic-io-errors.test.ts?ref=c24c4ac3f5e8f1e55b4958d9be1cea033a9e3f3a",
            "patch": "@@ -69,18 +69,22 @@ function runTests(options: { withMinification: boolean }) {\n         }\n       })\n \n-      it('should error the build if generateMetadata is dynamic', async () => {\n+      // This test used to assert the opposite but now that metadata is streaming during prerenders\n+      // we don't have to error the build when it is dynamic\n+      it('should not error the build if generateMetadata is dynamic', async () => {\n         try {\n           await next.start()\n         } catch {\n-          // we expect the build to fail\n+          throw new Error('expected build not to fail')\n         }\n-        const expectError = createExpectError(next.cliOutput)\n \n-        expectError('Error occurred prerendering page \"/\"')\n-        expectError(\n-          'Error: Route \"/\" has a `generateMetadata` that depends on Request data (`cookies()`, etc...) or external data (`fetch(...)`, etc...) but the rest of the route was static or only used cached data (`\"use cache\"`). If you expected this route to be prerenderable update your `generateMetadata` to not use Request data and only use cached external data. Otherwise, add `await connection()` somewhere within this route to indicate explicitly it should not be prerendered.'\n-        )\n+        if (WITH_PPR) {\n+          expect(next.cliOutput).toContain('◐ / ')\n+        } else {\n+          expect(next.cliOutput).toContain('ƒ / ')\n+        }\n+        const $ = await next.render$('/')\n+        expect($('#sentinel').text()).toBe('sentinel')\n       })\n     })\n     describe('Dynamic Metadata - Static Route With Suspense', () => {\n@@ -110,18 +114,22 @@ function runTests(options: { withMinification: boolean }) {\n         }\n       })\n \n-      it('should error the build if generateMetadata is dynamic', async () => {\n+      // This test used to assert the opposite but now that metadata is streaming during prerenders\n+      // we don't have to error the build when it is dynamic\n+      it('should not error the build if generateMetadata is dynamic', async () => {\n         try {\n           await next.start()\n         } catch {\n-          // we expect the build to fail\n+          throw new Error('expected build not to fail')\n         }\n-        const expectError = createExpectError(next.cliOutput)\n \n-        expectError('Error occurred prerendering page \"/\"')\n-        expectError(\n-          'Error: Route \"/\" has a `generateMetadata` that depends on Request data (`cookies()`, etc...) or external data (`fetch(...)`, etc...) but the rest of the route was static or only used cached data (`\"use cache\"`). If you expected this route to be prerenderable update your `generateMetadata` to not use Request data and only use cached external data. Otherwise, add `await connection()` somewhere within this route to indicate explicitly it should not be prerendered.'\n-        )\n+        if (WITH_PPR) {\n+          expect(next.cliOutput).toContain('◐ / ')\n+        } else {\n+          expect(next.cliOutput).toContain('ƒ / ')\n+        }\n+        const $ = await next.render$('/')\n+        expect($('#sentinel').text()).toBe('sentinel')\n       })\n     })\n \n@@ -209,7 +217,7 @@ function runTests(options: { withMinification: boolean }) {\n \n         expectError('Error occurred prerendering page \"/\"')\n         expectError(\n-          'Error: Route \"/\" has a `generateViewport` that depends on Request data (`cookies()`, etc...) or external data (`fetch(...)`, etc...) but the rest of the route was static or only used cached data (`\"use cache\"`). If you expected this route to be prerenderable update your `generateViewport` to not use Request data and only use cached external data. Otherwise, add `await connection()` somewhere within this route to indicate explicitly it should not be prerendered.'\n+          'Route \"/\" has a `generateViewport` that depends on Request data (`cookies()`, etc...) or uncached external data (`fetch(...)`, etc...) without explicitly allowing fully dynamic rendering. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport'\n         )\n       })\n     })\n@@ -241,17 +249,18 @@ function runTests(options: { withMinification: boolean }) {\n         }\n       })\n \n-      it('should partially prerender when all dynamic components are inside a Suspense boundary', async () => {\n+      it('should error the build if generateViewport is dynamic even if there are other uses of dynamic on the page', async () => {\n         try {\n           await next.start()\n         } catch {\n-          throw new Error('expected build not to fail for fully static project')\n+          // we expect the build to fail\n         }\n+        const expectError = createExpectError(next.cliOutput)\n \n-        expect(next.cliOutput).toContain('ƒ / ')\n-        const $ = await next.render$('/')\n-        expect($('#dynamic').text()).toBe('Dynamic')\n-        expect($('[data-fallback]').length).toBe(0)\n+        expectError('Error occurred prerendering page \"/\"')\n+        expectError(\n+          'Route \"/\" has a `generateViewport` that depends on Request data (`cookies()`, etc...) or uncached external data (`fetch(...)`, etc...) without explicitly allowing fully dynamic rendering. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport'\n+        )\n       })\n     })\n "
        },
        {
            "sha": "ebb13a7c5512b8eb32659cc4811b45d65b5945b2",
            "filename": "test/e2e/app-dir/dynamic-io-errors/fixtures/dynamic-metadata-static-route/app/page.tsx",
            "status": "modified",
            "additions": 6,
            "deletions": 4,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/c24c4ac3f5e8f1e55b4958d9be1cea033a9e3f3a/test%2Fe2e%2Fapp-dir%2Fdynamic-io-errors%2Ffixtures%2Fdynamic-metadata-static-route%2Fapp%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/c24c4ac3f5e8f1e55b4958d9be1cea033a9e3f3a/test%2Fe2e%2Fapp-dir%2Fdynamic-io-errors%2Ffixtures%2Fdynamic-metadata-static-route%2Fapp%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fdynamic-io-errors%2Ffixtures%2Fdynamic-metadata-static-route%2Fapp%2Fpage.tsx?ref=c24c4ac3f5e8f1e55b4958d9be1cea033a9e3f3a",
            "patch": "@@ -7,11 +7,13 @@ export default async function Page() {\n   return (\n     <>\n       <p>\n-        This page is static except for generateMetadata which does some IO. This\n-        is a build error because metadata is not wrapped in a Suspense boundary.\n-        We expect that if you intended for your metadata to be dynamic you will\n-        ensure your page is dynamic too\n+        This page is static except for metadata. Metadata can now be streamed in\n+        so if PPR is enabled we expect that the visual content of this page will\n+        be statically served and the metadata will be resumed dynamically. If\n+        this project is not PPR then we expect this page to just render\n+        dynamically.\n       </p>\n+      <span id=\"sentinel\">sentinel</span>\n     </>\n   )\n }"
        },
        {
            "sha": "8d18cdf066bb912bf7610253c213b8a0702437fa",
            "filename": "test/e2e/app-dir/dynamic-io-errors/fixtures/dynamic-metadata-static-with-suspense/app/page.tsx",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/c24c4ac3f5e8f1e55b4958d9be1cea033a9e3f3a/test%2Fe2e%2Fapp-dir%2Fdynamic-io-errors%2Ffixtures%2Fdynamic-metadata-static-with-suspense%2Fapp%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/c24c4ac3f5e8f1e55b4958d9be1cea033a9e3f3a/test%2Fe2e%2Fapp-dir%2Fdynamic-io-errors%2Ffixtures%2Fdynamic-metadata-static-with-suspense%2Fapp%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fdynamic-io-errors%2Ffixtures%2Fdynamic-metadata-static-with-suspense%2Fapp%2Fpage.tsx?ref=c24c4ac3f5e8f1e55b4958d9be1cea033a9e3f3a",
            "patch": "@@ -12,6 +12,7 @@ export default async function Page() {\n         We expect that if you intended for your metadata to be dynamic you will\n         ensure your page is dynamic too\n       </p>\n+      <span id=\"sentinel\">sentinel</span>\n     </>\n   )\n }"
        },
        {
            "sha": "e92d753f7484c1a88dda5a9bdcf7fd42c19998de",
            "filename": "test/e2e/app-dir/dynamic-io-errors/fixtures/dynamic-viewport-dynamic-route/app/page.tsx",
            "status": "modified",
            "additions": 6,
            "deletions": 4,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/c24c4ac3f5e8f1e55b4958d9be1cea033a9e3f3a/test%2Fe2e%2Fapp-dir%2Fdynamic-io-errors%2Ffixtures%2Fdynamic-viewport-dynamic-route%2Fapp%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/c24c4ac3f5e8f1e55b4958d9be1cea033a9e3f3a/test%2Fe2e%2Fapp-dir%2Fdynamic-io-errors%2Ffixtures%2Fdynamic-viewport-dynamic-route%2Fapp%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fdynamic-io-errors%2Ffixtures%2Fdynamic-viewport-dynamic-route%2Fapp%2Fpage.tsx?ref=c24c4ac3f5e8f1e55b4958d9be1cea033a9e3f3a",
            "patch": "@@ -9,10 +9,12 @@ export default async function Page() {\n   return (\n     <>\n       <p>\n-        This page is static except for generateViewport which does some IO. This\n-        is a build error because metadata is not wrapped in a Suspense boundary.\n-        We expect that if you intended for your metadata to be dynamic you will\n-        ensure your page is dynamic too\n+        This page is dynamic and also has dynamic `generateViewport`. This is a\n+        build error because anything dynamic must be wrapped in a Suspense\n+        boundary. While you aren't directly in control of where viewport renders\n+        it semantically renders as part of the page preamble and so you must put\n+        a Suspense boundary around the root layout to opt into allowing dynamic\n+        in generateViewport.\n       </p>\n       <Suspense fallback={<Fallback />}>\n         <Dynamic />"
        },
        {
            "sha": "3b9364b1ef019572df74a9bde210eafd721f5f14",
            "filename": "test/e2e/app-dir/dynamic-io-errors/fixtures/dynamic-viewport-static-route/app/page.tsx",
            "status": "modified",
            "additions": 6,
            "deletions": 4,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/c24c4ac3f5e8f1e55b4958d9be1cea033a9e3f3a/test%2Fe2e%2Fapp-dir%2Fdynamic-io-errors%2Ffixtures%2Fdynamic-viewport-static-route%2Fapp%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/c24c4ac3f5e8f1e55b4958d9be1cea033a9e3f3a/test%2Fe2e%2Fapp-dir%2Fdynamic-io-errors%2Ffixtures%2Fdynamic-viewport-static-route%2Fapp%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fdynamic-io-errors%2Ffixtures%2Fdynamic-viewport-static-route%2Fapp%2Fpage.tsx?ref=c24c4ac3f5e8f1e55b4958d9be1cea033a9e3f3a",
            "patch": "@@ -7,10 +7,12 @@ export default async function Page() {\n   return (\n     <>\n       <p>\n-        This page is static except for generateViewport which does some IO. This\n-        is a build error because metadata is not wrapped in a Suspense boundary.\n-        We expect that if you intended for your metadata to be dynamic you will\n-        ensure your page is dynamic too\n+        This page is static except for `generateViewport`. This is a build error\n+        because anything dynamic must be wrapped in a Suspense boundary. While\n+        you aren't directly in control of where viewport renders it semantically\n+        renders as part of the page preamble and so you must put a Suspense\n+        boundary around the root layout to opt into allowing dynamic in\n+        generateViewport.\n       </p>\n     </>\n   )"
        },
        {
            "sha": "ff40097a83922de10f7fc9c055309589348c60a1",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-scheduling/app/layout.tsx",
            "status": "modified",
            "additions": 7,
            "deletions": 3,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/c24c4ac3f5e8f1e55b4958d9be1cea033a9e3f3a/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-scheduling%2Fapp%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/c24c4ac3f5e8f1e55b4958d9be1cea033a9e3f3a/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-scheduling%2Fapp%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-scheduling%2Fapp%2Flayout.tsx?ref=c24c4ac3f5e8f1e55b4958d9be1cea033a9e3f3a",
            "patch": "@@ -1,11 +1,15 @@\n+import { Suspense } from 'react'\n+\n export default function RootLayout({\n   children,\n }: {\n   children: React.ReactNode\n }) {\n   return (\n-    <html lang=\"en\">\n-      <body>{children}</body>\n-    </html>\n+    <Suspense>\n+      <html lang=\"en\">\n+        <body>{children}</body>\n+      </html>\n+    </Suspense>\n   )\n }"
        }
    ],
    "stats": {
        "total": 517,
        "additions": 328,
        "deletions": 189
    }
}