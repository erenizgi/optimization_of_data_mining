{
    "author": "bgub",
    "message": "feat: type guard file generation (#81400)\n\n## Overview\nGenerates `.next/types/validator.ts` - a single TypeScript file that\nvalidates all route exports using the `satisfies` operator. Replaces the\nold `next-types-plugin` webpack plugin.\n\n## Why needed\n- **Turbopack compatibility**: Old webpack plugin didn't work with\nTurbopack\n- **Performance**: Single large file vs hundreds of small validation\nfiles\n- **Type safety**: Catches invalid exports like `dynamic =\n'invalid-value'`\n\n## Validation Structure\n```typescript\n// Type definitions\ntype PageConfig = {\n  default: React.ComponentType<any>\n  config?: {}\n  generateMetadata?: (props: any, parent: any) => Promise<any> | any\n  dynamic?: 'auto' | 'force-dynamic' | 'error' | 'force-static'\n  // ... other Next.js exports\n}\n\n// Validation checks\n\n// Validate app/page.tsx\n{\n  const handler = {} as typeof import(\"../../app/page\")\n  handler satisfies PageConfig\n}\n...\n```\n\n## Example Usage\n```typescript\n// app/blog/[slug]/page.tsx\nexport const dynamic = 'some-random-string' // ← Type error caught!\n\nexport default async function BlogPostPage(props: PageProps<'/blog/[slug]'>) {\n  const params = await props.params\n  return <div>Blog Post: {params.slug}</div>\n}\n```\n\n## Key Benefits\n- **Build-time validation**: Catches invalid route exports during\nTypeScript compilation\n- **Turbopack support**: Works with both webpack and Turbopack\n- **Better performance**: One file instead of hundreds of small type\nguard files",
    "sha": "f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c",
    "files": [
        {
            "sha": "6b3cd231cb7b33b1b95e1ee62b8722ba28709db6",
            "filename": "packages/next/src/build/entries.ts",
            "status": "modified",
            "additions": 124,
            "deletions": 33,
            "changes": 157,
            "blob_url": "https://github.com/vercel/next.js/blob/f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c/packages%2Fnext%2Fsrc%2Fbuild%2Fentries.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c/packages%2Fnext%2Fsrc%2Fbuild%2Fentries.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fentries.ts?ref=f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c",
            "patch": "@@ -76,37 +76,36 @@ import type { MappedPages } from './build-context'\n import { PAGE_TYPES } from '../lib/page-types'\n import { isAppPageRoute } from '../lib/is-app-page-route'\n import { recursiveReadDir } from '../lib/recursive-readdir'\n-import { createValidFileMatcher } from '../server/lib/find-page-file'\n+import type { createValidFileMatcher } from '../server/lib/find-page-file'\n import { isReservedPage } from './utils'\n import { isParallelRouteSegment } from '../shared/lib/segment'\n import { ensureLeadingSlash } from '../shared/lib/page-path/ensure-leading-slash'\n \n /**\n- * Collect app pages and layouts from the app directory\n+ * Collect app pages, layouts, and default files from the app directory\n  * @param appDir - The app directory path\n- * @param pageExtensions - The configured page extensions\n- * @param options - Optional configuration\n- * @returns Object containing appPaths and layoutPaths arrays\n+ * @param validFileMatcher - File matcher object\n+ * @returns Object containing appPaths, layoutPaths, and defaultPaths arrays\n  */\n export async function collectAppFiles(\n   appDir: string,\n-  pageExtensions: PageExtensions\n+  validFileMatcher: ReturnType<typeof createValidFileMatcher>\n ): Promise<{\n   appPaths: string[]\n   layoutPaths: string[]\n+  defaultPaths: string[]\n }> {\n-  const validFileMatcher = createValidFileMatcher(pageExtensions, appDir)\n-\n-  // Collect both app pages and layouts in a single directory traversal\n+  // Collect app pages, layouts, and default files in a single directory traversal\n   const allAppFiles = await recursiveReadDir(appDir, {\n     pathnameFilter: (absolutePath) =>\n       validFileMatcher.isAppRouterPage(absolutePath) ||\n       validFileMatcher.isRootNotFound(absolutePath) ||\n-      validFileMatcher.isAppLayoutPage(absolutePath),\n+      validFileMatcher.isAppLayoutPage(absolutePath) ||\n+      validFileMatcher.isAppDefaultPage(absolutePath),\n     ignorePartFilter: (part) => part.startsWith('_'),\n   })\n \n-  // Separate app pages from layouts\n+  // Separate app pages, layouts, and defaults\n   const appPaths = allAppFiles.filter(\n     (absolutePath) =>\n       validFileMatcher.isAppRouterPage(absolutePath) ||\n@@ -115,26 +114,25 @@ export async function collectAppFiles(\n   const layoutPaths = allAppFiles.filter((absolutePath) =>\n     validFileMatcher.isAppLayoutPage(absolutePath)\n   )\n+  const defaultPaths = allAppFiles.filter((absolutePath) =>\n+    validFileMatcher.isAppDefaultPage(absolutePath)\n+  )\n \n-  return { appPaths, layoutPaths }\n+  return { appPaths, layoutPaths, defaultPaths }\n }\n \n /**\n  * Collect pages from the pages directory\n  * @param pagesDir - The pages directory path\n- * @param pageExtensions - The configured page extensions\n+ * @param validFileMatcher - File matcher object\n  * @returns Array of page file paths\n  */\n export async function collectPagesFiles(\n   pagesDir: string,\n-  pageExtensions: PageExtensions\n+  validFileMatcher: ReturnType<typeof createValidFileMatcher>\n ): Promise<string[]> {\n   return recursiveReadDir(pagesDir, {\n-    pathnameFilter: (absolutePath) => {\n-      const relativePath = absolutePath.replace(pagesDir + '/', '')\n-      return pageExtensions.some((ext) => relativePath.endsWith(`.${ext}`))\n-    },\n-    ignorePartFilter: (part) => part.startsWith('_'),\n+    pathnameFilter: validFileMatcher.isPageFile,\n   })\n }\n \n@@ -154,30 +152,35 @@ export type SlotInfo = {\n  * @param baseDir - The base directory path\n  * @param filePath - The mapped file path (with private prefix)\n  * @param prefix - The directory prefix ('pages' or 'app')\n+ * @param isSrcDir - Whether the project uses src directory structure\n  * @returns The relative file path\n  */\n export function createRelativeFilePath(\n   baseDir: string,\n   filePath: string,\n-  prefix: 'pages' | 'app'\n+  prefix: 'pages' | 'app',\n+  isSrcDir: boolean\n ): string {\n   const privatePrefix =\n     prefix === 'pages' ? 'private-next-pages' : 'private-next-app-dir'\n+  const srcPrefix = isSrcDir ? 'src/' : ''\n   return join(\n     baseDir,\n-    filePath.replace(new RegExp(`^${privatePrefix}/`), `${prefix}/`)\n+    filePath.replace(new RegExp(`^${privatePrefix}/`), `${srcPrefix}${prefix}/`)\n   )\n }\n \n /**\n  * Process pages routes from mapped pages\n  * @param mappedPages - The mapped pages object\n  * @param baseDir - The base directory path\n+ * @param isSrcDir - Whether the project uses src directory structure\n  * @returns Object containing pageRoutes and pageApiRoutes\n  */\n export function processPageRoutes(\n   mappedPages: { [page: string]: string },\n-  baseDir: string\n+  baseDir: string,\n+  isSrcDir: boolean\n ): {\n   pageRoutes: RouteInfo[]\n   pageApiRoutes: RouteInfo[]\n@@ -186,7 +189,12 @@ export function processPageRoutes(\n   const pageApiRoutes: RouteInfo[] = []\n \n   for (const [route, filePath] of Object.entries(mappedPages)) {\n-    const relativeFilePath = createRelativeFilePath(baseDir, filePath, 'pages')\n+    const relativeFilePath = createRelativeFilePath(\n+      baseDir,\n+      filePath,\n+      'pages',\n+      isSrcDir\n+    )\n \n     if (route.startsWith('/api/')) {\n       pageApiRoutes.push({\n@@ -243,46 +251,129 @@ export function extractSlotsFromAppRoutes(mappedAppPages: {\n   return slots\n }\n \n+/**\n+ * Extract slots from default files\n+ * @param mappedDefaultFiles - The mapped default files object\n+ * @returns Array of slot information\n+ */\n+export function extractSlotsFromDefaultFiles(mappedDefaultFiles: {\n+  [page: string]: string\n+}): SlotInfo[] {\n+  const slots: SlotInfo[] = []\n+\n+  for (const [route] of Object.entries(mappedDefaultFiles)) {\n+    const segments = route.split('/')\n+    for (let i = segments.length - 1; i >= 0; i--) {\n+      const segment = segments[i]\n+      if (isParallelRouteSegment(segment)) {\n+        const parentPath = normalizeAppPath(segments.slice(0, i).join('/'))\n+        const slotName = segment.slice(1)\n+\n+        // Check if the slot already exists\n+        if (slots.some((s) => s.name === slotName && s.parent === parentPath))\n+          continue\n+\n+        slots.push({\n+          name: slotName,\n+          parent: parentPath,\n+        })\n+        break\n+      }\n+    }\n+  }\n+\n+  return slots\n+}\n+\n+/**\n+ * Combine and deduplicate slot arrays using a Set\n+ * @param slotArrays - Arrays of slot information to combine\n+ * @returns Deduplicated array of slots\n+ */\n+export function combineSlots(...slotArrays: SlotInfo[][]): SlotInfo[] {\n+  const slotSet = new Set<string>()\n+  const result: SlotInfo[] = []\n+\n+  for (const slots of slotArrays) {\n+    for (const slot of slots) {\n+      const key = `${slot.name}:${slot.parent}`\n+      if (!slotSet.has(key)) {\n+        slotSet.add(key)\n+        result.push(slot)\n+      }\n+    }\n+  }\n+\n+  return result\n+}\n+\n /**\n  * Process app routes from mapped app pages\n  * @param mappedAppPages - The mapped app pages object\n+ * @param validFileMatcher - File matcher object\n  * @param baseDir - The base directory path\n+ * @param isSrcDir - Whether the project uses src directory structure\n  * @returns Array of route information\n  */\n export function processAppRoutes(\n   mappedAppPages: { [page: string]: string },\n-  baseDir: string\n-): RouteInfo[] {\n+  validFileMatcher: ReturnType<typeof createValidFileMatcher>,\n+  baseDir: string,\n+  isSrcDir: boolean\n+): {\n+  appRoutes: RouteInfo[]\n+  appRouteHandlers: RouteInfo[]\n+} {\n   const appRoutes: RouteInfo[] = []\n+  const appRouteHandlers: RouteInfo[] = []\n \n   for (const [route, filePath] of Object.entries(mappedAppPages)) {\n     if (route === '/_not-found/page') continue\n \n-    const relativeFilePath = createRelativeFilePath(baseDir, filePath, 'app')\n+    const relativeFilePath = createRelativeFilePath(\n+      baseDir,\n+      filePath,\n+      'app',\n+      isSrcDir\n+    )\n \n-    appRoutes.push({\n-      route: normalizeAppPath(normalizePathSep(route)),\n-      filePath: relativeFilePath,\n-    })\n+    if (validFileMatcher.isAppRouterRoute(filePath)) {\n+      appRouteHandlers.push({\n+        route: normalizeAppPath(normalizePathSep(route)),\n+        filePath: relativeFilePath,\n+      })\n+    } else {\n+      appRoutes.push({\n+        route: normalizeAppPath(normalizePathSep(route)),\n+        filePath: relativeFilePath,\n+      })\n+    }\n   }\n \n-  return appRoutes\n+  return { appRoutes, appRouteHandlers }\n }\n \n /**\n  * Process layout routes from mapped app layouts\n  * @param mappedAppLayouts - The mapped app layouts object\n  * @param baseDir - The base directory path\n+ * @param isSrcDir - Whether the project uses src directory structure\n  * @returns Array of layout route information\n  */\n export function processLayoutRoutes(\n   mappedAppLayouts: { [page: string]: string },\n-  baseDir: string\n+  baseDir: string,\n+  isSrcDir: boolean\n ): RouteInfo[] {\n   const layoutRoutes: RouteInfo[] = []\n \n   for (const [route, filePath] of Object.entries(mappedAppLayouts)) {\n-    const relativeFilePath = createRelativeFilePath(baseDir, filePath, 'app')\n+    const relativeFilePath = createRelativeFilePath(\n+      baseDir,\n+      filePath,\n+      'app',\n+      isSrcDir\n+    )\n     layoutRoutes.push({\n       route: ensureLeadingSlash(\n         normalizeAppPath(normalizePathSep(route)).replace(/\\/layout$/, '')"
        },
        {
            "sha": "cffba97079d7f9d16e58bcb1be17ff03d6d24735",
            "filename": "packages/next/src/build/index.ts",
            "status": "modified",
            "additions": 62,
            "deletions": 20,
            "changes": 82,
            "blob_url": "https://github.com/vercel/next.js/blob/f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts?ref=f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c",
            "patch": "@@ -115,8 +115,11 @@ import {\n   processAppRoutes,\n   processLayoutRoutes,\n   extractSlotsFromAppRoutes,\n+  extractSlotsFromDefaultFiles,\n+  combineSlots,\n   type RouteInfo,\n   type SlotInfo,\n+  collectPagesFiles,\n } from './entries'\n import { PAGE_TYPES } from '../lib/page-types'\n import { generateBuildId } from './generate-build-id'\n@@ -145,7 +148,6 @@ import isError from '../lib/is-error'\n import type { NextError } from '../lib/is-error'\n import { isEdgeRuntime } from '../lib/is-edge-runtime'\n import { recursiveCopy } from '../lib/recursive-copy'\n-import { recursiveReadDir } from '../lib/recursive-readdir'\n import { lockfilePatchPromise, teardownTraceSubscriber } from './swc'\n import { getNamedRouteRegex } from '../shared/lib/router/utils/route-regex'\n import { getFilesInDir } from '../lib/get-files-in-dir'\n@@ -218,9 +220,11 @@ import {\n   sortPages,\n   sortSortableRouteObjects,\n } from '../shared/lib/router/utils/sortable-routes'\n+import { mkdir } from 'fs/promises'\n import {\n   createRouteTypesManifest,\n   writeRouteTypesManifest,\n+  writeValidatorFile,\n } from '../server/lib/router-utils/route-types-utils'\n \n type Fallback = null | boolean | string\n@@ -1120,11 +1124,9 @@ export default async function build(\n       let pagesPaths = Boolean(process.env.NEXT_PRIVATE_PAGE_PATHS)\n         ? providedPagePaths\n         : !appDirOnly && pagesDir\n-          ? await nextBuildSpan.traceChild('collect-pages').traceAsyncFn(() =>\n-              recursiveReadDir(pagesDir, {\n-                pathnameFilter: validFileMatcher.isPageFile,\n-              })\n-            )\n+          ? await nextBuildSpan\n+              .traceChild('collect-pages')\n+              .traceAsyncFn(() => collectPagesFiles(pagesDir, validFileMatcher))\n           : []\n \n       const middlewareDetectionRegExp = new RegExp(\n@@ -1190,16 +1192,18 @@ export default async function build(\n         let layoutPaths: string[]\n \n         if (Boolean(process.env.NEXT_PRIVATE_APP_PATHS)) {\n+          // used for testing?\n           appPaths = providedAppPaths\n           layoutPaths = []\n         } else {\n-          // Collect both app pages and layouts in a single directory traversal\n+          // Collect app pages, layouts, and default files in a single directory traversal\n           const result = await nextBuildSpan\n             .traceChild('collect-app-files')\n-            .traceAsyncFn(() => collectAppFiles(appDir, config.pageExtensions))\n+            .traceAsyncFn(() => collectAppFiles(appDir, validFileMatcher))\n \n           appPaths = result.appPaths\n           layoutPaths = result.layoutPaths\n+          // Note: defaultPaths are not used in the build process, only for slot detection in generating route types\n         }\n \n         mappedAppPages = await nextBuildSpan\n@@ -1280,47 +1284,85 @@ export default async function build(\n         .traceChild('generate-route-types')\n         .traceAsyncFn(async () => {\n           const routeTypesFilePath = path.join(distDir, 'types', 'routes.d.ts')\n-          await fs.mkdir(path.dirname(routeTypesFilePath), { recursive: true })\n+          const validatorFilePath = path.join(distDir, 'types', 'validator.ts')\n+          await mkdir(path.dirname(routeTypesFilePath), { recursive: true })\n \n-          let pageRoutes: RouteInfo[] = []\n           let appRoutes: RouteInfo[] = []\n+          let appRouteHandlers: RouteInfo[] = []\n           let layoutRoutes: RouteInfo[] = []\n           let slots: SlotInfo[] = []\n \n-          // Build pages routes\n-          const processedPages = processPageRoutes(mappedPages, dir)\n-          // We combine both page routes and API routes\n-          pageRoutes = [\n-            ...processedPages.pageRoutes,\n-            ...processedPages.pageApiRoutes,\n-          ]\n+          const { pageRoutes, pageApiRoutes } = processPageRoutes(\n+            mappedPages,\n+            dir,\n+            isSrcDir\n+          )\n \n           // Build app routes\n           if (appDir && mappedAppPages) {\n-            slots = extractSlotsFromAppRoutes(mappedAppPages)\n-            appRoutes = processAppRoutes(mappedAppPages, dir)\n+            // Extract slots from both pages and default files\n+            const slotsFromPages = extractSlotsFromAppRoutes(mappedAppPages)\n+            let slotsFromDefaults: SlotInfo[] = []\n+\n+            // Collect and map default files for slot extraction\n+            const { defaultPaths } = await nextBuildSpan\n+              .traceChild('collect-default-files')\n+              .traceAsyncFn(() => collectAppFiles(appDir, validFileMatcher))\n+\n+            if (defaultPaths.length > 0) {\n+              const mappedDefaultFiles = await nextBuildSpan\n+                .traceChild('create-default-mapping')\n+                .traceAsyncFn(() =>\n+                  createPagesMapping({\n+                    pagePaths: defaultPaths,\n+                    isDev: false,\n+                    pagesType: PAGE_TYPES.APP,\n+                    pageExtensions: config.pageExtensions,\n+                    pagesDir,\n+                    appDir,\n+                  })\n+                )\n+              slotsFromDefaults =\n+                extractSlotsFromDefaultFiles(mappedDefaultFiles)\n+            }\n+\n+            // Combine slots and deduplicate using Set\n+            slots = combineSlots(slotsFromPages, slotsFromDefaults)\n+\n+            const result = processAppRoutes(\n+              mappedAppPages,\n+              validFileMatcher,\n+              dir,\n+              isSrcDir\n+            )\n+            appRoutes = result.appRoutes\n+            appRouteHandlers = result.appRouteHandlers\n           }\n \n           // Build app layouts\n           if (appDir && mappedAppLayouts) {\n-            layoutRoutes = processLayoutRoutes(mappedAppLayouts, dir)\n+            layoutRoutes = processLayoutRoutes(mappedAppLayouts, dir, isSrcDir)\n           }\n \n           const routeTypesManifest = await createRouteTypesManifest({\n             dir,\n             pageRoutes,\n             appRoutes,\n+            appRouteHandlers,\n+            pageApiRoutes,\n             layoutRoutes,\n             slots,\n             redirects: config.redirects,\n             rewrites: config.rewrites,\n+            validatorFilePath,\n           })\n \n           await writeRouteTypesManifest(\n             routeTypesManifest,\n             routeTypesFilePath,\n             config\n           )\n+          await writeValidatorFile(routeTypesManifest, validatorFilePath)\n         })\n \n       // Turbopack already handles conflicting app and page routes."
        },
        {
            "sha": "828f4957ad08b4371b50aaa59054e2b4280d1d57",
            "filename": "packages/next/src/cli/next-typegen.ts",
            "status": "modified",
            "additions": 45,
            "deletions": 15,
            "changes": 60,
            "blob_url": "https://github.com/vercel/next.js/blob/f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c/packages%2Fnext%2Fsrc%2Fcli%2Fnext-typegen.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c/packages%2Fnext%2Fsrc%2Fcli%2Fnext-typegen.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcli%2Fnext-typegen.ts?ref=f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c",
            "patch": "@@ -1,7 +1,7 @@\n #!/usr/bin/env node\n \n import { existsSync } from 'fs'\n-import { join } from 'path'\n+import path, { join } from 'path'\n import { mkdir } from 'fs/promises'\n \n import loadConfig from '../server/config'\n@@ -18,6 +18,8 @@ import {\n   processAppRoutes,\n   processLayoutRoutes,\n   extractSlotsFromAppRoutes,\n+  extractSlotsFromDefaultFiles,\n+  combineSlots,\n   type RouteInfo,\n   type SlotInfo,\n } from '../build/entries'\n@@ -26,7 +28,9 @@ import { PAGE_TYPES } from '../lib/page-types'\n import {\n   createRouteTypesManifest,\n   writeRouteTypesManifest,\n+  writeValidatorFile,\n } from '../server/lib/router-utils/route-types-utils'\n+import { createValidFileMatcher } from '../server/lib/find-page-file'\n \n export type NextTypegenOptions = {\n   dir?: string\n@@ -61,14 +65,16 @@ const nextTypegen = async (\n   console.log('Generating route types...')\n \n   const routeTypesFilePath = join(distDir, 'types', 'routes.d.ts')\n+  const validatorFilePath = join(distDir, 'types', 'validator.ts')\n   await mkdir(join(distDir, 'types'), { recursive: true })\n \n   let pageRoutes: RouteInfo[] = []\n   let appRoutes: RouteInfo[] = []\n+  let appRouteHandlers: RouteInfo[] = []\n   let layoutRoutes: RouteInfo[] = []\n   let slots: SlotInfo[] = []\n \n-  let _pageApiRoutes: RouteInfo[] = []\n+  let pageApiRoutes: RouteInfo[] = []\n \n   let mappedPages: { [page: string]: string } = {}\n   let mappedAppPages: { [page: string]: string } = {}\n@@ -85,48 +91,70 @@ const nextTypegen = async (\n       appDir,\n     })\n \n+  const validFileMatcher = createValidFileMatcher(\n+    nextConfig.pageExtensions,\n+    appDir\n+  )\n+\n+  const isSrcDir = path\n+    .relative(baseDir, pagesDir || appDir || '')\n+    .startsWith('src')\n+\n   // Build pages routes\n   if (pagesDir) {\n-    const pagePaths = await collectPagesFiles(\n-      pagesDir,\n-      nextConfig.pageExtensions\n-    )\n+    const pagePaths = await collectPagesFiles(pagesDir, validFileMatcher)\n \n     mappedPages = await createMapping(pagePaths, PAGE_TYPES.PAGES)\n \n     // Process pages routes\n-    const processedPages = processPageRoutes(mappedPages, baseDir)\n+    const processedPages = processPageRoutes(mappedPages, baseDir, isSrcDir)\n     pageRoutes = processedPages.pageRoutes\n-    _pageApiRoutes = processedPages.pageApiRoutes\n+    pageApiRoutes = processedPages.pageApiRoutes\n   }\n \n   // Build app routes\n   if (appDir) {\n-    // Collect both app pages and layouts in a single directory traversal\n-    const { appPaths, layoutPaths } = await collectAppFiles(\n+    // Collect app pages, layouts, and default files in a single directory traversal\n+    const { appPaths, layoutPaths, defaultPaths } = await collectAppFiles(\n       appDir,\n-      nextConfig.pageExtensions\n+      validFileMatcher\n     )\n \n     mappedAppPages = await createMapping(appPaths, PAGE_TYPES.APP)\n     mappedAppLayouts = await createMapping(layoutPaths, PAGE_TYPES.APP)\n+    const mappedDefaultFiles = await createMapping(defaultPaths, PAGE_TYPES.APP)\n \n-    // Process app routes and extract slots\n-    slots = extractSlotsFromAppRoutes(mappedAppPages)\n-    appRoutes = processAppRoutes(mappedAppPages, baseDir)\n+    // Process app routes and extract slots from both pages and default files\n+    const slotsFromPages = extractSlotsFromAppRoutes(mappedAppPages)\n+    const slotsFromDefaults = extractSlotsFromDefaultFiles(mappedDefaultFiles)\n+\n+    // Combine slots and deduplicate using Set\n+    slots = combineSlots(slotsFromPages, slotsFromDefaults)\n+\n+    const result = processAppRoutes(\n+      mappedAppPages,\n+      validFileMatcher,\n+      baseDir,\n+      isSrcDir\n+    )\n+    appRoutes = result.appRoutes\n+    appRouteHandlers = result.appRouteHandlers\n \n     // Process layout routes\n-    layoutRoutes = processLayoutRoutes(mappedAppLayouts, baseDir)\n+    layoutRoutes = processLayoutRoutes(mappedAppLayouts, baseDir, isSrcDir)\n   }\n \n   const routeTypesManifest = await createRouteTypesManifest({\n     dir: baseDir,\n     pageRoutes,\n     appRoutes,\n+    appRouteHandlers,\n+    pageApiRoutes,\n     layoutRoutes,\n     slots,\n     redirects: nextConfig.redirects,\n     rewrites: nextConfig.rewrites,\n+    validatorFilePath,\n   })\n \n   await writeRouteTypesManifest(\n@@ -135,6 +163,8 @@ const nextTypegen = async (\n     nextConfig\n   )\n \n+  await writeValidatorFile(routeTypesManifest, validatorFilePath)\n+\n   console.log('✓ Route types generated successfully')\n }\n "
        },
        {
            "sha": "c6c7051fb45ecc2fd29fba771c7c6ea5ac137a31",
            "filename": "packages/next/src/server/lib/find-page-file.ts",
            "status": "modified",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Ffind-page-file.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Ffind-page-file.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Ffind-page-file.ts?ref=f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c",
            "patch": "@@ -90,12 +90,19 @@ export function createValidFileMatcher(\n       pageExtensions\n     )}$`\n   )\n+\n+  const leafOnlyRouteFileRegex = new RegExp(\n+    `(^route|[\\\\\\\\/]route)\\\\.${getExtensionRegexString(pageExtensions)}$`\n+  )\n   const leafOnlyLayoutFileRegex = new RegExp(\n     `(^(layout)|[\\\\\\\\/](layout))\\\\.${getExtensionRegexString(pageExtensions)}$`\n   )\n   const rootNotFoundFileRegex = new RegExp(\n     `^not-found\\\\.${getExtensionRegexString(pageExtensions)}$`\n   )\n+  const leafOnlyDefaultFileRegex = new RegExp(\n+    `(^(default)|[\\\\\\\\/](default))\\\\.${getExtensionRegexString(pageExtensions)}$`\n+  )\n   /** TODO-METADATA: support other metadata routes\n    *  regex for:\n    *\n@@ -126,10 +133,19 @@ export function createValidFileMatcher(\n     return leafOnlyPageFileRegex.test(filePath) || isMetadataFile(filePath)\n   }\n \n+  // Determine if the file is leaf node route file under app directory\n+  function isAppRouterRoute(filePath: string) {\n+    return leafOnlyRouteFileRegex.test(filePath)\n+  }\n+\n   function isAppLayoutPage(filePath: string) {\n     return leafOnlyLayoutFileRegex.test(filePath)\n   }\n \n+  function isAppDefaultPage(filePath: string) {\n+    return leafOnlyDefaultFileRegex.test(filePath)\n+  }\n+\n   function isPageFile(filePath: string) {\n     return validExtensionFileRegex.test(filePath) || isMetadataFile(filePath)\n   }\n@@ -148,7 +164,9 @@ export function createValidFileMatcher(\n   return {\n     isPageFile,\n     isAppRouterPage,\n+    isAppRouterRoute,\n     isAppLayoutPage,\n+    isAppDefaultPage,\n     isMetadataFile,\n     isRootNotFound,\n   }"
        },
        {
            "sha": "058d7376945607de5b89ebc157f70cac5cfb8cd6",
            "filename": "packages/next/src/server/lib/router-utils/route-types-utils.ts",
            "status": "modified",
            "additions": 126,
            "deletions": 27,
            "changes": 153,
            "blob_url": "https://github.com/vercel/next.js/blob/f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Froute-types-utils.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Froute-types-utils.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Froute-types-utils.ts?ref=f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c",
            "patch": "@@ -4,10 +4,18 @@ import {\n   type Group,\n } from '../../../shared/lib/router/utils/route-regex'\n import type { NextConfigComplete } from '../../config-shared'\n-import { isParallelRouteSegment } from '../../../shared/lib/segment'\n+\n import fs from 'fs'\n-import { generateRouteTypesFile, generateLinkTypesFile } from './typegen'\n+import {\n+  generateRouteTypesFile,\n+  generateLinkTypesFile,\n+  generateValidatorFile,\n+} from './typegen'\n import { tryToParsePath } from '../../../lib/try-to-parse-path'\n+import {\n+  extractInterceptionRouteInformation,\n+  isInterceptionRouteAppPath,\n+} from '../../../shared/lib/router/utils/interception-routes'\n \n interface RouteInfo {\n   path: string\n@@ -18,10 +26,19 @@ export interface RouteTypesManifest {\n   appRoutes: Record<string, RouteInfo>\n   pageRoutes: Record<string, RouteInfo>\n   layoutRoutes: Record<string, RouteInfo & { slots: string[] }>\n+  appRouteHandlerRoutes: Record<string, RouteInfo>\n   /** Map of redirect source => RouteInfo */\n   redirectRoutes: Record<string, RouteInfo>\n   /** Map of rewrite source => RouteInfo */\n   rewriteRoutes: Record<string, RouteInfo>\n+  /** File paths for validation */\n+  appPagePaths: Set<string>\n+  pagesRouterPagePaths: Set<string>\n+  layoutPaths: Set<string>\n+  appRouteHandlers: Set<string>\n+  pageApiRoutes: Set<string>\n+  /** Direct mapping from file paths to routes for validation */\n+  filePathToRoute: Map<string, string>\n }\n \n // Convert a custom-route source string (`/blog/:slug`, `/docs/:path*`, ...)\n@@ -102,22 +119,20 @@ export function extractRouteParams(route: string) {\n   return regex.groups\n }\n \n-function isCanonicalRoute(route: string) {\n-  const segments = route.split('/')\n-  for (let i = segments.length - 1; i >= 0; i--) {\n-    const segment = segments[i]\n-\n-    if (\n-      isParallelRouteSegment(segment) ||\n-      segment.startsWith('(.)') ||\n-      segment.startsWith('(..)') ||\n-      segment.startsWith('(...)')\n-    ) {\n-      return false\n-    }\n+/**\n+ * Resolves an intercepting route to its canonical equivalent\n+ * Example: /gallery/test/(..)photo/[id] -> /gallery/photo/[id]\n+ */\n+function resolveInterceptingRoute(route: string): string {\n+  // Reuse centralized interception route normalization logic\n+  try {\n+    if (!isInterceptionRouteAppPath(route)) return route\n+    const { interceptedRoute } = extractInterceptionRouteInformation(route)\n+    return interceptedRoute\n+  } catch {\n+    // If parsing fails, fall back to the original route\n+    return route\n   }\n-\n-  return true\n }\n \n /**\n@@ -128,43 +143,88 @@ export async function createRouteTypesManifest({\n   dir,\n   pageRoutes,\n   appRoutes,\n+  appRouteHandlers,\n+  pageApiRoutes,\n   layoutRoutes,\n   slots,\n   redirects,\n   rewrites,\n+  validatorFilePath,\n }: {\n   dir: string\n   pageRoutes: Array<{ route: string; filePath: string }>\n   appRoutes: Array<{ route: string; filePath: string }>\n+  appRouteHandlers: Array<{ route: string; filePath: string }>\n+  pageApiRoutes: Array<{ route: string; filePath: string }>\n   layoutRoutes: Array<{ route: string; filePath: string }>\n   slots: Array<{ name: string; parent: string }>\n   redirects?: NextConfigComplete['redirects']\n   rewrites?: NextConfigComplete['rewrites']\n+  validatorFilePath?: string\n }): Promise<RouteTypesManifest> {\n+  // Helper function to calculate the correct relative path\n+  const getRelativePath = (filePath: string) => {\n+    if (validatorFilePath) {\n+      // For validator generation, calculate path relative to validator directory\n+      return path.relative(path.dirname(validatorFilePath), filePath)\n+    }\n+    // For other uses, calculate path relative to project directory\n+    return path.relative(dir, filePath)\n+  }\n+\n   const manifest: RouteTypesManifest = {\n     appRoutes: {},\n     pageRoutes: {},\n     layoutRoutes: {},\n+    appRouteHandlerRoutes: {},\n     redirectRoutes: {},\n     rewriteRoutes: {},\n+    appRouteHandlers: new Set(appRouteHandlers.map(({ filePath }) => filePath)),\n+    pageApiRoutes: new Set(pageApiRoutes.map(({ filePath }) => filePath)),\n+    appPagePaths: new Set(appRoutes.map(({ filePath }) => filePath)),\n+    pagesRouterPagePaths: new Set(pageRoutes.map(({ filePath }) => filePath)),\n+    layoutPaths: new Set(layoutRoutes.map(({ filePath }) => filePath)),\n+    filePathToRoute: new Map([\n+      ...appRoutes.map(\n+        ({ route, filePath }) =>\n+          [filePath, resolveInterceptingRoute(route)] as [string, string]\n+      ),\n+      ...layoutRoutes.map(\n+        ({ route, filePath }) =>\n+          [filePath, resolveInterceptingRoute(route)] as [string, string]\n+      ),\n+      ...appRouteHandlers.map(\n+        ({ route, filePath }) =>\n+          [filePath, resolveInterceptingRoute(route)] as [string, string]\n+      ),\n+      ...pageRoutes.map(\n+        ({ route, filePath }) => [filePath, route] as [string, string]\n+      ),\n+      ...pageApiRoutes.map(\n+        ({ route, filePath }) => [filePath, route] as [string, string]\n+      ),\n+    ]),\n   }\n \n   // Process page routes\n   for (const { route, filePath } of pageRoutes) {\n     manifest.pageRoutes[route] = {\n-      path: path.relative(dir, filePath),\n+      path: getRelativePath(filePath),\n       groups: extractRouteParams(route),\n     }\n   }\n \n   // Process layout routes\n   for (const { route, filePath } of layoutRoutes) {\n-    if (!isCanonicalRoute(route)) continue\n+    // Use the resolved route (for interception routes, this gives us the canonical route)\n+    const resolvedRoute = resolveInterceptingRoute(route)\n \n-    manifest.layoutRoutes[route] = {\n-      path: path.relative(dir, filePath),\n-      groups: extractRouteParams(route),\n-      slots: [],\n+    if (!manifest.layoutRoutes[resolvedRoute]) {\n+      manifest.layoutRoutes[resolvedRoute] = {\n+        path: getRelativePath(filePath),\n+        groups: extractRouteParams(resolvedRoute),\n+        slots: [],\n+      }\n     }\n   }\n \n@@ -177,11 +237,37 @@ export async function createRouteTypesManifest({\n \n   // Process app routes\n   for (const { route, filePath } of appRoutes) {\n-    if (!isCanonicalRoute(route)) continue\n+    // Don't include metadata routes or pages\n+    if (\n+      !filePath.endsWith('page.ts') &&\n+      !filePath.endsWith('page.tsx') &&\n+      !filePath.endsWith('.mdx') &&\n+      !filePath.endsWith('.md')\n+    ) {\n+      continue\n+    }\n \n-    manifest.appRoutes[route] = {\n-      path: path.relative(dir, filePath),\n-      groups: extractRouteParams(route),\n+    // Use the resolved route (for interception routes, this gives us the canonical route)\n+    const resolvedRoute = resolveInterceptingRoute(route)\n+\n+    if (!manifest.appRoutes[resolvedRoute]) {\n+      manifest.appRoutes[resolvedRoute] = {\n+        path: getRelativePath(filePath),\n+        groups: extractRouteParams(resolvedRoute),\n+      }\n+    }\n+  }\n+\n+  // Process app route handlers\n+  for (const { route, filePath } of appRouteHandlers) {\n+    // Use the resolved route (for interception routes, this gives us the canonical route)\n+    const resolvedRoute = resolveInterceptingRoute(route)\n+\n+    if (!manifest.appRouteHandlerRoutes[resolvedRoute]) {\n+      manifest.appRouteHandlerRoutes[resolvedRoute] = {\n+        path: getRelativePath(filePath),\n+        groups: extractRouteParams(resolvedRoute),\n+      }\n     }\n   }\n \n@@ -246,3 +332,16 @@ export async function writeRouteTypesManifest(\n     await fs.promises.writeFile(linkTypesPath, generateLinkTypesFile(manifest))\n   }\n }\n+\n+export async function writeValidatorFile(\n+  manifest: RouteTypesManifest,\n+  filePath: string\n+) {\n+  const dirname = path.dirname(filePath)\n+\n+  if (!fs.existsSync(dirname)) {\n+    await fs.promises.mkdir(dirname, { recursive: true })\n+  }\n+\n+  await fs.promises.writeFile(filePath, generateValidatorFile(manifest))\n+}"
        },
        {
            "sha": "87371759714b0650581916a78aa45489cfd2204b",
            "filename": "packages/next/src/server/lib/router-utils/setup-dev-bundler.ts",
            "status": "modified",
            "additions": 52,
            "deletions": 9,
            "changes": 61,
            "blob_url": "https://github.com/vercel/next.js/blob/f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Fsetup-dev-bundler.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Fsetup-dev-bundler.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Fsetup-dev-bundler.ts?ref=f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c",
            "patch": "@@ -87,6 +87,7 @@ import { JSON_CONTENT_TYPE_HEADER } from '../../../lib/constants'\n import {\n   createRouteTypesManifest,\n   writeRouteTypesManifest,\n+  writeValidatorFile,\n } from './route-types-utils'\n import { isParallelRouteSegment } from '../../../shared/lib/segment'\n import { ensureLeadingSlash } from '../../../shared/lib/page-path/ensure-leading-slash'\n@@ -219,8 +220,15 @@ async function startWatcher(\n       appRoutes: {},\n       pageRoutes: {},\n       layoutRoutes: {},\n+      appRouteHandlerRoutes: {},\n       redirectRoutes: {},\n       rewriteRoutes: {},\n+      appPagePaths: new Set(),\n+      pagesRouterPagePaths: new Set(),\n+      layoutPaths: new Set(),\n+      appRouteHandlers: new Set(),\n+      pageApiRoutes: new Set(),\n+      filePathToRoute: new Map(),\n     },\n     path.join(distTypesDir, 'routes.d.ts'),\n     opts.nextConfig\n@@ -335,6 +343,7 @@ async function startWatcher(\n     let previousConflictingPagePaths: Set<string> = new Set()\n \n     const routeTypesFilePath = path.join(distDir, 'types', 'routes.d.ts')\n+    const validatorFilePath = path.join(distDir, 'types', 'validator.ts')\n \n     wp.on('aggregated', async () => {\n       let middlewareMatchers: MiddlewareMatcher[] | undefined\n@@ -345,6 +354,8 @@ async function startWatcher(\n       const conflictingAppPagePaths = new Set<string>()\n       const appPageFilePaths = new Map<string, string>()\n       const pagesPageFilePaths = new Map<string, string>()\n+      const appRouteHandlers: Array<{ route: string; filePath: string }> = []\n+      const pageApiRoutes: Array<{ route: string; filePath: string }> = []\n \n       const pageRoutes: Array<{ route: string; filePath: string }> = []\n       const appRoutes: Array<{ route: string; filePath: string }> = []\n@@ -565,7 +576,10 @@ async function startWatcher(\n                   ''\n                 )\n               ),\n-              filePath: fileName,\n+              filePath: path.relative(\n+                path.dirname(validatorFilePath),\n+                fileName\n+              ),\n             })\n           }\n \n@@ -589,10 +603,23 @@ async function startWatcher(\n             appFiles.add(pageName)\n           }\n \n-          appRoutes.push({\n-            route: normalizePathSep(pageName),\n-            filePath: fileName,\n-          })\n+          if (validFileMatcher.isAppRouterRoute(fileName)) {\n+            appRouteHandlers.push({\n+              route: normalizePathSep(pageName),\n+              filePath: path.relative(\n+                path.dirname(validatorFilePath),\n+                fileName\n+              ),\n+            })\n+          } else {\n+            appRoutes.push({\n+              route: normalizePathSep(pageName),\n+              filePath: path.relative(\n+                path.dirname(validatorFilePath),\n+                fileName\n+              ),\n+            })\n+          }\n \n           if (routedPages.includes(pageName)) {\n             continue\n@@ -605,10 +632,23 @@ async function startWatcher(\n             opts.fsChecker.nextDataRoutes.add(pageName)\n           }\n \n-          pageRoutes.push({\n-            route: normalizePathSep(pageName),\n-            filePath: fileName,\n-          })\n+          if (pageName.startsWith('/api/')) {\n+            pageApiRoutes.push({\n+              route: normalizePathSep(pageName),\n+              filePath: path.relative(\n+                path.dirname(validatorFilePath),\n+                fileName\n+              ),\n+            })\n+          } else {\n+            pageRoutes.push({\n+              route: normalizePathSep(pageName),\n+              filePath: path.relative(\n+                path.dirname(validatorFilePath),\n+                fileName\n+              ),\n+            })\n+          }\n         }\n \n         // Record pages\n@@ -1022,13 +1062,16 @@ async function startWatcher(\n             slots,\n             redirects: opts.nextConfig.redirects,\n             rewrites: opts.nextConfig.rewrites,\n+            appRouteHandlers,\n+            pageApiRoutes,\n           })\n \n           await writeRouteTypesManifest(\n             routeTypesManifest,\n             routeTypesFilePath,\n             opts.nextConfig\n           )\n+          await writeValidatorFile(routeTypesManifest, validatorFilePath)\n         }\n \n         if (!resolved) {"
        },
        {
            "sha": "25434b6bf4efb19d7a849b5865e0afcb795bd1c7",
            "filename": "packages/next/src/server/lib/router-utils/typegen.ts",
            "status": "modified",
            "additions": 178,
            "deletions": 3,
            "changes": 181,
            "blob_url": "https://github.com/vercel/next.js/blob/f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Ftypegen.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Ftypegen.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Ftypegen.ts?ref=f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c",
            "patch": "@@ -10,13 +10,24 @@ function generateRouteTypes(routesManifest: RouteTypesManifest): string {\n \n   let result = ''\n \n-  // Generate AppRoutes union type\n+  // Generate AppRoutes union type (pages only)\n   if (appRoutes.length > 0) {\n     result += `type AppRoutes = ${appRoutes.map((route) => JSON.stringify(route)).join(' | ')}\\n`\n   } else {\n     result += 'type AppRoutes = never\\n'\n   }\n \n+  // Generate AppRouteHandlerRoutes union type for route handlers\n+  const appRouteHandlerRoutes = Object.keys(\n+    routesManifest.appRouteHandlerRoutes\n+  ).sort()\n+\n+  if (appRouteHandlerRoutes.length > 0) {\n+    result += `type AppRouteHandlerRoutes = ${appRouteHandlerRoutes.map((route) => JSON.stringify(route)).join(' | ')}\\n`\n+  } else {\n+    result += 'type AppRouteHandlerRoutes = never\\n'\n+  }\n+\n   // Generate PageRoutes union type\n   if (pageRoutes.length > 0) {\n     result += `type PageRoutes = ${pageRoutes.map((route) => JSON.stringify(route)).join(' | ')}\\n`\n@@ -50,14 +61,15 @@ function generateRouteTypes(routesManifest: RouteTypesManifest): string {\n   }\n \n   result +=\n-    'type Routes = AppRoutes | PageRoutes | LayoutRoutes | RedirectRoutes | RewriteRoutes\\n'\n+    'type Routes = AppRoutes | AppRouteHandlerRoutes | PageRoutes | LayoutRoutes | RedirectRoutes | RewriteRoutes\\n'\n \n   return result\n }\n \n function generateParamTypes(routesManifest: RouteTypesManifest): string {\n   const allRoutes = {\n     ...routesManifest.appRoutes,\n+    ...routesManifest.appRouteHandlerRoutes,\n     ...routesManifest.pageRoutes,\n     ...routesManifest.layoutRoutes,\n     ...routesManifest.redirectRoutes,\n@@ -340,6 +352,169 @@ declare module 'next/form' {\n `\n }\n \n+export function generateValidatorFile(\n+  routesManifest: RouteTypesManifest\n+): string {\n+  const generateValidations = (\n+    paths: string[],\n+    type:\n+      | 'AppPageConfig'\n+      | 'PagesPageConfig'\n+      | 'LayoutConfig'\n+      | 'RouteHandlerConfig'\n+      | 'ApiRouteConfig',\n+    pathToRouteMap?: Map<string, string>\n+  ) =>\n+    paths\n+      .sort()\n+      // Only validate TypeScript files - JavaScript files have too many type inference limitations\n+      .filter(\n+        (filePath) => filePath.endsWith('.ts') || filePath.endsWith('.tsx')\n+      )\n+      .filter(\n+        // Don't include metadata routes or pages\n+        // (e.g. /manifest.webmanifest)\n+        (filePath) =>\n+          type !== 'AppPageConfig' ||\n+          filePath.endsWith('page.ts') ||\n+          filePath.endsWith('page.tsx')\n+      )\n+      .map((filePath) => {\n+        // Keep the file extension for TypeScript imports to support node16 module resolution\n+        const importPath = filePath\n+        const route = pathToRouteMap?.get(filePath)\n+        const typeWithRoute =\n+          route &&\n+          (type === 'AppPageConfig' ||\n+            type === 'LayoutConfig' ||\n+            type === 'RouteHandlerConfig')\n+            ? `${type}<${JSON.stringify(route)}>`\n+            : type\n+        return `// Validate ${filePath}\n+{\n+  const handler = {} as typeof import(${JSON.stringify(importPath)})\n+  handler satisfies ${typeWithRoute}\n+}`\n+      })\n+      .join('\\n\\n')\n+\n+  // Use direct mappings from the manifest\n+\n+  // Generate validations for different route types\n+  const appPageValidations = generateValidations(\n+    Array.from(routesManifest.appPagePaths).sort(),\n+    'AppPageConfig',\n+    routesManifest.filePathToRoute\n+  )\n+  const appRouteHandlerValidations = generateValidations(\n+    Array.from(routesManifest.appRouteHandlers).sort(),\n+    'RouteHandlerConfig',\n+    routesManifest.filePathToRoute\n+  )\n+  const pagesRouterPageValidations = generateValidations(\n+    Array.from(routesManifest.pagesRouterPagePaths).sort(),\n+    'PagesPageConfig'\n+  )\n+  const pagesApiRouteValidations = generateValidations(\n+    Array.from(routesManifest.pageApiRoutes).sort(),\n+    'ApiRouteConfig'\n+  )\n+  const layoutValidations = generateValidations(\n+    Array.from(routesManifest.layoutPaths).sort(),\n+    'LayoutConfig',\n+    routesManifest.filePathToRoute\n+  )\n+\n+  return `// This file is generated automatically by Next.js\n+// Do not edit this file manually\n+// This file validates that all pages and layouts export the correct types\n+\n+import type { AppRoutes, AppRouteHandlerRoutes, LayoutRoutes, ParamMap } from \"./routes.js\"\n+import type { ResolvingMetadata, ResolvingViewport } from \"next/dist/lib/metadata/types/metadata-interface.js\"\n+\n+type AppPageConfig<Route extends AppRoutes = AppRoutes> = {\n+  default: React.ComponentType<{ params: Promise<ParamMap[Route]> } & any> | ((props: { params: Promise<ParamMap[Route]> } & any) => React.ReactNode | Promise<React.ReactNode> | never | void | Promise<void>)\n+  generateStaticParams?: (props: { params: ParamMap[Route] }) => Promise<any[]> | any[]\n+  generateMetadata?: (\n+    props: { params: Promise<ParamMap[Route]> } & any,\n+    parent: ResolvingMetadata\n+  ) => Promise<any> | any\n+  generateViewport?: (\n+    props: { params: Promise<ParamMap[Route]> } & any,\n+    parent: ResolvingViewport\n+  ) => Promise<any> | any\n+  metadata?: any\n+  viewport?: any\n+}\n+\n+type PagesPageConfig = {\n+  default: React.ComponentType<any> | ((props: any) => React.ReactNode | Promise<React.ReactNode> | never | void)\n+  getStaticProps?: (context: any) => Promise<any> | any\n+  getStaticPaths?: (context: any) => Promise<any> | any\n+  getServerSideProps?: (context: any) => Promise<any> | any\n+  getInitialProps?: (context: any) => Promise<any> | any\n+  /**\n+   * Segment configuration for legacy Pages Router pages.\n+   * Validated at build-time by parsePagesSegmentConfig.\n+   */\n+  config?: {\n+    amp?: boolean | 'hybrid'\n+    maxDuration?: number\n+    runtime?: 'edge' | 'experimental-edge' | 'nodejs' | string // necessary unless config is exported as const\n+    regions?: string[]\n+  }\n+}\n+\n+type LayoutConfig<Route extends LayoutRoutes = LayoutRoutes> = {\n+  default: React.ComponentType<LayoutProps<Route>> | ((props: LayoutProps<Route>) => React.ReactNode | Promise<React.ReactNode> | never | void | Promise<void>)\n+  generateStaticParams?: (props: { params: ParamMap[Route] }) => Promise<any[]> | any[]\n+  generateMetadata?: (\n+    props: { params: Promise<ParamMap[Route]> } & any,\n+    parent: ResolvingMetadata\n+  ) => Promise<any> | any\n+  generateViewport?: (\n+    props: { params: Promise<ParamMap[Route]> } & any,\n+    parent: ResolvingViewport\n+  ) => Promise<any> | any\n+  metadata?: any\n+  viewport?: any\n+}\n+\n+type RouteHandlerConfig<Route extends AppRouteHandlerRoutes = AppRouteHandlerRoutes> = {\n+  GET?: (request: Request, context: { params: Promise<ParamMap[Route]> }) => Promise<Response> | Response | Promise<void> | void\n+  POST?: (request: Request, context: { params: Promise<ParamMap[Route]> }) => Promise<Response> | Response | Promise<void> | void\n+  PUT?: (request: Request, context: { params: Promise<ParamMap[Route]> }) => Promise<Response> | Response | Promise<void> | void\n+  PATCH?: (request: Request, context: { params: Promise<ParamMap[Route]> }) => Promise<Response> | Response | Promise<void> | void\n+  DELETE?: (request: Request, context: { params: Promise<ParamMap[Route]> }) => Promise<Response> | Response | Promise<void> | void\n+  HEAD?: (request: Request, context: { params: Promise<ParamMap[Route]> }) => Promise<Response> | Response | Promise<void> | void\n+  OPTIONS?: (request: Request, context: { params: Promise<ParamMap[Route]> }) => Promise<Response> | Response | Promise<void> | void\n+}\n+\n+type ApiRouteConfig = {\n+  default: (req: any, res: any) => Promise<void> | void | Promise<Response> | Response\n+  config?: {\n+    api?: {\n+      bodyParser?: boolean | { sizeLimit?: string }\n+      responseLimit?: string | number\n+      externalResolver?: boolean\n+    }\n+    runtime?: 'edge' | 'experimental-edge' | 'nodejs' | string // necessary unless config is exported as const\n+    maxDuration?: number\n+  }\n+}\n+\n+${appPageValidations}\n+\n+${appRouteHandlerValidations}\n+\n+${pagesRouterPageValidations}\n+\n+${pagesApiRouteValidations}\n+\n+${layoutValidations}\n+`\n+}\n+\n export function generateRouteTypesFile(\n   routesManifest: RouteTypesManifest\n ): string {\n@@ -358,7 +533,7 @@ export type ParamsOf<Route extends Routes> = ParamMap[Route]\n \n ${layoutSlotMap}\n \n-export type { AppRoutes, PageRoutes, LayoutRoutes, RedirectRoutes, RewriteRoutes }\n+export type { AppRoutes, AppRouteHandlerRoutes, PageRoutes, LayoutRoutes, RedirectRoutes, RewriteRoutes, ParamMap }\n \n declare global {\n   /**"
        },
        {
            "sha": "5338d34716a696e3564a117b2464a97cbadb9ccd",
            "filename": "test/e2e/app-dir/app-alias/src/app/typing/[slug]/page.tsx",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c/test%2Fe2e%2Fapp-dir%2Fapp-alias%2Fsrc%2Fapp%2Ftyping%2F%5Bslug%5D%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c/test%2Fe2e%2Fapp-dir%2Fapp-alias%2Fsrc%2Fapp%2Ftyping%2F%5Bslug%5D%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fapp-alias%2Fsrc%2Fapp%2Ftyping%2F%5Bslug%5D%2Fpage.tsx?ref=f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c",
            "patch": "@@ -5,7 +5,7 @@ export default function page() {\n export async function generateStaticParams({\n   params,\n }: {\n-  params: { slug: 'a' | 'b' }\n+  params: { slug: string }\n }) {\n   console.log(params)\n   return []"
        },
        {
            "sha": "f20c283e96ef76547c0720db732852755dd30cae",
            "filename": "test/e2e/app-dir/typed-routes-validator/app/layout.tsx",
            "status": "added",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c/test%2Fe2e%2Fapp-dir%2Ftyped-routes-validator%2Fapp%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c/test%2Fe2e%2Fapp-dir%2Ftyped-routes-validator%2Fapp%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Ftyped-routes-validator%2Fapp%2Flayout.tsx?ref=f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c",
            "patch": "@@ -0,0 +1,7 @@\n+export default function Root(props: LayoutProps<'/'>) {\n+  return (\n+    <html>\n+      <body>{props.children}</body>\n+    </html>\n+  )\n+}"
        },
        {
            "sha": "de387b76b80213204144324be7b23a31354bf026",
            "filename": "test/e2e/app-dir/typed-routes-validator/app/page.tsx",
            "status": "added",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c/test%2Fe2e%2Fapp-dir%2Ftyped-routes-validator%2Fapp%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c/test%2Fe2e%2Fapp-dir%2Ftyped-routes-validator%2Fapp%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Ftyped-routes-validator%2Fapp%2Fpage.tsx?ref=f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c",
            "patch": "@@ -0,0 +1,3 @@\n+export default function Page(props: PageProps<'/'>) {\n+  return <p>hello world</p>\n+}"
        },
        {
            "sha": "29d5fc37b60d5ec5861a2af319820b92f0ab86d1",
            "filename": "test/e2e/app-dir/typed-routes-validator/app/send-email/route.ts",
            "status": "added",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c/test%2Fe2e%2Fapp-dir%2Ftyped-routes-validator%2Fapp%2Fsend-email%2Froute.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c/test%2Fe2e%2Fapp-dir%2Ftyped-routes-validator%2Fapp%2Fsend-email%2Froute.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Ftyped-routes-validator%2Fapp%2Fsend-email%2Froute.ts?ref=f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c",
            "patch": "@@ -0,0 +1,3 @@\n+export async function GET() {\n+  return Response.json({ message: 'Hello World' })\n+}"
        },
        {
            "sha": "807126e4cf0bf5b1c8c917e6e0148a27331587d1",
            "filename": "test/e2e/app-dir/typed-routes-validator/next.config.js",
            "status": "added",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c/test%2Fe2e%2Fapp-dir%2Ftyped-routes-validator%2Fnext.config.js",
            "raw_url": "https://github.com/vercel/next.js/raw/f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c/test%2Fe2e%2Fapp-dir%2Ftyped-routes-validator%2Fnext.config.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Ftyped-routes-validator%2Fnext.config.js?ref=f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c",
            "patch": "@@ -0,0 +1,6 @@\n+/**\n+ * @type {import('next').NextConfig}\n+ */\n+const nextConfig = {}\n+\n+module.exports = nextConfig"
        },
        {
            "sha": "519e595f226f584a863a7ff31fb7fee2a6620056",
            "filename": "test/e2e/app-dir/typed-routes-validator/pages/about.tsx",
            "status": "added",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c/test%2Fe2e%2Fapp-dir%2Ftyped-routes-validator%2Fpages%2Fabout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c/test%2Fe2e%2Fapp-dir%2Ftyped-routes-validator%2Fpages%2Fabout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Ftyped-routes-validator%2Fpages%2Fabout.tsx?ref=f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c",
            "patch": "@@ -0,0 +1,3 @@\n+export default function AboutPage() {\n+  return <div>About Page</div>\n+}"
        },
        {
            "sha": "9ffed7484f99d600bd17c43959a678303db28f10",
            "filename": "test/e2e/app-dir/typed-routes-validator/pages/api/test-route.ts",
            "status": "added",
            "additions": 12,
            "deletions": 0,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c/test%2Fe2e%2Fapp-dir%2Ftyped-routes-validator%2Fpages%2Fapi%2Ftest-route.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c/test%2Fe2e%2Fapp-dir%2Ftyped-routes-validator%2Fpages%2Fapi%2Ftest-route.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Ftyped-routes-validator%2Fpages%2Fapi%2Ftest-route.ts?ref=f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c",
            "patch": "@@ -0,0 +1,12 @@\n+import type { NextApiRequest, NextApiResponse } from 'next/types'\n+\n+type ResponseData = {\n+  message: string\n+}\n+\n+export default function handler(\n+  req: NextApiRequest,\n+  res: NextApiResponse<ResponseData>\n+) {\n+  res.status(200).json({ message: 'Hello from Next.js!' })\n+}"
        },
        {
            "sha": "7937b6e3c8603ca15982b801d6c03e13a00cf59d",
            "filename": "test/e2e/app-dir/typed-routes-validator/typed-routes-validator.test.ts",
            "status": "added",
            "additions": 203,
            "deletions": 0,
            "changes": 203,
            "blob_url": "https://github.com/vercel/next.js/blob/f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c/test%2Fe2e%2Fapp-dir%2Ftyped-routes-validator%2Ftyped-routes-validator.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c/test%2Fe2e%2Fapp-dir%2Ftyped-routes-validator%2Ftyped-routes-validator.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Ftyped-routes-validator%2Ftyped-routes-validator.test.ts?ref=f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c",
            "patch": "@@ -0,0 +1,203 @@\n+import { nextTestSetup } from 'e2e-utils'\n+\n+describe('typed-routes-validator', () => {\n+  const { next, isNextStart, skipped } = nextTestSetup({\n+    files: __dirname,\n+    skipDeployment: true,\n+  })\n+\n+  if (skipped) {\n+    return\n+  }\n+\n+  it('should generate route validation correctly', async () => {\n+    const dts = await next.readFile('.next/types/validator.ts')\n+    expect(dts).toMatch(\n+      /const handler = {} as typeof import\\(\".*\\/app\\/page.tsx\"\\)\\s+handler satisfies AppPageConfig<\"\\/\">/\n+    )\n+    expect(dts).toMatch(\n+      /const handler = {} as typeof import\\(\".*\\/app\\/send-email\\/route.ts\"\\)\\s+handler satisfies RouteHandlerConfig<\"\\/send-email\">/\n+    )\n+    expect(dts).toMatch(\n+      /const handler = {} as typeof import\\(\".*\\/pages\\/about.tsx\"\\)\\s+handler satisfies PagesPageConfig/\n+    )\n+    expect(dts).toMatch(\n+      /const handler = {} as typeof import\\(\".*\\/pages\\/api\\/test-route.ts\"\\)\\s+handler satisfies ApiRouteConfig/\n+    )\n+    expect(dts).toMatch(\n+      /const handler = {} as typeof import\\(\".*\\/app\\/layout.tsx\"\\)\\s+handler satisfies LayoutConfig<\"\\/\">/\n+    )\n+  })\n+\n+  if (isNextStart) {\n+    it('should pass type checking with valid page exports', async () => {\n+      await next.stop()\n+      await next.patchFile(\n+        'app/test-page.tsx',\n+        `\n+    export default function TestPage() {\n+      return <div>Test Page</div>\n+    }\n+\n+    export const dynamic = 'force-static'\n+    export const metadata = { title: 'Test' }\n+            `\n+      )\n+\n+      const { exitCode } = await next.build()\n+      expect(exitCode).toBe(0)\n+    })\n+\n+    it('should fail type checking with invalid page exports', async () => {\n+      await next.stop()\n+      await next.patchFile(\n+        'app/invalid/page.tsx',\n+        `\n+    // Missing default export\n+    export const metadata = { title: 'Invalid' }\n+            `\n+      )\n+\n+      const { exitCode, cliOutput } = await next.build()\n+      // clean up before assertion just in case it fails\n+      await next.deleteFile('app/invalid/page.tsx')\n+\n+      expect(exitCode).toBe(1)\n+      expect(cliOutput).toMatch(\n+        /Type error: Type 'typeof import\\(.*\\)' does not satisfy the expected type 'AppPageConfig<\"\\/invalid\">'/\n+      )\n+    })\n+\n+    it('should pass type checking with valid route handler exports', async () => {\n+      await next.stop()\n+      await next.patchFile(\n+        'app/valid/route.ts',\n+        `\n+    export async function GET() {\n+      return new Response('OK')\n+    }\n+\n+    export async function POST(request: Request) {\n+      return new Response('Created', { status: 201 })\n+    }\n+\n+    export const dynamic = 'force-dynamic'\n+            `\n+      )\n+\n+      const { exitCode } = await next.build()\n+      expect(exitCode).toBe(0)\n+    })\n+\n+    it('should fail type checking with invalid route handler exports', async () => {\n+      await next.stop()\n+      await next.patchFile(\n+        'app/invalid/route.ts',\n+        `\n+    // Invalid signature - missing Response return type\n+    export function GET() {\n+      return 'not a response'\n+    }\n+            `\n+      )\n+\n+      const { exitCode, cliOutput } = await next.build()\n+      // clean up before assertion just in case it fails\n+      await next.deleteFile('app/invalid/route.ts')\n+\n+      expect(exitCode).toBe(1)\n+      expect(cliOutput).toMatch(\n+        /Type error: Type 'typeof import.*does not satisfy the expected type 'RouteHandlerConfig<\"\\/invalid\">'/\n+      )\n+    })\n+\n+    it('should pass type checking with valid layout exports', async () => {\n+      await next.stop()\n+      await next.patchFile(\n+        'app/test/layout.tsx',\n+        `\n+        export default function TestLayout({\n+          children,\n+        }: {\n+          children: React.ReactNode\n+        }) {\n+          return <div>{children}</div>\n+        }\n+\n+        export const metadata = { title: 'Test Layout' }\n+                `\n+      )\n+\n+      const { exitCode } = await next.build()\n+      expect(exitCode).toBe(0)\n+    })\n+\n+    it('should fail type checking with invalid layout exports', async () => {\n+      await next.stop()\n+      await next.patchFile(\n+        'app/invalid/layout.tsx',\n+        `\n+    // Invalid - doesn't return a React node\n+    export default function InvalidLayout() {\n+      return {randomKey: 'randomValue'}\n+    }\n+            `\n+      )\n+\n+      const { exitCode, cliOutput } = await next.build()\n+      // clean up before assertion just in case it fails\n+      await next.deleteFile('app/invalid/layout.tsx')\n+\n+      expect(exitCode).toBe(1)\n+      expect(cliOutput).toMatch(\n+        /Type error: Type 'typeof import\\(.*does not satisfy the expected type 'LayoutConfig<\"\\/invalid\">'/\n+      )\n+    })\n+\n+    it('should pass type checking with valid API route exports', async () => {\n+      await next.stop()\n+      await next.patchFile(\n+        'pages/api/valid-api.ts',\n+        `\n+    import type { NextApiRequest, NextApiResponse } from 'next'\n+\n+    export default function handler(\n+      req: NextApiRequest,\n+      res: NextApiResponse\n+    ) {\n+      res.status(200).json({ message: 'OK' })\n+    }\n+\n+    export const config = {\n+      api: {\n+        bodyParser: true,\n+      },\n+    }\n+            `\n+      )\n+\n+      const { exitCode } = await next.build()\n+      expect(exitCode).toBe(0)\n+    })\n+\n+    it('should fail type checking with invalid API route exports', async () => {\n+      await next.stop()\n+      await next.patchFile(\n+        'pages/api/invalid-api.ts',\n+        `\n+    // Invalid - not a function\n+    export default { message: 'not a function' }\n+            `\n+      )\n+\n+      const { exitCode, cliOutput } = await next.build()\n+      // clean up before assertion just in case it fails\n+      await next.deleteFile('pages/api/invalid-api.ts')\n+\n+      expect(exitCode).toBe(1)\n+      expect(cliOutput).toMatch(\n+        /Type error: Type 'typeof import\\(.*does not satisfy the expected type 'ApiRouteConfig'/\n+      )\n+    })\n+  }\n+})"
        },
        {
            "sha": "f25622f4bb5a29cb05e62e485b1a4402ed303c3a",
            "filename": "test/e2e/app-dir/typed-routes/typed-routes.test.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c/test%2Fe2e%2Fapp-dir%2Ftyped-routes%2Ftyped-routes.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c/test%2Fe2e%2Fapp-dir%2Ftyped-routes%2Ftyped-routes.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Ftyped-routes%2Ftyped-routes.test.ts?ref=f88de0d8f1b8ec508b7cfef6abfaaa32e72e690c",
            "patch": "@@ -2,11 +2,12 @@ import { nextTestSetup } from 'e2e-utils'\n \n const expectedDts = `\n type AppRoutes = \"/\" | \"/_shop/[[...category]]\" | \"/dashboard\" | \"/dashboard/settings\" | \"/docs/[...slug]\" | \"/gallery/photo/[id]\" | \"/project/[slug]\"\n+type AppRouteHandlerRoutes = never\n type PageRoutes = \"/about\" | \"/users/[id]\"\n type LayoutRoutes = \"/\" | \"/dashboard\"\n type RedirectRoutes = \"/blog/[category]/[[...slug]]\" | \"/project/[slug]\"\n type RewriteRoutes = \"/api-legacy/[version]/[[...endpoint]]\" | \"/docs-old/[...path]\"\n-type Routes = AppRoutes | PageRoutes | LayoutRoutes | RedirectRoutes | RewriteRoutes\n+type Routes = AppRoutes | AppRouteHandlerRoutes | PageRoutes | LayoutRoutes | RedirectRoutes | RewriteRoutes\n `\n \n describe('typed-routes', () => {"
        }
    ],
    "stats": {
        "total": 954,
        "additions": 845,
        "deletions": 109
    }
}