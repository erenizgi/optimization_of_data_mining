{
    "author": "icyJoseph",
    "message": "docs: use cache feedback (#85169)",
    "sha": "4001cc95466e03e02c9ade767d0386c8b35cbccb",
    "files": [
        {
            "sha": "45bca4711b7977de961f56f8244c576e1e716028",
            "filename": "docs/01-app/03-api-reference/01-directives/use-cache.mdx",
            "status": "modified",
            "additions": 23,
            "deletions": 6,
            "changes": 29,
            "blob_url": "https://github.com/vercel/next.js/blob/4001cc95466e03e02c9ade767d0386c8b35cbccb/docs%2F01-app%2F03-api-reference%2F01-directives%2Fuse-cache.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/4001cc95466e03e02c9ade767d0386c8b35cbccb/docs%2F01-app%2F03-api-reference%2F01-directives%2Fuse-cache.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-api-reference%2F01-directives%2Fuse-cache.mdx?ref=4001cc95466e03e02c9ade767d0386c8b35cbccb",
            "patch": "@@ -148,7 +148,7 @@ export default function Layout({ children }) {\n }\n ```\n \n-Any components imported and nested in `page` file will inherit the cache behavior of `page`.\n+Any components imported and nested in `page` file are part of the cache output associated with the `page`.\n \n ```tsx filename=\"app/page.tsx\" switcher\n 'use cache'\n@@ -243,23 +243,34 @@ export async function getData() {\n \n ### Interleaving\n \n-If you need to pass non-serializable arguments to a cacheable function, you can pass them as `children`. This means the `children` reference can change without affecting the cache entry.\n+In React, composition with `children` or slots is a well-known pattern for building flexible components. When using `use cache`, you can continue to compose your UI in this way. Anything included as `children`, or other compositional slots, in the returned JSX will be passed through the cached component without affecting its cache entry.\n+\n+As long as you don't directly reference any of the JSX slots inside the body of the cacheable function itself, their presence in the returned output won't affect the cache entry.\n \n ```tsx filename=\"app/page.tsx\" switcher\n export default async function Page() {\n   const uncachedData = await getData()\n   return (\n-    <CacheComponent>\n+    // Pass compositional slots as props, e.g. header and children\n+    <CacheComponent header={<h1>Home</h1>}>\n+      {/* DynamicComponent is provided as the children slot */}\n       <DynamicComponent data={uncachedData} />\n     </CacheComponent>\n   )\n }\n \n-async function CacheComponent({ children }: { children: ReactNode }) {\n+async function CacheComponent({\n+  header, // header: a compositional slot, injected as a prop\n+  children, // children: another slot for nested composition\n+}: {\n+  header: ReactNode\n+  children: ReactNode\n+}) {\n   'use cache'\n   const cachedData = await fetch('/api/cached-data')\n   return (\n     <div>\n+      {header}\n       <PrerenderedComponent data={cachedData} />\n       {children}\n     </div>\n@@ -271,17 +282,23 @@ async function CacheComponent({ children }: { children: ReactNode }) {\n export default async function Page() {\n   const uncachedData = await getData()\n   return (\n-    <CacheComponent>\n+    // Pass compositional slots as props, e.g. header and children\n+    <CacheComponent header={<h1>Home</h1>}>\n+      {/* DynamicComponent is provided as the children slot */}\n       <DynamicComponent data={uncachedData} />\n     </CacheComponent>\n   )\n }\n \n-async function CacheComponent({ children }) {\n+async function CacheComponent({\n+  header, // header: a compositional slot, injected as a prop\n+  children, // children: another slot for nested composition\n+}) {\n   'use cache'\n   const cachedData = await fetch('/api/cached-data')\n   return (\n     <div>\n+      {header}\n       <PrerenderedComponent data={cachedData} />\n       {children}\n     </div>"
        },
        {
            "sha": "164fa5452bc6648f0f2d664eeedb9d7fbbfe4adf",
            "filename": "docs/01-app/03-api-reference/05-config/01-next-config-js/cacheComponents.mdx",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/4001cc95466e03e02c9ade767d0386c8b35cbccb/docs%2F01-app%2F03-api-reference%2F05-config%2F01-next-config-js%2FcacheComponents.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/4001cc95466e03e02c9ade767d0386c8b35cbccb/docs%2F01-app%2F03-api-reference%2F05-config%2F01-next-config-js%2FcacheComponents.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-api-reference%2F05-config%2F01-next-config-js%2FcacheComponents.mdx?ref=4001cc95466e03e02c9ade767d0386c8b35cbccb",
            "patch": "@@ -32,3 +32,9 @@ When `cacheComponents` is enabled, you can use the following cache functions and\n ## Notes\n \n - While `cacheComponents` can optimize performance by ensuring fresh data fetching during runtime, it may also introduce additional latency compared to serving pre-rendered content.\n+\n+## Version History\n+\n+| Version | Change                                                                                                                            |\n+| ------- | --------------------------------------------------------------------------------------------------------------------------------- |\n+| 16.0.0  | `cacheComponents` introduced. This flag controls the `ppr`, `useCache`, and `dynamicIO` flags as a single, unified configuration. |"
        },
        {
            "sha": "5fa4dd685c0829745be5f7b6f687144ae94d506b",
            "filename": "docs/01-app/03-api-reference/05-config/01-next-config-js/incrementalCacheHandlerPath.mdx",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/4001cc95466e03e02c9ade767d0386c8b35cbccb/docs%2F01-app%2F03-api-reference%2F05-config%2F01-next-config-js%2FincrementalCacheHandlerPath.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/4001cc95466e03e02c9ade767d0386c8b35cbccb/docs%2F01-app%2F03-api-reference%2F05-config%2F01-next-config-js%2FincrementalCacheHandlerPath.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-api-reference%2F05-config%2F01-next-config-js%2FincrementalCacheHandlerPath.mdx?ref=4001cc95466e03e02c9ade767d0386c8b35cbccb",
            "patch": "@@ -6,6 +6,8 @@ description: Configure the Next.js cache used for storing and revalidating data\n \n You can configure the Next.js cache location if you want to persist cached pages and data to durable storage, or share the cache across multiple containers or instances of your Next.js application.\n \n+> **Good to know**: The `cacheHandler` configuration is specifically used by Next.js for server cache operations such as storing and revalidating ISR and route handler responses. It is not used by `'use cache'`, `'use cache: remote'`, nor `'use cache: private'`, which manage their own cache independently.\n+\n ```js filename=\"next.config.js\"\n module.exports = {\n   cacheHandler: require.resolve('./cache-handler.js'),"
        }
    ],
    "stats": {
        "total": 37,
        "additions": 31,
        "deletions": 6
    }
}