{
    "author": "timneutkens",
    "message": "Turbopack: Skip manifest loading in server when using route modules (#82903)\n\n## What?\n\nWhen using Turbopack we'd try to load these files even when they don't\nexist, which adds latency because of the retrying. This PR ensures the\nfiles are skipped from loading where possible, which moves the place\nwhere it starts loading the manifest to the route modules instead. The\nexception to this is the static generation steps as those don't rely on\nroute modules yet. This is something still being worked on.",
    "sha": "3efa21aad6c8f727da8d528a67a0b10765ead685",
    "files": [
        {
            "sha": "f564d658bab2168b74b3e7dcd76528a1b61891be",
            "filename": "packages/next/src/build/utils.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/3efa21aad6c8f727da8d528a67a0b10765ead685/packages%2Fnext%2Fsrc%2Fbuild%2Futils.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/3efa21aad6c8f727da8d528a67a0b10765ead685/packages%2Fnext%2Fsrc%2Fbuild%2Futils.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Futils.ts?ref=3efa21aad6c8f727da8d528a67a0b10765ead685",
            "patch": "@@ -1164,6 +1164,7 @@ export async function isPageStatic({\n           isAppPath: pageType === 'app',\n           isDev: false,\n           sriEnabled,\n+          needsManifestsForLegacyReasons: true,\n         })\n       }\n \n@@ -1436,6 +1437,7 @@ export async function hasCustomGetInitialProps({\n     isAppPath: false,\n     isDev: false,\n     sriEnabled,\n+    needsManifestsForLegacyReasons: true,\n   })\n   let mod = ComponentMod\n \n@@ -1468,6 +1470,7 @@ export async function getDefinedNamedExports({\n     isAppPath: false,\n     isDev: false,\n     sriEnabled,\n+    needsManifestsForLegacyReasons: true,\n   })\n \n   return Object.keys(ComponentMod).filter((key) => {"
        },
        {
            "sha": "9f049b376be9bdec34d8591f3acdc4848de1f92e",
            "filename": "packages/next/src/export/worker.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/3efa21aad6c8f727da8d528a67a0b10765ead685/packages%2Fnext%2Fsrc%2Fexport%2Fworker.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/3efa21aad6c8f727da8d528a67a0b10765ead685/packages%2Fnext%2Fsrc%2Fexport%2Fworker.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fexport%2Fworker.ts?ref=3efa21aad6c8f727da8d528a67a0b10765ead685",
            "patch": "@@ -240,6 +240,7 @@ async function exportPageImpl(\n     isAppPath: isAppDir,\n     isDev: false,\n     sriEnabled,\n+    needsManifestsForLegacyReasons: true,\n   })\n \n   // Handle App Routes."
        },
        {
            "sha": "227933c08fe22b9b9ede193155e86434060077d1",
            "filename": "packages/next/src/server/dev/static-paths-worker.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/3efa21aad6c8f727da8d528a67a0b10765ead685/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fstatic-paths-worker.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/3efa21aad6c8f727da8d528a67a0b10765ead685/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fstatic-paths-worker.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fstatic-paths-worker.ts?ref=3efa21aad6c8f727da8d528a67a0b10765ead685",
            "patch": "@@ -106,6 +106,7 @@ export async function loadStaticPaths({\n     isAppPath,\n     isDev: true,\n     sriEnabled,\n+    needsManifestsForLegacyReasons: true,\n   })\n \n   if (isAppPath) {"
        },
        {
            "sha": "7daa3d440322bb971aa2e138c3b2bb6718e3eb7f",
            "filename": "packages/next/src/server/load-components.ts",
            "status": "modified",
            "additions": 161,
            "deletions": 131,
            "changes": 292,
            "blob_url": "https://github.com/vercel/next.js/blob/3efa21aad6c8f727da8d528a67a0b10765ead685/packages%2Fnext%2Fsrc%2Fserver%2Fload-components.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/3efa21aad6c8f727da8d528a67a0b10765ead685/packages%2Fnext%2Fsrc%2Fserver%2Fload-components.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fload-components.ts?ref=3efa21aad6c8f727da8d528a67a0b10765ead685",
            "patch": "@@ -153,12 +153,17 @@ async function loadComponentsImpl<N = any>({\n   isAppPath,\n   isDev,\n   sriEnabled,\n+  // When route modules are used, which is the case for the server calls to loadComponents, it no longer needs manifest to be loaded here.\n+  // Static generation still needs the manifests to be loaded here.\n+  // In the future static generation will also use route modules, and we will remove this flag.\n+  needsManifestsForLegacyReasons,\n }: {\n   distDir: string\n   page: string\n   isAppPath: boolean\n   isDev: boolean\n   sriEnabled: boolean\n+  needsManifestsForLegacyReasons: boolean\n }): Promise<LoadComponentsReturnType<N>> {\n   let DocumentMod = {}\n   let AppMod = {}\n@@ -169,147 +174,172 @@ async function loadComponentsImpl<N = any>({\n     ])\n   }\n \n-  // In dev mode we retry loading a manifest file to handle a race condition\n-  // that can occur while app and pages are compiling at the same time, and the\n-  // build-manifest is still being written to disk while an app path is\n-  // attempting to load.\n-  const manifestLoadAttempts = isDev ? 3 : 1\n+  if (needsManifestsForLegacyReasons) {\n+    // In dev mode we retry loading a manifest file to handle a race condition\n+    // that can occur while app and pages are compiling at the same time, and the\n+    // build-manifest is still being written to disk while an app path is\n+    // attempting to load.\n+    const manifestLoadAttempts = isDev ? 3 : 1\n \n-  let reactLoadableManifestPath\n-  if (!process.env.TURBOPACK) {\n-    reactLoadableManifestPath = join(\n-      /* turbopackIgnore: true */ distDir,\n-      REACT_LOADABLE_MANIFEST\n-    )\n-  } else if (isAppPath) {\n-    reactLoadableManifestPath = join(\n-      /* turbopackIgnore: true */\n-      distDir,\n-      'server',\n-      'app',\n-      page,\n-      REACT_LOADABLE_MANIFEST\n-    )\n-  } else {\n-    reactLoadableManifestPath = join(\n-      /* turbopackIgnore: true */\n-      distDir,\n-      'server',\n-      'pages',\n-      normalizePagePath(page),\n-      REACT_LOADABLE_MANIFEST\n-    )\n-  }\n-\n-  // Make sure to avoid loading the manifest for static metadata routes for better performance.\n-  const hasClientManifest = !isStaticMetadataRoute(page)\n+    let reactLoadableManifestPath\n+    if (!process.env.TURBOPACK) {\n+      reactLoadableManifestPath = join(\n+        /* turbopackIgnore: true */ distDir,\n+        REACT_LOADABLE_MANIFEST\n+      )\n+    } else if (isAppPath) {\n+      reactLoadableManifestPath = join(\n+        /* turbopackIgnore: true */ distDir,\n+        'server',\n+        'app',\n+        page,\n+        REACT_LOADABLE_MANIFEST\n+      )\n+    } else {\n+      reactLoadableManifestPath = join(\n+        /* turbopackIgnore: true */ distDir,\n+        'server',\n+        'pages',\n+        normalizePagePath(page),\n+        REACT_LOADABLE_MANIFEST\n+      )\n+    }\n \n-  // Load the manifest files first\n-  //\n-  // Loading page-specific manifests shouldn't throw an error if the manifest couldn't be found, so\n-  // that the `requirePage` call below will throw the correct error in that case\n-  // (a `PageNotFoundError`).\n-  const [\n-    buildManifest,\n-    reactLoadableManifest,\n-    dynamicCssManifest,\n-    clientReferenceManifest,\n-    serverActionsManifest,\n-    subresourceIntegrityManifest,\n-  ] = await Promise.all([\n-    loadManifestWithRetries<BuildManifest>(\n-      join(/* turbopackIgnore: true */ distDir, BUILD_MANIFEST),\n-      manifestLoadAttempts\n-    ),\n-    tryLoadManifestWithRetries<ReactLoadableManifest>(\n-      reactLoadableManifestPath,\n-      manifestLoadAttempts\n-    ),\n-    // This manifest will only exist in Pages dir && Production && Webpack.\n-    isAppPath || process.env.TURBOPACK\n-      ? undefined\n-      : loadManifestWithRetries<DynamicCssManifest>(\n-          join(\n-            /* turbopackIgnore: true */ distDir,\n-            `${DYNAMIC_CSS_MANIFEST}.json`\n-          ),\n-          manifestLoadAttempts\n-        ).catch(() => undefined),\n-    isAppPath && hasClientManifest\n-      ? tryLoadClientReferenceManifest(\n-          join(\n-            /* turbopackIgnore: true */\n-            distDir,\n-            'server',\n-            'app',\n-            page.replace(/%5F/g, '_') + '_' + CLIENT_REFERENCE_MANIFEST + '.js'\n-          ),\n-          page.replace(/%5F/g, '_'),\n-          manifestLoadAttempts\n-        )\n-      : undefined,\n-    isAppPath\n-      ? loadManifestWithRetries<ActionManifest>(\n-          join(\n-            /* turbopackIgnore: true */ distDir,\n-            'server',\n-            SERVER_REFERENCE_MANIFEST + '.json'\n-          ),\n-          manifestLoadAttempts\n-        ).catch(() => null)\n-      : null,\n-    sriEnabled\n-      ? loadManifestWithRetries<DeepReadonly<Record<string, string>>>(\n-          join(\n-            /* turbopackIgnore: true */ distDir,\n-            'server',\n-            SUBRESOURCE_INTEGRITY_MANIFEST + '.json'\n-          )\n-        ).catch(() => undefined)\n-      : undefined,\n-  ])\n+    // Make sure to avoid loading the manifest for static metadata routes for better performance.\n+    const hasClientManifest = !isStaticMetadataRoute(page)\n \n-  // Before requiring the actual page module, we have to set the reference\n-  // manifests to our global store so Server Action's encryption util can access\n-  // to them at the top level of the page module.\n-  if (serverActionsManifest && clientReferenceManifest) {\n-    setReferenceManifestsSingleton({\n-      page,\n+    // Load the manifest files first\n+    //\n+    // Loading page-specific manifests shouldn't throw an error if the manifest couldn't be found, so\n+    // that the `requirePage` call below will throw the correct error in that case\n+    // (a `PageNotFoundError`).\n+    const [\n+      buildManifest,\n+      reactLoadableManifest,\n+      dynamicCssManifest,\n       clientReferenceManifest,\n       serverActionsManifest,\n-      serverModuleMap: createServerModuleMap({\n+      subresourceIntegrityManifest,\n+    ] = await Promise.all([\n+      loadManifestWithRetries<BuildManifest>(\n+        join(/* turbopackIgnore: true */ distDir, BUILD_MANIFEST),\n+        manifestLoadAttempts\n+      ),\n+      tryLoadManifestWithRetries<ReactLoadableManifest>(\n+        reactLoadableManifestPath,\n+        manifestLoadAttempts\n+      ),\n+      // This manifest will only exist in Pages dir && Production && Webpack.\n+      isAppPath || process.env.TURBOPACK\n+        ? undefined\n+        : loadManifestWithRetries<DynamicCssManifest>(\n+            join(\n+              /* turbopackIgnore: true */ distDir,\n+              `${DYNAMIC_CSS_MANIFEST}.json`\n+            ),\n+            manifestLoadAttempts\n+          ).catch(() => undefined),\n+      isAppPath && hasClientManifest\n+        ? tryLoadClientReferenceManifest(\n+            join(\n+              /* turbopackIgnore: true */ distDir,\n+              'server',\n+              'app',\n+              page.replace(/%5F/g, '_') +\n+                '_' +\n+                CLIENT_REFERENCE_MANIFEST +\n+                '.js'\n+            ),\n+            page.replace(/%5F/g, '_'),\n+            manifestLoadAttempts\n+          )\n+        : undefined,\n+      isAppPath\n+        ? loadManifestWithRetries<ActionManifest>(\n+            join(\n+              /* turbopackIgnore: true */ distDir,\n+              'server',\n+              SERVER_REFERENCE_MANIFEST + '.json'\n+            ),\n+            manifestLoadAttempts\n+          ).catch(() => null)\n+        : null,\n+      sriEnabled\n+        ? loadManifestWithRetries<DeepReadonly<Record<string, string>>>(\n+            join(\n+              /* turbopackIgnore: true */ distDir,\n+              'server',\n+              SUBRESOURCE_INTEGRITY_MANIFEST + '.json'\n+            )\n+          ).catch(() => undefined)\n+        : undefined,\n+    ])\n+\n+    // Before requiring the actual page module, we have to set the reference\n+    // manifests to our global store so Server Action's encryption util can access\n+    // to them at the top level of the page module.\n+    if (serverActionsManifest && clientReferenceManifest) {\n+      setReferenceManifestsSingleton({\n+        page,\n+        clientReferenceManifest,\n         serverActionsManifest,\n-      }),\n-    })\n-  }\n+        serverModuleMap: createServerModuleMap({\n+          serverActionsManifest,\n+        }),\n+      })\n+    }\n+\n+    const ComponentMod = await requirePage(page, distDir, isAppPath)\n+\n+    const Component = interopDefault(ComponentMod)\n+    const Document = interopDefault(DocumentMod)\n+    const App = interopDefault(AppMod)\n \n-  const ComponentMod = await requirePage(page, distDir, isAppPath)\n+    const { getServerSideProps, getStaticProps, getStaticPaths, routeModule } =\n+      ComponentMod\n+\n+    return {\n+      App,\n+      Document,\n+      Component,\n+      buildManifest,\n+      subresourceIntegrityManifest,\n+      reactLoadableManifest: reactLoadableManifest || {},\n+      dynamicCssManifest,\n+      pageConfig: ComponentMod.config || {},\n+      ComponentMod,\n+      getServerSideProps,\n+      getStaticProps,\n+      getStaticPaths,\n+      clientReferenceManifest,\n+      serverActionsManifest,\n+      isAppPath,\n+      page,\n+      routeModule,\n+    }\n+  } else {\n+    const ComponentMod = await requirePage(page, distDir, isAppPath)\n \n-  const Component = interopDefault(ComponentMod)\n-  const Document = interopDefault(DocumentMod)\n-  const App = interopDefault(AppMod)\n+    const Component = interopDefault(ComponentMod)\n+    const Document = interopDefault(DocumentMod)\n+    const App = interopDefault(AppMod)\n \n-  const { getServerSideProps, getStaticProps, getStaticPaths, routeModule } =\n-    ComponentMod\n+    const { getServerSideProps, getStaticProps, getStaticPaths, routeModule } =\n+      ComponentMod\n \n-  return {\n-    App,\n-    Document,\n-    Component,\n-    buildManifest,\n-    subresourceIntegrityManifest,\n-    reactLoadableManifest: reactLoadableManifest || {},\n-    dynamicCssManifest,\n-    pageConfig: ComponentMod.config || {},\n-    ComponentMod,\n-    getServerSideProps,\n-    getStaticProps,\n-    getStaticPaths,\n-    clientReferenceManifest,\n-    serverActionsManifest,\n-    isAppPath,\n-    page,\n-    routeModule,\n+    return {\n+      App,\n+      Document,\n+      Component,\n+      pageConfig: ComponentMod.config || {},\n+      ComponentMod,\n+      getServerSideProps,\n+      getStaticProps,\n+      getStaticPaths,\n+      isAppPath,\n+      page,\n+      routeModule,\n+    } as any // temporary `as any` to make TypeScript not fail so that the tests will run on the PR.\n   }\n }\n "
        },
        {
            "sha": "2571c8b2efc6e4d278b37a1cc942c54ab5a4b955",
            "filename": "packages/next/src/server/next-server.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/3efa21aad6c8f727da8d528a67a0b10765ead685/packages%2Fnext%2Fsrc%2Fserver%2Fnext-server.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/3efa21aad6c8f727da8d528a67a0b10765ead685/packages%2Fnext%2Fsrc%2Fserver%2Fnext-server.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fnext-server.ts?ref=3efa21aad6c8f727da8d528a67a0b10765ead685",
            "patch": "@@ -371,6 +371,7 @@ export default class NextNodeServer extends BaseServer<\n           isAppPath: false,\n           isDev: this.isDev,\n           sriEnabled: this.sriEnabled,\n+          needsManifestsForLegacyReasons: false,\n         })\n       } catch (_err) {\n         // Intentionally ignored because this is a preload step.\n@@ -385,6 +386,7 @@ export default class NextNodeServer extends BaseServer<\n           isAppPath: true,\n           isDev: this.isDev,\n           sriEnabled: this.sriEnabled,\n+          needsManifestsForLegacyReasons: false,\n         })\n         // we need to ensure fetch is patched before we require the page,\n         // otherwise if the fetch is patched by user code, we will be patching it\n@@ -905,6 +907,7 @@ export default class NextNodeServer extends BaseServer<\n           isAppPath,\n           isDev: this.isDev,\n           sriEnabled: this.sriEnabled,\n+          needsManifestsForLegacyReasons: false,\n         })\n \n         if ("
        },
        {
            "sha": "5d2ae4050673fb218f7f4b6c58c58d994ee4153c",
            "filename": "test/e2e/app-dir/require-context/require-context.test.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/3efa21aad6c8f727da8d528a67a0b10765ead685/test%2Fe2e%2Fapp-dir%2Frequire-context%2Frequire-context.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/3efa21aad6c8f727da8d528a67a0b10765ead685/test%2Fe2e%2Fapp-dir%2Frequire-context%2Frequire-context.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Frequire-context%2Frequire-context.test.ts?ref=3efa21aad6c8f727da8d528a67a0b10765ead685",
            "patch": "@@ -18,6 +18,7 @@ describe('require-context', () => {\n   })\n \n   // TODO: This test is already scaffolded and just needs to be turned on when turbopack supports it.\n+  // eslint-disable-next-line jest/no-commented-out-tests\n   // it('should get correct require context when using no regex', async () => {\n   //   const $ = await next.render$('/require-context-with-no-regex')\n   //   expect($('pre').text()).toBe("
        }
    ],
    "stats": {
        "total": 301,
        "additions": 170,
        "deletions": 131
    }
}