{
    "author": "icyJoseph",
    "message": "docs: getting started updates 01 (#85750)",
    "sha": "6ba8ec8725b3ea146b24e948e1d6f0c65a3f772d",
    "files": [
        {
            "sha": "9f23e81e59ba684d02c1a479de4257e39e1b55e4",
            "filename": "docs/01-app/01-getting-started/06-cache-components.mdx",
            "status": "modified",
            "additions": 23,
            "deletions": 8,
            "changes": 31,
            "blob_url": "https://github.com/vercel/next.js/blob/6ba8ec8725b3ea146b24e948e1d6f0c65a3f772d/docs%2F01-app%2F01-getting-started%2F06-cache-components.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/6ba8ec8725b3ea146b24e948e1d6f0c65a3f772d/docs%2F01-app%2F01-getting-started%2F06-cache-components.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F01-getting-started%2F06-cache-components.mdx?ref=6ba8ec8725b3ea146b24e948e1d6f0c65a3f772d",
            "patch": "@@ -232,37 +232,52 @@ Like Server Actions, arguments to cached functions must be serializable. This me\n You can accept unserializable values as arguments as long as you don't introspect them. However, you can return them. This allows patterns like cached components that accept Server or Client Components as children:\n \n ```tsx filename=\"app/cached-wrapper.tsx\" switcher\n-import { ReactNode } from 'react'\n+import type { ReactNode } from 'react'\n+import { setTimeout } from 'node:timers/promises'\n+\n+async function getSiteTitle() {\n+  // Simulate a slow database or API call\n+  await setTimeout(1000) // from 'node:timers/promises'\n+  return 'My Website'\n+}\n \n export async function CachedWrapper({ children }: { children: ReactNode }) {\n   'use cache'\n+  const title = await getSiteTitle()\n+\n   // Don't introspect children, just pass it through\n   return (\n     <div className=\"wrapper\">\n-      <header>Cached Header</header>\n+      <h1>{title}</h1>\n       {children}\n     </div>\n   )\n }\n ```\n \n ```jsx filename=\"app/cached-wrapper.js\" switcher\n+import { setTimeout } from 'node:timers/promises'\n+\n+async function getSiteTitle() {\n+  // Simulate a slow database or API call\n+  await setTimeout(1000) // from 'node:timers/promises'\n+  return 'My Website'\n+}\n+\n export async function CachedWrapper({ children }) {\n   'use cache'\n+  const title = await getSiteTitle()\n+\n   // Don't introspect children, just pass it through\n   return (\n     <div className=\"wrapper\">\n-      <header>Cached Header</header>\n+      <h1>{title}</h1>\n       {children}\n     </div>\n   )\n }\n ```\n \n-#### Avoid passing dynamic inputs\n-\n-You must not pass dynamic or runtime data into `use cache` functions unless you avoid introspecting them. Passing values from `cookies()`, `headers()`, or other runtime APIs as arguments will cause errors, as the cache key cannot be determined at pre-render time.\n-\n ### Tagging and revalidating\n \n Tag cached data with [`cacheTag`](/docs/app/api-reference/functions/cacheTag) and revalidate it after mutations using [`updateTag`](/docs/app/api-reference/functions/updateTag) in Server Actions for immediate updates, or [`revalidateTag`](/docs/app/api-reference/functions/revalidateTag) delay in updates are acceptable.\n@@ -521,7 +536,7 @@ export default function Page() {\n \n ### Passing dynamic props\n \n-Components only opt into dynamic rendering when the value is accessed. For example, if you are reading `searchParams` from a `<Page />` component, you can forward this value to another component as a prop:\n+Components that access runtime values like `cookies` or `searchParams` cannot be prerendered. To prerender more of a page's content, you can pass these props down and access their values lower in the tree. For example, if you are reading `searchParams` from a `<Page />` component, you can forward this value to another component as a prop:\n \n ```tsx filename=\"app/page.tsx\" switcher\n import { Table, TableSkeleton } from './table'"
        },
        {
            "sha": "83d7123bd434c976f134185756cf748f8cff4105",
            "filename": "docs/01-app/01-getting-started/07-fetching-data.mdx",
            "status": "modified",
            "additions": 14,
            "deletions": 19,
            "changes": 33,
            "blob_url": "https://github.com/vercel/next.js/blob/6ba8ec8725b3ea146b24e948e1d6f0c65a3f772d/docs%2F01-app%2F01-getting-started%2F07-fetching-data.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/6ba8ec8725b3ea146b24e948e1d6f0c65a3f772d/docs%2F01-app%2F01-getting-started%2F07-fetching-data.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F01-getting-started%2F07-fetching-data.mdx?ref=6ba8ec8725b3ea146b24e948e1d6f0c65a3f772d",
            "patch": "@@ -18,10 +18,11 @@ This page will walk you through how you can fetch data in [Server and Client Com\n \n ### Server Components\n \n-You can fetch data in Server Components using:\n+You can fetch data in Server Components using any asynchronous I/O, such as:\n \n 1. The [`fetch` API](#with-the-fetch-api)\n 2. An [ORM or database](#with-an-orm-or-database)\n+3. Reading from the filesystem using Node.js APIs like `fs`\n \n #### With the `fetch` API\n \n@@ -285,7 +286,7 @@ To improve the initial load time and user experience, you can use streaming to b\n   height=\"785\"\n />\n \n-There are two ways you can implement streaming in your application:\n+There are two ways you can leverage streaming in your application:\n \n 1. Wrapping a page with a [`loading.js` file](#with-loadingjs)\n 2. Wrapping a component with [`<Suspense>`](#with-suspense)\n@@ -356,7 +357,7 @@ export default function BlogPage() {\n         <p>Read the latest posts below.</p>\n       </header>\n       <main>\n-        {/* Any content wrapped in a <Suspense> boundary will be streamed */}\n+        {/* If there's any dynamic content inside this boundary, it will be streamed in */}\n         <Suspense fallback={<BlogListSkeleton />}>\n           <BlogList />\n         </Suspense>\n@@ -380,7 +381,7 @@ export default function BlogPage() {\n         <p>Read the latest posts below.</p>\n       </header>\n       <main>\n-        {/* Any content wrapped in a <Suspense> boundary will be streamed */}\n+        {/* If there's any dynamic content inside this boundary, it will be streamed in */}\n         <Suspense fallback={<BlogListSkeleton />}>\n           <BlogList />\n         </Suspense>\n@@ -400,19 +401,9 @@ In development, you can preview and inspect the loading state of your components\n \n ### Sequential data fetching\n \n-Sequential data fetching happens when nested components in a tree each fetch their own data and the requests are not [deduplicated](/docs/app/guides/caching#request-memoization), leading to longer response times.\n+Sequential data fetching happens when one request depends on data from another.\n \n-<Image\n-  alt=\"Sequential and Parallel Data Fetching\"\n-  srcLight=\"/docs/light/sequential-parallel-data-fetching.png\"\n-  srcDark=\"/docs/dark/sequential-parallel-data-fetching.png\"\n-  width=\"1600\"\n-  height=\"525\"\n-/>\n-\n-There may be cases where you want this pattern because one fetch depends on the result of the other.\n-\n-For example, the `<Playlists>` component will only start fetching data once the `<Artist>` component has finished fetching data because `<Playlists>` depends on the `artistID` prop:\n+For example, `<Playlists>` can only fetch data after `<Artist>` completes because it needs the `artistID`:\n \n ```tsx filename=\"app/artist/[username]/page.tsx\" switcher\n export default async function Page({\n@@ -482,7 +473,9 @@ async function Playlists({ artistID }) {\n }\n ```\n \n-To improve the user experience, you should use [React `<Suspense>`](/docs/app/getting-started/linking-and-navigating#streaming) to show a `fallback` while data is being fetch. This will enable [streaming](#streaming) and prevent the whole route from being blocked by the sequential data requests.\n+In this example, `<Suspense>` allows the playlists to stream in after the artist data loads. However, the page still waits for the artist data before displaying anything. To prevent this, you can wrap the entire page component in a `<Suspense>` boundary (for example, using a [`loading.js` file](#with-loadingjs)) to show a loading state immediately.\n+\n+Ensure your data source can resolve the first request quickly, as it blocks everything else. If you can't optimize the request further, consider [caching](#deduplicate-requests-and-cache-data) the result if the data changes infrequently.\n \n ### Parallel data fetching\n \n@@ -597,11 +590,12 @@ export default async function Page({\n   return isAvailable ? <Item id={id} /> : null\n }\n \n-export const preload = (id: string) => {\n+const preload = (id: string) => {\n   // void evaluates the given expression and returns undefined\n   // https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/void\n   void getItem(id)\n }\n+\n export async function Item({ id }: { id: string }) {\n   const result = await getItem(id)\n   // ...\n@@ -621,11 +615,12 @@ export default async function Page({ params }) {\n   return isAvailable ? <Item id={id} /> : null\n }\n \n-export const preload = (id) => {\n+const preload = (id) => {\n   // void evaluates the given expression and returns undefined\n   // https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/void\n   void getItem(id)\n }\n+\n export async function Item({ id }) {\n   const result = await getItem(id)\n   // ..."
        },
        {
            "sha": "30548c96c2d1f1cf96651d12de5b92ade2b13c99",
            "filename": "docs/01-app/01-getting-started/08-updating-data.mdx",
            "status": "modified",
            "additions": 32,
            "deletions": 0,
            "changes": 32,
            "blob_url": "https://github.com/vercel/next.js/blob/6ba8ec8725b3ea146b24e948e1d6f0c65a3f772d/docs%2F01-app%2F01-getting-started%2F08-updating-data.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/6ba8ec8725b3ea146b24e948e1d6f0c65a3f772d/docs%2F01-app%2F01-getting-started%2F08-updating-data.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F01-getting-started%2F08-updating-data.mdx?ref=6ba8ec8725b3ea146b24e948e1d6f0c65a3f772d",
            "patch": "@@ -328,6 +328,38 @@ export function Button() {\n }\n ```\n \n+### Refreshing\n+\n+After a mutation, you may want to refresh the current page to show the latest data. You can do this by calling [`refresh`](/docs/app/api-reference/functions/refresh) from `next/cache` in a Server Action:\n+\n+```ts filename=\"app/lib/actions.ts\" switcher\n+'use server'\n+\n+import { refresh } from 'next/cache'\n+\n+export async function updatePost(formData: FormData) {\n+  // Update data\n+  // ...\n+\n+  refresh()\n+}\n+```\n+\n+```js filename=\"app/lib/actions.js\" switcher\n+'use server'\n+\n+import { refresh } from 'next/cache'\n+\n+export async function updatePost(formData) {\n+  // Update data\n+  // ...\n+\n+  refresh()\n+}\n+```\n+\n+This refreshes the client router, ensuring the UI reflects the latest state. The `refresh()` function does not revalidate tagged data. To revalidate tagged data, use [`updateTag`](/docs/app/api-reference/functions/updateTag) or [`revalidateTag`](/docs/app/api-reference/functions/revalidateTag) instead.\n+\n ### Revalidating\n \n After performing an update, you can revalidate the Next.js cache and show the updated data by calling [`revalidatePath`](/docs/app/api-reference/functions/revalidatePath) or [`revalidateTag`](/docs/app/api-reference/functions/revalidateTag) within the Server Function:"
        },
        {
            "sha": "58a6e094776e95c1e6ca8af4d9ae3a0cf549b7cb",
            "filename": "docs/01-app/03-api-reference/04-functions/refresh.mdx",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/6ba8ec8725b3ea146b24e948e1d6f0c65a3f772d/docs%2F01-app%2F03-api-reference%2F04-functions%2Frefresh.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/6ba8ec8725b3ea146b24e948e1d6f0c65a3f772d/docs%2F01-app%2F03-api-reference%2F04-functions%2Frefresh.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-api-reference%2F04-functions%2Frefresh.mdx?ref=6ba8ec8725b3ea146b24e948e1d6f0c65a3f772d",
            "patch": "@@ -25,7 +25,6 @@ refresh(): void;\n 'use server'\n \n import { refresh } from 'next/cache'\n-import { redirect } from 'next/navigation'\n \n export async function createPost(formData: FormData) {\n   const title = formData.get('title')\n@@ -44,7 +43,6 @@ export async function createPost(formData: FormData) {\n 'use server'\n \n import { refresh } from 'next/cache'\n-import { redirect } from 'next/navigation'\n \n export async function createPost(formData) {\n   const title = formData.get('title')"
        },
        {
            "sha": "90021f422f5601788ea24149ac02740cf23e7efc",
            "filename": "docs/01-app/03-api-reference/05-config/01-next-config-js/mdxRs.mdx",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/6ba8ec8725b3ea146b24e948e1d6f0c65a3f772d/docs%2F01-app%2F03-api-reference%2F05-config%2F01-next-config-js%2FmdxRs.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/6ba8ec8725b3ea146b24e948e1d6f0c65a3f772d/docs%2F01-app%2F03-api-reference%2F05-config%2F01-next-config-js%2FmdxRs.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-api-reference%2F05-config%2F01-next-config-js%2FmdxRs.mdx?ref=6ba8ec8725b3ea146b24e948e1d6f0c65a3f772d",
            "patch": "@@ -1,7 +1,7 @@\n ---\n title: mdxRs\n description: Use the new Rust compiler to compile MDX files in the App Router.\n-version: experimental.\n+version: experimental\n ---\n \n For experimental use with `@next/mdx`. Compiles MDX files using the new Rust compiler."
        },
        {
            "sha": "f2d29d53ef18e192b23ed0b8c77db8fdf6a61b78",
            "filename": "docs/01-app/03-api-reference/06-cli/next.mdx",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/6ba8ec8725b3ea146b24e948e1d6f0c65a3f772d/docs%2F01-app%2F03-api-reference%2F06-cli%2Fnext.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/6ba8ec8725b3ea146b24e948e1d6f0c65a3f772d/docs%2F01-app%2F03-api-reference%2F06-cli%2Fnext.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-api-reference%2F06-cli%2Fnext.mdx?ref=6ba8ec8725b3ea146b24e948e1d6f0c65a3f772d",
            "patch": "@@ -149,7 +149,7 @@ The following options are available for the `next telemetry` command:\n \n Learn more about [Telemetry](/telemetry).\n \n-### `next typegen` Options\n+### `next typegen` options\n \n `next typegen` generates TypeScript definitions for your application's routes without performing a full build. This is useful for IDE autocomplete and CI type-checking of route usage.\n "
        }
    ],
    "stats": {
        "total": 102,
        "additions": 71,
        "deletions": 31
    }
}