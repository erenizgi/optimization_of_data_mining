{
    "author": "icyJoseph",
    "message": "docs: GET handler behavior under cache components (#85389)",
    "sha": "0adb4986a081c36a6e4ff32e2bf9f85daf5c31c3",
    "files": [
        {
            "sha": "8fd65cef3a991ced4cbf17c07e2e8463c3c6435c",
            "filename": "docs/01-app/01-getting-started/06-cache-components.mdx",
            "status": "modified",
            "additions": 59,
            "deletions": 0,
            "changes": 59,
            "blob_url": "https://github.com/vercel/next.js/blob/0adb4986a081c36a6e4ff32e2bf9f85daf5c31c3/docs%2F01-app%2F01-getting-started%2F06-cache-components.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/0adb4986a081c36a6e4ff32e2bf9f85daf5c31c3/docs%2F01-app%2F01-getting-started%2F06-cache-components.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F01-getting-started%2F06-cache-components.mdx?ref=0adb4986a081c36a6e4ff32e2bf9f85daf5c31c3",
            "patch": "@@ -575,6 +575,65 @@ export async function Table({ sortPromise }) {\n }\n ```\n \n+## Route Handlers with Cache Components\n+\n+`GET` Route Handlers follow the same model as normal UI routes in your application. They are dynamic by default, can be pre-rendered when deterministic, and you can `use cache` to include more dynamic data in the cached response.\n+\n+Dynamic example, returns a different number for every request:\n+\n+```tsx filename=\"app/api/random-number/route.ts\"\n+export async function GET() {\n+  return Response.json({\n+    randomNumber: Math.random(),\n+  })\n+}\n+```\n+\n+A handler that returns only static data will be pre-rendered at build time:\n+\n+```tsx filename=\"app/api/project-info/route.ts\"\n+export async function GET() {\n+  return Response.json({\n+    projectName: 'Next.js',\n+  })\n+}\n+```\n+\n+If you had a route that returned fresh dynamic data on every request, say products from a database:\n+\n+```tsx filename=\"app/api/products/route.ts\"\n+export async function GET() {\n+  const products = await db.query('SELECT * FROM products')\n+\n+  return Response.json(products)\n+}\n+```\n+\n+To cache this and avoid hitting the database on every request, extract the dynamic work into a `use cache` function and set `cacheLife('hours')` so the database is queried at most once per hour:\n+\n+```tsx filename=\"app/api/products/route.ts\"\n+import { cacheLife } from 'next/cache'\n+\n+export async function GET() {\n+  const products = await getProducts()\n+\n+  return Response.json(products)\n+}\n+\n+async function getProducts() {\n+  'use cache'\n+  cacheLife('hours')\n+\n+  return await db.query('SELECT * FROM products')\n+}\n+```\n+\n+> **Good to know**\n+>\n+> - `use cache` cannot be used directly inside a Route Handler body; extract to a helper.\n+> - Cached responses revalidate according to `cacheLife` when a new request arrives.\n+> - Using runtime APIs like [`cookies()`](/docs/app/api-reference/functions/cookies) or [`headers()`](/docs/app/api-reference/functions/headers), or calling [`connection()`](/docs/app/api-reference/functions/connection), always defers to request time (no pre-rendering).\n+\n ## Frequently Asked Questions\n \n ### Does this replace Partial Prerendering (PPR)?"
        }
    ],
    "stats": {
        "total": 59,
        "additions": 59,
        "deletions": 0
    }
}