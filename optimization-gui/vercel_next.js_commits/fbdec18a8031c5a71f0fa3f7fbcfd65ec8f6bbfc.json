{
    "author": "eps1lon",
    "message": "Revert \"[ppr] RDC for RSCs\" (#80794)",
    "sha": "fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc",
    "files": [
        {
            "sha": "c5896248569a9bfcaec46d468d50341ab8e91dfa",
            "filename": "packages/next/errors.json",
            "status": "modified",
            "additions": 1,
            "deletions": 3,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc/packages%2Fnext%2Ferrors.json",
            "raw_url": "https://github.com/vercel/next.js/raw/fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc/packages%2Fnext%2Ferrors.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Ferrors.json?ref=fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc",
            "patch": "@@ -712,7 +712,5 @@\n   \"711\": \"Can't resolve %s\",\n   \"712\": \"`rspack.warnForEdgeRuntime` is not supported by the wasm bindings.\",\n   \"713\": \"Unexpected error during process lookup\",\n-  \"714\": \"cannot run loadNative when `NEXT_TEST_WASM` is set\",\n-  \"715\": \"expected a result to be returned\",\n-  \"716\": \"expected a page response, got %s\"\n+  \"714\": \"cannot run loadNative when `NEXT_TEST_WASM` is set\"\n }"
        },
        {
            "sha": "95adb78da216f18cba7e7130ff25a1792d254296",
            "filename": "packages/next/src/build/index.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts?ref=fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc",
            "patch": "@@ -447,7 +447,6 @@ export type RoutesManifest = {\n     prefetchSegmentHeader: typeof NEXT_ROUTER_SEGMENT_PREFETCH_HEADER\n     prefetchSegmentDirSuffix: typeof RSC_SEGMENTS_DIR_SUFFIX\n     prefetchSegmentSuffix: typeof RSC_SEGMENT_SUFFIX\n-    dynamicRSCPrerender: boolean\n   }\n   rewriteHeaders: {\n     pathHeader: typeof NEXT_REWRITTEN_PATH_HEADER\n@@ -1371,7 +1370,6 @@ export default async function build(\n               prefetchSegmentHeader: NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n               prefetchSegmentSuffix: RSC_SEGMENT_SUFFIX,\n               prefetchSegmentDirSuffix: RSC_SEGMENTS_DIR_SUFFIX,\n-              dynamicRSCPrerender: isAppPPREnabled,\n             },\n             rewriteHeaders: {\n               pathHeader: NEXT_REWRITTEN_PATH_HEADER,"
        },
        {
            "sha": "aad1b98bfade066c7371a137f5319f5cf786205c",
            "filename": "packages/next/src/build/templates/app-page.ts",
            "status": "modified",
            "additions": 60,
            "deletions": 62,
            "changes": 122,
            "blob_url": "https://github.com/vercel/next.js/blob/fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fapp-page.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fapp-page.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fapp-page.ts?ref=fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc",
            "patch": "@@ -36,7 +36,6 @@ import {\n import { getBotType, isBot } from '../../shared/lib/router/utils/is-bot'\n import {\n   CachedRouteKind,\n-  IncrementalCacheKind,\n   type CachedAppPageValue,\n   type CachedPageValue,\n   type ResponseCacheEntry,\n@@ -127,6 +126,7 @@ export async function handler(\n   const multiZoneDraftMode = process.env\n     .__NEXT_MULTI_ZONE_DRAFT_MODE as any as boolean\n \n+  const initialPostponed = getRequestMeta(req, 'postponed')\n   // TODO: replace with more specific flags\n   const minimalMode = getRequestMeta(req, 'minimalMode')\n \n@@ -260,9 +260,7 @@ export async function handler(\n   // If we're in minimal mode, then try to get the postponed information from\n   // the request metadata. If available, use it for resuming the postponed\n   // render.\n-  const minimalPostponed = isRoutePPREnabled\n-    ? getRequestMeta(req, 'postponed')\n-    : undefined\n+  const minimalPostponed = isRoutePPREnabled ? initialPostponed : undefined\n \n   // If PPR is enabled, and this is a RSC request (but not a prefetch), then\n   // we can use this fact to only generate the flight data for the request\n@@ -299,10 +297,10 @@ export async function handler(\n     !isSSG ||\n     // If this request has provided postponed data, it supports dynamic\n     // HTML.\n-    typeof minimalPostponed === 'string' ||\n+    typeof initialPostponed === 'string' ||\n     // If this is a dynamic RSC request, then this render supports dynamic\n     // HTML (it's dynamic).\n-    (isDynamicRSCRequest && !minimalMode)\n+    isDynamicRSCRequest\n \n   // When html bots request PPR page, perform the full dynamic rendering.\n   const shouldWaitOnAllReady = isHtmlBot && isRoutePPREnabled\n@@ -417,8 +415,6 @@ export async function handler(\n       })\n     }\n \n-    const incrementalCache = getRequestMeta(req, 'incrementalCache')\n-\n     const doRender = async ({\n       span,\n       postponed,\n@@ -436,9 +432,6 @@ export async function handler(\n        */\n       fallbackRouteParams: FallbackRouteParams | null\n     }): Promise<ResponseCacheEntry> => {\n-      // When we're resuming a render, we should allow dynamic response.\n-      if (typeof postponed === 'string') supportsDynamicResponse = true\n-\n       const context: AppPageRouteHandlerContext = {\n         query,\n         params,\n@@ -464,7 +457,8 @@ export async function handler(\n           postponed,\n           shouldWaitOnAllReady,\n           serveStreamingMetadata,\n-          supportsDynamicResponse,\n+          supportsDynamicResponse:\n+            typeof postponed === 'string' || supportsDynamicResponse,\n           buildManifest,\n           nextFontManifest,\n           reactLoadableManifest,\n@@ -492,11 +486,21 @@ export async function handler(\n           reactMaxHeadersLength: nextConfig.reactMaxHeadersLength,\n \n           multiZoneDraftMode,\n-          incrementalCache,\n+          incrementalCache: getRequestMeta(req, 'incrementalCache'),\n           cacheLifeProfiles: nextConfig.experimental.cacheLife,\n           basePath: nextConfig.basePath,\n           serverActions: nextConfig.experimental.serverActions,\n \n+          ...(isDebugStaticShell || isDebugDynamicAccesses\n+            ? {\n+                nextExport: true,\n+                supportsDynamicResponse: false,\n+                isStaticGeneration: true,\n+                isRevalidate: true,\n+                isDebugDynamicAccesses: isDebugDynamicAccesses,\n+              }\n+            : {}),\n+\n           experimental: {\n             isRoutePPREnabled,\n             expireTime: nextConfig.expireTime,\n@@ -530,14 +534,6 @@ export async function handler(\n         },\n       }\n \n-      if (isDebugStaticShell || isDebugDynamicAccesses) {\n-        context.renderOpts.nextExport = true\n-        context.renderOpts.supportsDynamicResponse = false\n-        context.renderOpts.isStaticGeneration = true\n-        context.renderOpts.isRevalidate = true\n-        context.renderOpts.isDebugDynamicAccesses = isDebugDynamicAccesses\n-      }\n-\n       const result = await invokeRouteModule(span, context)\n \n       const { metadata } = result\n@@ -703,42 +699,13 @@ export async function handler(\n           }\n         }\n       }\n-\n       // Only requests that aren't revalidating can be resumed. If we have the\n       // minimal postponed data, then we should resume the render with it.\n-      let postponed =\n+      const postponed =\n         !isOnDemandRevalidate && !isRevalidating && minimalPostponed\n           ? minimalPostponed\n           : undefined\n \n-      // If this is a dynamic RSC request, we should use the postponed data from\n-      // the static render (if available). This ensures that we can utilize the\n-      // resume data cache (RDC) from the static render to ensure that the data\n-      // is consistent between the static and dynamic renders.\n-      if (\n-        process.env.NEXT_RUNTIME !== 'edge' &&\n-        !minimalMode &&\n-        incrementalCache &&\n-        isDynamicRSCRequest\n-      ) {\n-        const cachedEntry = await incrementalCache.get(resolvedPathname, {\n-          kind: IncrementalCacheKind.APP_PAGE,\n-          isRoutePPREnabled: true,\n-          isFallback: false,\n-          allowStale: true,\n-        })\n-\n-        // If the cache entry is found, we should use the postponed data from\n-        // the cache.\n-        if (\n-          cachedEntry &&\n-          cachedEntry.value &&\n-          cachedEntry.value.kind === CachedRouteKind.APP_PAGE\n-        ) {\n-          postponed = cachedEntry.value.postponed\n-        }\n-      }\n-\n       // When we're in minimal mode, if we're trying to debug the static shell,\n       // we should just return nothing instead of resuming the dynamic render.\n       if (\n@@ -864,7 +831,12 @@ export async function handler(\n       // If this is in minimal mode and this is a flight request that isn't a\n       // prefetch request while PPR is enabled, it cannot be cached as it contains\n       // dynamic content.\n-      else if (isDynamicRSCRequest) {\n+      else if (\n+        minimalMode &&\n+        isRSCRequest &&\n+        !isPrefetchRSCRequest &&\n+        isRoutePPREnabled\n+      ) {\n         cacheControl = { revalidate: 0, expire: undefined }\n       } else if (!routeModule.isDev) {\n         // If this is a preview mode request, we shouldn't cache it\n@@ -961,15 +933,34 @@ export async function handler(\n \n       // If there's a callback for `onCacheEntry`, call it with the cache entry\n       // and the revalidate options.\n-      const onCacheEntry =\n-        getRequestMeta(req, 'onCacheEntryV2') ??\n-        // TODO: Remove this once we've migrated to `onCacheEntryV2`\n-        getRequestMeta(req, 'onCacheEntry')\n+      const onCacheEntry = getRequestMeta(req, 'onCacheEntry')\n       if (onCacheEntry) {\n-        const finished = await onCacheEntry(cacheEntry, {\n-          url: getRequestMeta(req, 'initURL') ?? req.url,\n-        })\n-        if (finished) return null\n+        const finished = await onCacheEntry(\n+          {\n+            ...cacheEntry,\n+            // TODO: remove this when upstream doesn't\n+            // always expect this value to be \"PAGE\"\n+            value: {\n+              ...cacheEntry.value,\n+              kind: 'PAGE',\n+            },\n+          },\n+          {\n+            url: getRequestMeta(req, 'initURL'),\n+          }\n+        )\n+        if (finished) {\n+          // TODO: maybe we have to end the request?\n+          return null\n+        }\n+      }\n+\n+      // If the request has a postponed state and it's a resume request we\n+      // should error.\n+      if (didPostpone && minimalPostponed) {\n+        throw new Error(\n+          'Invariant: postponed state should not be present on a resume request'\n+        )\n       }\n \n       if (cachedData.headers) {\n@@ -1042,7 +1033,14 @@ export async function handler(\n             generateEtags: nextConfig.generateEtags,\n             poweredByHeader: nextConfig.poweredByHeader,\n             result: cachedData.html,\n-            cacheControl: cacheEntry.cacheControl,\n+            // Dynamic RSC responses cannot be cached, even if they're\n+            // configured with `force-static` because we have no way of\n+            // distinguishing between `force-static` and pages that have no\n+            // postponed state.\n+            // TODO: distinguish `force-static` from pages with no postponed state (static)\n+            cacheControl: isDynamicRSCRequest\n+              ? { revalidate: 0, expire: undefined }\n+              : cacheEntry.cacheControl,\n           })\n         }\n \n@@ -1060,7 +1058,7 @@ export async function handler(\n       }\n \n       // This is a request for HTML data.\n-      const body = cachedData.html\n+      let body = cachedData.html\n \n       // If there's no postponed state, we should just serve the HTML. This\n       // should also be the case for a resume request because it's completed"
        },
        {
            "sha": "9cc898a553cd07bd865794edd8e9d0670029947f",
            "filename": "packages/next/src/server/app-render/app-render.tsx",
            "status": "modified",
            "additions": 1,
            "deletions": 9,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx?ref=fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc",
            "patch": "@@ -1508,9 +1508,7 @@ async function renderToHTMLOrFlightImpl(\n   } else {\n     // We're rendering dynamically\n     const renderResumeDataCache =\n-      renderOpts.renderResumeDataCache ??\n-      postponedState?.renderResumeDataCache ??\n-      null\n+      renderOpts.renderResumeDataCache ?? postponedState?.renderResumeDataCache\n \n     const rootParams = getRootParams(loaderTree, ctx.getDynamicParamFromSegment)\n     const requestStore = createRequestStoreForRender(\n@@ -1564,9 +1562,6 @@ async function renderToHTMLOrFlightImpl(\n \n     let formState: null | any = null\n     if (isPossibleActionRequest) {\n-      // For action requests, we don't want to use the resume data cache.\n-      requestStore.renderResumeDataCache = null\n-\n       // For action requests, we handle them differently with a special render result.\n       const actionRequestResult = await handleAction({\n         req,\n@@ -1607,9 +1602,6 @@ async function renderToHTMLOrFlightImpl(\n           }\n         }\n       }\n-\n-      // Restore the resume data cache\n-      requestStore.renderResumeDataCache = renderResumeDataCache\n     }\n \n     const options: RenderResultOptions = {"
        },
        {
            "sha": "89558398a70056f1ff9f61dddae40ce94050a139",
            "filename": "packages/next/src/server/async-storage/request-store.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc/packages%2Fnext%2Fsrc%2Fserver%2Fasync-storage%2Frequest-store.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc/packages%2Fnext%2Fsrc%2Fserver%2Fasync-storage%2Frequest-store.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fasync-storage%2Frequest-store.ts?ref=fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc",
            "patch": "@@ -114,7 +114,7 @@ export function createRequestStoreForRender(\n   previewProps: WrapperRenderOpts['previewProps'],\n   isHmrRefresh: RequestContext['isHmrRefresh'],\n   serverComponentsHmrCache: RequestContext['serverComponentsHmrCache'],\n-  renderResumeDataCache: RenderResumeDataCache | null\n+  renderResumeDataCache: RenderResumeDataCache | undefined\n ): RequestStore {\n   return createRequestStoreImpl(\n     // Pages start in render phase by default\n@@ -148,7 +148,7 @@ export function createRequestStoreForAPI(\n     {},\n     implicitTags,\n     onUpdateCookies,\n-    null,\n+    undefined,\n     previewProps,\n     false,\n     undefined\n@@ -163,7 +163,7 @@ function createRequestStoreImpl(\n   rootParams: Params,\n   implicitTags: RequestContext['implicitTags'],\n   onUpdateCookies: RenderOpts['onUpdateCookies'],\n-  renderResumeDataCache: RenderResumeDataCache | null,\n+  renderResumeDataCache: RenderResumeDataCache | undefined,\n   previewProps: WrapperRenderOpts['previewProps'],\n   isHmrRefresh: RequestContext['isHmrRefresh'],\n   serverComponentsHmrCache: RequestContext['serverComponentsHmrCache']"
        },
        {
            "sha": "821179b23c0d8e1bea5f9e7be19e1b08531211e2",
            "filename": "packages/next/src/server/base-server.ts",
            "status": "modified",
            "additions": 48,
            "deletions": 19,
            "changes": 67,
            "blob_url": "https://github.com/vercel/next.js/blob/fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc/packages%2Fnext%2Fsrc%2Fserver%2Fbase-server.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc/packages%2Fnext%2Fsrc%2Fserver%2Fbase-server.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fbase-server.ts?ref=fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc",
            "patch": "@@ -3034,7 +3034,9 @@ export default abstract class Server<\n           fallbackResponse = await this.responseCache.get(\n             isProduction ? (locale ? `/${locale}${pathname}` : pathname) : null,\n             // This is the response generator for the fallback shell.\n-            ({ previousCacheEntry: previousFallbackCacheEntry = null }) => {\n+            async ({\n+              previousCacheEntry: previousFallbackCacheEntry = null,\n+            }) => {\n               // For the pages router, fallbacks cannot be revalidated or\n               // generated in production. In the case of a missing fallback,\n               // we return null, but if it's being revalidated, we just return\n@@ -3075,7 +3077,7 @@ export default abstract class Server<\n           fallbackResponse = await this.responseCache.get(\n             isProduction ? pathname : null,\n             // This is the response generator for the fallback shell.\n-            () =>\n+            async () =>\n               doRender({\n                 // We pass `undefined` as rendering a fallback isn't resumed\n                 // here.\n@@ -3105,7 +3107,7 @@ export default abstract class Server<\n         if (fallbackResponse) {\n           // Remove the cache control from the response to prevent it from being\n           // used in the surrounding cache.\n-          fallbackResponse.cacheControl = undefined\n+          delete fallbackResponse.cacheControl\n \n           return fallbackResponse\n         }\n@@ -3270,9 +3272,15 @@ export default abstract class Server<\n       cacheControl = { revalidate: 0, expire: undefined }\n     }\n \n-    // If this is a flight request that isn't a pre-fetch request while PPR is\n-    // enabled, it cannot be cached as it contains dynamic content.\n-    else if (isDynamicRSCRequest) {\n+    // If this is in minimal mode and this is a flight request that isn't a\n+    // prefetch request while PPR is enabled, it cannot be cached as it contains\n+    // dynamic content.\n+    else if (\n+      this.minimalMode &&\n+      isRSCRequest &&\n+      !isPrefetchRSCRequest &&\n+      isRoutePPREnabled\n+    ) {\n       cacheControl = { revalidate: 0, expire: undefined }\n     } else if (!this.renderOpts.dev || (hasServerProps && !isNextDataRequest)) {\n       // If this is a preview mode request, we shouldn't cache it\n@@ -3382,15 +3390,29 @@ export default abstract class Server<\n \n     // If there's a callback for `onCacheEntry`, call it with the cache entry\n     // and the revalidate options.\n-    const onCacheEntry =\n-      getRequestMeta(req, 'onCacheEntryV2') ??\n-      // TODO: Remove this once we've migrated to `onCacheEntryV2`\n-      getRequestMeta(req, 'onCacheEntry')\n+    const onCacheEntry = getRequestMeta(req, 'onCacheEntry')\n     if (onCacheEntry) {\n-      const finished = await onCacheEntry(cacheEntry, {\n-        url: getRequestMeta(req, 'initURL') ?? req.url,\n-      })\n-      if (finished) return null\n+      const finished = await onCacheEntry(\n+        {\n+          ...cacheEntry,\n+          // TODO: remove this when upstream doesn't\n+          // always expect this value to be \"PAGE\"\n+          value: {\n+            ...cacheEntry.value,\n+            kind:\n+              cacheEntry.value?.kind === CachedRouteKind.APP_PAGE\n+                ? 'PAGE'\n+                : cacheEntry.value?.kind,\n+          },\n+        },\n+        {\n+          url: getRequestMeta(req, 'initURL'),\n+        }\n+      )\n+      if (finished) {\n+        // TODO: maybe we have to end the request?\n+        return null\n+      }\n     }\n \n     if (!cachedData) {\n@@ -3506,7 +3528,7 @@ export default abstract class Server<\n       }\n \n       // Mark that the request did postpone.\n-      if (didPostpone && !isDynamicRSCRequest) {\n+      if (didPostpone) {\n         res.setHeader(NEXT_DID_POSTPONE_HEADER, '1')\n       }\n \n@@ -3524,7 +3546,14 @@ export default abstract class Server<\n           return {\n             type: 'rsc',\n             body: cachedData.html,\n-            cacheControl: cacheEntry.cacheControl,\n+            // Dynamic RSC responses cannot be cached, even if they're\n+            // configured with `force-static` because we have no way of\n+            // distinguishing between `force-static` and pages that have no\n+            // postponed state.\n+            // TODO: distinguish `force-static` from pages with no postponed state (static)\n+            cacheControl: isDynamicRSCRequest\n+              ? { revalidate: 0, expire: undefined }\n+              : cacheEntry.cacheControl,\n           }\n         }\n \n@@ -3592,12 +3621,12 @@ export default abstract class Server<\n       })\n         .then(async (result) => {\n           if (!result) {\n-            throw new InvariantError('expected a result to be returned')\n+            throw new Error('Invariant: expected a result to be returned')\n           }\n \n           if (result.value?.kind !== CachedRouteKind.APP_PAGE) {\n-            throw new InvariantError(\n-              `expected a page response, got ${result.value?.kind}`\n+            throw new Error(\n+              `Invariant: expected a page response, got ${result.value?.kind}`\n             )\n           }\n "
        },
        {
            "sha": "51bd58dabbf4cb95b9c9bb5d9fbc315f62390c31",
            "filename": "packages/next/src/server/lib/incremental-cache/file-system-cache.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 28,
            "changes": 37,
            "blob_url": "https://github.com/vercel/next.js/blob/fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fincremental-cache%2Ffile-system-cache.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fincremental-cache%2Ffile-system-cache.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fincremental-cache%2Ffile-system-cache.ts?ref=fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc",
            "patch": "@@ -276,16 +276,6 @@ export default class FileSystemCache implements CacheHandler {\n       }\n     }\n \n-    // If enabled, this will return the possibly stale data without validating\n-    // that the tags have expired or not yet been revalidated.\n-    if ('allowStale' in ctx && ctx.allowStale) {\n-      if (FileSystemCache.debug) {\n-        console.log('allow stale', ctx.allowStale)\n-      }\n-\n-      return data ?? null\n-    }\n-\n     if (\n       data?.value?.kind === CachedRouteKind.APP_PAGE ||\n       data?.value?.kind === CachedRouteKind.PAGES\n@@ -302,10 +292,6 @@ export default class FileSystemCache implements CacheHandler {\n         // had a tag revalidated, if we want to be a background\n         // revalidation instead we return data.lastModified = -1\n         if (isStale(cacheTags, data?.lastModified || Date.now())) {\n-          if (FileSystemCache.debug) {\n-            console.log('stale tags', cacheTags)\n-          }\n-\n           return null\n         }\n       }\n@@ -315,22 +301,17 @@ export default class FileSystemCache implements CacheHandler {\n           ? [...(ctx.tags || []), ...(ctx.softTags || [])]\n           : []\n \n-      // When revalidate tag is called we don't return stale data so it's\n-      // updated right away.\n-      if (combinedTags.some((tag) => this.revalidatedTags.includes(tag))) {\n-        if (FileSystemCache.debug) {\n-          console.log('was revalidated', combinedTags)\n-        }\n-\n-        return null\n-      }\n-\n-      if (isStale(combinedTags, data?.lastModified || Date.now())) {\n-        if (FileSystemCache.debug) {\n-          console.log('stale tags', combinedTags)\n+      const wasRevalidated = combinedTags.some((tag) => {\n+        if (this.revalidatedTags.includes(tag)) {\n+          return true\n         }\n \n-        return null\n+        return isStale([tag], data?.lastModified || Date.now())\n+      })\n+      // When revalidate tag is called we don't return\n+      // stale data so it's updated right away\n+      if (wasRevalidated) {\n+        data = undefined\n       }\n     }\n "
        },
        {
            "sha": "2794b4c0bf19e72569d30f9ab0c5e59c293b6186",
            "filename": "packages/next/src/server/lib/incremental-cache/index.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 37,
            "changes": 40,
            "blob_url": "https://github.com/vercel/next.js/blob/fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fincremental-cache%2Findex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fincremental-cache%2Findex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fincremental-cache%2Findex.ts?ref=fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc",
            "patch": "@@ -15,6 +15,7 @@ import {\n   type SetIncrementalResponseCacheContext,\n } from '../../response-cache'\n import type { DeepReadonly } from '../../../shared/lib/deep-readonly'\n+\n import FileSystemCache from './file-system-cache'\n import { normalizePagePath } from '../../../shared/lib/page-path/normalize-page-path'\n \n@@ -88,8 +89,8 @@ export class IncrementalCache implements IncrementalCacheType {\n   readonly allowedRevalidateHeaderKeys?: string[]\n   readonly minimalMode?: boolean\n   readonly fetchCacheKeyPrefix?: string\n+  readonly revalidatedTags?: string[]\n   readonly isOnDemandRevalidate?: boolean\n-  readonly revalidatedTags?: readonly string[]\n \n   private static readonly debug: boolean =\n     !!process.env.NEXT_PRIVATE_DEBUG_CACHE\n@@ -178,7 +179,7 @@ export class IncrementalCache implements IncrementalCacheType {\n     }\n \n     if (minimalMode) {\n-      revalidatedTags = this.revalidatedTags = getPreviouslyRevalidatedTags(\n+      revalidatedTags = getPreviouslyRevalidatedTags(\n         requestHeaders,\n         this.prerenderManifest?.preview?.previewModeId\n       )\n@@ -425,13 +426,7 @@ export class IncrementalCache implements IncrementalCacheType {\n       if (resumeDataCache) {\n         const memoryCacheData = resumeDataCache.fetch.get(cacheKey)\n         if (memoryCacheData?.kind === CachedRouteKind.FETCH) {\n-          if (IncrementalCache.debug) {\n-            console.log('rdc:hit', cacheKey)\n-          }\n-\n           return { isStale: false, value: memoryCacheData }\n-        } else if (IncrementalCache.debug) {\n-          console.log('rdc:miss', cacheKey)\n         }\n       }\n     }\n@@ -475,34 +470,9 @@ export class IncrementalCache implements IncrementalCacheType {\n             workStore?.pendingRevalidatedTags?.includes(tag)\n         )\n       ) {\n-        if (IncrementalCache.debug) {\n-          console.log('stale tag', cacheKey)\n-        }\n-\n         return null\n       }\n \n-      // As we're able to get the cache entry for this fetch, and the prerender\n-      // resume data cache (RDC) is available, it must have been populated by a\n-      // previous fetch, but was not yet present in the in-memory cache. This\n-      // could be the case when performing multiple renders in parallel during\n-      // build time where we de-duplicate the fetch calls.\n-      //\n-      // We add it to the RDC so that the next fetch call will be able to use it\n-      // and it won't have to reach into the fetch cache implementation.\n-      const workUnitStore = workUnitAsyncStorage.getStore()\n-      if (workUnitStore) {\n-        const prerenderResumeDataCache =\n-          getPrerenderResumeDataCache(workUnitStore)\n-        if (prerenderResumeDataCache) {\n-          if (IncrementalCache.debug) {\n-            console.log('rdc:set', cacheKey)\n-          }\n-\n-          prerenderResumeDataCache.fetch.set(cacheKey, cacheData.value)\n-        }\n-      }\n-\n       const revalidate = ctx.revalidate || cacheData.value.revalidate\n       const age =\n         (performance.timeOrigin +\n@@ -601,10 +571,6 @@ export class IncrementalCache implements IncrementalCacheType {\n         ? getPrerenderResumeDataCache(workUnitStore)\n         : null\n       if (prerenderResumeDataCache) {\n-        if (IncrementalCache.debug) {\n-          console.log('rdc:set', pathname)\n-        }\n-\n         prerenderResumeDataCache.fetch.set(pathname, data)\n       }\n     }"
        },
        {
            "sha": "28a8b3be8a992eae0e9607cfc6d29e8b83f60ce8",
            "filename": "packages/next/src/server/request-meta.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 23,
            "changes": 27,
            "blob_url": "https://github.com/vercel/next.js/blob/fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc/packages%2Fnext%2Fsrc%2Fserver%2Frequest-meta.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc/packages%2Fnext%2Fsrc%2Fserver%2Frequest-meta.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest-meta.ts?ref=fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc",
            "patch": "@@ -6,12 +6,8 @@ import type { BaseNextRequest } from './base-http'\n import type { CloneableBody } from './body-streams'\n import type { RouteMatch } from './route-matches/route-match'\n import type { NEXT_RSC_UNION_QUERY } from '../client/components/app-router-headers'\n-import type {\n-  ResponseCacheEntry,\n-  ServerComponentsHmrCache,\n-} from './response-cache'\n+import type { ServerComponentsHmrCache } from './response-cache'\n import type { PagesDevOverlayBridgeType } from '../next-devtools/userspace/pages/pages-dev-overlay-setup'\n-import type { IncrementalCache } from './lib/incremental-cache'\n \n // FIXME: (wyattjoh) this is a temporary solution to allow us to pass data between bundled modules\n export const NEXT_REQUEST_META = Symbol.for('NextInternalRequestMeta')\n@@ -72,7 +68,7 @@ export interface RequestMeta {\n   /**\n    * The incremental cache to use for the request.\n    */\n-  incrementalCache?: IncrementalCache\n+  incrementalCache?: any\n \n   /**\n    * The server components HMR cache, only for dev.\n@@ -122,25 +118,10 @@ export interface RequestMeta {\n   /**\n    * If provided, this will be called when a response cache entry was generated\n    * or looked up in the cache.\n-   *\n-   * @deprecated Use `onCacheEntryV2` instead.\n    */\n   onCacheEntry?: (\n-    cacheEntry: ResponseCacheEntry,\n-    requestMeta: {\n-      url: string | undefined\n-    }\n-  ) => Promise<boolean | void> | boolean | void\n-\n-  /**\n-   * If provided, this will be called when a response cache entry was generated\n-   * or looked up in the cache.\n-   */\n-  onCacheEntryV2?: (\n-    cacheEntry: ResponseCacheEntry,\n-    requestMeta: {\n-      url: string | undefined\n-    }\n+    cacheEntry: any,\n+    requestMeta: any\n   ) => Promise<boolean | void> | boolean | void\n \n   /**"
        },
        {
            "sha": "04b9daa8535e19dc569c5f05a7627abcca7df988",
            "filename": "packages/next/src/server/response-cache/types.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 5,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc/packages%2Fnext%2Fsrc%2Fserver%2Fresponse-cache%2Ftypes.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc/packages%2Fnext%2Fsrc%2Fserver%2Fresponse-cache%2Ftypes.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fresponse-cache%2Ftypes.ts?ref=fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc",
            "patch": "@@ -219,11 +219,6 @@ export interface GetIncrementalResponseCacheContext {\n    * True if this is a fallback request.\n    */\n   isFallback: boolean\n-\n-  /**\n-   * True if stale data is allowed to be returned.\n-   */\n-  allowStale?: boolean\n }\n \n export interface SetIncrementalFetchCacheContext {"
        },
        {
            "sha": "137b025028f78b36221b2ae547e425957bfe1d07",
            "filename": "test/integration/custom-routes/test/index.test.js",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc/test%2Fintegration%2Fcustom-routes%2Ftest%2Findex.test.js",
            "raw_url": "https://github.com/vercel/next.js/raw/fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc/test%2Fintegration%2Fcustom-routes%2Ftest%2Findex.test.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fintegration%2Fcustom-routes%2Ftest%2Findex.test.js?ref=fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc",
            "patch": "@@ -2570,7 +2570,6 @@ const runTests = (isDev = false) => {\n           prefetchSegmentSuffix: '.segment.rsc',\n           prefetchSuffix: '.prefetch.rsc',\n           suffix: '.rsc',\n-          dynamicRSCPrerender: !!process.env.__NEXT_EXPERIMENTAL_PPR,\n         },\n       })\n     })"
        },
        {
            "sha": "b6be113ce580c1e9e43c751246ae3b33dee222ed",
            "filename": "test/integration/dynamic-routing/test/index.test.js",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc/test%2Fintegration%2Fdynamic-routing%2Ftest%2Findex.test.js",
            "raw_url": "https://github.com/vercel/next.js/raw/fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc/test%2Fintegration%2Fdynamic-routing%2Ftest%2Findex.test.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fintegration%2Fdynamic-routing%2Ftest%2Findex.test.js?ref=fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc",
            "patch": "@@ -1529,7 +1529,6 @@ function runTests({ dev }) {\n           prefetchSegmentSuffix: '.segment.rsc',\n           prefetchSuffix: '.prefetch.rsc',\n           suffix: '.rsc',\n-          dynamicRSCPrerender: !!process.env.__NEXT_EXPERIMENTAL_PPR,\n         },\n       })\n     })"
        },
        {
            "sha": "32d34ee70e6089e11a5a03cedcd56e124afa2ee0",
            "filename": "test/ppr-tests-manifest.json",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc/test%2Fppr-tests-manifest.json",
            "raw_url": "https://github.com/vercel/next.js/raw/fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc/test%2Fppr-tests-manifest.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fppr-tests-manifest.json?ref=fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc",
            "patch": "@@ -174,8 +174,7 @@\n       \"test/e2e/app-dir/use-cache-route-handler-only/**/*\",\n       \"test/integration/app-dir-export/**/*\",\n       \"test/production/app-dir/build-output-tree-view/build-output-tree-view.test.ts\",\n-      \"test/production/app-dir/global-default-cache-handler/global-default-cache-handler.test.ts\",\n-      \"test/production/app-dir/resume-data-cache/resume-data-cache.test.ts\"\n+      \"test/production/app-dir/global-default-cache-handler/global-default-cache-handler.test.ts\"\n     ]\n   }\n }"
        },
        {
            "sha": "9dfde1627512b37a73ed3912c0b31e351276e718",
            "filename": "test/production/app-dir/resume-data-cache/app/layout.tsx",
            "status": "removed",
            "additions": 0,
            "deletions": 9,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/036b95767621d12227a7635de1f289db189db15d/test%2Fproduction%2Fapp-dir%2Fresume-data-cache%2Fapp%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/036b95767621d12227a7635de1f289db189db15d/test%2Fproduction%2Fapp-dir%2Fresume-data-cache%2Fapp%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fapp-dir%2Fresume-data-cache%2Fapp%2Flayout.tsx?ref=036b95767621d12227a7635de1f289db189db15d",
            "patch": "@@ -1,9 +0,0 @@\n-import React, { ReactNode } from 'react'\n-\n-export default function Root({ children }: { children: ReactNode }) {\n-  return (\n-    <html>\n-      <body>{children}</body>\n-    </html>\n-  )\n-}"
        },
        {
            "sha": "a42bd6f524a3954725b84d2eb7b3480bd49ced27",
            "filename": "test/production/app-dir/resume-data-cache/app/page.tsx",
            "status": "removed",
            "additions": 0,
            "deletions": 32,
            "changes": 32,
            "blob_url": "https://github.com/vercel/next.js/blob/036b95767621d12227a7635de1f289db189db15d/test%2Fproduction%2Fapp-dir%2Fresume-data-cache%2Fapp%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/036b95767621d12227a7635de1f289db189db15d/test%2Fproduction%2Fapp-dir%2Fresume-data-cache%2Fapp%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fapp-dir%2Fresume-data-cache%2Fapp%2Fpage.tsx?ref=036b95767621d12227a7635de1f289db189db15d",
            "patch": "@@ -1,32 +0,0 @@\n-import React, { Suspense } from 'react'\n-import { connection } from 'next/server'\n-\n-import { unstable_cacheTag } from 'next/cache'\n-\n-async function getRandomNumber() {\n-  'use cache'\n-  unstable_cacheTag('test')\n-  return Math.random()\n-}\n-\n-async function DynamicComponent() {\n-  await connection()\n-  return null\n-}\n-\n-export default async function Page() {\n-  const randomNumber = await getRandomNumber()\n-  const anotherRandomNumber = await fetch(\n-    'https://next-data-api-endpoint.vercel.app/api/random',\n-    { cache: 'force-cache', next: { tags: ['test'] } }\n-  ).then((res) => res.text())\n-  return (\n-    <>\n-      <p id=\"random-number\">{randomNumber}</p>\n-      <p id=\"another-random-number\">{anotherRandomNumber}</p>\n-      <Suspense>\n-        <DynamicComponent />\n-      </Suspense>\n-    </>\n-  )\n-}"
        },
        {
            "sha": "4100bb53cdd06963db1274e8de7906a848adf954",
            "filename": "test/production/app-dir/resume-data-cache/app/revalidate/route.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 6,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/036b95767621d12227a7635de1f289db189db15d/test%2Fproduction%2Fapp-dir%2Fresume-data-cache%2Fapp%2Frevalidate%2Froute.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/036b95767621d12227a7635de1f289db189db15d/test%2Fproduction%2Fapp-dir%2Fresume-data-cache%2Fapp%2Frevalidate%2Froute.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fapp-dir%2Fresume-data-cache%2Fapp%2Frevalidate%2Froute.ts?ref=036b95767621d12227a7635de1f289db189db15d",
            "patch": "@@ -1,6 +0,0 @@\n-import { revalidateTag } from 'next/cache'\n-\n-export function POST() {\n-  revalidateTag('test')\n-  return new Response(null, { status: 200 })\n-}"
        },
        {
            "sha": "bea0706290af6bfcb4d7dfbd29c8f6acfbc78477",
            "filename": "test/production/app-dir/resume-data-cache/next.config.js",
            "status": "removed",
            "additions": 0,
            "deletions": 11,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/036b95767621d12227a7635de1f289db189db15d/test%2Fproduction%2Fapp-dir%2Fresume-data-cache%2Fnext.config.js",
            "raw_url": "https://github.com/vercel/next.js/raw/036b95767621d12227a7635de1f289db189db15d/test%2Fproduction%2Fapp-dir%2Fresume-data-cache%2Fnext.config.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fapp-dir%2Fresume-data-cache%2Fnext.config.js?ref=036b95767621d12227a7635de1f289db189db15d",
            "patch": "@@ -1,11 +0,0 @@\n-/**\n- * @type {import('next').NextConfig}\n- */\n-const nextConfig = {\n-  experimental: {\n-    ppr: true,\n-    useCache: true,\n-  },\n-}\n-\n-module.exports = nextConfig"
        },
        {
            "sha": "b7c3a0ec7f71e7e03c7d5165169204530edf3142",
            "filename": "test/production/app-dir/resume-data-cache/resume-data-cache.test.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 109,
            "changes": 109,
            "blob_url": "https://github.com/vercel/next.js/blob/036b95767621d12227a7635de1f289db189db15d/test%2Fproduction%2Fapp-dir%2Fresume-data-cache%2Fresume-data-cache.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/036b95767621d12227a7635de1f289db189db15d/test%2Fproduction%2Fapp-dir%2Fresume-data-cache%2Fresume-data-cache.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fapp-dir%2Fresume-data-cache%2Fresume-data-cache.test.ts?ref=036b95767621d12227a7635de1f289db189db15d",
            "patch": "@@ -1,109 +0,0 @@\n-import { nextTestSetup } from 'e2e-utils'\n-import { retry } from 'next-test-utils'\n-\n-describe('resume-data-cache', () => {\n-  const { next, skipped } = nextTestSetup({\n-    files: __dirname,\n-    // TODO: re-enable once support has been added\n-    skipDeployment: true,\n-  })\n-  if (skipped) return\n-\n-  it.each([\n-    { name: 'use cache', id: 'random-number' },\n-    { name: 'fetch cache', id: 'another-random-number' },\n-  ])(\n-    'should have consistent data between static and dynamic renders with $name',\n-    async ({ id }) => {\n-      // First render the page statically, getting the random number from the\n-      // HTML.\n-      let $ = await next.render$('/')\n-      const first = $(`p#${id}`).text()\n-\n-      // Then get the Prefetch RSC and validate that it also contains the same\n-      // random number.\n-      let rsc\n-\n-      await retry(async () => {\n-        rsc = await next\n-          .fetch('/', {\n-            headers: {\n-              RSC: '1',\n-              'Next-Router-Prefetch': '1',\n-            },\n-          })\n-          .then((res) => res.text())\n-        expect(rsc).toContain(first)\n-      })\n-\n-      // Then get the dynamic RSC and validate that it also contains the same\n-      // random number.\n-      await retry(async () => {\n-        rsc = await next\n-          .fetch('/', {\n-            headers: {\n-              RSC: '1',\n-            },\n-          })\n-          .then((res) => res.text())\n-        expect(rsc).toContain(first)\n-      })\n-\n-      // Then revalidate the page\n-      await next.fetch('/revalidate', { method: 'POST' })\n-\n-      // Then get the dynamic RSC again and validate that it still contains the\n-      // same random number.\n-      await retry(async () => {\n-        rsc = await next\n-          .fetch('/', {\n-            headers: {\n-              RSC: '1',\n-            },\n-          })\n-          .then((res) => res.text())\n-        expect(rsc).toContain(first)\n-      })\n-\n-      // This proves that the dynamic RSC was able to use the resume data cache\n-      // (RDC) from the static render to ensure that the data is consistent\n-      // between the static and dynamic renders. Let's now try to render the\n-      // page statically and see that the random number changes.\n-\n-      $ = await next.render$('/')\n-      const random2 = $(`p#${id}`).text()\n-      expect(random2).not.toBe(first)\n-\n-      // Then get the Prefetch RSC and validate that it also contains the new\n-      // random number.\n-      await retry(async () => {\n-        rsc = await next\n-          .fetch('/', {\n-            headers: {\n-              RSC: '1',\n-              'Next-Router-Prefetch': '1',\n-            },\n-          })\n-          .then((res) => res.text())\n-        expect(rsc).toContain(random2)\n-      })\n-\n-      // Then get the dynamic RSC again and validate that it also contains the\n-      // new random number.\n-      await retry(async () => {\n-        rsc = await next\n-          .fetch('/', {\n-            headers: {\n-              RSC: '1',\n-            },\n-          })\n-          .then((res) => res.text())\n-        expect(rsc).toContain(random2)\n-      })\n-\n-      // This proves that the dynamic RSC was able to use the resume data cache\n-      // (RDC) from the static render to ensure that the data is consistent\n-      // between the static and dynamic renders.\n-    }\n-  )\n-})"
        },
        {
            "sha": "dc35c2f7d7d9147579b0b2a5ba9eef70023df94e",
            "filename": "test/production/standalone-mode/required-server-files/app/dyn/[slug]/page.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc/test%2Fproduction%2Fstandalone-mode%2Frequired-server-files%2Fapp%2Fdyn%2F%5Bslug%5D%2Fpage.js",
            "raw_url": "https://github.com/vercel/next.js/raw/fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc/test%2Fproduction%2Fstandalone-mode%2Frequired-server-files%2Fapp%2Fdyn%2F%5Bslug%5D%2Fpage.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fstandalone-mode%2Frequired-server-files%2Fapp%2Fdyn%2F%5Bslug%5D%2Fpage.js?ref=fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc",
            "patch": "@@ -1,7 +1,7 @@\n import { headers } from 'next/headers'\n \n export default async function Page({ params }) {\n-  const data = await headers()\n+  const data = headers()\n \n   return (\n     <>"
        },
        {
            "sha": "8267d9a68933f16051e198d54d2b2ae2b574806b",
            "filename": "test/production/standalone-mode/required-server-files/app/rewrite/[slug]/page.js",
            "status": "modified",
            "additions": 3,
            "deletions": 9,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc/test%2Fproduction%2Fstandalone-mode%2Frequired-server-files%2Fapp%2Frewrite%2F%5Bslug%5D%2Fpage.js",
            "raw_url": "https://github.com/vercel/next.js/raw/fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc/test%2Fproduction%2Fstandalone-mode%2Frequired-server-files%2Fapp%2Frewrite%2F%5Bslug%5D%2Fpage.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fstandalone-mode%2Frequired-server-files%2Fapp%2Frewrite%2F%5Bslug%5D%2Fpage.js?ref=fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc",
            "patch": "@@ -1,24 +1,18 @@\n import { Suspense } from 'react'\n-import { connection } from 'next/server'\n+import { unstable_noStore } from 'next/cache'\n \n export function generateStaticParams() {\n   return [{ slug: 'first-cookie' }]\n }\n \n-async function Postpone({ children }) {\n-  await connection()\n+function Postpone({ children }) {\n+  unstable_noStore()\n   return children\n }\n \n export default async function Page({ params }) {\n-  const random = await fetch(\n-    'https://next-data-api-endpoint.vercel.app/api/random',\n-    { cache: 'force-cache' }\n-  ).then((res) => res.text())\n-\n   return (\n     <>\n-      <p id=\"random\">{random}</p>\n       <Suspense>\n         <Postpone>\n           <p id=\"page\">/rewrite/[slug]</p>"
        },
        {
            "sha": "07f6636fdd73c575bb037cafefb47b3efb70e78e",
            "filename": "test/production/standalone-mode/required-server-files/required-server-files-ppr.test.ts",
            "status": "modified",
            "additions": 72,
            "deletions": 140,
            "changes": 212,
            "blob_url": "https://github.com/vercel/next.js/blob/fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc/test%2Fproduction%2Fstandalone-mode%2Frequired-server-files%2Frequired-server-files-ppr.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc/test%2Fproduction%2Fstandalone-mode%2Frequired-server-files%2Frequired-server-files-ppr.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fstandalone-mode%2Frequired-server-files%2Frequired-server-files-ppr.test.ts?ref=fbdec18a8031c5a71f0fa3f7fbcfd65ec8f6bbfc",
            "patch": "@@ -1,5 +1,6 @@\n-import fs from 'node:fs/promises'\n-import { join } from 'node:path'\n+import glob from 'glob'\n+import fs from 'fs-extra'\n+import { join } from 'path'\n import cheerio from 'cheerio'\n import { createNext, FileRef } from 'e2e-utils'\n import { NextInstance } from 'e2e-utils'\n@@ -10,22 +11,27 @@ import {\n   initNextServerScript,\n   killApp,\n } from 'next-test-utils'\n-import { ChildProcess } from 'node:child_process'\n+import { ChildProcess } from 'child_process'\n \n describe('required server files app router', () => {\n   let next: NextInstance\n   let server: ChildProcess\n   let appPort: number | string\n-  let delayedPostpone: string\n-  let rewritePostpone: string\n-  let rewriteHTML: string\n+  let delayedPostpone\n+  let rewritePostpone\n   let cliOutput = ''\n \n-  beforeAll(async () => {\n-    process.env.NOW_BUILDER = '1'\n+  const setupNext = async ({\n+    nextEnv,\n+    minimalMode,\n+  }: {\n+    nextEnv?: boolean\n+    minimalMode?: boolean\n+  }) => {\n+    // test build against environment with next support\n+    process.env.NOW_BUILDER = nextEnv ? '1' : ''\n     process.env.NEXT_PRIVATE_TEST_HEADERS = '1'\n \n-    // Setup the Next.js app and build it.\n     next = await createNext({\n       files: {\n         app: new FileRef(join(__dirname, 'app')),\n@@ -41,57 +47,57 @@ describe('required server files app router', () => {\n         cacheHandler: './cache-handler.js',\n         experimental: {\n           ppr: true,\n-          clientSegmentCache: true,\n         },\n         eslint: {\n           ignoreDuringBuilds: true,\n         },\n         output: 'standalone',\n       },\n     })\n-\n-    // Stop the server, we're going to restart it using the standalone server\n-    // below after some cleanup.\n     await next.stop()\n \n-    // Read the postponed state and the HTML that was generated at build time\n-    // from the output of the build.\n     delayedPostpone = (await next.readJSON('.next/server/app/delayed.meta'))\n       .postponed\n     rewritePostpone = (\n       await next.readJSON('.next/server/app/rewrite/first-cookie.meta')\n     ).postponed\n-    rewriteHTML = await next.readFile(\n-      '.next/server/app/rewrite/first-cookie.html'\n-    )\n \n-    await fs.rename(\n+    await fs.move(\n       join(next.testDir, '.next/standalone'),\n       join(next.testDir, 'standalone')\n     )\n+    for (const file of await fs.readdir(next.testDir)) {\n+      if (file !== 'standalone') {\n+        await fs.remove(join(next.testDir, file))\n+        console.log('removed', file)\n+      }\n+    }\n+    const files = glob.sync('**/*', {\n+      cwd: join(next.testDir, 'standalone/.next/server/pages'),\n+      dot: true,\n+    })\n \n-    const serverFilePath = join(next.testDir, 'standalone/server.js')\n+    for (const file of files) {\n+      if (file.endsWith('.json') || file.endsWith('.html')) {\n+        await fs.remove(join(next.testDir, '.next/server', file))\n+      }\n+    }\n \n-    // We're going to use the minimal mode for the server.\n+    const testServer = join(next.testDir, 'standalone/server.js')\n     await fs.writeFile(\n-      serverFilePath,\n-      (await fs.readFile(serverFilePath, 'utf8')).replace(\n+      testServer,\n+      (await fs.readFile(testServer, 'utf8')).replace(\n         'port:',\n-        `minimalMode: true, port:`\n+        `minimalMode: ${minimalMode},port:`\n       )\n     )\n-\n-    // Find a port to use for the server.\n     appPort = await findPort()\n-\n-    // Then we can start the server with the new environment variables.\n     server = await initNextServerScript(\n-      serverFilePath,\n+      testServer,\n       /- Local:/,\n       {\n         ...process.env,\n         PORT: `${appPort}`,\n-        NEXT_PRIVATE_DEBUG_CACHE: '1',\n       },\n       undefined,\n       {\n@@ -104,8 +110,11 @@ describe('required server files app router', () => {\n         },\n       }\n     )\n-  })\n+  }\n \n+  beforeAll(async () => {\n+    await setupNext({ nextEnv: true, minimalMode: true })\n+  })\n   afterAll(async () => {\n     delete process.env.NEXT_PRIVATE_TEST_HEADERS\n     await next.destroy()\n@@ -116,35 +125,37 @@ describe('required server files app router', () => {\n     expect(next.cliOutput).not.toContain('ERR_INVALID_URL')\n   })\n \n-  it('should de-dupe client segment tree revalidate requests', async () => {\n-    const { segmentPaths } = await next.readJSON(\n-      'standalone/.next/server/app/isr/first.meta'\n-    )\n-    const outputIdx = cliOutput.length\n+  // this enables client segment cache in CI\n+  if (process.env.__NEXT_EXPERIMENTAL_PPR) {\n+    it('should de-dupe client segment tree revalidate requests', async () => {\n+      const { segmentPaths } = await next.readJSON(\n+        'standalone/.next/server/app/isr/first.meta'\n+      )\n+      const outputIdx = cliOutput.length\n \n-    for (const segmentPath of segmentPaths) {\n-      const outputSegmentPath =\n-        join('/isr/[slug].segments', segmentPath) + '.segment.rsc'\n+      for (const segmentPath of segmentPaths) {\n+        const outputSegmentPath =\n+          join('/isr/[slug].segments', segmentPath) + '.segment.rsc'\n \n-      require('console').error('requesting', outputSegmentPath)\n+        require('console').error('requesting', outputSegmentPath)\n \n-      const res = await fetchViaHTTP(appPort, outputSegmentPath, undefined, {\n-        headers: {\n-          'x-matched-path': '/isr/[slug].segments/_tree.segment.rsc',\n-          'x-now-route-matches': createNowRouteMatches({\n-            slug: 'first',\n-          }).toString(),\n-        },\n-      })\n+        const res = await fetchViaHTTP(appPort, outputSegmentPath, undefined, {\n+          headers: {\n+            'x-matched-path': '/isr/[slug].segments/_tree.segment.rsc',\n+            'x-now-route-matches': 'slug=first&1=first',\n+          },\n+        })\n \n-      expect(res.status).toBe(200)\n-      expect(res.headers.get('content-type')).toBe('text/x-component')\n-    }\n+        expect(res.status).toBe(200)\n+        expect(res.headers.get('content-type')).toBe('text/x-component')\n+      }\n \n-    expect(\n-      cliOutput.substring(outputIdx).match(/rendering \\/isr\\/\\[slug\\]/g).length\n-    ).toBe(1)\n-  })\n+      expect(\n+        cliOutput.substring(outputIdx).match(/rendering \\/isr\\/\\[slug\\]/g)\n+          .length\n+      ).toBe(1)\n+    })\n+  }\n \n   it('should properly stream resume with Next-Resume', async () => {\n     const res = await fetchViaHTTP(appPort, '/delayed', undefined, {\n@@ -170,6 +181,11 @@ describe('required server files app router', () => {\n     const firstSuspense = chunks.find((item) => item.chunk.includes('time'))\n     const secondSuspense = chunks.find((item) => item.chunk.includes('random'))\n \n+    console.log({\n+      firstSuspense,\n+      secondSuspense,\n+    })\n+\n     expect(secondSuspense.time - firstSuspense.time).toBeGreaterThanOrEqual(\n       2 * 1000\n     )\n@@ -347,15 +363,12 @@ describe('required server files app router', () => {\n     const res = await fetchViaHTTP(appPort, '/dyn/first.rsc', undefined, {\n       headers: {\n         'x-matched-path': '/dyn/[slug]',\n-        'x-now-route-matches': createNowRouteMatches({\n-          slug: 'first',\n-        }).toString(),\n       },\n     })\n \n     expect(res.status).toBe(200)\n     expect(res.headers.get('content-type')).toEqual('text/x-component')\n-    expect(res.headers.has('x-nextjs-postponed')).toBeTrue()\n+    expect(res.headers.has('x-nextjs-postponed')).toBeFalse()\n   })\n \n   it('should handle prefetch RSC requests', async () => {\n@@ -366,9 +379,6 @@ describe('required server files app router', () => {\n       {\n         headers: {\n           'x-matched-path': '/dyn/[slug]',\n-          'x-now-route-matches': createNowRouteMatches({\n-            slug: 'first',\n-          }).toString(),\n         },\n       }\n     )\n@@ -378,84 +388,6 @@ describe('required server files app router', () => {\n     expect(res.headers.has('x-nextjs-postponed')).toBeTrue()\n   })\n \n-  it('should use the postponed state for the RSC requests', async () => {\n-    // Let's parse the random number out of the HTML that was generated at build\n-    // time. We want to use that value as it's the one that's tied to the\n-    // postponed state that we also have.\n-    const $ = cheerio.load(rewriteHTML)\n-\n-    const random = $('#random').text()\n-    expect(random).toBeDefined()\n-    expect(random.length).toBeGreaterThan(0)\n-\n-    // Record the start of the logs for this test.\n-    let start = cliOutput.length\n-\n-    // Then let's do a Dynamic RSC request and verify that the random value is\n-    // not present in the response without passing the postponed state.\n-    let res = await fetchViaHTTP(\n-      appPort,\n-      '/rewrite/first-cookie.rsc',\n-      undefined,\n-      {\n-        headers: {\n-          'x-matched-path': '/rewrite/[slug]',\n-          'x-now-route-matches': createNowRouteMatches({\n-            slug: 'first-cookie',\n-          }).toString(),\n-        },\n-      }\n-    )\n-\n-    expect(res.status).toBe(200)\n-    expect(res.headers.get('content-type')).toEqual('text/x-component')\n-    expect(res.headers.has('x-nextjs-postponed')).toBeTrue()\n-\n-    // Ensure that we hit the cache handler and not the resume data cache.\n-    expect(cliOutput.substring(start)).toContain('cache-handler get')\n-    expect(cliOutput.substring(start)).toContain('cache-handler set')\n-    expect(cliOutput.substring(start)).toContain('rdc:miss')\n-    expect(cliOutput.substring(start)).not.toContain('rdc:hit')\n-\n-    // We expect that the random value is not present in the response because\n-    // we're not providing a resume data cache via the postponed state.\n-    // Instead it'll contain another random number that's been generated at\n-    // runtime.\n-    let rsc = await res.text()\n-    expect(rsc).not.toContain(random)\n-\n-    // Reset the start of the logs for this test.\n-    start = cliOutput.length\n-\n-    // Then let's get the Dynamic RSC request and verify that the random value\n-    // is present in the response by passing the postponed state.\n-    res = await fetchViaHTTP(appPort, '/rewrite/first-cookie.rsc', undefined, {\n-      method: 'POST',\n-      headers: {\n-        'x-matched-path': '/rewrite/[slug]',\n-        'x-now-route-matches': createNowRouteMatches({\n-          slug: 'first-cookie',\n-        }).toString(),\n-        'next-resume': '1',\n-      },\n-      body: rewritePostpone,\n-    })\n-\n-    expect(res.status).toBe(200)\n-    expect(res.headers.get('content-type')).toEqual('text/x-component')\n-    expect(res.headers.has('x-nextjs-postponed')).toBeFalse()\n-\n-    // Ensure that we hit the resume data cache and not the cache handler.\n-    expect(cliOutput.substring(start)).not.toContain('cache-handler get')\n-    expect(cliOutput.substring(start)).not.toContain('cache-handler set')\n-    expect(cliOutput.substring(start)).toContain('rdc:hit')\n-\n-    // We expect that the random value is present in the response because\n-    // we're providing a resume data cache via the postponed state.\n-    rsc = await res.text()\n-    expect(rsc).toContain(random)\n-  })\n-\n   it('should handle revalidating the fallback page', async () => {\n     const res = await fetchViaHTTP(appPort, '/postpone/isr/[slug]', undefined, {\n       headers: {"
        }
    ],
    "stats": {
        "total": 718,
        "additions": 206,
        "deletions": 512
    }
}