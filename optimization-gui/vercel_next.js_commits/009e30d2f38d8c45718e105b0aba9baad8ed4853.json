{
    "author": "sokra",
    "message": "Turbopack: remove lazy invalidated tasks (#83845)\n\n### What?\n\nLazy invalidation is no longer used with the new backend",
    "sha": "009e30d2f38d8c45718e105b0aba9baad8ed4853",
    "files": [
        {
            "sha": "03c93d962bcd729806afb5bfd7e245bf144ca01b",
            "filename": "turbopack/crates/turbo-tasks-testing/src/lib.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 4,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/009e30d2f38d8c45718e105b0aba9baad8ed4853/turbopack%2Fcrates%2Fturbo-tasks-testing%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/009e30d2f38d8c45718e105b0aba9baad8ed4853/turbopack%2Fcrates%2Fturbo-tasks-testing%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-testing%2Fsrc%2Flib.rs?ref=009e30d2f38d8c45718e105b0aba9baad8ed4853",
            "patch": "@@ -157,10 +157,6 @@ impl TurboTasksApi for VcStorage {\n         // ignore\n     }\n \n-    fn notify_scheduled_tasks(&self) {\n-        // ignore\n-    }\n-\n     fn try_read_task_output(\n         &self,\n         id: TaskId,"
        },
        {
            "sha": "47a567bd0ebd3e47247d8dd11930c32e46045ee0",
            "filename": "turbopack/crates/turbo-tasks/src/macro_helpers.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/009e30d2f38d8c45718e105b0aba9baad8ed4853/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmacro_helpers.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/009e30d2f38d8c45718e105b0aba9baad8ed4853/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmacro_helpers.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmacro_helpers.rs?ref=009e30d2f38d8c45718e105b0aba9baad8ed4853",
            "patch": "@@ -14,7 +14,7 @@ use crate::{\n pub use crate::{\n     global_name, inventory_submit,\n     magic_any::MagicAny,\n-    manager::{find_cell_by_type, notify_scheduled_tasks, spawn_detached_for_testing},\n+    manager::{find_cell_by_type, spawn_detached_for_testing},\n     native_function::{\n         CollectableFunction, FunctionMeta, NativeFunction, downcast_args_owned, downcast_args_ref,\n     },"
        },
        {
            "sha": "6aaf08359f1e495464a21fd085cce67a6021ae15",
            "filename": "turbopack/crates/turbo-tasks/src/manager.rs",
            "status": "modified",
            "additions": 7,
            "deletions": 83,
            "changes": 90,
            "blob_url": "https://github.com/vercel/next.js/blob/009e30d2f38d8c45718e105b0aba9baad8ed4853/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/009e30d2f38d8c45718e105b0aba9baad8ed4853/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs?ref=009e30d2f38d8c45718e105b0aba9baad8ed4853",
            "patch": "@@ -15,15 +15,14 @@ use anyhow::{Result, anyhow};\n use auto_hash_map::AutoMap;\n use rustc_hash::FxHasher;\n use serde::{Deserialize, Serialize};\n-use smallvec::SmallVec;\n use tokio::{select, sync::mpsc::Receiver, task_local};\n use tokio_util::task::TaskTracker;\n-use tracing::{Instrument, Level, instrument, trace_span};\n+use tracing::{Instrument, Level, instrument};\n \n use crate::{\n     Completion, InvalidationReason, InvalidationReasonSet, OutputContent, ReadCellOptions,\n-    ResolvedVc, SharedReference, TaskId, TaskIdSet, TraitMethod, ValueTypeId, Vc, VcRead,\n-    VcValueTrait, VcValueType,\n+    ResolvedVc, SharedReference, TaskId, TraitMethod, ValueTypeId, Vc, VcRead, VcValueTrait,\n+    VcValueType,\n     backend::{\n         Backend, CachedTaskType, CellContent, TaskCollectiblesMap, TaskExecutionSpec,\n         TransientTaskType, TurboTasksExecutionError, TypedCellContent,\n@@ -102,10 +101,6 @@ pub trait TurboTasksApi: TurboTasksCallApi + Sync + Send {\n \n     fn invalidate_serialization(&self, task: TaskId);\n \n-    /// Eagerly notifies all tasks that were scheduled for notifications via\n-    /// `schedule_notify_tasks_set()`\n-    fn notify_scheduled_tasks(&self);\n-\n     fn try_read_task_output(\n         &self,\n         task: TaskId,\n@@ -264,14 +259,6 @@ pub trait TurboTasksBackendApi<B: Backend + 'static>: TurboTasksCallApi + Sync +\n     /// idle even with active background jobs.\n     fn schedule_backend_background_job(&self, job: B::BackendJob);\n \n-    /// Enqueues tasks for notification of changed dependencies. This will\n-    /// eventually call `invalidate_tasks()` on all tasks.\n-    fn schedule_notify_tasks(&self, tasks: &[TaskId]);\n-\n-    /// Enqueues tasks for notification of changed dependencies. This will\n-    /// eventually call `invalidate_tasks()` on all tasks.\n-    fn schedule_notify_tasks_set(&self, tasks: &TaskIdSet);\n-\n     /// Returns the duration from the start of the program to the given instant.\n     fn program_duration_until(&self, instant: Instant) -> Duration;\n \n@@ -403,11 +390,6 @@ struct CurrentTaskState {\n     task_id: TaskId,\n     execution_id: ExecutionId,\n \n-    /// Affected tasks, that are tracked during task execution. These tasks will\n-    /// be invalidated when the execution finishes or before reading a cell\n-    /// value.\n-    tasks_to_notify: SmallVec<[TaskId; 4]>,\n-\n     /// True if the current task has state in cells\n     stateful: bool,\n \n@@ -439,7 +421,6 @@ impl CurrentTaskState {\n         Self {\n             task_id,\n             execution_id,\n-            tasks_to_notify: SmallVec::new(),\n             stateful: false,\n             has_invalidator: false,\n             cell_counters: Some(AutoMap::default()),\n@@ -749,18 +730,15 @@ impl<B: Backend + 'static> TurboTasks<B> {\n                         } = this.finish_current_task_state();\n                         let cell_counters = CURRENT_TASK_STATE\n                             .with(|ts| ts.write().unwrap().cell_counters.take().unwrap());\n-                        let schedule_again = this.backend.task_execution_completed(\n+                        this.backend.task_execution_completed(\n                             task_id,\n                             duration,\n                             alloc_info.memory_usage(),\n                             &cell_counters,\n                             stateful,\n                             has_invalidator,\n                             &*this,\n-                        );\n-                        // task_execution_completed might need to notify tasks\n-                        this.notify_scheduled_tasks();\n-                        schedule_again\n+                        )\n                     }\n                     .instrument(span)\n                     .await\n@@ -1123,19 +1101,15 @@ impl<B: Backend + 'static> TurboTasks<B> {\n     }\n \n     fn finish_current_task_state(&self) -> FinishedTaskState {\n-        let (stateful, has_invalidator, tasks) = CURRENT_TASK_STATE.with(|cell| {\n+        let (stateful, has_invalidator) = CURRENT_TASK_STATE.with(|cell| {\n             let CurrentTaskState {\n-                tasks_to_notify,\n                 stateful,\n                 has_invalidator,\n                 ..\n             } = &mut *cell.write().unwrap();\n-            (*stateful, *has_invalidator, take(tasks_to_notify))\n+            (*stateful, *has_invalidator)\n         });\n \n-        if !tasks.is_empty() {\n-            self.backend.invalidate_tasks(&tasks, self);\n-        }\n         FinishedTaskState {\n             stateful,\n             has_invalidator,\n@@ -1245,21 +1219,6 @@ impl<B: Backend + 'static> TurboTasksApi for TurboTasks<B> {\n         self.backend.invalidate_serialization(task, self);\n     }\n \n-    fn notify_scheduled_tasks(&self) {\n-        let _ = CURRENT_TASK_STATE.try_with(|cell| {\n-            let tasks = {\n-                let CurrentTaskState {\n-                    tasks_to_notify, ..\n-                } = &mut *cell.write().unwrap();\n-                take(tasks_to_notify)\n-            };\n-            if tasks.is_empty() {\n-                return;\n-            }\n-            self.backend.invalidate_tasks(&tasks, self);\n-        });\n-    }\n-\n     fn try_read_task_output(\n         &self,\n         task: TaskId,\n@@ -1475,36 +1434,6 @@ impl<B: Backend + 'static> TurboTasksBackendApi<B> for TurboTasks<B> {\n         })\n     }\n \n-    /// Enqueues tasks for notification of changed dependencies. This will\n-    /// eventually call `dependent_cell_updated()` on all tasks.\n-    fn schedule_notify_tasks(&self, tasks: &[TaskId]) {\n-        let result = CURRENT_TASK_STATE.try_with(|cell| {\n-            let CurrentTaskState {\n-                tasks_to_notify, ..\n-            } = &mut *cell.write().unwrap();\n-            tasks_to_notify.extend(tasks.iter().copied());\n-        });\n-        if result.is_err() {\n-            let _guard = trace_span!(\"schedule_notify_tasks\", count = tasks.len()).entered();\n-            self.backend.invalidate_tasks(tasks, self);\n-        }\n-    }\n-\n-    /// Enqueues tasks for notification of changed dependencies. This will\n-    /// eventually call `dependent_cell_updated()` on all tasks.\n-    fn schedule_notify_tasks_set(&self, tasks: &TaskIdSet) {\n-        let result = CURRENT_TASK_STATE.try_with(|cell| {\n-            let CurrentTaskState {\n-                tasks_to_notify, ..\n-            } = &mut *cell.write().unwrap();\n-            tasks_to_notify.extend(tasks.iter().copied());\n-        });\n-        if result.is_err() {\n-            let _guard = trace_span!(\"schedule_notify_tasks_set\", count = tasks.len()).entered();\n-            self.backend.invalidate_tasks_set(tasks, self);\n-        };\n-    }\n-\n     #[track_caller]\n     fn schedule(&self, task: TaskId) {\n         self.schedule(task)\n@@ -1730,11 +1659,6 @@ pub fn prevent_gc() {\n     mark_stateful();\n }\n \n-/// Notifies scheduled tasks for execution.\n-pub fn notify_scheduled_tasks() {\n-    with_turbo_tasks(|tt| tt.notify_scheduled_tasks())\n-}\n-\n pub fn emit<T: VcValueTrait + ?Sized>(collectible: ResolvedVc<T>) {\n     with_turbo_tasks(|tt| {\n         let raw_vc = collectible.node.node;"
        },
        {
            "sha": "f8a6f95ab262e41fda02c2255b63a4a1fb21ee8d",
            "filename": "turbopack/crates/turbo-tasks/src/raw_vc.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 9,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/009e30d2f38d8c45718e105b0aba9baad8ed4853/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fraw_vc.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/009e30d2f38d8c45718e105b0aba9baad8ed4853/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fraw_vc.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fraw_vc.rs?ref=009e30d2f38d8c45718e105b0aba9baad8ed4853",
            "patch": "@@ -166,7 +166,6 @@ impl RawVc {\n         conditional: impl FnOnce(ValueTypeId) -> (bool, Option<&'static ValueType>),\n     ) -> Result<Option<RawVc>, ResolveTypeError> {\n         let tt = turbo_tasks();\n-        tt.notify_scheduled_tasks();\n         let mut current = self;\n         loop {\n             match current {\n@@ -211,14 +210,9 @@ impl RawVc {\n     async fn resolve_inner(self, mut consistency: ReadConsistency) -> Result<RawVc> {\n         let tt = turbo_tasks();\n         let mut current = self;\n-        let mut notified = false;\n         loop {\n             match current {\n                 RawVc::TaskOutput(task) => {\n-                    if !notified {\n-                        tt.notify_scheduled_tasks();\n-                        notified = true;\n-                    }\n                     current = read_task_output(&*tt, task, consistency).await?;\n                     // We no longer need to read strongly consistent, as any Vc returned\n                     // from the first task will be inside of the scope of the first\n@@ -302,7 +296,6 @@ impl CollectiblesSource for RawVc {\n             );\n         };\n         let tt = turbo_tasks();\n-        tt.notify_scheduled_tasks();\n         let map = tt.read_task_collectibles(task_id, T::get_trait_type_id());\n         map.into_iter()\n             .filter_map(|(raw, count)| (count > 0).then_some(raw.try_into().unwrap()))\n@@ -317,7 +310,6 @@ impl CollectiblesSource for RawVc {\n             );\n         };\n         let tt = turbo_tasks();\n-        tt.notify_scheduled_tasks();\n         let map = tt.read_task_collectibles(task_id, T::get_trait_type_id());\n         tt.unemit_collectibles(T::get_trait_type_id(), &map);\n         map.into_iter()\n@@ -368,7 +360,6 @@ impl Future for ReadRawVcFuture {\n \n     fn poll(self: Pin<&mut Self>, cx: &mut std::task::Context<'_>) -> Poll<Self::Output> {\n         with_turbo_tasks(|tt| {\n-            tt.notify_scheduled_tasks();\n             // SAFETY: we are not moving this\n             let this = unsafe { self.get_unchecked_mut() };\n             'outer: loop {"
        }
    ],
    "stats": {
        "total": 105,
        "additions": 8,
        "deletions": 97
    }
}