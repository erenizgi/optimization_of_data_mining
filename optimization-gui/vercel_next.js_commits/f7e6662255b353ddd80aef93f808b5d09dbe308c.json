{
    "author": "sokra",
    "message": "Turbopack: add verify_determinism feature to check if tasks are deterministic (#85559)\n\n### What?\n\nEnabling the feature will double execute tasks and print to stdout when tasks are updating cells while recomputing\n\nThe change will also change the behavior of cell updates during recomputation slightly. Instead of updating the cell and not notifying dependents, it will not update the cell at all ignoring the (unexpected) change.\nThis means when a task is recomputed without being invalidated, it won't update any cell data, except for the missing cell values.",
    "sha": "f7e6662255b353ddd80aef93f808b5d09dbe308c",
    "files": [
        {
            "sha": "51f50ca4fc15b6b8d2251492727f77b6aec0849f",
            "filename": "turbopack/crates/turbo-tasks-backend/Cargo.toml",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/f7e6662255b353ddd80aef93f808b5d09dbe308c/turbopack%2Fcrates%2Fturbo-tasks-backend%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/f7e6662255b353ddd80aef93f808b5d09dbe308c/turbopack%2Fcrates%2Fturbo-tasks-backend%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2FCargo.toml?ref=f7e6662255b353ddd80aef93f808b5d09dbe308c",
            "patch": "@@ -19,6 +19,7 @@ no_fast_stale = []\n verify_serialization = []\n verify_aggregation_graph = []\n verify_immutable = []\n+verify_determinism = []\n trace_aggregation_update = []\n trace_find_and_schedule = []\n trace_task_completion = []"
        },
        {
            "sha": "ca67a0a25f865ff3baa24b198b307c79bcf9ffe0",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 41,
            "deletions": 8,
            "changes": 49,
            "blob_url": "https://github.com/vercel/next.js/blob/f7e6662255b353ddd80aef93f808b5d09dbe308c/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f7e6662255b353ddd80aef93f808b5d09dbe308c/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=f7e6662255b353ddd80aef93f808b5d09dbe308c",
            "patch": "@@ -31,7 +31,7 @@ use turbo_tasks::{\n     TraitTypeId, TurboTasksBackendApi, ValueTypeId,\n     backend::{\n         Backend, CachedTaskType, CellContent, TaskExecutionSpec, TransientTaskRoot,\n-        TransientTaskType, TurboTasksExecutionError, TypedCellContent,\n+        TransientTaskType, TurboTasksExecutionError, TypedCellContent, VerificationMode,\n     },\n     event::{Event, EventListener},\n     message_queue::TimingEvent,\n@@ -423,6 +423,8 @@ struct TaskExecutionCompletePrepareResult {\n     pub new_children: FxHashSet<TaskId>,\n     pub removed_data: Vec<CachedDataItem>,\n     pub is_now_immutable: bool,\n+    #[cfg(feature = \"verify_determinism\")]\n+    pub no_output_set: bool,\n     pub new_output: Option<OutputValue>,\n     pub output_dependent_tasks: SmallVec<[TaskId; 4]>,\n }\n@@ -1765,6 +1767,8 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             new_children,\n             mut removed_data,\n             is_now_immutable,\n+            #[cfg(feature = \"verify_determinism\")]\n+            no_output_set,\n             new_output,\n             output_dependent_tasks,\n         }) = self.task_execution_completed_prepare(\n@@ -1809,6 +1813,8 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         if self.task_execution_completed_finish(\n             &mut ctx,\n             task_id,\n+            #[cfg(feature = \"verify_determinism\")]\n+            no_output_set,\n             new_output,\n             &mut removed_data,\n             is_now_immutable,\n@@ -1843,6 +1849,8 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                 new_children: Default::default(),\n                 removed_data: Default::default(),\n                 is_now_immutable: false,\n+                #[cfg(feature = \"verify_determinism\")]\n+                no_output_set: false,\n                 new_output: None,\n                 output_dependent_tasks: Default::default(),\n             });\n@@ -2021,6 +2029,8 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n \n         // Check if output need to be updated\n         let current_output = get!(task, Output);\n+        #[cfg(feature = \"verify_determinism\")]\n+        let no_output_set = current_output.is_none();\n         let new_output = match result {\n             Ok(RawVc::TaskOutput(output_task_id)) => {\n                 if let Some(OutputValue::Output(current_task_id)) = current_output\n@@ -2092,6 +2102,8 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             new_children,\n             removed_data,\n             is_now_immutable,\n+            #[cfg(feature = \"verify_determinism\")]\n+            no_output_set,\n             new_output,\n             output_dependent_tasks,\n         })\n@@ -2232,6 +2244,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         &self,\n         ctx: &mut impl ExecuteContext<'_>,\n         task_id: TaskId,\n+        #[cfg(feature = \"verify_determinism\")] no_output_set: bool,\n         new_output: Option<OutputValue>,\n         removed_data: &mut Vec<CachedDataItem>,\n         is_now_immutable: bool,\n@@ -2306,7 +2319,8 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             None\n         };\n \n-        let data_update = if old_dirty_state != new_dirty_state {\n+        let dirty_changed = old_dirty_state != new_dirty_state;\n+        let data_update = if dirty_changed {\n             if let Some(new_dirty_state) = new_dirty_state {\n                 task.insert(CachedDataItem::Dirty {\n                     value: new_dirty_state,\n@@ -2353,17 +2367,32 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             None\n         };\n \n-        drop(task);\n-        drop(old_content);\n+        #[cfg(feature = \"verify_determinism\")]\n+        let reschedule = (dirty_changed || no_output_set) && !task_id.is_transient();\n+        #[cfg(not(feature = \"verify_determinism\"))]\n+        let reschedule = false;\n+        if reschedule {\n+            task.add_new(CachedDataItem::InProgress {\n+                value: InProgressState::Scheduled {\n+                    done_event,\n+                    reason: TaskExecutionReason::Stale,\n+                },\n+            });\n+            drop(task);\n+        } else {\n+            drop(task);\n+\n+            // Notify dependent tasks that are waiting for this task to finish\n+            done_event.notify(usize::MAX);\n+        }\n \n-        // Notify dependent tasks that are waiting for this task to finish\n-        done_event.notify(usize::MAX);\n+        drop(old_content);\n \n         if let Some(data_update) = data_update {\n             AggregationUpdateQueue::run(data_update, ctx);\n         }\n \n-        false\n+        reschedule\n     }\n \n     fn task_execution_completed_cleanup(&self, ctx: &mut impl ExecuteContext<'_>, task_id: TaskId) {\n@@ -2652,12 +2681,14 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         task_id: TaskId,\n         cell: CellId,\n         content: CellContent,\n+        verification_mode: VerificationMode,\n         turbo_tasks: &dyn TurboTasksBackendApi<TurboTasksBackend<B>>,\n     ) {\n         operation::UpdateCellOperation::run(\n             task_id,\n             cell,\n             content,\n+            verification_mode,\n             self.execute_context(turbo_tasks),\n         );\n     }\n@@ -3251,9 +3282,11 @@ impl<B: BackingStorage> Backend for TurboTasksBackend<B> {\n         task_id: TaskId,\n         cell: CellId,\n         content: CellContent,\n+        verification_mode: VerificationMode,\n         turbo_tasks: &dyn TurboTasksBackendApi<Self>,\n     ) {\n-        self.0.update_task_cell(task_id, cell, content, turbo_tasks);\n+        self.0\n+            .update_task_cell(task_id, cell, content, verification_mode, turbo_tasks);\n     }\n \n     fn mark_own_task_as_finished("
        },
        {
            "sha": "5bd654fb19ca2ce0a23509e5565a650a3f1f29eb",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/update_cell.rs",
            "status": "modified",
            "additions": 52,
            "deletions": 14,
            "changes": 66,
            "blob_url": "https://github.com/vercel/next.js/blob/f7e6662255b353ddd80aef93f808b5d09dbe308c/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fupdate_cell.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f7e6662255b353ddd80aef93f808b5d09dbe308c/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fupdate_cell.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fupdate_cell.rs?ref=f7e6662255b353ddd80aef93f808b5d09dbe308c",
            "patch": "@@ -2,6 +2,8 @@ use std::mem::take;\n \n use serde::{Deserialize, Serialize};\n use smallvec::SmallVec;\n+#[cfg(not(feature = \"verify_determinism\"))]\n+use turbo_tasks::backend::VerificationMode;\n use turbo_tasks::{CellId, TaskId, TypedSharedReference, backend::CellContent};\n \n #[cfg(feature = \"trace_task_dirty\")]\n@@ -13,7 +15,7 @@ use crate::{\n             AggregationUpdateQueue, ExecuteContext, Operation, TaskGuard,\n             invalidate::make_task_dirty_internal,\n         },\n-        storage::{get_many, remove},\n+        storage::{get, get_many, remove},\n     },\n     data::{CachedDataItem, CachedDataItemKey, CellRef},\n };\n@@ -40,18 +42,61 @@ pub enum UpdateCellOperation {\n }\n \n impl UpdateCellOperation {\n-    pub fn run(task_id: TaskId, cell: CellId, content: CellContent, mut ctx: impl ExecuteContext) {\n+    pub fn run(\n+        task_id: TaskId,\n+        cell: CellId,\n+        content: CellContent,\n+        #[cfg(feature = \"verify_determinism\")] verification_mode: VerificationMode,\n+        #[cfg(not(feature = \"verify_determinism\"))] _verification_mode: VerificationMode,\n+        mut ctx: impl ExecuteContext,\n+    ) {\n+        let content = if let CellContent(Some(new_content)) = content {\n+            Some(new_content.into_typed(cell.type_id))\n+        } else {\n+            None\n+        };\n+\n         let mut task = ctx.task(task_id, TaskDataCategory::All);\n \n+        let is_stateful = task.has_key(&CachedDataItemKey::Stateful {});\n         // We need to detect recomputation, because here the content has not actually changed (even\n         // if it's not equal to the old content, as not all values implement Eq). We have to\n         // assume that tasks are deterministic and pure.\n-        let should_invalidate = ctx.should_track_dependencies()\n-            && (task.has_key(&CachedDataItemKey::Dirty {}) ||\n+        let assume_unchanged = !ctx.should_track_dependencies()\n+            || (!task.has_key(&CachedDataItemKey::Dirty {})\n             // This is a hack for the streaming hack. Stateful tasks are never recomputed, so this forces invalidation for them in case of this hack.\n-            task.has_key(&CachedDataItemKey::Stateful {}));\n+            && !is_stateful);\n+\n+        let old_content = get!(task, CellData { cell });\n+\n+        if assume_unchanged {\n+            if old_content.is_some() {\n+                // Never update cells when recomputing if they already have a value.\n+                // It's not expected that content changes during recomputation.\n+\n+                // Check if this assumption holds.\n+                #[cfg(feature = \"verify_determinism\")]\n+                if !is_stateful\n+                    && matches!(verification_mode, VerificationMode::EqualityCheck)\n+                    && content.as_ref() != old_content\n+                {\n+                    let task_description = ctx.get_task_description(task_id);\n+                    let cell_type = turbo_tasks::registry::get_value_type(cell.type_id).global_name;\n+                    eprintln!(\n+                        \"Task {} updated cell #{} (type: {}) while recomputing\",\n+                        task_description, cell.index, cell_type\n+                    );\n+                }\n+                return;\n+            } else {\n+                // Initial computation, or computation after a cell has been cleared.\n+                // We can just set the content, but we don't want to notify dependent tasks,\n+                // as we assume that content hasn't changed (deterministic tasks).\n+            }\n+        } else {\n+            // When not recomputing, we need to notify dependent tasks if the content actually\n+            // changes.\n \n-        if should_invalidate {\n             let dependent_tasks: SmallVec<[TaskId; 4]> = get_many!(\n                 task,\n                 CellDependent { cell: dependent_cell, task }\n@@ -78,12 +123,6 @@ impl UpdateCellOperation {\n                 drop(task);\n                 drop(old_content);\n \n-                let content = if let CellContent(Some(new_content)) = content {\n-                    Some(new_content.into_typed(cell.type_id))\n-                } else {\n-                    None\n-                };\n-\n                 UpdateCellOperation::InvalidateWhenCellDependency {\n                     cell_ref: CellRef {\n                         task: task_id,\n@@ -101,8 +140,7 @@ impl UpdateCellOperation {\n         // Fast path: We don't need to invalidate anything.\n         // So we can just update the cell content.\n \n-        let old_content = if let CellContent(Some(new_content)) = content {\n-            let new_content = new_content.into_typed(cell.type_id);\n+        let old_content = if let Some(new_content) = content {\n             task.insert(CachedDataItem::CellData {\n                 cell,\n                 value: new_content,"
        },
        {
            "sha": "cbd9888e92d282fcf26917692f983e7af13ccefe",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/detached.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/f7e6662255b353ddd80aef93f808b5d09dbe308c/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fdetached.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f7e6662255b353ddd80aef93f808b5d09dbe308c/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fdetached.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fdetached.rs?ref=f7e6662255b353ddd80aef93f808b5d09dbe308c",
            "patch": "@@ -18,6 +18,7 @@ static REGISTRATION: Registration = register!();\n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn test_spawns_detached() -> anyhow::Result<()> {\n     run_once(&REGISTRATION, || async {\n+        println!(\"test_spawns_detached\");\n         // HACK: The watch channel we use has an incorrect implementation of `TraceRawVcs`, just\n         // disable GC for the test so this can't cause any problems.\n         prevent_gc();\n@@ -73,7 +74,9 @@ async fn spawns_detached(\n     sender: TransientInstance<WatchSenderTaskInput<Option<Vc<u32>>>>,\n ) -> Vc<()> {\n     tokio::spawn(turbo_tasks().detached_for_testing(Box::pin(async move {\n+        println!(\"spawns_detached: waiting for notify\");\n         notify.0.notified().await;\n+        println!(\"spawns_detached: notified, sending value\");\n         // creating cells after the normal lifetime of the task should be okay, as the parent task\n         // is waiting on us before exiting!\n         sender.0.send(Some(Vc::cell(42))).unwrap();"
        },
        {
            "sha": "b298f282c07bdc37c9cbdbce2703ecf1e8626f62",
            "filename": "turbopack/crates/turbo-tasks-testing/src/lib.rs",
            "status": "modified",
            "additions": 8,
            "deletions": 2,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/f7e6662255b353ddd80aef93f808b5d09dbe308c/turbopack%2Fcrates%2Fturbo-tasks-testing%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f7e6662255b353ddd80aef93f808b5d09dbe308c/turbopack%2Fcrates%2Fturbo-tasks-testing%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-testing%2Fsrc%2Flib.rs?ref=f7e6662255b353ddd80aef93f808b5d09dbe308c",
            "patch": "@@ -18,7 +18,7 @@ use tokio::sync::mpsc::Receiver;\n use turbo_tasks::{\n     CellId, ExecutionId, InvalidationReason, LocalTaskId, MagicAny, RawVc, ReadCellOptions,\n     ReadOutputOptions, TaskId, TaskPersistence, TraitTypeId, TurboTasksApi, TurboTasksCallApi,\n-    backend::{CellContent, TaskCollectiblesMap, TypedCellContent},\n+    backend::{CellContent, TaskCollectiblesMap, TypedCellContent, VerificationMode},\n     event::{Event, EventListener},\n     message_queue::CompilationEvent,\n     test_helpers::with_turbo_tasks_for_testing,\n@@ -261,7 +261,13 @@ impl TurboTasksApi for VcStorage {\n         .into_typed(index.type_id))\n     }\n \n-    fn update_own_task_cell(&self, task: TaskId, index: CellId, content: CellContent) {\n+    fn update_own_task_cell(\n+        &self,\n+        task: TaskId,\n+        index: CellId,\n+        content: CellContent,\n+        _verification_mode: VerificationMode,\n+    ) {\n         let mut map = self.cells.lock().unwrap();\n         let cell = map.entry((task, index)).or_default();\n         *cell = content;"
        },
        {
            "sha": "565c80e31606f01a64e5bdf52cd799ad409e0c21",
            "filename": "turbopack/crates/turbo-tasks-testing/src/run.rs",
            "status": "modified",
            "additions": 13,
            "deletions": 7,
            "changes": 20,
            "blob_url": "https://github.com/vercel/next.js/blob/f7e6662255b353ddd80aef93f808b5d09dbe308c/turbopack%2Fcrates%2Fturbo-tasks-testing%2Fsrc%2Frun.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f7e6662255b353ddd80aef93f808b5d09dbe308c/turbopack%2Fcrates%2Fturbo-tasks-testing%2Fsrc%2Frun.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-testing%2Fsrc%2Frun.rs?ref=f7e6662255b353ddd80aef93f808b5d09dbe308c",
            "patch": "@@ -1,4 +1,4 @@\n-use std::{fmt::Debug, future::Future, sync::Arc};\n+use std::{env, fmt::Debug, future::Future, sync::Arc};\n \n use anyhow::Result;\n use turbo_tasks::{TurboTasksApi, trace::TraceRawVcs};\n@@ -98,22 +98,28 @@ where\n     F: Future<Output = Result<T>> + Send + 'static,\n     T: Debug + PartialEq + Eq + TraceRawVcs + Send + 'static,\n {\n+    let single_run = env::var(\"SINGLE_RUN\").is_ok();\n     let name = closure_to_name(&fut);\n     let tt = registration.create_turbo_tasks(&name, true);\n     println!(\"Run #1 (without cache)\");\n     let start = std::time::Instant::now();\n     let first = fut(tt.clone()).await?;\n     println!(\"Run #1 took {:?}\", start.elapsed());\n-    for i in 2..10 {\n-        println!(\"Run #{i} (with memory cache, same TurboTasks instance)\");\n-        let start = std::time::Instant::now();\n-        let second = fut(tt.clone()).await?;\n-        println!(\"Run #{i} took {:?}\", start.elapsed());\n-        assert_eq!(first, second);\n+    if !single_run {\n+        for i in 2..10 {\n+            println!(\"Run #{i} (with memory cache, same TurboTasks instance)\");\n+            let start = std::time::Instant::now();\n+            let second = fut(tt.clone()).await?;\n+            println!(\"Run #{i} took {:?}\", start.elapsed());\n+            assert_eq!(first, second);\n+        }\n     }\n     let start = std::time::Instant::now();\n     tt.stop_and_wait().await;\n     println!(\"Stopping TurboTasks took {:?}\", start.elapsed());\n+    if single_run {\n+        return Ok(());\n+    }\n     for i in 10..20 {\n         let tt = registration.create_turbo_tasks(&name, false);\n         println!(\"Run #{i} (with filesystem cache if available, new TurboTasks instance)\");"
        },
        {
            "sha": "74d61e3ef546e3f3a9dc254f454e2f8588207d7f",
            "filename": "turbopack/crates/turbo-tasks/src/backend.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/f7e6662255b353ddd80aef93f808b5d09dbe308c/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fbackend.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f7e6662255b353ddd80aef93f808b5d09dbe308c/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fbackend.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fbackend.rs?ref=f7e6662255b353ddd80aef93f808b5d09dbe308c",
            "patch": "@@ -497,6 +497,11 @@ impl From<anyhow::Error> for TurboTasksExecutionError {\n     }\n }\n \n+pub enum VerificationMode {\n+    EqualityCheck,\n+    Skip,\n+}\n+\n pub trait Backend: Sync + Send {\n     #[allow(unused_variables)]\n     fn startup(&self, turbo_tasks: &dyn TurboTasksBackendApi<Self>) {}\n@@ -621,6 +626,7 @@ pub trait Backend: Sync + Send {\n         task: TaskId,\n         index: CellId,\n         content: CellContent,\n+        verification_mode: VerificationMode,\n         turbo_tasks: &dyn TurboTasksBackendApi<Self>,\n     );\n "
        },
        {
            "sha": "4d7e303bb4453fa1a7d020ce18cfb1599a72805e",
            "filename": "turbopack/crates/turbo-tasks/src/manager.rs",
            "status": "modified",
            "additions": 54,
            "deletions": 22,
            "changes": 76,
            "blob_url": "https://github.com/vercel/next.js/blob/f7e6662255b353ddd80aef93f808b5d09dbe308c/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f7e6662255b353ddd80aef93f808b5d09dbe308c/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs?ref=f7e6662255b353ddd80aef93f808b5d09dbe308c",
            "patch": "@@ -25,7 +25,7 @@ use crate::{\n     VcValueTrait, VcValueType,\n     backend::{\n         Backend, CachedTaskType, CellContent, TaskCollectiblesMap, TaskExecutionSpec,\n-        TransientTaskType, TurboTasksExecutionError, TypedCellContent,\n+        TransientTaskType, TurboTasksExecutionError, TypedCellContent, VerificationMode,\n     },\n     capture_future::CaptureFuture,\n     event::{Event, EventListener},\n@@ -155,7 +155,13 @@ pub trait TurboTasksApi: TurboTasksCallApi + Sync + Send {\n         index: CellId,\n         options: ReadCellOptions,\n     ) -> Result<TypedCellContent>;\n-    fn update_own_task_cell(&self, task: TaskId, index: CellId, content: CellContent);\n+    fn update_own_task_cell(\n+        &self,\n+        task: TaskId,\n+        index: CellId,\n+        content: CellContent,\n+        verification_mode: VerificationMode,\n+    );\n     fn mark_own_task_as_finished(&self, task: TaskId);\n     fn set_own_task_aggregation_number(&self, task: TaskId, aggregation_number: u32);\n     fn mark_own_task_as_session_dependent(&self, task: TaskId);\n@@ -1354,8 +1360,15 @@ impl<B: Backend + 'static> TurboTasksApi for TurboTasks<B> {\n         self.try_read_own_task_cell(task, index, options)\n     }\n \n-    fn update_own_task_cell(&self, task: TaskId, index: CellId, content: CellContent) {\n-        self.backend.update_task_cell(task, index, content, self);\n+    fn update_own_task_cell(\n+        &self,\n+        task: TaskId,\n+        index: CellId,\n+        content: CellContent,\n+        verification_mode: VerificationMode,\n+    ) {\n+        self.backend\n+            .update_task_cell(task, index, content, verification_mode, self);\n     }\n \n     fn connect_task(&self, task: TaskId) {\n@@ -1769,7 +1782,12 @@ impl CurrentCellRef {\n             .ok();\n         let update = functor(cell_content.as_ref().and_then(|cc| cc.1.0.as_ref()));\n         if let Some(update) = update {\n-            tt.update_own_task_cell(self.current_task, self.index, CellContent(Some(update)))\n+            tt.update_own_task_cell(\n+                self.current_task,\n+                self.index,\n+                CellContent(Some(update)),\n+                VerificationMode::EqualityCheck,\n+            )\n         }\n     }\n \n@@ -1851,7 +1869,7 @@ impl CurrentCellRef {\n     }\n \n     /// Unconditionally updates the content of the cell.\n-    pub fn update<T>(&self, new_value: T)\n+    pub fn update<T>(&self, new_value: T, verification_mode: VerificationMode)\n     where\n         T: VcValueType,\n     {\n@@ -1862,6 +1880,7 @@ impl CurrentCellRef {\n             CellContent(Some(SharedReference::new(triomphe::Arc::new(\n                 <T::Read as VcRead<T>>::value_to_repr(new_value),\n             )))),\n+            verification_mode,\n         )\n     }\n \n@@ -1873,27 +1892,40 @@ impl CurrentCellRef {\n     ///\n     /// The [`SharedReference`] is expected to use the `<T::Read as\n     /// VcRead<T>>::Repr` type for its representation of the value.\n-    pub fn update_with_shared_reference(&self, shared_ref: SharedReference) {\n+    pub fn update_with_shared_reference(\n+        &self,\n+        shared_ref: SharedReference,\n+        verification_mode: VerificationMode,\n+    ) {\n         let tt = turbo_tasks();\n-        let content = tt\n-            .read_own_task_cell(\n-                self.current_task,\n-                self.index,\n-                ReadCellOptions {\n-                    // INVALIDATION: Reading our own cell must be untracked\n-                    tracking: ReadTracking::Untracked,\n-                    ..Default::default()\n-                },\n-            )\n-            .ok();\n-        let update = if let Some(TypedCellContent(_, CellContent(Some(shared_ref_exp)))) = content {\n-            // pointer equality (not value equality)\n-            shared_ref_exp != shared_ref\n+        let update = if matches!(verification_mode, VerificationMode::EqualityCheck) {\n+            let content = tt\n+                .read_own_task_cell(\n+                    self.current_task,\n+                    self.index,\n+                    ReadCellOptions {\n+                        // INVALIDATION: Reading our own cell must be untracked\n+                        tracking: ReadTracking::Untracked,\n+                        ..Default::default()\n+                    },\n+                )\n+                .ok();\n+            if let Some(TypedCellContent(_, CellContent(Some(shared_ref_exp)))) = content {\n+                // pointer equality (not value equality)\n+                shared_ref_exp != shared_ref\n+            } else {\n+                true\n+            }\n         } else {\n             true\n         };\n         if update {\n-            tt.update_own_task_cell(self.current_task, self.index, CellContent(Some(shared_ref)))\n+            tt.update_own_task_cell(\n+                self.current_task,\n+                self.index,\n+                CellContent(Some(shared_ref)),\n+                verification_mode,\n+            )\n         }\n     }\n }"
        },
        {
            "sha": "cffeed9d67c237b70f614bdf910477541f3576df",
            "filename": "turbopack/crates/turbo-tasks/src/vc/cell_mode.rs",
            "status": "modified",
            "additions": 9,
            "deletions": 3,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/f7e6662255b353ddd80aef93f808b5d09dbe308c/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fvc%2Fcell_mode.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f7e6662255b353ddd80aef93f808b5d09dbe308c/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fvc%2Fcell_mode.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fvc%2Fcell_mode.rs?ref=f7e6662255b353ddd80aef93f808b5d09dbe308c",
            "patch": "@@ -1,7 +1,10 @@\n use std::{any::type_name, marker::PhantomData};\n \n use super::{read::VcRead, traits::VcValueType};\n-use crate::{RawVc, Vc, manager::find_cell_by_type, task::shared_reference::TypedSharedReference};\n+use crate::{\n+    RawVc, Vc, backend::VerificationMode, manager::find_cell_by_type,\n+    task::shared_reference::TypedSharedReference,\n+};\n \n type VcReadTarget<T> = <<T as VcValueType>::Read as VcRead<T>>::Target;\n type VcReadRepr<T> = <<T as VcValueType>::Read as VcRead<T>>::Repr;\n@@ -37,7 +40,10 @@ where\n {\n     fn cell(inner: VcReadTarget<T>) -> Vc<T> {\n         let cell = find_cell_by_type(T::get_value_type_id());\n-        cell.update(<T::Read as VcRead<T>>::target_to_value(inner));\n+        cell.update(\n+            <T::Read as VcRead<T>>::target_to_value(inner),\n+            VerificationMode::Skip,\n+        );\n         Vc {\n             node: cell.into(),\n             _t: PhantomData,\n@@ -47,7 +53,7 @@ where\n     fn raw_cell(content: TypedSharedReference) -> RawVc {\n         debug_assert_repr::<T>(&content);\n         let cell = find_cell_by_type(content.type_id);\n-        cell.update_with_shared_reference(content.reference);\n+        cell.update_with_shared_reference(content.reference, VerificationMode::Skip);\n         cell.into()\n     }\n }"
        },
        {
            "sha": "e495896bcce6b3cc6fbda80f6c18befa04763788",
            "filename": "turbopack/crates/turbopack-node/src/evaluate.rs",
            "status": "modified",
            "additions": 13,
            "deletions": 10,
            "changes": 23,
            "blob_url": "https://github.com/vercel/next.js/blob/f7e6662255b353ddd80aef93f808b5d09dbe308c/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fevaluate.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f7e6662255b353ddd80aef93f808b5d09dbe308c/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fevaluate.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fevaluate.rs?ref=f7e6662255b353ddd80aef93f808b5d09dbe308c",
            "patch": "@@ -16,8 +16,8 @@ use serde_json::Value as JsonValue;\n use turbo_rcstr::rcstr;\n use turbo_tasks::{\n     Completion, Effects, FxIndexMap, NonLocalValue, OperationVc, RawVc, ReadRef, ResolvedVc,\n-    TaskInput, TryJoinIterExt, Vc, VcValueType, duration_span, fxindexmap, get_effects,\n-    mark_finished, prevent_gc, trace::TraceRawVcs, util::SharedError,\n+    TaskInput, TryJoinIterExt, Vc, VcValueType, backend::VerificationMode, duration_span,\n+    fxindexmap, get_effects, mark_finished, prevent_gc, trace::TraceRawVcs, util::SharedError,\n };\n use turbo_tasks_bytes::{Bytes, Stream};\n use turbo_tasks_env::{EnvMap, ProcessEnv};\n@@ -401,10 +401,10 @@ pub async fn custom_evaluate(\n     // We initialize the cell with a stream that is open, but has no values.\n     // The first [compute_evaluate_stream] pipe call will pick up that stream.\n     let (sender, receiver) = unbounded();\n-    cell.update(JavaScriptEvaluation(JavaScriptStream::new_open(\n-        vec![],\n-        Box::new(receiver),\n-    )));\n+    cell.update(\n+        JavaScriptEvaluation(JavaScriptStream::new_open(vec![], Box::new(receiver))),\n+        VerificationMode::Skip,\n+    );\n     let initial = Mutex::new(Some(sender));\n \n     // run the evaluation as side effect\n@@ -418,10 +418,13 @@ pub async fn custom_evaluate(\n                         // In cases when only [compute_evaluate_stream] is (re)executed, we need to\n                         // update the old stream with a new value.\n                         let (sender, receiver) = unbounded();\n-                        cell.update(JavaScriptEvaluation(JavaScriptStream::new_open(\n-                            vec![],\n-                            Box::new(receiver),\n-                        )));\n+                        cell.update(\n+                            JavaScriptEvaluation(JavaScriptStream::new_open(\n+                                vec![],\n+                                Box::new(receiver),\n+                            )),\n+                            VerificationMode::Skip,\n+                        );\n                         sender\n                     }\n                 }),"
        }
    ],
    "stats": {
        "total": 266,
        "additions": 200,
        "deletions": 66
    }
}