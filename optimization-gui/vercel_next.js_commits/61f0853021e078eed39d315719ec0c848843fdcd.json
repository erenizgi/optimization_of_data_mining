{
    "author": "lukesandberg",
    "message": "[turbopack] Fix a crash under turbopackPersistentCaching (#82592)\n\nAddress a crash found at head when testing caching while switching back and forth from `dev` and `build`.  \n\n```\nthread '<unnamed>' panicked at turbopack/crates/turbo-persistence/src/db.rs:798:17:\nattempt to subtract with overflow\nstack backtrace:\n   0: __rustc::rust_begin_unwind\n   1: core::panicking::panic_fmt\n   2: core::panicking::panic_const::panic_const_sub_overflow\n   3: <core::iter::adapters::map::Map<core::slice::iter::Iter<alloc::vec::Vec<<turbo_persistence::db::TurboPersistence>::compact_internal::SstWithRange>>, <turbo_persistence::db::TurboPersistence>::compact_internal::{closure#2}> as core::iter::traits::iterator::Iterator>::fold::<(), core::iter::traits::iterator::Iterator::for_each::call<alloc::vec::Vec<smallvec::SmallVec<[usize; 1]>>, <alloc::vec::Vec<alloc::vec::Vec<smallvec::SmallVec<[usize; 1]>>>>::extend_trusted<core::iter::adapters::map::Map<core::slice::iter::Iter<alloc::vec::Vec<<turbo_persistence::db::TurboPersistence>::compact_internal::SstWithRange>>, <turbo_persistence::db::TurboPersistence>::compact_internal::{closure#2}>>::{closure#0}>::{closure#0}>\n   4: <alloc::vec::Vec<alloc::vec::Vec<smallvec::SmallVec<[usize; 1]>>> as alloc::vec::spec_from_iter_nested::SpecFromIterNested<alloc::vec::Vec<smallvec::SmallVec<[usize; 1]>>, core::iter::adapters::map::Map<core::slice::iter::Iter<alloc::vec::Vec<<turbo_persistence::db::TurboPersistence>::compact_internal::SstWithRange>>, <turbo_persistence::db::TurboPersistence>::compact_internal::{closure#2}>>>::from_iter\n   5: <turbo_persistence::db::TurboPersistence>::compact\n```\n\nScenario:\n * build turbopack and next\n * cd bench/module-cost\n * enable persistent caching\n * pnpm i\n * pnpm dev-turbopack\n * load localhost:3000 and click all the buttons\n * pnpm build-turbopack\n * pnpm dev-turbopack\n * load localhost:3000 and see the crash\n\n## What?\n\nThe `get_merge_segments` function and its caller had a different idea about what `max_merge_segment_count` means.  Unify how this is accounted to avoid underflow.",
    "sha": "61f0853021e078eed39d315719ec0c848843fdcd",
    "files": [
        {
            "sha": "1616535b972a98bb48ad00bf4cdbf0265ba79458",
            "filename": "turbopack/crates/turbo-persistence/src/compaction/selector.rs",
            "status": "modified",
            "additions": 8,
            "deletions": 5,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/61f0853021e078eed39d315719ec0c848843fdcd/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fcompaction%2Fselector.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/61f0853021e078eed39d315719ec0c848843fdcd/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fcompaction%2Fselector.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fcompaction%2Fselector.rs?ref=61f0853021e078eed39d315719ec0c848843fdcd",
            "patch": "@@ -200,10 +200,13 @@ fn total_duplication_size(duplication: &IntervalMap<Option<DuplicationInfo>>) ->\n \n type MergeSegments = Vec<SmallVec<[usize; 1]>>;\n \n+/// Computes the set of merge segments that should be run to compact the given compactables.\n+///\n+/// Returns both the mergeable segments and the actual number of merge segments that were created.\n pub fn get_merge_segments<T: Compactable>(\n     compactables: &[T],\n     config: &CompactConfig,\n-) -> MergeSegments {\n+) -> (MergeSegments, usize) {\n     // Process all compactables in reverse order.\n     // For each compactable, find the smallest set of compactables that overlaps with it and matches\n     // the conditions.\n@@ -259,7 +262,7 @@ pub fn get_merge_segments<T: Compactable>(\n                     continue 'outer;\n                 }\n \n-                // If we are limited by size or count, we might also crate a merge segment if it's\n+                // If we are limited by size or count, we might also create a merge segment if it's\n                 // within the limits.\n                 let valid_merge_job = current_set.len() >= config.min_merge_count\n                     && duplication_size >= config.min_merge_duplication_bytes;\n@@ -361,7 +364,7 @@ pub fn get_merge_segments<T: Compactable>(\n         true\n     });\n \n-    merge_segments\n+    (merge_segments, real_merge_segments)\n }\n \n #[cfg(test)]\n@@ -398,7 +401,7 @@ mod tests {\n             .into_iter()\n             .map(|range| TestCompactable { range, size: 100 })\n             .collect::<Vec<_>>();\n-        let jobs = get_merge_segments(&compactables, config);\n+        let (jobs, _) = get_merge_segments(&compactables, config);\n         jobs.into_iter()\n             .map(|job| job.into_iter().collect())\n             .collect()\n@@ -613,7 +616,7 @@ mod tests {\n                 optimal_merge_duplication_bytes: 500,\n                 max_merge_segment_count: 4,\n             };\n-            let jobs = get_merge_segments(&containers, &config);\n+            let (jobs, _) = get_merge_segments(&containers, &config);\n             if !jobs.is_empty() {\n                 println!(\"{jobs:?}\");\n "
        },
        {
            "sha": "58e35e7d191751060d4762f62670244dc2b2fea9",
            "filename": "turbopack/crates/turbo-persistence/src/db.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/61f0853021e078eed39d315719ec0c848843fdcd/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fdb.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/61f0853021e078eed39d315719ec0c848843fdcd/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fdb.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fdb.rs?ref=61f0853021e078eed39d315719ec0c848843fdcd",
            "patch": "@@ -794,8 +794,9 @@ impl TurboPersistence {\n                 if compact_config.max_merge_segment_count == 0 {\n                     return Vec::new();\n                 }\n-                let merge_jobs = get_merge_segments(ssts_with_ranges, &compact_config);\n-                compact_config.max_merge_segment_count -= merge_jobs.len();\n+                let (merge_jobs, real_merge_job_size) =\n+                    get_merge_segments(ssts_with_ranges, &compact_config);\n+                compact_config.max_merge_segment_count -= real_merge_job_size;\n                 merge_jobs\n             })\n             .collect::<Vec<_>>();"
        }
    ],
    "stats": {
        "total": 18,
        "additions": 11,
        "deletions": 7
    }
}