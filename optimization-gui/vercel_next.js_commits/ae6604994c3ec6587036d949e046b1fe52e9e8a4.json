{
    "author": "acdlite",
    "message": "[router-act] Fixes related to segment inlining (#81896)\n\nWhile working on a feature called segment inlining, I had to make some\nchanges to the internal `act` function we use for testing the Next.js\nclient.\n\nDescriptions are given in each commit message.",
    "sha": "ae6604994c3ec6587036d949e046b1fe52e9e8a4",
    "files": [
        {
            "sha": "f18435454cee510593ad5f4b1e55ba2d48c849e9",
            "filename": "test/e2e/app-dir/segment-cache/router-act.ts",
            "status": "modified",
            "additions": 54,
            "deletions": 33,
            "changes": 87,
            "blob_url": "https://github.com/vercel/next.js/blob/ae6604994c3ec6587036d949e046b1fe52e9e8a4/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frouter-act.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/ae6604994c3ec6587036d949e046b1fe52e9e8a4/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frouter-act.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frouter-act.ts?ref=ae6604994c3ec6587036d949e046b1fe52e9e8a4",
            "patch": "@@ -8,7 +8,8 @@ type Batch = {\n }\n \n type PendingRSCRequest = {\n-  route: Playwright.Route\n+  url: string\n+  route: Playwright.Route | null\n   result: Promise<{\n     text: string\n     body: any\n@@ -153,6 +154,7 @@ export function createRouterAct(\n           // This request was initiated by the Next.js Router. Intercept it and\n           // add it to the current batch.\n           pendingRequests.add({\n+            url: request.url(),\n             route,\n             // `act` controls the timing of when responses reach the client,\n             // but it should not affect the timing of when requests reach the\n@@ -262,7 +264,7 @@ export function createRouterAct(\n         batch.pendingRequests = new Set()\n         for (const item of pending) {\n           const route = item.route\n-          const request = route.request()\n+          const url = item.url\n \n           let shouldBlock = false\n           const fulfilled = await item.result\n@@ -274,7 +276,7 @@ export function createRouterAct(\n               error.message = `\n Expected no network requests to be initiated.\n \n-URL: ${request.url()}\n+URL: ${url}\n Headers: ${JSON.stringify(fulfilled.headers)}\n \n Response:\n@@ -288,7 +290,7 @@ ${fulfilled.body}\n Received a response with an error status code.\n \n Status: ${fulfilled.status}\n-URL: ${request.url()}\n+URL: ${url}\n Headers: ${JSON.stringify(fulfilled.headers)}\n \n Response:\n@@ -313,7 +315,6 @@ ${fulfilled.body}\n               }\n             }\n             if (expectedResponses !== null) {\n-              let alreadyMatchedByThisResponse: string | null = null\n               for (const expectedResponse of expectedResponses) {\n                 const includes = expectedResponse.includes\n                 const block = expectedResponse.block\n@@ -322,21 +323,6 @@ ${fulfilled.body}\n                   // in the expected order. Instead collect all the matches and\n                   // check at the end so we can include a diff in the\n                   // error message.\n-                  if (alreadyMatchedByThisResponse) {\n-                    error.message = `\n-Received a response that includes both of the following substrings.\n-\n-Expected substrings:\n-- ${alreadyMatchedByThisResponse}\n-- ${includes}\n-\n-Response:\n-${fulfilled.body}\n-\n-Choose more specific substrings to assert on.\n-`\n-                    throw error\n-                  }\n                   const otherResponse = alreadyMatched.get(includes)\n                   if (otherResponse !== undefined) {\n                     error.message = `\n@@ -355,7 +341,6 @@ Choose a more specific substring to assert on.\n `\n                     throw error\n                   }\n-                  alreadyMatchedByThisResponse = includes\n                   alreadyMatched.set(includes, fulfilled.body)\n                   if (actualResponses === null) {\n                     actualResponses = [expectedResponse]\n@@ -376,27 +361,63 @@ Choose a more specific substring to assert on.\n             // This response was blocked by the `block` option. Don't\n             // fulfill it yet.\n             remaining.add(item)\n+            if (route === null) {\n+              error.message = `\n+The \"block\" option is not supported for requests that are redirected.\n+\n+URL: ${url}\n+Headers: ${JSON.stringify(fulfilled.headers)}\n+\n+Response:\n+${fulfilled.body}\n+`\n+\n+              throw error\n+            }\n           } else {\n-            await route.fulfill({\n-              body: fulfilled.body,\n-              headers: fulfilled.headers,\n-              status: fulfilled.status,\n-            })\n-            const browserResponse = await request.response()\n-            if (browserResponse !== null) {\n-              await browserResponse.finished()\n+            if (route !== null) {\n+              const request = route.request()\n+              await route.fulfill({\n+                body: fulfilled.body,\n+                headers: fulfilled.headers,\n+                status: fulfilled.status,\n+              })\n+              const browserResponse = await request.response()\n+              if (browserResponse !== null) {\n+                await browserResponse.finished()\n+              }\n             }\n           }\n \n           if (fulfilled.status === 307 || fulfilled.status === 308) {\n-            // If this was a redirect, give the browser time to follow the\n-            // redirect, before continuing. We do that by waiting for the very\n-            // next request to respond. Otherwise, we might exit early, before\n-            // the request was added to the pending requests set.\n+            // When fulfilling a redirect, for some reason, the page.route()\n+            // handler installed earlier will not intercept the\n+            // redirect request. Install a one-off event listener to wait for\n+            // the redirected request to finish. This works for this case\n+            // because we don't need to modify to delay the response; we only\n+            // need to observe when it has finished.\n+            // TODO: Because this request cannot be intercepted, it's\n+            // incompatible with the \"block\" option. I haven't yet figured out\n+            // a strategy to make that work. In the meantime, attempting to\n+            // write a test that blocks a redirect will result in an error\n+            // (see error above).\n             await new Promise<void>((resolve) => {\n               page.once('request', (req) => {\n                 const handleResponse = (res: Playwright.Response) => {\n                   if (res.url() === req.url()) {\n+                    batch.pendingRequests.add({\n+                      url: req.url(),\n+                      route: null,\n+                      result: new Promise(async (resolve) => {\n+                        resolve({\n+                          text: await res.text(),\n+                          body: await res.body(),\n+                          headers: res.headers(),\n+                          status: res.status(),\n+                        })\n+                      }),\n+                      didProcess: false,\n+                    })\n                     page.off('response', handleResponse)\n                     resolve()\n                   }"
        }
    ],
    "stats": {
        "total": 87,
        "additions": 54,
        "deletions": 33
    }
}