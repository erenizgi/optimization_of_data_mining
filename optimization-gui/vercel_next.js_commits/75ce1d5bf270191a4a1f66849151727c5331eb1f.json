{
    "author": "lubieowoce",
    "message": "use FetchStrategy to control prefetching behavior everywhere (#82032)\n\nReplaces `includeDynamicData` and `PrefetchKind` with `FetchStrategy` wherever possible. We convert it from into a `PrefetchKind` in `router.prefetch()`, and back into a `PrefetchKind` when using the old prefetching implementation.",
    "sha": "75ce1d5bf270191a4a1f66849151727c5331eb1f",
    "files": [
        {
            "sha": "3639f5d469e43814b6583efc1f78673b943b963b",
            "filename": "packages/next/src/client/app-dir/form.tsx",
            "status": "modified",
            "additions": 8,
            "deletions": 2,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/75ce1d5bf270191a4a1f66849151727c5331eb1f/packages%2Fnext%2Fsrc%2Fclient%2Fapp-dir%2Fform.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/75ce1d5bf270191a4a1f66849151727c5331eb1f/packages%2Fnext%2Fsrc%2Fclient%2Fapp-dir%2Fform.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fapp-dir%2Fform.tsx?ref=75ce1d5bf270191a4a1f66849151727c5331eb1f",
            "patch": "@@ -7,7 +7,6 @@ import {\n   AppRouterContext,\n   type AppRouterInstance,\n } from '../../shared/lib/app-router-context.shared-runtime'\n-import { PrefetchKind } from '../components/router-reducer/router-reducer-types'\n import {\n   checkFormActionUrl,\n   createFormSubmitDestinationUrl,\n@@ -20,6 +19,7 @@ import {\n   mountFormInstance,\n   unmountPrefetchableInstance,\n } from '../components/links'\n+import { FetchStrategy } from '../components/segment-cache'\n \n export type { FormProps }\n \n@@ -99,7 +99,13 @@ export default function Form({\n   const observeFormVisibilityOnMount = useCallback(\n     (element: HTMLFormElement) => {\n       if (isPrefetchEnabled && router !== null) {\n-        mountFormInstance(element, actionProp, router, PrefetchKind.AUTO)\n+        mountFormInstance(\n+          element,\n+          actionProp,\n+          router,\n+          // We default to PPR. We'll discover whether or not the route supports it with the initial prefetch.\n+          FetchStrategy.PPR\n+        )\n       }\n       return () => {\n         unmountPrefetchableInstance(element)"
        },
        {
            "sha": "9c3b1e53dd8132de425d699239e0ebbf2ad6d07e",
            "filename": "packages/next/src/client/app-dir/link.tsx",
            "status": "modified",
            "additions": 7,
            "deletions": 6,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/75ce1d5bf270191a4a1f66849151727c5331eb1f/packages%2Fnext%2Fsrc%2Fclient%2Fapp-dir%2Flink.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/75ce1d5bf270191a4a1f66849151727c5331eb1f/packages%2Fnext%2Fsrc%2Fclient%2Fapp-dir%2Flink.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fapp-dir%2Flink.tsx?ref=75ce1d5bf270191a4a1f66849151727c5331eb1f",
            "patch": "@@ -4,7 +4,6 @@ import React, { createContext, useContext, useOptimistic, useRef } from 'react'\n import type { UrlObject } from 'url'\n import { formatUrl } from '../../shared/lib/router/utils/format-url'\n import { AppRouterContext } from '../../shared/lib/app-router-context.shared-runtime'\n-import { PrefetchKind } from '../components/router-reducer/router-reducer-types'\n import { useMergedRef } from '../use-merged-ref'\n import { isAbsoluteUrl } from '../../shared/lib/utils'\n import { addBasePath } from '../add-base-path'\n@@ -21,6 +20,7 @@ import {\n import { isLocalURL } from '../../shared/lib/router/utils/is-local-url'\n import { dispatchNavigateAction } from '../components/app-router-instance'\n import { errorOnce } from '../../shared/lib/utils/error-once'\n+import { FetchStrategy } from '../components/segment-cache'\n \n type Url = string | UrlObject\n type RequiredKeys<T> = {\n@@ -363,10 +363,11 @@ export default function LinkComponent(\n    * - false: we will not prefetch if in the viewport at all\n    * - 'unstable_dynamicOnHover': this starts in \"auto\" mode, but switches to \"full\" when the link is hovered\n    */\n-  const appPrefetchKind =\n+  const fetchStrategy =\n     prefetchProp === null || prefetchProp === 'auto'\n-      ? PrefetchKind.AUTO\n-      : PrefetchKind.FULL\n+      ? // We default to PPR. We'll discover whether or not the route supports it with the initial prefetch.\n+        FetchStrategy.PPR\n+      : FetchStrategy.Full\n \n   if (process.env.NODE_ENV !== 'production') {\n     function createPropError(args: {\n@@ -581,7 +582,7 @@ export default function LinkComponent(\n           element,\n           href,\n           router,\n-          appPrefetchKind,\n+          fetchStrategy,\n           prefetchEnabled,\n           setOptimisticLinkStatus\n         )\n@@ -595,7 +596,7 @@ export default function LinkComponent(\n         unmountPrefetchableInstance(element)\n       }\n     },\n-    [prefetchEnabled, href, router, appPrefetchKind, setOptimisticLinkStatus]\n+    [prefetchEnabled, href, router, fetchStrategy, setOptimisticLinkStatus]\n   )\n \n   const mergedRef = useMergedRef(observeLinkVisibilityOnMount, childRef)"
        },
        {
            "sha": "a431a9e3a3505d24ceced1a7f29c0c4ee8fe9ba9",
            "filename": "packages/next/src/client/components/app-router-instance.ts",
            "status": "modified",
            "additions": 33,
            "deletions": 2,
            "changes": 35,
            "blob_url": "https://github.com/vercel/next.js/blob/75ce1d5bf270191a4a1f66849151727c5331eb1f/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fapp-router-instance.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/75ce1d5bf270191a4a1f66849151727c5331eb1f/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fapp-router-instance.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fapp-router-instance.ts?ref=75ce1d5bf270191a4a1f66849151727c5331eb1f",
            "patch": "@@ -14,7 +14,11 @@ import {\n import { reducer } from './router-reducer/router-reducer'\n import { startTransition } from 'react'\n import { isThenable } from '../../shared/lib/is-thenable'\n-import { prefetch as prefetchWithSegmentCache } from './segment-cache'\n+import {\n+  FetchStrategy,\n+  prefetch as prefetchWithSegmentCache,\n+  type PrefetchTaskFetchStrategy,\n+} from './segment-cache'\n import { dispatchAppRouterAction } from './use-action-queue'\n import { addBasePath } from '../add-base-path'\n import { createPrefetchURL, isExternalURL } from './app-router'\n@@ -323,11 +327,38 @@ export const publicAppRouterInstance: AppRouterInstance = {\n       // cache. So we don't need to dispatch an action.\n       (href: string, options?: PrefetchOptions) => {\n         const actionQueue = getAppRouterActionQueue()\n+        const prefetchKind = options?.kind ?? PrefetchKind.AUTO\n+\n+        let fetchStrategy: PrefetchTaskFetchStrategy\n+        switch (prefetchKind) {\n+          case PrefetchKind.AUTO: {\n+            // We default to PPR. We'll discover whether or not the route supports it with the initial prefetch.\n+            fetchStrategy = FetchStrategy.PPR\n+            break\n+          }\n+          case PrefetchKind.FULL: {\n+            fetchStrategy = FetchStrategy.Full\n+            break\n+          }\n+          case PrefetchKind.TEMPORARY: {\n+            // This concept doesn't exist in the segment cache implementation.\n+            return\n+          }\n+          default: {\n+            prefetchKind satisfies never\n+            // Despite typescript thinking that this can't happen,\n+            // we might get an unexpected value from user code.\n+            // We don't know what they want, but we know they want a prefetch,\n+            // so use the default.\n+            fetchStrategy = FetchStrategy.PPR\n+          }\n+        }\n+\n         prefetchWithSegmentCache(\n           href,\n           actionQueue.state.nextUrl,\n           actionQueue.state.tree,\n-          options?.kind === PrefetchKind.FULL,\n+          fetchStrategy,\n           options?.onInvalidate ?? null\n         )\n       }"
        },
        {
            "sha": "378078407ee139374e216c82bd374f20ad507faf",
            "filename": "packages/next/src/client/components/links.ts",
            "status": "modified",
            "additions": 35,
            "deletions": 13,
            "changes": 48,
            "blob_url": "https://github.com/vercel/next.js/blob/75ce1d5bf270191a4a1f66849151727c5331eb1f/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Flinks.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/75ce1d5bf270191a4a1f66849151727c5331eb1f/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Flinks.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Flinks.ts?ref=75ce1d5bf270191a4a1f66849151727c5331eb1f",
            "patch": "@@ -2,8 +2,11 @@ import type { FlightRouterState } from '../../server/app-render/types'\n import type { AppRouterInstance } from '../../shared/lib/app-router-context.shared-runtime'\n import { getCurrentAppRouterState } from './app-router-instance'\n import { createPrefetchURL } from './app-router'\n-import { PrefetchKind } from './router-reducer/router-reducer-types'\n-import { isPrefetchTaskDirty } from './segment-cache'\n+import {\n+  FetchStrategy,\n+  isPrefetchTaskDirty,\n+  type PrefetchTaskFetchStrategy,\n+} from './segment-cache'\n import { createCacheKey } from './segment-cache'\n import {\n   type PrefetchTask,\n@@ -13,6 +16,7 @@ import {\n   reschedulePrefetchTask,\n } from './segment-cache'\n import { startTransition } from 'react'\n+import { PrefetchKind } from './router-reducer/router-reducer-types'\n \n type LinkElement = HTMLAnchorElement | SVGAElement\n \n@@ -22,7 +26,7 @@ type Element = LinkElement | HTMLFormElement\n // shape for both to prevent a polymorphic de-opt in the VM.\n type LinkOrFormInstanceShared = {\n   router: AppRouterInstance\n-  kind: PrefetchKind.AUTO | PrefetchKind.FULL\n+  fetchStrategy: PrefetchTaskFetchStrategy\n \n   isVisible: boolean\n \n@@ -140,7 +144,7 @@ export function mountLinkInstance(\n   element: LinkElement,\n   href: string,\n   router: AppRouterInstance,\n-  kind: PrefetchKind.AUTO | PrefetchKind.FULL,\n+  fetchStrategy: PrefetchTaskFetchStrategy,\n   prefetchEnabled: boolean,\n   setOptimisticLinkStatus: (status: { pending: boolean }) => void\n ): LinkInstance {\n@@ -149,7 +153,7 @@ export function mountLinkInstance(\n     if (prefetchURL !== null) {\n       const instance: PrefetchableLinkInstance = {\n         router,\n-        kind,\n+        fetchStrategy,\n         isVisible: false,\n         prefetchTask: null,\n         prefetchHref: prefetchURL.href,\n@@ -165,7 +169,7 @@ export function mountLinkInstance(\n   // track its optimistic state (i.e. useLinkStatus).\n   const instance: NonPrefetchableLinkInstance = {\n     router,\n-    kind,\n+    fetchStrategy,\n     isVisible: false,\n     prefetchTask: null,\n     prefetchHref: null,\n@@ -178,7 +182,7 @@ export function mountFormInstance(\n   element: HTMLFormElement,\n   href: string,\n   router: AppRouterInstance,\n-  kind: PrefetchKind.AUTO | PrefetchKind.FULL\n+  fetchStrategy: PrefetchTaskFetchStrategy\n ): void {\n   const prefetchURL = coercePrefetchableUrl(href)\n   if (prefetchURL === null) {\n@@ -190,7 +194,7 @@ export function mountFormInstance(\n   }\n   const instance: FormInstance = {\n     router,\n-    kind,\n+    fetchStrategy,\n     isVisible: false,\n     prefetchTask: null,\n     prefetchHref: prefetchURL.href,\n@@ -261,7 +265,7 @@ export function onNavigationIntent(\n       unstable_upgradeToDynamicPrefetch\n     ) {\n       // Switch to a full, dynamic prefetch\n-      instance.kind = PrefetchKind.FULL\n+      instance.fetchStrategy = FetchStrategy.Full\n     }\n     rescheduleLinkPrefetch(instance, PrefetchPriority.Intent)\n   }\n@@ -303,7 +307,7 @@ function rescheduleLinkPrefetch(\n       instance.prefetchTask = scheduleSegmentPrefetchTask(\n         cacheKey,\n         treeAtTimeOfPrefetch,\n-        instance.kind === PrefetchKind.FULL,\n+        instance.fetchStrategy,\n         priority,\n         null\n       )\n@@ -313,7 +317,7 @@ function rescheduleLinkPrefetch(\n       reschedulePrefetchTask(\n         existingPrefetchTask,\n         treeAtTimeOfPrefetch,\n-        instance.kind === PrefetchKind.FULL,\n+        instance.fetchStrategy,\n         priority\n       )\n     }\n@@ -347,7 +351,7 @@ export function pingVisibleLinks(\n     instance.prefetchTask = scheduleSegmentPrefetchTask(\n       cacheKey,\n       tree,\n-      instance.kind === PrefetchKind.FULL,\n+      instance.fetchStrategy,\n       PrefetchPriority.Default,\n       null\n     )\n@@ -363,8 +367,26 @@ function prefetchWithOldCacheImplementation(instance: PrefetchableInstance) {\n   const doPrefetch = async () => {\n     // note that `appRouter.prefetch()` is currently sync,\n     // so we have to wrap this call in an async function to be able to catch() errors below.\n+\n+    let prefetchKind: PrefetchKind\n+    switch (instance.fetchStrategy) {\n+      case FetchStrategy.PPR: {\n+        prefetchKind = PrefetchKind.AUTO\n+        break\n+      }\n+      case FetchStrategy.Full: {\n+        prefetchKind = PrefetchKind.FULL\n+        break\n+      }\n+      default: {\n+        instance.fetchStrategy satisfies never\n+        // Unreachable, but otherwise typescript will consider the variable unassigned\n+        prefetchKind = undefined!\n+      }\n+    }\n+\n     return instance.router.prefetch(instance.prefetchHref, {\n-      kind: instance.kind,\n+      kind: prefetchKind,\n     })\n   }\n "
        },
        {
            "sha": "67daaf21af6706632bb292d47bae2d2ddb18ef31",
            "filename": "packages/next/src/client/components/segment-cache-impl/cache.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 7,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/75ce1d5bf270191a4a1f66849151727c5331eb1f/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/75ce1d5bf270191a4a1f66849151727c5331eb1f/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts?ref=75ce1d5bf270191a4a1f66849151727c5331eb1f",
            "patch": "@@ -63,6 +63,7 @@ import {\n   DOC_PREFETCH_RANGE_HEADER_VALUE,\n   doesExportedHtmlMatchBuildId,\n } from '../../../shared/lib/segment-cache/output-export-prefetch-encoding'\n+import { FetchStrategy } from '../segment-cache'\n \n // A note on async/await when working in the prefetch cache:\n //\n@@ -165,12 +166,6 @@ export type RouteCacheEntry =\n   | FulfilledRouteCacheEntry\n   | RejectedRouteCacheEntry\n \n-export const enum FetchStrategy {\n-  PPR,\n-  Full,\n-  LoadingBoundary,\n-}\n-\n type SegmentCacheEntryShared = {\n   staleAt: number\n   fetchStrategy: FetchStrategy\n@@ -415,7 +410,8 @@ export function getSegmentKeypathForTask(\n   // If we're fetching using PPR, we do not need to include the search params in\n   // the cache key, because the search params are treated as dynamic data. The\n   // cache entry is valid for all possible search param values.\n-  const isDynamicTask = task.includeDynamicData || !route.isPPREnabled\n+  const isDynamicTask =\n+    task.fetchStrategy === FetchStrategy.Full || !route.isPPREnabled\n   return isDynamicTask && path.endsWith('/' + PAGE_SEGMENT_KEY)\n     ? [path, route.renderedSearch]\n     : [path]"
        },
        {
            "sha": "ab82b6350ae91b6d057f5cb4eae24f2f72f0389c",
            "filename": "packages/next/src/client/components/segment-cache-impl/prefetch.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 5,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/75ce1d5bf270191a4a1f66849151727c5331eb1f/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fprefetch.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/75ce1d5bf270191a4a1f66849151727c5331eb1f/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fprefetch.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fprefetch.ts?ref=75ce1d5bf270191a4a1f66849151727c5331eb1f",
            "patch": "@@ -2,7 +2,10 @@ import type { FlightRouterState } from '../../../server/app-render/types'\n import { createPrefetchURL } from '../app-router'\n import { createCacheKey } from './cache-key'\n import { schedulePrefetchTask } from './scheduler'\n-import { PrefetchPriority } from '../segment-cache'\n+import {\n+  PrefetchPriority,\n+  type PrefetchTaskFetchStrategy,\n+} from '../segment-cache'\n \n /**\n  * Entrypoint for prefetching a URL into the Segment Cache.\n@@ -12,8 +15,8 @@ import { PrefetchPriority } from '../segment-cache'\n  * Roughly corresponds to the current URL.\n  * @param treeAtTimeOfPrefetch - The FlightRouterState at the time the prefetch\n  * was requested. This is only used when PPR is disabled.\n- * @param includeDynamicData - Whether to prefetch dynamic data, in addition to\n- * static data. This is used by <Link prefetch={true}>.\n+ * @param fetchStrategy - Whether to prefetch dynamic data, in addition to\n+ * static data. This is used by `<Link prefetch={true}>`.\n  * @param onInvalidate - A callback that will be called when the prefetch cache\n  * When called, it signals to the listener that the data associated with the\n  * prefetch may have been invalidated from the cache. This is not a live\n@@ -28,7 +31,7 @@ export function prefetch(\n   href: string,\n   nextUrl: string | null,\n   treeAtTimeOfPrefetch: FlightRouterState,\n-  includeDynamicData: boolean,\n+  fetchStrategy: PrefetchTaskFetchStrategy,\n   onInvalidate: null | (() => void)\n ) {\n   const url = createPrefetchURL(href)\n@@ -40,7 +43,7 @@ export function prefetch(\n   schedulePrefetchTask(\n     cacheKey,\n     treeAtTimeOfPrefetch,\n-    includeDynamicData,\n+    fetchStrategy,\n     PrefetchPriority.Default,\n     onInvalidate\n   )"
        },
        {
            "sha": "05df92bb7bdf9cd8e9d44c493d750d37d7ece09e",
            "filename": "packages/next/src/client/components/segment-cache-impl/scheduler.ts",
            "status": "modified",
            "additions": 26,
            "deletions": 16,
            "changes": 42,
            "blob_url": "https://github.com/vercel/next.js/blob/75ce1d5bf270191a4a1f66849151727c5331eb1f/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fscheduler.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/75ce1d5bf270191a4a1f66849151727c5331eb1f/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fscheduler.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fscheduler.ts?ref=75ce1d5bf270191a4a1f66849151727c5331eb1f",
            "patch": "@@ -18,7 +18,6 @@ import {\n   fetchSegmentPrefetchesUsingDynamicRequest,\n   type PendingSegmentCacheEntry,\n   convertRouteTreeToFlightRouterState,\n-  FetchStrategy,\n   readOrCreateRevalidatingSegmentEntry,\n   upsertSegmentEntry,\n   type FulfilledSegmentCacheEntry,\n@@ -28,7 +27,12 @@ import {\n   getSegmentKeypathForTask,\n } from './cache'\n import type { RouteCacheKey } from './cache-key'\n-import { getCurrentCacheVersion, PrefetchPriority } from '../segment-cache'\n+import {\n+  getCurrentCacheVersion,\n+  PrefetchPriority,\n+  FetchStrategy,\n+  type PrefetchTaskFetchStrategy,\n+} from '../segment-cache'\n import {\n   addSearchParamsIfPageSegment,\n   PAGE_SEGMENT_KEY,\n@@ -64,9 +68,13 @@ export type PrefetchTask = {\n \n   /**\n    * Whether to prefetch dynamic data, in addition to static data. This is\n-   * used by <Link prefetch={true}>.\n+   * used by `<Link prefetch={true}>`.\n+   *\n+   * Note that a task with `FetchStrategy.PPR` might need to use\n+   * `FetchStrategy.LoadingBoundary` instead if we find out that a route\n+   * does not support PPR after doing the initial route prefetch.\n    */\n-  includeDynamicData: boolean\n+  fetchStrategy: PrefetchTaskFetchStrategy\n \n   /**\n    * sortId is an incrementing counter\n@@ -194,13 +202,13 @@ let mostRecentlyHoveredLink: PrefetchTask | null = null\n  *\n  * @param key The RouteCacheKey to prefetch.\n  * @param treeAtTimeOfPrefetch The app's current FlightRouterState\n- * @param includeDynamicData Whether to prefetch dynamic data, in addition to\n- * static data. This is used by <Link prefetch={true}>.\n+ * @param fetchStrategy Whether to prefetch dynamic data, in addition to\n+ * static data. This is used by `<Link prefetch={true}>`.\n  */\n export function schedulePrefetchTask(\n   key: RouteCacheKey,\n   treeAtTimeOfPrefetch: FlightRouterState,\n-  includeDynamicData: boolean,\n+  fetchStrategy: PrefetchTaskFetchStrategy,\n   priority: PrefetchPriority,\n   onInvalidate: null | (() => void)\n ): PrefetchTask {\n@@ -212,7 +220,7 @@ export function schedulePrefetchTask(\n     priority,\n     phase: PrefetchPhase.RouteTree,\n     hasBackgroundWork: false,\n-    includeDynamicData,\n+    fetchStrategy,\n     sortId: sortIdCounter++,\n     isCanceled: false,\n     onInvalidate,\n@@ -248,7 +256,7 @@ export function cancelPrefetchTask(task: PrefetchTask): void {\n export function reschedulePrefetchTask(\n   task: PrefetchTask,\n   treeAtTimeOfPrefetch: FlightRouterState,\n-  includeDynamicData: boolean,\n+  fetchStrategy: PrefetchTaskFetchStrategy,\n   priority: PrefetchPriority\n ): void {\n   // Bump the prefetch task to the top of the queue, as if it were a fresh\n@@ -271,7 +279,7 @@ export function reschedulePrefetchTask(\n     task === mostRecentlyHoveredLink ? PrefetchPriority.Intent : priority\n \n   task.treeAtTimeOfPrefetch = treeAtTimeOfPrefetch\n-  task.includeDynamicData = includeDynamicData\n+  task.fetchStrategy = fetchStrategy\n \n   trackMostRecentlyHoveredLink(task)\n \n@@ -550,12 +558,14 @@ function pingRootRouteTree(\n       }\n       const tree = route.tree\n \n-      // Determine which fetch strategy to use for this prefetch task.\n-      const fetchStrategy = task.includeDynamicData\n-        ? FetchStrategy.Full\n-        : route.isPPREnabled\n-          ? FetchStrategy.PPR\n-          : FetchStrategy.LoadingBoundary\n+      // A task's fetch strategy gets set to `PPR` for any \"auto\" prefetch.\n+      // If it turned out that the route isn't PPR-enabled, we need to use `LoadingBoundary` instead.\n+      const fetchStrategy =\n+        task.fetchStrategy === FetchStrategy.PPR\n+          ? route.isPPREnabled\n+            ? FetchStrategy.PPR\n+            : FetchStrategy.LoadingBoundary\n+          : task.fetchStrategy\n \n       switch (fetchStrategy) {\n         case FetchStrategy.PPR:"
        },
        {
            "sha": "b6665fe4a063092f3ebf5d67ada5907501c3045f",
            "filename": "packages/next/src/client/components/segment-cache.ts",
            "status": "modified",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/75ce1d5bf270191a4a1f66849151727c5331eb1f/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/75ce1d5bf270191a4a1f66849151727c5331eb1f/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache.ts?ref=75ce1d5bf270191a4a1f66849151727c5331eb1f",
            "patch": "@@ -140,3 +140,17 @@ export const enum PrefetchPriority {\n    */\n   Background = 0,\n }\n+\n+export const enum FetchStrategy {\n+  PPR,\n+  Full,\n+  LoadingBoundary,\n+}\n+\n+/**\n+ * A subset of fetch strategies used for prefetch tasks.\n+ * A prefetch task can't know if it should use `PPR` or `LoadingBoundary`\n+ * until we complete the initial tree prefetch request, so we use `PPR` to signal both cases\n+ * and adjust it based on the route when actually fetching.\n+ * */\n+export type PrefetchTaskFetchStrategy = FetchStrategy.PPR | FetchStrategy.Full"
        }
    ],
    "stats": {
        "total": 185,
        "additions": 134,
        "deletions": 51
    }
}