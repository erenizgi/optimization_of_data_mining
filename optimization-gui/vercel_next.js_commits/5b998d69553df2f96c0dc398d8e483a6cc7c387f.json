{
    "author": "wyattjoh",
    "message": "fix: revert client segment route changes for sub shell generation (#81740)\n\n### What?\n\nImplements a new sortable routes system that distinguishes between\nsource pages and rendered pages for sub-shell generation.\n\n### Why?\n\nThe existing route sorting logic in Next.js doesn't account for the\ndistinction between the original page definition (`sourcePage`) and the\nfinal rendered route (`page`). This is critical for sub-shell\ngeneration, given this example:\n\n| Page | Source Page |\n|--------|--------|\n| `/en/[teamSlug]/[projectSlug]/monitoring` |\n`/[lang]/[teamSlug]/[projectSlug]/monitoring` |\n| `/fr/[teamSlug]/[projectSlug]/monitoring` |\n`/[lang]/[teamSlug]/[projectSlug]/monitoring` |\n| `/[lang]/[teamSlug]/~/monitoring` | `/[lang]/[teamSlug]/~/monitoring`\n|\n\nAnd a request to `/en/vercel/~/monitoring` that it will hit the\n`/[lang]/[teamSlug]/~/monitoring` page instead of the\n`/en/[teamSlug]/[projectSlug]/monitoring`. This is because we first need\nto sort by the Source Page and then the Page to ensure that the correct\nroute ordering is respected.\n\n### How?\n\n- Adds new `SortableRoute` type that tracks both `sourcePage` and `page`\n- Implements depth-first route comparison algorithm that properly\nhandles segment specificity\n- Refactors build process to use the new sorting functions instead of\nlegacy `getSortedRoutes`\n- Adds source page tracking for PPR-enabled routes with\n`clientSegmentEnabled`\n- Includes comprehensive test coverage for all route sorting scenarios\n\nThe new sorting algorithm ensures consistent route ordering across\nbuilds and proper sub-shell generation behavior.",
    "sha": "5b998d69553df2f96c0dc398d8e483a6cc7c387f",
    "files": [
        {
            "sha": "ad187953e6d3f6684577e5dba960f155400c4a80",
            "filename": "packages/next/src/build/index.ts",
            "status": "modified",
            "additions": 73,
            "deletions": 36,
            "changes": 109,
            "blob_url": "https://github.com/vercel/next.js/blob/5b998d69553df2f96c0dc398d8e483a6cc7c387f/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/5b998d69553df2f96c0dc398d8e483a6cc7c387f/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts?ref=5b998d69553df2f96c0dc398d8e483a6cc7c387f",
            "patch": "@@ -81,11 +81,7 @@ import {\n   DYNAMIC_CSS_MANIFEST,\n   TURBOPACK_CLIENT_MIDDLEWARE_MANIFEST,\n } from '../shared/lib/constants'\n-import {\n-  getSortedRoutes,\n-  isDynamicRoute,\n-  getSortedRouteObjects,\n-} from '../shared/lib/router/utils'\n+import { isDynamicRoute } from '../shared/lib/router/utils'\n import type { __ApiPreviewProps } from '../server/api-utils'\n import loadConfig from '../server/config'\n import type { BuildManifest } from '../server/get-page-files'\n@@ -210,6 +206,11 @@ import { extractNextErrorCode } from '../lib/error-telemetry-utils'\n import { runAfterProductionCompile } from './after-production-compile'\n import { generatePreviewKeys } from './preview-key-utils'\n import { handleBuildComplete } from './adapter/build-complete'\n+import {\n+  sortPageObjects,\n+  sortPages,\n+  sortSortableRouteObjects,\n+} from '../shared/lib/router/utils/sortable-routes'\n \n type Fallback = null | boolean | string\n \n@@ -430,7 +431,7 @@ export type RoutesManifest = {\n   }\n   headers: Array<ManifestHeaderRoute>\n   staticRoutes: Array<ManifestRoute>\n-  dynamicRoutes: Array<ManifestRoute>\n+  dynamicRoutes: ReadonlyArray<ManifestRoute>\n   dataRoutes: Array<ManifestDataRoute>\n   i18n?: {\n     domains?: ReadonlyArray<{\n@@ -1328,14 +1329,20 @@ export default async function build(\n       const isAppPPREnabled = checkIsAppPPREnabled(config.experimental.ppr)\n \n       const routesManifestPath = path.join(distDir, ROUTES_MANIFEST)\n+      const dynamicRoutes: Array<ManifestRoute> = []\n+\n+      /**\n+       * A map of all the pages to their sourcePage value. This is only used for\n+       * routes that have PPR enabled and clientSegmentEnabled is true.\n+       */\n+      const sourcePages = new Map<string, string>()\n       const routesManifest: RoutesManifest = nextBuildSpan\n         .traceChild('generate-routes-manifest')\n         .traceFn(() => {\n-          const sortedRoutes = getSortedRoutes([\n+          const sortedRoutes = sortPages([\n             ...pageKeys.pages,\n             ...(pageKeys.app ?? []),\n           ])\n-          const dynamicRoutes: Array<ManifestRoute> = []\n           const staticRoutes: Array<ManifestRoute> = []\n \n           for (const route of sortedRoutes) {\n@@ -2466,7 +2473,7 @@ export default async function build(\n       if (serverPropsPages.size > 0 || ssgPages.size > 0) {\n         // We update the routes manifest after the build with the\n         // data routes since we can't determine these until after build\n-        routesManifest.dataRoutes = getSortedRoutes([\n+        routesManifest.dataRoutes = sortPages([\n           ...serverPropsPages,\n           ...ssgPages,\n         ]).map((page) => {\n@@ -2930,39 +2937,39 @@ export default async function build(\n             // route), any routes that were generated with unknown route params\n             // should be collected and included in the dynamic routes part\n             // of the manifest instead.\n-            const routes: PrerenderedRoute[] = []\n-            const dynamicRoutes: PrerenderedRoute[] = []\n+            const staticPrerenderedRoutes: PrerenderedRoute[] = []\n+            const dynamicPrerenderedRoutes: PrerenderedRoute[] = []\n \n             // Sort the outputted routes to ensure consistent output. Any route\n             // though that has unknown route params will be pulled and sorted\n             // independently. This is because the routes with unknown route\n             // params will contain the dynamic path parameters, some of which\n             // may conflict with the actual prerendered routes.\n-            let unknownPrerenderRoutes: PrerenderedRoute[] = []\n-            let knownPrerenderRoutes: PrerenderedRoute[] = []\n+            const unsortedUnknownPrerenderRoutes: PrerenderedRoute[] = []\n+            const unsortedKnownPrerenderRoutes: PrerenderedRoute[] = []\n             for (const prerenderedRoute of prerenderedRoutes) {\n               if (\n                 prerenderedRoute.fallbackRouteParams &&\n                 prerenderedRoute.fallbackRouteParams.length > 0\n               ) {\n-                unknownPrerenderRoutes.push(prerenderedRoute)\n+                unsortedUnknownPrerenderRoutes.push(prerenderedRoute)\n               } else {\n-                knownPrerenderRoutes.push(prerenderedRoute)\n+                unsortedKnownPrerenderRoutes.push(prerenderedRoute)\n               }\n             }\n \n-            unknownPrerenderRoutes = getSortedRouteObjects(\n-              unknownPrerenderRoutes,\n+            const sortedUnknownPrerenderRoutes = sortPageObjects(\n+              unsortedUnknownPrerenderRoutes,\n               (prerenderedRoute) => prerenderedRoute.pathname\n             )\n-            knownPrerenderRoutes = getSortedRouteObjects(\n-              knownPrerenderRoutes,\n+            const sortedKnownPrerenderRoutes = sortPageObjects(\n+              unsortedKnownPrerenderRoutes,\n               (prerenderedRoute) => prerenderedRoute.pathname\n             )\n \n             prerenderedRoutes = [\n-              ...knownPrerenderRoutes,\n-              ...unknownPrerenderRoutes,\n+              ...sortedKnownPrerenderRoutes,\n+              ...sortedUnknownPrerenderRoutes,\n             ]\n \n             for (const prerenderedRoute of prerenderedRoutes) {\n@@ -2979,16 +2986,16 @@ export default async function build(\n               ) {\n                 // If the route has unknown params, then we need to add it to\n                 // the list of dynamic routes.\n-                dynamicRoutes.push(prerenderedRoute)\n+                dynamicPrerenderedRoutes.push(prerenderedRoute)\n               } else {\n                 // If the route doesn't have unknown params, then we need to\n-                // add it to the list of routes.\n-                routes.push(prerenderedRoute)\n+                // add it to the list of static routes.\n+                staticPrerenderedRoutes.push(prerenderedRoute)\n               }\n             }\n \n             // Handle all the static routes.\n-            for (const route of routes) {\n+            for (const route of staticPrerenderedRoutes) {\n               if (isDynamicRoute(page) && route.pathname === page) continue\n               if (route.pathname === UNDERSCORE_NOT_FOUND_ROUTE) continue\n \n@@ -3075,7 +3082,7 @@ export default async function build(\n               // they are enabled, then it'll already be included in the\n               // prerendered routes.\n               if (!isRoutePPREnabled) {\n-                dynamicRoutes.push({\n+                dynamicPrerenderedRoutes.push({\n                   params: {},\n                   pathname: page,\n                   encodedPathname: page,\n@@ -3088,7 +3095,7 @@ export default async function build(\n                 })\n               }\n \n-              for (const route of dynamicRoutes) {\n+              for (const route of dynamicPrerenderedRoutes) {\n                 const normalizedRoute = normalizePagePath(route.pathname)\n \n                 const metadata = exportResult.byPath.get(\n@@ -3103,18 +3110,43 @@ export default async function build(\n                 }\n \n                 let prefetchDataRoute: string | undefined\n+                let dynamicRoute = routesManifest.dynamicRoutes.find(\n+                  (r) => r.page === route.pathname\n+                )\n                 if (!isAppRouteHandler && isAppPPREnabled) {\n                   prefetchDataRoute = path.posix.join(\n                     `${normalizedRoute}${RSC_PREFETCH_SUFFIX}`\n                   )\n+\n+                  // If the dynamic route wasn't found, then we need to create\n+                  // it. This ensures that for each fallback shell there's an\n+                  // entry in the app routes manifest which enables routing for\n+                  // this fallback shell.\n+                  if (!dynamicRoute) {\n+                    dynamicRoute = pageToRoute(route.pathname)\n+                    sourcePages.set(route.pathname, page)\n+\n+                    // This route is not for the internal router, but instead\n+                    // for external routers.\n+                    dynamicRoute.skipInternalRouting = true\n+\n+                    // Push this to the end of the array. The dynamic routes are\n+                    // sorted by page later.\n+                    dynamicRoutes.push(dynamicRoute)\n+                  }\n                 }\n \n                 if (!isAppRouteHandler && metadata?.segmentPaths) {\n-                  const dynamicRoute = routesManifest.dynamicRoutes.find(\n-                    (r) => r.page === page\n-                  )\n+                  // If PPR isn't enabled, then we might not find the dynamic\n+                  // route by pathname. If that's the case, we need to find the\n+                  // route by page.\n                   if (!dynamicRoute) {\n-                    throw new InvariantError('Dynamic route not found')\n+                    dynamicRoute = dynamicRoutes.find((r) => r.page === page)\n+\n+                    // If it can't be found by page, we must throw an error.\n+                    if (!dynamicRoute) {\n+                      throw new InvariantError('Dynamic route not found')\n+                    }\n                   }\n \n                   dynamicRoute.prefetchSegmentDataRoutes ??= []\n@@ -3573,11 +3605,16 @@ export default async function build(\n           }\n         })\n \n-        // As we may have modified the routesManifest.dynamicRoutes, we need to\n-        // sort the dynamic routes by page.\n-        routesManifest.dynamicRoutes = getSortedRouteObjects(\n-          routesManifest.dynamicRoutes,\n-          (route) => route.page\n+        // As we may have modified the dynamicRoutes, we need to sort the\n+        // dynamic routes by page.\n+        routesManifest.dynamicRoutes = sortSortableRouteObjects(\n+          dynamicRoutes,\n+          (route) => ({\n+            // If the route is PPR enabled, and has an associated source page,\n+            // use it. Otherwise fallback to the page which should be the same.\n+            sourcePage: sourcePages.get(route.page) ?? route.page,\n+            page: route.page,\n+          })\n         )\n \n         // Now write the routes manifest out."
        },
        {
            "sha": "f437b6afeb2b9a748a6dad63b053b7aaa1ff0288",
            "filename": "packages/next/src/server/config-shared.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/5b998d69553df2f96c0dc398d8e483a6cc7c387f/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/5b998d69553df2f96c0dc398d8e483a6cc7c387f/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts?ref=5b998d69553df2f96c0dc398d8e483a6cc7c387f",
            "patch": "@@ -18,6 +18,7 @@ import type {\n   ManifestHeaderRoute,\n   ManifestRedirectRoute,\n   RouteType,\n+  ManifestRoute,\n } from '../build'\n import { isStableBuild } from '../shared/lib/canary-only'\n \n@@ -63,7 +64,7 @@ export interface NextAdapter {\n         afterFiles: Array<ManifestRewriteRoute>\n         fallback: Array<ManifestRewriteRoute>\n       }\n-      dynamicRoutes: Array<{}>\n+      dynamicRoutes: ReadonlyArray<ManifestRoute>\n     }\n     outputs: AdapterOutputs\n   }) => Promise<void> | void"
        },
        {
            "sha": "c60392b835ef3f5e6cbadcb9b7159475b0d76c7b",
            "filename": "packages/next/src/shared/lib/router/utils/sortable-routes.test.ts",
            "status": "added",
            "additions": 1014,
            "deletions": 0,
            "changes": 1014,
            "blob_url": "https://github.com/vercel/next.js/blob/5b998d69553df2f96c0dc398d8e483a6cc7c387f/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Fsortable-routes.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/5b998d69553df2f96c0dc398d8e483a6cc7c387f/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Fsortable-routes.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Fsortable-routes.test.ts?ref=5b998d69553df2f96c0dc398d8e483a6cc7c387f",
            "patch": "@@ -0,0 +1,1014 @@\n+import {\n+  sortSortableRoutes,\n+  sortSortableRouteObjects,\n+  sortPageObjects,\n+  sortPages,\n+  getSegmentSpecificity,\n+  compareRouteSegments,\n+  type SortableRoute,\n+} from './sortable-routes'\n+\n+describe('sortSortableRoutes', () => {\n+  it('should sort routes by page', () => {\n+    const routes: SortableRoute[] = [\n+      {\n+        sourcePage: '/[lang]/[teamSlug]/[projectSlug]/monitoring',\n+        page: '/[lang]/[teamSlug]/[projectSlug]/monitoring',\n+      },\n+      {\n+        sourcePage: '/[lang]/[teamSlug]/[projectSlug]/monitoring',\n+        page: '/en/[teamSlug]/[projectSlug]/monitoring',\n+      },\n+      {\n+        sourcePage: '/[lang]/[teamSlug]/~/monitoring',\n+        page: '/[lang]/[teamSlug]/~/monitoring',\n+      },\n+      {\n+        sourcePage: '/[lang]/[teamSlug]/[projectSlug]/monitoring',\n+        page: '/fr/[teamSlug]/[projectSlug]/monitoring',\n+      },\n+    ]\n+\n+    const sorted = sortSortableRoutes(routes)\n+\n+    expect(sorted).toEqual([\n+      {\n+        sourcePage: '/[lang]/[teamSlug]/~/monitoring',\n+        page: '/[lang]/[teamSlug]/~/monitoring',\n+      },\n+      {\n+        sourcePage: '/[lang]/[teamSlug]/[projectSlug]/monitoring',\n+        page: '/en/[teamSlug]/[projectSlug]/monitoring',\n+      },\n+      {\n+        sourcePage: '/[lang]/[teamSlug]/[projectSlug]/monitoring',\n+        page: '/fr/[teamSlug]/[projectSlug]/monitoring',\n+      },\n+      {\n+        sourcePage: '/[lang]/[teamSlug]/[projectSlug]/monitoring',\n+        page: '/[lang]/[teamSlug]/[projectSlug]/monitoring',\n+      },\n+    ])\n+  })\n+\n+  it('should sort routes by specificity with different parameter types', () => {\n+    const routes: SortableRoute[] = [\n+      {\n+        sourcePage: '/docs/[[...slug]]',\n+        page: '/docs/[[...slug]]',\n+      },\n+      {\n+        sourcePage: '/docs/[...slug]',\n+        page: '/docs/[...slug]',\n+      },\n+      {\n+        sourcePage: '/docs/[slug]',\n+        page: '/docs/[slug]',\n+      },\n+      {\n+        sourcePage: '/docs/api',\n+        page: '/docs/api',\n+      },\n+    ]\n+\n+    const sorted = sortSortableRoutes(routes)\n+\n+    expect(sorted).toEqual([\n+      {\n+        sourcePage: '/docs/api',\n+        page: '/docs/api',\n+      },\n+      {\n+        sourcePage: '/docs/[slug]',\n+        page: '/docs/[slug]',\n+      },\n+      {\n+        sourcePage: '/docs/[...slug]',\n+        page: '/docs/[...slug]',\n+      },\n+      {\n+        sourcePage: '/docs/[[...slug]]',\n+        page: '/docs/[[...slug]]',\n+      },\n+    ])\n+  })\n+\n+  it('should prioritize source over page in sorting', () => {\n+    const routes: SortableRoute[] = [\n+      {\n+        sourcePage: '/[lang]/[...slug]',\n+        page: '/en/docs/api',\n+      },\n+      {\n+        sourcePage: '/en/docs',\n+        page: '/[lang]/[...slug]',\n+      },\n+    ]\n+\n+    const sorted = sortSortableRoutes(routes)\n+\n+    expect(sorted).toEqual([\n+      {\n+        sourcePage: '/en/docs',\n+        page: '/[lang]/[...slug]',\n+      },\n+      {\n+        sourcePage: '/[lang]/[...slug]',\n+        page: '/en/docs/api',\n+      },\n+    ])\n+  })\n+\n+  it('should handle mixed route lengths correctly', () => {\n+    const routes: SortableRoute[] = [\n+      {\n+        sourcePage: '/api/[...path]',\n+        page: '/api/[...path]',\n+      },\n+      {\n+        sourcePage: '/api',\n+        page: '/api',\n+      },\n+      {\n+        sourcePage: '/api/users/[id]',\n+        page: '/api/users/[id]',\n+      },\n+      {\n+        sourcePage: '/api/users',\n+        page: '/api/users',\n+      },\n+    ]\n+\n+    const sorted = sortSortableRoutes(routes)\n+\n+    expect(sorted).toEqual([\n+      {\n+        sourcePage: '/api',\n+        page: '/api',\n+      },\n+      {\n+        sourcePage: '/api/users',\n+        page: '/api/users',\n+      },\n+      {\n+        sourcePage: '/api/users/[id]',\n+        page: '/api/users/[id]',\n+      },\n+      {\n+        sourcePage: '/api/[...path]',\n+        page: '/api/[...path]',\n+      },\n+    ])\n+  })\n+\n+  it('should sort lexicographically when specificity is equal', () => {\n+    const routes: SortableRoute[] = [\n+      {\n+        sourcePage: '/[lang]/zebra',\n+        page: '/[lang]/zebra',\n+      },\n+      {\n+        sourcePage: '/[lang]/apple',\n+        page: '/[lang]/apple',\n+      },\n+      {\n+        sourcePage: '/[lang]/banana',\n+        page: '/[lang]/banana',\n+      },\n+    ]\n+\n+    const sorted = sortSortableRoutes(routes)\n+\n+    expect(sorted).toEqual([\n+      {\n+        sourcePage: '/[lang]/apple',\n+        page: '/[lang]/apple',\n+      },\n+      {\n+        sourcePage: '/[lang]/banana',\n+        page: '/[lang]/banana',\n+      },\n+      {\n+        sourcePage: '/[lang]/zebra',\n+        page: '/[lang]/zebra',\n+      },\n+    ])\n+  })\n+\n+  it('should handle empty routes array', () => {\n+    const routes: SortableRoute[] = []\n+    const sorted = sortSortableRoutes(routes)\n+    expect(sorted).toEqual([])\n+  })\n+\n+  it('should handle single route', () => {\n+    const routes: SortableRoute[] = [\n+      {\n+        sourcePage: '/api/users/[id]',\n+        page: '/api/users/[id]',\n+      },\n+    ]\n+\n+    const sorted = sortSortableRoutes(routes)\n+\n+    expect(sorted).toEqual([\n+      {\n+        sourcePage: '/api/users/[id]',\n+        page: '/api/users/[id]',\n+      },\n+    ])\n+  })\n+\n+  it('should handle identical routes', () => {\n+    const routes: SortableRoute[] = [\n+      {\n+        sourcePage: '/api/users',\n+        page: '/api/users',\n+      },\n+      {\n+        sourcePage: '/api/users',\n+        page: '/api/users',\n+      },\n+    ]\n+\n+    const sorted = sortSortableRoutes(routes)\n+\n+    expect(sorted).toEqual([\n+      {\n+        sourcePage: '/api/users',\n+        page: '/api/users',\n+      },\n+      {\n+        sourcePage: '/api/users',\n+        page: '/api/users',\n+      },\n+    ])\n+  })\n+\n+  it('should handle complex nested routes with different parameter types', () => {\n+    const routes: SortableRoute[] = [\n+      {\n+        sourcePage: '/[lang]/blog/[[...slug]]',\n+        page: '/[lang]/blog/[[...slug]]',\n+      },\n+      {\n+        sourcePage: '/[lang]/blog/[slug]',\n+        page: '/[lang]/blog/[slug]',\n+      },\n+      {\n+        sourcePage: '/en/blog/[slug]',\n+        page: '/en/blog/[slug]',\n+      },\n+      {\n+        sourcePage: '/en/blog',\n+        page: '/en/blog',\n+      },\n+      {\n+        sourcePage: '/[lang]/blog',\n+        page: '/[lang]/blog',\n+      },\n+      {\n+        sourcePage: '/[lang]/blog/[...slug]',\n+        page: '/[lang]/blog/[...slug]',\n+      },\n+    ]\n+\n+    const sorted = sortSortableRoutes(routes)\n+\n+    expect(sorted).toEqual([\n+      {\n+        sourcePage: '/en/blog',\n+        page: '/en/blog',\n+      },\n+      {\n+        sourcePage: '/en/blog/[slug]',\n+        page: '/en/blog/[slug]',\n+      },\n+      {\n+        sourcePage: '/[lang]/blog',\n+        page: '/[lang]/blog',\n+      },\n+      {\n+        sourcePage: '/[lang]/blog/[slug]',\n+        page: '/[lang]/blog/[slug]',\n+      },\n+      {\n+        sourcePage: '/[lang]/blog/[...slug]',\n+        page: '/[lang]/blog/[...slug]',\n+      },\n+      {\n+        sourcePage: '/[lang]/blog/[[...slug]]',\n+        page: '/[lang]/blog/[[...slug]]',\n+      },\n+    ])\n+  })\n+})\n+\n+describe('sortSortableRouteObjects', () => {\n+  it('should sort objects by sourcePage and page while preserving object references', () => {\n+    interface TestRoute {\n+      id: string\n+      sourcePage: string\n+      page: string\n+      data: string\n+    }\n+\n+    const objects: TestRoute[] = [\n+      {\n+        id: '1',\n+        sourcePage: '/[lang]/[slug]',\n+        page: '/[lang]/[slug]',\n+        data: 'dynamic',\n+      },\n+      {\n+        id: '2',\n+        sourcePage: '/api/users',\n+        page: '/api/users',\n+        data: 'static',\n+      },\n+      {\n+        id: '3',\n+        sourcePage: '/[lang]/blog',\n+        page: '/[lang]/blog',\n+        data: 'partial',\n+      },\n+      { id: '4', sourcePage: '/api', page: '/api', data: 'root' },\n+    ]\n+\n+    const sorted = sortSortableRouteObjects(objects, (obj) => ({\n+      sourcePage: obj.sourcePage,\n+      page: obj.page,\n+    }))\n+\n+    expect(sorted).toEqual([\n+      { id: '4', sourcePage: '/api', page: '/api', data: 'root' },\n+      {\n+        id: '2',\n+        sourcePage: '/api/users',\n+        page: '/api/users',\n+        data: 'static',\n+      },\n+      {\n+        id: '3',\n+        sourcePage: '/[lang]/blog',\n+        page: '/[lang]/blog',\n+        data: 'partial',\n+      },\n+      {\n+        id: '1',\n+        sourcePage: '/[lang]/[slug]',\n+        page: '/[lang]/[slug]',\n+        data: 'dynamic',\n+      },\n+    ])\n+\n+    // Verify object references are preserved\n+    expect(sorted[0]).toBe(objects[3])\n+    expect(sorted[1]).toBe(objects[1])\n+    expect(sorted[2]).toBe(objects[2])\n+    expect(sorted[3]).toBe(objects[0])\n+  })\n+\n+  it('should handle objects with different source and page paths', () => {\n+    interface PrerenderedRoute {\n+      page: string\n+      metadata: { type: string }\n+    }\n+\n+    const routes: PrerenderedRoute[] = [\n+      { page: '/blog/post-1', metadata: { type: 'static' } },\n+      { page: '/blog/[slug]', metadata: { type: 'dynamic' } },\n+      { page: '/api/[...path]', metadata: { type: 'catchall' } },\n+      { page: '/api/users', metadata: { type: 'api' } },\n+    ]\n+\n+    const sorted = sortSortableRouteObjects(routes, (route) => ({\n+      sourcePage: route.page,\n+      page: route.page,\n+    }))\n+\n+    expect(sorted.map((r) => r.page)).toEqual([\n+      '/api/users',\n+      '/api/[...path]',\n+      '/blog/post-1',\n+      '/blog/[slug]',\n+    ])\n+\n+    // Verify metadata is preserved\n+    expect(sorted[0].metadata.type).toBe('api')\n+    expect(sorted[1].metadata.type).toBe('catchall')\n+    expect(sorted[2].metadata.type).toBe('static')\n+    expect(sorted[3].metadata.type).toBe('dynamic')\n+  })\n+\n+  it('should sort by sourcePage first, then page as tiebreaker', () => {\n+    interface RouteWithDifferentPages {\n+      name: string\n+      source: string\n+      rendered: string\n+    }\n+\n+    const objects: RouteWithDifferentPages[] = [\n+      { name: 'route-1', source: '/[lang]/docs', rendered: '/fr/docs' },\n+      { name: 'route-2', source: '/[lang]/docs', rendered: '/en/docs' },\n+      { name: 'route-3', source: '/en/docs', rendered: '/[lang]/docs' },\n+      { name: 'route-4', source: '/[lang]/docs', rendered: '/[lang]/docs' },\n+    ]\n+\n+    const sorted = sortSortableRouteObjects(objects, (obj) => ({\n+      sourcePage: obj.source,\n+      page: obj.rendered,\n+    }))\n+\n+    expect(sorted.map((r) => r.name)).toEqual([\n+      'route-3', // static source wins\n+      'route-2', // same dynamic source, but '/en/docs' < '/fr/docs'\n+      'route-1', // same dynamic source, but '/fr/docs' > '/en/docs'\n+      'route-4', // same dynamic source, fully dynamic page last\n+    ])\n+  })\n+\n+  it('should handle complex route specificity ordering', () => {\n+    const objects = [\n+      { id: 'optional-catchall', path: '/docs/[[...slug]]' },\n+      { id: 'catchall', path: '/docs/[...slug]' },\n+      { id: 'dynamic', path: '/docs/[slug]' },\n+      { id: 'static-nested', path: '/docs/api/auth' },\n+      { id: 'static-mid', path: '/docs/api' },\n+      { id: 'static-root', path: '/docs' },\n+    ]\n+\n+    const sorted = sortSortableRouteObjects(objects, (obj) => ({\n+      sourcePage: obj.path,\n+      page: obj.path,\n+    }))\n+\n+    expect(sorted.map((r) => r.id)).toEqual([\n+      'static-root', // '/docs' - most specific (shortest + static)\n+      'static-mid', // '/docs/api' - static segment\n+      'static-nested', // '/docs/api/auth' - longer static path\n+      'dynamic', // '/docs/[slug]' - dynamic segment\n+      'catchall', // '/docs/[...slug]' - catch-all\n+      'optional-catchall', // '/docs/[[...slug]]' - optional catch-all (least specific)\n+    ])\n+  })\n+\n+  it('should not mutate the input array', () => {\n+    const objects = [\n+      { id: 3, route: '/api/[id]' },\n+      { id: 1, route: '/api' },\n+      { id: 2, route: '/api/users' },\n+    ]\n+\n+    const originalOrder = [...objects]\n+\n+    const sorted = sortSortableRouteObjects(objects, (obj) => ({\n+      sourcePage: obj.route,\n+      page: obj.route,\n+    }))\n+\n+    // Original array should be unchanged\n+    expect(objects).toEqual(originalOrder)\n+\n+    // Sorted array should be different\n+    expect(sorted.map((r) => r.id)).toEqual([1, 2, 3])\n+  })\n+\n+  it('should handle empty array', () => {\n+    const objects: any[] = []\n+\n+    const sorted = sortSortableRouteObjects(objects, (obj) => ({\n+      sourcePage: obj.path,\n+      page: obj.path,\n+    }))\n+\n+    expect(sorted).toEqual([])\n+  })\n+\n+  it('should handle single object', () => {\n+    const objects = [{ name: 'only', path: '/api/users/[id]' }]\n+\n+    const sorted = sortSortableRouteObjects(objects, (obj) => ({\n+      sourcePage: obj.path,\n+      page: obj.path,\n+    }))\n+\n+    expect(sorted).toEqual([{ name: 'only', path: '/api/users/[id]' }])\n+    expect(sorted[0]).toBe(objects[0]) // Same reference\n+  })\n+\n+  it('should handle duplicate route patterns with different objects', () => {\n+    const objects = [\n+      { type: 'layout', pattern: '/[lang]/blog' },\n+      { type: 'page', pattern: '/[lang]/blog' },\n+      { type: 'api', pattern: '/[lang]/blog' },\n+    ]\n+\n+    const sorted = sortSortableRouteObjects(objects, (obj) => ({\n+      sourcePage: obj.pattern,\n+      page: obj.pattern,\n+    }))\n+\n+    // All should have same route, so original order preserved (stable sort)\n+    expect(sorted).toEqual(objects)\n+    expect(sorted[0]).toBe(objects[0])\n+    expect(sorted[1]).toBe(objects[1])\n+    expect(sorted[2]).toBe(objects[2])\n+  })\n+\n+  it('should work with getter function that creates new objects each time', () => {\n+    // This test specifically covers the bug that was fixed in the WeakMap version\n+    const objects = [\n+      { page: '/blog/[slug]' },\n+      { page: '/blog/post-1' },\n+      { page: '/api/[...params]' },\n+    ]\n+\n+    // Getter that creates new objects each time (like in the build process)\n+    const sorted = sortSortableRouteObjects(objects, (obj) => ({\n+      sourcePage: obj.page, // New object created each call\n+      page: obj.page,\n+    }))\n+\n+    expect(sorted.map((r) => r.page)).toEqual([\n+      '/api/[...params]', // Catch-all at root level comes first in this context\n+      '/blog/post-1', // Static segment\n+      '/blog/[slug]', // Dynamic segment\n+    ])\n+\n+    // Verify original objects are returned, not new ones\n+    expect(sorted[1]).toBe(objects[1]) // post-1 object reference preserved\n+  })\n+\n+  it('should handle mixed route depths correctly', () => {\n+    const objects = [\n+      { name: 'deep-catchall', route: '/api/v1/[...path]' },\n+      { name: 'root', route: '/' },\n+      { name: 'shallow-dynamic', route: '/[slug]' },\n+      { name: 'mid-static', route: '/api/users' },\n+      { name: 'deep-static', route: '/api/v1/auth/login' },\n+    ]\n+\n+    const sorted = sortSortableRouteObjects(objects, (obj) => ({\n+      sourcePage: obj.route,\n+      page: obj.route,\n+    }))\n+\n+    expect(sorted.map((r) => r.name)).toEqual([\n+      'root', // '/' - shortest and static\n+      'mid-static', // '/api/users' - static segment before dynamic\n+      'deep-static', // '/api/v1/auth/login' - longest static\n+      'deep-catchall', // '/api/v1/[...path]' - catch-all\n+      'shallow-dynamic', // '/[slug]' - dynamic comes after static\n+    ])\n+  })\n+\n+  it('should sort lexicographically when all other factors are equal', () => {\n+    const objects = [\n+      { letter: 'z', route: '/[lang]/zebra' },\n+      { letter: 'a', route: '/[lang]/apple' },\n+      { letter: 'm', route: '/[lang]/mango' },\n+      { letter: 'b', route: '/[lang]/banana' },\n+    ]\n+\n+    const sorted = sortSortableRouteObjects(objects, (obj) => ({\n+      sourcePage: obj.route,\n+      page: obj.route,\n+    }))\n+\n+    expect(sorted.map((r) => r.letter)).toEqual(['a', 'b', 'm', 'z'])\n+  })\n+})\n+\n+describe('sortPageObjects', () => {\n+  it('should handle duplicate pages correctly (bug fix)', () => {\n+    // This test specifically covers the bug that was fixed where duplicate pages\n+    // would overwrite each other in the indexes object\n+    const objects = [\n+      { id: 'first', type: 'layout', route: '/blog/[slug]' },\n+      { id: 'second', type: 'page', route: '/blog/post-1' },\n+      { id: 'third', type: 'page', route: '/blog/[slug]' }, // Same route as first\n+      { id: 'fourth', type: 'api', route: '/api/users' },\n+      { id: 'fifth', type: 'middleware', route: '/blog/[slug]' }, // Same route as first and third\n+    ]\n+\n+    const sorted = sortPageObjects(objects, (obj) => obj.route)\n+\n+    // Should preserve all objects, even those with duplicate routes\n+    expect(sorted.length).toBe(5)\n+\n+    // Should be sorted by route specificity\n+    expect(sorted.map((r) => r.id)).toEqual([\n+      'fourth', // '/api/users' - static, most specific\n+      'second', // '/blog/post-1' - static\n+      'first', // '/blog/[slug]' - dynamic (first occurrence)\n+      'third', // '/blog/[slug]' - dynamic (second occurrence)\n+      'fifth', // '/blog/[slug]' - dynamic (third occurrence)\n+    ])\n+\n+    // Verify all objects are preserved with their original properties\n+    expect(sorted[0]).toEqual({\n+      id: 'fourth',\n+      type: 'api',\n+      route: '/api/users',\n+    })\n+    expect(sorted[1]).toEqual({\n+      id: 'second',\n+      type: 'page',\n+      route: '/blog/post-1',\n+    })\n+    expect(sorted[2]).toEqual({\n+      id: 'first',\n+      type: 'layout',\n+      route: '/blog/[slug]',\n+    })\n+    expect(sorted[3]).toEqual({\n+      id: 'third',\n+      type: 'page',\n+      route: '/blog/[slug]',\n+    })\n+    expect(sorted[4]).toEqual({\n+      id: 'fifth',\n+      type: 'middleware',\n+      route: '/blog/[slug]',\n+    })\n+  })\n+\n+  it('should sort pages by specificity', () => {\n+    const objects = [\n+      { name: 'catchall', path: '/docs/[...slug]' },\n+      { name: 'static', path: '/docs/api' },\n+      { name: 'dynamic', path: '/docs/[slug]' },\n+      { name: 'optional', path: '/docs/[[...slug]]' },\n+    ]\n+\n+    const sorted = sortPageObjects(objects, (obj) => obj.path)\n+\n+    expect(sorted.map((r) => r.name)).toEqual([\n+      'static', // '/docs/api' - static segment\n+      'dynamic', // '/docs/[slug]' - dynamic segment\n+      'catchall', // '/docs/[...slug]' - catch-all\n+      'optional', // '/docs/[[...slug]]' - optional catch-all\n+    ])\n+  })\n+\n+  it('should maintain original order for identical routes (stable sort)', () => {\n+    const objects = [\n+      { id: 'a', route: '/same' },\n+      { id: 'b', route: '/same' },\n+      { id: 'c', route: '/same' },\n+    ]\n+\n+    const sorted = sortPageObjects(objects, (obj) => obj.route)\n+\n+    expect(sorted.map((r) => r.id)).toEqual(['a', 'b', 'c'])\n+  })\n+\n+  it('should handle mixed route depths', () => {\n+    const objects = [\n+      { name: 'deep', route: '/api/v1/users/[id]' },\n+      { name: 'shallow', route: '/[slug]' },\n+      { name: 'root', route: '/' },\n+      { name: 'mid', route: '/api/users' },\n+    ]\n+\n+    const sorted = sortPageObjects(objects, (obj) => obj.route)\n+\n+    expect(sorted.map((r) => r.name)).toEqual([\n+      'root', // '/' - shortest and static\n+      'mid', // '/api/users' - static\n+      'deep', // '/api/v1/users/[id]' - longer static path before dynamic\n+      'shallow', // '/[slug]' - dynamic\n+    ])\n+  })\n+\n+  it('should sort lexicographically when specificity is equal', () => {\n+    const objects = [\n+      { letter: 'z', route: '/zebra' },\n+      { letter: 'a', route: '/apple' },\n+      { letter: 'm', route: '/mango' },\n+    ]\n+\n+    const sorted = sortPageObjects(objects, (obj) => obj.route)\n+\n+    expect(sorted.map((r) => r.letter)).toEqual(['a', 'm', 'z'])\n+  })\n+\n+  it('should handle empty array', () => {\n+    const objects: any[] = []\n+    const sorted = sortPageObjects(objects, (obj) => obj.route)\n+    expect(sorted).toEqual([])\n+  })\n+\n+  it('should handle single object', () => {\n+    const objects = [{ name: 'only', route: '/single' }]\n+    const sorted = sortPageObjects(objects, (obj) => obj.route)\n+    expect(sorted).toEqual([{ name: 'only', route: '/single' }])\n+  })\n+\n+  it('should not mutate the input array', () => {\n+    const objects = [\n+      { id: 2, route: '/dynamic/[id]' },\n+      { id: 1, route: '/static' },\n+    ]\n+    const originalOrder = [...objects]\n+\n+    const sorted = sortPageObjects(objects, (obj) => obj.route)\n+\n+    // Original array should be unchanged\n+    expect(objects).toEqual(originalOrder)\n+\n+    // Sorted array should be different - '/dynamic/[id]' comes before '/static' lexicographically\n+    expect(sorted.map((r) => r.id)).toEqual([2, 1])\n+  })\n+\n+  it('should handle many duplicate routes efficiently', () => {\n+    // Test with many duplicates to ensure the fix handles large datasets\n+    const objects = []\n+    for (let i = 0; i < 100; i++) {\n+      objects.push({ id: i, route: '/blog/[slug]' })\n+    }\n+    objects.push({ id: 'static', route: '/blog/about' })\n+\n+    const sorted = sortPageObjects(objects, (obj) => obj.route)\n+\n+    // Should preserve all objects\n+    expect(sorted.length).toBe(101)\n+\n+    // Static route should come first\n+    expect(sorted[0].id).toBe('static')\n+\n+    // All dynamic routes should follow in original order\n+    for (let i = 1; i < 101; i++) {\n+      expect(sorted[i].id).toBe(i - 1)\n+    }\n+  })\n+})\n+\n+describe('sortPages', () => {\n+  it('should sort pages by specificity', () => {\n+    const pages = [\n+      '/docs/[[...slug]]',\n+      '/docs/[...slug]',\n+      '/docs/[slug]',\n+      '/docs/api',\n+      '/docs',\n+    ]\n+\n+    const sorted = sortPages(pages)\n+\n+    expect(sorted).toEqual([\n+      '/docs',\n+      '/docs/api',\n+      '/docs/[slug]',\n+      '/docs/[...slug]',\n+      '/docs/[[...slug]]',\n+    ])\n+  })\n+\n+  it('should handle mixed route depths', () => {\n+    const pages = [\n+      '/api/v1/[...path]',\n+      '/[slug]',\n+      '/',\n+      '/api/users/[id]',\n+      '/api',\n+    ]\n+\n+    const sorted = sortPages(pages)\n+\n+    expect(sorted).toEqual([\n+      '/',\n+      '/api',\n+      '/api/users/[id]',\n+      '/api/v1/[...path]',\n+      '/[slug]',\n+    ])\n+  })\n+\n+  it('should sort lexicographically when specificity is equal', () => {\n+    const pages = ['/zebra', '/apple', '/mango']\n+\n+    const sorted = sortPages(pages)\n+\n+    expect(sorted).toEqual(['/apple', '/mango', '/zebra'])\n+  })\n+\n+  it('should handle empty array', () => {\n+    const pages: string[] = []\n+    const sorted = sortPages(pages)\n+    expect(sorted).toEqual([])\n+  })\n+\n+  it('should handle single page', () => {\n+    const pages = ['/single']\n+    const sorted = sortPages(pages)\n+    expect(sorted).toEqual(['/single'])\n+  })\n+\n+  it('should not mutate the input array', () => {\n+    const pages = ['/static', '/dynamic/[id]']\n+    const originalOrder = [...pages]\n+\n+    const sorted = sortPages(pages)\n+\n+    // Original array should be unchanged\n+    expect(pages).toEqual(originalOrder)\n+\n+    // Sorted array should be different - '/dynamic/[id]' comes before '/static' lexicographically\n+    expect(sorted).toEqual(['/dynamic/[id]', '/static'])\n+  })\n+\n+  it('should handle duplicate pages', () => {\n+    const pages = [\n+      '/blog/[slug]',\n+      '/blog/post-1',\n+      '/blog/[slug]',\n+      '/blog/[slug]',\n+    ]\n+\n+    const sorted = sortPages(pages)\n+\n+    expect(sorted).toEqual([\n+      '/blog/post-1',\n+      '/blog/[slug]',\n+      '/blog/[slug]',\n+      '/blog/[slug]',\n+    ])\n+  })\n+\n+  it('should handle complex nested routes', () => {\n+    const pages = [\n+      '/[lang]/blog/[[...slug]]',\n+      '/en/blog/[slug]',\n+      '/[lang]/blog/[slug]',\n+      '/en/blog',\n+      '/[lang]/blog',\n+      '/[lang]/blog/[...slug]',\n+    ]\n+\n+    const sorted = sortPages(pages)\n+\n+    expect(sorted).toEqual([\n+      '/en/blog',\n+      '/en/blog/[slug]',\n+      '/[lang]/blog',\n+      '/[lang]/blog/[slug]',\n+      '/[lang]/blog/[...slug]',\n+      '/[lang]/blog/[[...slug]]',\n+    ])\n+  })\n+})\n+\n+describe('getSegmentSpecificity', () => {\n+  it('should return 0 for static segments', () => {\n+    expect(getSegmentSpecificity('api')).toBe(0)\n+    expect(getSegmentSpecificity('users')).toBe(0)\n+    expect(getSegmentSpecificity('dashboard')).toBe(0)\n+    expect(getSegmentSpecificity('123')).toBe(0)\n+    expect(getSegmentSpecificity('about-us')).toBe(0)\n+  })\n+\n+  it('should return 1 for dynamic segments', () => {\n+    expect(getSegmentSpecificity('[id]')).toBe(1)\n+    expect(getSegmentSpecificity('[slug]')).toBe(1)\n+    expect(getSegmentSpecificity('[userId]')).toBe(1)\n+    expect(getSegmentSpecificity('[post-id]')).toBe(1)\n+  })\n+\n+  it('should return 2 for catch-all segments', () => {\n+    expect(getSegmentSpecificity('[...slug]')).toBe(2)\n+    expect(getSegmentSpecificity('[...path]')).toBe(2)\n+    expect(getSegmentSpecificity('[...params]')).toBe(2)\n+  })\n+\n+  it('should return 3 for optional catch-all segments', () => {\n+    expect(getSegmentSpecificity('[[...slug]]')).toBe(3)\n+    expect(getSegmentSpecificity('[[...path]]')).toBe(3)\n+    expect(getSegmentSpecificity('[[...params]]')).toBe(3)\n+  })\n+\n+  it('should handle edge cases', () => {\n+    expect(getSegmentSpecificity('')).toBe(0)\n+    expect(getSegmentSpecificity('[')).toBe(0) // Malformed bracket\n+    expect(getSegmentSpecificity(']')).toBe(0) // Malformed bracket\n+    expect(getSegmentSpecificity('[id')).toBe(0) // Missing closing bracket\n+    expect(getSegmentSpecificity('id]')).toBe(0) // Missing opening bracket\n+    expect(getSegmentSpecificity('[[...slug]')).toBe(1) // Malformed optional catch-all - treated as dynamic\n+    expect(getSegmentSpecificity('[...slug]]')).toBe(2) // Malformed optional catch-all - treated as catch-all\n+  })\n+\n+  it('should handle segments with brackets but not dynamic routes', () => {\n+    expect(getSegmentSpecificity('api[version]')).toBe(0) // Contains brackets but not a dynamic route\n+    expect(getSegmentSpecificity('users[admin]')).toBe(0)\n+  })\n+})\n+\n+describe('compareRouteSegments', () => {\n+  it('should prioritize shorter routes', () => {\n+    expect(compareRouteSegments('/api', '/api/users')).toBe(-1)\n+    expect(compareRouteSegments('/api/users', '/api')).toBe(1)\n+    expect(compareRouteSegments('/', '/about')).toBe(-1)\n+    expect(compareRouteSegments('/about', '/')).toBe(1)\n+  })\n+\n+  it('should prioritize static over dynamic segments', () => {\n+    expect(compareRouteSegments('/api/users', '/api/[id]')).toBe(-1)\n+    expect(compareRouteSegments('/api/[id]', '/api/users')).toBe(1)\n+    expect(compareRouteSegments('/blog/about', '/blog/[slug]')).toBe(-1)\n+  })\n+\n+  it('should prioritize dynamic over catch-all segments', () => {\n+    expect(compareRouteSegments('/api/[id]', '/api/[...path]')).toBe(-1)\n+    expect(compareRouteSegments('/api/[...path]', '/api/[id]')).toBe(1)\n+    expect(compareRouteSegments('/docs/[slug]', '/docs/[...slug]')).toBe(-1)\n+  })\n+\n+  it('should prioritize catch-all over optional catch-all segments', () => {\n+    expect(compareRouteSegments('/docs/[...slug]', '/docs/[[...slug]]')).toBe(\n+      -1\n+    )\n+    expect(compareRouteSegments('/docs/[[...slug]]', '/docs/[...slug]')).toBe(1)\n+  })\n+\n+  it('should handle complete specificity hierarchy', () => {\n+    const routes = [\n+      '/docs/[[...slug]]',\n+      '/docs/[...slug]',\n+      '/docs/[slug]',\n+      '/docs/api',\n+    ]\n+\n+    const sorted = routes.sort(compareRouteSegments)\n+    expect(sorted).toEqual([\n+      '/docs/api', // Static - most specific\n+      '/docs/[slug]', // Dynamic\n+      '/docs/[...slug]', // Catch-all\n+      '/docs/[[...slug]]', // Optional catch-all - least specific\n+    ])\n+  })\n+\n+  it('should sort lexicographically when specificity is equal', () => {\n+    expect(compareRouteSegments('/api/zebra', '/api/apple')).toBe(1)\n+    expect(compareRouteSegments('/api/apple', '/api/zebra')).toBe(-1)\n+    expect(compareRouteSegments('/[lang]/zebra', '/[lang]/apple')).toBe(1)\n+    expect(compareRouteSegments('/[lang]/apple', '/[lang]/zebra')).toBe(-1)\n+  })\n+\n+  it('should handle identical routes', () => {\n+    expect(compareRouteSegments('/api/users', '/api/users')).toBe(0)\n+    expect(compareRouteSegments('/[lang]/[slug]', '/[lang]/[slug]')).toBe(0)\n+    expect(compareRouteSegments('/docs/[...slug]', '/docs/[...slug]')).toBe(0)\n+  })\n+\n+  it('should handle empty paths', () => {\n+    expect(compareRouteSegments('', '')).toBe(0)\n+    expect(compareRouteSegments('', '/api')).toBe(-1)\n+    expect(compareRouteSegments('/api', '')).toBe(1)\n+  })\n+\n+  it('should handle root path', () => {\n+    expect(compareRouteSegments('/', '/api')).toBe(-1)\n+    expect(compareRouteSegments('/api', '/')).toBe(1)\n+    expect(compareRouteSegments('/', '/')).toBe(0)\n+  })\n+\n+  it('should handle paths with leading/trailing slashes consistently', () => {\n+    expect(compareRouteSegments('/api/users/', '/api/users')).toBe(0)\n+    expect(compareRouteSegments('api/users', '/api/users')).toBe(0)\n+    expect(compareRouteSegments('/api/users/', 'api/users')).toBe(0)\n+  })\n+\n+  it('should handle complex nested comparisons', () => {\n+    expect(compareRouteSegments('/[lang]/blog/[slug]', '/en/blog/[slug]')).toBe(\n+      1\n+    )\n+    expect(compareRouteSegments('/en/blog/[slug]', '/[lang]/blog/[slug]')).toBe(\n+      -1\n+    )\n+    expect(\n+      compareRouteSegments('/[lang]/blog/[...slug]', '/[lang]/blog/[slug]')\n+    ).toBe(1)\n+  })\n+\n+  it('should handle mixed depths with different specificities', () => {\n+    const routes = [\n+      '/api/v1/users/[id]/posts/[...slug]',\n+      '/api/v1/users/[id]/posts',\n+      '/api/v1/users/[id]',\n+      '/api/v1/users',\n+      '/api/v1',\n+      '/api',\n+    ]\n+\n+    const sorted = routes.sort(compareRouteSegments)\n+    expect(sorted).toEqual([\n+      '/api',\n+      '/api/v1',\n+      '/api/v1/users',\n+      '/api/v1/users/[id]',\n+      '/api/v1/users/[id]/posts',\n+      '/api/v1/users/[id]/posts/[...slug]',\n+    ])\n+  })\n+})"
        },
        {
            "sha": "9d1340f03ab4dfeaa713dd70f90cca56538c1821",
            "filename": "packages/next/src/shared/lib/router/utils/sortable-routes.ts",
            "status": "added",
            "additions": 242,
            "deletions": 0,
            "changes": 242,
            "blob_url": "https://github.com/vercel/next.js/blob/5b998d69553df2f96c0dc398d8e483a6cc7c387f/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Fsortable-routes.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/5b998d69553df2f96c0dc398d8e483a6cc7c387f/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Fsortable-routes.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Fsortable-routes.ts?ref=5b998d69553df2f96c0dc398d8e483a6cc7c387f",
            "patch": "@@ -0,0 +1,242 @@\n+/**\n+ * A route that can be sorted by specificity.\n+ */\n+export type SortableRoute = {\n+  /**\n+   * The source page of the route. This represents the original page that's on\n+   * disk. For example, the `app/[lang]/[...rest]/page.tsx` would have a source\n+   * page of '/[lang]/[...rest]'.\n+   */\n+  readonly sourcePage: string\n+\n+  /**\n+   * The page of the route. This represents the final rendered route. For\n+   * example, the `app/[lang]/[...rest]/page.tsx` that was rendered with a lang\n+   * value of `en` would have a page of '/en/[...rest]'.\n+   */\n+  readonly page: string\n+}\n+\n+/**\n+ * Determines the specificity of a route segment for sorting purposes.\n+ *\n+ * In Next.js routing, more specific routes should match before less specific ones.\n+ * This function returns a numeric value where lower numbers indicate higher specificity.\n+ *\n+ * Specificity order (most to least specific):\n+ * 1. Static segments (e.g., \"about\", \"api\") - return 0\n+ * 2. Dynamic segments (e.g., \"[id]\", \"[slug]\") - return 1\n+ * 3. Catch-all segments (e.g., \"[...slug]\") - return 2\n+ * 4. Optional catch-all segments (e.g., \"[[...slug]]\") - return 3\n+ *\n+ * @param segment - A single path segment (e.g., \"api\", \"[id]\", \"[...slug]\")\n+ * @returns A numeric specificity value (0-3, where 0 is most specific)\n+ */\n+export function getSegmentSpecificity(segment: string): number {\n+  // Static segments are most specific - they match exactly one path\n+  if (!segment.includes('[')) {\n+    return 0\n+  }\n+\n+  // Optional catch-all [[...param]] is least specific - matches zero or more segments\n+  if (segment.startsWith('[[...') && segment.endsWith(']]')) {\n+    return 3\n+  }\n+\n+  // Catch-all [...param] is less specific - matches one or more segments\n+  if (segment.startsWith('[...') && segment.endsWith(']')) {\n+    return 2\n+  }\n+\n+  // Regular dynamic [param] is more specific than catch-all - matches exactly one segment\n+  if (segment.startsWith('[') && segment.endsWith(']')) {\n+    return 1\n+  }\n+\n+  // Default to static (fallback case)\n+  return 0\n+}\n+\n+/**\n+ * Compares two route paths using a depth-first traversal approach.\n+ *\n+ * This function implements a deterministic comparison that sorts routes by specificity:\n+ * 1. More specific routes come first (fewer dynamic segments)\n+ * 2. Shorter routes are more specific than longer ones\n+ * 3. Routes with same specificity are sorted lexicographically\n+ *\n+ * The comparison is done segment by segment, left to right, similar to how\n+ * you would traverse a route tree in depth-first order.\n+ *\n+ * @param pathA - First route path to compare (e.g., \"/api/users/[id]\")\n+ * @param pathB - Second route path to compare (e.g., \"/api/[...slug]\")\n+ * @returns Negative if pathA is more specific, positive if pathB is more specific, 0 if equal\n+ */\n+export function compareRouteSegments(pathA: string, pathB: string): number {\n+  // Split paths into segments, removing empty strings from leading/trailing slashes\n+  const segmentsA = pathA.split('/').filter(Boolean)\n+  const segmentsB = pathB.split('/').filter(Boolean)\n+\n+  // Compare segment by segment up to the length of the longer path\n+  const maxLength = Math.max(segmentsA.length, segmentsB.length)\n+\n+  for (let i = 0; i < maxLength; i++) {\n+    const segA = segmentsA[i] || ''\n+    const segB = segmentsB[i] || ''\n+\n+    // Handle length differences: shorter routes are MORE specific\n+    // Example: \"/api\" is more specific than \"/api/users\"\n+    if (!segA && segB) return -1 // pathA is shorter, so more specific\n+    if (segA && !segB) return 1 // pathB is shorter, so more specific\n+    if (!segA && !segB) return 0 // Both paths ended, they're equal\n+\n+    // Compare segment specificity using our specificity scoring\n+    const specificityA = getSegmentSpecificity(segA)\n+    const specificityB = getSegmentSpecificity(segB)\n+\n+    // Lower specificity number = more specific route\n+    // Example: \"api\" (0) vs \"[slug]\" (1) - \"api\" wins\n+    if (specificityA !== specificityB) {\n+      return specificityA - specificityB\n+    }\n+\n+    // If segments have same specificity, compare lexicographically for determinism\n+    // Example: \"[id]\" vs \"[slug]\" - \"[id]\" comes first alphabetically\n+    if (segA !== segB) {\n+      return segA.localeCompare(segB)\n+    }\n+\n+    // Segments are identical, continue to next segment\n+  }\n+\n+  // All segments compared equally\n+  return 0\n+}\n+\n+/**\n+ * Compares two complete routes for sorting purposes.\n+ *\n+ * Routes are compared with a two-tier priority system:\n+ * 1. Primary: Compare by source path specificity\n+ * 2. Secondary: If sources are equal, compare by page path specificity\n+ *\n+ * This ensures that routes are primarily organized by their source patterns,\n+ * with page-specific variations grouped together.\n+ *\n+ * @param a - First route to compare\n+ * @param b - Second route to compare\n+ * @returns Negative if route a should come first, positive if route b should come first, 0 if equal\n+ */\n+function compareSortableRoutes(a: SortableRoute, b: SortableRoute): number {\n+  // First compare by source specificity - this is the primary sorting criterion\n+  // Source represents the original route pattern and takes precedence\n+  const sourceResult = compareRouteSegments(a.sourcePage, b.sourcePage)\n+  if (sourceResult !== 0) return sourceResult\n+\n+  // If sources are identical, compare by page specificity as a tiebreaker\n+  // Page represents the final rendered route and provides secondary ordering\n+  return compareRouteSegments(a.page, b.page)\n+}\n+\n+/**\n+ * Sorts an array of routes by specificity using a deterministic depth-first traversal approach.\n+ *\n+ * This function implements Next.js route matching priority where more specific routes\n+ * should be matched before less specific ones. The sorting is deterministic and stable,\n+ * meaning identical inputs will always produce identical outputs.\n+ *\n+ * Sorting criteria (in order of priority):\n+ * 1. Source path specificity (primary)\n+ * 2. Page path specificity (secondary)\n+ * 3. Lexicographic ordering (tertiary, for determinism)\n+ *\n+ * Examples of specificity order:\n+ * - \"/api/users\" (static) comes before \"/api/[slug]\" (dynamic)\n+ * - \"/api/[id]\" (dynamic) comes before \"/api/[...slug]\" (catch-all)\n+ * - \"/api/[...slug]\" (catch-all) comes before \"/api/[[...slug]]\" (optional catch-all)\n+ *\n+ * @param routes - Array of routes to sort\n+ * @returns New sorted array (does not mutate input)\n+ */\n+export function sortSortableRoutes(\n+  routes: readonly SortableRoute[]\n+): readonly SortableRoute[] {\n+  // Because sort is always in-place, we need to create a shallow copy to avoid\n+  // mutating the input array.\n+  return [...routes].sort(compareSortableRoutes)\n+}\n+\n+/**\n+ * Sorts an array of pages by specificity using a deterministic depth-first\n+ * traversal approach.\n+ *\n+ * @param pages - Array of pages to sort\n+ * @returns New sorted array (does not mutate input)\n+ */\n+export function sortPages(pages: readonly string[]): readonly string[] {\n+  // Because sort is always in-place, we need to create a shallow copy to avoid\n+  // mutating the input array.\n+  return [...pages].sort(compareRouteSegments)\n+}\n+\n+/**\n+ * Sorts an array of objects by sourcePage and page using a deterministic\n+ * depth-first traversal approach.\n+ *\n+ * @param objects - Array of objects to sort\n+ * @param getter - Function to get the sourcePage and page from an object\n+ * @returns New sorted array (does not mutate input)\n+ */\n+export function sortSortableRouteObjects<T>(\n+  objects: readonly T[],\n+  getter: (object: T) => SortableRoute\n+): readonly T[] {\n+  // Create a SortableRoute for each object.\n+  const routes: Array<SortableRoute & { object: T }> = []\n+  for (const object of objects) {\n+    const route = getter(object)\n+    routes.push({ ...route, object })\n+  }\n+\n+  // In-place sort the SortableRoutes.\n+  routes.sort(compareSortableRoutes)\n+\n+  // Map the sorted SortableRoutes back to the original objects.\n+  return routes.map(({ object }) => object)\n+}\n+\n+/**\n+ * Sorts an array of objects by page using a deterministic depth-first traversal\n+ * approach.\n+ *\n+ * @param objects - Array of objects to sort\n+ * @param getter - Function to get the page from an object\n+ * @returns New sorted array (does not mutate input)\n+ */\n+export function sortPageObjects<T>(\n+  objects: readonly T[],\n+  getter: (object: T) => string\n+): readonly T[] {\n+  const indexes: Record<string, number[]> = {}\n+  const pages: Set<string> = new Set()\n+  for (let i = 0; i < objects.length; i++) {\n+    const object = objects[i]\n+    const page = getter(object)\n+    indexes[page]?.push(i) || (indexes[page] = [i])\n+    pages.add(page)\n+  }\n+\n+  // Sort the unique pages.\n+  const sortedPages = Array.from(pages).sort(compareRouteSegments)\n+\n+  // Map the sorted pages back to the original objects.\n+  return sortedPages.reduce<T[]>((sortedObjects, page) => {\n+    // Add all objects for this page to the sorted array.\n+    for (const i of indexes[page]) {\n+      sortedObjects.push(objects[i])\n+    }\n+\n+    // Return the sorted array.\n+    return sortedObjects\n+  }, [])\n+}"
        },
        {
            "sha": "c83e8cf103532f237d678e6c760810ee73bd5d47",
            "filename": "packages/next/src/shared/lib/router/utils/sorted-routes.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/5b998d69553df2f96c0dc398d8e483a6cc7c387f/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Fsorted-routes.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/5b998d69553df2f96c0dc398d8e483a6cc7c387f/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Fsorted-routes.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Fsorted-routes.ts?ref=5b998d69553df2f96c0dc398d8e483a6cc7c387f",
            "patch": "@@ -201,6 +201,9 @@ class UrlNode {\n   }\n }\n \n+/**\n+ * @deprecated Use `sortSortableRoutes` or `sortPages` instead.\n+ */\n export function getSortedRoutes(\n   normalizedPages: ReadonlyArray<string>\n ): string[] {\n@@ -223,6 +226,9 @@ export function getSortedRoutes(\n   return root.smoosh()\n }\n \n+/**\n+ * @deprecated Use `sortSortableRouteObjects` or `sortPageObjects` instead.\n+ */\n export function getSortedRouteObjects<T>(\n   objects: T[],\n   getter: (obj: T) => string"
        },
        {
            "sha": "4c02303e4a14943fc26024d42ccdf69fdc07d54f",
            "filename": "test/e2e/app-dir/sub-shell-generation/sub-shell-generation.test.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/5b998d69553df2f96c0dc398d8e483a6cc7c387f/test%2Fe2e%2Fapp-dir%2Fsub-shell-generation%2Fsub-shell-generation.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/5b998d69553df2f96c0dc398d8e483a6cc7c387f/test%2Fe2e%2Fapp-dir%2Fsub-shell-generation%2Fsub-shell-generation.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsub-shell-generation%2Fsub-shell-generation.test.ts?ref=5b998d69553df2f96c0dc398d8e483a6cc7c387f",
            "patch": "@@ -4,8 +4,6 @@ import * as cheerio from 'cheerio'\n describe('sub-shell-generation', () => {\n   const { next, isNextDev, isNextDeploy } = nextTestSetup({\n     files: __dirname,\n-    // FIXME: re-enable once we've re-enabled the sub-shell generation in Vercel\n-    skipDeployment: true,\n   })\n \n   if (isNextDev) {"
        }
    ],
    "stats": {
        "total": 1376,
        "additions": 1337,
        "deletions": 39
    }
}