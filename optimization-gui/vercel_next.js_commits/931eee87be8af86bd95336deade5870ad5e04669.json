{
    "author": "bgw",
    "message": "refactor(turbo-tasks): Use an execution id instead of the parent task id to prevent local Vc escapes (#78487)\n\nRe-using the task id just for the `Vc` scope escape check isn't ideal:\n\n- A task can execute multiple times. Just using task ids doesn't guarantee that the `Vc` hasn't leaked across multiple executions of the same task.\n- This is just a fallback check to help with debugging, so allocating 32 bits to this id seems wasteful. We can do a good job with 16 bits. Nothing else really needs the task id, so we can get rid of it later in this PR stack.\n\nA version of this idea was part of the original local tasks idea: https://www.notion.so/vercel/Resolved-Vcs-Vc-Lifetimes-Local-Vcs-and-Vc-Refcounts-49d666d3f9594017b5b312b87ddc5bff?pvs=4#da95dbdc390144a9bb1b3d2fb73867b7\n\nEven with this extra 4 bits, the overall enum size is still 16 bits due to alignment and the size of the other enum variants, so this shouldn't regress memory consumption.\n\nThe next PR (https://github.com/vercel/next.js/pull/78561) removes `TaskId` entirely...",
    "sha": "931eee87be8af86bd95336deade5870ad5e04669",
    "files": [
        {
            "sha": "f02d095e0cb1dcb39b3b6fee9f0b7648d96f028f",
            "filename": "turbopack/crates/turbo-tasks-testing/src/lib.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 3,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/931eee87be8af86bd95336deade5870ad5e04669/turbopack%2Fcrates%2Fturbo-tasks-testing%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/931eee87be8af86bd95336deade5870ad5e04669/turbopack%2Fcrates%2Fturbo-tasks-testing%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-testing%2Fsrc%2Flib.rs?ref=931eee87be8af86bd95336deade5870ad5e04669",
            "patch": "@@ -20,8 +20,8 @@ use turbo_tasks::{\n     registry,\n     test_helpers::with_turbo_tasks_for_testing,\n     util::{SharedError, StaticOrArc},\n-    CellId, InvalidationReason, LocalTaskId, MagicAny, RawVc, ReadCellOptions, ReadConsistency,\n-    TaskId, TaskPersistence, TraitTypeId, TurboTasksApi, TurboTasksCallApi,\n+    CellId, ExecutionId, InvalidationReason, LocalTaskId, MagicAny, RawVc, ReadCellOptions,\n+    ReadConsistency, TaskId, TaskPersistence, TraitTypeId, TurboTasksApi, TurboTasksCallApi,\n };\n \n pub use crate::run::{run, run_with_tt, run_without_cache_check, Registration};\n@@ -57,9 +57,11 @@ impl VcStorage {\n             i\n         };\n         let task_id = TaskId::try_from(u32::try_from(i + 1).unwrap()).unwrap();\n+        let execution_id = ExecutionId::try_from(u16::try_from(i + 1).unwrap()).unwrap();\n         handle.spawn(with_turbo_tasks_for_testing(\n             this.clone(),\n             task_id,\n+            execution_id,\n             async move {\n                 let result = AssertUnwindSafe(future).catch_unwind().await;\n \n@@ -230,7 +232,7 @@ impl TurboTasksApi for VcStorage {\n \n     fn try_read_local_output(\n         &self,\n-        _parent_task_id: TaskId,\n+        _execution_id: ExecutionId,\n         _local_task_id: LocalTaskId,\n     ) -> Result<Result<RawVc, EventListener>> {\n         unimplemented!()\n@@ -322,6 +324,7 @@ impl VcStorage {\n                 ..Default::default()\n             }),\n             TaskId::MAX,\n+            ExecutionId::MIN,\n             f,\n         )\n     }"
        },
        {
            "sha": "13eec4c911dca77a570f763146399410c771dd10",
            "filename": "turbopack/crates/turbo-tasks/src/id.rs",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/931eee87be8af86bd95336deade5870ad5e04669/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fid.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/931eee87be8af86bd95336deade5870ad5e04669/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fid.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fid.rs?ref=931eee87be8af86bd95336deade5870ad5e04669",
            "patch": "@@ -125,6 +125,13 @@ define_id!(\n     serde(transparent),\n     doc = \"Represents the nth `local` function call inside a task.\",\n );\n+define_id!(\n+    ExecutionId: u16,\n+    derive(Debug, Serialize, Deserialize),\n+    serde(transparent),\n+    doc = \"An identifier for a specific task execution. Used to assert that local `Vc`s don't \\\n+        leak. This value may overflow and re-use old values.\",\n+);\n \n impl Debug for TaskId {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {"
        },
        {
            "sha": "582b437e0589857dcfe4cb8dc1e6f481f9c01f5a",
            "filename": "turbopack/crates/turbo-tasks/src/id_factory.rs",
            "status": "modified",
            "additions": 26,
            "deletions": 0,
            "changes": 26,
            "blob_url": "https://github.com/vercel/next.js/blob/931eee87be8af86bd95336deade5870ad5e04669/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fid_factory.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/931eee87be8af86bd95336deade5870ad5e04669/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fid_factory.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fid_factory.rs?ref=931eee87be8af86bd95336deade5870ad5e04669",
            "patch": "@@ -96,10 +96,36 @@ where\n             ),\n         }\n     }\n+\n+    /// Returns an id, potentially allowing an overflow. This may cause ids to be silently re-used.\n+    /// Used for [`crate::id::ExecutionId`].\n+    ///\n+    /// If id re-use is desired only for \"freed\" ids, use [`IdFactoryWithReuse`] instead.\n+    pub fn wrapping_get(&self) -> T {\n+        let count = self.counter.fetch_add(1, Ordering::Relaxed);\n+\n+        let new_id_u64 = (count % self.max_count) + self.id_offset;\n+        // Safety:\n+        // - `id_offset` is a non-zero value.\n+        // - `id_offset + max_count < u64::MAX`.\n+        let new_id = unsafe { NonZeroU64::new_unchecked(new_id_u64) };\n+\n+        match new_id.try_into() {\n+            Ok(id) => id,\n+            Err(_) => panic!(\n+                \"Failed to convert NonZeroU64 value of {} into {}\",\n+                new_id,\n+                type_name::<T>()\n+            ),\n+        }\n+    }\n }\n \n /// An [`IdFactory`], but extended with a free list to allow for id reuse for ids such as\n /// [`BackendJobId`][crate::backend::BackendJobId].\n+///\n+/// If silent untracked re-use of ids is okay, consider using the cheaper\n+/// [`IdFactory::wrapping_get`] method.\n pub struct IdFactoryWithReuse<T> {\n     factory: IdFactory<T>,\n     free_ids: ConcurrentQueue<T>,"
        },
        {
            "sha": "936f2ffb9c056cf05b0858925eff3c69762a48bb",
            "filename": "turbopack/crates/turbo-tasks/src/lib.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/931eee87be8af86bd95336deade5870ad5e04669/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/931eee87be8af86bd95336deade5870ad5e04669/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs?ref=931eee87be8af86bd95336deade5870ad5e04669",
            "patch": "@@ -91,7 +91,8 @@ pub use completion::{Completion, Completions};\n pub use display::ValueToString;\n pub use effect::{apply_effects, effect, get_effects, Effects};\n pub use id::{\n-    FunctionId, LocalTaskId, SessionId, TaskId, TraitTypeId, ValueTypeId, TRANSIENT_TASK_BIT,\n+    ExecutionId, FunctionId, LocalTaskId, SessionId, TaskId, TraitTypeId, ValueTypeId,\n+    TRANSIENT_TASK_BIT,\n };\n pub use invalidation::{\n     get_invalidator, DynamicEqHash, InvalidationReason, InvalidationReasonKind,"
        },
        {
            "sha": "8ebffdde145db93f6794f05d645fd9bd168694c1",
            "filename": "turbopack/crates/turbo-tasks/src/manager.rs",
            "status": "modified",
            "additions": 56,
            "deletions": 31,
            "changes": 87,
            "blob_url": "https://github.com/vercel/next.js/blob/931eee87be8af86bd95336deade5870ad5e04669/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/931eee87be8af86bd95336deade5870ad5e04669/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs?ref=931eee87be8af86bd95336deade5870ad5e04669",
            "patch": "@@ -31,7 +31,7 @@ use crate::{\n     },\n     capture_future::{self, CaptureFuture},\n     event::{Event, EventListener},\n-    id::{BackendJobId, FunctionId, LocalTaskId, TraitTypeId, TRANSIENT_TASK_BIT},\n+    id::{BackendJobId, ExecutionId, FunctionId, LocalTaskId, TraitTypeId, TRANSIENT_TASK_BIT},\n     id_factory::IdFactoryWithReuse,\n     magic_any::MagicAny,\n     raw_vc::{CellId, RawVc},\n@@ -41,10 +41,11 @@ use crate::{\n     task_statistics::TaskStatisticsApi,\n     trace::TraceRawVcs,\n     trait_helpers::get_trait_method,\n-    util::StaticOrArc,\n+    util::{IdFactory, StaticOrArc},\n     vc::ReadVcFuture,\n-    Completion, InvalidationReason, InvalidationReasonSet, ReadCellOptions, ResolvedVc,\n-    SharedReference, TaskId, TaskIdSet, ValueTypeId, Vc, VcRead, VcValueTrait, VcValueType,\n+    Completion, InvalidationReason, InvalidationReasonSet, OutputContent, ReadCellOptions,\n+    ResolvedVc, SharedReference, TaskId, TaskIdSet, ValueTypeId, Vc, VcRead, VcValueTrait,\n+    VcValueType,\n };\n \n pub trait TurboTasksCallApi: Sync + Send {\n@@ -139,7 +140,7 @@ pub trait TurboTasksApi: TurboTasksCallApi + Sync + Send {\n     /// `OperationVc`s, which should never be local tasks.\n     fn try_read_local_output(\n         &self,\n-        parent_task_id: TaskId,\n+        execution_id: ExecutionId,\n         local_task_id: LocalTaskId,\n     ) -> Result<Result<RawVc, EventListener>>;\n \n@@ -347,6 +348,7 @@ pub struct TurboTasks<B: Backend + 'static> {\n     backend: B,\n     task_id_factory: IdFactoryWithReuse<TaskId>,\n     transient_task_id_factory: IdFactoryWithReuse<TaskId>,\n+    execution_id_factory: IdFactory<ExecutionId>,\n     stopped: AtomicBool,\n     currently_scheduled_tasks: AtomicUsize,\n     currently_scheduled_foreground_jobs: AtomicUsize,\n@@ -371,6 +373,7 @@ pub struct TurboTasks<B: Backend + 'static> {\n /// - The backend is aware of.\n struct CurrentTaskState {\n     task_id: TaskId,\n+    execution_id: ExecutionId,\n \n     /// Affected tasks, that are tracked during task execution. These tasks will\n     /// be invalidated when the execution finishes or before reading a cell\n@@ -397,9 +400,14 @@ struct CurrentTaskState {\n }\n \n impl CurrentTaskState {\n-    fn new(task_id: TaskId, backend_state: Box<dyn Any + Send + Sync>) -> Self {\n+    fn new(\n+        task_id: TaskId,\n+        execution_id: ExecutionId,\n+        backend_state: Box<dyn Any + Send + Sync>,\n+    ) -> Self {\n         Self {\n             task_id,\n+            execution_id,\n             tasks_to_notify: Vec::new(),\n             stateful: false,\n             cell_counters: Some(AutoMap::default()),\n@@ -409,10 +417,11 @@ impl CurrentTaskState {\n         }\n     }\n \n-    fn assert_task_id(&self, expected_task_id: TaskId) {\n-        if self.task_id != expected_task_id {\n-            unimplemented!(\n-                \"Local tasks can currently only be scheduled/awaited within their parent task\"\n+    fn assert_execution_id(&self, expected_execution_id: ExecutionId) {\n+        if self.execution_id != expected_execution_id {\n+            panic!(\n+                \"Local tasks can only be scheduled/awaited within the same execution of the \\\n+                 parent task that created them\"\n             );\n         }\n     }\n@@ -458,11 +467,13 @@ impl<B: Backend + 'static> TurboTasks<B> {\n         );\n         let transient_task_id_factory =\n             IdFactoryWithReuse::new(TaskId::try_from(TRANSIENT_TASK_BIT).unwrap(), TaskId::MAX);\n+        let execution_id_factory = IdFactory::new(ExecutionId::MIN, ExecutionId::MAX);\n         let this = Arc::new_cyclic(|this| Self {\n             this: this.clone(),\n             backend,\n             task_id_factory,\n             transient_task_id_factory,\n+            execution_id_factory,\n             stopped: AtomicBool::new(false),\n             currently_scheduled_tasks: AtomicUsize::new(0),\n             currently_scheduled_background_jobs: AtomicUsize::new(0),\n@@ -644,8 +655,11 @@ impl<B: Backend + 'static> TurboTasks<B> {\n             let mut schedule_again = true;\n             while schedule_again {\n                 let backend_state = this.backend.new_task_state(task_id);\n+                // it's okay for execution ids to overflow and wrap, they're just used for an assert\n+                let execution_id = this.execution_id_factory.wrapping_get();\n                 let current_task_state = Arc::new(RwLock::new(CurrentTaskState::new(\n                     task_id,\n+                    execution_id,\n                     Box::new(backend_state),\n                 )));\n                 let single_execution_future = async {\n@@ -722,22 +736,31 @@ impl<B: Backend + 'static> TurboTasks<B> {\n         &self,\n         ty: LocalTaskType,\n         // if this is a `LocalTaskType::Resolve*`, we may spawn another task with this persistence,\n-        // if this is a `LocalTaskType::Native`, persistence is unused (there's no caching).\n+        // if this is a `LocalTaskType::Native`, persistence is unused.\n+        //\n+        // TODO: In the rare case that we're crossing a transient->persistent boundary, we should\n+        // force `LocalTaskType::Native` to be spawned as real tasks, so that any cells they create\n+        // have the correct persistence. This is not an issue for resolution stub task, as they\n+        // don't end up owning any cells.\n         persistence: TaskPersistence,\n     ) -> RawVc {\n-        use crate::OutputContent;\n-\n         let ty = Arc::new(ty);\n-        let (global_task_state, local_task_id, parent_task_id) = CURRENT_TASK_STATE.with(|gts| {\n-            let mut gts_write = gts.write().unwrap();\n-            let local_task_id = gts_write.create_local_task(LocalTask::Scheduled {\n-                done_event: Event::new({\n-                    let ty = Arc::clone(&ty);\n-                    move || format!(\"LocalTask({})::done_event\", ty)\n-                }),\n+        let (global_task_state, parent_task_id, execution_id, local_task_id) = CURRENT_TASK_STATE\n+            .with(|gts| {\n+                let mut gts_write = gts.write().unwrap();\n+                let local_task_id = gts_write.create_local_task(LocalTask::Scheduled {\n+                    done_event: Event::new({\n+                        let ty = Arc::clone(&ty);\n+                        move || format!(\"LocalTask({})::done_event\", ty)\n+                    }),\n+                });\n+                (\n+                    Arc::clone(gts),\n+                    gts_write.task_id,\n+                    gts_write.execution_id,\n+                    local_task_id,\n+                )\n             });\n-            (Arc::clone(gts), local_task_id, gts_write.task_id)\n-        });\n \n         #[cfg(feature = \"tokio_tracing\")]\n         let description = format!(\n@@ -799,7 +822,7 @@ impl<B: Backend + 'static> TurboTasks<B> {\n         #[cfg(not(feature = \"tokio_tracing\"))]\n         tokio::task::spawn(future);\n \n-        RawVc::LocalOutput(parent_task_id, persistence, local_task_id)\n+        RawVc::LocalOutput(parent_task_id, persistence, execution_id, local_task_id)\n     }\n \n     fn begin_primary_job(&self) {\n@@ -1277,17 +1300,17 @@ impl<B: Backend + 'static> TurboTasksApi for TurboTasks<B> {\n \n     fn try_read_local_output(\n         &self,\n-        parent_task_id: TaskId,\n+        execution_id: ExecutionId,\n         local_task_id: LocalTaskId,\n     ) -> Result<Result<RawVc, EventListener>> {\n         CURRENT_TASK_STATE.with(|gts| {\n             let gts_read = gts.read().unwrap();\n \n-            // Local Vcs are local to their parent task, and do not exist outside of it. This is\n-            // weakly enforced at compile time using the `NonLocalValue` marker trait. This\n-            // assertion exists to handle any potential escapes that the compile-time checks cannot\n-            // capture.\n-            gts_read.assert_task_id(parent_task_id);\n+            // Local Vcs are local to their parent task's current execution, and do not exist\n+            // outside of it. This is weakly enforced at compile time using the `NonLocalValue`\n+            // marker trait. This assertion exists to handle any potential escapes that the\n+            // compile-time checks cannot capture.\n+            gts_read.assert_execution_id(execution_id);\n \n             match gts_read.get_local_task(local_task_id) {\n                 LocalTask::Scheduled { done_event } => Ok(Err(done_event.listen())),\n@@ -1632,13 +1655,15 @@ pub fn turbo_tasks_future_scope<T>(\n pub fn with_turbo_tasks_for_testing<T>(\n     tt: Arc<dyn TurboTasksApi>,\n     current_task: TaskId,\n+    execution_id: ExecutionId,\n     f: impl Future<Output = T>,\n ) -> impl Future<Output = T> {\n     TURBO_TASKS.scope(\n         tt,\n         CURRENT_TASK_STATE.scope(\n             Arc::new(RwLock::new(CurrentTaskState::new(\n                 current_task,\n+                execution_id,\n                 Box::new(()),\n             ))),\n             f,\n@@ -1969,11 +1994,11 @@ pub fn find_cell_by_type(ty: ValueTypeId) -> CurrentCellRef {\n \n pub(crate) async fn read_local_output(\n     this: &dyn TurboTasksApi,\n-    parent_task_id: TaskId,\n+    execution_id: ExecutionId,\n     local_task_id: LocalTaskId,\n ) -> Result<RawVc> {\n     loop {\n-        match this.try_read_local_output(parent_task_id, local_task_id)? {\n+        match this.try_read_local_output(execution_id, local_task_id)? {\n             Ok(raw_vc) => return Ok(raw_vc),\n             Err(event_listener) => event_listener.await,\n         }"
        },
        {
            "sha": "40536a7f7c267bd9b4cd9d9be65476d325e7dd6f",
            "filename": "turbopack/crates/turbo-tasks/src/raw_vc.rs",
            "status": "modified",
            "additions": 12,
            "deletions": 12,
            "changes": 24,
            "blob_url": "https://github.com/vercel/next.js/blob/931eee87be8af86bd95336deade5870ad5e04669/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fraw_vc.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/931eee87be8af86bd95336deade5870ad5e04669/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fraw_vc.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fraw_vc.rs?ref=931eee87be8af86bd95336deade5870ad5e04669",
            "patch": "@@ -8,7 +8,7 @@ use thiserror::Error;\n use crate::{\n     backend::{CellContent, TypedCellContent},\n     event::EventListener,\n-    id::LocalTaskId,\n+    id::{ExecutionId, LocalTaskId},\n     manager::{read_local_output, read_task_cell, read_task_output, with_turbo_tasks},\n     registry::{self, get_value_type},\n     turbo_tasks, CollectiblesSource, ReadCellOptions, ReadConsistency, ResolvedVc, TaskId,\n@@ -57,7 +57,7 @@ impl Display for CellId {\n pub enum RawVc {\n     TaskOutput(TaskId),\n     TaskCell(TaskId, CellId),\n-    LocalOutput(TaskId, TaskPersistence, LocalTaskId),\n+    LocalOutput(TaskId, TaskPersistence, ExecutionId, LocalTaskId),\n }\n \n impl RawVc {\n@@ -148,8 +148,8 @@ impl RawVc {\n                         return Err(ResolveTypeError::NoContent);\n                     }\n                 }\n-                RawVc::LocalOutput(task_id, _persistence, local_task_id) => {\n-                    current = read_local_output(&*tt, task_id, local_task_id)\n+                RawVc::LocalOutput(_task_id, _persistence, execution_id, local_task_id) => {\n+                    current = read_local_output(&*tt, execution_id, local_task_id)\n                         .await\n                         .map_err(|source| ResolveTypeError::TaskError { source })?;\n                 }\n@@ -185,9 +185,9 @@ impl RawVc {\n                     consistency = ReadConsistency::Eventual;\n                 }\n                 RawVc::TaskCell(_, _) => return Ok(current),\n-                RawVc::LocalOutput(task_id, _persistence, local_task_id) => {\n+                RawVc::LocalOutput(_task_id, _persistence, execution_id, local_task_id) => {\n                     debug_assert_eq!(consistency, ReadConsistency::Eventual);\n-                    current = read_local_output(&*tt, task_id, local_task_id).await?;\n+                    current = read_local_output(&*tt, execution_id, local_task_id).await?;\n                 }\n             }\n         }\n@@ -200,8 +200,8 @@ impl RawVc {\n         let mut current = self;\n         loop {\n             match current {\n-                RawVc::LocalOutput(task_id, _persistence, local_task_id) => {\n-                    current = read_local_output(&*tt, task_id, local_task_id).await?;\n+                RawVc::LocalOutput(_task_id, _persistence, execution_id, local_task_id) => {\n+                    current = read_local_output(&*tt, execution_id, local_task_id).await?;\n                 }\n                 non_local => return Ok(non_local),\n             }\n@@ -215,14 +215,14 @@ impl RawVc {\n \n     pub fn get_task_id(&self) -> TaskId {\n         match self {\n-            RawVc::TaskOutput(t) | RawVc::TaskCell(t, _) | RawVc::LocalOutput(t, ..) => *t,\n+            RawVc::TaskOutput(t) | RawVc::TaskCell(t, ..) | RawVc::LocalOutput(t, ..) => *t,\n         }\n     }\n \n     pub fn try_get_type_id(&self) -> Option<ValueTypeId> {\n         match self {\n             RawVc::TaskCell(_, CellId { type_id, .. }) => Some(*type_id),\n-            RawVc::TaskOutput(_) | RawVc::LocalOutput(..) => None,\n+            RawVc::TaskOutput(..) | RawVc::LocalOutput(..) => None,\n         }\n     }\n \n@@ -360,9 +360,9 @@ impl Future for ReadRawVcFuture {\n                             Err(err) => return Poll::Ready(Err(err)),\n                         }\n                     }\n-                    RawVc::LocalOutput(task_id, _persistence, local_output_id) => {\n+                    RawVc::LocalOutput(_task_id, _persistence, execution_id, local_output_id) => {\n                         debug_assert_eq!(this.consistency, ReadConsistency::Eventual);\n-                        let read_result = tt.try_read_local_output(task_id, local_output_id);\n+                        let read_result = tt.try_read_local_output(execution_id, local_output_id);\n                         match read_result {\n                             Ok(Ok(vc)) => {\n                                 this.current = vc;"
        },
        {
            "sha": "247a30473f11ba4242ddb408edcd3fa2d33a5393",
            "filename": "turbopack/crates/turbo-tasks/src/task/local_task.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/931eee87be8af86bd95336deade5870ad5e04669/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask%2Flocal_task.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/931eee87be8af86bd95336deade5870ad5e04669/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask%2Flocal_task.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask%2Flocal_task.rs?ref=931eee87be8af86bd95336deade5870ad5e04669",
            "patch": "@@ -20,7 +20,8 @@ pub enum LocalTask {\n pub fn get_local_task_execution_spec<'a>(\n     turbo_tasks: &'_ dyn TurboTasksBackendApi<impl Backend + 'static>,\n     ty: &'a LocalTaskType,\n-    // if this is a `LocalTaskType::Resolve*`, we'll spawn another task with this persistence\n+    // if this is a `LocalTaskType::Resolve*`, we'll spawn another task with this persistence, if\n+    // this is a `LocalTaskType::Native`, this refers to the parent non-local task.\n     persistence: TaskPersistence,\n ) -> TaskExecutionSpec<'a> {\n     match ty {\n@@ -29,7 +30,6 @@ pub fn get_local_task_execution_spec<'a>(\n             this,\n             arg,\n         } => {\n-            debug_assert_eq!(persistence, TaskPersistence::Local);\n             let func = registry::get_function(*native_fn_id);\n             let span = func.span(TaskPersistence::Local);\n             let entered = span.enter();"
        }
    ],
    "stats": {
        "total": 160,
        "additions": 111,
        "deletions": 49
    }
}