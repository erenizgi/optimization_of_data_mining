{
    "author": "huozhi",
    "message": "[metadata] refactor metadata sitemap loader code (#83443)",
    "sha": "ede8d1b861378b4b8aa7ff77ad2cacd583d9b21d",
    "files": [
        {
            "sha": "7055cce5e1caf1573c6c2db63882685219c4bea4",
            "filename": "crates/next-core/src/next_app/metadata/route.rs",
            "status": "modified",
            "additions": 128,
            "deletions": 91,
            "changes": 219,
            "blob_url": "https://github.com/vercel/next.js/blob/ede8d1b861378b4b8aa7ff77ad2cacd583d9b21d/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fmetadata%2Froute.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/ede8d1b861378b4b8aa7ff77ad2cacd583d9b21d/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fmetadata%2Froute.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fmetadata%2Froute.rs?ref=ede8d1b861378b4b8aa7ff77ad2cacd583d9b21d",
            "patch": "@@ -4,7 +4,7 @@\n \n use anyhow::{Ok, Result, bail};\n use base64::{display::Base64Display, engine::general_purpose::STANDARD};\n-use indoc::{formatdoc, indoc};\n+use indoc::formatdoc;\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::Vc;\n use turbo_tasks_fs::{self, File, FileContent, FileSystemPath};\n@@ -46,9 +46,9 @@ pub async fn get_app_metadata_route_source(\n             if stem == \"robots\" || stem == \"manifest\" {\n                 dynamic_text_route_source(path)\n             } else if stem == \"sitemap\" {\n-                dynamic_site_map_route_source(mode, path, is_multi_dynamic)\n+                dynamic_site_map_route_source(path, is_multi_dynamic)\n             } else {\n-                dynamic_image_route_source(mode, path, is_multi_dynamic)\n+                dynamic_image_route_source(path, is_multi_dynamic)\n             }\n         }\n     })\n@@ -265,61 +265,22 @@ async fn dynamic_text_route_source(path: FileSystemPath) -> Result<Vc<Box<dyn So\n     Ok(Vc::upcast(source))\n }\n \n-#[turbo_tasks::function]\n-async fn dynamic_site_map_route_source(\n-    mode: NextMode,\n+async fn dynamic_sitemap_route_with_generate_source(\n     path: FileSystemPath,\n-    is_multi_dynamic: bool,\n ) -> Result<Vc<Box<dyn Source>>> {\n     let stem = path.file_stem();\n     let stem = stem.unwrap_or_default();\n     let ext = path.extension();\n     let content_type = get_content_type(path.clone()).await?;\n-    let mut static_generation_code = \"\";\n-    let mut validation_code = \"\";\n-\n-    if is_multi_dynamic {\n-        if mode.is_production() {\n-            static_generation_code = indoc! {\n-                r#\"\n-                    export async function generateStaticParams() {\n-                        const sitemaps = await generateSitemaps()\n-                        const params = []\n-\n-                        for (const item of sitemaps) {{\n-                            params.push({ __metadata_id__: item.id.toString() + '.xml' })\n-                        }}\n-                        return params\n-                    }\n-                \"#,\n-            };\n-        } else {\n-            validation_code = indoc! {\n-                r#\"\n-                    if (process.env.NODE_ENV !== 'production' && sitemapModule.generateSitemaps) {\n-                        const sitemaps = await sitemapModule.generateSitemaps()\n-                        for (const item of sitemaps) {\n-                            if (item?.id == null) {\n-                                throw new Error('id property is required for every item returned from generateSitemaps')\n-                            }\n-                        }\n-                    }\n-                \"#,\n-            };\n-        }\n-    }\n \n     let code = formatdoc! {\n         r#\"\n             import {{ NextResponse }} from 'next/server'\n-            import * as _sitemapModule from {resource_path}\n+            import {{ default as handler, generateSitemaps }} from {resource_path}\n             import {{ resolveRouteData }} from 'next/dist/build/webpack/loaders/metadata/resolve-route-data'\n \n-            const sitemapModule = {{ ..._sitemapModule }}\n-            const handler = sitemapModule.default\n-            const generateSitemaps = sitemapModule.generateSitemaps\n             const contentType = {content_type}\n-            const cacheControl = {cache_control}\n+            const cache_control = {cache_control}\n             const fileType = {file_type}\n \n             if (typeof handler !== 'function') {{\n@@ -335,7 +296,24 @@ async fn dynamic_site_map_route_source(\n                     }})\n                 }}\n \n-                {validation_code}\n+                if (process.env.NODE_ENV !== 'production') {{\n+                    const sitemaps = await generateSitemaps()\n+                    let foundId\n+                    for (const item of sitemaps) {{\n+                        if (item?.id == null) {{\n+                            throw new Error('id property is required for every item returned from generateSitemaps')\n+                        }}\n+                        const baseId = id && hasXmlExtension ? id.slice(0, -4) : id\n+                        if (item.id.toString() === baseId) {{\n+                            foundId = item.id\n+                        }}\n+                    }}\n+                    if (foundId == null) {{\n+                        return new NextResponse('Not Found', {{\n+                            status: 404,\n+                        }})\n+                    }}\n+                }}\n                 \n                 const targetId = id && hasXmlExtension ? id.slice(0, -4) : undefined\n                 const data = await handler({{ id: targetId }})\n@@ -344,21 +322,31 @@ async fn dynamic_site_map_route_source(\n                 return new NextResponse(content, {{\n                     headers: {{\n                         'Content-Type': contentType,\n-                        'Cache-Control': cacheControl,\n+                        'Cache-Control': cache_control,\n                     }},\n                 }})\n             }}\n \n             export * from {resource_path}\n \n-            {static_generation_code}\n+            export const dynamicParams = false\n+            export async function generateStaticParams() {{\n+                const sitemaps = await generateSitemaps()\n+                const params = []\n+\n+                for (const item of sitemaps) {{\n+                    if (item?.id == null) {{\n+                        throw new Error('id property is required for every item returned from generateSitemaps')\n+                    }}\n+                    params.push({{ __metadata_id__: item.id.toString() + '.xml' }})\n+                }}\n+                return params\n+            }}\n         \"#,\n         resource_path = StringifyJs(&format!(\"./{stem}.{ext}\")),\n         content_type = StringifyJs(&content_type),\n         file_type = StringifyJs(&stem),\n         cache_control = StringifyJs(CACHE_HEADER_REVALIDATE),\n-        validation_code = validation_code,\n-        static_generation_code = static_generation_code,\n     };\n \n     let file = File::from(code);\n@@ -370,41 +358,80 @@ async fn dynamic_site_map_route_source(\n     Ok(Vc::upcast(source))\n }\n \n-async fn dynamic_image_route_with_metadata_source(\n-    mode: NextMode,\n+async fn dynamic_sitemap_route_without_generate_source(\n     path: FileSystemPath,\n ) -> Result<Vc<Box<dyn Source>>> {\n     let stem = path.file_stem();\n     let stem = stem.unwrap_or_default();\n     let ext = path.extension();\n-\n-    let mut static_generation_code = \"\";\n-\n-    if mode.is_production() {\n-        static_generation_code = indoc! {\n-            r#\"\n-                export async function generateStaticParams({ params }) {\n-                    const imageMetadata = await generateImageMetadata({ params })\n-                    const staticParams = []\n-\n-                    for (const item of imageMetadata) {\n-                        staticParams.push({ __metadata_id__: item.id.toString() })\n-                    }\n-                    return staticParams\n-                }\n-            \"#,\n-        };\n-    }\n+    let content_type = get_content_type(path.clone()).await?;\n \n     let code = formatdoc! {\n         r#\"\n             import {{ NextResponse }} from 'next/server'\n-            import * as _imageModule from {resource_path}\n+            import {{ default as handler }} from {resource_path}\n+            import {{ resolveRouteData }} from 'next/dist/build/webpack/loaders/metadata/resolve-route-data'\n+\n+            const contentType = {content_type}\n+            const cacheControl = {cache_control}\n+            const fileType = {file_type}\n+\n+            if (typeof handler !== 'function') {{\n+                throw new Error('Default export is missing in {resource_path}')\n+            }}\n+\n+            export async function GET() {{\n+                const data = await handler()\n+                const content = resolveRouteData(data, fileType)\n+\n+                return new NextResponse(content, {{\n+                    headers: {{\n+                        'Content-Type': contentType,\n+                        'Cache-Control': cacheControl,\n+                    }},\n+                }})\n+            }}\n \n-            const imageModule = {{ ..._imageModule }}\n+            export * from {resource_path}\n+        \"#,\n+        resource_path = StringifyJs(&format!(\"./{stem}.{ext}\")),\n+        content_type = StringifyJs(&content_type),\n+        file_type = StringifyJs(&stem),\n+        cache_control = StringifyJs(CACHE_HEADER_REVALIDATE),\n+    };\n+\n+    let file = File::from(code);\n+    let source = VirtualSource::new(\n+        path.parent().join(&format!(\"{stem}--route-entry.js\"))?,\n+        AssetContent::file(file.into()),\n+    );\n \n-            const handler = imageModule.default\n-            const generateImageMetadata = imageModule.generateImageMetadata\n+    Ok(Vc::upcast(source))\n+}\n+\n+#[turbo_tasks::function]\n+async fn dynamic_site_map_route_source(\n+    path: FileSystemPath,\n+    is_multi_dynamic: bool,\n+) -> Result<Vc<Box<dyn Source>>> {\n+    if is_multi_dynamic {\n+        dynamic_sitemap_route_with_generate_source(path).await\n+    } else {\n+        dynamic_sitemap_route_without_generate_source(path).await\n+    }\n+}\n+\n+async fn dynamic_image_route_with_metadata_source(\n+    path: FileSystemPath,\n+) -> Result<Vc<Box<dyn Source>>> {\n+    let stem = path.file_stem();\n+    let stem = stem.unwrap_or_default();\n+    let ext = path.extension();\n+\n+    let code = formatdoc! {\n+        r#\"\n+            import {{ NextResponse }} from 'next/server'\n+            import {{ default as handler, generateImageMetadata }} from {resource_path}\n \n             if (typeof handler !== 'function') {{\n                 throw new Error('Default export is missing in {resource_path}')\n@@ -414,33 +441,44 @@ async fn dynamic_image_route_with_metadata_source(\n                 const params = await ctx.params\n                 const {{ __metadata_id__, ...rest }} = params || {{}}\n                 const restParams = params ? rest : undefined\n-                const targetId = __metadata_id__\n-\n-                const imageMetadata = await generateImageMetadata({{ params: restParams }})\n-                const id = imageMetadata.find((item) => {{\n-                    if (process.env.NODE_ENV !== 'production') {{\n+                \n+                if (process.env.NODE_ENV !== 'production') {{\n+                    const imageMetadata = await generateImageMetadata({{ params: restParams }})\n+                    const id = imageMetadata.find((item) => {{\n                         if (item?.id == null) {{\n                             throw new Error('id property is required for every item returned from generateImageMetadata')\n                         }}\n-                    }}\n-                    return item.id.toString() === targetId\n-                }})?.id\n \n-                if (id == null) {{\n-                    return new NextResponse('Not Found', {{\n-                        status: 404,\n-                    }})\n+                        return item.id.toString() === __metadata_id__\n+                    }})?.id\n+\n+                    if (id == null) {{\n+                        return new NextResponse('Not Found', {{\n+                            status: 404,\n+                        }})\n+                    }}\n                 }}\n \n-                return handler({{ params: restParams, id }})\n+                return handler({{ params: restParams, id: __metadata_id__ }})\n             }}\n \n             export * from {resource_path}\n \n-            {static_generation_code}\n+            export const dynamicParams = false\n+            export async function generateStaticParams({{ params }}) {{\n+                const imageMetadata = await generateImageMetadata({{ params }})\n+                const staticParams = []\n+\n+                for (const item of imageMetadata) {{\n+                    if (item?.id == null) {{\n+                        throw new Error('id property is required for every item returned from generateImageMetadata')\n+                    }}\n+                    staticParams.push({{ __metadata_id__: item.id.toString() }})\n+                }}\n+                return staticParams\n+            }}\n         \"#,\n         resource_path = StringifyJs(&format!(\"./{stem}.{ext}\")),\n-        static_generation_code = static_generation_code,\n     };\n \n     let file = File::from(code);\n@@ -488,12 +526,11 @@ async fn dynamic_image_route_without_metadata_source(\n \n #[turbo_tasks::function]\n async fn dynamic_image_route_source(\n-    mode: NextMode,\n     path: FileSystemPath,\n     is_multi_dynamic: bool,\n ) -> Result<Vc<Box<dyn Source>>> {\n     if is_multi_dynamic {\n-        dynamic_image_route_with_metadata_source(mode, path).await\n+        dynamic_image_route_with_metadata_source(path).await\n     } else {\n         dynamic_image_route_without_metadata_source(path).await\n     }"
        },
        {
            "sha": "ed297d05c1476e7425bb6d2fd4c00c1821c4fa03",
            "filename": "packages/next/src/build/webpack/loaders/next-metadata-route-loader.ts",
            "status": "modified",
            "additions": 105,
            "deletions": 60,
            "changes": 165,
            "blob_url": "https://github.com/vercel/next.js/blob/ede8d1b861378b4b8aa7ff77ad2cacd583d9b21d/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack%2Floaders%2Fnext-metadata-route-loader.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/ede8d1b861378b4b8aa7ff77ad2cacd583d9b21d/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack%2Floaders%2Fnext-metadata-route-loader.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack%2Floaders%2Fnext-metadata-route-loader.ts?ref=ede8d1b861378b4b8aa7ff77ad2cacd583d9b21d",
            "patch": "@@ -25,7 +25,10 @@ async function createReExportsCode(\n   )\n   // Re-export configs but avoid conflicted exports\n   const reExportNames = exportNames.filter(\n-    (name) => name !== 'default' && name !== 'generateSitemaps'\n+    (name) =>\n+      name !== 'default' &&\n+      name !== 'generateSitemaps' &&\n+      name !== 'dynamicParams'\n   )\n \n   return reExportNames.length > 0\n@@ -157,22 +160,6 @@ async function getDynamicImageRouteCode(\n   resourcePath: string,\n   loaderContext: webpack.LoaderContext<any>\n ) {\n-  let staticGenerationCode = ''\n-\n-  if (process.env.NODE_ENV === 'production') {\n-    staticGenerationCode = `\\\n-export async function generateStaticParams({ params }) {\n-  const imageMetadata = await generateImageMetadata({ params })\n-  const staticParams = []\n-\n-  for (const item of imageMetadata) {\n-    staticParams.push({ __metadata_id__: item.id.toString() })\n-  }\n-  return staticParams\n-}\n-`\n-  }\n-\n   return `\\\n /* dynamic image route with generateImageMetadata */\n import { NextResponse } from 'next/server'\n@@ -185,25 +172,41 @@ export async function GET(_, ctx) {\n   const params = await ctx.params\n   const { __metadata_id__, ...rest } = params || {}\n   const restParams = params ? rest : undefined\n-  const imageMetadata = await generateImageMetadata({ params: restParams })\n-  const id = imageMetadata.find((item) => {\n-    if (process.env.NODE_ENV !== 'production') {\n+  \n+  ${/* we need a dev assertion for id since dynamicParams=false won't work well in dev */ ''}\n+  if (process.env.NODE_ENV !== 'production') {\n+    const imageMetadata = await generateImageMetadata({ params: restParams })\n+    const id = imageMetadata.find((item) => {\n       if (item?.id == null) {\n         throw new Error('id property is required for every item returned from generateImageMetadata')\n       }\n+\n+      return item.id.toString() === __metadata_id__\n+    })?.id\n+\n+    if (id == null) {\n+      return new NextResponse('Not Found', {\n+        status: 404,\n+      })\n     }\n-    return item.id.toString() === __metadata_id__\n-  })?.id\n-  if (id == null) {\n-    return new NextResponse('Not Found', {\n-      status: 404,\n-    })\n   }\n \n-  return handler({ params: restParams, id })\n+  return handler({ params: restParams, id: __metadata_id__ })\n }\n \n-${staticGenerationCode}\n+export const dynamicParams = false\n+export async function generateStaticParams({ params }) {\n+  const imageMetadata = await generateImageMetadata({ params })\n+  const staticParams = []\n+\n+  for (const item of imageMetadata) {\n+    if (item?.id == null) {\n+      throw new Error('id property is required for every item returned from generateImageMetadata')\n+    }\n+    staticParams.push({ __metadata_id__: item.id.toString() })\n+  }\n+  return staticParams\n+}\n `\n }\n \n@@ -244,41 +247,46 @@ async function getImageRouteCode(\n   }\n }\n \n-async function getDynamicSitemapRouteCode(\n+async function getSingleSitemapRouteCode(\n   resourcePath: string,\n   loaderContext: webpack.LoaderContext<any>\n ) {\n-  let staticGenerationCode = ''\n+  return `\\\n+/* single sitemap route */\n+import { NextResponse } from 'next/server'\n+import { default as handler } from ${JSON.stringify(resourcePath)}\n+import { resolveRouteData } from 'next/dist/build/webpack/loaders/metadata/resolve-route-data'\n \n-  const exportNames = await getLoaderModuleNamedExports(\n-    resourcePath,\n-    loaderContext\n-  )\n+const contentType = ${JSON.stringify(getContentType(resourcePath))}\n+const fileType = ${JSON.stringify(getFilenameAndExtension(resourcePath).name)}\n \n-  const hasGenerateSitemaps = exportNames.includes('generateSitemaps')\n+${errorOnBadHandler(resourcePath)}\n+${await createReExportsCode(resourcePath, loaderContext)}\n \n-  if (process.env.NODE_ENV === 'production' && hasGenerateSitemaps) {\n-    staticGenerationCode = `\\\n-    /* dynamic sitemap route */\n-    export async function generateStaticParams() {\n-      const sitemaps = await sitemapModule.generateSitemaps()\n-      const params = []\n+export async function GET() {\n+  const data = await handler()\n+  const content = resolveRouteData(data, fileType)\n \n-      for (const item of sitemaps) {\n-        params.push({ __metadata_id__: item.id.toString() + '.xml' })\n-      }\n-      return params\n-    }\n-    `\n-  }\n+  return new NextResponse(content, {\n+    headers: {\n+      'Content-Type': contentType,\n+      'Cache-Control': ${JSON.stringify(CACHE_HEADERS.REVALIDATE)},\n+    },\n+  })\n+}\n+`\n+}\n \n+async function getDynamicSitemapRouteCode(\n+  resourcePath: string,\n+  loaderContext: webpack.LoaderContext<any>\n+) {\n   const code = `\\\n+/* dynamic sitemap route with generateSitemaps */\n import { NextResponse } from 'next/server'\n-import * as userland from ${JSON.stringify(resourcePath)}\n+import { default as handler, generateSitemaps } from ${JSON.stringify(resourcePath)}\n import { resolveRouteData } from 'next/dist/build/webpack/loaders/metadata/resolve-route-data'\n \n-const sitemapModule = { ...userland }\n-const handler = sitemapModule.default\n const contentType = ${JSON.stringify(getContentType(resourcePath))}\n const fileType = ${JSON.stringify(getFilenameAndExtension(resourcePath).name)}\n \n@@ -288,18 +296,24 @@ ${await createReExportsCode(resourcePath, loaderContext)}\n export async function GET(_, ctx) {\n   const { __metadata_id__: id, ...params } = await ctx.params || {}\n   const hasXmlExtension = id ? id.endsWith('.xml') : false\n-  if (id && !hasXmlExtension) {\n-    return new NextResponse('Not Found', {\n-      status: 404,\n-    })\n-  }\n \n-  if (process.env.NODE_ENV !== 'production' && sitemapModule.generateSitemaps) {\n-    const sitemaps = await sitemapModule.generateSitemaps()\n+  if (process.env.NODE_ENV !== 'production') {\n+    const sitemaps = await generateSitemaps()\n+    let foundId\n     for (const item of sitemaps) {\n       if (item?.id == null) {\n         throw new Error('id property is required for every item returned from generateSitemaps')\n       }\n+      \n+      const baseId = id && hasXmlExtension ? id.slice(0, -4) : undefined\n+      if (item.id.toString() === baseId) {\n+        foundId = item.id\n+      }\n+    }\n+    if (foundId == null) {\n+      return new NextResponse('Not Found', {\n+        status: 404,\n+      })\n     }\n   }\n \n@@ -315,11 +329,42 @@ export async function GET(_, ctx) {\n   })\n }\n \n-${staticGenerationCode}\n+export const dynamicParams = false\n+export async function generateStaticParams() {\n+  const sitemaps = await generateSitemaps()\n+  const params = []\n+\n+  for (const item of sitemaps) {\n+    if (item?.id == null) {\n+      throw new Error('id property is required for every item returned from generateSitemaps')\n+    }\n+    params.push({ __metadata_id__: item.id.toString() + '.xml' })\n+  }\n+  return params\n+}\n `\n   return code\n }\n \n+// <metadata-sitemap>/[id]/route.js\n+async function getSitemapRouteCode(\n+  resourcePath: string,\n+  loaderContext: webpack.LoaderContext<any>\n+) {\n+  const exportNames = await getLoaderModuleNamedExports(\n+    resourcePath,\n+    loaderContext\n+  )\n+\n+  const hasGenerateSitemaps = exportNames.includes('generateSitemaps')\n+\n+  if (hasGenerateSitemaps) {\n+    return getDynamicSitemapRouteCode(resourcePath, loaderContext)\n+  } else {\n+    return getSingleSitemapRouteCode(resourcePath, loaderContext)\n+  }\n+}\n+\n // When it's static route, it could be favicon.ico, sitemap.xml, robots.txt etc.\n // TODO-METADATA: improve the cache control strategy\n const nextMetadataRouterLoader: webpack.LoaderDefinitionFunction<MetadataRouteLoaderOptions> =\n@@ -333,7 +378,7 @@ const nextMetadataRouterLoader: webpack.LoaderDefinitionFunction<MetadataRouteLo\n       if (fileBaseName === 'robots' || fileBaseName === 'manifest') {\n         code = await getDynamicTextRouteCode(filePath, this)\n       } else if (fileBaseName === 'sitemap') {\n-        code = await getDynamicSitemapRouteCode(filePath, this)\n+        code = await getSitemapRouteCode(filePath, this)\n       } else {\n         code = await getImageRouteCode(filePath, this)\n       }"
        },
        {
            "sha": "2c4d0fbadb5385719babb5791fd1ccb2645ec9b4",
            "filename": "test/e2e/app-dir/metadata-dynamic-routes/index.test.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/ede8d1b861378b4b8aa7ff77ad2cacd583d9b21d/test%2Fe2e%2Fapp-dir%2Fmetadata-dynamic-routes%2Findex.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/ede8d1b861378b4b8aa7ff77ad2cacd583d9b21d/test%2Fe2e%2Fapp-dir%2Fmetadata-dynamic-routes%2Findex.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fmetadata-dynamic-routes%2Findex.test.ts?ref=ede8d1b861378b4b8aa7ff77ad2cacd583d9b21d",
            "patch": "@@ -86,6 +86,11 @@ describe('app dir - metadata dynamic routes', () => {\n       }\n     })\n \n+    it('should 404 for non-existing id from generateImageMetadata', async () => {\n+      const res = await next.fetch('/gsp/icon/non-existing-id')\n+      expect(res.status).toBe(404)\n+    })\n+\n     it('should not throw if client components are imported but not used in sitemap', async () => {\n       const { status } = await next.fetch('/client-ref-dependency/sitemap.xml')\n       expect(status).toBe(200)"
        }
    ],
    "stats": {
        "total": 389,
        "additions": 238,
        "deletions": 151
    }
}