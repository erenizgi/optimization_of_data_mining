{
    "author": "lubieowoce",
    "message": "Always apply render preparations after running an action (#77898)\n\nThis PR centralizes some logic that we always want to run after\nexecuting a server action into `executeActionAndPrepareForRender`. This\nfixes some issues where we were only executing revalidates, setting\ndraft mode, and synchronizing mutated cookies for fetch actions, but not\nMPA actions.\n\nI've also moved the logic for `addRevalidationHeader` to the one place\nwhere it makes sense -- after executing a fetch action. This header is\nonly used by the client router and only makes sense to add if we\nactually executed an action, so e.g. calling it for each possible error\ntype was unnecessary.",
    "sha": "c784c6f0dfa02df0ce0a6b969be3f1bd146f2cfc",
    "files": [
        {
            "sha": "0363a96426bee6229f1d2ae0b4d7dbb6f43ca5a9",
            "filename": "packages/next/src/server/app-render/action-handler.ts",
            "status": "modified",
            "additions": 57,
            "deletions": 57,
            "changes": 114,
            "blob_url": "https://github.com/vercel/next.js/blob/c784c6f0dfa02df0ce0a6b969be3f1bd146f2cfc/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Faction-handler.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/c784c6f0dfa02df0ce0a6b969be3f1bd146f2cfc/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Faction-handler.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Faction-handler.ts?ref=c784c6f0dfa02df0ce0a6b969be3f1bd146f2cfc",
            "patch": "@@ -501,20 +501,6 @@ export async function handleAction({\n \n   let temporaryReferences: TemporaryReferenceSet | undefined\n \n-  const finalizeAndGenerateFlight: GenerateFlight = (...args) => {\n-    // When we switch to the render phase, cookies() will return\n-    // `workUnitStore.cookies` instead of `workUnitStore.userspaceMutableCookies`.\n-    // We want the render to see any cookie writes that we performed during the action,\n-    // so we need to update the immutable cookies to reflect the changes.\n-    synchronizeMutableCookies(requestStore)\n-\n-    // The server action might have toggled draft mode, so we need to reflect\n-    // that in the work store to be up-to-date for subsequent rendering.\n-    workStore.isDraftMode = requestStore.draftMode.isEnabled\n-\n-    return generateFlight(...args)\n-  }\n-\n   // When running actions the default is no-store, you can still `cache: 'force-cache'`\n   workStore.fetchCache = 'default-no-store'\n \n@@ -566,7 +552,6 @@ export async function handleAction({\n \n       if (isFetchAction) {\n         res.statusCode = 500\n-        await executeRevalidates(workStore)\n \n         const promise = Promise.reject(error)\n         try {\n@@ -581,10 +566,10 @@ export async function handleAction({\n \n         return {\n           type: 'done',\n-          result: await finalizeAndGenerateFlight(req, ctx, requestStore, {\n+          result: await generateFlight(req, ctx, requestStore, {\n             actionResult: promise,\n-            // if the page was not revalidated, we can skip the rendering the flight tree\n-            skipFlight: !workStore.pathWasRevalidated,\n+            // We didn't execute an action, so no revalidations could have occurred. We can skip rendering the page.\n+            skipFlight: true,\n             temporaryReferences,\n           }),\n         }\n@@ -672,16 +657,13 @@ export async function handleAction({\n               // Only warn if it's a server action, otherwise skip for other post requests\n               warnBadServerActionRequest()\n \n-              let actionReturnedState: unknown\n-              requestStore.phase = 'action'\n-              try {\n-                actionReturnedState = await workUnitAsyncStorage.run(\n-                  requestStore,\n-                  action\n+              const actionReturnedState =\n+                await executeActionAndPrepareForRender(\n+                  action as () => Promise<unknown>,\n+                  [],\n+                  workStore,\n+                  requestStore\n                 )\n-              } finally {\n-                requestStore.phase = 'render'\n-              }\n \n               formState = await decodeFormState(\n                 actionReturnedState,\n@@ -846,16 +828,13 @@ export async function handleAction({\n               // Only warn if it's a server action, otherwise skip for other post requests\n               warnBadServerActionRequest()\n \n-              let actionReturnedState: unknown\n-              requestStore.phase = 'action'\n-              try {\n-                actionReturnedState = await workUnitAsyncStorage.run(\n-                  requestStore,\n-                  action\n+              const actionReturnedState =\n+                await executeActionAndPrepareForRender(\n+                  action as () => Promise<unknown>,\n+                  [],\n+                  workStore,\n+                  requestStore\n                 )\n-              } finally {\n-                requestStore.phase = 'render'\n-              }\n \n               formState = await decodeFormState(\n                 actionReturnedState,\n@@ -938,22 +917,18 @@ export async function handleAction({\n           actionId!\n         ]\n \n-      let returnVal: unknown\n-      requestStore.phase = 'action'\n-      try {\n-        returnVal = await workUnitAsyncStorage.run(requestStore, () =>\n-          actionHandler.apply(null, boundActionArguments)\n-        )\n-      } finally {\n-        requestStore.phase = 'render'\n-      }\n+      const returnVal = await executeActionAndPrepareForRender(\n+        actionHandler,\n+        boundActionArguments,\n+        workStore,\n+        requestStore\n+      ).finally(() => {\n+        addRevalidationHeader(res, { workStore, requestStore })\n+      })\n \n       // For form actions, we need to continue rendering the page.\n       if (isFetchAction) {\n-        await executeRevalidates(workStore)\n-        addRevalidationHeader(res, { workStore, requestStore })\n-\n-        actionResult = await finalizeAndGenerateFlight(req, ctx, requestStore, {\n+        actionResult = await generateFlight(req, ctx, requestStore, {\n           actionResult: Promise.resolve(returnVal),\n           // if the page was not revalidated, or if the action was forwarded from another worker, we can skip the rendering the flight tree\n           skipFlight: !workStore.pathWasRevalidated || actionWasForwarded,\n@@ -972,9 +947,6 @@ export async function handleAction({\n       const redirectUrl = getURLFromRedirectError(err)\n       const redirectType = getRedirectTypeFromError(err)\n \n-      await executeRevalidates(workStore)\n-      addRevalidationHeader(res, { workStore, requestStore })\n-\n       // if it's a fetch action, we'll set the status code for logging/debugging purposes\n       // but we won't set a Location header, as the redirect will be handled by the client router\n       res.statusCode = RedirectStatusCode.SeeOther\n@@ -1002,9 +974,6 @@ export async function handleAction({\n     } else if (isHTTPAccessFallbackError(err)) {\n       res.statusCode = getAccessFallbackHTTPStatus(err)\n \n-      await executeRevalidates(workStore)\n-      addRevalidationHeader(res, { workStore, requestStore })\n-\n       if (isFetchAction) {\n         const promise = Promise.reject(err)\n         try {\n@@ -1018,7 +987,7 @@ export async function handleAction({\n         }\n         return {\n           type: 'done',\n-          result: await finalizeAndGenerateFlight(req, ctx, requestStore, {\n+          result: await generateFlight(req, ctx, requestStore, {\n             skipFlight: false,\n             actionResult: promise,\n             temporaryReferences,\n@@ -1035,7 +1004,6 @@ export async function handleAction({\n       // so that we can respond with a 413 to requests that break the body size limit\n       // (but if we do that, we also need to make sure that whatever handles the non-fetch error path below does the same)\n       res.statusCode = 500\n-      await executeRevalidates(workStore)\n       const promise = Promise.reject(err)\n       try {\n         // we need to await the promise to trigger the rejection early\n@@ -1062,6 +1030,38 @@ export async function handleAction({\n   }\n }\n \n+async function executeActionAndPrepareForRender<\n+  TFn extends (...args: any[]) => Promise<any>,\n+>(\n+  action: TFn,\n+  args: Parameters<TFn>,\n+  workStore: WorkStore,\n+  requestStore: RequestStore\n+): Promise<Awaited<ReturnType<TFn>>> {\n+  requestStore.phase = 'action'\n+  try {\n+    return await workUnitAsyncStorage.run(requestStore, () =>\n+      action.apply(null, args)\n+    )\n+  } finally {\n+    requestStore.phase = 'render'\n+\n+    // When we switch to the render phase, cookies() will return\n+    // `workUnitStore.cookies` instead of `workUnitStore.userspaceMutableCookies`.\n+    // We want the render to see any cookie writes that we performed during the action,\n+    // so we need to update the immutable cookies to reflect the changes.\n+    synchronizeMutableCookies(requestStore)\n+\n+    // The server action might have toggled draft mode, so we need to reflect\n+    // that in the work store to be up-to-date for subsequent rendering.\n+    workStore.isDraftMode = requestStore.draftMode.isEnabled\n+\n+    // If the action called revalidateTag/revalidatePath, then that might affect data used by the subsequent render,\n+    // so we need to make sure all revalidations are applied before that\n+    await executeRevalidates(workStore)\n+  }\n+}\n+\n /**\n  * Attempts to find the module ID for the action from the module map. When this fails, it could be a deployment skew where\n  * the action came from a different deployment. It could also simply be an invalid POST request that is not a server action."
        },
        {
            "sha": "094f1b6187f6385604dad76efab616c37ef6941a",
            "filename": "test/e2e/app-dir/use-cache/use-cache.test.ts",
            "status": "modified",
            "additions": 92,
            "deletions": 67,
            "changes": 159,
            "blob_url": "https://github.com/vercel/next.js/blob/c784c6f0dfa02df0ce0a6b969be3f1bd146f2cfc/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fuse-cache.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/c784c6f0dfa02df0ce0a6b969be3f1bd146f2cfc/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fuse-cache.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fuse-cache.test.ts?ref=c784c6f0dfa02df0ce0a6b969be3f1bd146f2cfc",
            "patch": "@@ -740,96 +740,121 @@ describe('use-cache', () => {\n     expect(text).toBe('This page could not be found.')\n   })\n \n-  it('should not read nor write cached data when draft mode is enabled', async () => {\n-    const browser = await next.browser('/draft-mode')\n+  it.each([\n+    { description: 'js enabled', disableJavaScript: false },\n+    { description: 'js disabled', disableJavaScript: true },\n+  ])(\n+    'should not read nor write cached data when draft mode is enabled: $description',\n+    async ({ disableJavaScript }) => {\n+      const browser = await next.browser('/draft-mode', {\n+        // This test relies on a server action to set draft mode.\n+        // To ensure that it works for both fetch actions and MPA actions,\n+        // we test it with javascript disabled too.\n+        // (this is because of a bug where draft mode status was not correctly propagated to the workStore for MPA actions)\n+        disableJavaScript,\n+      })\n \n-    expect(await browser.elementByCss('button#toggle').text()).toBe(\n-      'Enable Draft Mode'\n-    )\n+      const refreshAfterServerAction = async () => {\n+        if (disableJavaScript) {\n+          // browser.refresh() seems to automatically resubmit POST requests,\n+          // so if we submitted an MPA action, it'll trigger the action again,\n+          // which in this case will toggle draftMode again.\n+          await browser.get(new URL('/draft-mode', next.url).href)\n+        } else {\n+          await browser.refresh()\n+        }\n+      }\n \n-    let initialTopLevelValue = await browser.elementById('top-level').text()\n+      expect(await browser.elementByCss('button#toggle').text()).toBe(\n+        'Enable Draft Mode'\n+      )\n \n-    if (isNextDeploy) {\n-      await retry(async () => {\n-        // Wait for the background revalidation after the deployment to settle.\n-        await browser.refresh()\n+      let initialTopLevelValue = await browser.elementById('top-level').text()\n \n-        expect(await browser.elementById('top-level').text()).not.toBe(\n-          initialTopLevelValue\n-        )\n-      })\n+      if (isNextDeploy) {\n+        await retry(async () => {\n+          // Wait for the background revalidation after the deployment to settle.\n+          await browser.refresh()\n \n-      initialTopLevelValue = await browser.elementById('top-level').text()\n-    }\n+          expect(await browser.elementById('top-level').text()).not.toBe(\n+            initialTopLevelValue\n+          )\n+        })\n \n-    // Draft mode is disabled, cached data should be returned on refresh.\n+        initialTopLevelValue = await browser.elementById('top-level').text()\n+      }\n \n-    const initialClosureValue = await browser.elementById('closure').text()\n+      // Draft mode is disabled, cached data should be returned on refresh.\n \n-    await browser.refresh()\n+      const initialClosureValue = await browser.elementById('closure').text()\n \n-    expect(await browser.elementById('top-level').text()).toBe(\n-      initialTopLevelValue\n-    )\n-    expect(await browser.elementById('closure').text()).toBe(\n-      initialClosureValue\n-    )\n+      await browser.refresh()\n \n-    await browser.elementByCss('button#toggle').click()\n-    await browser.waitForElementByCss('button#toggle:enabled')\n+      expect(await browser.elementById('top-level').text()).toBe(\n+        initialTopLevelValue\n+      )\n+      expect(await browser.elementById('closure').text()).toBe(\n+        initialClosureValue\n+      )\n \n-    expect(await browser.elementByCss('button#toggle').text()).toBe(\n-      'Disable Draft Mode'\n-    )\n+      await browser.elementByCss('button#toggle').click()\n+      await browser.waitForElementByCss('button#toggle:enabled')\n \n-    // Draft mode is now enabled, no cached data should be returned on refresh.\n+      expect(await browser.elementByCss('button#toggle').text()).toBe(\n+        'Disable Draft Mode'\n+      )\n \n-    const newTopLevelValue = await browser.elementById('top-level').text()\n-    const newClosureValue = await browser.elementById('closure').text()\n-    console.log(await browser.elementById('top-level').text())\n+      // Draft mode is now enabled, no cached data should be returned on refresh.\n \n-    expect(newTopLevelValue).not.toBe(initialTopLevelValue)\n-    expect(newClosureValue).not.toBe(initialClosureValue)\n+      const newTopLevelValue = await browser.elementById('top-level').text()\n+      const newClosureValue = await browser.elementById('closure').text()\n+      console.log(await browser.elementById('top-level').text())\n \n-    await browser.refresh()\n+      expect(newTopLevelValue).not.toBe(initialTopLevelValue)\n+      expect(newClosureValue).not.toBe(initialClosureValue)\n \n-    expect(await browser.elementById('top-level').text()).not.toBe(\n-      newTopLevelValue\n-    )\n-    console.log(await browser.elementById('top-level').text())\n+      await refreshAfterServerAction()\n \n-    expect(await browser.elementById('closure').text()).not.toBe(\n-      newClosureValue\n-    )\n+      expect(await browser.elementById('top-level').text()).not.toBe(\n+        newTopLevelValue\n+      )\n+      console.log(await browser.elementById('top-level').text())\n \n-    // Accessing request-scoped data should still not be allowed.\n-    expect(\n-      await browser\n-        .elementById('is-accessing-request-scoped-data-allowed-in-use-cache')\n-        .text()\n-    ).toBe('false')\n+      expect(await browser.elementById('closure').text()).not.toBe(\n+        newClosureValue\n+      )\n \n-    await browser.elementByCss('button#toggle').click()\n-    await browser.waitForElementByCss('button#toggle:enabled')\n+      // Accessing request-scoped data should still not be allowed.\n+      expect(\n+        await browser\n+          .elementById('is-accessing-request-scoped-data-allowed-in-use-cache')\n+          .text()\n+      ).toBe('false')\n \n-    expect(await browser.elementByCss('button#toggle').text()).toBe(\n-      'Enable Draft Mode'\n-    )\n+      await browser.elementByCss('button#toggle').click()\n+      await browser.waitForElementByCss('button#toggle:enabled')\n \n-    // Draft mode is disabled again, the initially cached data should be\n-    // returned again.\n+      expect(await browser.elementByCss('button#toggle').text()).toBe(\n+        'Enable Draft Mode'\n+      )\n \n-    console.log(await browser.elementById('top-level').text())\n-    await browser.refresh()\n-    console.log(await browser.elementById('top-level').text())\n+      // Draft mode is disabled again, the initially cached data should be\n+      // returned again.\n \n-    expect(await browser.elementById('top-level').text()).toBe(\n-      initialTopLevelValue\n-    )\n-    expect(await browser.elementById('closure').text()).toBe(\n-      initialClosureValue\n-    )\n-  })\n+      console.log(await browser.elementById('top-level').text())\n+\n+      await refreshAfterServerAction()\n+\n+      console.log(await browser.elementById('top-level').text())\n+\n+      expect(await browser.elementById('top-level').text()).toBe(\n+        initialTopLevelValue\n+      )\n+      expect(await browser.elementById('closure').text()).toBe(\n+        initialClosureValue\n+      )\n+    }\n+  )\n \n   if (isNextDev) {\n     it('should not have unhandled rejection of Request data promises when use cache is enabled without dynamicIO', async () => {"
        }
    ],
    "stats": {
        "total": 273,
        "additions": 149,
        "deletions": 124
    }
}