{
    "author": "bgw",
    "message": "refactor(turbo-tasks): Tighten up id factory overflow checks, tweak API to make construction easier (#78486)\n\n- Prefer construction of `IdFactory<T>` with value of type `T` instead of `u64`, except in cases where we can't because of limitations with `const`.\n- Always start the internal counter at 0 so that our assumptions of overflowing a `u64` type hold. A test is included for this.\n- Add an extra debug assertion (and abort) in the bizarre case that a `u64` does overflow.\n- Remove unused type bounds from `register_thing` and `get_thing_id`.\n- Avoid `as` casts as much as possible (these have silent overflow behavior).\n\nI did this prior to https://github.com/vercel/next.js/pull/78487 because I add an intentionally-overflowing id factory method there.",
    "sha": "05784122a677d0b6a166561f482ad60314b13976",
    "files": [
        {
            "sha": "a9ba3fdc9d99ee69495c88cf53c716856c6efc4a",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/05784122a677d0b6a166561f482ad60314b13976/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/05784122a677d0b6a166561f482ad60314b13976/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=05784122a677d0b6a166561f482ad60314b13976",
            "patch": "@@ -218,12 +218,12 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             start_time: Instant::now(),\n             session_id: backing_storage.next_session_id(),\n             persisted_task_id_factory: IdFactoryWithReuse::new(\n-                *backing_storage.next_free_task_id() as u64,\n-                (TRANSIENT_TASK_BIT - 1) as u64,\n+                backing_storage.next_free_task_id(),\n+                TaskId::try_from(TRANSIENT_TASK_BIT - 1).unwrap(),\n             ),\n             transient_task_id_factory: IdFactoryWithReuse::new(\n-                TRANSIENT_TASK_BIT as u64,\n-                u32::MAX as u64,\n+                TaskId::try_from(TRANSIENT_TASK_BIT).unwrap(),\n+                TaskId::MAX,\n             ),\n             persisted_task_cache_log: need_log.then(|| Sharded::new(shard_amount)),\n             task_cache: BiMap::new(),"
        },
        {
            "sha": "a300f0c4e37db254e916e82391963b30e0c75d8d",
            "filename": "turbopack/crates/turbo-tasks-backend/src/kv_backing_storage.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 3,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/05784122a677d0b6a166561f482ad60314b13976/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fkv_backing_storage.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/05784122a677d0b6a166561f482ad60314b13976/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fkv_backing_storage.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fkv_backing_storage.rs?ref=05784122a677d0b6a166561f482ad60314b13976",
            "patch": "@@ -128,11 +128,13 @@ impl<T: KeyValueDatabase + Send + Sync + 'static> BackingStorage\n     }\n \n     fn next_free_task_id(&self) -> TaskId {\n-        TaskId::from(get_infra_u32(&self.database, META_KEY_NEXT_FREE_TASK_ID).unwrap_or(1))\n+        TaskId::try_from(get_infra_u32(&self.database, META_KEY_NEXT_FREE_TASK_ID).unwrap_or(1))\n+            .unwrap()\n     }\n \n     fn next_session_id(&self) -> SessionId {\n-        SessionId::from(get_infra_u32(&self.database, META_KEY_SESSION_ID).unwrap_or(0) + 1)\n+        SessionId::try_from(get_infra_u32(&self.database, META_KEY_SESSION_ID).unwrap_or(0) + 1)\n+            .unwrap()\n     }\n \n     fn uncompleted_operations(&self) -> Vec<AnyOperation> {\n@@ -367,7 +369,7 @@ impl<T: KeyValueDatabase + Send + Sync + 'static> BackingStorage\n                 return Ok(None);\n             };\n             let bytes = bytes.borrow().try_into()?;\n-            let id = TaskId::from(u32::from_le_bytes(bytes));\n+            let id = TaskId::try_from(u32::from_le_bytes(bytes)).unwrap();\n             Ok(Some(id))\n         }\n         if self.database.is_empty() {"
        },
        {
            "sha": "fb6b0862a149486c3cc138dc2f110ddd5929baa6",
            "filename": "turbopack/crates/turbo-tasks-memory/src/memory_backend.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/05784122a677d0b6a166561f482ad60314b13976/turbopack%2Fcrates%2Fturbo-tasks-memory%2Fsrc%2Fmemory_backend.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/05784122a677d0b6a166561f482ad60314b13976/turbopack%2Fcrates%2Fturbo-tasks-memory%2Fsrc%2Fmemory_backend.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-memory%2Fsrc%2Fmemory_backend.rs?ref=05784122a677d0b6a166561f482ad60314b13976",
            "patch": "@@ -79,7 +79,7 @@ impl MemoryBackend {\n             persistent_tasks: NoMoveVec::new(),\n             transient_tasks: NoMoveVec::new(),\n             backend_jobs: NoMoveVec::new(),\n-            backend_job_id_factory: IdFactoryWithReuse::new(1, u32::MAX as u64),\n+            backend_job_id_factory: IdFactoryWithReuse::new(BackendJobId::MIN, BackendJobId::MAX),\n             task_cache: DashMap::with_hasher_and_shard_amount(Default::default(), shard_amount),\n             transient_task_cache: DashMap::with_hasher_and_shard_amount(\n                 Default::default(),"
        },
        {
            "sha": "4b456ed021c6b37bec2ec7b2c3b2f70a08861c17",
            "filename": "turbopack/crates/turbo-tasks-testing/src/lib.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/05784122a677d0b6a166561f482ad60314b13976/turbopack%2Fcrates%2Fturbo-tasks-testing%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/05784122a677d0b6a166561f482ad60314b13976/turbopack%2Fcrates%2Fturbo-tasks-testing%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-testing%2Fsrc%2Flib.rs?ref=05784122a677d0b6a166561f482ad60314b13976",
            "patch": "@@ -56,7 +56,7 @@ impl VcStorage {\n             })));\n             i\n         };\n-        let task_id = TaskId::from(i as u32 + 1);\n+        let task_id = TaskId::try_from(u32::try_from(i + 1).unwrap()).unwrap();\n         handle.spawn(with_turbo_tasks_for_testing(\n             this.clone(),\n             task_id,\n@@ -321,7 +321,7 @@ impl VcStorage {\n                 this: weak.clone(),\n                 ..Default::default()\n             }),\n-            TaskId::from(u32::MAX),\n+            TaskId::MAX,\n             f,\n         )\n     }"
        },
        {
            "sha": "8d59be34354c4aa33ca08d09fd9e73641973bdf2",
            "filename": "turbopack/crates/turbo-tasks/src/id.rs",
            "status": "modified",
            "additions": 45,
            "deletions": 12,
            "changes": 57,
            "blob_url": "https://github.com/vercel/next.js/blob/05784122a677d0b6a166561f482ad60314b13976/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fid.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/05784122a677d0b6a166561f482ad60314b13976/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fid.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fid.rs?ref=05784122a677d0b6a166561f482ad60314b13976",
            "patch": "@@ -29,6 +29,9 @@ macro_rules! define_id {\n         }\n \n         impl $name {\n+            pub const MIN: Self = Self { id: NonZero::<$primitive>::MIN };\n+            pub const MAX: Self = Self { id: NonZero::<$primitive>::MAX };\n+\n             /// Constructs a wrapper type from the numeric identifier.\n             ///\n             /// # Safety\n@@ -37,6 +40,15 @@ macro_rules! define_id {\n             pub const unsafe fn new_unchecked(id: $primitive) -> Self {\n                 Self { id: unsafe { NonZero::<$primitive>::new_unchecked(id) } }\n             }\n+\n+            /// Allows `const` conversion to a [`NonZeroU64`], useful with\n+            /// [`crate::id_factory::IdFactory::new_const`].\n+            pub const fn to_non_zero_u64(self) -> NonZeroU64 {\n+                const {\n+                    assert!(<$primitive>::BITS <= u64::BITS);\n+                }\n+                unsafe { NonZeroU64::new_unchecked(self.id.get() as u64) }\n+            }\n         }\n \n         impl Display for $name {\n@@ -53,30 +65,51 @@ macro_rules! define_id {\n             }\n         }\n \n-        /// Converts a numeric identifier to the wrapper type.\n-        ///\n-        /// Panics if the given id value is zero.\n-        impl From<$primitive> for $name {\n-            fn from(id: $primitive) -> Self {\n+        define_id!(@impl_try_from_primitive_conversion $name $primitive);\n+\n+        impl From<NonZero<$primitive>> for $name {\n+            fn from(id: NonZero::<$primitive>) -> Self {\n                 Self {\n-                    id: NonZero::<$primitive>::new(id)\n-                        .expect(\"Ids can only be created from non zero values\")\n+                    id,\n                 }\n             }\n         }\n \n-        /// Converts a numeric identifier to the wrapper type.\n+        impl From<$name> for NonZeroU64 {\n+            fn from(id: $name) -> Self {\n+                id.to_non_zero_u64()\n+            }\n+        }\n+\n+        impl TraceRawVcs for $name {\n+            fn trace_raw_vcs(&self, _trace_context: &mut TraceRawVcsContext) {}\n+        }\n+    };\n+    (\n+        @impl_try_from_primitive_conversion $name:ident u64\n+    ) => {\n+        // we get a `TryFrom` blanket impl for free via the `From` impl\n+    };\n+    (\n+        @impl_try_from_primitive_conversion $name:ident $primitive:ty\n+    ) => {\n+        impl TryFrom<$primitive> for $name {\n+            type Error = TryFromIntError;\n+\n+            fn try_from(id: $primitive) -> Result<Self, Self::Error> {\n+                Ok(Self {\n+                    id: NonZero::try_from(id)?\n+                })\n+            }\n+        }\n+\n         impl TryFrom<NonZeroU64> for $name {\n             type Error = TryFromIntError;\n \n             fn try_from(id: NonZeroU64) -> Result<Self, Self::Error> {\n                 Ok(Self { id: NonZero::try_from(id)? })\n             }\n         }\n-\n-        impl TraceRawVcs for $name {\n-            fn trace_raw_vcs(&self, _trace_context: &mut TraceRawVcsContext) {}\n-        }\n     };\n }\n "
        },
        {
            "sha": "5a1fc754b4284701a5bbc485d6d5a5808d31f406",
            "filename": "turbopack/crates/turbo-tasks/src/id_factory.rs",
            "status": "modified",
            "additions": 91,
            "deletions": 29,
            "changes": 120,
            "blob_url": "https://github.com/vercel/next.js/blob/05784122a677d0b6a166561f482ad60314b13976/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fid_factory.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/05784122a677d0b6a166561f482ad60314b13976/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fid_factory.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fid_factory.rs?ref=05784122a677d0b6a166561f482ad60314b13976",
            "patch": "@@ -11,16 +11,36 @@ use concurrent_queue::ConcurrentQueue;\n ///\n /// For ids that may be re-used, see [`IdFactoryWithReuse`].\n pub struct IdFactory<T> {\n-    next_id: AtomicU64,\n-    max_id: u64,\n+    /// A value starting at 0 and incremented each time a new id is allocated. Regardless of the\n+    /// underlying type, a u64 is used to cheaply detect overflows.\n+    counter: AtomicU64,\n+    /// We've overflowed if the `counter > max_count`.\n+    max_count: u64,\n+    id_offset: u64, // added to the value received from `counter`\n     _phantom_data: PhantomData<T>,\n }\n \n impl<T> IdFactory<T> {\n-    pub const fn new(start: u64, max: u64) -> Self {\n+    /// Create a factory for ids in the range `start..=max`.\n+    pub fn new(start: T, max: T) -> Self\n+    where\n+        T: Into<NonZeroU64> + Ord,\n+    {\n+        Self::new_const(start.into(), max.into())\n+    }\n+\n+    /// Create a factory for ids in the range `start..=max`.\n+    ///\n+    /// Provides a less convenient API than [`IdFactory::new`], but skips a type conversion that\n+    /// would make the function non-const.\n+    pub const fn new_const(start: NonZeroU64, max: NonZeroU64) -> Self {\n+        assert!(start.get() < max.get());\n         Self {\n-            next_id: AtomicU64::new(start),\n-            max_id: max,\n+            // Always start `counter` at 0, don't use the value of `start` because `start` could be\n+            // close to `u64::MAX`.\n+            counter: AtomicU64::new(0),\n+            max_count: max.get() - start.get(),\n+            id_offset: start.get(),\n             _phantom_data: PhantomData,\n         }\n     }\n@@ -32,47 +52,80 @@ where\n {\n     /// Return a unique new id.\n     ///\n-    /// Panics (best-effort) if the id type overflows.\n+    /// Panics if the id type overflows.\n     pub fn get(&self) -> T {\n-        let new_id = self.next_id.fetch_add(1, Ordering::Relaxed);\n+        let count = self.counter.fetch_add(1, Ordering::Relaxed);\n+\n+        #[cfg(debug_assertions)]\n+        {\n+            if count == u64::MAX {\n+                // u64 counter is about to overflow -- this should never happen! A `u64` counter\n+                // starting at 0 should take decades to overflow on a single machine.\n+                //\n+                // This is unrecoverable because other threads may have already read the overflowed\n+                // value, so abort the entire process.\n+                std::process::abort()\n+            }\n+        }\n \n-        if new_id > self.max_id {\n+        // `max_count` might be something like `u32::MAX`. The extra bits of `u64` are useful to\n+        // detect overflows in that case. We assume the u64 counter is large enough to never\n+        // overflow.\n+        if count > self.max_count {\n             panic!(\n-                \"Max id limit hit while attempting to generate a unique {}\",\n+                \"Max id limit (overflow) hit while attempting to generate a unique {}\",\n                 type_name::<T>(),\n             )\n         }\n \n-        // Safety: u64 will not overflow. This is *very* unlikely to happen (would take\n-        // decades).\n-        let new_id = unsafe { NonZeroU64::new_unchecked(new_id) };\n+        let new_id_u64 = count + self.id_offset;\n+        // Safety:\n+        // - `count` is assumed not to overflow.\n+        // - `id_offset` is a non-zero value.\n+        // - `id_offset + count < u64::MAX`.\n+        let new_id = unsafe { NonZeroU64::new_unchecked(new_id_u64) };\n \n-        // Use the extra bits of the AtomicU64 as cheap overflow detection when the\n-        // value is less than 64 bits.\n         match new_id.try_into() {\n             Ok(id) => id,\n+            // With any sane implementation of `TryFrom`, this shouldn't happen, as we've already\n+            // checked the `max_count` bound. (Could happen with the `new_const` constructor)\n             Err(_) => panic!(\n-                \"Overflow detected while attempting to generate a unique {}\",\n-                type_name::<T>(),\n+                \"Failed to convert NonZeroU64 value of {} into {}\",\n+                new_id,\n+                type_name::<T>()\n             ),\n         }\n     }\n }\n \n-/// An [`IdFactory`], but extended with a free list to allow for id reuse for\n-/// ids such as [`BackendJobId`][crate::backend::BackendJobId].\n+/// An [`IdFactory`], but extended with a free list to allow for id reuse for ids such as\n+/// [`BackendJobId`][crate::backend::BackendJobId].\n pub struct IdFactoryWithReuse<T> {\n     factory: IdFactory<T>,\n     free_ids: ConcurrentQueue<T>,\n }\n \n-impl<T> IdFactoryWithReuse<T> {\n-    pub const fn new(start: u64, max: u64) -> Self {\n+impl<T> IdFactoryWithReuse<T>\n+where\n+    T: Into<NonZeroU64> + Ord,\n+{\n+    /// Create a factory for ids in the range `start..=max`.\n+    pub fn new(start: T, max: T) -> Self {\n         Self {\n             factory: IdFactory::new(start, max),\n             free_ids: ConcurrentQueue::unbounded(),\n         }\n     }\n+\n+    /// Create a factory for ids in the range `start..=max`. Provides a less convenient API than\n+    /// [`IdFactoryWithReuse::new`], but skips a type conversion that would make the function\n+    /// non-const.\n+    pub const fn new_const(start: NonZeroU64, max: NonZeroU64) -> Self {\n+        Self {\n+            factory: IdFactory::new_const(start, max),\n+            free_ids: ConcurrentQueue::unbounded(),\n+        }\n+    }\n }\n \n impl<T> IdFactoryWithReuse<T>\n@@ -81,18 +134,18 @@ where\n {\n     /// Return a new or potentially reused id.\n     ///\n-    /// Panics (best-effort) if the id type overflows.\n+    /// Panics if the id type overflows.\n     pub fn get(&self) -> T {\n         self.free_ids.pop().unwrap_or_else(|_| self.factory.get())\n     }\n \n-    /// Add an id to the free list, allowing it to be re-used on a subsequent\n-    /// call to [`IdFactoryWithReuse::get`].\n+    /// Add an id to the free list, allowing it to be re-used on a subsequent call to\n+    /// [`IdFactoryWithReuse::get`].\n     ///\n     /// # Safety\n     ///\n-    /// It must be ensured that the id is no longer used. Id must be a valid id\n-    /// that was previously returned by `get`.\n+    /// The id must no longer be used. Must be a valid id that was previously returned by\n+    /// [`IdFactoryWithReuse::get`].\n     pub unsafe fn reuse(&self, id: T) {\n         let _ = self.free_ids.push(id);\n     }\n@@ -105,12 +158,21 @@ mod tests {\n     use super::*;\n \n     #[test]\n-    #[should_panic(expected = \"Overflow detected\")]\n-    fn test_overflow() {\n-        let factory = IdFactory::<NonZeroU8>::new(1, u16::MAX as u64);\n+    #[should_panic(expected = \"Max id limit (overflow)\")]\n+    fn test_overflow_detection() {\n+        let factory = IdFactory::new(NonZeroU8::MIN, NonZeroU8::MAX);\n         assert_eq!(factory.get(), NonZeroU8::new(1).unwrap());\n         assert_eq!(factory.get(), NonZeroU8::new(2).unwrap());\n-        for _i in 2..256 {\n+        for _ in 2..256 {\n+            factory.get();\n+        }\n+    }\n+\n+    #[test]\n+    #[should_panic(expected = \"Max id limit (overflow)\")]\n+    fn test_overflow_detection_near_u64_max() {\n+        let factory = IdFactory::new(NonZeroU64::try_from(u64::MAX - 5).unwrap(), NonZeroU64::MAX);\n+        for _ in 0..=6 {\n             factory.get();\n         }\n     }"
        },
        {
            "sha": "c2957f61de9efca86a50f5ba0f370a1b8faab154",
            "filename": "turbopack/crates/turbo-tasks/src/manager.rs",
            "status": "modified",
            "additions": 7,
            "deletions": 4,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/05784122a677d0b6a166561f482ad60314b13976/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/05784122a677d0b6a166561f482ad60314b13976/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs?ref=05784122a677d0b6a166561f482ad60314b13976",
            "patch": "@@ -419,9 +419,9 @@ impl CurrentTaskState {\n \n     fn create_local_task(&mut self, local_task: LocalTask) -> LocalTaskId {\n         self.local_tasks.push(local_task);\n-        // generate a one-indexed id\n+        // generate a one-indexed id from len() -- we just pushed so len() is >= 1\n         if cfg!(debug_assertions) {\n-            LocalTaskId::from(u32::try_from(self.local_tasks.len()).unwrap())\n+            LocalTaskId::try_from(u32::try_from(self.local_tasks.len()).unwrap()).unwrap()\n         } else {\n             unsafe { LocalTaskId::new_unchecked(self.local_tasks.len() as u32) }\n         }\n@@ -452,9 +452,12 @@ impl<B: Backend + 'static> TurboTasks<B> {\n     // so we probably want to make sure that all tasks are joined\n     // when trying to drop turbo tasks\n     pub fn new(backend: B) -> Arc<Self> {\n-        let task_id_factory = IdFactoryWithReuse::new(1, (TRANSIENT_TASK_BIT - 1) as u64);\n+        let task_id_factory = IdFactoryWithReuse::new(\n+            TaskId::MIN,\n+            TaskId::try_from(TRANSIENT_TASK_BIT - 1).unwrap(),\n+        );\n         let transient_task_id_factory =\n-            IdFactoryWithReuse::new(TRANSIENT_TASK_BIT as u64, u32::MAX as u64);\n+            IdFactoryWithReuse::new(TaskId::try_from(TRANSIENT_TASK_BIT).unwrap(), TaskId::MAX);\n         let this = Arc::new_cyclic(|this| Self {\n             this: this.clone(),\n             backend,"
        },
        {
            "sha": "f3340e2631e9fd1502f0b8bbf0152cefd6a0b18a",
            "filename": "turbopack/crates/turbo-tasks/src/registry.rs",
            "status": "modified",
            "additions": 20,
            "deletions": 13,
            "changes": 33,
            "blob_url": "https://github.com/vercel/next.js/blob/05784122a677d0b6a166561f482ad60314b13976/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fregistry.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/05784122a677d0b6a166561f482ad60314b13976/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fregistry.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fregistry.rs?ref=05784122a677d0b6a166561f482ad60314b13976",
            "patch": "@@ -11,30 +11,39 @@ use crate::{\n     FxDashMap, TraitType, ValueType,\n };\n \n-static FUNCTION_ID_FACTORY: IdFactory<FunctionId> = IdFactory::new(1, u32::MAX as u64);\n+static FUNCTION_ID_FACTORY: IdFactory<FunctionId> = IdFactory::new_const(\n+    FunctionId::MIN.to_non_zero_u64(),\n+    FunctionId::MAX.to_non_zero_u64(),\n+);\n static FUNCTIONS_BY_NAME: Lazy<FxDashMap<&'static str, FunctionId>> = Lazy::new(FxDashMap::default);\n static FUNCTIONS_BY_VALUE: Lazy<FxDashMap<&'static NativeFunction, FunctionId>> =\n     Lazy::new(FxDashMap::default);\n static FUNCTIONS: Lazy<NoMoveVec<(&'static NativeFunction, &'static str)>> =\n     Lazy::new(NoMoveVec::new);\n \n-static VALUE_TYPE_ID_FACTORY: IdFactory<ValueTypeId> = IdFactory::new(1, u32::MAX as u64);\n+static VALUE_TYPE_ID_FACTORY: IdFactory<ValueTypeId> = IdFactory::new_const(\n+    ValueTypeId::MIN.to_non_zero_u64(),\n+    ValueTypeId::MAX.to_non_zero_u64(),\n+);\n static VALUE_TYPES_BY_NAME: Lazy<FxDashMap<&'static str, ValueTypeId>> =\n     Lazy::new(FxDashMap::default);\n static VALUE_TYPES_BY_VALUE: Lazy<FxDashMap<&'static ValueType, ValueTypeId>> =\n     Lazy::new(FxDashMap::default);\n static VALUE_TYPES: Lazy<NoMoveVec<(&'static ValueType, &'static str)>> = Lazy::new(NoMoveVec::new);\n \n-static TRAIT_TYPE_ID_FACTORY: IdFactory<TraitTypeId> = IdFactory::new(1, u32::MAX as u64);\n+static TRAIT_TYPE_ID_FACTORY: IdFactory<TraitTypeId> = IdFactory::new_const(\n+    TraitTypeId::MIN.to_non_zero_u64(),\n+    TraitTypeId::MAX.to_non_zero_u64(),\n+);\n static TRAIT_TYPES_BY_NAME: Lazy<FxDashMap<&'static str, TraitTypeId>> =\n     Lazy::new(FxDashMap::default);\n static TRAIT_TYPES_BY_VALUE: Lazy<FxDashMap<&'static TraitType, TraitTypeId>> =\n     Lazy::new(FxDashMap::default);\n static TRAIT_TYPES: Lazy<NoMoveVec<(&'static TraitType, &'static str)>> = Lazy::new(NoMoveVec::new);\n \n fn register_thing<\n-    K: TryFrom<NonZeroU64> + Deref<Target = u32> + Sync + Send + Copy,\n-    V: Clone + Hash + Eq + Sync + Send + Copy,\n+    K: Copy + Deref<Target = u32> + TryFrom<NonZeroU64>,\n+    V: Copy + Hash + Eq,\n     const INITIAL_CAPACITY_BITS: u32,\n >(\n     global_name: &'static str,\n@@ -55,15 +64,13 @@ fn register_thing<\n     }\n }\n \n-fn get_thing_id<\n-    K: From<u32> + Deref<Target = u32> + Sync + Send + Copy + Debug,\n-    V: Clone + Hash + Eq + Debug + Sync + Send + Debug,\n->(\n-    value: V,\n-    map_by_value: &FxDashMap<V, K>,\n-) -> K {\n+fn get_thing_id<K, V>(value: V, map_by_value: &FxDashMap<V, K>) -> K\n+where\n+    V: Hash + Eq + Debug,\n+    K: Clone,\n+{\n     if let Some(id) = map_by_value.get(&value) {\n-        *id\n+        id.clone()\n     } else {\n         panic!(\"Use of unregistered {:?}\", value);\n     }"
        }
    ],
    "stats": {
        "total": 243,
        "additions": 175,
        "deletions": 68
    }
}