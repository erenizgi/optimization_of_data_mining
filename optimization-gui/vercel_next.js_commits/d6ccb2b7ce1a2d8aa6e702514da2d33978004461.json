{
    "author": "unstubbable",
    "message": "Avoid microtaskiness when lazily fetching from cache handlers (#77843)",
    "sha": "d6ccb2b7ce1a2d8aa6e702514da2d33978004461",
    "files": [
        {
            "sha": "3598f3c56a3df4cf10617e47c55b0a9219796cd0",
            "filename": "packages/next/src/server/app-render/work-async-storage.external.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 4,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/d6ccb2b7ce1a2d8aa6e702514da2d33978004461/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwork-async-storage.external.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d6ccb2b7ce1a2d8aa6e702514da2d33978004461/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwork-async-storage.external.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwork-async-storage.external.ts?ref=d6ccb2b7ce1a2d8aa6e702514da2d33978004461",
            "patch": "@@ -9,6 +9,7 @@ import type { CacheLife } from '../use-cache/cache-life'\n \n // Share the instance module in the next-shared layer\n import { workAsyncStorageInstance } from './work-async-storage-instance' with { 'turbopack-transition': 'next-shared' }\n+import type { LazyResult } from '../lib/lazy-result'\n \n export interface WorkStore {\n   readonly isStaticGeneration: boolean\n@@ -74,11 +75,11 @@ export interface WorkStore {\n   readonly previouslyRevalidatedTags: readonly string[]\n \n   /**\n-   * This map contains promise-like values so that we can evaluate them lazily\n-   * when a cache entry is read. It allows us to skip refreshing tags if no\n-   * caches are read at all.\n+   * This map contains lazy results so that we can evaluate them when the first\n+   * cache entry is read. It allows us to skip refreshing tags if no caches are\n+   * read at all.\n    */\n-  readonly refreshTagsByCacheKind: Map<string, PromiseLike<void>>\n+  readonly refreshTagsByCacheKind: Map<string, LazyResult<void>>\n \n   fetchMetrics?: FetchMetrics\n "
        },
        {
            "sha": "e2bd6c5a8d087af2049c4944b4b934adc1fbe926",
            "filename": "packages/next/src/server/async-storage/work-store.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/d6ccb2b7ce1a2d8aa6e702514da2d33978004461/packages%2Fnext%2Fsrc%2Fserver%2Fasync-storage%2Fwork-store.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d6ccb2b7ce1a2d8aa6e702514da2d33978004461/packages%2Fnext%2Fsrc%2Fserver%2Fasync-storage%2Fwork-store.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fasync-storage%2Fwork-store.ts?ref=d6ccb2b7ce1a2d8aa6e702514da2d33978004461",
            "patch": "@@ -10,7 +10,7 @@ import type { CacheLife } from '../use-cache/cache-life'\n import { AfterContext } from '../after/after-context'\n \n import { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\n-import { createLazyResult } from '../lib/lazy-result'\n+import { createLazyResult, type LazyResult } from '../lib/lazy-result'\n import { getCacheHandlerEntries } from '../use-cache/handlers'\n \n export type WorkStoreContext = {\n@@ -156,11 +156,11 @@ function createAfterContext(renderOpts: RequestLifecycleOpts): AfterContext {\n }\n \n /**\n- * Creates a map with promise-like objects, that refresh tags for the given\n- * cache kind when they're awaited for the first time.\n+ * Creates a map with lazy results that refresh tags for the respective cache\n+ * kind when they're awaited for the first time.\n  */\n-function createRefreshTagsByCacheKind(): Map<string, PromiseLike<void>> {\n-  const refreshTagsByCacheKind = new Map<string, PromiseLike<void>>()\n+function createRefreshTagsByCacheKind(): Map<string, LazyResult<void>> {\n+  const refreshTagsByCacheKind = new Map<string, LazyResult<void>>()\n   const cacheHandlers = getCacheHandlerEntries()\n \n   if (cacheHandlers) {"
        },
        {
            "sha": "ee4e544006641527c6efeb234cc43d334e6cc51d",
            "filename": "packages/next/src/server/lib/implicit-tags.ts",
            "status": "modified",
            "additions": 32,
            "deletions": 37,
            "changes": 69,
            "blob_url": "https://github.com/vercel/next.js/blob/d6ccb2b7ce1a2d8aa6e702514da2d33978004461/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fimplicit-tags.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d6ccb2b7ce1a2d8aa6e702514da2d33978004461/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fimplicit-tags.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fimplicit-tags.ts?ref=d6ccb2b7ce1a2d8aa6e702514da2d33978004461",
            "patch": "@@ -1,22 +1,25 @@\n import { NEXT_CACHE_IMPLICIT_TAG_ID } from '../../lib/constants'\n import type { FallbackRouteParams } from '../request/fallback-params'\n-import { getCacheHandlers } from '../use-cache/handlers'\n-import { createLazyResult } from './lazy-result'\n+import { getCacheHandlerEntries } from '../use-cache/handlers'\n+import { createLazyResult, type LazyResult } from './lazy-result'\n \n export interface ImplicitTags {\n   /**\n    * For legacy usage, the implicit tags are passed to the incremental cache\n    * handler in `get` calls.\n    */\n   readonly tags: string[]\n+\n   /**\n    * Modern cache handlers don't receive implicit tags. Instead, the implicit\n-   * tags' expiration is stored in the work unit store, and used to compare with\n-   * a cache entry's timestamp. Note: This is a promise-like value so that we\n-   * can evaluate it lazily when a cache entry is read. It allows us to skip\n-   * fetching the expiration value if no caches are read at all.\n+   * tags' expirations are stored in the work unit store, and used to compare\n+   * with a cache entry's timestamp.\n+   *\n+   * Note: This map contains lazy results so that we can evaluate them when the\n+   * first cache entry is read. It allows us to skip fetching the expiration\n+   * values if no caches are read at all.\n    */\n-  readonly expiration: PromiseLike<number>\n+  readonly expirationsByCacheKind: Map<string, LazyResult<number>>\n }\n \n const getDerivedTags = (pathname: string): string[] => {\n@@ -44,34 +47,28 @@ const getDerivedTags = (pathname: string): string[] => {\n   return derivedTags\n }\n \n-async function getImplicitTagsExpiration(tags: string[]): Promise<number> {\n-  // We're starting off with assuming that implicit tags are not expired, so we\n-  // use an artificial timestamp of 0.\n-  let expiration = 0\n-\n-  const cacheHandlers = getCacheHandlers()\n+/**\n+ * Creates a map with lazy results that fetch the expiration value for the given\n+ * tags and respective cache kind when they're awaited for the first time.\n+ */\n+function createTagsExpirationsByCacheKind(\n+  tags: string[]\n+): Map<string, LazyResult<number>> {\n+  const expirationsByCacheKind = new Map<string, LazyResult<number>>()\n+  const cacheHandlers = getCacheHandlerEntries()\n \n   if (cacheHandlers) {\n-    const expirations = await Promise.all(\n-      [...cacheHandlers].map(async (handler) => {\n-        if ('getExpiration' in handler) {\n-          return handler.getExpiration(...tags)\n-        }\n-\n-        // Use 0 as fallback of legacy cache handlers. We don't need to track\n-        // the expiration of implicit tags for those, because they're passed\n-        // into the `get()` method and are checked internally by the cache\n-        // handler.\n-        return 0\n-      })\n-    )\n-\n-    // We use the most recent expiration from all cache handlers, i.e. the\n-    // largest timestamp. Semantically, they should all be the same though.\n-    expiration = Math.max(...expirations)\n+    for (const [kind, cacheHandler] of cacheHandlers) {\n+      if ('getExpiration' in cacheHandler) {\n+        expirationsByCacheKind.set(\n+          kind,\n+          createLazyResult(async () => cacheHandler.getExpiration(...tags))\n+        )\n+      }\n+    }\n   }\n \n-  return expiration\n+  return expirationsByCacheKind\n }\n \n export async function getImplicitTags(\n@@ -82,7 +79,6 @@ export async function getImplicitTags(\n   },\n   fallbackRouteParams: null | FallbackRouteParams\n ): Promise<ImplicitTags> {\n-  // TODO: Cache the result\n   const tags: string[] = []\n   const hasFallbackRouteParams =\n     fallbackRouteParams && fallbackRouteParams.size > 0\n@@ -101,9 +97,8 @@ export async function getImplicitTags(\n     tags.push(tag)\n   }\n \n-  const expiration = createLazyResult(async () =>\n-    getImplicitTagsExpiration(tags)\n-  )\n-\n-  return { tags, expiration }\n+  return {\n+    tags,\n+    expirationsByCacheKind: createTagsExpirationsByCacheKind(tags),\n+  }\n }"
        },
        {
            "sha": "3c84ac013112eab9915f756e8b08d2011e4e0477",
            "filename": "packages/next/src/server/lib/lazy-result.ts",
            "status": "modified",
            "additions": 28,
            "deletions": 6,
            "changes": 34,
            "blob_url": "https://github.com/vercel/next.js/blob/d6ccb2b7ce1a2d8aa6e702514da2d33978004461/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Flazy-result.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d6ccb2b7ce1a2d8aa6e702514da2d33978004461/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Flazy-result.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Flazy-result.ts?ref=d6ccb2b7ce1a2d8aa6e702514da2d33978004461",
            "patch": "@@ -1,19 +1,41 @@\n+export type LazyResult<TValue> = PromiseLike<TValue> & { value?: TValue }\n+export type ResolvedLazyResult<TValue> = PromiseLike<TValue> & { value: TValue }\n+\n /**\n  * Calls the given async function only when the returned promise-like object is\n- * awaited.\n+ * awaited. Afterwards, it provides the resolved value synchronously as `value`\n+ * property.\n  */\n-export function createLazyResult<TResult>(\n-  fn: () => Promise<TResult>\n-): PromiseLike<TResult> {\n-  let pendingResult: Promise<TResult> | undefined\n+export function createLazyResult<TValue>(\n+  fn: () => Promise<TValue>\n+): LazyResult<TValue> {\n+  let pendingResult: Promise<TValue> | undefined\n \n-  return {\n+  const result: LazyResult<TValue> = {\n     then(onfulfilled, onrejected) {\n       if (!pendingResult) {\n         pendingResult = fn()\n       }\n \n+      pendingResult\n+        .then((value) => {\n+          result.value = value\n+        })\n+        .catch(() => {\n+          // The externally awaited result will be rejected via `onrejected`. We\n+          // don't need to handle it here. But we do want to avoid an unhandled\n+          // rejection.\n+        })\n+\n       return pendingResult.then(onfulfilled, onrejected)\n     },\n   }\n+\n+  return result\n+}\n+\n+export function isResolvedLazyResult<TValue>(\n+  result: LazyResult<TValue>\n+): result is ResolvedLazyResult<TValue> {\n+  return result.hasOwnProperty('value')\n }"
        },
        {
            "sha": "9a22a48feb4fcfe19338801a1d47130100622ddf",
            "filename": "packages/next/src/server/use-cache/use-cache-wrapper.ts",
            "status": "modified",
            "additions": 54,
            "deletions": 38,
            "changes": 92,
            "blob_url": "https://github.com/vercel/next.js/blob/d6ccb2b7ce1a2d8aa6e702514da2d33978004461/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d6ccb2b7ce1a2d8aa6e702514da2d33978004461/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts?ref=d6ccb2b7ce1a2d8aa6e702514da2d33978004461",
            "patch": "@@ -51,8 +51,7 @@ import {\n } from '../request/search-params'\n import type { Params } from '../request/params'\n import React from 'react'\n-import type { ImplicitTags } from '../lib/implicit-tags'\n-import { createLazyResult } from '../lib/lazy-result'\n+import { createLazyResult, isResolvedLazyResult } from '../lib/lazy-result'\n \n type CacheKeyParts =\n   | [buildId: string, id: string, args: unknown[]]\n@@ -702,15 +701,13 @@ export function cache(\n           cacheSignal.beginRead()\n         }\n \n-        const implicitTags = workUnitStore?.implicitTags\n-        const forceRevalidate = shouldForceRevalidate(workStore, workUnitStore)\n+        const lazyRefreshTags = workStore.refreshTagsByCacheKind.get(kind)\n \n-        // Lazily refresh the tags for the cache handler that's associated with\n-        // this cache function. This is only done once per request and cache\n-        // handler, when it's awaited for the first time.\n-        await workStore.refreshTagsByCacheKind.get(kind)\n+        if (lazyRefreshTags && !isResolvedLazyResult(lazyRefreshTags)) {\n+          await lazyRefreshTags\n+        }\n \n-        let entry = forceRevalidate\n+        let entry = shouldForceRevalidate(workStore, workUnitStore)\n           ? undefined\n           : 'getExpiration' in cacheHandler\n             ? await cacheHandler.get(serializedCacheKey)\n@@ -719,15 +716,37 @@ export function cache(\n               // cache handlers (see below).\n               await cacheHandler.get(\n                 serializedCacheKey,\n-                implicitTags?.tags ?? []\n+                workUnitStore?.implicitTags?.tags ?? []\n               )\n \n-        if (\n-          entry &&\n-          (await shouldDiscardCacheEntry(entry, workStore, implicitTags))\n-        ) {\n-          debug?.('discarding stale entry', serializedCacheKey)\n-          entry = undefined\n+        if (entry) {\n+          const implicitTags = workUnitStore?.implicitTags?.tags ?? []\n+          let implicitTagsExpiration = 0\n+\n+          if (workUnitStore?.implicitTags) {\n+            const lazyExpiration =\n+              workUnitStore.implicitTags.expirationsByCacheKind.get(kind)\n+\n+            if (lazyExpiration) {\n+              if (isResolvedLazyResult(lazyExpiration)) {\n+                implicitTagsExpiration = lazyExpiration.value\n+              } else {\n+                implicitTagsExpiration = await lazyExpiration\n+              }\n+            }\n+          }\n+\n+          if (\n+            shouldDiscardCacheEntry(\n+              entry,\n+              workStore,\n+              implicitTags,\n+              implicitTagsExpiration\n+            )\n+          ) {\n+            debug?.('discarding stale entry', serializedCacheKey)\n+            entry = undefined\n+          }\n         }\n \n         const currentTime = performance.timeOrigin + performance.now()\n@@ -951,38 +970,35 @@ function shouldForceRevalidate(\n   return false\n }\n \n-async function shouldDiscardCacheEntry(\n+function shouldDiscardCacheEntry(\n   entry: CacheEntry,\n   workStore: WorkStore,\n-  implicitTags: ImplicitTags | undefined\n-): Promise<boolean> {\n+  implicitTags: string[],\n+  implicitTagsExpiration: number\n+): boolean {\n   // If the cache entry contains revalidated tags that the cache handler might\n   // not know about yet, we need to discard it.\n   if (entry.tags.some((tag) => isRecentlyRevalidatedTag(tag, workStore))) {\n     return true\n   }\n \n-  if (implicitTags) {\n-    // If the cache entry was created before any of the implicit tags were\n-    // revalidated last, we also need to discard it.\n-    if (entry.timestamp <= (await implicitTags.expiration)) {\n-      debug?.(\n-        'entry was created at',\n-        entry.timestamp,\n-        'before implicit tags were revalidated at',\n-        implicitTags.expiration\n-      )\n+  // If the cache entry was created before any of the implicit tags were\n+  // revalidated last, we also need to discard it.\n+  if (entry.timestamp <= implicitTagsExpiration) {\n+    debug?.(\n+      'entry was created at',\n+      entry.timestamp,\n+      'before implicit tags were revalidated at',\n+      implicitTagsExpiration\n+    )\n \n-      return true\n-    }\n+    return true\n+  }\n \n-    // Finally, if any of the implicit tags have been revalidated recently, we\n-    // also need to discard the cache entry.\n-    if (\n-      implicitTags.tags.some((tag) => isRecentlyRevalidatedTag(tag, workStore))\n-    ) {\n-      return true\n-    }\n+  // Finally, if any of the implicit tags have been revalidated recently, we\n+  // also need to discard the cache entry.\n+  if (implicitTags.some((tag) => isRecentlyRevalidatedTag(tag, workStore))) {\n+    return true\n   }\n \n   return false"
        }
    ],
    "stats": {
        "total": 214,
        "additions": 124,
        "deletions": 90
    }
}