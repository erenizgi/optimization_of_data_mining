{
    "author": "acdlite",
    "message": "[Segment Cache] Hard nav when root layout changes (#76163)\n\nThe highest-level layout in a route tree is referred to as the \"root\"\nlayout. When it changes, we perform a full-page (MPA-style) navigation.\n\nTo implement this for the Segment Cache, I moved the\n`isNavigatingToNewRootLayout` check from `navigateReducer` into\n`startPPRNavigation`.\n\nRather than run the `isNavigatingToNewRootLayout` check on every\nnavigation, I combined it with the route tree traversal we already\nperform when diffing the tree on navigation. In the common case,\nnavigation happens inside the root layout. If we discover a root layout\nbefore the first new segment is reached, we don't have to do anything\nextra.\n\nThe only special case is when a root parameter changes. Although this\ntriggers a re-render of that segment, it shouldn't cause the root layout\nto be treated as different for the purposes of deciding whether to\ntrigger an MPA navigation. It's only in this case where we need to\nswitch to a different tree traversal (isNavigatingToNewRootLayout).",
    "sha": "81ce3af8428a78b2cd6c19b823d830ff4196580f",
    "files": [
        {
            "sha": "c92445e16e3375363277565cf7600ab44ec89b50",
            "filename": "packages/next/src/client/components/router-reducer/ppr-navigations.ts",
            "status": "modified",
            "additions": 123,
            "deletions": 15,
            "changes": 138,
            "blob_url": "https://github.com/vercel/next.js/blob/81ce3af8428a78b2cd6c19b823d830ff4196580f/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fppr-navigations.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/81ce3af8428a78b2cd6c19b823d830ff4196580f/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fppr-navigations.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fppr-navigations.ts?ref=81ce3af8428a78b2cd6c19b823d830ff4196580f",
            "patch": "@@ -14,14 +14,15 @@ import { DEFAULT_SEGMENT_KEY } from '../../../shared/lib/segment'\n import { matchSegment } from '../match-segments'\n import { createRouterCacheKey } from './create-router-cache-key'\n import type { FetchServerResponseResult } from './fetch-server-response'\n+import { isNavigatingToNewRootLayout } from './is-navigating-to-new-root-layout'\n \n // This is yet another tree type that is used to track pending promises that\n // need to be fulfilled once the dynamic data is received. The terminal nodes of\n // this tree represent the new Cache Node trees that were created during this\n // request. We can't use the Cache Node tree or Route State tree directly\n // because those include reused nodes, too. This tree is discarded as soon as\n // the navigation response is received.\n-export type Task = {\n+type SPANavigationTask = {\n   // The router state that corresponds to the tree that this Task represents.\n   route: FlightRouterState\n   // The CacheNode that corresponds to the tree that this Task represents. If\n@@ -34,9 +35,27 @@ export type Task = {\n   // If all the segments are static, then this will be null, and no server\n   // request is required.\n   dynamicRequestTree: FlightRouterState | null\n-  children: Map<string, Task> | null\n+  children: Map<string, SPANavigationTask> | null\n }\n \n+// A special type used to bail out and trigger a full-page navigation.\n+type MPANavigationTask = {\n+  // MPA tasks are distinguised from SPA tasks by having a null `route`.\n+  route: null\n+  node: null\n+  dynamicRequestTree: null\n+  children: null\n+}\n+\n+const MPA_NAVIGATION_TASK: MPANavigationTask = {\n+  route: null,\n+  node: null,\n+  dynamicRequestTree: null,\n+  children: null,\n+}\n+\n+export type Task = SPANavigationTask | MPANavigationTask\n+\n // Creates a new Cache Node tree (i.e. copy-on-write) that represents the\n // optimistic result of a navigation, using both the current Cache Node tree and\n // data that was prefetched prior to navigation.\n@@ -66,10 +85,30 @@ export type Task = {\n //\n // A return value of `null` means there were no changes, and the previous tree\n // can be reused without initiating a server request.\n-export function updateCacheNodeOnNavigation(\n+export function startPPRNavigation(\n+  oldCacheNode: CacheNode,\n+  oldRouterState: FlightRouterState,\n+  newRouterState: FlightRouterState,\n+  prefetchData: CacheNodeSeedData | null,\n+  prefetchHead: HeadData | null,\n+  isPrefetchHeadPartial: boolean\n+): Task | null {\n+  return updateCacheNodeOnNavigation(\n+    oldCacheNode,\n+    oldRouterState,\n+    newRouterState,\n+    false,\n+    prefetchData,\n+    prefetchHead,\n+    isPrefetchHeadPartial\n+  )\n+}\n+\n+function updateCacheNodeOnNavigation(\n   oldCacheNode: CacheNode,\n   oldRouterState: FlightRouterState,\n   newRouterState: FlightRouterState,\n+  didFindRootLayout: boolean,\n   prefetchData: CacheNodeSeedData | null,\n   prefetchHead: HeadData | null,\n   isPrefetchHeadPartial: boolean\n@@ -79,6 +118,17 @@ export function updateCacheNodeOnNavigation(\n   const newRouterStateChildren = newRouterState[1]\n   const prefetchDataChildren = prefetchData !== null ? prefetchData[2] : null\n \n+  if (!didFindRootLayout) {\n+    // We're currently traversing the part of the tree that was also part of\n+    // the previous route. If we discover a root layout, then we don't need to\n+    // trigger an MPA navigation. See beginRenderingNewRouteTree for context.\n+    const isRootLayout = newRouterState[4] === true\n+    if (isRootLayout) {\n+      // Found a matching root layout.\n+      didFindRootLayout = true\n+    }\n+  }\n+\n   const oldParallelRoutes = oldCacheNode.parallelRoutes\n \n   // Clone the current set of segment children, even if they aren't active in\n@@ -163,14 +213,17 @@ export function updateCacheNodeOnNavigation(\n         taskChild = spawnReusedTask(oldRouterStateChild)\n       } else {\n         // There's no currently active segment. Switch to the \"create\" path.\n-        taskChild = createCacheNodeOnNavigation(\n+        taskChild = beginRenderingNewRouteTree(\n+          oldRouterStateChild,\n           newRouterStateChild,\n+          didFindRootLayout,\n           prefetchDataChild !== undefined ? prefetchDataChild : null,\n           prefetchHead,\n           isPrefetchHeadPartial\n         )\n       }\n     } else if (\n+      oldRouterStateChild !== undefined &&\n       oldSegmentChild !== undefined &&\n       matchSegment(newSegmentChild, oldSegmentChild)\n     ) {\n@@ -184,33 +237,44 @@ export function updateCacheNodeOnNavigation(\n           oldCacheNodeChild,\n           oldRouterStateChild,\n           newRouterStateChild,\n+          didFindRootLayout,\n           prefetchDataChild,\n           prefetchHead,\n           isPrefetchHeadPartial\n         )\n       } else {\n-        // Either there's no existing Cache Node for this segment, or this\n-        // segment doesn't exist in the old Router State tree. Switch to the\n+        // There's no existing Cache Node for this segment. Switch to the\n         // \"create\" path.\n-        taskChild = createCacheNodeOnNavigation(\n+        taskChild = beginRenderingNewRouteTree(\n+          oldRouterStateChild,\n           newRouterStateChild,\n+          didFindRootLayout,\n           prefetchDataChild !== undefined ? prefetchDataChild : null,\n           prefetchHead,\n           isPrefetchHeadPartial\n         )\n       }\n     } else {\n       // This is a new tree. Switch to the \"create\" path.\n-      taskChild = createCacheNodeOnNavigation(\n+      taskChild = beginRenderingNewRouteTree(\n+        oldRouterStateChild,\n         newRouterStateChild,\n+        didFindRootLayout,\n         prefetchDataChild !== undefined ? prefetchDataChild : null,\n         prefetchHead,\n         isPrefetchHeadPartial\n       )\n     }\n \n     if (taskChild !== null) {\n-      // Something changed in the child tree. Keep track of the child task.\n+      // Recursively propagate up the child tasks.\n+\n+      if (taskChild.route === null) {\n+        // One of the child tasks discovered a change to the root layout.\n+        // Immediately unwind from this recursive traversal.\n+        return MPA_NAVIGATION_TASK\n+      }\n+\n       if (taskChildren === null) {\n         taskChildren = new Map()\n       }\n@@ -283,12 +347,56 @@ export function updateCacheNodeOnNavigation(\n   }\n }\n \n+function beginRenderingNewRouteTree(\n+  oldRouterState: FlightRouterState | void,\n+  newRouterState: FlightRouterState,\n+  didFindRootLayout: boolean,\n+  prefetchData: CacheNodeSeedData | null,\n+  possiblyPartialPrefetchHead: HeadData | null,\n+  isPrefetchHeadPartial: boolean\n+): Task {\n+  if (!didFindRootLayout) {\n+    // The route tree changed before we reached a layout. (The highest-level\n+    // layout in a route tree is referred to as the \"root\" layout.) This could\n+    // mean that we're navigating between two different root layouts. When this\n+    // happens, we perform a full-page (MPA-style) navigation.\n+    //\n+    // However, the algorithm for deciding where to start rendering a route\n+    // (i.e. the one performed in order to reach this function) is stricter\n+    // than the one used to detect a change in the root layout. So just because\n+    // we're re-rendering a segment outside of the root layout does not mean we\n+    // should trigger a full-page navigation.\n+    //\n+    // Specifically, we handle dynamic parameters differently: two segments are\n+    // considered the same even if their parameter values are different.\n+    //\n+    // Refer to isNavigatingToNewRootLayout for details.\n+    //\n+    // Note that we only have to perform this extra traversal if we didn't\n+    // already discover a root layout in the part of the tree that is unchanged.\n+    // In the common case, this branch is skipped completely.\n+    if (\n+      oldRouterState === undefined ||\n+      isNavigatingToNewRootLayout(oldRouterState, newRouterState)\n+    ) {\n+      // The root layout changed. Perform a full-page navigation.\n+      return MPA_NAVIGATION_TASK\n+    }\n+  }\n+  return createCacheNodeOnNavigation(\n+    newRouterState,\n+    prefetchData,\n+    possiblyPartialPrefetchHead,\n+    isPrefetchHeadPartial\n+  )\n+}\n+\n function createCacheNodeOnNavigation(\n   routerState: FlightRouterState,\n   prefetchData: CacheNodeSeedData | null,\n   possiblyPartialPrefetchHead: HeadData | null,\n   isPrefetchHeadPartial: boolean\n-): Task {\n+): SPANavigationTask {\n   // Same traversal as updateCacheNodeNavigation, but we switch to this path\n   // once we reach the part of the tree that was not in the previous route. We\n   // don't need to diff against the old tree, we just need to create a new one.\n@@ -424,7 +532,7 @@ function spawnPendingTask(\n   prefetchData: CacheNodeSeedData | null,\n   prefetchHead: HeadData | null,\n   isPrefetchHeadPartial: boolean\n-): Task {\n+): SPANavigationTask {\n   // Create a task that will later be fulfilled by data from the server.\n \n   // Clone the prefetched route tree and the `refetch` marker to it. We'll send\n@@ -480,7 +588,7 @@ function spawnReusedTask(reusedRouterState: FlightRouterState): Task {\n // This does _not_ create a new tree; it modifies the existing one in place.\n // Which means it must follow the Suspense rules of cache safety.\n export function listenForDynamicRequest(\n-  task: Task,\n+  task: SPANavigationTask,\n   responsePromise: Promise<FetchServerResponseResult>\n ) {\n   responsePromise.then(\n@@ -528,7 +636,7 @@ export function listenForDynamicRequest(\n }\n \n function writeDynamicDataIntoPendingTask(\n-  rootTask: Task,\n+  rootTask: SPANavigationTask,\n   segmentPath: FlightSegmentPath,\n   serverRouterState: FlightRouterState,\n   dynamicData: CacheNodeSeedData,\n@@ -576,7 +684,7 @@ function writeDynamicDataIntoPendingTask(\n }\n \n function finishTaskUsingDynamicDataPayload(\n-  task: Task,\n+  task: SPANavigationTask,\n   serverRouterState: FlightRouterState,\n   dynamicData: CacheNodeSeedData,\n   dynamicHead: HeadData\n@@ -802,7 +910,7 @@ function finishPendingCacheNode(\n   }\n }\n \n-export function abortTask(task: Task, error: any): void {\n+export function abortTask(task: SPANavigationTask, error: any): void {\n   const cacheNode = task.node\n   if (cacheNode === null) {\n     // This indicates the task is already complete."
        },
        {
            "sha": "df6efef8a85c585d26958f4784e36a4a9a837fde",
            "filename": "packages/next/src/client/components/router-reducer/reducers/navigate-reducer.ts",
            "status": "modified",
            "additions": 14,
            "deletions": 11,
            "changes": 25,
            "blob_url": "https://github.com/vercel/next.js/blob/81ce3af8428a78b2cd6c19b823d830ff4196580f/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fnavigate-reducer.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/81ce3af8428a78b2cd6c19b823d830ff4196580f/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fnavigate-reducer.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fnavigate-reducer.ts?ref=81ce3af8428a78b2cd6c19b823d830ff4196580f",
            "patch": "@@ -21,10 +21,7 @@ import { applyFlightData } from '../apply-flight-data'\n import { prefetchQueue } from './prefetch-reducer'\n import { createEmptyCacheNode } from '../../app-router'\n import { DEFAULT_SEGMENT_KEY } from '../../../../shared/lib/segment'\n-import {\n-  listenForDynamicRequest,\n-  updateCacheNodeOnNavigation,\n-} from '../ppr-navigations'\n+import { listenForDynamicRequest, startPPRNavigation } from '../ppr-navigations'\n import {\n   getOrCreatePrefetchCacheEntry,\n   prunePrefetchCache,\n@@ -296,23 +293,19 @@ export function navigateReducer(\n         }\n \n         if (newTree !== null) {\n-          if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n-            return handleExternalUrl(state, mutable, href, pendingPush)\n-          }\n-\n           if (\n             // This is just a paranoid check. When a route is PPRed, the server\n             // will send back a static response that's rendered from\n             // the root. If for some reason it doesn't, we fall back to the\n             // non-PPR implementation.\n             // TODO: We should get rid of the else branch and do all navigations\n-            // via updateCacheNodeOnNavigation. The current structure is just\n+            // via startPPRNavigation. The current structure is just\n             // an incremental step.\n             seedData &&\n             isRootRender &&\n             postponed\n           ) {\n-            const task = updateCacheNodeOnNavigation(\n+            const task = startPPRNavigation(\n               currentCache,\n               currentTree,\n               treePatch,\n@@ -322,7 +315,12 @@ export function navigateReducer(\n             )\n \n             if (task !== null) {\n-              // Use the tree computed by updateCacheNodeOnNavigation instead\n+              if (task.route === null) {\n+                // Detected a change to the root layout. Perform an full-\n+                // page navigation.\n+                return handleExternalUrl(state, mutable, href, pendingPush)\n+              }\n+              // Use the tree computed by startPPRNavigation instead\n               // of the one computed by applyRouterStatePatchToTree.\n               // TODO: We should remove applyRouterStatePatchToTree\n               // from the PPR path entirely.\n@@ -379,6 +377,11 @@ export function navigateReducer(\n             // given that PPR prefetches are always static and return the whole\n             // tree. Or in the meantime we could factor it out into a\n             // separate function.\n+\n+            if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n+              return handleExternalUrl(state, mutable, href, pendingPush)\n+            }\n+\n             const cache: CacheNode = createEmptyCacheNode()\n             let applied = false\n "
        },
        {
            "sha": "06352a7699fb36fc7d2ab9d673c15d0b91313053",
            "filename": "packages/next/src/client/components/segment-cache/navigation.ts",
            "status": "modified",
            "additions": 17,
            "deletions": 11,
            "changes": 28,
            "blob_url": "https://github.com/vercel/next.js/blob/81ce3af8428a78b2cd6c19b823d830ff4196580f/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fnavigation.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/81ce3af8428a78b2cd6c19b823d830ff4196580f/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fnavigation.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fnavigation.ts?ref=81ce3af8428a78b2cd6c19b823d830ff4196580f",
            "patch": "@@ -11,7 +11,7 @@ import type {\n import type { NormalizedFlightData } from '../../flight-data-helpers'\n import { fetchServerResponse } from '../router-reducer/fetch-server-response'\n import {\n-  updateCacheNodeOnNavigation,\n+  startPPRNavigation,\n   listenForDynamicRequest,\n   type Task as PPRNavigationTask,\n } from '../router-reducer/ppr-navigations'\n@@ -82,7 +82,7 @@ export function navigate(\n   currentCacheNode: CacheNode,\n   currentFlightRouterState: FlightRouterState,\n   nextUrl: string | null\n-): AsyncNavigationResult | SuccessfulNavigationResult | NoOpNavigationResult {\n+): NavigationResult {\n   const now = Date.now()\n \n   const cacheKey = createCacheKey(url.href, nextUrl)\n@@ -129,17 +129,14 @@ function navigateUsingPrefetchedRouteTree(\n   prefetchHead: HeadData | null,\n   isPrefetchHeadPartial: boolean,\n   canonicalUrl: string\n-): SuccessfulNavigationResult | NoOpNavigationResult {\n+): SuccessfulNavigationResult | NoOpNavigationResult | MPANavigationResult {\n   // Recursively construct a prefetch tree by reading from the Segment Cache. To\n   // maintain compatibility, we output the same data structures as the old\n   // prefetching implementation: FlightRouterState and CacheNodeSeedData.\n   // TODO: Eventually updateCacheNodeOnNavigation (or the equivalent) should\n   // read from the Segment Cache directly. It's only structured this way for now\n   // so we can share code with the old prefetching implementation.\n-  // TODO: Need to detect whether we're navigating to a new root layout, i.e.\n-  // reimplement the isNavigatingToNewRootLayout logic\n-  // inside updateCacheNodeOnNavigation.\n-  const task = updateCacheNodeOnNavigation(\n+  const task = startPPRNavigation(\n     currentCacheNode,\n     currentFlightRouterState,\n     prefetchFlightRouterState,\n@@ -169,12 +166,21 @@ function navigationTaskToResult(\n   task: PPRNavigationTask,\n   currentCacheNode: CacheNode,\n   canonicalUrl: string\n-): SuccessfulNavigationResult {\n+): SuccessfulNavigationResult | MPANavigationResult {\n+  const flightRouterState = task.route\n+  if (flightRouterState === null) {\n+    // When no router state is provided, it signals that we should perform an\n+    // MPA navigation.\n+    return {\n+      tag: NavigationResultTag.MPA,\n+      data: canonicalUrl,\n+    }\n+  }\n   const newCacheNode = task.node\n   return {\n     tag: NavigationResultTag.Success,\n     data: {\n-      flightRouterState: task.route,\n+      flightRouterState,\n       cacheNode: newCacheNode !== null ? newCacheNode : currentCacheNode,\n       canonicalUrl,\n     },\n@@ -308,7 +314,7 @@ async function navigateDynamicallyWithNoPrefetch(\n   )\n \n   // Now we proceed exactly as we would for normal navigation.\n-  const task = updateCacheNodeOnNavigation(\n+  const task = startPPRNavigation(\n     currentCacheNode,\n     currentFlightRouterState,\n     prefetchFlightRouterState,\n@@ -318,7 +324,7 @@ async function navigateDynamicallyWithNoPrefetch(\n   )\n   if (task !== null) {\n     // In this case, we've already sent the dynamic request, so we don't\n-    // actually use the request tree created by `updateCacheNodeOnNavigation`,\n+    // actually use the request tree created by `startPPRNavigation`,\n     // except to check if it contains dynamic holes.\n     //\n     // This is almost always true, but it could be false if all the segment data"
        },
        {
            "sha": "dbce4ea8e3aeb6cb61b81712b62288d5abaf776b",
            "filename": "test/e2e/app-dir/segment-cache/mpa-navigations/app/(group1)/layout.tsx",
            "status": "added",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/81ce3af8428a78b2cd6c19b823d830ff4196580f/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fmpa-navigations%2Fapp%2F(group1)%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/81ce3af8428a78b2cd6c19b823d830ff4196580f/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fmpa-navigations%2Fapp%2F(group1)%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fmpa-navigations%2Fapp%2F(group1)%2Flayout.tsx?ref=81ce3af8428a78b2cd6c19b823d830ff4196580f",
            "patch": "@@ -0,0 +1,11 @@\n+export default function RootLayout({\n+  children,\n+}: {\n+  children: React.ReactNode\n+}) {\n+  return (\n+    <html lang=\"en\">\n+      <body>{children}</body>\n+    </html>\n+  )\n+}"
        },
        {
            "sha": "6dc8dff166c56b6b32ba51de2d9da51bd5b76c22",
            "filename": "test/e2e/app-dir/segment-cache/mpa-navigations/app/(group1)/page.tsx",
            "status": "added",
            "additions": 15,
            "deletions": 0,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/81ce3af8428a78b2cd6c19b823d830ff4196580f/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fmpa-navigations%2Fapp%2F(group1)%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/81ce3af8428a78b2cd6c19b823d830ff4196580f/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fmpa-navigations%2Fapp%2F(group1)%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fmpa-navigations%2Fapp%2F(group1)%2Fpage.tsx?ref=81ce3af8428a78b2cd6c19b823d830ff4196580f",
            "patch": "@@ -0,0 +1,15 @@\n+import Link from 'next/link'\n+\n+export default async function Page() {\n+  return (\n+    <>\n+      <p>\n+        This link <em>should</em> trigger an MPA navigation, because it\n+        navigates to a different root layout:\n+      </p>\n+      <p>\n+        <Link href=\"/foo\">/foo</Link>\n+      </p>\n+    </>\n+  )\n+}"
        },
        {
            "sha": "dbce4ea8e3aeb6cb61b81712b62288d5abaf776b",
            "filename": "test/e2e/app-dir/segment-cache/mpa-navigations/app/(group2)/[rootParam]/(groupA)/layout.tsx",
            "status": "added",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/81ce3af8428a78b2cd6c19b823d830ff4196580f/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fmpa-navigations%2Fapp%2F(group2)%2F%5BrootParam%5D%2F(groupA)%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/81ce3af8428a78b2cd6c19b823d830ff4196580f/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fmpa-navigations%2Fapp%2F(group2)%2F%5BrootParam%5D%2F(groupA)%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fmpa-navigations%2Fapp%2F(group2)%2F%5BrootParam%5D%2F(groupA)%2Flayout.tsx?ref=81ce3af8428a78b2cd6c19b823d830ff4196580f",
            "patch": "@@ -0,0 +1,11 @@\n+export default function RootLayout({\n+  children,\n+}: {\n+  children: React.ReactNode\n+}) {\n+  return (\n+    <html lang=\"en\">\n+      <body>{children}</body>\n+    </html>\n+  )\n+}"
        },
        {
            "sha": "d14691d93a67945888da2cee8ced0378f098ed58",
            "filename": "test/e2e/app-dir/segment-cache/mpa-navigations/app/(group2)/[rootParam]/(groupA)/page.tsx",
            "status": "added",
            "additions": 29,
            "deletions": 0,
            "changes": 29,
            "blob_url": "https://github.com/vercel/next.js/blob/81ce3af8428a78b2cd6c19b823d830ff4196580f/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fmpa-navigations%2Fapp%2F(group2)%2F%5BrootParam%5D%2F(groupA)%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/81ce3af8428a78b2cd6c19b823d830ff4196580f/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fmpa-navigations%2Fapp%2F(group2)%2F%5BrootParam%5D%2F(groupA)%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fmpa-navigations%2Fapp%2F(group2)%2F%5BrootParam%5D%2F(groupA)%2Fpage.tsx?ref=81ce3af8428a78b2cd6c19b823d830ff4196580f",
            "patch": "@@ -0,0 +1,29 @@\n+import Link from 'next/link'\n+\n+export function generateStaticParams() {\n+  return [{ rootParam: 'foo' }, { rootParam: 'bar' }]\n+}\n+\n+export default async function Page({ params }) {\n+  const { rootParam } = params\n+  const otherRootParam = rootParam === 'foo' ? 'bar' : 'foo'\n+  return (\n+    <>\n+      <p>\n+        <p>\n+          This link <em>should not</em> trigger an MPA navigation, because it\n+          only changes a root param:\n+        </p>\n+        <Link href={`/${otherRootParam}`}>/{otherRootParam}</Link>\n+      </p>\n+      <p>\n+        <p>\n+          This link <em>should</em> trigger an MPA navigation, because in\n+          addition to changing a root param, it also navigates to a different\n+          root layout:\n+        </p>\n+        <Link href={`/${otherRootParam}/inner`}>/{otherRootParam}/inner</Link>\n+      </p>\n+    </>\n+  )\n+}"
        },
        {
            "sha": "dbce4ea8e3aeb6cb61b81712b62288d5abaf776b",
            "filename": "test/e2e/app-dir/segment-cache/mpa-navigations/app/(group2)/[rootParam]/(groupB)/inner/layout.tsx",
            "status": "added",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/81ce3af8428a78b2cd6c19b823d830ff4196580f/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fmpa-navigations%2Fapp%2F(group2)%2F%5BrootParam%5D%2F(groupB)%2Finner%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/81ce3af8428a78b2cd6c19b823d830ff4196580f/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fmpa-navigations%2Fapp%2F(group2)%2F%5BrootParam%5D%2F(groupB)%2Finner%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fmpa-navigations%2Fapp%2F(group2)%2F%5BrootParam%5D%2F(groupB)%2Finner%2Flayout.tsx?ref=81ce3af8428a78b2cd6c19b823d830ff4196580f",
            "patch": "@@ -0,0 +1,11 @@\n+export default function RootLayout({\n+  children,\n+}: {\n+  children: React.ReactNode\n+}) {\n+  return (\n+    <html lang=\"en\">\n+      <body>{children}</body>\n+    </html>\n+  )\n+}"
        },
        {
            "sha": "d65db5aab753345421c313c0d46bdcf7035979cc",
            "filename": "test/e2e/app-dir/segment-cache/mpa-navigations/app/(group2)/[rootParam]/(groupB)/inner/page.tsx",
            "status": "added",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/81ce3af8428a78b2cd6c19b823d830ff4196580f/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fmpa-navigations%2Fapp%2F(group2)%2F%5BrootParam%5D%2F(groupB)%2Finner%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/81ce3af8428a78b2cd6c19b823d830ff4196580f/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fmpa-navigations%2Fapp%2F(group2)%2F%5BrootParam%5D%2F(groupB)%2Finner%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fmpa-navigations%2Fapp%2F(group2)%2F%5BrootParam%5D%2F(groupB)%2Finner%2Fpage.tsx?ref=81ce3af8428a78b2cd6c19b823d830ff4196580f",
            "patch": "@@ -0,0 +1,6 @@\n+export function generateStaticParams() {\n+  return [{ rootParam: 'foo' }, { rootParam: 'bar' }]\n+}\n+export default async function Page() {\n+  return <p>Content of inner page</p>\n+}"
        },
        {
            "sha": "c735a55918b5489458940dcdd29daa6f2ec50315",
            "filename": "test/e2e/app-dir/segment-cache/mpa-navigations/components/link-accordion.tsx",
            "status": "added",
            "additions": 33,
            "deletions": 0,
            "changes": 33,
            "blob_url": "https://github.com/vercel/next.js/blob/81ce3af8428a78b2cd6c19b823d830ff4196580f/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fmpa-navigations%2Fcomponents%2Flink-accordion.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/81ce3af8428a78b2cd6c19b823d830ff4196580f/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fmpa-navigations%2Fcomponents%2Flink-accordion.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fmpa-navigations%2Fcomponents%2Flink-accordion.tsx?ref=81ce3af8428a78b2cd6c19b823d830ff4196580f",
            "patch": "@@ -0,0 +1,33 @@\n+'use client'\n+\n+import Link from 'next/link'\n+import { useState } from 'react'\n+\n+export function LinkAccordion({\n+  href,\n+  children,\n+  prefetch,\n+}: {\n+  href: string\n+  children: React.ReactNode\n+  prefetch?: boolean\n+}) {\n+  const [isVisible, setIsVisible] = useState(false)\n+  return (\n+    <>\n+      <input\n+        type=\"checkbox\"\n+        checked={isVisible}\n+        onChange={() => setIsVisible(!isVisible)}\n+        data-link-accordion={href}\n+      />\n+      {isVisible ? (\n+        <Link href={href} prefetch={prefetch}>\n+          {children}\n+        </Link>\n+      ) : (\n+        <>{children} (link is hidden)</>\n+      )}\n+    </>\n+  )\n+}"
        },
        {
            "sha": "be94b4785fbf6e576c24d898504bd3beea34c05b",
            "filename": "test/e2e/app-dir/segment-cache/mpa-navigations/mpa-navigations.test.ts",
            "status": "added",
            "additions": 55,
            "deletions": 0,
            "changes": 55,
            "blob_url": "https://github.com/vercel/next.js/blob/81ce3af8428a78b2cd6c19b823d830ff4196580f/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fmpa-navigations%2Fmpa-navigations.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/81ce3af8428a78b2cd6c19b823d830ff4196580f/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fmpa-navigations%2Fmpa-navigations.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fmpa-navigations%2Fmpa-navigations.test.ts?ref=81ce3af8428a78b2cd6c19b823d830ff4196580f",
            "patch": "@@ -0,0 +1,55 @@\n+import { nextTestSetup } from 'e2e-utils'\n+\n+describe('segment cache (MPA navigations)', () => {\n+  const { next, isNextDev, skipped } = nextTestSetup({\n+    files: __dirname,\n+    skipDeployment: true,\n+  })\n+  if (isNextDev || skipped) {\n+    test('ppr is disabled', () => {})\n+    return\n+  }\n+\n+  it('triggers MPA navigation when navigating to a different root layout', async () => {\n+    const browser = await next.browser('/')\n+\n+    // Set an expando on the html element so we can detect if the page\n+    // gets unloaded.\n+    const html = await browser.elementByCss('html')\n+    await html.evaluate((el) => (el.__expando = true))\n+\n+    // Navigate to a page with a different root layout.\n+    const link = await browser.elementByCss(`a[href=\"/foo\"]`)\n+    await link.click()\n+\n+    // The expando should not be present because we did a full-page navigation.\n+    const htmlAfterNav = await browser.elementByCss('html')\n+    expect(await htmlAfterNav.evaluate((el) => el.__expando)).toBe(undefined)\n+  })\n+\n+  it(\n+    'triggers MPA navigation when navigating to a different root layout, ' +\n+      'during a navigation where a root param also changed',\n+    async () => {\n+      // Testing this scenario because a root param change alone does not\n+      // trigger an MPA navigation, but if an inner segment changes before the\n+      // root layout, then we should trigger an MPA navigation. This case is\n+      // handled slightly differently in the implementation than the case where\n+      // there's no root param change.\n+      const browser = await next.browser('/foo')\n+\n+      // Set an expando on the html element so we can detect if the page\n+      // gets unloaded.\n+      const html = await browser.elementByCss('html')\n+      await html.evaluate((el) => (el.__expando = true))\n+\n+      // Navigate to a page with a different root layout.\n+      const link = await browser.elementByCss(`a[href=\"/bar/inner\"]`)\n+      await link.click()\n+\n+      // The expando should not be present because we did a full-page navigation.\n+      const htmlAfterNav = await browser.elementByCss('html')\n+      expect(await htmlAfterNav.evaluate((el) => el.__expando)).toBe(undefined)\n+    }\n+  )\n+})"
        },
        {
            "sha": "a74129c5a24f2a6e1e828d8224b872c67645319b",
            "filename": "test/e2e/app-dir/segment-cache/mpa-navigations/next.config.js",
            "status": "added",
            "additions": 12,
            "deletions": 0,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/81ce3af8428a78b2cd6c19b823d830ff4196580f/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fmpa-navigations%2Fnext.config.js",
            "raw_url": "https://github.com/vercel/next.js/raw/81ce3af8428a78b2cd6c19b823d830ff4196580f/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fmpa-navigations%2Fnext.config.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fmpa-navigations%2Fnext.config.js?ref=81ce3af8428a78b2cd6c19b823d830ff4196580f",
            "patch": "@@ -0,0 +1,12 @@\n+/**\n+ * @type {import('next').NextConfig}\n+ */\n+const nextConfig = {\n+  experimental: {\n+    ppr: true,\n+    dynamicIO: true,\n+    clientSegmentCache: true,\n+  },\n+}\n+\n+module.exports = nextConfig"
        }
    ],
    "stats": {
        "total": 374,
        "additions": 337,
        "deletions": 37
    }
}