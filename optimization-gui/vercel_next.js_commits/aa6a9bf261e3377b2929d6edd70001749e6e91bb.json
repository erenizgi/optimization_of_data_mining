{
    "author": "bgw",
    "message": "refactor(turbo-tasks): Check for transient tasks called from persistent tasks in more places (#77760)\n\nCurrently, we only do this check when a transient task is created for the first time.\n\nHowever (e.g. assuming buggy implementations of `TaskInput`, use of `turbo_tasks::State`, etc) it's possible that a persistent function does not create a transient task, but does read from cached data.\n\nIn these cases, you wouldn't see the issue in development or in most e2e tests. Instead, you'd see panics after cache eviction (not yet on-by-default) or a restart of turbopack (as we cannot persistently cache transient tasks).\n\nThis tries to catch such potential issues earlier, so that we can catch them before they get to users.\n\nThis codepath is hot, but the check is very cheap: it's just checking the upper bit of two `u32`s.",
    "sha": "aa6a9bf261e3377b2929d6edd70001749e6e91bb",
    "files": [
        {
            "sha": "a071e048ea38df0d113f7d0635d1164521c95026",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 31,
            "deletions": 5,
            "changes": 36,
            "blob_url": "https://github.com/vercel/next.js/blob/aa6a9bf261e3377b2929d6edd70001749e6e91bb/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/aa6a9bf261e3377b2929d6edd70001749e6e91bb/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=aa6a9bf261e3377b2929d6edd70001749e6e91bb",
            "patch": "@@ -424,6 +424,10 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         consistency: ReadConsistency,\n         turbo_tasks: &dyn TurboTasksBackendApi<TurboTasksBackend<B>>,\n     ) -> Result<Result<RawVc, EventListener>> {\n+        if let Some(reader) = reader {\n+            self.assert_not_persistent_calling_transient(reader, task_id);\n+        }\n+\n         let mut ctx = self.execute_context(turbo_tasks);\n         let mut task = ctx.task(task_id, TaskDataCategory::All);\n \n@@ -622,6 +626,10 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         options: ReadCellOptions,\n         turbo_tasks: &dyn TurboTasksBackendApi<TurboTasksBackend<B>>,\n     ) -> Result<Result<TypedCellContent, EventListener>> {\n+        if let Some(reader) = reader {\n+            self.assert_not_persistent_calling_transient(reader, task_id);\n+        }\n+\n         fn add_cell_dependency<B: BackingStorage>(\n             backend: &TurboTasksBackendInner<B>,\n             mut task: impl TaskGuard,\n@@ -979,11 +987,9 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         turbo_tasks: &dyn TurboTasksBackendApi<TurboTasksBackend<B>>,\n     ) -> TaskId {\n         if !parent_task.is_transient() {\n-            let parent_task_type = self.lookup_task_type(parent_task);\n-            panic!(\n-                \"Calling transient function {} from persistent function {} is not allowed\",\n-                task_type.get_name(),\n-                parent_task_type.map_or(\"unknown\", |t| t.get_name())\n+            panic_persistent_calling_transient(\n+                self.lookup_task_type(parent_task).as_deref(),\n+                Some(&task_type),\n             );\n         }\n         if let Some(task_id) = self.task_cache.lookup_forward(&task_type) {\n@@ -1984,6 +1990,15 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             root_state.all_clean_event.notify(usize::MAX);\n         }\n     }\n+\n+    fn assert_not_persistent_calling_transient(&self, parent_id: TaskId, child_id: TaskId) {\n+        if !parent_id.is_transient() && child_id.is_transient() {\n+            panic_persistent_calling_transient(\n+                self.lookup_task_type(parent_id).as_deref(),\n+                self.lookup_task_type(child_id).as_deref(),\n+            );\n+        }\n+    }\n }\n \n impl<B: BackingStorage> Backend for TurboTasksBackend<B> {\n@@ -2261,6 +2276,17 @@ impl<B: BackingStorage> Backend for TurboTasksBackend<B> {\n     }\n }\n \n+fn panic_persistent_calling_transient(\n+    parent: Option<&CachedTaskType>,\n+    child: Option<&CachedTaskType>,\n+) {\n+    panic!(\n+        \"Persistent task {} is not allowed to call or read transient tasks {}\",\n+        parent.map_or(\"unknown\", |t| t.get_name()),\n+        child.map_or(\"unknown\", |t| t.get_name()),\n+    );\n+}\n+\n // from https://github.com/tokio-rs/tokio/blob/29cd6ec1ec6f90a7ee1ad641c03e0e00badbcb0e/tokio/src/time/instant.rs#L57-L63\n fn far_future() -> Instant {\n     // Roughly 30 years from now."
        }
    ],
    "stats": {
        "total": 36,
        "additions": 31,
        "deletions": 5
    }
}