{
    "author": "mischnic",
    "message": "Turbopack: compute async info from module graph (#76118)\n\nJust quickly propagate this boolean in the graph, as opposed to chunking. Enables us to eventually get rid of `AvailableModules` and also to reimplement chunking generally.\r\nCloses PACK-3667\r\n\r\nTODO:\r\n- [x] Per-layout segment computation of the async info\r\n- [x] Fix computation of the async info to handle cycles\r\n\r\n```\r\ntesting against 0293c96cf32\r\n\r\n\r\ncanary 42ab0048ad\r\n12,8gb\r\n533.86s user 82.91s system 889% cpu 1:09.36 total\r\n534.25s user 79.95s system 889% cpu 1:09.05 total\r\n\r\nmischnic/optimizations 2774fc5a3\r\n12,7\r\n520.29s user 81.71s system 881% cpu 1:08.31 total\r\n512.83s user 78.11s system 887% cpu 1:06.58 total\r\n```",
    "sha": "3ecef51b8c761e52e7c24bbe5f554418d9657abb",
    "files": [
        {
            "sha": "31bbf931fac0006ab8515ec39f40f62184dfe1f2",
            "filename": "crates/next-api/src/app.rs",
            "status": "modified",
            "additions": 38,
            "deletions": 41,
            "changes": 79,
            "blob_url": "https://github.com/vercel/next.js/blob/3ecef51b8c761e52e7c24bbe5f554418d9657abb/crates%2Fnext-api%2Fsrc%2Fapp.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3ecef51b8c761e52e7c24bbe5f554418d9657abb/crates%2Fnext-api%2Fsrc%2Fapp.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fapp.rs?ref=3ecef51b8c761e52e7c24bbe5f554418d9657abb",
            "patch": "@@ -54,7 +54,7 @@ use turbopack_core::{\n     asset::AssetContent,\n     chunk::{\n         availability_info::AvailabilityInfo, ChunkableModule, ChunkableModules, ChunkingContext,\n-        ChunkingContextExt, EntryChunkGroupResult, EvaluatableAsset, EvaluatableAssets,\n+        ChunkingContextExt, EvaluatableAsset, EvaluatableAssets,\n     },\n     file_source::FileSource,\n     ident::AssetIdent,\n@@ -1336,14 +1336,15 @@ impl AppEndpoint {\n \n         let server_action_manifest_loader = server_action_manifest.loader;\n \n-        let (app_entry_chunks, app_entry_chunks_availability) = &*self\n+        let app_entry_chunks = self\n             .app_entry_chunks(\n                 client_references,\n                 *server_action_manifest_loader,\n                 server_path,\n                 process_client_assets,\n                 *module_graphs.full,\n             )\n+            .to_resolved()\n             .await?;\n         let app_entry_chunks_ref = app_entry_chunks.await?;\n         server_assets.extend(app_entry_chunks_ref.iter().copied());\n@@ -1363,10 +1364,10 @@ impl AppEndpoint {\n                     entry_name: app_entry.original_name.clone(),\n                     client_references,\n                     client_references_chunks,\n-                    rsc_app_entry_chunks: **app_entry_chunks,\n-                    rsc_app_entry_chunks_availability: Value::new(*app_entry_chunks_availability),\n+                    rsc_app_entry_chunks: *app_entry_chunks,\n                     client_chunking_context,\n                     ssr_chunking_context,\n+                    async_module_info: module_graphs.full.async_module_info(),\n                     next_config: project.next_config(),\n                     runtime,\n                     mode: project.next_mode(),\n@@ -1414,7 +1415,7 @@ impl AppEndpoint {\n                 file_paths_from_root\n                     .extend(get_js_paths_from_root(&node_root_value, &app_entry_chunks_ref).await?);\n \n-                let all_output_assets = all_assets_from_entries(**app_entry_chunks).await?;\n+                let all_output_assets = all_assets_from_entries(*app_entry_chunks).await?;\n \n                 wasm_paths_from_root\n                     .extend(get_wasm_paths_from_root(&node_root_value, &middleware_assets).await?);\n@@ -1514,7 +1515,7 @@ impl AppEndpoint {\n                 }\n \n                 AppEndpointOutput::Edge {\n-                    files: *app_entry_chunks,\n+                    files: app_entry_chunks,\n                     server_assets: ResolvedVc::cell(\n                         server_assets.iter().cloned().collect::<Vec<_>>(),\n                     ),\n@@ -1617,7 +1618,7 @@ impl AppEndpoint {\n         server_path: Vc<FileSystemPath>,\n         process_client_assets: bool,\n         module_graph: Vc<ModuleGraph>,\n-    ) -> Result<Vc<OutputAssetsWithAvailability>> {\n+    ) -> Result<Vc<OutputAssets>> {\n         let this = self.await?;\n         let project = this.app_project.project();\n         let app_entry = self.app_endpoint_entry().await?;\n@@ -1636,29 +1637,23 @@ impl AppEndpoint {\n \n                 {\n                     let _span = tracing::info_span!(\"Server Components\");\n-                    Vc::cell((\n-                        chunking_context\n-                            .evaluated_chunk_group_assets(\n-                                app_entry.rsc_entry.ident(),\n-                                Vc::cell(evaluatable_assets.clone()),\n-                                module_graph,\n-                                Value::new(AvailabilityInfo::Root),\n-                            )\n-                            .to_resolved()\n-                            .await?,\n-                        AvailabilityInfo::Untracked,\n-                    ))\n+                    chunking_context\n+                        .evaluated_chunk_group_assets(\n+                            app_entry.rsc_entry.ident(),\n+                            Vc::cell(evaluatable_assets.clone()),\n+                            module_graph,\n+                            Value::new(AvailabilityInfo::Root),\n+                        )\n+                        .resolve()\n+                        .await?\n                 }\n             }\n             NextRuntime::NodeJs => {\n                 let mut evaluatable_assets = this.app_project.rsc_runtime_entries().owned().await?;\n \n                 evaluatable_assets.push(server_action_manifest_loader);\n \n-                let EntryChunkGroupResult {\n-                    asset: rsc_chunk,\n-                    availability_info,\n-                } = *(async {\n+                async {\n                     let mut current_chunks = OutputAssets::empty();\n                     let mut current_availability_info = AvailabilityInfo::Root;\n \n@@ -1731,26 +1726,28 @@ impl AppEndpoint {\n                         .await?;\n                     }\n \n-                    chunking_context\n-                        .entry_chunk_group(\n-                            server_path.join(\n-                                format!(\n-                                    \"app{original_name}.js\",\n-                                    original_name = app_entry.original_name\n-                                )\n-                                .into(),\n-                            ),\n-                            *app_entry.rsc_entry,\n-                            Vc::cell(evaluatable_assets),\n-                            module_graph,\n-                            current_chunks,\n-                            Value::new(current_availability_info),\n-                        )\n-                        .await\n+                    anyhow::Ok(Vc::cell(vec![\n+                        chunking_context\n+                            .entry_chunk_group_asset(\n+                                server_path.join(\n+                                    format!(\n+                                        \"app{original_name}.js\",\n+                                        original_name = app_entry.original_name\n+                                    )\n+                                    .into(),\n+                                ),\n+                                *app_entry.rsc_entry,\n+                                Vc::cell(evaluatable_assets),\n+                                module_graph,\n+                                current_chunks,\n+                                Value::new(current_availability_info),\n+                            )\n+                            .to_resolved()\n+                            .await?,\n+                    ]))\n                 }\n                 .instrument(tracing::trace_span!(\"server node entrypoint\"))\n-                .await?);\n-                Vc::cell((ResolvedVc::cell(vec![rsc_chunk]), availability_info))\n+                .await?\n             }\n         })\n     }"
        },
        {
            "sha": "394b254e341290be6b433369feb3696bfca3e100",
            "filename": "crates/next-api/src/module_graph.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/3ecef51b8c761e52e7c24bbe5f554418d9657abb/crates%2Fnext-api%2Fsrc%2Fmodule_graph.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3ecef51b8c761e52e7c24bbe5f554418d9657abb/crates%2Fnext-api%2Fsrc%2Fmodule_graph.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fmodule_graph.rs?ref=3ecef51b8c761e52e7c24bbe5f554418d9657abb",
            "patch": "@@ -313,7 +313,7 @@ impl ClientReferencesGraph {\n                 // state_map is `module -> Option< the current so parent server component >`\n                 &mut FxHashMap::default(),\n                 |parent_info, node, state_map| {\n-                    let module = node.module;\n+                    let module = node.module();\n                     let module_type = data.get(&module);\n \n                     let current_server_component = if let Some(\n@@ -346,7 +346,7 @@ impl ClientReferencesGraph {\n \n                     let parent_server_component = *state_map.get(&parent_module).unwrap();\n \n-                    match data.get(&node.module) {\n+                    match data.get(&node.module()) {\n                         Some(ClientReferenceMapType::EcmascriptClientReference {\n                             module: module_ref,\n                             ssr_module,"
        },
        {
            "sha": "985fd84aad9aa336411d0ecab81614d806ea7418",
            "filename": "crates/next-api/src/server_actions.rs",
            "status": "modified",
            "additions": 15,
            "deletions": 3,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/3ecef51b8c761e52e7c24bbe5f554418d9657abb/crates%2Fnext-api%2Fsrc%2Fserver_actions.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3ecef51b8c761e52e7c24bbe5f554418d9657abb/crates%2Fnext-api%2Fsrc%2Fserver_actions.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fserver_actions.rs?ref=3ecef51b8c761e52e7c24bbe5f554418d9657abb",
            "patch": "@@ -29,7 +29,10 @@ use turbopack_core::{\n     file_source::FileSource,\n     ident::AssetIdent,\n     module::Module,\n-    module_graph::{ModuleGraph, SingleModuleGraph, SingleModuleGraphModuleNode},\n+    module_graph::{\n+        async_module_info::AsyncModulesInfo, ModuleGraph, SingleModuleGraph,\n+        SingleModuleGraphModuleNode,\n+    },\n     output::OutputAsset,\n     reference_type::{EcmaScriptModulesReferenceSubType, ReferenceType},\n     resolve::ModulePart,\n@@ -74,7 +77,15 @@ pub(crate) async fn create_server_actions_manifest(\n         .await?;\n \n     let chunk_item = loader.as_chunk_item(module_graph, Vc::upcast(chunking_context));\n-    let manifest = build_manifest(node_root, page_name, runtime, actions, chunk_item).await?;\n+    let manifest = build_manifest(\n+        node_root,\n+        page_name,\n+        runtime,\n+        actions,\n+        chunk_item,\n+        module_graph.async_module_info(),\n+    )\n+    .await?;\n     Ok(ServerActionsManifest {\n         loader: evaluable,\n         manifest,\n@@ -150,6 +161,7 @@ async fn build_manifest(\n     runtime: NextRuntime,\n     actions: Vc<AllActions>,\n     chunk_item: Vc<Box<dyn ChunkItem>>,\n+    async_module_info: Vc<AsyncModulesInfo>,\n ) -> Result<ResolvedVc<Box<dyn OutputAsset>>> {\n     let manifest_path_prefix = &page_name;\n     let manifest_path = node_root\n@@ -173,7 +185,7 @@ async fn build_manifest(\n             &key,\n             ActionManifestWorkerEntry {\n                 module_id: ActionManifestModuleId::String(loader_id.as_str()),\n-                is_async: *chunk_item.module().is_self_async().await?,\n+                is_async: *async_module_info.is_async(chunk_item.module()).await?,\n             },\n         );\n         entry.layer.insert(&key, *layer);"
        },
        {
            "sha": "c8136d14373850a4c1cbd8f5660523227be393bf",
            "filename": "crates/next-core/src/next_manifests/client_reference_manifest.rs",
            "status": "modified",
            "additions": 194,
            "deletions": 195,
            "changes": 389,
            "blob_url": "https://github.com/vercel/next.js/blob/3ecef51b8c761e52e7c24bbe5f554418d9657abb/crates%2Fnext-core%2Fsrc%2Fnext_manifests%2Fclient_reference_manifest.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3ecef51b8c761e52e7c24bbe5f554418d9657abb/crates%2Fnext-core%2Fsrc%2Fnext_manifests%2Fclient_reference_manifest.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_manifests%2Fclient_reference_manifest.rs?ref=3ecef51b8c761e52e7c24bbe5f554418d9657abb",
            "patch": "@@ -6,15 +6,14 @@ use serde::{Deserialize, Serialize};\n use tracing::Instrument;\n use turbo_rcstr::RcStr;\n use turbo_tasks::{\n-    FxIndexSet, ReadRef, ResolvedVc, TaskInput, TryJoinIterExt, Value, ValueToString, Vc,\n+    FxIndexSet, ReadRef, ResolvedVc, TaskInput, TryFlatJoinIterExt, TryJoinIterExt, ValueToString,\n+    Vc,\n };\n use turbo_tasks_fs::{File, FileSystemPath};\n use turbopack_core::{\n     asset::{Asset, AssetContent},\n-    chunk::{\n-        availability_info::AvailabilityInfo, ChunkableModule, ChunkingContext,\n-        ModuleChunkItemIdExt, ModuleId as TurbopackModuleId,\n-    },\n+    chunk::{ChunkingContext, ModuleChunkItemIdExt, ModuleId as TurbopackModuleId},\n+    module_graph::async_module_info::AsyncModulesInfo,\n     output::{OutputAsset, OutputAssets},\n     virtual_output::VirtualOutputAsset,\n };\n@@ -37,9 +36,9 @@ pub struct ClientReferenceManifestOptions {\n     pub client_references: Vc<ClientReferenceGraphResult>,\n     pub client_references_chunks: Vc<ClientReferencesChunks>,\n     pub rsc_app_entry_chunks: Vc<OutputAssets>,\n-    pub rsc_app_entry_chunks_availability: Value<AvailabilityInfo>,\n     pub client_chunking_context: Vc<Box<dyn ChunkingContext>>,\n     pub ssr_chunking_context: Option<Vc<Box<dyn ChunkingContext>>>,\n+    pub async_module_info: Vc<AsyncModulesInfo>,\n     pub next_config: Vc<NextConfig>,\n     pub runtime: NextRuntime,\n     pub mode: Vc<NextMode>,\n@@ -58,9 +57,9 @@ impl ClientReferenceManifest {\n             client_references,\n             client_references_chunks,\n             rsc_app_entry_chunks,\n-            rsc_app_entry_chunks_availability,\n             client_chunking_context,\n             ssr_chunking_context,\n+            async_module_info,\n             next_config,\n             runtime,\n             mode,\n@@ -93,6 +92,34 @@ impl ClientReferenceManifest {\n             let node_root_ref = &*node_root.await?;\n             let rsc_app_entry_chunks = &*rsc_app_entry_chunks.await?;\n \n+            let client_references_ecmascript = client_references\n+                .await?\n+                .client_references\n+                .iter()\n+                .map(async |r| {\n+                    Ok(match r.ty() {\n+                        ClientReferenceType::EcmascriptClientReference(r) => Some((r, r.await?)),\n+                        ClientReferenceType::CssClientReference(_) => None,\n+                    })\n+                })\n+                .try_flat_join()\n+                .await?;\n+\n+            let async_modules = async_module_info\n+                .is_async_multiple(Vc::cell(\n+                    client_references_ecmascript\n+                        .iter()\n+                        .flat_map(|(r, r_val)| {\n+                            [\n+                                ResolvedVc::upcast(*r),\n+                                ResolvedVc::upcast(r_val.client_module),\n+                                ResolvedVc::upcast(r_val.ssr_module),\n+                            ]\n+                        })\n+                        .collect(),\n+                ))\n+                .await?;\n+\n             async fn cached_chunk_paths(\n                 cache: &mut FxHashMap<ResolvedVc<Box<dyn OutputAsset>>, ReadRef<FileSystemPath>>,\n                 chunks: impl Iterator<Item = ResolvedVc<Box<dyn OutputAsset>>>,\n@@ -135,188 +162,173 @@ impl ClientReferenceManifest {\n                 ReadRef<FileSystemPath>,\n             > = FxHashMap::default();\n \n-            for app_client_reference in client_references.await?.client_references.iter() {\n-                let app_client_reference_ty = app_client_reference.ty();\n+            for (client_reference_module, client_reference_module_ref) in\n+                client_references_ecmascript\n+            {\n+                let app_client_reference_ty =\n+                    ClientReferenceType::EcmascriptClientReference(client_reference_module);\n \n-                // An client component need to be emitted into the client reference manifest\n-                if let ClientReferenceType::EcmascriptClientReference(client_reference_module) =\n-                    app_client_reference_ty\n-                {\n-                    let client_reference_module_ref = client_reference_module.await?;\n+                let server_path = client_reference_module_ref.server_ident.to_string().await?;\n+                let client_module = client_reference_module_ref.client_module;\n+                let client_chunk_item_id = client_module\n+                    .chunk_item_id(Vc::upcast(client_chunking_context))\n+                    .await?;\n \n-                    let server_path = client_reference_module_ref.server_ident.to_string().await?;\n-                    let client_module = client_reference_module_ref.client_module;\n-                    let client_chunk_item_id = client_module\n-                        .chunk_item_id(Vc::upcast(client_chunking_context))\n+                let (client_chunks_paths, client_is_async) =\n+                    if let Some((client_chunks, _client_availability_info)) =\n+                        client_component_client_chunks.get(&app_client_reference_ty)\n+                    {\n+                        let client_chunks = client_chunks.await?;\n+                        references.extend(client_chunks.iter());\n+                        let client_chunks_paths = cached_chunk_paths(\n+                            &mut client_chunk_path_cache,\n+                            client_chunks.iter().copied(),\n+                        )\n                         .await?;\n \n-                    let (client_chunks_paths, client_is_async) =\n-                        if let Some((client_chunks, client_availability_info)) =\n-                            client_component_client_chunks.get(&app_client_reference_ty)\n-                        {\n-                            let client_chunks = client_chunks.await?;\n-                            references.extend(client_chunks.iter());\n-                            let client_chunks_paths = cached_chunk_paths(\n-                                &mut client_chunk_path_cache,\n-                                client_chunks.iter().copied(),\n-                            )\n-                            .await?;\n-\n-                            let chunk_paths = client_chunks_paths\n-                                .filter_map(|(_, chunk_path)| {\n-                                    client_relative_path\n-                                        .get_path_to(&chunk_path)\n-                                        .map(ToString::to_string)\n-                                })\n-                                // It's possible that a chunk also emits CSS files, that will\n-                                // be handled separatedly.\n-                                .filter(|path| path.ends_with(\".js\"))\n-                                .map(RcStr::from)\n-                                .collect::<Vec<_>>();\n-\n-                            let is_async = is_item_async(\n-                                client_availability_info,\n-                                ResolvedVc::upcast(client_module),\n-                            )\n-                            .await?;\n-\n-                            (chunk_paths, is_async)\n-                        } else {\n-                            (Vec::new(), false)\n-                        };\n+                        let chunk_paths = client_chunks_paths\n+                            .filter_map(|(_, chunk_path)| {\n+                                client_relative_path\n+                                    .get_path_to(&chunk_path)\n+                                    .map(ToString::to_string)\n+                            })\n+                            // It's possible that a chunk also emits CSS files, that will\n+                            // be handled separatedly.\n+                            .filter(|path| path.ends_with(\".js\"))\n+                            .map(RcStr::from)\n+                            .collect::<Vec<_>>();\n+\n+                        let is_async = async_modules.contains(&ResolvedVc::upcast(client_module));\n+\n+                        (chunk_paths, is_async)\n+                    } else {\n+                        (Vec::new(), false)\n+                    };\n+\n+                if let Some(ssr_chunking_context) = ssr_chunking_context {\n+                    let ssr_module = client_reference_module_ref.ssr_module;\n+                    let ssr_chunk_item_id = ssr_module\n+                        .chunk_item_id(Vc::upcast(ssr_chunking_context))\n+                        .await?;\n \n-                    if let Some(ssr_chunking_context) = ssr_chunking_context {\n-                        let ssr_module = client_reference_module_ref.ssr_module;\n-                        let ssr_chunk_item_id = ssr_module\n-                            .chunk_item_id(Vc::upcast(ssr_chunking_context))\n-                            .await?;\n-\n-                        let rsc_chunk_item_id = client_reference_module\n-                            .chunk_item_id(Vc::upcast(ssr_chunking_context))\n-                            .await?;\n-\n-                        let (ssr_chunks_paths, ssr_is_async) = if runtime == NextRuntime::Edge {\n-                            // the chunks get added to the middleware-manifest.json instead\n-                            // of this file because the\n-                            // edge runtime doesn't support dynamically\n-                            // loading chunks.\n-                            (Vec::new(), false)\n-                        } else if let Some((ssr_chunks, ssr_availability_info)) =\n-                            client_component_ssr_chunks.get(&app_client_reference_ty)\n-                        {\n-                            let ssr_chunks = ssr_chunks.await?;\n-                            references.extend(ssr_chunks.iter());\n-\n-                            let ssr_chunks_paths = cached_chunk_paths(\n-                                &mut ssr_chunk_path_cache,\n-                                ssr_chunks.iter().copied(),\n-                            )\n-                            .await?;\n-                            let chunk_paths = ssr_chunks_paths\n-                                .filter_map(|(_, chunk_path)| {\n-                                    node_root_ref\n-                                        .get_path_to(&chunk_path)\n-                                        .map(ToString::to_string)\n-                                })\n-                                .map(RcStr::from)\n-                                .collect::<Vec<_>>();\n-\n-                            let is_async = is_item_async(\n-                                ssr_availability_info,\n-                                ResolvedVc::upcast(ssr_module),\n-                            )\n-                            .await?;\n-\n-                            (chunk_paths, is_async)\n-                        } else {\n-                            (Vec::new(), false)\n-                        };\n+                    let rsc_chunk_item_id = client_reference_module\n+                        .chunk_item_id(Vc::upcast(ssr_chunking_context))\n+                        .await?;\n \n-                        let (rsc_chunks_paths, rsc_is_async) = if runtime == NextRuntime::Edge {\n-                            // the chunks get added to the middleware-manifest.json instead\n-                            // of this file because the\n-                            // edge runtime doesn't support dynamically\n-                            // loading chunks.\n-                            (Vec::new(), false)\n-                        } else {\n-                            let rsc_chunks_paths = cached_chunk_paths(\n-                                &mut rsc_chunk_path_cache,\n-                                rsc_app_entry_chunks.iter().copied(),\n-                            )\n-                            .await?;\n-\n-                            let chunk_paths = rsc_chunks_paths\n-                                .filter_map(|(_, chunk_path)| {\n-                                    node_root_ref\n-                                        .get_path_to(&chunk_path)\n-                                        .map(ToString::to_string)\n-                                })\n-                                .map(RcStr::from)\n-                                .collect::<Vec<_>>();\n-\n-                            let is_async = is_item_async(\n-                                &rsc_app_entry_chunks_availability,\n-                                ResolvedVc::upcast(client_reference_module),\n-                            )\n-                            .await?;\n-\n-                            (chunk_paths, is_async)\n-                        };\n+                    let (ssr_chunks_paths, ssr_is_async) = if runtime == NextRuntime::Edge {\n+                        // the chunks get added to the middleware-manifest.json instead\n+                        // of this file because the\n+                        // edge runtime doesn't support dynamically\n+                        // loading chunks.\n+                        (Vec::new(), false)\n+                    } else if let Some((ssr_chunks, _ssr_availability_info)) =\n+                        client_component_ssr_chunks.get(&app_client_reference_ty)\n+                    {\n+                        let ssr_chunks = ssr_chunks.await?;\n+                        references.extend(ssr_chunks.iter());\n+\n+                        let ssr_chunks_paths = cached_chunk_paths(\n+                            &mut ssr_chunk_path_cache,\n+                            ssr_chunks.iter().copied(),\n+                        )\n+                        .await?;\n+                        let chunk_paths = ssr_chunks_paths\n+                            .filter_map(|(_, chunk_path)| {\n+                                node_root_ref\n+                                    .get_path_to(&chunk_path)\n+                                    .map(ToString::to_string)\n+                            })\n+                            .map(RcStr::from)\n+                            .collect::<Vec<_>>();\n+\n+                        let is_async = async_modules.contains(&ResolvedVc::upcast(ssr_module));\n+\n+                        (chunk_paths, is_async)\n+                    } else {\n+                        (Vec::new(), false)\n+                    };\n+\n+                    let (rsc_chunks_paths, rsc_is_async) = if runtime == NextRuntime::Edge {\n+                        // the chunks get added to the middleware-manifest.json instead\n+                        // of this file because the\n+                        // edge runtime doesn't support dynamically\n+                        // loading chunks.\n+                        (Vec::new(), false)\n+                    } else {\n+                        let rsc_chunks_paths = cached_chunk_paths(\n+                            &mut rsc_chunk_path_cache,\n+                            rsc_app_entry_chunks.iter().copied(),\n+                        )\n+                        .await?;\n \n-                        entry_manifest.client_modules.module_exports.insert(\n-                            get_client_reference_module_key(&server_path, \"*\"),\n-                            ManifestNodeEntry {\n-                                name: \"*\".into(),\n-                                id: (&*client_chunk_item_id).into(),\n-                                chunks: client_chunks_paths,\n-                                // This should of course be client_is_async, but SSR can become\n-                                // async due to ESM externals, and\n-                                // the ssr_manifest_node is currently ignored\n-                                // by React.\n-                                r#async: client_is_async || ssr_is_async,\n-                            },\n-                        );\n-\n-                        let mut ssr_manifest_node = ManifestNode::default();\n-                        ssr_manifest_node.module_exports.insert(\n-                            \"*\".into(),\n-                            ManifestNodeEntry {\n-                                name: \"*\".into(),\n-                                id: (&*ssr_chunk_item_id).into(),\n-                                chunks: ssr_chunks_paths,\n-                                // See above\n-                                r#async: client_is_async || ssr_is_async,\n-                            },\n-                        );\n-\n-                        let mut rsc_manifest_node = ManifestNode::default();\n-                        rsc_manifest_node.module_exports.insert(\n-                            \"*\".into(),\n-                            ManifestNodeEntry {\n-                                name: \"*\".into(),\n-                                id: (&*rsc_chunk_item_id).into(),\n-                                chunks: rsc_chunks_paths,\n-                                r#async: rsc_is_async,\n-                            },\n-                        );\n-\n-                        match runtime {\n-                            NextRuntime::NodeJs => {\n-                                entry_manifest\n-                                    .ssr_module_mapping\n-                                    .insert((&*client_chunk_item_id).into(), ssr_manifest_node);\n-                                entry_manifest\n-                                    .rsc_module_mapping\n-                                    .insert((&*client_chunk_item_id).into(), rsc_manifest_node);\n-                            }\n-                            NextRuntime::Edge => {\n-                                entry_manifest\n-                                    .edge_ssr_module_mapping\n-                                    .insert((&*client_chunk_item_id).into(), ssr_manifest_node);\n-                                entry_manifest\n-                                    .edge_rsc_module_mapping\n-                                    .insert((&*client_chunk_item_id).into(), rsc_manifest_node);\n-                            }\n+                        let chunk_paths = rsc_chunks_paths\n+                            .filter_map(|(_, chunk_path)| {\n+                                node_root_ref\n+                                    .get_path_to(&chunk_path)\n+                                    .map(ToString::to_string)\n+                            })\n+                            .map(RcStr::from)\n+                            .collect::<Vec<_>>();\n+\n+                        let is_async =\n+                            async_modules.contains(&ResolvedVc::upcast(client_reference_module));\n+\n+                        (chunk_paths, is_async)\n+                    };\n+\n+                    entry_manifest.client_modules.module_exports.insert(\n+                        get_client_reference_module_key(&server_path, \"*\"),\n+                        ManifestNodeEntry {\n+                            name: \"*\".into(),\n+                            id: (&*client_chunk_item_id).into(),\n+                            chunks: client_chunks_paths,\n+                            // This should of course be client_is_async, but SSR can become\n+                            // async due to ESM externals, and\n+                            // the ssr_manifest_node is currently ignored\n+                            // by React.\n+                            r#async: client_is_async || ssr_is_async,\n+                        },\n+                    );\n+\n+                    let mut ssr_manifest_node = ManifestNode::default();\n+                    ssr_manifest_node.module_exports.insert(\n+                        \"*\".into(),\n+                        ManifestNodeEntry {\n+                            name: \"*\".into(),\n+                            id: (&*ssr_chunk_item_id).into(),\n+                            chunks: ssr_chunks_paths,\n+                            // See above\n+                            r#async: client_is_async || ssr_is_async,\n+                        },\n+                    );\n+\n+                    let mut rsc_manifest_node = ManifestNode::default();\n+                    rsc_manifest_node.module_exports.insert(\n+                        \"*\".into(),\n+                        ManifestNodeEntry {\n+                            name: \"*\".into(),\n+                            id: (&*rsc_chunk_item_id).into(),\n+                            chunks: rsc_chunks_paths,\n+                            r#async: rsc_is_async,\n+                        },\n+                    );\n+\n+                    match runtime {\n+                        NextRuntime::NodeJs => {\n+                            entry_manifest\n+                                .ssr_module_mapping\n+                                .insert((&*client_chunk_item_id).into(), ssr_manifest_node);\n+                            entry_manifest\n+                                .rsc_module_mapping\n+                                .insert((&*client_chunk_item_id).into(), rsc_manifest_node);\n+                        }\n+                        NextRuntime::Edge => {\n+                            entry_manifest\n+                                .edge_ssr_module_mapping\n+                                .insert((&*client_chunk_item_id).into(), ssr_manifest_node);\n+                            entry_manifest\n+                                .edge_rsc_module_mapping\n+                                .insert((&*client_chunk_item_id).into(), rsc_manifest_node);\n                         }\n                     }\n                 }\n@@ -433,16 +445,3 @@ pub fn get_client_reference_module_key(server_path: &str, export_name: &str) ->\n         format!(\"{}#{}\", server_path, export_name).into()\n     }\n }\n-\n-async fn is_item_async(\n-    availability_info: &AvailabilityInfo,\n-    module: ResolvedVc<Box<dyn ChunkableModule>>,\n-) -> Result<bool> {\n-    let Some(available_modules) = availability_info.available_modules() else {\n-        return Ok(false);\n-    };\n-\n-    let available_modules = available_modules.snapshot().await?;\n-\n-    Ok(available_modules.get(module).is_some_and(|i| i.is_async))\n-}"
        },
        {
            "sha": "6415fbe18db8d048eabcc933774006978b4f258b",
            "filename": "turbopack/crates/turbopack-core/src/chunk/available_chunk_items.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 108,
            "changes": 108,
            "blob_url": "https://github.com/vercel/next.js/blob/5216f2ccba4c089d158f07124fecc3b474eddec6/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Favailable_chunk_items.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5216f2ccba4c089d158f07124fecc3b474eddec6/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Favailable_chunk_items.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Favailable_chunk_items.rs?ref=5216f2ccba4c089d158f07124fecc3b474eddec6",
            "patch": "@@ -1,108 +0,0 @@\n-use anyhow::Result;\n-use serde::{Deserialize, Serialize};\n-use turbo_tasks::{\n-    debug::ValueDebugFormat, trace::TraceRawVcs, FxIndexMap, NonLocalValue, ResolvedVc,\n-    TryFlatJoinIterExt, TryJoinIterExt, ValueToString, Vc,\n-};\n-use turbo_tasks_hash::Xxh3Hash64Hasher;\n-\n-use super::ChunkItem;\n-\n-#[derive(\n-    PartialEq, Eq, TraceRawVcs, Copy, Clone, Serialize, Deserialize, ValueDebugFormat, NonLocalValue,\n-)]\n-pub struct AvailableChunkItemInfo {\n-    pub is_async: bool,\n-}\n-\n-#[turbo_tasks::value(transparent)]\n-pub struct AvailableChunkItemInfoMap(\n-    FxIndexMap<ResolvedVc<Box<dyn ChunkItem>>, AvailableChunkItemInfo>,\n-);\n-\n-/// Allows to gather information about which assets are already available.\n-/// Adding more roots will form a linked list like structure to allow caching\n-/// `include` queries.\n-#[turbo_tasks::value]\n-pub struct AvailableChunkItems {\n-    parent: Option<ResolvedVc<AvailableChunkItems>>,\n-    chunk_items: ResolvedVc<AvailableChunkItemInfoMap>,\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl AvailableChunkItems {\n-    #[turbo_tasks::function]\n-    pub fn new(chunk_items: ResolvedVc<AvailableChunkItemInfoMap>) -> Vc<Self> {\n-        AvailableChunkItems {\n-            parent: None,\n-            chunk_items,\n-        }\n-        .cell()\n-    }\n-\n-    #[turbo_tasks::function]\n-    pub async fn with_chunk_items(\n-        self: ResolvedVc<Self>,\n-        chunk_items: ResolvedVc<AvailableChunkItemInfoMap>,\n-    ) -> Result<Vc<Self>> {\n-        let this = &*self.await?;\n-        let chunk_items = chunk_items\n-            .await?\n-            .into_iter()\n-            .map(|(&chunk_item, &info)| async move {\n-                Ok(this\n-                    .get(chunk_item)\n-                    .await?\n-                    .is_none()\n-                    .then_some((chunk_item, info)))\n-            })\n-            .try_flat_join()\n-            .await?;\n-        Ok(AvailableChunkItems {\n-            parent: Some(self),\n-            chunk_items: ResolvedVc::cell(chunk_items.into_iter().collect()),\n-        }\n-        .cell())\n-    }\n-\n-    #[turbo_tasks::function]\n-    pub async fn hash(&self) -> Result<Vc<u64>> {\n-        let mut hasher = Xxh3Hash64Hasher::new();\n-        if let Some(parent) = self.parent {\n-            hasher.write_value(parent.hash().await?);\n-        } else {\n-            hasher.write_value(0u64);\n-        }\n-        let item_idents = self\n-            .chunk_items\n-            .await?\n-            .iter()\n-            .map(|(&chunk_item, _)| chunk_item.asset_ident().to_string())\n-            .try_join()\n-            .await?;\n-        for ident in item_idents {\n-            hasher.write_value(ident);\n-        }\n-        Ok(Vc::cell(hasher.finish()))\n-    }\n-}\n-\n-impl AvailableChunkItems {\n-    // This is not a turbo-tasks function because:\n-    //\n-    // - We want to enforce that the `chunk_item` key is a `ResolvedVc`, so that it will actually\n-    //   match the entries in the `HashMap`.\n-    // - This is a cheap operation that's unlikely to be worth caching.\n-    pub async fn get(\n-        &self,\n-        chunk_item: ResolvedVc<Box<dyn ChunkItem>>,\n-    ) -> Result<Option<AvailableChunkItemInfo>> {\n-        if let Some(&info) = self.chunk_items.await?.get(&chunk_item) {\n-            return Ok(Some(info));\n-        };\n-        if let Some(parent) = self.parent {\n-            return Box::pin(parent.await?.get(chunk_item)).await;\n-        }\n-        Ok(None)\n-    }\n-}"
        },
        {
            "sha": "38f2329502912161fb4de9c1ef41a8b9ce333ac2",
            "filename": "turbopack/crates/turbopack-core/src/chunk/available_modules.rs",
            "status": "modified",
            "additions": 14,
            "deletions": 60,
            "changes": 74,
            "blob_url": "https://github.com/vercel/next.js/blob/3ecef51b8c761e52e7c24bbe5f554418d9657abb/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Favailable_modules.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3ecef51b8c761e52e7c24bbe5f554418d9657abb/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Favailable_modules.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Favailable_modules.rs?ref=3ecef51b8c761e52e7c24bbe5f554418d9657abb",
            "patch": "@@ -1,38 +1,13 @@\n use anyhow::Result;\n-use serde::{Deserialize, Serialize};\n-use turbo_tasks::{\n-    debug::ValueDebugFormat, trace::TraceRawVcs, FxIndexMap, NonLocalValue, ReadRef, ResolvedVc,\n-    TryJoinIterExt, ValueToString, Vc,\n-};\n+use turbo_tasks::{FxIndexSet, ReadRef, ResolvedVc, TryJoinIterExt, ValueToString, Vc};\n use turbo_tasks_hash::Xxh3Hash64Hasher;\n \n use super::ChunkableModule;\n use crate::module::Module;\n \n-#[derive(\n-    Debug,\n-    PartialEq,\n-    Eq,\n-    TraceRawVcs,\n-    Copy,\n-    Clone,\n-    Serialize,\n-    Deserialize,\n-    ValueDebugFormat,\n-    NonLocalValue,\n-)]\n-pub struct AvailableModulesInfo {\n-    pub is_async: bool,\n-}\n-\n-#[turbo_tasks::value(transparent)]\n-pub struct OptionAvailableModulesInfo(Option<AvailableModulesInfo>);\n-\n #[turbo_tasks::value(transparent)]\n #[derive(Debug, Clone)]\n-pub struct AvailableModuleInfoMap(\n-    FxIndexMap<ResolvedVc<Box<dyn ChunkableModule>>, AvailableModulesInfo>,\n-);\n+pub struct AvailableModuleInfoMap(FxIndexSet<ResolvedVc<Box<dyn ChunkableModule>>>);\n \n /// Allows to gather information about which assets are already available.\n /// Adding more roots will form a linked list like structure to allow caching\n@@ -59,22 +34,9 @@ impl AvailableModules {\n         self: ResolvedVc<Self>,\n         modules: ResolvedVc<AvailableModuleInfoMap>,\n     ) -> Result<Vc<Self>> {\n-        let self_snapshot = self.snapshot().await?;\n-\n-        let modules = modules\n-            .await?\n-            .into_iter()\n-            .flat_map(|(&module, &info)| {\n-                self_snapshot\n-                    .get(module)\n-                    .is_none()\n-                    .then_some((module, info))\n-            })\n-            .collect();\n-\n         Ok(AvailableModules {\n             parent: Some(self),\n-            modules: ResolvedVc::cell(modules),\n+            modules,\n         }\n         .cell())\n     }\n@@ -91,7 +53,7 @@ impl AvailableModules {\n             .modules\n             .await?\n             .iter()\n-            .map(|(&module, _)| module.ident().to_string())\n+            .map(|module| module.ident().to_string())\n             .try_join()\n             .await?;\n         for ident in item_idents {\n@@ -101,17 +63,14 @@ impl AvailableModules {\n     }\n \n     #[turbo_tasks::function]\n-    pub async fn get(\n-        &self,\n-        module: ResolvedVc<Box<dyn ChunkableModule>>,\n-    ) -> Result<Vc<OptionAvailableModulesInfo>> {\n-        if let Some(&info) = self.modules.await?.get(&module) {\n-            return Ok(Vc::cell(Some(info)));\n+    pub async fn get(&self, module: ResolvedVc<Box<dyn ChunkableModule>>) -> Result<Vc<bool>> {\n+        if self.modules.await?.contains(&module) {\n+            return Ok(Vc::cell(true));\n         };\n         if let Some(parent) = self.parent {\n             return Ok(parent.get(*module));\n         }\n-        Ok(Vc::cell(None))\n+        Ok(Vc::cell(false))\n     }\n \n     #[turbo_tasks::function]\n@@ -135,16 +94,11 @@ pub struct AvailableModulesSnapshot {\n }\n \n impl AvailableModulesSnapshot {\n-    pub fn get(\n-        &self,\n-        module: ResolvedVc<Box<dyn ChunkableModule>>,\n-    ) -> Option<AvailableModulesInfo> {\n-        if let Some(&info) = self.modules.get(&module) {\n-            return Some(info);\n-        };\n-        if let Some(parent) = &self.parent {\n-            return parent.get(module);\n-        }\n-        None\n+    pub fn get(&self, module: ResolvedVc<Box<dyn ChunkableModule>>) -> bool {\n+        self.modules.contains(&module)\n+            || self\n+                .parent\n+                .as_ref()\n+                .is_some_and(|parent| parent.get(module))\n     }\n }"
        },
        {
            "sha": "5e734c280f2778de795248d30e6abdbed8dc2a6a",
            "filename": "turbopack/crates/turbopack-core/src/chunk/chunk_group.rs",
            "status": "modified",
            "additions": 35,
            "deletions": 136,
            "changes": 171,
            "blob_url": "https://github.com/vercel/next.js/blob/3ecef51b8c761e52e7c24bbe5f554418d9657abb/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fchunk_group.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3ecef51b8c761e52e7c24bbe5f554418d9657abb/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fchunk_group.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fchunk_group.rs?ref=3ecef51b8c761e52e7c24bbe5f554418d9657abb",
            "patch": "@@ -1,17 +1,14 @@\n use std::collections::HashSet;\n \n-use anyhow::{Context, Result};\n-use auto_hash_map::AutoSet;\n+use anyhow::Result;\n use futures::future::Either;\n use rustc_hash::FxHashMap;\n-use turbo_tasks::{\n-    FxIndexMap, FxIndexSet, ResolvedVc, TryFlatJoinIterExt, TryJoinIterExt, Value, Vc,\n-};\n+use turbo_tasks::{FxIndexMap, FxIndexSet, ResolvedVc, TryJoinIterExt, Value, Vc};\n \n use super::{\n-    availability_info::AvailabilityInfo, available_modules::AvailableModulesInfo,\n-    chunking::make_chunks, AsyncModuleInfo, Chunk, ChunkGroupContent, ChunkItem, ChunkItemTy,\n-    ChunkItemWithAsyncModuleInfo, ChunkableModule, ChunkingContext,\n+    availability_info::AvailabilityInfo, chunking::make_chunks, AsyncModuleInfo, Chunk,\n+    ChunkGroupContent, ChunkItem, ChunkItemTy, ChunkItemWithAsyncModuleInfo, ChunkableModule,\n+    ChunkingContext,\n };\n use crate::{\n     chunk::ChunkingType,\n@@ -46,9 +43,6 @@ pub async fn make_chunk_group(\n         async_modules,\n         traced_modules,\n         passthrough_modules,\n-        forward_edges_inherit_async,\n-        local_back_edges_inherit_async,\n-        available_async_modules_back_edges_inherit_async,\n     } = chunk_group_content(\n         &*module_graph.await?,\n         chunk_group_entries,\n@@ -58,99 +52,36 @@ pub async fn make_chunk_group(\n     )\n     .await?;\n \n-    // Find all local chunk items that are self async\n-    let self_async_children = chunkable_modules\n-        .iter()\n-        .copied()\n-        .map(|m| async move {\n-            let is_self_async = *m.is_self_async().await?;\n-            Ok(is_self_async.then_some(m))\n-        })\n-        .try_flat_join()\n-        .await?;\n+    let async_modules_info = module_graph.async_module_info().await?;\n \n-    // Get all available async modules and concatenate with local async modules\n-    let mut all_async_modules = available_async_modules_back_edges_inherit_async\n-        .keys()\n+    // Create map for chunk items with empty [Option<Vc<AsyncModuleInfo>>]\n+    let all_modules = chunkable_modules\n+        .iter()\n         .copied()\n-        .chain(self_async_children.into_iter())\n-        .map(|m| (m, AutoSet::<ResolvedVc<Box<dyn ChunkableModule>>>::new()))\n-        .collect::<FxIndexMap<_, _>>();\n-\n-    // Propagate async inheritance\n-    let mut i = 0;\n-    loop {\n-        let Some((&async_module, _)) = all_async_modules.get_index(i) else {\n-            break;\n-        };\n-        // The first few entries are from\n-        // available_async_modules_back_edges_inherit_async and need to use that map,\n-        // all other entries are local\n-        let map = if i < available_async_modules_back_edges_inherit_async.len() {\n-            &available_async_modules_back_edges_inherit_async\n-        } else {\n-            &local_back_edges_inherit_async\n-        };\n-        if let Some(parents) = map.get(&async_module) {\n-            for &parent in parents.iter() {\n-                // Add item, it will be iterated by this loop too\n-                all_async_modules\n-                    .entry(parent)\n-                    .or_default()\n-                    .insert(async_module);\n+        .map(async |m| {\n+            if async_modules_info.contains(&ResolvedVc::upcast(m)) {\n+                anyhow::Ok((\n+                    m,\n+                    Some(\n+                        module_graph\n+                            .referenced_async_modules(*ResolvedVc::upcast(m))\n+                            .to_resolved()\n+                            .await?,\n+                    ),\n+                ))\n+            } else {\n+                anyhow::Ok((m, None))\n             }\n-        }\n-        i += 1;\n-    }\n-\n-    // Create map for chunk items with empty [Option<Vc<AsyncModuleInfo>>]\n-    let mut all_modules = chunkable_modules\n+        })\n+        .try_join()\n+        .await?\n         .into_iter()\n-        .map(|m| (m, None))\n         .collect::<FxIndexMap<_, Option<ResolvedVc<AsyncModuleInfo>>>>();\n \n-    // Insert AsyncModuleInfo for every async module\n-    for (async_item, referenced_async_modules) in all_async_modules {\n-        let referenced_async_modules =\n-            if let Some(references) = forward_edges_inherit_async.get(&async_item) {\n-                references\n-                    .iter()\n-                    .copied()\n-                    .filter(|item| referenced_async_modules.contains(item))\n-                    .map(|item| *item)\n-                    .collect()\n-            } else {\n-                Default::default()\n-            };\n-        all_modules.insert(\n-            async_item,\n-            Some(\n-                AsyncModuleInfo::new(referenced_async_modules)\n-                    .to_resolved()\n-                    .await?,\n-            ),\n-        );\n-    }\n-\n     // Compute new [AvailabilityInfo]\n-    let availability_info = {\n-        let map = all_modules\n-            .iter()\n-            .map(|(&module, async_info)| async move {\n-                Ok((\n-                    module,\n-                    AvailableModulesInfo {\n-                        is_async: async_info.is_some(),\n-                    },\n-                ))\n-            })\n-            .try_join()\n-            .await?\n-            .into_iter()\n-            .collect();\n-        let map = Vc::cell(map);\n-        availability_info.with_modules(map).await?\n-    };\n+    let availability_info = availability_info\n+        .with_modules(Vc::cell(chunkable_modules))\n+        .await?;\n \n     // Insert async chunk loaders for every referenced async module\n     let async_loaders = async_modules\n@@ -282,9 +213,6 @@ pub async fn chunk_group_content(\n             async_modules: FxIndexSet::default(),\n             traced_modules: FxIndexSet::default(),\n             passthrough_modules: FxIndexSet::default(),\n-            forward_edges_inherit_async: FxIndexMap::default(),\n-            local_back_edges_inherit_async: FxIndexMap::default(),\n-            available_async_modules_back_edges_inherit_async: FxIndexMap::default(),\n         },\n     };\n \n@@ -316,57 +244,28 @@ pub async fn chunk_group_content(\n                     return Ok(GraphTraversalAction::Skip);\n                 };\n \n-                let available_info = available_modules\n+                let is_available = available_modules\n                     .as_ref()\n-                    .and_then(|available_modules| available_modules.get(chunkable_module));\n+                    .is_some_and(|available_modules| available_modules.get(chunkable_module));\n \n-                let Some((parent_node, edge)) = parent_info else {\n-                    return Ok(if available_info.is_some() {\n+                let Some((_, edge)) = parent_info else {\n+                    return Ok(if is_available {\n                         GraphTraversalAction::Skip\n                     } else {\n                         unsorted_chunkable_modules.insert(node.module, chunkable_module);\n                         GraphTraversalAction::Continue\n                     });\n                 };\n \n-                let parent_module =\n-                    ResolvedVc::try_sidecast::<Box<dyn ChunkableModule>>(parent_node.module)\n-                        .context(\"Expected parent module to be chunkable\")?;\n-\n                 Ok(match edge {\n                     ChunkingType::Passthrough => {\n                         result.passthrough_modules.insert(chunkable_module);\n                         GraphTraversalAction::Continue\n                     }\n-                    ChunkingType::Parallel => {\n-                        if available_info.is_some() {\n-                            GraphTraversalAction::Skip\n-                        } else {\n-                            unsorted_chunkable_modules.insert(node.module, chunkable_module);\n-                            GraphTraversalAction::Continue\n-                        }\n-                    }\n-                    ChunkingType::ParallelInheritAsync => {\n-                        result\n-                            .forward_edges_inherit_async\n-                            .entry(parent_module)\n-                            .or_default()\n-                            .push(chunkable_module);\n-                        if let Some(info) = available_info {\n-                            if info.is_async {\n-                                result\n-                                    .available_async_modules_back_edges_inherit_async\n-                                    .entry(chunkable_module)\n-                                    .or_default()\n-                                    .push(parent_module);\n-                            }\n+                    ChunkingType::Parallel | ChunkingType::ParallelInheritAsync => {\n+                        if is_available {\n                             GraphTraversalAction::Skip\n                         } else {\n-                            result\n-                                .local_back_edges_inherit_async\n-                                .entry(chunkable_module)\n-                                .or_default()\n-                                .push(parent_module);\n                             unsorted_chunkable_modules.insert(node.module, chunkable_module);\n                             GraphTraversalAction::Continue\n                         }\n@@ -375,7 +274,7 @@ pub async fn chunk_group_content(\n                         if can_split_async {\n                             result.async_modules.insert(chunkable_module);\n                             GraphTraversalAction::Skip\n-                        } else if available_info.is_some() {\n+                        } else if is_available {\n                             GraphTraversalAction::Skip\n                         } else {\n                             unsorted_chunkable_modules.insert(node.module, chunkable_module);"
        },
        {
            "sha": "cf79320de0974265bdb97718933db1786bb05587",
            "filename": "turbopack/crates/turbopack-core/src/chunk/mod.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 16,
            "changes": 20,
            "blob_url": "https://github.com/vercel/next.js/blob/3ecef51b8c761e52e7c24bbe5f554418d9657abb/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3ecef51b8c761e52e7c24bbe5f554418d9657abb/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fmod.rs?ref=3ecef51b8c761e52e7c24bbe5f554418d9657abb",
            "patch": "@@ -16,8 +16,8 @@ use auto_hash_map::AutoSet;\n use serde::{Deserialize, Serialize};\n use turbo_rcstr::RcStr;\n use turbo_tasks::{\n-    debug::ValueDebugFormat, trace::TraceRawVcs, FxIndexMap, FxIndexSet, NonLocalValue, ResolvedVc,\n-    TaskInput, Upcast, ValueToString, Vc,\n+    debug::ValueDebugFormat, trace::TraceRawVcs, FxIndexSet, NonLocalValue, ResolvedVc, TaskInput,\n+    Upcast, ValueToString, Vc,\n };\n use turbo_tasks_hash::DeterministicHash;\n \n@@ -202,24 +202,12 @@ pub trait ChunkableModuleReference: ModuleReference + ValueToString {\n     }\n }\n \n-type AsyncInfo =\n-    FxIndexMap<ResolvedVc<Box<dyn ChunkableModule>>, Vec<ResolvedVc<Box<dyn ChunkableModule>>>>;\n-\n #[derive(Default)]\n pub struct ChunkGroupContent {\n     pub chunkable_modules: FxIndexSet<ResolvedVc<Box<dyn ChunkableModule>>>,\n     pub async_modules: FxIndexSet<ResolvedVc<Box<dyn ChunkableModule>>>,\n     pub traced_modules: FxIndexSet<ResolvedVc<Box<dyn Module>>>,\n     pub passthrough_modules: FxIndexSet<ResolvedVc<Box<dyn ChunkableModule>>>,\n-    /// A map from local module to all children from which the async module\n-    /// status is inherited\n-    pub forward_edges_inherit_async: AsyncInfo,\n-    /// A map from local module to all parents that inherit the async module\n-    /// status\n-    pub local_back_edges_inherit_async: AsyncInfo,\n-    /// A map from already available async modules to all local parents that\n-    /// inherit the async module status\n-    pub available_async_modules_back_edges_inherit_async: AsyncInfo,\n }\n \n #[turbo_tasks::value_trait]\n@@ -281,14 +269,14 @@ pub struct ChunkItems(pub Vec<ResolvedVc<Box<dyn ChunkItem>>>);\n \n #[turbo_tasks::value]\n pub struct AsyncModuleInfo {\n-    pub referenced_async_modules: AutoSet<ResolvedVc<Box<dyn ChunkableModule>>>,\n+    pub referenced_async_modules: AutoSet<ResolvedVc<Box<dyn Module>>>,\n }\n \n #[turbo_tasks::value_impl]\n impl AsyncModuleInfo {\n     #[turbo_tasks::function]\n     pub async fn new(\n-        referenced_async_modules: Vec<ResolvedVc<Box<dyn ChunkableModule>>>,\n+        referenced_async_modules: Vec<ResolvedVc<Box<dyn Module>>>,\n     ) -> Result<Vc<Self>> {\n         Ok(Self {\n             referenced_async_modules: referenced_async_modules.into_iter().collect(),"
        },
        {
            "sha": "ba38a410c0d7e92a768c90c525525a9bf7841c4b",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/async_module_info.rs",
            "status": "added",
            "additions": 121,
            "deletions": 0,
            "changes": 121,
            "blob_url": "https://github.com/vercel/next.js/blob/3ecef51b8c761e52e7c24bbe5f554418d9657abb/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fasync_module_info.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3ecef51b8c761e52e7c24bbe5f554418d9657abb/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fasync_module_info.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fasync_module_info.rs?ref=3ecef51b8c761e52e7c24bbe5f554418d9657abb",
            "patch": "@@ -0,0 +1,121 @@\n+use anyhow::Result;\n+use rustc_hash::FxHashSet;\n+use turbo_tasks::{ResolvedVc, TryJoinIterExt, Vc};\n+\n+use crate::{\n+    chunk::ChunkingType,\n+    module::{Module, Modules},\n+    module_graph::{GraphTraversalAction, ModuleGraph, SingleModuleGraph},\n+};\n+\n+#[turbo_tasks::value(transparent)]\n+pub struct ModulesSet(FxHashSet<ResolvedVc<Box<dyn Module>>>);\n+\n+/// This lists all the modules that are async (self or transitively because they reference another\n+/// module in this list).\n+#[turbo_tasks::value(transparent)]\n+pub struct AsyncModulesInfo(FxHashSet<ResolvedVc<Box<dyn Module>>>);\n+\n+#[turbo_tasks::value_impl]\n+impl AsyncModulesInfo {\n+    #[turbo_tasks::function]\n+    pub fn is_async(&self, module: ResolvedVc<Box<dyn Module>>) -> Vc<bool> {\n+        Vc::cell(self.0.contains(&module))\n+    }\n+\n+    #[turbo_tasks::function]\n+    pub async fn is_async_multiple(&self, modules: ResolvedVc<Modules>) -> Result<Vc<ModulesSet>> {\n+        Ok(Vc::cell(\n+            modules\n+                .await?\n+                .iter()\n+                .copied()\n+                .filter(|m| self.0.contains(m))\n+                .collect(),\n+        ))\n+    }\n+}\n+\n+#[turbo_tasks::function(operation)]\n+pub async fn compute_async_module_info(\n+    graph: ResolvedVc<ModuleGraph>,\n+) -> Result<Vc<AsyncModulesInfo>> {\n+    // Layout segment optimization, we can individually compute the async modules for each graph.\n+    let mut result: Vc<AsyncModulesInfo> = Vc::cell(Default::default());\n+    for g in &graph.await?.graphs {\n+        result = compute_async_module_info_single(**g, result);\n+    }\n+    Ok(result)\n+}\n+\n+#[turbo_tasks::function]\n+async fn compute_async_module_info_single(\n+    graph: Vc<SingleModuleGraph>,\n+    parent_async_modules: Vc<AsyncModulesInfo>,\n+) -> Result<Vc<AsyncModulesInfo>> {\n+    let parent_async_modules = parent_async_modules.await?;\n+    let graph = graph.await?;\n+\n+    let self_async_modules = graph\n+        .iter_nodes()\n+        .map(async |node| Ok((node.module, *node.module.is_self_async().await?)))\n+        .try_join()\n+        .await?\n+        .into_iter()\n+        .flat_map(|(k, v)| v.then_some(k))\n+        .chain(parent_async_modules.iter().copied())\n+        .collect::<FxHashSet<_>>();\n+\n+    // To determine which modules are async, we need to propagate the self-async flag to all\n+    // importers, which is done using a postorder traversal of the graph.\n+    //\n+    // This however doesn't cover cycles of async modules, which are handled by determining all\n+    // strongly-connected components, and then marking all the whole SCC as async if one of the\n+    // modules in the SCC is async.\n+\n+    let mut async_modules = self_async_modules;\n+    graph.traverse_edges_from_entries_topological(\n+        graph.entries.iter(),\n+        &mut (),\n+        |_, _, _| Ok(GraphTraversalAction::Continue),\n+        |parent_info, module, _| {\n+            let Some((parent_module, chunking_type)) = parent_info else {\n+                // An entry module\n+                return;\n+            };\n+            let module = module.module();\n+            let parent_module = parent_module.module;\n+\n+            // edges.push((parent_module, module, async_modules.contains(&module)));\n+            match chunking_type {\n+                ChunkingType::ParallelInheritAsync => {\n+                    if async_modules.contains(&module) {\n+                        async_modules.insert(parent_module);\n+                    }\n+                }\n+                ChunkingType::Parallel\n+                | ChunkingType::Async\n+                | ChunkingType::Isolated { .. }\n+                | ChunkingType::Passthrough\n+                | ChunkingType::Traced => {\n+                    // Nothing to propagate\n+                }\n+            }\n+        },\n+    )?;\n+\n+    petgraph::algo::TarjanScc::new().run(&graph.graph.0, |scc| {\n+        // Only SCCs with more than one node are cycles\n+        if scc.len() > 1\n+            && scc\n+                .iter()\n+                .any(|idx| async_modules.contains(&graph.graph.node_weight(*idx).unwrap().module()))\n+        {\n+            for &idx in scc {\n+                async_modules.insert(graph.graph.node_weight(idx).unwrap().module());\n+            }\n+        }\n+    });\n+\n+    Ok(Vc::cell(async_modules))\n+}"
        },
        {
            "sha": "3a8164c45f665ba5b431b5fd1b669d1135a82381",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/mod.rs",
            "status": "modified",
            "additions": 110,
            "deletions": 35,
            "changes": 145,
            "blob_url": "https://github.com/vercel/next.js/blob/3ecef51b8c761e52e7c24bbe5f554418d9657abb/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3ecef51b8c761e52e7c24bbe5f554418d9657abb/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs?ref=3ecef51b8c761e52e7c24bbe5f554418d9657abb",
            "patch": "@@ -17,17 +17,22 @@ use turbo_tasks::{\n     debug::ValueDebugFormat,\n     graph::{AdjacencyMap, GraphTraversal, Visit, VisitControlFlow},\n     trace::{TraceRawVcs, TraceRawVcsContext},\n-    FxIndexMap, NonLocalValue, ReadRef, ResolvedVc, TryJoinIterExt, ValueToString, Vc,\n+    CollectiblesSource, FxIndexMap, NonLocalValue, ReadRef, ResolvedVc, TryJoinIterExt,\n+    ValueToString, Vc,\n };\n \n use crate::{\n-    chunk::ChunkingType,\n+    chunk::{AsyncModuleInfo, ChunkingType},\n     issue::Issue,\n     module::{Module, Modules},\n-    module_graph::chunk_group_info::{compute_chunk_group_info, ChunkGroupInfo},\n+    module_graph::{\n+        async_module_info::{compute_async_module_info, AsyncModulesInfo},\n+        chunk_group_info::{compute_chunk_group_info, ChunkGroupInfo},\n+    },\n     reference::primary_chunkable_referenced_modules,\n };\n \n+pub mod async_module_info;\n pub mod chunk_group_info;\n \n #[derive(\n@@ -241,7 +246,8 @@ impl SingleModuleGraph {\n                         let current_idx = if let Some(current_idx) = modules.get(&module) {\n                             *current_idx\n                         } else {\n-                            let idx = graph.add_node(SingleModuleGraphNode::VisitedModule { idx });\n+                            let idx = graph\n+                                .add_node(SingleModuleGraphNode::VisitedModule { idx, module });\n                             modules.insert(module, idx);\n                             idx\n                         };\n@@ -263,7 +269,10 @@ impl SingleModuleGraph {\n                         } else {\n                             let target_idx = visited_modules.get(&target);\n                             let idx = graph.add_node(match target_idx {\n-                                Some(idx) => SingleModuleGraphNode::VisitedModule { idx: *idx },\n+                                Some(idx) => SingleModuleGraphNode::VisitedModule {\n+                                    idx: *idx,\n+                                    module: target,\n+                                },\n                                 None => {\n                                     SingleModuleGraphNode::Module(SingleModuleGraphModuleNode {\n                                         module: target,\n@@ -488,12 +497,12 @@ impl SingleModuleGraph {\n         state: &mut S,\n         mut visit_preorder: impl FnMut(\n             Option<(&'a SingleModuleGraphModuleNode, &'a ChunkingType)>,\n-            &'a SingleModuleGraphModuleNode,\n+            &'a SingleModuleGraphNode,\n             &mut S,\n         ) -> Result<GraphTraversalAction>,\n         mut visit_postorder: impl FnMut(\n             Option<(&'a SingleModuleGraphModuleNode, &'a ChunkingType)>,\n-            &'a SingleModuleGraphModuleNode,\n+            &'a SingleModuleGraphNode,\n             &mut S,\n         ),\n     ) -> Result<()> {\n@@ -528,26 +537,29 @@ impl SingleModuleGraph {\n             });\n             match pass {\n                 ReverseTopologicalPass::Visit => {\n-                    if let SingleModuleGraphNode::Module(current_node) =\n-                        graph.node_weight(current).unwrap()\n-                    {\n-                        visit_postorder(parent_arg, current_node, state);\n-                    }\n+                    visit_postorder(parent_arg, graph.node_weight(current).unwrap(), state);\n                 }\n                 ReverseTopologicalPass::ExpandAndVisit => {\n-                    if let SingleModuleGraphNode::Module(current_node) =\n-                        graph.node_weight(current).unwrap()\n-                    {\n-                        let action = visit_preorder(parent_arg, current_node, state);\n-                        stack.push((ReverseTopologicalPass::Visit, parent, current));\n-                        if action? == GraphTraversalAction::Continue && expanded.insert(current) {\n-                            stack.extend(iter_neighbors(graph, current).map(|(edge, child)| {\n-                                (\n-                                    ReverseTopologicalPass::ExpandAndVisit,\n-                                    Some((current, edge)),\n-                                    child,\n-                                )\n-                            }));\n+                    match graph.node_weight(current).unwrap() {\n+                        current_node @ SingleModuleGraphNode::Module(_) => {\n+                            let action = visit_preorder(parent_arg, current_node, state);\n+                            stack.push((ReverseTopologicalPass::Visit, parent, current));\n+                            if action? == GraphTraversalAction::Continue && expanded.insert(current)\n+                            {\n+                                stack.extend(iter_neighbors(graph, current).map(\n+                                    |(edge, child)| {\n+                                        (\n+                                            ReverseTopologicalPass::ExpandAndVisit,\n+                                            Some((current, edge)),\n+                                            child,\n+                                        )\n+                                    },\n+                                ));\n+                            }\n+                        }\n+                        current_node @ SingleModuleGraphNode::VisitedModule { .. } => {\n+                            visit_preorder(parent_arg, current_node, state)?;\n+                            visit_postorder(parent_arg, current_node, state);\n                         }\n                     }\n                 }\n@@ -595,6 +607,52 @@ impl ModuleGraph {\n             .instrument(tracing::info_span!(\"compute_chunk_group_info\"))\n             .await\n     }\n+\n+    #[turbo_tasks::function]\n+    pub async fn async_module_info(self: Vc<Self>) -> Result<Vc<AsyncModulesInfo>> {\n+        // `compute_async_module_info` calls `module.is_self_async()`, so we need to again ignore\n+        // all issues such that they aren't emitted multiple times.\n+        async move {\n+            let result_op = compute_async_module_info(self.to_resolved().await?);\n+            let result_vc = result_op.resolve_strongly_consistent().await?;\n+            let _issues = result_op.take_collectibles::<Box<dyn Issue>>();\n+            anyhow::Ok(*result_vc)\n+        }\n+        .instrument(tracing::info_span!(\"compute_async_module_info\"))\n+        .await\n+    }\n+\n+    #[turbo_tasks::function]\n+    pub async fn referenced_async_modules(\n+        self: Vc<Self>,\n+        module: ResolvedVc<Box<dyn Module>>,\n+    ) -> Result<Vc<AsyncModuleInfo>> {\n+        let this = self.await?;\n+        let graphs = this.get_graphs().await?;\n+        let async_modules_info = self.async_module_info().await?;\n+\n+        let entry = ModuleGraph::get_entry(&graphs, module).await?;\n+        let referenced_modules = iter_neighbors(&graphs[entry.graph_idx].graph, entry.node_idx)\n+            .map(|(_, child_idx)| {\n+                anyhow::Ok(\n+                    get_node!(\n+                        graphs,\n+                        GraphNodeIndex {\n+                            graph_idx: entry.graph_idx,\n+                            node_idx: child_idx\n+                        }\n+                    )?\n+                    .module,\n+                )\n+            })\n+            .collect::<Result<Vec<_>>>()?\n+            .into_iter()\n+            .filter(|m| async_modules_info.contains(m))\n+            .map(|m| *m)\n+            .collect();\n+\n+        Ok(AsyncModuleInfo::new(referenced_modules))\n+    }\n }\n \n // fn get_node<T>(\n@@ -609,7 +667,7 @@ macro_rules! get_node {\n             .node_weight(node_idx.node_idx)\n         {\n             Some(SingleModuleGraphNode::Module(node)) => ::anyhow::Ok(node),\n-            Some(SingleModuleGraphNode::VisitedModule { idx }) => {\n+            Some(SingleModuleGraphNode::VisitedModule { idx, .. }) => {\n                 match $graphs[idx.graph_idx].graph.node_weight(idx.node_idx) {\n                     Some(SingleModuleGraphNode::Module(node)) => anyhow::Ok(node),\n                     Some(SingleModuleGraphNode::VisitedModule { .. }) => Err(::anyhow::anyhow!(\n@@ -624,8 +682,18 @@ macro_rules! get_node {\n }\n pub(crate) use get_node;\n \n+// pub struct AllNodesIterator {\n+//     inner: Vec<ReadRef<SingleModuleGraph>>,\n+// }\n+// impl<'a> Iterator for &'a AllNodesIterator {\n+//     type Item = &'a SingleModuleGraphModuleNode;\n+//     fn next(&mut self) -> Option<Self::Item> {\n+//         self.inner.iter().flat_map(|g| g.iter_nodes()).next()\n+//     }\n+// }\n+\n impl ModuleGraph {\n-    async fn get_graphs(&self) -> Result<Vec<ReadRef<SingleModuleGraph>>> {\n+    pub async fn get_graphs(&self) -> Result<Vec<ReadRef<SingleModuleGraph>>> {\n         self.graphs.iter().try_join().await\n     }\n \n@@ -653,6 +721,12 @@ impl ModuleGraph {\n         Ok(idx)\n     }\n \n+    // Iterate over all nodes in the graph\n+    // pub async fn iter_nodes(&self) -> Result<AllNodesIterator> {\n+    // let graphs = self.get_graphs().await?;\n+    // Ok(AllNodesIterator { inner: graphs })\n+    // }\n+\n     /// Traverses all reachable edges exactly once and calls the visitor with the edge source and\n     /// target.\n     ///\n@@ -785,7 +859,7 @@ impl ModuleGraph {\n                 };\n                 let target = match graph.node_weight(edge.target()).unwrap() {\n                     SingleModuleGraphNode::Module(node) => node,\n-                    SingleModuleGraphNode::VisitedModule { idx } => get_node!(graphs, idx)?,\n+                    SingleModuleGraphNode::VisitedModule { idx, .. } => get_node!(graphs, idx)?,\n                 };\n                 visitor((source, edge.weight()), target)?;\n             }\n@@ -875,7 +949,7 @@ impl ModuleGraph {\n                                 SingleModuleGraphNode::Module(_) => {\n                                     (iter_neighbors(graph, current.node_idx), current)\n                                 }\n-                                SingleModuleGraphNode::VisitedModule { idx } => (\n+                                SingleModuleGraphNode::VisitedModule { idx, .. } => (\n                                     // We switch graphs\n                                     iter_neighbors(&graphs[idx.graph_idx].graph, idx.node_idx),\n                                     *idx,\n@@ -927,16 +1001,17 @@ pub struct SingleModuleGraphModuleNode {\n #[derive(Clone, Debug, Serialize, Deserialize, TraceRawVcs, NonLocalValue)]\n pub enum SingleModuleGraphNode {\n     Module(SingleModuleGraphModuleNode),\n-    VisitedModule { idx: GraphNodeIndex },\n+    VisitedModule {\n+        idx: GraphNodeIndex,\n+        module: ResolvedVc<Box<dyn Module>>,\n+    },\n }\n \n impl SingleModuleGraphNode {\n-    pub fn module(&self) -> Option<ResolvedVc<Box<dyn Module>>> {\n+    pub fn module(&self) -> ResolvedVc<Box<dyn Module>> {\n         match self {\n-            SingleModuleGraphNode::Module(SingleModuleGraphModuleNode { module, .. }) => {\n-                Some(*module)\n-            }\n-            SingleModuleGraphNode::VisitedModule { .. } => None,\n+            SingleModuleGraphNode::Module(SingleModuleGraphModuleNode { module, .. }) => *module,\n+            SingleModuleGraphNode::VisitedModule { module, .. } => *module,\n         }\n     }\n "
        },
        {
            "sha": "c9d6ba47b9c58d92a2d654ca60317207ffba5aeb",
            "filename": "turbopack/crates/turbopack-ecmascript/src/async_chunk/chunk_item.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/3ecef51b8c761e52e7c24bbe5f554418d9657abb/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fasync_chunk%2Fchunk_item.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3ecef51b8c761e52e7c24bbe5f554418d9657abb/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fasync_chunk%2Fchunk_item.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fasync_chunk%2Fchunk_item.rs?ref=3ecef51b8c761e52e7c24bbe5f554418d9657abb",
            "patch": "@@ -36,7 +36,7 @@ impl AsyncLoaderChunkItem {\n     pub(super) async fn chunks(&self) -> Result<Vc<OutputAssets>> {\n         let module = self.module.await?;\n         if let Some(chunk_items) = module.availability_info.available_modules() {\n-            if chunk_items.get(*module.inner).await?.is_some() {\n+            if *chunk_items.get(*module.inner).await? {\n                 return Ok(Vc::cell(vec![]));\n             }\n         }"
        },
        {
            "sha": "a99961d2075754a1b2eb047054a86c6f3aab6ebb",
            "filename": "turbopack/crates/turbopack-ecmascript/src/manifest/chunk_asset.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/3ecef51b8c761e52e7c24bbe5f554418d9657abb/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fmanifest%2Fchunk_asset.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3ecef51b8c761e52e7c24bbe5f554418d9657abb/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fmanifest%2Fchunk_asset.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fmanifest%2Fchunk_asset.rs?ref=3ecef51b8c761e52e7c24bbe5f554418d9657abb",
            "patch": "@@ -70,7 +70,7 @@ impl ManifestAsyncModule {\n     pub async fn manifest_chunks(self: Vc<Self>) -> Result<Vc<OutputAssets>> {\n         let this = self.await?;\n         if let Some(chunk_items) = this.availability_info.available_modules() {\n-            if chunk_items.get(*this.inner).await?.is_some() {\n+            if *chunk_items.get(*this.inner).await? {\n                 return Ok(Vc::cell(vec![]));\n             }\n         }"
        },
        {
            "sha": "578a4ff4a39deacf75b4933991f7618827134242",
            "filename": "turbopack/crates/turbopack-tests/tests/execution/turbopack/async-modules/cycle/input/a-sync.js",
            "status": "added",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/3ecef51b8c761e52e7c24bbe5f554418d9657abb/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fasync-modules%2Fcycle%2Finput%2Fa-sync.js",
            "raw_url": "https://github.com/vercel/next.js/raw/3ecef51b8c761e52e7c24bbe5f554418d9657abb/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fasync-modules%2Fcycle%2Finput%2Fa-sync.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fasync-modules%2Fcycle%2Finput%2Fa-sync.js?ref=3ecef51b8c761e52e7c24bbe5f554418d9657abb",
            "patch": "@@ -0,0 +1,6 @@\n+export { b } from './b-sync.js'\n+import { dep } from './dep-async.js'\n+\n+export function a() {\n+  return 'a' + dep()\n+}"
        },
        {
            "sha": "981c2aa91bcd98062e5e9355e3bafe65a78cb7dc",
            "filename": "turbopack/crates/turbopack-tests/tests/execution/turbopack/async-modules/cycle/input/b-sync.js",
            "status": "added",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/3ecef51b8c761e52e7c24bbe5f554418d9657abb/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fasync-modules%2Fcycle%2Finput%2Fb-sync.js",
            "raw_url": "https://github.com/vercel/next.js/raw/3ecef51b8c761e52e7c24bbe5f554418d9657abb/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fasync-modules%2Fcycle%2Finput%2Fb-sync.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fasync-modules%2Fcycle%2Finput%2Fb-sync.js?ref=3ecef51b8c761e52e7c24bbe5f554418d9657abb",
            "patch": "@@ -0,0 +1,5 @@\n+import {c} from './c-sync.js'\n+\n+export function b() {\n+  return 'b' + c()\n+}"
        },
        {
            "sha": "0f7c22da69f8cd3e075529d78d7892e40462d58d",
            "filename": "turbopack/crates/turbopack-tests/tests/execution/turbopack/async-modules/cycle/input/c-sync.js",
            "status": "added",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/3ecef51b8c761e52e7c24bbe5f554418d9657abb/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fasync-modules%2Fcycle%2Finput%2Fc-sync.js",
            "raw_url": "https://github.com/vercel/next.js/raw/3ecef51b8c761e52e7c24bbe5f554418d9657abb/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fasync-modules%2Fcycle%2Finput%2Fc-sync.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fasync-modules%2Fcycle%2Finput%2Fc-sync.js?ref=3ecef51b8c761e52e7c24bbe5f554418d9657abb",
            "patch": "@@ -0,0 +1,5 @@\n+import {a} from './a-sync.js'\n+\n+export function c() {\n+  return 'c' + a()\n+}"
        },
        {
            "sha": "8d9c30399ba88f9f1c869198a130e1cdf36aad6d",
            "filename": "turbopack/crates/turbopack-tests/tests/execution/turbopack/async-modules/cycle/input/dep-async.js",
            "status": "added",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/3ecef51b8c761e52e7c24bbe5f554418d9657abb/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fasync-modules%2Fcycle%2Finput%2Fdep-async.js",
            "raw_url": "https://github.com/vercel/next.js/raw/3ecef51b8c761e52e7c24bbe5f554418d9657abb/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fasync-modules%2Fcycle%2Finput%2Fdep-async.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fasync-modules%2Fcycle%2Finput%2Fdep-async.js?ref=3ecef51b8c761e52e7c24bbe5f554418d9657abb",
            "patch": "@@ -0,0 +1,5 @@\n+await 0\n+\n+export function dep() {\n+  return 'dep'\n+}"
        },
        {
            "sha": "27653d04870d39ecf662d8b402b9b951377a954a",
            "filename": "turbopack/crates/turbopack-tests/tests/execution/turbopack/async-modules/cycle/input/index.js",
            "status": "added",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/3ecef51b8c761e52e7c24bbe5f554418d9657abb/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fasync-modules%2Fcycle%2Finput%2Findex.js",
            "raw_url": "https://github.com/vercel/next.js/raw/3ecef51b8c761e52e7c24bbe5f554418d9657abb/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fasync-modules%2Fcycle%2Finput%2Findex.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fasync-modules%2Fcycle%2Finput%2Findex.js?ref=3ecef51b8c761e52e7c24bbe5f554418d9657abb",
            "patch": "@@ -0,0 +1,9 @@\n+import { a, b } from './a-sync.js'\n+\n+// index.js --> a-sync.js -> b-sync.js -> c-sync.js (-> back to a-sync.js)\n+//          \\-> dep-async.js\n+\n+it('should handle export all from cjs modules in modules with top level await', async () => {\n+  expect(a()).toBe('adep')\n+  expect(b()).toBe('bcadep')\n+})"
        }
    ],
    "stats": {
        "total": 1163,
        "additions": 565,
        "deletions": 598
    }
}