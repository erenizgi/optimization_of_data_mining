{
    "author": "ijjk",
    "message": "Remove extra base-server code (#81944)",
    "sha": "955adbb05778e732c3d43c5afc5880c18feaaeb2",
    "files": [
        {
            "sha": "bde747c230859fe9b02d679722c56f8e281e3829",
            "filename": "packages/next/next-runtime.webpack-config.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/955adbb05778e732c3d43c5afc5880c18feaaeb2/packages%2Fnext%2Fnext-runtime.webpack-config.js",
            "raw_url": "https://github.com/vercel/next.js/raw/955adbb05778e732c3d43c5afc5880c18feaaeb2/packages%2Fnext%2Fnext-runtime.webpack-config.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fnext-runtime.webpack-config.js?ref=955adbb05778e732c3d43c5afc5880c18feaaeb2",
            "patch": "@@ -139,7 +139,7 @@ module.exports = ({ dev, turbo, bundleType, experimental, ...rest }) => {\n         return\n       }\n \n-      if (request.endsWith('.external')) {\n+      if (request.match(/\\.external(\\.js)?$/)) {\n         const resolve = getResolve()\n         const resolved = await resolve(context, request)\n         const relative = path.relative("
        },
        {
            "sha": "072f03d3fec365ecea9f67947f97ed7d9c606772",
            "filename": "packages/next/src/build/define-env.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 9,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/955adbb05778e732c3d43c5afc5880c18feaaeb2/packages%2Fnext%2Fsrc%2Fbuild%2Fdefine-env.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/955adbb05778e732c3d43c5afc5880c18feaaeb2/packages%2Fnext%2Fsrc%2Fbuild%2Fdefine-env.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fdefine-env.ts?ref=955adbb05778e732c3d43c5afc5880c18feaaeb2",
            "patch": "@@ -294,15 +294,12 @@ export function getDefineEnv({\n         }\n       : undefined),\n \n-    'process.env.__NEXT_MULTI_ZONE_DRAFT_MODE': JSON.stringify(\n-      config.experimental.multiZoneDraftMode\n-    ),\n-    'process.env.__NEXT_TRUST_HOST_HEADER': JSON.stringify(\n-      config.experimental.trustHostHeader\n-    ),\n-    'process.env.__NEXT_ALLOWED_REVALIDATE_HEADERS': JSON.stringify(\n-      config.experimental.allowedRevalidateHeaderKeys\n-    ),\n+    'process.env.__NEXT_MULTI_ZONE_DRAFT_MODE':\n+      config.experimental.multiZoneDraftMode ?? false,\n+    'process.env.__NEXT_TRUST_HOST_HEADER':\n+      config.experimental.trustHostHeader ?? false,\n+    'process.env.__NEXT_ALLOWED_REVALIDATE_HEADERS':\n+      config.experimental.allowedRevalidateHeaderKeys ?? [],\n     ...(isNodeServer\n       ? {\n           'process.env.__NEXT_RELATIVE_DIST_DIR': config.distDir,"
        },
        {
            "sha": "70568be634f4375ca4abb56d0e7c804ca2d98e3f",
            "filename": "packages/next/src/build/templates/app-page.ts",
            "status": "modified",
            "additions": 29,
            "deletions": 2,
            "changes": 31,
            "blob_url": "https://github.com/vercel/next.js/blob/955adbb05778e732c3d43c5afc5880c18feaaeb2/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fapp-page.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/955adbb05778e732c3d43c5afc5880c18feaaeb2/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fapp-page.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fapp-page.ts?ref=955adbb05778e732c3d43c5afc5880c18feaaeb2",
            "patch": "@@ -13,6 +13,7 @@ import { getTracer, SpanKind, type Span } from '../../server/lib/trace/tracer'\n import { getRequestMeta } from '../../server/request-meta'\n import { BaseServerSpan } from '../../server/lib/trace/constants'\n import { interopDefault } from '../../server/app-render/interop-default'\n+import { stripFlightHeaders } from '../../server/app-render/strip-flight-headers'\n import { NodeNextRequest, NodeNextResponse } from '../../server/base-http/node'\n import { checkIsAppPPREnabled } from '../../server/lib/experimental/ppr'\n import {\n@@ -106,7 +107,7 @@ export const routeModule = new AppPageRouteModule({\n     loaderTree: tree,\n   },\n   distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n-  projectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n+  relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n })\n \n export async function handler(\n@@ -164,6 +165,7 @@ export async function handler(\n     revalidateOnlyGenerated,\n     routerServerContext,\n     nextConfig,\n+    interceptionRoutePatterns,\n   } = prepareResult\n \n   const pathname = parsedUrl.pathname || '/'\n@@ -314,6 +316,19 @@ export async function handler(\n     staticPathKey = resolvedPathname\n   }\n \n+  // If this is a request for an app path that should be statically generated\n+  // and we aren't in the edge runtime, strip the flight headers so it will\n+  // generate the static response.\n+  if (\n+    !routeModule.isDev &&\n+    !isDraftMode &&\n+    isSSG &&\n+    isRSCRequest &&\n+    !isDynamicRSCRequest\n+  ) {\n+    stripFlightHeaders(req.headers)\n+  }\n+\n   const ComponentMod = {\n     ...entryBase,\n     tree,\n@@ -343,6 +358,11 @@ export async function handler(\n   const activeSpan = tracer.getActiveScopeSpan()\n \n   try {\n+    const varyHeader = routeModule.getVaryHeader(\n+      resolvedPathname,\n+      interceptionRoutePatterns\n+    )\n+    res.setHeader('Vary', varyHeader)\n     const invokeRouteModule = async (\n       span: Span | undefined,\n       context: AppPageRouteHandlerContext\n@@ -464,7 +484,14 @@ export async function handler(\n           clientReferenceManifest,\n           setIsrStatus: routerServerContext?.setIsrStatus,\n \n-          dir: routeModule.projectDir,\n+          dir:\n+            process.env.NEXT_RUNTIME === 'nodejs'\n+              ? (require('path') as typeof import('path')).join(\n+                  /* turbopackIgnore: true */\n+                  process.cwd(),\n+                  routeModule.relativeProjectDir\n+                )\n+              : `${process.cwd()}/${routeModule.relativeProjectDir}`,\n           isDraftMode,\n           isRevalidate: isSSG && !postponed && !isDynamicRSCRequest,\n           botType,"
        },
        {
            "sha": "a3ccf4b88f0b93bc1ed9087ca19f793313ac0236",
            "filename": "packages/next/src/build/templates/app-route.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/955adbb05778e732c3d43c5afc5880c18feaaeb2/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fapp-route.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/955adbb05778e732c3d43c5afc5880c18feaaeb2/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fapp-route.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fapp-route.ts?ref=955adbb05778e732c3d43c5afc5880c18feaaeb2",
            "patch": "@@ -50,7 +50,7 @@ const routeModule = new AppRouteRouteModule({\n     bundlePath: 'VAR_DEFINITION_BUNDLE_PATH',\n   },\n   distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n-  projectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n+  relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n   resolvedPagePath: 'VAR_RESOLVED_PAGE_PATH',\n   nextConfigOutput,\n   userland,"
        },
        {
            "sha": "df2f2e729128b45e4bacb300dfd8fec7078b45d1",
            "filename": "packages/next/src/build/templates/edge-ssr-app.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/955adbb05778e732c3d43c5afc5880c18feaaeb2/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fedge-ssr-app.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/955adbb05778e732c3d43c5afc5880c18feaaeb2/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fedge-ssr-app.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fedge-ssr-app.ts?ref=955adbb05778e732c3d43c5afc5880c18feaaeb2",
            "patch": "@@ -135,7 +135,7 @@ async function requestHandler(\n       clientReferenceManifest,\n       setIsrStatus: routerServerContext?.setIsrStatus,\n \n-      dir: pageRouteModule.projectDir,\n+      dir: pageRouteModule.relativeProjectDir,\n       botType,\n       isDraftMode: false,\n       isRevalidate: false,"
        },
        {
            "sha": "95cba63ce88bc070b6f024148e2e04ef1e4399fd",
            "filename": "packages/next/src/build/templates/pages-api.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 3,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/955adbb05778e732c3d43c5afc5880c18feaaeb2/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fpages-api.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/955adbb05778e732c3d43c5afc5880c18feaaeb2/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fpages-api.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fpages-api.ts?ref=955adbb05778e732c3d43c5afc5880c18feaaeb2",
            "patch": "@@ -32,7 +32,7 @@ const routeModule = new PagesAPIRouteModule({\n   },\n   userland,\n   distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n-  projectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n+  relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n })\n \n export async function handler(\n@@ -60,7 +60,8 @@ export async function handler(\n     return\n   }\n \n-  const { query, params, prerenderManifest } = prepareResult\n+  const { query, params, prerenderManifest, routerServerContext } =\n+    prepareResult\n \n   try {\n     const method = req.method || 'GET'\n@@ -89,7 +90,8 @@ export async function handler(\n           propagateError: false,\n           dev: routeModule.isDev,\n           page: 'VAR_DEFINITION_PAGE',\n-          projectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n+\n+          internalRevalidate: routerServerContext?.revalidate,\n \n           onError: (...args: Parameters<InstrumentationOnRequestError>) =>\n             onRequestError(req, ...args),"
        },
        {
            "sha": "a1d6130ea7e28703fdc5b633d3cccd55c5271952",
            "filename": "packages/next/src/build/templates/pages.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 724,
            "changes": 735,
            "blob_url": "https://github.com/vercel/next.js/blob/955adbb05778e732c3d43c5afc5880c18feaaeb2/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fpages.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/955adbb05778e732c3d43c5afc5880c18feaaeb2/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fpages.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fpages.ts?ref=955adbb05778e732c3d43c5afc5880c18feaaeb2",
            "patch": "@@ -1,21 +1,5 @@\n-import type { IncomingMessage, ServerResponse } from 'node:http'\n-import type { ParsedUrlQuery } from 'node:querystring'\n import { PagesRouteModule } from '../../server/route-modules/pages/module.compiled'\n import { RouteKind } from '../../server/route-kind'\n-import { BaseServerSpan } from '../../server/lib/trace/constants'\n-import { getTracer, SpanKind, type Span } from '../../server/lib/trace/tracer'\n-import { formatUrl } from '../../shared/lib/router/utils/format-url'\n-import { addRequestMeta, getRequestMeta } from '../../server/request-meta'\n-import { interopDefault } from '../../server/app-render/interop-default'\n-import { getRevalidateReason } from '../../server/instrumentation/utils'\n-import { normalizeDataPath } from '../../shared/lib/page-path/normalize-data-path'\n-import {\n-  CachedRouteKind,\n-  type CachedPageValue,\n-  type CachedRedirectValue,\n-  type ResponseCacheEntry,\n-  type ResponseGenerator,\n-} from '../../server/response-cache'\n \n import { hoist } from './helpers'\n \n@@ -25,25 +9,7 @@ import * as app from 'VAR_MODULE_APP'\n \n // Import the userland code.\n import * as userland from 'VAR_USERLAND'\n-import {\n-  getCacheControlHeader,\n-  type CacheControl,\n-} from '../../server/lib/cache-control'\n-import { normalizeRepeatedSlashes } from '../../shared/lib/utils'\n-import { getRedirectStatus } from '../../lib/redirect-status'\n-import {\n-  CACHE_ONE_YEAR,\n-  HTML_CONTENT_TYPE_HEADER,\n-  JSON_CONTENT_TYPE_HEADER,\n-} from '../../lib/constants'\n-import { sendRenderResult } from '../../server/send-payload'\n-import RenderResult from '../../server/render-result'\n-import { toResponseCacheEntry } from '../../server/response-cache/utils'\n-import { NoFallbackError } from '../../shared/lib/no-fallback-error.external'\n-import { RedirectStatusCode } from '../../client/components/redirect-status-code'\n-import { isBot } from '../../shared/lib/router/utils/is-bot'\n-import { addPathPrefix } from '../../shared/lib/router/utils/add-path-prefix'\n-import { removeTrailingSlash } from '../../shared/lib/router/utils/remove-trailing-slash'\n+import { getHandler } from '../../server/route-modules/pages/pages-handler'\n \n // Re-export the component (should be the default export).\n export default hoist(userland, 'default')\n@@ -88,7 +54,7 @@ export const routeModule = new PagesRouteModule({\n     filename: '',\n   },\n   distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n-  projectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n+  relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n   components: {\n     // default export might not exist when optimized for data only\n     App: app.default,\n@@ -97,691 +63,12 @@ export const routeModule = new PagesRouteModule({\n   userland,\n })\n \n-export async function handler(\n-  req: IncomingMessage,\n-  res: ServerResponse,\n-  ctx: {\n-    waitUntil: (prom: Promise<void>) => void\n-  }\n-): Promise<void> {\n-  let srcPage = 'VAR_DEFINITION_PAGE'\n-\n-  // turbopack doesn't normalize `/index` in the page name\n-  // so we need to to process dynamic routes properly\n-  // TODO: fix turbopack providing differing value from webpack\n-  if (process.env.TURBOPACK) {\n-    srcPage = srcPage.replace(/\\/index$/, '') || '/'\n-  } else if (srcPage === '/index') {\n-    // we always normalize /index specifically\n-    srcPage = '/'\n-  }\n-  const multiZoneDraftMode = process.env\n-    .__NEXT_MULTI_ZONE_DRAFT_MODE as any as boolean\n-\n-  const prepareResult = await routeModule.prepare(req, res, {\n-    srcPage,\n-    multiZoneDraftMode,\n-  })\n-\n-  if (!prepareResult) {\n-    res.statusCode = 400\n-    res.end('Bad Request')\n-    ctx.waitUntil?.(Promise.resolve())\n-    return\n-  }\n-\n-  const {\n-    buildId,\n-    query,\n-    params,\n-    parsedUrl,\n-    originalQuery,\n-    originalPathname,\n-    buildManifest,\n-    nextFontManifest,\n-    serverFilesManifest,\n-    reactLoadableManifest,\n-    prerenderManifest,\n-    isDraftMode,\n-    isOnDemandRevalidate,\n-    revalidateOnlyGenerated,\n-    locale,\n-    locales,\n-    defaultLocale,\n-    routerServerContext,\n-    nextConfig,\n-    resolvedPathname,\n-  } = prepareResult\n-\n-  const isExperimentalCompile =\n-    serverFilesManifest?.config?.experimental?.isExperimentalCompile\n-\n-  const hasServerProps = Boolean(getServerSideProps)\n-  const hasStaticProps = Boolean(getStaticProps)\n-  const hasStaticPaths = Boolean(getStaticPaths)\n-  const hasGetInitialProps = Boolean(\n-    (userland.default || userland).getInitialProps\n-  )\n-  const isAmp = query.amp && config.amp\n-  let cacheKey: null | string = null\n-  let isIsrFallback = false\n-  let isNextDataRequest =\n-    prepareResult.isNextDataRequest && (hasStaticProps || hasServerProps)\n-\n-  const is404Page = srcPage === '/404'\n-  const is500Page = srcPage === '/500'\n-  const isErrorPage = srcPage === '/_error'\n-\n-  if (!routeModule.isDev && !isDraftMode && hasStaticProps) {\n-    cacheKey = `${locale ? `/${locale}` : ''}${\n-      (srcPage === '/' || resolvedPathname === '/') && locale\n-        ? ''\n-        : resolvedPathname\n-    }${isAmp ? '.amp' : ''}`\n-\n-    if (is404Page || is500Page || isErrorPage) {\n-      cacheKey = `${locale ? `/${locale}` : ''}${srcPage}${isAmp ? '.amp' : ''}`\n-    }\n-\n-    // ensure /index and / is normalized to one key\n-    cacheKey = cacheKey === '/index' ? '/' : cacheKey\n-  }\n-\n-  if (hasStaticPaths && !isDraftMode) {\n-    const decodedPathname = removeTrailingSlash(\n-      locale ? addPathPrefix(resolvedPathname, `/${locale}`) : resolvedPathname\n-    )\n-    const isPrerendered =\n-      Boolean(prerenderManifest.routes[decodedPathname]) ||\n-      prerenderManifest.notFoundRoutes.includes(decodedPathname)\n-\n-    const prerenderInfo = prerenderManifest.dynamicRoutes[srcPage]\n-\n-    if (prerenderInfo) {\n-      if (prerenderInfo.fallback === false && !isPrerendered) {\n-        throw new NoFallbackError()\n-      }\n-\n-      if (\n-        typeof prerenderInfo.fallback === 'string' &&\n-        !isPrerendered &&\n-        !isNextDataRequest\n-      ) {\n-        isIsrFallback = true\n-      }\n-    }\n-  }\n-\n-  // When serving a bot request, we want to serve a blocking render and not\n-  // the prerendered page. This ensures that the correct content is served\n-  // to the bot in the head.\n-  if (\n-    (isIsrFallback && isBot(req.headers['user-agent'] || '')) ||\n-    getRequestMeta(req, 'minimalMode')\n-  ) {\n-    isIsrFallback = false\n-  }\n-\n-  const tracer = getTracer()\n-  const activeSpan = tracer.getActiveScopeSpan()\n-\n-  try {\n-    const method = req.method || 'GET'\n-\n-    const resolvedUrl = formatUrl({\n-      pathname: nextConfig.trailingSlash\n-        ? parsedUrl.pathname\n-        : removeTrailingSlash(parsedUrl.pathname || '/'),\n-      // make sure to only add query values from original URL\n-      query: hasStaticProps ? {} : originalQuery,\n-    })\n-\n-    const publicRuntimeConfig: Record<string, string> =\n-      routerServerContext?.publicRuntimeConfig || nextConfig.publicRuntimeConfig\n-\n-    const handleResponse = async (span?: Span) => {\n-      const responseGenerator: ResponseGenerator = async ({\n-        previousCacheEntry,\n-      }) => {\n-        const doRender = async () => {\n-          try {\n-            return await routeModule\n-              .render(req, res, {\n-                query:\n-                  hasStaticProps && !isExperimentalCompile\n-                    ? ({\n-                        ...params,\n-                        ...(isAmp\n-                          ? {\n-                              amp: query.amp,\n-                            }\n-                          : {}),\n-                      } as ParsedUrlQuery)\n-                    : {\n-                        ...query,\n-                        ...params,\n-                      },\n-                params,\n-                page: srcPage,\n-                renderContext: {\n-                  isDraftMode,\n-                  isFallback: isIsrFallback,\n-                  developmentNotFoundSourcePage: getRequestMeta(\n-                    req,\n-                    'developmentNotFoundSourcePage'\n-                  ),\n-                },\n-                sharedContext: {\n-                  buildId,\n-                  customServer:\n-                    Boolean(routerServerContext?.isCustomServer) || undefined,\n-                  deploymentId: process.env.NEXT_DEPLOYMENT_ID,\n-                },\n-                renderOpts: {\n-                  params,\n-                  routeModule,\n-                  page: srcPage,\n-                  pageConfig: config || {},\n-                  Component: interopDefault(userland),\n-                  ComponentMod: userland,\n-                  getStaticProps,\n-                  getStaticPaths,\n-                  getServerSideProps,\n-                  supportsDynamicResponse: !hasStaticProps,\n-                  buildManifest,\n-                  nextFontManifest,\n-                  reactLoadableManifest,\n-\n-                  assetPrefix: nextConfig.assetPrefix,\n-                  previewProps: prerenderManifest.preview,\n-                  images: nextConfig.images as any,\n-                  nextConfigOutput: nextConfig.output,\n-                  optimizeCss: Boolean(nextConfig.experimental.optimizeCss),\n-                  nextScriptWorkers: Boolean(\n-                    nextConfig.experimental.nextScriptWorkers\n-                  ),\n-                  domainLocales: nextConfig.i18n?.domains,\n-                  crossOrigin: nextConfig.crossOrigin,\n-\n-                  multiZoneDraftMode,\n-                  basePath: nextConfig.basePath,\n-                  canonicalBase: nextConfig.amp.canonicalBase || '',\n-                  ampOptimizerConfig: nextConfig.experimental.amp?.optimizer,\n-                  disableOptimizedLoading:\n-                    nextConfig.experimental.disableOptimizedLoading,\n-                  largePageDataBytes:\n-                    nextConfig.experimental.largePageDataBytes,\n-                  // Only the `publicRuntimeConfig` key is exposed to the client side\n-                  // It'll be rendered as part of __NEXT_DATA__ on the client side\n-                  runtimeConfig:\n-                    Object.keys(publicRuntimeConfig).length > 0\n-                      ? publicRuntimeConfig\n-                      : undefined,\n-\n-                  isExperimentalCompile,\n-\n-                  experimental: {\n-                    clientTraceMetadata:\n-                      nextConfig.experimental.clientTraceMetadata ||\n-                      ([] as any),\n-                  },\n-\n-                  locale,\n-                  locales,\n-                  defaultLocale,\n-                  setIsrStatus: routerServerContext?.setIsrStatus,\n-\n-                  isNextDataRequest:\n-                    isNextDataRequest && (hasServerProps || hasStaticProps),\n-\n-                  resolvedUrl,\n-                  // For getServerSideProps and getInitialProps we need to ensure we use the original URL\n-                  // and not the resolved URL to prevent a hydration mismatch on\n-                  // asPath\n-                  resolvedAsPath:\n-                    hasServerProps || hasGetInitialProps\n-                      ? formatUrl({\n-                          // we use the original URL pathname less the _next/data prefix if\n-                          // present\n-                          pathname: isNextDataRequest\n-                            ? normalizeDataPath(originalPathname)\n-                            : originalPathname,\n-                          query: originalQuery,\n-                        })\n-                      : resolvedUrl,\n-\n-                  isOnDemandRevalidate,\n-\n-                  ErrorDebug: getRequestMeta(req, 'PagesErrorDebug'),\n-                  err: getRequestMeta(req, 'invokeError'),\n-                  dev: routeModule.isDev,\n-\n-                  // needed for experimental.optimizeCss feature\n-                  distDir: `${routeModule.projectDir}/${routeModule.distDir}`,\n-\n-                  ampSkipValidation:\n-                    nextConfig.experimental.amp?.skipValidation,\n-                  ampValidator: getRequestMeta(req, 'ampValidator'),\n-                },\n-              })\n-              .then((renderResult): ResponseCacheEntry => {\n-                const { metadata } = renderResult\n-\n-                let cacheControl: CacheControl | undefined =\n-                  metadata.cacheControl\n-\n-                if ('isNotFound' in metadata && metadata.isNotFound) {\n-                  return {\n-                    value: null,\n-                    cacheControl,\n-                  } satisfies ResponseCacheEntry\n-                }\n-\n-                // Handle `isRedirect`.\n-                if (metadata.isRedirect) {\n-                  return {\n-                    value: {\n-                      kind: CachedRouteKind.REDIRECT,\n-                      props: metadata.pageData ?? metadata.flightData,\n-                    } satisfies CachedRedirectValue,\n-                    cacheControl,\n-                  } satisfies ResponseCacheEntry\n-                }\n-\n-                return {\n-                  value: {\n-                    kind: CachedRouteKind.PAGES,\n-                    html: renderResult,\n-                    pageData: renderResult.metadata.pageData,\n-                    headers: renderResult.metadata.headers,\n-                    status: renderResult.metadata.statusCode,\n-                  },\n-                  cacheControl,\n-                }\n-              })\n-              .finally(() => {\n-                if (!span) return\n-\n-                span.setAttributes({\n-                  'http.status_code': res.statusCode,\n-                  'next.rsc': false,\n-                })\n-\n-                const rootSpanAttributes = tracer.getRootSpanAttributes()\n-                // We were unable to get attributes, probably OTEL is not enabled\n-                if (!rootSpanAttributes) {\n-                  return\n-                }\n-\n-                if (\n-                  rootSpanAttributes.get('next.span_type') !==\n-                  BaseServerSpan.handleRequest\n-                ) {\n-                  console.warn(\n-                    `Unexpected root span type '${rootSpanAttributes.get(\n-                      'next.span_type'\n-                    )}'. Please report this Next.js issue https://github.com/vercel/next.js`\n-                  )\n-                  return\n-                }\n-\n-                const route = rootSpanAttributes.get('next.route')\n-                if (route) {\n-                  const name = `${method} ${route}`\n-\n-                  span.setAttributes({\n-                    'next.route': route,\n-                    'http.route': route,\n-                    'next.span_name': name,\n-                  })\n-                  span.updateName(name)\n-                } else {\n-                  span.updateName(`${method} ${req.url}`)\n-                }\n-              })\n-          } catch (err: unknown) {\n-            // if this is a background revalidate we need to report\n-            // the request error here as it won't be bubbled\n-            if (previousCacheEntry?.isStale) {\n-              await routeModule.onRequestError(\n-                req,\n-                err,\n-                {\n-                  routerKind: 'Pages Router',\n-                  routePath: srcPage,\n-                  routeType: 'render',\n-                  revalidateReason: getRevalidateReason({\n-                    isRevalidate: hasStaticProps,\n-                    isOnDemandRevalidate,\n-                  }),\n-                },\n-                routerServerContext\n-              )\n-            }\n-            throw err\n-          }\n-        }\n-\n-        // if we've already generated this page we no longer\n-        // serve the fallback\n-        if (previousCacheEntry) {\n-          isIsrFallback = false\n-        }\n-\n-        if (isIsrFallback) {\n-          const fallbackResponse = await routeModule.getResponseCache(req).get(\n-            routeModule.isDev\n-              ? null\n-              : locale\n-                ? `/${locale}${srcPage}`\n-                : srcPage,\n-            async ({\n-              previousCacheEntry: previousFallbackCacheEntry = null,\n-            }) => {\n-              if (!routeModule.isDev) {\n-                return toResponseCacheEntry(previousFallbackCacheEntry)\n-              }\n-              return doRender()\n-            },\n-            {\n-              routeKind: RouteKind.PAGES,\n-              isFallback: true,\n-              isRoutePPREnabled: false,\n-              isOnDemandRevalidate: false,\n-              incrementalCache: await routeModule.getIncrementalCache(\n-                req,\n-                nextConfig,\n-                prerenderManifest\n-              ),\n-              waitUntil: ctx.waitUntil,\n-            }\n-          )\n-          if (fallbackResponse) {\n-            // Remove the cache control from the response to prevent it from being\n-            // used in the surrounding cache.\n-            delete fallbackResponse.cacheControl\n-            fallbackResponse.isMiss = true\n-            return fallbackResponse\n-          }\n-        }\n-\n-        if (\n-          !getRequestMeta(req, 'minimalMode') &&\n-          isOnDemandRevalidate &&\n-          revalidateOnlyGenerated &&\n-          !previousCacheEntry\n-        ) {\n-          res.statusCode = 404\n-          // on-demand revalidate always sets this header\n-          res.setHeader('x-nextjs-cache', 'REVALIDATED')\n-          res.end('This page could not be found')\n-          return null\n-        }\n-\n-        if (\n-          isIsrFallback &&\n-          previousCacheEntry?.value?.kind === CachedRouteKind.PAGES\n-        ) {\n-          return {\n-            value: {\n-              kind: CachedRouteKind.PAGES,\n-              html: new RenderResult(\n-                Buffer.from(previousCacheEntry.value.html),\n-                {\n-                  contentType: HTML_CONTENT_TYPE_HEADER,\n-                  metadata: {\n-                    statusCode: previousCacheEntry.value.status,\n-                    headers: previousCacheEntry.value.headers,\n-                  },\n-                }\n-              ),\n-              pageData: {},\n-              status: previousCacheEntry.value.status,\n-              headers: previousCacheEntry.value.headers,\n-            } satisfies CachedPageValue,\n-            cacheControl: { revalidate: 0, expire: undefined },\n-          } satisfies ResponseCacheEntry\n-        }\n-        return doRender()\n-      }\n-\n-      const result = await routeModule.handleResponse({\n-        cacheKey,\n-        req,\n-        nextConfig,\n-        routeKind: RouteKind.PAGES,\n-        isOnDemandRevalidate,\n-        revalidateOnlyGenerated,\n-        waitUntil: ctx.waitUntil,\n-        responseGenerator: responseGenerator,\n-        prerenderManifest,\n-      })\n-\n-      // if we got a cache hit this wasn't an ISR fallback\n-      // but it wasn't generated during build so isn't in the\n-      // prerender-manifest\n-      if (isIsrFallback && !result?.isMiss) {\n-        isIsrFallback = false\n-      }\n-\n-      // response is finished is no cache entry\n-      if (!result) {\n-        return\n-      }\n-\n-      if (hasStaticProps && !getRequestMeta(req, 'minimalMode')) {\n-        res.setHeader(\n-          'x-nextjs-cache',\n-          isOnDemandRevalidate\n-            ? 'REVALIDATED'\n-            : result.isMiss\n-              ? 'MISS'\n-              : result.isStale\n-                ? 'STALE'\n-                : 'HIT'\n-        )\n-      }\n-\n-      let cacheControl: CacheControl | undefined\n-\n-      if (!hasStaticProps || isIsrFallback) {\n-        if (!res.getHeader('Cache-Control')) {\n-          cacheControl = { revalidate: 0, expire: undefined }\n-        }\n-      } else if (is404Page) {\n-        const notFoundRevalidate = getRequestMeta(req, 'notFoundRevalidate')\n-\n-        cacheControl = {\n-          revalidate:\n-            typeof notFoundRevalidate === 'undefined' ? 0 : notFoundRevalidate,\n-          expire: undefined,\n-        }\n-      } else if (is500Page) {\n-        cacheControl = { revalidate: 0, expire: undefined }\n-      } else if (result.cacheControl) {\n-        // If the cache entry has a cache control with a revalidate value that's\n-        // a number, use it.\n-        if (typeof result.cacheControl.revalidate === 'number') {\n-          if (result.cacheControl.revalidate < 1) {\n-            throw new Error(\n-              `Invalid revalidate configuration provided: ${result.cacheControl.revalidate} < 1`\n-            )\n-          }\n-          cacheControl = {\n-            revalidate: result.cacheControl.revalidate,\n-            expire: result.cacheControl?.expire ?? nextConfig.expireTime,\n-          }\n-        } else {\n-          // revalidate: false\n-          cacheControl = {\n-            revalidate: CACHE_ONE_YEAR,\n-            expire: undefined,\n-          }\n-        }\n-      }\n-\n-      // If cache control is already set on the response we don't\n-      // override it to allow users to customize it via next.config\n-      if (cacheControl && !res.getHeader('Cache-Control')) {\n-        res.setHeader('Cache-Control', getCacheControlHeader(cacheControl))\n-      }\n-\n-      // notFound: true case\n-      if (!result.value) {\n-        // add revalidate metadata before rendering 404 page\n-        // so that we can use this as source of truth for the\n-        // cache-control header instead of what the 404 page returns\n-        // for the revalidate value\n-        addRequestMeta(\n-          req,\n-          'notFoundRevalidate',\n-          result.cacheControl?.revalidate\n-        )\n-\n-        res.statusCode = 404\n-\n-        if (isNextDataRequest) {\n-          res.end('{\"notFound\":true}')\n-          return\n-        }\n-        // TODO: should route-module itself handle rendering the 404\n-        if (routerServerContext?.render404) {\n-          await routerServerContext.render404(req, res, parsedUrl, false)\n-        } else {\n-          res.end('This page could not be found')\n-        }\n-        return\n-      }\n-\n-      if (result.value.kind === CachedRouteKind.REDIRECT) {\n-        if (isNextDataRequest) {\n-          res.setHeader('content-type', JSON_CONTENT_TYPE_HEADER)\n-          res.end(JSON.stringify(result.value.props))\n-          return\n-        } else {\n-          const handleRedirect = (pageData: any) => {\n-            const redirect = {\n-              destination: pageData.pageProps.__N_REDIRECT,\n-              statusCode: pageData.pageProps.__N_REDIRECT_STATUS,\n-              basePath: pageData.pageProps.__N_REDIRECT_BASE_PATH,\n-            }\n-            const statusCode = getRedirectStatus(redirect)\n-            const { basePath } = nextConfig\n-\n-            if (\n-              basePath &&\n-              redirect.basePath !== false &&\n-              redirect.destination.startsWith('/')\n-            ) {\n-              redirect.destination = `${basePath}${redirect.destination}`\n-            }\n-\n-            if (redirect.destination.startsWith('/')) {\n-              redirect.destination = normalizeRepeatedSlashes(\n-                redirect.destination\n-              )\n-            }\n-\n-            res.statusCode = statusCode\n-            res.setHeader('Location', redirect.destination)\n-            if (statusCode === RedirectStatusCode.PermanentRedirect) {\n-              res.setHeader('Refresh', `0;url=${redirect.destination}`)\n-            }\n-            res.end(redirect.destination)\n-          }\n-          await handleRedirect(result.value.props)\n-          return null\n-        }\n-      }\n-\n-      if (result.value.kind !== CachedRouteKind.PAGES) {\n-        throw new Error(\n-          `Invariant: received non-pages cache entry in pages handler`\n-        )\n-      }\n-\n-      // In dev, we should not cache pages for any reason.\n-      if (routeModule.isDev) {\n-        res.setHeader('Cache-Control', 'no-store, must-revalidate')\n-      }\n-\n-      // Draft mode should never be cached\n-      if (isDraftMode) {\n-        res.setHeader(\n-          'Cache-Control',\n-          'private, no-cache, no-store, max-age=0, must-revalidate'\n-        )\n-      }\n-\n-      // when invoking _error before pages/500 we don't actually\n-      // send the _error response\n-      if (\n-        getRequestMeta(req, 'customErrorRender') ||\n-        (isErrorPage &&\n-          getRequestMeta(req, 'minimalMode') &&\n-          res.statusCode === 500)\n-      ) {\n-        return null\n-      }\n-\n-      await sendRenderResult({\n-        req,\n-        res,\n-        // If we are rendering the error page it's not a data request\n-        // anymore\n-        result:\n-          isNextDataRequest && !isErrorPage && !is500Page\n-            ? new RenderResult(\n-                Buffer.from(JSON.stringify(result.value.pageData)),\n-                {\n-                  contentType: JSON_CONTENT_TYPE_HEADER,\n-                  metadata: result.value.html.metadata,\n-                }\n-              )\n-            : result.value.html,\n-        generateEtags: nextConfig.generateEtags,\n-        poweredByHeader: nextConfig.poweredByHeader,\n-        cacheControl: routeModule.isDev ? undefined : cacheControl,\n-      })\n-    }\n-\n-    // TODO: activeSpan code path is for when wrapped by\n-    // next-server can be removed when this is no longer used\n-    if (activeSpan) {\n-      await handleResponse()\n-    } else {\n-      await tracer.withPropagatedContext(req.headers, () =>\n-        tracer.trace(\n-          BaseServerSpan.handleRequest,\n-          {\n-            spanName: `${method} ${req.url}`,\n-            kind: SpanKind.SERVER,\n-            attributes: {\n-              'http.method': method,\n-              'http.target': req.url,\n-            },\n-          },\n-          handleResponse\n-        )\n-      )\n-    }\n-  } catch (err) {\n-    await routeModule.onRequestError(\n-      req,\n-      err,\n-      {\n-        routerKind: 'Pages Router',\n-        routePath: srcPage,\n-        routeType: 'render',\n-        revalidateReason: getRevalidateReason({\n-          isRevalidate: hasStaticProps,\n-          isOnDemandRevalidate,\n-        }),\n-      },\n-      routerServerContext\n-    )\n-\n-    // rethrow so that we can handle serving error page\n-    throw err\n-  }\n-}\n+export const handler = getHandler({\n+  srcPage: 'VAR_DEFINITION_PAGE',\n+  config,\n+  userland,\n+  routeModule,\n+  getStaticPaths,\n+  getStaticProps,\n+  getServerSideProps,\n+})"
        },
        {
            "sha": "15247aeb03f44173714acb8d81d671a94aee043b",
            "filename": "packages/next/src/build/webpack/loaders/next-edge-ssr-loader/index.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/955adbb05778e732c3d43c5afc5880c18feaaeb2/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack%2Floaders%2Fnext-edge-ssr-loader%2Findex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/955adbb05778e732c3d43c5afc5880c18feaaeb2/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack%2Floaders%2Fnext-edge-ssr-loader%2Findex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack%2Floaders%2Fnext-edge-ssr-loader%2Findex.ts?ref=955adbb05778e732c3d43c5afc5880c18feaaeb2",
            "patch": "@@ -57,7 +57,7 @@ function getRouteModuleOptions(page: string) {\n     },\n     // edge runtime doesn't read from distDir or projectDir\n     distDir: '',\n-    projectDir: '',\n+    relativeProjectDir: '',\n   }\n \n   return options"
        },
        {
            "sha": "c5a563432da7370a5e16ace8e6d2c95a04107c85",
            "filename": "packages/next/src/server/api-utils/node/api-resolver.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 8,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/955adbb05778e732c3d43c5afc5880c18feaaeb2/packages%2Fnext%2Fsrc%2Fserver%2Fapi-utils%2Fnode%2Fapi-resolver.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/955adbb05778e732c3d43c5afc5880c18feaaeb2/packages%2Fnext%2Fsrc%2Fserver%2Fapi-utils%2Fnode%2Fapi-resolver.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapi-utils%2Fnode%2Fapi-resolver.ts?ref=955adbb05778e732c3d43c5afc5880c18feaaeb2",
            "patch": "@@ -30,10 +30,7 @@ import {\n } from '../../../lib/constants'\n import { tryGetPreviewData } from './try-get-preview-data'\n import { parseBody } from './parse-body'\n-import {\n-  RouterServerContextSymbol,\n-  routerServerGlobal,\n-} from '../../lib/router-utils/router-server-context'\n+import type { RevalidateFn } from '../../lib/router-utils/router-server-context'\n import type { InstrumentationOnRequestError } from '../../instrumentation/types'\n \n type ApiContext = __ApiPreviewProps & {\n@@ -42,7 +39,7 @@ type ApiContext = __ApiPreviewProps & {\n   hostname?: string\n   multiZoneDraftMode?: boolean\n   dev: boolean\n-  projectDir: string\n+  internalRevalidate?: RevalidateFn\n }\n \n function getMaxContentLength(responseLimit?: ResponseLimit) {\n@@ -287,9 +284,7 @@ async function revalidate(\n     }\n   }\n \n-  const internalRevalidate =\n-    routerServerGlobal[RouterServerContextSymbol]?.[context.projectDir]\n-      ?.revalidate\n+  const internalRevalidate = context.internalRevalidate\n \n   try {\n     // We use the revalidate in router-server if available."
        },
        {
            "sha": "d4d2dfab6f4794098018cce1dec2c7d779a8fcc9",
            "filename": "packages/next/src/server/base-server.ts",
            "status": "modified",
            "additions": 87,
            "deletions": 1404,
            "changes": 1491,
            "blob_url": "https://github.com/vercel/next.js/blob/955adbb05778e732c3d43c5afc5880c18feaaeb2/packages%2Fnext%2Fsrc%2Fserver%2Fbase-server.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/955adbb05778e732c3d43c5afc5880c18feaaeb2/packages%2Fnext%2Fsrc%2Fserver%2Fbase-server.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fbase-server.ts?ref=955adbb05778e732c3d43c5afc5880c18feaaeb2",
            "patch": "@@ -2,10 +2,6 @@ import type { __ApiPreviewProps } from './api-utils'\n import type { LoadComponentsReturnType } from './load-components'\n import type { MiddlewareRouteMatch } from '../shared/lib/router/utils/middleware-route-matcher'\n import type { Params } from './request/params'\n-import {\n-  type FallbackRouteParams,\n-  getFallbackRouteParams,\n-} from './request/fallback-params'\n import type { NextConfig, NextConfigComplete } from './config-shared'\n import type {\n   NextParsedUrlQuery,\n@@ -18,15 +14,9 @@ import type {\n   RenderOptsPartial as AppRenderOptsPartial,\n   ServerOnInstrumentationRequestError,\n } from './app-render/types'\n-import {\n-  type CachedAppPageValue,\n-  type CachedPageValue,\n-  type ServerComponentsHmrCache,\n-  type ResponseCacheBase,\n-  type ResponseCacheEntry,\n-  type ResponseGenerator,\n-  CachedRouteKind,\n-  type CachedRedirectValue,\n+import type {\n+  ServerComponentsHmrCache,\n+  ResponseCacheBase,\n } from './response-cache'\n import type { UrlWithParsedQuery } from 'url'\n import {\n@@ -35,7 +25,6 @@ import {\n   normalizeRepeatedSlashes,\n   MissingStaticPage,\n } from '../shared/lib/utils'\n-import type { PreviewData } from '../types'\n import type { PagesManifest } from '../build/webpack/plugins/pages-manifest-plugin'\n import type { BaseNextRequest, BaseNextResponse } from './base-http'\n import type {\n@@ -45,10 +34,6 @@ import type {\n } from '../build'\n import type { ClientReferenceManifest } from '../build/webpack/plugins/flight-manifest-plugin'\n import type { NextFontManifest } from '../build/webpack/plugins/next-font-manifest-plugin'\n-import type {\n-  AppPageRouteHandlerContext,\n-  AppPageRouteModule,\n-} from './route-modules/app-page/module'\n import type { PagesAPIRouteMatch } from './route-matches/pages-api-route-match'\n import type {\n   Server as HTTPServer,\n@@ -62,8 +47,6 @@ import type { InstrumentationModule } from './instrumentation/types'\n \n import { format as formatUrl, parse as parseUrl } from 'url'\n import { formatHostname } from './lib/format-hostname'\n-import { getRedirectStatus } from '../lib/redirect-status'\n-import { isEdgeRuntime } from '../lib/is-edge-runtime'\n import {\n   APP_PATHS_MANIFEST,\n   NEXT_BUILTIN_DOCUMENT,\n@@ -73,9 +56,7 @@ import {\n   UNDERSCORE_NOT_FOUND_ROUTE_ENTRY,\n } from '../shared/lib/constants'\n import { isDynamicRoute } from '../shared/lib/router/utils'\n-import { checkIsOnDemandRevalidate } from './api-utils'\n import { setConfig } from '../shared/lib/runtime-config.external'\n-import { getCacheControlHeader, type CacheControl } from './lib/cache-control'\n import { execOnce } from '../shared/lib/utils'\n import { isBlockedPage } from './utils'\n import { getBotType, isBot } from '../shared/lib/router/utils/is-bot'\n@@ -101,11 +82,8 @@ import {\n   NEXT_RSC_UNION_QUERY,\n   NEXT_ROUTER_PREFETCH_HEADER,\n   NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n-  NEXT_DID_POSTPONE_HEADER,\n   NEXT_URL,\n   NEXT_ROUTER_STATE_TREE_HEADER,\n-  NEXT_IS_PRERENDER_HEADER,\n-  RSC_CONTENT_TYPE_HEADER,\n } from '../client/components/app-router-headers'\n import type {\n   MatchOptions,\n@@ -124,23 +102,19 @@ import { I18NProvider } from './lib/i18n-provider'\n import { sendResponse } from './send-response'\n import { normalizeNextQueryParam } from './web/utils'\n import {\n-  CACHE_ONE_YEAR,\n   HTML_CONTENT_TYPE_HEADER,\n   JSON_CONTENT_TYPE_HEADER,\n   MATCHED_PATH_HEADER,\n-  NEXT_CACHE_TAGS_HEADER,\n   NEXT_RESUME_HEADER,\n } from '../lib/constants'\n import { normalizeLocalePath } from '../shared/lib/i18n/normalize-locale-path'\n import { matchNextDataPathname } from './lib/match-next-data-pathname'\n import getRouteFromAssetPath from '../shared/lib/router/utils/get-route-from-asset-path'\n-import { decodePathParams } from './lib/router-utils/decode-path-params'\n import { RSCPathnameNormalizer } from './normalizers/request/rsc'\n import { stripFlightHeaders } from './app-render/strip-flight-headers'\n import {\n   isAppPageRouteModule,\n   isAppRouteRouteModule,\n-  isPagesRouteModule,\n } from './route-modules/checks'\n import { PrefetchRSCPathnameNormalizer } from './normalizers/request/prefetch-rsc'\n import { NextDataPathnameNormalizer } from './normalizers/request/next-data'\n@@ -155,26 +129,18 @@ import {\n   getBuiltinRequestContext,\n   type WaitUntil,\n } from './after/builtin-request-context'\n-import { ENCODED_TAGS } from './stream-utils/encoded-tags'\n import { NextRequestHint } from './web/adapter'\n-import { getRevalidateReason } from './instrumentation/utils'\n-import { RouteKind } from './route-kind'\n import type { RouteModule } from './route-modules/route-module'\n-import { FallbackMode, parseFallbackField } from '../lib/fallback'\n-import { toResponseCacheEntry } from './response-cache/utils'\n+import { type FallbackMode, parseFallbackField } from '../lib/fallback'\n import { SegmentPrefixRSCPathnameNormalizer } from './normalizers/request/segment-prefix-rsc'\n-import {\n-  shouldServeStreamingMetadata,\n-  isHtmlBotRequest,\n-} from './lib/streaming-metadata'\n-import { InvariantError } from '../shared/lib/invariant-error'\n+import { shouldServeStreamingMetadata } from './lib/streaming-metadata'\n import { decodeQueryPathParameter } from './lib/decode-query-path-parameter'\n import { NoFallbackError } from '../shared/lib/no-fallback-error.external'\n import { getCacheHandlers } from './use-cache/handlers'\n import { fixMojibake } from './lib/fix-mojibake'\n import { computeCacheBustingSearchParam } from '../shared/lib/router/utils/cache-busting-search-param'\n-import { RedirectStatusCode } from '../client/components/redirect-status-code'\n import { setCacheBustingSearchParamWithHash } from '../client/components/router-reducer/set-cache-busting-search-param'\n+import type { CacheControl } from './lib/cache-control'\n \n export type FindComponentsResult = {\n   components: LoadComponentsReturnType\n@@ -471,10 +437,7 @@ export default abstract class Server<\n     this.experimentalTestProxy = experimentalTestProxy\n     this.serverOptions = options\n \n-    this.dir =\n-      process.env.NEXT_RUNTIME === 'edge'\n-        ? dir\n-        : (require('path') as typeof import('path')).resolve(dir)\n+    this.dir = (require('path') as typeof import('path')).resolve(dir)\n \n     this.quiet = quiet\n     this.loadEnvConfig({ dev })\n@@ -488,13 +451,10 @@ export default abstract class Server<\n       this.fetchHostname = formatHostname(this.hostname)\n     }\n     this.port = port\n-    this.distDir =\n-      process.env.NEXT_RUNTIME === 'edge'\n-        ? this.nextConfig.distDir\n-        : (require('path') as typeof import('path')).join(\n-            this.dir,\n-            this.nextConfig.distDir\n-          )\n+    this.distDir = (require('path') as typeof import('path')).join(\n+      this.dir,\n+      this.nextConfig.distDir\n+    )\n     this.publicDir = this.getPublicDir()\n     this.hasStaticDir = !minimalMode && this.getHasStaticDir()\n \n@@ -555,10 +515,7 @@ export default abstract class Server<\n     }\n \n     this.nextFontManifest = this.getNextFontManifest()\n-\n-    if (process.env.NEXT_RUNTIME !== 'edge') {\n-      process.env.NEXT_DEPLOYMENT_ID = this.nextConfig.deploymentId || ''\n-    }\n+    process.env.NEXT_DEPLOYMENT_ID = this.nextConfig.deploymentId || ''\n \n     this.renderOpts = {\n       dir: this.dir,\n@@ -735,10 +692,7 @@ export default abstract class Server<\n \n       if (params.path[0] !== this.buildId) {\n         // Ignore if its a middleware request when we aren't on edge.\n-        if (\n-          process.env.NEXT_RUNTIME !== 'edge' &&\n-          getRequestMeta(req, 'middlewareInvoke')\n-        ) {\n+        if (getRequestMeta(req, 'middlewareInvoke')) {\n           return false\n         }\n \n@@ -1493,10 +1447,7 @@ export default abstract class Server<\n       // we only honor this header if we are inside of a render worker to\n       // prevent external users coercing the routing path\n       const invokePath = getRequestMeta(req, 'invokePath')\n-      const useInvokePath =\n-        !useMatchedPathHeader &&\n-        process.env.NEXT_RUNTIME !== 'edge' &&\n-        invokePath\n+      const useInvokePath = !useMatchedPathHeader && invokePath\n \n       if (useInvokePath) {\n         const invokeStatus = getRequestMeta(req, 'invokeStatus')\n@@ -1556,10 +1507,7 @@ export default abstract class Server<\n         return\n       }\n \n-      if (\n-        process.env.NEXT_RUNTIME !== 'edge' &&\n-        getRequestMeta(req, 'middlewareInvoke')\n-      ) {\n+      if (getRequestMeta(req, 'middlewareInvoke')) {\n         finished = await this.normalizeAndAttachMetadata(req, res, parsedUrl)\n         if (finished) return\n \n@@ -1956,6 +1904,7 @@ export default abstract class Server<\n     pathname,\n   }: {\n     pathname: string\n+    urlPathname: string\n     requestHeaders: import('./lib/incremental-cache').IncrementalCache['requestHeaders']\n     page: string\n     isAppPath: boolean\n@@ -2047,9 +1996,7 @@ export default abstract class Server<\n     const isAppPath = components.isAppPath === true\n \n     const hasServerProps = !!components.getServerSideProps\n-    let hasGetStaticPaths = !!components.getStaticPaths\n     const isPossibleServerAction = getIsPossibleServerAction(req)\n-    const hasGetInitialProps = !!components.Component?.getInitialProps\n     let isSSG = !!components.getStaticProps\n     // NOTE: Don't delete headers[RSC] yet, it still needs to be used in renderToHTML later\n     const isRSCRequest = getRequestMeta(req, 'isRSCRequest') ?? false\n@@ -2103,46 +2050,10 @@ export default abstract class Server<\n     this.setVaryHeader(req, res, isAppPath, resolvedUrlPathname)\n \n     let staticPaths: string[] | undefined\n-    let fallbackMode: FallbackMode | undefined\n     let hasFallback = false\n \n-    const isDynamic = isDynamicRoute(components.page)\n-\n     const prerenderManifest = this.getPrerenderManifest()\n \n-    if (isAppPath && isDynamic) {\n-      const pathsResult = await this.getStaticPaths({\n-        pathname,\n-        page: components.page,\n-        isAppPath,\n-        requestHeaders: req.headers,\n-      })\n-\n-      staticPaths = pathsResult.staticPaths\n-      fallbackMode = pathsResult.fallbackMode\n-      hasFallback = typeof fallbackMode !== 'undefined'\n-\n-      if (this.nextConfig.output === 'export') {\n-        const page = components.page\n-        if (!staticPaths) {\n-          throw new Error(\n-            `Page \"${page}\" is missing exported function \"generateStaticParams()\", which is required with \"output: export\" config.`\n-          )\n-        }\n-\n-        const resolvedWithoutSlash = removeTrailingSlash(resolvedUrlPathname)\n-        if (!staticPaths.includes(resolvedWithoutSlash)) {\n-          throw new Error(\n-            `Page \"${page}\" is missing param \"${resolvedWithoutSlash}\" in \"generateStaticParams()\", which is required with \"output: export\" config.`\n-          )\n-        }\n-      }\n-\n-      if (hasFallback) {\n-        hasGetStaticPaths = true\n-      }\n-    }\n-\n     if (\n       hasFallback ||\n       staticPaths?.includes(resolvedUrlPathname) ||\n@@ -2164,13 +2075,6 @@ export default abstract class Server<\n       ) &&\n       (isSSG || hasServerProps)\n \n-    /**\n-     * If true, this indicates that the request being made is for an app\n-     * prefetch request.\n-     */\n-    const isPrefetchRSCRequest =\n-      getRequestMeta(req, 'isPrefetchRSCRequest') ?? false\n-\n     // when we are handling a middleware prefetch and it doesn't\n     // resolve to a static data route we bail early to avoid\n     // unexpected SSR invocations\n@@ -2201,9 +2105,6 @@ export default abstract class Server<\n     }\n \n     const locale = getRequestMeta(req, 'locale')\n-    const defaultLocale = isSSG\n-      ? this.nextConfig.i18n?.defaultLocale\n-      : getRequestMeta(req, 'defaultLocale')\n \n     if (\n       !!req.headers['x-nextjs-data'] &&\n@@ -2236,11 +2137,6 @@ export default abstract class Server<\n       typeof query.__nextppronly !== 'undefined' &&\n       couldSupportPPR\n \n-    // When enabled, this will allow the use of the `?__nextppronly` query\n-    // to enable debugging of the fallback shell.\n-    const hasDebugFallbackShellQuery =\n-      hasDebugStaticShellQuery && query.__nextppronly === 'fallback'\n-\n     // This page supports PPR if it is marked as being `PARTIALLY_STATIC` in the\n     // prerender manifest and this is an app page.\n     const isRoutePPREnabled: boolean =\n@@ -2257,44 +2153,13 @@ export default abstract class Server<\n           (this.renderOpts.dev === true ||\n             this.experimentalTestProxy === true)))\n \n-    const isDebugStaticShell: boolean =\n-      hasDebugStaticShellQuery && isRoutePPREnabled\n-\n-    // We should enable debugging dynamic accesses when the static shell\n-    // debugging has been enabled and we're also in development mode.\n-    const isDebugDynamicAccesses =\n-      isDebugStaticShell && this.renderOpts.dev === true\n-\n-    const isDebugFallbackShell = hasDebugFallbackShellQuery && isRoutePPREnabled\n-\n     // If we're in minimal mode, then try to get the postponed information from\n     // the request metadata. If available, use it for resuming the postponed\n     // render.\n     const minimalPostponed = isRoutePPREnabled\n       ? getRequestMeta(req, 'postponed')\n       : undefined\n \n-    // If PPR is enabled, and this is a RSC request (but not a prefetch), then\n-    // we can use this fact to only generate the flight data for the request\n-    // because we can't cache the HTML (as it's also dynamic).\n-    const isDynamicRSCRequest =\n-      isRoutePPREnabled && isRSCRequest && !isPrefetchRSCRequest\n-\n-    // Need to read this before it's stripped by stripFlightHeaders. We don't\n-    // need to transfer it to the request meta because it's only read\n-    // within this function; the static segment data should have already been\n-    // generated, so we will always either return a static response or a 404.\n-    const segmentPrefetchHeader = getRequestMeta(\n-      req,\n-      'segmentPrefetchRSCRequest'\n-    )\n-\n-    const isHtmlBot = isHtmlBotRequest(req)\n-    if (isHtmlBot && isRoutePPREnabled) {\n-      isSSG = false\n-      this.renderOpts.serveStreamingMetadata = false\n-    }\n-\n     // we need to ensure the status code if /404 is visited directly\n     if (is404Page && !isNextDataRequest && !isRSCRequest) {\n       res.statusCode = 404\n@@ -2360,45 +2225,6 @@ export default abstract class Server<\n       opts.supportsDynamicResponse = true\n     }\n \n-    const locales = this.nextConfig.i18n?.locales\n-\n-    let previewData: PreviewData\n-    let isPreviewMode = false\n-\n-    if (hasServerProps || isSSG || isAppPath) {\n-      // For the edge runtime, we don't support preview mode in SSG.\n-      if (process.env.NEXT_RUNTIME !== 'edge') {\n-        const { tryGetPreviewData } =\n-          require('./api-utils/node/try-get-preview-data') as typeof import('./api-utils/node/try-get-preview-data')\n-        previewData = tryGetPreviewData(\n-          req,\n-          res,\n-          this.renderOpts.previewProps,\n-          !!this.nextConfig.experimental.multiZoneDraftMode\n-        )\n-        isPreviewMode = previewData !== false\n-      }\n-    }\n-\n-    // If this is a request for an app path that should be statically generated\n-    // and we aren't in the edge runtime, strip the flight headers so it will\n-    // generate the static response.\n-    if (\n-      isAppPath &&\n-      !opts.dev &&\n-      !isPreviewMode &&\n-      isSSG &&\n-      isRSCRequest &&\n-      !isDynamicRSCRequest &&\n-      (!isEdgeRuntime(opts.runtime) ||\n-        (this.serverOptions as any).webServerConfig)\n-    ) {\n-      stripFlightHeaders(req.headers)\n-    }\n-\n-    let { isOnDemandRevalidate, revalidateOnlyGenerated } =\n-      checkIsOnDemandRevalidate(req, this.renderOpts.previewProps)\n-\n     if (isSSG && this.minimalMode && req.headers[MATCHED_PATH_HEADER]) {\n       // the url value is already correct when the matched-path header is set\n       resolvedUrlPathname = urlPathname\n@@ -2410,1252 +2236,112 @@ export default abstract class Server<\n       resolvedUrlPathname = this.localeNormalizer.normalize(resolvedUrlPathname)\n     }\n \n-    const handleRedirect = (pageData: any) => {\n-      const redirect = {\n-        destination: pageData.pageProps.__N_REDIRECT,\n-        statusCode: pageData.pageProps.__N_REDIRECT_STATUS,\n-        basePath: pageData.pageProps.__N_REDIRECT_BASE_PATH,\n-      }\n-      const statusCode = getRedirectStatus(redirect)\n-      const { basePath } = this.nextConfig\n-\n-      if (\n-        basePath &&\n-        redirect.basePath !== false &&\n-        redirect.destination.startsWith('/')\n-      ) {\n-        redirect.destination = `${basePath}${redirect.destination}`\n-      }\n-\n-      if (redirect.destination.startsWith('/')) {\n-        redirect.destination = normalizeRepeatedSlashes(redirect.destination)\n-      }\n-\n-      res\n-        .redirect(redirect.destination, statusCode)\n-        .body(redirect.destination)\n-        .send()\n-    }\n-\n     // remove /_next/data prefix from urlPathname so it matches\n     // for direct page visit and /_next/data visit\n     if (isNextDataRequest) {\n       resolvedUrlPathname = this.stripNextDataPath(resolvedUrlPathname)\n       urlPathname = this.stripNextDataPath(urlPathname)\n     }\n \n-    let ssgCacheKey: string | null = null\n-    if (\n-      !isPreviewMode &&\n-      isSSG &&\n-      !opts.supportsDynamicResponse &&\n-      !isPossibleServerAction &&\n-      !minimalPostponed &&\n-      !isDynamicRSCRequest\n-    ) {\n-      ssgCacheKey = `${locale ? `/${locale}` : ''}${\n-        (pathname === '/' || resolvedUrlPathname === '/') && locale\n-          ? ''\n-          : resolvedUrlPathname\n-      }${query.amp ? '.amp' : ''}`\n-    }\n-\n-    if ((is404Page || is500Page) && isSSG) {\n-      ssgCacheKey = `${locale ? `/${locale}` : ''}${pathname}${\n-        query.amp ? '.amp' : ''\n-      }`\n-    }\n-\n-    if (ssgCacheKey) {\n-      ssgCacheKey = decodePathParams(ssgCacheKey)\n-\n-      // ensure /index and / is normalized to one key\n-      ssgCacheKey =\n-        ssgCacheKey === '/index' && pathname === '/' ? '/' : ssgCacheKey\n-    }\n-\n     // use existing incrementalCache instance if available\n     const incrementalCache: import('./lib/incremental-cache').IncrementalCache =\n-      process.env.NEXT_RUNTIME === 'edge' &&\n-      (globalThis as any).__incrementalCache\n-        ? (globalThis as any).__incrementalCache\n-        : await this.getIncrementalCache({\n-            requestHeaders: Object.assign({}, req.headers),\n-          })\n+      await this.getIncrementalCache({\n+        requestHeaders: Object.assign({}, req.headers),\n+      })\n \n     // TODO: investigate, this is not safe across multiple concurrent requests\n     incrementalCache.resetRequestCache()\n \n-    type RendererContext = {\n-      /**\n-       * The postponed data for this render. This is only provided when resuming\n-       * a render that has been postponed.\n-       */\n-      postponed: string | undefined\n-\n-      pagesFallback: boolean | undefined\n-\n-      /**\n-       * The unknown route params for this render.\n-       */\n-      fallbackRouteParams: FallbackRouteParams | null\n-    }\n-    type Renderer = (\n-      context: RendererContext\n-    ) => Promise<ResponseCacheEntry | null>\n-\n-    const doRender: Renderer = async ({\n-      postponed,\n-      pagesFallback = false,\n-      fallbackRouteParams,\n-    }) => {\n-      // In development, we always want to generate dynamic HTML.\n-      let supportsDynamicResponse: boolean =\n-        // If we're in development, we always support dynamic HTML, unless it's\n-        // a data request, in which case we only produce static HTML.\n-        (!isNextDataRequest && opts.dev === true) ||\n-        // If this is not SSG or does not have static paths, then it supports\n-        // dynamic HTML.\n-        (!isSSG && !hasGetStaticPaths) ||\n-        // If this request has provided postponed data, it supports dynamic\n-        // HTML.\n-        typeof postponed === 'string' ||\n-        // If this is a dynamic RSC request, then this render supports dynamic\n-        // HTML (it's dynamic).\n-        isDynamicRSCRequest\n-\n-      const origQuery = parseUrl(req.url || '', true).query\n-\n-      // clear any dynamic route params so they aren't in\n-      // the resolvedUrl\n-      if (opts.params) {\n-        Object.keys(opts.params).forEach((key) => {\n-          delete origQuery[key]\n-        })\n-      }\n-      const hadTrailingSlash =\n-        urlPathname !== '/' && this.nextConfig.trailingSlash\n-\n-      const resolvedUrl = formatUrl({\n-        pathname: `${resolvedUrlPathname}${hadTrailingSlash ? '/' : ''}`,\n-        // make sure to only add query values from original URL\n-        query: origQuery,\n-      })\n-\n-      // When html bots request PPR page, perform the full dynamic rendering.\n-      const shouldWaitOnAllReady = isHtmlBot && isRoutePPREnabled\n-\n-      const renderOpts: LoadedRenderOpts = {\n-        ...components,\n-        ...opts,\n-        ...(isAppPath\n-          ? {\n-              incrementalCache,\n-              // This is a revalidation request if the request is for a static\n-              // page and it is not being resumed from a postponed render and\n-              // it is not a dynamic RSC request then it is a revalidation\n-              // request.\n-              isRevalidate: isSSG && !postponed && !isDynamicRSCRequest,\n-              serverActions: this.nextConfig.experimental.serverActions,\n-            }\n-          : {}),\n-        isNextDataRequest,\n-        resolvedUrl,\n-        locale,\n-        locales,\n-        defaultLocale,\n-        multiZoneDraftMode: this.nextConfig.experimental.multiZoneDraftMode,\n-        // For getServerSideProps and getInitialProps we need to ensure we use the original URL\n-        // and not the resolved URL to prevent a hydration mismatch on\n-        // asPath\n-        resolvedAsPath:\n-          hasServerProps || hasGetInitialProps\n-            ? formatUrl({\n-                // we use the original URL pathname less the _next/data prefix if\n-                // present\n-                pathname: `${urlPathname}${hadTrailingSlash ? '/' : ''}`,\n-                query: origQuery,\n-              })\n-            : resolvedUrl,\n-        experimental: {\n-          ...opts.experimental,\n-          isRoutePPREnabled,\n-        },\n-        supportsDynamicResponse,\n-        shouldWaitOnAllReady,\n-        isOnDemandRevalidate,\n-        isDraftMode: isPreviewMode,\n-        isPossibleServerAction,\n-        postponed,\n-        waitUntil: this.getWaitUntil(),\n-        onClose: res.onClose.bind(res),\n-        onAfterTaskError: undefined,\n-        // only available in dev\n-        setIsrStatus: (this as any).setIsrStatus,\n-      }\n-\n-      if (isDebugStaticShell || isDebugDynamicAccesses) {\n-        supportsDynamicResponse = false\n-        renderOpts.nextExport = true\n-        renderOpts.supportsDynamicResponse = false\n-        renderOpts.isStaticGeneration = true\n-        renderOpts.isRevalidate = true\n-        renderOpts.isDebugDynamicAccesses = isDebugDynamicAccesses\n-      }\n-\n-      // Legacy render methods will return a render result that needs to be\n-      // served by the server.\n-      let result: RenderResult\n-\n-      if (routeModule) {\n-        if (\n-          isAppRouteRouteModule(routeModule) ||\n-          isPagesRouteModule(routeModule) ||\n-          isAppPageRouteModule(routeModule)\n-        ) {\n-          // An OPTIONS request to a page handler is invalid.\n-          if (\n-            req.method === 'OPTIONS' &&\n-            !is404Page &&\n-            !isAppRouteRouteModule(routeModule)\n-          ) {\n-            await sendResponse(req, res, new Response(null, { status: 400 }))\n-            return null\n-          }\n-\n-          const request = isNodeNextRequest(req) ? req.originalRequest : req\n-          const response = isNodeNextResponse(res) ? res.originalResponse : res\n-\n-          if (\n-            components.ComponentMod.handler &&\n-            process.env.NEXT_RUNTIME !== 'edge'\n-          ) {\n-            const parsedInitUrl = parseUrl(\n-              getRequestMeta(req, 'initURL') || req.url\n-            )\n-            let initPathname = parsedInitUrl.pathname || '/'\n-\n-            for (const normalizer of [\n-              this.normalizers.segmentPrefetchRSC,\n-              this.normalizers.prefetchRSC,\n-              this.normalizers.rsc,\n-            ]) {\n-              if (normalizer?.match(initPathname)) {\n-                initPathname = normalizer.normalize(initPathname)\n-              }\n-            }\n-            request.url = `${initPathname}${parsedInitUrl.search || ''}`\n-\n-            // propagate the request context for dev\n-            setRequestMeta(request, getRequestMeta(req))\n-            addRequestMeta(request, 'projectDir', this.dir)\n-            addRequestMeta(request, 'distDir', this.distDir)\n-            addRequestMeta(request, 'isIsrFallback', pagesFallback)\n-            addRequestMeta(request, 'query', query)\n-            addRequestMeta(request, 'params', opts.params)\n-            addRequestMeta(\n-              request,\n-              'ampValidator',\n-              this.renderOpts.ampValidator\n-            )\n-            addRequestMeta(request, 'minimalMode', this.minimalMode)\n-\n-            if (renderOpts.err) {\n-              addRequestMeta(request, 'invokeError', renderOpts.err)\n-            }\n-\n-            const handler: (\n-              req: ServerRequest | IncomingMessage,\n-              res: ServerResponse | HTTPServerResponse,\n-              ctx: {\n-                waitUntil: ReturnType<Server['getWaitUntil']>\n-              }\n-            ) => Promise<RenderResult> = components.ComponentMod.handler\n-\n-            const maybeDevRequest =\n-              // we need to capture fetch metrics when they are set\n-              // and can't wait for handler to resolve as the fetch\n-              // metrics are logged on response close which happens\n-              // before handler resolves\n-              process.env.NODE_ENV === 'development'\n-                ? new Proxy(request, {\n-                    get(target: any, prop) {\n-                      if (typeof target[prop] === 'function') {\n-                        return target[prop].bind(target)\n-                      }\n-                      return target[prop]\n-                    },\n-                    set(target: any, prop, value) {\n-                      if (prop === 'fetchMetrics') {\n-                        ;(req as any).fetchMetrics = value\n-                      }\n-                      target[prop] = value\n-                      return true\n-                    },\n-                  })\n-                : request\n-\n-            result = await handler(maybeDevRequest, response, {\n-              waitUntil: this.getWaitUntil(),\n-            })\n-\n-            // response is handled fully in handler\n-            return null\n-          } else {\n-            if (isPagesRouteModule(routeModule)) {\n-              // Due to the way we pass data by mutating `renderOpts`, we can't extend\n-              // the object here but only updating its `clientReferenceManifest` and\n-              // `nextFontManifest` properties.\n-              // https://github.com/vercel/next.js/blob/df7cbd904c3bd85f399d1ce90680c0ecf92d2752/packages/next/server/render.tsx#L947-L952\n-              renderOpts.nextFontManifest = this.nextFontManifest\n-              renderOpts.clientReferenceManifest =\n-                components.clientReferenceManifest\n-\n-              // Call the built-in render method on the module.\n-              try {\n-                result = await routeModule.render(\n-                  request as any,\n-                  response as any,\n-                  {\n-                    page: pathname,\n-                    params: opts.params,\n-                    query,\n-                    renderOpts,\n-                    sharedContext: {\n-                      buildId: this.buildId,\n-                      deploymentId: this.nextConfig.deploymentId,\n-                      customServer:\n-                        this.serverOptions.customServer || undefined,\n-                    },\n-                    renderContext: {\n-                      isFallback: pagesFallback,\n-                      isDraftMode: renderOpts.isDraftMode,\n-                      developmentNotFoundSourcePage: getRequestMeta(\n-                        req,\n-                        'developmentNotFoundSourcePage'\n-                      ),\n-                    },\n-                  }\n-                )\n-              } catch (err) {\n-                await this.instrumentationOnRequestError(err, req, {\n-                  routerKind: 'Pages Router',\n-                  routePath: pathname,\n-                  routeType: 'render',\n-                  revalidateReason: getRevalidateReason({\n-                    isRevalidate: isSSG,\n-                    isOnDemandRevalidate: renderOpts.isOnDemandRevalidate,\n-                  }),\n-                })\n-                throw err\n-              }\n-            } else {\n-              const module = components.routeModule as AppPageRouteModule\n-\n-              // Due to the way we pass data by mutating `renderOpts`, we can't extend the\n-              // object here but only updating its `nextFontManifest` field.\n-              // https://github.com/vercel/next.js/blob/df7cbd904c3bd85f399d1ce90680c0ecf92d2752/packages/next/server/render.tsx#L947-L952\n-              renderOpts.nextFontManifest = this.nextFontManifest\n-\n-              const context: AppPageRouteHandlerContext = {\n-                page: is404Page ? '/404' : pathname,\n-                params: opts.params,\n-                query,\n-                fallbackRouteParams,\n-                renderOpts,\n-                serverComponentsHmrCache: this.getServerComponentsHmrCache(),\n-                sharedContext: {\n-                  buildId: this.buildId,\n-                },\n-              }\n-\n-              // TODO: adapt for putting the RDC inside the postponed data\n-              // If we're in dev, and this isn't a prefetch or a server action,\n-              // we should seed the resume data cache.\n-              if (\n-                this.nextConfig.experimental.cacheComponents &&\n-                this.renderOpts.dev &&\n-                !isPrefetchRSCRequest &&\n-                !isPossibleServerAction\n-              ) {\n-                const warmup = await module.warmup(req, res, context)\n-\n-                // If the warmup is successful, we should use the resume data\n-                // cache from the warmup.\n-                if (warmup.metadata.renderResumeDataCache) {\n-                  renderOpts.renderResumeDataCache =\n-                    warmup.metadata.renderResumeDataCache\n-                }\n-              }\n-\n-              // Call the built-in render method on the module.\n-              result = await module.render(req, res, context)\n-            }\n-          }\n-        } else {\n-          throw new Error('Invariant: Unknown route module type')\n-        }\n-      } else {\n-        // If we didn't match a page, we should fallback to using the legacy\n-        // render method.\n-        result = await this.renderHTML(req, res, pathname, query, renderOpts)\n-      }\n-\n-      const { metadata } = result\n-\n-      const {\n-        cacheControl,\n-        headers = {},\n-        // Add any fetch tags that were on the page to the response headers.\n-        fetchTags: cacheTags,\n-      } = metadata\n-\n-      if (cacheTags) {\n-        headers[NEXT_CACHE_TAGS_HEADER] = cacheTags\n-      }\n-\n-      // Pull any fetch metrics from the render onto the request.\n-      ;(req as any).fetchMetrics = metadata.fetchMetrics\n-\n-      // we don't throw static to dynamic errors in dev as isSSG\n-      // is a best guess in dev since we don't have the prerender pass\n-      // to know whether the path is actually static or not\n-      if (\n-        isAppPath &&\n-        isSSG &&\n-        cacheControl?.revalidate === 0 &&\n-        !this.renderOpts.dev &&\n-        !isRoutePPREnabled\n-      ) {\n-        const staticBailoutInfo = metadata.staticBailoutInfo\n-\n-        const err = new Error(\n-          `Page changed from static to dynamic at runtime ${urlPathname}${\n-            staticBailoutInfo?.description\n-              ? `, reason: ${staticBailoutInfo.description}`\n-              : ``\n-          }` +\n-            `\\nsee more here https://nextjs.org/docs/messages/app-static-to-dynamic-error`\n-        )\n-\n-        if (staticBailoutInfo?.stack) {\n-          const stack = staticBailoutInfo.stack\n-          err.stack = err.message + stack.substring(stack.indexOf('\\n'))\n-        }\n-\n-        throw err\n-      }\n-\n-      // Based on the metadata, we can determine what kind of cache result we\n-      // should return.\n-\n-      // Handle `isNotFound`.\n-      if ('isNotFound' in metadata && metadata.isNotFound) {\n-        return {\n-          value: null,\n-          cacheControl,\n-        } satisfies ResponseCacheEntry\n-      }\n-\n-      // Handle `isRedirect`.\n-      if (metadata.isRedirect) {\n-        return {\n-          value: {\n-            kind: CachedRouteKind.REDIRECT,\n-            props: metadata.pageData ?? metadata.flightData,\n-          } satisfies CachedRedirectValue,\n-          cacheControl,\n-        } satisfies ResponseCacheEntry\n-      }\n-\n-      // Handle `isNull`.\n-      if (result.isNull) {\n-        return null\n-      }\n-\n-      // We now have a valid HTML result that we can return to the user.\n-      if (isAppPath) {\n-        return {\n-          value: {\n-            kind: CachedRouteKind.APP_PAGE,\n-            html: result,\n-            headers,\n-            rscData: metadata.flightData,\n-            postponed: metadata.postponed,\n-            status: metadata.statusCode,\n-            segmentData: metadata.segmentData,\n-          } satisfies CachedAppPageValue,\n-          cacheControl,\n-        } satisfies ResponseCacheEntry\n-      }\n-\n-      return {\n-        value: {\n-          kind: CachedRouteKind.PAGES,\n-          html: result,\n-          pageData: metadata.pageData ?? metadata.flightData,\n-          headers,\n-          status: isAppPath ? res.statusCode : undefined,\n-        } satisfies CachedPageValue,\n-        cacheControl,\n-      }\n-    }\n-\n-    let responseGenerator: ResponseGenerator = async ({\n-      hasResolved,\n-      previousCacheEntry,\n-      isRevalidating,\n-    }): Promise<ResponseCacheEntry | null> => {\n-      const isProduction = !this.renderOpts.dev\n-      const didRespond = hasResolved || res.sent\n-\n-      // If we haven't found the static paths for the route, then do it now.\n-      if (!staticPaths && isDynamic) {\n-        if (hasGetStaticPaths) {\n-          const pathsResult = await this.getStaticPaths({\n-            pathname,\n-            requestHeaders: req.headers,\n-            isAppPath,\n-            page: components.page,\n-          })\n-\n-          staticPaths = pathsResult.staticPaths\n-          fallbackMode = pathsResult.fallbackMode\n-        } else {\n-          staticPaths = undefined\n-          fallbackMode = FallbackMode.NOT_FOUND\n-        }\n-      }\n-\n-      // When serving a bot request, we want to serve a blocking render and not\n-      // the prerendered page. This ensures that the correct content is served\n-      // to the bot in the head.\n-      if (\n-        fallbackMode === FallbackMode.PRERENDER &&\n-        isBot(req.headers['user-agent'] || '')\n-      ) {\n-        fallbackMode = FallbackMode.BLOCKING_STATIC_RENDER\n-      }\n-\n-      // skip on-demand revalidate if cache is not present and\n-      // revalidate-if-generated is set\n-      if (\n-        isOnDemandRevalidate &&\n-        revalidateOnlyGenerated &&\n-        !previousCacheEntry &&\n-        !this.minimalMode\n-      ) {\n-        await this.render404(req, res)\n-        return null\n-      }\n-\n-      if (previousCacheEntry?.isStale === -1) {\n-        isOnDemandRevalidate = true\n-      }\n-\n-      // TODO: adapt for PPR\n-      // only allow on-demand revalidate for fallback: true/blocking\n-      // or for prerendered fallback: false paths\n-      if (\n-        isOnDemandRevalidate &&\n-        (fallbackMode !== FallbackMode.NOT_FOUND || previousCacheEntry)\n-      ) {\n-        fallbackMode = FallbackMode.BLOCKING_STATIC_RENDER\n-      }\n-\n-      // We use `ssgCacheKey` here as it is normalized to match the encoding\n-      // from getStaticPaths along with including the locale.\n-      //\n-      // We use the `resolvedUrlPathname` for the development case when this\n-      // is an app path since it doesn't include locale information.\n-      //\n-      // We decode the `resolvedUrlPathname` to correctly match the app path\n-      // with prerendered paths.\n-      let staticPathKey = ssgCacheKey\n-      if (!staticPathKey && opts.dev && isAppPath) {\n-        staticPathKey = decodePathParams(resolvedUrlPathname)\n-      }\n-      if (staticPathKey && query.amp) {\n-        staticPathKey = staticPathKey.replace(/\\.amp$/, '')\n-      }\n-\n-      const isPageIncludedInStaticPaths =\n-        staticPathKey && staticPaths?.includes(staticPathKey)\n-\n-      // When experimental compile is used, no pages have been prerendered,\n-      // so they should all be blocking.\n-\n-      if (this.nextConfig.experimental.isExperimentalCompile) {\n-        fallbackMode = FallbackMode.BLOCKING_STATIC_RENDER\n-      }\n-\n-      // When we did not respond from cache, we need to choose to block on\n-      // rendering or return a skeleton.\n-      //\n-      // - Data requests always block.\n-      // - Blocking mode fallback always blocks.\n-      // - Preview mode toggles all pages to be resolved in a blocking manner.\n-      // - Non-dynamic pages should block (though this is an impossible\n-      //   case in production).\n-      // - Dynamic pages should return their skeleton if not defined in\n-      //   getStaticPaths, then finish the data request on the client-side.\n-      //\n-      if (\n-        process.env.NEXT_RUNTIME !== 'edge' &&\n-        !this.minimalMode &&\n-        fallbackMode !== FallbackMode.BLOCKING_STATIC_RENDER &&\n-        staticPathKey &&\n-        !didRespond &&\n-        !isPreviewMode &&\n-        isDynamic &&\n-        (isProduction || !staticPaths || !isPageIncludedInStaticPaths)\n-      ) {\n-        if (\n-          // In development, fall through to render to handle missing\n-          // getStaticPaths.\n-          (isProduction || (staticPaths && staticPaths?.length > 0)) &&\n-          // When fallback isn't present, abort this render so we 404\n-          fallbackMode === FallbackMode.NOT_FOUND\n-        ) {\n-          throw new NoFallbackError()\n-        }\n-\n-        let fallbackResponse: ResponseCacheEntry | null | undefined\n-\n-        // If this is a pages router page.\n-        if (isPagesRouteModule(components.routeModule) && !isNextDataRequest) {\n-          // We use the response cache here to handle the revalidation and\n-          // management of the fallback shell.\n-          fallbackResponse = await this.responseCache.get(\n-            isProduction ? (locale ? `/${locale}${pathname}` : pathname) : null,\n-            // This is the response generator for the fallback shell.\n-            async ({\n-              previousCacheEntry: previousFallbackCacheEntry = null,\n-            }) => {\n-              // For the pages router, fallbacks cannot be revalidated or\n-              // generated in production. In the case of a missing fallback,\n-              // we return null, but if it's being revalidated, we just return\n-              // the previous fallback cache entry. This preserves the previous\n-              // behavior.\n-              if (isProduction) {\n-                return toResponseCacheEntry(previousFallbackCacheEntry)\n-              }\n-\n-              // We pass `undefined` and `null` as it doesn't apply to the pages\n-              // router.\n-              return doRender({\n-                postponed: undefined,\n-                // For the pages router, fallbacks can only be generated on\n-                // demand in development, so if we're not in production, and we\n-                // aren't a app path.\n-                pagesFallback: true,\n-                fallbackRouteParams: null,\n-              })\n-            },\n-            {\n-              routeKind: RouteKind.PAGES,\n-              incrementalCache,\n-              isRoutePPREnabled,\n-              isFallback: true,\n-            }\n-          )\n-        }\n-        // If this is a app router page, PPR is enabled, and PPR is also\n-        // enabled, then we should use the fallback renderer.\n-        else if (\n-          isRoutePPREnabled &&\n-          isAppPageRouteModule(components.routeModule) &&\n-          !isRSCRequest\n-        ) {\n-          // We use the response cache here to handle the revalidation and\n-          // management of the fallback shell.\n-          fallbackResponse = await this.responseCache.get(\n-            isProduction ? pathname : null,\n-            // This is the response generator for the fallback shell.\n-            async () =>\n-              doRender({\n-                // We pass `undefined` as rendering a fallback isn't resumed\n-                // here.\n-                postponed: undefined,\n-                pagesFallback: undefined,\n-                fallbackRouteParams:\n-                  // If we're in production or we're debugging the fallback\n-                  // shell then we should postpone when dynamic params are\n-                  // accessed.\n-                  isProduction || isDebugFallbackShell\n-                    ? getFallbackRouteParams(pathname)\n-                    : null,\n-              }),\n-            {\n-              routeKind: RouteKind.APP_PAGE,\n-              incrementalCache,\n-              isRoutePPREnabled,\n-              isFallback: true,\n-            }\n-          )\n-        }\n-\n-        // If the fallback response was set to null, then we should return null.\n-        if (fallbackResponse === null) return null\n-\n-        // Otherwise, if we did get a fallback response, we should return it.\n-        if (fallbackResponse) {\n-          // Remove the cache control from the response to prevent it from being\n-          // used in the surrounding cache.\n-          delete fallbackResponse.cacheControl\n-\n-          return fallbackResponse\n-        }\n-      }\n-\n-      // Only requests that aren't revalidating can be resumed. If we have the\n-      // minimal postponed data, then we should resume the render with it.\n-      const postponed =\n-        !isOnDemandRevalidate && !isRevalidating && minimalPostponed\n-          ? minimalPostponed\n-          : undefined\n-\n-      // When we're in minimal mode, if we're trying to debug the static shell,\n-      // we should just return nothing instead of resuming the dynamic render.\n-      if (\n-        (isDebugStaticShell || isDebugDynamicAccesses) &&\n-        typeof postponed !== 'undefined'\n-      ) {\n-        return {\n-          cacheControl: { revalidate: 1, expire: undefined },\n-          value: {\n-            kind: CachedRouteKind.PAGES,\n-            html: RenderResult.EMPTY,\n-            pageData: {},\n-            headers: undefined,\n-            status: undefined,\n-          } satisfies CachedPageValue,\n-        }\n-      }\n-\n-      // If this is a dynamic route with PPR enabled and the default route\n-      // matches were set, then we should pass the fallback route params to\n-      // the renderer as this is a fallback revalidation request.\n-      const fallbackRouteParams =\n-        isDynamic &&\n-        isRoutePPREnabled &&\n-        (getRequestMeta(req, 'renderFallbackShell') || isDebugFallbackShell)\n-          ? getFallbackRouteParams(pathname)\n-          : null\n-\n-      // Perform the render.\n-      return doRender({\n-        postponed,\n-        pagesFallback: undefined,\n-        fallbackRouteParams,\n-      })\n-    }\n-\n     if (\n-      process.env.NEXT_RUNTIME !== 'edge' &&\n-      // default _error module in dev doesn't have handler yet\n-      components.ComponentMod.handler &&\n-      (isPagesRouteModule(components.routeModule) ||\n-        isAppRouteRouteModule(components.routeModule) ||\n-        isAppPageRouteModule(components.routeModule))\n+      routeModule?.isDev &&\n+      isDynamicRoute(pathname) &&\n+      (components.getStaticPaths || isAppPath)\n     ) {\n-      if (\n-        routeModule?.isDev &&\n-        isDynamicRoute(pathname) &&\n-        (components.getStaticPaths || isAppPath)\n-      ) {\n-        await this.getStaticPaths({\n-          pathname,\n-          requestHeaders: req.headers,\n-          page: components.page,\n-          isAppPath,\n-        })\n-      }\n-      await doRender({\n-        postponed: undefined,\n-        pagesFallback: false,\n-        fallbackRouteParams: null,\n+      await this.getStaticPaths({\n+        pathname,\n+        urlPathname,\n+        requestHeaders: req.headers,\n+        page: components.page,\n+        isAppPath,\n       })\n-      return null\n     }\n \n-    const cacheEntry = await this.responseCache.get(\n-      ssgCacheKey,\n-      responseGenerator,\n-      {\n-        routeKind:\n-          // If the route module is not defined, we can assume it's a page being\n-          // rendered and thus check isAppPath.\n-          routeModule?.definition.kind ??\n-          (isAppPath ? RouteKind.APP_PAGE : RouteKind.PAGES),\n-        incrementalCache,\n-        isOnDemandRevalidate,\n-        isPrefetch: req.headers.purpose === 'prefetch',\n-        isRoutePPREnabled,\n-      }\n-    )\n-\n-    if (isPreviewMode) {\n-      res.setHeader(\n-        'Cache-Control',\n-        'private, no-cache, no-store, max-age=0, must-revalidate'\n-      )\n-    }\n-\n-    if (!cacheEntry) {\n-      if (\n-        ssgCacheKey &&\n-        !(isOnDemandRevalidate && revalidateOnlyGenerated) &&\n-        !isPagesRouteModule(components.routeModule) &&\n-        !isAppRouteRouteModule(components.routeModule) &&\n-        !isAppPageRouteModule(components.routeModule)\n-      ) {\n-        // A cache entry might not be generated if a response is written\n-        // in `getInitialProps` or `getServerSideProps`, but those shouldn't\n-        // have a cache key. If we do have a cache key but we don't end up\n-        // with a cache entry, then either Next.js or the application has a\n-        // bug that needs fixing.\n-        throw new Error('invariant: cache entry required but not generated')\n-      }\n-      return null\n-    }\n-\n-    const didPostpone =\n-      cacheEntry.value?.kind === CachedRouteKind.APP_PAGE &&\n-      typeof cacheEntry.value.postponed === 'string'\n-\n+    // An OPTIONS request to a page handler is invalid.\n     if (\n-      isSSG &&\n-      // We don't want to send a cache header for requests that contain dynamic\n-      // data. If this is a Dynamic RSC request or wasn't a Prefetch RSC\n-      // request, then we should set the cache header.\n-      !isDynamicRSCRequest &&\n-      (!didPostpone || isPrefetchRSCRequest)\n+      req.method === 'OPTIONS' &&\n+      !is404Page &&\n+      (!routeModule || !isAppRouteRouteModule(routeModule))\n     ) {\n-      if (!this.minimalMode) {\n-        // set x-nextjs-cache header to match the header\n-        // we set for the image-optimizer\n-        res.setHeader(\n-          'x-nextjs-cache',\n-          isOnDemandRevalidate\n-            ? 'REVALIDATED'\n-            : cacheEntry.isMiss\n-              ? 'MISS'\n-              : cacheEntry.isStale\n-                ? 'STALE'\n-                : 'HIT'\n-        )\n-      }\n-      // Set a header used by the client router to signal the response is static\n-      // and should respect the `static` cache staleTime value.\n-      res.setHeader(NEXT_IS_PRERENDER_HEADER, '1')\n-    }\n-\n-    const { value: cachedData } = cacheEntry\n-\n-    // If the cache value is an image, we should error early.\n-    if (cachedData?.kind === CachedRouteKind.IMAGE) {\n-      throw new InvariantError('SSG should not return an image cache value')\n+      await sendResponse(req, res, new Response(null, { status: 400 }))\n+      return null\n     }\n \n-    // Coerce the cache control parameter from the render.\n-    let cacheControl: CacheControl | undefined\n-\n-    // If this is a resume request in minimal mode it is streamed with dynamic\n-    // content and should not be cached.\n-    if (minimalPostponed) {\n-      cacheControl = { revalidate: 0, expire: undefined }\n-    }\n+    const request = isNodeNextRequest(req) ? req.originalRequest : req\n+    const response = isNodeNextResponse(res) ? res.originalResponse : res\n \n-    // If this is in minimal mode and this is a flight request that isn't a\n-    // prefetch request while PPR is enabled, it cannot be cached as it contains\n-    // dynamic content.\n-    else if (\n-      this.minimalMode &&\n-      isRSCRequest &&\n-      !isPrefetchRSCRequest &&\n-      isRoutePPREnabled\n-    ) {\n-      cacheControl = { revalidate: 0, expire: undefined }\n-    } else if (!this.renderOpts.dev || (hasServerProps && !isNextDataRequest)) {\n-      // If this is a preview mode request, we shouldn't cache it\n-      if (isPreviewMode) {\n-        cacheControl = { revalidate: 0, expire: undefined }\n-      }\n+    const parsedInitUrl = parseUrl(getRequestMeta(req, 'initURL') || req.url)\n+    let initPathname = parsedInitUrl.pathname || '/'\n \n-      // If this isn't SSG, then we should set change the header only if it is\n-      // not set already.\n-      else if (!isSSG) {\n-        if (!res.getHeader('Cache-Control')) {\n-          cacheControl = { revalidate: 0, expire: undefined }\n-        }\n-      }\n-\n-      // If we are rendering the 404 page we derive the cache-control\n-      // revalidate period from the value that trigged the not found\n-      // to be rendered. So if `getStaticProps` returns\n-      // { notFound: true, revalidate 60 } the revalidate period should\n-      // be 60 but if a static asset 404s directly it should have a revalidate\n-      // period of 0 so that it doesn't get cached unexpectedly by a CDN\n-      else if (is404Page) {\n-        const notFoundRevalidate = getRequestMeta(req, 'notFoundRevalidate')\n-\n-        cacheControl = {\n-          revalidate:\n-            typeof notFoundRevalidate === 'undefined' ? 0 : notFoundRevalidate,\n-          expire: undefined,\n-        }\n-      } else if (is500Page) {\n-        cacheControl = { revalidate: 0, expire: undefined }\n-      } else if (cacheEntry.cacheControl) {\n-        // If the cache entry has a cache control with a revalidate value that's\n-        // a number, use it.\n-        if (typeof cacheEntry.cacheControl.revalidate === 'number') {\n-          if (cacheEntry.cacheControl.revalidate < 1) {\n-            throw new Error(\n-              `Invalid revalidate configuration provided: ${cacheEntry.cacheControl.revalidate} < 1`\n-            )\n-          }\n-\n-          cacheControl = {\n-            revalidate: cacheEntry.cacheControl.revalidate,\n-            expire:\n-              cacheEntry.cacheControl?.expire ?? this.nextConfig.expireTime,\n-          }\n-        }\n-        // Otherwise if the revalidate value is false, then we should use the\n-        // cache time of one year.\n-        else {\n-          cacheControl = { revalidate: CACHE_ONE_YEAR, expire: undefined }\n-        }\n+    for (const normalizer of [\n+      this.normalizers.segmentPrefetchRSC,\n+      this.normalizers.prefetchRSC,\n+      this.normalizers.rsc,\n+    ]) {\n+      if (normalizer?.match(initPathname)) {\n+        initPathname = normalizer.normalize(initPathname)\n       }\n     }\n+    request.url = `${initPathname}${parsedInitUrl.search || ''}`\n \n-    cacheEntry.cacheControl = cacheControl\n-\n-    if (\n-      typeof segmentPrefetchHeader === 'string' &&\n-      cachedData?.kind === CachedRouteKind.APP_PAGE &&\n-      cachedData.segmentData\n-    ) {\n-      // This is a prefetch request issued by the client Segment Cache. These\n-      // should never reach the application layer (lambda). We should either\n-      // respond from the cache (HIT) or respond with 204 No Content (MISS).\n-\n-      // Set a header to indicate that PPR is enabled for this route. This\n-      // lets the client distinguish between a regular cache miss and a cache\n-      // miss due to PPR being disabled. In other contexts this header is used\n-      // to indicate that the response contains dynamic data, but here we're\n-      // only using it to indicate that the feature is enabled  the segment\n-      // response itself contains whether the data is dynamic.\n-      res.setHeader(NEXT_DID_POSTPONE_HEADER, '2')\n-\n-      // Add the cache tags header to the response if it exists and we're in\n-      // minimal mode while rendering a static page.\n-      const tags = cachedData.headers?.[NEXT_CACHE_TAGS_HEADER]\n-      if (this.minimalMode && isSSG && tags && typeof tags === 'string') {\n-        res.setHeader(NEXT_CACHE_TAGS_HEADER, tags)\n-      }\n-\n-      const matchedSegment = cachedData.segmentData.get(segmentPrefetchHeader)\n-      if (matchedSegment !== undefined) {\n-        // Cache hit\n-        return {\n-          body: RenderResult.fromStatic(\n-            matchedSegment,\n-            RSC_CONTENT_TYPE_HEADER\n-          ),\n-          // TODO: Eventually this should use cache control of the individual\n-          // segment, not the whole page.\n-          cacheControl: cacheEntry.cacheControl,\n-        }\n-      }\n-\n-      // Cache miss. Either a cache entry for this route has not been generated\n-      // (which technically should not be possible when PPR is enabled, because\n-      // at a minimum there should always be a fallback entry) or there's no\n-      // match for the requested segment. Respond with a 204 No Content. We\n-      // don't bother to respond with 404, because these requests are only\n-      // issued as part of a prefetch.\n-      res.statusCode = 204\n-      return {\n-        body: RenderResult.EMPTY,\n-        cacheControl: cacheEntry?.cacheControl,\n-      }\n-    }\n+    // propagate the request context for dev\n+    setRequestMeta(request, getRequestMeta(req))\n+    addRequestMeta(request, 'distDir', this.distDir)\n+    addRequestMeta(request, 'query', query)\n+    addRequestMeta(request, 'params', opts.params)\n+    addRequestMeta(request, 'ampValidator', this.renderOpts.ampValidator)\n+    addRequestMeta(request, 'minimalMode', this.minimalMode)\n \n-    // If there's a callback for `onCacheEntry`, call it with the cache entry\n-    // and the revalidate options.\n-    const onCacheEntry = getRequestMeta(req, 'onCacheEntry')\n-    if (onCacheEntry) {\n-      const finished = await onCacheEntry(\n-        {\n-          ...cacheEntry,\n-          // TODO: remove this when upstream doesn't\n-          // always expect this value to be \"PAGE\"\n-          value: {\n-            ...cacheEntry.value,\n-            kind:\n-              cacheEntry.value?.kind === CachedRouteKind.APP_PAGE\n-                ? 'PAGE'\n-                : cacheEntry.value?.kind,\n-          },\n-        },\n-        {\n-          url: getRequestMeta(req, 'initURL'),\n-        }\n-      )\n-      if (finished) {\n-        // TODO: maybe we have to end the request?\n-        return null\n-      }\n+    if (opts.err) {\n+      addRequestMeta(request, 'invokeError', opts.err)\n     }\n \n-    if (!cachedData) {\n-      // add revalidate metadata before rendering 404 page\n-      // so that we can use this as source of truth for the\n-      // cache-control header instead of what the 404 page returns\n-      // for the revalidate value\n-      addRequestMeta(\n-        req,\n-        'notFoundRevalidate',\n-        cacheEntry.cacheControl?.revalidate\n-      )\n-\n-      // If cache control is already set on the response we don't\n-      // override it to allow users to customize it via next.config\n-      if (cacheEntry.cacheControl && !res.getHeader('Cache-Control')) {\n-        res.setHeader(\n-          'Cache-Control',\n-          getCacheControlHeader(cacheEntry.cacheControl)\n-        )\n-      }\n-      if (isNextDataRequest) {\n-        res.statusCode = 404\n-        res.body('{\"notFound\":true}').send()\n-        return null\n+    const handler: (\n+      req: ServerRequest | IncomingMessage,\n+      res: ServerResponse | HTTPServerResponse,\n+      ctx: {\n+        waitUntil: ReturnType<Server['getWaitUntil']>\n       }\n+    ) => Promise<void> = components.ComponentMod.handler\n \n-      if (this.renderOpts.dev) {\n-        addRequestMeta(req, 'developmentNotFoundSourcePage', pathname)\n-      }\n-      await this.render404(req, res, { pathname, query }, false)\n-      return null\n-    } else if (cachedData.kind === CachedRouteKind.REDIRECT) {\n-      // If cache control is already set on the response we don't\n-      // override it to allow users to customize it via next.config\n-      if (cacheEntry.cacheControl && !res.getHeader('Cache-Control')) {\n-        res.setHeader(\n-          'Cache-Control',\n-          getCacheControlHeader(cacheEntry.cacheControl)\n-        )\n-      }\n-\n-      if (isNextDataRequest) {\n-        return {\n-          body: RenderResult.fromStatic(\n-            JSON.stringify(cachedData.props),\n-            JSON_CONTENT_TYPE_HEADER\n-          ),\n-          cacheControl: cacheEntry.cacheControl,\n-        }\n-      } else {\n-        await handleRedirect(cachedData.props)\n-        return null\n-      }\n-    } else if (cachedData.kind === CachedRouteKind.APP_ROUTE) {\n-      // this is handled inside the app_route handler fully\n-      throw new Error(`Invariant: unexpected APP_ROUTE cache data`)\n-    } else if (cachedData.kind === CachedRouteKind.APP_PAGE) {\n-      // If the request has a postponed state and it's a resume request we\n-      // should error.\n-      if (didPostpone && minimalPostponed) {\n-        throw new Error(\n-          'Invariant: postponed state should not be present on a resume request'\n-        )\n-      }\n-\n-      if (cachedData.headers) {\n-        const headers = { ...cachedData.headers }\n-\n-        if (!this.minimalMode || !isSSG) {\n-          delete headers[NEXT_CACHE_TAGS_HEADER]\n-        }\n-\n-        for (let [key, value] of Object.entries(headers)) {\n-          if (typeof value === 'undefined') continue\n-\n-          if (Array.isArray(value)) {\n-            for (const v of value) {\n-              res.appendHeader(key, v)\n-            }\n-          } else if (typeof value === 'number') {\n-            value = value.toString()\n-            res.appendHeader(key, value)\n-          } else {\n-            res.appendHeader(key, value)\n-          }\n-        }\n-      }\n-\n-      // Add the cache tags header to the response if it exists and we're in\n-      // minimal mode while rendering a static page.\n-      const tags = cachedData.headers?.[NEXT_CACHE_TAGS_HEADER]\n-      if (this.minimalMode && isSSG && tags && typeof tags === 'string') {\n-        res.setHeader(NEXT_CACHE_TAGS_HEADER, tags)\n-      }\n-\n-      // If the request is a data request, then we shouldn't set the status code\n-      // from the response because it should always be 200. This should be gated\n-      // behind the experimental PPR flag.\n-      if (cachedData.status && (!isRSCRequest || !isRoutePPREnabled)) {\n-        res.statusCode = cachedData.status\n-      }\n-\n-      // Redirect information is encoded in RSC payload, so we don't need to use redirect status codes\n-      if (\n-        !this.minimalMode &&\n-        cachedData.status &&\n-        RedirectStatusCode[cachedData.status] &&\n-        isRSCRequest\n-      ) {\n-        res.statusCode = 200\n-      }\n-\n-      // Mark that the request did postpone.\n-      if (didPostpone) {\n-        res.setHeader(NEXT_DID_POSTPONE_HEADER, '1')\n-      }\n-\n-      // we don't go through this block when preview mode is true\n-      // as preview mode is a dynamic request (bypasses cache) and doesn't\n-      // generate both HTML and payloads in the same request so continue to just\n-      // return the generated payload\n-      if (isRSCRequest && !isPreviewMode) {\n-        // If this is a dynamic RSC request, then stream the response.\n-        if (typeof cachedData.rscData === 'undefined') {\n-          if (cachedData.postponed) {\n-            throw new Error('Invariant: Expected postponed to be undefined')\n-          }\n-\n-          return {\n-            body: cachedData.html,\n-            // Dynamic RSC responses cannot be cached, even if they're\n-            // configured with `force-static` because we have no way of\n-            // distinguishing between `force-static` and pages that have no\n-            // postponed state.\n-            // TODO: distinguish `force-static` from pages with no postponed state (static)\n-            cacheControl: isDynamicRSCRequest\n-              ? { revalidate: 0, expire: undefined }\n-              : cacheEntry.cacheControl,\n-          }\n-        }\n-\n-        // As this isn't a prefetch request, we should serve the static flight\n-        // data.\n-        return {\n-          body: RenderResult.fromStatic(\n-            cachedData.rscData,\n-            RSC_CONTENT_TYPE_HEADER\n-          ),\n-          cacheControl: cacheEntry.cacheControl,\n-        }\n-      }\n-\n-      // This is a request for HTML data.\n-      let body = cachedData.html\n-\n-      // If there's no postponed state, we should just serve the HTML. This\n-      // should also be the case for a resume request because it's completed\n-      // as a server render (rather than a static render).\n-      if (!didPostpone || this.minimalMode) {\n-        return {\n-          body,\n-          cacheControl: cacheEntry.cacheControl,\n-        }\n-      }\n-\n-      // If we're debugging the static shell or the dynamic API accesses, we\n-      // should just serve the HTML without resuming the render. The returned\n-      // HTML will be the static shell so all the Dynamic API's will be used\n-      // during static generation.\n-      if (isDebugStaticShell || isDebugDynamicAccesses) {\n-        // Since we're not resuming the render, we need to at least add the\n-        // closing body and html tags to create valid HTML.\n-        body.push(\n-          new ReadableStream({\n-            start(controller) {\n-              controller.enqueue(ENCODED_TAGS.CLOSED.BODY_AND_HTML)\n-              controller.close()\n+    const maybeDevRequest =\n+      // we need to capture fetch metrics when they are set\n+      // and can't wait for handler to resolve as the fetch\n+      // metrics are logged on response close which happens\n+      // before handler resolves\n+      process.env.NODE_ENV === 'development'\n+        ? new Proxy(request, {\n+            get(target: any, prop) {\n+              if (typeof target[prop] === 'function') {\n+                return target[prop].bind(target)\n+              }\n+              return target[prop]\n+            },\n+            set(target: any, prop, value) {\n+              if (prop === 'fetchMetrics') {\n+                ;(req as any).fetchMetrics = value\n+              }\n+              target[prop] = value\n+              return true\n             },\n           })\n-        )\n-\n-        return {\n-          body,\n-          cacheControl: { revalidate: 0, expire: undefined },\n-        }\n-      }\n-\n-      // This request has postponed, so let's create a new transformer that the\n-      // dynamic data can pipe to that will attach the dynamic data to the end\n-      // of the response.\n-      const transformer = new TransformStream<Uint8Array, Uint8Array>()\n-      body.push(transformer.readable)\n-\n-      // Perform the render again, but this time, provide the postponed state.\n-      // We don't await because we want the result to start streaming now, and\n-      // we've already chained the transformer's readable to the render result.\n-      doRender({\n-        postponed: cachedData.postponed,\n-        pagesFallback: undefined,\n-        // This is a resume render, not a fallback render, so we don't need to\n-        // set this.\n-        fallbackRouteParams: null,\n-      })\n-        .then(async (result) => {\n-          if (!result) {\n-            throw new Error('Invariant: expected a result to be returned')\n-          }\n-\n-          if (result.value?.kind !== CachedRouteKind.APP_PAGE) {\n-            throw new Error(\n-              `Invariant: expected a page response, got ${result.value?.kind}`\n-            )\n-          }\n+        : request\n \n-          // Pipe the resume result to the transformer.\n-          await result.value.html.pipeTo(transformer.writable)\n-        })\n-        .catch((err) => {\n-          // An error occurred during piping or preparing the render, abort\n-          // the transformers writer so we can terminate the stream.\n-          transformer.writable.abort(err).catch((e) => {\n-            console.error(\"couldn't abort transformer\", e)\n-          })\n-        })\n+    await handler(maybeDevRequest, response, {\n+      waitUntil: this.getWaitUntil(),\n+    })\n \n-      return {\n-        body,\n-        // We don't want to cache the response if it has postponed data because\n-        // the response being sent to the client it's dynamic parts are streamed\n-        // to the client on the same request.\n-        cacheControl: { revalidate: 0, expire: undefined },\n-      }\n-    } else if (isNextDataRequest) {\n-      return {\n-        body: RenderResult.fromStatic(\n-          JSON.stringify(cachedData.pageData),\n-          JSON_CONTENT_TYPE_HEADER\n-        ),\n-        cacheControl: cacheEntry.cacheControl,\n-      }\n-    } else {\n-      return {\n-        body: cachedData.html,\n-        cacheControl: cacheEntry.cacheControl,\n-      }\n-    }\n+    // response is handled fully in handler\n+    return null\n   }\n \n   private stripNextDataPath(path: string, stripLocale = true) {\n@@ -3857,10 +2543,7 @@ export default abstract class Server<\n       const isWrappedError = err instanceof WrappedBuildError\n \n       if (!isWrappedError) {\n-        if (\n-          (this.minimalMode && process.env.NEXT_RUNTIME !== 'edge') ||\n-          this.renderOpts.dev\n-        ) {\n+        if (this.minimalMode || this.renderOpts.dev) {\n           if (isError(err)) err.page = page\n           throw err\n         }"
        },
        {
            "sha": "fdba36790f712df31ac3ede7b1b29e57c10ecda0",
            "filename": "packages/next/src/server/dev/next-dev-server.ts",
            "status": "modified",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/955adbb05778e732c3d43c5afc5880c18feaaeb2/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fnext-dev-server.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/955adbb05778e732c3d43c5afc5880c18feaaeb2/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fnext-dev-server.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fnext-dev-server.ts?ref=955adbb05778e732c3d43c5afc5880c18feaaeb2",
            "patch": "@@ -784,11 +784,13 @@ export default class DevServer extends Server {\n \n   protected async getStaticPaths({\n     pathname,\n+    urlPathname,\n     requestHeaders,\n     page,\n     isAppPath,\n   }: {\n     pathname: string\n+    urlPathname: string\n     requestHeaders: IncrementalCache['requestHeaders']\n     page: string\n     isAppPath: boolean\n@@ -856,6 +858,22 @@ export default class DevServer extends Server {\n         const { prerenderedRoutes: staticPaths, fallbackMode: fallback } =\n           res.value\n \n+        if (isAppPath) {\n+          if (this.nextConfig.output === 'export') {\n+            if (!staticPaths) {\n+              throw new Error(\n+                `Page \"${page}\" is missing exported function \"generateStaticParams()\", which is required with \"output: export\" config.`\n+              )\n+            }\n+\n+            if (!staticPaths.some((item) => item.pathname === urlPathname)) {\n+              throw new Error(\n+                `Page \"${page}\" is missing param \"${pathname}\" in \"generateStaticParams()\", which is required with \"output: export\" config.`\n+              )\n+            }\n+          }\n+        }\n+\n         if (!isAppPath && this.nextConfig.output === 'export') {\n           if (fallback === FallbackMode.BLOCKING_STATIC_RENDER) {\n             throw new Error("
        },
        {
            "sha": "f24bdeffd68728b6b9cee0fa2e7b7c66269f9bf6",
            "filename": "packages/next/src/server/lib/router-server.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/955adbb05778e732c3d43c5afc5880c18feaaeb2/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-server.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/955adbb05778e732c3d43c5afc5880c18feaaeb2/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-server.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-server.ts?ref=955adbb05778e732c3d43c5afc5880c18feaaeb2",
            "patch": "@@ -178,6 +178,8 @@ export async function initialize(opts: {\n     require('./render-server') as typeof import('./render-server')\n \n   const requestHandlerImpl: WorkerRequestHandler = async (req, res) => {\n+    addRequestMeta(req, 'relativeProjectDir', relativeProjectDir)\n+\n     // internal headers should not be honored by the request handler\n     if (!process.env.NEXT_PRIVATE_TEST_HEADERS) {\n       filterInternalHeaders(req.headers)"
        },
        {
            "sha": "338df2ce1edd6f8247a5abafe71d40d44bfe3f67",
            "filename": "packages/next/src/server/next-server.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 3,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/955adbb05778e732c3d43c5afc5880c18feaaeb2/packages%2Fnext%2Fsrc%2Fserver%2Fnext-server.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/955adbb05778e732c3d43c5afc5880c18feaaeb2/packages%2Fnext%2Fsrc%2Fserver%2Fnext-server.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fnext-server.ts?ref=955adbb05778e732c3d43c5afc5880c18feaaeb2",
            "patch": "@@ -661,7 +661,11 @@ export default class NextNodeServer extends BaseServer<\n         }\n       ) => Promise<void>\n     }\n-    addRequestMeta(req.originalRequest, 'projectDir', this.dir)\n+    addRequestMeta(\n+      req.originalRequest,\n+      'relativeProjectDir',\n+      relative(process.cwd(), this.dir)\n+    )\n     addRequestMeta(req.originalRequest, 'distDir', this.distDir)\n     await module.handler(req.originalRequest, res.originalResponse, {\n       waitUntil: this.getWaitUntil(),\n@@ -1095,8 +1099,8 @@ export default class NextNodeServer extends BaseServer<\n     // such.\n     addRequestMeta(req, 'bubbleNoFallback', true)\n \n-    // TODO: this is only needed until route-module can handle\n-    // rendering/serving the 404 directly with next-server\n+    // This is needed to expose render404 and nextConfig\n+    // for environments without router-server\n     if (!routerServerGlobal[RouterServerContextSymbol]) {\n       routerServerGlobal[RouterServerContextSymbol] = {}\n     }"
        },
        {
            "sha": "3eb892264f52243be865c283398dc327f2887212",
            "filename": "packages/next/src/server/request-meta.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 7,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/955adbb05778e732c3d43c5afc5880c18feaaeb2/packages%2Fnext%2Fsrc%2Fserver%2Frequest-meta.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/955adbb05778e732c3d43c5afc5880c18feaaeb2/packages%2Fnext%2Fsrc%2Fserver%2Frequest-meta.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest-meta.ts?ref=955adbb05778e732c3d43c5afc5880c18feaaeb2",
            "patch": "@@ -197,20 +197,15 @@ export interface RequestMeta {\n   defaultLocale?: string\n \n   /**\n-   * The project dir the server is running in\n+   * The relative project dir the server is running in from project root\n    */\n-  projectDir?: string\n+  relativeProjectDir?: string\n \n   /**\n    * The dist directory the server is currently using\n    */\n   distDir?: string\n \n-  /**\n-   * Whether we are generating the fallback version of the page in dev mode\n-   */\n-  isIsrFallback?: boolean\n-\n   /**\n    * The query after resolving routes\n    */"
        },
        {
            "sha": "0e3e3c09f3c037fe2ffc7ffa9ba2751a99c2de17",
            "filename": "packages/next/src/server/route-modules/app-route/module.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/955adbb05778e732c3d43c5afc5880c18feaaeb2/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Fapp-route%2Fmodule.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/955adbb05778e732c3d43c5afc5880c18feaaeb2/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Fapp-route%2Fmodule.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Fapp-route%2Fmodule.ts?ref=955adbb05778e732c3d43c5afc5880c18feaaeb2",
            "patch": "@@ -217,11 +217,11 @@ export class AppRouteRouteModule extends RouteModule<\n     userland,\n     definition,\n     distDir,\n-    projectDir,\n+    relativeProjectDir,\n     resolvedPagePath,\n     nextConfigOutput,\n   }: AppRouteRouteModuleOptions) {\n-    super({ userland, definition, distDir, projectDir })\n+    super({ userland, definition, distDir, relativeProjectDir })\n \n     this.resolvedPagePath = resolvedPagePath\n     this.nextConfigOutput = nextConfigOutput"
        },
        {
            "sha": "ffcfa4f4641a02788960f0ba3268aabf91dc0a7e",
            "filename": "packages/next/src/server/route-modules/pages-api/module.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 3,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/955adbb05778e732c3d43c5afc5880c18feaaeb2/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Fpages-api%2Fmodule.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/955adbb05778e732c3d43c5afc5880c18feaaeb2/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Fpages-api%2Fmodule.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Fpages-api%2Fmodule.ts?ref=955adbb05778e732c3d43c5afc5880c18feaaeb2",
            "patch": "@@ -7,6 +7,7 @@ import type { RouteModuleOptions } from '../route-module'\n \n import { RouteModule, type RouteModuleHandleContext } from '../route-module'\n import { apiResolver } from '../../api-utils/node/api-resolver'\n+import type { RevalidateFn } from '../../lib/router-utils/router-server-context'\n \n type PagesAPIHandleFn = (\n   req: IncomingMessage,\n@@ -94,9 +95,10 @@ type PagesAPIRouteHandlerContext = RouteModuleHandleContext & {\n   multiZoneDraftMode?: boolean\n \n   /**\n-   * The relative project directory\n+   * Internal revalidate function to avoid revalidating\n+   * over the network\n    */\n-  projectDir: string\n+  internalRevalidate?: RevalidateFn\n }\n \n export type PagesAPIRouteModuleOptions = RouteModuleOptions<\n@@ -149,7 +151,7 @@ export class PagesAPIRouteModule extends RouteModule<\n         hostname: context.hostname,\n         multiZoneDraftMode: context.multiZoneDraftMode,\n         dev: context.dev,\n-        projectDir: context.projectDir,\n+        internalRevalidate: context.internalRevalidate,\n       },\n       context.propagateError,\n       context.dev,"
        },
        {
            "sha": "23f7ecd5286091b6acf1f331c4f989d4da279e97",
            "filename": "packages/next/src/server/route-modules/pages/builtin/_error.tsx",
            "status": "modified",
            "additions": 11,
            "deletions": 2,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/955adbb05778e732c3d43c5afc5880c18feaaeb2/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Fpages%2Fbuiltin%2F_error.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/955adbb05778e732c3d43c5afc5880c18feaaeb2/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Fpages%2Fbuiltin%2F_error.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Fpages%2Fbuiltin%2F_error.tsx?ref=955adbb05778e732c3d43c5afc5880c18feaaeb2",
            "patch": "@@ -1,10 +1,11 @@\n-import Document from '../../../../pages/_document'\n import App from '../../../../pages/_app'\n+import Document from '../../../../pages/_document'\n import { RouteKind } from '../../../route-kind'\n \n import * as moduleError from '../../../../pages/_error'\n \n import PagesRouteModule from '../module'\n+import { getHandler } from '../pages-handler'\n \n export const routeModule = new PagesRouteModule({\n   // TODO: add descriptor for internal error page\n@@ -16,10 +17,18 @@ export const routeModule = new PagesRouteModule({\n     bundlePath: '',\n   },\n   distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n-  projectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n+  relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n   components: {\n     App,\n     Document,\n   },\n   userland: moduleError,\n })\n+\n+export const handler = getHandler({\n+  srcPage: '/_error',\n+  routeModule,\n+  userland: moduleError,\n+  config: {},\n+  isFallbackError: true,\n+})"
        },
        {
            "sha": "e888bfc9984c7dc9fef523646a572ac2d0023479",
            "filename": "packages/next/src/server/route-modules/pages/pages-handler.ts",
            "status": "added",
            "additions": 767,
            "deletions": 0,
            "changes": 767,
            "blob_url": "https://github.com/vercel/next.js/blob/955adbb05778e732c3d43c5afc5880c18feaaeb2/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Fpages%2Fpages-handler.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/955adbb05778e732c3d43c5afc5880c18feaaeb2/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Fpages%2Fpages-handler.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Fpages%2Fpages-handler.ts?ref=955adbb05778e732c3d43c5afc5880c18feaaeb2",
            "patch": "@@ -0,0 +1,767 @@\n+import type { IncomingMessage, ServerResponse } from 'node:http'\n+import type { ParsedUrlQuery } from 'node:querystring'\n+import { RouteKind } from '../../route-kind'\n+import { BaseServerSpan } from '../../lib/trace/constants'\n+import { getTracer, SpanKind, type Span } from '../../lib/trace/tracer'\n+import { formatUrl } from '../../../shared/lib/router/utils/format-url'\n+import { addRequestMeta, getRequestMeta } from '../../request-meta'\n+import { interopDefault } from '../../app-render/interop-default'\n+import { getRevalidateReason } from '../../instrumentation/utils'\n+import { normalizeDataPath } from '../../../shared/lib/page-path/normalize-data-path'\n+import {\n+  CachedRouteKind,\n+  type CachedPageValue,\n+  type CachedRedirectValue,\n+  type ResponseCacheEntry,\n+  type ResponseGenerator,\n+} from '../../response-cache'\n+\n+import {\n+  getCacheControlHeader,\n+  type CacheControl,\n+} from '../../lib/cache-control'\n+import { normalizeRepeatedSlashes } from '../../../shared/lib/utils'\n+import { getRedirectStatus } from '../../../lib/redirect-status'\n+import {\n+  CACHE_ONE_YEAR,\n+  HTML_CONTENT_TYPE_HEADER,\n+  JSON_CONTENT_TYPE_HEADER,\n+} from '../../../lib/constants'\n+import path from 'path'\n+import { sendRenderResult } from '../../send-payload'\n+import RenderResult from '../../render-result'\n+import { toResponseCacheEntry } from '../../response-cache/utils'\n+import { NoFallbackError } from '../../../shared/lib/no-fallback-error.external'\n+import { RedirectStatusCode } from '../../../client/components/redirect-status-code'\n+import { isBot } from '../../../shared/lib/router/utils/is-bot'\n+import { addPathPrefix } from '../../../shared/lib/router/utils/add-path-prefix'\n+import { removeTrailingSlash } from '../../../shared/lib/router/utils/remove-trailing-slash'\n+import type { PagesRouteModule } from './module.compiled'\n+import type {\n+  GetServerSideProps,\n+  GetStaticPaths,\n+  GetStaticProps,\n+} from '../../../types'\n+\n+export const getHandler = ({\n+  srcPage: originalSrcPage,\n+  config,\n+  userland,\n+  routeModule,\n+  isFallbackError,\n+  getStaticPaths,\n+  getStaticProps,\n+  getServerSideProps,\n+}: {\n+  srcPage: string\n+  config: Record<string, any> | undefined\n+  userland: any\n+  isFallbackError?: boolean\n+  routeModule: PagesRouteModule\n+  getStaticProps?: GetStaticProps\n+  getStaticPaths?: GetStaticPaths\n+  getServerSideProps?: GetServerSideProps\n+}) => {\n+  return async function handler(\n+    req: IncomingMessage,\n+    res: ServerResponse,\n+    ctx: {\n+      waitUntil: (prom: Promise<void>) => void\n+    }\n+  ): Promise<void> {\n+    let srcPage = originalSrcPage\n+    // turbopack doesn't normalize `/index` in the page name\n+    // so we need to to process dynamic routes properly\n+    // TODO: fix turbopack providing differing value from webpack\n+    if (process.env.TURBOPACK) {\n+      srcPage = srcPage.replace(/\\/index$/, '') || '/'\n+    } else if (srcPage === '/index') {\n+      // we always normalize /index specifically\n+      srcPage = '/'\n+    }\n+    const multiZoneDraftMode = process.env\n+      .__NEXT_MULTI_ZONE_DRAFT_MODE as any as boolean\n+\n+    const prepareResult = await routeModule.prepare(req, res, {\n+      srcPage,\n+      multiZoneDraftMode,\n+    })\n+\n+    if (!prepareResult) {\n+      res.statusCode = 400\n+      res.end('Bad Request')\n+      ctx.waitUntil?.(Promise.resolve())\n+      return\n+    }\n+\n+    const {\n+      buildId,\n+      query,\n+      params,\n+      parsedUrl,\n+      originalQuery,\n+      originalPathname,\n+      buildManifest,\n+      fallbackBuildManifest,\n+      nextFontManifest,\n+      serverFilesManifest,\n+      reactLoadableManifest,\n+      prerenderManifest,\n+      isDraftMode,\n+      isOnDemandRevalidate,\n+      revalidateOnlyGenerated,\n+      locale,\n+      locales,\n+      defaultLocale,\n+      routerServerContext,\n+      nextConfig,\n+      resolvedPathname,\n+    } = prepareResult\n+\n+    const isExperimentalCompile =\n+      serverFilesManifest?.config?.experimental?.isExperimentalCompile\n+\n+    const hasServerProps = Boolean(getServerSideProps)\n+    const hasStaticProps = Boolean(getStaticProps)\n+    const hasStaticPaths = Boolean(getStaticPaths)\n+    const hasGetInitialProps = Boolean(\n+      (userland.default || userland).getInitialProps\n+    )\n+    const isAmp = query.amp && config?.amp\n+    let cacheKey: null | string = null\n+    let isIsrFallback = false\n+    let isNextDataRequest =\n+      prepareResult.isNextDataRequest && (hasStaticProps || hasServerProps)\n+\n+    const is404Page = srcPage === '/404'\n+    const is500Page = srcPage === '/500'\n+    const isErrorPage = srcPage === '/_error'\n+\n+    if (!routeModule.isDev && !isDraftMode && hasStaticProps) {\n+      cacheKey = `${locale ? `/${locale}` : ''}${\n+        (srcPage === '/' || resolvedPathname === '/') && locale\n+          ? ''\n+          : resolvedPathname\n+      }${isAmp ? '.amp' : ''}`\n+\n+      if (is404Page || is500Page || isErrorPage) {\n+        cacheKey = `${locale ? `/${locale}` : ''}${srcPage}${isAmp ? '.amp' : ''}`\n+      }\n+\n+      // ensure /index and / is normalized to one key\n+      cacheKey = cacheKey === '/index' ? '/' : cacheKey\n+    }\n+\n+    if (hasStaticPaths && !isDraftMode) {\n+      const decodedPathname = removeTrailingSlash(\n+        locale\n+          ? addPathPrefix(resolvedPathname, `/${locale}`)\n+          : resolvedPathname\n+      )\n+      const isPrerendered =\n+        Boolean(prerenderManifest.routes[decodedPathname]) ||\n+        prerenderManifest.notFoundRoutes.includes(decodedPathname)\n+\n+      const prerenderInfo = prerenderManifest.dynamicRoutes[srcPage]\n+\n+      if (prerenderInfo) {\n+        if (prerenderInfo.fallback === false && !isPrerendered) {\n+          throw new NoFallbackError()\n+        }\n+\n+        if (\n+          typeof prerenderInfo.fallback === 'string' &&\n+          !isPrerendered &&\n+          !isNextDataRequest\n+        ) {\n+          isIsrFallback = true\n+        }\n+      }\n+    }\n+\n+    // When serving a bot request, we want to serve a blocking render and not\n+    // the prerendered page. This ensures that the correct content is served\n+    // to the bot in the head.\n+    if (\n+      (isIsrFallback && isBot(req.headers['user-agent'] || '')) ||\n+      getRequestMeta(req, 'minimalMode')\n+    ) {\n+      isIsrFallback = false\n+    }\n+\n+    const tracer = getTracer()\n+    const activeSpan = tracer.getActiveScopeSpan()\n+\n+    try {\n+      const method = req.method || 'GET'\n+\n+      const resolvedUrl = formatUrl({\n+        pathname: nextConfig.trailingSlash\n+          ? parsedUrl.pathname\n+          : removeTrailingSlash(parsedUrl.pathname || '/'),\n+        // make sure to only add query values from original URL\n+        query: hasStaticProps ? {} : originalQuery,\n+      })\n+\n+      const publicRuntimeConfig: Record<string, string> =\n+        routerServerContext?.publicRuntimeConfig ||\n+        nextConfig.publicRuntimeConfig\n+\n+      const handleResponse = async (span?: Span) => {\n+        const responseGenerator: ResponseGenerator = async ({\n+          previousCacheEntry,\n+        }) => {\n+          const doRender = async () => {\n+            try {\n+              return await routeModule\n+                .render(req, res, {\n+                  query:\n+                    hasStaticProps && !isExperimentalCompile\n+                      ? ({\n+                          ...params,\n+                          ...(isAmp\n+                            ? {\n+                                amp: query.amp,\n+                              }\n+                            : {}),\n+                        } as ParsedUrlQuery)\n+                      : {\n+                          ...query,\n+                          ...params,\n+                        },\n+                  params,\n+                  page: srcPage,\n+                  renderContext: {\n+                    isDraftMode,\n+                    isFallback: isIsrFallback,\n+                    developmentNotFoundSourcePage: getRequestMeta(\n+                      req,\n+                      'developmentNotFoundSourcePage'\n+                    ),\n+                  },\n+                  sharedContext: {\n+                    buildId,\n+                    customServer:\n+                      Boolean(routerServerContext?.isCustomServer) || undefined,\n+                    deploymentId: process.env.NEXT_DEPLOYMENT_ID,\n+                  },\n+                  renderOpts: {\n+                    params,\n+                    routeModule,\n+                    page: srcPage,\n+                    pageConfig: config || {},\n+                    Component: interopDefault(userland),\n+                    ComponentMod: userland,\n+                    getStaticProps,\n+                    getStaticPaths,\n+                    getServerSideProps,\n+                    supportsDynamicResponse: !hasStaticProps,\n+                    buildManifest: isFallbackError\n+                      ? fallbackBuildManifest\n+                      : buildManifest,\n+                    nextFontManifest,\n+                    reactLoadableManifest,\n+\n+                    assetPrefix: nextConfig.assetPrefix,\n+                    previewProps: prerenderManifest.preview,\n+                    images: nextConfig.images as any,\n+                    nextConfigOutput: nextConfig.output,\n+                    optimizeCss: Boolean(nextConfig.experimental.optimizeCss),\n+                    nextScriptWorkers: Boolean(\n+                      nextConfig.experimental.nextScriptWorkers\n+                    ),\n+                    domainLocales: nextConfig.i18n?.domains,\n+                    crossOrigin: nextConfig.crossOrigin,\n+\n+                    multiZoneDraftMode,\n+                    basePath: nextConfig.basePath,\n+                    canonicalBase: nextConfig.amp.canonicalBase || '',\n+                    ampOptimizerConfig: nextConfig.experimental.amp?.optimizer,\n+                    disableOptimizedLoading:\n+                      nextConfig.experimental.disableOptimizedLoading,\n+                    largePageDataBytes:\n+                      nextConfig.experimental.largePageDataBytes,\n+                    // Only the `publicRuntimeConfig` key is exposed to the client side\n+                    // It'll be rendered as part of __NEXT_DATA__ on the client side\n+                    runtimeConfig:\n+                      Object.keys(publicRuntimeConfig).length > 0\n+                        ? publicRuntimeConfig\n+                        : undefined,\n+\n+                    isExperimentalCompile,\n+\n+                    experimental: {\n+                      clientTraceMetadata:\n+                        nextConfig.experimental.clientTraceMetadata ||\n+                        ([] as any),\n+                    },\n+\n+                    locale,\n+                    locales,\n+                    defaultLocale,\n+                    setIsrStatus: routerServerContext?.setIsrStatus,\n+\n+                    isNextDataRequest:\n+                      isNextDataRequest && (hasServerProps || hasStaticProps),\n+\n+                    resolvedUrl,\n+                    // For getServerSideProps and getInitialProps we need to ensure we use the original URL\n+                    // and not the resolved URL to prevent a hydration mismatch on\n+                    // asPath\n+                    resolvedAsPath:\n+                      hasServerProps || hasGetInitialProps\n+                        ? formatUrl({\n+                            // we use the original URL pathname less the _next/data prefix if\n+                            // present\n+                            pathname: isNextDataRequest\n+                              ? normalizeDataPath(originalPathname)\n+                              : originalPathname,\n+                            query: originalQuery,\n+                          })\n+                        : resolvedUrl,\n+\n+                    isOnDemandRevalidate,\n+\n+                    ErrorDebug: getRequestMeta(req, 'PagesErrorDebug'),\n+                    err: getRequestMeta(req, 'invokeError'),\n+                    dev: routeModule.isDev,\n+\n+                    // needed for experimental.optimizeCss feature\n+                    distDir: path.join(\n+                      /* turbopackIgnore: true */\n+                      process.cwd(),\n+                      routeModule.relativeProjectDir,\n+                      routeModule.distDir\n+                    ),\n+\n+                    ampSkipValidation:\n+                      nextConfig.experimental.amp?.skipValidation,\n+                    ampValidator: getRequestMeta(req, 'ampValidator'),\n+                  },\n+                })\n+                .then((renderResult): ResponseCacheEntry => {\n+                  const { metadata } = renderResult\n+\n+                  let cacheControl: CacheControl | undefined =\n+                    metadata.cacheControl\n+\n+                  if ('isNotFound' in metadata && metadata.isNotFound) {\n+                    return {\n+                      value: null,\n+                      cacheControl,\n+                    } satisfies ResponseCacheEntry\n+                  }\n+\n+                  // Handle `isRedirect`.\n+                  if (metadata.isRedirect) {\n+                    return {\n+                      value: {\n+                        kind: CachedRouteKind.REDIRECT,\n+                        props: metadata.pageData ?? metadata.flightData,\n+                      } satisfies CachedRedirectValue,\n+                      cacheControl,\n+                    } satisfies ResponseCacheEntry\n+                  }\n+\n+                  return {\n+                    value: {\n+                      kind: CachedRouteKind.PAGES,\n+                      html: renderResult,\n+                      pageData: renderResult.metadata.pageData,\n+                      headers: renderResult.metadata.headers,\n+                      status: renderResult.metadata.statusCode,\n+                    },\n+                    cacheControl,\n+                  }\n+                })\n+                .finally(() => {\n+                  if (!span) return\n+\n+                  span.setAttributes({\n+                    'http.status_code': res.statusCode,\n+                    'next.rsc': false,\n+                  })\n+\n+                  const rootSpanAttributes = tracer.getRootSpanAttributes()\n+                  // We were unable to get attributes, probably OTEL is not enabled\n+                  if (!rootSpanAttributes) {\n+                    return\n+                  }\n+\n+                  if (\n+                    rootSpanAttributes.get('next.span_type') !==\n+                    BaseServerSpan.handleRequest\n+                  ) {\n+                    console.warn(\n+                      `Unexpected root span type '${rootSpanAttributes.get(\n+                        'next.span_type'\n+                      )}'. Please report this Next.js issue https://github.com/vercel/next.js`\n+                    )\n+                    return\n+                  }\n+\n+                  const route = rootSpanAttributes.get('next.route')\n+                  if (route) {\n+                    const name = `${method} ${route}`\n+\n+                    span.setAttributes({\n+                      'next.route': route,\n+                      'http.route': route,\n+                      'next.span_name': name,\n+                    })\n+                    span.updateName(name)\n+                  } else {\n+                    span.updateName(`${method} ${req.url}`)\n+                  }\n+                })\n+            } catch (err: unknown) {\n+              // if this is a background revalidate we need to report\n+              // the request error here as it won't be bubbled\n+              if (previousCacheEntry?.isStale) {\n+                await routeModule.onRequestError(\n+                  req,\n+                  err,\n+                  {\n+                    routerKind: 'Pages Router',\n+                    routePath: srcPage,\n+                    routeType: 'render',\n+                    revalidateReason: getRevalidateReason({\n+                      isRevalidate: hasStaticProps,\n+                      isOnDemandRevalidate,\n+                    }),\n+                  },\n+                  routerServerContext\n+                )\n+              }\n+              throw err\n+            }\n+          }\n+\n+          // if we've already generated this page we no longer\n+          // serve the fallback\n+          if (previousCacheEntry) {\n+            isIsrFallback = false\n+          }\n+\n+          if (isIsrFallback) {\n+            const fallbackResponse = await routeModule\n+              .getResponseCache(req)\n+              .get(\n+                routeModule.isDev\n+                  ? null\n+                  : locale\n+                    ? `/${locale}${srcPage}`\n+                    : srcPage,\n+                async ({\n+                  previousCacheEntry: previousFallbackCacheEntry = null,\n+                }) => {\n+                  if (!routeModule.isDev) {\n+                    return toResponseCacheEntry(previousFallbackCacheEntry)\n+                  }\n+                  return doRender()\n+                },\n+                {\n+                  routeKind: RouteKind.PAGES,\n+                  isFallback: true,\n+                  isRoutePPREnabled: false,\n+                  isOnDemandRevalidate: false,\n+                  incrementalCache: await routeModule.getIncrementalCache(\n+                    req,\n+                    nextConfig,\n+                    prerenderManifest\n+                  ),\n+                  waitUntil: ctx.waitUntil,\n+                }\n+              )\n+            if (fallbackResponse) {\n+              // Remove the cache control from the response to prevent it from being\n+              // used in the surrounding cache.\n+              delete fallbackResponse.cacheControl\n+              fallbackResponse.isMiss = true\n+              return fallbackResponse\n+            }\n+          }\n+\n+          if (\n+            !getRequestMeta(req, 'minimalMode') &&\n+            isOnDemandRevalidate &&\n+            revalidateOnlyGenerated &&\n+            !previousCacheEntry\n+          ) {\n+            res.statusCode = 404\n+            // on-demand revalidate always sets this header\n+            res.setHeader('x-nextjs-cache', 'REVALIDATED')\n+            res.end('This page could not be found')\n+            return null\n+          }\n+\n+          if (\n+            isIsrFallback &&\n+            previousCacheEntry?.value?.kind === CachedRouteKind.PAGES\n+          ) {\n+            return {\n+              value: {\n+                kind: CachedRouteKind.PAGES,\n+                html: new RenderResult(\n+                  Buffer.from(previousCacheEntry.value.html),\n+                  {\n+                    contentType: HTML_CONTENT_TYPE_HEADER,\n+                    metadata: {\n+                      statusCode: previousCacheEntry.value.status,\n+                      headers: previousCacheEntry.value.headers,\n+                    },\n+                  }\n+                ),\n+                pageData: {},\n+                status: previousCacheEntry.value.status,\n+                headers: previousCacheEntry.value.headers,\n+              } satisfies CachedPageValue,\n+              cacheControl: { revalidate: 0, expire: undefined },\n+            } satisfies ResponseCacheEntry\n+          }\n+          return doRender()\n+        }\n+\n+        const result = await routeModule.handleResponse({\n+          cacheKey,\n+          req,\n+          nextConfig,\n+          routeKind: RouteKind.PAGES,\n+          isOnDemandRevalidate,\n+          revalidateOnlyGenerated,\n+          waitUntil: ctx.waitUntil,\n+          responseGenerator: responseGenerator,\n+          prerenderManifest,\n+        })\n+\n+        // if we got a cache hit this wasn't an ISR fallback\n+        // but it wasn't generated during build so isn't in the\n+        // prerender-manifest\n+        if (isIsrFallback && !result?.isMiss) {\n+          isIsrFallback = false\n+        }\n+\n+        // response is finished is no cache entry\n+        if (!result) {\n+          return\n+        }\n+\n+        if (hasStaticProps && !getRequestMeta(req, 'minimalMode')) {\n+          res.setHeader(\n+            'x-nextjs-cache',\n+            isOnDemandRevalidate\n+              ? 'REVALIDATED'\n+              : result.isMiss\n+                ? 'MISS'\n+                : result.isStale\n+                  ? 'STALE'\n+                  : 'HIT'\n+          )\n+        }\n+\n+        let cacheControl: CacheControl | undefined\n+\n+        if (!hasStaticProps || isIsrFallback) {\n+          if (!res.getHeader('Cache-Control')) {\n+            cacheControl = { revalidate: 0, expire: undefined }\n+          }\n+        } else if (is404Page) {\n+          const notFoundRevalidate = getRequestMeta(req, 'notFoundRevalidate')\n+\n+          cacheControl = {\n+            revalidate:\n+              typeof notFoundRevalidate === 'undefined'\n+                ? 0\n+                : notFoundRevalidate,\n+            expire: undefined,\n+          }\n+        } else if (is500Page) {\n+          cacheControl = { revalidate: 0, expire: undefined }\n+        } else if (result.cacheControl) {\n+          // If the cache entry has a cache control with a revalidate value that's\n+          // a number, use it.\n+          if (typeof result.cacheControl.revalidate === 'number') {\n+            if (result.cacheControl.revalidate < 1) {\n+              throw new Error(\n+                `Invalid revalidate configuration provided: ${result.cacheControl.revalidate} < 1`\n+              )\n+            }\n+            cacheControl = {\n+              revalidate: result.cacheControl.revalidate,\n+              expire: result.cacheControl?.expire ?? nextConfig.expireTime,\n+            }\n+          } else {\n+            // revalidate: false\n+            cacheControl = {\n+              revalidate: CACHE_ONE_YEAR,\n+              expire: undefined,\n+            }\n+          }\n+        }\n+\n+        // If cache control is already set on the response we don't\n+        // override it to allow users to customize it via next.config\n+        if (cacheControl && !res.getHeader('Cache-Control')) {\n+          res.setHeader('Cache-Control', getCacheControlHeader(cacheControl))\n+        }\n+\n+        // notFound: true case\n+        if (!result.value) {\n+          // add revalidate metadata before rendering 404 page\n+          // so that we can use this as source of truth for the\n+          // cache-control header instead of what the 404 page returns\n+          // for the revalidate value\n+          addRequestMeta(\n+            req,\n+            'notFoundRevalidate',\n+            result.cacheControl?.revalidate\n+          )\n+\n+          res.statusCode = 404\n+\n+          if (isNextDataRequest) {\n+            res.end('{\"notFound\":true}')\n+            return\n+          }\n+          // TODO: should route-module itself handle rendering the 404\n+          if (routerServerContext?.render404) {\n+            await routerServerContext.render404(req, res, parsedUrl, false)\n+          } else {\n+            res.end('This page could not be found')\n+          }\n+          return\n+        }\n+\n+        if (result.value.kind === CachedRouteKind.REDIRECT) {\n+          if (isNextDataRequest) {\n+            res.setHeader('content-type', JSON_CONTENT_TYPE_HEADER)\n+            res.end(JSON.stringify(result.value.props))\n+            return\n+          } else {\n+            const handleRedirect = (pageData: any) => {\n+              const redirect = {\n+                destination: pageData.pageProps.__N_REDIRECT,\n+                statusCode: pageData.pageProps.__N_REDIRECT_STATUS,\n+                basePath: pageData.pageProps.__N_REDIRECT_BASE_PATH,\n+              }\n+              const statusCode = getRedirectStatus(redirect)\n+              const { basePath } = nextConfig\n+\n+              if (\n+                basePath &&\n+                redirect.basePath !== false &&\n+                redirect.destination.startsWith('/')\n+              ) {\n+                redirect.destination = `${basePath}${redirect.destination}`\n+              }\n+\n+              if (redirect.destination.startsWith('/')) {\n+                redirect.destination = normalizeRepeatedSlashes(\n+                  redirect.destination\n+                )\n+              }\n+\n+              res.statusCode = statusCode\n+              res.setHeader('Location', redirect.destination)\n+              if (statusCode === RedirectStatusCode.PermanentRedirect) {\n+                res.setHeader('Refresh', `0;url=${redirect.destination}`)\n+              }\n+              res.end(redirect.destination)\n+            }\n+            await handleRedirect(result.value.props)\n+            return null\n+          }\n+        }\n+\n+        if (result.value.kind !== CachedRouteKind.PAGES) {\n+          throw new Error(\n+            `Invariant: received non-pages cache entry in pages handler`\n+          )\n+        }\n+\n+        // In dev, we should not cache pages for any reason.\n+        if (routeModule.isDev) {\n+          res.setHeader('Cache-Control', 'no-store, must-revalidate')\n+        }\n+\n+        // Draft mode should never be cached\n+        if (isDraftMode) {\n+          res.setHeader(\n+            'Cache-Control',\n+            'private, no-cache, no-store, max-age=0, must-revalidate'\n+          )\n+        }\n+\n+        // when invoking _error before pages/500 we don't actually\n+        // send the _error response\n+        if (\n+          getRequestMeta(req, 'customErrorRender') ||\n+          (isErrorPage &&\n+            getRequestMeta(req, 'minimalMode') &&\n+            res.statusCode === 500)\n+        ) {\n+          return null\n+        }\n+\n+        await sendRenderResult({\n+          req,\n+          res,\n+          // If we are rendering the error page it's not a data request\n+          // anymore\n+          result:\n+            isNextDataRequest && !isErrorPage && !is500Page\n+              ? new RenderResult(\n+                  Buffer.from(JSON.stringify(result.value.pageData)),\n+                  {\n+                    contentType: JSON_CONTENT_TYPE_HEADER,\n+                    metadata: result.value.html.metadata,\n+                  }\n+                )\n+              : result.value.html,\n+          generateEtags: nextConfig.generateEtags,\n+          poweredByHeader: nextConfig.poweredByHeader,\n+          cacheControl: routeModule.isDev ? undefined : cacheControl,\n+        })\n+      }\n+\n+      // TODO: activeSpan code path is for when wrapped by\n+      // next-server can be removed when this is no longer used\n+      if (activeSpan) {\n+        await handleResponse()\n+      } else {\n+        await tracer.withPropagatedContext(req.headers, () =>\n+          tracer.trace(\n+            BaseServerSpan.handleRequest,\n+            {\n+              spanName: `${method} ${req.url}`,\n+              kind: SpanKind.SERVER,\n+              attributes: {\n+                'http.method': method,\n+                'http.target': req.url,\n+              },\n+            },\n+            handleResponse\n+          )\n+        )\n+      }\n+    } catch (err) {\n+      await routeModule.onRequestError(\n+        req,\n+        err,\n+        {\n+          routerKind: 'Pages Router',\n+          routePath: srcPage,\n+          routeType: 'render',\n+          revalidateReason: getRevalidateReason({\n+            isRevalidate: hasStaticProps,\n+            isOnDemandRevalidate,\n+          }),\n+        },\n+        routerServerContext\n+      )\n+\n+      // rethrow so that we can handle serving error page\n+      throw err\n+    }\n+  }\n+}"
        },
        {
            "sha": "61161949b097773352fffa263750684f596fc971",
            "filename": "packages/next/src/server/route-modules/route-module.ts",
            "status": "modified",
            "additions": 44,
            "deletions": 23,
            "changes": 67,
            "blob_url": "https://github.com/vercel/next.js/blob/955adbb05778e732c3d43c5afc5880c18feaaeb2/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Froute-module.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/955adbb05778e732c3d43c5afc5880c18feaaeb2/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Froute-module.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Froute-module.ts?ref=955adbb05778e732c3d43c5afc5880c18feaaeb2",
            "patch": "@@ -74,7 +74,7 @@ export interface RouteModuleOptions<\n   readonly definition: Readonly<D>\n   readonly userland: Readonly<U>\n   readonly distDir: string\n-  readonly projectDir: string\n+  readonly relativeProjectDir: string\n }\n \n /**\n@@ -120,22 +120,22 @@ export abstract class RouteModule<\n \n   public isDev: boolean\n   public distDir: string\n-  public projectDir: string\n   public isAppRouter?: boolean\n+  public relativeProjectDir: string\n   public incrementCache?: IncrementalCache\n   public responseCache?: ResponseCache\n \n   constructor({\n     userland,\n     definition,\n     distDir,\n-    projectDir,\n+    relativeProjectDir,\n   }: RouteModuleOptions<D, U>) {\n     this.userland = userland\n     this.definition = definition\n     this.isDev = process.env.NODE_ENV === 'development'\n     this.distDir = distDir\n-    this.projectDir = projectDir\n+    this.relativeProjectDir = relativeProjectDir\n   }\n \n   public async instrumentationOnRequestError(\n@@ -151,12 +151,13 @@ export abstract class RouteModule<\n       }\n     } else {\n       const { join } = require('node:path') as typeof import('node:path')\n-      const absoluteProjectDir =\n-        getRequestMeta(req, 'projectDir') ||\n-        join(process.cwd(), this.projectDir)\n+      const absoluteProjectDir = join(\n+        process.cwd(),\n+        getRequestMeta(req, 'relativeProjectDir') || this.relativeProjectDir\n+      )\n \n       const { instrumentationOnRequestError } = await import(\n-        '../lib/router-utils/instrumentation-globals.external'\n+        '../lib/router-utils/instrumentation-globals.external.js'\n       )\n \n       return instrumentationOnRequestError(\n@@ -173,6 +174,7 @@ export abstract class RouteModule<\n   ): {\n     buildId: string\n     buildManifest: BuildManifest\n+    fallbackBuildManifest: BuildManifest\n     routesManifest: DeepReadonly<DevRoutesManifest>\n     nextFontManifest: DeepReadonly<NextFontManifest>\n     prerenderManifest: DeepReadonly<PrerenderManifest>\n@@ -194,6 +196,7 @@ export abstract class RouteModule<\n       return {\n         buildId: process.env.__NEXT_BUILD_ID || '',\n         buildManifest: self.__BUILD_MANIFEST as any,\n+        fallbackBuildManifest: {} as any,\n         reactLoadableManifest: maybeJSONParse(self.__REACT_LOADABLE_MANIFEST),\n         nextFontManifest: maybeJSONParse(self.__NEXT_FONT_MANIFEST),\n         prerenderManifest: {\n@@ -245,6 +248,7 @@ export abstract class RouteModule<\n         routesManifest,\n         prerenderManifest,\n         buildManifest,\n+        fallbackBuildManifest,\n         reactLoadableManifest,\n         nextFontManifest,\n         clientReferenceManifest,\n@@ -272,6 +276,15 @@ export abstract class RouteModule<\n           manifest: BUILD_MANIFEST,\n           shouldCache: !this.isDev,\n         }),\n+        srcPage === '/_error'\n+          ? loadManifestFromRelativePath<BuildManifest>({\n+              projectDir,\n+              distDir: this.distDir,\n+              manifest: `fallback-${BUILD_MANIFEST}`,\n+              shouldCache: !this.isDev,\n+              handleMissing: true,\n+            })\n+          : ({} as BuildManifest),\n         loadManifestFromRelativePath<ReactLoadableManifest>({\n           projectDir,\n           distDir: this.distDir,\n@@ -339,6 +352,7 @@ export abstract class RouteModule<\n       return {\n         buildId,\n         buildManifest,\n+        fallbackBuildManifest,\n         routesManifest,\n         nextFontManifest,\n         prerenderManifest,\n@@ -375,9 +389,10 @@ export abstract class RouteModule<\n           require('../../lib/format-dynamic-import-path') as typeof import('../../lib/format-dynamic-import-path')\n \n         const { join } = require('node:path') as typeof import('node:path')\n-        const absoluteProjectDir =\n-          getRequestMeta(req, 'projectDir') ||\n-          join(process.cwd(), this.projectDir)\n+        const absoluteProjectDir = join(\n+          process.cwd(),\n+          getRequestMeta(req, 'relativeProjectDir') || this.relativeProjectDir\n+        )\n \n         setCacheHandler(\n           kind,\n@@ -416,9 +431,10 @@ export abstract class RouteModule<\n         )\n       }\n       const { join } = require('node:path') as typeof import('node:path')\n-      const projectDir =\n-        getRequestMeta(req, 'projectDir') ||\n-        join(process.cwd(), this.projectDir)\n+      const projectDir = join(\n+        process.cwd(),\n+        getRequestMeta(req, 'relativeProjectDir') || this.relativeProjectDir\n+      )\n \n       await this.loadCustomCacheHandlers(req, nextConfig)\n \n@@ -494,6 +510,7 @@ export abstract class RouteModule<\n         resolvedPathname: string\n         isNextDataRequest: boolean\n         buildManifest: DeepReadonly<BuildManifest>\n+        fallbackBuildManifest: DeepReadonly<BuildManifest>\n         nextFontManifest: DeepReadonly<NextFontManifest>\n         serverFilesManifest: DeepReadonly<RequiredServerFilesManifest>\n         reactLoadableManifest: DeepReadonly<ReactLoadableManifest>\n@@ -513,30 +530,31 @@ export abstract class RouteModule<\n       }\n     | undefined\n   > {\n-    let projectDir: string | undefined\n+    let absoluteProjectDir: string | undefined\n \n     // edge runtime handles loading instrumentation at the edge adapter level\n     if (process.env.NEXT_RUNTIME !== 'edge') {\n       const { join, relative } =\n         require('node:path') as typeof import('node:path')\n \n-      projectDir =\n-        getRequestMeta(req, 'projectDir') ||\n-        join(process.cwd(), this.projectDir)\n+      absoluteProjectDir = join(\n+        process.cwd(),\n+        getRequestMeta(req, 'relativeProjectDir') || this.relativeProjectDir\n+      )\n \n       const absoluteDistDir = getRequestMeta(req, 'distDir')\n \n       if (absoluteDistDir) {\n-        this.distDir = relative(projectDir, absoluteDistDir)\n+        this.distDir = relative(absoluteProjectDir, absoluteDistDir)\n       }\n       const { ensureInstrumentationRegistered } = await import(\n-        '../lib/router-utils/instrumentation-globals.external'\n+        '../lib/router-utils/instrumentation-globals.external.js'\n       )\n       // ensure instrumentation is registered and pass\n       // onRequestError below\n-      ensureInstrumentationRegistered(projectDir, this.distDir)\n+      ensureInstrumentationRegistered(absoluteProjectDir, this.distDir)\n     }\n-    const manifests = await this.loadManifests(srcPage, projectDir)\n+    const manifests = await this.loadManifests(srcPage, absoluteProjectDir)\n     const { routesManifest, prerenderManifest, serverFilesManifest } = manifests\n \n     const { basePath, i18n, rewrites } = routesManifest\n@@ -769,8 +787,11 @@ export abstract class RouteModule<\n       isDraftMode = previewData !== false\n     }\n \n+    const relativeProjectDir =\n+      getRequestMeta(req, 'relativeProjectDir') || this.relativeProjectDir\n+\n     const routerServerContext =\n-      routerServerGlobal[RouterServerContextSymbol]?.[this.projectDir]\n+      routerServerGlobal[RouterServerContextSymbol]?.[relativeProjectDir]\n     const nextConfig =\n       routerServerContext?.nextConfig || serverFilesManifest.config\n "
        }
    ],
    "stats": {
        "total": 3197,
        "additions": 1003,
        "deletions": 2194
    }
}