{
    "author": "ijjk",
    "message": "Optimize segment data routes (#82033)\n\nThis tweaks the segment data routes we create for dynamic routes to be\nderived from the `__PAGE__` segment route as we can create one route to\nhandle the 3 segment outputs for a dynamic route.\n\nThis also removes the segment data routes for static routes as they are\nnot needed and be routed to without an explicit regex route per entry.",
    "sha": "ad1e3f209b87b6cc4829b125a667e94f7193f62f",
    "files": [
        {
            "sha": "eb85dec68b4c08b685e6d380d1e3784459c7536b",
            "filename": "packages/next/errors.json",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/ad1e3f209b87b6cc4829b125a667e94f7193f62f/packages%2Fnext%2Ferrors.json",
            "raw_url": "https://github.com/vercel/next.js/raw/ad1e3f209b87b6cc4829b125a667e94f7193f62f/packages%2Fnext%2Ferrors.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Ferrors.json?ref=ad1e3f209b87b6cc4829b125a667e94f7193f62f",
            "patch": "@@ -756,5 +756,6 @@\n   \"755\": \"Route must be a string\",\n   \"756\": \"Route %s not found\",\n   \"757\": \"Unknown styled string type: %s\",\n-  \"758\": \"Missing workStore in useDynamicRouteParams\"\n+  \"758\": \"Missing workStore in useDynamicRouteParams\",\n+  \"759\": \"Invariant: missing __PAGE__ segmentPath\"\n }"
        },
        {
            "sha": "eb9f8ccac6993460e1a28cc4595c4ff1104bd2ea",
            "filename": "packages/next/src/build/index.ts",
            "status": "modified",
            "additions": 28,
            "deletions": 34,
            "changes": 62,
            "blob_url": "https://github.com/vercel/next.js/blob/ad1e3f209b87b6cc4829b125a667e94f7193f62f/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/ad1e3f209b87b6cc4829b125a667e94f7193f62f/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts?ref=ad1e3f209b87b6cc4829b125a667e94f7193f62f",
            "patch": "@@ -191,7 +191,6 @@ import { InvariantError } from '../shared/lib/invariant-error'\n import { HTML_LIMITED_BOT_UA_RE_STRING } from '../shared/lib/router/utils/is-bot'\n import type { UseCacheTrackerKey } from './webpack/plugins/telemetry-plugin/use-cache-tracker-utils'\n import {\n-  buildInversePrefetchSegmentDataRoute,\n   buildPrefetchSegmentDataRoute,\n   type PrefetchSegmentDataRoute,\n } from '../server/lib/router-utils/build-prefetch-segment-data-route'\n@@ -3186,10 +3185,35 @@ export default async function build(\n                     }\n                   }\n \n-                  dynamicRoute.prefetchSegmentDataRoutes ??= []\n-                  for (const segmentPath of metadata.segmentPaths) {\n+                  if (metadata.segmentPaths) {\n+                    const pageSegmentPath = metadata.segmentPaths.find((item) =>\n+                      item.endsWith('__PAGE__')\n+                    )\n+                    if (!pageSegmentPath) {\n+                      throw new Error(`Invariant: missing __PAGE__ segmentPath`)\n+                    }\n+\n+                    // We build a combined segment data route from the\n+                    // page segment as we need to limit the number of\n+                    // routes we output and they can be shared\n+                    const builtSegmentDataRoute = buildPrefetchSegmentDataRoute(\n+                      route.pathname,\n+                      pageSegmentPath\n+                    )\n+\n+                    builtSegmentDataRoute.source =\n+                      builtSegmentDataRoute.source.replace(\n+                        '/__PAGE__\\\\.segment\\\\.rsc$',\n+                        `(?<segment>/__PAGE__\\\\.segment\\\\.rsc|\\\\.segment\\\\.rsc)(?:/)?$`\n+                      )\n+                    builtSegmentDataRoute.destination =\n+                      builtSegmentDataRoute.destination.replace(\n+                        '/__PAGE__.segment.rsc',\n+                        '$segment'\n+                      )\n+                    dynamicRoute.prefetchSegmentDataRoutes ??= []\n                     dynamicRoute.prefetchSegmentDataRoutes.push(\n-                      buildPrefetchSegmentDataRoute(route.pathname, segmentPath)\n+                      builtSegmentDataRoute\n                     )\n                   }\n                 }\n@@ -3610,36 +3634,6 @@ export default async function build(\n           // remove temporary export folder\n           await fs.rm(outdir, { recursive: true, force: true })\n           await writeManifest(pagesManifestPath, pagesManifest)\n-\n-          if (config.experimental.clientSegmentCache) {\n-            for (const route of [\n-              ...routesManifest.staticRoutes,\n-              ...routesManifest.dynamicRoutes,\n-            ]) {\n-              // If the segment paths aren't defined, we need to insert a\n-              // reverse routing rule so that there isn't any conflicts\n-              // with other dynamic routes for the prefetch segment\n-              // routes. This is true for any route that is not PPR-enabled,\n-              // including all routes defined by Pages Router.\n-\n-              // We don't need to add the prefetch segment data routes if it was\n-              // added due to a page that was already generated. This would have\n-              // happened if the page was static or partially static.\n-              if (route.prefetchSegmentDataRoutes) {\n-                continue\n-              }\n-\n-              route.prefetchSegmentDataRoutes = [\n-                buildInversePrefetchSegmentDataRoute(\n-                  route.page,\n-                  // We use the special segment path of `/_tree` because it's\n-                  // the first one sent by the client router so it's the only\n-                  // one we need to rewrite to the regular prefetch RSC route.\n-                  '/_tree'\n-                ),\n-              ]\n-            }\n-          }\n         })\n \n         // As we may have modified the dynamicRoutes, we need to sort the"
        },
        {
            "sha": "8b8a4cb1b5d924a2860b486d0d63785c01620c56",
            "filename": "packages/next/src/export/routes/app-page.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 2,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/ad1e3f209b87b6cc4829b125a667e94f7193f62f/packages%2Fnext%2Fsrc%2Fexport%2Froutes%2Fapp-page.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/ad1e3f209b87b6cc4829b125a667e94f7193f62f/packages%2Fnext%2Fsrc%2Fexport%2Froutes%2Fapp-page.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fexport%2Froutes%2Fapp-page.ts?ref=ad1e3f209b87b6cc4829b125a667e94f7193f62f",
            "patch": "@@ -216,8 +216,12 @@ export async function exportAppPage(\n     )\n \n     return {\n-      // Only include the metadata if the environment has next support.\n-      metadata: hasNextSupport ? meta : undefined,\n+      // Filter the metadata if the environment does not have next support.\n+      metadata: hasNextSupport\n+        ? meta\n+        : {\n+            segmentPaths: meta.segmentPaths,\n+          },\n       hasEmptyStaticShell: Boolean(postponed) && html === '',\n       hasPostponed: Boolean(postponed),\n       cacheControl,"
        },
        {
            "sha": "0421f81ad5993f5c12c431adba620081c59768f1",
            "filename": "test/e2e/app-dir/segment-cache/conflicting-routes/conflicting-routes.test.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 16,
            "changes": 22,
            "blob_url": "https://github.com/vercel/next.js/blob/ad1e3f209b87b6cc4829b125a667e94f7193f62f/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fconflicting-routes%2Fconflicting-routes.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/ad1e3f209b87b6cc4829b125a667e94f7193f62f/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fconflicting-routes%2Fconflicting-routes.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fconflicting-routes%2Fconflicting-routes.test.ts?ref=ad1e3f209b87b6cc4829b125a667e94f7193f62f",
            "patch": "@@ -61,21 +61,11 @@ describe('conflicting routes', () => {\n   it('handles conflict between App Router and Pages Router routes', async () => {\n     const res = await segmentPrefetch('/new/templates', '/_tree')\n \n-    // Should match the route defined at pages/new/templates/[[...slug]].js,\n-    // not the one at app/new/[teamSlug]/page.tsx\n-    if (isNextDeploy) {\n-      // In a deployed environment the builder routes this to the .prefetch.rsc\n-      // route, which doesn't exist, so it returns a 404.\n-      // TODO: It'd probably be more correct if it didn't re-route to\n-      // .prefetch.rsc and just routed to the normal Pages route. This would\n-      // match the behavior in server mode. This only happens when the\n-      // prefetch header is present, though, so the only observable effect right\n-      // now is that it shows up as a 404 in the network panel. Either way, the\n-      // page can't be prefetched by App Router because it's a Pages route.\n-      expect(res.status).toBe(404)\n-    } else {\n-      expect(res.status).toBe(200)\n-      expect(await res.text()).toContain('/new/templates/[[...slug]].js')\n-    }\n+    expect(res.status).toBe(200)\n+    expect(await res.text()).toContain(\n+      // when deployed we map to an empty object to signal to\n+      // client router it should MPA navigate\n+      isNextDeploy ? '{}' : '/new/templates/[[...slug]].js'\n+    )\n   })\n })"
        },
        {
            "sha": "57ff4260a0367842f0a8e002e180ba768f1b0103",
            "filename": "test/e2e/app-dir/segment-cache/incremental-opt-in/segment-cache-incremental-opt-in.test.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 6,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/ad1e3f209b87b6cc4829b125a667e94f7193f62f/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fincremental-opt-in%2Fsegment-cache-incremental-opt-in.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/ad1e3f209b87b6cc4829b125a667e94f7193f62f/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fincremental-opt-in%2Fsegment-cache-incremental-opt-in.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fincremental-opt-in%2Fsegment-cache-incremental-opt-in.test.ts?ref=ad1e3f209b87b6cc4829b125a667e94f7193f62f",
            "patch": "@@ -3,7 +3,7 @@ import { createRouterAct } from '../router-act'\n import { Page } from 'playwright'\n \n describe('segment cache (incremental opt in)', () => {\n-  const { next, isNextDeploy, isNextDev } = nextTestSetup({\n+  const { next, isNextDev } = nextTestSetup({\n     files: __dirname,\n   })\n   if (isNextDev) {\n@@ -102,11 +102,8 @@ describe('segment cache (incremental opt in)', () => {\n \n   describe('multiple prefetches to same link are deduped', () => {\n     it('page with PPR enabled', () => testPrefetchDeduping('/ppr-enabled'))\n-    // FIXME: When deployed, the _tree prefetch request returns an empty 204.\n-    ;(isNextDeploy ? it.failing : it)(\n-      'page with PPR enabled, and has a dynamic param',\n-      () => testPrefetchDeduping('/ppr-enabled/dynamic-param')\n-    )\n+    it('page with PPR enabled, and has a dynamic param', () =>\n+      testPrefetchDeduping('/ppr-enabled/dynamic-param'))\n     it('page with PPR disabled', () => testPrefetchDeduping('/ppr-disabled'))\n     it('page with PPR disabled, and has a loading boundary', () =>\n       testPrefetchDeduping('/ppr-disabled-with-loading-boundary'))"
        }
    ],
    "stats": {
        "total": 104,
        "additions": 45,
        "deletions": 59
    }
}