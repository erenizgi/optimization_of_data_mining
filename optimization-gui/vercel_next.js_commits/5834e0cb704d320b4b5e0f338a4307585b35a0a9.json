{
    "author": "mischnic",
    "message": "Turbopack: slightly improve resolve_source_map_sources (#84147)\n\n- slightly fewer clones\n- slightly fewer turbotask calls",
    "sha": "5834e0cb704d320b4b5e0f338a4307585b35a0a9",
    "files": [
        {
            "sha": "c2593658b7dfeb05e06eebf2b6c0938639c05ceb",
            "filename": "turbopack/crates/turbopack-core/src/reference/source_map.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/5834e0cb704d320b4b5e0f338a4307585b35a0a9/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Freference%2Fsource_map.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5834e0cb704d320b4b5e0f338a4307585b35a0a9/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Freference%2Fsource_map.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Freference%2Fsource_map.rs?ref=5834e0cb704d320b4b5e0f338a4307585b35a0a9",
            "patch": "@@ -64,7 +64,7 @@ impl GenerateSourceMap for SourceMapReference {\n \n         let content = file.read().await?;\n         let content = content.as_content().map(|file| file.content());\n-        let source_map = resolve_source_map_sources(content, self.from.clone()).await?;\n+        let source_map = resolve_source_map_sources(content, &self.from).await?;\n         Ok(Vc::cell(source_map))\n     }\n }"
        },
        {
            "sha": "5aa9590c6e80ea1222e40862cabf142a8bb7f44d",
            "filename": "turbopack/crates/turbopack-core/src/source_map/utils.rs",
            "status": "modified",
            "additions": 17,
            "deletions": 14,
            "changes": 31,
            "blob_url": "https://github.com/vercel/next.js/blob/5834e0cb704d320b4b5e0f338a4307585b35a0a9/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fsource_map%2Futils.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5834e0cb704d320b4b5e0f338a4307585b35a0a9/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fsource_map%2Futils.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fsource_map%2Futils.rs?ref=5834e0cb704d320b4b5e0f338a4307585b35a0a9",
            "patch": "@@ -5,7 +5,7 @@ use const_format::concatcp;\n use once_cell::sync::Lazy;\n use regex::Regex;\n use serde::{Deserialize, Serialize};\n-use turbo_tasks::ResolvedVc;\n+use turbo_tasks::{ResolvedVc, ValueToString};\n use turbo_tasks_fs::{\n     DiskFileSystem, FileContent, FileSystemPath, rope::Rope, util::uri_from_file,\n };\n@@ -75,16 +75,19 @@ struct SourceMapJson {\n /// `sourceContent`s from disk.\n pub async fn resolve_source_map_sources(\n     map: Option<&Rope>,\n-    origin: FileSystemPath,\n+    origin: &FileSystemPath,\n ) -> Result<Option<Rope>> {\n+    let fs = &*format!(\"[{}]\", origin.fs().to_string().await?);\n+\n     async fn resolve_source(\n         original_source: &mut String,\n         original_content: Option<&mut Option<String>>,\n-        origin: FileSystemPath,\n+        fs: &str,\n+        origin: &FileSystemPath,\n     ) -> Result<()> {\n         if let Some(path) = origin.parent().try_join(original_source)? {\n-            let path_str = path.value_to_string().await?;\n-            let source = format!(\"{SOURCE_URL_PROTOCOL}///{path_str}\");\n+            let path_str = &path.path;\n+            let source = format!(\"{SOURCE_URL_PROTOCOL}///{fs}/{path_str}\");\n             *original_source = source;\n \n             if let Some(original_content) = original_content\n@@ -94,30 +97,30 @@ pub async fn resolve_source_map_sources(\n                     let text = file.content().to_str()?;\n                     *original_content = Some(text.to_string())\n                 } else {\n-                    *original_content = Some(format!(\"unable to read source {path_str}\"));\n+                    *original_content = Some(format!(\"unable to read source {fs}/{path_str}\"));\n                 }\n             }\n         } else {\n-            let origin_str = origin.value_to_string().await?;\n+            let origin_str = &origin.path;\n             static INVALID_REGEX: Lazy<Regex> =\n                 Lazy::new(|| Regex::new(r#\"(?:^|/)(?:\\.\\.?(?:/|$))+\"#).unwrap());\n             let source = INVALID_REGEX.replace_all(original_source, |s: &regex::Captures<'_>| {\n                 s[0].replace('.', \"_\")\n             });\n-            *original_source = format!(\"{SOURCE_URL_PROTOCOL}///{origin_str}/{source}\");\n+            *original_source = format!(\"{SOURCE_URL_PROTOCOL}///{fs}/{origin_str}/{source}\");\n             if let Some(original_content) = original_content\n                 && original_content.is_none()\n             {\n                 *original_content = Some(format!(\n-                    \"unable to access {original_source} in {origin_str} (it's leaving the \\\n+                    \"unable to access {original_source} in {fs}/{origin_str} (it's leaving the \\\n                      filesystem root)\"\n                 ));\n             }\n         }\n         anyhow::Ok(())\n     }\n \n-    async fn resolve_map(map: &mut SourceMapJson, origin: FileSystemPath) -> Result<()> {\n+    async fn resolve_map(map: &mut SourceMapJson, fs: &str, origin: &FileSystemPath) -> Result<()> {\n         if let Some(sources) = &mut map.sources {\n             let mut contents = if let Some(mut contents) = map.sources_content.take() {\n                 contents.resize(sources.len(), None);\n@@ -128,7 +131,7 @@ pub async fn resolve_source_map_sources(\n \n             for (source, content) in sources.iter_mut().zip(contents.iter_mut()) {\n                 if let Some(source) = source {\n-                    resolve_source(source, Some(content), origin.clone()).await?;\n+                    resolve_source(source, Some(content), fs, origin).await?;\n                 }\n             }\n \n@@ -147,12 +150,12 @@ pub async fn resolve_source_map_sources(\n     };\n \n     if let Some(file) = &mut map.file {\n-        resolve_source(file, None, origin.clone()).await?;\n+        resolve_source(file, None, fs, origin).await?;\n     }\n \n-    resolve_map(&mut map, origin.clone()).await?;\n+    resolve_map(&mut map, fs, origin).await?;\n     for section in map.sections.iter_mut().flatten() {\n-        resolve_map(&mut section.map, origin.clone()).await?;\n+        resolve_map(&mut section.map, fs, origin).await?;\n     }\n \n     let map = Rope::from(serde_json::to_vec(&map)?);"
        },
        {
            "sha": "4c6f614311c3202d25b167aa9b92140174a42ef6",
            "filename": "turbopack/crates/turbopack-ecmascript/src/lib.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/5834e0cb704d320b4b5e0f338a4307585b35a0a9/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5834e0cb704d320b4b5e0f338a4307585b35a0a9/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs?ref=5834e0cb704d320b4b5e0f338a4307585b35a0a9",
            "patch": "@@ -891,7 +891,7 @@ impl EcmascriptChunkItem for ModuleChunkItem {\n     ) -> Result<Vc<EcmascriptChunkItemContent>> {\n         let span = tracing::info_span!(\n             \"code generation\",\n-            name = self.asset_ident().to_string().await?.to_string()\n+            name = display(self.asset_ident().to_string().await?)\n         );\n         async {\n             let this = self.await?;"
        },
        {
            "sha": "f2f76d948395e02fcc378d8d03f9cfe41c25d478",
            "filename": "turbopack/crates/turbopack-ecmascript/src/source_map.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/5834e0cb704d320b4b5e0f338a4307585b35a0a9/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fsource_map.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5834e0cb704d320b4b5e0f338a4307585b35a0a9/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fsource_map.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fsource_map.rs?ref=5834e0cb704d320b4b5e0f338a4307585b35a0a9",
            "patch": "@@ -30,8 +30,7 @@ impl GenerateSourceMap for InlineSourceMap {\n     #[turbo_tasks::function]\n     pub async fn generate_source_map(&self) -> Result<Vc<OptionStringifiedSourceMap>> {\n         let source_map = maybe_decode_data_url(&self.source_map);\n-        let source_map =\n-            resolve_source_map_sources(source_map.as_ref(), self.origin_path.clone()).await?;\n+        let source_map = resolve_source_map_sources(source_map.as_ref(), &self.origin_path).await?;\n         Ok(Vc::cell(source_map))\n     }\n }"
        },
        {
            "sha": "407bb97de124c70f8d9a7f483d7622de78e4c875",
            "filename": "turbopack/crates/turbopack-node/src/transforms/webpack.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 5,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/5834e0cb704d320b4b5e0f338a4307585b35a0a9/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Fwebpack.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5834e0cb704d320b4b5e0f338a4307585b35a0a9/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Fwebpack.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Fwebpack.rs?ref=5834e0cb704d320b4b5e0f338a4307585b35a0a9",
            "patch": "@@ -247,12 +247,11 @@ impl WebpackLoadersProcessedAsset {\n             .to_resolved()\n             .await?;\n \n-        let resource_fs_path = this.source.ident().path().owned().await?;\n-        let resource_fs_path_ref = resource_fs_path.clone();\n-        let Some(resource_path) = project_path.get_relative_path_to(&resource_fs_path_ref) else {\n+        let resource_fs_path = this.source.ident().path().await?;\n+        let Some(resource_path) = project_path.get_relative_path_to(&resource_fs_path) else {\n             bail!(format!(\n                 \"Resource path \\\"{}\\\" need to be on project filesystem \\\"{}\\\"\",\n-                resource_fs_path_ref, project_path\n+                resource_fs_path, project_path\n             ));\n         };\n         let loaders = transform.loaders.await?;\n@@ -298,7 +297,7 @@ impl WebpackLoadersProcessedAsset {\n                 .map\n                 .map(|source_map| Rope::from(source_map.into_owned()))\n         };\n-        let source_map = resolve_source_map_sources(source_map.as_ref(), resource_fs_path).await?;\n+        let source_map = resolve_source_map_sources(source_map.as_ref(), &resource_fs_path).await?;\n \n         let file = match processed.source {\n             Either::Left(str) => File::from(str),"
        }
    ],
    "stats": {
        "total": 47,
        "additions": 24,
        "deletions": 23
    }
}