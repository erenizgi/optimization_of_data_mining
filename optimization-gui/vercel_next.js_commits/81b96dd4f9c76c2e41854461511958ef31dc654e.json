{
    "author": "bgw",
    "message": "feat(turbo-tasks): Generate a trace of transient tasks when panicking (#77600)\n\nWhen panicking due to a transient task called from a persistent task, it's often hard to figure out why the read task was transient in the first place, as turbo-tasks doesn't have normal stack traces.\n\nTo make it worse, these issues are often hard to reproduce (can happen due to file invalidations, turbopack restarts, etc), so we want to gather as much information from users reporting bugs as possible in the panic message.\n\nThis uses `TraceRawVcs` to log debug information about transient dependencies:\n\n```\nAdder::add_method (read cell of type turbo-tasks@TODO::::primitives::u64)\n  self:\n    Adder::new (read cell of type turbo-tasks-backend@TODO::::Adder)\n      args:\n        unknown transient task (read cell of type turbo-tasks@TODO::::primitives::unit)\n  args:\n    unknown transient task (read cell of type turbo-tasks@TODO::::primitives::u16)\n    unknown transient task (read cell of type turbo-tasks@TODO::::primitives::u32)\n```\n\nIn this example, `unknown transient task` refers to a `TurboTasks::run_once` call, which has no name.\n\nFor a real-world example of this in use, see #77798.\n\nThis uses information already stored on cached tasks, so there's no additional tracking overhead, outside of the work that must happen on a panic (a cold codepath).",
    "sha": "81b96dd4f9c76c2e41854461511958ef31dc654e",
    "files": [
        {
            "sha": "7a7e75f0fa921afabab1aa6f73c2e012977e7e8c",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 200,
            "deletions": 15,
            "changes": 215,
            "blob_url": "https://github.com/vercel/next.js/blob/81b96dd4f9c76c2e41854461511958ef31dc654e/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/81b96dd4f9c76c2e41854461511958ef31dc654e/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=81b96dd4f9c76c2e41854461511958ef31dc654e",
            "patch": "@@ -5,6 +5,7 @@ mod storage;\n \n use std::{\n     borrow::Cow,\n+    fmt::{self, Write},\n     future::Future,\n     hash::BuildHasherDefault,\n     mem::take,\n@@ -18,6 +19,7 @@ use std::{\n \n use anyhow::{bail, Result};\n use auto_hash_map::{AutoMap, AutoSet};\n+use indexmap::IndexSet;\n use parking_lot::{Condvar, Mutex};\n use rustc_hash::{FxHashMap, FxHashSet, FxHasher};\n use smallvec::smallvec;\n@@ -28,8 +30,9 @@ use turbo_tasks::{\n         TransientTaskType, TypedCellContent,\n     },\n     event::{Event, EventListener},\n-    registry,\n+    registry::{self, get_value_type_global_name},\n     task_statistics::TaskStatisticsApi,\n+    trace::TraceRawVcs,\n     util::IdFactoryWithReuse,\n     CellId, FunctionId, FxDashMap, RawVc, ReadCellOptions, ReadConsistency, SessionId, TaskId,\n     TraitTypeId, TurboTasksBackendApi, ValueTypeId, TRANSIENT_TASK_BIT,\n@@ -425,7 +428,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         turbo_tasks: &dyn TurboTasksBackendApi<TurboTasksBackend<B>>,\n     ) -> Result<Result<RawVc, EventListener>> {\n         if let Some(reader) = reader {\n-            self.assert_not_persistent_calling_transient(reader, task_id);\n+            self.assert_not_persistent_calling_transient(reader, task_id, /* cell_id */ None);\n         }\n \n         let mut ctx = self.execute_context(turbo_tasks);\n@@ -627,7 +630,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         turbo_tasks: &dyn TurboTasksBackendApi<TurboTasksBackend<B>>,\n     ) -> Result<Result<TypedCellContent, EventListener>> {\n         if let Some(reader) = reader {\n-            self.assert_not_persistent_calling_transient(reader, task_id);\n+            self.assert_not_persistent_calling_transient(reader, task_id, Some(cell));\n         }\n \n         fn add_cell_dependency<B: BackingStorage>(\n@@ -987,9 +990,10 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         turbo_tasks: &dyn TurboTasksBackendApi<TurboTasksBackend<B>>,\n     ) -> TaskId {\n         if !parent_task.is_transient() {\n-            panic_persistent_calling_transient(\n+            self.panic_persistent_calling_transient(\n                 self.lookup_task_type(parent_task).as_deref(),\n                 Some(&task_type),\n+                /* cell_id */ None,\n             );\n         }\n         if let Some(task_id) = self.task_cache.lookup_forward(&task_type) {\n@@ -1015,6 +1019,84 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         task_id\n     }\n \n+    /// Generate an object that implements [`fmt::Display`] explaining why the given\n+    /// [`CachedTaskType`] is transient.\n+    fn debug_trace_transient_task(\n+        &self,\n+        task_type: &CachedTaskType,\n+        cell_id: Option<CellId>,\n+    ) -> DebugTraceTransientTask {\n+        // it shouldn't be possible to have cycles in tasks, but we could have an exponential blowup\n+        // from tracing the same task many times, so use a visited_set\n+        fn inner_id(\n+            backend: &TurboTasksBackendInner<impl BackingStorage>,\n+            task_id: TaskId,\n+            cell_type_id: Option<ValueTypeId>,\n+            visited_set: &mut FxHashSet<TaskId>,\n+        ) -> DebugTraceTransientTask {\n+            if let Some(task_type) = backend.lookup_task_type(task_id) {\n+                if visited_set.contains(&task_id) {\n+                    let task_name = task_type.get_name();\n+                    DebugTraceTransientTask::Collapsed {\n+                        task_name,\n+                        cell_type_id,\n+                    }\n+                } else {\n+                    inner_cached(backend, &task_type, cell_type_id, visited_set)\n+                }\n+            } else {\n+                DebugTraceTransientTask::Uncached { cell_type_id }\n+            }\n+        }\n+        fn inner_cached(\n+            backend: &TurboTasksBackendInner<impl BackingStorage>,\n+            task_type: &CachedTaskType,\n+            cell_type_id: Option<ValueTypeId>,\n+            visited_set: &mut FxHashSet<TaskId>,\n+        ) -> DebugTraceTransientTask {\n+            let task_name = task_type.get_name();\n+\n+            let cause_self = task_type.this.and_then(|cause_self_raw_vc| {\n+                let task_id = cause_self_raw_vc.get_task_id();\n+                if task_id.is_transient() {\n+                    Some(Box::new(inner_id(\n+                        backend,\n+                        cause_self_raw_vc.get_task_id(),\n+                        cause_self_raw_vc.try_get_type_id(),\n+                        visited_set,\n+                    )))\n+                } else {\n+                    None\n+                }\n+            });\n+            let cause_args = task_type\n+                .arg\n+                .get_raw_vcs()\n+                .into_iter()\n+                .map(|raw_vc| (raw_vc.get_task_id(), raw_vc.try_get_type_id()))\n+                .filter(|(task_id, _)| task_id.is_transient())\n+                .collect::<IndexSet<_>>() // dedupe\n+                .into_iter()\n+                .map(|(task_id, cell_type_id)| {\n+                    inner_id(backend, task_id, cell_type_id, visited_set)\n+                })\n+                .collect();\n+\n+            DebugTraceTransientTask::Cached {\n+                task_name,\n+                cell_type_id,\n+                cause_self,\n+                cause_args,\n+            }\n+        }\n+        inner_cached(\n+            self,\n+            task_type,\n+            cell_id.map(|c| c.type_id),\n+            &mut FxHashSet::default(),\n+        )\n+    }\n+\n     fn invalidate_task(\n         &self,\n         task_id: TaskId,\n@@ -1991,14 +2073,42 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         }\n     }\n \n-    fn assert_not_persistent_calling_transient(&self, parent_id: TaskId, child_id: TaskId) {\n+    fn assert_not_persistent_calling_transient(\n+        &self,\n+        parent_id: TaskId,\n+        child_id: TaskId,\n+        cell_id: Option<CellId>,\n+    ) {\n         if !parent_id.is_transient() && child_id.is_transient() {\n-            panic_persistent_calling_transient(\n+            self.panic_persistent_calling_transient(\n                 self.lookup_task_type(parent_id).as_deref(),\n                 self.lookup_task_type(child_id).as_deref(),\n+                cell_id,\n             );\n         }\n     }\n+\n+    fn panic_persistent_calling_transient(\n+        &self,\n+        parent: Option<&CachedTaskType>,\n+        child: Option<&CachedTaskType>,\n+        cell_id: Option<CellId>,\n+    ) {\n+        let transient_reason = if let Some(child) = child {\n+            format!(\n+                \" The callee is transient because it depends on:\\n{}\",\n+                self.debug_trace_transient_task(child, cell_id),\n+            )\n+        } else {\n+            String::new()\n+        };\n+        panic!(\n+            \"Persistent task {} is not allowed to call or read transient tasks {}.{}\",\n+            parent.map_or(\"unknown\", |t| t.get_name()),\n+            child.map_or(\"unknown\", |t| t.get_name()),\n+            transient_reason,\n+        );\n+    }\n }\n \n impl<B: BackingStorage> Backend for TurboTasksBackend<B> {\n@@ -2276,15 +2386,90 @@ impl<B: BackingStorage> Backend for TurboTasksBackend<B> {\n     }\n }\n \n-fn panic_persistent_calling_transient(\n-    parent: Option<&CachedTaskType>,\n-    child: Option<&CachedTaskType>,\n-) {\n-    panic!(\n-        \"Persistent task {} is not allowed to call or read transient tasks {}\",\n-        parent.map_or(\"unknown\", |t| t.get_name()),\n-        child.map_or(\"unknown\", |t| t.get_name()),\n-    );\n+enum DebugTraceTransientTask {\n+    Cached {\n+        task_name: &'static str,\n+        cell_type_id: Option<ValueTypeId>,\n+        cause_self: Option<Box<DebugTraceTransientTask>>,\n+        cause_args: Vec<DebugTraceTransientTask>,\n+    },\n+    /// This representation is used when this task is a duplicate of one previously shown\n+    Collapsed {\n+        task_name: &'static str,\n+        cell_type_id: Option<ValueTypeId>,\n+    },\n+    Uncached {\n+        cell_type_id: Option<ValueTypeId>,\n+    },\n+}\n+\n+impl DebugTraceTransientTask {\n+    fn fmt_indented(&self, f: &mut fmt::Formatter<'_>, level: usize) -> fmt::Result {\n+        let indent = \"    \".repeat(level);\n+        f.write_str(&indent)?;\n+\n+        fn fmt_cell_type_id(\n+            f: &mut fmt::Formatter<'_>,\n+            cell_type_id: Option<ValueTypeId>,\n+        ) -> fmt::Result {\n+            if let Some(ty) = cell_type_id {\n+                write!(f, \" (read cell of type {})\", get_value_type_global_name(ty))\n+            } else {\n+                Ok(())\n+            }\n+        }\n+\n+        // write the name and type\n+        match self {\n+            Self::Cached {\n+                task_name,\n+                cell_type_id,\n+                ..\n+            }\n+            | Self::Collapsed {\n+                task_name,\n+                cell_type_id,\n+                ..\n+            } => {\n+                f.write_str(task_name)?;\n+                fmt_cell_type_id(f, *cell_type_id)?;\n+                if matches!(self, Self::Collapsed { .. }) {\n+                    f.write_str(\" (collapsed)\")?;\n+                }\n+            }\n+            Self::Uncached { cell_type_id } => {\n+                f.write_str(\"unknown transient task\")?;\n+                fmt_cell_type_id(f, *cell_type_id)?;\n+            }\n+        }\n+        f.write_char('\\n')?;\n+\n+        // write any extra \"cause\" information we might have\n+        if let Self::Cached {\n+            cause_self,\n+            cause_args,\n+            ..\n+        } = self\n+        {\n+            if let Some(c) = cause_self {\n+                writeln!(f, \"{indent}  self:\")?;\n+                c.fmt_indented(f, level + 1)?;\n+            }\n+            if !cause_args.is_empty() {\n+                writeln!(f, \"{indent}  args:\")?;\n+                for c in cause_args {\n+                    c.fmt_indented(f, level + 1)?;\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl fmt::Display for DebugTraceTransientTask {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.fmt_indented(f, 0)\n+    }\n }\n \n // from https://github.com/tokio-rs/tokio/blob/29cd6ec1ec6f90a7ee1ad641c03e0e00badbcb0e/tokio/src/time/instant.rs#L57-L63"
        },
        {
            "sha": "f805d015b621fd0738e9a86f029ad304abb1edac",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/trace_transient.rs",
            "status": "added",
            "additions": 74,
            "deletions": 0,
            "changes": 74,
            "blob_url": "https://github.com/vercel/next.js/blob/81b96dd4f9c76c2e41854461511958ef31dc654e/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftrace_transient.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/81b96dd4f9c76c2e41854461511958ef31dc654e/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftrace_transient.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftrace_transient.rs?ref=81b96dd4f9c76c2e41854461511958ef31dc654e",
            "patch": "@@ -0,0 +1,74 @@\n+#![feature(arbitrary_self_types)]\n+#![feature(arbitrary_self_types_pointers)]\n+\n+use anyhow::Result;\n+use serde::{Deserialize, Serialize};\n+use turbo_tasks::{trace::TraceRawVcs, NonLocalValue, ResolvedVc, TaskInput, Vc};\n+use turbo_tasks_testing::{register, run_without_cache_check, Registration};\n+\n+static REGISTRATION: Registration = register!();\n+\n+const EXPECTED_TRACE: &str = \"\\\n+Adder::add_method (read cell of type turbo-tasks@TODO::::primitives::u64)\n+  self:\n+    Adder::new (read cell of type turbo-tasks-backend@TODO::::Adder)\n+      args:\n+        unknown transient task (read cell of type turbo-tasks@TODO::::primitives::unit)\n+  args:\n+    unknown transient task (read cell of type turbo-tasks@TODO::::primitives::u16)\n+    unknown transient task (read cell of type turbo-tasks@TODO::::primitives::u32)\";\n+\n+#[tokio::test]\n+async fn test_trace_transient() {\n+    let result = run_without_cache_check(&REGISTRATION, async {\n+        read_incorrect_task_input_operation(IncorrectTaskInput(\n+            Adder::new(Vc::cell(()))\n+                .add_method(Vc::cell(2), Vc::cell(3))\n+                .to_resolved()\n+                .await?,\n+        ))\n+        .read_strongly_consistent()\n+        .await?;\n+        anyhow::Ok(())\n+    })\n+    .await;\n+    assert!(result\n+        .unwrap_err()\n+        .to_string()\n+        .contains(&EXPECTED_TRACE.escape_debug().to_string()));\n+}\n+\n+#[turbo_tasks::value]\n+struct Adder;\n+\n+#[turbo_tasks::value_impl]\n+impl Adder {\n+    #[turbo_tasks::function]\n+    fn new(arg: ResolvedVc<()>) -> Vc<Adder> {\n+        let _ = arg; // Make sure unused argument filtering doesn't remove the arg\n+        Adder.cell()\n+    }\n+\n+    #[turbo_tasks::function]\n+    async fn add_method(&self, arg1: ResolvedVc<u16>, arg2: ResolvedVc<u32>) -> Result<Vc<u64>> {\n+        Ok(Vc::cell(u64::from(*arg1.await?) + u64::from(*arg2.await?)))\n+    }\n+}\n+\n+#[turbo_tasks::function(operation)]\n+async fn read_incorrect_task_input_operation(value: IncorrectTaskInput) -> Result<Vc<u64>> {\n+    Ok(Vc::cell(*value.0.await?))\n+}\n+\n+/// Has an intentionally incorrect `TaskInput` implementation, representing some code that the debug\n+/// tracing might be particularly useful with.\n+#[derive(\n+    Copy, Clone, Debug, PartialEq, Eq, Hash, TraceRawVcs, Serialize, Deserialize, NonLocalValue,\n+)]\n+struct IncorrectTaskInput(ResolvedVc<u64>);\n+\n+impl TaskInput for IncorrectTaskInput {\n+    fn is_transient(&self) -> bool {\n+        false\n+    }\n+}"
        },
        {
            "sha": "5b4b657397efe93e6d45a7f2bedd0895345d9f51",
            "filename": "turbopack/crates/turbo-tasks/src/backend.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/81b96dd4f9c76c2e41854461511958ef31dc654e/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fbackend.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/81b96dd4f9c76c2e41854461511958ef31dc654e/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fbackend.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fbackend.rs?ref=81b96dd4f9c76c2e41854461511958ef31dc654e",
            "patch": "@@ -68,6 +68,8 @@ pub struct CachedTaskType {\n }\n \n impl CachedTaskType {\n+    /// Get the name of the function from the registry. Equivalent to the\n+    /// [`fmt::Display::to_string`] implementation, but does not allocate a `String`.\n     pub fn get_name(&self) -> &'static str {\n         &registry::get_function(self.fn_type).name\n     }"
        },
        {
            "sha": "0ef2e1eef7082daae69f1a7372501cab688c28b0",
            "filename": "turbopack/crates/turbo-tasks/src/raw_vc.rs",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/81b96dd4f9c76c2e41854461511958ef31dc654e/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fraw_vc.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/81b96dd4f9c76c2e41854461511958ef31dc654e/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fraw_vc.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fraw_vc.rs?ref=81b96dd4f9c76c2e41854461511958ef31dc654e",
            "patch": "@@ -216,6 +216,13 @@ impl RawVc {\n         }\n     }\n \n+    pub fn try_get_type_id(&self) -> Option<ValueTypeId> {\n+        match self {\n+            RawVc::TaskCell(_, CellId { type_id, .. }) => Some(*type_id),\n+            RawVc::TaskOutput(_) | RawVc::LocalOutput(_, _) => None,\n+        }\n+    }\n+\n     /// For a cell that's already resolved, synchronously check if it implements a trait using the\n     /// type information in `RawVc::TaskCell` (we don't actualy need to read the cell!).\n     pub(crate) fn resolved_has_trait(&self, trait_id: TraitTypeId) -> bool {"
        }
    ],
    "stats": {
        "total": 298,
        "additions": 283,
        "deletions": 15
    }
}