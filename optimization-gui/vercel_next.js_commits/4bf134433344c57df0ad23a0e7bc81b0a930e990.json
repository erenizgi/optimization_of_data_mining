{
    "author": "bgw",
    "message": "Turbopack: chore: Remove dead experimental.ppr struct field (#85792)\n\n- `experimental.ppr` was replaced with `cacheComponents`.\n- It's still in the zod and TS type schemas, I think for our error messages on the Next.js side, but Turbopack only needs to know about the fields that Turbopack cares about. Serde silently ignores unknown fields by default.\n- Nothing was reading this field from this struct.\n- This unit test coverage is very overkill.",
    "sha": "4bf134433344c57df0ad23a0e7bc81b0a930e990",
    "files": [
        {
            "sha": "ab9df2c0dec84943d49dd98375a2f8a24ab7729e",
            "filename": "crates/next-core/src/next_config.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 66,
            "changes": 66,
            "blob_url": "https://github.com/vercel/next.js/blob/4bf134433344c57df0ad23a0e7bc81b0a930e990/crates%2Fnext-core%2Fsrc%2Fnext_config.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4bf134433344c57df0ad23a0e7bc81b0a930e990/crates%2Fnext-core%2Fsrc%2Fnext_config.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_config.rs?ref=4bf134433344c57df0ad23a0e7bc81b0a930e990",
            "patch": "@@ -863,9 +863,6 @@ pub struct ExperimentalConfig {\n     /// Automatically apply the \"modularize_imports\" optimization to imports of\n     /// the specified packages.\n     optimize_package_imports: Option<Vec<RcStr>>,\n-    /// Using this feature will enable the `react@experimental` for the `app`\n-    /// directory.\n-    ppr: Option<ExperimentalPartialPrerendering>,\n     taint: Option<bool>,\n     proxy_timeout: Option<f64>,\n     /// enables the minification of server code.\n@@ -962,53 +959,6 @@ fn test_cache_life_profiles_invalid() {\n     );\n }\n \n-#[derive(\n-    Clone, Debug, PartialEq, Serialize, Deserialize, TraceRawVcs, NonLocalValue, OperationValue,\n-)]\n-#[serde(rename_all = \"lowercase\")]\n-pub enum ExperimentalPartialPrerenderingIncrementalValue {\n-    Incremental,\n-}\n-\n-#[derive(\n-    Clone, Debug, PartialEq, Deserialize, Serialize, TraceRawVcs, NonLocalValue, OperationValue,\n-)]\n-#[serde(untagged)]\n-pub enum ExperimentalPartialPrerendering {\n-    Boolean(bool),\n-    Incremental(ExperimentalPartialPrerenderingIncrementalValue),\n-}\n-\n-#[test]\n-fn test_parse_experimental_partial_prerendering() {\n-    let json = serde_json::json!({\n-        \"ppr\": \"incremental\"\n-    });\n-    let config: ExperimentalConfig = serde_json::from_value(json).unwrap();\n-    assert_eq!(\n-        config.ppr,\n-        Some(ExperimentalPartialPrerendering::Incremental(\n-            ExperimentalPartialPrerenderingIncrementalValue::Incremental\n-        ))\n-    );\n-\n-    let json = serde_json::json!({\n-        \"ppr\": true\n-    });\n-    let config: ExperimentalConfig = serde_json::from_value(json).unwrap();\n-    assert_eq!(\n-        config.ppr,\n-        Some(ExperimentalPartialPrerendering::Boolean(true))\n-    );\n-\n-    // Expect if we provide a random string, it will fail.\n-    let json = serde_json::json!({\n-        \"ppr\": \"random\"\n-    });\n-    let config = serde_json::from_value::<ExperimentalConfig>(json);\n-    assert!(config.is_err());\n-}\n-\n #[derive(\n     Clone, Debug, PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, NonLocalValue, OperationValue,\n )]\n@@ -1719,22 +1669,6 @@ impl NextConfig {\n         }\n     }\n \n-    #[turbo_tasks::function]\n-    pub fn enable_ppr(&self) -> Vc<bool> {\n-        Vc::cell(\n-            self.experimental\n-                .ppr\n-                .as_ref()\n-                .map(|ppr| match ppr {\n-                    ExperimentalPartialPrerendering::Incremental(\n-                        ExperimentalPartialPrerenderingIncrementalValue::Incremental,\n-                    ) => true,\n-                    ExperimentalPartialPrerendering::Boolean(b) => *b,\n-                })\n-                .unwrap_or(false),\n-        )\n-    }\n-\n     #[turbo_tasks::function]\n     pub fn enable_taint(&self) -> Vc<bool> {\n         Vc::cell(self.experimental.taint.unwrap_or(false))"
        }
    ],
    "stats": {
        "total": 66,
        "additions": 0,
        "deletions": 66
    }
}