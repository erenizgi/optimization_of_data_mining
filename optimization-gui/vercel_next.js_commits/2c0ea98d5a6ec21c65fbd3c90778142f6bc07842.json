{
    "author": "mischnic",
    "message": "Turbopack: don't block on parsing traced modules (#82602)\n\nWe were (unnecessarily) calling `is_self_async()` even for the traced externals (the directly referenced ones, not transitively). \r\nThis created a bottleneck during the global information computation:\r\n<img width=\"2560\" height=\"1315\" alt=\"Bildschirmfoto 2025-08-13 um 09 50 19\" src=\"https://github.com/user-attachments/assets/4f5d1fa6-3d65-40b2-875e-8a4a579b234b\" />\r\n\r\n`compute_async_module_info_single` calls `is_self_async` for every single module, regardless of whether the computed value is actually used or not (the traced modules have `ChunkingType::Traced`, so they'd never cause any importers to be async anyway). So manually optimize this case by overriding `is_self_async` for traced externals. This defers the parsing to emitting which is much more parallel:\r\n\r\n<img width=\"2560\" height=\"1315\" alt=\"Bildschirmfoto 2025-08-13 um 09 51 23\" src=\"https://github.com/user-attachments/assets/820c7157-7fe0-4253-b02f-1e0d2a8c7e7d\" />",
    "sha": "2c0ea98d5a6ec21c65fbd3c90778142f6bc07842",
    "files": [
        {
            "sha": "844e4c995020d5efbde6cb5288d6dd66c1471c95",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/external_module.rs",
            "status": "modified",
            "additions": 50,
            "deletions": 1,
            "changes": 51,
            "blob_url": "https://github.com/vercel/next.js/blob/2c0ea98d5a6ec21c65fbd3c90778142f6bc07842/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fexternal_module.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2c0ea98d5a6ec21c65fbd3c90778142f6bc07842/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fexternal_module.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fexternal_module.rs?ref=2c0ea98d5a6ec21c65fbd3c90778142f6bc07842",
            "patch": "@@ -255,7 +255,18 @@ impl Module for CachedExternalModule {\n                     .affecting_sources\n                     .iter()\n                     .map(|s| Vc::upcast::<Box<dyn Module>>(RawModule::new(**s)))\n-                    .chain(external_result.primary_modules_raw_iter().map(|rvc| *rvc))\n+                    .chain(\n+                        external_result\n+                            .primary_modules_raw_iter()\n+                            // These modules aren't bundled but still need to be part of the module\n+                            // graph for chunking. `compute_async_module_info` computes\n+                            // `is_self_async` for every module, but at least for traced modules,\n+                            // that value is never used as `ChunkingType::Traced.is_inherit_async()\n+                            // == false`. Optimize this case by using `ModuleWithoutSelfAsync` to\n+                            // short circuit that computation and thus defer parsing traced modules\n+                            // to emitting to not block all of chunking on this.\n+                            .map(|m| Vc::upcast(ModuleWithoutSelfAsync::new(*m))),\n+                    )\n                     .map(|s| {\n                         Vc::upcast::<Box<dyn ModuleReference>>(TracedModuleReference::new(s))\n                             .to_resolved()\n@@ -402,3 +413,41 @@ impl EcmascriptChunkItem for CachedExternalModuleChunkItem {\n         )\n     }\n }\n+\n+/// A wrapper \"passthrough\" module type that always returns `false` for `is_self_async`. Be careful\n+/// when using it, as it may hide async dependencies.\n+#[turbo_tasks::value]\n+pub struct ModuleWithoutSelfAsync {\n+    module: ResolvedVc<Box<dyn Module>>,\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl ModuleWithoutSelfAsync {\n+    #[turbo_tasks::function]\n+    pub fn new(module: ResolvedVc<Box<dyn Module>>) -> Vc<Self> {\n+        Self::cell(ModuleWithoutSelfAsync { module })\n+    }\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl Asset for ModuleWithoutSelfAsync {\n+    #[turbo_tasks::function]\n+    fn content(&self) -> Vc<AssetContent> {\n+        self.module.content()\n+    }\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl Module for ModuleWithoutSelfAsync {\n+    #[turbo_tasks::function]\n+    fn ident(&self) -> Vc<AssetIdent> {\n+        self.module.ident()\n+    }\n+\n+    #[turbo_tasks::function]\n+    fn references(&self) -> Vc<ModuleReferences> {\n+        self.module.references()\n+    }\n+\n+    // Don't override and use default is_self_async that always returns false\n+}"
        }
    ],
    "stats": {
        "total": 51,
        "additions": 50,
        "deletions": 1
    }
}