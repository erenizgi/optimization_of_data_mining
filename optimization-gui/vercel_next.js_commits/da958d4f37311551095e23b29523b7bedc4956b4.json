{
    "author": "devjiwonchoi",
    "message": "[ts-next-plugin] fix: warn only if no type (#78628)",
    "sha": "da958d4f37311551095e23b29523b7bedc4956b4",
    "files": [
        {
            "sha": "f30fb0ecaf71e1aae5df6eb823815388a7e9affd",
            "filename": "packages/next/src/server/typescript/rules/metadata.ts",
            "status": "modified",
            "additions": 27,
            "deletions": 131,
            "changes": 158,
            "blob_url": "https://github.com/vercel/next.js/blob/da958d4f37311551095e23b29523b7bedc4956b4/packages%2Fnext%2Fsrc%2Fserver%2Ftypescript%2Frules%2Fmetadata.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/da958d4f37311551095e23b29523b7bedc4956b4/packages%2Fnext%2Fsrc%2Fserver%2Ftypescript%2Frules%2Fmetadata.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Ftypescript%2Frules%2Fmetadata.ts?ref=da958d4f37311551095e23b29523b7bedc4956b4",
            "patch": "@@ -82,7 +82,7 @@ const metadata = {\n \n       if (ts.isFunctionDeclaration(node)) {\n         if (node.name?.getText() === 'generateMetadata') {\n-          if (hasCorrectType(node)) {\n+          if (hasType(node)) {\n             return []\n           }\n \n@@ -103,7 +103,7 @@ const metadata = {\n         }\n       } else {\n         for (const declaration of node.declarationList.declarations) {\n-          if (hasCorrectType(declaration)) {\n+          if (hasType(declaration)) {\n             return []\n           }\n \n@@ -209,7 +209,7 @@ const metadata = {\n             if (\n               declaration &&\n               ts.isFunctionDeclaration(declaration) &&\n-              !hasCorrectType(declaration)\n+              !hasType(declaration)\n             ) {\n               diagnostics.push({\n                 file: source,\n@@ -226,7 +226,7 @@ const metadata = {\n             if (\n               declaration &&\n               ts.isVariableDeclaration(declaration) &&\n-              !hasCorrectType(declaration)\n+              !hasType(declaration)\n             ) {\n               diagnostics.push({\n                 file: source,\n@@ -246,144 +246,40 @@ const metadata = {\n   },\n }\n \n-function hasCorrectType(\n-  node: tsModule.FunctionDeclaration | tsModule.VariableDeclaration\n-): boolean {\n-  // Skip if already has type.\n-  if (node.type) {\n-    return true\n-  }\n-\n-  const ts = getTs()\n-  const typeChecker = getTypeChecker()\n-  if (!typeChecker) {\n-    return false\n-  }\n-\n-  // For generateMetadata, check if it's Promise<Metadata> for async or Metadata for sync\n-  if (ts.isFunctionDeclaration(node)) {\n-    return checkFunctionReturnType(node, typeChecker)\n-  } else {\n-    // For variable declarations (const/let/var)\n-    const name = node.name.getText()\n-\n-    if (name === 'generateMetadata') {\n-      // For generateMetadata as a variable, it must be a function expression or arrow function\n-      if (\n-        !node.initializer ||\n-        (!ts.isFunctionExpression(node.initializer) &&\n-          !ts.isArrowFunction(node.initializer))\n-      ) {\n-        return false\n-      }\n-\n-      // Check the return type of the function expression/arrow function\n-      if (node.initializer.type) {\n-        // If it has an explicit return type annotation\n-        return checkFunctionReturnType(node.initializer, typeChecker)\n-      } else {\n-        // If no explicit return type, infer it from the function\n-        const signature = typeChecker.getSignatureFromDeclaration(\n-          node.initializer\n-        )\n-        if (!signature) return false\n-\n-        const returnType = typeChecker.getReturnTypeOfSignature(signature)\n-        if (!returnType) return false\n-\n-        const isAsync =\n-          node.initializer.modifiers?.some(\n-            (m) => m.kind === ts.SyntaxKind.AsyncKeyword\n-          ) ?? false\n-\n-        if (isAsync) {\n-          // For async functions, check if it's Promise<Metadata>\n-          const typeSymbol = returnType.getSymbol()\n-          if (!typeSymbol || typeSymbol.getName() !== 'Promise') return false\n-\n-          // Check if it's a reference type (like Promise<T>)\n-          if (\n-            !(returnType.flags & ts.TypeFlags.Object) ||\n-            !('typeArguments' in returnType)\n-          ) {\n-            return false\n-          }\n-\n-          const typeArgs = (\n-            returnType as { typeArguments: readonly tsModule.Type[] }\n-          ).typeArguments\n-          if (!typeArgs || typeArgs.length !== 1) return false\n-\n-          const promiseType = typeArgs[0]\n-          const promiseTypeSymbol = promiseType.getSymbol()\n-          return promiseTypeSymbol?.getName() === 'Metadata'\n-        } else {\n-          // For sync functions, check if it returns Metadata\n-          const returnTypeSymbol = returnType.getSymbol()\n-          return returnTypeSymbol?.getName() === 'Metadata'\n-        }\n-      }\n-    } else {\n-      // For metadata export, we just need Metadata type\n-      if (!node.type) return false\n-      const type = typeChecker.getTypeFromTypeNode(node.type)\n-      if (!type) return false\n-      const symbol = type.getSymbol()\n-      return symbol?.getName() === 'Metadata'\n-    }\n-  }\n-}\n-\n-function checkFunctionReturnType(\n+function hasType(\n   node:\n     | tsModule.FunctionDeclaration\n+    | tsModule.VariableDeclaration\n     | tsModule.FunctionExpression\n-    | tsModule.ArrowFunction,\n-  typeChecker: tsModule.TypeChecker\n+    | tsModule.ArrowFunction\n ): boolean {\n   const ts = getTs()\n \n-  if (!node.type) return false\n-\n-  const returnType = typeChecker.getTypeFromTypeNode(node.type)\n-  if (!returnType) return false\n-\n-  const isAsync =\n-    node.modifiers?.some((m) => m.kind === ts.SyntaxKind.AsyncKeyword) ?? false\n-\n-  if (isAsync) {\n-    // For async functions, we need Promise<Metadata>\n-    const typeSymbol = returnType.getSymbol()\n-    if (!typeSymbol || typeSymbol.getName() !== 'Promise') {\n-      return false\n-    }\n-\n-    // Get the type argument of Promise<T>\n-    if (!ts.isTypeReferenceNode(node.type)) {\n-      return false\n-    }\n+  // For function declarations, expressions, and arrow functions, check if they have return type\n+  if (\n+    ts.isFunctionDeclaration(node) ||\n+    ts.isFunctionExpression(node) ||\n+    ts.isArrowFunction(node)\n+  ) {\n+    return !!node.type\n+  }\n \n-    // Check if it's a reference type (like Promise<T>)\n+  // For variable declarations\n+  if (!node.name) return false\n+  const name = node.name.getText()\n+  if (name === 'generateMetadata') {\n+    // If it's a function expression or arrow function, check if it has return type\n     if (\n-      !(returnType.flags & ts.TypeFlags.Object) ||\n-      !('typeArguments' in returnType)\n+      node.initializer &&\n+      (ts.isFunctionExpression(node.initializer) ||\n+        ts.isArrowFunction(node.initializer))\n     ) {\n-      return false\n-    }\n-\n-    const typeArgs = (returnType as { typeArguments: readonly tsModule.Type[] })\n-      .typeArguments\n-    if (!typeArgs || typeArgs.length !== 1) {\n-      return false\n+      return !!node.initializer.type\n     }\n-    const promiseType = typeArgs[0]\n-    const promiseTypeSymbol = promiseType.getSymbol()\n-    return promiseTypeSymbol?.getName() === 'Metadata'\n-  } else {\n-    // For sync functions, we need Metadata directly\n-    const symbol = returnType.getSymbol()\n-    return symbol?.getName() === 'Metadata'\n   }\n+\n+  // For all other cases, check if the node has a type annotation\n+  return !!node.type\n }\n \n export default metadata"
        }
    ],
    "stats": {
        "total": 158,
        "additions": 27,
        "deletions": 131
    }
}