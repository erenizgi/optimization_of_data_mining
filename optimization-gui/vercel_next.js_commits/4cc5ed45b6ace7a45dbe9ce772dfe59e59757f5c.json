{
    "author": "ijjk",
    "message": "Remove web-server from edge-ssr-app (#81389)\n\nContinues https://github.com/vercel/next.js/pull/80915 removing the\nfinal usage of `web-server` from `edge-ssr-app`.\n\nValidated against our deploy E2E tests here\nhttps://github.com/vercel/next.js/actions/runs/16428349930/job/46424359435\nand\nhttps://github.com/vercel/vercel/actions/runs/16428657423/job/46425277718?pr=13582\n\nCloses PACK-1824",
    "sha": "4cc5ed45b6ace7a45dbe9ce772dfe59e59757f5c",
    "files": [
        {
            "sha": "c4f9db15adccdd0a7106e5c6c200fa841ef1c390",
            "filename": "crates/next-core/src/next_app/app_page_entry.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 20,
            "changes": 20,
            "blob_url": "https://github.com/vercel/next.js/blob/4cc5ed45b6ace7a45dbe9ce772dfe59e59757f5c/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fapp_page_entry.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4cc5ed45b6ace7a45dbe9ce772dfe59e59757f5c/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fapp_page_entry.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fapp_page_entry.rs?ref=4cc5ed45b6ace7a45dbe9ce772dfe59e59757f5c",
            "patch": "@@ -155,22 +155,6 @@ async fn wrap_edge_page(\n \n     let next_config_val = &*next_config.await?;\n \n-    // TODO(WEB-1824): add build support\n-    let dev = true;\n-\n-    // TODO(timneutkens): remove this\n-    let is_server_component = true;\n-\n-    let server_actions = next_config.experimental_server_actions().await?;\n-\n-    let sri_enabled = !dev\n-        && next_config\n-            .experimental_sri()\n-            .await?\n-            .as_ref()\n-            .map(|sri| sri.algorithm.as_ref())\n-            .is_some();\n-\n     let source = load_next_js_template(\n         \"edge-ssr-app.js\",\n         project_root.clone(),\n@@ -179,13 +163,9 @@ async fn wrap_edge_page(\n             \"VAR_PAGE\" => page.to_string().into(),\n         },\n         fxindexmap! {\n-            \"sriEnabled\" => serde_json::Value::Bool(sri_enabled).to_string().into(),\n             // TODO do we really need to pass the entire next config here?\n             // This is bad for invalidation as any config change will invalidate this\n             \"nextConfig\" => serde_json::to_string(next_config_val)?.into(),\n-            \"isServerComponent\" => serde_json::Value::Bool(is_server_component).to_string().into(),\n-            \"dev\" => serde_json::Value::Bool(dev).to_string().into(),\n-            \"serverActions\" => serde_json::to_string(&server_actions)?.into(),\n         },\n         fxindexmap! {\n             \"incrementalCacheHandler\" => None,"
        },
        {
            "sha": "e42c1c859de40958fb16b62ff3db3b4a56bbdd53",
            "filename": "packages/next/src/build/templates/edge-ssr-app.ts",
            "status": "modified",
            "additions": 314,
            "deletions": 52,
            "changes": 366,
            "blob_url": "https://github.com/vercel/next.js/blob/4cc5ed45b6ace7a45dbe9ce772dfe59e59757f5c/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fedge-ssr-app.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/4cc5ed45b6ace7a45dbe9ce772dfe59e59757f5c/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fedge-ssr-app.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fedge-ssr-app.ts?ref=4cc5ed45b6ace7a45dbe9ce772dfe59e59757f5c",
            "patch": "@@ -1,56 +1,44 @@\n import '../../server/web/globals'\n-import { adapter } from '../../server/web/adapter'\n-import { getRender } from '../webpack/loaders/next-edge-ssr-loader/render'\n+import { adapter, type NextRequestHint } from '../../server/web/adapter'\n import { IncrementalCache } from '../../server/lib/incremental-cache'\n \n-import { renderToHTMLOrFlight as renderToHTML } from '../../server/app-render/app-render'\n import * as pageMod from 'VAR_USERLAND'\n \n-import type { DocumentType } from '../../shared/lib/utils'\n-import type { BuildManifest } from '../../server/get-page-files'\n import type { RequestData } from '../../server/web/types'\n import type { NextConfigComplete } from '../../server/config-shared'\n-import { PAGE_TYPES } from '../../lib/page-types'\n import { setReferenceManifestsSingleton } from '../../server/app-render/encryption-utils'\n import { createServerModuleMap } from '../../server/app-render/action-utils'\n import { initializeCacheHandlers } from '../../server/use-cache/handlers'\n+import { BaseServerSpan } from '../../server/lib/trace/constants'\n+import { getTracer, SpanKind, type Span } from '../../server/lib/trace/tracer'\n+import { WebNextRequest, WebNextResponse } from '../../server/base-http/web'\n+import type { NextFetchEvent } from '../../server/web/spec-extension/fetch-event'\n+import type {\n+  AppPageRouteHandlerContext,\n+  AppPageRouteModule,\n+} from '../../server/route-modules/app-page/module.compiled'\n+import type { AppPageRenderResultMetadata } from '../../server/render-result'\n+import type RenderResult from '../../server/render-result'\n+import { getIsPossibleServerAction } from '../../server/lib/server-action-request-meta'\n+import { getBotType } from '../../shared/lib/router/utils/is-bot'\n+import { interopDefault } from '../../lib/interop-default'\n+import { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\n+import { checkIsOnDemandRevalidate } from '../../server/api-utils'\n \n declare const incrementalCacheHandler: any\n // OPTIONAL_IMPORT:incrementalCacheHandler\n \n // Initialize the cache handlers interface.\n initializeCacheHandlers()\n \n-const Document: DocumentType = null!\n-const appMod = null\n-const errorMod = null\n-const error500Mod = null\n-\n // injected by the loader afterwards.\n-declare const sriEnabled: boolean\n-declare const isServerComponent: boolean\n-declare const dev: boolean\n-declare const serverActions: any\n declare const nextConfig: NextConfigComplete\n-// INJECT:sriEnabled\n-// INJECT:isServerComponent\n-// INJECT:dev\n-// INJECT:serverActions\n // INJECT:nextConfig\n \n const maybeJSONParse = (str?: string) => (str ? JSON.parse(str) : undefined)\n \n-const buildManifest: BuildManifest = self.__BUILD_MANIFEST as any\n-const reactLoadableManifest = maybeJSONParse(self.__REACT_LOADABLE_MANIFEST)\n const rscManifest = self.__RSC_MANIFEST?.['VAR_PAGE']\n const rscServerManifest = maybeJSONParse(self.__RSC_SERVER_MANIFEST)\n-const subresourceIntegrityManifest = sriEnabled\n-  ? maybeJSONParse(self.__SUBRESOURCE_INTEGRITY_MANIFEST)\n-  : undefined\n-const nextFontManifest = maybeJSONParse(self.__NEXT_FONT_MANIFEST)\n-\n-const interceptionRouteRewrites =\n-  maybeJSONParse(self.__INTERCEPTION_ROUTE_REWRITE_MANIFEST) ?? []\n \n if (rscManifest && rscServerManifest) {\n   setReferenceManifestsSingleton({\n@@ -63,35 +51,309 @@ if (rscManifest && rscServerManifest) {\n   })\n }\n \n-const render = getRender({\n-  pagesType: PAGE_TYPES.APP,\n-  dev,\n-  page: 'VAR_PAGE',\n-  appMod,\n-  pageMod,\n-  errorMod,\n-  error500Mod,\n-  Document,\n-  buildManifest,\n-  renderToHTML,\n-  reactLoadableManifest,\n-  clientReferenceManifest: isServerComponent ? rscManifest : null,\n-  serverActionsManifest: isServerComponent ? rscServerManifest : null,\n-  serverActions: isServerComponent ? serverActions : undefined,\n-  subresourceIntegrityManifest,\n-  config: nextConfig,\n-  buildId: process.env.__NEXT_BUILD_ID!,\n-  nextFontManifest,\n-  incrementalCacheHandler,\n-  interceptionRouteRewrites,\n-})\n-\n export const ComponentMod = pageMod\n \n+async function requestHandler(\n+  req: NextRequestHint,\n+  event: NextFetchEvent\n+): Promise<Response> {\n+  let srcPage = 'VAR_PAGE'\n+\n+  const normalizedSrcPage = normalizeAppPath(srcPage)\n+  const relativeUrl = `${req.nextUrl.pathname}${req.nextUrl.search}`\n+  const baseReq = new WebNextRequest(req)\n+  const baseRes = new WebNextResponse(undefined)\n+\n+  const pageRouteModule = pageMod.routeModule as AppPageRouteModule\n+  const prepareResult = await pageRouteModule.prepare(baseReq, null, {\n+    srcPage,\n+    multiZoneDraftMode: false,\n+  })\n+\n+  if (!prepareResult) {\n+    return new Response('Bad Request', {\n+      status: 400,\n+    })\n+  }\n+  const {\n+    query,\n+    params,\n+    buildId,\n+    buildManifest,\n+    prerenderManifest,\n+    reactLoadableManifest,\n+    clientReferenceManifest,\n+    subresourceIntegrityManifest,\n+    dynamicCssManifest,\n+    nextFontManifest,\n+    resolvedPathname,\n+    serverActionsManifest,\n+    interceptionRoutePatterns,\n+    routerServerContext,\n+  } = prepareResult\n+\n+  const isPossibleServerAction = getIsPossibleServerAction(req)\n+  const botType = getBotType(req.headers.get('User-Agent') || '')\n+  const { isOnDemandRevalidate } = checkIsOnDemandRevalidate(\n+    req,\n+    prerenderManifest.preview\n+  )\n+\n+  const renderContext: AppPageRouteHandlerContext = {\n+    page: normalizedSrcPage,\n+    query,\n+    params,\n+\n+    sharedContext: {\n+      buildId,\n+    },\n+    fallbackRouteParams: null,\n+\n+    renderOpts: {\n+      App: () => null,\n+      Document: () => null,\n+      pageConfig: {},\n+      ComponentMod,\n+      Component: interopDefault(ComponentMod),\n+      routeModule: pageRouteModule,\n+\n+      params,\n+      page: srcPage,\n+      postponed: undefined,\n+      shouldWaitOnAllReady: false,\n+      serveStreamingMetadata: true,\n+      supportsDynamicResponse: true,\n+      buildManifest,\n+      nextFontManifest,\n+      reactLoadableManifest,\n+      subresourceIntegrityManifest,\n+      dynamicCssManifest,\n+      serverActionsManifest,\n+      clientReferenceManifest,\n+      setIsrStatus: routerServerContext?.setIsrStatus,\n+\n+      dir: pageRouteModule.projectDir,\n+      botType,\n+      isDraftMode: false,\n+      isRevalidate: false,\n+      isOnDemandRevalidate,\n+      isPossibleServerAction,\n+      assetPrefix: nextConfig.assetPrefix,\n+      nextConfigOutput: nextConfig.output,\n+      crossOrigin: nextConfig.crossOrigin,\n+      trailingSlash: nextConfig.trailingSlash,\n+      previewProps: prerenderManifest.preview,\n+      deploymentId: nextConfig.deploymentId,\n+      enableTainting: nextConfig.experimental.taint,\n+      htmlLimitedBots: nextConfig.htmlLimitedBots,\n+      devtoolSegmentExplorer: nextConfig.experimental.devtoolSegmentExplorer,\n+      reactMaxHeadersLength: nextConfig.reactMaxHeadersLength,\n+\n+      multiZoneDraftMode: false,\n+      cacheLifeProfiles: nextConfig.experimental.cacheLife,\n+      basePath: nextConfig.basePath,\n+      serverActions: nextConfig.experimental.serverActions,\n+\n+      experimental: {\n+        isRoutePPREnabled: false,\n+        expireTime: nextConfig.expireTime,\n+        staleTimes: nextConfig.experimental.staleTimes,\n+        cacheComponents: Boolean(nextConfig.experimental.cacheComponents),\n+        clientSegmentCache: Boolean(nextConfig.experimental.clientSegmentCache),\n+        dynamicOnHover: Boolean(nextConfig.experimental.dynamicOnHover),\n+        inlineCss: Boolean(nextConfig.experimental.inlineCss),\n+        authInterrupts: Boolean(nextConfig.experimental.authInterrupts),\n+        clientTraceMetadata:\n+          nextConfig.experimental.clientTraceMetadata || ([] as any),\n+      },\n+\n+      incrementalCache: await pageRouteModule.getIncrementalCache(\n+        baseReq,\n+        nextConfig,\n+        prerenderManifest\n+      ),\n+\n+      waitUntil: event.waitUntil.bind(event),\n+      onClose: (cb) => {\n+        onCloseCallback = cb\n+      },\n+      onAfterTaskError: () => {},\n+\n+      onInstrumentationRequestError: (error, _request, errorContext) =>\n+        pageRouteModule.onRequestError(\n+          baseReq,\n+          error,\n+          errorContext,\n+          routerServerContext\n+        ),\n+      dev: pageRouteModule.isDev,\n+    },\n+  }\n+  let finalStatus = 200\n+  let onCloseCallback: (() => void) | undefined\n+\n+  const renderResultToResponse = (\n+    result: RenderResult<AppPageRenderResultMetadata>\n+  ): Response => {\n+    const varyHeader = pageRouteModule.getVaryHeader(\n+      resolvedPathname,\n+      interceptionRoutePatterns\n+    )\n+    // Handle null responses\n+    if (result.isNull) {\n+      finalStatus = 500\n+      onCloseCallback?.()\n+      return new Response(null, { status: 500 })\n+    }\n+\n+    // Extract metadata\n+    const { metadata } = result\n+    const headers = new Headers()\n+    finalStatus = metadata.statusCode || baseRes.statusCode || 200\n+    // Pull any fetch metrics from the render onto the request.\n+    ;(req as any).fetchMetrics = metadata.fetchMetrics\n+\n+    // Set content type\n+    const contentType = result.contentType || 'text/html; charset=utf-8'\n+    headers.set('Content-Type', contentType)\n+    headers.set('x-edge-runtime', '1')\n+\n+    if (varyHeader) {\n+      headers.set('Vary', varyHeader)\n+    }\n+\n+    // Add existing headers\n+    for (const [key, value] of Object.entries({\n+      ...baseRes.getHeaders(),\n+      ...metadata.headers,\n+    })) {\n+      if (value !== undefined) {\n+        if (Array.isArray(value)) {\n+          // Handle multiple header values\n+          for (const v of value) {\n+            headers.append(key, String(v))\n+          }\n+        } else {\n+          headers.set(key, String(value))\n+        }\n+      }\n+    }\n+\n+    // Handle static response\n+    if (!result.isDynamic) {\n+      const body = result.toUnchunkedString()\n+      headers.set(\n+        'Content-Length',\n+        String(new TextEncoder().encode(body).length)\n+      )\n+      onCloseCallback?.()\n+      return new Response(body, {\n+        status: finalStatus,\n+        headers,\n+      })\n+    }\n+\n+    // Handle dynamic/streaming response\n+    // For edge runtime, we need to create a readable stream that pipes from the result\n+    const { readable, writable } = new TransformStream()\n+\n+    // Start piping the result to the writable stream\n+    // This is done asynchronously to avoid blocking the response creation\n+    result\n+      .pipeTo(writable)\n+      .catch((err: unknown) => {\n+        console.error('Error piping RenderResult to response:', err)\n+      })\n+      .finally(() => onCloseCallback?.())\n+\n+    return new Response(readable, {\n+      status: finalStatus,\n+      headers,\n+    })\n+  }\n+\n+  const invokeRender = async (span?: Span): Promise<Response> => {\n+    try {\n+      const result = await pageRouteModule\n+        .render(baseReq, baseRes, renderContext)\n+        .finally(() => {\n+          if (!span) return\n+\n+          span.setAttributes({\n+            'http.status_code': finalStatus,\n+            'next.rsc': false,\n+          })\n+\n+          const rootSpanAttributes = tracer.getRootSpanAttributes()\n+          // We were unable to get attributes, probably OTEL is not enabled\n+          if (!rootSpanAttributes) {\n+            return\n+          }\n+\n+          if (\n+            rootSpanAttributes.get('next.span_type') !==\n+            BaseServerSpan.handleRequest\n+          ) {\n+            console.warn(\n+              `Unexpected root span type '${rootSpanAttributes.get(\n+                'next.span_type'\n+              )}'. Please report this Next.js issue https://github.com/vercel/next.js`\n+            )\n+            return\n+          }\n+\n+          const route = normalizedSrcPage\n+          if (route) {\n+            const name = `${req.method} ${route}`\n+\n+            span.setAttributes({\n+              'next.route': route,\n+              'http.route': route,\n+              'next.span_name': name,\n+            })\n+            span.updateName(name)\n+          } else {\n+            span.updateName(`${req.method} ${relativeUrl}`)\n+          }\n+        })\n+\n+      return renderResultToResponse(result)\n+    } catch (err) {\n+      await pageRouteModule.onRequestError(baseReq, err, {\n+        routerKind: 'App Router',\n+        routePath: normalizedSrcPage,\n+        routeType: 'render',\n+        revalidateReason: undefined,\n+      })\n+      // rethrow so that we can handle serving error page\n+      throw err\n+    }\n+  }\n+\n+  const tracer = getTracer()\n+\n+  return tracer.withPropagatedContext(req.headers, () =>\n+    tracer.trace(\n+      BaseServerSpan.handleRequest,\n+      {\n+        spanName: `${req.method} ${relativeUrl}`,\n+        kind: SpanKind.SERVER,\n+        attributes: {\n+          'http.method': req.method,\n+          'http.target': relativeUrl,\n+          'http.route': normalizedSrcPage,\n+        },\n+      },\n+      invokeRender\n+    )\n+  )\n+}\n+\n export default function nHandler(opts: { page: string; request: RequestData }) {\n   return adapter({\n     ...opts,\n     IncrementalCache,\n-    handler: render,\n+    handler: requestHandler,\n+    incrementalCacheHandler,\n   })\n }"
        },
        {
            "sha": "33ac1546391419daa6a4985b5d303163f5afa5d2",
            "filename": "packages/next/src/build/templates/edge-ssr.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 5,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/4cc5ed45b6ace7a45dbe9ce772dfe59e59757f5c/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fedge-ssr.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/4cc5ed45b6ace7a45dbe9ce772dfe59e59757f5c/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fedge-ssr.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fedge-ssr.ts?ref=4cc5ed45b6ace7a45dbe9ce772dfe59e59757f5c",
            "patch": "@@ -13,9 +13,6 @@ declare const incrementalCacheHandler: any\n // OPTIONAL_IMPORT:* as userland500Page\n // OPTIONAL_IMPORT:incrementalCacheHandler\n \n-// TODO: re-enable this once we've refactored to use implicit matches\n-// const renderToHTML = undefined\n-\n import RouteModule, {\n   type PagesRouteHandlerContext,\n } from '../../server/route-modules/pages/module'\n@@ -342,8 +339,6 @@ async function requestHandler(\n \n   const tracer = getTracer()\n \n-  // TODO: activeSpan code path is for when wrapped by\n-  // next-server can be removed when this is no longer used\n   return tracer.withPropagatedContext(req.headers, () =>\n     tracer.trace(\n       BaseServerSpan.handleRequest,"
        },
        {
            "sha": "b4d6e6d72f84c575e2d4979a301109bf53722aef",
            "filename": "packages/next/src/build/webpack/loaders/next-edge-ssr-loader/index.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 10,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/4cc5ed45b6ace7a45dbe9ce772dfe59e59757f5c/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack%2Floaders%2Fnext-edge-ssr-loader%2Findex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/4cc5ed45b6ace7a45dbe9ce772dfe59e59757f5c/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack%2Floaders%2Fnext-edge-ssr-loader%2Findex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack%2Floaders%2Fnext-edge-ssr-loader%2Findex.ts?ref=4cc5ed45b6ace7a45dbe9ce772dfe59e59757f5c",
            "patch": "@@ -66,7 +66,6 @@ function getRouteModuleOptions(page: string) {\n const edgeSSRLoader: webpack.LoaderDefinitionFunction<EdgeSSRLoaderQuery> =\n   async function edgeSSRLoader(this) {\n     const {\n-      dev,\n       page,\n       absolutePagePath,\n       absoluteAppPath,\n@@ -77,12 +76,10 @@ const edgeSSRLoader: webpack.LoaderDefinitionFunction<EdgeSSRLoaderQuery> =\n       stringifiedConfig: stringifiedConfigBase64,\n       appDirLoader: appDirLoaderBase64,\n       pagesType,\n-      sriEnabled,\n       cacheHandler,\n       cacheHandlers: cacheHandlersStringified,\n       preferredRegion,\n       middlewareConfig: middlewareConfigBase64,\n-      serverActions,\n     } = this.getOptions()\n \n     const cacheHandlers = JSON.parse(cacheHandlersStringified || '{}')\n@@ -158,14 +155,7 @@ const edgeSSRLoader: webpack.LoaderDefinitionFunction<EdgeSSRLoaderQuery> =\n           VAR_PAGE: page,\n         },\n         {\n-          sriEnabled: JSON.stringify(sriEnabled),\n           nextConfig: stringifiedConfig,\n-          isServerComponent: JSON.stringify(isServerComponent),\n-          dev: JSON.stringify(dev),\n-          serverActions:\n-            typeof serverActions === 'undefined'\n-              ? 'undefined'\n-              : JSON.stringify(serverActions),\n         },\n         {\n           incrementalCacheHandler: cacheHandler ?? null,"
        },
        {
            "sha": "c45746066b892ccfb57f1ef2f9c60ab04ed3c599",
            "filename": "packages/next/src/build/webpack/loaders/next-edge-ssr-loader/render.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 182,
            "changes": 182,
            "blob_url": "https://github.com/vercel/next.js/blob/174a241a7a0243881fc96d40c6abc7115aa6e040/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack%2Floaders%2Fnext-edge-ssr-loader%2Frender.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/174a241a7a0243881fc96d40c6abc7115aa6e040/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack%2Floaders%2Fnext-edge-ssr-loader%2Frender.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack%2Floaders%2Fnext-edge-ssr-loader%2Frender.ts?ref=174a241a7a0243881fc96d40c6abc7115aa6e040",
            "patch": "@@ -1,182 +0,0 @@\n-import type { NextConfigComplete } from '../../../../server/config-shared'\n-\n-import type { DocumentType, AppType } from '../../../../shared/lib/utils'\n-import type { BuildManifest } from '../../../../server/get-page-files'\n-import type {\n-  DynamicCssManifest,\n-  ReactLoadableManifest,\n-} from '../../../../server/load-components'\n-import type { ClientReferenceManifest } from '../../plugins/flight-manifest-plugin'\n-import type { NextFontManifest } from '../../plugins/next-font-manifest-plugin'\n-import type { NextFetchEvent } from '../../../../server/web/spec-extension/fetch-event'\n-\n-import WebServer from '../../../../server/web-server'\n-import {\n-  WebNextRequest,\n-  WebNextResponse,\n-} from '../../../../server/base-http/web'\n-import { SERVER_RUNTIME } from '../../../../lib/constants'\n-import type { ManifestRewriteRoute } from '../../..'\n-import { normalizeAppPath } from '../../../../shared/lib/router/utils/app-paths'\n-import type { SizeLimit } from '../../../../types'\n-import { internal_getCurrentFunctionWaitUntil } from '../../../../server/web/internal-edge-wait-until'\n-import type { PAGE_TYPES } from '../../../../lib/page-types'\n-import type { NextRequestHint } from '../../../../server/web/adapter'\n-\n-export function getRender({\n-  dev,\n-  page,\n-  appMod,\n-  pageMod,\n-  errorMod,\n-  error500Mod,\n-  pagesType,\n-  Document,\n-  buildManifest,\n-  reactLoadableManifest,\n-  dynamicCssManifest,\n-  interceptionRouteRewrites,\n-  renderToHTML,\n-  clientReferenceManifest,\n-  subresourceIntegrityManifest,\n-  serverActionsManifest,\n-  serverActions,\n-  config,\n-  buildId,\n-  nextFontManifest,\n-  incrementalCacheHandler,\n-}: {\n-  pagesType: PAGE_TYPES\n-  dev: boolean\n-  page: string\n-  appMod: any\n-  pageMod: any\n-  errorMod: any\n-  error500Mod: any\n-  renderToHTML?: any\n-  Document: DocumentType\n-  buildManifest: BuildManifest\n-  reactLoadableManifest: ReactLoadableManifest\n-  dynamicCssManifest?: DynamicCssManifest\n-  subresourceIntegrityManifest?: Record<string, string>\n-  interceptionRouteRewrites?: ManifestRewriteRoute[]\n-  clientReferenceManifest?: ClientReferenceManifest\n-  serverActionsManifest?: any\n-  serverActions?: {\n-    bodySizeLimit?: SizeLimit\n-    allowedOrigins?: string[]\n-  }\n-  config: NextConfigComplete\n-  buildId: string\n-  nextFontManifest: NextFontManifest\n-  incrementalCacheHandler?: any\n-}) {\n-  const isAppPath = pagesType === 'app'\n-  const baseLoadComponentResult = {\n-    dev,\n-    buildManifest,\n-    reactLoadableManifest,\n-    dynamicCssManifest,\n-    subresourceIntegrityManifest,\n-    Document,\n-    App: appMod?.default as AppType,\n-    clientReferenceManifest,\n-  }\n-\n-  const server = new WebServer({\n-    dev,\n-    buildId,\n-    conf: config,\n-    minimalMode: true,\n-    webServerConfig: {\n-      page,\n-      pathname: isAppPath ? normalizeAppPath(page) : page,\n-      pagesType,\n-      interceptionRouteRewrites,\n-      extendRenderOpts: {\n-        runtime: SERVER_RUNTIME.experimentalEdge,\n-        supportsDynamicResponse: true,\n-        disableOptimizedLoading: true,\n-        serverActionsManifest,\n-        serverActions,\n-        nextFontManifest,\n-        devtoolSegmentExplorer: config.experimental.devtoolSegmentExplorer,\n-      },\n-      renderToHTML,\n-      incrementalCacheHandler,\n-      loadComponent: async (inputPage) => {\n-        if (inputPage === page) {\n-          return {\n-            ...baseLoadComponentResult,\n-            Component: pageMod.default,\n-            pageConfig: pageMod.config || {},\n-            getStaticProps: pageMod.getStaticProps,\n-            getServerSideProps: pageMod.getServerSideProps,\n-            getStaticPaths: pageMod.getStaticPaths,\n-            ComponentMod: pageMod,\n-            isAppPath: !!pageMod.__next_app__,\n-            page: inputPage,\n-            routeModule: pageMod.routeModule,\n-          }\n-        }\n-\n-        // If there is a custom 500 page, we need to handle it separately.\n-        if (inputPage === '/500' && error500Mod) {\n-          return {\n-            ...baseLoadComponentResult,\n-            Component: error500Mod.default,\n-            pageConfig: error500Mod.config || {},\n-            getStaticProps: error500Mod.getStaticProps,\n-            getServerSideProps: error500Mod.getServerSideProps,\n-            getStaticPaths: error500Mod.getStaticPaths,\n-            ComponentMod: error500Mod,\n-            page: inputPage,\n-            routeModule: error500Mod.routeModule,\n-          }\n-        }\n-\n-        if (inputPage === '/_error') {\n-          return {\n-            ...baseLoadComponentResult,\n-            Component: errorMod.default,\n-            pageConfig: errorMod.config || {},\n-            getStaticProps: errorMod.getStaticProps,\n-            getServerSideProps: errorMod.getServerSideProps,\n-            getStaticPaths: errorMod.getStaticPaths,\n-            ComponentMod: errorMod,\n-            page: inputPage,\n-            routeModule: errorMod.routeModule,\n-          }\n-        }\n-\n-        return null\n-      },\n-    },\n-  })\n-\n-  const handler = server.getRequestHandler()\n-\n-  return async function render(\n-    request: NextRequestHint,\n-    event?: NextFetchEvent\n-  ) {\n-    const extendedReq = new WebNextRequest(request)\n-    const extendedRes = new WebNextResponse(undefined)\n-\n-    handler(extendedReq, extendedRes)\n-    const result = await extendedRes.toResponse()\n-    request.fetchMetrics = extendedReq.fetchMetrics\n-\n-    if (event?.waitUntil) {\n-      // TODO(after):\n-      // remove `internal_runWithWaitUntil` and the `internal-edge-wait-until` module\n-      // when consumers switch to `after`.\n-      const waitUntilPromise = internal_getCurrentFunctionWaitUntil()\n-      if (waitUntilPromise) {\n-        event.waitUntil(waitUntilPromise)\n-      }\n-    }\n-\n-    return result\n-  }\n-}"
        },
        {
            "sha": "3bc28eee427abcfa78217ec07a3a191329991b34",
            "filename": "packages/next/src/lib/generate-interception-routes-rewrites.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/4cc5ed45b6ace7a45dbe9ce772dfe59e59757f5c/packages%2Fnext%2Fsrc%2Flib%2Fgenerate-interception-routes-rewrites.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/4cc5ed45b6ace7a45dbe9ce772dfe59e59757f5c/packages%2Fnext%2Fsrc%2Flib%2Fgenerate-interception-routes-rewrites.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Flib%2Fgenerate-interception-routes-rewrites.ts?ref=4cc5ed45b6ace7a45dbe9ce772dfe59e59757f5c",
            "patch": "@@ -5,6 +5,7 @@ import {\n } from '../shared/lib/router/utils/interception-routes'\n import type { Rewrite } from './load-custom-routes'\n import { safePathToRegexp } from '../shared/lib/router/utils/route-match-utils'\n+import type { DeepReadonly } from '../shared/lib/deep-readonly'\n \n // a function that converts normalised paths (e.g. /foo/[bar]/[baz]) to the format expected by pathToRegexp (e.g. /foo/:bar/:baz)\n function toPathToRegexpPath(path: string): string {\n@@ -62,7 +63,7 @@ export function generateInterceptionRoutesRewrites(\n   return rewrites\n }\n \n-export function isInterceptionRouteRewrite(route: Rewrite) {\n+export function isInterceptionRouteRewrite(route: DeepReadonly<Rewrite>) {\n   // When we generate interception rewrites in the above implementation, we always do so with only a single `has` condition.\n   return route.has?.[0]?.key === NEXT_URL\n }"
        },
        {
            "sha": "30ba9c10b38e9d8c3d8b8cfa6c97aa6fe90a2f12",
            "filename": "packages/next/src/server/route-modules/app-page/module.ts",
            "status": "modified",
            "additions": 39,
            "deletions": 0,
            "changes": 39,
            "blob_url": "https://github.com/vercel/next.js/blob/4cc5ed45b6ace7a45dbe9ce772dfe59e59757f5c/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Fapp-page%2Fmodule.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/4cc5ed45b6ace7a45dbe9ce772dfe59e59757f5c/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Fapp-page%2Fmodule.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Fapp-page%2Fmodule.ts?ref=4cc5ed45b6ace7a45dbe9ce772dfe59e59757f5c",
            "patch": "@@ -20,6 +20,14 @@ import type { ServerComponentsHmrCache } from '../../response-cache'\n import type { FallbackRouteParams } from '../../request/fallback-params'\n import { PrerenderManifestMatcher } from './helpers/prerender-manifest-matcher'\n import type { DeepReadonly } from '../../../shared/lib/deep-readonly'\n+import {\n+  NEXT_ROUTER_PREFETCH_HEADER,\n+  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n+  NEXT_ROUTER_STATE_TREE_HEADER,\n+  NEXT_URL,\n+  RSC_HEADER,\n+} from '../../../client/components/app-router-headers'\n+import { isInterceptionRouteAppPath } from '../../../shared/lib/router/utils/interception-routes'\n \n let vendoredReactRSC\n let vendoredReactSSR\n@@ -127,6 +135,37 @@ export class AppPageRouteModule extends RouteModule<\n       context.sharedContext\n     )\n   }\n+\n+  private pathCouldBeIntercepted(\n+    resolvedPathname: string,\n+    interceptionRoutePatterns: RegExp[]\n+  ): boolean {\n+    return (\n+      isInterceptionRouteAppPath(resolvedPathname) ||\n+      interceptionRoutePatterns.some((regexp) => {\n+        return regexp.test(resolvedPathname)\n+      })\n+    )\n+  }\n+\n+  public getVaryHeader(\n+    resolvedPathname: string,\n+    interceptionRoutePatterns: RegExp[]\n+  ): string {\n+    const baseVaryHeader = `${RSC_HEADER}, ${NEXT_ROUTER_STATE_TREE_HEADER}, ${NEXT_ROUTER_PREFETCH_HEADER}, ${NEXT_ROUTER_SEGMENT_PREFETCH_HEADER}`\n+\n+    if (\n+      this.pathCouldBeIntercepted(resolvedPathname, interceptionRoutePatterns)\n+    ) {\n+      // Interception route responses can vary based on the `Next-URL` header.\n+      // We use the Vary header to signal this behavior to the client to properly cache the response.\n+      return `${baseVaryHeader}, ${NEXT_URL}`\n+    } else {\n+      // We don't need to include `Next-URL` in the Vary header for non-interception routes since it won't affect the response.\n+      // We also set this header for pages to avoid caching issues when navigating between pages and app.\n+      return baseVaryHeader\n+    }\n+  }\n }\n \n const vendored = {"
        },
        {
            "sha": "9087b801db3819a4d6a27cb384a3517843f21bdd",
            "filename": "packages/next/src/server/route-modules/route-module.ts",
            "status": "modified",
            "additions": 13,
            "deletions": 4,
            "changes": 17,
            "blob_url": "https://github.com/vercel/next.js/blob/4cc5ed45b6ace7a45dbe9ce772dfe59e59757f5c/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Froute-module.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/4cc5ed45b6ace7a45dbe9ce772dfe59e59757f5c/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Froute-module.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Froute-module.ts?ref=4cc5ed45b6ace7a45dbe9ce772dfe59e59757f5c",
            "patch": "@@ -60,6 +60,7 @@ import {\n } from '../lib/router-utils/router-server-context'\n import { decodePathParams } from '../lib/router-utils/decode-path-params'\n import { removeTrailingSlash } from '../../shared/lib/router/utils/remove-trailing-slash'\n+import { isInterceptionRouteRewrite } from '../../lib/generate-interception-routes-rewrites'\n \n /**\n  * RouteModuleOptions is the options that are passed to the route module, other\n@@ -181,6 +182,7 @@ export abstract class RouteModule<\n     clientReferenceManifest: any\n     serverActionsManifest: any\n     dynamicCssManifest: any\n+    interceptionRoutePatterns: RegExp[]\n   } {\n     if (process.env.NEXT_RUNTIME === 'edge') {\n       const { getEdgePreviewProps } =\n@@ -227,6 +229,9 @@ export abstract class RouteModule<\n           self.__SUBRESOURCE_INTEGRITY_MANIFEST\n         ),\n         dynamicCssManifest: maybeJSONParse(self.__DYNAMIC_CSS_MANIFEST),\n+        interceptionRoutePatterns: (\n+          maybeJSONParse(self.__INTERCEPTION_ROUTE_REWRITE_MANIFEST) ?? []\n+        ).map((rewrite: any) => new RegExp(rewrite.regex)),\n       }\n     } else {\n       if (!projectDir) {\n@@ -344,12 +349,15 @@ export abstract class RouteModule<\n         serverActionsManifest,\n         subresourceIntegrityManifest,\n         dynamicCssManifest,\n+        interceptionRoutePatterns: routesManifest.rewrites.beforeFiles\n+          .filter(isInterceptionRouteRewrite)\n+          .map((rewrite) => new RegExp(rewrite.regex)),\n       }\n     }\n   }\n \n   public async loadCustomCacheHandlers(\n-    req: IncomingMessage,\n+    req: IncomingMessage | BaseNextRequest,\n     nextConfig: NextConfigComplete\n   ) {\n     if (process.env.NEXT_RUNTIME !== 'edge') {\n@@ -387,7 +395,7 @@ export abstract class RouteModule<\n   }\n \n   public async getIncrementalCache(\n-    req: IncomingMessage,\n+    req: IncomingMessage | BaseNextRequest,\n     nextConfig: NextConfigComplete,\n     prerenderManifest: DeepReadonly<PrerenderManifest>\n   ): Promise<IncrementalCache> {\n@@ -501,6 +509,7 @@ export abstract class RouteModule<\n         revalidateOnlyGenerated: boolean\n         nextConfig: NextConfigComplete\n         routerServerContext?: RouterServerContext[string]\n+        interceptionRoutePatterns?: any\n       }\n     | undefined\n   > {\n@@ -809,7 +818,7 @@ export abstract class RouteModule<\n     }\n   }\n \n-  public getResponseCache(req: IncomingMessage) {\n+  public getResponseCache(req: IncomingMessage | BaseNextRequest) {\n     if (!this.responseCache) {\n       const minimalMode = getRequestMeta(req, 'minimalMode') ?? false\n       this.responseCache = new ResponseCache(minimalMode)\n@@ -830,7 +839,7 @@ export abstract class RouteModule<\n     responseGenerator,\n     waitUntil,\n   }: {\n-    req: IncomingMessage\n+    req: IncomingMessage | BaseNextRequest\n     nextConfig: NextConfigComplete\n     cacheKey: string | null\n     routeKind: RouteKind"
        },
        {
            "sha": "1a7f6ea123888f9b6d87718e0f85c10511a69525",
            "filename": "packages/next/src/server/web-server.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 413,
            "changes": 413,
            "blob_url": "https://github.com/vercel/next.js/blob/174a241a7a0243881fc96d40c6abc7115aa6e040/packages%2Fnext%2Fsrc%2Fserver%2Fweb-server.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/174a241a7a0243881fc96d40c6abc7115aa6e040/packages%2Fnext%2Fsrc%2Fserver%2Fweb-server.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fweb-server.ts?ref=174a241a7a0243881fc96d40c6abc7115aa6e040",
            "patch": "@@ -1,413 +0,0 @@\n-import type { WebNextRequest, WebNextResponse } from './base-http/web'\n-import type RenderResult from './render-result'\n-import type { NextParsedUrlQuery, NextUrlWithParsedQuery } from './request-meta'\n-import type { Params } from './request/params'\n-import type { LoadComponentsReturnType } from './load-components'\n-import type {\n-  LoadedRenderOpts,\n-  MiddlewareRoutingItem,\n-  NormalizedRouteManifest,\n-  Options,\n-  RouteHandler,\n-} from './base-server'\n-import type { CacheControl } from './lib/cache-control'\n-\n-import { byteLength } from './api-utils/web'\n-import BaseServer from './base-server'\n-import { generateETag } from './lib/etag'\n-import { addRequestMeta, getRequestMeta } from './request-meta'\n-import WebResponseCache from './response-cache/web'\n-import { removeTrailingSlash } from '../shared/lib/router/utils/remove-trailing-slash'\n-import { isDynamicRoute } from '../shared/lib/router/utils'\n-import {\n-  interpolateDynamicPath,\n-  normalizeCdnUrl,\n-  normalizeDynamicRouteParams,\n-} from './server-utils'\n-import { getNamedRouteRegex } from '../shared/lib/router/utils/route-regex'\n-import { getRouteMatcher } from '../shared/lib/router/utils/route-matcher'\n-import { IncrementalCache } from './lib/incremental-cache'\n-import type { PAGE_TYPES } from '../lib/page-types'\n-import type { Rewrite } from '../lib/load-custom-routes'\n-import { buildCustomRoute } from '../lib/build-custom-route'\n-import { UNDERSCORE_NOT_FOUND_ROUTE } from '../api/constants'\n-import { getEdgeInstrumentationModule } from './web/globals'\n-import type { ServerOnInstrumentationRequestError } from './app-render/types'\n-import { getEdgePreviewProps } from './web/get-edge-preview-props'\n-import { NoFallbackError } from '../shared/lib/no-fallback-error.external'\n-import { HTML_CONTENT_TYPE_HEADER } from '../lib/constants'\n-\n-interface WebServerOptions extends Options {\n-  buildId: string\n-  webServerConfig: {\n-    page: string\n-    pathname: string\n-    pagesType: PAGE_TYPES\n-    loadComponent: (page: string) => Promise<LoadComponentsReturnType | null>\n-    extendRenderOpts: Partial<BaseServer['renderOpts']> & {\n-      serverActionsManifest?: any\n-    }\n-    renderToHTML:\n-      | typeof import('./app-render/app-render').renderToHTMLOrFlight\n-      | undefined\n-    incrementalCacheHandler?: any\n-    interceptionRouteRewrites?: Rewrite[]\n-  }\n-}\n-\n-type WebRouteHandler = RouteHandler<WebNextRequest, WebNextResponse>\n-\n-export default class NextWebServer extends BaseServer<\n-  WebServerOptions,\n-  WebNextRequest,\n-  WebNextResponse\n-> {\n-  constructor(options: WebServerOptions) {\n-    super(options)\n-\n-    // Extend `renderOpts`.\n-    Object.assign(this.renderOpts, options.webServerConfig.extendRenderOpts)\n-  }\n-\n-  protected async getIncrementalCache({\n-    requestHeaders,\n-  }: {\n-    requestHeaders: IncrementalCache['requestHeaders']\n-  }) {\n-    const dev = !!this.renderOpts.dev\n-    // incremental-cache is request specific\n-    // although can have shared caches in module scope\n-    // per-cache handler\n-    return new IncrementalCache({\n-      dev,\n-      requestHeaders,\n-      allowedRevalidateHeaderKeys:\n-        this.nextConfig.experimental.allowedRevalidateHeaderKeys,\n-      minimalMode: this.minimalMode,\n-      fetchCacheKeyPrefix: this.nextConfig.experimental.fetchCacheKeyPrefix,\n-      maxMemoryCacheSize: this.nextConfig.cacheMaxMemorySize,\n-      flushToDisk: false,\n-      CurCacheHandler:\n-        this.serverOptions.webServerConfig.incrementalCacheHandler,\n-      getPrerenderManifest: () => this.getPrerenderManifest(),\n-    })\n-  }\n-  protected getResponseCache() {\n-    return new WebResponseCache(this.minimalMode)\n-  }\n-\n-  protected async hasPage(page: string) {\n-    return page === this.serverOptions.webServerConfig.page\n-  }\n-\n-  protected getBuildId() {\n-    return this.serverOptions.buildId\n-  }\n-\n-  protected getEnabledDirectories() {\n-    return {\n-      app: this.serverOptions.webServerConfig.pagesType === 'app',\n-      pages: this.serverOptions.webServerConfig.pagesType === 'pages',\n-    }\n-  }\n-\n-  protected getPagesManifest() {\n-    return {\n-      // keep same theme but server path doesn't need to be accurate\n-      [this.serverOptions.webServerConfig.pathname]:\n-        `server${this.serverOptions.webServerConfig.page}.js`,\n-    }\n-  }\n-\n-  protected getAppPathsManifest() {\n-    const page = this.serverOptions.webServerConfig.page\n-    return {\n-      [this.serverOptions.webServerConfig.page]: `app${page}.js`,\n-    }\n-  }\n-\n-  protected attachRequestMeta(\n-    req: WebNextRequest,\n-    parsedUrl: NextUrlWithParsedQuery\n-  ) {\n-    addRequestMeta(req, 'initQuery', { ...parsedUrl.query })\n-  }\n-\n-  protected getPrerenderManifest() {\n-    return {\n-      version: -1 as any, // letting us know this doesn't conform to spec\n-      routes: {},\n-      dynamicRoutes: {},\n-      notFoundRoutes: [],\n-      preview: getEdgePreviewProps(),\n-    }\n-  }\n-\n-  protected getNextFontManifest() {\n-    return this.serverOptions.webServerConfig.extendRenderOpts.nextFontManifest\n-  }\n-\n-  protected handleCatchallRenderRequest: WebRouteHandler = async (\n-    req,\n-    res,\n-    parsedUrl\n-  ) => {\n-    let { pathname, query } = parsedUrl\n-    if (!pathname) {\n-      throw new Error('pathname is undefined')\n-    }\n-\n-    // interpolate query information into page for dynamic route\n-    // so that rewritten paths are handled properly\n-    const normalizedPage = this.serverOptions.webServerConfig.pathname\n-\n-    if (pathname !== normalizedPage) {\n-      pathname = normalizedPage\n-\n-      if (isDynamicRoute(pathname)) {\n-        const routeRegex = getNamedRouteRegex(pathname, {\n-          prefixRouteKeys: false,\n-        })\n-        const dynamicRouteMatcher = getRouteMatcher(routeRegex)\n-        const defaultRouteMatches = dynamicRouteMatcher(\n-          pathname\n-        ) as NextParsedUrlQuery\n-        const paramsResult = normalizeDynamicRouteParams(\n-          query,\n-          routeRegex,\n-          defaultRouteMatches,\n-          false\n-        )\n-        const normalizedParams = paramsResult.hasValidParams\n-          ? paramsResult.params\n-          : query\n-\n-        pathname = interpolateDynamicPath(\n-          pathname,\n-          normalizedParams,\n-          routeRegex\n-        )\n-        normalizeCdnUrl(req, Object.keys(routeRegex.routeKeys))\n-      }\n-    }\n-\n-    // next.js core assumes page path without trailing slash\n-    pathname = removeTrailingSlash(pathname)\n-\n-    if (this.i18nProvider) {\n-      const { detectedLocale } = await this.i18nProvider.analyze(pathname)\n-      if (detectedLocale) {\n-        addRequestMeta(req, 'locale', detectedLocale)\n-      }\n-    }\n-\n-    const bubbleNoFallback = getRequestMeta(req, 'bubbleNoFallback')\n-\n-    try {\n-      await this.render(req, res, pathname, query, parsedUrl, true)\n-\n-      return true\n-    } catch (err) {\n-      if (err instanceof NoFallbackError && bubbleNoFallback) {\n-        return false\n-      }\n-      throw err\n-    }\n-  }\n-\n-  protected renderHTML(\n-    req: WebNextRequest,\n-    res: WebNextResponse,\n-    pathname: string,\n-    query: NextParsedUrlQuery,\n-    renderOpts: LoadedRenderOpts\n-  ): Promise<RenderResult> {\n-    const { renderToHTML } = this.serverOptions.webServerConfig\n-    if (!renderToHTML) {\n-      throw new Error(\n-        'Invariant: routeModule should be configured when rendering pages'\n-      )\n-    }\n-\n-    // For edge runtime if the pathname hit as /_not-found entrypoint,\n-    // override the pathname to /404 for rendering\n-    if (pathname === UNDERSCORE_NOT_FOUND_ROUTE) {\n-      pathname = '/404'\n-    }\n-    return renderToHTML(\n-      req as any,\n-      res as any,\n-      pathname,\n-      query,\n-      // Edge runtime does not support ISR/PPR, so we don't need to pass in\n-      // the unknown params.\n-      null,\n-      Object.assign(renderOpts, {\n-        disableOptimizedLoading: true,\n-        runtime: 'experimental-edge',\n-      }),\n-      undefined,\n-      false,\n-      {\n-        buildId: this.serverOptions.buildId,\n-      }\n-    )\n-  }\n-\n-  protected async sendRenderResult(\n-    _req: WebNextRequest,\n-    res: WebNextResponse,\n-    options: {\n-      result: RenderResult\n-      generateEtags: boolean\n-      poweredByHeader: boolean\n-      cacheControl: CacheControl | undefined\n-    }\n-  ): Promise<void> {\n-    res.setHeader('X-Edge-Runtime', '1')\n-\n-    // Add necessary headers.\n-    // @TODO: Share the isomorphic logic with server/send-payload.ts.\n-    if (\n-      options.poweredByHeader &&\n-      options.result.contentType === HTML_CONTENT_TYPE_HEADER\n-    ) {\n-      res.setHeader('X-Powered-By', 'Next.js')\n-    }\n-\n-    if (!res.getHeader('Content-Type') && options.result.contentType) {\n-      res.setHeader('Content-Type', options.result.contentType)\n-    }\n-\n-    let promise: Promise<void> | undefined\n-    if (options.result.isDynamic) {\n-      promise = options.result.pipeTo(res.transformStream.writable)\n-    } else {\n-      const payload = options.result.toUnchunkedString()\n-      res.setHeader('Content-Length', String(byteLength(payload)))\n-      if (options.generateEtags) {\n-        res.setHeader('ETag', generateETag(payload))\n-      }\n-      res.body(payload)\n-    }\n-\n-    res.send()\n-\n-    // If we have a promise, wait for it to resolve.\n-    if (promise) await promise\n-  }\n-\n-  protected async findPageComponents({\n-    page,\n-    query,\n-    params,\n-    url: _url,\n-  }: {\n-    page: string\n-    query: NextParsedUrlQuery\n-    params: Params | null\n-    isAppPath: boolean\n-    url?: string\n-  }) {\n-    const result = await this.serverOptions.webServerConfig.loadComponent(page)\n-    if (!result) return null\n-\n-    return {\n-      query: {\n-        ...(query || {}),\n-        ...(params || {}),\n-      },\n-      components: result,\n-    }\n-  }\n-\n-  // Below are methods that are not implemented by the web server as they are\n-  // handled by the upstream proxy (edge runtime or node server).\n-\n-  protected async runApi() {\n-    // This web server does not need to handle API requests.\n-    return true\n-  }\n-\n-  protected async handleApiRequest() {\n-    // Edge API requests are handled separately in minimal mode.\n-    return false\n-  }\n-\n-  protected loadEnvConfig() {\n-    // The web server does not need to load the env config. This is done by the\n-    // runtime already.\n-  }\n-\n-  protected getPublicDir() {\n-    // Public files are not handled by the web server.\n-    return ''\n-  }\n-\n-  protected getHasStaticDir() {\n-    return false\n-  }\n-\n-  protected getFontManifest() {\n-    return undefined\n-  }\n-\n-  protected handleCompression() {\n-    // For the web server layer, compression is automatically handled by the\n-    // upstream proxy (edge runtime or node server) and we can simply skip here.\n-  }\n-\n-  protected async handleUpgrade(): Promise<void> {\n-    // The web server does not support web sockets.\n-  }\n-\n-  protected async getFallbackErrorComponents(\n-    _url?: string\n-  ): Promise<LoadComponentsReturnType | null> {\n-    // The web server does not need to handle fallback errors in production.\n-    return null\n-  }\n-  protected getRoutesManifest(): NormalizedRouteManifest | undefined {\n-    // The web server does not need to handle rewrite rules. This is done by the\n-    // upstream proxy (edge runtime or node server).\n-    return undefined\n-  }\n-\n-  protected getMiddleware(): Promise<MiddlewareRoutingItem | undefined> {\n-    // The web server does not need to handle middleware. This is done by the\n-    // upstream proxy (edge runtime or node server).\n-    return Promise.resolve(undefined)\n-  }\n-\n-  protected getFilesystemPaths() {\n-    return new Set<string>()\n-  }\n-\n-  protected getinterceptionRoutePatterns(): RegExp[] {\n-    return (\n-      this.serverOptions.webServerConfig.interceptionRouteRewrites?.map(\n-        (rewrite) => new RegExp(buildCustomRoute('rewrite', rewrite).regex)\n-      ) ?? []\n-    )\n-  }\n-\n-  protected async loadInstrumentationModule() {\n-    return await getEdgeInstrumentationModule()\n-  }\n-\n-  protected async instrumentationOnRequestError(\n-    ...args: Parameters<ServerOnInstrumentationRequestError>\n-  ) {\n-    await super.instrumentationOnRequestError(...args)\n-    const err = args[0]\n-\n-    if (\n-      process.env.NODE_ENV !== 'production' &&\n-      typeof __next_log_error__ === 'function'\n-    ) {\n-      __next_log_error__(err)\n-    } else {\n-      console.error(err)\n-    }\n-  }\n-}"
        },
        {
            "sha": "12e5c876efde0cc81aabf96856cb64674bb6d77b",
            "filename": "packages/next/src/server/web/globals.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 5,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/4cc5ed45b6ace7a45dbe9ce772dfe59e59757f5c/packages%2Fnext%2Fsrc%2Fserver%2Fweb%2Fglobals.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/4cc5ed45b6ace7a45dbe9ce772dfe59e59757f5c/packages%2Fnext%2Fsrc%2Fserver%2Fweb%2Fglobals.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fweb%2Fglobals.ts?ref=4cc5ed45b6ace7a45dbe9ce772dfe59e59757f5c",
            "patch": "@@ -95,11 +95,13 @@ function enhanceGlobals() {\n \n   // to allow building code that import but does not use node.js modules,\n   // webpack will expect this function to exist in global scope\n-  Object.defineProperty(globalThis, '__import_unsupported', {\n-    value: __import_unsupported,\n-    enumerable: false,\n-    configurable: false,\n-  })\n+  try {\n+    Object.defineProperty(globalThis, '__import_unsupported', {\n+      value: __import_unsupported,\n+      enumerable: false,\n+      configurable: false,\n+    })\n+  } catch {}\n \n   // Eagerly fire instrumentation hook to make the startup faster.\n   void ensureInstrumentationRegistered()"
        },
        {
            "sha": "c671d59ae92f2b95e71dadb2b2b1856d74e13860",
            "filename": "packages/next/src/server/web/sandbox/sandbox.ts",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/4cc5ed45b6ace7a45dbe9ce772dfe59e59757f5c/packages%2Fnext%2Fsrc%2Fserver%2Fweb%2Fsandbox%2Fsandbox.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/4cc5ed45b6ace7a45dbe9ce772dfe59e59757f5c/packages%2Fnext%2Fsrc%2Fserver%2Fweb%2Fsandbox%2Fsandbox.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fweb%2Fsandbox%2Fsandbox.ts?ref=4cc5ed45b6ace7a45dbe9ce772dfe59e59757f5c",
            "patch": "@@ -13,6 +13,10 @@ import {\n   getBuiltinRequestContext,\n   type BuiltinRequestContextValue,\n } from '../../after/builtin-request-context'\n+import {\n+  RouterServerContextSymbol,\n+  routerServerGlobal,\n+} from '../../lib/router-utils/router-server-context'\n \n export const ErrorSource = Symbol('SandboxError')\n \n@@ -81,6 +85,12 @@ export async function getRuntimeContext(\n     runtime.context.globalThis.__incrementalCache = params.incrementalCache\n   }\n \n+  // expose router server context for access to dev handlers like\n+  // logErrorWithOriginalStack\n+  ;(runtime.context.globalThis as any as typeof routerServerGlobal)[\n+    RouterServerContextSymbol\n+  ] = routerServerGlobal[RouterServerContextSymbol]\n+\n   if (params.serverComponentsHmrCache) {\n     runtime.context.globalThis.__serverComponentsHmrCache =\n       params.serverComponentsHmrCache"
        },
        {
            "sha": "bcf5009e521a150455041bda951e32981e40feff",
            "filename": "test/e2e/app-dir/actions-unrecognized/actions-unrecognized.test.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 9,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/4cc5ed45b6ace7a45dbe9ce772dfe59e59757f5c/test%2Fe2e%2Fapp-dir%2Factions-unrecognized%2Factions-unrecognized.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/4cc5ed45b6ace7a45dbe9ce772dfe59e59757f5c/test%2Fe2e%2Fapp-dir%2Factions-unrecognized%2Factions-unrecognized.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Factions-unrecognized%2Factions-unrecognized.test.ts?ref=4cc5ed45b6ace7a45dbe9ce772dfe59e59757f5c",
            "patch": "@@ -152,19 +152,14 @@ describe('unrecognized server actions', () => {\n \n           if (isNextDeploy) {\n             // FIXME: When deployed to vercel, the request is logged as a 500, but returns a 405.\n-            // We also don't seem to display the error page correctly,\n-            // and the response is inconsistent between nodejs and edge.\n-            expect(response.status()).toBe(runtime === 'nodejs' ? 405 : 500)\n-            expect(response.headers()['content-type']).toStartWith(\n-              runtime === 'nodejs' ? 'text/html' : 'text/plain'\n-            )\n+            // We also don't seem to display the error page correctly\n+            expect(response.status()).toBe(405)\n+            expect(response.headers()['content-type']).toStartWith('text/html')\n           } else {\n             // FIXME: Currently, an unrecognized id in an MPA action results in a 500.\n             // This is not ideal, and ignores all nested `error.js` files, only showing the topmost one.\n             expect(response.status()).toBe(500)\n-            expect(response.headers()['content-type']).toStartWith(\n-              runtime === 'nodejs' ? 'text/html' : 'text/plain'\n-            )\n+            expect(response.headers()['content-type']).toStartWith('text/html')\n             // In dev, the 500 page doesn't have any SSR'd html, so it won't show anything without JS.\n             if (!isNextDev) {\n               expect(await browser.elementByCss('body').text()).toContain("
        }
    ],
    "stats": {
        "total": 1090,
        "additions": 389,
        "deletions": 701
    }
}