{
    "author": "acdlite",
    "message": "Experimental bfcache: Restore state w/ <Activity> (#77992)\n\n> [!NOTE]  \n> This feature does not affect the caching of dynamic data — only UI\nstate. Dynamic data is cached during back/forward navigations using a\ndifferent, preexisting mechanism; during normal navigations, dynamic\ndata is never cached, unless you opt in via\n`experimental.staleTimes.dynamic`.\n\nWhen navigating to a route that has already been visited, we should\nrestore as much of its previous state as we reasonably can — not only\nstate tracked by the browser, like scroll position and form inputs, but\nalso state owned by React, like `useState`.\n\nThe browser's native bfcache provides some of this automatically when\nyou use the back/forward buttons, or the history API. But it has\nlimitations, mainly that it can't restore state controlled by React. It\nalso doesn't work with navigations by regular links.\n\nReact has an experimental API called `<Activity>` that is designed for\nthis purpose. Content inside an Activity boundary can be hidden from the\nUI without unmounting it; later, it can be restored to the UI without\nhaving lost any state. React optimizes hidden Activity boundaries by\nskipping over them during rendering, similar to how the browser handles\n`content-visibility`. Later, during idle time, React will prerender the\nboundaries so they are ready by the time they are revealed again.\n\nIn this PR, I've added an Activity boundary around every route segment\n(i.e. layout or page). For each level of the route tree, the router will\nrender the N most recently active routes, and automatically toggle their\nvisibility as the user navigates, regardless of whether it's via the\nback/forward buttons or regular links.\n\nAside from preserving state, keeping the inactive routes mounted also\nmakes navigations faster, since by the time you navigate the next screen\nhas already been prerendered.\n\nIn the future, we'll use this same mechanism to speculatively/\noptimistically prerender routes that haven't yet been visited.\n\nThis is a nested bfcache — we track the history separately at each level\nof the route tree. The lifetime of the bfcache is tied to the lifetime\nof the React tree.\n\nFor now, the maximum number of entries per level is hardcoded to 3.\nEventually this will likely need to configurable per segment, but the\nplan is for the default to be some smallish non-zero number. We'll\ntinker with the heuristic before the feature is shipped to stable.",
    "sha": "078fff2d484a8c70ac8ef18776720789e095abc3",
    "files": [
        {
            "sha": "7bbb6a8a0ab7bbdc275dd72086a10a3cf2ed29b6",
            "filename": "packages/next/src/client/components/bfcache.ts",
            "status": "added",
            "additions": 112,
            "deletions": 0,
            "changes": 112,
            "blob_url": "https://github.com/vercel/next.js/blob/078fff2d484a8c70ac8ef18776720789e095abc3/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fbfcache.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/078fff2d484a8c70ac8ef18776720789e095abc3/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fbfcache.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fbfcache.ts?ref=078fff2d484a8c70ac8ef18776720789e095abc3",
            "patch": "@@ -0,0 +1,112 @@\n+import type { FlightRouterState } from '../../server/app-render/types'\n+import { useState } from 'react'\n+\n+// When the flag is disabled, only track the currently active tree\n+const MAX_BF_CACHE_ENTRIES = process.env.__NEXT_ROUTER_BF_CACHE ? 3 : 1\n+\n+export type RouterBFCacheEntry = {\n+  tree: FlightRouterState\n+  stateKey: string\n+  // The entries form a linked list, sorted in order of most recently active.\n+  next: RouterBFCacheEntry | null\n+}\n+\n+/**\n+ * Keeps track of the most recent N trees (FlightRouterStates) that were active\n+ * at a certain segment level. E.g. for a segment \"/a/b/[param]\", this hook\n+ * tracks the last N param values that the router rendered for N.\n+ *\n+ * The result of this hook precisely determines the number and order of\n+ * trees that are rendered in parallel at their segment level.\n+ *\n+ * The purpose of this cache is to we can preserve the React and DOM state of\n+ * some number of inactive trees, by rendering them in an <Activity> boundary.\n+ * That means it would not make sense for the the lifetime of the cache to be\n+ * any longer than the lifetime of the React tree; e.g. if the hook were\n+ * unmounted, then the React tree would be, too. So, we use React state to\n+ * manage it.\n+ *\n+ * Note that we don't store the RSC data for the cache entries in this hook —\n+ * the data for inactive segments is stored in the parent CacheNode, which\n+ * *does* have a longer lifetime than the React tree. This hook only determines\n+ * which of those trees should have their *state* preserved, by <Activity>.\n+ */\n+export function useRouterBFCache(\n+  activeTree: FlightRouterState,\n+  activeStateKey: string\n+): RouterBFCacheEntry {\n+  // The currently active entry. The entries form a linked list, sorted in\n+  // order of most recently active. This allows us to reuse parts of the list\n+  // without cloning, unless there's a reordering or removal.\n+  // TODO: Once we start tracking back/forward history at each route level,\n+  // we should use the history order instead. In other words, when traversing\n+  // to an existing entry as a result of a popstate event, we should maintain\n+  // the existing order instead of moving it to the front of the list. I think\n+  // an initial implementation of this could be to pass an incrementing id\n+  // to history.pushState/replaceState, then use that here for ordering.\n+  const [prevActiveEntry, setPrevActiveEntry] = useState<RouterBFCacheEntry>(\n+    () => {\n+      const initialEntry: RouterBFCacheEntry = {\n+        tree: activeTree,\n+        stateKey: activeStateKey,\n+        next: null,\n+      }\n+      return initialEntry\n+    }\n+  )\n+\n+  if (prevActiveEntry.tree === activeTree) {\n+    // Fast path. The active tree hasn't changed, so we can reuse the\n+    // existing state.\n+    return prevActiveEntry\n+  }\n+\n+  // The route tree changed. Note that this doesn't mean that the tree changed\n+  // *at this level* — the change may be due to a child route. Either way, we\n+  // need to either add or update the router tree in the bfcache.\n+  //\n+  // The rest of the code looks more complicated than it actually is because we\n+  // can't mutate the state in place; we have to copy-on-write.\n+\n+  // Create a new entry for the active cache key. This is the head of the new\n+  // linked list.\n+  const newActiveEntry: RouterBFCacheEntry = {\n+    tree: activeTree,\n+    stateKey: activeStateKey,\n+    next: null,\n+  }\n+\n+  // We need to append the old list onto the new list. If the head of the new\n+  // list was already present in the cache, then we'll need to clone everything\n+  // that came before it. Then we can reuse the rest.\n+  let n = 1\n+  let oldEntry: RouterBFCacheEntry | null = prevActiveEntry\n+  let clonedEntry: RouterBFCacheEntry = newActiveEntry\n+  while (oldEntry !== null && n < MAX_BF_CACHE_ENTRIES) {\n+    if (oldEntry.stateKey === activeStateKey) {\n+      // Fast path. This entry in the old list that corresponds to the key that\n+      // is now active. We've already placed a clone of this entry at the front\n+      // of the new list. We can reuse the rest of the old list without cloning.\n+      // NOTE: We don't need to worry about eviction in this case because we\n+      // haven't increased the size of the cache, and we assume the max size\n+      // is constant across renders. If we were to change it to a dynamic limit,\n+      // then the implementation would need to account for that.\n+      clonedEntry.next = oldEntry.next\n+      break\n+    } else {\n+      // Clone the entry and append it to the list.\n+      n++\n+      const entry: RouterBFCacheEntry = {\n+        tree: oldEntry.tree,\n+        stateKey: oldEntry.stateKey,\n+        next: null,\n+      }\n+      clonedEntry.next = entry\n+      clonedEntry = entry\n+    }\n+    oldEntry = oldEntry.next\n+  }\n+\n+  setPrevActiveEntry(newActiveEntry)\n+  return newActiveEntry\n+}"
        },
        {
            "sha": "53bd1e7ac55942e65c45b229ab6519f2279ca669",
            "filename": "packages/next/src/client/components/layout-router.tsx",
            "status": "modified",
            "additions": 107,
            "deletions": 73,
            "changes": 180,
            "blob_url": "https://github.com/vercel/next.js/blob/078fff2d484a8c70ac8ef18776720789e095abc3/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Flayout-router.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/078fff2d484a8c70ac8ef18776720789e095abc3/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Flayout-router.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Flayout-router.tsx?ref=078fff2d484a8c70ac8ef18776720789e095abc3",
            "patch": "@@ -39,6 +39,11 @@ import { HTTPAccessFallbackBoundary } from './http-access-fallback/error-boundar\n import { createRouterCacheKey } from './router-reducer/create-router-cache-key'\n import { hasInterceptionRouteInCurrentTree } from './router-reducer/reducers/has-interception-route-in-current-tree'\n import { dispatchAppRouterAction } from './use-action-queue'\n+import { useRouterBFCache, type RouterBFCacheEntry } from './bfcache'\n+\n+const Activity = process.env.__NEXT_ROUTER_BF_CACHE\n+  ? require('react').unstable_Activity\n+  : null\n \n /**\n  * Add refetch marker to router state at the point of the current layout segment.\n@@ -526,13 +531,7 @@ export default function OuterLayoutRouter({\n     segmentMap = new Map()\n     parentParallelRoutes.set(parallelRouterKey, segmentMap)\n   }\n-\n-  // Get the active segment in the tree\n-  // The reason arrays are used in the data format is that these are transferred from the server to the browser so it's optimized to save bytes.\n   const parentTreeSegment = parentTree[0]\n-  const tree = parentTree[1][parallelRouterKey]\n-  const treeSegment = tree[0]\n-\n   const segmentPath =\n     parentSegmentPath === null\n       ? // TODO: The root segment value is currently omitted from the segment\n@@ -551,31 +550,49 @@ export default function OuterLayoutRouter({\n   // it's possible that the segment accessed the search params on the server.\n   // (This only applies to page segments; layout segments cannot access search\n   // params on the server.)\n-  const cacheKey = createRouterCacheKey(treeSegment)\n-  const stateKey = createRouterCacheKey(treeSegment, true) // no search params\n-\n-  // Read segment path from the parallel router cache node.\n-  let cacheNode = segmentMap.get(cacheKey)\n-  if (cacheNode === undefined) {\n-    // When data is not available during rendering client-side we need to fetch\n-    // it from the server.\n-    const newLazyCacheNode: LazyCacheNode = {\n-      lazyData: null,\n-      rsc: null,\n-      prefetchRsc: null,\n-      head: null,\n-      prefetchHead: null,\n-      parallelRoutes: new Map(),\n-      loading: null,\n-      navigatedAt: -1,\n-    }\n+  const activeTree = parentTree[1][parallelRouterKey]\n+  const activeSegment = activeTree[0]\n+  const activeStateKey = createRouterCacheKey(activeSegment, true) // no search params\n+\n+  // At each level of the route tree, not only do we render the currently\n+  // active segment — we also render the last N segments that were active at\n+  // this level inside a hidden <Activity> boundary, to preserve their state\n+  // if or when the user navigates to them again.\n+  //\n+  // bfcacheEntry is a linked list of FlightRouterStates.\n+  let bfcacheEntry: RouterBFCacheEntry | null = useRouterBFCache(\n+    activeTree,\n+    activeStateKey\n+  )\n+  let children: Array<React.ReactNode> = []\n+  do {\n+    const tree = bfcacheEntry.tree\n+    const stateKey = bfcacheEntry.stateKey\n+    const segment = tree[0]\n+    const cacheKey = createRouterCacheKey(segment)\n+\n+    // Read segment path from the parallel router cache node.\n+    let cacheNode = segmentMap.get(cacheKey)\n+    if (cacheNode === undefined) {\n+      // When data is not available during rendering client-side we need to fetch\n+      // it from the server.\n+      const newLazyCacheNode: LazyCacheNode = {\n+        lazyData: null,\n+        rsc: null,\n+        prefetchRsc: null,\n+        head: null,\n+        prefetchHead: null,\n+        parallelRoutes: new Map(),\n+        loading: null,\n+        navigatedAt: -1,\n+      }\n \n-    // Flight data fetch kicked off during render and put into the cache.\n-    cacheNode = newLazyCacheNode\n-    segmentMap.set(cacheKey, newLazyCacheNode)\n-  }\n+      // Flight data fetch kicked off during render and put into the cache.\n+      cacheNode = newLazyCacheNode\n+      segmentMap.set(cacheKey, newLazyCacheNode)\n+    }\n \n-  /*\n+    /*\n     - Error boundary\n       - Only renders error boundary if error component is provided.\n       - Rendered for each segment to ensure they have their own error state.\n@@ -585,49 +602,66 @@ export default function OuterLayoutRouter({\n       - Passed to the router during rendering to ensure it can be immediately rendered when suspending on a Flight fetch.\n   */\n \n-  // TODO: The loading module data for a segment is stored on the parent, then\n-  // applied to each of that parent segment's parallel route slots. In the\n-  // simple case where there's only one parallel route (the `children` slot),\n-  // this is no different from if the loading module data where stored on the\n-  // child directly. But I'm not sure this actually makes sense when there are\n-  // multiple parallel routes. It's not a huge issue because you always have\n-  // the option to define a narrower loading boundary for a particular slot. But\n-  // this sort of smells like an implementation accident to me.\n-  const loadingModuleData = parentCacheNode.loading\n+    // TODO: The loading module data for a segment is stored on the parent, then\n+    // applied to each of that parent segment's parallel route slots. In the\n+    // simple case where there's only one parallel route (the `children` slot),\n+    // this is no different from if the loading module data where stored on the\n+    // child directly. But I'm not sure this actually makes sense when there are\n+    // multiple parallel routes. It's not a huge issue because you always have\n+    // the option to define a narrower loading boundary for a particular slot. But\n+    // this sort of smells like an implementation accident to me.\n+    const loadingModuleData = parentCacheNode.loading\n+    let child = (\n+      <TemplateContext.Provider\n+        key={stateKey}\n+        value={\n+          <ScrollAndFocusHandler segmentPath={segmentPath}>\n+            <ErrorBoundary\n+              errorComponent={error}\n+              errorStyles={errorStyles}\n+              errorScripts={errorScripts}\n+            >\n+              <LoadingBoundary loading={loadingModuleData}>\n+                <HTTPAccessFallbackBoundary\n+                  notFound={notFound}\n+                  forbidden={forbidden}\n+                  unauthorized={unauthorized}\n+                >\n+                  <RedirectBoundary>\n+                    <InnerLayoutRouter\n+                      url={url}\n+                      tree={tree}\n+                      cacheNode={cacheNode}\n+                      segmentPath={segmentPath}\n+                    />\n+                  </RedirectBoundary>\n+                </HTTPAccessFallbackBoundary>\n+              </LoadingBoundary>\n+            </ErrorBoundary>\n+          </ScrollAndFocusHandler>\n+        }\n+      >\n+        {templateStyles}\n+        {templateScripts}\n+        {template}\n+      </TemplateContext.Provider>\n+    )\n \n-  return (\n-    <TemplateContext.Provider\n-      key={stateKey}\n-      value={\n-        <ScrollAndFocusHandler segmentPath={segmentPath}>\n-          <ErrorBoundary\n-            errorComponent={error}\n-            errorStyles={errorStyles}\n-            errorScripts={errorScripts}\n-          >\n-            <LoadingBoundary loading={loadingModuleData}>\n-              <HTTPAccessFallbackBoundary\n-                notFound={notFound}\n-                forbidden={forbidden}\n-                unauthorized={unauthorized}\n-              >\n-                <RedirectBoundary>\n-                  <InnerLayoutRouter\n-                    url={url}\n-                    tree={tree}\n-                    cacheNode={cacheNode}\n-                    segmentPath={segmentPath}\n-                  />\n-                </RedirectBoundary>\n-              </HTTPAccessFallbackBoundary>\n-            </LoadingBoundary>\n-          </ErrorBoundary>\n-        </ScrollAndFocusHandler>\n-      }\n-    >\n-      {templateStyles}\n-      {templateScripts}\n-      {template}\n-    </TemplateContext.Provider>\n-  )\n+    if (process.env.__NEXT_ROUTER_BF_CACHE) {\n+      child = (\n+        <Activity\n+          key={stateKey}\n+          mode={stateKey === activeStateKey ? 'visible' : 'hidden'}\n+        >\n+          {child}\n+        </Activity>\n+      )\n+    }\n+\n+    children.push(child)\n+\n+    bfcacheEntry = bfcacheEntry.next\n+  } while (bfcacheEntry !== null)\n+\n+  return children\n }"
        },
        {
            "sha": "ea399dea6f2590c87080a5d308a9ce90751a0cfd",
            "filename": "test/e2e/app-dir/back-forward-cache/app/layout.tsx",
            "status": "modified",
            "additions": 19,
            "deletions": 1,
            "changes": 20,
            "blob_url": "https://github.com/vercel/next.js/blob/078fff2d484a8c70ac8ef18776720789e095abc3/test%2Fe2e%2Fapp-dir%2Fback-forward-cache%2Fapp%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/078fff2d484a8c70ac8ef18776720789e095abc3/test%2Fe2e%2Fapp-dir%2Fback-forward-cache%2Fapp%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fback-forward-cache%2Fapp%2Flayout.tsx?ref=078fff2d484a8c70ac8ef18776720789e095abc3",
            "patch": "@@ -1,11 +1,29 @@\n+import Link from 'next/link'\n+\n export default function RootLayout({\n   children,\n }: {\n   children: React.ReactNode\n }) {\n+  const links = []\n+  for (let n = 1; n <= 5; n++) {\n+    links.push(\n+      <li key={n}>\n+        <Link href={`/page/${n}`}>Page {n}</Link>\n+      </li>\n+    )\n+    links.push(\n+      <li key={n + '-with-search-param'}>\n+        <Link href={`/page/${n}?param=true`}>Page {n} (with search param)</Link>\n+      </li>\n+    )\n+  }\n   return (\n     <html lang=\"en\">\n-      <body>{children}</body>\n+      <body>\n+        <ul>{links}</ul>\n+        <div>{children}</div>\n+      </body>\n     </html>\n   )\n }"
        },
        {
            "sha": "7e94a0265302fde7e33eec1c8f26213f12bef1a3",
            "filename": "test/e2e/app-dir/back-forward-cache/app/page/[n]/page.tsx",
            "status": "added",
            "additions": 20,
            "deletions": 0,
            "changes": 20,
            "blob_url": "https://github.com/vercel/next.js/blob/078fff2d484a8c70ac8ef18776720789e095abc3/test%2Fe2e%2Fapp-dir%2Fback-forward-cache%2Fapp%2Fpage%2F%5Bn%5D%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/078fff2d484a8c70ac8ef18776720789e095abc3/test%2Fe2e%2Fapp-dir%2Fback-forward-cache%2Fapp%2Fpage%2F%5Bn%5D%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fback-forward-cache%2Fapp%2Fpage%2F%5Bn%5D%2Fpage.tsx?ref=078fff2d484a8c70ac8ef18776720789e095abc3",
            "patch": "@@ -0,0 +1,20 @@\n+import { Suspense } from 'react'\n+import { StatefulClientComponent } from './stateful-client-component'\n+\n+export default async function Page({\n+  params,\n+}: {\n+  params: Promise<{ n: string }>\n+}) {\n+  const { n } = await params\n+  return (\n+    <>\n+      <h2>Page {n}</h2>\n+      <div>\n+        <Suspense fallback={<div>Loading...</div>}>\n+          <StatefulClientComponent n={n} />\n+        </Suspense>\n+      </div>\n+    </>\n+  )\n+}"
        },
        {
            "sha": "035ca6904b9fdc76a0077ff76aa468b218ec39f2",
            "filename": "test/e2e/app-dir/back-forward-cache/app/page/[n]/stateful-client-component.tsx",
            "status": "added",
            "additions": 28,
            "deletions": 0,
            "changes": 28,
            "blob_url": "https://github.com/vercel/next.js/blob/078fff2d484a8c70ac8ef18776720789e095abc3/test%2Fe2e%2Fapp-dir%2Fback-forward-cache%2Fapp%2Fpage%2F%5Bn%5D%2Fstateful-client-component.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/078fff2d484a8c70ac8ef18776720789e095abc3/test%2Fe2e%2Fapp-dir%2Fback-forward-cache%2Fapp%2Fpage%2F%5Bn%5D%2Fstateful-client-component.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fback-forward-cache%2Fapp%2Fpage%2F%5Bn%5D%2Fstateful-client-component.tsx?ref=078fff2d484a8c70ac8ef18776720789e095abc3",
            "patch": "@@ -0,0 +1,28 @@\n+'use client'\n+\n+import { useState } from 'react'\n+import { useSearchParams } from 'next/navigation'\n+\n+export function StatefulClientComponent({ n }: { n: string }) {\n+  const [count, setCount] = useState(0)\n+  const searchParams = useSearchParams()\n+  return (\n+    <div>\n+      <div>\n+        <button\n+          id={'increment-button-' + n}\n+          onClick={() => setCount(count + 1)}\n+        >\n+          Increment\n+        </button>\n+        <span id={'counter-display-' + n}>Count: {count}</span>\n+      </div>\n+      <div>\n+        <input id={'uncontrolled-input-' + n} type=\"text\" />\n+      </div>\n+      <div id={'has-search-param-' + n}>\n+        Has search param: {searchParams.get('param') ? 'yes' : 'no'}\n+      </div>\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "dad1c013e7999b2fabcea4deffdbe3878baf9c65",
            "filename": "test/e2e/app-dir/back-forward-cache/back-forward-cache.test.ts",
            "status": "modified",
            "additions": 200,
            "deletions": 8,
            "changes": 208,
            "blob_url": "https://github.com/vercel/next.js/blob/078fff2d484a8c70ac8ef18776720789e095abc3/test%2Fe2e%2Fapp-dir%2Fback-forward-cache%2Fback-forward-cache.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/078fff2d484a8c70ac8ef18776720789e095abc3/test%2Fe2e%2Fapp-dir%2Fback-forward-cache%2Fback-forward-cache.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fback-forward-cache%2Fback-forward-cache.test.ts?ref=078fff2d484a8c70ac8ef18776720789e095abc3",
            "patch": "@@ -5,13 +5,205 @@ describe('back/forward cache', () => {\n     files: __dirname,\n   })\n \n-  it('Activity component is renderable when the routerBFCache flag is on', async () => {\n-    // None of the back/forward behavior has been implemented yet; this just\n-    // tests that when the flag is enabled, we're able to successfully render\n-    // an Activity component.\n-    const browser = await next.browser('/')\n-    const activityContent = await browser.elementById('activity-content')\n-    expect(await activityContent.innerHTML()).toBe('Hello')\n-    expect(await activityContent.getComputedCss('display')).toBe('none')\n+  it('React state is preserved when navigating with back/forward buttons', async () => {\n+    const browser = await next.browser('/page/1')\n+\n+    // Accumulate some state on page 1.\n+    const incrementButton1 = await browser.elementById('increment-button-1')\n+    const counterDisplay1 = await browser.elementById('counter-display-1')\n+    await incrementButton1.click()\n+    await incrementButton1.click()\n+    expect(await counterDisplay1.text()).toBe('Count: 2')\n+\n+    // Navigate to page 2. Accumulate some state here, too.\n+    const linkToPage2 = await browser.elementByCss('a[href=\"/page/2\"]')\n+    await linkToPage2.click()\n+    const incrementButton2 = await browser.elementById('increment-button-2')\n+    const counterDisplay2 = await browser.elementById('counter-display-2')\n+    await incrementButton2.click()\n+    await incrementButton2.click()\n+    await incrementButton2.click()\n+    await incrementButton2.click()\n+    await incrementButton2.click()\n+    await incrementButton2.click()\n+    await incrementButton2.click()\n+    await incrementButton2.click()\n+    await incrementButton2.click()\n+    expect(await counterDisplay2.text()).toBe('Count: 9')\n+\n+    // Navigate back to page 1. Its state should be preserved.\n+    await browser.back()\n+    const counterDisplay1AfterNav =\n+      await browser.elementById('counter-display-1')\n+    expect(await counterDisplay1AfterNav.text()).toBe('Count: 2')\n+\n+    // Navigate forward to page 2. Its state should be preserved.\n+    await browser.forward()\n+    const counterDisplay2AfterNav =\n+      await browser.elementById('counter-display-2')\n+    expect(await counterDisplay2AfterNav.text()).toBe('Count: 9')\n+  })\n+\n+  it('React state is preserved when navigating back/forward with links', async () => {\n+    const browser = await next.browser('/page/1')\n+\n+    // Accumulate some state on page 1.\n+    const incrementButton1 = await browser.elementById('increment-button-1')\n+    const counterDisplay1 = await browser.elementById('counter-display-1')\n+    await incrementButton1.click()\n+    await incrementButton1.click()\n+    expect(await counterDisplay1.text()).toBe('Count: 2')\n+\n+    // Navigate to page 2. Accumulate some state here, too.\n+    const linkToPage2 = await browser.elementByCss('a[href=\"/page/2\"]')\n+    await linkToPage2.click()\n+    const incrementButton2 = await browser.elementById('increment-button-2')\n+    const counterDisplay2 = await browser.elementById('counter-display-2')\n+    await incrementButton2.click()\n+    await incrementButton2.click()\n+    await incrementButton2.click()\n+    await incrementButton2.click()\n+    await incrementButton2.click()\n+    await incrementButton2.click()\n+    await incrementButton2.click()\n+    await incrementButton2.click()\n+    await incrementButton2.click()\n+    expect(await counterDisplay2.text()).toBe('Count: 9')\n+\n+    // Navigate back to page 1. Its state should be preserved.\n+    const linkToPage1 = await browser.elementByCss('a[href=\"/page/1\"]')\n+    await linkToPage1.click()\n+    const counterDisplay1AfterNav =\n+      await browser.elementById('counter-display-1')\n+    expect(await counterDisplay1AfterNav.text()).toBe('Count: 2')\n+\n+    // Navigate back to page 2. Its state should be preserved.\n+    await linkToPage2.click()\n+    const counterDisplay2AfterNav =\n+      await browser.elementById('counter-display-2')\n+    expect(await counterDisplay2AfterNav.text()).toBe('Count: 9')\n+  })\n+\n+  it('React state is preserved when navigating back to a page with different search params than before ', async () => {\n+    const browser = await next.browser('/page/1')\n+\n+    // Accumulate some state on page 1.\n+    const incrementButton1 = await browser.elementById('increment-button-1')\n+    const counterDisplay1 = await browser.elementById('counter-display-1')\n+    await incrementButton1.click()\n+    await incrementButton1.click()\n+    expect(await counterDisplay1.text()).toBe('Count: 2')\n+\n+    // Navigate to page 2.\n+    const linkToPage2 = await browser.elementByCss('a[href=\"/page/2\"]')\n+    await linkToPage2.click()\n+\n+    // Navigate back to page 1, but with a different search param.\n+    const linkToPage1WithSearchParam = await browser.elementByCss(\n+      'a[href=\"/page/1?param=true\"]'\n+    )\n+    await linkToPage1WithSearchParam.click()\n+    const counterDisplay1AfterNav =\n+      await browser.elementById('counter-display-1')\n+    const hasSearchParam = await browser.elementById('has-search-param-1')\n+    expect(await counterDisplay1AfterNav.text()).toBe('Count: 2')\n+    expect(await hasSearchParam.text()).toBe('Has search param: yes')\n+  })\n+\n+  it('bfcache only preserves up to N entries', async () => {\n+    // The current limit is hardcoded to 3.\n+    const browser = await next.browser('/page/1')\n+\n+    // Accumulate some state on page 1.\n+    const incrementButton1 = await browser.elementById('increment-button-1')\n+    const counterDisplay1 = await browser.elementById('counter-display-1')\n+    await incrementButton1.click()\n+    await incrementButton1.click()\n+    expect(await counterDisplay1.text()).toBe('Count: 2')\n+\n+    // Navigate to page 2. Accumulate some state here, too.\n+    const linkToPage2 = await browser.elementByCss('a[href=\"/page/2\"]')\n+    await linkToPage2.click()\n+    const incrementButton2 = await browser.elementById('increment-button-2')\n+    const counterDisplay2 = await browser.elementById('counter-display-2')\n+    await incrementButton2.click()\n+    await incrementButton2.click()\n+    await incrementButton2.click()\n+    await incrementButton2.click()\n+    await incrementButton2.click()\n+    await incrementButton2.click()\n+    await incrementButton2.click()\n+    await incrementButton2.click()\n+    await incrementButton2.click()\n+    expect(await counterDisplay2.text()).toBe('Count: 9')\n+\n+    // Navigate to 2 additional pages.\n+    const linkToPage3 = await browser.elementByCss('a[href=\"/page/3\"]')\n+    await linkToPage3.click()\n+    const linkToPage4 = await browser.elementByCss('a[href=\"/page/4\"]')\n+    await linkToPage4.click()\n+\n+    // The bfcache size is now 4. Because the limit is 3, page 1 should have\n+    // been evicted, but not page 2.\n+\n+    // Navigate to page 2 to confirm its state is preserved.\n+    await linkToPage2.click()\n+    const counterDisplay2AfterNav =\n+      await browser.elementById('counter-display-2')\n+    expect(await counterDisplay2AfterNav.text()).toBe('Count: 9')\n+\n+    // Navigate back to page 1 to confirm its state is not preserved.\n+    const linkToPage1 = await browser.elementByCss('a[href=\"/page/1\"]')\n+    await linkToPage1.click()\n+    const counterDisplay1AfterNav =\n+      await browser.elementById('counter-display-1')\n+    expect(await counterDisplay1AfterNav.text()).toBe('Count: 0')\n+  })\n+\n+  it('navigate back and forth repeatedly between the same pages without evicting', async () => {\n+    // The current limit is hardcoded to 3.\n+    const browser = await next.browser('/page/1')\n+\n+    // Accumulate some state on page 1.\n+    const incrementButton1 = await browser.elementById('increment-button-1')\n+    const counterDisplay1 = await browser.elementById('counter-display-1')\n+    await incrementButton1.click()\n+    await incrementButton1.click()\n+    expect(await counterDisplay1.text()).toBe('Count: 2')\n+\n+    // Navigate to page 2. Accumulate some state here, too.\n+    const linkToPage2 = await browser.elementByCss('a[href=\"/page/2\"]')\n+    await linkToPage2.click()\n+    const incrementButton2 = await browser.elementById('increment-button-2')\n+    const counterDisplay2 = await browser.elementById('counter-display-2')\n+    await incrementButton2.click()\n+    await incrementButton2.click()\n+    await incrementButton2.click()\n+    await incrementButton2.click()\n+    await incrementButton2.click()\n+    await incrementButton2.click()\n+    await incrementButton2.click()\n+    await incrementButton2.click()\n+    await incrementButton2.click()\n+    expect(await counterDisplay2.text()).toBe('Count: 9')\n+\n+    // Navigate between pages 1 and 2 repeatedly\n+    const linkToPage1 = await browser.elementByCss('a[href=\"/page/1\"]')\n+    await linkToPage1.click()\n+    await linkToPage2.click()\n+    await linkToPage1.click()\n+    await linkToPage2.click()\n+    await linkToPage1.click()\n+    await linkToPage2.click()\n+\n+    // Confirm the state is preserved on both pages.\n+    const counterDisplay2AfterNav =\n+      await browser.elementById('counter-display-2')\n+    expect(await counterDisplay2AfterNav.text()).toBe('Count: 9')\n+\n+    await linkToPage1.click()\n+    const counterDisplay1AfterNav =\n+      await browser.elementById('counter-display-1')\n+    expect(await counterDisplay1AfterNav.text()).toBe('Count: 2')\n   })\n })"
        }
    ],
    "stats": {
        "total": 568,
        "additions": 486,
        "deletions": 82
    }
}