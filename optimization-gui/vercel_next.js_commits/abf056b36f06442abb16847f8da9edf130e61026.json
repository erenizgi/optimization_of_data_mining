{
    "author": "mischnic",
    "message": "Turbopack: remove unused code (#88274)",
    "sha": "abf056b36f06442abb16847f8da9edf130e61026",
    "files": [
        {
            "sha": "a34d2efbcdecaef9c8447d5286ae5bc3aa094cd7",
            "filename": "turbopack/crates/turbopack-core/src/chunk/containment_tree.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 278,
            "changes": 278,
            "blob_url": "https://github.com/vercel/next.js/blob/669b3e74deb9ee3ba64e0eb7f9502f0875924cdf/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fcontainment_tree.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/669b3e74deb9ee3ba64e0eb7f9502f0875924cdf/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fcontainment_tree.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fcontainment_tree.rs?ref=669b3e74deb9ee3ba64e0eb7f9502f0875924cdf",
            "patch": "@@ -1,278 +0,0 @@\n-use std::{cell::RefCell, mem::take, rc::Rc};\n-\n-use anyhow::Result;\n-use turbo_tasks::{FxIndexMap, FxIndexSet, TryJoinIterExt};\n-\n-#[derive(Debug, Default, Clone, Eq, PartialEq)]\n-pub struct ContainmentTree<K, V> {\n-    pub key: Option<K>,\n-    pub values: Option<Vec<V>>,\n-    pub children: Vec<ContainmentTree<K, V>>,\n-}\n-\n-// Temp structure which uses Rc and RefCell\n-struct Node<K, V> {\n-    key: K,\n-    values: Vec<V>,\n-    children: Vec<Rc<RefCell<Node<K, V>>>>,\n-}\n-\n-#[async_trait::async_trait]\n-pub trait ContainmentTreeKey: Sized {\n-    async fn parent(&self) -> Result<Self>;\n-}\n-\n-impl<K, V> ContainmentTree<K, V>\n-where\n-    K: ContainmentTreeKey + std::hash::Hash + Eq + Clone,\n-{\n-    pub async fn build<I>(values: I) -> Result<ContainmentTree<K, V>>\n-    where\n-        I: IntoIterator<Item = (Option<K>, V)>,\n-    {\n-        let values: Vec<_> = values.into_iter().collect();\n-\n-        // compute all unique common_parents\n-        let mut common_parents = values\n-            .iter()\n-            .filter_map(|(key, _)| key.clone())\n-            .collect::<FxIndexSet<_>>();\n-\n-        Self::expand_common_parents(&mut common_parents).await?;\n-\n-        let relationships = Self::compute_relationships(&common_parents).await?;\n-\n-        let mut trees = Self::create_node_tree(common_parents);\n-\n-        let orphan_values = Self::add_values_to_tree(&mut trees, values);\n-\n-        let roots = Self::treeify(relationships, &trees);\n-\n-        // optimize tree by removing unnecessary nodes\n-        Self::skip_unnecessary_nodes(&mut trees);\n-\n-        // do conversion\n-        let roots = Self::convert_into_common_parent_tree(roots, orphan_values);\n-\n-        // top level nesting\n-        Ok(if roots.len() == 1 {\n-            roots.into_iter().next().unwrap()\n-        } else {\n-            ContainmentTree {\n-                key: None,\n-                values: None,\n-                children: roots,\n-            }\n-        })\n-    }\n-\n-    /// Expand all common parents to include all their parents.\n-    async fn expand_common_parents(common_parents: &mut FxIndexSet<K>) -> Result<()> {\n-        // This is mutated while iterating, so we need to loop with index\n-        let mut i = 0;\n-        while i < common_parents.len() {\n-            let current = &common_parents[i];\n-            let parent = current.parent().await?;\n-            common_parents.insert(parent);\n-            i += 1;\n-        }\n-        Ok(())\n-    }\n-\n-    /// Compute parent -> child relationships between common_parents.\n-    async fn compute_relationships(common_parents: &FxIndexSet<K>) -> Result<Vec<(Option<K>, K)>> {\n-        common_parents\n-            .iter()\n-            .map(|key| {\n-                let common_parents = &common_parents;\n-                async move {\n-                    let mut current = key.clone();\n-                    loop {\n-                        let parent = current.parent().await?;\n-                        if parent == current {\n-                            return Ok((None, key.clone()));\n-                        }\n-                        if common_parents.contains(&parent) {\n-                            // Can't insert here into the parent tree, since we want the order\n-                            // of children to be deterministic\n-                            return Ok((Some(parent), key.clone()));\n-                        }\n-                        current = parent;\n-                    }\n-                }\n-            })\n-            .try_join()\n-            .await\n-    }\n-\n-    /// Create the tree nodes.\n-    fn create_node_tree(common_parents: FxIndexSet<K>) -> FxIndexMap<K, Rc<RefCell<Node<K, V>>>> {\n-        let mut trees = FxIndexMap::<K, Rc<RefCell<Node<K, V>>>>::default();\n-        for common_parent in common_parents {\n-            trees.insert(\n-                common_parent.clone(),\n-                Rc::new(RefCell::new(Node {\n-                    key: common_parent,\n-                    values: Vec::new(),\n-                    children: Vec::new(),\n-                })),\n-            );\n-        }\n-        trees\n-    }\n-\n-    /// Add chunks to nodes.\n-    fn add_values_to_tree(\n-        trees: &mut FxIndexMap<K, Rc<RefCell<Node<K, V>>>>,\n-        values: Vec<(Option<K>, V)>,\n-    ) -> Vec<V> {\n-        let mut orphan_values = Vec::new();\n-        for (common_parent, chunk) in values {\n-            if let Some(common_parent) = common_parent {\n-                trees\n-                    .get_mut(&common_parent)\n-                    .unwrap()\n-                    .borrow_mut()\n-                    .values\n-                    .push(chunk);\n-            } else {\n-                orphan_values.push(chunk);\n-            }\n-        }\n-        orphan_values\n-    }\n-\n-    /// Nest each tree by relationship, compute the roots\n-    fn treeify(\n-        relationships: Vec<(Option<K>, K)>,\n-        trees: &FxIndexMap<K, Rc<RefCell<Node<K, V>>>>,\n-    ) -> Vec<Rc<RefCell<Node<K, V>>>> {\n-        relationships\n-            .into_iter()\n-            .flat_map(|(parent, key)| {\n-                let tree = trees.get(&key).unwrap().clone();\n-                if let Some(parent) = parent {\n-                    trees.get(&parent).unwrap().borrow_mut().children.push(tree);\n-                    None\n-                } else {\n-                    Some(tree)\n-                }\n-            })\n-            .collect::<Vec<_>>()\n-    }\n-\n-    /// Optimize tree by removing unnecessary nodes.\n-    fn skip_unnecessary_nodes(trees: &mut FxIndexMap<K, Rc<RefCell<Node<K, V>>>>) {\n-        for tree in trees.values_mut() {\n-            let mut tree = tree.borrow_mut();\n-            if tree.values.is_empty() && tree.children.len() == 1 {\n-                let child = tree.children.pop().unwrap();\n-                let mut child = child.borrow_mut();\n-                tree.key = child.key.clone();\n-                tree.values.append(&mut child.values);\n-                tree.children.append(&mut child.children);\n-            }\n-        }\n-    }\n-\n-    // Convert function to the real data structure\n-    fn node_to_common_parent_tree(node: Rc<RefCell<Node<K, V>>>) -> ContainmentTree<K, V> {\n-        let mut node = node.borrow_mut();\n-        let children = take(&mut node.children)\n-            .into_iter()\n-            .map(Self::node_to_common_parent_tree)\n-            .collect();\n-        // TODO keyed cell: this would benefit from keying the cell by node.path\n-        let values = Some(take(&mut node.values));\n-        ContainmentTree {\n-            key: Some(node.key.clone()),\n-            values,\n-            children,\n-        }\n-    }\n-\n-    fn convert_into_common_parent_tree(\n-        roots: Vec<Rc<RefCell<Node<K, V>>>>,\n-        orphan_values: Vec<V>,\n-    ) -> Vec<ContainmentTree<K, V>> {\n-        roots\n-            .into_iter()\n-            .map(Self::node_to_common_parent_tree)\n-            .chain(orphan_values.into_iter().map(|value| ContainmentTree {\n-                key: None,\n-                values: Some(vec![value]),\n-                children: Vec::new(),\n-            }))\n-            .collect::<Vec<_>>()\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    #![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n-    use async_trait::async_trait;\n-\n-    use super::*;\n-\n-    #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-    struct TestKey(u32, u32);\n-\n-    #[async_trait]\n-    impl ContainmentTreeKey for TestKey {\n-        async fn parent(&self) -> Result<Self> {\n-            if self.1 == 0 {\n-                Ok(TestKey(self.0, 0))\n-            } else {\n-                Ok(TestKey(self.0, self.1 - 1))\n-            }\n-        }\n-    }\n-\n-    #[tokio::test]\n-    async fn test_build_simple_input() -> Result<()> {\n-        let input = vec![\n-            (None, \"value0\"),\n-            (Some(TestKey(0, 0)), \"value1\"),\n-            (Some(TestKey(0, 1)), \"value2\"),\n-            (Some(TestKey(0, 2)), \"value3\"),\n-            (Some(TestKey(1, 2)), \"value4\"),\n-        ];\n-\n-        let tree = ContainmentTree::<TestKey, &str>::build(input).await?;\n-\n-        assert_eq!(\n-            tree,\n-            ContainmentTree {\n-                key: None,\n-                values: None,\n-                children: vec![\n-                    ContainmentTree {\n-                        key: Some(TestKey(0, 0)),\n-                        values: Some(vec![\"value1\"]),\n-                        children: vec![ContainmentTree {\n-                            key: Some(TestKey(0, 1)),\n-                            values: Some(vec![\"value2\"]),\n-                            children: vec![ContainmentTree {\n-                                key: Some(TestKey(0, 2)),\n-                                values: Some(vec![\"value3\"]),\n-                                children: vec![]\n-                            }]\n-                        }]\n-                    },\n-                    ContainmentTree {\n-                        key: Some(TestKey(1, 2)),\n-                        values: Some(vec![\"value4\"]),\n-                        children: vec![]\n-                    },\n-                    ContainmentTree {\n-                        key: None,\n-                        values: Some(vec![\"value0\"]),\n-                        children: vec![]\n-                    },\n-                ]\n-            }\n-        );\n-\n-        Ok(())\n-    }\n-}"
        },
        {
            "sha": "727ef6b58039fff5e7ef2dc20bb819872a3fccf8",
            "filename": "turbopack/crates/turbopack-core/src/chunk/mod.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/abf056b36f06442abb16847f8da9edf130e61026/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/abf056b36f06442abb16847f8da9edf130e61026/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fmod.rs?ref=abf056b36f06442abb16847f8da9edf130e61026",
            "patch": "@@ -4,11 +4,9 @@ pub mod chunk_group;\n pub(crate) mod chunk_item_batch;\n pub mod chunking;\n pub(crate) mod chunking_context;\n-pub(crate) mod containment_tree;\n pub(crate) mod data;\n pub(crate) mod evaluate;\n pub mod module_id_strategies;\n-pub mod optimize;\n \n use std::fmt::Display;\n "
        },
        {
            "sha": "c04fdcd6536ed1f7662354ed226e32019b49a99d",
            "filename": "turbopack/crates/turbopack-core/src/chunk/optimize.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 75,
            "changes": 75,
            "blob_url": "https://github.com/vercel/next.js/blob/669b3e74deb9ee3ba64e0eb7f9502f0875924cdf/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Foptimize.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/669b3e74deb9ee3ba64e0eb7f9502f0875924cdf/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Foptimize.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Foptimize.rs?ref=669b3e74deb9ee3ba64e0eb7f9502f0875924cdf",
            "patch": "@@ -1,75 +0,0 @@\n-//! Traits and functions to optimize a list of chunks.\n-//!\n-//! Usually chunks are optimized by limiting their total count, restricting\n-//! their size and eliminating duplicates between them.\n-\n-use anyhow::Result;\n-use turbo_tasks::{TryJoinIterExt, Vc};\n-use turbo_tasks_fs::{FileSystemPath, FileSystemPathOption};\n-\n-use crate::chunk::containment_tree::{ContainmentTree, ContainmentTreeKey};\n-\n-#[derive(Debug, Clone, Eq, PartialEq, Hash)]\n-struct FileSystemPathKey(FileSystemPath);\n-\n-impl FileSystemPathKey {\n-    async fn new(path: FileSystemPath) -> Result<Self> {\n-        Ok(Self(path))\n-    }\n-}\n-\n-#[async_trait::async_trait]\n-impl ContainmentTreeKey for FileSystemPathKey {\n-    async fn parent(&self) -> Result<Self> {\n-        Ok(FileSystemPathKey::new(self.0.parent()).await?)\n-    }\n-}\n-\n-pub async fn optimize_by_common_parent<T, Acc, GetCommonParent, Optimize>(\n-    chunks: &[T],\n-    get_common_parent: GetCommonParent,\n-    optimize: Optimize,\n-) -> Result<Acc>\n-where\n-    T: Clone,\n-    GetCommonParent: Fn(T) -> Vc<FileSystemPathOption> + Clone,\n-    Optimize: Fn(Option<Vec<T>>, Vec<Acc>) -> Acc,\n-{\n-    let tree = ContainmentTree::build(\n-        chunks\n-            .iter()\n-            .map(move |chunk| {\n-                let get_common_parent = get_common_parent.clone();\n-                async move {\n-                    let common_parent = get_common_parent(chunk.clone()).await?;\n-\n-                    Ok((\n-                        if let Some(common_parent) = &*common_parent {\n-                            Some(FileSystemPathKey::new(common_parent.clone()).await?)\n-                        } else {\n-                            None\n-                        },\n-                        chunk.clone(),\n-                    ))\n-                }\n-            })\n-            .try_join()\n-            .await?,\n-    )\n-    .await?;\n-\n-    fn optimize_tree<K, V, Acc>(\n-        tree: ContainmentTree<K, V>,\n-        optimize: &impl Fn(Option<Vec<V>>, Vec<Acc>) -> Acc,\n-    ) -> Acc {\n-        let children = tree\n-            .children\n-            .into_iter()\n-            .map(|tree| optimize_tree(tree, optimize))\n-            .collect::<Vec<_>>();\n-\n-        optimize(tree.values, children)\n-    }\n-\n-    Ok(optimize_tree(tree, &optimize))\n-}"
        }
    ],
    "stats": {
        "total": 355,
        "additions": 0,
        "deletions": 355
    }
}