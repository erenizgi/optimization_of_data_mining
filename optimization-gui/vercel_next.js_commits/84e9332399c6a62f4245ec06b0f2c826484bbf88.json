{
    "author": "mischnic",
    "message": "Turbopack: print failing module during panic (#82938)\n\nInclude the actual module in the panic, not only the merged chunk item.\nParticularly with the \"scope hoisting bit width issue\".\n\nWell, and also make it a bail instead of a panic.",
    "sha": "84e9332399c6a62f4245ec06b0f2c826484bbf88",
    "files": [
        {
            "sha": "875c78ff5568453cd84678c65d989c5e42d1a48a",
            "filename": "turbopack/crates/turbopack-ecmascript/src/lib.rs",
            "status": "modified",
            "additions": 51,
            "deletions": 21,
            "changes": 72,
            "blob_url": "https://github.com/vercel/next.js/blob/84e9332399c6a62f4245ec06b0f2c826484bbf88/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/84e9332399c6a62f4245ec06b0f2c826484bbf88/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs?ref=84e9332399c6a62f4245ec06b0f2c826484bbf88",
            "patch": "@@ -42,7 +42,7 @@ use std::{\n     sync::Arc,\n };\n \n-use anyhow::{Context, Result, bail};\n+use anyhow::{Context, Result, anyhow, bail};\n use chunk::EcmascriptChunkItem;\n use code_gen::{CodeGeneration, CodeGenerationHoistedStmt};\n use either::Either;\n@@ -1168,6 +1168,8 @@ async fn merge_modules(\n             (ResolvedVc<Box<dyn EcmascriptChunkPlaceable>>, SyntaxContext),\n             SyntaxContext,\n         >,\n+\n+        error: anyhow::Result<()>,\n     }\n \n     impl<'a> SetSyntaxContextVisitor<'a> {\n@@ -1247,12 +1249,20 @@ async fn merge_modules(\n                 self.modules_header_width,\n                 self.current_module_idx,\n                 span.lo,\n-            );\n+            )\n+            .unwrap_or_else(|err| {\n+                self.error = Err(err);\n+                span.lo\n+            });\n             span.hi = CodeGenResultComments::encode_bytepos(\n                 self.modules_header_width,\n                 self.current_module_idx,\n                 span.hi,\n-            );\n+            )\n+            .unwrap_or_else(|err| {\n+                self.error = Err(err);\n+                span.hi\n+            });\n         }\n     }\n \n@@ -1277,7 +1287,7 @@ async fn merge_modules(\n         })\n         .collect::<Result<FxHashMap<_, _>>>()?;\n \n-    let (merged_ast, inserted) = GLOBALS.set(globals_merged, || {\n+    let result = GLOBALS.set(globals_merged, || {\n         let _ = tracing::trace_span!(\"merge inner\").entered();\n         // As an optimization, assume an average number of 5 contexts per module.\n         let mut unique_contexts_cache =\n@@ -1296,7 +1306,7 @@ async fn merge_modules(\n                 {\n                     let modules_header_width = module_count.next_power_of_two().trailing_zeros();\n                     GLOBALS.set(globals_merged, || {\n-                        program.visit_mut_with(&mut SetSyntaxContextVisitor {\n+                        let mut visitor = SetSyntaxContextVisitor {\n                             modules_header_width,\n                             current_module: *module,\n                             current_module_idx: current_module_idx as u32,\n@@ -1306,8 +1316,10 @@ async fn merge_modules(\n                                 .collect(),\n                             export_contexts: &export_contexts,\n                             unique_contexts_cache: &mut unique_contexts_cache,\n-                        });\n-                        anyhow::Ok(())\n+                            error: Ok(()),\n+                        };\n+                        program.visit_mut_with(&mut visitor);\n+                        visitor.error\n                     })?;\n \n                     Ok(match program.take() {\n@@ -1334,10 +1346,13 @@ async fn merge_modules(\n         // ith-module.\n         let mut queue = entry_points\n             .iter()\n-            .map(|(_, i)| prepare_module(contents.len(), *i, &contents[*i], &mut programs[*i]))\n+            .map(|&(_, i)| {\n+                prepare_module(contents.len(), i, &contents[i], &mut programs[i])\n+                    .map_err(|err| (i, err))\n+            })\n             .flatten_ok()\n             .rev()\n-            .collect::<Result<Vec<_>>>()?;\n+            .collect::<Result<Vec<_>, _>>()?;\n         let mut result = vec![];\n         while let Some(item) = queue.pop() {\n             if let ModuleItem::Stmt(stmt) = &item {\n@@ -1361,7 +1376,8 @@ async fn merge_modules(\n                                         index,\n                                         &contents[index],\n                                         &mut programs[index],\n-                                    )?\n+                                    )\n+                                    .map_err(|err| (index, err))?\n                                     .into_iter()\n                                     .rev(),\n                                 );\n@@ -1418,8 +1434,18 @@ async fn merge_modules(\n         merged_ast.visit_mut_with(&mut swc_core::ecma::transforms::base::hygiene::hygiene());\n         drop(span);\n \n-        anyhow::Ok((merged_ast, inserted))\n-    })?;\n+        Ok((merged_ast, inserted))\n+    });\n+\n+    let (merged_ast, inserted) = match result {\n+        Ok(v) => v,\n+        Err((content_idx, err)) => {\n+            return Err(err.context(format!(\n+                \"Processing {}\",\n+                contents[content_idx].0.ident().to_string().await?\n+            )));\n+        }\n+    };\n \n     debug_assert!(\n         inserted.len() == contents.len(),\n@@ -2395,10 +2421,10 @@ impl CodeGenResultComments {\n         }\n     }\n \n-    fn encode_bytepos(modules_header_width: u32, module: u32, pos: BytePos) -> BytePos {\n+    fn encode_bytepos(modules_header_width: u32, module: u32, pos: BytePos) -> Result<BytePos> {\n         if pos.is_dummy() {\n             // nothing to encode\n-            return pos;\n+            return Ok(pos);\n         }\n \n         // 00010000000000100100011010100101\n@@ -2426,17 +2452,17 @@ impl CodeGenResultComments {\n         } else if old_high_bits == 0 {\n             false\n         } else {\n-            panic!(\n+            return Err(anyhow!(\n                 \"The high bits of the position {pos} are not all 0s or 1s. \\\n                  modules_header_width={modules_header_width}, module={module}\",\n-            );\n+            ));\n         };\n \n         let pos = pos & !((2u32.pow(header_width) - 1) << pos_width);\n         let encoded_high_bits = if high_bits_set { 1 } else { 0 } << pos_width;\n         let encoded_module = module << (pos_width + 1);\n \n-        BytePos(encoded_module | encoded_high_bits | pos)\n+        Ok(BytePos(encoded_module | encoded_high_bits | pos))\n     }\n \n     fn decode_bytepos(modules_header_width: u32, pos: BytePos) -> (usize, BytePos) {\n@@ -2484,9 +2510,11 @@ fn encode_module_into_comment_span(\n     mut comment: Comment,\n ) -> Comment {\n     comment.span.lo =\n-        CodeGenResultComments::encode_bytepos(modules_header_width, module as u32, comment.span.lo);\n+        CodeGenResultComments::encode_bytepos(modules_header_width, module as u32, comment.span.lo)\n+            .unwrap();\n     comment.span.hi =\n-        CodeGenResultComments::encode_bytepos(modules_header_width, module as u32, comment.span.hi);\n+        CodeGenResultComments::encode_bytepos(modules_header_width, module as u32, comment.span.hi)\n+            .unwrap();\n     comment\n }\n \n@@ -2703,7 +2731,8 @@ mod tests {\n         .into_iter()\n         .filter(|&m| m < module_count)\n         {\n-            let encoded = CodeGenResultComments::encode_bytepos(modules_header_width, module, pos);\n+            let encoded =\n+                CodeGenResultComments::encode_bytepos(modules_header_width, module, pos).unwrap();\n             let (decoded_module, decoded_pos) =\n                 CodeGenResultComments::decode_bytepos(modules_header_width, encoded);\n             assert_eq!(\n@@ -2748,7 +2777,8 @@ mod tests {\n             (BytePos::DUMMY.0, 0b0001, 4, BytePos::DUMMY.0),\n         ] {\n             let encoded =\n-                CodeGenResultComments::encode_bytepos(modules_header_width, module, BytePos(pos));\n+                CodeGenResultComments::encode_bytepos(modules_header_width, module, BytePos(pos))\n+                    .unwrap();\n             assert_eq!(encoded.0, result);\n         }\n     }"
        }
    ],
    "stats": {
        "total": 72,
        "additions": 51,
        "deletions": 21
    }
}