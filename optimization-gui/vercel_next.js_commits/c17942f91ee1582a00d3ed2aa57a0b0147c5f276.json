{
    "author": "lukesandberg",
    "message": "Unroll recursion in `RuleCondition::matches` This trades allocations due to `Box::pin` calls during recursion for an explicit stack and a tiny interpreter loop. (#79310)\n\n### What?\nReplace recursion with an explicit stack to reduce allocations.  Also, add tests!\n\nThis trims peak heap in a build of `vercel-site` by 100-300m, see https://vercel.slack.com/archives/C06PPGZ0FD3/p1747438469043789?thread_ts=1746823119.596949&cid=C06PPGZ0FD3\n\n\n### Why?\nThis replaces a lot of `Box::pin` calls during evaluation, instead we can amortize the heap allocation cost by pushing items onto explicit stack. This is managed as a SmallVec so in many cases we should be able to avoid allocations.\n\n### How?\nTediously introduce a small bytecode machine... sigh.  The main alternatives considered were:\n\n* pulling all `awaits` up to the top level and using a normal recursive function.  This works, but would be limiting when we inevitably add another async dependency on the `Source::content`\n* eliminating asynchrony from `Source::ident`.  This turned out to be controversial (see discussion in linear) and incredibly complex to implement so it is deferred.\n\nCloses PACK-4560",
    "sha": "c17942f91ee1582a00d3ed2aa57a0b0147c5f276",
    "files": [
        {
            "sha": "370361d330e303ba2dda6d6a778965e20233d1af",
            "filename": "Cargo.lock",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/c17942f91ee1582a00d3ed2aa57a0b0147c5f276/Cargo.lock",
            "raw_url": "https://github.com/vercel/next.js/raw/c17942f91ee1582a00d3ed2aa57a0b0147c5f276/Cargo.lock",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/Cargo.lock?ref=c17942f91ee1582a00d3ed2aa57a0b0147c5f276",
            "patch": "@@ -9896,6 +9896,7 @@ dependencies = [\n  \"turbo-esregex\",\n  \"turbo-rcstr\",\n  \"turbo-tasks\",\n+ \"turbo-tasks-backend\",\n  \"turbo-tasks-build\",\n  \"turbo-tasks-env\",\n  \"turbo-tasks-fs\","
        },
        {
            "sha": "cb3dee27ab0bb9472a564c25cbe9cc634d48ffeb",
            "filename": "turbopack/crates/turbopack/Cargo.toml",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/c17942f91ee1582a00d3ed2aa57a0b0147c5f276/turbopack%2Fcrates%2Fturbopack%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/c17942f91ee1582a00d3ed2aa57a0b0147c5f276/turbopack%2Fcrates%2Fturbopack%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack%2FCargo.toml?ref=c17942f91ee1582a00d3ed2aa57a0b0147c5f276",
            "patch": "@@ -54,6 +54,7 @@ rstest_reuse = \"0.5.0\"\n tokio = { workspace = true }\n turbo-tasks-malloc = { workspace = true, default-features = false }\n turbo-tasks-memory = { workspace = true }\n+turbo-tasks-backend = { workspace = true }\n \n [build-dependencies]\n turbo-tasks-build = { workspace = true }"
        },
        {
            "sha": "12ecf0782b99e4485daaba0db7e9667f4fd1f464",
            "filename": "turbopack/crates/turbopack/src/module_options/rule_condition.rs",
            "status": "modified",
            "additions": 445,
            "deletions": 54,
            "changes": 499,
            "blob_url": "https://github.com/vercel/next.js/blob/c17942f91ee1582a00d3ed2aa57a0b0147c5f276/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Frule_condition.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c17942f91ee1582a00d3ed2aa57a0b0147c5f276/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Frule_condition.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Frule_condition.rs?ref=c17942f91ee1582a00d3ed2aa57a0b0147c5f276",
            "patch": "@@ -1,5 +1,6 @@\n use anyhow::{Result, bail};\n use serde::{Deserialize, Serialize};\n+use smallvec::SmallVec;\n use turbo_esregex::EsRegex;\n use turbo_tasks::{NonLocalValue, ReadRef, ResolvedVc, primitives::Regex, trace::TraceRawVcs};\n use turbo_tasks_fs::{FileSystemPath, glob::Glob};\n@@ -59,75 +60,465 @@ impl RuleCondition {\n         path: &FileSystemPath,\n         reference_type: &ReferenceType,\n     ) -> Result<bool> {\n-        Ok(match self {\n-            RuleCondition::All(conditions) => {\n-                for condition in conditions {\n-                    if !Box::pin(condition.matches(source, path, reference_type)).await? {\n-                        return Ok(false);\n+        enum Op<'a> {\n+            All(&'a [RuleCondition]), // Remaining conditions in an All\n+            Any(&'a [RuleCondition]), // Remaining conditions in an Any\n+            Not,                      // Inverts the previous condition\n+        }\n+\n+        // Evaluates the condition returning the result and possibly pushing additional operations\n+        // onto the stack as a kind of continuation.\n+        async fn process_condition<'a, const SZ: usize>(\n+            source: ResolvedVc<Box<dyn Source + 'static>>,\n+            path: &FileSystemPath,\n+            reference_type: &ReferenceType,\n+            stack: &mut SmallVec<[Op<'a>; SZ]>,\n+            mut cond: &'a RuleCondition,\n+        ) -> Result<bool, anyhow::Error> {\n+            // Use a loop to avoid recursion and unnecessary stack operations.\n+            loop {\n+                match cond {\n+                    RuleCondition::All(conditions) => {\n+                        if conditions.is_empty() {\n+                            return Ok(true);\n+                        } else {\n+                            if conditions.len() > 1 {\n+                                stack.push(Op::All(&conditions[1..]));\n+                            }\n+                            cond = &conditions[0];\n+                            // jump directly to the next condition, no need to deal with\n+                            // the stack.\n+                            continue;\n+                        }\n+                    }\n+                    RuleCondition::Any(conditions) => {\n+                        if conditions.is_empty() {\n+                            return Ok(false);\n+                        } else {\n+                            if conditions.len() > 1 {\n+                                stack.push(Op::Any(&conditions[1..]));\n+                            }\n+                            cond = &conditions[0];\n+                            continue;\n+                        }\n+                    }\n+                    RuleCondition::Not(inner) => {\n+                        stack.push(Op::Not);\n+                        cond = inner.as_ref();\n+                        continue;\n+                    }\n+                    RuleCondition::ReferenceType(condition_ty) => {\n+                        return Ok(condition_ty.includes(reference_type));\n+                    }\n+                    RuleCondition::ResourceIsVirtualSource => {\n+                        return Ok(ResolvedVc::try_downcast_type::<VirtualSource>(source).is_some());\n+                    }\n+                    RuleCondition::ResourcePathEquals(other) => {\n+                        return Ok(path == &**other);\n+                    }\n+                    RuleCondition::ResourcePathEndsWith(end) => {\n+                        return Ok(path.path.ends_with(end));\n+                    }\n+                    RuleCondition::ResourcePathHasNoExtension => {\n+                        return Ok(if let Some(i) = path.path.rfind('.') {\n+                            if let Some(j) = path.path.rfind('/') {\n+                                j > i\n+                            } else {\n+                                false\n+                            }\n+                        } else {\n+                            true\n+                        });\n+                    }\n+                    RuleCondition::ResourcePathInDirectory(dir) => {\n+                        return Ok(path.path.starts_with(&format!(\"{dir}/\"))\n+                            || path.path.contains(&format!(\"/{dir}/\")));\n+                    }\n+                    RuleCondition::ResourcePathInExactDirectory(parent_path) => {\n+                        return Ok(path.is_inside_ref(parent_path));\n+                    }\n+                    RuleCondition::ContentTypeStartsWith(start) => {\n+                        let content_type = &source.ident().await?.content_type;\n+                        return Ok(content_type\n+                            .as_ref()\n+                            .is_some_and(|ct| ct.starts_with(start)));\n+                    }\n+                    RuleCondition::ContentTypeEmpty => {\n+                        return Ok(source.ident().await?.content_type.is_none());\n+                    }\n+                    RuleCondition::ResourcePathGlob { glob, base } => {\n+                        return Ok(if let Some(rel_path) = base.get_relative_path_to(path) {\n+                            glob.execute(&rel_path)\n+                        } else {\n+                            glob.execute(&path.path)\n+                        });\n+                    }\n+                    RuleCondition::ResourceBasePathGlob(glob) => {\n+                        let basename = path\n+                            .path\n+                            .rsplit_once('/')\n+                            .map_or(path.path.as_str(), |(_, b)| b);\n+                        return Ok(glob.execute(basename));\n+                    }\n+                    RuleCondition::ResourcePathRegex(_) => {\n+                        bail!(\"ResourcePathRegex not implemented yet\");\n+                    }\n+                    RuleCondition::ResourcePathEsRegex(regex) => {\n+                        return Ok(regex.is_match(&path.path));\n                     }\n                 }\n-                true\n             }\n-            RuleCondition::Any(conditions) => {\n-                for condition in conditions {\n-                    if Box::pin(condition.matches(source, path, reference_type)).await? {\n-                        return Ok(true);\n+        }\n+        // Allocate a small inline stack to avoid heap allocations in the common case where\n+        // conditions are not deeply stacked.  Additionally we take care to avoid stack\n+        // operations unless strictly necessary.\n+        const EXPECTED_SIZE: usize = 8;\n+        let mut stack = SmallVec::<[Op; EXPECTED_SIZE]>::with_capacity(EXPECTED_SIZE);\n+        let mut result = process_condition(source, path, reference_type, &mut stack, self).await?;\n+        while let Some(op) = stack.pop() {\n+            match op {\n+                Op::All(remaining) => {\n+                    // Previous was true, keep going\n+                    if result {\n+                        if remaining.len() > 1 {\n+                            stack.push(Op::All(&remaining[1..]));\n+                        }\n+                        result = process_condition(\n+                            source,\n+                            path,\n+                            reference_type,\n+                            &mut stack,\n+                            &remaining[0],\n+                        )\n+                        .await?;\n+                    }\n+                }\n+                Op::Any(remaining) => {\n+                    // Previous was false, keep going\n+                    if !result {\n+                        if remaining.len() > 1 {\n+                            stack.push(Op::Any(&remaining[1..]));\n+                        }\n+                        // If the stack didn't change, we can loop inline, but we would still need\n+                        // to pop the item.  This might be faster since we would avoid the `match`\n+                        // but overall, that is quite minor for an enum with 3 cases.\n+                        result = process_condition(\n+                            source,\n+                            path,\n+                            reference_type,\n+                            &mut stack,\n+                            &remaining[0],\n+                        )\n+                        .await?;\n                     }\n                 }\n-                false\n+                Op::Not => {\n+                    result = !result;\n+                }\n             }\n-            RuleCondition::Not(condition) => {\n-                !Box::pin(condition.matches(source, path, reference_type)).await?\n+        }\n+        Ok(result)\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use turbo_tasks::Vc;\n+    use turbo_tasks_backend::{BackendOptions, TurboTasksBackend, noop_backing_storage};\n+    use turbo_tasks_fs::{FileContent, FileSystem, VirtualFileSystem};\n+    use turbopack_core::{asset::AssetContent, file_source::FileSource};\n+\n+    use super::*;\n+\n+    #[tokio::test]\n+    async fn test_rule_condition_leaves() {\n+        crate::register();\n+        let tt = turbo_tasks::TurboTasks::new(TurboTasksBackend::new(\n+            BackendOptions::default(),\n+            noop_backing_storage(),\n+        ));\n+        tt.run_once(async {\n+            let fs = VirtualFileSystem::new();\n+            let virtual_path = fs.root().join(\"foo.js\".into());\n+            let virtual_source = Vc::upcast::<Box<dyn Source>>(VirtualSource::new(\n+                virtual_path,\n+                AssetContent::File(FileContent::NotFound.cell().to_resolved().await?).cell(),\n+            ))\n+            .to_resolved()\n+            .await?;\n+\n+            let non_virtual_path = fs.root().join(\"bar.js\".into());\n+            let non_virtual_source =\n+                Vc::upcast::<Box<dyn Source>>(FileSource::new(non_virtual_path))\n+                    .to_resolved()\n+                    .await?;\n+\n+            {\n+                let condition = RuleCondition::ReferenceType(ReferenceType::Runtime);\n+                assert!(\n+                    condition\n+                        .matches(\n+                            virtual_source,\n+                            &*virtual_path.await?,\n+                            &ReferenceType::Runtime\n+                        )\n+                        .await\n+                        .unwrap()\n+                );\n+                assert!(\n+                    !condition\n+                        .matches(\n+                            non_virtual_source,\n+                            &*non_virtual_path.await?,\n+                            &ReferenceType::Css(\n+                                turbopack_core::reference_type::CssReferenceSubType::Compose\n+                            )\n+                        )\n+                        .await\n+                        .unwrap()\n+                );\n             }\n-            RuleCondition::ResourcePathEquals(other) => path == &**other,\n-            RuleCondition::ResourcePathEndsWith(end) => path.path.ends_with(end),\n-            RuleCondition::ResourcePathHasNoExtension => {\n-                if let Some(i) = path.path.rfind('.') {\n-                    if let Some(j) = path.path.rfind('/') {\n-                        j > i\n-                    } else {\n-                        false\n-                    }\n-                } else {\n-                    true\n-                }\n+\n+            {\n+                let condition = RuleCondition::ResourceIsVirtualSource;\n+                assert!(\n+                    condition\n+                        .matches(\n+                            virtual_source,\n+                            &*virtual_path.await?,\n+                            &ReferenceType::Undefined\n+                        )\n+                        .await\n+                        .unwrap()\n+                );\n+                assert!(\n+                    !condition\n+                        .matches(\n+                            non_virtual_source,\n+                            &*non_virtual_path.await?,\n+                            &ReferenceType::Undefined\n+                        )\n+                        .await\n+                        .unwrap()\n+                );\n             }\n-            RuleCondition::ResourcePathInDirectory(dir) => {\n-                path.path.starts_with(&format!(\"{dir}/\")) || path.path.contains(&format!(\"/{dir}/\"))\n+            {\n+                let condition = RuleCondition::ResourcePathEquals(virtual_path.await?);\n+                assert!(\n+                    condition\n+                        .matches(\n+                            virtual_source,\n+                            &*virtual_path.await?,\n+                            &ReferenceType::Undefined\n+                        )\n+                        .await\n+                        .unwrap()\n+                );\n+                assert!(\n+                    !condition\n+                        .matches(\n+                            non_virtual_source,\n+                            &*non_virtual_path.await?,\n+                            &ReferenceType::Undefined\n+                        )\n+                        .await\n+                        .unwrap()\n+                );\n             }\n-            RuleCondition::ResourcePathInExactDirectory(parent_path) => {\n-                path.is_inside_ref(parent_path)\n+            {\n+                let condition = RuleCondition::ResourcePathHasNoExtension;\n+                assert!(\n+                    condition\n+                        .matches(\n+                            virtual_source,\n+                            &*fs.root().join(\"foo\".into()).await?,\n+                            &ReferenceType::Undefined\n+                        )\n+                        .await\n+                        .unwrap()\n+                );\n+                assert!(\n+                    !condition\n+                        .matches(\n+                            non_virtual_source,\n+                            &*non_virtual_path.await?,\n+                            &ReferenceType::Undefined\n+                        )\n+                        .await\n+                        .unwrap()\n+                );\n             }\n-            RuleCondition::ReferenceType(condition_ty) => condition_ty.includes(reference_type),\n-            RuleCondition::ResourceIsVirtualSource => {\n-                ResolvedVc::try_downcast_type::<VirtualSource>(source).is_some()\n+            {\n+                let condition = RuleCondition::ResourcePathEndsWith(\"foo.js\".to_string());\n+                assert!(\n+                    condition\n+                        .matches(\n+                            virtual_source,\n+                            &*virtual_path.await?,\n+                            &ReferenceType::Undefined\n+                        )\n+                        .await\n+                        .unwrap()\n+                );\n+                assert!(\n+                    !condition\n+                        .matches(\n+                            non_virtual_source,\n+                            &*non_virtual_path.await?,\n+                            &ReferenceType::Undefined\n+                        )\n+                        .await\n+                        .unwrap()\n+                );\n             }\n-            RuleCondition::ContentTypeStartsWith(start) => {\n-                if let Some(content_type) = source.ident().await?.content_type.as_ref() {\n-                    content_type.starts_with(start)\n-                } else {\n-                    false\n-                }\n+            anyhow::Ok(())\n+        })\n+        .await\n+        .unwrap();\n+    }\n+\n+    #[tokio::test]\n+    async fn test_rule_condition_tree() {\n+        crate::register();\n+        let tt = turbo_tasks::TurboTasks::new(TurboTasksBackend::new(\n+            BackendOptions::default(),\n+            noop_backing_storage(),\n+        ));\n+        tt.run_once(async {\n+            let fs = VirtualFileSystem::new();\n+            let virtual_path = fs.root().join(\"foo.js\".into());\n+            let virtual_source = Vc::upcast::<Box<dyn Source>>(VirtualSource::new(\n+                virtual_path,\n+                AssetContent::File(FileContent::NotFound.cell().to_resolved().await?).cell(),\n+            ))\n+            .to_resolved()\n+            .await?;\n+\n+            let non_virtual_path = fs.root().join(\"bar.js\".into());\n+            let non_virtual_source =\n+                Vc::upcast::<Box<dyn Source>>(FileSource::new(non_virtual_path))\n+                    .to_resolved()\n+                    .await?;\n+\n+            {\n+                // not\n+                let condition = RuleCondition::not(RuleCondition::ResourceIsVirtualSource);\n+                assert!(\n+                    !condition\n+                        .matches(\n+                            virtual_source,\n+                            &*virtual_path.await?,\n+                            &ReferenceType::Undefined\n+                        )\n+                        .await\n+                        .unwrap()\n+                );\n+                assert!(\n+                    condition\n+                        .matches(\n+                            non_virtual_source,\n+                            &*non_virtual_path.await?,\n+                            &ReferenceType::Undefined\n+                        )\n+                        .await\n+                        .unwrap()\n+                );\n             }\n-            RuleCondition::ContentTypeEmpty => source.ident().await?.content_type.is_none(),\n-            RuleCondition::ResourcePathGlob { glob, base } => {\n-                if let Some(path) = base.get_relative_path_to(path) {\n-                    glob.execute(&path)\n-                } else {\n-                    glob.execute(&path.path)\n-                }\n+            {\n+                // any\n+                // Only one of the conditions matches our virtual source\n+                let condition = RuleCondition::any(vec![\n+                    RuleCondition::ResourcePathInDirectory(\"doesnt/exist\".to_string()),\n+                    RuleCondition::ResourceIsVirtualSource,\n+                    RuleCondition::ResourcePathHasNoExtension,\n+                ]);\n+                assert!(\n+                    condition\n+                        .matches(\n+                            virtual_source,\n+                            &*virtual_path.await?,\n+                            &ReferenceType::Undefined\n+                        )\n+                        .await\n+                        .unwrap()\n+                );\n+                assert!(\n+                    !condition\n+                        .matches(\n+                            non_virtual_source,\n+                            &*non_virtual_path.await?,\n+                            &ReferenceType::Undefined\n+                        )\n+                        .await\n+                        .unwrap()\n+                );\n             }\n-            RuleCondition::ResourceBasePathGlob(glob) => {\n-                let basename = path\n-                    .path\n-                    .rsplit_once('/')\n-                    .map_or(path.path.as_str(), |(_, b)| b);\n-                glob.execute(basename)\n+            {\n+                // all\n+                // Only one of the conditions matches our virtual source\n+                let condition = RuleCondition::all(vec![\n+                    RuleCondition::ResourcePathEndsWith(\"foo.js\".to_string()),\n+                    RuleCondition::ResourceIsVirtualSource,\n+                    RuleCondition::ResourcePathEquals(virtual_path.await?),\n+                ]);\n+                assert!(\n+                    condition\n+                        .matches(\n+                            virtual_source,\n+                            &*virtual_path.await?,\n+                            &ReferenceType::Undefined\n+                        )\n+                        .await\n+                        .unwrap()\n+                );\n+                assert!(\n+                    !condition\n+                        .matches(\n+                            non_virtual_source,\n+                            &*non_virtual_path.await?,\n+                            &ReferenceType::Undefined\n+                        )\n+                        .await\n+                        .unwrap()\n+                );\n             }\n-            RuleCondition::ResourcePathRegex(_) => {\n-                bail!(\"ResourcePathRegex not implemented yet\")\n+            {\n+                // bigger tree\n+\n+                // Build a simple tree to cover our various composite conditions\n+                let condition = RuleCondition::all(vec![\n+                    RuleCondition::ResourceIsVirtualSource,\n+                    RuleCondition::ResourcePathEquals(virtual_path.await?),\n+                    RuleCondition::Not(Box::new(RuleCondition::ResourcePathHasNoExtension)),\n+                    RuleCondition::Any(vec![\n+                        RuleCondition::ResourcePathEndsWith(\"foo.js\".to_string()),\n+                        RuleCondition::ContentTypeEmpty,\n+                    ]),\n+                ]);\n+                assert!(\n+                    condition\n+                        .matches(\n+                            virtual_source,\n+                            &*virtual_path.await?,\n+                            &ReferenceType::Undefined\n+                        )\n+                        .await\n+                        .unwrap()\n+                );\n+                assert!(\n+                    !condition\n+                        .matches(\n+                            non_virtual_source,\n+                            &*non_virtual_path.await?,\n+                            &ReferenceType::Undefined\n+                        )\n+                        .await\n+                        .unwrap()\n+                );\n             }\n-            RuleCondition::ResourcePathEsRegex(regex) => regex.is_match(&path.path),\n+            anyhow::Ok(())\n         })\n+        .await\n+        .unwrap();\n     }\n }"
        }
    ],
    "stats": {
        "total": 501,
        "additions": 447,
        "deletions": 54
    }
}