{
    "author": "sokra",
    "message": "Turbopack: fix incorrect graph state bug (#81202)\n\n### What?\n\nTechnically a task should start with `Dirty` flag set and propagate that info through the aggregation graph. But that would be very expensive to do in the initial compilation. So we have the extra check of tasks not having Output set.\n\nBut there is this rare case where a task A calls a task B purely for side effects without `await`ing the output. In this case A would become clean, while B is in its initial computation and don't have Dirty set. This would lead to the subgraph being incorrectly considered as clean.\n\nTo fix that case, we eagerly mark all children as Dirty when they don't have Output set, once the parent task gets its Output set.\n\nBut there was a bug in that implementation where we early exit when Output is set to something equal the previous Output.",
    "sha": "2dbc947cdeebce7fbfc91240d71473395e961616",
    "files": [
        {
            "sha": "1df13365e18243a08ab4303e2fd52bcf80a06cce",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/update_output.rs",
            "status": "modified",
            "additions": 73,
            "deletions": 73,
            "changes": 146,
            "blob_url": "https://github.com/vercel/next.js/blob/2dbc947cdeebce7fbfc91240d71473395e961616/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fupdate_output.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2dbc947cdeebce7fbfc91240d71473395e961616/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fupdate_output.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fupdate_output.rs?ref=2dbc947cdeebce7fbfc91240d71473395e961616",
            "patch": "@@ -48,86 +48,86 @@ impl UpdateOutputOperation {\n         output: Result<RawVc, TurboTasksExecutionError>,\n         mut ctx: impl ExecuteContext,\n     ) {\n-        let mut task = ctx.task(task_id, TaskDataCategory::All);\n-        let Some(InProgressState::InProgress(box InProgressStateInner {\n-            stale,\n-            new_children,\n-            ..\n-        })) = get!(task, InProgress)\n-        else {\n-            panic!(\"Task is not in progress while updating the output\");\n-        };\n-        if *stale {\n-            // Skip updating the output when the task is stale\n-            return;\n-        }\n-        let children = if ctx.should_track_children() {\n-            new_children.iter().copied().collect()\n-        } else {\n-            Default::default()\n-        };\n+        let mut dependent_tasks = Default::default();\n+        let mut children = Default::default();\n+        let mut queue = AggregationUpdateQueue::new();\n \n-        let current_output = get!(task, Output);\n-        let output_value = match output {\n-            Ok(RawVc::TaskOutput(output_task_id)) => {\n-                if let Some(OutputValue::Output(current_task_id)) = current_output\n-                    && *current_task_id == output_task_id\n-                {\n-                    return;\n-                }\n-                OutputValue::Output(output_task_id)\n+        'output: {\n+            let mut task = ctx.task(task_id, TaskDataCategory::All);\n+            let Some(InProgressState::InProgress(box InProgressStateInner {\n+                stale,\n+                new_children,\n+                ..\n+            })) = get!(task, InProgress)\n+            else {\n+                panic!(\"Task is not in progress while updating the output\");\n+            };\n+            if *stale {\n+                // Skip updating the output when the task is stale\n+                break 'output;\n             }\n-            Ok(RawVc::TaskCell(output_task_id, cell)) => {\n-                if let Some(OutputValue::Cell(CellRef {\n-                    task: current_task_id,\n-                    cell: current_cell,\n-                })) = current_output\n-                    && *current_task_id == output_task_id\n-                    && *current_cell == cell\n-                {\n-                    return;\n-                }\n-                OutputValue::Cell(CellRef {\n-                    task: output_task_id,\n-                    cell,\n-                })\n+            if ctx.should_track_children() {\n+                children = new_children.iter().copied().collect();\n             }\n-            Ok(RawVc::LocalOutput(..)) => {\n-                panic!(\"Non-local tasks must not return a local Vc\");\n-            }\n-            Err(err) => {\n-                if let Some(OutputValue::Error(old_error)) = current_output\n-                    && old_error == &err\n-                {\n-                    return;\n-                }\n-                OutputValue::Error(err)\n-            }\n-        };\n-        let old_content = task.insert(CachedDataItem::Output {\n-            value: output_value,\n-        });\n \n-        let dependent_tasks = if ctx.should_track_dependencies() {\n-            get_many!(task, OutputDependent { task } => task)\n-        } else {\n-            Default::default()\n-        };\n+            let current_output = get!(task, Output);\n+            let output_value = match output {\n+                Ok(RawVc::TaskOutput(output_task_id)) => {\n+                    if let Some(OutputValue::Output(current_task_id)) = current_output\n+                        && *current_task_id == output_task_id\n+                    {\n+                        break 'output;\n+                    }\n+                    OutputValue::Output(output_task_id)\n+                }\n+                Ok(RawVc::TaskCell(output_task_id, cell)) => {\n+                    if let Some(OutputValue::Cell(CellRef {\n+                        task: current_task_id,\n+                        cell: current_cell,\n+                    })) = current_output\n+                        && *current_task_id == output_task_id\n+                        && *current_cell == cell\n+                    {\n+                        break 'output;\n+                    }\n+                    OutputValue::Cell(CellRef {\n+                        task: output_task_id,\n+                        cell,\n+                    })\n+                }\n+                Ok(RawVc::LocalOutput(..)) => {\n+                    panic!(\"Non-local tasks must not return a local Vc\");\n+                }\n+                Err(err) => {\n+                    if let Some(OutputValue::Error(old_error)) = current_output\n+                        && old_error == &err\n+                    {\n+                        break 'output;\n+                    }\n+                    OutputValue::Error(err)\n+                }\n+            };\n+            let old_content = task.insert(CachedDataItem::Output {\n+                value: output_value,\n+            });\n \n-        let mut queue = AggregationUpdateQueue::new();\n+            if ctx.should_track_dependencies() {\n+                dependent_tasks = get_many!(task, OutputDependent { task } => task);\n+            }\n \n-        make_task_dirty_internal(\n-            &mut task,\n-            task_id,\n-            false,\n-            #[cfg(feature = \"trace_task_dirty\")]\n-            TaskDirtyCause::InitialDirty,\n-            &mut queue,\n-            &ctx,\n-        );\n+            make_task_dirty_internal(\n+                &mut task,\n+                task_id,\n+                false,\n+                #[cfg(feature = \"trace_task_dirty\")]\n+                TaskDirtyCause::InitialDirty,\n+                &mut queue,\n+                &ctx,\n+            );\n \n-        drop(task);\n-        drop(old_content);\n+            drop(task);\n+            drop(old_content);\n+        }\n \n         UpdateOutputOperation::MakeDependentTasksDirty {\n             #[cfg(feature = \"trace_task_dirty\")]"
        },
        {
            "sha": "df3115b8aa3dae81802deb0224c94d467431f93c",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/bug2.rs",
            "status": "added",
            "additions": 156,
            "deletions": 0,
            "changes": 156,
            "blob_url": "https://github.com/vercel/next.js/blob/2dbc947cdeebce7fbfc91240d71473395e961616/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fbug2.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2dbc947cdeebce7fbfc91240d71473395e961616/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fbug2.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fbug2.rs?ref=2dbc947cdeebce7fbfc91240d71473395e961616",
            "patch": "@@ -0,0 +1,156 @@\n+#![feature(arbitrary_self_types)]\n+#![feature(arbitrary_self_types_pointers)]\n+#![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n+\n+use std::sync::Arc;\n+\n+use anyhow::Result;\n+use serde::{Deserialize, Serialize};\n+use turbo_tasks::{NonLocalValue, State, TaskInput, Vc, trace::TraceRawVcs};\n+use turbo_tasks_testing::{Registration, register, run};\n+\n+static REGISTRATION: Registration = register!();\n+\n+#[derive(\n+    Clone, Debug, PartialEq, Eq, Hash, NonLocalValue, Serialize, Deserialize, TraceRawVcs, TaskInput,\n+)]\n+pub struct TaskReferenceSpec {\n+    task: u16,\n+    chain: u8,\n+    read: bool,\n+    read_strongly_consistent: bool,\n+}\n+\n+#[derive(\n+    Clone, Debug, PartialEq, Eq, Hash, NonLocalValue, Serialize, Deserialize, TraceRawVcs, TaskInput,\n+)]\n+pub struct TaskSpec {\n+    references: Vec<TaskReferenceSpec>,\n+    children: u8,\n+    change: Option<Box<TaskSpec>>,\n+}\n+\n+#[turbo_tasks::value(transparent)]\n+struct Iteration(State<usize>);\n+\n+#[tokio::test]\n+async fn graph_bug() {\n+    run(&REGISTRATION, move || async move {\n+        let spec = vec![\n+            TaskSpec {\n+                references: vec![TaskReferenceSpec {\n+                    task: 1,\n+                    chain: 0,\n+                    read: false,\n+                    read_strongly_consistent: false,\n+                }],\n+                children: 0,\n+                change: Some(Box::new(TaskSpec {\n+                    references: vec![TaskReferenceSpec {\n+                        task: 1,\n+                        chain: 254,\n+                        read: false,\n+                        read_strongly_consistent: false,\n+                    }],\n+                    children: 0,\n+                    change: None,\n+                })),\n+            },\n+            TaskSpec {\n+                references: vec![],\n+                children: 0,\n+                change: None,\n+            },\n+        ];\n+\n+        let it = create_iteration().resolve().await?;\n+        it.await?.set(0);\n+        println!(\"ðŸš€ Initial\");\n+        let task = run_task(Arc::new(spec), it, 0);\n+        task.strongly_consistent().await?;\n+        println!(\"ðŸš€ Set iteration to 1\");\n+        it.await?.set(1);\n+        task.strongly_consistent().await?;\n+        println!(\"ðŸš€ Finished strongly consistent wait\");\n+\n+        anyhow::Ok(())\n+    })\n+    .await\n+    .unwrap()\n+}\n+\n+#[turbo_tasks::function]\n+fn create_iteration() -> Vc<Iteration> {\n+    Vc::cell(State::new(0))\n+}\n+\n+#[turbo_tasks::function]\n+async fn run_task_chain(\n+    spec: Arc<Vec<TaskSpec>>,\n+    iteration: Vc<Iteration>,\n+    from: u16,\n+    ref_index: usize,\n+    to: u16,\n+    chain: u8,\n+) -> Result<Vc<()>> {\n+    println!(\"run_task_chain(from: {from}, ref_index: {ref_index}, to: {to}, chain: {chain})\");\n+    if chain > 0 {\n+        run_task_chain(spec, iteration, from, ref_index, to, chain - 1).await?;\n+    } else {\n+        run_task(spec, iteration, to).await?;\n+    }\n+    Ok(Vc::cell(()))\n+}\n+\n+#[turbo_tasks::function]\n+async fn run_task(\n+    spec: Arc<Vec<TaskSpec>>,\n+    iteration: Vc<Iteration>,\n+    task_index: u16,\n+) -> Result<Vc<()>> {\n+    println!(\"run_task(task_index: {task_index})\");\n+    let mut task = &spec[task_index as usize];\n+    if task.change.is_some() {\n+        let iteration = iteration.await?;\n+        let it = *iteration.get();\n+        for _ in 0..it {\n+            task = if let Some(change) = &task.change {\n+                change\n+            } else {\n+                task\n+            };\n+        }\n+    }\n+    for i in 0..task.children {\n+        run_task_child(task_index, i).await?;\n+    }\n+    for (i, reference) in task.references.iter().enumerate() {\n+        let call = if reference.chain > 0 {\n+            run_task_chain(\n+                spec.clone(),\n+                iteration,\n+                task_index,\n+                i,\n+                reference.task,\n+                reference.chain,\n+            )\n+        } else {\n+            run_task(spec.clone(), iteration, reference.task)\n+        };\n+        if reference.read {\n+            call.await?;\n+        }\n+        if reference.read_strongly_consistent {\n+            call.strongly_consistent().await?;\n+        }\n+    }\n+    Ok(Vc::cell(()))\n+}\n+\n+#[turbo_tasks::function]\n+async fn run_task_child(from: u16, i: u8) -> Result<Vc<()>> {\n+    println!(\"run_task_child(from: {from}, i: {i})\");\n+    let _ = from;\n+    let _ = i;\n+    Ok(Vc::cell(()))\n+}"
        }
    ],
    "stats": {
        "total": 302,
        "additions": 229,
        "deletions": 73
    }
}