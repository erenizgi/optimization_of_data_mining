{
    "author": "mischnic",
    "message": "Turbopack: codegen EsmAssetReference without turbo tasks (#76024)\n\nRun `EsmAssetReference::code_generation` without cells/turbo tasks.\r\n\r\n```\r\ntesting against 0293c96cf32\r\n\r\n\r\ncanary 71d8bfcc1f\r\n14.8gb\r\n529.67s user 81.57s system 883% cpu 1:09.18 total\r\n\r\nmischnic/codegen-fewer-tasks 72eba1ead2\r\n14.8gb\r\n533.13s user 82.01s system 874% cpu 1:10.32 total\r\n\r\nmischnic/codegen-fewer-tasks don't store twice\r\n14.6gb\r\n529.85s user 82.35s system 875% cpu 1:09.90 total\r\n\r\nmischnic/codegen-esm-asset\r\n14.2gb\r\n528.69s user 81.37s system 881% cpu 1:09.17 total\r\n```",
    "sha": "15b664341e1774fc8224dcba90aea2ef36ab0cae",
    "files": [
        {
            "sha": "02792c2f620a11f08099fed11ab2f6cc2f4894ad",
            "filename": "turbopack/crates/turbopack-ecmascript/src/code_gen.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 21,
            "changes": 21,
            "blob_url": "https://github.com/vercel/next.js/blob/15b664341e1774fc8224dcba90aea2ef36ab0cae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fcode_gen.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/15b664341e1774fc8224dcba90aea2ef36ab0cae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fcode_gen.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fcode_gen.rs?ref=15b664341e1774fc8224dcba90aea2ef36ab0cae",
            "patch": "@@ -31,19 +31,9 @@ use crate::references::{\n     AstPath,\n };\n \n-/// impl of code generation inferred from a ModuleReference.\n-/// This is rust only and can't be implemented by non-rust plugins.\n-#[turbo_tasks::value(\n-    shared,\n-    serialization = \"none\",\n-    eq = \"manual\",\n-    into = \"new\",\n-    cell = \"new\"\n-)]\n #[derive(Default)]\n pub struct CodeGeneration {\n     /// ast nodes matching the span will be visitor by the visitor\n-    #[turbo_tasks(debug_ignore, trace_ignore)]\n     pub visitors: Vec<(Vec<AstParentKind>, Box<dyn VisitorFactory>)>,\n     pub hoisted_stmts: Vec<CodeGenerationHoistedStmt>,\n     pub early_hoisted_stmts: Vec<CodeGenerationHoistedStmt>,\n@@ -90,11 +80,9 @@ impl CodeGeneration {\n     }\n }\n \n-#[turbo_tasks::value(shared)]\n #[derive(Clone)]\n pub struct CodeGenerationHoistedStmt {\n     pub key: RcStr,\n-    #[turbo_tasks(trace_ignore)]\n     pub stmt: Stmt,\n }\n \n@@ -108,15 +96,6 @@ pub trait VisitorFactory: Send + Sync {\n     fn create<'a>(&'a self) -> Box<dyn VisitMut + Send + Sync + 'a>;\n }\n \n-#[turbo_tasks::value_trait]\n-pub trait CodeGenerateable {\n-    fn code_generation(\n-        self: Vc<Self>,\n-        module_graph: Vc<ModuleGraph>,\n-        chunking_context: Vc<Box<dyn ChunkingContext>>,\n-    ) -> Vc<CodeGeneration>;\n-}\n-\n #[derive(PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue)]\n pub enum CodeGen {\n     // AMD occurs very rarely and makes the enum much bigger"
        },
        {
            "sha": "2a03e9f22785c9f335a8dc2b1b3c3c5c6e9e9f26",
            "filename": "turbopack/crates/turbopack-ecmascript/src/lib.rs",
            "status": "modified",
            "additions": 65,
            "deletions": 44,
            "changes": 109,
            "blob_url": "https://github.com/vercel/next.js/blob/15b664341e1774fc8224dcba90aea2ef36ab0cae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/15b664341e1774fc8224dcba90aea2ef36ab0cae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs?ref=15b664341e1774fc8224dcba90aea2ef36ab0cae",
            "patch": "@@ -42,7 +42,7 @@ use std::{\n \n use anyhow::Result;\n use chunk::EcmascriptChunkItem;\n-use code_gen::{CodeGenerateable, CodeGeneration, CodeGenerationHoistedStmt};\n+use code_gen::{CodeGeneration, CodeGenerationHoistedStmt};\n use either::Either;\n use parse::{parse, ParseResult};\n use path_visitor::ApplyVisitors;\n@@ -95,7 +95,9 @@ use crate::{\n     chunk::EcmascriptChunkPlaceable,\n     code_gen::CodeGens,\n     parse::generate_js_source_map,\n-    references::{analyse_ecmascript_module, async_module::OptionAsyncModule},\n+    references::{\n+        analyse_ecmascript_module, async_module::OptionAsyncModule, esm::base::EsmAssetReferences,\n+    },\n     transform::remove_shebang,\n };\n \n@@ -417,24 +419,28 @@ impl EcmascriptAnalyzable for EcmascriptModuleAsset {\n     ) -> Result<Vc<EcmascriptModuleContent>> {\n         let parsed = self.parse().to_resolved().await?;\n \n-        let analyze = self.analyze().await?;\n+        let analyze = self.analyze();\n+        let analyze_ref = analyze.await?;\n \n         let module_type_result = *self.determine_module_type().await?;\n         let generate_source_map = chunking_context.reference_module_source_maps(Vc::upcast(self));\n \n         Ok(EcmascriptModuleContent::new(\n-            *parsed,\n-            self.ident(),\n-            module_type_result.module_type,\n-            module_graph,\n-            chunking_context,\n-            *analyze.references,\n-            *analyze.code_generation,\n-            *analyze.async_module,\n-            generate_source_map,\n-            *analyze.source_map,\n-            *analyze.exports,\n-            async_module_info,\n+            EcmascriptModuleContentOptions {\n+                parsed,\n+                ident: self.ident(),\n+                specified_module_type: module_type_result.module_type,\n+                module_graph,\n+                chunking_context,\n+                references: analyze.references(),\n+                esm_references: *analyze_ref.esm_references,\n+                code_generation: *analyze_ref.code_generation,\n+                async_module: *analyze_ref.async_module,\n+                generate_source_map,\n+                original_source_map: analyze_ref.source_map,\n+                exports: *analyze_ref.exports,\n+                async_module_info,\n+            },\n         ))\n     }\n }\n@@ -590,15 +596,13 @@ impl Module for EcmascriptModuleAsset {\n \n     #[turbo_tasks::function]\n     async fn references(self: Vc<Self>) -> Result<Vc<ModuleReferences>> {\n-        let analyze = self.analyze().await?;\n-        let references = analyze.references.await?.iter().copied().collect();\n-        Ok(Vc::cell(references))\n+        Ok(self.analyze().references())\n     }\n \n     #[turbo_tasks::function]\n     async fn is_self_async(self: Vc<Self>) -> Result<Vc<bool>> {\n         if let Some(async_module) = *self.get_async_module().await? {\n-            Ok(async_module.is_self_async(*self.analyze().await?.references))\n+            Ok(async_module.is_self_async(self.references()))\n         } else {\n             Ok(Vc::cell(false))\n         }\n@@ -756,30 +760,43 @@ pub struct EcmascriptModuleContent {\n     // pub refresh: bool,\n }\n \n+#[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize, TaskInput)]\n+pub struct EcmascriptModuleContentOptions {\n+    parsed: ResolvedVc<ParseResult>,\n+    ident: Vc<AssetIdent>,\n+    specified_module_type: SpecifiedModuleType,\n+    module_graph: Vc<ModuleGraph>,\n+    chunking_context: Vc<Box<dyn ChunkingContext>>,\n+    references: Vc<ModuleReferences>,\n+    esm_references: Vc<EsmAssetReferences>,\n+    code_generation: Vc<CodeGens>,\n+    async_module: Vc<OptionAsyncModule>,\n+    generate_source_map: Vc<bool>,\n+    original_source_map: ResolvedVc<OptionStringifiedSourceMap>,\n+    exports: Vc<EcmascriptExports>,\n+    async_module_info: Option<Vc<AsyncModuleInfo>>,\n+}\n+\n #[turbo_tasks::value_impl]\n impl EcmascriptModuleContent {\n     /// Creates a new [`Vc<EcmascriptModuleContent>`].\n     #[turbo_tasks::function]\n-    pub async fn new(\n-        parsed: ResolvedVc<ParseResult>,\n-        ident: ResolvedVc<AssetIdent>,\n-        specified_module_type: SpecifiedModuleType,\n-        module_graph: Vc<ModuleGraph>,\n-        chunking_context: Vc<Box<dyn ChunkingContext>>,\n-        references: Vc<ModuleReferences>,\n-        code_generation: Vc<CodeGens>,\n-        async_module: Vc<OptionAsyncModule>,\n-        generate_source_map: Vc<bool>,\n-        original_source_map: ResolvedVc<OptionStringifiedSourceMap>,\n-        exports: Vc<EcmascriptExports>,\n-        async_module_info: Option<Vc<AsyncModuleInfo>>,\n-    ) -> Result<Vc<Self>> {\n-        let mut code_gen_cells = Vec::new();\n-        for r in references.await?.iter() {\n-            if let Some(code_gen) = ResolvedVc::try_sidecast::<Box<dyn CodeGenerateable>>(*r) {\n-                code_gen_cells.push(code_gen.code_generation(module_graph, chunking_context));\n-            }\n-        }\n+    pub async fn new(input: EcmascriptModuleContentOptions) -> Result<Vc<Self>> {\n+        let EcmascriptModuleContentOptions {\n+            parsed,\n+            ident,\n+            specified_module_type,\n+            module_graph,\n+            chunking_context,\n+            references,\n+            esm_references,\n+            code_generation,\n+            async_module,\n+            generate_source_map,\n+            original_source_map,\n+            exports,\n+            async_module_info,\n+        } = input;\n \n         let additional_code_gens = [\n             if let Some(async_module) = &*async_module.await? {\n@@ -807,17 +824,21 @@ impl EcmascriptModuleContent {\n             },\n         ];\n \n+        let esm_code_gens = esm_references\n+            .await?\n+            .iter()\n+            .map(|r| r.code_generation(module_graph, chunking_context))\n+            .try_join()\n+            .await?;\n         let code_gens = code_generation\n             .await?\n             .iter()\n             .map(|c| c.code_generation(module_graph, chunking_context))\n             .try_join()\n             .await?;\n-        let code_gen_cells = code_gen_cells.into_iter().try_join().await?;\n \n-        let code_gens = code_gen_cells\n+        let code_gens = esm_code_gens\n             .iter()\n-            .map(|c| &**c)\n             .chain(additional_code_gens.iter().flatten())\n             .chain(code_gens.iter());\n         gen_content_with_code_gens(\n@@ -841,7 +862,7 @@ impl EcmascriptModuleContent {\n     ) -> Result<Vc<Self>> {\n         gen_content_with_code_gens(\n             parsed.to_resolved().await?,\n-            ident.to_resolved().await?,\n+            ident,\n             specified_module_type,\n             &[],\n             generate_source_map,\n@@ -853,7 +874,7 @@ impl EcmascriptModuleContent {\n \n async fn gen_content_with_code_gens(\n     parsed: ResolvedVc<ParseResult>,\n-    ident: ResolvedVc<AssetIdent>,\n+    ident: Vc<AssetIdent>,\n     specified_module_type: SpecifiedModuleType,\n     code_gens: impl IntoIterator<Item = &CodeGeneration>,\n     generate_source_map: Vc<bool>,"
        },
        {
            "sha": "55aa42d482763560d1a115bbcc09a318e2808706",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/esm/base.rs",
            "status": "modified",
            "additions": 9,
            "deletions": 8,
            "changes": 17,
            "blob_url": "https://github.com/vercel/next.js/blob/15b664341e1774fc8224dcba90aea2ef36ab0cae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fbase.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/15b664341e1774fc8224dcba90aea2ef36ab0cae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fbase.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fbase.rs?ref=15b664341e1774fc8224dcba90aea2ef36ab0cae",
            "patch": "@@ -33,7 +33,7 @@ use super::export::{all_known_export_names, is_export_missing};\n use crate::{\n     analyzer::imports::ImportAnnotations,\n     chunk::EcmascriptChunkPlaceable,\n-    code_gen::{CodeGenerateable, CodeGeneration},\n+    code_gen::CodeGeneration,\n     magic_identifier,\n     references::util::{request_to_string, throw_module_not_found_expr},\n     runtime_functions::{TURBOPACK_EXTERNAL_IMPORT, TURBOPACK_EXTERNAL_REQUIRE, TURBOPACK_IMPORT},\n@@ -110,6 +110,9 @@ impl ReferencedAsset {\n     }\n }\n \n+#[turbo_tasks::value(transparent)]\n+pub struct EsmAssetReferences(Vec<ResolvedVc<EsmAssetReference>>);\n+\n #[turbo_tasks::value(shared)]\n #[derive(Hash, Debug)]\n pub struct EsmAssetReference {\n@@ -252,14 +255,12 @@ impl ChunkableModuleReference for EsmAssetReference {\n     }\n }\n \n-#[turbo_tasks::value_impl]\n-impl CodeGenerateable for EsmAssetReference {\n-    #[turbo_tasks::function]\n-    async fn code_generation(\n+impl EsmAssetReference {\n+    pub async fn code_generation(\n         self: Vc<Self>,\n         module_graph: Vc<ModuleGraph>,\n         chunking_context: Vc<Box<dyn ChunkingContext>>,\n-    ) -> Result<Vc<CodeGeneration>> {\n+    ) -> Result<CodeGeneration> {\n         let this = &*self.await?;\n \n         // only chunked references can be imported\n@@ -392,9 +393,9 @@ impl CodeGenerateable for EsmAssetReference {\n         };\n \n         if let Some((key, stmt)) = result {\n-            Ok(CodeGeneration::hoisted_stmt(key, stmt).cell())\n+            Ok(CodeGeneration::hoisted_stmt(key, stmt))\n         } else {\n-            Ok(CodeGeneration::empty().cell())\n+            Ok(CodeGeneration::empty())\n         }\n     }\n }"
        },
        {
            "sha": "7b472ffac90a7f2698c7d1c917b2b0cba75fa65e",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/mod.rs",
            "status": "modified",
            "additions": 189,
            "deletions": 94,
            "changes": 283,
            "blob_url": "https://github.com/vercel/next.js/blob/15b664341e1774fc8224dcba90aea2ef36ab0cae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/15b664341e1774fc8224dcba90aea2ef36ab0cae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fmod.rs?ref=15b664341e1774fc8224dcba90aea2ef36ab0cae",
            "patch": "@@ -23,12 +23,13 @@ use std::{borrow::Cow, collections::BTreeMap, future::Future, mem::take, ops::De\n use anyhow::{bail, Result};\n use constant_condition::{ConstantConditionCodeGen, ConstantConditionValue};\n use constant_value::ConstantValueCodeGen;\n+use indexmap::map::Entry;\n use lazy_static::lazy_static;\n use num_traits::Zero;\n use once_cell::sync::Lazy;\n use parking_lot::Mutex;\n use regex::Regex;\n-use rustc_hash::FxHashMap;\n+use rustc_hash::{FxHashMap, FxHashSet};\n use serde::{Deserialize, Serialize};\n use swc_core::{\n     atoms::JsWord,\n@@ -136,7 +137,10 @@ use crate::{\n         async_module::{AsyncModule, OptionAsyncModule},\n         cjs::{CjsRequireAssetReference, CjsRequireCacheAccess, CjsRequireResolveAssetReference},\n         dynamic_expression::DynamicExpression,\n-        esm::{module_id::EsmModuleIdAssetReference, EsmBinding, UrlRewriteBehavior},\n+        esm::{\n+            base::EsmAssetReferences, module_id::EsmModuleIdAssetReference, EsmBinding,\n+            UrlRewriteBehavior,\n+        },\n         ident::IdentReplacement,\n         member::MemberReplacement,\n         node::PackageJsonReference,\n@@ -154,12 +158,14 @@ use crate::{\n };\n \n #[turbo_tasks::value(shared)]\n-#[derive(Clone)]\n pub struct AnalyzeEcmascriptModuleResult {\n-    pub references: ResolvedVc<ModuleReferences>,\n-    pub local_references: ResolvedVc<ModuleReferences>,\n-    pub reexport_references: ResolvedVc<ModuleReferences>,\n-    pub evaluation_references: ResolvedVc<ModuleReferences>,\n+    references: Vec<ResolvedVc<Box<dyn ModuleReference>>>,\n+\n+    pub esm_references: ResolvedVc<EsmAssetReferences>,\n+    pub esm_local_references: ResolvedVc<EsmAssetReferences>,\n+    pub esm_reexport_references: ResolvedVc<EsmAssetReferences>,\n+    pub esm_evaluation_references: ResolvedVc<EsmAssetReferences>,\n+\n     pub code_generation: ResolvedVc<CodeGens>,\n     pub exports: ResolvedVc<EcmascriptExports>,\n     pub async_module: ResolvedVc<OptionAsyncModule>,\n@@ -168,16 +174,47 @@ pub struct AnalyzeEcmascriptModuleResult {\n     pub source_map: ResolvedVc<OptionStringifiedSourceMap>,\n }\n \n+#[turbo_tasks::value_impl]\n+impl AnalyzeEcmascriptModuleResult {\n+    #[turbo_tasks::function]\n+    pub async fn references(&self) -> Result<Vc<ModuleReferences>> {\n+        Ok(Vc::cell(\n+            self.esm_references\n+                .await?\n+                .iter()\n+                .map(|r| ResolvedVc::upcast(*r))\n+                .chain(self.references.iter().copied())\n+                .collect(),\n+        ))\n+    }\n+\n+    #[turbo_tasks::function]\n+    pub async fn local_references(&self) -> Result<Vc<ModuleReferences>> {\n+        Ok(Vc::cell(\n+            self.esm_local_references\n+                .await?\n+                .iter()\n+                .map(|r| ResolvedVc::upcast(*r))\n+                .chain(self.references.iter().copied())\n+                .collect(),\n+        ))\n+    }\n+}\n+\n /// A temporary analysis result builder to pass around, to be turned into an\n /// `Vc<AnalyzeEcmascriptModuleResult>` eventually.\n pub struct AnalyzeEcmascriptModuleResultBuilder {\n     references: FxIndexSet<ResolvedVc<Box<dyn ModuleReference>>>,\n-    local_references: FxIndexSet<ResolvedVc<Box<dyn ModuleReference>>>,\n \n-    esm_references: Vec<usize>,\n-    esm_local_references: Vec<usize>,\n-    esm_reexport_references: Vec<usize>,\n-    esm_evaluation_references: Vec<usize>,\n+    esm_references: FxHashSet<usize>,\n+    esm_local_references: FxHashSet<usize>,\n+    esm_reexport_references: FxHashSet<usize>,\n+    esm_evaluation_references: FxHashSet<usize>,\n+\n+    esm_references_free_var: FxIndexMap<RcStr, ResolvedVc<EsmAssetReference>>,\n+    // Ad-hoc created import references that are resolved `import * as x from ...; x.foo` accesses\n+    // This caches repeated access because EsmAssetReference::new is not a turbo task function.\n+    esm_references_rewritten: FxHashMap<usize, FxIndexMap<RcStr, ResolvedVc<EsmAssetReference>>>,\n \n     code_gens: Vec<CodeGen>,\n     exports: EcmascriptExports,\n@@ -190,11 +227,12 @@ impl AnalyzeEcmascriptModuleResultBuilder {\n     pub fn new() -> Self {\n         Self {\n             references: Default::default(),\n-            local_references: Default::default(),\n             esm_references: Default::default(),\n             esm_local_references: Default::default(),\n             esm_reexport_references: Default::default(),\n             esm_evaluation_references: Default::default(),\n+            esm_references_rewritten: Default::default(),\n+            esm_references_free_var: Default::default(),\n             code_gens: Default::default(),\n             exports: EcmascriptExports::None,\n             async_module: ResolvedVc::cell(None),\n@@ -207,7 +245,6 @@ impl AnalyzeEcmascriptModuleResultBuilder {\n     pub fn add_reference(&mut self, reference: ResolvedVc<impl Upcast<Box<dyn ModuleReference>>>) {\n         let r = ResolvedVc::upcast(reference);\n         self.references.insert(r);\n-        self.local_references.insert(r);\n     }\n \n     /// Adds an asset reference with codegen to the analysis result.\n@@ -219,22 +256,22 @@ impl AnalyzeEcmascriptModuleResultBuilder {\n \n     /// Adds an ESM asset reference to the analysis result.\n     pub fn add_esm_reference(&mut self, idx: usize) {\n-        self.esm_references.push(idx);\n-        self.esm_local_references.push(idx);\n+        self.esm_references.insert(idx);\n+        self.esm_local_references.insert(idx);\n     }\n \n     /// Adds an reexport ESM reference to the analysis result.\n     /// If you're unsure about which function to use, use `add_reference()`\n     pub fn add_esm_reexport_reference(&mut self, idx: usize) {\n-        self.esm_references.push(idx);\n-        self.esm_reexport_references.push(idx);\n+        self.esm_references.insert(idx);\n+        self.esm_reexport_references.insert(idx);\n     }\n \n     /// Adds an evaluation ESM reference to the analysis result.\n     /// If you're unsure about which function to use, use `add_reference()`\n     pub fn add_esm_evaluation_reference(&mut self, idx: usize) {\n-        self.esm_references.push(idx);\n-        self.esm_evaluation_references.push(idx);\n+        self.esm_references.insert(idx);\n+        self.esm_evaluation_references.insert(idx);\n     }\n \n     /// Adds a codegen to the analysis result.\n@@ -265,47 +302,93 @@ impl AnalyzeEcmascriptModuleResultBuilder {\n         self.successful = successful;\n     }\n \n+    pub fn add_esm_reference_namespace_resolved(\n+        &mut self,\n+        esm_reference_idx: usize,\n+        export: RcStr,\n+        on_insert: impl FnOnce() -> ResolvedVc<EsmAssetReference>,\n+    ) -> ResolvedVc<EsmAssetReference> {\n+        *self\n+            .esm_references_rewritten\n+            .entry(esm_reference_idx)\n+            .or_default()\n+            .entry(export)\n+            .or_insert_with(on_insert)\n+    }\n+\n+    pub async fn add_esm_reference_free_var(\n+        &mut self,\n+        request: RcStr,\n+        on_insert: impl AsyncFnOnce() -> Result<ResolvedVc<EsmAssetReference>>,\n+    ) -> Result<ResolvedVc<EsmAssetReference>> {\n+        Ok(match self.esm_references_free_var.entry(request) {\n+            Entry::Occupied(e) => *e.get(),\n+            Entry::Vacant(e) => *e.insert(on_insert().await?),\n+        })\n+    }\n+\n     /// Builds the final analysis result. Resolves internal Vcs.\n     pub async fn build(\n         mut self,\n         import_references: Vec<ResolvedVc<EsmAssetReference>>,\n         track_reexport_references: bool,\n     ) -> Result<Vc<AnalyzeEcmascriptModuleResult>> {\n-        self.esm_references.sort();\n-        let esm_references = self\n-            .esm_references\n-            .into_iter()\n-            .map(|i| ResolvedVc::upcast(import_references[i]));\n-        let (esm_local_references, esm_reexport_references, esm_evaluation_references) =\n-            if track_reexport_references {\n-                self.esm_local_references.sort();\n-                self.esm_reexport_references.sort();\n-                self.esm_evaluation_references.sort();\n-                (\n-                    Some(\n-                        self.esm_local_references\n-                            .into_iter()\n-                            .map(|i| ResolvedVc::upcast(import_references[i])),\n-                    ),\n-                    self.esm_reexport_references\n-                        .into_iter()\n-                        .map(|i| ResolvedVc::upcast(import_references[i]))\n-                        .collect(),\n-                    self.esm_evaluation_references\n-                        .into_iter()\n-                        .map(|i| ResolvedVc::upcast(import_references[i]))\n-                        .collect(),\n-                )\n-            } else {\n-                (None, vec![], vec![])\n-            };\n+        // esm_references_rewritten (and esm_references_free_var) needs to be spliced in at the\n+        // correct index into esm_references and esm_local_references\n+        let mut esm_references = Vec::with_capacity(\n+            self.esm_references.len()\n+                + self.esm_references_free_var.len()\n+                + self.esm_references_rewritten.len(),\n+        );\n+        esm_references.extend(self.esm_references_free_var.values());\n \n-        let references: Vec<_> = esm_references.chain(self.references.into_iter()).collect();\n-        let local_references: Vec<_> = esm_local_references\n-            .into_iter()\n-            .flatten()\n-            .chain(self.local_references.into_iter())\n-            .collect();\n+        let mut esm_local_references = track_reexport_references.then(|| {\n+            let mut esm_local_references = Vec::with_capacity(\n+                self.esm_local_references.len()\n+                    + self.esm_references_free_var.len()\n+                    + self.esm_references_rewritten.len(),\n+            );\n+            esm_local_references.extend(self.esm_references_free_var.values());\n+            esm_local_references\n+        });\n+        let mut esm_reexport_references = track_reexport_references\n+            .then(|| Vec::with_capacity(self.esm_reexport_references.len()));\n+        let mut esm_evaluation_references = track_reexport_references\n+            .then(|| Vec::with_capacity(self.esm_evaluation_references.len()));\n+        for (i, reference) in import_references.iter().enumerate() {\n+            if self.esm_references.contains(&i) {\n+                esm_references.push(*reference);\n+            }\n+            esm_references.extend(\n+                self.esm_references_rewritten\n+                    .get(&i)\n+                    .iter()\n+                    .flat_map(|m| m.values().copied()),\n+            );\n+            if let Some(esm_local_references) = &mut esm_local_references {\n+                if self.esm_local_references.contains(&i) {\n+                    esm_local_references.push(*reference);\n+                }\n+                esm_local_references.extend(\n+                    self.esm_references_rewritten\n+                        .get(&i)\n+                        .iter()\n+                        .flat_map(|m| m.values().copied()),\n+                );\n+            }\n+            if let Some(esm_evaluation_references) = &mut esm_evaluation_references {\n+                if self.esm_evaluation_references.contains(&i) {\n+                    esm_evaluation_references.push(*reference);\n+                }\n+            }\n+            if let Some(esm_reexport_references) = &mut esm_reexport_references {\n+                if self.esm_reexport_references.contains(&i) {\n+                    esm_reexport_references.push(*reference);\n+                }\n+            }\n+        }\n+\n+        let references: Vec<_> = self.references.into_iter().collect();\n \n         let source_map = if let Some(source_map) = self.source_map {\n             source_map\n@@ -316,10 +399,15 @@ impl AnalyzeEcmascriptModuleResultBuilder {\n         self.code_gens.shrink_to_fit();\n         Ok(AnalyzeEcmascriptModuleResult::cell(\n             AnalyzeEcmascriptModuleResult {\n-                references: ResolvedVc::cell(references),\n-                local_references: ResolvedVc::cell(local_references),\n-                reexport_references: ResolvedVc::cell(esm_reexport_references),\n-                evaluation_references: ResolvedVc::cell(esm_evaluation_references),\n+                references,\n+                esm_references: ResolvedVc::cell(esm_references),\n+                esm_local_references: ResolvedVc::cell(esm_local_references.unwrap_or_default()),\n+                esm_reexport_references: ResolvedVc::cell(\n+                    esm_reexport_references.unwrap_or_default(),\n+                ),\n+                esm_evaluation_references: ResolvedVc::cell(\n+                    esm_evaluation_references.unwrap_or_default(),\n+                ),\n                 code_generation: ResolvedVc::cell(self.code_gens),\n                 exports: self.exports.resolved_cell(),\n                 async_module: self.async_module,\n@@ -495,7 +583,7 @@ pub(crate) async fn analyse_ecmascript_module_internal(\n         ..\n     } = &*parsed\n     else {\n-        return analysis.build(vec![], false).await;\n+        return analysis.build(Default::default(), false).await;\n     };\n \n     let compile_time_info = compile_time_info_for_module_type(\n@@ -611,10 +699,6 @@ pub(crate) async fn analyse_ecmascript_module_internal(\n         set_handler_and_globals(&handler, globals, || create_graph(program, eval_context))\n     };\n \n-    // Ad-hoc created import references that are resolved `import * as x from ...; x.foo` accesses\n-    // This caches repeated access because EsmAssetReference::new is not a turbo task function.\n-    let mut import_references_namespace_rewritten = FxIndexMap::default();\n-\n     let span = tracing::info_span!(\"esm import references\");\n     let import_references = async {\n         let mut import_references = Vec::with_capacity(eval_context.imports.references().len());\n@@ -1235,13 +1319,13 @@ pub(crate) async fn analyse_ecmascript_module_internal(\n                     span: _,\n                     in_try: _,\n                 } => {\n-                    let Some(r) = import_references.get(esm_reference_index).copied() else {\n+                    let Some(r) = import_references.get(esm_reference_index) else {\n                         continue;\n                     };\n \n                     if let Some(\"__turbopack_module_id__\") = export.as_deref() {\n                         analysis.add_reference_code_gen(\n-                            EsmModuleIdAssetReference::new(r),\n+                            EsmModuleIdAssetReference::new(*r),\n                             ast_path.into(),\n                         )\n                     } else {\n@@ -1252,9 +1336,10 @@ pub(crate) async fn analyse_ecmascript_module_internal(\n                             let r_ref = r.await?;\n                             if r_ref.export_name.is_none() && export.is_some() {\n                                 if let Some(export) = export {\n-                                    let r = *import_references_namespace_rewritten\n-                                        .entry((esm_reference_index, export.clone()))\n-                                        .or_insert_with(|| {\n+                                    let r = analysis.add_esm_reference_namespace_resolved(\n+                                        esm_reference_index,\n+                                        export.clone(),\n+                                        || {\n                                             EsmAssetReference::new(\n                                                 r_ref.origin,\n                                                 r_ref.request,\n@@ -1264,8 +1349,8 @@ pub(crate) async fn analyse_ecmascript_module_internal(\n                                                 r_ref.import_externals,\n                                             )\n                                             .resolved_cell()\n-                                        });\n-                                    analysis.add_reference(r);\n+                                        },\n+                                    );\n                                     analysis.add_code_gen(EsmBinding::new(\n                                         r,\n                                         Some(export),\n@@ -1277,7 +1362,7 @@ pub(crate) async fn analyse_ecmascript_module_internal(\n                         }\n \n                         analysis.add_esm_reference(esm_reference_index);\n-                        analysis.add_code_gen(EsmBinding::new(r, export, ast_path.into()));\n+                        analysis.add_code_gen(EsmBinding::new(*r, export, ast_path.into()));\n                     }\n                 }\n                 Effect::TypeOf {\n@@ -2419,33 +2504,43 @@ async fn handle_free_var_reference(\n             lookup_path,\n             export,\n         } => {\n-            let esm_reference = EsmAssetReference::new(\n-                if let Some(lookup_path) = lookup_path {\n-                    ResolvedVc::upcast(\n-                        PlainResolveOrigin::new(state.origin.asset_context(), **lookup_path)\n+            let esm_reference = analysis\n+                .add_esm_reference_free_var(request.clone(), async || {\n+                    Ok(EsmAssetReference::new(\n+                        if let Some(lookup_path) = lookup_path {\n+                            ResolvedVc::upcast(\n+                                PlainResolveOrigin::new(\n+                                    state.origin.asset_context(),\n+                                    **lookup_path,\n+                                )\n+                                .to_resolved()\n+                                .await?,\n+                            )\n+                        } else {\n+                            state.origin\n+                        },\n+                        Request::parse(Value::new(request.clone().into()))\n                             .to_resolved()\n                             .await?,\n+                        IssueSource::from_swc_offsets(\n+                            state.source,\n+                            span.lo.to_u32(),\n+                            span.hi.to_u32(),\n+                        ),\n+                        Default::default(),\n+                        match state.tree_shaking_mode {\n+                            Some(TreeShakingMode::ModuleFragments)\n+                            | Some(TreeShakingMode::ReexportsOnly) => {\n+                                export.clone().map(ModulePart::export)\n+                            }\n+                            None => None,\n+                        },\n+                        state.import_externals,\n                     )\n-                } else {\n-                    state.origin\n-                },\n-                Request::parse(Value::new(request.clone().into()))\n-                    .to_resolved()\n-                    .await?,\n-                IssueSource::from_swc_offsets(state.source, span.lo.to_u32(), span.hi.to_u32()),\n-                Default::default(),\n-                match state.tree_shaking_mode {\n-                    Some(TreeShakingMode::ModuleFragments)\n-                    | Some(TreeShakingMode::ReexportsOnly) => {\n-                        export.clone().map(ModulePart::export)\n-                    }\n-                    None => None,\n-                },\n-                state.import_externals,\n-            )\n-            .resolved_cell();\n+                    .resolved_cell())\n+                })\n+                .await?;\n \n-            analysis.add_reference(esm_reference);\n             analysis.add_code_gen(EsmBinding::new(\n                 esm_reference,\n                 export.clone(),"
        },
        {
            "sha": "6ef30935fdddde3216b0a2efdf889bf9a0bdbe97",
            "filename": "turbopack/crates/turbopack-ecmascript/src/side_effect_optimization/facade/chunk_item.rs",
            "status": "modified",
            "additions": 7,
            "deletions": 17,
            "changes": 24,
            "blob_url": "https://github.com/vercel/next.js/blob/15b664341e1774fc8224dcba90aea2ef36ab0cae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Ffacade%2Fchunk_item.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/15b664341e1774fc8224dcba90aea2ef36ab0cae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Ffacade%2Fchunk_item.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Ffacade%2Fchunk_item.rs?ref=15b664341e1774fc8224dcba90aea2ef36ab0cae",
            "patch": "@@ -8,7 +8,7 @@ use swc_core::{\n         codegen::{text_writer::JsWriter, Emitter},\n     },\n };\n-use turbo_tasks::{ResolvedVc, TryJoinIterExt, Vc};\n+use turbo_tasks::{ResolvedVc, Vc};\n use turbo_tasks_fs::rope::RopeBuilder;\n use turbopack_core::{\n     chunk::{AsyncModuleInfo, ChunkItem, ChunkType, ChunkingContext},\n@@ -23,7 +23,6 @@ use crate::{\n         EcmascriptChunkItem, EcmascriptChunkItemContent, EcmascriptChunkItemOptions,\n         EcmascriptChunkPlaceable, EcmascriptChunkType, EcmascriptExports,\n     },\n-    code_gen::CodeGenerateable,\n     process_content_with_code_gens,\n };\n \n@@ -67,21 +66,16 @@ impl EcmascriptChunkItem for EcmascriptModuleFacadeChunkItem {\n \n         let mut code = RopeBuilder::default();\n \n-        let references = self.module.references();\n-        let references_ref = references.await?;\n-        let mut code_gens_cells = Vec::with_capacity(references_ref.len() + 2);\n-        for r in &references_ref {\n-            if let Some(code_gen) = ResolvedVc::try_sidecast::<Box<dyn CodeGenerateable>>(*r) {\n-                code_gens_cells\n-                    .push(code_gen.code_generation(*self.module_graph, *chunking_context));\n-            }\n-        }\n+        let esm_code_gens = self\n+            .module\n+            .code_generation(*self.module_graph, *chunking_context)\n+            .await?;\n         let additional_code_gens = [\n             self.module\n                 .async_module()\n                 .code_generation(\n                     async_module_info,\n-                    references,\n+                    self.module.references(),\n                     *self.module_graph,\n                     *chunking_context,\n                 )\n@@ -90,11 +84,7 @@ impl EcmascriptChunkItem for EcmascriptModuleFacadeChunkItem {\n                 .code_generation(*self.module_graph, *chunking_context)\n                 .await?,\n         ];\n-        let code_gen_cells = code_gens_cells.into_iter().try_join().await?;\n-        let code_gens = code_gen_cells\n-            .iter()\n-            .map(|cg| &**cg)\n-            .chain(additional_code_gens.iter());\n+        let code_gens = esm_code_gens.iter().chain(additional_code_gens.iter());\n \n         let mut program = Program::Module(swc_core::ecma::ast::Module::dummy());\n         process_content_with_code_gens(&mut program, &Globals::new(), None, code_gens);"
        },
        {
            "sha": "f47700f118c4ad72980204d0b290c1e10d6adb9b",
            "filename": "turbopack/crates/turbopack-ecmascript/src/side_effect_optimization/facade/module.rs",
            "status": "modified",
            "additions": 108,
            "deletions": 18,
            "changes": 126,
            "blob_url": "https://github.com/vercel/next.js/blob/15b664341e1774fc8224dcba90aea2ef36ab0cae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Ffacade%2Fmodule.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/15b664341e1774fc8224dcba90aea2ef36ab0cae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Ffacade%2Fmodule.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Ffacade%2Fmodule.rs?ref=15b664341e1774fc8224dcba90aea2ef36ab0cae",
            "patch": "@@ -1,7 +1,7 @@\n use std::collections::BTreeMap;\n \n use anyhow::{bail, Result};\n-use turbo_tasks::{ResolvedVc, Vc};\n+use turbo_tasks::{ResolvedVc, TryJoinIterExt, Vc};\n use turbo_tasks_fs::{glob::Glob, File, FileContent};\n use turbopack_core::{\n     asset::{Asset, AssetContent},\n@@ -16,6 +16,7 @@ use turbopack_core::{\n use super::chunk_item::EcmascriptModuleFacadeChunkItem;\n use crate::{\n     chunk::{EcmascriptChunkPlaceable, EcmascriptExports},\n+    code_gen::CodeGeneration,\n     references::{\n         async_module::{AsyncModule, OptionAsyncModule},\n         esm::{EsmExport, EsmExports},\n@@ -59,6 +60,89 @@ impl EcmascriptModuleFacadeModule {\n     }\n }\n \n+impl EcmascriptModuleFacadeModule {\n+    pub async fn code_generation(\n+        self: Vc<Self>,\n+        module_graph: Vc<ModuleGraph>,\n+        chunking_context: Vc<Box<dyn ChunkingContext>>,\n+    ) -> Result<Vec<CodeGeneration>> {\n+        let this = self.await?;\n+        Ok(match &this.ty {\n+            ModulePart::Evaluation => {\n+                let Some(module) =\n+                    ResolvedVc::try_sidecast::<Box<dyn EcmascriptAnalyzable>>(this.module)\n+                else {\n+                    bail!(\n+                        \"Expected EcmascriptModuleAsset for a EcmascriptModuleFacadeModule with \\\n+                         ModulePart::Evaluation\"\n+                    );\n+                };\n+                let result = module.analyze().await?;\n+                let mut code_gens = result\n+                    .esm_evaluation_references\n+                    .await?\n+                    .iter()\n+                    .map(|r| r.code_generation(module_graph, chunking_context))\n+                    .try_join()\n+                    .await?;\n+                code_gens.push(\n+                    EcmascriptModulePartReference::new_part(*this.module, ModulePart::locals())\n+                        .code_generation(module_graph, chunking_context)\n+                        .await?,\n+                );\n+                code_gens\n+            }\n+            ModulePart::Exports => {\n+                let Some(module) =\n+                    ResolvedVc::try_sidecast::<Box<dyn EcmascriptAnalyzable>>(this.module)\n+                else {\n+                    bail!(\n+                        \"Expected EcmascriptModuleAsset for a EcmascriptModuleFacadeModule with \\\n+                         ModulePart::Exports\"\n+                    );\n+                };\n+                let result = module.analyze().await?;\n+                let mut code_gens = result\n+                    .esm_reexport_references\n+                    .await?\n+                    .iter()\n+                    .map(|r| r.code_generation(module_graph, chunking_context))\n+                    .try_join()\n+                    .await?;\n+                code_gens.push(\n+                    EcmascriptModulePartReference::new_part(*this.module, ModulePart::locals())\n+                        .code_generation(module_graph, chunking_context)\n+                        .await?,\n+                );\n+                code_gens\n+            }\n+            ModulePart::Facade => {\n+                vec![\n+                    EcmascriptModulePartReference::new_part(*this.module, ModulePart::evaluation())\n+                        .code_generation(module_graph, chunking_context)\n+                        .await?,\n+                    EcmascriptModulePartReference::new_part(*this.module, ModulePart::exports())\n+                        .code_generation(module_graph, chunking_context)\n+                        .await?,\n+                ]\n+            }\n+            ModulePart::RenamedNamespace { .. } => vec![\n+                EcmascriptModulePartReference::new(*this.module)\n+                    .code_generation(module_graph, chunking_context)\n+                    .await?,\n+            ],\n+            ModulePart::RenamedExport { .. } => vec![\n+                EcmascriptModulePartReference::new(*this.module)\n+                    .code_generation(module_graph, chunking_context)\n+                    .await?,\n+            ],\n+            _ => {\n+                bail!(\"Unexpected ModulePart for EcmascriptModuleFacadeModule\");\n+            }\n+        })\n+    }\n+}\n+\n #[turbo_tasks::value_impl]\n impl Module for EcmascriptModuleFacadeModule {\n     #[turbo_tasks::function]\n@@ -81,33 +165,39 @@ impl Module for EcmascriptModuleFacadeModule {\n                     );\n                 };\n                 let result = module.analyze().await?;\n-                let references = result.evaluation_references;\n-                let mut references = references.owned().await?;\n-                references.push(ResolvedVc::upcast(\n-                    EcmascriptModulePartReference::new_part(*self.module, ModulePart::locals())\n-                        .to_resolved()\n-                        .await?,\n-                ));\n-                references\n+                result\n+                    .esm_evaluation_references\n+                    .await?\n+                    .iter()\n+                    .map(|r| ResolvedVc::upcast(*r))\n+                    .chain(std::iter::once(ResolvedVc::upcast(\n+                        EcmascriptModulePartReference::new_part(*self.module, ModulePart::locals())\n+                            .to_resolved()\n+                            .await?,\n+                    )))\n+                    .collect()\n             }\n             ModulePart::Exports => {\n                 let Some(module) =\n                     ResolvedVc::try_sidecast::<Box<dyn EcmascriptAnalyzable>>(self.module)\n                 else {\n                     bail!(\n                         \"Expected EcmascriptModuleAsset for a EcmascriptModuleFacadeModule with \\\n-                         ModulePart::Evaluation\"\n+                         ModulePart::Exports\"\n                     );\n                 };\n                 let result = module.analyze().await?;\n-                let references = result.reexport_references;\n-                let mut references = references.owned().await?;\n-                references.push(ResolvedVc::upcast(\n-                    EcmascriptModulePartReference::new_part(*self.module, ModulePart::locals())\n-                        .to_resolved()\n-                        .await?,\n-                ));\n-                references\n+                result\n+                    .esm_reexport_references\n+                    .await?\n+                    .iter()\n+                    .map(|r| ResolvedVc::upcast(*r))\n+                    .chain(std::iter::once(ResolvedVc::upcast(\n+                        EcmascriptModulePartReference::new_part(*self.module, ModulePart::locals())\n+                            .to_resolved()\n+                            .await?,\n+                    )))\n+                    .collect()\n             }\n             ModulePart::Facade => {\n                 vec!["
        },
        {
            "sha": "9c4e87091b707ab0fdf4d6bfd6caca0ac51c0999",
            "filename": "turbopack/crates/turbopack-ecmascript/src/side_effect_optimization/locals/chunk_item.rs",
            "status": "modified",
            "additions": 15,
            "deletions": 13,
            "changes": 28,
            "blob_url": "https://github.com/vercel/next.js/blob/15b664341e1774fc8224dcba90aea2ef36ab0cae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Flocals%2Fchunk_item.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/15b664341e1774fc8224dcba90aea2ef36ab0cae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Flocals%2Fchunk_item.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Flocals%2Fchunk_item.rs?ref=15b664341e1774fc8224dcba90aea2ef36ab0cae",
            "patch": "@@ -13,7 +13,7 @@ use crate::{\n         EcmascriptChunkItem, EcmascriptChunkItemContent, EcmascriptChunkPlaceable,\n         EcmascriptChunkType,\n     },\n-    EcmascriptModuleContent,\n+    EcmascriptModuleContent, EcmascriptModuleContentOptions,\n };\n \n /// The chunk item for [EcmascriptModuleLocalsModule].\n@@ -41,9 +41,10 @@ impl EcmascriptChunkItem for EcmascriptModuleLocalsChunkItem {\n         let module_graph = self.module_graph;\n         let exports = self.module.get_exports();\n         let original_module = module.module;\n-        let parsed = original_module.parse().resolve().await?;\n+        let parsed = original_module.parse().to_resolved().await?;\n \n-        let analyze_result = original_module.analyze().await?;\n+        let analyze = original_module.analyze();\n+        let analyze_result = analyze.await?;\n         let async_module_options = analyze_result\n             .async_module\n             .module_options(async_module_info);\n@@ -52,20 +53,21 @@ impl EcmascriptChunkItem for EcmascriptModuleLocalsChunkItem {\n         let generate_source_map =\n             chunking_context.reference_module_source_maps(*ResolvedVc::upcast(self.module));\n \n-        let content = EcmascriptModuleContent::new(\n+        let content = EcmascriptModuleContent::new(EcmascriptModuleContentOptions {\n             parsed,\n-            self.module.ident(),\n-            module_type_result.module_type,\n-            *module_graph,\n-            *chunking_context,\n-            *analyze_result.local_references,\n-            *analyze_result.code_generation,\n-            *analyze_result.async_module,\n+            ident: self.module.ident(),\n+            specified_module_type: module_type_result.module_type,\n+            module_graph: *module_graph,\n+            chunking_context: *chunking_context,\n+            references: analyze.local_references(),\n+            esm_references: *analyze_result.esm_local_references,\n+            code_generation: *analyze_result.code_generation,\n+            async_module: *analyze_result.async_module,\n             generate_source_map,\n-            *analyze_result.source_map,\n+            original_source_map: analyze_result.source_map,\n             exports,\n             async_module_info,\n-        );\n+        });\n \n         Ok(EcmascriptChunkItemContent::new(\n             content,"
        },
        {
            "sha": "1d49adaaac974219d5826a5f9462dfbd0678540e",
            "filename": "turbopack/crates/turbopack-ecmascript/src/side_effect_optimization/locals/module.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/15b664341e1774fc8224dcba90aea2ef36ab0cae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Flocals%2Fmodule.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/15b664341e1774fc8224dcba90aea2ef36ab0cae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Flocals%2Fmodule.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Flocals%2Fmodule.rs?ref=15b664341e1774fc8224dcba90aea2ef36ab0cae",
            "patch": "@@ -50,15 +50,15 @@ impl Module for EcmascriptModuleLocalsModule {\n \n     #[turbo_tasks::function]\n     async fn references(&self) -> Result<Vc<ModuleReferences>> {\n-        let result = self.module.analyze().await?;\n-        Ok(*result.local_references)\n+        let result = self.module.analyze();\n+        Ok(result.local_references())\n     }\n \n     #[turbo_tasks::function]\n-    async fn is_self_async(&self) -> Result<Vc<bool>> {\n-        let analyze = self.module.analyze().await?;\n+    async fn is_self_async(self: Vc<Self>) -> Result<Vc<bool>> {\n+        let analyze = self.await?.module.analyze().await?;\n         if let Some(async_module) = *analyze.async_module.await? {\n-            let is_self_async = async_module.is_self_async(*analyze.local_references);\n+            let is_self_async = async_module.is_self_async(self.references());\n             Ok(is_self_async)\n         } else {\n             Ok(Vc::cell(false))"
        },
        {
            "sha": "9134ca08e8afb3ff60684e322bbb88762f6178df",
            "filename": "turbopack/crates/turbopack-ecmascript/src/side_effect_optimization/reference.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 11,
            "changes": 17,
            "blob_url": "https://github.com/vercel/next.js/blob/15b664341e1774fc8224dcba90aea2ef36ab0cae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Freference.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/15b664341e1774fc8224dcba90aea2ef36ab0cae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Freference.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Freference.rs?ref=15b664341e1774fc8224dcba90aea2ef36ab0cae",
            "patch": "@@ -17,10 +17,8 @@ use super::{\n     facade::module::EcmascriptModuleFacadeModule, locals::module::EcmascriptModuleLocalsModule,\n };\n use crate::{\n-    chunk::EcmascriptChunkPlaceable,\n-    code_gen::{CodeGenerateable, CodeGeneration},\n-    references::esm::base::ReferencedAsset,\n-    runtime_functions::TURBOPACK_IMPORT,\n+    chunk::EcmascriptChunkPlaceable, code_gen::CodeGeneration,\n+    references::esm::base::ReferencedAsset, runtime_functions::TURBOPACK_IMPORT,\n     utils::module_id_to_lit,\n };\n \n@@ -111,14 +109,12 @@ impl ChunkableModuleReference for EcmascriptModulePartReference {\n     }\n }\n \n-#[turbo_tasks::value_impl]\n-impl CodeGenerateable for EcmascriptModulePartReference {\n-    #[turbo_tasks::function]\n-    async fn code_generation(\n+impl EcmascriptModulePartReference {\n+    pub async fn code_generation(\n         self: Vc<Self>,\n         module_graph: Vc<ModuleGraph>,\n         chunking_context: Vc<Box<dyn ChunkingContext>>,\n-    ) -> Result<Vc<CodeGeneration>> {\n+    ) -> Result<CodeGeneration> {\n         let referenced_asset = ReferencedAsset::from_resolve_result(self.resolve_reference());\n         let referenced_asset = referenced_asset.await?;\n         let ident = referenced_asset\n@@ -142,7 +138,6 @@ impl CodeGenerateable for EcmascriptModulePartReference {\n                 turbopack_import: Expr = TURBOPACK_IMPORT.into(),\n                 id: Expr = module_id_to_lit(&id),\n             ),\n-        )\n-        .cell())\n+        ))\n     }\n }"
        },
        {
            "sha": "126068e5d5a4dddb9eab6e79904584826170a51c",
            "filename": "turbopack/crates/turbopack-ecmascript/src/tree_shake/asset.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/15b664341e1774fc8224dcba90aea2ef36ab0cae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fasset.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/15b664341e1774fc8224dcba90aea2ef36ab0cae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fasset.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fasset.rs?ref=15b664341e1774fc8224dcba90aea2ef36ab0cae",
            "patch": "@@ -292,11 +292,11 @@ impl Module for EcmascriptModulePartAsset {\n     async fn references(&self) -> Result<Vc<ModuleReferences>> {\n         let split_data = split_module(*self.full_module).await?;\n \n-        let analyze = analyze(*self.full_module, self.part.clone()).await?;\n+        let analyze = analyze(*self.full_module, self.part.clone());\n \n         let deps = match &*split_data {\n             SplitResult::Ok { deps, .. } => deps,\n-            SplitResult::Failed { .. } => return Ok(*analyze.references),\n+            SplitResult::Failed { .. } => return Ok(analyze.references()),\n         };\n \n         let part_dep = |part: ModulePart| -> Vc<Box<dyn ModuleReference>> {\n@@ -306,7 +306,7 @@ impl Module for EcmascriptModulePartAsset {\n             ))\n         };\n \n-        let mut references = analyze.references.await?.to_vec();\n+        let mut references = analyze.references().owned().await?;\n \n         // Facade depends on evaluation and re-exports\n         if self.part == ModulePart::Facade {"
        },
        {
            "sha": "bd6314fffdcb0a40ff245a5c821b566edafd865f",
            "filename": "turbopack/crates/turbopack-ecmascript/src/tree_shake/chunk_item.rs",
            "status": "modified",
            "additions": 19,
            "deletions": 15,
            "changes": 34,
            "blob_url": "https://github.com/vercel/next.js/blob/15b664341e1774fc8224dcba90aea2ef36ab0cae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fchunk_item.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/15b664341e1774fc8224dcba90aea2ef36ab0cae/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fchunk_item.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fchunk_item.rs?ref=15b664341e1774fc8224dcba90aea2ef36ab0cae",
            "patch": "@@ -20,7 +20,7 @@ use crate::{\n     runtime_functions::{TURBOPACK_EXPORT_NAMESPACE, TURBOPACK_IMPORT},\n     tree_shake::side_effect_module::SideEffectsModule,\n     utils::StringifyModuleId,\n-    EcmascriptModuleContent,\n+    EcmascriptModuleContent, EcmascriptModuleContentOptions,\n };\n \n /// This is an implementation of [ChunkItem] for\n@@ -49,30 +49,34 @@ impl EcmascriptChunkItem for EcmascriptModulePartChunkItem {\n         let module = self.module.await?;\n \n         let split_data = split_module(*module.full_module);\n-        let parsed = part_of_module(split_data, module.part.clone());\n+        let parsed = part_of_module(split_data, module.part.clone())\n+            .to_resolved()\n+            .await?;\n \n-        let analyze = self.module.analyze().await?;\n-        let async_module_options = analyze.async_module.module_options(async_module_info);\n+        let analyze = self.module.analyze();\n+        let analyze_ref = analyze.await?;\n+        let async_module_options = analyze_ref.async_module.module_options(async_module_info);\n \n         let module_type_result = *module.full_module.determine_module_type().await?;\n         let generate_source_map = self\n             .chunking_context\n             .reference_module_source_maps(*ResolvedVc::upcast(self.module));\n \n-        let content = EcmascriptModuleContent::new(\n+        let content = EcmascriptModuleContent::new(EcmascriptModuleContentOptions {\n             parsed,\n-            self.module.ident(),\n-            module_type_result.module_type,\n-            *self.module_graph,\n-            *self.chunking_context,\n-            *analyze.references,\n-            *analyze.code_generation,\n-            *analyze.async_module,\n+            ident: self.module.ident(),\n+            specified_module_type: module_type_result.module_type,\n+            module_graph: *self.module_graph,\n+            chunking_context: *self.chunking_context,\n+            references: analyze.references(),\n+            esm_references: *analyze_ref.esm_references,\n+            code_generation: *analyze_ref.code_generation,\n+            async_module: *analyze_ref.async_module,\n             generate_source_map,\n-            *analyze.source_map,\n-            *analyze.exports,\n+            original_source_map: analyze_ref.source_map,\n+            exports: *analyze_ref.exports,\n             async_module_info,\n-        );\n+        });\n \n         Ok(EcmascriptChunkItemContent::new(\n             content,"
        }
    ],
    "stats": {
        "total": 675,
        "additions": 426,
        "deletions": 249
    }
}