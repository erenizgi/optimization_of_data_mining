{
    "author": "unstubbable",
    "message": "Create server module map proxy only once (#86750)\n\nSmall follow-up to #86591.\n\nWe don't need to recreate the server module map proxy every time we set\nthe manifests singleton. Instead, we can just update the underlying\nserver actions manifest, and the server module map can read the current\nmanifest from the singleton.",
    "sha": "1b3c51aa68046f5c83f489fc5e57e4f4eed96eaa",
    "files": [
        {
            "sha": "bb7f2cc4ecf002c913f401ec182115e2716f4067",
            "filename": "packages/next/src/server/app-render/action-handler.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/1b3c51aa68046f5c83f489fc5e57e4f4eed96eaa/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Faction-handler.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1b3c51aa68046f5c83f489fc5e57e4f4eed96eaa/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Faction-handler.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Faction-handler.ts?ref=1b3c51aa68046f5c83f489fc5e57e4f4eed96eaa",
            "patch": "@@ -49,7 +49,10 @@ import { warn } from '../../build/output/log'\n import { RequestCookies, ResponseCookies } from '../web/spec-extension/cookies'\n import { HeadersAdapter } from '../web/spec-extension/adapters/headers'\n import { fromNodeOutgoingHttpHeaders } from '../web/utils'\n-import { selectWorkerForForwarding, type ServerModuleMap } from './action-utils'\n+import {\n+  selectWorkerForForwarding,\n+  type ServerModuleMap,\n+} from './manifests-singleton'\n import { isNodeNextRequest, isWebNextRequest } from '../base-http/helpers'\n import { RedirectStatusCode } from '../../client/components/redirect-status-code'\n import { synchronizeMutableCookies } from '../async-storage/request-store'"
        },
        {
            "sha": "422286764c97feb106e46b826b784b50620b3b87",
            "filename": "packages/next/src/server/app-render/action-utils.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 111,
            "changes": 111,
            "blob_url": "https://github.com/vercel/next.js/blob/1a1957ca63eab115ba56042c03e83436d2375fff/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Faction-utils.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1a1957ca63eab115ba56042c03e83436d2375fff/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Faction-utils.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Faction-utils.ts?ref=1a1957ca63eab115ba56042c03e83436d2375fff",
            "patch": "@@ -1,111 +0,0 @@\n-import type { ActionManifest } from '../../build/webpack/plugins/flight-client-entry-plugin'\n-import { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\n-import { pathHasPrefix } from '../../shared/lib/router/utils/path-has-prefix'\n-import { removePathPrefix } from '../../shared/lib/router/utils/remove-path-prefix'\n-import { getServerActionsManifest } from './manifests-singleton'\n-import { workAsyncStorage } from './work-async-storage.external'\n-\n-export interface ServerModuleMap {\n-  readonly [name: string]: {\n-    readonly id: string | number\n-    readonly name: string\n-    readonly chunks: Readonly<Array<string>> // currently not used\n-    readonly async?: boolean\n-  }\n-}\n-\n-// This function creates a Flight-acceptable server module map proxy from our\n-// Server Reference Manifest similar to our client module map.\n-// This is because our manifest contains a lot of internal Next.js data that\n-// are relevant to the runtime, workers, etc. that React doesn't need to know.\n-export function createServerModuleMap({\n-  serverActionsManifest,\n-}: {\n-  serverActionsManifest: ActionManifest\n-}): ServerModuleMap {\n-  return new Proxy(\n-    {},\n-    {\n-      get: (_, id: string) => {\n-        const workers =\n-          serverActionsManifest[\n-            process.env.NEXT_RUNTIME === 'edge' ? 'edge' : 'node'\n-          ]?.[id]?.workers\n-\n-        if (!workers) {\n-          return undefined\n-        }\n-\n-        const workStore = workAsyncStorage.getStore()\n-\n-        let workerEntry:\n-          | { moduleId: string | number; async: boolean }\n-          | undefined\n-\n-        if (workStore) {\n-          workerEntry = workers[normalizeWorkerPageName(workStore.page)]\n-        } else {\n-          // If there's no work store defined, we can assume that a server\n-          // module map is needed during module evaluation, e.g. to create a\n-          // server action using a higher-order function. Therefore it should be\n-          // safe to return any entry from the manifest that matches the action\n-          // ID. They all refer to the same module ID, which must also exist in\n-          // the current page bundle. TODO: This is currently not guaranteed in\n-          // Turbopack, and needs to be fixed.\n-          workerEntry = Object.values(workers).at(0)\n-        }\n-\n-        if (!workerEntry) {\n-          return undefined\n-        }\n-\n-        const { moduleId, async } = workerEntry\n-\n-        return { id: moduleId, name: id, chunks: [], async }\n-      },\n-    }\n-  )\n-}\n-\n-/**\n- * Checks if the requested action has a worker for the current page.\n- * If not, it returns the first worker that has a handler for the action.\n- */\n-export function selectWorkerForForwarding(actionId: string, pageName: string) {\n-  const serverActionsManifest = getServerActionsManifest()\n-  const workers =\n-    serverActionsManifest[\n-      process.env.NEXT_RUNTIME === 'edge' ? 'edge' : 'node'\n-    ][actionId]?.workers\n-  const workerName = normalizeWorkerPageName(pageName)\n-\n-  // no workers, nothing to forward to\n-  if (!workers) return\n-\n-  // if there is a worker for this page, no need to forward it.\n-  if (workers[workerName]) {\n-    return\n-  }\n-\n-  // otherwise, grab the first worker that has a handler for this action id\n-  return denormalizeWorkerPageName(Object.keys(workers)[0])\n-}\n-\n-/**\n- * The flight entry loader keys actions by bundlePath.\n- * bundlePath corresponds with the relative path (including 'app') to the page entrypoint.\n- */\n-function normalizeWorkerPageName(pageName: string) {\n-  if (pathHasPrefix(pageName, 'app')) {\n-    return pageName\n-  }\n-\n-  return 'app' + pageName\n-}\n-\n-/**\n- * Converts a bundlePath (relative path to the entrypoint) to a routable page name\n- */\n-function denormalizeWorkerPageName(bundlePath: string) {\n-  return normalizeAppPath(removePathPrefix(bundlePath, 'app'))\n-}"
        },
        {
            "sha": "c917feefc6e9bdf4f8c0331094a78eb03d99d83b",
            "filename": "packages/next/src/server/app-render/manifests-singleton.ts",
            "status": "modified",
            "additions": 111,
            "deletions": 10,
            "changes": 121,
            "blob_url": "https://github.com/vercel/next.js/blob/1b3c51aa68046f5c83f489fc5e57e4f4eed96eaa/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fmanifests-singleton.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1b3c51aa68046f5c83f489fc5e57e4f4eed96eaa/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fmanifests-singleton.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fmanifests-singleton.ts?ref=1b3c51aa68046f5c83f489fc5e57e4f4eed96eaa",
            "patch": "@@ -3,9 +3,19 @@ import type { ClientReferenceManifest } from '../../build/webpack/plugins/flight\n import type { DeepReadonly } from '../../shared/lib/deep-readonly'\n import { InvariantError } from '../../shared/lib/invariant-error'\n import { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\n-import { createServerModuleMap, type ServerModuleMap } from './action-utils'\n+import { pathHasPrefix } from '../../shared/lib/router/utils/path-has-prefix'\n+import { removePathPrefix } from '../../shared/lib/router/utils/remove-path-prefix'\n import { workAsyncStorage } from './work-async-storage.external'\n \n+export interface ServerModuleMap {\n+  readonly [name: string]: {\n+    readonly id: string | number\n+    readonly name: string\n+    readonly chunks: Readonly<Array<string>> // currently not used\n+    readonly async?: boolean\n+  }\n+}\n+\n // This is a global singleton that is, among other things, also used to\n // encode/decode bound args of server function closures. This can't be using a\n // AsyncLocalStorage as it might happen at the module level.\n@@ -162,6 +172,105 @@ function createProxiedClientReferenceManifest(\n   ) as DeepReadonly<ClientReferenceManifest>\n }\n \n+/**\n+ * This function creates a Flight-acceptable server module map proxy from our\n+ * Server Reference Manifest similar to our client module map. This is because\n+ * our manifest contains a lot of internal Next.js data that are relevant to the\n+ * runtime, workers, etc. that React doesn't need to know.\n+ */\n+function createServerModuleMap(): ServerModuleMap {\n+  return new Proxy(\n+    {},\n+    {\n+      get: (_, id: string) => {\n+        const workers =\n+          getServerActionsManifest()[\n+            process.env.NEXT_RUNTIME === 'edge' ? 'edge' : 'node'\n+          ]?.[id]?.workers\n+\n+        if (!workers) {\n+          return undefined\n+        }\n+\n+        const workStore = workAsyncStorage.getStore()\n+\n+        let workerEntry:\n+          | { moduleId: string | number; async: boolean }\n+          | undefined\n+\n+        if (workStore) {\n+          workerEntry = workers[normalizeWorkerPageName(workStore.page)]\n+        } else {\n+          // If there's no work store defined, we can assume that a server\n+          // module map is needed during module evaluation, e.g. to create a\n+          // server action using a higher-order function. Therefore it should be\n+          // safe to return any entry from the manifest that matches the action\n+          // ID. They all refer to the same module ID, which must also exist in\n+          // the current page bundle. TODO: This is currently not guaranteed in\n+          // Turbopack, and needs to be fixed.\n+          workerEntry = Object.values(workers).at(0)\n+        }\n+\n+        if (!workerEntry) {\n+          return undefined\n+        }\n+\n+        const { moduleId, async } = workerEntry\n+\n+        return { id: moduleId, name: id, chunks: [], async }\n+      },\n+    }\n+  )\n+}\n+\n+/**\n+ * The flight entry loader keys actions by bundlePath. bundlePath corresponds\n+ * with the relative path (including 'app') to the page entrypoint.\n+ */\n+function normalizeWorkerPageName(pageName: string) {\n+  if (pathHasPrefix(pageName, 'app')) {\n+    return pageName\n+  }\n+\n+  return 'app' + pageName\n+}\n+\n+/**\n+ * Converts a bundlePath (relative path to the entrypoint) to a routable page\n+ * name.\n+ */\n+function denormalizeWorkerPageName(bundlePath: string) {\n+  return normalizeAppPath(removePathPrefix(bundlePath, 'app'))\n+}\n+\n+/**\n+ * Checks if the requested action has a worker for the current page.\n+ * If not, it returns the first worker that has a handler for the action.\n+ */\n+export function selectWorkerForForwarding(\n+  actionId: string,\n+  pageName: string\n+): string | undefined {\n+  const serverActionsManifest = getServerActionsManifest()\n+  const workers =\n+    serverActionsManifest[\n+      process.env.NEXT_RUNTIME === 'edge' ? 'edge' : 'node'\n+    ][actionId]?.workers\n+\n+  // There are no workers to handle this action, nothing to forward to.\n+  if (!workers) {\n+    return\n+  }\n+\n+  // If there is an entry for the current page, we don't need to forward.\n+  if (workers[normalizeWorkerPageName(pageName)]) {\n+    return\n+  }\n+\n+  // Otherwise, grab the first worker that has a handler for this action id.\n+  return denormalizeWorkerPageName(Object.keys(workers)[0])\n+}\n+\n export function setManifestsSingleton({\n   page,\n   clientReferenceManifest,\n@@ -180,10 +289,6 @@ export function setManifestsSingleton({\n     )\n \n     existingSingleton.serverActionsManifest = serverActionsManifest\n-\n-    existingSingleton.serverModuleMap = createServerModuleMap({\n-      serverActionsManifest,\n-    })\n   } else {\n     const clientReferenceManifestsPerRoute = new Map<\n       string,\n@@ -194,15 +299,11 @@ export function setManifestsSingleton({\n       clientReferenceManifestsPerRoute\n     )\n \n-    const serverModuleMap = createServerModuleMap({\n-      serverActionsManifest,\n-    })\n-\n     globalThisWithManifests[MANIFESTS_SINGLETON] = {\n       clientReferenceManifestsPerRoute,\n       proxiedClientReferenceManifest,\n       serverActionsManifest,\n-      serverModuleMap,\n+      serverModuleMap: createServerModuleMap(),\n     }\n   }\n }"
        }
    ],
    "stats": {
        "total": 237,
        "additions": 115,
        "deletions": 122
    }
}