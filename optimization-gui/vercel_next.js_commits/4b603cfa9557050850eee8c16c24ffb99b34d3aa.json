{
    "author": "wyattjoh",
    "message": "Fix interception routes with trailing slash configuration (#86787)\n\n### What?\n\nThis PR fixes interception routes to work correctly with the\n`trailingSlash` configuration option.\n\n### Why?\n\nInterception routes were not working when users had `trailingSlash:\ntrue` in their Next.js config. This was because interception route\nrewrites were marked as `internal: true`, which caused them to bypass\nthe `modifyRouteRegex` processing that handles trailing slash\nnormalization.\n\nWhen a route is marked as internal and provides its own regex, the code\nwould skip the regex modification step that ensures routes work\ncorrectly with both `trailingSlash: true` and `trailingSlash: false`\nconfigurations. This meant interception routes would fail to match when\ntrailing slashes were enabled.\n\n### How?\n\n1. **Removed `internal: true` flag** from interception route rewrites in\n`generate-interception-routes-rewrites.ts`. This ensures they go through\nthe same regex modification process as regular routes, properly handling\ntrailing slash normalization.\n\n2. **Added comprehensive test coverage** by wrapping the parallel routes\nand interception test suite in `describe.each([true, false])` to test\nboth trailing slash configurations. Updated all URL assertions to\naccount for the trailing slash setting.\n\n3. **Refactored `build-custom-route.ts`** to scope the `source` variable\ncloser to where it's actually used, preventing unnecessary computation\nfor internal routes that already provide a regex.\n\n4. **Moved `next.config.js` inline** to the test file for better\norganization and to support the parameterized test structure.",
    "sha": "4b603cfa9557050850eee8c16c24ffb99b34d3aa",
    "files": [
        {
            "sha": "0c7e558d5d5504ee2f914bac55203e8e4ee69472",
            "filename": "packages/next/src/lib/build-custom-route.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 8,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/4b603cfa9557050850eee8c16c24ffb99b34d3aa/packages%2Fnext%2Fsrc%2Flib%2Fbuild-custom-route.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/4b603cfa9557050850eee8c16c24ffb99b34d3aa/packages%2Fnext%2Fsrc%2Flib%2Fbuild-custom-route.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Flib%2Fbuild-custom-route.ts?ref=4b603cfa9557050850eee8c16c24ffb99b34d3aa",
            "patch": "@@ -37,14 +37,6 @@ export function buildCustomRoute(\n     delimiter: '/', // default is `/#?`, but Next does not pass query info\n   })\n \n-  let source = compiled.source\n-  if (!route.internal) {\n-    source = modifyRouteRegex(\n-      source,\n-      type === 'redirect' ? restrictedRedirectPaths : undefined\n-    )\n-  }\n-\n   // If this is an internal rewrite and it already provides a regex, use it\n   // otherwise, normalize the source to a regex.\n   let regex: string\n@@ -54,6 +46,14 @@ export function buildCustomRoute(\n     !('regex' in route) ||\n     typeof route.regex !== 'string'\n   ) {\n+    let source = compiled.source\n+    if (!route.internal) {\n+      source = modifyRouteRegex(\n+        source,\n+        type === 'redirect' ? restrictedRedirectPaths : undefined\n+      )\n+    }\n+\n     regex = normalizeRouteRegex(source)\n   } else {\n     regex = route.regex"
        },
        {
            "sha": "90de10fab1abc168c9cff909280d03ab7085e10b",
            "filename": "packages/next/src/lib/generate-interception-routes-rewrites.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/4b603cfa9557050850eee8c16c24ffb99b34d3aa/packages%2Fnext%2Fsrc%2Flib%2Fgenerate-interception-routes-rewrites.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/4b603cfa9557050850eee8c16c24ffb99b34d3aa/packages%2Fnext%2Fsrc%2Flib%2Fgenerate-interception-routes-rewrites.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Flib%2Fgenerate-interception-routes-rewrites.ts?ref=4b603cfa9557050850eee8c16c24ffb99b34d3aa",
            "patch": "@@ -52,7 +52,6 @@ export function generateInterceptionRoutesRewrites(\n             value: headerRegex,\n           },\n         ],\n-        internal: true,\n         regex: source.namedRegex,\n       })\n     }"
        },
        {
            "sha": "87591b02febda3ee2d6eb7879dd16d0038ba1955",
            "filename": "test/e2e/app-dir/parallel-routes-and-interception/next.config.js",
            "status": "removed",
            "additions": 0,
            "deletions": 21,
            "changes": 21,
            "blob_url": "https://github.com/vercel/next.js/blob/771447034e5d684570c3c6b0d191f0d023f5a195/test%2Fe2e%2Fapp-dir%2Fparallel-routes-and-interception%2Fnext.config.js",
            "raw_url": "https://github.com/vercel/next.js/raw/771447034e5d684570c3c6b0d191f0d023f5a195/test%2Fe2e%2Fapp-dir%2Fparallel-routes-and-interception%2Fnext.config.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fparallel-routes-and-interception%2Fnext.config.js?ref=771447034e5d684570c3c6b0d191f0d023f5a195",
            "patch": "@@ -1,21 +0,0 @@\n-/**\n- * @type {import('next').NextConfig}\n- */\n-const nextConfig = {\n-  async rewrites() {\n-    return {\n-      beforeFiles: [\n-        {\n-          source: '/foo',\n-          destination: '/en/foo',\n-        },\n-        {\n-          source: '/photos',\n-          destination: '/en/photos',\n-        },\n-      ],\n-    }\n-  },\n-}\n-\n-module.exports = nextConfig"
        },
        {
            "sha": "4e5c31590c3756e3d37c6f11e881f19e993a04b4",
            "filename": "test/e2e/app-dir/parallel-routes-and-interception/parallel-routes-and-interception.test.ts",
            "status": "modified",
            "additions": 925,
            "deletions": 790,
            "changes": 1715,
            "blob_url": "https://github.com/vercel/next.js/blob/4b603cfa9557050850eee8c16c24ffb99b34d3aa/test%2Fe2e%2Fapp-dir%2Fparallel-routes-and-interception%2Fparallel-routes-and-interception.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/4b603cfa9557050850eee8c16c24ffb99b34d3aa/test%2Fe2e%2Fapp-dir%2Fparallel-routes-and-interception%2Fparallel-routes-and-interception.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fparallel-routes-and-interception%2Fparallel-routes-and-interception.test.ts?ref=4b603cfa9557050850eee8c16c24ffb99b34d3aa",
            "patch": "@@ -1,926 +1,1060 @@\n import { nextTestSetup, FileRef } from 'e2e-utils'\n+import { NextConfig } from 'next'\n import { check, retry } from 'next-test-utils'\n import path from 'path'\n \n-describe('parallel-routes-and-interception', () => {\n-  const { next, isNextDev, isNextStart } = nextTestSetup({\n-    files: __dirname,\n-  })\n+const nextConfig: NextConfig = {\n+  async rewrites() {\n+    return {\n+      beforeFiles: [\n+        {\n+          source: '/foo',\n+          destination: '/en/foo',\n+        },\n+        {\n+          source: '/photos',\n+          destination: '/en/photos',\n+        },\n+      ],\n+    }\n+  },\n+}\n+\n+describe.each([true, false])(\n+  'parallel-routes-and-interception (trailingSlash: %s)',\n+  (trailingSlash) => {\n+    const { next, isNextDev, isNextStart } = nextTestSetup({\n+      files: __dirname,\n+      nextConfig: {\n+        trailingSlash,\n+        ...nextConfig,\n+      },\n+    })\n+\n+    describe('parallel routes', () => {\n+      it('should support parallel route tab bars', async () => {\n+        const browser = await next.browser('/parallel-tab-bar')\n+\n+        const hasHome = async () => {\n+          await check(\n+            () => browser.waitForElementByCss('#home').text(),\n+            'Tab bar page (@children)'\n+          )\n+        }\n+        const hasViewsHome = async () => {\n+          await check(\n+            () => browser.waitForElementByCss('#views-home').text(),\n+            'Views home'\n+          )\n+        }\n+        const hasViewDuration = async () => {\n+          await check(\n+            () => browser.waitForElementByCss('#view-duration').text(),\n+            'View duration'\n+          )\n+        }\n+        const hasImpressions = async () => {\n+          await check(\n+            () => browser.waitForElementByCss('#impressions').text(),\n+            'Impressions'\n+          )\n+        }\n+        const hasAudienceHome = async () => {\n+          await check(\n+            () => browser.waitForElementByCss('#audience-home').text(),\n+            'Audience home'\n+          )\n+        }\n+        const hasDemographics = async () => {\n+          await check(\n+            () => browser.waitForElementByCss('#demographics').text(),\n+            'Demographics'\n+          )\n+        }\n+        const hasSubscribers = async () => {\n+          await check(\n+            () => browser.waitForElementByCss('#subscribers').text(),\n+            'Subscribers'\n+          )\n+        }\n+        const checkUrlPath = async (path: string) => {\n+          await check(\n+            () => browser.url(),\n+            `${next.url}/parallel-tab-bar${path}${trailingSlash ? '/' : ''}`\n+          )\n+        }\n+\n+        // Initial page\n+        const step1 = async () => {\n+          await hasHome()\n+          await hasViewsHome()\n+          await hasAudienceHome()\n+          await checkUrlPath('')\n+        }\n+\n+        await step1()\n+\n+        console.log('step1')\n+        // Navigate to /views/duration\n+        await browser.elementByCss('#view-duration-link').click()\n+\n+        const step2 = async () => {\n+          await hasHome()\n+          await hasViewDuration()\n+          await hasAudienceHome()\n+          await checkUrlPath('/view-duration')\n+        }\n+\n+        await step2()\n+        console.log('step2')\n \n-  describe('parallel routes', () => {\n-    it('should support parallel route tab bars', async () => {\n-      const browser = await next.browser('/parallel-tab-bar')\n+        // Navigate to /views/impressions\n+        await browser.elementByCss('#impressions-link').click()\n+\n+        const step3 = async () => {\n+          await hasHome()\n+          await hasImpressions()\n+          await hasAudienceHome()\n+          await checkUrlPath('/impressions')\n+        }\n+\n+        await step3()\n+        console.log('step3')\n+\n+        // Navigate to /audience/demographics\n+        await browser.elementByCss('#demographics-link').click()\n+\n+        const step4 = async () => {\n+          await hasHome()\n+          await hasImpressions()\n+          await hasDemographics()\n+          await checkUrlPath('/demographics')\n+        }\n+\n+        await step4()\n+        console.log('step4')\n+\n+        // Navigate to /audience/subscribers\n+        await browser.elementByCss('#subscribers-link').click()\n+\n+        const step5 = async () => {\n+          await hasHome()\n+          await hasImpressions()\n+          await hasSubscribers()\n+          await checkUrlPath('/subscribers')\n+        }\n+\n+        await step5()\n+        console.log('step5')\n+\n+        // Navigate to /\n+        await browser.elementByCss('#home-link-audience').click()\n+\n+        await checkUrlPath('')\n+\n+        // TODO: home link behavior\n+        // await step1()\n+\n+        // TODO: fix back/forward navigation test\n+        // Test that back navigation works as intended\n+        await browser.back()\n+        await step5()\n+        console.log('step5 back')\n+        await browser.back()\n+        await step4()\n+        console.log('step4 back')\n+        await browser.back()\n+        await step3()\n+        console.log('step3 back')\n+\n+        await browser.back()\n+        await step2()\n+        console.log('step2 back')\n+        await browser.back()\n+        await step1()\n+        console.log('step1 back')\n+        console.log('step6')\n+\n+        // Test that forward navigation works as intended\n+        await browser.forward()\n+        await step2()\n+        console.log('step2 forward')\n+        await browser.forward()\n+        await step3()\n+        console.log('step3 forward')\n+        await browser.forward()\n+        await step4()\n+        console.log('step4 forward')\n+        await browser.forward()\n+        await step5()\n+      })\n+\n+      it('should match parallel routes', async () => {\n+        const $ = await next.render$('/parallel/nested')\n+        const pageText = $('#parallel-layout').text()\n+        expect(pageText).toContain('parallel/layout')\n+        expect(pageText).toContain('parallel/@foo/nested/layout')\n+        expect(pageText).toContain('parallel/@foo/nested/@a/page')\n+        expect(pageText).toContain('parallel/@foo/nested/@b/page')\n+        expect(pageText).toContain('parallel/@bar/nested/layout')\n+        expect(pageText).toContain('parallel/@bar/nested/@a/page')\n+        expect(pageText).toContain('parallel/@bar/nested/@b/page')\n+        expect(pageText).toContain('parallel/nested/page')\n+      })\n+\n+      it('should match parallel routes in route groups', async () => {\n+        const $ = await next.render$('/parallel/nested-2')\n+        const pageText = $('#parallel-layout').text()\n+        expect(pageText).toContain('parallel/layout')\n+        expect(pageText).toContain('parallel/(new)/layout')\n+        expect(pageText).toContain('parallel/(new)/@baz/nested/page')\n+      })\n \n-      const hasHome = async () => {\n+      it('should throw a 404 when no matching parallel route is found', async () => {\n+        const browser = await next.browser('/parallel-tab-bar')\n+        // we make sure the page is available through navigating\n         await check(\n           () => browser.waitForElementByCss('#home').text(),\n           'Tab bar page (@children)'\n         )\n-      }\n-      const hasViewsHome = async () => {\n-        await check(\n-          () => browser.waitForElementByCss('#views-home').text(),\n-          'Views home'\n-        )\n-      }\n-      const hasViewDuration = async () => {\n+        await browser.elementByCss('#view-duration-link').click()\n         await check(\n           () => browser.waitForElementByCss('#view-duration').text(),\n           'View duration'\n         )\n-      }\n-      const hasImpressions = async () => {\n-        await check(\n-          () => browser.waitForElementByCss('#impressions').text(),\n-          'Impressions'\n+\n+        // fetch /parallel-tab-bar/view-duration\n+        const res = await next.fetch(\n+          `${next.url}/parallel-tab-bar/view-duration`\n         )\n-      }\n-      const hasAudienceHome = async () => {\n+        const html = await res.text()\n+        expect(html).toContain('page could not be found')\n+      })\n+\n+      it('should render nested parallel routes', async () => {\n+        const browser = await next.browser('/parallel-side-bar/nested/deeper')\n         await check(\n-          () => browser.waitForElementByCss('#audience-home').text(),\n-          'Audience home'\n+          () => browser.waitForElementByCss('#nested-deeper-main').text(),\n+          'Nested deeper page'\n         )\n-      }\n-      const hasDemographics = async () => {\n+\n         await check(\n-          () => browser.waitForElementByCss('#demographics').text(),\n-          'Demographics'\n+          () => browser.waitForElementByCss('#nested-deeper-sidebar').text(),\n+          'Nested deeper sidebar here'\n         )\n-      }\n-      const hasSubscribers = async () => {\n+\n+        await browser\n+          .elementByCss(\n+            `[href=\"/parallel-side-bar/nested${trailingSlash ? '/' : ''}\"]`\n+          )\n+          .click()\n+\n         await check(\n-          () => browser.waitForElementByCss('#subscribers').text(),\n-          'Subscribers'\n+          () => browser.waitForElementByCss('#nested-main').text(),\n+          'Nested page'\n         )\n-      }\n-      const checkUrlPath = async (path: string) => {\n-        await check(() => browser.url(), `${next.url}/parallel-tab-bar${path}`)\n-      }\n \n-      // Initial page\n-      const step1 = async () => {\n-        await hasHome()\n-        await hasViewsHome()\n-        await hasAudienceHome()\n-        await checkUrlPath('')\n-      }\n+        await check(\n+          () => browser.waitForElementByCss('#nested-sidebar').text(),\n+          'Nested sidebar here'\n+        )\n \n-      await step1()\n+        await browser\n+          .elementByCss(\n+            `[href=\"/parallel-side-bar${trailingSlash ? '/' : ''}\"]`\n+          )\n+          .click()\n \n-      console.log('step1')\n-      // Navigate to /views/duration\n-      await browser.elementByCss('#view-duration-link').click()\n+        await check(\n+          () => browser.waitForElementByCss('#main').text(),\n+          'homepage'\n+        )\n \n-      const step2 = async () => {\n-        await hasHome()\n-        await hasViewDuration()\n-        await hasAudienceHome()\n-        await checkUrlPath('/view-duration')\n-      }\n+        await check(\n+          () => browser.waitForElementByCss('#sidebar-main').text(),\n+          'root sidebar here'\n+        )\n+      })\n \n-      await step2()\n-      console.log('step2')\n+      it('should support layout files in parallel routes', async () => {\n+        const browser = await next.browser('/parallel-layout')\n+        await check(\n+          () => browser.waitForElementByCss('#parallel-layout').text(),\n+          'parallel layout'\n+        )\n \n-      // Navigate to /views/impressions\n-      await browser.elementByCss('#impressions-link').click()\n+        // navigate to /parallel-layout/subroute\n+        await browser\n+          .elementByCss(\n+            `[href=\"/parallel-layout/subroute${trailingSlash ? '/' : ''}\"]`\n+          )\n+          .click()\n+        await check(\n+          () => browser.waitForElementByCss('#parallel-layout').text(),\n+          'parallel layout'\n+        )\n+        await check(\n+          () => browser.waitForElementByCss('#parallel-subroute').text(),\n+          'parallel subroute layout'\n+        )\n+      })\n \n-      const step3 = async () => {\n-        await hasHome()\n-        await hasImpressions()\n-        await hasAudienceHome()\n-        await checkUrlPath('/impressions')\n-      }\n+      it('should only scroll to the parallel route that was navigated to', async () => {\n+        const browser = await next.browser('/parallel-scroll')\n \n-      await step3()\n-      console.log('step3')\n+        await browser.eval('window.scrollTo(0, 1000)')\n+        const position = await browser.eval('window.scrollY')\n+        console.log('position', position)\n+        await browser\n+          .elementByCss(\n+            `[href=\"/parallel-scroll/nav${trailingSlash ? '/' : ''}\"]`\n+          )\n+          .click()\n+        await browser.waitForElementByCss('#modal')\n+        // check that we didn't scroll back to the top\n+        await check(() => browser.eval('window.scrollY'), position)\n+      })\n \n-      // Navigate to /audience/demographics\n-      await browser.elementByCss('#demographics-link').click()\n+      it('should apply the catch-all route to the parallel route if no matching route is found', async () => {\n+        const browser = await next.browser('/parallel-catchall')\n \n-      const step4 = async () => {\n-        await hasHome()\n-        await hasImpressions()\n-        await hasDemographics()\n-        await checkUrlPath('/demographics')\n-      }\n+        await browser\n+          .elementByCss(\n+            `[href=\"/parallel-catchall/bar${trailingSlash ? '/' : ''}\"]`\n+          )\n+          .click()\n+        await check(\n+          () => browser.waitForElementByCss('#main').text(),\n+          'bar slot'\n+        )\n+        await check(\n+          () => browser.waitForElementByCss('#slot-content').text(),\n+          'slot catchall'\n+        )\n \n-      await step4()\n-      console.log('step4')\n+        await browser\n+          .elementByCss(\n+            `[href=\"/parallel-catchall/foo${trailingSlash ? '/' : ''}\"]`\n+          )\n+          .click()\n+        await check(() => browser.waitForElementByCss('#main').text(), 'foo')\n+        await check(\n+          () => browser.waitForElementByCss('#slot-content').text(),\n+          'foo slot'\n+        )\n \n-      // Navigate to /audience/subscribers\n-      await browser.elementByCss('#subscribers-link').click()\n+        await browser\n+          .elementByCss(\n+            `[href=\"/parallel-catchall/baz${trailingSlash ? '/' : ''}\"]`\n+          )\n+          .click()\n+        await check(\n+          () => browser.waitForElementByCss('#main').text(),\n+          /main catchall/\n+        )\n+        await check(\n+          () => browser.waitForElementByCss('#main').text(),\n+          /catchall page client component/\n+        )\n+        await check(\n+          () => browser.waitForElementByCss('#slot-content').text(),\n+          'baz slot'\n+        )\n+      })\n \n-      const step5 = async () => {\n-        await hasHome()\n-        await hasImpressions()\n-        await hasSubscribers()\n-        await checkUrlPath('/subscribers')\n-      }\n+      it('should match the catch-all routes of the more specific path, if there is more than one catch-all route', async () => {\n+        const browser = await next.browser('/parallel-nested-catchall')\n \n-      await step5()\n-      console.log('step5')\n-\n-      // Navigate to /\n-      await browser.elementByCss('#home-link-audience').click()\n-\n-      await checkUrlPath('')\n-\n-      // TODO: home link behavior\n-      // await step1()\n-\n-      // TODO: fix back/forward navigation test\n-      // Test that back navigation works as intended\n-      await browser.back()\n-      await step5()\n-      console.log('step5 back')\n-      await browser.back()\n-      await step4()\n-      console.log('step4 back')\n-      await browser.back()\n-      await step3()\n-      console.log('step3 back')\n-\n-      await browser.back()\n-      await step2()\n-      console.log('step2 back')\n-      await browser.back()\n-      await step1()\n-      console.log('step1 back')\n-      console.log('step6')\n-\n-      // Test that forward navigation works as intended\n-      await browser.forward()\n-      await step2()\n-      console.log('step2 forward')\n-      await browser.forward()\n-      await step3()\n-      console.log('step3 forward')\n-      await browser.forward()\n-      await step4()\n-      console.log('step4 forward')\n-      await browser.forward()\n-      await step5()\n-    })\n+        await browser\n+          .elementByCss(\n+            `[href=\"/parallel-nested-catchall/foo${trailingSlash ? '/' : ''}\"]`\n+          )\n+          .click()\n+        await check(() => browser.waitForElementByCss('#main').text(), 'foo')\n+        await check(\n+          () => browser.waitForElementByCss('#slot-content').text(),\n+          'foo slot'\n+        )\n \n-    it('should match parallel routes', async () => {\n-      const $ = await next.render$('/parallel/nested')\n-      const pageText = $('#parallel-layout').text()\n-      expect(pageText).toContain('parallel/layout')\n-      expect(pageText).toContain('parallel/@foo/nested/layout')\n-      expect(pageText).toContain('parallel/@foo/nested/@a/page')\n-      expect(pageText).toContain('parallel/@foo/nested/@b/page')\n-      expect(pageText).toContain('parallel/@bar/nested/layout')\n-      expect(pageText).toContain('parallel/@bar/nested/@a/page')\n-      expect(pageText).toContain('parallel/@bar/nested/@b/page')\n-      expect(pageText).toContain('parallel/nested/page')\n-    })\n+        await browser\n+          .elementByCss(\n+            `[href=\"/parallel-nested-catchall/bar${trailingSlash ? '/' : ''}\"]`\n+          )\n+          .click()\n+        await check(() => browser.waitForElementByCss('#main').text(), 'bar')\n+        await check(\n+          () => browser.waitForElementByCss('#slot-content').text(),\n+          'slot catchall'\n+        )\n \n-    it('should match parallel routes in route groups', async () => {\n-      const $ = await next.render$('/parallel/nested-2')\n-      const pageText = $('#parallel-layout').text()\n-      expect(pageText).toContain('parallel/layout')\n-      expect(pageText).toContain('parallel/(new)/layout')\n-      expect(pageText).toContain('parallel/(new)/@baz/nested/page')\n-    })\n+        await browser\n+          .elementByCss(\n+            `[href=\"/parallel-nested-catchall/foo/123${trailingSlash ? '/' : ''}\"]`\n+          )\n+          .click()\n+        await check(() => browser.waitForElementByCss('#main').text(), 'foo id')\n+        await check(\n+          () => browser.waitForElementByCss('#slot-content').text(),\n+          'foo id catchAll'\n+        )\n+      })\n \n-    it('should throw a 404 when no matching parallel route is found', async () => {\n-      const browser = await next.browser('/parallel-tab-bar')\n-      // we make sure the page is available through navigating\n-      await check(\n-        () => browser.waitForElementByCss('#home').text(),\n-        'Tab bar page (@children)'\n-      )\n-      await browser.elementByCss('#view-duration-link').click()\n-      await check(\n-        () => browser.waitForElementByCss('#view-duration').text(),\n-        'View duration'\n-      )\n-\n-      // fetch /parallel-tab-bar/view-duration\n-      const res = await next.fetch(`${next.url}/parallel-tab-bar/view-duration`)\n-      const html = await res.text()\n-      expect(html).toContain('page could not be found')\n-    })\n+      it('should navigate with a link with prefetch=false', async () => {\n+        const browser = await next.browser('/parallel-prefetch-false')\n \n-    it('should render nested parallel routes', async () => {\n-      const browser = await next.browser('/parallel-side-bar/nested/deeper')\n-      await check(\n-        () => browser.waitForElementByCss('#nested-deeper-main').text(),\n-        'Nested deeper page'\n-      )\n+        // check if the default view loads\n+        await check(\n+          () => browser.waitForElementByCss('#default-parallel').text(),\n+          'default view for parallel'\n+        )\n \n-      await check(\n-        () => browser.waitForElementByCss('#nested-deeper-sidebar').text(),\n-        'Nested deeper sidebar here'\n-      )\n+        // check that navigating to /foo re-renders the layout to display @parallel/foo\n+        await check(\n+          () =>\n+            browser\n+              .elementByCss(\n+                `[href=\"/parallel-prefetch-false/foo${trailingSlash ? '/' : ''}\"]`\n+              )\n+              .click()\n+              .waitForElementByCss('#parallel-foo')\n+              .text(),\n+          'parallel for foo'\n+        )\n+      })\n \n-      await browser.elementByCss('[href=\"/parallel-side-bar/nested\"]').click()\n+      it('should display all parallel route params with useParams', async () => {\n+        const browser = await next.browser('/parallel-dynamic/foo/bar')\n \n-      await check(\n-        () => browser.waitForElementByCss('#nested-main').text(),\n-        'Nested page'\n-      )\n+        await check(\n+          () => browser.waitForElementByCss('#foo').text(),\n+          `{\"slug\":\"foo\",\"id\":\"bar\"}`\n+        )\n \n-      await check(\n-        () => browser.waitForElementByCss('#nested-sidebar').text(),\n-        'Nested sidebar here'\n-      )\n+        await check(\n+          () => browser.waitForElementByCss('#bar').text(),\n+          `{\"slug\":\"foo\",\"id\":\"bar\"}`\n+        )\n+      })\n \n-      await browser.elementByCss('[href=\"/parallel-side-bar\"]').click()\n+      it('should load CSS for a default page that exports another page', async () => {\n+        const browser = await next.browser('/default-css')\n \n-      await check(() => browser.waitForElementByCss('#main').text(), 'homepage')\n+        expect(\n+          await browser.eval(\n+            `window.getComputedStyle(document.getElementById(\"red-text\")).color`\n+          )\n+        ).toBe('rgb(255, 0, 0)')\n \n-      await check(\n-        () => browser.waitForElementByCss('#sidebar-main').text(),\n-        'root sidebar here'\n-      )\n-    })\n+        // the more page will now be using the page's `default.tsx` file, which re-exports the root page.\n+        await browser\n+          .elementByCss(`[href=\"/default-css/more${trailingSlash ? '/' : ''}\"]`)\n+          .click()\n \n-    it('should support layout files in parallel routes', async () => {\n-      const browser = await next.browser('/parallel-layout')\n-      await check(\n-        () => browser.waitForElementByCss('#parallel-layout').text(),\n-        'parallel layout'\n-      )\n-\n-      // navigate to /parallel-layout/subroute\n-      await browser.elementByCss('[href=\"/parallel-layout/subroute\"]').click()\n-      await check(\n-        () => browser.waitForElementByCss('#parallel-layout').text(),\n-        'parallel layout'\n-      )\n-      await check(\n-        () => browser.waitForElementByCss('#parallel-subroute').text(),\n-        'parallel subroute layout'\n-      )\n-    })\n+        expect(\n+          await browser.eval(\n+            `window.getComputedStyle(document.getElementById(\"red-text\")).color`\n+          )\n+        ).toBe('rgb(255, 0, 0)')\n \n-    it('should only scroll to the parallel route that was navigated to', async () => {\n-      const browser = await next.browser('/parallel-scroll')\n+        // ensure that everything still works on a fresh load\n+        await browser.refresh()\n \n-      await browser.eval('window.scrollTo(0, 1000)')\n-      const position = await browser.eval('window.scrollY')\n-      console.log('position', position)\n-      await browser.elementByCss('[href=\"/parallel-scroll/nav\"]').click()\n-      await browser.waitForElementByCss('#modal')\n-      // check that we didn't scroll back to the top\n-      await check(() => browser.eval('window.scrollY'), position)\n-    })\n+        expect(\n+          await browser.eval(\n+            `window.getComputedStyle(document.getElementById(\"red-text\")).color`\n+          )\n+        ).toBe('rgb(255, 0, 0)')\n+      })\n \n-    it('should apply the catch-all route to the parallel route if no matching route is found', async () => {\n-      const browser = await next.browser('/parallel-catchall')\n-\n-      await browser.elementByCss('[href=\"/parallel-catchall/bar\"]').click()\n-      await check(() => browser.waitForElementByCss('#main').text(), 'bar slot')\n-      await check(\n-        () => browser.waitForElementByCss('#slot-content').text(),\n-        'slot catchall'\n-      )\n-\n-      await browser.elementByCss('[href=\"/parallel-catchall/foo\"]').click()\n-      await check(() => browser.waitForElementByCss('#main').text(), 'foo')\n-      await check(\n-        () => browser.waitForElementByCss('#slot-content').text(),\n-        'foo slot'\n-      )\n-\n-      await browser.elementByCss('[href=\"/parallel-catchall/baz\"]').click()\n-      await check(\n-        () => browser.waitForElementByCss('#main').text(),\n-        /main catchall/\n-      )\n-      await check(\n-        () => browser.waitForElementByCss('#main').text(),\n-        /catchall page client component/\n-      )\n-      await check(\n-        () => browser.waitForElementByCss('#slot-content').text(),\n-        'baz slot'\n-      )\n-    })\n+      it('should handle a loading state', async () => {\n+        const browser = await next.browser('/with-loading')\n+        expect(await browser.elementById('slot').text()).toBe('Root Slot')\n+        expect(await browser.elementById('children').text()).toBe('Root Page')\n \n-    it('should match the catch-all routes of the more specific path, if there is more than one catch-all route', async () => {\n-      const browser = await next.browser('/parallel-nested-catchall')\n-\n-      await browser\n-        .elementByCss('[href=\"/parallel-nested-catchall/foo\"]')\n-        .click()\n-      await check(() => browser.waitForElementByCss('#main').text(), 'foo')\n-      await check(\n-        () => browser.waitForElementByCss('#slot-content').text(),\n-        'foo slot'\n-      )\n-\n-      await browser\n-        .elementByCss('[href=\"/parallel-nested-catchall/bar\"]')\n-        .click()\n-      await check(() => browser.waitForElementByCss('#main').text(), 'bar')\n-      await check(\n-        () => browser.waitForElementByCss('#slot-content').text(),\n-        'slot catchall'\n-      )\n-\n-      await browser\n-        .elementByCss('[href=\"/parallel-nested-catchall/foo/123\"]')\n-        .click()\n-      await check(() => browser.waitForElementByCss('#main').text(), 'foo id')\n-      await check(\n-        () => browser.waitForElementByCss('#slot-content').text(),\n-        'foo id catchAll'\n-      )\n-    })\n+        // should have triggered a loading state\n+        expect(\n+          await browser\n+            .elementByCss(\n+              `[href=\"/with-loading/foo${trailingSlash ? '/' : ''}\"]`\n+            )\n+            .click()\n+            .waitForElementByCss('#loading-page')\n+            .text()\n+        ).toBe('Loading...')\n+\n+        // should eventually load the full page\n+        await retry(async () => {\n+          expect(await browser.elementById('slot').text()).toBe('Nested Slot')\n+          expect(await browser.elementById('children').text()).toBe(\n+            'Welcome to Foo Page'\n+          )\n+        })\n+      })\n \n-    it('should navigate with a link with prefetch=false', async () => {\n-      const browser = await next.browser('/parallel-prefetch-false')\n+      if (isNextDev) {\n+        it('should support parallel routes with no page component', async () => {\n+          const browser = await next.browser('/parallel-no-page/foo')\n+          const timestamp = await browser.elementByCss('#timestamp').text()\n \n-      // check if the default view loads\n-      await check(\n-        () => browser.waitForElementByCss('#default-parallel').text(),\n-        'default view for parallel'\n-      )\n+          await new Promise((resolve) => {\n+            setTimeout(resolve, 3000)\n+          })\n \n-      // check that navigating to /foo re-renders the layout to display @parallel/foo\n-      await check(\n-        () =>\n-          browser\n-            .elementByCss('[href=\"/parallel-prefetch-false/foo\"]')\n-            .click()\n-            .waitForElementByCss('#parallel-foo')\n-            .text(),\n-        'parallel for foo'\n-      )\n-    })\n+          await check(async () => {\n+            // an invalid response triggers a fast refresh, so if the timestamp doesn't update, this behaved correctly\n+            const newTimestamp = await browser.elementByCss('#timestamp').text()\n+            return newTimestamp !== timestamp ? 'failure' : 'success'\n+          }, 'success')\n+        })\n \n-    it('should display all parallel route params with useParams', async () => {\n-      const browser = await next.browser('/parallel-dynamic/foo/bar')\n+        it('should support nested parallel routes', async () => {\n+          const browser = await next.browser('parallel-nested/home/nested')\n+          const timestamp = await browser.elementByCss('#timestamp').text()\n \n-      await check(\n-        () => browser.waitForElementByCss('#foo').text(),\n-        `{\"slug\":\"foo\",\"id\":\"bar\"}`\n-      )\n+          await new Promise((resolve) => {\n+            setTimeout(resolve, 3000)\n+          })\n \n-      await check(\n-        () => browser.waitForElementByCss('#bar').text(),\n-        `{\"slug\":\"foo\",\"id\":\"bar\"}`\n-      )\n+          await check(async () => {\n+            // an invalid response triggers a fast refresh, so if the timestamp doesn't update, this behaved correctly\n+            const newTimestamp = await browser.elementByCss('#timestamp').text()\n+            return newTimestamp !== timestamp ? 'failure' : 'success'\n+          }, 'success')\n+        })\n+      }\n     })\n \n-    it('should load CSS for a default page that exports another page', async () => {\n-      const browser = await next.browser('/default-css')\n-\n-      expect(\n-        await browser.eval(\n-          `window.getComputedStyle(document.getElementById(\"red-text\")).color`\n+    describe('route intercepting with dynamic routes', () => {\n+      it('should render intercepted route', async () => {\n+        const browser = await next.browser(\n+          `/intercepting-routes-dynamic/photos${trailingSlash ? '/' : ''}`\n         )\n-      ).toBe('rgb(255, 0, 0)')\n \n-      // the more page will now be using the page's `default.tsx` file, which re-exports the root page.\n-      await browser.elementByCss('[href=\"/default-css/more\"]').click()\n+        // Check if navigation to modal route works\n+        await check(\n+          () =>\n+            browser\n+              .elementByCss(\n+                `[href=\"/intercepting-routes-dynamic/photos/next/123${trailingSlash ? '/' : ''}\"]`\n+              )\n+              .click()\n+              .waitForElementByCss('#user-intercept-page')\n+              .text(),\n+          'Intercepted Page'\n+        )\n \n-      expect(\n-        await browser.eval(\n-          `window.getComputedStyle(document.getElementById(\"red-text\")).color`\n+        // Check if url matches even though it was intercepted.\n+        await check(\n+          () => browser.url(),\n+          next.url +\n+            '/intercepting-routes-dynamic/photos/next/123' +\n+            (trailingSlash ? '/' : '')\n         )\n-      ).toBe('rgb(255, 0, 0)')\n \n-      // ensure that everything still works on a fresh load\n-      await browser.refresh()\n+        // Trigger a refresh, this should load the normal page, not the modal.\n+        await check(\n+          () =>\n+            browser.refresh().waitForElementByCss('#user-regular-page').text(),\n+          'Regular Page'\n+        )\n \n-      expect(\n-        await browser.eval(\n-          `window.getComputedStyle(document.getElementById(\"red-text\")).color`\n+        // Check if the url matches still.\n+        await check(\n+          () => browser.url(),\n+          next.url +\n+            '/intercepting-routes-dynamic/photos/next/123' +\n+            (trailingSlash ? '/' : '')\n         )\n-      ).toBe('rgb(255, 0, 0)')\n+      })\n     })\n \n-    it('should handle a loading state', async () => {\n-      const browser = await next.browser('/with-loading')\n-      expect(await browser.elementById('slot').text()).toBe('Root Slot')\n-      expect(await browser.elementById('children').text()).toBe('Root Page')\n+    describe('route intercepting with prerendered dynamic routes ', () => {\n+      it('should render intercepted route', async () => {\n+        const browser = await next.browser(\n+          '/intercepting-routes-dynamic-prerendered/photos'\n+        )\n \n-      // should have triggered a loading state\n-      expect(\n+        // Check if navigation to modal route works.\n         await browser\n-          .elementByCss('[href=\"/with-loading/foo\"]')\n+          .elementByCss(\n+            `[href=\"/intercepting-routes-dynamic-prerendered/photos/1${trailingSlash ? '/' : ''}\"]`\n+          )\n           .click()\n-          .waitForElementByCss('#loading-page')\n-          .text()\n-      ).toBe('Loading...')\n \n-      // should eventually load the full page\n-      await retry(async () => {\n-        expect(await browser.elementById('slot').text()).toBe('Nested Slot')\n-        expect(await browser.elementById('children').text()).toBe(\n-          'Welcome to Foo Page'\n+        // This should load the intercepted page.\n+        await retry(async () => {\n+          expect(\n+            await browser.waitForElementByCss('#photo-intercepted-1').text()\n+          ).toBe('Photo INTERCEPTED 1')\n+        })\n+\n+        // Check if url matches even though it was intercepted.\n+        expect(await browser.url()).toBe(\n+          next.url +\n+            '/intercepting-routes-dynamic-prerendered/photos/1' +\n+            (trailingSlash ? '/' : '')\n         )\n-      })\n-    })\n \n-    if (isNextDev) {\n-      it('should support parallel routes with no page component', async () => {\n-        const browser = await next.browser('/parallel-no-page/foo')\n-        const timestamp = await browser.elementByCss('#timestamp').text()\n+        // There must not be any errors from prefetching the intercepted page.\n+        expect(\n+          (await browser.log()).filter(({ source }) => source === 'error')\n+        ).toEqual([])\n \n-        await new Promise((resolve) => {\n-          setTimeout(resolve, 3000)\n-        })\n+        // Trigger a refresh, this should load the normal page, not the modal.\n+        await browser.refresh()\n+        expect(await browser.waitForElementByCss('#photo-page-1').text()).toBe(\n+          'Photo PAGE 1'\n+        )\n \n-        await check(async () => {\n-          // an invalid response triggers a fast refresh, so if the timestamp doesn't update, this behaved correctly\n-          const newTimestamp = await browser.elementByCss('#timestamp').text()\n-          return newTimestamp !== timestamp ? 'failure' : 'success'\n-        }, 'success')\n+        // Check if the url matches still.\n+        expect(await browser.url()).toBe(\n+          next.url +\n+            '/intercepting-routes-dynamic-prerendered/photos/1' +\n+            (trailingSlash ? '/' : '')\n+        )\n       })\n+    })\n \n-      it('should support nested parallel routes', async () => {\n-        const browser = await next.browser('parallel-nested/home/nested')\n-        const timestamp = await browser.elementByCss('#timestamp').text()\n+    describe('route intercepting with dynamic optional catch-all routes', () => {\n+      it('should render intercepted route', async () => {\n+        const browser = await next.browser(\n+          `/intercepting-routes-dynamic-catchall/photos${trailingSlash ? '/' : ''}`\n+        )\n \n-        await new Promise((resolve) => {\n-          setTimeout(resolve, 3000)\n-        })\n+        // Check if navigation to modal route works\n+        await check(\n+          () =>\n+            browser\n+              .elementByCss(\n+                `[href=\"/intercepting-routes-dynamic-catchall/photos/optional-catchall/123${trailingSlash ? '/' : ''}\"]`\n+              )\n+              .click()\n+              .waitForElementByCss('#optional-catchall-intercept-page')\n+              .text(),\n+          'Intercepted Page'\n+        )\n \n-        await check(async () => {\n-          // an invalid response triggers a fast refresh, so if the timestamp doesn't update, this behaved correctly\n-          const newTimestamp = await browser.elementByCss('#timestamp').text()\n-          return newTimestamp !== timestamp ? 'failure' : 'success'\n-        }, 'success')\n-      })\n-    }\n-  })\n+        // Check if url matches even though it was intercepted.\n+        await check(\n+          () => browser.url(),\n+          next.url +\n+            '/intercepting-routes-dynamic-catchall/photos/optional-catchall/123' +\n+            (trailingSlash ? '/' : '')\n+        )\n \n-  describe('route intercepting with dynamic routes', () => {\n-    it('should render intercepted route', async () => {\n-      const browser = await next.browser('/intercepting-routes-dynamic/photos')\n+        // Trigger a refresh, this should load the normal page, not the modal.\n+        await check(\n+          () =>\n+            browser\n+              .refresh()\n+              .waitForElementByCss('#optional-catchall-regular-page')\n+              .text(),\n+          'Regular Page'\n+        )\n \n-      // Check if navigation to modal route works\n-      await check(\n-        () =>\n-          browser\n-            .elementByCss(\n-              '[href=\"/intercepting-routes-dynamic/photos/next/123\"]'\n-            )\n-            .click()\n-            .waitForElementByCss('#user-intercept-page')\n-            .text(),\n-        'Intercepted Page'\n-      )\n-\n-      // Check if url matches even though it was intercepted.\n-      await check(\n-        () => browser.url(),\n-        next.url + '/intercepting-routes-dynamic/photos/next/123'\n-      )\n-\n-      // Trigger a refresh, this should load the normal page, not the modal.\n-      await check(\n-        () =>\n-          browser.refresh().waitForElementByCss('#user-regular-page').text(),\n-        'Regular Page'\n-      )\n-\n-      // Check if the url matches still.\n-      await check(\n-        () => browser.url(),\n-        next.url + '/intercepting-routes-dynamic/photos/next/123'\n-      )\n+        // Check if the url matches still.\n+        await check(\n+          () => browser.url(),\n+          next.url +\n+            '/intercepting-routes-dynamic-catchall/photos/optional-catchall/123' +\n+            (trailingSlash ? '/' : '')\n+        )\n+      })\n     })\n-  })\n \n-  describe('route intercepting with prerendered dynamic routes ', () => {\n-    it('should render intercepted route', async () => {\n-      const browser = await next.browser(\n-        '/intercepting-routes-dynamic-prerendered/photos'\n-      )\n+    describe('route intercepting with dynamic catch-all routes', () => {\n+      it('should render intercepted route', async () => {\n+        const browser = await next.browser(\n+          `/intercepting-routes-dynamic-catchall/photos${trailingSlash ? '/' : ''}`\n+        )\n \n-      // Check if navigation to modal route works.\n-      await browser\n-        .elementByCss(\n-          '[href=\"/intercepting-routes-dynamic-prerendered/photos/1\"]'\n+        // Check if navigation to modal route works\n+        await check(\n+          () =>\n+            browser\n+              .elementByCss(\n+                `[href=\"/intercepting-routes-dynamic-catchall/photos/catchall/123${trailingSlash ? '/' : ''}\"]`\n+              )\n+              .click()\n+              .waitForElementByCss('#catchall-intercept-page')\n+              .text(),\n+          'Intercepted Page'\n         )\n-        .click()\n \n-      // This should load the intercepted page.\n-      await retry(async () => {\n-        expect(\n-          await browser.waitForElementByCss('#photo-intercepted-1').text()\n-        ).toBe('Photo INTERCEPTED 1')\n-      })\n+        // Check if url matches even though it was intercepted.\n+        await check(\n+          () => browser.url(),\n+          next.url +\n+            '/intercepting-routes-dynamic-catchall/photos/catchall/123' +\n+            (trailingSlash ? '/' : '')\n+        )\n \n-      // Check if url matches even though it was intercepted.\n-      expect(await browser.url()).toBe(\n-        next.url + '/intercepting-routes-dynamic-prerendered/photos/1'\n-      )\n-\n-      // There must not be any errors from prefetching the intercepted page.\n-      expect(\n-        (await browser.log()).filter(({ source }) => source === 'error')\n-      ).toEqual([])\n-\n-      // Trigger a refresh, this should load the normal page, not the modal.\n-      await browser.refresh()\n-      expect(await browser.waitForElementByCss('#photo-page-1').text()).toBe(\n-        'Photo PAGE 1'\n-      )\n-\n-      // Check if the url matches still.\n-      expect(await browser.url()).toBe(\n-        next.url + '/intercepting-routes-dynamic-prerendered/photos/1'\n-      )\n+        // Trigger a refresh, this should load the normal page, not the modal.\n+        await check(\n+          () =>\n+            browser\n+              .refresh()\n+              .waitForElementByCss('#catchall-regular-page')\n+              .text(),\n+          'Regular Page'\n+        )\n+\n+        // Check if the url matches still.\n+        await check(\n+          () => browser.url(),\n+          next.url +\n+            '/intercepting-routes-dynamic-catchall/photos/catchall/123' +\n+            (trailingSlash ? '/' : '')\n+        )\n+      })\n     })\n-  })\n \n-  describe('route intercepting with dynamic optional catch-all routes', () => {\n-    it('should render intercepted route', async () => {\n-      const browser = await next.browser(\n-        '/intercepting-routes-dynamic-catchall/photos'\n-      )\n+    describe('route intercepting', () => {\n+      it('should render intercepted route', async () => {\n+        const browser = await next.browser(\n+          `/intercepting-routes/feed${trailingSlash ? '/' : ''}`\n+        )\n \n-      // Check if navigation to modal route works\n-      await check(\n-        () =>\n-          browser\n-            .elementByCss(\n-              '[href=\"/intercepting-routes-dynamic-catchall/photos/optional-catchall/123\"]'\n-            )\n-            .click()\n-            .waitForElementByCss('#optional-catchall-intercept-page')\n-            .text(),\n-        'Intercepted Page'\n-      )\n-\n-      // Check if url matches even though it was intercepted.\n-      await check(\n-        () => browser.url(),\n-        next.url +\n-          '/intercepting-routes-dynamic-catchall/photos/optional-catchall/123'\n-      )\n-\n-      // Trigger a refresh, this should load the normal page, not the modal.\n-      await check(\n-        () =>\n-          browser\n-            .refresh()\n-            .waitForElementByCss('#optional-catchall-regular-page')\n-            .text(),\n-        'Regular Page'\n-      )\n-\n-      // Check if the url matches still.\n-      await check(\n-        () => browser.url(),\n-        next.url +\n-          '/intercepting-routes-dynamic-catchall/photos/optional-catchall/123'\n-      )\n-    })\n-  })\n+        // Check if navigation to modal route works.\n+        await check(\n+          () =>\n+            browser\n+              .elementByCss(\n+                `[href=\"/intercepting-routes/feed/photos/1${trailingSlash ? '/' : ''}\"]`\n+              )\n+              .click()\n+              .waitForElementByCss('#photo-intercepted-1')\n+              .text(),\n+          'Photo INTERCEPTED 1'\n+        )\n \n-  describe('route intercepting with dynamic catch-all routes', () => {\n-    it('should render intercepted route', async () => {\n-      const browser = await next.browser(\n-        '/intercepting-routes-dynamic-catchall/photos'\n-      )\n+        // Check if intercepted route was rendered while existing page content was removed.\n+        // Content would only be preserved when combined with parallel routes.\n+        // await check(() => browser.elementByCss('#feed-page').text()).not.toBe('Feed')\n \n-      // Check if navigation to modal route works\n-      await check(\n-        () =>\n-          browser\n-            .elementByCss(\n-              '[href=\"/intercepting-routes-dynamic-catchall/photos/catchall/123\"]'\n-            )\n-            .click()\n-            .waitForElementByCss('#catchall-intercept-page')\n-            .text(),\n-        'Intercepted Page'\n-      )\n-\n-      // Check if url matches even though it was intercepted.\n-      await check(\n-        () => browser.url(),\n-        next.url + '/intercepting-routes-dynamic-catchall/photos/catchall/123'\n-      )\n-\n-      // Trigger a refresh, this should load the normal page, not the modal.\n-      await check(\n-        () =>\n-          browser\n-            .refresh()\n-            .waitForElementByCss('#catchall-regular-page')\n-            .text(),\n-        'Regular Page'\n-      )\n-\n-      // Check if the url matches still.\n-      await check(\n-        () => browser.url(),\n-        next.url + '/intercepting-routes-dynamic-catchall/photos/catchall/123'\n-      )\n-    })\n-  })\n+        // Check if url matches even though it was intercepted.\n+        await check(\n+          () => browser.url(),\n+          next.url +\n+            '/intercepting-routes/feed/photos/1' +\n+            (trailingSlash ? '/' : '')\n+        )\n \n-  describe('route intercepting', () => {\n-    it('should render intercepted route', async () => {\n-      const browser = await next.browser('/intercepting-routes/feed')\n+        // Trigger a refresh, this should load the normal page, not the modal.\n+        await check(\n+          () => browser.refresh().waitForElementByCss('#photo-page-1').text(),\n+          'Photo PAGE 1'\n+        )\n \n-      // Check if navigation to modal route works.\n-      await check(\n-        () =>\n-          browser\n-            .elementByCss('[href=\"/intercepting-routes/feed/photos/1\"]')\n-            .click()\n-            .waitForElementByCss('#photo-intercepted-1')\n-            .text(),\n-        'Photo INTERCEPTED 1'\n-      )\n-\n-      // Check if intercepted route was rendered while existing page content was removed.\n-      // Content would only be preserved when combined with parallel routes.\n-      // await check(() => browser.elementByCss('#feed-page').text()).not.toBe('Feed')\n-\n-      // Check if url matches even though it was intercepted.\n-      await check(\n-        () => browser.url(),\n-        next.url + '/intercepting-routes/feed/photos/1'\n-      )\n-\n-      // Trigger a refresh, this should load the normal page, not the modal.\n-      await check(\n-        () => browser.refresh().waitForElementByCss('#photo-page-1').text(),\n-        'Photo PAGE 1'\n-      )\n-\n-      // Check if the url matches still.\n-      await check(\n-        () => browser.url(),\n-        next.url + '/intercepting-routes/feed/photos/1'\n-      )\n-    })\n+        // Check if the url matches still.\n+        await check(\n+          () => browser.url(),\n+          next.url +\n+            '/intercepting-routes/feed/photos/1' +\n+            (trailingSlash ? '/' : '')\n+        )\n+      })\n \n-    it('should render an intercepted route from a slot', async () => {\n-      const browser = await next.browser('/')\n+      it('should render an intercepted route from a slot', async () => {\n+        const browser = await next.browser('/')\n \n-      await check(\n-        () => browser.waitForElementByCss('#default-slot').text(),\n-        'default from @slot'\n-      )\n+        await check(\n+          () => browser.waitForElementByCss('#default-slot').text(),\n+          'default from @slot'\n+        )\n \n-      await check(\n-        () =>\n-          browser\n-            .elementByCss('[href=\"/nested\"]')\n-            .click()\n-            .waitForElementByCss('#interception-slot')\n-            .text(),\n-        'interception from @slot/nested'\n-      )\n-\n-      // Check if the client component is rendered\n-      await check(\n-        () => browser.waitForElementByCss('#interception-slot-client').text(),\n-        'client component'\n-      )\n-\n-      await check(\n-        () => browser.refresh().waitForElementByCss('#nested').text(),\n-        'hello world from /nested'\n-      )\n-    })\n+        await check(\n+          () =>\n+            browser\n+              .elementByCss(`[href=\"/nested${trailingSlash ? '/' : ''}\"]`)\n+              .click()\n+              .waitForElementByCss('#interception-slot')\n+              .text(),\n+          'interception from @slot/nested'\n+        )\n \n-    it('should render an intercepted route at the top level from a nested path', async () => {\n-      const browser = await next.browser('/nested-link')\n+        // Check if the client component is rendered\n+        await check(\n+          () => browser.waitForElementByCss('#interception-slot-client').text(),\n+          'client component'\n+        )\n \n-      await check(\n-        () => browser.waitForElementByCss('#default-slot').text(),\n-        'default from @slot'\n-      )\n+        await check(\n+          () => browser.refresh().waitForElementByCss('#nested').text(),\n+          'hello world from /nested'\n+        )\n+      })\n \n-      await check(\n-        () =>\n-          browser\n-            .elementByCss('[href=\"/nested\"]')\n-            .click()\n-            .waitForElementByCss('#interception-slot')\n-            .text(),\n-        'interception from @slot/nested'\n-      )\n-\n-      await check(\n-        () => browser.refresh().waitForElementByCss('#nested').text(),\n-        'hello world from /nested'\n-      )\n-    })\n+      it('should render an intercepted route at the top level from a nested path', async () => {\n+        const browser = await next.browser(\n+          `/nested-link${trailingSlash ? '/' : ''}`\n+        )\n \n-    it('should render intercepted route from a nested route', async () => {\n-      const browser = await next.browser('/intercepting-routes/feed/nested')\n+        await check(\n+          () => browser.waitForElementByCss('#default-slot').text(),\n+          'default from @slot'\n+        )\n \n-      // Check if navigation to modal route works.\n-      await check(\n-        () =>\n-          browser\n-            .elementByCss('[href=\"/intercepting-routes/feed/photos/1\"]')\n-            .click()\n-            .waitForElementByCss('#photo-intercepted-1')\n-            .text(),\n-        'Photo INTERCEPTED 1'\n-      )\n-\n-      // Check if intercepted route was rendered while existing page content was removed.\n-      // Content would only be preserved when combined with parallel routes.\n-      // await check(() => browser.elementByCss('#feed-page').text()).not.toBe('Feed')\n-\n-      // Check if url matches even though it was intercepted.\n-      await check(\n-        () => browser.url(),\n-        next.url + '/intercepting-routes/feed/photos/1'\n-      )\n-\n-      // Trigger a refresh, this should load the normal page, not the modal.\n-      await check(\n-        () => browser.refresh().waitForElementByCss('#photo-page-1').text(),\n-        'Photo PAGE 1'\n-      )\n-\n-      // Check if the url matches still.\n-      await check(\n-        () => browser.url(),\n-        next.url + '/intercepting-routes/feed/photos/1'\n-      )\n-    })\n+        await check(\n+          () =>\n+            browser\n+              .elementByCss(`[href=\"/nested${trailingSlash ? '/' : ''}\"]`)\n+              .click()\n+              .waitForElementByCss('#interception-slot')\n+              .text(),\n+          'interception from @slot/nested'\n+        )\n \n-    it('should re-render the layout on the server when it had a default child route', async () => {\n-      const browser = await next.browser('/parallel-non-intercepting')\n+        await check(\n+          () => browser.refresh().waitForElementByCss('#nested').text(),\n+          'hello world from /nested'\n+        )\n+      })\n \n-      // check if the default view loads\n-      await check(\n-        () => browser.waitForElementByCss('#default-parallel').text(),\n-        'default view for parallel'\n-      )\n+      it('should render intercepted route from a nested route', async () => {\n+        const browser = await next.browser(\n+          `/intercepting-routes/feed/nested${trailingSlash ? '/' : ''}`\n+        )\n \n-      // check that navigating to /foo re-renders the layout to display @parallel/foo\n-      await check(\n-        () =>\n-          browser\n-            .elementByCss('[href=\"/parallel-non-intercepting/foo\"]')\n-            .click()\n-            .waitForElementByCss('#parallel-foo')\n-            .text(),\n-        'parallel for foo'\n-      )\n+        // Check if navigation to modal route works.\n+        await check(\n+          () =>\n+            browser\n+              .elementByCss(\n+                `[href=\"/intercepting-routes/feed/photos/1${trailingSlash ? '/' : ''}\"]`\n+              )\n+              .click()\n+              .waitForElementByCss('#photo-intercepted-1')\n+              .text(),\n+          'Photo INTERCEPTED 1'\n+        )\n \n-      // check that navigating to /foo also re-renders the base children\n-      await check(() => browser.elementByCss('#children-foo').text(), 'foo')\n-    })\n+        // Check if intercepted route was rendered while existing page content was removed.\n+        // Content would only be preserved when combined with parallel routes.\n+        // await check(() => browser.elementByCss('#feed-page').text()).not.toBe('Feed')\n \n-    it('should render modal when paired with parallel routes', async () => {\n-      const browser = await next.browser('/intercepting-parallel-modal/vercel')\n-      // Check if navigation to modal route works.\n-      await check(\n-        () =>\n-          browser\n-            .elementByCss('[href=\"/intercepting-parallel-modal/photo/1\"]')\n-            .click()\n-            .waitForElementByCss('#photo-modal-1')\n-            .text(),\n-        'Photo MODAL 1'\n-      )\n-\n-      await check(\n-        () =>\n-          browser\n-            .elementByCss('[href=\"/intercepting-parallel-modal/photo/2\"]')\n-            .click()\n-            .waitForElementByCss('#photo-modal-2')\n-            .text(),\n-        'Photo MODAL 2'\n-      )\n-\n-      // Check if modal was rendered while existing page content is preserved.\n-      await check(\n-        () => browser.elementByCss('#user-page').text(),\n-        'Feed for vercel'\n-      )\n-\n-      // Check if url matches even though it was intercepted.\n-      await check(\n-        () => browser.url(),\n-        next.url + '/intercepting-parallel-modal/photo/2'\n-      )\n-\n-      // Trigger a refresh, this should load the normal page, not the modal.\n-      await check(\n-        () => browser.refresh().waitForElementByCss('#photo-page-2').text(),\n-        'Photo PAGE 2'\n-      )\n-\n-      // Check if the url matches still.\n-      await check(\n-        () => browser.url(),\n-        next.url + '/intercepting-parallel-modal/photo/2'\n-      )\n-    })\n+        // Check if url matches even though it was intercepted.\n+        await check(\n+          () => browser.url(),\n+          next.url +\n+            '/intercepting-routes/feed/photos/1' +\n+            (trailingSlash ? '/' : '')\n+        )\n \n-    it('should support intercepting with beforeFiles rewrites', async () => {\n-      const browser = await next.browser('/foo')\n+        // Trigger a refresh, this should load the normal page, not the modal.\n+        await check(\n+          () => browser.refresh().waitForElementByCss('#photo-page-1').text(),\n+          'Photo PAGE 1'\n+        )\n \n-      await check(\n-        () =>\n-          browser\n-            .elementByCss('[href=\"/photos\"]')\n-            .click()\n-            .waitForElementByCss('#intercepted')\n-            .text(),\n-        'intercepted'\n-      )\n-    })\n+        // Check if the url matches still.\n+        await check(\n+          () => browser.url(),\n+          next.url +\n+            '/intercepting-routes/feed/photos/1' +\n+            (trailingSlash ? '/' : '')\n+        )\n+      })\n \n-    it('should support intercepting local dynamic sibling routes', async () => {\n-      const browser = await next.browser('/intercepting-siblings')\n+      it('should re-render the layout on the server when it had a default child route', async () => {\n+        const browser = await next.browser(\n+          `/parallel-non-intercepting${trailingSlash ? '/' : ''}`\n+        )\n \n-      await check(\n-        () =>\n-          browser\n-            .elementByCss('[href=\"/intercepting-siblings/1\"]')\n-            .click()\n-            .waitForElementByCss('#intercepted-sibling')\n-            .text(),\n-        '1'\n-      )\n-      await check(\n-        () =>\n-          browser\n-            .elementByCss('[href=\"/intercepting-siblings/2\"]')\n-            .click()\n-            .waitForElementByCss('#intercepted-sibling')\n-            .text(),\n-        '2'\n-      )\n-      await check(\n-        () =>\n-          browser\n-            .elementByCss('[href=\"/intercepting-siblings/3\"]')\n-            .click()\n-            .waitForElementByCss('#intercepted-sibling')\n-            .text(),\n-        '3'\n-      )\n+        // check if the default view loads\n+        await check(\n+          () => browser.waitForElementByCss('#default-parallel').text(),\n+          'default view for parallel'\n+        )\n \n-      await next.browser('/intercepting-siblings/1')\n+        // check that navigating to /foo re-renders the layout to display @parallel/foo\n+        await check(\n+          () =>\n+            browser\n+              .elementByCss(\n+                `[href=\"/parallel-non-intercepting/foo${trailingSlash ? '/' : ''}\"]`\n+              )\n+              .click()\n+              .waitForElementByCss('#parallel-foo')\n+              .text(),\n+          'parallel for foo'\n+        )\n \n-      await check(() => browser.waitForElementByCss('#main-slot').text(), '1')\n-    })\n+        // check that navigating to /foo also re-renders the base children\n+        await check(() => browser.elementByCss('#children-foo').text(), 'foo')\n+      })\n \n-    it('should intercept on routes that contain hyphenated/special dynamic params', async () => {\n-      const browser = await next.browser(\n-        '/interception-route-special-params/some-random-param'\n-      )\n+      it('should render modal when paired with parallel routes', async () => {\n+        const browser = await next.browser(\n+          `/intercepting-parallel-modal/vercel${trailingSlash ? '/' : ''}`\n+        )\n+        // Check if navigation to modal route works.\n+        await check(\n+          () =>\n+            browser\n+              .elementByCss(\n+                `[href=\"/intercepting-parallel-modal/photo/1${trailingSlash ? '/' : ''}\"]`\n+              )\n+              .click()\n+              .waitForElementByCss('#photo-modal-1')\n+              .text(),\n+          'Photo MODAL 1'\n+        )\n \n-      await browser\n-        .elementByCss(\n-          \"[href='/interception-route-special-params/some-random-param/some-page']\"\n+        await check(\n+          () =>\n+            browser\n+              .elementByCss(\n+                `[href=\"/intercepting-parallel-modal/photo/2${trailingSlash ? '/' : ''}\"]`\n+              )\n+              .click()\n+              .waitForElementByCss('#photo-modal-2')\n+              .text(),\n+          'Photo MODAL 2'\n         )\n-        .click()\n \n-      const interceptionText =\n-        'Hello from [this-is-my-route]/@intercept/some-page. Param: some-random-param'\n-      const pageText =\n-        'Hello from [this-is-my-route]/some-page. Param: some-random-param'\n+        // Check if modal was rendered while existing page content is preserved.\n+        await check(\n+          () => browser.elementByCss('#user-page').text(),\n+          'Feed for vercel'\n+        )\n+\n+        // Check if url matches even though it was intercepted.\n+        await check(\n+          () => browser.url(),\n+          next.url +\n+            '/intercepting-parallel-modal/photo/2' +\n+            (trailingSlash ? '/' : '')\n+        )\n+\n+        // Trigger a refresh, this should load the normal page, not the modal.\n+        await check(\n+          () => browser.refresh().waitForElementByCss('#photo-page-2').text(),\n+          'Photo PAGE 2'\n+        )\n \n-      await retry(async () => {\n-        expect(await browser.elementByCss('body').text()).toContain(\n-          interceptionText\n+        // Check if the url matches still.\n+        await check(\n+          () => browser.url(),\n+          next.url +\n+            '/intercepting-parallel-modal/photo/2' +\n+            (trailingSlash ? '/' : '')\n         )\n+      })\n+\n+      it('should support intercepting with beforeFiles rewrites', async () => {\n+        const browser = await next.browser(`/foo${trailingSlash ? '/' : ''}`)\n \n-        expect(await browser.elementByCss('body').text()).not.toContain(\n-          pageText\n+        await check(\n+          () =>\n+            browser\n+              .elementByCss(`[href=\"/photos${trailingSlash ? '/' : ''}\"]`)\n+              .click()\n+              .waitForElementByCss('#intercepted')\n+              .text(),\n+          'intercepted'\n         )\n       })\n \n-      await browser.refresh()\n+      it('should support intercepting local dynamic sibling routes', async () => {\n+        const browser = await next.browser(\n+          `/intercepting-siblings${trailingSlash ? '/' : ''}`\n+        )\n \n-      await retry(async () => {\n-        expect(await browser.elementByCss('body').text()).toContain(pageText)\n+        await check(\n+          () =>\n+            browser\n+              .elementByCss(\n+                `[href=\"/intercepting-siblings/1${trailingSlash ? '/' : ''}\"]`\n+              )\n+              .click()\n+              .waitForElementByCss('#intercepted-sibling')\n+              .text(),\n+          '1'\n+        )\n+        await check(\n+          () =>\n+            browser\n+              .elementByCss(\n+                `[href=\"/intercepting-siblings/2${trailingSlash ? '/' : ''}\"]`\n+              )\n+              .click()\n+              .waitForElementByCss('#intercepted-sibling')\n+              .text(),\n+          '2'\n+        )\n+        await check(\n+          () =>\n+            browser\n+              .elementByCss(\n+                `[href=\"/intercepting-siblings/3${trailingSlash ? '/' : ''}\"]`\n+              )\n+              .click()\n+              .waitForElementByCss('#intercepted-sibling')\n+              .text(),\n+          '3'\n+        )\n \n-        expect(await browser.elementByCss('body').text()).not.toContain(\n-          interceptionText\n+        await next.browser(\n+          `/intercepting-siblings/1${trailingSlash ? '/' : ''}`\n         )\n+\n+        await check(() => browser.waitForElementByCss('#main-slot').text(), '1')\n       })\n-    })\n \n-    if (isNextStart) {\n-      it('should not have /default paths in the prerender manifest', async () => {\n-        const prerenderManifest = JSON.parse(\n-          await next.readFile('.next/prerender-manifest.json')\n+      it('should intercept on routes that contain hyphenated/special dynamic params', async () => {\n+        const browser = await next.browser(\n+          `/interception-route-special-params/some-random-param${trailingSlash ? '/' : ''}`\n         )\n \n-        const routes = Object.keys(prerenderManifest.routes)\n+        await browser\n+          .elementByCss(\n+            `[href=\"/interception-route-special-params/some-random-param/some-page${trailingSlash ? '/' : ''}\"]`\n+          )\n+          .click()\n \n-        for (const route of routes) {\n-          expect(route.endsWith('/default')).toBe(false)\n-        }\n+        const interceptionText =\n+          'Hello from [this-is-my-route]/@intercept/some-page. Param: some-random-param'\n+        const pageText =\n+          'Hello from [this-is-my-route]/some-page. Param: some-random-param'\n+\n+        await retry(async () => {\n+          expect(await browser.elementByCss('body').text()).toContain(\n+            interceptionText\n+          )\n+\n+          expect(await browser.elementByCss('body').text()).not.toContain(\n+            pageText\n+          )\n+        })\n+\n+        await browser.refresh()\n+\n+        await retry(async () => {\n+          expect(await browser.elementByCss('body').text()).toContain(pageText)\n+\n+          expect(await browser.elementByCss('body').text()).not.toContain(\n+            interceptionText\n+          )\n+        })\n       })\n-    }\n-  })\n-})\n+\n+      if (isNextStart) {\n+        it('should not have /default paths in the prerender manifest', async () => {\n+          const prerenderManifest = JSON.parse(\n+            await next.readFile('.next/prerender-manifest.json')\n+          )\n+\n+          const routes = Object.keys(prerenderManifest.routes)\n+\n+          for (const route of routes) {\n+            expect(route.endsWith('/default')).toBe(false)\n+          }\n+        })\n+      }\n+    })\n+  }\n+)\n \n describe('parallel-routes-and-interception-conflicting-pages', () => {\n   const { next, skipped } = nextTestSetup({\n@@ -935,6 +1069,7 @@ describe('parallel-routes-and-interception-conflicting-pages', () => {\n        }\n       `,\n     },\n+    nextConfig,\n   })\n \n   if (skipped) return"
        }
    ],
    "stats": {
        "total": 1753,
        "additions": 933,
        "deletions": 820
    }
}