{
    "author": "acdlite",
    "message": "[Segment Cache] Re-prefetch links on navigation (#76060)\n\nThe result of certain kinds of prefetches may depend on the current URL\nat the time it is initiated. This is true if for links that are\nintercepted, or links that are prefetched using a dynamic request (e.g.\n`prefetch={true}`). So, whenever the location changes, we should\nre-prefetch all the links using the updated value.\n\nIn most cases, this will not result in any new network requests â€” only\nif the prefetch result actually varies on one of these inputs.\n\nFor similar reasons, we also re-prefetch links whenever the client cache\nis revalidated by a Server Action.\n\nAs part of the implementation, we must be able to enumerate over all the\ncurrently visible links. I've added a Set to track this.",
    "sha": "b98d8f834a1386af01ca704f8f8e0b09d9b79532",
    "files": [
        {
            "sha": "1b5bbb8a199db89d2e464d9402507c219464448a",
            "filename": "packages/next/src/client/app-dir/link.tsx",
            "status": "modified",
            "additions": 66,
            "deletions": 4,
            "changes": 70,
            "blob_url": "https://github.com/vercel/next.js/blob/b98d8f834a1386af01ca704f8f8e0b09d9b79532/packages%2Fnext%2Fsrc%2Fclient%2Fapp-dir%2Flink.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/b98d8f834a1386af01ca704f8f8e0b09d9b79532/packages%2Fnext%2Fsrc%2Fclient%2Fapp-dir%2Flink.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fapp-dir%2Flink.tsx?ref=b98d8f834a1386af01ca704f8f8e0b09d9b79532",
            "patch": "@@ -22,6 +22,8 @@ import {\n import { getCurrentAppRouterState } from '../../shared/lib/router/action-queue'\n import { createCacheKey } from '../components/segment-cache/cache-key'\n import { createPrefetchURL } from '../components/app-router'\n+import type { FlightRouterState } from '../../server/app-render/types'\n+import { getCurrentCacheVersion } from '../components/segment-cache/cache'\n \n type Url = string | UrlObject\n type RequiredKeys<T> = {\n@@ -221,16 +223,25 @@ type LinkInstance = {\n   // already completed.  The same prefetch task object can be reused across\n   // multiple prefetches of the same link.\n   prefetchTask: PrefetchTask | null\n+\n+  // The cache version at the time the task was initiated. This is used to\n+  // determine if the cache was invalidated since the task was initiated.\n+  cacheVersion: number\n }\n \n-// TODO: This is currently a WeakMap because it doesn't need to be enumerable,\n-// but eventually we'll want to be able to re-prefetch all the currently\n-// visible links, e.g. after a revalidation or refresh.\n+// Use a WeakMap to associate a Link instance with its DOM element. This is\n+// used by the IntersectionObserver to track the link's visibility.\n const links:\n   | WeakMap<HTMLAnchorElement | SVGAElement, LinkInstance>\n   | Map<Element, LinkInstance> =\n   typeof WeakMap === 'function' ? new WeakMap() : new Map()\n \n+// A Set of the currently visible links. We re-prefetch visible links after a\n+// cache invalidation, or when the current URL changes. It's a separate data\n+// structure from the WeakMap above because only the visible links need to\n+// be enumerated.\n+const visibleLinks: Set<LinkInstance> = new Set()\n+\n // A single IntersectionObserver instance shared by all <Link> components.\n const observer: IntersectionObserver | null =\n   typeof IntersectionObserver === 'function'\n@@ -274,6 +285,7 @@ function mountLinkInstance(\n     isVisible: false,\n     wasHoveredOrTouched: false,\n     prefetchTask: null,\n+    cacheVersion: -1,\n   }\n   const existingInstance = links.get(element)\n   if (existingInstance !== undefined) {\n@@ -288,10 +300,11 @@ function mountLinkInstance(\n   }\n }\n \n-export function unmountLinkInstance(element: HTMLAnchorElement | SVGAElement) {\n+function unmountLinkInstance(element: HTMLAnchorElement | SVGAElement) {\n   const instance = links.get(element)\n   if (instance !== undefined) {\n     links.delete(element)\n+    visibleLinks.delete(instance)\n     const prefetchTask = instance.prefetchTask\n     if (prefetchTask !== null) {\n       cancelPrefetchTask(prefetchTask)\n@@ -329,6 +342,11 @@ function onLinkVisibilityChanged(\n   }\n \n   instance.isVisible = isVisible\n+  if (isVisible) {\n+    visibleLinks.add(instance)\n+  } else {\n+    visibleLinks.delete(instance)\n+  }\n   rescheduleLinkPrefetch(instance)\n }\n \n@@ -389,6 +407,7 @@ function rescheduleLinkPrefetch(instance: LinkInstance) {\n         instance.kind === PrefetchKind.FULL,\n         priority\n       )\n+      instance.cacheVersion = getCurrentCacheVersion()\n     }\n   } else {\n     // We already have an old task object that we can reschedule. This is\n@@ -397,6 +416,49 @@ function rescheduleLinkPrefetch(instance: LinkInstance) {\n   }\n }\n \n+export function pingVisibleLinks(\n+  nextUrl: string | null,\n+  tree: FlightRouterState\n+) {\n+  // For each currently visible link, cancel the existing prefetch task (if it\n+  // exists) and schedule a new one. This is effectively the same as if all the\n+  // visible links left and then re-entered the viewport.\n+  //\n+  // This is called when the Next-Url or the base tree changes, since those\n+  // may affect the result of a prefetch task. It's also called after a\n+  // cache invalidation.\n+  const currentCacheVersion = getCurrentCacheVersion()\n+  for (const instance of visibleLinks) {\n+    const task = instance.prefetchTask\n+    if (\n+      task !== null &&\n+      instance.cacheVersion === currentCacheVersion &&\n+      task.key.nextUrl === nextUrl &&\n+      task.treeAtTimeOfPrefetch === tree\n+    ) {\n+      // The cache has not been invalidated, and none of the inputs have\n+      // changed. Bail out.\n+      continue\n+    }\n+    // Something changed. Cancel the existing prefetch task and schedule a\n+    // new one.\n+    if (task !== null) {\n+      cancelPrefetchTask(task)\n+    }\n+    const cacheKey = createCacheKey(instance.prefetchHref, nextUrl)\n+    const priority = instance.wasHoveredOrTouched\n+      ? PrefetchPriority.Intent\n+      : PrefetchPriority.Default\n+    instance.prefetchTask = scheduleSegmentPrefetchTask(\n+      cacheKey,\n+      tree,\n+      instance.kind === PrefetchKind.FULL,\n+      priority\n+    )\n+    instance.cacheVersion = getCurrentCacheVersion()\n+  }\n+}\n+\n function prefetchWithOldCacheImplementation(instance: LinkInstance) {\n   // This is the path used when the Segment Cache is not enabled.\n   if (typeof window === 'undefined') {"
        },
        {
            "sha": "cf125386caa4ca8381022fd021f7ae4bda5b55bd",
            "filename": "packages/next/src/client/components/app-router.tsx",
            "status": "modified",
            "additions": 12,
            "deletions": 0,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/b98d8f834a1386af01ca704f8f8e0b09d9b79532/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fapp-router.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/b98d8f834a1386af01ca704f8f8e0b09d9b79532/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fapp-router.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fapp-router.tsx?ref=b98d8f834a1386af01ca704f8f8e0b09d9b79532",
            "patch": "@@ -62,6 +62,7 @@ import { prefetch as prefetchWithSegmentCache } from '../components/segment-cach\n import { getRedirectTypeFromError, getURLFromRedirectError } from './redirect'\n import { isRedirectError, RedirectType } from './redirect-error'\n import { prefetchReducer } from './router-reducer/reducers/prefetch-reducer'\n+import { pingVisibleLinks } from '../app-dir/link'\n \n const globalMutable: {\n   pendingMpaPath?: string\n@@ -142,6 +143,17 @@ function HistoryUpdater({\n       window.history.replaceState(historyState, '', canonicalUrl)\n     }\n   }, [appRouterState])\n+\n+  useEffect(() => {\n+    // The Next-Url and the base tree may affect the result of a prefetch\n+    // task. Re-prefetch all visible links with the updated values. In most\n+    // cases, this will not result in any new network requests, only if\n+    // the prefetch result actually varies on one of these inputs.\n+    if (process.env.__NEXT_CLIENT_SEGMENT_CACHE) {\n+      pingVisibleLinks(appRouterState.nextUrl, appRouterState.tree)\n+    }\n+  }, [appRouterState.nextUrl, appRouterState.tree])\n+\n   return null\n }\n "
        },
        {
            "sha": "1c37a01f26f87a4812e98b81297f25581206f9fa",
            "filename": "packages/next/src/client/components/router-reducer/reducers/refresh-reducer.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/b98d8f834a1386af01ca704f8f8e0b09d9b79532/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Frefresh-reducer.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/b98d8f834a1386af01ca704f8f8e0b09d9b79532/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Frefresh-reducer.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Frefresh-reducer.ts?ref=b98d8f834a1386af01ca704f8f8e0b09d9b79532",
            "patch": "@@ -123,7 +123,7 @@ export function refreshReducer(\n             undefined\n           )\n           if (process.env.__NEXT_CLIENT_SEGMENT_CACHE) {\n-            revalidateEntireCache()\n+            revalidateEntireCache(state.nextUrl, newTree)\n           } else {\n             mutable.prefetchCache = new Map()\n           }"
        },
        {
            "sha": "01c065c6d0b290377a84c9d8f227487729b010ee",
            "filename": "packages/next/src/client/components/router-reducer/reducers/server-action-reducer.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/b98d8f834a1386af01ca704f8f8e0b09d9b79532/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fserver-action-reducer.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/b98d8f834a1386af01ca704f8f8e0b09d9b79532/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fserver-action-reducer.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fserver-action-reducer.ts?ref=b98d8f834a1386af01ca704f8f8e0b09d9b79532",
            "patch": "@@ -340,7 +340,7 @@ export function serverActionReducer(\n \n           mutable.cache = cache\n           if (process.env.__NEXT_CLIENT_SEGMENT_CACHE) {\n-            revalidateEntireCache()\n+            revalidateEntireCache(state.nextUrl, newTree)\n           } else {\n             mutable.prefetchCache = new Map()\n           }"
        },
        {
            "sha": "c123f60ed8a0af8e44f0df5a30d3edeca8726d01",
            "filename": "packages/next/src/client/components/segment-cache/cache.ts",
            "status": "modified",
            "additions": 17,
            "deletions": 1,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/b98d8f834a1386af01ca704f8f8e0b09d9b79532/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fcache.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/b98d8f834a1386af01ca704f8f8e0b09d9b79532/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fcache.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fcache.ts?ref=b98d8f834a1386af01ca704f8f8e0b09d9b79532",
            "patch": "@@ -52,6 +52,7 @@ import type {\n } from '../../../server/app-render/types'\n import { normalizeFlightData } from '../../flight-data-helpers'\n import { STATIC_STALETIME_MS } from '../router-reducer/prefetch-cache-utils'\n+import { pingVisibleLinks } from '../../app-dir/link'\n \n // A note on async/await when working in the prefetch cache:\n //\n@@ -238,13 +239,25 @@ let segmentCacheLru = createLRU<SegmentCacheEntry>(\n   onSegmentLRUEviction\n )\n \n+// Incrementing counter used to track cache invalidations.\n+let currentCacheVersion = 0\n+\n+export function getCurrentCacheVersion(): number {\n+  return currentCacheVersion\n+}\n+\n /**\n  * Used to clear the client prefetch cache when a server action calls\n  * revalidatePath or revalidateTag. Eventually we will support only clearing the\n  * segments that were actually affected, but there's more work to be done on the\n  * server before the client is able to do this correctly.\n  */\n-export function revalidateEntireCache() {\n+export function revalidateEntireCache(\n+  nextUrl: string | null,\n+  tree: FlightRouterState\n+) {\n+  currentCacheVersion++\n+\n   // Clearing the cache also effectively rejects any pending requests, because\n   // when the response is received, it gets written into a cache entry that is\n   // no longer reachable.\n@@ -254,6 +267,9 @@ export function revalidateEntireCache() {\n   routeCacheLru = createLRU(maxRouteLruSize, onRouteLRUEviction)\n   segmentCacheMap = new Map()\n   segmentCacheLru = createLRU(maxSegmentLruSize, onSegmentLRUEviction)\n+\n+  // Prefetch all the currently visible links again, to re-fill the cache.\n+  pingVisibleLinks(nextUrl, tree)\n }\n \n export function readExactRouteCacheEntry("
        },
        {
            "sha": "dbe20faa6571eb78cafabb74d1662f5f37457a38",
            "filename": "test/e2e/app-dir/segment-cache/revalidation/app/refetch-on-new-base-tree/a/page.tsx",
            "status": "added",
            "additions": 15,
            "deletions": 0,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/b98d8f834a1386af01ca704f8f8e0b09d9b79532/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frevalidation%2Fapp%2Frefetch-on-new-base-tree%2Fa%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/b98d8f834a1386af01ca704f8f8e0b09d9b79532/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frevalidation%2Fapp%2Frefetch-on-new-base-tree%2Fa%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frevalidation%2Fapp%2Frefetch-on-new-base-tree%2Fa%2Fpage.tsx?ref=b98d8f834a1386af01ca704f8f8e0b09d9b79532",
            "patch": "@@ -0,0 +1,15 @@\n+import { connection } from 'next/server'\n+import { Suspense } from 'react'\n+\n+async function Content() {\n+  await connection()\n+  return <div id=\"page-a-content\">Page A content</div>\n+}\n+\n+export default async function PageA() {\n+  return (\n+    <Suspense fallback=\"Loading...\">\n+      <Content />\n+    </Suspense>\n+  )\n+}"
        },
        {
            "sha": "fb75357e8df3897a5d389cc0ebf07c7138c971dd",
            "filename": "test/e2e/app-dir/segment-cache/revalidation/app/refetch-on-new-base-tree/b/page.tsx",
            "status": "added",
            "additions": 15,
            "deletions": 0,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/b98d8f834a1386af01ca704f8f8e0b09d9b79532/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frevalidation%2Fapp%2Frefetch-on-new-base-tree%2Fb%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/b98d8f834a1386af01ca704f8f8e0b09d9b79532/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frevalidation%2Fapp%2Frefetch-on-new-base-tree%2Fb%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frevalidation%2Fapp%2Frefetch-on-new-base-tree%2Fb%2Fpage.tsx?ref=b98d8f834a1386af01ca704f8f8e0b09d9b79532",
            "patch": "@@ -0,0 +1,15 @@\n+import { connection } from 'next/server'\n+import { Suspense } from 'react'\n+\n+async function Content() {\n+  await connection()\n+  return <div id=\"page-b-content\">Page B content</div>\n+}\n+\n+export default async function PageB() {\n+  return (\n+    <Suspense fallback=\"Loading...\">\n+      <Content />\n+    </Suspense>\n+  )\n+}"
        },
        {
            "sha": "1f0eef1102b602d917148ee33b89c34ebfaa391d",
            "filename": "test/e2e/app-dir/segment-cache/revalidation/app/refetch-on-new-base-tree/layout.tsx",
            "status": "added",
            "additions": 61,
            "deletions": 0,
            "changes": 61,
            "blob_url": "https://github.com/vercel/next.js/blob/b98d8f834a1386af01ca704f8f8e0b09d9b79532/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frevalidation%2Fapp%2Frefetch-on-new-base-tree%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/b98d8f834a1386af01ca704f8f8e0b09d9b79532/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frevalidation%2Fapp%2Frefetch-on-new-base-tree%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frevalidation%2Fapp%2Frefetch-on-new-base-tree%2Flayout.tsx?ref=b98d8f834a1386af01ca704f8f8e0b09d9b79532",
            "patch": "@@ -0,0 +1,61 @@\n+import { LinkAccordion } from '../../components/link-accordion'\n+\n+export default function RefetchOnNewBaseTreeLayout({\n+  children,\n+}: {\n+  children: React.ReactNode\n+}) {\n+  return (\n+    <>\n+      <div style={{ backgroundColor: 'lightgray', padding: '1rem' }}>\n+        <p>\n+          This demonstrates what happens when a link is prefetched using{' '}\n+          <code>{'prefetch={true}'}</code> and the URL changes. Next.js should\n+          re-prefetch the link in case the delta between the base tree and the\n+          target tree has changed.\n+        </p>\n+        <p>\n+          Everything in this gray section is part of a shared layout. The links\n+          below are prefetched using <code>{'prefetch={true}'}</code>. If the\n+          first loaded page is \"/refetch-on-new-base-tree/a\", the prefetch for\n+          this link will be empty, because there's no delta between the base\n+          tree and the target tree.\n+        </p>\n+        <p>\n+          However, if you then navigate to page B, we should re-prefetch the\n+          link to A, because the delta between the base tree and the target tree\n+          is now different.\n+        </p>\n+        <p>Test steps:</p>\n+        <ul>\n+          <li>Load \"/refetch-on-new-base-tree/a\" in the browser.</li>\n+          <li>\n+            Click the checkboxes to reveal the links. (These exist so the e2e\n+            test can control the timing of the prefetch.)\n+          </li>\n+          <li>\n+            Observe that the prefetch for page A is empty, i.e. the string \"Page\n+            A content\" should not appear anywhere in the response.\n+          </li>\n+          <li>Click the link to page B to navigate away.</li>\n+          <li>\n+            Check the network tab to confirm that a new prefetch for page A was\n+            requested.\n+          </li>\n+          <li>Click the link to page A</li>\n+          <li>\n+            Observe that no new request was made when navigating to page A,\n+            because it was fully prefetched.\n+          </li>\n+        </ul>\n+        <LinkAccordion prefetch={true} href=\"/refetch-on-new-base-tree/a\">\n+          Page A\n+        </LinkAccordion>\n+        <LinkAccordion prefetch={true} href=\"/refetch-on-new-base-tree/b\">\n+          Page B\n+        </LinkAccordion>\n+      </div>\n+      <div>{children}</div>\n+    </>\n+  )\n+}"
        },
        {
            "sha": "fbffe2481812e657be84c0c5c0048d7a107a9ca7",
            "filename": "test/e2e/app-dir/segment-cache/revalidation/app/refetch-on-new-base-tree/page.tsx",
            "status": "added",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/b98d8f834a1386af01ca704f8f8e0b09d9b79532/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frevalidation%2Fapp%2Frefetch-on-new-base-tree%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/b98d8f834a1386af01ca704f8f8e0b09d9b79532/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frevalidation%2Fapp%2Frefetch-on-new-base-tree%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frevalidation%2Fapp%2Frefetch-on-new-base-tree%2Fpage.tsx?ref=b98d8f834a1386af01ca704f8f8e0b09d9b79532",
            "patch": "@@ -0,0 +1,5 @@\n+import { redirect } from 'next/navigation'\n+\n+export default function Page() {\n+  redirect('/refetch-on-new-base-tree/a')\n+}"
        },
        {
            "sha": "c735a55918b5489458940dcdd29daa6f2ec50315",
            "filename": "test/e2e/app-dir/segment-cache/revalidation/components/link-accordion.tsx",
            "status": "modified",
            "additions": 13,
            "deletions": 3,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/b98d8f834a1386af01ca704f8f8e0b09d9b79532/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frevalidation%2Fcomponents%2Flink-accordion.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/b98d8f834a1386af01ca704f8f8e0b09d9b79532/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frevalidation%2Fcomponents%2Flink-accordion.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frevalidation%2Fcomponents%2Flink-accordion.tsx?ref=b98d8f834a1386af01ca704f8f8e0b09d9b79532",
            "patch": "@@ -3,7 +3,15 @@\n import Link from 'next/link'\n import { useState } from 'react'\n \n-export function LinkAccordion({ href, children }) {\n+export function LinkAccordion({\n+  href,\n+  children,\n+  prefetch,\n+}: {\n+  href: string\n+  children: React.ReactNode\n+  prefetch?: boolean\n+}) {\n   const [isVisible, setIsVisible] = useState(false)\n   return (\n     <>\n@@ -14,9 +22,11 @@ export function LinkAccordion({ href, children }) {\n         data-link-accordion={href}\n       />\n       {isVisible ? (\n-        <Link href={href}>{children}</Link>\n+        <Link href={href} prefetch={prefetch}>\n+          {children}\n+        </Link>\n       ) : (\n-        `${children} (link is hidden)`\n+        <>{children} (link is hidden)</>\n       )}\n     </>\n   )"
        },
        {
            "sha": "10c5c45e3cac4ca3d7a2c80b21ebb4347afe7082",
            "filename": "test/e2e/app-dir/segment-cache/revalidation/segment-cache-revalidation.test.ts",
            "status": "modified",
            "additions": 100,
            "deletions": 60,
            "changes": 160,
            "blob_url": "https://github.com/vercel/next.js/blob/b98d8f834a1386af01ca704f8f8e0b09d9b79532/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frevalidation%2Fsegment-cache-revalidation.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/b98d8f834a1386af01ca704f8f8e0b09d9b79532/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frevalidation%2Fsegment-cache-revalidation.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frevalidation%2Fsegment-cache-revalidation.test.ts?ref=b98d8f834a1386af01ca704f8f8e0b09d9b79532",
            "patch": "@@ -13,35 +13,35 @@ describe('segment cache (revalidation)', () => {\n \n   let port = -1\n   let server\n-  let pendingRequests = new Map()\n+  let dataVersions = new Map()\n   let TestLog = createTestLog()\n \n   let next\n   beforeAll(async () => {\n     port = await findPort()\n-    let isFinishedBuilding = false\n     server = createTestDataServer(async (key, res) => {\n-      if (!isFinishedBuilding) {\n-        res.resolve('Initial value during build for: ' + key)\n-        return\n-      }\n-      if (pendingRequests.has(key)) {\n-        throw new Error('Request already pending for: ' + key)\n-      }\n-      pendingRequests.set(key, res)\n+      const currentVersion = dataVersions.get(key)\n+\n+      // Increment the version number each time to track how often the\n+      // server renders.\n+      const nextVersion = currentVersion === undefined ? 1 : currentVersion + 1\n+      dataVersions.set(key, nextVersion)\n+\n+      // Append the version number to the response\n+      const response = `${key} [${nextVersion}]`\n       TestLog.log('REQUEST: ' + key)\n+      res.resolve(response)\n     })\n     server.listen(port)\n \n     next = await createNext({\n       files: __dirname,\n       env: { TEST_DATA_SERVICE_URL: `http://localhost:${port}` },\n     })\n-    isFinishedBuilding = true\n   })\n \n-  afterEach(async () => {\n-    pendingRequests = new Map()\n+  beforeEach(async () => {\n+    dataVersions = new Map()\n     TestLog = createTestLog()\n   })\n \n@@ -59,7 +59,7 @@ describe('segment cache (revalidation)', () => {\n     })\n \n     const linkVisibilityToggle = await browser.elementByCss(\n-      'input[type=\"checkbox\"]'\n+      'input[data-link-accordion=\"/greeting\"]'\n     )\n \n     // Reveal the link the target page to trigger a prefetch\n@@ -68,37 +68,23 @@ describe('segment cache (revalidation)', () => {\n         await linkVisibilityToggle.click()\n       },\n       {\n-        includes: 'Greeting',\n+        includes: 'random-greeting',\n       }\n     )\n \n-    // Hide the link so we can reveal it again later to trigger another\n-    // prefetch task\n-    await linkVisibilityToggle.click()\n-\n     // Perform an action that calls revalidatePath. This should cause the\n-    // corresponding entry to be evicted from the client cache.\n-    await act(async () => {\n-      const revalidateByPath = await browser.elementById('revalidate-by-path')\n-      await revalidateByPath.click()\n-    })\n-\n+    // corresponding entry to be evicted from the client cache, and a new\n+    // prefetch to be requested.\n     await act(\n       async () => {\n-        // Reveal the link\n-        await linkVisibilityToggle.click()\n-\n-        // Because the corresponding entry was evicted from the cache, this\n-        // should trigger a new prefetch.\n-        await TestLog.waitFor(['REQUEST: random-greeting'])\n-\n-        // Fulfill the prefetch request.\n-        await pendingRequests.get('random-greeting').resolve('yo!')\n+        const revalidateByPath = await browser.elementById('revalidate-by-path')\n+        await revalidateByPath.click()\n       },\n       {\n-        includes: 'yo!',\n+        includes: 'random-greeting [1]',\n       }\n     )\n+    TestLog.assert(['REQUEST: random-greeting'])\n \n     // Navigate to the target page.\n     await act(async () => {\n@@ -107,7 +93,7 @@ describe('segment cache (revalidation)', () => {\n       // Navigation should finish immedately because the page is\n       // fully prefetched.\n       const greeting = await browser.elementById('greeting')\n-      expect(await greeting.innerHTML()).toBe('yo!')\n+      expect(await greeting.innerHTML()).toBe('random-greeting [1]')\n     }, 'no-requests')\n   })\n \n@@ -120,46 +106,32 @@ describe('segment cache (revalidation)', () => {\n     })\n \n     const linkVisibilityToggle = await browser.elementByCss(\n-      'input[type=\"checkbox\"]'\n+      'input[data-link-accordion=\"/greeting\"]'\n     )\n \n-    // Reveal the link the target page to trigger a prefetch\n+    // Reveal the link the target page to trigger a prefetch.\n     await act(\n       async () => {\n         await linkVisibilityToggle.click()\n       },\n       {\n-        includes: 'Greeting',\n+        includes: 'random-greeting',\n       }\n     )\n \n-    // Hide the link so we can reveal it again later to trigger another\n-    // prefetch task\n-    await linkVisibilityToggle.click()\n-\n     // Perform an action that calls revalidateTag. This should cause the\n-    // corresponding entry to be evicted from the client cache.\n-    await act(async () => {\n-      const revalidateByPath = await browser.elementById('revalidate-by-tag')\n-      await revalidateByPath.click()\n-    })\n-\n+    // corresponding entry to be evicted from the client cache, and a new\n+    // prefetch to be requested.\n     await act(\n       async () => {\n-        // Reveal the link\n-        await linkVisibilityToggle.click()\n-\n-        // Because the corresponding entry was evicted from the cache, this\n-        // should trigger a new prefetch.\n-        await TestLog.waitFor(['REQUEST: random-greeting'])\n-\n-        // Fulfill the prefetch request.\n-        await pendingRequests.get('random-greeting').resolve('hey!')\n+        const revalidateByTag = await browser.elementById('revalidate-by-tag')\n+        await revalidateByTag.click()\n       },\n       {\n-        includes: 'hey!',\n+        includes: 'random-greeting [1]',\n       }\n     )\n+    TestLog.assert(['REQUEST: random-greeting'])\n \n     // Navigate to the target page.\n     await act(async () => {\n@@ -168,7 +140,75 @@ describe('segment cache (revalidation)', () => {\n       // Navigation should finish immedately because the page is\n       // fully prefetched.\n       const greeting = await browser.elementById('greeting')\n-      expect(await greeting.innerHTML()).toBe('hey!')\n+      expect(await greeting.innerHTML()).toBe('random-greeting [1]')\n     }, 'no-requests')\n   })\n+\n+  it('re-fetch visible links after a navigation, if needed', async () => {\n+    let act: ReturnType<typeof createRouterAct>\n+    const browser = await next.browser('/refetch-on-new-base-tree/a', {\n+      beforePageLoad(page: Playwright.Page) {\n+        act = createRouterAct(page)\n+      },\n+    })\n+\n+    const linkALinkVisibilityToggle = await browser.elementByCss(\n+      'input[data-link-accordion=\"/refetch-on-new-base-tree/a\"]'\n+    )\n+    const linkBLinkVisibilityToggle = await browser.elementByCss(\n+      'input[data-link-accordion=\"/refetch-on-new-base-tree/b\"]'\n+    )\n+\n+    // Reveal the links to trigger prefetches\n+    await act(async () => {\n+      await linkALinkVisibilityToggle.click()\n+      await linkBLinkVisibilityToggle.click()\n+    }, [\n+      // Page B's content should have been prefetched\n+      {\n+        includes: 'Page B content',\n+      },\n+      // Page A's content should not be prefetched because we're already on that\n+      // page. When prefetching with `prefetch={true}`, we only prefetch the\n+      // delta between the current route and the target route.\n+      {\n+        includes: 'Page A content',\n+        block: 'reject',\n+      },\n+    ])\n+\n+    // Navigate to page B\n+    await act(\n+      async () => {\n+        const link = await browser.elementByCss(\n+          'a[href=\"/refetch-on-new-base-tree/b\"]'\n+        )\n+        await link.click()\n+        const content = await browser.elementById('page-b-content')\n+        expect(await content.innerHTML()).toBe('Page B content')\n+      },\n+      // The link for page A is re-prefetched again, even though it's an\n+      // existing link, because the delta between the current route and the\n+      // target route has changed.\n+      //\n+      // This time, the response does include the content for page A.\n+      {\n+        includes: 'Page A content',\n+      }\n+    )\n+\n+    // Navigate to page A\n+    await act(\n+      async () => {\n+        const link = await browser.elementByCss(\n+          'a[href=\"/refetch-on-new-base-tree/a\"]'\n+        )\n+        await link.click()\n+        const content = await browser.elementById('page-a-content')\n+        expect(await content.innerHTML()).toBe('Page A content')\n+      },\n+      // There should be no new requests because everything is fully prefetched.\n+      'no-requests'\n+    )\n+  })\n })"
        }
    ],
    "stats": {
        "total": 376,
        "additions": 306,
        "deletions": 70
    }
}