{
    "author": "lukesandberg",
    "message": "[turbopack] Enable the filesystem cache for dev in canary builds (#85940)\n\nEnable the filesystem cache in canary builds in preparation for enabling it by default in the next release.\n\nIt can still be disabled by explicitly setting the option to `false`.\n\nFlipping it for all users is deferred to #85975 so as not to interfere with potential patch releases.\n\nAlso fix the filesystem caching test that was accidentally disabled in #84632 due to the file rename.",
    "sha": "fd7838e95dd4d07b3218d3eab069277614f59147",
    "files": [
        {
            "sha": "0f6a53025cdb08ddc8a7430d694e7b1010f3fbd1",
            "filename": "packages/next/src/server/config-shared.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/fd7838e95dd4d07b3218d3eab069277614f59147/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/fd7838e95dd4d07b3218d3eab069277614f59147/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts?ref=fd7838e95dd4d07b3218d3eab069277614f59147",
            "patch": "@@ -427,6 +427,8 @@ export interface ExperimentalConfig {\n \n   /**\n    * Enable filesystem cache for the turbopack dev server.\n+   *\n+   * Defaults to `true` in canary releases.\n    */\n   turbopackFileSystemCacheForDev?: boolean\n \n@@ -1548,6 +1550,8 @@ export const defaultConfig = Object.freeze({\n     proxyClientMaxBodySize: 10_485_760, // 10MB\n     hideLogsAfterAbort: false,\n     mcpServer: true,\n+    turbopackFileSystemCacheForDev: !isStableBuild(),\n+    turbopackFileSystemCacheForBuild: false,\n   },\n   htmlLimitedBots: undefined,\n   bundlePagesRouterDependencies: false,"
        },
        {
            "sha": "741452c4d892028b372b2b2e62bb6df0c8baec0e",
            "filename": "packages/next/src/server/config.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/fd7838e95dd4d07b3218d3eab069277614f59147/packages%2Fnext%2Fsrc%2Fserver%2Fconfig.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/fd7838e95dd4d07b3218d3eab069277614f59147/packages%2Fnext%2Fsrc%2Fserver%2Fconfig.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fconfig.ts?ref=fd7838e95dd4d07b3218d3eab069277614f59147",
            "patch": "@@ -400,7 +400,7 @@ function assignDefaultsAndValidate(\n \n   if (isStableBuild()) {\n     // Prevents usage of certain experimental features outside of canary\n-    if (result.experimental?.turbopackFileSystemCacheForBuild) {\n+    if (result.experimental.turbopackFileSystemCacheForBuild) {\n       throw new CanaryOnlyConfigError({\n         feature: 'experimental.turbopackFileSystemCacheForBuild',\n       })"
        },
        {
            "sha": "38e11cbd7974d0647c28b775c1cc40981fbeeb62",
            "filename": "test/e2e/filesystem-cache/filesystem-cache.test.ts",
            "status": "added",
            "additions": 313,
            "deletions": 0,
            "changes": 313,
            "blob_url": "https://github.com/vercel/next.js/blob/fd7838e95dd4d07b3218d3eab069277614f59147/test%2Fe2e%2Ffilesystem-cache%2Ffilesystem-cache.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/fd7838e95dd4d07b3218d3eab069277614f59147/test%2Fe2e%2Ffilesystem-cache%2Ffilesystem-cache.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Ffilesystem-cache%2Ffilesystem-cache.test.ts?ref=fd7838e95dd4d07b3218d3eab069277614f59147",
            "patch": "@@ -0,0 +1,313 @@\n+import { nextTestSetup, isNextDev } from 'e2e-utils'\n+import { waitFor } from 'next-test-utils'\n+\n+process.env.NEXT_PUBLIC_ENV_VAR = 'hello world'\n+// Make it easier to run in development, test directories are cleared between runs already so this is safe.\n+process.env.TURBO_ENGINE_IGNORE_DIRTY = '1'\n+// decrease the idle timeout to make the test more reliable\n+process.env.TURBO_ENGINE_SNAPSHOT_IDLE_TIMEOUT_MILLIS = '1000'\n+\n+for (const cacheEnabled of [false, true]) {\n+  describe(`filesystem-caching with cache ${cacheEnabled ? 'enabled' : 'disabled'}`, () => {\n+    const { skipped, next, isTurbopack } = nextTestSetup({\n+      files: __dirname,\n+      skipDeployment: true,\n+      packageJson: {\n+        scripts: {\n+          build: `ENABLE_CACHING=${cacheEnabled ? '1' : ''} next build`,\n+          dev: `ENABLE_CACHING=${cacheEnabled ? '1' : ''} next dev`,\n+          start: 'next start',\n+        },\n+      },\n+      // We need to use npm here as pnpms symlinks trigger a weird bug (kernel bug?)\n+      installCommand: 'npm i',\n+      // Next is always started with caching, but this can disable it for the followup restarts\n+      buildCommand: `npm run build`,\n+      startCommand: isNextDev ? 'npm run dev' : 'npm run start',\n+    })\n+\n+    if (skipped) {\n+      return\n+    }\n+\n+    beforeAll(() => {\n+      // We can skip the dev watch delay since this is not an HMR test\n+      ;(next as any).handleDevWatchDelayBeforeChange = () => {}\n+      ;(next as any).handleDevWatchDelayAfterChange = () => {}\n+    })\n+\n+    async function restartCycle() {\n+      await stop()\n+      await start()\n+    }\n+\n+    async function stop() {\n+      if (isNextDev) {\n+        // Give FileSystem Cache time to write to disk\n+        // Turbopack is configured to wait 1s above.\n+        // Webpack has an idle timeout (after large changes) of 1s\n+        // and we give time a bit more to allow writing to disk\n+        await waitFor(3000)\n+      }\n+      await next.stop()\n+    }\n+\n+    async function start() {\n+      await next.start()\n+    }\n+\n+    it('should cache or not cache loaders', async () => {\n+      let appTimestamp, unchangedTimestamp, appClientTimestamp, pagesTimestamp\n+      {\n+        const browser = await next.browser('/')\n+        appTimestamp = await browser.elementByCss('main').text()\n+        expect(appTimestamp).toMatch(/Timestamp = \\d+$/)\n+        await browser.close()\n+      }\n+      {\n+        const browser = await next.browser('/unchanged')\n+        unchangedTimestamp = await browser.elementByCss('main').text()\n+        expect(unchangedTimestamp).toMatch(/Timestamp = \\d+$/)\n+        await browser.close()\n+      }\n+      {\n+        const browser = await next.browser('/client')\n+        appClientTimestamp = await browser.elementByCss('main').text()\n+        expect(appClientTimestamp).toMatch(/Timestamp = \\d+$/)\n+        await browser.close()\n+      }\n+      {\n+        const browser = await next.browser('/pages')\n+        pagesTimestamp = await browser.elementByCss('main').text()\n+        expect(pagesTimestamp).toMatch(/Timestamp = \\d+$/)\n+        await browser.close()\n+      }\n+      await restartCycle()\n+\n+      {\n+        const browser = await next.browser('/')\n+        const newTimestamp = await browser.elementByCss('main').text()\n+        expect(newTimestamp).toMatch(/Timestamp = \\d+$/)\n+        if (cacheEnabled) {\n+          expect(newTimestamp).toBe(appTimestamp)\n+        } else {\n+          expect(newTimestamp).not.toBe(appTimestamp)\n+        }\n+        await browser.close()\n+      }\n+      {\n+        const browser = await next.browser('/unchanged')\n+        const newTimestamp = await browser.elementByCss('main').text()\n+        expect(newTimestamp).toMatch(/Timestamp = \\d+$/)\n+        if (cacheEnabled) {\n+          expect(newTimestamp).toBe(unchangedTimestamp)\n+        } else {\n+          expect(newTimestamp).not.toBe(unchangedTimestamp)\n+        }\n+        await browser.close()\n+      }\n+      {\n+        const browser = await next.browser('/client')\n+        const newTimestamp = await browser.elementByCss('main').text()\n+        expect(newTimestamp).toMatch(/Timestamp = \\d+$/)\n+        if (cacheEnabled) {\n+          expect(newTimestamp).toBe(appClientTimestamp)\n+        } else {\n+          expect(newTimestamp).not.toBe(appClientTimestamp)\n+        }\n+        await browser.close()\n+      }\n+      {\n+        const browser = await next.browser('/pages')\n+        const newTimestamp = await browser.elementByCss('main').text()\n+        expect(newTimestamp).toMatch(/Timestamp = \\d+$/)\n+        if (cacheEnabled) {\n+          expect(newTimestamp).toBe(pagesTimestamp)\n+        } else {\n+          expect(newTimestamp).not.toBe(pagesTimestamp)\n+        }\n+        await browser.close()\n+      }\n+    })\n+\n+    function makeTextCheck(url: string, text: string) {\n+      return textCheck.bind(null, url, text)\n+    }\n+\n+    async function textCheck(url: string, text: string) {\n+      const browser = await next.browser(url)\n+      expect(await browser.elementByCss('p').text()).toBe(text)\n+      await browser.close()\n+    }\n+\n+    function makeFileEdit(file: string) {\n+      return async (inner: () => Promise<void>) => {\n+        await next.patchFile(\n+          file,\n+          (content) => {\n+            return content.replace('hello world', 'hello filesystem cache')\n+          },\n+          inner\n+        )\n+      }\n+    }\n+\n+    interface Change {\n+      checkInitial(): Promise<void>\n+      withChange(previous: () => Promise<void>): Promise<void>\n+      checkChanged(): Promise<void>\n+      fullInvalidation?: boolean\n+    }\n+    const POTENTIAL_CHANGES: Record<string, Change> = {\n+      'RSC change': {\n+        checkInitial: makeTextCheck('/', 'hello world'),\n+        withChange: makeFileEdit('app/page.tsx'),\n+        checkChanged: makeTextCheck('/', 'hello filesystem cache'),\n+      },\n+      'RCC change': {\n+        checkInitial: makeTextCheck('/client', 'hello world'),\n+        withChange: makeFileEdit('app/client/page.tsx'),\n+        checkChanged: makeTextCheck('/client', 'hello filesystem cache'),\n+      },\n+      'Pages change': {\n+        checkInitial: makeTextCheck('/pages', 'hello world'),\n+        withChange: makeFileEdit('pages/pages.tsx'),\n+        checkChanged: makeTextCheck('/pages', 'hello filesystem cache'),\n+      },\n+      'rename app page': {\n+        checkInitial: makeTextCheck('/remove-me', 'hello world'),\n+        async withChange(inner) {\n+          await next.renameFolder('app/remove-me', 'app/add-me')\n+          try {\n+            await inner()\n+          } finally {\n+            await next.renameFolder('app/add-me', 'app/remove-me')\n+          }\n+        },\n+        checkChanged: makeTextCheck('/add-me', 'hello world'),\n+      },\n+      // TODO fix this case with Turbopack\n+      ...(isTurbopack\n+        ? {}\n+        : {\n+            'loader change': {\n+              async checkInitial() {\n+                await textCheck('/loader', 'hello world')\n+                await textCheck('/loader/client', 'hello world')\n+              },\n+              withChange: makeFileEdit('my-loader.js'),\n+              async checkChanged() {\n+                await textCheck('/loader', 'hello filesystem cache')\n+                await textCheck('/loader/client', 'hello filesystem cache')\n+              },\n+              fullInvalidation: !isTurbopack,\n+            },\n+          }),\n+      'next config change': {\n+        async checkInitial() {\n+          await textCheck('/next-config', 'hello world')\n+          await textCheck('/next-config/client', 'hello world')\n+        },\n+        withChange: makeFileEdit('next.config.js'),\n+        async checkChanged() {\n+          await textCheck('/next-config', 'hello filesystem cache')\n+          await textCheck('/next-config/client', 'hello filesystem cache')\n+        },\n+        fullInvalidation: !isTurbopack,\n+      },\n+      'env var change': {\n+        async checkInitial() {\n+          await textCheck('/env', 'hello world')\n+          await textCheck('/env/client', 'hello world')\n+        },\n+        async withChange(inner) {\n+          process.env.NEXT_PUBLIC_ENV_VAR = 'hello filesystem cache'\n+          try {\n+            await inner()\n+          } finally {\n+            process.env.NEXT_PUBLIC_ENV_VAR = 'hello world'\n+          }\n+        },\n+        async checkChanged() {\n+          await textCheck('/env', 'hello filesystem cache')\n+          await textCheck('/env/client', 'hello filesystem cache')\n+        },\n+      },\n+    } as const\n+\n+    // Checking only single change and all combined for performance reasons.\n+    const combinations = Object.entries(POTENTIAL_CHANGES).map(([k, v]) => [\n+      k,\n+      [v],\n+    ]) as Array<[string, Array<Change>]>\n+    combinations.push([\n+      Object.keys(POTENTIAL_CHANGES).join(', '),\n+      Object.values(POTENTIAL_CHANGES),\n+    ])\n+\n+    for (const [name, changes] of combinations) {\n+      it(`should allow to change files while stopped (${name})`, async () => {\n+        let fullInvalidation = !cacheEnabled\n+        for (const change of changes) {\n+          await change.checkInitial()\n+          if (change.fullInvalidation) {\n+            fullInvalidation = true\n+          }\n+        }\n+\n+        let unchangedTimestamp: string\n+        if (!fullInvalidation) {\n+          const browser = await next.browser('/unchanged')\n+          unchangedTimestamp = await browser.elementByCss('main').text()\n+          expect(unchangedTimestamp).toMatch(/Timestamp = \\d+$/)\n+          await browser.close()\n+        }\n+\n+        async function checkChanged() {\n+          for (const change of changes) {\n+            await change.checkChanged()\n+          }\n+\n+          if (!fullInvalidation) {\n+            const browser = await next.browser('/unchanged')\n+            const timestamp = await browser.elementByCss('main').text()\n+            expect(unchangedTimestamp).toEqual(timestamp)\n+            await browser.close()\n+          }\n+        }\n+\n+        await stop()\n+\n+        async function inner() {\n+          await start()\n+          await checkChanged()\n+          // Some no-op change builds\n+          for (let i = 0; i < 2; i++) {\n+            await restartCycle()\n+            await checkChanged()\n+          }\n+          await stop()\n+        }\n+\n+        let current = inner\n+        for (const change of changes) {\n+          const prev = current\n+          current = () => change.withChange(prev)\n+        }\n+        await current()\n+\n+        await start()\n+        for (const change of changes) {\n+          await change.checkInitial()\n+        }\n+\n+        if (!fullInvalidation) {\n+          const browser = await next.browser('/unchanged')\n+          const timestamp = await browser.elementByCss('main').text()\n+          expect(unchangedTimestamp).toEqual(timestamp)\n+          await browser.close()\n+        }\n+      }, 200000)\n+    }\n+  })\n+}"
        },
        {
            "sha": "e27687c4f74f62058be59655b02e3f1baeb12dc3",
            "filename": "test/e2e/filesystem-cache/filesystem-cache.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 268,
            "changes": 268,
            "blob_url": "https://github.com/vercel/next.js/blob/0daf66739d28439d009ec9e3b1bf76d3eaa0731e/test%2Fe2e%2Ffilesystem-cache%2Ffilesystem-cache.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/0daf66739d28439d009ec9e3b1bf76d3eaa0731e/test%2Fe2e%2Ffilesystem-cache%2Ffilesystem-cache.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Ffilesystem-cache%2Ffilesystem-cache.ts?ref=0daf66739d28439d009ec9e3b1bf76d3eaa0731e",
            "patch": "@@ -1,268 +0,0 @@\n-import { nextTestSetup, isNextDev } from 'e2e-utils'\n-import { waitFor } from 'next-test-utils'\n-\n-describe('persistent-caching', () => {\n-  process.env.NEXT_PUBLIC_ENV_VAR = 'hello world'\n-  const { skipped, next, isTurbopack } = nextTestSetup({\n-    files: __dirname,\n-    skipDeployment: true,\n-    // We need to use npm here as pnpms symlinks trigger a weird bug (kernel bug?)\n-    installCommand: 'npm i',\n-    buildCommand: 'npm exec next build',\n-    startCommand: isNextDev ? 'npm exec next dev' : 'npm exec next start',\n-  })\n-\n-  if (skipped) {\n-    return\n-  }\n-\n-  beforeAll(() => {\n-    // We can skip the dev watch delay since this is not an HMR test\n-    ;(next as any).handleDevWatchDelayBeforeChange = () => {}\n-    ;(next as any).handleDevWatchDelayAfterChange = () => {}\n-  })\n-\n-  async function restartCycle() {\n-    await stop()\n-    await start()\n-  }\n-\n-  async function stop() {\n-    if (isNextDev) {\n-      // Give FileSystem Cache time to write to disk\n-      // Turbopack has an idle timeout of 2s\n-      // Webpack has an idle timeout (after large changes) of 1s\n-      // and we give time a bit more to allow writing to disk\n-      await waitFor(3000)\n-    }\n-    await next.stop()\n-  }\n-\n-  async function start() {\n-    await next.start()\n-  }\n-\n-  it('should filesystem cache loaders', async () => {\n-    let appTimestamp, unchangedTimestamp, appClientTimestamp, pagesTimestamp\n-    {\n-      const browser = await next.browser('/')\n-      appTimestamp = await browser.elementByCss('main').text()\n-      expect(appTimestamp).toMatch(/Timestamp = \\d+$/)\n-      await browser.close()\n-    }\n-    {\n-      const browser = await next.browser('/unchanged')\n-      unchangedTimestamp = await browser.elementByCss('main').text()\n-      expect(unchangedTimestamp).toMatch(/Timestamp = \\d+$/)\n-      await browser.close()\n-    }\n-    {\n-      const browser = await next.browser('/client')\n-      appClientTimestamp = await browser.elementByCss('main').text()\n-      expect(appClientTimestamp).toMatch(/Timestamp = \\d+$/)\n-      await browser.close()\n-    }\n-    {\n-      const browser = await next.browser('/pages')\n-      pagesTimestamp = await browser.elementByCss('main').text()\n-      expect(pagesTimestamp).toMatch(/Timestamp = \\d+$/)\n-      await browser.close()\n-    }\n-    await restartCycle()\n-\n-    {\n-      const browser = await next.browser('/')\n-      expect(await browser.elementByCss('main').text()).toBe(appTimestamp)\n-      await browser.close()\n-    }\n-    {\n-      const browser = await next.browser('/unchanged')\n-      expect(await browser.elementByCss('main').text()).toBe(unchangedTimestamp)\n-      await browser.close()\n-    }\n-    {\n-      const browser = await next.browser('/client')\n-      expect(await browser.elementByCss('main').text()).toBe(appClientTimestamp)\n-      await browser.close()\n-    }\n-    {\n-      const browser = await next.browser('/pages')\n-      expect(await browser.elementByCss('main').text()).toBe(pagesTimestamp)\n-      await browser.close()\n-    }\n-  })\n-\n-  function makeTextCheck(url: string, text: string) {\n-    return textCheck.bind(null, url, text)\n-  }\n-\n-  async function textCheck(url: string, text: string) {\n-    const browser = await next.browser(url)\n-    expect(await browser.elementByCss('p').text()).toBe(text)\n-    await browser.close()\n-  }\n-\n-  function makeFileEdit(file: string) {\n-    return async (inner: () => Promise<void>) => {\n-      await next.patchFile(\n-        file,\n-        (content) => {\n-          return content.replace('hello world', 'hello filesystem cache')\n-        },\n-        inner\n-      )\n-    }\n-  }\n-\n-  const POTENTIAL_CHANGES = {\n-    'RSC change': {\n-      checkInitial: makeTextCheck('/', 'hello world'),\n-      withChange: makeFileEdit('app/page.tsx'),\n-      checkChanged: makeTextCheck('/', 'hello filesystem cache'),\n-    },\n-    'RCC change': {\n-      checkInitial: makeTextCheck('/client', 'hello world'),\n-      withChange: makeFileEdit('app/client/page.tsx'),\n-      checkChanged: makeTextCheck('/client', 'hello filesystem cache'),\n-    },\n-    'Pages change': {\n-      checkInitial: makeTextCheck('/pages', 'hello world'),\n-      withChange: makeFileEdit('pages/pages.tsx'),\n-      checkChanged: makeTextCheck('/pages', 'hello filesystem cache'),\n-    },\n-    'rename app page': {\n-      checkInitial: makeTextCheck('/remove-me', 'hello world'),\n-      async withChange(inner) {\n-        await next.renameFolder('app/remove-me', 'app/add-me')\n-        try {\n-          await inner()\n-        } finally {\n-          await next.renameFolder('app/add-me', 'app/remove-me')\n-        }\n-      },\n-      checkChanged: makeTextCheck('/add-me', 'hello world'),\n-    },\n-    // TODO fix this case with Turbopack\n-    ...(isTurbopack\n-      ? {}\n-      : {\n-          'loader change': {\n-            async checkInitial() {\n-              await textCheck('/loader', 'hello world')\n-              await textCheck('/loader/client', 'hello world')\n-            },\n-            withChange: makeFileEdit('my-loader.js'),\n-            async checkChanged() {\n-              await textCheck('/loader', 'hello filesystem cache')\n-              await textCheck('/loader/client', 'hello filesystem cache')\n-            },\n-            fullInvalidation: !isTurbopack,\n-          },\n-        }),\n-    'next config change': {\n-      async checkInitial() {\n-        await textCheck('/next-config', 'hello world')\n-        await textCheck('/next-config/client', 'hello world')\n-      },\n-      withChange: makeFileEdit('next.config.js'),\n-      async checkChanged() {\n-        await textCheck('/next-config', 'hello filesystem cache')\n-        await textCheck('/next-config/client', 'hello filesystem cache')\n-      },\n-      fullInvalidation: !isTurbopack,\n-    },\n-    'env var change': {\n-      async checkInitial() {\n-        await textCheck('/env', 'hello world')\n-        await textCheck('/env/client', 'hello world')\n-      },\n-      async withChange(inner) {\n-        process.env.NEXT_PUBLIC_ENV_VAR = 'hello filesystem cache'\n-        try {\n-          await inner()\n-        } finally {\n-          process.env.NEXT_PUBLIC_ENV_VAR = 'hello world'\n-        }\n-      },\n-      async checkChanged() {\n-        await textCheck('/env', 'hello filesystem cache')\n-        await textCheck('/env/client', 'hello filesystem cache')\n-      },\n-    },\n-  }\n-\n-  const KEYS = Object.keys(POTENTIAL_CHANGES)\n-  for (let bitset = 1; bitset < 1 << KEYS.length; bitset++) {\n-    let combination = []\n-    for (let i = 0; i < KEYS.length; i++) {\n-      if (bitset & (1 << i)) {\n-        combination.push(KEYS[i])\n-      }\n-    }\n-    // Checking only single change and all combined for performance reasons.\n-    if (combination.length !== 1 && combination.length !== KEYS.length) continue\n-\n-    it(`should allow to change files while stopped (${combination.join(', ')})`, async () => {\n-      let fullInvalidation = false\n-      for (const key of combination) {\n-        await POTENTIAL_CHANGES[key].checkInitial()\n-        if (POTENTIAL_CHANGES[key].fullInvalidation) {\n-          fullInvalidation = true\n-        }\n-      }\n-\n-      let unchangedTimestamp\n-      if (!fullInvalidation) {\n-        const browser = await next.browser('/unchanged')\n-        unchangedTimestamp = await browser.elementByCss('main').text()\n-        expect(unchangedTimestamp).toMatch(/Timestamp = \\d+$/)\n-        await browser.close()\n-      }\n-\n-      async function checkChanged() {\n-        for (const key of combination) {\n-          await POTENTIAL_CHANGES[key].checkChanged()\n-        }\n-\n-        if (!fullInvalidation) {\n-          const browser = await next.browser('/unchanged')\n-          const timestamp = await browser.elementByCss('main').text()\n-          expect(unchangedTimestamp).toEqual(timestamp)\n-          await browser.close()\n-        }\n-      }\n-\n-      await stop()\n-\n-      async function inner() {\n-        await start()\n-        await checkChanged()\n-        // Some no-op change builds\n-        for (let i = 0; i < 2; i++) {\n-          await restartCycle()\n-          await checkChanged()\n-        }\n-        await stop()\n-      }\n-\n-      let current = inner\n-      for (const key of combination) {\n-        const prev = current\n-        current = () => POTENTIAL_CHANGES[key].withChange(prev)\n-      }\n-      await current()\n-\n-      await start()\n-      for (const key of combination) {\n-        await POTENTIAL_CHANGES[key].checkInitial()\n-      }\n-\n-      if (!fullInvalidation) {\n-        const browser = await next.browser('/unchanged')\n-        const timestamp = await browser.elementByCss('main').text()\n-        expect(unchangedTimestamp).toEqual(timestamp)\n-        await browser.close()\n-      }\n-    }, 200000)\n-  }\n-})"
        },
        {
            "sha": "89f644ec2b2cc37f6b28672459eb7efda0c7c0fa",
            "filename": "test/e2e/filesystem-cache/next.config.js",
            "status": "modified",
            "additions": 15,
            "deletions": 4,
            "changes": 19,
            "blob_url": "https://github.com/vercel/next.js/blob/fd7838e95dd4d07b3218d3eab069277614f59147/test%2Fe2e%2Ffilesystem-cache%2Fnext.config.js",
            "raw_url": "https://github.com/vercel/next.js/raw/fd7838e95dd4d07b3218d3eab069277614f59147/test%2Fe2e%2Ffilesystem-cache%2Fnext.config.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Ffilesystem-cache%2Fnext.config.js?ref=fd7838e95dd4d07b3218d3eab069277614f59147",
            "patch": "@@ -1,3 +1,5 @@\n+const enableCaching = !!process.env.ENABLE_CACHING\n+\n /**\n  * @type {import('next').NextConfig}\n  */\n@@ -15,10 +17,14 @@ const nextConfig = {\n       },\n     },\n   },\n-  experimental: {\n-    turbopackFileSystemCacheForDev: true,\n-    turbopackFileSystemCacheForBuild: true,\n-  },\n+  experimental: enableCaching\n+    ? {\n+        turbopackFileSystemCacheForBuild: true,\n+      }\n+    : {\n+        turbopackFileSystemCacheForDev: false,\n+        turbopackFileSystemCacheForBuild: false,\n+      },\n   env: {\n     NEXT_PUBLIC_CONFIG_ENV: 'hello world',\n   },\n@@ -31,6 +37,11 @@ const nextConfig = {\n       test: /app\\/loader(?:\\/client)?\\/page\\.tsx/,\n       use: ['./my-loader.js'],\n     })\n+    if (enableCaching) {\n+      config.cache = Object.freeze({\n+        type: 'memory',\n+      })\n+    }\n     if (dev) {\n       // Make webpack consider the build as large change which makes it filesystem cache it sooner\n       config.plugins.push((compiler) => {"
        },
        {
            "sha": "e3f8530e084bac3ec3c3c67312e825c1635ca7d4",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 15,
            "deletions": 6,
            "changes": 21,
            "blob_url": "https://github.com/vercel/next.js/blob/fd7838e95dd4d07b3218d3eab069277614f59147/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/fd7838e95dd4d07b3218d3eab069277614f59147/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=fd7838e95dd4d07b3218d3eab069277614f59147",
            "patch": "@@ -12,7 +12,7 @@ use std::{\n     ops::Range,\n     pin::Pin,\n     sync::{\n-        Arc,\n+        Arc, LazyLock,\n         atomic::{AtomicBool, AtomicU64, AtomicUsize, Ordering},\n     },\n };\n@@ -72,6 +72,16 @@ use crate::{\n \n const SNAPSHOT_REQUESTED_BIT: usize = 1 << (usize::BITS - 1);\n \n+/// Configurable idle timeout for snapshot persistence.\n+/// Defaults to 2 seconds if not set or if the value is invalid.\n+static IDLE_TIMEOUT: LazyLock<Duration> = LazyLock::new(|| {\n+    std::env::var(\"TURBO_ENGINE_SNAPSHOT_IDLE_TIMEOUT_MILLIS\")\n+        .ok()\n+        .and_then(|v| v.parse::<u64>().ok())\n+        .map(Duration::from_millis)\n+        .unwrap_or(Duration::from_secs(2))\n+});\n+\n struct SnapshotRequest {\n     snapshot_requested: bool,\n     suspended_operations: FxHashSet<PtrEqArc<AnyOperation>>,\n@@ -2470,8 +2480,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                     loop {\n                         const FIRST_SNAPSHOT_WAIT: Duration = Duration::from_secs(300);\n                         const SNAPSHOT_INTERVAL: Duration = Duration::from_secs(120);\n-                        const IDLE_TIMEOUT: Duration = Duration::from_secs(2);\n-\n+                        let idle_timeout = *IDLE_TIMEOUT;\n                         let (time, mut reason) =\n                             if matches!(job, TurboTasksBackendJob::InitialSnapshot) {\n                                 (FIRST_SNAPSHOT_WAIT, \"initial snapshot timeout\")\n@@ -2488,7 +2497,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                             let mut idle_start_listener = self.idle_start_event.listen();\n                             let mut idle_end_listener = self.idle_end_event.listen();\n                             let mut idle_time = if turbo_tasks.is_idle() {\n-                                Instant::now() + IDLE_TIMEOUT\n+                                Instant::now() + idle_timeout\n                             } else {\n                                 far_future()\n                             };\n@@ -2498,11 +2507,11 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                                         return;\n                                     },\n                                     _ = &mut idle_start_listener => {\n-                                        idle_time = Instant::now() + IDLE_TIMEOUT;\n+                                        idle_time = Instant::now() + idle_timeout;\n                                         idle_start_listener = self.idle_start_event.listen()\n                                     },\n                                     _ = &mut idle_end_listener => {\n-                                        idle_time = until + IDLE_TIMEOUT;\n+                                        idle_time = until + idle_timeout;\n                                         idle_end_listener = self.idle_end_event.listen()\n                                     },\n                                     _ = tokio::time::sleep_until(until) => {"
        }
    ],
    "stats": {
        "total": 627,
        "additions": 348,
        "deletions": 279
    }
}