{
    "author": "mischnic",
    "message": "Turbopack: fixup route hashes generation (#86502)\n\nPreviously, it tried to compute the hash of some pages router endpoints, even they weren't in the graph (because there is no `pages` folder)",
    "sha": "e64be50becbdcd795a10921983fe48534802b338",
    "files": [
        {
            "sha": "3ef10e5a74d906962f94c94fa0e175a0514d5e20",
            "filename": "crates/next-api/src/project.rs",
            "status": "modified",
            "additions": 26,
            "deletions": 8,
            "changes": 34,
            "blob_url": "https://github.com/vercel/next.js/blob/e64be50becbdcd795a10921983fe48534802b338/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e64be50becbdcd795a10921983fe48534802b338/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fproject.rs?ref=e64be50becbdcd795a10921983fe48534802b338",
            "patch": "@@ -83,7 +83,10 @@ use crate::{\n     instrumentation::InstrumentationEndpoint,\n     middleware::MiddlewareEndpoint,\n     pages::PagesProject,\n-    route::{Endpoint, EndpointGroup, EndpointGroupKey, EndpointGroups, Endpoints, Route},\n+    route::{\n+        Endpoint, EndpointGroup, EndpointGroupEntry, EndpointGroupKey, EndpointGroups, Endpoints,\n+        Route,\n+    },\n     versioned_content_map::VersionedContentMap,\n };\n \n@@ -936,9 +939,18 @@ impl Project {\n                         endpoint_groups.push((\n                             EndpointGroupKey::Route(key.clone()),\n                             EndpointGroup {\n-                                primary: vec![*html_endpoint],\n+                                primary: vec![EndpointGroupEntry {\n+                                    endpoint: *html_endpoint,\n+                                    sub_name: None,\n+                                }],\n                                 // This only exists in development mode for HMR\n-                                additional: data_endpoint.iter().copied().collect(),\n+                                additional: data_endpoint\n+                                    .iter()\n+                                    .map(|endpoint| EndpointGroupEntry {\n+                                        endpoint: *endpoint,\n+                                        sub_name: None,\n+                                    })\n+                                    .collect(),\n                             },\n                         ));\n                         add_pages_entries = true;\n@@ -957,7 +969,13 @@ impl Project {\n                     endpoint_groups.push((\n                         EndpointGroupKey::Route(key.clone()),\n                         EndpointGroup {\n-                            primary: page_routes.iter().map(|r| r.html_endpoint).collect(),\n+                            primary: page_routes\n+                                .iter()\n+                                .map(|r| EndpointGroupEntry {\n+                                    endpoint: r.html_endpoint,\n+                                    sub_name: Some(r.original_name.clone()),\n+                                })\n+                                .collect(),\n                             additional: Vec::new(),\n                         },\n                     ));\n@@ -999,11 +1017,11 @@ impl Project {\n     pub async fn get_all_endpoints(self: Vc<Self>, app_dir_only: bool) -> Result<Vc<Endpoints>> {\n         let mut endpoints = Vec::new();\n         for (_key, group) in self.get_all_endpoint_groups(app_dir_only).await?.iter() {\n-            for &endpoint in group.primary.iter() {\n-                endpoints.push(endpoint);\n+            for entry in group.primary.iter() {\n+                endpoints.push(entry.endpoint);\n             }\n-            for &endpoint in group.additional.iter() {\n-                endpoints.push(endpoint);\n+            for entry in group.additional.iter() {\n+                endpoints.push(entry.endpoint);\n             }\n         }\n "
        },
        {
            "sha": "4c8a31994312a2444785c944bc8bc091ce51cd38",
            "filename": "crates/next-api/src/route.rs",
            "status": "modified",
            "additions": 49,
            "deletions": 6,
            "changes": 55,
            "blob_url": "https://github.com/vercel/next.js/blob/e64be50becbdcd795a10921983fe48534802b338/crates%2Fnext-api%2Fsrc%2Froute.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e64be50becbdcd795a10921983fe48534802b338/crates%2Fnext-api%2Fsrc%2Froute.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Froute.rs?ref=e64be50becbdcd795a10921983fe48534802b338",
            "patch": "@@ -95,6 +95,20 @@ pub enum EndpointGroupKey {\n     Route(RcStr),\n }\n \n+impl EndpointGroupKey {\n+    pub fn as_str(&self) -> &str {\n+        match self {\n+            EndpointGroupKey::Instrumentation => \"instrumentation\",\n+            EndpointGroupKey::InstrumentationEdge => \"instrumentation-edge\",\n+            EndpointGroupKey::Middleware => \"middleware\",\n+            EndpointGroupKey::PagesError => \"_error\",\n+            EndpointGroupKey::PagesApp => \"_app\",\n+            EndpointGroupKey::PagesDocument => \"_document\",\n+            EndpointGroupKey::Route(route) => route,\n+        }\n+    }\n+}\n+\n impl Display for EndpointGroupKey {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         match self {\n@@ -104,11 +118,27 @@ impl Display for EndpointGroupKey {\n             EndpointGroupKey::PagesError => write!(f, \"_error\"),\n             EndpointGroupKey::PagesApp => write!(f, \"_app\"),\n             EndpointGroupKey::PagesDocument => write!(f, \"_document\"),\n-            EndpointGroupKey::Route(route) => write!(f, \"/{}\", route),\n+            EndpointGroupKey::Route(route) => write!(f, \"{}\", route),\n         }\n     }\n }\n \n+#[derive(\n+    TraceRawVcs,\n+    Serialize,\n+    Deserialize,\n+    PartialEq,\n+    Eq,\n+    ValueDebugFormat,\n+    Clone,\n+    Debug,\n+    NonLocalValue,\n+)]\n+pub struct EndpointGroupEntry {\n+    pub endpoint: ResolvedVc<Box<dyn Endpoint>>,\n+    pub sub_name: Option<RcStr>,\n+}\n+\n #[derive(\n     TraceRawVcs,\n     Serialize,\n@@ -121,24 +151,37 @@ impl Display for EndpointGroupKey {\n     NonLocalValue,\n )]\n pub struct EndpointGroup {\n-    pub primary: Vec<ResolvedVc<Box<dyn Endpoint>>>,\n-    pub additional: Vec<ResolvedVc<Box<dyn Endpoint>>>,\n+    pub primary: Vec<EndpointGroupEntry>,\n+    pub additional: Vec<EndpointGroupEntry>,\n }\n \n impl EndpointGroup {\n     pub fn from(endpoint: ResolvedVc<Box<dyn Endpoint>>) -> Self {\n         Self {\n-            primary: vec![endpoint],\n+            primary: vec![EndpointGroupEntry {\n+                endpoint,\n+                sub_name: None,\n+            }],\n             additional: vec![],\n         }\n     }\n \n     pub fn output_assets(&self) -> Vc<OutputAssets> {\n-        output_of_endpoints(self.primary.iter().map(|endpoint| **endpoint).collect())\n+        output_of_endpoints(\n+            self.primary\n+                .iter()\n+                .map(|endpoint| *endpoint.endpoint)\n+                .collect(),\n+        )\n     }\n \n     pub fn module_graphs(&self) -> Vc<ModuleGraphs> {\n-        module_graphs_of_endpoints(self.primary.iter().map(|endpoint| **endpoint).collect())\n+        module_graphs_of_endpoints(\n+            self.primary\n+                .iter()\n+                .map(|endpoint| *endpoint.endpoint)\n+                .collect(),\n+        )\n     }\n }\n "
        },
        {
            "sha": "061f060482a37995690fdbea1e1f011760b1db36",
            "filename": "crates/next-api/src/routes_hashes_manifest.rs",
            "status": "modified",
            "additions": 31,
            "deletions": 119,
            "changes": 150,
            "blob_url": "https://github.com/vercel/next.js/blob/e64be50becbdcd795a10921983fe48534802b338/crates%2Fnext-api%2Fsrc%2Froutes_hashes_manifest.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e64be50becbdcd795a10921983fe48534802b338/crates%2Fnext-api%2Fsrc%2Froutes_hashes_manifest.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Froutes_hashes_manifest.rs?ref=e64be50becbdcd795a10921983fe48534802b338",
            "patch": "@@ -1,5 +1,6 @@\n use anyhow::Result;\n use serde::Serialize;\n+use turbo_rcstr::RcStr;\n use turbo_tasks::{FxIndexMap, FxIndexSet, ResolvedVc, TryFlatJoinIterExt, TryJoinIterExt, Vc};\n use turbo_tasks_fs::{FileContent, FileSystemPath};\n use turbo_tasks_hash::{DeterministicHash, Xxh3Hash64Hasher};\n@@ -15,7 +16,7 @@ use turbopack_core::{\n \n use crate::{\n     project::Project,\n-    route::{AppPageRoute, Endpoint, Route},\n+    route::{Endpoint, EndpointGroup},\n };\n \n #[turbo_tasks::value(shared)]\n@@ -25,7 +26,7 @@ pub struct EndpointHashes {\n }\n \n impl EndpointHashes {\n-    pub fn merge<'l>(iterator: impl Iterator<Item = (&'l str, &'l EndpointHashes)>) -> Self {\n+    pub fn merge<'l>(iterator: impl Iterator<Item = (Option<RcStr>, &'l EndpointHashes)>) -> Self {\n         let mut sources_hasher = Xxh3Hash64Hasher::new();\n         let mut outputs_hasher = Xxh3Hash64Hasher::new();\n \n@@ -151,138 +152,49 @@ impl RoutesHashesManifestAsset {\n impl Asset for RoutesHashesManifestAsset {\n     #[turbo_tasks::function]\n     async fn content(&self) -> Result<Vc<AssetContent>> {\n-        let entrypoints = self.project.entrypoints().await?;\n         let module_graphs = self.project.whole_app_module_graphs().await?;\n         let base_module_graph = *module_graphs.base;\n         let full_module_graph = *module_graphs.full;\n \n         let mut entrypoint_hashes = FxIndexMap::default();\n \n-        if let Some(instrumentation) = &entrypoints.instrumentation {\n-            entrypoint_hashes.insert(\n-                \"instrumentation\",\n-                endpoint_hashes(\n-                    base_module_graph,\n-                    full_module_graph,\n-                    *instrumentation.node_js,\n-                ),\n-            );\n-            entrypoint_hashes.insert(\n-                \"edgeInstrumentation\",\n-                endpoint_hashes(base_module_graph, full_module_graph, *instrumentation.edge),\n-            );\n-        }\n-        if let Some(middleware) = &entrypoints.middleware {\n-            entrypoint_hashes.insert(\n-                \"middleware\",\n-                endpoint_hashes(base_module_graph, full_module_graph, *middleware.endpoint),\n-            );\n-        }\n-        entrypoint_hashes.insert(\n-            \"_document\",\n-            endpoint_hashes(\n-                base_module_graph,\n-                full_module_graph,\n-                *entrypoints.pages_document_endpoint,\n-            ),\n-        );\n-        entrypoint_hashes.insert(\n-            \"_app\",\n-            endpoint_hashes(\n-                base_module_graph,\n-                full_module_graph,\n-                *entrypoints.pages_app_endpoint,\n-            ),\n-        );\n-        entrypoint_hashes.insert(\n-            \"_error\",\n-            endpoint_hashes(\n-                base_module_graph,\n-                full_module_graph,\n-                *entrypoints.pages_error_endpoint,\n-            ),\n-        );\n-\n-        for (key, route) in entrypoints.routes.iter() {\n-            match route {\n-                Route::Page {\n-                    html_endpoint,\n-                    // Only for dev\n-                    data_endpoint: _,\n-                } => {\n-                    entrypoint_hashes.insert(\n-                        key,\n-                        endpoint_hashes(base_module_graph, full_module_graph, **html_endpoint),\n-                    );\n-                }\n-                Route::PageApi { endpoint } => {\n-                    entrypoint_hashes.insert(\n-                        key,\n-                        endpoint_hashes(base_module_graph, full_module_graph, **endpoint),\n-                    );\n-                }\n-                Route::AppPage(pages) => {\n-                    if pages.len() == 1 {\n-                        entrypoint_hashes.insert(\n-                            key,\n-                            endpoint_hashes(\n-                                base_module_graph,\n-                                full_module_graph,\n-                                *pages[0].html_endpoint,\n-                            ),\n-                        );\n-                    } else {\n-                        let hashes = pages\n-                            .iter()\n-                            .map(\n-                                |&AppPageRoute {\n-                                     original_name: _,\n-                                     html_endpoint,\n-                                     // Only for dev\n-                                     rsc_endpoint: _,\n-                                 }| {\n-                                    endpoint_hashes(\n-                                        base_module_graph,\n-                                        full_module_graph,\n-                                        *html_endpoint,\n-                                    )\n-                                },\n-                            )\n-                            .try_join()\n-                            .await?;\n-                        let hashes = EndpointHashes::merge(\n-                            pages\n-                                .iter()\n-                                .map(|page| page.original_name.as_str())\n-                                .zip(hashes.iter())\n-                                .map(|(k, v)| (k, &**v)),\n-                        )\n-                        .cell();\n-                        entrypoint_hashes.insert(key, hashes);\n-                    }\n-                }\n-                Route::AppRoute {\n-                    original_name: _,\n-                    endpoint,\n-                } => {\n-                    entrypoint_hashes.insert(\n-                        key,\n-                        endpoint_hashes(base_module_graph, full_module_graph, **endpoint),\n-                    );\n-                }\n-                Route::Conflict => {}\n+        let entrypoint_groups = self.project.get_all_endpoint_groups(false).await?;\n+\n+        for (key, EndpointGroup { primary, .. }) in entrypoint_groups {\n+            if let &[entry] = &primary.as_slice() {\n+                entrypoint_hashes.insert(\n+                    key.as_str(),\n+                    endpoint_hashes(base_module_graph, full_module_graph, *entry.endpoint),\n+                );\n+            } else {\n+                let hashes = primary\n+                    .iter()\n+                    .map(|entry| {\n+                        endpoint_hashes(base_module_graph, full_module_graph, *entry.endpoint)\n+                    })\n+                    .try_join()\n+                    .await?;\n+                let hashes = EndpointHashes::merge(\n+                    primary\n+                        .iter()\n+                        .map(|page| page.sub_name.clone())\n+                        .zip(hashes.iter())\n+                        .map(|(k, v)| (k, &**v)),\n+                )\n+                .cell();\n+                entrypoint_hashes.insert(key.as_str(), hashes);\n             }\n         }\n \n         let entrypoint_hashes_values = entrypoint_hashes.values().copied().try_join().await?;\n \n         let manifest = serde_json::to_string_pretty(&RoutesHashesManifest {\n             routes: entrypoint_hashes\n-                .keys()\n-                .zip(entrypoint_hashes_values.iter())\n+                .into_keys()\n+                .zip(entrypoint_hashes_values.into_iter())\n                 .map(|(k, v)| {\n                     (\n-                        *k,\n+                        k,\n                         EndpointHashStrings {\n                             sources_hash: format!(\"{:016x}\", v.sources_hash),\n                             outputs_hash: format!(\"{:016x}\", v.outputs_hash),"
        }
    ],
    "stats": {
        "total": 239,
        "additions": 106,
        "deletions": 133
    }
}