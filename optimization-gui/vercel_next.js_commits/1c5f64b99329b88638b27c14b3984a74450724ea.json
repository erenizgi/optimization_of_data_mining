{
    "author": "lubieowoce",
    "message": "[Cache Components] Runtime prefetching (#81088)\n\nInitial implementation of runtime prefetching.\n\nA \"runtime prefetch\" is a more complete version of a static prefetch\n(i.e. the one that a link does by default), rendered on demand, and not\ncached server-side. It will render the server part of the page\ndynamically, allowing the usage of\n- `params` and `searchParams`\n- `cookies()`\n- `\"use cache: private\"` (these are omitted from static prerenders)\n- `\"use cache\"` with a short expire time (these are omitted from static\nprerenders)\n\nThe result may be partial (in the PPR sense). It will exclude any parts\nof the page that depend on\n- uncached IO\n- `connection()`, `headers()`\nThis allows the client router to cache the result, because it has a\nwell-defined stale time. Note that public caches with a stale time below\na certain fixed treshold will also be excluded, because it wouldn't make\nsense to keep them around in the router cache if we need to throw them\naway soon after getting them.\n\nWith this PR, `<Link prefetch={true}>` changes meaning\nif `clientSegmentCache` + `cacheComponents` are enabled. It will now\ninitiate a runtime prefetch instead of a \"full\" prefetch, which included\neverything that a navigation request would. Full prefetches can be done\nvia `<Link prefetch=\"unstable_forceStale\">`. If only one of the two\nflags is on, the behavior of `<Link prefetch={true}>` is unchanged from\nhow it currently works.\n\nI've split the changes up into separate commits for ease of review:\n1. Introducing the new workUnitStore type\n2. Server - handling the prefetch header and rendering\n3. Client - Link and segment cache changes\n\n### Implementation notes\n\nThe client router sends `next-router-prefetch: 2` to signal that it\nwants a runtime prefetch (as opposed to the old `next-router-prefetch:\n1`, which is used for static prefetches).\n\n> NOTE: this builder change is required for this to work on vercel\nhttps://github.com/vercel/vercel/pull/13547. It was released in\n`vercel@44.6.5`\n\nSomewhat confusingly, in order to to avoid existing static prefetch\ncodepaths, we need the server to _not_ treat this as \"a prefetch\nrequest\". Instead, we want to mostly treat this like we would a\nnavigation request, and render dynamically. This means that:\n- `isPrefetchRequest` (from `parseRequestHeaders` in `app-render`) will\nbe `false`\n- `getRequestMeta(req, 'isPrefetchRSCRequest')` won't be set\n\nThis is a bit ugly but it works for now. I'll try to clean it up in the\nfuture.\n\nWe render a payload of the same shape as a navigation request (including\nomitting shared layouts, as instructed by the `Next-Router-State-Tree`\nheader). But unlike a navigation request, we do a cache-components-style\nprerender at runtime in order to exclude uncached/sync IO.\n\nThis prerender uses a new workUnitStore type, `'prerender-runtime'`.\nThis store type changes the behavior of `cookies()`, `params`,\n`searchParams`, `\"use cache: private\"`, `next/root-params`, and others.\nUnlike a static prerender, if we detect a bad uncached/sync IO usage, we\njust log an error (instead of throwing it and erroring) and respond with\nwhatever we managed to render up until the render was aborted, in hopes\nthat we can still return something useful to the client. This request is\nhappening at runtime, so we should try to handle errors gracefully.\n\nWe track whether or not the prerender has any dynamic holes, and if it\ndoes, set `x-nextjs-postponed: 1` on the response. This tells the client\nrouter if we still need to fetch more data when navigating, or if we can\nskip it because we already have a complete page. Ideally, we'd track\nthis information per-segment for better reuse on the client side, but\nthat's not in scope for this PR.\n\nWe also set the `x-nextjs-staletime` header on the response to tell the\nclient router how long it should keep this prefetch in the cache. Note\nthat this does not affect `Cache-Control`, which should still be the\nsame as a dynamic navigation request to prevent it from being cached by\nanything other than the client router.\nThis may be improved in the future if it turns out we can safely set an\nappropriate `Cache-Control: private, ...` that also accounts for e.g.\nchanging cookie values, but i'm erring on the side of caution for now.",
    "sha": "1c5f64b99329b88638b27c14b3984a74450724ea",
    "files": [
        {
            "sha": "b3c2e089080c1ad50d78f9624bc279ea39b98535",
            "filename": "packages/next/errors.json",
            "status": "modified",
            "additions": 7,
            "deletions": 1,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Ferrors.json",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Ferrors.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Ferrors.json?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -764,5 +764,11 @@\n   \"763\": \"\\\\`unstable_rootParams\\\\` must not be used within a client component. Next.js should be preventing it from being included in client components statically, but did not in this case.\",\n   \"764\": \"Missing workStore in %s\",\n   \"765\": \"Route %s used %s inside a Route Handler. Support for this API in Route Handlers is planned for a future version of Next.js.\",\n-  \"766\": \"%s was used inside a Server Action. This is not supported. Functions from 'next/root-params' can only be called in the context of a route.\"\n+  \"766\": \"%s was used inside a Server Action. This is not supported. Functions from 'next/root-params' can only be called in the context of a route.\",\n+  \"767\": \"A runtime prerender store should not be used for a route handler.\",\n+  \"768\": \"createPrerenderSearchParamsForClientPage should not be called in a runtime prerender.\",\n+  \"769\": \"createSearchParamsFromClient should not be called in a runtime prerender.\",\n+  \"770\": \"createParamsFromClient should not be called in a runtime prerender.\",\n+  \"771\": \"\\\\`%s\\\\` was called during a runtime prerender. Next.js should be preventing %s from being included in server components statically, but did not in this case.\",\n+  \"772\": \"FetchStrategy.PPRRuntime should never be used when `experimental.clientSegmentCache` is disabled\"\n }"
        },
        {
            "sha": "7ee24b6672ea33c7ccc754d468c5faa7da9ac812",
            "filename": "packages/next/src/build/templates/app-page.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fapp-page.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fapp-page.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fapp-page.ts?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -192,7 +192,7 @@ export async function handler(\n    */\n   const isPrefetchRSCRequest =\n     getRequestMeta(req, 'isPrefetchRSCRequest') ??\n-    Boolean(req.headers[NEXT_ROUTER_PREFETCH_HEADER])\n+    req.headers[NEXT_ROUTER_PREFETCH_HEADER] === '1' // exclude runtime prefetches, which use '2'\n \n   // NOTE: Don't delete headers[RSC] yet, it still needs to be used in renderToHTML later\n "
        },
        {
            "sha": "ad4aecf2fefe06e6cfac45a868777e7b3c58f213",
            "filename": "packages/next/src/client/app-dir/form.tsx",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fclient%2Fapp-dir%2Fform.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fclient%2Fapp-dir%2Fform.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fapp-dir%2Fform.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -61,6 +61,7 @@ export default function Form({\n     }\n   }\n \n+  // TODO(runtime-ppr): allow runtime prefetches in Form\n   const prefetch =\n     prefetchProp === false || prefetchProp === null ? prefetchProp : null\n "
        },
        {
            "sha": "6b67faf4186f15b5edf9934a6e6068a8c4b3e763",
            "filename": "packages/next/src/client/app-dir/link.tsx",
            "status": "modified",
            "additions": 51,
            "deletions": 15,
            "changes": 66,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fclient%2Fapp-dir%2Flink.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fclient%2Fapp-dir%2Flink.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fapp-dir%2Flink.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -20,7 +20,10 @@ import {\n import { isLocalURL } from '../../shared/lib/router/utils/is-local-url'\n import { dispatchNavigateAction } from '../components/app-router-instance'\n import { errorOnce } from '../../shared/lib/utils/error-once'\n-import { FetchStrategy } from '../components/segment-cache'\n+import {\n+  FetchStrategy,\n+  type PrefetchTaskFetchStrategy,\n+} from '../components/segment-cache'\n \n type Url = string | UrlObject\n type RequiredKeys<T> = {\n@@ -151,10 +154,10 @@ type InternalLinkProps = {\n    * </Link>\n    * ```\n    */\n-  prefetch?: boolean | 'auto' | null\n+  prefetch?: boolean | 'auto' | null | 'unstable_forceStale'\n \n   /**\n-   * (unstable) Switch to a dynamic prefetch on hover. Effectively the same as\n+   * (unstable) Switch to a full prefetch on hover. Effectively the same as\n    * updating the prefetch prop to `true` in a mouse event.\n    */\n   unstable_dynamicOnHover?: boolean\n@@ -356,18 +359,12 @@ export default function LinkComponent(\n   const router = React.useContext(AppRouterContext)\n \n   const prefetchEnabled = prefetchProp !== false\n-  /**\n-   * The possible states for prefetch are:\n-   * - null: this is the default \"auto\" mode, where we will prefetch partially if the link is in the viewport\n-   * - true: we will prefetch if the link is visible and prefetch the full page, not just partially\n-   * - false: we will not prefetch if in the viewport at all\n-   * - 'unstable_dynamicOnHover': this starts in \"auto\" mode, but switches to \"full\" when the link is hovered\n-   */\n+\n   const fetchStrategy =\n-    prefetchProp === null || prefetchProp === 'auto'\n-      ? // We default to PPR. We'll discover whether or not the route supports it with the initial prefetch.\n+    prefetchProp !== false\n+      ? getFetchStrategyFromPrefetchProp(prefetchProp)\n+      : // TODO: it makes no sense to assign a fetchStrategy when prefetching is disabled.\n         FetchStrategy.PPR\n-      : FetchStrategy.Full\n \n   if (process.env.NODE_ENV !== 'production') {\n     function createPropError(args: {\n@@ -470,11 +467,12 @@ export default function LinkComponent(\n         if (\n           props[key] != null &&\n           valType !== 'boolean' &&\n-          props[key] !== 'auto'\n+          props[key] !== 'auto' &&\n+          props[key] !== 'unstable_forceStale'\n         ) {\n           throw createPropError({\n             key,\n-            expected: '`boolean | \"auto\"`',\n+            expected: '`boolean | \"auto\" | \"unstable_forceStale\"`',\n             actual: valType,\n           })\n         }\n@@ -745,3 +743,41 @@ const LinkStatusContext = createContext<\n export const useLinkStatus = () => {\n   return useContext(LinkStatusContext)\n }\n+\n+function getFetchStrategyFromPrefetchProp(\n+  prefetchProp: Exclude<LinkProps['prefetch'], undefined | false>\n+): PrefetchTaskFetchStrategy {\n+  if (\n+    process.env.__NEXT_CACHE_COMPONENTS &&\n+    process.env.__NEXT_CLIENT_SEGMENT_CACHE\n+  ) {\n+    // In the new implementation:\n+    // - `prefetch={true}` is a runtime prefetch\n+    //   (includes cached IO + params + cookies, with dynamic holes for uncached IO).\n+    // - `unstable_forceStale` is a \"full\" prefetch\n+    //   (forces inclusion of all dynamic data, i.e. the old behavior of `prefetch={true}`)\n+    if (prefetchProp === true) {\n+      return FetchStrategy.PPRRuntime\n+    }\n+    if (prefetchProp === 'unstable_forceStale') {\n+      return FetchStrategy.Full\n+    }\n+\n+    // `null` or `\"auto\"`: this is the default \"auto\" mode, where we will prefetch partially if the link is in the viewport.\n+    // This will also include invalid prop values that don't match the types specified here.\n+    // (although those should've been filtered out by prop validation in dev)\n+    prefetchProp satisfies null | 'auto'\n+    // In `clientSegmentCache`, we default to PPR, and we'll discover whether or not the route supports it with the initial prefetch.\n+    // If we're not using `clientSegmentCache`, this will be converted into a `PrefetchKind.AUTO`.\n+    return FetchStrategy.PPR\n+  } else {\n+    return prefetchProp === null || prefetchProp === 'auto'\n+      ? // In `clientSegmentCache`, we default to PPR, and we'll discover whether or not the route supports it with the initial prefetch.\n+        // If we're not using `clientSegmentCache`, this will be converted into a `PrefetchKind.AUTO`.\n+        FetchStrategy.PPR\n+      : // In the old implementation without runtime prefetches, `prefetch={true}` forces all dynamic data to be prefetched.\n+        // To preserve backwards-compatibility, anything other than `false`, `null`, or `\"auto\"` results in a full prefetch.\n+        // (although invalid values should've been filtered out by prop validation in dev)\n+        FetchStrategy.Full\n+  }\n+}"
        },
        {
            "sha": "956257aab3bc95b674e3243c964881fc39de1a96",
            "filename": "packages/next/src/client/components/app-router-instance.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fapp-router-instance.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fapp-router-instance.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fapp-router-instance.ts?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -329,6 +329,8 @@ export const publicAppRouterInstance: AppRouterInstance = {\n         const actionQueue = getAppRouterActionQueue()\n         const prefetchKind = options?.kind ?? PrefetchKind.AUTO\n \n+        // We don't currently offer a way to issue a runtime prefetch via `router.prefetch()`.\n+        // This will be possible when we update its API to not take a PrefetchKind.\n         let fetchStrategy: PrefetchTaskFetchStrategy\n         switch (prefetchKind) {\n           case PrefetchKind.AUTO: {"
        },
        {
            "sha": "7041bfe67a24a01940de7e34af18c851e6f8a14b",
            "filename": "packages/next/src/client/components/bailout-to-client-rendering.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fbailout-to-client-rendering.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fbailout-to-client-rendering.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fbailout-to-client-rendering.ts?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -12,6 +12,7 @@ export function bailoutToClientRendering(reason: string): void | never {\n   if (workUnitStore) {\n     switch (workUnitStore.type) {\n       case 'prerender':\n+      case 'prerender-runtime':\n       case 'prerender-client':\n       case 'prerender-ppr':\n       case 'prerender-legacy':"
        },
        {
            "sha": "1bc61f8b50f1f03fdf2bb26c95cae2b7a22fd710",
            "filename": "packages/next/src/client/components/links.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 1,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Flinks.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Flinks.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Flinks.ts?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -17,6 +17,7 @@ import {\n } from './segment-cache'\n import { startTransition } from 'react'\n import { PrefetchKind } from './router-reducer/router-reducer-types'\n+import { InvariantError } from '../../shared/lib/invariant-error'\n \n type LinkElement = HTMLAnchorElement | SVGAElement\n \n@@ -264,7 +265,7 @@ export function onNavigationIntent(\n       process.env.__NEXT_DYNAMIC_ON_HOVER &&\n       unstable_upgradeToDynamicPrefetch\n     ) {\n-      // Switch to a full, dynamic prefetch\n+      // Switch to a full prefetch\n       instance.fetchStrategy = FetchStrategy.Full\n     }\n     rescheduleLinkPrefetch(instance, PrefetchPriority.Intent)\n@@ -378,6 +379,13 @@ function prefetchWithOldCacheImplementation(instance: PrefetchableInstance) {\n         prefetchKind = PrefetchKind.FULL\n         break\n       }\n+      case FetchStrategy.PPRRuntime: {\n+        // We can only get here if Client Segment Cache is off, and in that case\n+        // it shouldn't be possible for a link to request a runtime prefetch.\n+        throw new InvariantError(\n+          'FetchStrategy.PPRRuntime should never be used when `experimental.clientSegmentCache` is disabled'\n+        )\n+      }\n       default: {\n         instance.fetchStrategy satisfies never\n         // Unreachable, but otherwise typescript will consider the variable unassigned"
        },
        {
            "sha": "e6987c30fb7b962c1674b8f9f34f81eeb1845a6d",
            "filename": "packages/next/src/client/components/navigation-untracked.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fnavigation-untracked.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fnavigation-untracked.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fnavigation-untracked.ts?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -24,6 +24,7 @@ function hasFallbackRouteParams(): boolean {\n         return fallbackParams ? fallbackParams.size > 0 : false\n       case 'prerender-legacy':\n       case 'request':\n+      case 'prerender-runtime':\n       case 'cache':\n       case 'private-cache':\n       case 'unstable-cache':"
        },
        {
            "sha": "ada2cb60818bf3c5d2e43ada1bd654f33866e300",
            "filename": "packages/next/src/client/components/router-reducer/fetch-server-response.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Ffetch-server-response.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Ffetch-server-response.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Ffetch-server-response.ts?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -55,7 +55,7 @@ export type RequestHeaders = {\n   [RSC_HEADER]?: '1'\n   [NEXT_ROUTER_STATE_TREE_HEADER]?: string\n   [NEXT_URL]?: string\n-  [NEXT_ROUTER_PREFETCH_HEADER]?: '1'\n+  [NEXT_ROUTER_PREFETCH_HEADER]?: '1' | '2'\n   [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]?: string\n   'x-deployment-id'?: string\n   [NEXT_HMR_REFRESH_HEADER]?: '1'"
        },
        {
            "sha": "135f49fa2e071672726bea212fd9dbcb1362be70",
            "filename": "packages/next/src/client/components/segment-cache-impl/cache.ts",
            "status": "modified",
            "additions": 89,
            "deletions": 19,
            "changes": 108,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -414,7 +414,9 @@ export function getSegmentKeypathForTask(\n   // the cache key, because the search params are treated as dynamic data. The\n   // cache entry is valid for all possible search param values.\n   const isDynamicTask =\n-    task.fetchStrategy === FetchStrategy.Full || !route.isPPREnabled\n+    task.fetchStrategy === FetchStrategy.Full ||\n+    task.fetchStrategy === FetchStrategy.PPRRuntime ||\n+    !route.isPPREnabled\n   return isDynamicTask && path.endsWith('/' + PAGE_SEGMENT_KEY)\n     ? [path, route.renderedSearch]\n     : [path]\n@@ -639,11 +641,21 @@ export function upsertSegmentEntry(\n   // this function and confirming it's the same as `existingEntry`.\n   const existingEntry = readExactSegmentCacheEntry(now, keypath)\n   if (existingEntry !== null) {\n-    if (candidateEntry.isPartial && !existingEntry.isPartial) {\n-      // Don't replace a full segment with a partial one. A case where this\n-      // might happen is if the existing segment was fetched via\n-      // <Link prefetch={true}>.\n-\n+    // Don't replace a more specific segment with a less-specific one. A case where this\n+    // might happen is if the existing segment was fetched via\n+    // `<Link prefetch={true}>`.\n+    if (\n+      // We fetched the new segment using a different, less specific fetch strategy\n+      // than the segment we already have in the cache, so it can't have more content.\n+      (candidateEntry.fetchStrategy !== existingEntry.fetchStrategy &&\n+        !canNewFetchStrategyProvideMoreContent(\n+          existingEntry.fetchStrategy,\n+          candidateEntry.fetchStrategy\n+        )) ||\n+      // The existing entry isn't partial, but the new one is.\n+      // (TODO: can this be true if `candidateEntry.fetchStrategy >= existingEntry.fetchStrategy`?)\n+      (!existingEntry.isPartial && candidateEntry.isPartial)\n+    ) {\n       // We're going to leave the entry on the owner's `revalidating` field\n       // so that it doesn't get revalidated again unnecessarily. Downgrade the\n       // Fulfilled entry to Rejected and null out the data so it can be garbage\n@@ -655,6 +667,7 @@ export function upsertSegmentEntry(\n       rejectedEntry.rsc = null\n       return null\n     }\n+\n     // Evict the existing entry from the cache.\n     deleteSegmentFromCache(existingEntry, keypath)\n   }\n@@ -1355,7 +1368,10 @@ export async function fetchSegmentOnCacheMiss(\n export async function fetchSegmentPrefetchesUsingDynamicRequest(\n   task: PrefetchTask,\n   route: FulfilledRouteCacheEntry,\n-  fetchStrategy: FetchStrategy.LoadingBoundary | FetchStrategy.Full,\n+  fetchStrategy:\n+    | FetchStrategy.LoadingBoundary\n+    | FetchStrategy.PPRRuntime\n+    | FetchStrategy.Full,\n   dynamicRequestTree: FlightRouterState,\n   spawnedEntries: Map<string, PendingSegmentCacheEntry>\n ): Promise<PrefetchSubtaskResult<null> | null> {\n@@ -1370,13 +1386,26 @@ export async function fetchSegmentPrefetchesUsingDynamicRequest(\n   if (nextUrl !== null) {\n     headers[NEXT_URL] = nextUrl\n   }\n-  // Only set the prefetch header if we're not doing a \"full\" prefetch. We\n-  // omit the prefetch header from a full prefetch because it's essentially\n-  // just a navigation request that happens ahead of time — it should include\n-  // all the same data in the response.\n-  if (fetchStrategy !== FetchStrategy.Full) {\n-    headers[NEXT_ROUTER_PREFETCH_HEADER] = '1'\n+  switch (fetchStrategy) {\n+    case FetchStrategy.Full: {\n+      // We omit the prefetch header from a full prefetch because it's essentially\n+      // just a navigation request that happens ahead of time — it should include\n+      // all the same data in the response.\n+      break\n+    }\n+    case FetchStrategy.PPRRuntime: {\n+      headers[NEXT_ROUTER_PREFETCH_HEADER] = '2'\n+      break\n+    }\n+    case FetchStrategy.LoadingBoundary: {\n+      headers[NEXT_ROUTER_PREFETCH_HEADER] = '1'\n+      break\n+    }\n+    default: {\n+      fetchStrategy satisfies never\n+    }\n   }\n+\n   try {\n     const response = await fetchPrefetchResponse(url, headers)\n     if (!response || !response.ok || !response.body) {\n@@ -1425,9 +1454,13 @@ export async function fetchSegmentPrefetchesUsingDynamicRequest(\n       prefetchStream\n     ) as Promise<NavigationFlightResponse>)\n \n-    // Since we did not set the prefetch header, the response from the server\n-    // will never contain dynamic holes.\n-    const isResponsePartial = false\n+    const isResponsePartial =\n+      fetchStrategy === FetchStrategy.PPRRuntime\n+        ? // A runtime prefetch may have holes.\n+          !!response.headers.get(NEXT_DID_POSTPONE_HEADER)\n+        : // Full and LoadingBoundary prefetches cannot have holes.\n+          // (even if we did set the prefetch header, we only use this codepath for non-PPR-enabled routes)\n+          false\n \n     // Aside from writing the data into the cache, this function also returns\n     // the entries that were fulfilled, so we can streamingly update their sizes\n@@ -1455,7 +1488,10 @@ export async function fetchSegmentPrefetchesUsingDynamicRequest(\n function writeDynamicTreeResponseIntoCache(\n   now: number,\n   task: PrefetchTask,\n-  fetchStrategy: FetchStrategy.LoadingBoundary | FetchStrategy.Full,\n+  fetchStrategy:\n+    | FetchStrategy.LoadingBoundary\n+    | FetchStrategy.PPRRuntime\n+    | FetchStrategy.Full,\n   response: RSCResponse,\n   serverData: NavigationFlightResponse,\n   entry: PendingRouteCacheEntry,\n@@ -1553,7 +1589,10 @@ function rejectSegmentEntriesIfStillPending(\n function writeDynamicRenderResponseIntoCache(\n   now: number,\n   task: PrefetchTask,\n-  fetchStrategy: FetchStrategy.LoadingBoundary | FetchStrategy.Full,\n+  fetchStrategy:\n+    | FetchStrategy.LoadingBoundary\n+    | FetchStrategy.PPRRuntime\n+    | FetchStrategy.Full,\n   response: RSCResponse,\n   serverData: NavigationFlightResponse,\n   isResponsePartial: boolean,\n@@ -1661,7 +1700,10 @@ function writeDynamicRenderResponseIntoCache(\n function writeSeedDataIntoCache(\n   now: number,\n   task: PrefetchTask,\n-  fetchStrategy: FetchStrategy.LoadingBoundary | FetchStrategy.Full,\n+  fetchStrategy:\n+    | FetchStrategy.LoadingBoundary\n+    | FetchStrategy.PPRRuntime\n+    | FetchStrategy.Full,\n   route: FulfilledRouteCacheEntry,\n   staleAt: number,\n   seedData: CacheNodeSeedData,\n@@ -1855,3 +1897,31 @@ function createPromiseWithResolvers<T>(): PromiseWithResolvers<T> {\n   })\n   return { resolve: resolve!, reject: reject!, promise }\n }\n+\n+/**\n+ * Checks whether the new fetch strategy is likely to provide more content than the old one.\n+ *\n+ * Generally, when an app uses dynamic data, a \"more specific\" fetch strategy is expected to provide more content:\n+ * - `LoadingBoundary` only provides static layouts\n+ * - `PPR` can provide shells for each segment (even for segments that use dynamic data)\n+ * - `PPRRuntime` can additionally include content that uses searchParams, params, or cookies\n+ * - `Full` includes all the content, even if it uses dynamic data\n+ *\n+ * However, it's possible that a more specific fetch strategy *won't* give us more content if:\n+ * - a segment is fully static\n+ *   (then, `PPR`/`PPRRuntime`/`Full` will all yield equivalent results)\n+ * - providing searchParams/params/cookies doesn't reveal any more content, e.g. because of an `await connection()`\n+ *   (then, `PPR` and `PPRRuntime` will yield equivalent results, only `Full` will give us more)\n+ * Because of this, when comparing two segments, we should also check if the existing segment is partial.\n+ * If it's not partial, then there's no need to prefetch it again, even using a \"more specific\" strategy.\n+ * There's currently no way to know if `PPRRuntime` will yield more data that `PPR`, so we have to assume it will.\n+ *\n+ * Also note that, in practice, we don't expect to be comparing `LoadingBoundary` to `PPR`/`PPRRuntime`,\n+ * because a non-PPR-enabled route wouldn't ever use the latter strategies. It might however use `Full`.\n+ */\n+export function canNewFetchStrategyProvideMoreContent(\n+  currentStrategy: FetchStrategy,\n+  newStrategy: FetchStrategy\n+): boolean {\n+  return currentStrategy < newStrategy\n+}"
        },
        {
            "sha": "4f4dc7eb446dc235467e55ad57f767ecb8d11a52",
            "filename": "packages/next/src/client/components/segment-cache-impl/scheduler.ts",
            "status": "modified",
            "additions": 75,
            "deletions": 23,
            "changes": 98,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fscheduler.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fscheduler.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fscheduler.ts?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -25,13 +25,14 @@ import {\n   waitForSegmentCacheEntry,\n   resetRevalidatingSegmentEntry,\n   getSegmentKeypathForTask,\n+  canNewFetchStrategyProvideMoreContent,\n } from './cache'\n import type { RouteCacheKey } from './cache-key'\n import {\n-  getCurrentCacheVersion,\n-  PrefetchPriority,\n   FetchStrategy,\n   type PrefetchTaskFetchStrategy,\n+  getCurrentCacheVersion,\n+  PrefetchPriority,\n } from '../segment-cache'\n import {\n   addSearchParamsIfPageSegment,\n@@ -193,6 +194,8 @@ let didScheduleMicrotask = false\n // priority at a time. We reserve special network bandwidth for this task only.\n let mostRecentlyHoveredLink: PrefetchTask | null = null\n \n+export type IncludeDynamicData = null | 'full' | 'dynamic'\n+\n /**\n  * Initiates a prefetch task for the given URL. If a prefetch for the same URL\n  * is already in progress, this will bump it to the top of the queue.\n@@ -510,8 +513,9 @@ function pingRootRouteTree(\n       // a route. Currently we've only implemented the main one: per-segment,\n       // static-data only.\n       //\n-      // There's also <Link prefetch={true}> which prefetches both static *and*\n-      // dynamic data. Similarly, we need to fallback to the old, per-page\n+      // There's also `<Link prefetch={true}>`\n+      // which prefetch both static *and* dynamic data.\n+      // Similarly, we need to fallback to the old, per-page\n       // behavior if PPR is disabled for a route (via the incremental opt-in).\n       //\n       // Those cases will be handled here.\n@@ -560,6 +564,8 @@ function pingRootRouteTree(\n \n       // A task's fetch strategy gets set to `PPR` for any \"auto\" prefetch.\n       // If it turned out that the route isn't PPR-enabled, we need to use `LoadingBoundary` instead.\n+      // We don't need to do this for runtime prefetches, because those are only available in\n+      // `cacheComponents`, where every route is PPR.\n       const fetchStrategy =\n         task.fetchStrategy === FetchStrategy.PPR\n           ? route.isPPREnabled\n@@ -574,6 +580,7 @@ function pingRootRouteTree(\n           // enabled. It will not include any dynamic data.\n           return pingPPRRouteTree(now, task, route, tree)\n         case FetchStrategy.Full:\n+        case FetchStrategy.PPRRuntime:\n         case FetchStrategy.LoadingBoundary: {\n           // Prefetch multiple segments using a single dynamic request.\n           const spawnedEntries = new Map<string, PendingSegmentCacheEntry>()\n@@ -679,7 +686,10 @@ function diffRouteTreeAgainstCurrent(\n   oldTree: FlightRouterState,\n   newTree: RouteTree,\n   spawnedEntries: Map<string, PendingSegmentCacheEntry>,\n-  fetchStrategy: FetchStrategy.Full | FetchStrategy.LoadingBoundary\n+  fetchStrategy:\n+    | FetchStrategy.Full\n+    | FetchStrategy.PPRRuntime\n+    | FetchStrategy.LoadingBoundary\n ): FlightRouterState {\n   // This is a single recursive traversal that does multiple things:\n   // - Finds the parts of the target route (newTree) that are not part of\n@@ -755,6 +765,21 @@ function diffRouteTreeAgainstCurrent(\n             requestTreeChildren[parallelRouteKey] = requestTreeChild\n             break\n           }\n+          case FetchStrategy.PPRRuntime: {\n+            // This is a runtime prefetch. Fetch all cacheable data in the tree,\n+            // not just the static PPR shell.\n+            const requestTreeChild = pingRouteTreeAndIncludeDynamicData(\n+              now,\n+              task,\n+              route,\n+              newTreeChild,\n+              false,\n+              spawnedEntries,\n+              fetchStrategy\n+            )\n+            requestTreeChildren[parallelRouteKey] = requestTreeChild\n+            break\n+          }\n           case FetchStrategy.Full: {\n             // This is a \"full\" prefetch. Fetch all the data in the tree, both\n             // static and dynamic. We issue roughly the same request that we\n@@ -779,7 +804,8 @@ function diffRouteTreeAgainstCurrent(\n               route,\n               newTreeChild,\n               false,\n-              spawnedEntries\n+              spawnedEntries,\n+              fetchStrategy\n             )\n             requestTreeChildren[parallelRouteKey] = requestTreeChild\n             break\n@@ -867,7 +893,7 @@ function pingPPRDisabledRouteTreeUpToLoadingBoundary(\n       // including it in this non-PPR request.\n       //\n       // We're intentionally choosing not to, though, because it's generally\n-      // better to avoid doing a dynamic prefetch whenever possible.\n+      // better to avoid doing a full prefetch whenever possible.\n       break\n     }\n     case EntryStatus.Pending: {\n@@ -914,7 +940,8 @@ function pingRouteTreeAndIncludeDynamicData(\n   route: FulfilledRouteCacheEntry,\n   tree: RouteTree,\n   isInsideRefetchingParent: boolean,\n-  spawnedEntries: Map<string, PendingSegmentCacheEntry>\n+  spawnedEntries: Map<string, PendingSegmentCacheEntry>,\n+  fetchStrategy: FetchStrategy.Full | FetchStrategy.PPRRuntime\n ): FlightRouterState {\n   // The tree we're constructing is the same shape as the tree we're navigating\n   // to. But even though this is a \"new\" tree, some of the individual segments\n@@ -931,35 +958,51 @@ function pingRouteTreeAndIncludeDynamicData(\n   switch (segment.status) {\n     case EntryStatus.Empty: {\n       // This segment is not cached. Include it in the request.\n-      spawnedSegment = upgradeToPendingSegment(segment, FetchStrategy.Full)\n+      spawnedSegment = upgradeToPendingSegment(segment, fetchStrategy)\n       break\n     }\n     case EntryStatus.Fulfilled: {\n       // The segment is already cached.\n-      if (segment.isPartial) {\n-        // The cached segment contians dynamic holes. Since this is a Full\n-        // prefetch, we need to include it in the request.\n+      if (\n+        segment.isPartial &&\n+        canNewFetchStrategyProvideMoreContent(\n+          segment.fetchStrategy,\n+          fetchStrategy\n+        )\n+      ) {\n+        // The cached segment contains dynamic holes, and was prefetched using a less specific strategy than the current one.\n+        // This means we're in one of these cases:\n+        //   - we have a static prefetch, and we're doing a runtime prefetch\n+        //   - we have a static or runtime prefetch, and we're doing a Full prefetch (or a navigation).\n+        // In either case, we need to include it in the request to get a more specific (or full) version.\n         spawnedSegment = pingFullSegmentRevalidation(\n           now,\n           task,\n           route,\n           segment,\n-          tree.key\n+          tree.key,\n+          fetchStrategy\n         )\n       }\n       break\n     }\n     case EntryStatus.Pending:\n     case EntryStatus.Rejected: {\n       // There's either another prefetch currently in progress, or the previous\n-      // attempt failed. If it wasn't a Full prefetch, fetch it again.\n-      if (segment.fetchStrategy !== FetchStrategy.Full) {\n+      // attempt failed. If the new strategy can provide more content, fetch it again.\n+      if (\n+        canNewFetchStrategyProvideMoreContent(\n+          segment.fetchStrategy,\n+          fetchStrategy\n+        )\n+      ) {\n         spawnedSegment = pingFullSegmentRevalidation(\n           now,\n           task,\n           route,\n           segment,\n-          tree.key\n+          tree.key,\n+          fetchStrategy\n         )\n       }\n       break\n@@ -978,7 +1021,8 @@ function pingRouteTreeAndIncludeDynamicData(\n           route,\n           childTree,\n           isInsideRefetchingParent || spawnedSegment !== null,\n-          spawnedEntries\n+          spawnedEntries,\n+          fetchStrategy\n         )\n     }\n   }\n@@ -1027,6 +1071,7 @@ function pingPerSegment(\n       // request it is, we may want to revalidate it.\n       switch (segment.fetchStrategy) {\n         case FetchStrategy.PPR:\n+        case FetchStrategy.PPRRuntime:\n         case FetchStrategy.Full:\n           // There's already a request in progress. Don't do anything.\n           break\n@@ -1059,6 +1104,7 @@ function pingPerSegment(\n       // was originally fetched, we may or may not want to revalidate it.\n       switch (segment.fetchStrategy) {\n         case FetchStrategy.PPR:\n+        case FetchStrategy.PPRRuntime:\n         case FetchStrategy.Full:\n           // The previous attempt to fetch this entry failed. Don't attempt to\n           // fetch it again until the entry expires.\n@@ -1148,21 +1194,22 @@ function pingFullSegmentRevalidation(\n   task: PrefetchTask,\n   route: FulfilledRouteCacheEntry,\n   currentSegment: SegmentCacheEntry,\n-  segmentKey: string\n+  segmentKey: string,\n+  fetchStrategy: FetchStrategy.Full | FetchStrategy.PPRRuntime\n ): PendingSegmentCacheEntry | null {\n   const revalidatingSegment = readOrCreateRevalidatingSegmentEntry(\n     now,\n     currentSegment\n   )\n   if (revalidatingSegment.status === EntryStatus.Empty) {\n-    // During a Full prefetch, a single dynamic request is made for all the\n+    // During a Full/PPRRuntime prefetch, a single dynamic request is made for all the\n     // segments that we need. So we don't initiate a request here directly. By\n     // returning a pending entry from this function, it signals to the caller\n     // that this segment should be included in the request that's sent to\n     // the server.\n     const pendingSegment = upgradeToPendingSegment(\n       revalidatingSegment,\n-      FetchStrategy.Full\n+      fetchStrategy\n     )\n     upsertSegmentOnCompletion(\n       task,\n@@ -1174,15 +1221,20 @@ function pingFullSegmentRevalidation(\n   } else {\n     // There's already a revalidation in progress.\n     const nonEmptyRevalidatingSegment = revalidatingSegment\n-    if (nonEmptyRevalidatingSegment.fetchStrategy !== FetchStrategy.Full) {\n-      // The existing revalidation was not fetched using the Full strategy.\n+    if (\n+      canNewFetchStrategyProvideMoreContent(\n+        nonEmptyRevalidatingSegment.fetchStrategy,\n+        fetchStrategy\n+      )\n+    ) {\n+      // The existing revalidation was fetched using a less specific strategy.\n       // Reset it and start a new revalidation.\n       const emptySegment = resetRevalidatingSegmentEntry(\n         nonEmptyRevalidatingSegment\n       )\n       const pendingSegment = upgradeToPendingSegment(\n         emptySegment,\n-        FetchStrategy.Full\n+        fetchStrategy\n       )\n       upsertSegmentOnCompletion(\n         task,"
        },
        {
            "sha": "9dedf453c9a0c2141111042f94e2fdda5b3ae50c",
            "filename": "packages/next/src/client/components/segment-cache.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 4,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache.ts?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -142,9 +142,13 @@ export const enum PrefetchPriority {\n }\n \n export const enum FetchStrategy {\n-  PPR,\n-  Full,\n-  LoadingBoundary,\n+  // Deliberately ordered so we can easily compare two segments\n+  // and determine if one segment is \"more specific\" than another\n+  // (i.e. if it's likely that it contains more data)\n+  LoadingBoundary = 0,\n+  PPR = 1,\n+  PPRRuntime = 2,\n+  Full = 3,\n }\n \n /**\n@@ -153,4 +157,7 @@ export const enum FetchStrategy {\n  * until we complete the initial tree prefetch request, so we use `PPR` to signal both cases\n  * and adjust it based on the route when actually fetching.\n  * */\n-export type PrefetchTaskFetchStrategy = FetchStrategy.PPR | FetchStrategy.Full\n+export type PrefetchTaskFetchStrategy =\n+  | FetchStrategy.PPR\n+  | FetchStrategy.PPRRuntime\n+  | FetchStrategy.Full"
        },
        {
            "sha": "58d55153e809481629c644d52eefc5674eafe0af",
            "filename": "packages/next/src/client/link.tsx",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fclient%2Flink.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fclient%2Flink.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Flink.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -82,7 +82,7 @@ type InternalLinkProps = {\n    * - `false`: Prefetching will not happen when entering the viewport, but will still happen on hover.\n    * @defaultValue `true` (pages router) or `null` (app router)\n    */\n-  prefetch?: boolean | 'auto' | null\n+  prefetch?: boolean | 'auto' | null | 'unstable_forceStale'\n   /**\n    * The active locale is automatically prepended. `locale` allows for providing a different locale.\n    * When `false` `href` has to include the locale as the default behavior is disabled."
        },
        {
            "sha": "646fcacc48296f80d167a8a6bd444a40111f7465",
            "filename": "packages/next/src/server/app-render/app-render.tsx",
            "status": "modified",
            "additions": 391,
            "deletions": 43,
            "changes": 434,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -15,7 +15,10 @@ import {\n   workAsyncStorage,\n   type WorkStore,\n } from '../app-render/work-async-storage.external'\n-import type { RequestStore } from '../app-render/work-unit-async-storage.external'\n+import type {\n+  PrerenderStoreModernRuntime,\n+  RequestStore,\n+} from '../app-render/work-unit-async-storage.external'\n import type { NextParsedUrlQuery } from '../request-meta'\n import type { LoaderTree } from '../lib/app-dir-module'\n import type { AppPageModule } from '../route-modules/app-page/module'\n@@ -54,6 +57,7 @@ import {\n   RSC_HEADER,\n   NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n   NEXT_HMR_REFRESH_HASH_COOKIE,\n+  NEXT_DID_POSTPONE_HEADER,\n } from '../../client/components/app-router-headers'\n import { createMetadataContext } from '../../lib/metadata/metadata-context'\n import { createRequestStoreForRender } from '../async-storage/request-store'\n@@ -133,6 +137,7 @@ import {\n   consumeDynamicAccess,\n   type DynamicAccess,\n   logDisallowedDynamicError,\n+  warnOnSyncDynamicError,\n } from './dynamic-rendering'\n import {\n   getClientComponentLoaderMetrics,\n@@ -193,6 +198,8 @@ import type { GlobalErrorComponent } from '../../client/components/builtin/globa\n import { normalizeConventionFilePath } from './segment-explorer-path'\n import { getRequestMeta } from '../request-meta'\n import { getDynamicParam } from '../../shared/lib/router/utils/get-dynamic-param'\n+import type { ExperimentalConfig } from '../config-shared'\n+import type { Params } from '../request/params'\n \n export type GetDynamicParamFromSegment = (\n   // [slug] / [[slug]] / [...slug]\n@@ -266,6 +273,7 @@ interface ParsedRequestHeaders {\n    */\n   readonly flightRouterState: FlightRouterState | undefined\n   readonly isPrefetchRequest: boolean\n+  readonly isRuntimePrefetchRequest: boolean\n   readonly isRouteTreePrefetchRequest: boolean\n   readonly isDevWarmupRequest: boolean\n   readonly isHmrRefresh: boolean\n@@ -281,8 +289,12 @@ function parseRequestHeaders(\n   const isDevWarmupRequest = options.isDevWarmup === true\n \n   // dev warmup requests are treated as prefetch RSC requests\n+  // runtime prefetch requests are *not* treated as prefetch requests\n+  // (TODO: this is confusing, we should refactor this to express this better)\n   const isPrefetchRequest =\n-    isDevWarmupRequest || headers[NEXT_ROUTER_PREFETCH_HEADER] !== undefined\n+    isDevWarmupRequest || headers[NEXT_ROUTER_PREFETCH_HEADER] === '1'\n+\n+  const isRuntimePrefetchRequest = headers[NEXT_ROUTER_PREFETCH_HEADER] === '2'\n \n   const isHmrRefresh = headers[NEXT_HMR_REFRESH_HEADER] !== undefined\n \n@@ -315,6 +327,7 @@ function parseRequestHeaders(\n   return {\n     flightRouterState,\n     isPrefetchRequest,\n+    isRuntimePrefetchRequest,\n     isRouteTreePrefetchRequest,\n     isHmrRefresh,\n     isRSCRequest,\n@@ -516,6 +529,7 @@ function createErrorContext(\n     revalidateReason: getRevalidateReason(ctx.workStore),\n   }\n }\n+\n /**\n  * Produces a RenderResult containing the Flight data for the given request. See\n  * `generateDynamicRSCPayload` for information on the contents of the render result.\n@@ -600,6 +614,317 @@ async function generateDynamicFlightRenderResult(\n   })\n }\n \n+async function generateRuntimePrefetchResult(\n+  req: BaseNextRequest,\n+  res: BaseNextResponse,\n+  ctx: AppRenderContext,\n+  requestStore: RequestStore\n+): Promise<RenderResult> {\n+  const { workStore } = ctx\n+  const renderOpts = ctx.renderOpts\n+\n+  function onFlightDataRenderError(err: DigestedError) {\n+    return renderOpts.onInstrumentationRequestError?.(\n+      err,\n+      req,\n+      // TODO(runtime-ppr): should we use a different value?\n+      createErrorContext(ctx, 'react-server-components-payload')\n+    )\n+  }\n+  const onError = createFlightReactServerErrorHandler(\n+    false,\n+    onFlightDataRenderError\n+  )\n+\n+  const metadata: AppPageRenderResultMetadata = {}\n+\n+  const generatePayload = () => generateDynamicRSCPayload(ctx, undefined)\n+\n+  const {\n+    componentMod: { tree },\n+    getDynamicParamFromSegment,\n+  } = ctx\n+  const rootParams = getRootParams(tree, getDynamicParamFromSegment)\n+\n+  // We need to share caches between the prospective prerender and the final prerender,\n+  // but we're not going to persist this anywhere.\n+  const prerenderResumeDataCache = createPrerenderResumeDataCache()\n+  // We're not resuming an existing render.\n+  const renderResumeDataCache = null\n+\n+  await prospectiveRuntimeServerPrerender(\n+    ctx,\n+    generatePayload,\n+    prerenderResumeDataCache,\n+    renderResumeDataCache,\n+    rootParams,\n+    requestStore.cookies,\n+    requestStore.draftMode\n+  )\n+\n+  const response = await finalRuntimeServerPrerender(\n+    ctx,\n+    generatePayload,\n+    prerenderResumeDataCache,\n+    renderResumeDataCache,\n+    rootParams,\n+    requestStore.cookies,\n+    requestStore.draftMode,\n+    onError\n+  )\n+\n+  applyMetadataFromPrerenderResult(response, metadata, workStore)\n+  metadata.fetchMetrics = ctx.workStore.fetchMetrics\n+\n+  if (response.isPartial) {\n+    res.setHeader(NEXT_DID_POSTPONE_HEADER, '1')\n+  }\n+\n+  return new FlightRenderResult(response.result.prelude, metadata)\n+}\n+\n+async function prospectiveRuntimeServerPrerender(\n+  ctx: AppRenderContext,\n+  getPayload: () => any,\n+  prerenderResumeDataCache: PrerenderResumeDataCache | null,\n+  renderResumeDataCache: RenderResumeDataCache | null,\n+  rootParams: Params,\n+  cookies: PrerenderStoreModernRuntime['cookies'],\n+  draftMode: PrerenderStoreModernRuntime['draftMode']\n+) {\n+  const { implicitTags, renderOpts, workStore } = ctx\n+\n+  const { clientReferenceManifest, ComponentMod } = renderOpts\n+\n+  assertClientReferenceManifest(clientReferenceManifest)\n+\n+  // Prerender controller represents the lifetime of the prerender.\n+  // It will be aborted when a Task is complete or a synchronously aborting\n+  // API is called. Notably during cache-filling renders this does not actually\n+  // terminate the render itself which will continue until all caches are filled\n+  const initialServerPrerenderController = new AbortController()\n+\n+  // This controller represents the lifetime of the React render call. Notably\n+  // during the cache-filling render it is different from the prerender controller\n+  // because we don't want to end the react render until all caches are filled.\n+  const initialServerRenderController = new AbortController()\n+\n+  // The cacheSignal helps us track whether caches are still filling or we are ready\n+  // to cut the render off.\n+  const cacheSignal = new CacheSignal()\n+\n+  const initialServerPrerenderStore: PrerenderStoreModernRuntime = {\n+    type: 'prerender-runtime',\n+    phase: 'render',\n+    rootParams,\n+    implicitTags,\n+    renderSignal: initialServerRenderController.signal,\n+    controller: initialServerPrerenderController,\n+    // During the initial prerender we need to track all cache reads to ensure\n+    // we render long enough to fill every cache it is possible to visit during\n+    // the final prerender.\n+    cacheSignal,\n+    // We only need to track dynamic accesses during the final prerender.\n+    dynamicTracking: null,\n+    // Runtime prefetches are never cached server-side, only client-side,\n+    // so we set `expire` and `revalidate` to their minimum values just in case.\n+    revalidate: 1,\n+    expire: 0,\n+    stale: INFINITE_CACHE,\n+    tags: [...implicitTags.tags],\n+    renderResumeDataCache,\n+    prerenderResumeDataCache,\n+    hmrRefreshHash: undefined,\n+    captureOwnerStack: undefined,\n+    // These are not present in regular prerenders, but allowed in a runtime prerender.\n+    cookies,\n+    draftMode,\n+  }\n+\n+  // We're not going to use the result of this render because the only time it could be used\n+  // is if it completes in a microtask and that's likely very rare for any non-trivial app\n+  const initialServerPayload = await workUnitAsyncStorage.run(\n+    initialServerPrerenderStore,\n+    getPayload\n+  )\n+\n+  const pendingInitialServerResult = workUnitAsyncStorage.run(\n+    initialServerPrerenderStore,\n+    ComponentMod.prerender,\n+    initialServerPayload,\n+    clientReferenceManifest.clientModules,\n+    {\n+      filterStackFrame,\n+      onError: (err) => {\n+        const digest = getDigestForWellKnownError(err)\n+\n+        if (digest) {\n+          return digest\n+        }\n+\n+        if (initialServerPrerenderController.signal.aborted) {\n+          // The render aborted before this error was handled which indicates\n+          // the error is caused by unfinished components within the render\n+          return\n+        } else if (\n+          process.env.NEXT_DEBUG_BUILD ||\n+          process.env.__NEXT_VERBOSE_LOGGING\n+        ) {\n+          printDebugThrownValueForProspectiveRender(err, workStore.route)\n+        }\n+      },\n+      // we don't care to track postpones during the prospective render because we need\n+      // to always do a final render anyway\n+      onPostpone: undefined,\n+      // We don't want to stop rendering until the cacheSignal is complete so we pass\n+      // a different signal to this render call than is used by dynamic APIs to signify\n+      // transitioning out of the prerender environment\n+      signal: initialServerRenderController.signal,\n+    }\n+  )\n+\n+  // Wait for all caches to be finished filling and for async imports to resolve\n+  trackPendingModules(cacheSignal)\n+  await cacheSignal.cacheReady()\n+\n+  initialServerRenderController.abort()\n+  initialServerPrerenderController.abort()\n+\n+  // We don't need to continue the prerender process if we already\n+  // detected invalid dynamic usage in the initial prerender phase.\n+  if (workStore.invalidDynamicUsageError) {\n+    throw workStore.invalidDynamicUsageError\n+  }\n+\n+  try {\n+    return await createReactServerPrerenderResult(pendingInitialServerResult)\n+  } catch (err) {\n+    if (\n+      initialServerRenderController.signal.aborted ||\n+      initialServerPrerenderController.signal.aborted\n+    ) {\n+      // These are expected errors that might error the prerender. we ignore them.\n+    } else if (\n+      process.env.NEXT_DEBUG_BUILD ||\n+      process.env.__NEXT_VERBOSE_LOGGING\n+    ) {\n+      // We don't normally log these errors because we are going to retry anyway but\n+      // it can be useful for debugging Next.js itself to get visibility here when needed\n+      printDebugThrownValueForProspectiveRender(err, workStore.route)\n+    }\n+    return null\n+  }\n+}\n+\n+async function finalRuntimeServerPrerender(\n+  ctx: AppRenderContext,\n+  getPayload: () => any,\n+  prerenderResumeDataCache: PrerenderResumeDataCache | null,\n+  renderResumeDataCache: RenderResumeDataCache | null,\n+  rootParams: Params,\n+  cookies: PrerenderStoreModernRuntime['cookies'],\n+  draftMode: PrerenderStoreModernRuntime['draftMode'],\n+  onError: (err: unknown) => string | undefined\n+) {\n+  const { implicitTags, renderOpts } = ctx\n+\n+  const {\n+    clientReferenceManifest,\n+    ComponentMod,\n+    experimental,\n+    isDebugDynamicAccesses,\n+  } = renderOpts\n+\n+  assertClientReferenceManifest(clientReferenceManifest)\n+\n+  const selectStaleTime = createSelectStaleTime(experimental)\n+\n+  let serverIsDynamic = false\n+  const finalServerController = new AbortController()\n+\n+  const serverDynamicTracking = createDynamicTrackingState(\n+    isDebugDynamicAccesses\n+  )\n+\n+  const finalServerPrerenderStore: PrerenderStoreModernRuntime = {\n+    type: 'prerender-runtime',\n+    phase: 'render',\n+    rootParams,\n+    implicitTags,\n+    renderSignal: finalServerController.signal,\n+    controller: finalServerController,\n+    // All caches we could read must already be filled so no tracking is necessary\n+    cacheSignal: null,\n+    dynamicTracking: serverDynamicTracking,\n+    // Runtime prefetches are never cached server-side, only client-side,\n+    // so we set `expire` and `revalidate` to their minimum values just in case.\n+    revalidate: 1,\n+    expire: 0,\n+    stale: INFINITE_CACHE,\n+    tags: [...implicitTags.tags],\n+    prerenderResumeDataCache,\n+    renderResumeDataCache,\n+    hmrRefreshHash: undefined,\n+    captureOwnerStack: undefined,\n+    // These are not present in regular prerenders, but allowed in a runtime prerender.\n+    cookies,\n+    draftMode,\n+  }\n+\n+  const finalRSCPayload = await workUnitAsyncStorage.run(\n+    finalServerPrerenderStore,\n+    getPayload\n+  )\n+\n+  let prerenderIsPending = true\n+  const result = await prerenderAndAbortInSequentialTasks(\n+    async () => {\n+      const prerenderResult = await workUnitAsyncStorage.run(\n+        finalServerPrerenderStore,\n+        ComponentMod.prerender,\n+        finalRSCPayload,\n+        clientReferenceManifest.clientModules,\n+        {\n+          filterStackFrame,\n+          onError,\n+          signal: finalServerController.signal,\n+        }\n+      )\n+      prerenderIsPending = false\n+      return prerenderResult\n+    },\n+    () => {\n+      if (finalServerController.signal.aborted) {\n+        // If the server controller is already aborted we must have called something\n+        // that required aborting the prerender synchronously such as with new Date()\n+        serverIsDynamic = true\n+        return\n+      }\n+\n+      if (prerenderIsPending) {\n+        // If prerenderIsPending then we have blocked for longer than a Task and we assume\n+        // there is something unfinished.\n+        serverIsDynamic = true\n+      }\n+      finalServerController.abort()\n+    }\n+  )\n+\n+  warnOnSyncDynamicError(serverDynamicTracking)\n+\n+  return {\n+    result,\n+    // TODO(runtime-ppr): do we need to produce a digest map here?\n+    // digestErrorsMap: ...,\n+    dynamicAccess: serverDynamicTracking,\n+    isPartial: serverIsDynamic,\n+    collectedRevalidate: finalServerPrerenderStore.revalidate,\n+    collectedExpire: finalServerPrerenderStore.expire,\n+    collectedStale: selectStaleTime(finalServerPrerenderStore.stale),\n+    collectedTags: finalServerPrerenderStore.tags,\n+  }\n+}\n+\n /**\n  * Performs a \"warmup\" render of the RSC payload for a given route. This function is called by the server\n  * prior to an actual render request in Dev mode only. It's purpose is to fill caches so the actual render\n@@ -1190,6 +1515,7 @@ async function renderToHTMLOrFlightImpl(\n       switch (workUnitStore.type) {\n         case 'prerender':\n         case 'prerender-client':\n+        case 'prerender-runtime':\n         case 'cache':\n         case 'private-cache':\n           return true\n@@ -1299,6 +1625,7 @@ async function renderToHTMLOrFlightImpl(\n   const {\n     flightRouterState,\n     isPrefetchRequest,\n+    isRuntimePrefetchRequest,\n     isRSCRequest,\n     isDevWarmupRequest,\n     isHmrRefresh,\n@@ -1448,41 +1775,7 @@ async function renderToHTMLOrFlightImpl(\n       }\n     }\n \n-    if (response.collectedTags) {\n-      metadata.fetchTags = response.collectedTags.join(',')\n-    }\n-\n-    // Let the client router know how long to keep the cached entry around.\n-    const staleHeader = String(response.collectedStale)\n-    res.setHeader(NEXT_ROUTER_STALE_TIME_HEADER, staleHeader)\n-    metadata.headers ??= {}\n-    metadata.headers[NEXT_ROUTER_STALE_TIME_HEADER] = staleHeader\n-\n-    // If force static is specifically set to false, we should not revalidate\n-    // the page.\n-    if (workStore.forceStatic === false || response.collectedRevalidate === 0) {\n-      metadata.cacheControl = { revalidate: 0, expire: undefined }\n-    } else {\n-      // Copy the cache control value onto the render result metadata.\n-      metadata.cacheControl = {\n-        revalidate:\n-          response.collectedRevalidate >= INFINITE_CACHE\n-            ? false\n-            : response.collectedRevalidate,\n-        expire:\n-          response.collectedExpire >= INFINITE_CACHE\n-            ? undefined\n-            : response.collectedExpire,\n-      }\n-    }\n-\n-    // provide bailout info for debugging\n-    if (metadata.cacheControl?.revalidate === 0) {\n-      metadata.staticBailoutInfo = {\n-        description: workStore.dynamicUsageDescription,\n-        stack: workStore.dynamicUsageStack,\n-      }\n-    }\n+    applyMetadataFromPrerenderResult(response, metadata, workStore)\n \n     if (response.renderResumeDataCache) {\n       metadata.renderResumeDataCache = response.renderResumeDataCache\n@@ -1530,7 +1823,11 @@ async function renderToHTMLOrFlightImpl(\n     if (isDevWarmupRequest) {\n       return warmupDevRender(req, ctx)\n     } else if (isRSCRequest) {\n-      return generateDynamicFlightRenderResult(req, ctx, requestStore)\n+      if (isRuntimePrefetchRequest) {\n+        return generateRuntimePrefetchResult(req, res, ctx, requestStore)\n+      } else {\n+        return generateDynamicFlightRenderResult(req, ctx, requestStore)\n+      }\n     }\n \n     const renderToStreamWithTracing = getTracer().wrap(\n@@ -1735,6 +2032,53 @@ export const renderToHTMLOrFlight: AppPageRender = (\n   )\n }\n \n+function applyMetadataFromPrerenderResult(\n+  response: Pick<\n+    PrerenderToStreamResult,\n+    | 'collectedExpire'\n+    | 'collectedRevalidate'\n+    | 'collectedStale'\n+    | 'collectedTags'\n+  >,\n+  metadata: AppPageRenderResultMetadata,\n+  workStore: WorkStore\n+) {\n+  if (response.collectedTags) {\n+    metadata.fetchTags = response.collectedTags.join(',')\n+  }\n+\n+  // Let the client router know how long to keep the cached entry around.\n+  const staleHeader = String(response.collectedStale)\n+  metadata.headers ??= {}\n+  metadata.headers[NEXT_ROUTER_STALE_TIME_HEADER] = staleHeader\n+\n+  // If force static is specifically set to false, we should not revalidate\n+  // the page.\n+  if (workStore.forceStatic === false || response.collectedRevalidate === 0) {\n+    metadata.cacheControl = { revalidate: 0, expire: undefined }\n+  } else {\n+    // Copy the cache control value onto the render result metadata.\n+    metadata.cacheControl = {\n+      revalidate:\n+        response.collectedRevalidate >= INFINITE_CACHE\n+          ? false\n+          : response.collectedRevalidate,\n+      expire:\n+        response.collectedExpire >= INFINITE_CACHE\n+          ? undefined\n+          : response.collectedExpire,\n+    }\n+  }\n+\n+  // provide bailout info for debugging\n+  if (metadata.cacheControl?.revalidate === 0) {\n+    metadata.staticBailoutInfo = {\n+      description: workStore.dynamicUsageDescription,\n+      stack: workStore.dynamicUsageStack,\n+    }\n+  }\n+}\n+\n async function renderToStream(\n   requestStore: RequestStore,\n   req: BaseNextRequest,\n@@ -2944,11 +3288,7 @@ async function prerenderToStream(\n     setMetadataHeader(name)\n   }\n \n-  const selectStaleTime = (stale: number) =>\n-    stale === INFINITE_CACHE &&\n-    typeof experimental.staleTimes?.static === 'number'\n-      ? experimental.staleTimes.static\n-      : stale\n+  const selectStaleTime = createSelectStaleTime(experimental)\n \n   let prerenderStore: PrerenderStore | null = null\n \n@@ -4170,6 +4510,14 @@ const getGlobalErrorStyles = async (\n   }\n }\n \n+function createSelectStaleTime(experimental: ExperimentalConfig) {\n+  return (stale: number) =>\n+    stale === INFINITE_CACHE &&\n+    typeof experimental.staleTimes?.static === 'number'\n+      ? experimental.staleTimes.static\n+      : stale\n+}\n+\n async function collectSegmentData(\n   fullPageDataBuffer: Buffer,\n   prerenderStore: PrerenderStore,"
        },
        {
            "sha": "789d95935dabc916a1ad6b8c9372bc97cc527abb",
            "filename": "packages/next/src/server/app-render/create-component-tree.tsx",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcreate-component-tree.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcreate-component-tree.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcreate-component-tree.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -300,6 +300,7 @@ async function createComponentTreeInternal(\n     if (workUnitStore) {\n       switch (workUnitStore.type) {\n         case 'prerender':\n+        case 'prerender-runtime':\n         case 'prerender-legacy':\n         case 'prerender-ppr':\n           if (workUnitStore.revalidate > defaultRevalidate) {"
        },
        {
            "sha": "5f34aeeed59f79ecd2e6449965d14f7b7841543e",
            "filename": "packages/next/src/server/app-render/dynamic-rendering.ts",
            "status": "modified",
            "additions": 21,
            "deletions": 0,
            "changes": 21,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fdynamic-rendering.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fdynamic-rendering.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fdynamic-rendering.ts?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -230,6 +230,7 @@ export function trackDynamicDataInDynamicRender(workUnitStore: WorkUnitStore) {\n       // A private cache scope is already dynamic by definition.\n       return\n     case 'prerender':\n+    case 'prerender-runtime':\n     case 'prerender-legacy':\n     case 'prerender-ppr':\n     case 'prerender-client':\n@@ -335,6 +336,21 @@ export function abortAndThrowOnSynchronousRequestDataAccess(\n   )\n }\n \n+/**\n+ * Use this function when dynamically prerendering with dynamicIO.\n+ * We don't want to error, because it's better to return something\n+ * (and we've already aborted the render at the point where the sync dynamic error occured),\n+ * but we should log an error server-side.\n+ * @internal\n+ */\n+export function warnOnSyncDynamicError(dynamicTracking: DynamicTrackingState) {\n+  if (dynamicTracking.syncDynamicErrorWithStack) {\n+    // the server did something sync dynamic, likely\n+    // leading to an early termination of the prerender.\n+    console.error(dynamicTracking.syncDynamicErrorWithStack)\n+  }\n+}\n+\n // For now these implementations are the same so we just reexport\n export const trackSynchronousRequestDataAccessInDev =\n   trackSynchronousPlatformIOAccessInDev\n@@ -519,6 +535,7 @@ export function createHangingInputAbortSignal(\n ): AbortSignal | undefined {\n   switch (workUnitStore.type) {\n     case 'prerender':\n+    case 'prerender-runtime':\n       const controller = new AbortController()\n \n       if (workUnitStore.cacheSignal) {\n@@ -599,6 +616,10 @@ export function useDynamicRouteParams(expression: string) {\n         }\n         break\n       }\n+      case 'prerender-runtime':\n+        throw new InvariantError(\n+          `\\`${expression}\\` was called during a runtime prerender. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`\n+        )\n       case 'cache':\n       case 'private-cache':\n         throw new InvariantError("
        },
        {
            "sha": "142277ad8346e2b817a528778a24791d1c09ae9e",
            "filename": "packages/next/src/server/app-render/encryption.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fencryption.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fencryption.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fencryption.ts?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -260,6 +260,7 @@ export async function decryptActionBoundArgs(\n \n         switch (workUnitStore?.type) {\n           case 'prerender':\n+          case 'prerender-runtime':\n             // Explicitly don't close the stream here (until prerendering is\n             // complete) so that hanging promises are not rejected.\n             if (workUnitStore.renderSignal.aborted) {"
        },
        {
            "sha": "5457f1c013b0a63c60f316fa374d16a0598ca73a",
            "filename": "packages/next/src/server/app-render/use-flight-response.tsx",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fuse-flight-response.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fuse-flight-response.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fuse-flight-response.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -71,6 +71,7 @@ export function useFlightStream<T>(\n         flightResponses.set(flightStream, responseOnNextTick)\n         return responseOnNextTick\n       case 'prerender':\n+      case 'prerender-runtime':\n       case 'prerender-ppr':\n       case 'prerender-legacy':\n       case 'request':"
        },
        {
            "sha": "b8eed2737bff17ca52ded45d12b0a18ffab3215d",
            "filename": "packages/next/src/server/app-render/work-unit-async-storage.external.ts",
            "status": "modified",
            "additions": 98,
            "deletions": 16,
            "changes": 114,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwork-unit-async-storage.external.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwork-unit-async-storage.external.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwork-unit-async-storage.external.ts?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -82,15 +82,34 @@ export interface RequestStore extends CommonWorkUnitStore {\n export type PrerenderStoreModern =\n   | PrerenderStoreModernClient\n   | PrerenderStoreModernServer\n+  | PrerenderStoreModernRuntime\n \n-export interface PrerenderStoreModernClient extends PrerenderStoreModernCommon {\n+/** Like `PrerenderStoreModern`, but only including static prerenders (i.e. not runtime prerenders) */\n+export type StaticPrerenderStoreModern = Exclude<\n+  PrerenderStoreModern,\n+  PrerenderStoreModernRuntime\n+>\n+\n+export interface PrerenderStoreModernClient\n+  extends PrerenderStoreModernCommon,\n+    StaticPrerenderStoreCommon {\n   readonly type: 'prerender-client'\n }\n \n-export interface PrerenderStoreModernServer extends PrerenderStoreModernCommon {\n+export interface PrerenderStoreModernServer\n+  extends PrerenderStoreModernCommon,\n+    StaticPrerenderStoreCommon {\n   readonly type: 'prerender'\n }\n \n+export interface PrerenderStoreModernRuntime\n+  extends PrerenderStoreModernCommon {\n+  readonly type: 'prerender-runtime'\n+\n+  readonly cookies: RequestStore['cookies']\n+  readonly draftMode: RequestStore['draftMode']\n+}\n+\n export interface RevalidateStore {\n   // Collected revalidate times and tags for this document during the prerender.\n   revalidate: number // in seconds. 0 means dynamic. INFINITE_CACHE and higher means never revalidate.\n@@ -139,20 +158,6 @@ interface PrerenderStoreModernCommon\n \n   readonly rootParams: Params\n \n-  /**\n-   * The set of unknown route parameters. Accessing these will be tracked as\n-   * a dynamic access.\n-   */\n-  readonly fallbackRouteParams: FallbackRouteParams | null\n-\n-  /**\n-   * When true, the page is prerendered as a fallback shell, while allowing any\n-   * dynamic accesses to result in an empty shell. This is the case when there\n-   * are also routes prerendered with a more complete set of params.\n-   * Prerendering those routes would catch any invalid dynamic accesses.\n-   */\n-  readonly allowEmptyStaticShell: boolean\n-\n   /**\n    * A mutable resume data cache for this prerender.\n    */\n@@ -179,6 +184,22 @@ interface PrerenderStoreModernCommon\n   readonly captureOwnerStack: undefined | (() => string | null)\n }\n \n+interface StaticPrerenderStoreCommon {\n+  /**\n+   * The set of unknown route parameters. Accessing these will be tracked as\n+   * a dynamic access.\n+   */\n+  readonly fallbackRouteParams: FallbackRouteParams | null\n+\n+  /**\n+   * When true, the page is prerendered as a fallback shell, while allowing any\n+   * dynamic accesses to result in an empty shell. This is the case when there\n+   * are also routes prerendered with a more complete set of params.\n+   * Prerendering those routes would catch any invalid dynamic accesses.\n+   */\n+  readonly allowEmptyStaticShell: boolean\n+}\n+\n export interface PrerenderStorePPR\n   extends CommonWorkUnitStore,\n     RevalidateStore {\n@@ -210,6 +231,12 @@ export type PrerenderStore =\n   | PrerenderStorePPR\n   | PrerenderStoreModern\n \n+// /** Like `PrerenderStoreModern`, but only including static prerenders (i.e. not runtime prerenders) */\n+export type StaticPrerenderStore = Exclude<\n+  PrerenderStore,\n+  PrerenderStoreModernRuntime\n+>\n+\n export interface CommonCacheStore\n   extends Omit<CommonWorkUnitStore, 'implicitTags'> {\n   /**\n@@ -289,6 +316,7 @@ export function getPrerenderResumeDataCache(\n ): PrerenderResumeDataCache | null {\n   switch (workUnitStore.type) {\n     case 'prerender':\n+    case 'prerender-runtime':\n     case 'prerender-ppr':\n       return workUnitStore.prerenderResumeDataCache\n     case 'prerender-client':\n@@ -313,6 +341,7 @@ export function getRenderResumeDataCache(\n     case 'request':\n       return workUnitStore.renderResumeDataCache\n     case 'prerender':\n+    case 'prerender-runtime':\n     case 'prerender-client':\n       if (workUnitStore.renderResumeDataCache) {\n         // If we are in a prerender, we might have a render resume data cache\n@@ -343,6 +372,7 @@ export function getHmrRefreshHash(\n       case 'cache':\n       case 'private-cache':\n       case 'prerender':\n+      case 'prerender-runtime':\n         return workUnitStore.hmrRefreshHash\n       case 'request':\n         return workUnitStore.cookies.get(NEXT_HMR_REFRESH_HASH_COOKIE)?.value\n@@ -359,6 +389,56 @@ export function getHmrRefreshHash(\n   return undefined\n }\n \n+export function isHmrRefresh(\n+  workStore: WorkStore,\n+  workUnitStore: WorkUnitStore\n+): boolean {\n+  if (workStore.dev) {\n+    switch (workUnitStore.type) {\n+      case 'cache':\n+      case 'private-cache':\n+      case 'request':\n+        return workUnitStore.isHmrRefresh ?? false\n+      case 'prerender':\n+      case 'prerender-client':\n+      case 'prerender-runtime':\n+      case 'prerender-ppr':\n+      case 'prerender-legacy':\n+      case 'unstable-cache':\n+        break\n+      default:\n+        workUnitStore satisfies never\n+    }\n+  }\n+\n+  return false\n+}\n+\n+export function getServerComponentsHmrCache(\n+  workStore: WorkStore,\n+  workUnitStore: WorkUnitStore\n+): ServerComponentsHmrCache | undefined {\n+  if (workStore.dev) {\n+    switch (workUnitStore.type) {\n+      case 'cache':\n+      case 'private-cache':\n+      case 'request':\n+        return workUnitStore.serverComponentsHmrCache\n+      case 'prerender':\n+      case 'prerender-client':\n+      case 'prerender-runtime':\n+      case 'prerender-ppr':\n+      case 'prerender-legacy':\n+      case 'unstable-cache':\n+        break\n+      default:\n+        workUnitStore satisfies never\n+    }\n+  }\n+\n+  return undefined\n+}\n+\n /**\n  * Returns a draft mode provider only if draft mode is enabled.\n  */\n@@ -371,6 +451,7 @@ export function getDraftModeProviderForCacheScope(\n       case 'cache':\n       case 'private-cache':\n       case 'unstable-cache':\n+      case 'prerender-runtime':\n       case 'request':\n         return workUnitStore.draftMode\n       case 'prerender':\n@@ -392,6 +473,7 @@ export function getCacheSignal(\n   switch (workUnitStore.type) {\n     case 'prerender':\n     case 'prerender-client':\n+    case 'prerender-runtime':\n       return workUnitStore.cacheSignal\n     case 'prerender-ppr':\n     case 'prerender-legacy':"
        },
        {
            "sha": "24f379ea36d0941df5743f6a3b97c4d983fcdd80",
            "filename": "packages/next/src/server/base-server.ts",
            "status": "modified",
            "additions": 14,
            "deletions": 4,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Fbase-server.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Fbase-server.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fbase-server.ts?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -2015,16 +2015,26 @@ export default abstract class Server<\n     ) {\n       const headers = req.headers\n \n-      const isPrefetchRSCRequest =\n-        headers[NEXT_ROUTER_PREFETCH_HEADER] ||\n-        getRequestMeta(req, 'isPrefetchRSCRequest')\n+      const prefetchHeaderValue = headers[NEXT_ROUTER_PREFETCH_HEADER]\n+      const routerPrefetch =\n+        prefetchHeaderValue !== undefined\n+          ? // We only recognize '1' and '2'. Strip all other values here.\n+            prefetchHeaderValue === '1' || prefetchHeaderValue === '2'\n+            ? prefetchHeaderValue\n+            : undefined\n+          : // For runtime prefetches, we always perform a dynamic request,\n+            // so we don't expect the header to be stripped by an intermediate layer.\n+            // This should only happen for static prefetches, so we only handle those here.\n+            getRequestMeta(req, 'isPrefetchRSCRequest')\n+            ? '1'\n+            : undefined\n \n       const segmentPrefetchRSCRequest =\n         headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER] ||\n         getRequestMeta(req, 'segmentPrefetchRSCRequest')\n \n       const expectedHash = computeCacheBustingSearchParam(\n-        isPrefetchRSCRequest ? '1' : '0',\n+        routerPrefetch,\n         segmentPrefetchRSCRequest,\n         headers[NEXT_ROUTER_STATE_TREE_HEADER],\n         headers[NEXT_URL]"
        },
        {
            "sha": "268ce6c875e381c082719cd371b2d83d312eeac0",
            "filename": "packages/next/src/server/lib/patch-fetch.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fpatch-fetch.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fpatch-fetch.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fpatch-fetch.ts?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -370,6 +370,7 @@ export function createPatchedFetcher(\n         if (workUnitStore) {\n           switch (workUnitStore.type) {\n             case 'prerender':\n+            case 'prerender-runtime':\n             // TODO: Stop accumulating tags in client prerender. (fallthrough)\n             case 'prerender-client':\n             case 'prerender-ppr':\n@@ -412,6 +413,7 @@ export function createPatchedFetcher(\n               break\n             case 'prerender':\n             case 'prerender-client':\n+            case 'prerender-runtime':\n             case 'prerender-ppr':\n             case 'prerender-legacy':\n             case 'request':\n@@ -552,6 +554,7 @@ export function createPatchedFetcher(\n         if (hasNoExplicitCacheConfig && workUnitStore !== undefined) {\n           switch (workUnitStore.type) {\n             case 'prerender':\n+            case 'prerender-runtime':\n             // While we don't want to do caching in the client scope we know the\n             // fetch will be dynamic for cacheComponents so we may as well avoid the\n             // call here. (fallthrough)\n@@ -668,6 +671,7 @@ export function createPatchedFetcher(\n               switch (workUnitStore.type) {\n                 case 'prerender':\n                 case 'prerender-client':\n+                case 'prerender-runtime':\n                   if (cacheSignal) {\n                     cacheSignal.endRead()\n                     cacheSignal = null\n@@ -721,6 +725,7 @@ export function createPatchedFetcher(\n               break\n             case 'prerender':\n             case 'prerender-client':\n+            case 'prerender-runtime':\n             case 'prerender-ppr':\n             case 'prerender-legacy':\n             case 'unstable-cache':\n@@ -840,6 +845,7 @@ export function createPatchedFetcher(\n                 switch (workUnitStore?.type) {\n                   case 'prerender':\n                   case 'prerender-client':\n+                  case 'prerender-runtime':\n                     return createCachedPrerenderResponse(\n                       res,\n                       cacheKey,\n@@ -912,6 +918,7 @@ export function createPatchedFetcher(\n               switch (workUnitStore.type) {\n                 case 'prerender':\n                 case 'prerender-client':\n+                case 'prerender-runtime':\n                   // We sometimes use the cache to dedupe fetches that do not\n                   // specify a cache configuration. In these cases we want to\n                   // make sure we still exclude them from prerenders if\n@@ -1013,6 +1020,7 @@ export function createPatchedFetcher(\n               switch (workUnitStore.type) {\n                 case 'prerender':\n                 case 'prerender-client':\n+                case 'prerender-runtime':\n                   if (cacheSignal) {\n                     cacheSignal.endRead()\n                     cacheSignal = null\n@@ -1052,6 +1060,7 @@ export function createPatchedFetcher(\n                 switch (workUnitStore.type) {\n                   case 'prerender':\n                   case 'prerender-client':\n+                  case 'prerender-runtime':\n                     return makeHangingPromise<Response>(\n                       workUnitStore.renderSignal,\n                       'fetch()'"
        },
        {
            "sha": "f783bf7a0690b44a39b6d6fc8b00ee0aa215646a",
            "filename": "packages/next/src/server/node-environment-extensions/console-dev.tsx",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Fconsole-dev.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Fconsole-dev.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Fconsole-dev.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -141,6 +141,7 @@ function patchConsoleMethodDEV(methodName: InterceptableConsoleMethod): void {\n       switch (workUnitStore?.type) {\n         case 'prerender':\n         case 'prerender-client':\n+        case 'prerender-runtime':\n           originalMethod.apply(this, dimConsoleCall(methodName, args))\n           break\n         case 'prerender-ppr':"
        },
        {
            "sha": "9e147e1a344e36bae1966e36f0bc17d0fe7346b2",
            "filename": "packages/next/src/server/node-environment-extensions/utils.tsx",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Futils.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Futils.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Futils.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -20,7 +20,8 @@ export function io(expression: string, type: ApiType) {\n   }\n \n   switch (workUnitStore.type) {\n-    case 'prerender': {\n+    case 'prerender':\n+    case 'prerender-runtime': {\n       const prerenderSignal = workUnitStore.controller.signal\n \n       if (prerenderSignal.aborted === false) {"
        },
        {
            "sha": "679a3d132ac57e5f5461e498dec2d4ca115f2a7f",
            "filename": "packages/next/src/server/request/connection.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fconnection.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fconnection.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fconnection.ts?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -53,7 +53,7 @@ export function connection(): Promise<void> {\n         }\n         case 'private-cache': {\n           // It might not be intuitive to throw for private caches as well, but\n-          // we don't consider dynamic prefetches as \"actual requests\" (in the\n+          // we don't consider runtime prefetches as \"actual requests\" (in the\n           // navigation sense), despite allowing them to read cookies.\n           const error = new Error(\n             `Route ${workStore.route} used \"connection\" inside \"use cache: private\". The \\`connection()\\` function is used to indicate the subsequent code must only run when there is an actual navigation request, but caches must be able to be produced before a navigation request, so this function is not allowed in this scope. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n@@ -68,6 +68,7 @@ export function connection(): Promise<void> {\n           )\n         case 'prerender':\n         case 'prerender-client':\n+        case 'prerender-runtime':\n           // We return a promise that never resolves to allow the prerender to\n           // stall at this point.\n           return makeHangingPromise("
        },
        {
            "sha": "73ddae8458c19a33dc65f9cf49b500017e95f6c5",
            "filename": "packages/next/src/server/request/cookies.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fcookies.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fcookies.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fcookies.ts?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -114,6 +114,7 @@ export function cookies(): Promise<ReadonlyRequestCookies> {\n             workStore,\n             workUnitStore\n           )\n+        case 'prerender-runtime':\n         case 'private-cache':\n           return makeUntrackedExoticCookies(workUnitStore.cookies)\n         case 'request':\n@@ -470,6 +471,7 @@ function syncIODev(route: string | undefined, expression: string) {\n         break\n       case 'prerender':\n       case 'prerender-client':\n+      case 'prerender-runtime':\n       case 'prerender-ppr':\n       case 'prerender-legacy':\n       case 'cache':"
        },
        {
            "sha": "a58f364af19bbccf4aabf49f47003366af6ce5f6",
            "filename": "packages/next/src/server/request/draft-mode.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 3,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fdraft-mode.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fdraft-mode.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fdraft-mode.ts?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -55,15 +55,16 @@ export function draftMode(): Promise<DraftMode> {\n   }\n \n   switch (workUnitStore.type) {\n+    case 'prerender-runtime':\n     case 'request':\n       return createOrGetCachedDraftMode(workUnitStore.draftMode, workStore)\n \n     case 'cache':\n     case 'private-cache':\n     case 'unstable-cache':\n       // Inside of `\"use cache\"` or `unstable_cache`, draft mode is available if\n-      // the outmost work unit store is a request store, and if draft mode is\n-      // enabled.\n+      // the outmost work unit store is a request store (or a runtime prerender),\n+      // and if draft mode is enabled.\n       const draftModeProvider = getDraftModeProviderForCacheScope(\n         workStore,\n         workUnitStore\n@@ -257,6 +258,7 @@ function syncIODev(route: string | undefined, expression: string) {\n         break\n       case 'prerender':\n       case 'prerender-client':\n+      case 'prerender-runtime':\n       case 'prerender-ppr':\n       case 'prerender-legacy':\n       case 'cache':\n@@ -322,7 +324,9 @@ function trackDynamicDraftMode(expression: string, constructorOpt: Function) {\n           throw new Error(\n             `Route ${workStore.route} used \"${expression}\" inside a function cached with \"unstable_cache(...)\". The enabled status of draftMode can be read in caches but you must not enable or disable draftMode inside a cache. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n           )\n-        case 'prerender': {\n+\n+        case 'prerender':\n+        case 'prerender-runtime': {\n           const error = new Error(\n             `Route ${workStore.route} used ${expression} without first calling \\`await connection()\\`. See more info here: https://nextjs.org/docs/messages/next-prerender-sync-headers`\n           )"
        },
        {
            "sha": "28189e018b9708b1e973f78248f797a0d93fc9c5",
            "filename": "packages/next/src/server/request/headers.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fheaders.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fheaders.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fheaders.ts?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -101,6 +101,7 @@ export function headers(): Promise<ReadonlyHeaders> {\n           )\n         case 'prerender':\n         case 'prerender-client':\n+        case 'prerender-runtime':\n         case 'prerender-ppr':\n         case 'prerender-legacy':\n         case 'request':\n@@ -119,6 +120,7 @@ export function headers(): Promise<ReadonlyHeaders> {\n     if (workUnitStore) {\n       switch (workUnitStore.type) {\n         case 'prerender':\n+        case 'prerender-runtime':\n           return makeHangingHeaders(workUnitStore)\n         case 'prerender-client':\n           const exportName = '`headers`'\n@@ -433,6 +435,7 @@ function syncIODev(route: string | undefined, expression: string) {\n         break\n       case 'prerender':\n       case 'prerender-client':\n+      case 'prerender-runtime':\n       case 'prerender-ppr':\n       case 'prerender-legacy':\n       case 'cache':"
        },
        {
            "sha": "143a6e30c5090ce5d9b5dfa1d686d6fdf8ac754e",
            "filename": "packages/next/src/server/request/params.ts",
            "status": "modified",
            "additions": 12,
            "deletions": 4,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fparams.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fparams.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fparams.ts?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -10,10 +10,10 @@ import {\n \n import {\n   workUnitAsyncStorage,\n-  type PrerenderStore,\n   type PrerenderStorePPR,\n   type PrerenderStoreLegacy,\n-  type PrerenderStoreModern,\n+  type StaticPrerenderStoreModern,\n+  type StaticPrerenderStore,\n } from '../app-render/work-unit-async-storage.external'\n import { InvariantError } from '../../shared/lib/invariant-error'\n import {\n@@ -74,6 +74,10 @@ export function createParamsFromClient(\n         throw new InvariantError(\n           'createParamsFromClient should not be called in cache contexts.'\n         )\n+      case 'prerender-runtime':\n+        throw new InvariantError(\n+          'createParamsFromClient should not be called in a runtime prerender.'\n+        )\n       case 'request':\n         break\n       default:\n@@ -106,6 +110,7 @@ export function createServerParamsForRoute(\n         throw new InvariantError(\n           'createServerParamsForRoute should not be called in cache contexts.'\n         )\n+      case 'prerender-runtime':\n       case 'request':\n         break\n       default:\n@@ -133,6 +138,7 @@ export function createServerParamsForServerSegment(\n         throw new InvariantError(\n           'createServerParamsForServerSegment should not be called in cache contexts.'\n         )\n+      case 'prerender-runtime':\n       case 'request':\n         break\n       default:\n@@ -171,6 +177,7 @@ export function createPrerenderParamsForClientSegment(\n         )\n       case 'prerender-ppr':\n       case 'prerender-legacy':\n+      case 'prerender-runtime':\n       case 'request':\n         break\n       default:\n@@ -186,7 +193,7 @@ export function createPrerenderParamsForClientSegment(\n function createPrerenderParams(\n   underlyingParams: Params,\n   workStore: WorkStore,\n-  prerenderStore: PrerenderStore\n+  prerenderStore: StaticPrerenderStore\n ): Promise<Params> {\n   switch (prerenderStore.type) {\n     case 'prerender':\n@@ -291,7 +298,7 @@ const fallbackParamsProxyHandler: ProxyHandler<Promise<Params>> = {\n \n function makeHangingParams(\n   underlyingParams: Params,\n-  prerenderStore: PrerenderStoreModern\n+  prerenderStore: StaticPrerenderStoreModern\n ): Promise<Params> {\n   const cachedParams = CachedParams.get(underlyingParams)\n   if (cachedParams) {\n@@ -578,6 +585,7 @@ function syncIODev(\n         break\n       case 'prerender':\n       case 'prerender-client':\n+      case 'prerender-runtime':\n       case 'prerender-ppr':\n       case 'prerender-legacy':\n       case 'cache':"
        },
        {
            "sha": "b13f82dd73ef879f1b36a7e57e4179a652a02a10",
            "filename": "packages/next/src/server/request/pathname.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fpathname.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fpathname.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fpathname.ts?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -7,7 +7,7 @@ import {\n \n import {\n   workUnitAsyncStorage,\n-  type PrerenderStore,\n+  type StaticPrerenderStore,\n } from '../app-render/work-unit-async-storage.external'\n import { makeHangingPromise } from '../dynamic-rendering-utils'\n import { InvariantError } from '../../shared/lib/invariant-error'\n@@ -35,6 +35,8 @@ export function createServerPathnameForMetadata(\n         throw new InvariantError(\n           'createServerPathnameForMetadata should not be called in cache contexts.'\n         )\n+\n+      case 'prerender-runtime':\n       case 'request':\n         break\n       default:\n@@ -47,7 +49,7 @@ export function createServerPathnameForMetadata(\n function createPrerenderPathname(\n   underlyingPathname: string,\n   workStore: WorkStore,\n-  prerenderStore: PrerenderStore\n+  prerenderStore: StaticPrerenderStore\n ): Promise<string> {\n   switch (prerenderStore.type) {\n     case 'prerender-client':"
        },
        {
            "sha": "3ee448a9dfea283d87400d6a657b5e3362dc898c",
            "filename": "packages/next/src/server/request/root-params.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 3,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Froot-params.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Froot-params.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Froot-params.ts?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -9,9 +9,9 @@ import {\n } from '../app-render/work-async-storage.external'\n import {\n   workUnitAsyncStorage,\n-  type PrerenderStore,\n   type PrerenderStoreLegacy,\n   type PrerenderStorePPR,\n+  type StaticPrerenderStore,\n } from '../app-render/work-unit-async-storage.external'\n import { makeHangingPromise } from '../dynamic-rendering-utils'\n import type { FallbackRouteParams } from './fallback-params'\n@@ -56,6 +56,7 @@ export async function unstable_rootParams(): Promise<Params> {\n         workUnitStore\n       )\n     case 'private-cache':\n+    case 'prerender-runtime':\n     case 'request':\n       return Promise.resolve(workUnitStore.rootParams)\n     default:\n@@ -66,7 +67,7 @@ export async function unstable_rootParams(): Promise<Params> {\n function createPrerenderRootParams(\n   underlyingParams: Params,\n   workStore: WorkStore,\n-  prerenderStore: PrerenderStore\n+  prerenderStore: StaticPrerenderStore\n ): Promise<Params> {\n   switch (prerenderStore.type) {\n     case 'prerender-client': {\n@@ -245,6 +246,7 @@ export function getRootParam(paramName: string): Promise<ParamValue> {\n       )\n     }\n     case 'private-cache':\n+    case 'prerender-runtime':\n     case 'request': {\n       break\n     }\n@@ -258,7 +260,7 @@ export function getRootParam(paramName: string): Promise<ParamValue> {\n function createPrerenderRootParamPromise(\n   paramName: string,\n   workStore: WorkStore,\n-  prerenderStore: PrerenderStore,\n+  prerenderStore: StaticPrerenderStore,\n   apiName: string\n ): Promise<ParamValue> {\n   switch (prerenderStore.type) {"
        },
        {
            "sha": "c0aef92fcbb6067917e9096b32c1e542738d2885",
            "filename": "packages/next/src/server/request/search-params.ts",
            "status": "modified",
            "additions": 12,
            "deletions": 2,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fsearch-params.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fsearch-params.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fsearch-params.ts?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -11,10 +11,10 @@ import {\n \n import {\n   workUnitAsyncStorage,\n-  type PrerenderStore,\n   type PrerenderStoreLegacy,\n   type PrerenderStorePPR,\n   type PrerenderStoreModern,\n+  type StaticPrerenderStore,\n } from '../app-render/work-unit-async-storage.external'\n import { InvariantError } from '../../shared/lib/invariant-error'\n import { makeHangingPromise } from '../dynamic-rendering-utils'\n@@ -72,6 +72,10 @@ export function createSearchParamsFromClient(\n       case 'prerender-ppr':\n       case 'prerender-legacy':\n         return createPrerenderSearchParams(workStore, workUnitStore)\n+      case 'prerender-runtime':\n+        throw new InvariantError(\n+          'createSearchParamsFromClient should not be called in a runtime prerender.'\n+        )\n       case 'cache':\n       case 'private-cache':\n       case 'unstable-cache':\n@@ -109,6 +113,7 @@ export function createServerSearchParamsForServerPage(\n         throw new InvariantError(\n           'createServerSearchParamsForServerPage should not be called in cache contexts.'\n         )\n+      case 'prerender-runtime':\n       case 'request':\n         break\n       default:\n@@ -135,6 +140,10 @@ export function createPrerenderSearchParamsForClientPage(\n         // We're prerendering in a mode that aborts (cacheComponents) and should stall\n         // the promise to ensure the RSC side is considered dynamic\n         return makeHangingPromise(workUnitStore.renderSignal, '`searchParams`')\n+      case 'prerender-runtime':\n+        throw new InvariantError(\n+          'createPrerenderSearchParamsForClientPage should not be called in a runtime prerender.'\n+        )\n       case 'cache':\n       case 'private-cache':\n       case 'unstable-cache':\n@@ -157,7 +166,7 @@ export function createPrerenderSearchParamsForClientPage(\n \n function createPrerenderSearchParams(\n   workStore: WorkStore,\n-  prerenderStore: PrerenderStore\n+  prerenderStore: StaticPrerenderStore\n ): Promise<SearchParams> {\n   if (workStore.forceStatic) {\n     // When using forceStatic we override all other logic and always just return an empty\n@@ -803,6 +812,7 @@ function syncIODev(\n         break\n       case 'prerender':\n       case 'prerender-client':\n+      case 'prerender-runtime':\n       case 'prerender-ppr':\n       case 'prerender-legacy':\n       case 'cache':"
        },
        {
            "sha": "3cabc7afba0e548d36bde9aa5bdce41f587eebed",
            "filename": "packages/next/src/server/route-modules/app-route/module.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Fapp-route%2Fmodule.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Fapp-route%2Fmodule.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Fapp-route%2Fmodule.ts?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -1189,6 +1189,10 @@ function trackDynamic(\n         throw new InvariantError(\n           'A client prerender store should not be used for a route handler.'\n         )\n+      case 'prerender-runtime':\n+        throw new InvariantError(\n+          'A runtime prerender store should not be used for a route handler.'\n+        )\n       case 'prerender-ppr':\n         return postponeWithTracking(\n           store.route,"
        },
        {
            "sha": "a02b9234b0ff6b954526a470da2b76b153956328",
            "filename": "packages/next/src/server/use-cache/cache-life.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fcache-life.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fcache-life.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fcache-life.ts?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -96,6 +96,7 @@ export function cacheLife(profile: CacheLifeProfiles | CacheLife): void {\n   switch (workUnitStore?.type) {\n     case 'prerender':\n     case 'prerender-client':\n+    case 'prerender-runtime':\n     case 'prerender-ppr':\n     case 'prerender-legacy':\n     case 'request':"
        },
        {
            "sha": "321c94249645548bd47222721d89ba5edfe3d71a",
            "filename": "packages/next/src/server/use-cache/cache-tag.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fcache-tag.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fcache-tag.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fcache-tag.ts?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -13,6 +13,7 @@ export function cacheTag(...tags: string[]): void {\n   switch (workUnitStore?.type) {\n     case 'prerender':\n     case 'prerender-client':\n+    case 'prerender-runtime':\n     case 'prerender-ppr':\n     case 'prerender-legacy':\n     case 'request':"
        },
        {
            "sha": "ca7e76d2c26d1dba97d456430b313d34665fb007",
            "filename": "packages/next/src/server/use-cache/constants.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fconstants.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fconstants.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fconstants.ts?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -1,2 +1,2 @@\n export const DYNAMIC_EXPIRE = 300 // 5 minutes\n-export const DYNAMIC_PREFETCH_DYNAMIC_STALE = 30 // 30 seconds\n+export const RUNTIME_PREFETCH_DYNAMIC_STALE = 30 // 30 seconds"
        },
        {
            "sha": "dd94d314df8396ea528c0f67232a471cb9d27b8d",
            "filename": "packages/next/src/server/use-cache/use-cache-wrapper.ts",
            "status": "modified",
            "additions": 54,
            "deletions": 12,
            "changes": 66,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -18,6 +18,7 @@ import type { WorkStore } from '../app-render/work-async-storage.external'\n import { workAsyncStorage } from '../app-render/work-async-storage.external'\n import type {\n   PrerenderStoreModernClient,\n+  PrerenderStoreModernRuntime,\n   PrivateUseCacheStore,\n   RequestStore,\n   RevalidateStore,\n@@ -31,6 +32,8 @@ import {\n   workUnitAsyncStorage,\n   getDraftModeProviderForCacheScope,\n   getCacheSignal,\n+  isHmrRefresh,\n+  getServerComponentsHmrCache,\n } from '../app-render/work-unit-async-storage.external'\n \n import { makeHangingPromise } from '../dynamic-rendering-utils'\n@@ -46,7 +49,7 @@ import type { CacheSignal } from '../app-render/cache-signal'\n import { decryptActionBoundArgs } from '../app-render/encryption'\n import { InvariantError } from '../../shared/lib/invariant-error'\n import { getDigestForWellKnownError } from '../app-render/create-error-handler'\n-import { DYNAMIC_EXPIRE, DYNAMIC_PREFETCH_DYNAMIC_STALE } from './constants'\n+import { DYNAMIC_EXPIRE, RUNTIME_PREFETCH_DYNAMIC_STALE } from './constants'\n import { getCacheHandler } from './handlers'\n import { UseCacheTimeoutError } from './use-cache-errors'\n import {\n@@ -67,8 +70,10 @@ import type { CacheLife } from './cache-life'\n \n interface PrivateCacheContext {\n   readonly kind: 'private'\n-  // TODO: Add dynamic prefetching store when this exists.\n-  readonly outerWorkUnitStore: RequestStore | PrivateUseCacheStore\n+  readonly outerWorkUnitStore:\n+    | RequestStore\n+    | PrivateUseCacheStore\n+    | PrerenderStoreModernRuntime\n }\n \n interface PublicCacheContext {\n@@ -188,8 +193,11 @@ function createUseCacheStore(\n       explicitStale: undefined,\n       tags: null,\n       hmrRefreshHash: getHmrRefreshHash(workStore, outerWorkUnitStore),\n-      isHmrRefresh: outerWorkUnitStore.isHmrRefresh ?? false,\n-      serverComponentsHmrCache: outerWorkUnitStore.serverComponentsHmrCache,\n+      isHmrRefresh: isHmrRefresh(workStore, outerWorkUnitStore),\n+      serverComponentsHmrCache: getServerComponentsHmrCache(\n+        workStore,\n+        outerWorkUnitStore\n+      ),\n       forceRevalidate: shouldForceRevalidate(workStore, outerWorkUnitStore),\n       draftMode: getDraftModeProviderForCacheScope(\n         workStore,\n@@ -209,6 +217,7 @@ function createUseCacheStore(\n         case 'request':\n           useCacheOrRequestStore = outerWorkUnitStore\n           break\n+        case 'prerender-runtime':\n         case 'prerender':\n         case 'prerender-ppr':\n         case 'prerender-legacy':\n@@ -324,8 +333,8 @@ function propagateCacheLifeAndTags(\n   entry: CacheEntry\n ): void {\n   if (cacheContext.kind === 'private') {\n-    switch (cacheContext.outerWorkUnitStore?.type) {\n-      // TODO: Also propagate cache life and tags to dynamic prefetching stores.\n+    switch (cacheContext.outerWorkUnitStore.type) {\n+      case 'prerender-runtime':\n       case 'private-cache':\n         propagateCacheLifeAndTagsToRevalidateStore(\n           cacheContext.outerWorkUnitStore,\n@@ -343,6 +352,7 @@ function propagateCacheLifeAndTags(\n       case 'cache':\n       case 'private-cache':\n       case 'prerender':\n+      case 'prerender-runtime':\n       case 'prerender-ppr':\n       case 'prerender-legacy':\n         propagateCacheLifeAndTagsToRevalidateStore(\n@@ -489,6 +499,7 @@ async function generateCacheEntryImpl(\n \n               if (outerWorkUnitStore) {\n                 switch (outerWorkUnitStore.type) {\n+                  case 'prerender-runtime':\n                   case 'prerender':\n                     // The encoded arguments might contain hanging promises. In\n                     // this case we don't want to reject with \"Error: Connection\n@@ -565,7 +576,7 @@ async function generateCacheEntryImpl(\n   let stream: ReadableStream<Uint8Array>\n \n   switch (outerWorkUnitStore?.type) {\n-    // TODO: Dynamic prefetches should also use the prerender variant.\n+    case 'prerender-runtime':\n     case 'prerender':\n       const timeoutAbortController = new AbortController()\n \n@@ -862,6 +873,7 @@ export function cache(\n             )\n           }\n           case 'request':\n+          case 'prerender-runtime':\n           case 'private-cache':\n             cacheContext = {\n               kind: 'private',\n@@ -891,6 +903,7 @@ export function cache(\n               `${expression} must not be used within a client component. Next.js should be preventing ${expression} from being allowed in client components statically, but did not in this case.`\n             )\n           case 'prerender':\n+          case 'prerender-runtime':\n           case 'prerender-ppr':\n           case 'prerender-legacy':\n           case 'request':\n@@ -1032,8 +1045,8 @@ export function cache(\n       // need to include the cookies in the cache key. This is because we don't\n       // store the cache entries in a cache handler, but only in the Resume Data\n       // Cache (RDC). Private caches are only used during dynamic requests and\n-      // dynamic prefetches. For dynamic requests, the RDC is immutable, so it\n-      // does not include any private caches. For dynamic prefetches, the RDC is\n+      // runtime prefetches. For dynamic requests, the RDC is immutable, so it\n+      // does not include any private caches. For runtime prefetches, the RDC is\n       // mutable, but only lives as long as the request, so the key does not\n       // need to include cookies.\n       const cacheKeyParts: CacheKeyParts = hmrRefreshHash\n@@ -1049,6 +1062,7 @@ export function cache(\n       let encodedCacheKeyParts: FormData | string\n \n       switch (workUnitStore?.type) {\n+        case 'prerender-runtime':\n         case 'prerender':\n           if (!isPageOrLayout) {\n             // If the \"use cache\" function is not a page or a layout, we need to\n@@ -1135,6 +1149,7 @@ export function cache(\n                     workUnitStore.renderSignal,\n                     'dynamic \"use cache\"'\n                   )\n+                case 'prerender-runtime':\n                 case 'prerender-ppr':\n                 case 'prerender-legacy':\n                 case 'request':\n@@ -1147,8 +1162,31 @@ export function cache(\n               }\n             }\n \n-            if (existingEntry.stale < DYNAMIC_PREFETCH_DYNAMIC_STALE) {\n-              // TODO: Return hanging promise for dynamic prefetches.\n+            if (existingEntry.stale < RUNTIME_PREFETCH_DYNAMIC_STALE) {\n+              switch (workUnitStore.type) {\n+                case 'prerender-runtime':\n+                  // In a runtime prerender, if the cache entry will become stale in less then 30 seconds,\n+                  // we consider this cache entry dynamic as it's not worth prefetching.\n+                  // It's better to leave a PPR hole that can be filled in dynamically\n+                  // with a potentially cached entry.\n+                  if (cacheSignal) {\n+                    cacheSignal.endRead()\n+                  }\n+                  return makeHangingPromise(\n+                    workUnitStore.renderSignal,\n+                    'dynamic \"use cache\"'\n+                  )\n+                case 'prerender':\n+                case 'prerender-ppr':\n+                case 'prerender-legacy':\n+                case 'request':\n+                case 'cache':\n+                case 'private-cache':\n+                case 'unstable-cache':\n+                  break\n+                default:\n+                  workUnitStore satisfies never\n+              }\n             }\n           }\n \n@@ -1192,6 +1230,7 @@ export function cache(\n                   )\n                 }\n                 break\n+              case 'prerender-runtime':\n               case 'prerender-ppr':\n               case 'prerender-legacy':\n               case 'request':\n@@ -1288,6 +1327,7 @@ export function cache(\n                 workUnitStore.renderSignal,\n                 'dynamic \"use cache\"'\n               )\n+            case 'prerender-runtime':\n             case 'prerender-ppr':\n             case 'prerender-legacy':\n             case 'request':\n@@ -1536,6 +1576,7 @@ function shouldForceRevalidate(\n       case 'cache':\n       case 'private-cache':\n         return workUnitStore.forceRevalidate\n+      case 'prerender-runtime':\n       case 'prerender':\n       case 'prerender-client':\n       case 'prerender-ppr':\n@@ -1579,6 +1620,7 @@ function shouldDiscardCacheEntry(\n     switch (workUnitStore.type) {\n       case 'prerender':\n         return false\n+      case 'prerender-runtime':\n       case 'prerender-client':\n       case 'prerender-ppr':\n       case 'prerender-legacy':"
        },
        {
            "sha": "09282979a5f91e6e127c35fd350ceefbb8b16a1c",
            "filename": "packages/next/src/server/web/adapter.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 3,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Fweb%2Fadapter.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Fweb%2Fadapter.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fweb%2Fadapter.ts?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -298,9 +298,8 @@ export async function adapter(\n                 onAfterTaskError: undefined,\n               },\n               requestEndedState: { ended: false },\n-              isPrefetchRequest: request.headers.has(\n-                NEXT_ROUTER_PREFETCH_HEADER\n-              ),\n+              isPrefetchRequest:\n+                request.headers.get(NEXT_ROUTER_PREFETCH_HEADER) === '1',\n               buildId: buildId ?? '',\n               previouslyRevalidatedTags: [],\n             })"
        },
        {
            "sha": "4cd7c62bc396b216b6ae63c3ae5b08eba8ae62d9",
            "filename": "packages/next/src/server/web/spec-extension/revalidate.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Fweb%2Fspec-extension%2Frevalidate.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Fweb%2Fspec-extension%2Frevalidate.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fweb%2Fspec-extension%2Frevalidate.ts?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -110,6 +110,7 @@ function revalidate(tags: string[], expression: string) {\n           `Route ${store.route} used \"${expression}\" inside a function cached with \"unstable_cache(...)\" which is unsupported. To ensure revalidation is performed consistently it must always happen outside of renders and cached functions. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n         )\n       case 'prerender':\n+      case 'prerender-runtime':\n         // cacheComponents Prerender\n         const error = new Error(\n           `Route ${store.route} used ${expression} without first calling \\`await connection()\\`.`"
        },
        {
            "sha": "555e88541e5b6a01247110f84d049d03d395ecbd",
            "filename": "packages/next/src/server/web/spec-extension/unstable-cache.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Fweb%2Fspec-extension%2Funstable-cache.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Fweb%2Fspec-extension%2Funstable-cache.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fweb%2Fspec-extension%2Funstable-cache.ts?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -163,6 +163,7 @@ export function unstable_cache<T extends Callback>(\n             case 'cache':\n             case 'private-cache':\n             case 'prerender':\n+            case 'prerender-runtime':\n             case 'prerender-ppr':\n             case 'prerender-legacy':\n               // We update the store's revalidate property if the option.revalidate is a higher precedence\n@@ -384,6 +385,7 @@ function getFetchUrlPrefix(\n       return `${pathname}${sortedSearch.length ? '?' : ''}${sortedSearch}`\n     case 'prerender':\n     case 'prerender-client':\n+    case 'prerender-runtime':\n     case 'prerender-ppr':\n     case 'prerender-legacy':\n     case 'cache':"
        },
        {
            "sha": "4d6926b23e52f77b4385de36cd8c3398a1834e68",
            "filename": "packages/next/src/server/web/spec-extension/unstable-no-store.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Fweb%2Fspec-extension%2Funstable-no-store.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fserver%2Fweb%2Fspec-extension%2Funstable-no-store.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fweb%2Fspec-extension%2Funstable-no-store.ts?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -34,6 +34,7 @@ export function unstable_noStore() {\n       switch (workUnitStore.type) {\n         case 'prerender':\n         case 'prerender-client':\n+        case 'prerender-runtime':\n           // unstable_noStore() is a noop in Dynamic I/O.\n           return\n         case 'prerender-ppr':"
        },
        {
            "sha": "ac671ec1e2648016bf7b335c2dd27ed01fb1cf3a",
            "filename": "packages/next/src/shared/lib/router/utils/cache-busting-search-param.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Fcache-busting-search-param.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Fcache-busting-search-param.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Fcache-busting-search-param.ts?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -1,7 +1,7 @@\n import { hexHash } from '../../hash'\n \n export function computeCacheBustingSearchParam(\n-  prefetchHeader: '1' | '0' | undefined,\n+  prefetchHeader: '1' | '2' | '0' | undefined,\n   segmentPrefetchHeader: string | string[] | undefined,\n   stateTreeHeader: string | string[] | undefined,\n   nextUrlHeader: string | string[] | undefined"
        },
        {
            "sha": "ea4e9e44440b83cb8392a633273e269fc19952b6",
            "filename": "test/e2e/app-dir/searchparams-reuse-loading/app/page.tsx",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsearchparams-reuse-loading%2Fapp%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsearchparams-reuse-loading%2Fapp%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsearchparams-reuse-loading%2Fapp%2Fpage.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -16,13 +16,13 @@ export default async function Page(props) {\n           <Link href=\"/search-params?id=2\">/search-params?id=2</Link>\n         </li>\n         <li>\n-          <Link href=\"/search-params?id=3\" prefetch>\n-            /search-params?id=3 (prefetch: true)\n+          <Link href=\"/search-params?id=3\" prefetch=\"unstable_forceStale\">\n+            /search-params?id=3 (prefetch: unstable_forceStale)\n           </Link>\n         </li>\n         <li>\n-          <Link href=\"/search-params\" prefetch>\n-            /search-params (prefetch: true)\n+          <Link href=\"/search-params\" prefetch=\"unstable_forceStale\">\n+            /search-params (prefetch: unstable_forceStale)\n           </Link>\n         </li>\n         <li>"
        },
        {
            "sha": "f62bc8039bfe74565a23f78746c655deb9c96dc7",
            "filename": "test/e2e/app-dir/searchparams-reuse-loading/app/with-middleware/page.tsx",
            "status": "modified",
            "additions": 9,
            "deletions": 3,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsearchparams-reuse-loading%2Fapp%2Fwith-middleware%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsearchparams-reuse-loading%2Fapp%2Fwith-middleware%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsearchparams-reuse-loading%2Fapp%2Fwith-middleware%2Fpage.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -5,7 +5,7 @@ export default function Page() {\n     <ul>\n       <li>\n         <Link href=\"/with-middleware/search-params?id=1\">\n-          /search-params?id=1 (prefetch: true)\n+          /search-params?id=1\n         </Link>\n       </li>\n       <li>\n@@ -14,12 +14,18 @@ export default function Page() {\n         </Link>\n       </li>\n       <li>\n-        <Link href=\"/with-middleware/search-params?id=3\" prefetch>\n+        <Link\n+          href=\"/with-middleware/search-params?id=3\"\n+          prefetch=\"unstable_forceStale\"\n+        >\n           /search-params?id=3 (prefetch: true)\n         </Link>\n       </li>\n       <li>\n-        <Link href=\"/with-middleware/search-params\" prefetch>\n+        <Link\n+          href=\"/with-middleware/search-params\"\n+          prefetch=\"unstable_forceStale\"\n+        >\n           /search-params (prefetch: true)\n         </Link>\n       </li>"
        },
        {
            "sha": "ff8070c83b1cae81f091e8dc3852749875f8a1f4",
            "filename": "test/e2e/app-dir/segment-cache/cdn-cache-busting/cdn-cache-busting.test.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fcdn-cache-busting%2Fcdn-cache-busting.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fcdn-cache-busting%2Fcdn-cache-busting.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fcdn-cache-busting%2Fcdn-cache-busting.test.ts?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -11,6 +11,8 @@ describe('segment cache (CDN cache busting)', () => {\n     return\n   }\n \n+  // TODO(runtime-ppr): add tests for runtime prefetches\n+\n   // To debug these tests locally, run:\n   //   node start.mjs\n   //"
        },
        {
            "sha": "c6848d479aef8cacef3a5d226cd017eae08edf71",
            "filename": "test/e2e/app-dir/segment-cache/cdn-cache-busting/components/link-accordion.tsx",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fcdn-cache-busting%2Fcomponents%2Flink-accordion.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fcdn-cache-busting%2Fcomponents%2Flink-accordion.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fcdn-cache-busting%2Fcomponents%2Flink-accordion.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -1,6 +1,6 @@\n 'use client'\n \n-import Link from 'next/link'\n+import Link, { type LinkProps } from 'next/link'\n import { useState } from 'react'\n \n export function LinkAccordion({\n@@ -10,7 +10,7 @@ export function LinkAccordion({\n }: {\n   href: string\n   children: React.ReactNode\n-  prefetch?: boolean\n+  prefetch?: LinkProps['prefetch']\n }) {\n   const [isVisible, setIsVisible] = useState(false)\n   return ("
        },
        {
            "sha": "c6848d479aef8cacef3a5d226cd017eae08edf71",
            "filename": "test/e2e/app-dir/segment-cache/client-only-opt-in/components/link-accordion.tsx",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fclient-only-opt-in%2Fcomponents%2Flink-accordion.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fclient-only-opt-in%2Fcomponents%2Flink-accordion.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fclient-only-opt-in%2Fcomponents%2Flink-accordion.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -1,6 +1,6 @@\n 'use client'\n \n-import Link from 'next/link'\n+import Link, { type LinkProps } from 'next/link'\n import { useState } from 'react'\n \n export function LinkAccordion({\n@@ -10,7 +10,7 @@ export function LinkAccordion({\n }: {\n   href: string\n   children: React.ReactNode\n-  prefetch?: boolean\n+  prefetch?: LinkProps['prefetch']\n }) {\n   const [isVisible, setIsVisible] = useState(false)\n   return ("
        },
        {
            "sha": "c6848d479aef8cacef3a5d226cd017eae08edf71",
            "filename": "test/e2e/app-dir/segment-cache/deployment-skew/components/link-accordion.tsx",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fdeployment-skew%2Fcomponents%2Flink-accordion.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fdeployment-skew%2Fcomponents%2Flink-accordion.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fdeployment-skew%2Fcomponents%2Flink-accordion.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -1,6 +1,6 @@\n 'use client'\n \n-import Link from 'next/link'\n+import Link, { type LinkProps } from 'next/link'\n import { useState } from 'react'\n \n export function LinkAccordion({\n@@ -10,7 +10,7 @@ export function LinkAccordion({\n }: {\n   href: string\n   children: React.ReactNode\n-  prefetch?: boolean\n+  prefetch?: LinkProps['prefetch']\n }) {\n   const [isVisible, setIsVisible] = useState(false)\n   return ("
        },
        {
            "sha": "4aa5ddff9ebcba191fdef8b2c04ac969aad3eb71",
            "filename": "test/e2e/app-dir/segment-cache/dynamic-on-hover/components/link-accordion.tsx",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fdynamic-on-hover%2Fcomponents%2Flink-accordion.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fdynamic-on-hover%2Fcomponents%2Flink-accordion.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fdynamic-on-hover%2Fcomponents%2Flink-accordion.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -1,6 +1,6 @@\n 'use client'\n \n-import Link from 'next/link'\n+import Link, { type LinkProps } from 'next/link'\n import { useState } from 'react'\n \n export function LinkAccordion({\n@@ -11,7 +11,7 @@ export function LinkAccordion({\n }: {\n   href: string\n   children: React.ReactNode\n-  prefetch?: boolean\n+  prefetch?: LinkProps['prefetch']\n   unstable_dynamicOnHover?: boolean\n }) {\n   const [isVisible, setIsVisible] = useState(false)"
        },
        {
            "sha": "40e57151e305518c114a1c043b453ed2bf654011",
            "filename": "test/e2e/app-dir/segment-cache/incremental-opt-in/app/link-accordion.tsx",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fincremental-opt-in%2Fapp%2Flink-accordion.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fincremental-opt-in%2Fapp%2Flink-accordion.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fincremental-opt-in%2Fapp%2Flink-accordion.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -1,6 +1,6 @@\n 'use client'\n \n-import Link from 'next/link'\n+import Link, { type LinkProps } from 'next/link'\n import { useState } from 'react'\n \n export function LinkAccordion({\n@@ -11,7 +11,7 @@ export function LinkAccordion({\n }: {\n   href: string\n   children: string\n-  prefetch?: boolean\n+  prefetch?: LinkProps['prefetch']\n   id?: string\n }) {\n   const [isVisible, setIsVisible] = useState(false)"
        },
        {
            "sha": "bc02ad99ecf6310726bbe2c96b5329014a58aebb",
            "filename": "test/e2e/app-dir/segment-cache/incremental-opt-in/app/mixed-fetch-strategies/page.tsx",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fincremental-opt-in%2Fapp%2Fmixed-fetch-strategies%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fincremental-opt-in%2Fapp%2Fmixed-fetch-strategies%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fincremental-opt-in%2Fapp%2Fmixed-fetch-strategies%2Fpage.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -22,10 +22,10 @@ export default function MixedFetchStrategies() {\n             <li>\n               <LinkAccordion\n                 id=\"ppr-enabled-prefetch-true\"\n-                prefetch={true}\n+                prefetch=\"unstable_forceStale\"\n                 href=\"/mixed-fetch-strategies/has-loading-boundary/a/b/shared-layout/ppr-enabled\"\n               >\n-                Same link, but with prefetch=true\n+                Same link, but with prefetch=\"unstable_forceStale\"\n               </LinkAccordion>\n             </li>\n           </ul>"
        },
        {
            "sha": "0ec9849e6ed8b6a711e6fc0743944ac1f4b50b4b",
            "filename": "test/e2e/app-dir/segment-cache/incremental-opt-in/segment-cache-incremental-opt-in.test.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fincremental-opt-in%2Fsegment-cache-incremental-opt-in.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fincremental-opt-in%2Fsegment-cache-incremental-opt-in.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fincremental-opt-in%2Fsegment-cache-incremental-opt-in.test.ts?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -285,7 +285,7 @@ describe('segment cache (incremental opt in)', () => {\n   )\n \n   it(\n-    'when a link is prefetched with <Link prefetch=true>, no dynamic request ' +\n+    'when a link is prefetched with <Link prefetch=\"unstable_forceStale\">, no dynamic request ' +\n       'is made on navigation',\n     async () => {\n       let act\n@@ -324,7 +324,7 @@ describe('segment cache (incremental opt in)', () => {\n   )\n \n   it(\n-    'when prefetching with prefetch=true, refetches cache entries that only ' +\n+    'when prefetching with prefetch=\"unstable_forceStale\", refetches cache entries that only ' +\n       'contain partial data',\n     async () => {\n       let act\n@@ -343,7 +343,7 @@ describe('segment cache (incremental opt in)', () => {\n         { includes: 'Loading (PPR shell of shared-layout)...' }\n       )\n \n-      // Prefetch the same link again, this time with prefetch=true to include\n+      // Prefetch the same link again, this time with prefetch=\"unstable_forceStale\" to include\n       // the dynamic data\n       await act(\n         async () => {\n@@ -370,7 +370,7 @@ describe('segment cache (incremental opt in)', () => {\n           // If this fails, it likely means that the partial cache entry that\n           // resulted from prefetching the normal link (<Link prefetch={false}>)\n           // was not properly re-fetched when the full link (<Link\n-          // prefetch={true}>) was prefetched.\n+          // prefetch='unstable_forceStale'>) was prefetched.\n           await browser.elementById('page-content')\n         },\n         // Assert that no network requests are initiated within this block.\n@@ -380,7 +380,7 @@ describe('segment cache (incremental opt in)', () => {\n   )\n \n   it(\n-    'when prefetching with prefetch=true, refetches partial cache entries ' +\n+    'when prefetching with prefetch=\"unstable_forceStale\", refetches partial cache entries ' +\n       \"even if there's already a pending PPR request\",\n     async () => {\n       // This test is hard to describe succinctly because it involves a fairly\n@@ -427,7 +427,7 @@ describe('segment cache (incremental opt in)', () => {\n         )\n \n         // Before the previous prefetch finishes, prefetch the same link again,\n-        // this time with prefetch=true to include the dynamic data.\n+        // this time with prefetch=\"unstable_forceStale\" to include the dynamic data.\n         await act(\n           async () => {\n             const checkbox = await browser.elementById(\n@@ -457,7 +457,7 @@ describe('segment cache (incremental opt in)', () => {\n           // If this fails, it likely means that the pending cache entry that\n           // resulted from prefetching the normal link (<Link prefetch={false}>)\n           // was not properly re-fetched when the full link (<Link\n-          // prefetch={true}>) was prefetched.\n+          // prefetch='unstable_forceStale'>) was prefetched.\n           await browser.elementById('page-content')\n         },\n         // Assert that no network requests are initiated within this block."
        },
        {
            "sha": "40e57151e305518c114a1c043b453ed2bf654011",
            "filename": "test/e2e/app-dir/segment-cache/metadata/app/link-accordion.tsx",
            "status": "modified",
            "additions": 2,
            "deletions": 3,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fmetadata%2Fapp%2Flink-accordion.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fmetadata%2Fapp%2Flink-accordion.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fmetadata%2Fapp%2Flink-accordion.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -1,6 +1,6 @@\n 'use client'\n \n-import Link from 'next/link'\n+import Link, { type LinkProps } from 'next/link'\n import { useState } from 'react'\n \n export function LinkAccordion({\n@@ -11,7 +11,7 @@ export function LinkAccordion({\n }: {\n   href: string\n   children: string\n-  prefetch?: boolean | 'unstable_forceStale' | 'auto'\n+  prefetch?: LinkProps['prefetch']\n   id?: string\n }) {\n   const [isVisible, setIsVisible] = useState(false)\n@@ -25,7 +25,6 @@ export function LinkAccordion({\n         id={id}\n       />\n       {isVisible ? (\n-        // @ts-expect-error - unstable_forceStale is not yet part of the types\n         <Link href={href} prefetch={prefetch}>\n           {children}\n         </Link>"
        },
        {
            "sha": "7c89517c848adb602d74057deedf1a2f3b59f6f0",
            "filename": "test/e2e/app-dir/segment-cache/metadata/app/page-with-runtime-prefetchable-head/page.tsx",
            "status": "added",
            "additions": 23,
            "deletions": 0,
            "changes": 23,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fmetadata%2Fapp%2Fpage-with-runtime-prefetchable-head%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fmetadata%2Fapp%2Fpage-with-runtime-prefetchable-head%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fmetadata%2Fapp%2Fpage-with-runtime-prefetchable-head%2Fpage.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -0,0 +1,23 @@\n+import { Metadata } from 'next'\n+import { Suspense } from 'react'\n+import { cookies } from 'next/headers'\n+\n+export async function generateMetadata(): Promise<Metadata> {\n+  await cookies()\n+  return {\n+    title: 'Runtime-prefetchable title',\n+  }\n+}\n+\n+async function Content() {\n+  await cookies()\n+  return <div id=\"target-page\">Target page</div>\n+}\n+\n+export default function PageWithRuntimePrefetchableTitle() {\n+  return (\n+    <Suspense fallback=\"Loading...\">\n+      <Content />\n+    </Suspense>\n+  )\n+}"
        },
        {
            "sha": "99d91b37e35b1ecd5b2f6c319d3fcb91b93901a0",
            "filename": "test/e2e/app-dir/segment-cache/metadata/app/page.tsx",
            "status": "modified",
            "additions": 26,
            "deletions": 4,
            "changes": 30,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fmetadata%2Fapp%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fmetadata%2Fapp%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fmetadata%2Fapp%2Fpage.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -5,16 +5,38 @@ export default function Page() {\n     <>\n       <ul>\n         <li>\n-          <LinkAccordion prefetch={true} href=\"/page-with-dynamic-head\">\n-            Page with dynamic head (prefetch=true))\n+          <LinkAccordion\n+            prefetch=\"unstable_forceStale\"\n+            href=\"/page-with-dynamic-head\"\n+          >\n+            Page with dynamic head (prefetch=unstable_forceStale)\n           </LinkAccordion>\n         </li>\n         <li>\n           <LinkAccordion\n-            prefetch={true}\n+            prefetch=\"unstable_forceStale\"\n             href=\"/rewrite-to-page-with-dynamic-head\"\n           >\n-            Rewrite to page with dynamic head (prefetch=true)\n+            Rewrite to page with dynamic head (prefetch=unstable_forceStale)\n+          </LinkAccordion>\n+        </li>\n+      </ul>\n+      <hr />\n+      <ul>\n+        <li>\n+          <LinkAccordion\n+            prefetch=\"unstable_forceStale\"\n+            href=\"/page-with-runtime-prefetchable-head\"\n+          >\n+            Page with runtime-prefetchable head (prefetch=true)\n+          </LinkAccordion>\n+        </li>\n+        <li>\n+          <LinkAccordion\n+            prefetch=\"unstable_forceStale\"\n+            href=\"/rewrite-to-page-with-runtime-prefetchable-head\"\n+          >\n+            Rewrite to page with runtime-prefetchable head (prefetch=true)\n           </LinkAccordion>\n         </li>\n       </ul>"
        },
        {
            "sha": "669695f920dc57f44e9b14ed8838c7efb2a2e3e2",
            "filename": "test/e2e/app-dir/segment-cache/metadata/next.config.js",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fmetadata%2Fnext.config.js",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fmetadata%2Fnext.config.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fmetadata%2Fnext.config.js?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -12,6 +12,10 @@ const nextConfig = {\n         source: '/rewrite-to-page-with-dynamic-head',\n         destination: '/page-with-dynamic-head',\n       },\n+      {\n+        source: '/rewrite-to-page-with-runtime-prefetchable-head',\n+        destination: '/page-with-runtime-prefetchable-head',\n+      },\n     ]\n   },\n }"
        },
        {
            "sha": "2866e499a38ec5f4755e2090f5f5f0826bf2c2e6",
            "filename": "test/e2e/app-dir/segment-cache/metadata/segment-cache-metadata.test.ts",
            "status": "modified",
            "additions": 70,
            "deletions": 8,
            "changes": 78,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fmetadata%2Fsegment-cache-metadata.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fmetadata%2Fsegment-cache-metadata.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fmetadata%2Fsegment-cache-metadata.test.ts?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -9,12 +9,9 @@ describe('segment cache (metadata)', () => {\n     test('disabled in development', () => {})\n     return\n   }\n-\n-  it(\n-    \"regression: prefetch the head if it's missing even if all other data \" +\n-      'is cached',\n-    async () => {\n-      let act\n+  describe(\"regression: prefetch the head if it's missing even if all other data is cached\", () => {\n+    it('pages with dynamic content and dynamic metadata, using a full prefetch', async () => {\n+      let act: ReturnType<typeof createRouterAct>\n       const browser = await next.browser('/', {\n         beforePageLoad(p) {\n           act = createRouterAct(p)\n@@ -75,6 +72,71 @@ describe('segment cache (metadata)', () => {\n         const title = await browser.eval(() => document.title)\n         expect(title).toBe('Dynamic Title')\n       }, 'no-requests')\n-    }\n-  )\n+    })\n+\n+    it('pages with runtime-prefetchable content and dynamic metadata, using a runtime prefetch', async () => {\n+      let act: ReturnType<typeof createRouterAct>\n+      const browser = await next.browser('/', {\n+        beforePageLoad(p) {\n+          act = createRouterAct(p)\n+        },\n+      })\n+\n+      // Runtime-prefetch a page.\n+      // It only uses cookies, so this should be a complete prefetch.\n+      await act(async () => {\n+        const checkbox = await browser.elementByCss(\n+          'input[data-link-accordion=\"/page-with-runtime-prefetchable-head\"]'\n+        )\n+        await checkbox.click()\n+      }, [\n+        // Because the link is prefetched with prefetch=\"unstable_forceStale\",\n+        // we should be able to prefetch the title, even though it's dynamic.\n+        {\n+          includes: 'Runtime-prefetchable title',\n+        },\n+        {\n+          includes: 'Target page',\n+        },\n+      ])\n+\n+      // Now runtime-prefetch a link that rewrites to the same underlying page.\n+      await act(async () => {\n+        const checkbox = await browser.elementByCss(\n+          'input[data-link-accordion=\"/rewrite-to-page-with-runtime-prefetchable-head\"]'\n+        )\n+        await checkbox.click()\n+      }, [\n+        // TODO: Ideally, this would not prefetch the dynamic title again,\n+        // because it was already prefetched by the previous link, and both\n+        // links resolve to the same underlying route. This is because, unlike\n+        // segment data, we cache routes solely by their input URL, not by the\n+        // path of the underlying route. Similarly, we don't cache metadata\n+        // separately from the route tree. We should probably do one or both.\n+        {\n+          includes: 'Runtime-prefetchable title',\n+        },\n+        // It should not prefetch the page content again, because it was\n+        // already cached.\n+        {\n+          includes: 'Target page',\n+          block: 'reject',\n+        },\n+      ])\n+\n+      // When we navigate to the page, it should not make any additional\n+      // network requests, because both the segment data and the head were\n+      // fully prefetched.\n+      await act(async () => {\n+        const link = await browser.elementByCss(\n+          'a[href=\"/rewrite-to-page-with-runtime-prefetchable-head\"]'\n+        )\n+        await link.click()\n+        const pageContent = await browser.elementById('target-page')\n+        expect(await pageContent.text()).toBe('Target page')\n+        const title = await browser.eval(() => document.title)\n+        expect(title).toBe('Runtime-prefetchable title')\n+      }, 'no-requests')\n+    })\n+  })\n })"
        },
        {
            "sha": "c6848d479aef8cacef3a5d226cd017eae08edf71",
            "filename": "test/e2e/app-dir/segment-cache/mpa-navigations/components/link-accordion.tsx",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fmpa-navigations%2Fcomponents%2Flink-accordion.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fmpa-navigations%2Fcomponents%2Flink-accordion.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fmpa-navigations%2Fcomponents%2Flink-accordion.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -1,6 +1,6 @@\n 'use client'\n \n-import Link from 'next/link'\n+import Link, { type LinkProps } from 'next/link'\n import { useState } from 'react'\n \n export function LinkAccordion({\n@@ -10,7 +10,7 @@ export function LinkAccordion({\n }: {\n   href: string\n   children: React.ReactNode\n-  prefetch?: boolean\n+  prefetch?: LinkProps['prefetch']\n }) {\n   const [isVisible, setIsVisible] = useState(false)\n   return ("
        },
        {
            "sha": "191aeead41903b889eef106ad59f942f5b706027",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-auto/components/link-accordion.tsx",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-auto%2Fcomponents%2Flink-accordion.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-auto%2Fcomponents%2Flink-accordion.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-auto%2Fcomponents%2Flink-accordion.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -1,6 +1,6 @@\n 'use client'\n \n-import Link, { LinkProps } from 'next/link'\n+import Link, { type LinkProps } from 'next/link'\n import { useState } from 'react'\n \n export function LinkAccordion({"
        },
        {
            "sha": "54b2b3630b432117f1f5af2bc05fbfd4107ec304",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-layout-sharing/app/layout.tsx",
            "status": "added",
            "additions": 23,
            "deletions": 0,
            "changes": 23,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-layout-sharing%2Fapp%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-layout-sharing%2Fapp%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-layout-sharing%2Fapp%2Flayout.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -0,0 +1,23 @@\n+import Link from 'next/link'\n+import { ReactNode } from 'react'\n+\n+export default function RootLayout({ children }: { children: ReactNode }) {\n+  return (\n+    <html>\n+      <body style={{ fontFamily: 'monospace' }}>\n+        <Header />\n+        {children}\n+      </body>\n+    </html>\n+  )\n+}\n+\n+function Header() {\n+  return (\n+    <header>\n+      <Link href=\"/\" prefetch={false}>\n+        Home\n+      </Link>\n+    </header>\n+  )\n+}"
        },
        {
            "sha": "3d08470aa081f5dfac7ad7f7f0a8544cb0dffb51",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-layout-sharing/app/page.tsx",
            "status": "added",
            "additions": 58,
            "deletions": 0,
            "changes": 58,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-layout-sharing%2Fapp%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-layout-sharing%2Fapp%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-layout-sharing%2Fapp%2Fpage.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -0,0 +1,58 @@\n+import { DebugLinkAccordion } from '../components/link-accordion'\n+import { unstable_cacheLife } from 'next/cache'\n+\n+export default async function Page() {\n+  'use cache'\n+  unstable_cacheLife('minutes')\n+  return (\n+    <main>\n+      <h2>shared layout prefetching - layout with cookies and dynamic data</h2>\n+      <ul>\n+        <li>\n+          <DebugLinkAccordion href=\"/shared-layout/one\" prefetch={true} />\n+        </li>\n+        <li>\n+          <DebugLinkAccordion\n+            href=\"/shared-layout/one\"\n+            prefetch={'unstable_forceStale'}\n+          />\n+        </li>\n+      </ul>\n+      <ul>\n+        <li>\n+          <DebugLinkAccordion href=\"/shared-layout/two\" prefetch={'auto'} />\n+        </li>\n+        <li>\n+          <DebugLinkAccordion href=\"/shared-layout/two\" prefetch={true} />\n+        </li>\n+        <li>\n+          <DebugLinkAccordion\n+            href=\"/shared-layout/two\"\n+            prefetch={'unstable_forceStale'}\n+          />\n+        </li>\n+      </ul>\n+      <h2>shared layout prefetching - layout with cookies</h2>\n+      <ul>\n+        <li>\n+          <DebugLinkAccordion\n+            href=\"/runtime-prefetchable-layout/one\"\n+            prefetch={true}\n+          />\n+        </li>\n+        <li>\n+          <DebugLinkAccordion\n+            href=\"/runtime-prefetchable-layout/two\"\n+            prefetch={'auto'}\n+          />\n+        </li>\n+        <li>\n+          <DebugLinkAccordion\n+            href=\"/runtime-prefetchable-layout/two\"\n+            prefetch={'unstable_forceStale'}\n+          />\n+        </li>\n+      </ul>\n+    </main>\n+  )\n+}"
        },
        {
            "sha": "e6723448ba9b442f389052a2473d82f45a870bf0",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-layout-sharing/app/runtime-prefetchable-layout/layout.tsx",
            "status": "added",
            "additions": 34,
            "deletions": 0,
            "changes": 34,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-layout-sharing%2Fapp%2Fruntime-prefetchable-layout%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-layout-sharing%2Fapp%2Fruntime-prefetchable-layout%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-layout-sharing%2Fapp%2Fruntime-prefetchable-layout%2Flayout.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -0,0 +1,34 @@\n+import { cookies } from 'next/headers'\n+import { Suspense } from 'react'\n+import { cachedDelay, DebugRenderKind } from '../shared'\n+\n+export default async function Layout({ children }) {\n+  return (\n+    <main>\n+      <div>\n+        <h2>Shared layout</h2>\n+        <DebugRenderKind />\n+        <p id=\"shared-layout-description\">\n+          This shared layout uses cookies and no uncached IO, so it should be\n+          completely runtime-prefetchable.\n+        </p>\n+        <Suspense fallback={<div style={{ color: 'grey' }}>Loading 1...</div>}>\n+          <RuntimePrefetchable />\n+        </Suspense>\n+      </div>\n+      <hr />\n+      {children}\n+    </main>\n+  )\n+}\n+\n+async function RuntimePrefetchable() {\n+  const cookieStore = await cookies()\n+  const cookieValue = cookieStore.get('testCookie')?.value ?? null\n+  await cachedDelay(500, [__filename, cookieValue])\n+  return (\n+    <div style={{ border: '1px solid blue', padding: '1em' }}>\n+      <div id=\"cookie-value-layout\">{`Cookie from layout: ${cookieValue}`}</div>\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "85066bc245ac472ca5a053bb6f713e77eb8674a7",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-layout-sharing/app/runtime-prefetchable-layout/one/page.tsx",
            "status": "added",
            "additions": 34,
            "deletions": 0,
            "changes": 34,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-layout-sharing%2Fapp%2Fruntime-prefetchable-layout%2Fone%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-layout-sharing%2Fapp%2Fruntime-prefetchable-layout%2Fone%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-layout-sharing%2Fapp%2Fruntime-prefetchable-layout%2Fone%2Fpage.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -0,0 +1,34 @@\n+import { Suspense } from 'react'\n+import { cachedDelay } from '../../shared'\n+import { cookies } from 'next/headers'\n+\n+export default function Page() {\n+  return (\n+    <main>\n+      <h1 style={{ color: 'yellow' }}>Page one</h1>\n+      <Suspense fallback={<div style={{ color: 'grey' }}>Loading 1...</div>}>\n+        <RuntimePrefetchable />\n+      </Suspense>\n+    </main>\n+  )\n+}\n+\n+async function RuntimePrefetchable() {\n+  const cookieStore = await cookies()\n+  const cookieValue = cookieStore.get('testCookie')?.value ?? null\n+  await cachedDelay(500, [__filename, cookieValue])\n+  return (\n+    <div style={{ border: '1px solid blue', padding: '1em' }}>\n+      <div id=\"cookie-value-page\">{`Cookie from page: ${cookieValue}`}</div>\n+      {/*\n+        TODO: a runtime-prefetched layout that had no holes itself will still be considered partial\n+        if any other segment in the response is partial, because we don't track partiality per-segment,\n+        so if we want to test that full prefetches can reuse layouts from runtime prefetches,\n+        the whole page needs to be dynamically prerenderable.\n+       */}\n+      {/* <Suspense fallback={<div style={{ color: 'grey' }}>Loading 2...</div>}>\n+        <Dynamic />\n+      </Suspense> */}\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "604205bb78bba6d09345312cab85b26762b616e8",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-layout-sharing/app/runtime-prefetchable-layout/two/page.tsx",
            "status": "added",
            "additions": 37,
            "deletions": 0,
            "changes": 37,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-layout-sharing%2Fapp%2Fruntime-prefetchable-layout%2Ftwo%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-layout-sharing%2Fapp%2Fruntime-prefetchable-layout%2Ftwo%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-layout-sharing%2Fapp%2Fruntime-prefetchable-layout%2Ftwo%2Fpage.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -0,0 +1,37 @@\n+import { Suspense } from 'react'\n+import { cachedDelay, uncachedIO } from '../../shared'\n+import { cookies } from 'next/headers'\n+\n+export default function Page() {\n+  return (\n+    <main>\n+      <h1 style={{ color: 'green' }}>Page two</h1>\n+      <Suspense fallback={<div style={{ color: 'grey' }}>Loading 1...</div>}>\n+        <RuntimePrefetchable />\n+      </Suspense>\n+    </main>\n+  )\n+}\n+\n+async function RuntimePrefetchable() {\n+  const cookieStore = await cookies()\n+  const cookieValue = cookieStore.get('testCookie')?.value ?? null\n+  await cachedDelay(500, [__filename, cookieValue])\n+  return (\n+    <div style={{ border: '1px solid blue', padding: '1em' }}>\n+      <div id=\"cookie-value-page\">{`Cookie from page: ${cookieValue}`}</div>\n+      <Suspense fallback={<div style={{ color: 'grey' }}>Loading 2...</div>}>\n+        <Dynamic />\n+      </Suspense>\n+    </div>\n+  )\n+}\n+\n+async function Dynamic() {\n+  await uncachedIO()\n+  return (\n+    <div style={{ border: '1px solid tomato', padding: '1em' }}>\n+      <div id=\"dynamic-content-page\">Dynamic content from page two</div>\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "95197f5bc837520db32530a9d8209ce4a9143999",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-layout-sharing/app/shared-layout/layout.tsx",
            "status": "added",
            "additions": 48,
            "deletions": 0,
            "changes": 48,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-layout-sharing%2Fapp%2Fshared-layout%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-layout-sharing%2Fapp%2Fshared-layout%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-layout-sharing%2Fapp%2Fshared-layout%2Flayout.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -0,0 +1,48 @@\n+import { cookies } from 'next/headers'\n+import { Suspense } from 'react'\n+import { cachedDelay, DebugRenderKind, uncachedIO } from '../shared'\n+import { connection } from 'next/server'\n+\n+export default async function Layout({ children }) {\n+  return (\n+    <main>\n+      <div>\n+        <h2>Shared layout</h2>\n+        <DebugRenderKind />\n+        <p id=\"shared-layout-description\">\n+          This shared layout uses cookies and some uncached IO, so parts of it\n+          should be runtime-prefetchable.\n+        </p>\n+        <Suspense fallback={<div style={{ color: 'grey' }}>Loading 1...</div>}>\n+          <RuntimePrefetchable />\n+        </Suspense>\n+      </div>\n+      <hr />\n+      {children}\n+    </main>\n+  )\n+}\n+\n+async function RuntimePrefetchable() {\n+  const cookieStore = await cookies()\n+  const cookieValue = cookieStore.get('testCookie')?.value ?? null\n+  await cachedDelay(500, [__filename, cookieValue])\n+  return (\n+    <div style={{ border: '1px solid blue', padding: '1em' }}>\n+      <div id=\"cookie-value-layout\">{`Cookie from layout: ${cookieValue}`}</div>\n+      <Suspense fallback={<div style={{ color: 'grey' }}>Loading 2...</div>}>\n+        <Dynamic />\n+      </Suspense>\n+    </div>\n+  )\n+}\n+\n+async function Dynamic() {\n+  await uncachedIO()\n+  await connection()\n+  return (\n+    <div style={{ border: '1px solid tomato', padding: '1em' }}>\n+      <div id=\"dynamic-content-layout\">Dynamic content from layout</div>\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "feecdec327dcec038b6950d8eb881df6f842e766",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-layout-sharing/app/shared-layout/one/page.tsx",
            "status": "added",
            "additions": 37,
            "deletions": 0,
            "changes": 37,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-layout-sharing%2Fapp%2Fshared-layout%2Fone%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-layout-sharing%2Fapp%2Fshared-layout%2Fone%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-layout-sharing%2Fapp%2Fshared-layout%2Fone%2Fpage.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -0,0 +1,37 @@\n+import { Suspense } from 'react'\n+import { cachedDelay, uncachedIO } from '../../shared'\n+import { cookies } from 'next/headers'\n+\n+export default function Page() {\n+  return (\n+    <main>\n+      <h1 style={{ color: 'yellow' }}>Page one</h1>\n+      <Suspense fallback={<div style={{ color: 'grey' }}>Loading 1...</div>}>\n+        <RuntimePrefetchable />\n+      </Suspense>\n+    </main>\n+  )\n+}\n+\n+async function RuntimePrefetchable() {\n+  const cookieStore = await cookies()\n+  const cookieValue = cookieStore.get('testCookie')?.value ?? null\n+  await cachedDelay(500, [__filename, cookieValue])\n+  return (\n+    <div style={{ border: '1px solid blue', padding: '1em' }}>\n+      <div id=\"cookie-value-page\">{`Cookie from page: ${cookieValue}`}</div>\n+      <Suspense fallback={<div style={{ color: 'grey' }}>Loading 2...</div>}>\n+        <Dynamic />\n+      </Suspense>\n+    </div>\n+  )\n+}\n+\n+async function Dynamic() {\n+  await uncachedIO()\n+  return (\n+    <div style={{ border: '1px solid tomato', padding: '1em' }}>\n+      <div id=\"dynamic-content-page\">Dynamic content from page one</div>\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "604205bb78bba6d09345312cab85b26762b616e8",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-layout-sharing/app/shared-layout/two/page.tsx",
            "status": "added",
            "additions": 37,
            "deletions": 0,
            "changes": 37,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-layout-sharing%2Fapp%2Fshared-layout%2Ftwo%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-layout-sharing%2Fapp%2Fshared-layout%2Ftwo%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-layout-sharing%2Fapp%2Fshared-layout%2Ftwo%2Fpage.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -0,0 +1,37 @@\n+import { Suspense } from 'react'\n+import { cachedDelay, uncachedIO } from '../../shared'\n+import { cookies } from 'next/headers'\n+\n+export default function Page() {\n+  return (\n+    <main>\n+      <h1 style={{ color: 'green' }}>Page two</h1>\n+      <Suspense fallback={<div style={{ color: 'grey' }}>Loading 1...</div>}>\n+        <RuntimePrefetchable />\n+      </Suspense>\n+    </main>\n+  )\n+}\n+\n+async function RuntimePrefetchable() {\n+  const cookieStore = await cookies()\n+  const cookieValue = cookieStore.get('testCookie')?.value ?? null\n+  await cachedDelay(500, [__filename, cookieValue])\n+  return (\n+    <div style={{ border: '1px solid blue', padding: '1em' }}>\n+      <div id=\"cookie-value-page\">{`Cookie from page: ${cookieValue}`}</div>\n+      <Suspense fallback={<div style={{ color: 'grey' }}>Loading 2...</div>}>\n+        <Dynamic />\n+      </Suspense>\n+    </div>\n+  )\n+}\n+\n+async function Dynamic() {\n+  await uncachedIO()\n+  return (\n+    <div style={{ border: '1px solid tomato', padding: '1em' }}>\n+      <div id=\"dynamic-content-page\">Dynamic content from page two</div>\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "4bdbb6e93655a504e301eb76f425c02cbe929a69",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-layout-sharing/app/shared.tsx",
            "status": "added",
            "additions": 34,
            "deletions": 0,
            "changes": 34,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-layout-sharing%2Fapp%2Fshared.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-layout-sharing%2Fapp%2Fshared.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-layout-sharing%2Fapp%2Fshared.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -0,0 +1,34 @@\n+import { unstable_cacheLife } from 'next/cache'\n+import { setTimeout } from 'timers/promises'\n+\n+export async function uncachedIO() {\n+  await setTimeout(500)\n+}\n+\n+export async function cachedDelay(time: number, cacheBuster?: any) {\n+  'use cache'\n+  unstable_cacheLife('minutes')\n+  console.log('cachedDelay', time, cacheBuster)\n+  await setTimeout(time)\n+}\n+\n+export function DebugRenderKind() {\n+  const { workUnitAsyncStorage } =\n+    require('next/dist/server/app-render/work-unit-async-storage.external') as typeof import('next/dist/server/app-render/work-unit-async-storage.external')\n+  const workUnitStore = workUnitAsyncStorage.getStore()!\n+  return (\n+    <div>\n+      workUnitStore.type: {workUnitStore.type}\n+      {(() => {\n+        switch (workUnitStore.type) {\n+          case 'prerender':\n+            return '(static prefetch)'\n+          case 'prerender-runtime':\n+            return '(runtime prefetch)'\n+          default:\n+            return null\n+        }\n+      })()}\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "19498939be06645619efe919f55560b3492b964a",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-layout-sharing/components/link-accordion.tsx",
            "status": "added",
            "additions": 63,
            "deletions": 0,
            "changes": 63,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-layout-sharing%2Fcomponents%2Flink-accordion.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-layout-sharing%2Fcomponents%2Flink-accordion.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-layout-sharing%2Fcomponents%2Flink-accordion.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -0,0 +1,63 @@\n+'use client'\n+\n+import Link, { type LinkProps } from 'next/link'\n+import { ComponentProps, useState } from 'react'\n+\n+export function LinkAccordion({\n+  href,\n+  children,\n+  prefetch,\n+}: {\n+  href: string\n+  children: React.ReactNode\n+  prefetch?: LinkProps['prefetch']\n+}) {\n+  const [isVisible, setIsVisible] = useState(false)\n+  return (\n+    <>\n+      <input\n+        type=\"checkbox\"\n+        checked={isVisible}\n+        onChange={() => setIsVisible(!isVisible)}\n+        data-link-accordion={href}\n+        data-prefetch={getPrefetchKind(prefetch)}\n+      />\n+      {isVisible ? (\n+        <Link href={href} prefetch={prefetch}>\n+          {children}\n+        </Link>\n+      ) : (\n+        <>{children} (link is hidden)</>\n+      )}\n+    </>\n+  )\n+}\n+\n+export function DebugLinkAccordion({\n+  href,\n+  prefetch,\n+}: Omit<ComponentProps<typeof LinkAccordion>, 'children'>) {\n+  const prefetchKind = getPrefetchKind(prefetch)\n+  return (\n+    <LinkAccordion href={href} prefetch={prefetch} data-prefetch={prefetch}>\n+      {href} ({prefetchKind})\n+    </LinkAccordion>\n+  )\n+}\n+\n+function getPrefetchKind(prefetch: LinkProps['prefetch']) {\n+  switch (prefetch) {\n+    case false:\n+      return 'disabled'\n+    case undefined:\n+    case null:\n+    case 'auto':\n+      return 'auto'\n+    case true:\n+      return 'runtime'\n+    case 'unstable_forceStale':\n+      return 'full'\n+    default:\n+      prefetch satisfies never\n+  }\n+}"
        },
        {
            "sha": "728848f57dc2d3db2b51946b889e2eb268aaec23",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-layout-sharing/next.config.ts",
            "status": "added",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-layout-sharing%2Fnext.config.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-layout-sharing%2Fnext.config.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-layout-sharing%2Fnext.config.ts?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -0,0 +1,8 @@\n+import type { NextConfig } from 'next'\n+\n+const nextConfig: NextConfig = {\n+  experimental: { cacheComponents: true, clientSegmentCache: true },\n+  productionBrowserSourceMaps: true,\n+}\n+\n+export default nextConfig"
        },
        {
            "sha": "1556d39ea290b007e13872bbb81fd23b7a029977",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-layout-sharing/prefetch-layout-sharing.test.ts",
            "status": "added",
            "additions": 575,
            "deletions": 0,
            "changes": 575,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-layout-sharing%2Fprefetch-layout-sharing.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-layout-sharing%2Fprefetch-layout-sharing.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-layout-sharing%2Fprefetch-layout-sharing.test.ts?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -0,0 +1,575 @@\n+import { nextTestSetup } from 'e2e-utils'\n+import type * as Playwright from 'playwright'\n+import { createRouterAct } from '../router-act'\n+\n+describe('layout sharing in non-static prefetches', () => {\n+  const { next, isNextDev } = nextTestSetup({\n+    files: __dirname,\n+  })\n+  if (isNextDev) {\n+    it('disabled in development', () => {})\n+    return\n+  }\n+\n+  // Glossary:\n+  //\n+  // - A \"full prefetch\" is `<Link prefetch=\"unstable_forceStale\">` (a.k.a old `prefetch={true}`, before cacheComponents).\n+  //  It includes cached and uncached IO.\n+\n+  // - A \"runtime prefetch\" is the new `<Link prefetch={true}>` (only available in cacheComponents mode).\n+  //   It includes cached IO, and allows access to cookies/params/searchParams/\"use cache: private\", but excludes uncached IO.\n+\n+  it('runtime prefetches should omit layouts that were already prefetched with a runtime prefetch', async () => {\n+    // Prefetches should re-use results from previous prefetches with the same fetch strategy.\n+\n+    let page: Playwright.Page\n+    const browser = await next.browser('/', {\n+      beforePageLoad(p: Playwright.Page) {\n+        page = p\n+      },\n+    })\n+    // Clear cookies after the test. This currently doesn't happen automatically.\n+    await using _ = defer(() => browser.deleteCookies())\n+\n+    const act = createRouterAct(page)\n+\n+    await browser.addCookie({ name: 'testCookie', value: 'testValue' })\n+\n+    // Reveal the link to trigger a runtime prefetch for page one\n+    await act(async () => {\n+      const linkToggle = await browser.elementByCss(\n+        `input[data-prefetch=\"runtime\"][data-link-accordion=\"/shared-layout/one\"]`\n+      )\n+      await linkToggle.click()\n+    }, [\n+      // should prefetch page one, and allow reading cookies\n+      {\n+        includes: 'Cookie from page: testValue',\n+      },\n+      // Should not prefetch any dynamic content\n+      {\n+        includes: 'Dynamic content',\n+        block: 'reject',\n+      },\n+    ])\n+\n+    // Reveal the link to trigger a runtime prefetch for page two\n+    await act(async () => {\n+      const linkToggle = await browser.elementByCss(\n+        `input[data-prefetch=\"runtime\"][data-link-accordion=\"/shared-layout/two\"]`\n+      )\n+      await linkToggle.click()\n+    }, [\n+      // Should not prefetch the shared layout, because we already have it in the cache\n+      {\n+        includes: 'Cookie from layout: testValue',\n+        block: 'reject',\n+      },\n+      // should prefetch page two, and allow reading cookies\n+      {\n+        includes: 'Cookie from page: testValue',\n+      },\n+      // Should not prefetch the dynamic content from either of them\n+      {\n+        includes: 'Dynamic content',\n+        block: 'reject',\n+      },\n+    ])\n+\n+    // Navigate to page two\n+    await act(async () => {\n+      await act(\n+        async () => {\n+          await browser.elementByCss(`a[href=\"/shared-layout/two\"]`).click()\n+        },\n+        {\n+          // Temporarily block the navigation request.\n+          // The runtime-prefetched parts of the tree should be visible before it finishes.\n+          includes: 'Dynamic content',\n+          block: true,\n+        }\n+      )\n+      expect(await browser.elementByCss('h2').text()).toEqual('Shared layout')\n+      expect(await browser.elementByCss('h1').text()).toEqual('Page two')\n+      expect(await browser.elementById('cookie-value-layout').text()).toEqual(\n+        'Cookie from layout: testValue'\n+      )\n+      expect(await browser.elementById('cookie-value-page').text()).toEqual(\n+        'Cookie from page: testValue'\n+      )\n+    })\n+\n+    // After navigating, we should see both the parts that we prefetched and dynamic content.\n+    expect(await browser.elementByCss('h2').text()).toEqual('Shared layout')\n+    expect(await browser.elementByCss('h1').text()).toEqual('Page two')\n+    expect(await browser.elementById('cookie-value-layout').text()).toEqual(\n+      'Cookie from layout: testValue'\n+    )\n+    expect(await browser.elementById('cookie-value-page').text()).toEqual(\n+      'Cookie from page: testValue'\n+    )\n+    expect(await browser.elementById('dynamic-content-layout').text()).toEqual(\n+      'Dynamic content from layout'\n+    )\n+    expect(await browser.elementById('dynamic-content-page').text()).toEqual(\n+      'Dynamic content from page two'\n+    )\n+  })\n+\n+  it('full prefetches should omit layouts that were already prefetched with a full prefetch', async () => {\n+    // Prefetches should re-use results from previous prefetches with the same fetch strategy.\n+\n+    let page: Playwright.Page\n+    const browser = await next.browser('/', {\n+      beforePageLoad(p: Playwright.Page) {\n+        page = p\n+      },\n+    })\n+    // Clear cookies after the test. This currently doesn't happen automatically.\n+    await using _ = defer(() => browser.deleteCookies())\n+\n+    const act = createRouterAct(page)\n+\n+    await browser.addCookie({ name: 'testCookie', value: 'testValue' })\n+\n+    // Reveal the link to trigger a full prefetch for page one\n+    await act(async () => {\n+      const linkToggle = await browser.elementByCss(\n+        `input[data-prefetch=\"full\"][data-link-accordion=\"/shared-layout/one\"]`\n+      )\n+      await linkToggle.click()\n+    }, [\n+      // Should prefetch the dynamic content\n+      {\n+        includes: 'Dynamic content from page one',\n+      },\n+    ])\n+\n+    // Reveal the link to trigger a full prefetch for page two\n+    await act(async () => {\n+      const linkToggle = await browser.elementByCss(\n+        `input[data-prefetch=\"full\"][data-link-accordion=\"/shared-layout/two\"]`\n+      )\n+      await linkToggle.click()\n+    }, [\n+      // Should not prefetch the shared layout, because we already have it in the cache\n+      {\n+        includes: 'Dynamic content from layout',\n+        block: 'reject',\n+      },\n+      // Should prefetch the dynamic content\n+      {\n+        includes: 'Dynamic content from page two',\n+      },\n+    ])\n+\n+    // Navigate to page two. We have everything in the cache, so we shouldn't issue any new requests\n+    await act(async () => {\n+      await browser.elementByCss(`a[href=\"/shared-layout/two\"]`).click()\n+    }, 'no-requests')\n+\n+    // After navigating, we should see both the parts that we prefetched and dynamic content.\n+    expect(await browser.elementByCss('h2').text()).toEqual('Shared layout')\n+    expect(await browser.elementByCss('h1').text()).toEqual('Page two')\n+    expect(await browser.elementById('dynamic-content-layout').text()).toEqual(\n+      'Dynamic content from layout'\n+    )\n+    expect(await browser.elementById('dynamic-content-page').text()).toEqual(\n+      'Dynamic content from page two'\n+    )\n+  })\n+\n+  it('navigations should omit layouts that were already prefetched with a full prefetch', async () => {\n+    // A navigation is mostly equivalent to a full prefetch, so it should re-use results from full prefetches.\n+\n+    let page: Playwright.Page\n+    const browser = await next.browser('/', {\n+      beforePageLoad(p: Playwright.Page) {\n+        page = p\n+      },\n+    })\n+    // Clear cookies after the test. This currently doesn't happen automatically.\n+    await using _ = defer(() => browser.deleteCookies())\n+\n+    const act = createRouterAct(page)\n+\n+    await browser.addCookie({ name: 'testCookie', value: 'testValue' })\n+\n+    // Reveal the link to trigger a full prefetch for page one\n+    await act(async () => {\n+      const linkToggle = await browser.elementByCss(\n+        `input[data-prefetch=\"full\"][data-link-accordion=\"/shared-layout/one\"]`\n+      )\n+      await linkToggle.click()\n+    }, [\n+      // Should prefetch the dynamic content\n+      {\n+        includes: 'Dynamic content from page one',\n+      },\n+    ])\n+\n+    // Reveal the link to trigger an auto prefetch for page two\n+    await act(async () => {\n+      const linkToggle = await browser.elementByCss(\n+        `input[data-prefetch=\"auto\"][data-link-accordion=\"/shared-layout/two\"]`\n+      )\n+      await linkToggle.click()\n+    })\n+\n+    // Navigate to page two. We have everything in the cache, so we shouldn't issue any new requests\n+    await act(async () => {\n+      await browser.elementByCss(`a[href=\"/shared-layout/two\"]`).click()\n+    }, [\n+      // Should not fetch the shared layout, because we already have it in the cache\n+      {\n+        includes: 'Dynamic content from layout',\n+        block: 'reject',\n+      },\n+      // Should fetch the dynamic content\n+      {\n+        includes: 'Dynamic content from page two',\n+      },\n+    ])\n+\n+    // After navigating, we should see both the parts that we prefetched and dynamic content.\n+    expect(await browser.elementByCss('h2').text()).toEqual('Shared layout')\n+    expect(await browser.elementByCss('h1').text()).toEqual('Page two')\n+    expect(await browser.elementById('dynamic-content-layout').text()).toEqual(\n+      'Dynamic content from layout'\n+    )\n+    expect(await browser.elementById('dynamic-content-page').text()).toEqual(\n+      'Dynamic content from page two'\n+    )\n+  })\n+\n+  it('runtime prefetches should omit layouts that were already prefetched with a full prefetch', async () => {\n+    // A prefetch should re-use layouts from past prefetches with more specific fetch strategies.\n+\n+    let page: Playwright.Page\n+    const browser = await next.browser('/', {\n+      beforePageLoad(p: Playwright.Page) {\n+        page = p\n+      },\n+    })\n+    // Clear cookies after the test. This currently doesn't happen automatically.\n+    await using _ = defer(() => browser.deleteCookies())\n+\n+    const act = createRouterAct(page)\n+\n+    await browser.addCookie({ name: 'testCookie', value: 'testValue' })\n+\n+    // Reveal the link to trigger a full prefetch for page one\n+    await act(async () => {\n+      const linkToggle = await browser.elementByCss(\n+        `input[data-prefetch=\"full\"][data-link-accordion=\"/shared-layout/one\"]`\n+      )\n+      await linkToggle.click()\n+    }, [\n+      // Should prefetch the dynamic content\n+      {\n+        includes: 'Dynamic content from page one',\n+      },\n+    ])\n+\n+    // Reveal the link to trigger a runtime prefetch for page two\n+    await act(async () => {\n+      const linkToggle = await browser.elementByCss(\n+        `input[data-prefetch=\"runtime\"][data-link-accordion=\"/shared-layout/two\"]`\n+      )\n+      await linkToggle.click()\n+    }, [\n+      // Should not prefetch the shared layout, because we already have it in the cache\n+      {\n+        includes: 'Cookie from layout: testValue',\n+        block: 'reject',\n+      },\n+      // should prefetch page two, and allow reading cookies\n+      {\n+        includes: 'Cookie from page: testValue',\n+      },\n+      // Should not prefetch any dynamic content\n+      {\n+        includes: 'Dynamic content',\n+        block: 'reject',\n+      },\n+    ])\n+\n+    // Navigate to page two\n+    await act(async () => {\n+      await act(async () => {\n+        await browser.elementByCss(`a[href=\"/shared-layout/two\"]`).click()\n+      }, [\n+        // Should not fetch the shared layout, because we already have a full prefetch of it\n+        {\n+          includes: 'Cookie from layout: testValue',\n+          block: 'reject',\n+        },\n+        {\n+          // Temporarily block the navigation request.\n+          // The runtime-prefetched parts of the tree should be visible before it finishes.\n+          includes: 'Dynamic content',\n+          block: true,\n+        },\n+      ])\n+      expect(await browser.elementByCss('h2').text()).toEqual('Shared layout')\n+      expect(await browser.elementByCss('h1').text()).toEqual('Page two')\n+      expect(await browser.elementById('cookie-value-layout').text()).toEqual(\n+        'Cookie from layout: testValue'\n+      )\n+      expect(await browser.elementById('cookie-value-page').text()).toEqual(\n+        'Cookie from page: testValue'\n+      )\n+    })\n+\n+    // After navigating, we should see both the parts that we prefetched and dynamic content.\n+    expect(await browser.elementByCss('h2').text()).toEqual('Shared layout')\n+    expect(await browser.elementByCss('h1').text()).toEqual('Page two')\n+    expect(await browser.elementById('cookie-value-layout').text()).toEqual(\n+      'Cookie from layout: testValue'\n+    )\n+    expect(await browser.elementById('cookie-value-page').text()).toEqual(\n+      'Cookie from page: testValue'\n+    )\n+    expect(await browser.elementById('dynamic-content-layout').text()).toEqual(\n+      'Dynamic content from layout'\n+    )\n+    expect(await browser.elementById('dynamic-content-page').text()).toEqual(\n+      'Dynamic content from page two'\n+    )\n+  })\n+\n+  it('full prefetches should include layouts that were only prefetched with a runtime prefetch', async () => {\n+    // A prefetch should NOT re-use layouts from past prefetches if they used a less specific fetch strategy.\n+\n+    let page: Playwright.Page\n+    const browser = await next.browser('/', {\n+      beforePageLoad(p: Playwright.Page) {\n+        page = p\n+      },\n+    })\n+    // Clear cookies after the test. This currently doesn't happen automatically.\n+    await using _ = defer(() => browser.deleteCookies())\n+\n+    const act = createRouterAct(page)\n+\n+    await browser.addCookie({ name: 'testCookie', value: 'testValue' })\n+\n+    // Reveal the link to trigger a runtime prefetch for page one\n+    await act(async () => {\n+      const linkToggle = await browser.elementByCss(\n+        `input[data-prefetch=\"runtime\"][data-link-accordion=\"/shared-layout/one\"]`\n+      )\n+      await linkToggle.click()\n+    }, [\n+      // should prefetch page one, and allow reading cookies\n+      {\n+        includes: 'Cookie from page: testValue',\n+      },\n+      // Should not prefetch any dynamic content\n+      {\n+        includes: 'Dynamic content',\n+        block: 'reject',\n+      },\n+    ])\n+\n+    // Reveal the link to trigger a full prefetch for page two\n+    await act(async () => {\n+      const linkToggle = await browser.elementByCss(\n+        `input[data-prefetch=\"full\"][data-link-accordion=\"/shared-layout/two\"]`\n+      )\n+      await linkToggle.click()\n+    }, [\n+      // Should prefetch the shared layout, because we didn't prefetch it fully\n+      {\n+        includes: 'Dynamic content from layout',\n+      },\n+    ])\n+\n+    // Navigate to page two. We have everything in the cache, so we shouldn't issue any new requests\n+    await act(async () => {\n+      await browser.elementByCss(`a[href=\"/shared-layout/two\"]`).click()\n+    }, 'no-requests')\n+\n+    // After navigating, we should see both the parts that we prefetched and dynamic content.\n+    expect(await browser.elementByCss('h2').text()).toEqual('Shared layout')\n+    expect(await browser.elementByCss('h1').text()).toEqual('Page two')\n+    expect(await browser.elementById('cookie-value-layout').text()).toEqual(\n+      'Cookie from layout: testValue'\n+    )\n+    expect(await browser.elementById('cookie-value-page').text()).toEqual(\n+      'Cookie from page: testValue'\n+    )\n+    expect(await browser.elementById('dynamic-content-layout').text()).toEqual(\n+      'Dynamic content from layout'\n+    )\n+    expect(await browser.elementById('dynamic-content-page').text()).toEqual(\n+      'Dynamic content from page two'\n+    )\n+  })\n+\n+  it('full prefetches should omit layouts that were prefetched with a runtime prefetch and had no dynamic holes', async () => {\n+    // If a runtime prefetch gave us a complete segment with no dynamic holes left, then it's equivalent to a full prefetch.\n+    //\n+    // TODO: This doesn't work in all cases -- if any segment in a runtime prefetch was partial, we'll mark all of them as partial,\n+    // which means they can't be reused in a full prefetch or a navigation. So this only works if the dynaimic prefetch has no holes at all.\n+\n+    let page: Playwright.Page\n+    const browser = await next.browser('/', {\n+      beforePageLoad(p: Playwright.Page) {\n+        page = p\n+      },\n+    })\n+    // Clear cookies after the test. This currently doesn't happen automatically.\n+    await using _ = defer(() => browser.deleteCookies())\n+\n+    const act = createRouterAct(page)\n+\n+    await browser.addCookie({ name: 'testCookie', value: 'testValue' })\n+\n+    // Reveal the link to trigger a runtime prefetch for page one\n+    await act(async () => {\n+      const linkToggle = await browser.elementByCss(\n+        `input[data-prefetch=\"runtime\"][data-link-accordion=\"/runtime-prefetchable-layout/one\"]`\n+      )\n+      await linkToggle.click()\n+    }, [\n+      // should prefetch page one, and allow reading cookies\n+      {\n+        includes: 'Cookie from page: testValue',\n+      },\n+    ])\n+\n+    // Navigate to page one. It should have been completely prefetched by the runtime prefetch.\n+    await act(async () => {\n+      await browser\n+        .elementByCss(`a[href=\"/runtime-prefetchable-layout/one\"]`)\n+        .click()\n+    }, 'no-requests')\n+\n+    await browser.back()\n+\n+    // Reveal the link to trigger a full prefetch for page two\n+    await act(async () => {\n+      const linkToggle = await browser.elementByCss(\n+        `input[data-prefetch=\"full\"][data-link-accordion=\"/runtime-prefetchable-layout/two\"]`\n+      )\n+      await linkToggle.click()\n+    }, [\n+      // Should not prefetch the shared layout, because we already got a complete result for it.\n+      {\n+        includes: 'Cookie from layout',\n+        block: 'reject',\n+      },\n+      // Should fully prefetch the page, which we haven't prefetched before.\n+      {\n+        includes: 'Dynamic content from page two',\n+      },\n+    ])\n+\n+    // Navigate to page two. We have everything in the cache, so we shouldn't issue any new requests\n+    await act(async () => {\n+      await browser\n+        .elementByCss(`a[href=\"/runtime-prefetchable-layout/two\"]`)\n+        .click()\n+    }, 'no-requests')\n+\n+    // After navigating, we should see both the parts that we prefetched and dynamic content.\n+    expect(await browser.elementByCss('h2').text()).toEqual('Shared layout')\n+    expect(await browser.elementByCss('h1').text()).toEqual('Page two')\n+    expect(await browser.elementById('cookie-value-layout').text()).toEqual(\n+      'Cookie from layout: testValue'\n+    )\n+    expect(await browser.elementById('cookie-value-page').text()).toEqual(\n+      'Cookie from page: testValue'\n+    )\n+    expect(await browser.elementById('dynamic-content-page').text()).toEqual(\n+      'Dynamic content from page two'\n+    )\n+  })\n+\n+  it('navigations should omit layouts that were prefetched with a runtime prefetch and had no dynamic holes', async () => {\n+    // If a runtime prefetch gave us a complete segment with no dynamic holes left, then it's equivalent to a full prefetch.\n+    //\n+    // TODO: This doesn't work in all cases -- if any segment in a runtime prefetch was partial, we'll mark all of them as partial,\n+    // which means they can't be reused in a full prefetch or a navigation. So this only works if the dynaimic prefetch has no holes at all.\n+\n+    let page: Playwright.Page\n+    const browser = await next.browser('/', {\n+      beforePageLoad(p: Playwright.Page) {\n+        page = p\n+      },\n+    })\n+    // Clear cookies after the test. This currently doesn't happen automatically.\n+    await using _ = defer(() => browser.deleteCookies())\n+\n+    const act = createRouterAct(page)\n+\n+    await browser.addCookie({ name: 'testCookie', value: 'testValue' })\n+\n+    // Reveal the link to trigger a runtime prefetch for page one\n+    await act(async () => {\n+      const linkToggle = await browser.elementByCss(\n+        `input[data-prefetch=\"runtime\"][data-link-accordion=\"/runtime-prefetchable-layout/one\"]`\n+      )\n+      await linkToggle.click()\n+    }, [\n+      // should prefetch page one, and allow reading cookies\n+      {\n+        includes: 'Cookie from page: testValue',\n+      },\n+    ])\n+\n+    // Navigate to page one. It should have been completely prefetched by the runtime prefetch.\n+    await act(async () => {\n+      await browser\n+        .elementByCss(`a[href=\"/runtime-prefetchable-layout/one\"]`)\n+        .click()\n+    }, 'no-requests')\n+\n+    await browser.back()\n+\n+    // Reveal the link to trigger an auto prefetch for page two\n+    await act(async () => {\n+      const linkToggle = await browser.elementByCss(\n+        `input[data-prefetch=\"auto\"][data-link-accordion=\"/runtime-prefetchable-layout/two\"]`\n+      )\n+      await linkToggle.click()\n+    })\n+\n+    // Navigate to page two. We need to request the page segment dynamically, but the shared layout should be cached.\n+    await act(async () => {\n+      await browser\n+        .elementByCss(`a[href=\"/runtime-prefetchable-layout/two\"]`)\n+        .click()\n+    }, [\n+      // Should not fetch the shared layout, because we already got a complete result for it.\n+      {\n+        includes: 'Cookie from layout',\n+        block: 'reject',\n+      },\n+      // Should fetch the page, which we haven't prefetched before.\n+      {\n+        includes: 'Dynamic content from page two',\n+      },\n+    ])\n+\n+    // After navigating, we should see both the parts that we prefetched and dynamic content.\n+    expect(await browser.elementByCss('h2').text()).toEqual('Shared layout')\n+    expect(await browser.elementByCss('h1').text()).toEqual('Page two')\n+    expect(await browser.elementById('cookie-value-layout').text()).toEqual(\n+      'Cookie from layout: testValue'\n+    )\n+    expect(await browser.elementById('cookie-value-page').text()).toEqual(\n+      'Cookie from page: testValue'\n+    )\n+    expect(await browser.elementById('dynamic-content-page').text()).toEqual(\n+      'Dynamic content from page two'\n+    )\n+  })\n+})\n+\n+function defer(callback: () => Promise<void>) {\n+  return {\n+    [Symbol.asyncDispose]: callback,\n+  }\n+}"
        },
        {
            "sha": "450b40e00671a7941e297170ec886ad4f3e5dfa3",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-runtime/app/(default)/caches/private-short-stale/page.tsx",
            "status": "added",
            "additions": 36,
            "deletions": 0,
            "changes": 36,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fcaches%2Fprivate-short-stale%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fcaches%2Fprivate-short-stale%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fcaches%2Fprivate-short-stale%2Fpage.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -0,0 +1,36 @@\n+import { Suspense } from 'react'\n+import { cachedDelay, DebugRenderKind } from '../../../shared'\n+import { unstable_cacheLife } from 'next/cache'\n+\n+export default async function Page() {\n+  return (\n+    <main>\n+      <DebugRenderKind />\n+      <p id=\"intro\">\n+        This page uses a short-lived private cache (staleTime &lt;\n+        RUNTIME_PREFETCH_DYNAMIC_STALE, which is 30s), which should not be\n+        included in a runtime prefetch\n+      </p>\n+      <Suspense fallback={<div style={{ color: 'grey' }}>Loading...</div>}>\n+        <CachedButShortLived />\n+      </Suspense>\n+    </main>\n+  )\n+}\n+\n+async function CachedButShortLived() {\n+  'use cache: private'\n+  unstable_cacheLife({\n+    stale: 5,\n+    // the rest of the settings don't matter for private caches,\n+    // because they are not persisted server-side\n+  })\n+  await cachedDelay(500, [__filename])\n+\n+  return (\n+    <div style={{ border: '1px solid blue', padding: '1em' }}>\n+      Short-lived cached content\n+      <div id=\"cached-value\">{Date.now()}</div>\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "6e73655bc322fd83c4549648af93ffa879437c0d",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-runtime/app/(default)/caches/public-short-expire-long-stale/page.tsx",
            "status": "added",
            "additions": 37,
            "deletions": 0,
            "changes": 37,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fcaches%2Fpublic-short-expire-long-stale%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fcaches%2Fpublic-short-expire-long-stale%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fcaches%2Fpublic-short-expire-long-stale%2Fpage.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -0,0 +1,37 @@\n+import { Suspense } from 'react'\n+import { cachedDelay, DebugRenderKind } from '../../../shared'\n+import { unstable_cacheLife } from 'next/cache'\n+\n+export default async function Page() {\n+  return (\n+    <main>\n+      <DebugRenderKind />\n+      <p id=\"intro\">\n+        This page uses a short-lived public cache (expire &lt; DYNAMIC_EXPIRE,\n+        5min), which should not be included in a static prefetch, but should be\n+        included in a runtime prefetch, because it has a long enough stale time\n+        (&gt; RUNTIME_PREFETCH_DYNAMIC_STALE, 30s)\n+      </p>\n+      <Suspense fallback={<div style={{ color: 'grey' }}>Loading...</div>}>\n+        <ShortLivedCache />\n+      </Suspense>\n+    </main>\n+  )\n+}\n+\n+async function ShortLivedCache() {\n+  'use cache'\n+  unstable_cacheLife({\n+    stale: 60, // > RUNTIME_PREFETCH_DYNAMIC_STALE\n+    revalidate: 2 * 60,\n+    expire: 3 * 60, // < DYNAMIC_EXPIRE\n+  })\n+  await cachedDelay(500, [__filename])\n+\n+  return (\n+    <div style={{ border: '1px solid blue', padding: '1em' }}>\n+      Short-lived cached content\n+      <div id=\"cached-value\">{Date.now()}</div>\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "1d077484086bba0a9302f0ccb4eb953fce027da1",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-runtime/app/(default)/caches/public-short-expire-short-stale/page.tsx",
            "status": "added",
            "additions": 37,
            "deletions": 0,
            "changes": 37,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fcaches%2Fpublic-short-expire-short-stale%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fcaches%2Fpublic-short-expire-short-stale%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fcaches%2Fpublic-short-expire-short-stale%2Fpage.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -0,0 +1,37 @@\n+import { Suspense } from 'react'\n+import { cachedDelay, DebugRenderKind } from '../../../shared'\n+import { unstable_cacheLife } from 'next/cache'\n+\n+export default async function Page() {\n+  return (\n+    <main>\n+      <DebugRenderKind />\n+      <p id=\"intro\">\n+        This page uses a short-lived public cache (expire &lt; DYNAMIC_EXPIRE,\n+        5min), which should not be included in a static prefetch, and should\n+        also not be included in a runtime prefetch, because it has a short\n+        enough stale time (&lt; RUNTIME_PREFETCH_DYNAMIC_STALE, 30s)\n+      </p>\n+      <Suspense fallback={<div style={{ color: 'grey' }}>Loading...</div>}>\n+        <ShortLivedCache />\n+      </Suspense>\n+    </main>\n+  )\n+}\n+\n+async function ShortLivedCache() {\n+  'use cache'\n+  unstable_cacheLife({\n+    stale: 20, // < RUNTIME_PREFETCH_DYNAMIC_STALE\n+    revalidate: 2 * 60,\n+    expire: 3 * 60, // < DYNAMIC_EXPIRE\n+  })\n+  await cachedDelay(500, [__filename])\n+\n+  return (\n+    <div style={{ border: '1px solid blue', padding: '1em' }}>\n+      Short-lived cached content\n+      <div id=\"cached-value\">{Date.now()}</div>\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "d844a29339a6f073e67939d4e93877f0b117da65",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-runtime/app/(default)/errors/error-after-cookies/page.tsx",
            "status": "added",
            "additions": 28,
            "deletions": 0,
            "changes": 28,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Ferrors%2Ferror-after-cookies%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Ferrors%2Ferror-after-cookies%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Ferrors%2Ferror-after-cookies%2Fpage.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -0,0 +1,28 @@\n+import { cookies } from 'next/headers'\n+import { Suspense } from 'react'\n+import { cachedDelay, DebugRenderKind } from '../../../shared'\n+import { ErrorBoundary } from '../../../../components/error-boundary'\n+\n+export default async function Page() {\n+  return (\n+    <main>\n+      <DebugRenderKind />\n+      <p id=\"intro\">\n+        This page errors after a cookies call, so we should only see the error\n+        in a runtime prefetch or a navigation (and not during prerendering /\n+        prefetching)\n+      </p>\n+      <Suspense fallback={<div style={{ color: 'grey' }}>Loading 1...</div>}>\n+        <ErrorBoundary>\n+          <One />\n+        </ErrorBoundary>\n+      </Suspense>\n+    </main>\n+  )\n+}\n+\n+async function One(): Promise<never> {\n+  const cookieStore = await cookies()\n+  await cachedDelay(500, ['/cookies', cookieStore.get('user-agent')?.value])\n+  throw new Error('Kaboom')\n+}"
        },
        {
            "sha": "d7b1d65fa23a1bfe840259a709df3aa8a4c28415",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-runtime/app/(default)/errors/sync-io-after-cookies/page.tsx",
            "status": "added",
            "additions": 25,
            "deletions": 0,
            "changes": 25,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Ferrors%2Fsync-io-after-cookies%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Ferrors%2Fsync-io-after-cookies%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Ferrors%2Fsync-io-after-cookies%2Fpage.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -0,0 +1,25 @@\n+import { cookies } from 'next/headers'\n+import { Suspense } from 'react'\n+import { cachedDelay, DebugRenderKind } from '../../../shared'\n+\n+export default async function Page() {\n+  return (\n+    <main>\n+      <DebugRenderKind />\n+      <p id=\"intro\">\n+        This page performs sync IO after a cookies() call, so we should only see\n+        the error in a runtime prefetch or a navigation (and not during\n+        prerendering / prefetching)\n+      </p>\n+      <Suspense fallback={<div style={{ color: 'grey' }}>Loading 1...</div>}>\n+        <One />\n+      </Suspense>\n+    </main>\n+  )\n+}\n+\n+async function One() {\n+  const cookieStore = await cookies()\n+  await cachedDelay(500, ['/cookies', cookieStore.get('user-agent')?.value])\n+  return <div id=\"timestamp\">Timestamp: {Date.now()}</div>\n+}"
        },
        {
            "sha": "0a162d0ab1ae9cf03cff43ec7c1eab47a3891a81",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-runtime/app/(default)/fully-static/page.tsx",
            "status": "added",
            "additions": 13,
            "deletions": 0,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Ffully-static%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Ffully-static%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Ffully-static%2Fpage.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -0,0 +1,13 @@\n+export default async function Page() {\n+  return (\n+    <main>\n+      <h1>Fully static</h1>\n+      <p id=\"intro\">Hello from a fully static page!</p>\n+      <p>\n+        {new Array({ length: 1000 })\n+          .fill(null)\n+          .map(() => 'Lorem ipsum dolor sit amet.')}\n+      </p>\n+    </main>\n+  )\n+}"
        },
        {
            "sha": "d9795d0c6d400851db893309843baa46e701bed5",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-runtime/app/(default)/in-page/cookies-only/page.tsx",
            "status": "added",
            "additions": 29,
            "deletions": 0,
            "changes": 29,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fin-page%2Fcookies-only%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fin-page%2Fcookies-only%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fin-page%2Fcookies-only%2Fpage.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -0,0 +1,29 @@\n+import { cookies } from 'next/headers'\n+import { Suspense } from 'react'\n+import { cachedDelay, DebugRenderKind } from '../../../shared'\n+\n+export default async function Page() {\n+  return (\n+    <main>\n+      <DebugRenderKind />\n+      <p>\n+        This page uses cookies and no uncached IO, So it should be completely\n+        prefetchable with a runtime prefetch.\n+      </p>\n+      <Suspense fallback={<div style={{ color: 'grey' }}>Loading 1...</div>}>\n+        <RuntimePrefetchable />\n+      </Suspense>\n+    </main>\n+  )\n+}\n+\n+async function RuntimePrefetchable() {\n+  const cookieStore = await cookies()\n+  const cookieValue = cookieStore.get('testCookie')?.value ?? null\n+  await cachedDelay(500, [__filename, cookieValue])\n+  return (\n+    <div style={{ border: '1px solid blue', padding: '1em' }}>\n+      <div id=\"cookie-value\">{`Cookie: ${cookieValue}`}</div>\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "eda5cfa098249e5c2857e3b27da1970f3a920702",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-runtime/app/(default)/in-page/cookies/page.tsx",
            "status": "added",
            "additions": 56,
            "deletions": 0,
            "changes": 56,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fin-page%2Fcookies%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fin-page%2Fcookies%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fin-page%2Fcookies%2Fpage.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -0,0 +1,56 @@\n+import { cookies } from 'next/headers'\n+import { Suspense } from 'react'\n+import { cachedDelay, DebugRenderKind, uncachedIO } from '../../../shared'\n+import { connection } from 'next/server'\n+\n+export default async function Page() {\n+  return (\n+    <main>\n+      <DebugRenderKind />\n+      <p>\n+        This page uses cookies and some uncached IO, so parts of it should be\n+        runtime-prefetchable.\n+      </p>\n+      <Suspense fallback={<div style={{ color: 'grey' }}>Loading 1...</div>}>\n+        <RuntimePrefetchable />\n+      </Suspense>\n+      <form\n+        action={async (formData: FormData) => {\n+          'use server'\n+          const cookieStore = await cookies()\n+          const cookieValue = formData.get('cookie') as string | null\n+          if (cookieValue) {\n+            cookieStore.set('testCookie', cookieValue)\n+          }\n+        }}\n+      >\n+        <input type=\"text\" name=\"cookie\" />\n+        <button type=\"submit\">Update cookie</button>\n+      </form>\n+    </main>\n+  )\n+}\n+\n+async function RuntimePrefetchable() {\n+  const cookieStore = await cookies()\n+  const cookieValue = cookieStore.get('testCookie')?.value ?? null\n+  await cachedDelay(500, [__filename, cookieValue])\n+  return (\n+    <div style={{ border: '1px solid blue', padding: '1em' }}>\n+      <div id=\"cookie-value\">{`Cookie: ${cookieValue}`}</div>\n+      <Suspense fallback={<div style={{ color: 'grey' }}>Loading 2...</div>}>\n+        <Dynamic />\n+      </Suspense>\n+    </div>\n+  )\n+}\n+\n+async function Dynamic() {\n+  await uncachedIO()\n+  await connection()\n+  return (\n+    <div style={{ border: '1px solid tomato', padding: '1em' }}>\n+      <div id=\"dynamic-content\">Dynamic content</div>\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "e046e9892944e3c46ba9ac2a03cf09b49d3a4272",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-runtime/app/(default)/in-page/dynamic-params/[id]/page.tsx",
            "status": "added",
            "additions": 43,
            "deletions": 0,
            "changes": 43,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fin-page%2Fdynamic-params%2F%5Bid%5D%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fin-page%2Fdynamic-params%2F%5Bid%5D%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fin-page%2Fdynamic-params%2F%5Bid%5D%2Fpage.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -0,0 +1,43 @@\n+import { Suspense } from 'react'\n+import { cachedDelay, DebugRenderKind, uncachedIO } from '../../../../shared'\n+import { connection } from 'next/server'\n+\n+type Params = { id: string }\n+\n+export default async function Page({ params }: { params: Promise<Params> }) {\n+  return (\n+    <main>\n+      <DebugRenderKind />\n+      <p>\n+        This page uses params and some uncached IO, so parts of it should be\n+        runtime-prefetchable.\n+      </p>\n+      <Suspense fallback={<div style={{ color: 'grey' }}>Loading 1...</div>}>\n+        <RuntimePrefetchable params={params} />\n+      </Suspense>\n+    </main>\n+  )\n+}\n+\n+async function RuntimePrefetchable({ params }: { params: Promise<Params> }) {\n+  const { id } = await params\n+  await cachedDelay(500, [__filename, id])\n+  return (\n+    <div style={{ border: '1px solid blue', padding: '1em' }}>\n+      <div id=\"param-value\">{`Param: ${id}`}</div>\n+      <Suspense fallback={<div style={{ color: 'grey' }}>Loading 2...</div>}>\n+        <Dynamic />\n+      </Suspense>\n+    </div>\n+  )\n+}\n+\n+async function Dynamic() {\n+  await uncachedIO()\n+  await connection()\n+  return (\n+    <div style={{ border: '1px solid tomato', padding: '1em' }}>\n+      <div id=\"dynamic-content\">Dynamic content</div>\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "4d79c239a56c42a75a0416c44404d945ad1b5bb9",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-runtime/app/(default)/in-page/search-params/page.tsx",
            "status": "added",
            "additions": 51,
            "deletions": 0,
            "changes": 51,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fin-page%2Fsearch-params%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fin-page%2Fsearch-params%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fin-page%2Fsearch-params%2Fpage.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -0,0 +1,51 @@\n+import { Suspense } from 'react'\n+import { cachedDelay, DebugRenderKind, uncachedIO } from '../../../shared'\n+import { connection } from 'next/server'\n+\n+type AnySearchParams = { [key: string]: string | string[] | undefined }\n+\n+export default async function Page({\n+  searchParams,\n+}: {\n+  searchParams: Promise<AnySearchParams>\n+}) {\n+  return (\n+    <main>\n+      <DebugRenderKind />\n+      <p>\n+        This page uses search params and some uncached IO, so parts of it should\n+        be runtime-prefetchable.\n+      </p>\n+      <Suspense fallback={<div style={{ color: 'grey' }}>Loading 1...</div>}>\n+        <RuntimePrefetchable searchParams={searchParams} />\n+      </Suspense>\n+    </main>\n+  )\n+}\n+\n+async function RuntimePrefetchable({\n+  searchParams,\n+}: {\n+  searchParams: Promise<AnySearchParams>\n+}) {\n+  const { searchParam } = await searchParams\n+  await cachedDelay(500, [__filename, searchParam])\n+  return (\n+    <div style={{ border: '1px solid blue', padding: '1em' }}>\n+      <div id=\"search-param-value\">{`Search param: ${searchParam}`}</div>\n+      <Suspense fallback={<div style={{ color: 'grey' }}>Loading 2...</div>}>\n+        <Dynamic />\n+      </Suspense>\n+    </div>\n+  )\n+}\n+\n+async function Dynamic() {\n+  await uncachedIO()\n+  await connection()\n+  return (\n+    <div style={{ border: '1px solid tomato', padding: '1em' }}>\n+      <div id=\"dynamic-content\">Dynamic content</div>\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "d8e157d6c7c437c9ca7d429a354679dca847cb37",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-runtime/app/(default)/in-private-cache/cookies-only/page.tsx",
            "status": "added",
            "additions": 35,
            "deletions": 0,
            "changes": 35,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fin-private-cache%2Fcookies-only%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fin-private-cache%2Fcookies-only%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fin-private-cache%2Fcookies-only%2Fpage.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -0,0 +1,35 @@\n+import { cookies } from 'next/headers'\n+import { Suspense } from 'react'\n+import { cachedDelay, DebugRenderKind } from '../../../shared'\n+\n+export default async function Page() {\n+  return (\n+    <main>\n+      <DebugRenderKind />\n+      <p>\n+        This page uses cookies (from a private cache) and no uncached IO, So it\n+        should be completely prefetchable with a runtime prefetch.\n+      </p>\n+      <Suspense fallback={<div style={{ color: 'grey' }}>Loading 1...</div>}>\n+        <RuntimePrefetchable />\n+      </Suspense>\n+    </main>\n+  )\n+}\n+\n+async function RuntimePrefetchable() {\n+  const cookieValue = await privateCache()\n+  return (\n+    <div style={{ border: '1px solid blue', padding: '1em' }}>\n+      <div id=\"cookie-value\">{`Cookie: ${cookieValue}`}</div>\n+    </div>\n+  )\n+}\n+\n+async function privateCache() {\n+  'use cache: private'\n+  const cookieStore = await cookies()\n+  const cookieValue = cookieStore.get('testCookie')?.value ?? null\n+  await cachedDelay(500, [__filename, cookieValue])\n+  return cookieValue\n+}"
        },
        {
            "sha": "af346dd3c10e23d133060b91cc29299689e68a08",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-runtime/app/(default)/in-private-cache/cookies/page.tsx",
            "status": "added",
            "additions": 62,
            "deletions": 0,
            "changes": 62,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fin-private-cache%2Fcookies%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fin-private-cache%2Fcookies%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fin-private-cache%2Fcookies%2Fpage.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -0,0 +1,62 @@\n+import { cookies } from 'next/headers'\n+import { Suspense } from 'react'\n+import { cachedDelay, DebugRenderKind, uncachedIO } from '../../../shared'\n+import { connection } from 'next/server'\n+\n+export default async function Page() {\n+  return (\n+    <main>\n+      <DebugRenderKind />\n+      <p>\n+        This page uses cookies (from inside a private cache) and some uncached\n+        IO, so parts of it should be runtime-prefetchable.\n+      </p>\n+      <Suspense fallback={<div style={{ color: 'grey' }}>Loading 1...</div>}>\n+        <RuntimePrefetchable />\n+      </Suspense>\n+      <form\n+        action={async (formData: FormData) => {\n+          'use server'\n+          const cookieStore = await cookies()\n+          const cookieValue = formData.get('cookie') as string | null\n+          if (cookieValue) {\n+            cookieStore.set('testCookie', cookieValue)\n+          }\n+        }}\n+      >\n+        <input type=\"text\" name=\"cookie\" />\n+        <button type=\"submit\">Update cookie</button>\n+      </form>\n+    </main>\n+  )\n+}\n+\n+async function RuntimePrefetchable() {\n+  const cookieValue = await privateCache()\n+  return (\n+    <div style={{ border: '1px solid blue', padding: '1em' }}>\n+      <div id=\"cookie-value\">{`Cookie: ${cookieValue}`}</div>\n+      <Suspense fallback={<div style={{ color: 'grey' }}>Loading 2...</div>}>\n+        <Dynamic />\n+      </Suspense>\n+    </div>\n+  )\n+}\n+\n+async function privateCache() {\n+  'use cache: private'\n+  const cookieStore = await cookies()\n+  const cookieValue = cookieStore.get('testCookie')?.value ?? null\n+  await cachedDelay(500, [__filename, cookieValue])\n+  return cookieValue\n+}\n+\n+async function Dynamic() {\n+  await uncachedIO()\n+  await connection()\n+  return (\n+    <div style={{ border: '1px solid tomato', padding: '1em' }}>\n+      <div id=\"dynamic-content\">Dynamic content</div>\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "6aafaeb34f14e628b70c0879b7a7015129c4e296",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-runtime/app/(default)/in-private-cache/date-now/page.tsx",
            "status": "added",
            "additions": 47,
            "deletions": 0,
            "changes": 47,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fin-private-cache%2Fdate-now%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fin-private-cache%2Fdate-now%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fin-private-cache%2Fdate-now%2Fpage.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -0,0 +1,47 @@\n+import { Suspense } from 'react'\n+import { cachedDelay, DebugRenderKind, uncachedIO } from '../../../shared'\n+import { connection } from 'next/server'\n+\n+export default async function Page() {\n+  return (\n+    <main>\n+      <DebugRenderKind />\n+      <p>\n+        This page uses Date.now (in a private cache) and some uncached IO, so\n+        parts of it should be runtime-prefetchable.\n+      </p>\n+      <Suspense fallback={<div style={{ color: 'grey' }}>Loading 1...</div>}>\n+        <RuntimePrefetchable />\n+      </Suspense>\n+    </main>\n+  )\n+}\n+\n+async function RuntimePrefetchable() {\n+  const now = await privateCache()\n+  return (\n+    <div style={{ border: '1px solid blue', padding: '1em' }}>\n+      <div id=\"timestamp\">{`Timestamp: ${now}`}</div>\n+      <Suspense fallback={<div style={{ color: 'grey' }}>Loading 2...</div>}>\n+        <Dynamic />\n+      </Suspense>\n+    </div>\n+  )\n+}\n+\n+async function privateCache() {\n+  'use cache: private'\n+  const now = Date.now()\n+  await cachedDelay(500, [__filename])\n+  return now\n+}\n+\n+async function Dynamic() {\n+  await uncachedIO()\n+  await connection()\n+  return (\n+    <div style={{ border: '1px solid tomato', padding: '1em' }}>\n+      <div id=\"dynamic-content\">Dynamic content</div>\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "c6a670d069c64e8e18a878c2eeca4427ec19adfb",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-runtime/app/(default)/in-private-cache/dynamic-params/[id]/page.tsx",
            "status": "added",
            "additions": 49,
            "deletions": 0,
            "changes": 49,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fin-private-cache%2Fdynamic-params%2F%5Bid%5D%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fin-private-cache%2Fdynamic-params%2F%5Bid%5D%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fin-private-cache%2Fdynamic-params%2F%5Bid%5D%2Fpage.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -0,0 +1,49 @@\n+import { Suspense } from 'react'\n+import { cachedDelay, DebugRenderKind, uncachedIO } from '../../../../shared'\n+import { connection } from 'next/server'\n+\n+type Params = { id: string }\n+\n+export default async function Page({ params }: { params: Promise<Params> }) {\n+  return (\n+    <main>\n+      <DebugRenderKind />\n+      <p>\n+        This page uses params (passed to a private cache) and some uncached IO,\n+        so parts of it should be runtime-prefetchable.\n+      </p>\n+      <Suspense fallback={<div style={{ color: 'grey' }}>Loading 1...</div>}>\n+        <RuntimePrefetchable params={params} />\n+      </Suspense>\n+    </main>\n+  )\n+}\n+\n+async function RuntimePrefetchable({ params }: { params: Promise<Params> }) {\n+  const id = await privateCache(params)\n+  return (\n+    <div style={{ border: '1px solid blue', padding: '1em' }}>\n+      <div id=\"param-value\">{`Param: ${id}`}</div>\n+      <Suspense fallback={<div style={{ color: 'grey' }}>Loading 2...</div>}>\n+        <Dynamic />\n+      </Suspense>\n+    </div>\n+  )\n+}\n+\n+async function privateCache(params: Promise<Params>) {\n+  'use cache: private'\n+  const { id } = await params\n+  await cachedDelay(500, [__filename, id])\n+  return id\n+}\n+\n+async function Dynamic() {\n+  await uncachedIO()\n+  await connection()\n+  return (\n+    <div style={{ border: '1px solid tomato', padding: '1em' }}>\n+      <div id=\"dynamic-content\">Dynamic content</div>\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "9b5e7a08db66140a97cfbcb907f1fba5899d22e8",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-runtime/app/(default)/in-private-cache/search-params/page.tsx",
            "status": "added",
            "additions": 57,
            "deletions": 0,
            "changes": 57,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fin-private-cache%2Fsearch-params%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fin-private-cache%2Fsearch-params%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fin-private-cache%2Fsearch-params%2Fpage.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -0,0 +1,57 @@\n+import { Suspense } from 'react'\n+import { cachedDelay, DebugRenderKind, uncachedIO } from '../../../shared'\n+import { connection } from 'next/server'\n+\n+type AnySearchParams = { [key: string]: string | string[] | undefined }\n+\n+export default async function Page({\n+  searchParams,\n+}: {\n+  searchParams: Promise<AnySearchParams>\n+}) {\n+  return (\n+    <main>\n+      <DebugRenderKind />\n+      <p>\n+        This page uses search params (passed to a private cache) and some\n+        uncached IO, so parts of it should be runtime-prefetchable.\n+      </p>\n+      <Suspense fallback={<div style={{ color: 'grey' }}>Loading 1...</div>}>\n+        <RuntimePrefetchable searchParams={searchParams} />\n+      </Suspense>\n+    </main>\n+  )\n+}\n+\n+async function RuntimePrefetchable({\n+  searchParams,\n+}: {\n+  searchParams: Promise<AnySearchParams>\n+}) {\n+  const searchParam = await privateCache(searchParams)\n+  return (\n+    <div style={{ border: '1px solid blue', padding: '1em' }}>\n+      <div id=\"search-param-value\">{`Search param: ${searchParam}`}</div>\n+      <Suspense fallback={<div style={{ color: 'grey' }}>Loading 2...</div>}>\n+        <Dynamic />\n+      </Suspense>\n+    </div>\n+  )\n+}\n+\n+async function privateCache(searchParams: Promise<AnySearchParams>) {\n+  'use cache: private'\n+  const { searchParam } = await searchParams\n+  await cachedDelay(500, [__filename, searchParam])\n+  return searchParam\n+}\n+\n+async function Dynamic() {\n+  await uncachedIO()\n+  await connection()\n+  return (\n+    <div style={{ border: '1px solid tomato', padding: '1em' }}>\n+      <div id=\"dynamic-content\">Dynamic content</div>\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "54b2b3630b432117f1f5af2bc05fbfd4107ec304",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-runtime/app/(default)/layout.tsx",
            "status": "added",
            "additions": 23,
            "deletions": 0,
            "changes": 23,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Flayout.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -0,0 +1,23 @@\n+import Link from 'next/link'\n+import { ReactNode } from 'react'\n+\n+export default function RootLayout({ children }: { children: ReactNode }) {\n+  return (\n+    <html>\n+      <body style={{ fontFamily: 'monospace' }}>\n+        <Header />\n+        {children}\n+      </body>\n+    </html>\n+  )\n+}\n+\n+function Header() {\n+  return (\n+    <header>\n+      <Link href=\"/\" prefetch={false}>\n+        Home\n+      </Link>\n+    </header>\n+  )\n+}"
        },
        {
            "sha": "3fb48a5db586bce14dcb383d80b4382f47124340",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-runtime/app/(default)/page.tsx",
            "status": "added",
            "additions": 218,
            "deletions": 0,
            "changes": 218,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fpage.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -0,0 +1,218 @@\n+import { DebugLinkAccordion } from '../../components/link-accordion'\n+\n+export default async function Page() {\n+  return (\n+    <main>\n+      <h1>Home</h1>\n+\n+      <h2>directly in a page</h2>\n+      <ul>\n+        <li>\n+          cookies + dynamic content\n+          <ul>\n+            <li>\n+              <DebugLinkAccordion href=\"/in-page/cookies\" prefetch={true} />\n+            </li>\n+          </ul>\n+        </li>\n+\n+        <li>\n+          search params + dynamic content\n+          <ul>\n+            <li>\n+              <DebugLinkAccordion\n+                href=\"/in-page/search-params?searchParam=123\"\n+                prefetch={true}\n+              />\n+            </li>\n+            <li>\n+              <DebugLinkAccordion\n+                href=\"/in-page/search-params?searchParam=456\"\n+                prefetch={true}\n+              />\n+            </li>\n+          </ul>\n+        </li>\n+        <li>\n+          dynamic params + dynamic content\n+          <ul>\n+            <li>\n+              <DebugLinkAccordion\n+                href=\"/in-page/dynamic-params/123\"\n+                prefetch={true}\n+              />\n+            </li>\n+            <li>\n+              <DebugLinkAccordion\n+                href=\"/in-page/dynamic-params/456\"\n+                prefetch={true}\n+              />\n+            </li>\n+          </ul>\n+        </li>\n+        <li>\n+          only cookies\n+          <ul>\n+            <li>\n+              <DebugLinkAccordion\n+                href=\"/in-page/cookies-only\"\n+                prefetch={true}\n+              />\n+            </li>\n+          </ul>\n+        </li>\n+      </ul>\n+\n+      <h2>\n+        <code>use cache: private</code>\n+      </h2>\n+      <ul>\n+        <li>\n+          cookies in private cache + dynamic content\n+          <ul>\n+            <li>\n+              <DebugLinkAccordion\n+                href=\"/in-private-cache/cookies\"\n+                prefetch={true}\n+              />\n+            </li>\n+          </ul>\n+        </li>\n+        <li>\n+          dynamic params in private cache + dynamic content\n+          <ul>\n+            <li>\n+              <DebugLinkAccordion\n+                href=\"/in-private-cache/dynamic-params/123\"\n+                prefetch={true}\n+              />\n+            </li>\n+            <li>\n+              <DebugLinkAccordion\n+                href=\"/in-private-cache/dynamic-params/456\"\n+                prefetch={true}\n+              />\n+            </li>\n+          </ul>\n+        </li>\n+        <li>\n+          search params in private cache + dynamic content\n+          <ul>\n+            <li>\n+              <DebugLinkAccordion\n+                href=\"/in-private-cache/search-params?searchParam=123\"\n+                prefetch={true}\n+              />\n+            </li>\n+            <li>\n+              <DebugLinkAccordion\n+                href=\"/in-private-cache/search-params?searchParam=456\"\n+                prefetch={true}\n+              />\n+            </li>\n+          </ul>\n+        </li>\n+        <li>\n+          only cookies in private cache\n+          <ul>\n+            <li>\n+              <DebugLinkAccordion\n+                href=\"/in-private-cache/cookies-only\"\n+                prefetch={true}\n+              />\n+            </li>\n+          </ul>\n+        </li>\n+        <li>\n+          Date.now() in private cache\n+          <ul>\n+            <li>\n+              <DebugLinkAccordion\n+                href=\"/in-private-cache/date-now\"\n+                prefetch={true}\n+              />\n+            </li>\n+          </ul>\n+        </li>\n+      </ul>\n+\n+      <h2>short-lived caches</h2>\n+      <ul>\n+        <li>\n+          private, short stale\n+          <ul>\n+            <li>\n+              <DebugLinkAccordion\n+                href=\"/caches/private-short-stale\"\n+                prefetch={'auto'}\n+              />\n+            </li>\n+            <li>\n+              <DebugLinkAccordion\n+                href=\"/caches/private-short-stale\"\n+                prefetch={true}\n+              />\n+            </li>\n+          </ul>\n+        </li>\n+        <li>\n+          public, short expire, long enough stale\n+          <ul>\n+            <li>\n+              <DebugLinkAccordion\n+                href=\"/caches/public-short-expire-long-stale\"\n+                prefetch={'auto'}\n+              />\n+            </li>\n+            <li>\n+              <DebugLinkAccordion\n+                href=\"/caches/public-short-expire-long-stale\"\n+                prefetch={true}\n+              />\n+            </li>\n+          </ul>\n+        </li>\n+        <li>\n+          public, short expire, short stale\n+          <ul>\n+            <li>\n+              <DebugLinkAccordion\n+                href=\"/caches/public-short-expire-short-stale\"\n+                prefetch={'auto'}\n+              />\n+            </li>\n+            <li>\n+              <DebugLinkAccordion\n+                href=\"/caches/public-short-expire-short-stale\"\n+                prefetch={true}\n+              />\n+            </li>\n+          </ul>\n+        </li>\n+      </ul>\n+\n+      <h2>misc</h2>\n+      <ul>\n+        <li>\n+          <DebugLinkAccordion href=\"/fully-static\" prefetch={true} />\n+        </li>\n+      </ul>\n+\n+      <h2>errors</h2>\n+      <ul>\n+        <li>\n+          <DebugLinkAccordion\n+            href=\"/errors/error-after-cookies\"\n+            prefetch={true}\n+          />\n+        </li>\n+        <li>\n+          <DebugLinkAccordion\n+            href=\"/errors/sync-io-after-cookies\"\n+            prefetch={true}\n+          />\n+        </li>\n+      </ul>\n+    </main>\n+  )\n+}"
        },
        {
            "sha": "4bdbb6e93655a504e301eb76f425c02cbe929a69",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-runtime/app/shared.tsx",
            "status": "added",
            "additions": 34,
            "deletions": 0,
            "changes": 34,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2Fshared.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2Fshared.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2Fshared.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -0,0 +1,34 @@\n+import { unstable_cacheLife } from 'next/cache'\n+import { setTimeout } from 'timers/promises'\n+\n+export async function uncachedIO() {\n+  await setTimeout(500)\n+}\n+\n+export async function cachedDelay(time: number, cacheBuster?: any) {\n+  'use cache'\n+  unstable_cacheLife('minutes')\n+  console.log('cachedDelay', time, cacheBuster)\n+  await setTimeout(time)\n+}\n+\n+export function DebugRenderKind() {\n+  const { workUnitAsyncStorage } =\n+    require('next/dist/server/app-render/work-unit-async-storage.external') as typeof import('next/dist/server/app-render/work-unit-async-storage.external')\n+  const workUnitStore = workUnitAsyncStorage.getStore()!\n+  return (\n+    <div>\n+      workUnitStore.type: {workUnitStore.type}\n+      {(() => {\n+        switch (workUnitStore.type) {\n+          case 'prerender':\n+            return '(static prefetch)'\n+          case 'prerender-runtime':\n+            return '(runtime prefetch)'\n+          default:\n+            return null\n+        }\n+      })()}\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "287fa05d34e91f26d32c71bf64019ae641b4cdf7",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-runtime/app/with-root-param/[lang]/in-page/root-params/page.tsx",
            "status": "added",
            "additions": 41,
            "deletions": 0,
            "changes": 41,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2Fwith-root-param%2F%5Blang%5D%2Fin-page%2Froot-params%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2Fwith-root-param%2F%5Blang%5D%2Fin-page%2Froot-params%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2Fwith-root-param%2F%5Blang%5D%2Fin-page%2Froot-params%2Fpage.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -0,0 +1,41 @@\n+import { Suspense } from 'react'\n+import { cachedDelay, DebugRenderKind, uncachedIO } from '../../../../shared'\n+import { connection } from 'next/server'\n+import { lang } from 'next/root-params'\n+\n+export default async function Page() {\n+  return (\n+    <main>\n+      <DebugRenderKind />\n+      <p>\n+        This page uses root params and some uncached IO. Root params should\n+        always be available in static prerenders, so a runtime prefetch should\n+        have them too.\n+      </p>\n+      <StaticallyPrefetchable />\n+    </main>\n+  )\n+}\n+\n+async function StaticallyPrefetchable() {\n+  const currentLang = await lang()\n+  await cachedDelay(500, [__filename, currentLang])\n+  return (\n+    <div style={{ border: '1px solid blue', padding: '1em' }}>\n+      <div id=\"root-param-value\">{`Lang: ${currentLang}`}</div>\n+      <Suspense fallback={<div style={{ color: 'grey' }}>Loading 2...</div>}>\n+        <Dynamic />\n+      </Suspense>\n+    </div>\n+  )\n+}\n+\n+async function Dynamic() {\n+  await uncachedIO()\n+  await connection()\n+  return (\n+    <div style={{ border: '1px solid tomato', padding: '1em' }}>\n+      <div id=\"dynamic-content\">Dynamic content</div>\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "8567c41156f8528adfe15b743cb1a326b6688e64",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-runtime/app/with-root-param/[lang]/in-private-cache/root-params/page.tsx",
            "status": "added",
            "additions": 50,
            "deletions": 0,
            "changes": 50,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2Fwith-root-param%2F%5Blang%5D%2Fin-private-cache%2Froot-params%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2Fwith-root-param%2F%5Blang%5D%2Fin-private-cache%2Froot-params%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2Fwith-root-param%2F%5Blang%5D%2Fin-private-cache%2Froot-params%2Fpage.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -0,0 +1,50 @@\n+import { Suspense } from 'react'\n+import { cachedDelay, DebugRenderKind, uncachedIO } from '../../../../shared'\n+import { connection } from 'next/server'\n+import { lang } from 'next/root-params'\n+\n+export default async function Page() {\n+  return (\n+    <main>\n+      <DebugRenderKind />\n+      <p>\n+        This page uses root params (inside a private cache) and some uncached\n+        IO. Private caches are only rendered during runtime prefetches and\n+        navigation requests, so they won't be part of a static prefetch, but\n+        they should be part of a runtime prefetch.\n+      </p>\n+      <Suspense fallback=\"Loading 1...\">\n+        <DynamicallyPrefetchable />\n+      </Suspense>\n+    </main>\n+  )\n+}\n+\n+async function DynamicallyPrefetchable() {\n+  const currentLang = await privateCache()\n+  return (\n+    <div style={{ border: '1px solid blue', padding: '1em' }}>\n+      <div id=\"root-param-value\">{`Lang: ${currentLang}`}</div>\n+      <Suspense fallback={<div style={{ color: 'grey' }}>Loading 2...</div>}>\n+        <Dynamic />\n+      </Suspense>\n+    </div>\n+  )\n+}\n+\n+async function privateCache() {\n+  'use cache: private'\n+  const currentLang = await lang()\n+  await cachedDelay(500, [__filename, currentLang])\n+  return currentLang\n+}\n+\n+async function Dynamic() {\n+  await uncachedIO()\n+  await connection()\n+  return (\n+    <div style={{ border: '1px solid tomato', padding: '1em' }}>\n+      <div id=\"dynamic-content\">Dynamic content</div>\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "3042ae2c18006cff56ad7b9e3c3f0ef17d96e8d0",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-runtime/app/with-root-param/[lang]/layout.tsx",
            "status": "added",
            "additions": 34,
            "deletions": 0,
            "changes": 34,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2Fwith-root-param%2F%5Blang%5D%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2Fwith-root-param%2F%5Blang%5D%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2Fwith-root-param%2F%5Blang%5D%2Flayout.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -0,0 +1,34 @@\n+import Link from 'next/link'\n+import { lang } from 'next/root-params'\n+import { ReactNode } from 'react'\n+\n+export default async function RootLayout({\n+  children,\n+}: {\n+  children: ReactNode\n+}) {\n+  const currentLang = await lang()\n+  return (\n+    <html lang={currentLang}>\n+      <body style={{ fontFamily: 'monospace' }}>\n+        <Header />\n+        {children}\n+      </body>\n+    </html>\n+  )\n+}\n+\n+async function Header() {\n+  const currentLang = await lang()\n+  return (\n+    <header>\n+      <Link href={`/with-root-param/${currentLang}`} prefetch={false}>\n+        Home (for lang: {currentLang})\n+      </Link>\n+    </header>\n+  )\n+}\n+\n+export function generateStaticParams() {\n+  return [{ lang: 'en' }]\n+}"
        },
        {
            "sha": "97cbf8adec0174ab955469c4350b7e94a0dd1d0e",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-runtime/app/with-root-param/[lang]/page.tsx",
            "status": "added",
            "additions": 56,
            "deletions": 0,
            "changes": 56,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2Fwith-root-param%2F%5Blang%5D%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2Fwith-root-param%2F%5Blang%5D%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2Fwith-root-param%2F%5Blang%5D%2Fpage.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -0,0 +1,56 @@\n+import { lang } from 'next/root-params'\n+import { DebugLinkAccordion } from '../../../components/link-accordion'\n+\n+export default async function Page() {\n+  const currentLang = await lang()\n+  const otherLang = currentLang === 'en' ? 'de' : 'en'\n+  return (\n+    <main>\n+      <h1>Home - with root param ({currentLang})</h1>\n+\n+      <h2>directly in a page</h2>\n+      <ul>\n+        <li>\n+          root params + dynamic content\n+          <ul>\n+            <li>\n+              <DebugLinkAccordion\n+                href={`/with-root-param/${currentLang}/in-page/root-params`}\n+                prefetch={true}\n+              />\n+            </li>\n+            <li>\n+              <DebugLinkAccordion\n+                href={`/with-root-param/${otherLang}/in-page/root-params`}\n+                prefetch={true}\n+              />\n+            </li>\n+          </ul>\n+        </li>\n+      </ul>\n+\n+      <h2>\n+        <code>use cache: private</code>\n+      </h2>\n+      <ul>\n+        <li>\n+          root params + dynamic content\n+          <ul>\n+            <li>\n+              <DebugLinkAccordion\n+                href={`/with-root-param/${currentLang}/in-private-cache/root-params`}\n+                prefetch={true}\n+              />\n+            </li>\n+            <li>\n+              <DebugLinkAccordion\n+                href={`/with-root-param/${otherLang}/in-private-cache/root-params`}\n+                prefetch={true}\n+              />\n+            </li>\n+          </ul>\n+        </li>\n+      </ul>\n+    </main>\n+  )\n+}"
        },
        {
            "sha": "64fb109773e01e9db59b9340ddaad87ed83cf3c5",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-runtime/components/error-boundary.tsx",
            "status": "added",
            "additions": 24,
            "deletions": 0,
            "changes": 24,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fcomponents%2Ferror-boundary.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fcomponents%2Ferror-boundary.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fcomponents%2Ferror-boundary.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -0,0 +1,24 @@\n+'use client'\n+\n+import React from 'react'\n+\n+export class ErrorBoundary extends React.Component<{\n+  children: React.ReactNode\n+}> {\n+  state = { error: null }\n+\n+  static getDerivedStateFromError(error) {\n+    return { error }\n+  }\n+\n+  render() {\n+    if (this.state.error) {\n+      return (\n+        <div id=\"error-boundary\">\n+          Error boundary: {this.state.error.message}\n+        </div>\n+      )\n+    }\n+    return this.props.children\n+  }\n+}"
        },
        {
            "sha": "19498939be06645619efe919f55560b3492b964a",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-runtime/components/link-accordion.tsx",
            "status": "added",
            "additions": 63,
            "deletions": 0,
            "changes": 63,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fcomponents%2Flink-accordion.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fcomponents%2Flink-accordion.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fcomponents%2Flink-accordion.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -0,0 +1,63 @@\n+'use client'\n+\n+import Link, { type LinkProps } from 'next/link'\n+import { ComponentProps, useState } from 'react'\n+\n+export function LinkAccordion({\n+  href,\n+  children,\n+  prefetch,\n+}: {\n+  href: string\n+  children: React.ReactNode\n+  prefetch?: LinkProps['prefetch']\n+}) {\n+  const [isVisible, setIsVisible] = useState(false)\n+  return (\n+    <>\n+      <input\n+        type=\"checkbox\"\n+        checked={isVisible}\n+        onChange={() => setIsVisible(!isVisible)}\n+        data-link-accordion={href}\n+        data-prefetch={getPrefetchKind(prefetch)}\n+      />\n+      {isVisible ? (\n+        <Link href={href} prefetch={prefetch}>\n+          {children}\n+        </Link>\n+      ) : (\n+        <>{children} (link is hidden)</>\n+      )}\n+    </>\n+  )\n+}\n+\n+export function DebugLinkAccordion({\n+  href,\n+  prefetch,\n+}: Omit<ComponentProps<typeof LinkAccordion>, 'children'>) {\n+  const prefetchKind = getPrefetchKind(prefetch)\n+  return (\n+    <LinkAccordion href={href} prefetch={prefetch} data-prefetch={prefetch}>\n+      {href} ({prefetchKind})\n+    </LinkAccordion>\n+  )\n+}\n+\n+function getPrefetchKind(prefetch: LinkProps['prefetch']) {\n+  switch (prefetch) {\n+    case false:\n+      return 'disabled'\n+    case undefined:\n+    case null:\n+    case 'auto':\n+      return 'auto'\n+    case true:\n+      return 'runtime'\n+    case 'unstable_forceStale':\n+      return 'full'\n+    default:\n+      prefetch satisfies never\n+  }\n+}"
        },
        {
            "sha": "728848f57dc2d3db2b51946b889e2eb268aaec23",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-runtime/next.config.ts",
            "status": "added",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fnext.config.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fnext.config.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fnext.config.ts?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -0,0 +1,8 @@\n+import type { NextConfig } from 'next'\n+\n+const nextConfig: NextConfig = {\n+  experimental: { cacheComponents: true, clientSegmentCache: true },\n+  productionBrowserSourceMaps: true,\n+}\n+\n+export default nextConfig"
        },
        {
            "sha": "3881ed0f83db1cff9067fcebf3e1bc4e224982ea",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-runtime/prefetch-runtime.test.ts",
            "status": "added",
            "additions": 1061,
            "deletions": 0,
            "changes": 1061,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fprefetch-runtime.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fprefetch-runtime.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fprefetch-runtime.test.ts?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -0,0 +1,1061 @@\n+import { nextTestSetup } from 'e2e-utils'\n+import type * as Playwright from 'playwright'\n+import { createRouterAct } from '../router-act'\n+\n+describe('<Link prefetch={true}> (runtime prefetch)', () => {\n+  const { next, isNextDev, isNextDeploy } = nextTestSetup({\n+    files: __dirname,\n+  })\n+  if (isNextDev) {\n+    it('disabled in development', () => {})\n+    return\n+  }\n+\n+  describe.each([\n+    { description: 'in a page', prefix: 'in-page' },\n+    { description: 'in a private cache', prefix: 'in-private-cache' },\n+  ])('$description', ({ prefix }) => {\n+    it('includes dynamic params, but not dynamic content', async () => {\n+      let page: Playwright.Page\n+      const browser = await next.browser('/', {\n+        beforePageLoad(p: Playwright.Page) {\n+          page = p\n+        },\n+      })\n+      const act = createRouterAct(page)\n+\n+      // Reveal the link to trigger a runtime prefetch for one value of the dynamic param\n+      await act(async () => {\n+        const linkToggle = await browser.elementByCss(\n+          `input[data-link-accordion=\"/${prefix}/dynamic-params/123\"]`\n+        )\n+        await linkToggle.click()\n+      }, [\n+        // Should allow reading dynamic params\n+        {\n+          includes: 'Param: 123',\n+        },\n+        // Should not prefetch the dynamic content\n+        {\n+          includes: 'Dynamic content',\n+          block: 'reject',\n+        },\n+      ])\n+\n+      // Reveal the link to trigger a runtime prefetch for a different value of the dynamic param\n+      await act(async () => {\n+        const linkToggle = await browser.elementByCss(\n+          `input[data-link-accordion=\"/${prefix}/dynamic-params/456\"]`\n+        )\n+        await linkToggle.click()\n+      }, [\n+        // Should allow reading dynamic params\n+        {\n+          includes: 'Param: 456',\n+        },\n+        // Should not prefetch the dynamic content\n+        {\n+          includes: 'Dynamic content',\n+          block: 'reject',\n+        },\n+      ])\n+\n+      // Navigate to the page\n+      await act(async () => {\n+        await act(\n+          async () => {\n+            await browser\n+              .elementByCss(`a[href=\"/${prefix}/dynamic-params/123\"]`)\n+              .click()\n+          },\n+          {\n+            // Temporarily block the navigation request.\n+            // The runtime-prefetched parts of the tree should be visible before it finishes.\n+            includes: 'Dynamic content',\n+            block: true,\n+          }\n+        )\n+        expect(await browser.elementById('param-value').text()).toEqual(\n+          'Param: 123'\n+        )\n+      })\n+      // After navigating, we should see both the parts that we prefetched and dynamic content.\n+      expect(await browser.elementById('param-value').text()).toEqual(\n+        'Param: 123'\n+      )\n+      expect(await browser.elementById('dynamic-content').text()).toEqual(\n+        'Dynamic content'\n+      )\n+\n+      await browser.back()\n+\n+      // Reveal the link to the second page again. It should not be prefetched again\n+      await act(async () => {\n+        const linkToggle = await browser.elementByCss(\n+          `input[data-link-accordion=\"/${prefix}/dynamic-params/456\"]`\n+        )\n+        await linkToggle.click()\n+      }, 'no-requests')\n+\n+      // Navigate to the other page\n+      await act(async () => {\n+        await act(\n+          async () => {\n+            await browser\n+              .elementByCss(`a[href=\"/${prefix}/dynamic-params/456\"]`)\n+              .click()\n+          },\n+          {\n+            // Temporarily block the navigation request.\n+            // The runtime-prefetched parts of the tree should be visible before it finishes.\n+            includes: 'Dynamic content',\n+            block: true,\n+          }\n+        )\n+        expect(await browser.elementById('param-value').text()).toEqual(\n+          'Param: 456'\n+        )\n+      })\n+      // After navigating, we should see both the parts that we prefetched and dynamic content.\n+      expect(await browser.elementById('param-value').text()).toEqual(\n+        'Param: 456'\n+      )\n+      expect(await browser.elementById('dynamic-content').text()).toEqual(\n+        'Dynamic content'\n+      )\n+    })\n+\n+    it('includes root params, but not dynamic content', async () => {\n+      let page: Playwright.Page\n+      const browser = await next.browser('/with-root-param/en', {\n+        beforePageLoad(p: Playwright.Page) {\n+          page = p\n+        },\n+      })\n+      const act = createRouterAct(page)\n+\n+      // Reveal the link to trigger a runtime prefetch for one value of the root param\n+      await act(async () => {\n+        const linkToggle = await browser.elementByCss(\n+          `input[data-link-accordion=\"/with-root-param/en/${prefix}/root-params\"]`\n+        )\n+        await linkToggle.click()\n+      }, [\n+        // Should allow reading root params\n+        {\n+          includes: 'Lang: en',\n+        },\n+        // Should not prefetch the dynamic content\n+        {\n+          includes: 'Dynamic content',\n+          block: 'reject',\n+        },\n+      ])\n+\n+      // TODO(runtime-ppr) - visiting root params that weren't in generateStaticParams errors when deployed\n+      if (!isNextDeploy) {\n+        // Reveal the link to trigger a runtime prefetch for a different value of the root param\n+        await act(async () => {\n+          const linkToggle = await browser.elementByCss(\n+            `input[data-link-accordion=\"/with-root-param/de/${prefix}/root-params\"]`\n+          )\n+          await linkToggle.click()\n+        }, [\n+          // Should allow reading root params\n+          {\n+            includes: 'Lang: de',\n+          },\n+          // Should not prefetch the dynamic content\n+          {\n+            includes: 'Dynamic content',\n+            block: 'reject',\n+          },\n+        ])\n+      }\n+\n+      // Navigate to the first page\n+      await act(async () => {\n+        await act(\n+          async () => {\n+            await browser\n+              .elementByCss(\n+                `a[href=\"/with-root-param/en/${prefix}/root-params\"]`\n+              )\n+              .click()\n+          },\n+          {\n+            // Temporarily block the navigation request.\n+            // The runtime-prefetched parts of the tree should be visible before it finishes.\n+            includes: 'Dynamic content',\n+            block: true,\n+          }\n+        )\n+        expect(await browser.elementById('root-param-value').text()).toEqual(\n+          'Lang: en'\n+        )\n+      })\n+      // After navigating, we should see both the parts that we prefetched and dynamic content.\n+      expect(await browser.elementById('root-param-value').text()).toEqual(\n+        'Lang: en'\n+      )\n+      expect(await browser.elementById('dynamic-content').text()).toEqual(\n+        'Dynamic content'\n+      )\n+\n+      // TODO(runtime-ppr) - visiting root params that weren't in generateStaticParams errors when deployed\n+      if (!isNextDeploy) {\n+        await browser.back()\n+\n+        // Reveal the link to the second page again. It should not be prefetched again\n+        await act(async () => {\n+          const linkToggle = await browser.elementByCss(\n+            `input[data-link-accordion=\"/with-root-param/de/${prefix}/root-params\"]`\n+          )\n+          await linkToggle.click()\n+        }, 'no-requests')\n+\n+        // Navigate to the other page\n+        await act(async () => {\n+          await act(\n+            async () => {\n+              await browser\n+                .elementByCss(\n+                  `a[href=\"/with-root-param/de/${prefix}/root-params\"]`\n+                )\n+                .click()\n+            },\n+            {\n+              // Temporarily block the navigation request.\n+              // The runtime-prefetched parts of the tree should be visible before it finishes.\n+              includes: 'Dynamic content',\n+              block: true,\n+            }\n+          )\n+          expect(await browser.elementById('root-param-value').text()).toEqual(\n+            'Lang: de'\n+          )\n+        })\n+        // After navigating, we should see both the parts that we prefetched and dynamic content.\n+        expect(await browser.elementById('root-param-value').text()).toEqual(\n+          'Lang: de'\n+        )\n+        expect(await browser.elementById('dynamic-content').text()).toEqual(\n+          'Dynamic content'\n+        )\n+      }\n+    })\n+\n+    it('includes search params, but not dynamic content', async () => {\n+      let page: Playwright.Page\n+      const browser = await next.browser('/', {\n+        beforePageLoad(p: Playwright.Page) {\n+          page = p\n+        },\n+      })\n+      const act = createRouterAct(page)\n+\n+      // Reveal the link to trigger a runtime prefetch for one value of the search param\n+      await act(async () => {\n+        const linkToggle = await browser.elementByCss(\n+          `input[data-link-accordion=\"/${prefix}/search-params?searchParam=123\"]`\n+        )\n+        await linkToggle.click()\n+      }, [\n+        // Should allow reading search params\n+        {\n+          includes: 'Search param: 123',\n+        },\n+        // Should not prefetch the dynamic content\n+        {\n+          includes: 'Dynamic content',\n+          block: 'reject',\n+        },\n+      ])\n+\n+      // Reveal the link to trigger a runtime prefetch for a different value of the search param\n+      await act(async () => {\n+        const linkToggle = await browser.elementByCss(\n+          `input[data-link-accordion=\"/${prefix}/search-params?searchParam=456\"]`\n+        )\n+        await linkToggle.click()\n+      }, [\n+        // Should allow reading search params\n+        {\n+          includes: 'Search param: 456',\n+        },\n+        // Should not prefetch the dynamic content\n+        {\n+          includes: 'Dynamic content',\n+          block: 'reject',\n+        },\n+      ])\n+\n+      // Navigate to the page\n+      await act(async () => {\n+        await act(\n+          async () => {\n+            await browser\n+              .elementByCss(\n+                `a[href=\"/${prefix}/search-params?searchParam=123\"]`\n+              )\n+              .click()\n+          },\n+          {\n+            // Temporarily block the navigation request.\n+            // The runtime-prefetched parts of the tree should be visible before it finishes.\n+            includes: 'Dynamic content',\n+            block: true,\n+          }\n+        )\n+        expect(await browser.elementById('search-param-value').text()).toEqual(\n+          'Search param: 123'\n+        )\n+      })\n+      // After navigating, we should see both the parts that we prefetched and dynamic content.\n+      expect(await browser.elementById('search-param-value').text()).toEqual(\n+        'Search param: 123'\n+      )\n+      expect(await browser.elementById('dynamic-content').text()).toEqual(\n+        'Dynamic content'\n+      )\n+\n+      await browser.back()\n+\n+      // Reveal the link to the second page again. It should not be prefetched again\n+      await act(async () => {\n+        const linkToggle = await browser.elementByCss(\n+          `input[data-link-accordion=\"/${prefix}/search-params?searchParam=456\"]`\n+        )\n+        await linkToggle.click()\n+      }, 'no-requests')\n+\n+      // Navigate to the other page\n+      await act(\n+        async () => {\n+          await browser\n+            .elementByCss(`a[href=\"/${prefix}/search-params?searchParam=456\"]`)\n+            .click()\n+        },\n+        {\n+          // Now the dynamic content should be fetched\n+          includes: 'Dynamic content',\n+        }\n+      )\n+      expect(await browser.elementById('search-param-value').text()).toEqual(\n+        'Search param: 456'\n+      )\n+      expect(await browser.elementById('dynamic-content').text()).toEqual(\n+        'Dynamic content'\n+      )\n+    })\n+\n+    it('includes cookies, but not dynamic content', async () => {\n+      let page: Playwright.Page\n+      const browser = await next.browser('/', {\n+        beforePageLoad(p: Playwright.Page) {\n+          page = p\n+        },\n+      })\n+      // Clear cookies after the test. This currently doesn't happen automatically.\n+      await using _ = defer(() => browser.deleteCookies())\n+\n+      const act = createRouterAct(page)\n+\n+      await browser.addCookie({ name: 'testCookie', value: 'initialValue' })\n+\n+      // Reveal the link to trigger a runtime prefetch for the initial cookie value\n+      await act(async () => {\n+        const linkToggle = await browser.elementByCss(\n+          `input[data-link-accordion=\"/${prefix}/cookies\"]`\n+        )\n+        await linkToggle.click()\n+      }, [\n+        // Should allow reading cookies\n+        {\n+          includes: 'Cookie: initialValue',\n+        },\n+        // Should not prefetch the dynamic content\n+        {\n+          includes: 'Dynamic content',\n+          block: 'reject',\n+        },\n+      ])\n+\n+      // Navigate to the page\n+      await act(async () => {\n+        await act(\n+          async () => {\n+            await browser.elementByCss(`a[href=\"/${prefix}/cookies\"]`).click()\n+          },\n+          {\n+            // Temporarily block the navigation request.\n+            // The runtime-prefetched parts of the tree should be visible before it finishes.\n+            includes: 'Dynamic content',\n+            block: true,\n+          }\n+        )\n+        expect(await browser.elementById('cookie-value').text()).toEqual(\n+          'Cookie: initialValue'\n+        )\n+      })\n+      // After navigating, we should see both the parts that we prefetched and dynamic content.\n+      expect(await browser.elementById('cookie-value').text()).toEqual(\n+        'Cookie: initialValue'\n+      )\n+      expect(await browser.elementById('dynamic-content').text()).toEqual(\n+        'Dynamic content'\n+      )\n+\n+      // Update the cookie via a server action.\n+      // This should cause the client cache to be dropped,\n+      // so the page should get prefetched again when the link becomes visible\n+      await browser.elementByCss('input[name=\"cookie\"]').type('updatedValue')\n+      await browser.elementByCss('[type=\"submit\"]').click()\n+\n+      // Go back to the previous page\n+      await browser.back()\n+\n+      // Reveal the link again to trigger a runtime prefetch for the new value of the cookie\n+      await act(async () => {\n+        const linkToggle = await browser.elementByCss(\n+          `input[data-link-accordion=\"/${prefix}/cookies\"]`\n+        )\n+        await linkToggle.click()\n+      }, [\n+        // Should allow reading dynamic params\n+        {\n+          includes: 'Cookie: updatedValue',\n+        },\n+        // Should not prefetch the dynamic content\n+        {\n+          includes: 'Dynamic content',\n+          block: 'reject',\n+        },\n+      ])\n+\n+      // Navigate to the page\n+      await act(async () => {\n+        await act(\n+          async () => {\n+            await browser.elementByCss(`a[href=\"/${prefix}/cookies\"]`).click()\n+          },\n+          {\n+            includes: 'Dynamic content',\n+            block: true,\n+          }\n+        )\n+        expect(await browser.elementById('cookie-value').text()).toEqual(\n+          'Cookie: updatedValue'\n+        )\n+      })\n+\n+      expect(await browser.elementById('cookie-value').text()).toEqual(\n+        'Cookie: updatedValue'\n+      )\n+      expect(await browser.elementById('dynamic-content').text()).toEqual(\n+        'Dynamic content'\n+      )\n+    })\n+\n+    it('can completely prefetch a page that uses cookies and no uncached IO', async () => {\n+      let page: Playwright.Page\n+      const browser = await next.browser('/', {\n+        beforePageLoad(p: Playwright.Page) {\n+          page = p\n+        },\n+      })\n+      // Clear cookies after the test. This currently doesn't happen automatically.\n+      await using _ = defer(() => browser.deleteCookies())\n+\n+      const act = createRouterAct(page)\n+\n+      await browser.addCookie({ name: 'testCookie', value: 'initialValue' })\n+\n+      // Reveal the link to trigger a runtime prefetch for the initial cookie value\n+      await act(async () => {\n+        const linkToggle = await browser.elementByCss(\n+          `input[data-link-accordion=\"/${prefix}/cookies-only\"]`\n+        )\n+        await linkToggle.click()\n+      }, [\n+        // Should allow reading cookies\n+        {\n+          includes: 'Cookie: initialValue',\n+        },\n+      ])\n+\n+      // Navigate to the page.\n+      await act(\n+        async () => {\n+          await browser\n+            .elementByCss(`a[href=\"/${prefix}/cookies-only\"]`)\n+            .click()\n+        },\n+        // The page doesn't use any other IO, so we prefetched it completely, and shouldn't issue any more requests.\n+        'no-requests'\n+      )\n+      expect(await browser.elementById('cookie-value').text()).toEqual(\n+        'Cookie: initialValue'\n+      )\n+    })\n+  })\n+\n+  describe('should not cache runtime prefetch responses in the browser cache or server-side', () => {\n+    // This is a bit difficult to test, but we can request the same thing repeatedly and expect different results.\n+\n+    it.each([\n+      { description: 'in a page', prefix: 'in-page' },\n+      { description: 'in a private cache', prefix: 'in-private-cache' },\n+    ])(\n+      'different cookies should return different prefetch results - $description',\n+      async ({ prefix }) => {\n+        let page: Playwright.Page\n+        const browser = await next.browser('/', {\n+          beforePageLoad(p: Playwright.Page) {\n+            page = p\n+          },\n+        })\n+        // Clear cookies after the test. This currently doesn't happen automatically.\n+        await using _ = defer(() => browser.deleteCookies())\n+\n+        const act = createRouterAct(page)\n+\n+        await browser.addCookie({ name: 'testCookie', value: 'initialValue' })\n+\n+        // Reveal the link to trigger a runtime prefetch for the initial cookie value\n+        await act(async () => {\n+          const linkToggle = await browser.elementByCss(\n+            `input[data-link-accordion=\"/${prefix}/cookies-only\"]`\n+          )\n+          await linkToggle.click()\n+        }, [\n+          // Should allow reading cookies\n+          {\n+            includes: 'Cookie: initialValue',\n+          },\n+        ])\n+\n+        // Reload the page with a new cookie value\n+        await browser.addCookie({ name: 'testCookie', value: 'updatedValue' })\n+        await browser.refresh()\n+\n+        // Reveal the link to trigger a runtime prefetch for the updated cookie value.\n+        await act(async () => {\n+          const linkToggle = await browser.elementByCss(\n+            `input[data-link-accordion=\"/${prefix}/cookies-only\"]`\n+          )\n+          await linkToggle.click()\n+        }, [\n+          // The response shouldn't be cached in the browser or on the server.\n+          // If it was, we'd get a stale value here.\n+          {\n+            includes: 'Cookie: updatedValue',\n+          },\n+        ])\n+      }\n+    )\n+\n+    it('private caches should return new results on each request', async () => {\n+      let page: Playwright.Page\n+      const browser = await next.browser('/', {\n+        beforePageLoad(p: Playwright.Page) {\n+          page = p\n+        },\n+      })\n+      // Clear cookies after the test. This currently doesn't happen automatically.\n+      await using _ = defer(() => browser.deleteCookies())\n+\n+      const act = createRouterAct(page)\n+\n+      // Reveal the link to trigger the first runtime prefetch\n+      await act(async () => {\n+        const linkToggle = await browser.elementByCss(\n+          `input[data-link-accordion=\"/in-private-cache/date-now\"]`\n+        )\n+        await linkToggle.click()\n+      }, [\n+        // The timestamp value is in a private cache, so it should be included\n+        {\n+          includes: 'Timestamp: ',\n+        },\n+      ])\n+\n+      // Navigate to the page to reveal the runtime-prefetched content, and save the timestamp value it had\n+      let firstTimestampValue: string\n+      await act(async () => {\n+        await act(\n+          async () => {\n+            await browser\n+              .elementByCss(`a[href=\"/in-private-cache/date-now\"]`)\n+              .click()\n+          },\n+          // Temporarily block the navigation request.\n+          // The prefetched parts of the tree should be visible before it finishes.\n+          'block'\n+        )\n+        firstTimestampValue = await browser.elementById('timestamp').text()\n+      })\n+\n+      // Go back to the initial page and reload it to clear the client router cache\n+      await browser.back()\n+      await browser.refresh()\n+\n+      // Reveal the link to trigger the second runtime prefetch\n+      await act(async () => {\n+        const linkToggle = await browser.elementByCss(\n+          `input[data-link-accordion=\"/in-private-cache/date-now\"]`\n+        )\n+        await linkToggle.click()\n+      }, [\n+        // The timestamp value is in a private cache, so it should be included\n+        {\n+          includes: 'Timestamp: ',\n+        },\n+      ])\n+\n+      // Navigate to the page to reveal the runtime-prefetched content, and save the timestamp value it had\n+      let secondTimestampValue: string\n+      await act(async () => {\n+        await act(\n+          async () => {\n+            await browser\n+              .elementByCss(`a[href=\"/in-private-cache/date-now\"]`)\n+              .click()\n+          },\n+          // Temporarily block the navigation request.\n+          // The prefetched parts of the tree should be visible before it finishes.\n+          'block'\n+        )\n+        secondTimestampValue = await browser.elementById('timestamp').text()\n+      })\n+\n+      // If the runtime prefetch response wasn't cached, the responses should be different\n+      expect(firstTimestampValue).not.toEqual(secondTimestampValue)\n+    })\n+  })\n+\n+  it('can completely prefetch a page that is fully static', async () => {\n+    let page: Playwright.Page\n+    const browser = await next.browser('/', {\n+      beforePageLoad(p: Playwright.Page) {\n+        page = p\n+      },\n+    })\n+\n+    const act = createRouterAct(page)\n+\n+    // Reveal the link to trigger a runtime prefetch for the page\n+    await act(async () => {\n+      const linkToggle = await browser.elementByCss(\n+        `input[data-link-accordion=\"/fully-static\"]`\n+      )\n+      await linkToggle.click()\n+    }, [\n+      {\n+        includes: 'Hello from a fully static page!',\n+      },\n+    ])\n+\n+    // Navigate to the page.\n+    await act(\n+      async () => {\n+        await browser.elementByCss(`a[href=\"/fully-static\"]`).click()\n+      },\n+      // The page doesn't use any IO, so we prefetched it completely, and shouldn't issue any more requests.\n+      'no-requests'\n+    )\n+    expect(await browser.elementByCss('p#intro').text()).toBe(\n+      'Hello from a fully static page!'\n+    )\n+  })\n+\n+  describe('cache stale time handling', () => {\n+    it('includes short-lived public caches with a long enough staleTime', async () => {\n+      // If a cache has an expiration time under 5min (DYNAMIC_EXPIRE), we omit it from static prerenders.\n+      // However, it should still be included in a runtime prefetch if it's stale time is above 30s. (RUNTIME_PREFETCH_DYNAMIC_STALE)\n+\n+      let page: Playwright.Page\n+      const browser = await next.browser('/', {\n+        beforePageLoad(p: Playwright.Page) {\n+          page = p\n+        },\n+      })\n+      const act = createRouterAct(page)\n+\n+      const STATIC_CONTENT = 'This page uses a short-lived public cache'\n+      const DYNAMICALLY_PREFETCHABLE_CONTENT = 'Short-lived cached content'\n+\n+      // Reveal the link to trigger a static prefetch\n+      await act(async () => {\n+        const linkToggle = await browser.elementByCss(\n+          `input[data-prefetch=\"auto\"][data-link-accordion=\"/caches/public-short-expire-long-stale\"]`\n+        )\n+        await linkToggle.click()\n+      }, [\n+        // Should include the static shell\n+        {\n+          includes: STATIC_CONTENT,\n+        },\n+        // Should not include the short-lived cache\n+        // (We set the `expire` value to be under 5min, so it will be excluded from prerenders)\n+        {\n+          includes: DYNAMICALLY_PREFETCHABLE_CONTENT,\n+          block: 'reject',\n+        },\n+      ])\n+\n+      // Reveal the link to trigger a runtime prefetch\n+      await act(async () => {\n+        const linkToggle = await browser.elementByCss(\n+          `input[data-prefetch=\"runtime\"][data-link-accordion=\"/caches/public-short-expire-long-stale\"]`\n+        )\n+        await linkToggle.click()\n+      }, [\n+        // Should include the short-lived cache\n+        // (We set `stale` to be above 30s, which means it shouldn't be omitted)\n+        {\n+          includes: DYNAMICALLY_PREFETCHABLE_CONTENT,\n+        },\n+      ])\n+\n+      // Navigate to the page. We didn't include any uncached IO, so the page is fully prefetched,\n+      // and this shouldn't issue any more requests\n+      await act(async () => {\n+        await browser\n+          .elementByCss(`a[href=\"/caches/public-short-expire-long-stale\"]`)\n+          .click()\n+      }, 'no-requests')\n+\n+      expect(await browser.elementByCss('main').text()).toInclude(\n+        DYNAMICALLY_PREFETCHABLE_CONTENT\n+      )\n+    })\n+\n+    it('omits short-lived public caches with a short enough staleTime', async () => {\n+      // If a cache has a stale time below 30s (RUNTIME_PREFETCH_DYNAMIC_STALE), we should omit it from runtime prefetches.\n+\n+      let page: Playwright.Page\n+      const browser = await next.browser('/', {\n+        beforePageLoad(p: Playwright.Page) {\n+          page = p\n+        },\n+      })\n+      const act = createRouterAct(page)\n+\n+      const STATIC_CONTENT = 'This page uses a short-lived public cache'\n+      const DYNAMIC_CONTENT = 'Short-lived cached content'\n+\n+      // Reveal the link to trigger a static prefetch\n+      await act(async () => {\n+        const linkToggle = await browser.elementByCss(\n+          `input[data-prefetch=\"auto\"][data-link-accordion=\"/caches/public-short-expire-short-stale\"]`\n+        )\n+        await linkToggle.click()\n+      }, [\n+        // Should include the static shell\n+        {\n+          includes: STATIC_CONTENT,\n+        },\n+        // Should not include the short-lived cache\n+        // (We set the `expire` value to be under 5min, so it will be excluded from prerenders)\n+        {\n+          includes: DYNAMIC_CONTENT,\n+          block: 'reject',\n+        },\n+      ])\n+\n+      // Reveal the link to trigger a runtime prefetch.\n+      // It'll essentially be the same as the static prefetch, because the only dynamic hole\n+      // will be omitted from both.\n+      // (NOTE: in the future, we might prevent scenarios like this via `generatePrefetch`)\n+      await act(async () => {\n+        const linkToggle = await browser.elementByCss(\n+          `input[data-prefetch=\"runtime\"][data-link-accordion=\"/caches/public-short-expire-short-stale\"]`\n+        )\n+        await linkToggle.click()\n+      }, [\n+        // Should include the shell\n+        {\n+          includes: STATIC_CONTENT,\n+        },\n+        // Should not include the short-lived cache\n+        // (We set the `stale` value to be under 30s, so it will be excluded from runtime prerenders)\n+        {\n+          includes: DYNAMIC_CONTENT,\n+          block: 'reject',\n+        },\n+      ])\n+\n+      // Navigate to the page\n+      await act(async () => {\n+        await act(\n+          async () => {\n+            await browser\n+              .elementByCss(`a[href=\"/caches/public-short-expire-short-stale\"]`)\n+              .click()\n+          },\n+          {\n+            // Temporarily block the navigation request.\n+            // The prefetched parts of the tree should be visible before it finishes.\n+            includes: DYNAMIC_CONTENT,\n+            block: true,\n+          }\n+        )\n+        expect(await browser.elementById('intro').text()).toInclude(\n+          STATIC_CONTENT\n+        )\n+      })\n+\n+      // After navigating, we should see both the parts that we prefetched and the short lived cache.\n+      expect(await browser.elementById('intro').text()).toInclude(\n+        STATIC_CONTENT\n+      )\n+      expect(await browser.elementById('cached-value').text()).toMatch(/\\d+/)\n+    })\n+\n+    it('omits private caches with a short enough staleTime', async () => {\n+      // If a cache has a stale time below 30s (RUNTIME_PREFETCH_DYNAMIC_STALE), we should omit it from runtime prefetches.\n+\n+      let page: Playwright.Page\n+      const browser = await next.browser('/', {\n+        beforePageLoad(p: Playwright.Page) {\n+          page = p\n+        },\n+      })\n+      const act = createRouterAct(page)\n+\n+      const STATIC_CONTENT = 'This page uses a short-lived private cache'\n+      const DYNAMIC_CONTENT = 'Short-lived cached content'\n+\n+      // Reveal the link to trigger a static prefetch\n+      await act(async () => {\n+        const linkToggle = await browser.elementByCss(\n+          `input[data-prefetch=\"auto\"][data-link-accordion=\"/caches/private-short-stale\"]`\n+        )\n+        await linkToggle.click()\n+      }, [\n+        // Should include the static shell\n+        {\n+          includes: STATIC_CONTENT,\n+        },\n+        // Should not include the short-lived cache\n+        // (We set the `expire` value to be under 5min, so it will be excluded from prerenders)\n+        {\n+          includes: DYNAMIC_CONTENT,\n+          block: 'reject',\n+        },\n+      ])\n+\n+      // Reveal the link to trigger a runtime prefetch\n+      await act(async () => {\n+        const linkToggle = await browser.elementByCss(\n+          `input[data-prefetch=\"runtime\"][data-link-accordion=\"/caches/private-short-stale\"]`\n+        )\n+        await linkToggle.click()\n+      }, [\n+        // Should include the shell\n+        {\n+          includes: STATIC_CONTENT,\n+        },\n+        // Should not prefetch the short-lived cache\n+        // (We set the `stale` value to be under 30s, so it will be excluded from runtime prefetches)\n+        {\n+          includes: DYNAMIC_CONTENT,\n+          block: 'reject',\n+        },\n+      ])\n+\n+      // Navigate to the page\n+      await act(async () => {\n+        await act(\n+          async () => {\n+            await browser\n+              .elementByCss(`a[href=\"/caches/private-short-stale\"]`)\n+              .click()\n+          },\n+          {\n+            // Temporarily block the navigation request.\n+            // The runtime-prefetched parts of the tree should be visible before it finishes.\n+            includes: DYNAMIC_CONTENT,\n+            block: true,\n+          }\n+        )\n+        expect(await browser.elementById('intro').text()).toInclude(\n+          STATIC_CONTENT\n+        )\n+      })\n+\n+      // After navigating, we should see both the parts that we prefetched and dynamic content.\n+      expect(await browser.elementById('intro').text()).toInclude(\n+        STATIC_CONTENT\n+      )\n+      const cachedValue1 = await browser.elementById('cached-value').text()\n+      expect(cachedValue1).toMatch(/\\d+/)\n+\n+      // Try navigating again. The cache is private, so we should see a different timestamp\n+      await browser.back()\n+\n+      // Reveal the link again. The prefetch should be cached, so we shouldn't see any requests\n+      await act(async () => {\n+        const linkToggle = await browser.elementByCss(\n+          `input[data-link-accordion=\"/caches/private-short-stale\"]`\n+        )\n+        await linkToggle.click()\n+      }, 'no-requests')\n+\n+      // Navigate to the page again\n+      await act(async () => {\n+        await act(\n+          async () => {\n+            await browser\n+              .elementByCss(`a[href=\"/caches/private-short-stale\"]`)\n+              .click()\n+          },\n+          {\n+            // Temporarily block the navigation request.\n+            // The runtime-prefetched parts of the tree should be visible before it finishes.\n+            includes: 'Short-lived cached content',\n+            block: true,\n+          }\n+        )\n+        expect(await browser.elementById('intro').text()).toInclude(\n+          STATIC_CONTENT\n+        )\n+      })\n+\n+      // After navigating, we should see both the parts that we prefetched and dynamic content.\n+      // The private cache was omitted from the runtime prefetch, so we didn't cache it in the router,\n+      // and it was not cached server-side either, so we should get a different value than the previous request.\n+      const cachedValue2 = await browser.elementById('cached-value').text()\n+      expect(cachedValue2).toMatch(/\\d+/)\n+\n+      expect(cachedValue1).not.toEqual(cachedValue2)\n+    })\n+  })\n+\n+  describe('errors', () => {\n+    it('aborts the prerender and logs an error when sync IO is used after cookies()', async () => {\n+      // In a runtime prefetch, we might encounter sync IO usages that weren't caught during build,\n+      // because they were hidden behind e.g. a cookies() call.\n+      // We currently have no way to catch these statically.\n+      // In that case, we should abort the prerender, but still return partial content.\n+\n+      // TODO: this doesn't work as well as it could, see comment before the navigation\n+\n+      let page: Playwright.Page\n+      const browser = await next.browser('/', {\n+        beforePageLoad(p: Playwright.Page) {\n+          page = p\n+        },\n+      })\n+      const act = createRouterAct(page)\n+\n+      const STATIC_CONTENT = 'This page performs sync IO after a cookies() call'\n+\n+      // Reveal the link to trigger a runtime prefetch\n+      await act(async () => {\n+        const linkToggle = await browser.elementByCss(\n+          `input[data-prefetch=\"runtime\"][data-link-accordion=\"/errors/sync-io-after-cookies\"]`\n+        )\n+        await linkToggle.click()\n+      }, [\n+        // Should include the shell\n+        {\n+          includes: STATIC_CONTENT,\n+        },\n+        // Should abort the render when sync IO is encountered,\n+        // so this should never be included\n+        {\n+          includes: 'Timestamp',\n+          block: 'reject',\n+        },\n+      ])\n+\n+      if (!isNextDeploy) {\n+        expect(next.cliOutput).toContain(\n+          'Error: Route \"/errors/sync-io-after-cookies\" used `Date.now()` instead of using `performance` or without explicitly calling `await connection()` beforehand.'\n+        )\n+      }\n+\n+      // TODO(runtime-ppr): we should be able to display the (aborted, partial) prefetched contents before navigating,\n+      // but it seems like when we abort the render, we're also inadvertently cutting off some promises related to metadata\n+      // which end up suspending on the client and blocking react from rendering.\n+      // Ideally, we'd be able to use the partial result, but this is an error scenario and we don't crash,\n+      // so i'm just settling for that for now.\n+\n+      // Navigate to the page\n+      await act(\n+        async () => {\n+          await browser\n+            .elementByCss(`a[href=\"/errors/sync-io-after-cookies\"]`)\n+            .click()\n+        },\n+        {\n+          includes: 'Timestamp',\n+        }\n+      )\n+\n+      // After navigating, we should see the sync IO result that we omitted from the prefetch.\n+      expect(await browser.elementById('intro').text()).toInclude(\n+        STATIC_CONTENT\n+      )\n+      expect(await browser.elementById('timestamp').text()).toMatch(\n+        /Timestamp: \\d+/\n+      )\n+    })\n+\n+    it('should trigger error boundaries for errors that occurred in runtime-prefetched content', async () => {\n+      // A thrown error in the prerender should not stop us from sending a prefetch response.\n+      // This should work without any extra effort, but I'm adding a test for it as a sanity check.\n+\n+      let page: Playwright.Page\n+      const browser = await next.browser('/', {\n+        beforePageLoad(p: Playwright.Page) {\n+          page = p\n+        },\n+      })\n+      const act = createRouterAct(page)\n+\n+      const STATIC_CONTENT = 'This page errors after a cookies call'\n+\n+      // Reveal the link to trigger a runtime prefetch\n+      await act(async () => {\n+        const linkToggle = await browser.elementByCss(\n+          `input[data-prefetch=\"runtime\"][data-link-accordion=\"/errors/error-after-cookies\"]`\n+        )\n+        await linkToggle.click()\n+      }, [\n+        // Should include the shell\n+        {\n+          includes: STATIC_CONTENT,\n+        },\n+      ])\n+\n+      if (!isNextDeploy) {\n+        expect(next.cliOutput).toContain('Error: Kaboom')\n+      }\n+\n+      // Navigate to the page. We already have the paged cached.\n+      // Even though the render errored, we shouldn't fetch it again.\n+      await act(async () => {\n+        await browser\n+          .elementByCss(`a[href=\"/errors/error-after-cookies\"]`)\n+          .click()\n+      }, 'no-requests')\n+\n+      // After navigating, we should see the sync IO result that we omitted from the prefetch.\n+      expect(await browser.elementById('intro').text()).toInclude(\n+        STATIC_CONTENT\n+      )\n+      expect(await browser.elementById('error-boundary').text()).toInclude(\n+        'Error boundary: An error occurred in the Server Components render'\n+      )\n+    })\n+  })\n+})\n+\n+function defer(callback: () => Promise<void>) {\n+  return {\n+    [Symbol.asyncDispose]: callback,\n+  }\n+}"
        },
        {
            "sha": "7b6987174ee58cfc84a73dbc8616c22ad1291454",
            "filename": "test/e2e/app-dir/segment-cache/revalidation/app/refetch-on-new-base-tree/layout.tsx",
            "status": "modified",
            "additions": 16,
            "deletions": 9,
            "changes": 25,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frevalidation%2Fapp%2Frefetch-on-new-base-tree%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frevalidation%2Fapp%2Frefetch-on-new-base-tree%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frevalidation%2Fapp%2Frefetch-on-new-base-tree%2Flayout.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -10,16 +10,17 @@ export default function RefetchOnNewBaseTreeLayout({\n       <div style={{ backgroundColor: 'lightgray', padding: '1rem' }}>\n         <p>\n           This demonstrates what happens when a link is prefetched using{' '}\n-          <code>{'prefetch={true}'}</code> and the URL changes. Next.js should\n-          re-prefetch the link in case the delta between the base tree and the\n-          target tree has changed.\n+          <code>{'prefetch=\"unstable_forceStale\"'}</code> and the URL changes.\n+          Next.js should re-prefetch the link in case the delta between the base\n+          tree and the target tree has changed.\n         </p>\n         <p>\n           Everything in this gray section is part of a shared layout. The links\n-          below are prefetched using <code>{'prefetch={true}'}</code>. If the\n-          first loaded page is \"/refetch-on-new-base-tree/a\", the prefetch for\n-          this link will be empty, because there's no delta between the base\n-          tree and the target tree.\n+          below are prefetched using{' '}\n+          <code>{'prefetch=\"unstable_forceStale\"'}</code>. If the first loaded\n+          page is \"/refetch-on-new-base-tree/a\", the prefetch for this link will\n+          be empty, because there's no delta between the base tree and the\n+          target tree.\n         </p>\n         <p>\n           However, if you then navigate to page B, we should re-prefetch the\n@@ -48,10 +49,16 @@ export default function RefetchOnNewBaseTreeLayout({\n             because it was fully prefetched.\n           </li>\n         </ul>\n-        <LinkAccordion prefetch={true} href=\"/refetch-on-new-base-tree/a\">\n+        <LinkAccordion\n+          prefetch=\"unstable_forceStale\"\n+          href=\"/refetch-on-new-base-tree/a\"\n+        >\n           Page A\n         </LinkAccordion>\n-        <LinkAccordion prefetch={true} href=\"/refetch-on-new-base-tree/b\">\n+        <LinkAccordion\n+          prefetch=\"unstable_forceStale\"\n+          href=\"/refetch-on-new-base-tree/b\"\n+        >\n           Page B\n         </LinkAccordion>\n       </div>"
        },
        {
            "sha": "5206fa1aae0e5c8ae5dd6bd50bf3fd21075e4bfb",
            "filename": "test/e2e/app-dir/segment-cache/revalidation/components/link-accordion.tsx",
            "status": "modified",
            "additions": 6,
            "deletions": 3,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frevalidation%2Fcomponents%2Flink-accordion.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frevalidation%2Fcomponents%2Flink-accordion.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frevalidation%2Fcomponents%2Flink-accordion.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -1,6 +1,6 @@\n 'use client'\n \n-import Link from 'next/link'\n+import Link, { type LinkProps } from 'next/link'\n import Form from 'next/form'\n import { useEffect, useState } from 'react'\n import { useRouter } from 'next/navigation'\n@@ -12,7 +12,7 @@ export function LinkAccordion({\n }: {\n   href: string\n   children: React.ReactNode\n-  prefetch?: boolean\n+  prefetch?: LinkProps['prefetch']\n }) {\n   const [isVisible, setIsVisible] = useState(false)\n   return (\n@@ -92,6 +92,9 @@ export function ManualPrefetchLinkAccordion({\n   )\n }\n \n+type Router = ReturnType<typeof useRouter>\n+type PrefetchOptions = Parameters<Router['prefetch']>[1]\n+\n function ManualPrefetchLink({\n   href,\n   children,\n@@ -109,8 +112,8 @@ function ManualPrefetchLink({\n       let didUnmount = false\n       const pollPrefetch = () => {\n         if (!didUnmount) {\n-          // @ts-expect-error: onInvalidate is not yet part of public types\n           router.prefetch(href, {\n+            kind: 'auto' as PrefetchOptions['kind'],\n             onInvalidate: pollPrefetch,\n           })\n         }"
        },
        {
            "sha": "0ba07df51c9ac5f99666ddfdeb90b46ce14fa1c1",
            "filename": "test/e2e/app-dir/segment-cache/revalidation/segment-cache-revalidation.test.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frevalidation%2Fsegment-cache-revalidation.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frevalidation%2Fsegment-cache-revalidation.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frevalidation%2Fsegment-cache-revalidation.test.ts?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -272,7 +272,7 @@ describe('segment cache (revalidation)', () => {\n         includes: 'Page B content',\n       },\n       // Page A's content should not be prefetched because we're already on that\n-      // page. When prefetching with `prefetch={true}`, we only prefetch the\n+      // page. When prefetching with `prefetch='unstable_forceStale'`, we only prefetch the\n       // delta between the current route and the target route.\n       {\n         includes: 'Page A content',"
        },
        {
            "sha": "d73e4cfdb8277c817a3d631df087c6688d0d13c0",
            "filename": "test/e2e/app-dir/segment-cache/router-act.ts",
            "status": "modified",
            "additions": 10,
            "deletions": 1,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frouter-act.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frouter-act.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frouter-act.ts?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -163,10 +163,19 @@ export function createRouterAct(\n               const originalResponse = await page.request.fetch(request, {\n                 maxRedirects: 0,\n               })\n+\n+              // WORKAROUND:\n+              // intercepting responses with 'Transfer-Encoding: chunked' (used for streaming)\n+              // seems to be problematic sometimes, making the browser error with `net::ERR_INCOMPLETE_CHUNKED_ENCODING`.\n+              // In particular, this seems to happen when blocking a streaming navigation response. (but not always)\n+              // Playwright buffers the whole body anyway, so we can remove the header to sidestep this.\n+              const headers = originalResponse.headers()\n+              delete headers['transfer-encoding']\n+\n               resolve({\n                 text: await originalResponse.text(),\n                 body: await originalResponse.body(),\n-                headers: originalResponse.headers(),\n+                headers,\n                 status: originalResponse.status(),\n               })\n             }),"
        },
        {
            "sha": "0dc847801e63c026efd0959e40f11a5c95008166",
            "filename": "test/e2e/app-dir/segment-cache/search-params/app/search-params/page.tsx",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fapp%2Fsearch-params%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fapp%2Fsearch-params%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fapp%2Fsearch-params%2Fpage.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -19,10 +19,10 @@ export default function SearchParamsPage({\n         </li>\n         <li>\n           <LinkAccordion\n-            prefetch={true}\n+            prefetch=\"unstable_forceStale\"\n             href=\"/search-params/target-page?searchParam=b_full\"\n           >\n-            searchParam=b_full, prefetch=true\n+            searchParam=b_full, prefetch=\"unstable_forceStale\"\n           </LinkAccordion>\n         </li>\n         <li>\n@@ -32,10 +32,10 @@ export default function SearchParamsPage({\n         </li>\n         <li>\n           <LinkAccordion\n-            prefetch={true}\n+            prefetch=\"unstable_forceStale\"\n             href=\"/search-params/target-page?searchParam=d_full\"\n           >\n-            searchParam=d_full, prefetch=true\n+            searchParam=d_full, prefetch=\"unstable_forceStale\"\n           </LinkAccordion>\n         </li>\n       </ul>"
        },
        {
            "sha": "72dafb3b9d970cedb56ec2b4908c7e9bddd46880",
            "filename": "test/e2e/app-dir/segment-cache/search-params/components/link-accordion.tsx",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fcomponents%2Flink-accordion.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fcomponents%2Flink-accordion.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fcomponents%2Flink-accordion.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -1,6 +1,6 @@\n 'use client'\n \n-import Link from 'next/link'\n+import Link, { type LinkProps } from 'next/link'\n import { useState } from 'react'\n \n export function LinkAccordion({\n@@ -10,7 +10,7 @@ export function LinkAccordion({\n }: {\n   href: string\n   children: React.ReactNode\n-  prefetch?: boolean\n+  prefetch?: LinkProps['prefetch']\n }) {\n   const [isVisible, setIsVisible] = useState(false)\n   return ("
        },
        {
            "sha": "a86678fce7e72e259a3a38e3bf979ab831f64f68",
            "filename": "test/e2e/app-dir/segment-cache/search-params/segment-cache-search-params.test.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fsegment-cache-search-params.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fsegment-cache-search-params.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fsegment-cache-search-params.test.ts?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -67,15 +67,15 @@ describe('segment cache (search params)', () => {\n     expect(await result.innerText()).toBe('Search param: c_PPR')\n   })\n \n-  it('when fetching without PPR (e.g. prefetch={true}), includes the search params in the cache key', async () => {\n+  it('when fetching without PPR (e.g. prefetch=\"unstable_forceStale\"), includes the search params in the cache key', async () => {\n     let act: ReturnType<typeof createRouterAct>\n     const browser = await next.browser('/search-params', {\n       beforePageLoad(page) {\n         act = createRouterAct(page)\n       },\n     })\n \n-    // Prefetch a page with search param `b_full`. This link has prefetch={true}\n+    // Prefetch a page with search param `b_full`. This link has prefetch='unstable_forceStale'\n     // so it will fetch the entire page, including the search param.\n     const revealB = await browser.elementByCss(\n       'input[data-link-accordion=\"/search-params/target-page?searchParam=b_full\"]'\n@@ -91,7 +91,7 @@ describe('segment cache (search params)', () => {\n     )\n \n     // Prefetch a link with a different search param, and without\n-    // prefetch={true}. This must fetch a new shell, because it can't use the\n+    // prefetch='unstable_forceStale'. This must fetch a new shell, because it can't use the\n     // entry we fetched for `searchParam=b_full` (because that one wasn't a\n     // shell — it included the search param).\n     const revealA = await browser.elementByCss(\n@@ -106,7 +106,7 @@ describe('segment cache (search params)', () => {\n       { includes: 'target-page-with-search-param' }\n     )\n \n-    // Prefetch a different link using prefetch={true}. Again, this must issue\n+    // Prefetch a different link using prefetch='unstable_forceStale'. Again, this must issue\n     // a new request, because it's a full page prefetch and we haven't fetched\n     // this particular search param before.\n     // TODO: As an future optimization, if a navigation to this link occurs"
        },
        {
            "sha": "aa6e9e530813d825d8bc5e0d6e2b8d0b3e3939ab",
            "filename": "test/e2e/app-dir/segment-cache/staleness/app/page.tsx",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fstaleness%2Fapp%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fstaleness%2Fapp%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fstaleness%2Fapp%2Fpage.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -20,6 +20,16 @@ export default function Page() {\n             Page with stale time of 10 minutes\n           </LinkAccordion>\n         </li>\n+        <li>\n+          <LinkAccordion href=\"/runtime-stale-5-minutes\" prefetch={true}>\n+            Page whose runtime prefetch has a stale time of 5 minutes\n+          </LinkAccordion>\n+        </li>\n+        <li>\n+          <LinkAccordion href=\"/runtime-stale-10-minutes\" prefetch={true}>\n+            Page whose runtime prefetch has a stale time of 10 minutes\n+          </LinkAccordion>\n+        </li>\n         <li>\n           <LinkAccordion href=\"/dynamic\">Page with dynamic data</LinkAccordion>\n         </li>"
        },
        {
            "sha": "010962995bbd40451e1db4928ca1d8147f6ed50a",
            "filename": "test/e2e/app-dir/segment-cache/staleness/app/runtime-stale-10-minutes/page.tsx",
            "status": "added",
            "additions": 30,
            "deletions": 0,
            "changes": 30,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fstaleness%2Fapp%2Fruntime-stale-10-minutes%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fstaleness%2Fapp%2Fruntime-stale-10-minutes%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fstaleness%2Fapp%2Fruntime-stale-10-minutes%2Fpage.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -0,0 +1,30 @@\n+import { Suspense } from 'react'\n+import { unstable_cacheLife as cacheLife } from 'next/cache'\n+import { cookies } from 'next/headers'\n+\n+export default function Page() {\n+  return (\n+    <Suspense fallback=\"Loading...\">\n+      <RuntimePrefetchable />\n+    </Suspense>\n+  )\n+}\n+\n+async function RuntimePrefetchable() {\n+  // Prevent this content from appearing in a regular prerender,\n+  // But allow it to be included in a runtime prefetch.\n+  await cookies()\n+\n+  return (\n+    <Suspense fallback=\"Loading...\">\n+      <Content />\n+    </Suspense>\n+  )\n+}\n+\n+async function Content() {\n+  'use cache'\n+  await new Promise((resolve) => setTimeout(resolve, 0))\n+  cacheLife({ stale: 10 * 60 })\n+  return 'Content with stale time of 10 minutes'\n+}"
        },
        {
            "sha": "214b50c911dc92b4fece15f65cab0e4b2d67b20e",
            "filename": "test/e2e/app-dir/segment-cache/staleness/app/runtime-stale-5-minutes/page.tsx",
            "status": "added",
            "additions": 30,
            "deletions": 0,
            "changes": 30,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fstaleness%2Fapp%2Fruntime-stale-5-minutes%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fstaleness%2Fapp%2Fruntime-stale-5-minutes%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fstaleness%2Fapp%2Fruntime-stale-5-minutes%2Fpage.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -0,0 +1,30 @@\n+import { Suspense } from 'react'\n+import { unstable_cacheLife as cacheLife } from 'next/cache'\n+import { cookies } from 'next/headers'\n+\n+export default function Page() {\n+  return (\n+    <Suspense fallback=\"Loading...\">\n+      <RuntimePrefetchable />\n+    </Suspense>\n+  )\n+}\n+\n+async function RuntimePrefetchable() {\n+  // Prevent this content from appearing in a regular prerender,\n+  // But allow it to be included in a runtime prefetch.\n+  await cookies()\n+\n+  return (\n+    <Suspense fallback=\"Loading...\">\n+      <Content />\n+    </Suspense>\n+  )\n+}\n+\n+async function Content() {\n+  'use cache'\n+  await new Promise((resolve) => setTimeout(resolve, 0))\n+  cacheLife({ stale: 5 * 60 })\n+  return 'Content with stale time of 5 minutes'\n+}"
        },
        {
            "sha": "fd8f6781732ead4eef634fefb87de57526acd1fd",
            "filename": "test/e2e/app-dir/segment-cache/staleness/components/link-accordion.tsx",
            "status": "modified",
            "additions": 13,
            "deletions": 3,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fstaleness%2Fcomponents%2Flink-accordion.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fstaleness%2Fcomponents%2Flink-accordion.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fstaleness%2Fcomponents%2Flink-accordion.tsx?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -1,9 +1,17 @@\n 'use client'\n \n-import Link from 'next/link'\n+import Link, { LinkProps } from 'next/link'\n import { useState } from 'react'\n \n-export function LinkAccordion({ href, children }) {\n+export function LinkAccordion({\n+  href,\n+  children,\n+  prefetch,\n+}: {\n+  href: string\n+  children: React.ReactNode\n+  prefetch?: LinkProps['prefetch']\n+}) {\n   const [isVisible, setIsVisible] = useState(false)\n   return (\n     <>\n@@ -14,7 +22,9 @@ export function LinkAccordion({ href, children }) {\n         data-link-accordion={href}\n       />\n       {isVisible ? (\n-        <Link href={href}>{children}</Link>\n+        <Link href={href} prefetch={prefetch}>\n+          {children}\n+        </Link>\n       ) : (\n         `${children} (link is hidden)`\n       )}"
        },
        {
            "sha": "331500951a92fd53a4c5b42fe551aa03b7689917",
            "filename": "test/e2e/app-dir/segment-cache/staleness/segment-cache-stale-time.test.ts",
            "status": "modified",
            "additions": 68,
            "deletions": 0,
            "changes": 68,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fstaleness%2Fsegment-cache-stale-time.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fstaleness%2Fsegment-cache-stale-time.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fstaleness%2Fsegment-cache-stale-time.test.ts?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -79,6 +79,74 @@ describe('segment cache (staleness)', () => {\n     )\n   })\n \n+  it('expires runtime prefetches when their stale time has elapsed', async () => {\n+    let page: Playwright.Page\n+    const browser = await next.browser('/', {\n+      beforePageLoad(p: Playwright.Page) {\n+        page = p\n+      },\n+    })\n+    const act = createRouterAct(page)\n+\n+    await page.clock.install()\n+\n+    // Reveal the links to trigger a runtime prefetch\n+    const toggle5MinutesLink = await browser.elementByCss(\n+      'input[data-link-accordion=\"/runtime-stale-5-minutes\"]'\n+    )\n+    const toggle10MinutesLink = await browser.elementByCss(\n+      'input[data-link-accordion=\"/runtime-stale-10-minutes\"]'\n+    )\n+    await act(\n+      async () => {\n+        await toggle5MinutesLink.click()\n+        await browser.elementByCss('a[href=\"/runtime-stale-5-minutes\"]')\n+      },\n+      {\n+        includes: 'Content with stale time of 5 minutes',\n+      }\n+    )\n+    await act(\n+      async () => {\n+        await toggle10MinutesLink.click()\n+        await browser.elementByCss('a[href=\"/runtime-stale-10-minutes\"]')\n+      },\n+      {\n+        includes: 'Content with stale time of 10 minutes',\n+      }\n+    )\n+\n+    // Hide the links\n+    await toggle5MinutesLink.click()\n+    await toggle10MinutesLink.click()\n+\n+    // Fast forward 5 minutes and 1 millisecond\n+    await page.clock.fastForward(5 * 60 * 1000 + 1)\n+\n+    // Reveal the links again to trigger new prefetch tasks\n+    await act(\n+      async () => {\n+        await toggle5MinutesLink.click()\n+        await browser.elementByCss('a[href=\"/runtime-stale-5-minutes\"]')\n+      },\n+      // The page with a stale time of 5 minutes is requested again\n+      // because its stale time elapsed.\n+      {\n+        includes: 'Content with stale time of 5 minutes',\n+      }\n+    )\n+\n+    await act(\n+      async () => {\n+        await toggle10MinutesLink.click()\n+        await browser.elementByCss('a[href=\"/runtime-stale-10-minutes\"]')\n+      },\n+      // The page with a stale time of 10 minutes is *not* requested again\n+      // because it's still fresh.\n+      'no-requests'\n+    )\n+  })\n+\n   it('reuses dynamic data up to the staleTimes.dynamic threshold', async () => {\n     let page: Playwright.Page\n     const startDate = Date.now()"
        },
        {
            "sha": "10e41e4d5797f645f8038eb29fad5048526711e2",
            "filename": "test/e2e/next-link-errors/next-link-errors.test.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fnext-link-errors%2Fnext-link-errors.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c5f64b99329b88638b27c14b3984a74450724ea/test%2Fe2e%2Fnext-link-errors%2Fnext-link-errors.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fnext-link-errors%2Fnext-link-errors.test.ts?ref=1c5f64b99329b88638b27c14b3984a74450724ea",
            "patch": "@@ -86,7 +86,7 @@ describe('next-link', () => {\n     if (isNextDev) {\n       await expect(browser).toDisplayRedbox(`\n        {\n-         \"description\": \"Failed prop type: The prop \\`prefetch\\` expects a \\`boolean | \"auto\"\\` in \\`<Link>\\`, but got \\`string\\` instead.\n+         \"description\": \"Failed prop type: The prop \\`prefetch\\` expects a \\`boolean | \"auto\" | \"unstable_forceStale\"\\` in \\`<Link>\\`, but got \\`string\\` instead.\n        Open your browser's console to view the Component stack trace.\",\n          \"environmentLabel\": null,\n          \"label\": \"Runtime Error\","
        }
    ],
    "stats": {
        "total": 4700,
        "additions": 4466,
        "deletions": 234
    }
}