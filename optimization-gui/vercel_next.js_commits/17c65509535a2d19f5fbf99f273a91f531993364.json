{
    "author": "eps1lon",
    "message": "[test] Bail on sending requests to Next.js instance if it's no longer available (#85557)",
    "sha": "17c65509535a2d19f5fbf99f273a91f531993364",
    "files": [
        {
            "sha": "43361b8d9ad97b254929a48c9abf6ec604b2c6a3",
            "filename": "test/lib/next-modes/base.ts",
            "status": "modified",
            "additions": 60,
            "deletions": 8,
            "changes": 68,
            "blob_url": "https://github.com/vercel/next.js/blob/17c65509535a2d19f5fbf99f273a91f531993364/test%2Flib%2Fnext-modes%2Fbase.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/17c65509535a2d19f5fbf99f273a91f531993364/test%2Flib%2Fnext-modes%2Fbase.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Flib%2Fnext-modes%2Fbase.ts?ref=17c65509535a2d19f5fbf99f273a91f531993364",
            "patch": "@@ -82,8 +82,8 @@ export class NextInstance {\n   public testDir: string\n   public distDir: string\n   tmpRepoDir: string\n-  protected isStopping: boolean = false\n-  protected isDestroyed: boolean = false\n+  protected isStopping: Error | null = null\n+  protected isDestroyed: Error | null = null\n   protected childProcess?: ChildProcess\n   protected _url: string\n   protected _parsedUrl: URL\n@@ -515,14 +515,16 @@ export class NextInstance {\n     signal: 'SIGINT' | 'SIGTERM' | 'SIGKILL' = 'SIGKILL'\n   ): Promise<void> {\n     if (this.childProcess) {\n-      if (this.isStopping) {\n+      if (this.isStopping !== null) {\n         // warn for debugging, but don't prevent sending two signals in succession\n         // (e.g. SIGINT and then SIGKILL)\n         require('console').error(\n-          `Next server is already being stopped (received signal: ${signal})`\n+          `Next server is already being stopped (received signal: ${signal}): `,\n+          this.isStopping\n         )\n       }\n-      this.isStopping = true\n+      this.isStopping = Error()\n+      Error.captureStackTrace(this.isStopping, this.stop)\n       const closePromise = once(this.childProcess, 'close')\n       await new Promise<void>((resolve) => {\n         treeKill(this.childProcess!.pid!, signal, (err) => {\n@@ -535,7 +537,7 @@ export class NextInstance {\n       this.childProcess.kill(signal)\n       await closePromise\n       this.childProcess = undefined\n-      this.isStopping = false\n+      this.isStopping = null\n       require('console').log(`Stopped next server`)\n     }\n   }\n@@ -545,9 +547,13 @@ export class NextInstance {\n       require('console').time('destroyed next instance')\n \n       if (this.isDestroyed) {\n-        throw new Error(`next instance already destroyed`)\n+        throw new Error(`next instance already destroyed`, {\n+          cause: this.isDestroyed,\n+        })\n       }\n-      this.isDestroyed = true\n+      this.isDestroyed = Error()\n+      Error.captureStackTrace(this.isDestroyed, this.destroy)\n+\n       this.emit('destroy', [])\n       await this.stop().catch(console.error)\n \n@@ -602,6 +608,22 @@ export class NextInstance {\n     return ''\n   }\n \n+  protected throwIfUnavailable(): void | never {\n+    if (this.isStopping !== null) {\n+      throw new Error('Next.js is no longer available.', {\n+        cause: this.isStopping,\n+      })\n+    }\n+    if (this.isDestroyed !== null) {\n+      throw new Error('Next.js is no longer available.', {\n+        cause: this.isDestroyed,\n+      })\n+    }\n+    if (this.childProcess === undefined) {\n+      throw new Error('No child process available')\n+    }\n+  }\n+\n   // TODO: block these in deploy mode\n   public async hasFile(filename: string) {\n     return existsSync(path.join(this.testDir, filename))\n@@ -733,6 +755,12 @@ export class NextInstance {\n   public async browser(\n     ...args: Parameters<OmitFirstArgument<typeof webdriver>>\n   ): Promise<Playwright> {\n+    try {\n+      this.throwIfUnavailable()\n+    } catch (error) {\n+      Error.captureStackTrace(error, this.browser)\n+      throw error\n+    }\n     return webdriver(this.url, ...args)\n   }\n \n@@ -743,6 +771,12 @@ export class NextInstance {\n   public async browserWithResponse(\n     ...args: Parameters<OmitFirstArgument<typeof webdriver>>\n   ): Promise<{ browser: Playwright; response: Response }> {\n+    try {\n+      this.throwIfUnavailable()\n+    } catch (error) {\n+      Error.captureStackTrace(error, this.browserWithResponse)\n+      throw error\n+    }\n     const [url, options = {}] = args\n \n     let resolveResponse: (response: Response) => void\n@@ -785,6 +819,12 @@ export class NextInstance {\n   public async render$(\n     ...args: Parameters<OmitFirstArgument<typeof renderViaHTTP>>\n   ): Promise<ReturnType<typeof cheerio.load>> {\n+    try {\n+      this.throwIfUnavailable()\n+    } catch (error) {\n+      Error.captureStackTrace(error, this.render$)\n+      throw error\n+    }\n     const html = await renderViaHTTP(this.url, ...args)\n     return cheerio.load(html)\n   }\n@@ -795,6 +835,12 @@ export class NextInstance {\n   public async render(\n     ...args: Parameters<OmitFirstArgument<typeof renderViaHTTP>>\n   ) {\n+    try {\n+      this.throwIfUnavailable()\n+    } catch (error) {\n+      Error.captureStackTrace(error, this.render)\n+      throw error\n+    }\n     return renderViaHTTP(this.url, ...args)\n   }\n \n@@ -809,6 +855,12 @@ export class NextInstance {\n     pathname: string,\n     opts?: import('node-fetch').RequestInit\n   ) {\n+    try {\n+      this.throwIfUnavailable()\n+    } catch (error) {\n+      Error.captureStackTrace(error, this.fetch)\n+      throw error\n+    }\n     return fetchViaHTTP(this.url, pathname, null, opts)\n   }\n "
        }
    ],
    "stats": {
        "total": 68,
        "additions": 60,
        "deletions": 8
    }
}