{
    "author": "bgw",
    "message": "Turbopack: Add new webpack loader rule/condition syntax in config (#82857)\n\n# This PR:\n\n- [x] Allow a condition to be specified inline within a `rule`\n- [x] Support `all`/`any`/`not` for conditions\n- [x] Simple flattening/optimization logic for the generated `RuleCondition` objects\n  - [x] Unit test coverage of flattening logic\n- [x] Allow builtin conditions (see https://github.com/vercel/next.js/pull/82765) to be specified in condition objects, instead of requiring a separate syntax for them\n- [x] Update regex serialization logic in `packages/next/src/build/swc/index.ts`\n- [x] Make sure the updated syntax is fully reflected in the config schema and typedefs\n- [x] Emit collectibles for configuration issues instead of hard-failing with anyhow\n- [x] e2e test coverage\n\n# Remaining Work for Subsequent PRs\n\n- [ ] Remove the legacy `conditions` field from the `turbopack` config object\n- [ ] Remove the legacy built-in condition object syntax from rules: https://github.com/vercel/next.js/pull/83068\n- [ ] Allow array values in the `turbopack.rules` object: https://github.com/vercel/next.js/pull/83138\n- [ ] Update user-facing documentation\n\nThis PR is the bulk of the work towards implementing the proposed new loader rule syntax:\nhttps://www.notion.so/vercel/Turbopack-loader-rule-syntax-254e06b059c4809096d1e7c9afad278c\n*(copied below)*\n\n# Loader Syntax Proposal\n\n## Today (documented)\n\n[https://nextjs.org/docs/app/api-reference/config/next-config-js/turbopack#configuring-webpack-loaders](https://nextjs.org/docs/app/api-reference/config/next-config-js/turbopack#configuring-webpack-loaders)\n\n```javascript\nmodule.exports = {\n  turbopack: {\n    rules: {\n      // all matched rules apply, adding their loaders in order\n      '*.svg': {\n        loaders: ['@svgr/webpack'],\n        as: '*.js',\n      },\n    },\n  },\n}\n```\n\n## Today (undocumented) - User-defined conditions\n\nYou can define custom `#`-prefixed “conditions” that can act as filters for rules.\n\n```javascript\nmodule.exports = {\n  turbopack: {\n    rules: {\n      '#svg-file': {\n        loaders: ['@svgr/webpack'],\n        // `as` is incompatible! There's no obvious glob to match against!\n      },\n    },\n    conditions: {\n      \"#svg-file\": {\n        // this is an implicit \"and\"/\"all\": both path and content must match\n        path: '*.svg', // can also be a RegExp\n        content: /\\<svg[^\\>]*\\>/, // can match the contents of the file!\n      },\n    },\n  },\n}\n```\n\n## Today (undocumented) - Built-in Conditions\n\nThese use a different syntax, and are provided by Next.js / Turbopack (are not user-defined).\n\n```javascript\nmodule.exports = {\n  turbopack: {\n    rules: {\n      // This will match svg files in the project that aren't from `node_modules`\n      '*.svg': {\n        // These object properties are evaluated in order, and the first match\n        // used. The supported keys can be found here:\n        // https://github.com/vercel/next.js/pull/82765\n        foreign: false, // causes us to bail out if node_modules are matched\n        default: {\n          loaders: ['@svgr/webpack'],\n          as: '*.js',\n        }\n      },\n    },\n  },\n}\n```\n\n## Proposed\n\n- Remove (minor breaking change in Next 16, was undocumented) the `conditions` field from the `turbopack` config object. The benefit of a separate `conditions` field was that named conditions could be re-used across rules. But, there’s not much value in allowing condition re-use as the configuration file is JS and could implement re-use with local variables or functions.\n    - The separate `conditions` field was also incompatible with the `as` field.\n- Add an optional `condition` field to each rule object.\n    - Rules must be matched by a glob first (can be `*`) before the condition is checked.\n    - This allows compatibility with `as`, since there’s always an obvious glob for that to match against.\n- Maintain support for `path` and `content` properties in `condition` objects.\n    - These can be used with each other (as an implicit `all`)\n- Extend `condition` object with `{all: [...]}`, `{any: [...]}` , and `{not: ...}`.\n    - Similar to webpack’s `{and: [...]}`, `{or: [...]}` and `{not: ...}` syntax: https://webpack.js.org/configuration/module/#condition\n    - Our underlying `RuleCondition` enum already supports this, it’s just a matter of translating it from the JS object.\n- Allow conditions to be an object or a string. If it’s a string, require it to be a built-in condition (like `'foreign'` or `'browser'`).\n- Allow values in the rules object to either be objects (what we support today) or an array of objects.\n\n```javascript\nmodule.exports = {\n  turbopack: {\n    rules: {\n      // all matched rules apply, adding their loaders in order\n      '*.svg': [\n        // this optionally can be an array of objects (shown here), or just an object\n        {\n          // this condition is matched after the glob\n          condition: {\n            all: [\n              { not: 'foreign' }, // excludes `node_modules`\n              { path: /app\\/.*\\.svg/, content: /\\<svg[^\\>]*\\>/ },\n            ],\n          },\n          loaders: ['@svgr/webpack'],\n          as: '*.js',\n        },\n      ],\n    },\n  },\n}\n```",
    "sha": "628540fbbc9cb2cce858cba63d56e973744f2f83",
    "files": [
        {
            "sha": "31a0080d913805cb1b3d664e4ce75557e75b4ef4",
            "filename": "Cargo.lock",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/628540fbbc9cb2cce858cba63d56e973744f2f83/Cargo.lock",
            "raw_url": "https://github.com/vercel/next.js/raw/628540fbbc9cb2cce858cba63d56e973744f2f83/Cargo.lock",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/Cargo.lock?ref=628540fbbc9cb2cce858cba63d56e973744f2f83",
            "patch": "@@ -9482,6 +9482,7 @@ dependencies = [\n  \"anyhow\",\n  \"codspeed-criterion-compat\",\n  \"difference\",\n+ \"either\",\n  \"regex\",\n  \"rstest\",\n  \"rstest_reuse\","
        },
        {
            "sha": "30868892dd992b3241c2c7b940795c9664289164",
            "filename": "crates/next-core/src/next_client/context.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/628540fbbc9cb2cce858cba63d56e973744f2f83/crates%2Fnext-core%2Fsrc%2Fnext_client%2Fcontext.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/628540fbbc9cb2cce858cba63d56e973744f2f83/crates%2Fnext-core%2Fsrc%2Fnext_client%2Fcontext.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_client%2Fcontext.rs?ref=628540fbbc9cb2cce858cba63d56e973744f2f83",
            "patch": "@@ -248,11 +248,11 @@ pub async fn get_client_module_options_context(\n     let mut foreign_conditions = loader_conditions.clone();\n     foreign_conditions.insert(WebpackLoaderBuiltinCondition::Foreign);\n     let foreign_enable_webpack_loaders =\n-        webpack_loader_options(project_path.clone(), next_config, true, foreign_conditions).await?;\n+        webpack_loader_options(project_path.clone(), next_config, foreign_conditions).await?;\n \n     // Now creates a webpack rules that applies to all code.\n     let enable_webpack_loaders =\n-        webpack_loader_options(project_path.clone(), next_config, false, loader_conditions).await?;\n+        webpack_loader_options(project_path.clone(), next_config, loader_conditions).await?;\n \n     let tree_shaking_mode_for_user_code = *next_config\n         .tree_shaking_mode_for_user_code(next_mode.is_development())"
        },
        {
            "sha": "4c5f63c158299ded300240aaf658dce5812c8b5d",
            "filename": "crates/next-core/src/next_config.rs",
            "status": "modified",
            "additions": 250,
            "deletions": 75,
            "changes": 325,
            "blob_url": "https://github.com/vercel/next.js/blob/628540fbbc9cb2cce858cba63d56e973744f2f83/crates%2Fnext-core%2Fsrc%2Fnext_config.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/628540fbbc9cb2cce858cba63d56e973744f2f83/crates%2Fnext-core%2Fsrc%2Fnext_config.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_config.rs?ref=628540fbbc9cb2cce858cba63d56e973744f2f83",
            "patch": "@@ -566,53 +566,104 @@ pub struct TurbopackConfig {\n     pub module_ids: Option<ModuleIds>,\n }\n \n-#[derive(Serialize, Deserialize, Clone, PartialEq, Eq, Debug)]\n+#[derive(\n+    Serialize, Deserialize, Clone, PartialEq, Eq, Debug, TraceRawVcs, NonLocalValue, OperationValue,\n+)]\n+#[serde(deny_unknown_fields)]\n pub struct RegexComponents {\n     source: RcStr,\n     flags: RcStr,\n }\n \n-#[derive(Clone, PartialEq, Eq, Debug, Serialize, Deserialize)]\n-#[serde(tag = \"type\", content = \"value\", rename_all = \"camelCase\")]\n+/// This type should not be hand-written, but instead `packages/next/src/build/swc/index.ts` will\n+/// transform a JS `RegExp` to a `RegexComponents` or a string to a `Glob` before passing it to us.\n+///\n+/// This is needed because `RegExp` objects are not otherwise serializable.\n+#[derive(\n+    Clone, PartialEq, Eq, Debug, Serialize, Deserialize, TraceRawVcs, NonLocalValue, OperationValue,\n+)]\n+#[serde(\n+    tag = \"type\",\n+    content = \"value\",\n+    rename_all = \"camelCase\",\n+    deny_unknown_fields\n+)]\n pub enum ConfigConditionPath {\n     Glob(RcStr),\n     Regex(RegexComponents),\n }\n \n-impl TryInto<ConditionPath> for ConfigConditionPath {\n-    fn try_into(self) -> Result<ConditionPath> {\n-        Ok(match self {\n+impl TryFrom<ConfigConditionPath> for ConditionPath {\n+    type Error = anyhow::Error;\n+\n+    fn try_from(config: ConfigConditionPath) -> Result<ConditionPath> {\n+        Ok(match config {\n             ConfigConditionPath::Glob(path) => ConditionPath::Glob(path),\n-            ConfigConditionPath::Regex(path) => ConditionPath::Regex(path.try_into()?),\n+            ConfigConditionPath::Regex(path) => {\n+                ConditionPath::Regex(EsRegex::try_from(path)?.resolved_cell())\n+            }\n         })\n     }\n+}\n \n+impl TryFrom<RegexComponents> for EsRegex {\n     type Error = anyhow::Error;\n-}\n \n-impl TryInto<ResolvedVc<EsRegex>> for RegexComponents {\n-    fn try_into(self) -> Result<ResolvedVc<EsRegex>> {\n-        Ok(EsRegex::new(&self.source, &self.flags)?.resolved_cell())\n+    fn try_from(components: RegexComponents) -> Result<EsRegex> {\n+        EsRegex::new(&components.source, &components.flags)\n     }\n-\n-    type Error = anyhow::Error;\n }\n \n-#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n-pub struct ConfigConditionItem {\n-    pub path: Option<ConfigConditionPath>,\n-    pub content: Option<RegexComponents>,\n+#[derive(\n+    Serialize, Deserialize, Clone, PartialEq, Eq, Debug, TraceRawVcs, NonLocalValue, OperationValue,\n+)]\n+// We can end up with confusing behaviors if we silently ignore extra properties, since `Base` will\n+// match nearly every object, since it has no required field.\n+#[serde(deny_unknown_fields)]\n+pub enum ConfigConditionItem {\n+    #[serde(rename = \"all\")]\n+    All(Box<[ConfigConditionItem]>),\n+    #[serde(rename = \"any\")]\n+    Any(Box<[ConfigConditionItem]>),\n+    #[serde(rename = \"not\")]\n+    Not(Box<ConfigConditionItem>),\n+    #[serde(untagged)]\n+    Builtin(WebpackLoaderBuiltinCondition),\n+    #[serde(untagged)]\n+    Base {\n+        #[serde(default)]\n+        path: Option<ConfigConditionPath>,\n+        #[serde(default)]\n+        content: Option<RegexComponents>,\n+    },\n }\n \n-impl TryInto<ConditionItem> for ConfigConditionItem {\n-    fn try_into(self) -> Result<ConditionItem> {\n-        Ok(ConditionItem {\n-            path: self.path.map(|p| p.try_into()).transpose()?,\n-            content: self.content.map(|r| r.try_into()).transpose()?,\n+impl TryFrom<ConfigConditionItem> for ConditionItem {\n+    type Error = anyhow::Error;\n+\n+    fn try_from(config: ConfigConditionItem) -> Result<Self> {\n+        let try_from_vec = |conds: Box<[_]>| {\n+            conds\n+                .into_iter()\n+                .map(ConditionItem::try_from)\n+                .collect::<Result<_>>()\n+        };\n+        Ok(match config {\n+            ConfigConditionItem::All(conds) => ConditionItem::All(try_from_vec(conds)?),\n+            ConfigConditionItem::Any(conds) => ConditionItem::Any(try_from_vec(conds)?),\n+            ConfigConditionItem::Not(cond) => ConditionItem::Not(Box::new((*cond).try_into()?)),\n+            ConfigConditionItem::Builtin(cond) => {\n+                ConditionItem::Builtin(RcStr::from(cond.as_str()))\n+            }\n+            ConfigConditionItem::Base { path, content } => ConditionItem::Base {\n+                path: path.map(ConditionPath::try_from).transpose()?,\n+                content: content\n+                    .map(EsRegex::try_from)\n+                    .transpose()?\n+                    .map(EsRegex::resolved_cell),\n+            },\n         })\n     }\n-\n-    type Error = anyhow::Error;\n }\n \n #[derive(\n@@ -623,6 +674,8 @@ pub struct RuleConfigItemOptions {\n     pub loaders: Vec<LoaderItem>,\n     #[serde(default, alias = \"as\")]\n     pub rename_as: Option<RcStr>,\n+    #[serde(default)]\n+    pub condition: Option<ConfigConditionItem>,\n }\n \n #[derive(\n@@ -640,8 +693,8 @@ pub enum RuleConfigItemOrShortcut {\n #[serde(rename_all = \"camelCase\", untagged)]\n pub enum RuleConfigItem {\n     Options(RuleConfigItemOptions),\n-    Conditional(FxIndexMap<RcStr, RuleConfigItem>),\n-    Boolean(bool),\n+    LegacyConditional(FxIndexMap<RcStr, RuleConfigItem>),\n+    LegacyBoolean(bool),\n }\n \n #[derive(\n@@ -1137,59 +1190,91 @@ pub struct OptionServerActions(Option<ServerActions>);\n #[turbo_tasks::value(transparent)]\n pub struct OptionJsonValue(pub Option<serde_json::Value>);\n \n+fn turbopack_config_documentation_link() -> RcStr {\n+    rcstr!(\"https://nextjs.org/docs/app/api-reference/config/next-config-js/turbopack#configuring-webpack-loaders\")\n+}\n+\n #[turbo_tasks::value(shared)]\n-struct InvalidLoaderRuleError {\n-    ext: RcStr,\n-    rename_as: Option<RcStr>,\n+struct InvalidLoaderRuleRenameAsIssue {\n+    glob: RcStr,\n+    rename_as: RcStr,\n     config_file_path: FileSystemPath,\n }\n \n #[turbo_tasks::value_impl]\n-impl Issue for InvalidLoaderRuleError {\n+impl Issue for InvalidLoaderRuleRenameAsIssue {\n     #[turbo_tasks::function]\n-    async fn file_path(self: turbo_tasks::Vc<Self>) -> Result<Vc<FileSystemPath>> {\n-        Ok(self.await?.config_file_path.clone().cell())\n+    async fn file_path(&self) -> Result<Vc<FileSystemPath>> {\n+        Ok(self.config_file_path.clone().cell())\n     }\n \n     #[turbo_tasks::function]\n-    fn stage(self: turbo_tasks::Vc<Self>) -> Vc<IssueStage> {\n+    fn stage(&self) -> Vc<IssueStage> {\n         IssueStage::Config.cell()\n     }\n \n     #[turbo_tasks::function]\n-    async fn title(self: turbo_tasks::Vc<Self>) -> Result<Vc<StyledString>> {\n-        Ok(StyledString::Text(\n-            format!(\n-                \"Invalid loader rule for extension: {}\",\n-                self.await?.ext.as_str()\n-            )\n-            .into(),\n+    async fn title(&self) -> Result<Vc<StyledString>> {\n+        Ok(\n+            StyledString::Text(format!(\"Invalid loader rule for extension: {}\", self.glob).into())\n+                .cell(),\n         )\n-        .cell())\n     }\n \n     #[turbo_tasks::function]\n-    async fn description(self: turbo_tasks::Vc<Self>) -> Result<Vc<OptionStyledString>> {\n-        Ok(Vc::cell(Some(StyledString::Stack(vec![\n-            StyledString::Text(\n-                format!(\n-                    \"The extension {} contains a wildcard, but the `as` option does not: {}\",\n-                    self.await?.ext.as_str(),\n-                    self.await?\n-                        .rename_as\n-                        .as_ref()\n-                        .map(|r| r.as_str())\n-                        .unwrap_or(\"\")\n-                )\n-                .into(),\n-            ),\n-            StyledString::Text(\n-                rcstr!(\"Check out the documentation here for more information:\"),\n-            ),\n-            StyledString::Text(\n-                rcstr!(\"https://nextjs.org/docs/app/api-reference/config/next-config-js/turbopack#configuring-webpack-loaders\"),\n-            ),\n-        ]).resolved_cell())))\n+    async fn description(&self) -> Result<Vc<OptionStyledString>> {\n+        Ok(Vc::cell(Some(\n+            StyledString::Text(RcStr::from(format!(\n+                \"The extension {} contains a wildcard, but the `as` option does not: {}\",\n+                self.glob, self.rename_as,\n+            )))\n+            .resolved_cell(),\n+        )))\n+    }\n+\n+    #[turbo_tasks::function]\n+    fn documentation_link(&self) -> Vc<RcStr> {\n+        Vc::cell(turbopack_config_documentation_link())\n+    }\n+}\n+\n+#[turbo_tasks::value(shared)]\n+struct InvalidLoaderRuleConditionIssue {\n+    condition: ConfigConditionItem,\n+    config_file_path: FileSystemPath,\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl Issue for InvalidLoaderRuleConditionIssue {\n+    #[turbo_tasks::function]\n+    async fn file_path(self: Vc<Self>) -> Result<Vc<FileSystemPath>> {\n+        Ok(self.await?.config_file_path.clone().cell())\n+    }\n+\n+    #[turbo_tasks::function]\n+    fn stage(self: Vc<Self>) -> Vc<IssueStage> {\n+        IssueStage::Config.cell()\n+    }\n+\n+    #[turbo_tasks::function]\n+    async fn title(&self) -> Result<Vc<StyledString>> {\n+        Ok(StyledString::Text(rcstr!(\"Invalid condition for Turbopack loader rule\")).cell())\n+    }\n+\n+    #[turbo_tasks::function]\n+    async fn description(&self) -> Result<Vc<OptionStyledString>> {\n+        Ok(Vc::cell(Some(\n+            StyledString::Text(RcStr::from(\n+                serde_json::to_string_pretty(&self.condition)\n+                    .expect(\"condition must be serializable\"),\n+            ))\n+            .resolved_cell(),\n+        )))\n+    }\n+\n+    #[turbo_tasks::function]\n+    fn documentation_link(&self) -> Vc<RcStr> {\n+        Vc::cell(turbopack_config_documentation_link())\n     }\n }\n \n@@ -1300,7 +1385,7 @@ impl NextConfig {\n             return Ok(Vc::cell(None));\n         }\n         let mut rules = FxIndexMap::default();\n-        for (ext, rule) in turbo_rules.iter() {\n+        for (glob, rule) in turbo_rules.iter() {\n             fn transform_loaders(loaders: &[LoaderItem]) -> ResolvedVc<WebpackLoaderItems> {\n                 ResolvedVc::cell(\n                     loaders\n@@ -1320,13 +1405,16 @@ impl NextConfig {\n                 NotFound,\n                 Break,\n             }\n+            // This logic is needed for the `LegacyConditional`/`LegacyBoolean` configuration\n+            // syntax. This is technically public syntax, but was never documented and it is\n+            // unlikely that anyone is depending on it (outside of some Next.js internals).\n             fn find_rule<'a>(\n                 rule: &'a RuleConfigItem,\n                 active_conditions: &BTreeSet<WebpackLoaderBuiltinCondition>,\n             ) -> FindRuleResult<'a> {\n                 match rule {\n                     RuleConfigItem::Options(rule) => FindRuleResult::Found(rule),\n-                    RuleConfigItem::Conditional(map) => {\n+                    RuleConfigItem::LegacyConditional(map) => {\n                         for (condition, rule) in map.iter() {\n                             let condition = WebpackLoaderBuiltinCondition::from_str(condition);\n                             if let Ok(condition) = condition\n@@ -1346,43 +1434,67 @@ impl NextConfig {\n                         }\n                         FindRuleResult::NotFound\n                     }\n-                    RuleConfigItem::Boolean(_) => FindRuleResult::Break,\n+                    RuleConfigItem::LegacyBoolean(_) => FindRuleResult::Break,\n                 }\n             }\n+            let config_file_path = || project_path.join(&self.config_file_name);\n             match rule {\n                 RuleConfigItemOrShortcut::Loaders(loaders) => {\n                     rules.insert(\n-                        ext.clone(),\n+                        glob.clone(),\n                         LoaderRuleItem {\n                             loaders: transform_loaders(loaders),\n                             rename_as: None,\n+                            condition: None,\n                         },\n                     );\n                 }\n                 RuleConfigItemOrShortcut::Advanced(rule) => {\n-                    if let FindRuleResult::Found(RuleConfigItemOptions { loaders, rename_as }) =\n-                        find_rule(rule, &active_conditions)\n+                    if let FindRuleResult::Found(RuleConfigItemOptions {\n+                        loaders,\n+                        rename_as,\n+                        condition,\n+                    }) = find_rule(rule, &active_conditions)\n                     {\n                         // If the extension contains a wildcard, and the rename_as does not,\n                         // emit an issue to prevent users from encountering duplicate module names.\n-                        if ext.contains(\"*\") && rename_as.as_ref().is_some_and(|r| !r.contains(\"*\"))\n+                        if glob.contains(\"*\")\n+                            && let Some(rename_as) = rename_as.as_ref()\n+                            && !rename_as.contains(\"*\")\n                         {\n-                            let config_file_path = project_path.join(&self.config_file_name)?;\n-\n-                            InvalidLoaderRuleError {\n-                                ext: ext.clone(),\n-                                config_file_path,\n+                            InvalidLoaderRuleRenameAsIssue {\n+                                glob: glob.clone(),\n+                                config_file_path: config_file_path()?,\n                                 rename_as: rename_as.clone(),\n                             }\n                             .resolved_cell()\n                             .emit();\n                         }\n \n+                        // convert from Next.js-specific condition type to internal Turbopack\n+                        // condition type\n+                        let condition = if let Some(condition) = condition {\n+                            if let Ok(cond) = ConditionItem::try_from(condition.clone()) {\n+                                Some(cond)\n+                            } else {\n+                                InvalidLoaderRuleConditionIssue {\n+                                    condition: condition.clone(),\n+                                    config_file_path: config_file_path()?,\n+                                }\n+                                .resolved_cell()\n+                                .emit();\n+                                None\n+                            }\n+                        } else {\n+                            None\n+                        };\n+\n                         rules.insert(\n-                            ext.clone(),\n+                            glob.clone(),\n                             LoaderRuleItem {\n                                 loaders: transform_loaders(loaders),\n                                 rename_as: rename_as.clone(),\n+                                condition,\n                             },\n                         );\n                     }\n@@ -1820,3 +1932,66 @@ impl JsConfig {\n         Vc::cell(self.compiler_options.clone().unwrap_or_default())\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn test_serde_rule_config_item_options() {\n+        let json_value = serde_json::json!({\n+            \"loaders\": [],\n+            \"as\": \"*.js\",\n+            \"condition\": {\n+                \"all\": [\n+                    \"production\",\n+                    {\"not\": \"foreign\"},\n+                    {\"any\": [\n+                        \"browser\",\n+                        {\n+                            \"path\": { \"type\": \"glob\", \"value\": \"*.svg\"},\n+                            \"content\": {\n+                                \"source\": \"@someTag\",\n+                                \"flags\": \"\"\n+                            }\n+                        }\n+                    ]},\n+                ],\n+            }\n+        });\n+\n+        let rule_config: RuleConfigItemOptions = serde_json::from_value(json_value).unwrap();\n+\n+        assert_eq!(\n+            rule_config,\n+            RuleConfigItemOptions {\n+                loaders: vec![],\n+                rename_as: Some(rcstr!(\"*.js\")),\n+                condition: Some(ConfigConditionItem::All(\n+                    [\n+                        ConfigConditionItem::Builtin(WebpackLoaderBuiltinCondition::Production),\n+                        ConfigConditionItem::Not(Box::new(ConfigConditionItem::Builtin(\n+                            WebpackLoaderBuiltinCondition::Foreign\n+                        ))),\n+                        ConfigConditionItem::Any(\n+                            vec![\n+                                ConfigConditionItem::Builtin(\n+                                    WebpackLoaderBuiltinCondition::Browser\n+                                ),\n+                                ConfigConditionItem::Base {\n+                                    path: Some(ConfigConditionPath::Glob(rcstr!(\"*.svg\"))),\n+                                    content: Some(RegexComponents {\n+                                        source: rcstr!(\"@someTag\"),\n+                                        flags: rcstr!(\"\"),\n+                                    }),\n+                                },\n+                            ]\n+                            .into(),\n+                        ),\n+                    ]\n+                    .into(),\n+                )),\n+            }\n+        );\n+    }\n+}"
        },
        {
            "sha": "a4f950c4e0b63eb6be30cbb82fc064903f8c8ff9",
            "filename": "crates/next-core/src/next_server/context.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/628540fbbc9cb2cce858cba63d56e973744f2f83/crates%2Fnext-core%2Fsrc%2Fnext_server%2Fcontext.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/628540fbbc9cb2cce858cba63d56e973744f2f83/crates%2Fnext-core%2Fsrc%2Fnext_server%2Fcontext.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_server%2Fcontext.rs?ref=628540fbbc9cb2cce858cba63d56e973744f2f83",
            "patch": "@@ -493,11 +493,11 @@ pub async fn get_server_module_options_context(\n     let mut foreign_conditions = loader_conditions.clone();\n     foreign_conditions.insert(WebpackLoaderBuiltinCondition::Foreign);\n     let foreign_enable_webpack_loaders =\n-        webpack_loader_options(project_path.clone(), next_config, true, foreign_conditions).await?;\n+        webpack_loader_options(project_path.clone(), next_config, foreign_conditions).await?;\n \n     // Now creates a webpack rules that applies to all code.\n     let enable_webpack_loaders =\n-        webpack_loader_options(project_path.clone(), next_config, false, loader_conditions).await?;\n+        webpack_loader_options(project_path.clone(), next_config, loader_conditions).await?;\n \n     let tree_shaking_mode_for_user_code = *next_config\n         .tree_shaking_mode_for_user_code(next_mode.is_development())"
        },
        {
            "sha": "24fe3175152e319a7009b31c3104305ae250f6a1",
            "filename": "crates/next-core/src/next_shared/webpack_rules/babel.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/628540fbbc9cb2cce858cba63d56e973744f2f83/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fwebpack_rules%2Fbabel.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/628540fbbc9cb2cce858cba63d56e973744f2f83/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fwebpack_rules%2Fbabel.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fwebpack_rules%2Fbabel.rs?ref=628540fbbc9cb2cce858cba63d56e973744f2f83",
            "patch": "@@ -97,6 +97,7 @@ pub async fn maybe_add_babel_loader(\n                         LoaderRuleItem {\n                             loaders: ResolvedVc::cell(vec![loader]),\n                             rename_as: Some(rcstr!(\"*\")),\n+                            condition: None,\n                         },\n                     );\n                 }"
        },
        {
            "sha": "0802bdd89664652f82d2204a26eace7aed803f30",
            "filename": "crates/next-core/src/next_shared/webpack_rules/mod.rs",
            "status": "modified",
            "additions": 49,
            "deletions": 14,
            "changes": 63,
            "blob_url": "https://github.com/vercel/next.js/blob/628540fbbc9cb2cce858cba63d56e973744f2f83/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fwebpack_rules%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/628540fbbc9cb2cce858cba63d56e973744f2f83/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fwebpack_rules%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fwebpack_rules%2Fmod.rs?ref=628540fbbc9cb2cce858cba63d56e973744f2f83",
            "patch": "@@ -3,9 +3,11 @@ use std::{collections::BTreeSet, str::FromStr};\n use anyhow::Result;\n use serde::{Deserialize, Serialize};\n use turbo_rcstr::rcstr;\n-use turbo_tasks::{NonLocalValue, ResolvedVc, TaskInput, Vc, trace::TraceRawVcs};\n+use turbo_tasks::{NonLocalValue, OperationValue, ResolvedVc, TaskInput, Vc, trace::TraceRawVcs};\n use turbo_tasks_fs::FileSystemPath;\n-use turbopack::module_options::WebpackLoadersOptions;\n+use turbopack::module_options::{\n+    WebpackLoaderBuiltinConditionSet, WebpackLoaderBuiltinConditionSetMatch, WebpackLoadersOptions,\n+};\n use turbopack_core::resolve::{ExternalTraced, ExternalType, options::ImportMapping};\n \n use self::{babel::maybe_add_babel_loader, sass::maybe_add_sass_loader};\n@@ -34,12 +36,14 @@ pub(crate) mod sass;\n     PartialOrd,\n     Ord,\n     Hash,\n-    Serialize,\n     Deserialize,\n+    Serialize,\n     TaskInput,\n     TraceRawVcs,\n     NonLocalValue,\n+    OperationValue,\n )]\n+#[serde(rename_all = \"kebab-case\")]\n pub enum WebpackLoaderBuiltinCondition {\n     /// Treated as always-present.\n     Default,\n@@ -60,7 +64,7 @@ pub enum WebpackLoaderBuiltinCondition {\n }\n \n impl WebpackLoaderBuiltinCondition {\n-    fn as_str(self) -> &'static str {\n+    pub fn as_str(self) -> &'static str {\n         match self {\n             Self::Default => \"default\",\n             Self::Browser => \"browser\",\n@@ -96,21 +100,49 @@ impl PartialEq<WebpackLoaderBuiltinCondition> for &str {\n     }\n }\n \n+#[turbo_tasks::value]\n+struct NextWebpackLoaderBuiltinConditionSet(BTreeSet<WebpackLoaderBuiltinCondition>);\n+\n+#[turbo_tasks::value_impl]\n+impl NextWebpackLoaderBuiltinConditionSet {\n+    #[turbo_tasks::function]\n+    fn new(\n+        conditions: BTreeSet<WebpackLoaderBuiltinCondition>,\n+    ) -> Vc<Box<dyn WebpackLoaderBuiltinConditionSet>> {\n+        Vc::upcast::<Box<dyn WebpackLoaderBuiltinConditionSet>>(\n+            NextWebpackLoaderBuiltinConditionSet(conditions).cell(),\n+        )\n+    }\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl WebpackLoaderBuiltinConditionSet for NextWebpackLoaderBuiltinConditionSet {\n+    fn match_condition(&self, condition: &str) -> WebpackLoaderBuiltinConditionSetMatch {\n+        match WebpackLoaderBuiltinCondition::from_str(condition) {\n+            Ok(cond) => {\n+                if self.0.contains(&cond) {\n+                    WebpackLoaderBuiltinConditionSetMatch::Matched\n+                } else {\n+                    WebpackLoaderBuiltinConditionSetMatch::Unmatched\n+                }\n+            }\n+            Err(_) => WebpackLoaderBuiltinConditionSetMatch::Invalid,\n+        }\n+    }\n+}\n+\n pub async fn webpack_loader_options(\n     project_path: FileSystemPath,\n     next_config: Vc<NextConfig>,\n-    foreign: bool,\n-    loader_conditions: BTreeSet<WebpackLoaderBuiltinCondition>,\n+    builtin_conditions: BTreeSet<WebpackLoaderBuiltinCondition>,\n ) -> Result<Option<ResolvedVc<WebpackLoadersOptions>>> {\n-    let rules = *next_config\n-        .webpack_rules(loader_conditions, project_path.clone())\n+    let mut rules = *next_config\n+        .webpack_rules(builtin_conditions.clone(), project_path.clone())\n         .await?;\n-    let rules = *maybe_add_sass_loader(next_config.sass_config(), rules.map(|v| *v)).await?;\n-    let rules = if foreign {\n-        rules\n-    } else {\n-        *maybe_add_babel_loader(project_path.clone(), rules.map(|v| *v)).await?\n-    };\n+    rules = *maybe_add_sass_loader(next_config.sass_config(), rules.map(|v| *v)).await?;\n+    if !builtin_conditions.contains(&WebpackLoaderBuiltinCondition::Foreign) {\n+        rules = *maybe_add_babel_loader(project_path.clone(), rules.map(|v| *v)).await?;\n+    }\n \n     let conditions = next_config.webpack_conditions().to_resolved().await?;\n     Ok(if let Some(rules) = rules {\n@@ -119,6 +151,9 @@ pub async fn webpack_loader_options(\n                 rules,\n                 conditions,\n                 loader_runner_package: Some(loader_runner_package_mapping().to_resolved().await?),\n+                builtin_conditions: NextWebpackLoaderBuiltinConditionSet::new(builtin_conditions)\n+                    .to_resolved()\n+                    .await?,\n             }\n             .resolved_cell(),\n         )"
        },
        {
            "sha": "23f0cafc25a9c218c95f1ade4228bdfbd7e3b157",
            "filename": "crates/next-core/src/next_shared/webpack_rules/sass.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/628540fbbc9cb2cce858cba63d56e973744f2f83/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fwebpack_rules%2Fsass.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/628540fbbc9cb2cce858cba63d56e973744f2f83/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fwebpack_rules%2Fsass.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fwebpack_rules%2Fsass.rs?ref=628540fbbc9cb2cce858cba63d56e973744f2f83",
            "patch": "@@ -87,6 +87,7 @@ pub async fn maybe_add_sass_loader(\n                 LoaderRuleItem {\n                     loaders: ResolvedVc::cell(vec![resolve_url_loader, sass_loader]),\n                     rename_as: Some(format!(\"*{rename}\").into()),\n+                    condition: None,\n                 },\n             );\n         }"
        },
        {
            "sha": "2aa7de1b35a35e8fa677846dcc11445d00a8ab1f",
            "filename": "packages/next/src/build/swc/index.ts",
            "status": "modified",
            "additions": 92,
            "deletions": 45,
            "changes": 137,
            "blob_url": "https://github.com/vercel/next.js/blob/628540fbbc9cb2cce858cba63d56e973744f2f83/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Findex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/628540fbbc9cb2cce858cba63d56e973744f2f83/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Findex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Findex.ts?ref=628540fbbc9cb2cce858cba63d56e973744f2f83",
            "patch": "@@ -11,7 +11,9 @@ import { downloadNativeNextSwc, downloadWasmSwc } from '../../lib/download-swc'\n import type {\n   NextConfigComplete,\n   ReactCompilerOptions,\n+  TurbopackLoaderBuiltinCondition,\n   TurbopackLoaderItem,\n+  TurbopackRuleCondition,\n   TurbopackRuleConfigItem,\n   TurbopackRuleConfigItemOptions,\n   TurbopackRuleConfigItemOrShortcut,\n@@ -869,7 +871,7 @@ function bindingToApi(\n     nextConfig: NextConfigComplete,\n     projectPath: string\n   ): Promise<string> {\n-    // Avoid mutating the existing `nextConfig` object.\n+    // Avoid mutating the existing `nextConfig` object. NOTE: This does a shallow clone.\n     let nextConfigSerializable = augmentNextConfig(nextConfig, projectPath)\n \n     nextConfigSerializable.generateBuildId =\n@@ -879,12 +881,6 @@ function bindingToApi(\n     nextConfigSerializable.exportPathMap = {}\n     nextConfigSerializable.webpack = nextConfigSerializable.webpack && {}\n \n-    if (nextConfigSerializable.turbopack?.rules) {\n-      ensureLoadersHaveSerializableOptions(\n-        nextConfigSerializable.turbopack?.rules\n-      )\n-    }\n-\n     if (nextConfigSerializable.modularizeImports) {\n       nextConfigSerializable.modularizeImports = Object.fromEntries(\n         Object.entries<any>(nextConfigSerializable.modularizeImports).map(\n@@ -942,71 +938,122 @@ function bindingToApi(\n       }\n     }\n \n-    const conditions: (typeof nextConfig)['turbopack']['conditions'] =\n-      nextConfigSerializable.turbopack?.conditions\n-    if (conditions) {\n-      type SerializedConditions = {\n-        [key: string]: {\n-          path?:\n-            | { type: 'regex'; value: { source: string; flags: string } }\n-            | { type: 'glob'; value: string }\n-          content?: { source: string; flags: string }\n-        }\n+    if (nextConfigSerializable.turbopack != null) {\n+      // clone to allow in-place mutations\n+      const turbopack = { ...nextConfigSerializable.turbopack }\n+\n+      if (turbopack.rules) {\n+        turbopack.rules = serializeTurbopackRules(turbopack.rules)\n       }\n \n-      function regexComponents(regex: RegExp): {\n-        source: string\n-        flags: string\n-      } {\n-        return {\n-          source: regex.source,\n-          flags: regex.flags,\n+      const conditions: (typeof nextConfig)['turbopack']['conditions'] =\n+        turbopack.conditions\n+      if (conditions) {\n+        const serializedConditions: { [key: string]: SerializedRuleCondition } =\n+          {}\n+        for (const [key, value] of Object.entries(conditions)) {\n+          serializedConditions[key] = serializeRuleCondition(value)\n         }\n+        turbopack.conditions = serializedConditions\n+      }\n+\n+      nextConfigSerializable.turbopack = turbopack\n+    }\n+\n+    return JSON.stringify(nextConfigSerializable, null, 2)\n+  }\n+\n+  type SerializedRuleCondition =\n+    | { all: SerializedRuleCondition[] }\n+    | { any: SerializedRuleCondition[] }\n+    | { not: SerializedRuleCondition }\n+    | TurbopackLoaderBuiltinCondition\n+    | {\n+        path?:\n+          | { type: 'regex'; value: { source: string; flags: string } }\n+          | { type: 'glob'; value: string }\n+        content?: { source: string; flags: string }\n       }\n \n-      const serializedConditions: SerializedConditions = {}\n-      for (const [key, value] of Object.entries(conditions)) {\n-        serializedConditions[key] = {\n-          ...value,\n-          path: !value.path\n+  // converts regexes to a `RegexComponents` object so that it can be JSON-serialized when passed to\n+  // Turbopack\n+  function serializeRuleCondition(\n+    cond: TurbopackRuleCondition\n+  ): SerializedRuleCondition {\n+    function regexComponents(regex: RegExp) {\n+      return {\n+        source: regex.source,\n+        flags: regex.flags,\n+      }\n+    }\n+\n+    if (typeof cond === 'string') {\n+      return cond\n+    } else if ('all' in cond) {\n+      return { ...cond, all: cond.all.map(serializeRuleCondition) }\n+    } else if ('any' in cond) {\n+      return { ...cond, any: cond.any.map(serializeRuleCondition) }\n+    } else if ('not' in cond) {\n+      return { ...cond, not: serializeRuleCondition(cond.not) }\n+    } else {\n+      return {\n+        ...cond,\n+        path:\n+          cond.path == null\n             ? undefined\n-            : value.path instanceof RegExp\n+            : cond.path instanceof RegExp\n               ? {\n                   type: 'regex',\n-                  value: regexComponents(value.path),\n+                  value: regexComponents(cond.path),\n                 }\n-              : { type: 'glob', value: value.path },\n-          content: !value.content ? undefined : regexComponents(value.content),\n-        }\n+              : { type: 'glob', value: cond.path },\n+        content: cond.content && regexComponents(cond.content),\n       }\n-      nextConfigSerializable.turbopack.conditions = serializedConditions\n     }\n-\n-    return JSON.stringify(nextConfigSerializable, null, 2)\n   }\n \n-  function ensureLoadersHaveSerializableOptions(\n+  // Note: Returns an updated `turbopackRules` with serialized conditions. Does not mutate in-place.\n+  function serializeTurbopackRules(\n     turbopackRules: Record<string, TurbopackRuleConfigItemOrShortcut>\n-  ) {\n+  ): Record<string, any> {\n+    const serializedRules: Record<string, any> = {}\n     for (const [glob, rule] of Object.entries(turbopackRules)) {\n       if (Array.isArray(rule)) {\n         checkLoaderItems(rule, glob)\n+        serializedRules[glob] = rule\n       } else {\n-        checkConfigItem(rule, glob)\n+        serializedRules[glob] = serializeConfigItem(rule, glob)\n       }\n     }\n \n-    function checkConfigItem(rule: TurbopackRuleConfigItem, glob: string) {\n-      if (!rule) return\n+    return serializedRules\n+\n+    function serializeConfigItem(\n+      rule: TurbopackRuleConfigItem,\n+      glob: string\n+    ): any {\n+      if (!rule) return rule\n+      let serializedRule: any = rule\n       if ('loaders' in rule) {\n-        checkLoaderItems((rule as TurbopackRuleConfigItemOptions).loaders, glob)\n+        const narrowedRule = rule as TurbopackRuleConfigItemOptions\n+        checkLoaderItems(narrowedRule.loaders, glob)\n+        if (narrowedRule.condition != null) {\n+          serializedRule = {\n+            ...rule,\n+            condition: serializeRuleCondition(narrowedRule.condition),\n+          }\n+        }\n       } else {\n-        for (const value of Object.values(rule)) {\n+        serializedRule = {}\n+        for (const [key, value] of Object.entries(rule)) {\n           if (typeof value === 'object' && value) {\n-            checkConfigItem(value, glob)\n+            serializedRule[key] = serializeConfigItem(value, glob)\n+          } else {\n+            serializedRule[key] = value\n           }\n         }\n       }\n+      return serializedRule\n     }\n \n     function checkLoaderItems("
        },
        {
            "sha": "74c861124ff381702978c57b1d009b970941f0af",
            "filename": "packages/next/src/server/config-schema.ts",
            "status": "modified",
            "additions": 21,
            "deletions": 13,
            "changes": 34,
            "blob_url": "https://github.com/vercel/next.js/blob/628540fbbc9cb2cce858cba63d56e973744f2f83/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-schema.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/628540fbbc9cb2cce858cba63d56e973744f2f83/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-schema.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-schema.ts?ref=628540fbbc9cb2cce858cba63d56e973744f2f83",
            "patch": "@@ -106,19 +106,13 @@ const zHeader: zod.ZodType<Header> = z.object({\n \n const zTurbopackLoaderItem: zod.ZodType<TurbopackLoaderItem> = z.union([\n   z.string(),\n-  z.object({\n+  z.strictObject({\n     loader: z.string(),\n     // Any JSON value can be used as turbo loader options, so use z.any() here\n-    options: z.record(z.string(), z.any()),\n+    options: z.record(z.string(), z.any()).optional(),\n   }),\n ])\n \n-const zTurbopackRuleConfigItemOptions: zod.ZodType<TurbopackRuleConfigItemOptions> =\n-  z.object({\n-    loaders: z.array(zTurbopackLoaderItem),\n-    as: z.string().optional(),\n-  })\n-\n const zTurbopackLoaderBuiltinCondition: zod.ZodType<TurbopackLoaderBuiltinCondition> =\n   z.union([\n     z.literal('default'),\n@@ -130,6 +124,24 @@ const zTurbopackLoaderBuiltinCondition: zod.ZodType<TurbopackLoaderBuiltinCondit\n     z.literal('edge-light'),\n   ])\n \n+const zTurbopackCondition: zod.ZodType<TurbopackRuleCondition> = z.union([\n+  z.strictObject({ all: z.lazy(() => z.array(zTurbopackCondition)) }),\n+  z.strictObject({ any: z.lazy(() => z.array(zTurbopackCondition)) }),\n+  z.strictObject({ not: z.lazy(() => zTurbopackCondition) }),\n+  zTurbopackLoaderBuiltinCondition,\n+  z.strictObject({\n+    path: z.union([z.string(), z.instanceof(RegExp)]).optional(),\n+    content: z.instanceof(RegExp).optional(),\n+  }),\n+])\n+\n+const zTurbopackRuleConfigItemOptions: zod.ZodType<TurbopackRuleConfigItemOptions> =\n+  z.strictObject({\n+    loaders: z.array(zTurbopackLoaderItem),\n+    as: z.string().optional(),\n+    condition: zTurbopackCondition.optional(),\n+  })\n+\n const zTurbopackRuleConfigItem: zod.ZodType<TurbopackRuleConfigItem> = z.union([\n   z.literal(false),\n   z.record(\n@@ -138,14 +150,10 @@ const zTurbopackRuleConfigItem: zod.ZodType<TurbopackRuleConfigItem> = z.union([\n   ),\n   zTurbopackRuleConfigItemOptions,\n ])\n+\n const zTurbopackRuleConfigItemOrShortcut: zod.ZodType<TurbopackRuleConfigItemOrShortcut> =\n   z.union([z.array(zTurbopackLoaderItem), zTurbopackRuleConfigItem])\n \n-const zTurbopackCondition: zod.ZodType<TurbopackRuleCondition> = z.object({\n-  path: z.union([z.string(), z.instanceof(RegExp)]).optional(),\n-  content: z.instanceof(RegExp).optional(),\n-})\n-\n const zTurbopackConfig: zod.ZodType<TurbopackOptions> = z.strictObject({\n   rules: z.record(z.string(), zTurbopackRuleConfigItemOrShortcut).optional(),\n   conditions: z.record(z.string(), zTurbopackCondition).optional(),"
        },
        {
            "sha": "03c04659d4d868b3029eb668168efb935f9687d6",
            "filename": "packages/next/src/server/config-shared.ts",
            "status": "modified",
            "additions": 16,
            "deletions": 10,
            "changes": 26,
            "blob_url": "https://github.com/vercel/next.js/blob/628540fbbc9cb2cce858cba63d56e973744f2f83/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/628540fbbc9cb2cce858cba63d56e973744f2f83/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts?ref=628540fbbc9cb2cce858cba63d56e973744f2f83",
            "patch": "@@ -259,7 +259,7 @@ export type TurbopackLoaderItem =\n   | {\n       loader: string\n       // At the moment, Turbopack options must be JSON-serializable, so restrict values.\n-      options: Record<string, JSONValue>\n+      options?: Record<string, JSONValue>\n     }\n \n export type TurbopackLoaderBuiltinCondition =\n@@ -271,25 +271,31 @@ export type TurbopackLoaderBuiltinCondition =\n   | 'node'\n   | 'edge-light'\n \n-export type TurbopackRuleCondition = {\n-  path?: string | RegExp\n-  content?: RegExp\n-}\n-\n-export type TurbopackRuleConfigItemOrShortcut =\n-  | TurbopackLoaderItem[]\n-  | TurbopackRuleConfigItem\n+export type TurbopackRuleCondition =\n+  | { all: TurbopackRuleCondition[] }\n+  | { any: TurbopackRuleCondition[] }\n+  | { not: TurbopackRuleCondition }\n+  | TurbopackLoaderBuiltinCondition\n+  | {\n+      path?: string | RegExp\n+      content?: RegExp\n+    }\n \n export type TurbopackRuleConfigItemOptions = {\n   loaders: TurbopackLoaderItem[]\n   as?: string\n+  condition?: TurbopackRuleCondition\n }\n \n export type TurbopackRuleConfigItem =\n   | TurbopackRuleConfigItemOptions\n   | { [condition in TurbopackLoaderBuiltinCondition]?: TurbopackRuleConfigItem }\n   | false\n \n+export type TurbopackRuleConfigItemOrShortcut =\n+  | TurbopackLoaderItem[]\n+  | TurbopackRuleConfigItem\n+\n export interface TurbopackOptions {\n   /**\n    * (`next --turbopack` only) A mapping of aliased imports to modules to load in their place.\n@@ -320,7 +326,7 @@ export interface TurbopackOptions {\n    *\n    * @see [Turbopack Loaders](https://nextjs.org/docs/app/api-reference/next-config-js/turbo#webpack-loaders)\n    */\n-  conditions?: Record<string, TurbopackRuleCondition>\n+  conditions?: Record<`#${string}`, TurbopackRuleCondition>\n \n   /**\n    * The module ID strategy to use for Turbopack."
        },
        {
            "sha": "467e3d85b37a5fbbec8eb57caff5300ca9cf21c9",
            "filename": "test/e2e/turbopack-loader-config/app/api/route.ts",
            "status": "added",
            "additions": 13,
            "deletions": 0,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/628540fbbc9cb2cce858cba63d56e973744f2f83/test%2Fe2e%2Fturbopack-loader-config%2Fapp%2Fapi%2Froute.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/628540fbbc9cb2cce858cba63d56e973744f2f83/test%2Fe2e%2Fturbopack-loader-config%2Fapp%2Fapi%2Froute.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fturbopack-loader-config%2Fapp%2Fapi%2Froute.ts?ref=628540fbbc9cb2cce858cba63d56e973744f2f83",
            "patch": "@@ -0,0 +1,13 @@\n+import { NextResponse } from 'next/server'\n+import foo from '../../foo.js'\n+import bar from '../../bar.js'\n+\n+export async function GET(_req) {\n+  return NextResponse.json(\n+    {\n+      foo,\n+      bar,\n+    },\n+    { status: 200 }\n+  )\n+}"
        },
        {
            "sha": "fbd95c97c7996d42968842e063d11115ef177c39",
            "filename": "test/e2e/turbopack-loader-config/bar.js",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/628540fbbc9cb2cce858cba63d56e973744f2f83/test%2Fe2e%2Fturbopack-loader-config%2Fbar.js",
            "raw_url": "https://github.com/vercel/next.js/raw/628540fbbc9cb2cce858cba63d56e973744f2f83/test%2Fe2e%2Fturbopack-loader-config%2Fbar.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fturbopack-loader-config%2Fbar.js?ref=628540fbbc9cb2cce858cba63d56e973744f2f83",
            "patch": "@@ -0,0 +1 @@\n+export default 'untransformed bar'"
        },
        {
            "sha": "e37ee37a14a3f880dc69820459647247398c699a",
            "filename": "test/e2e/turbopack-loader-config/foo.js",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/628540fbbc9cb2cce858cba63d56e973744f2f83/test%2Fe2e%2Fturbopack-loader-config%2Ffoo.js",
            "raw_url": "https://github.com/vercel/next.js/raw/628540fbbc9cb2cce858cba63d56e973744f2f83/test%2Fe2e%2Fturbopack-loader-config%2Ffoo.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fturbopack-loader-config%2Ffoo.js?ref=628540fbbc9cb2cce858cba63d56e973744f2f83",
            "patch": "@@ -0,0 +1 @@\n+export default 'untransformed foo'"
        },
        {
            "sha": "0eb89b7a9b11fd418d8401ec66c52c9216592283",
            "filename": "test/e2e/turbopack-loader-config/index.test.ts",
            "status": "added",
            "additions": 23,
            "deletions": 0,
            "changes": 23,
            "blob_url": "https://github.com/vercel/next.js/blob/628540fbbc9cb2cce858cba63d56e973744f2f83/test%2Fe2e%2Fturbopack-loader-config%2Findex.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/628540fbbc9cb2cce858cba63d56e973744f2f83/test%2Fe2e%2Fturbopack-loader-config%2Findex.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fturbopack-loader-config%2Findex.test.ts?ref=628540fbbc9cb2cce858cba63d56e973744f2f83",
            "patch": "@@ -0,0 +1,23 @@\n+import { nextTestSetup } from 'e2e-utils'\n+\n+describe('turbopack-loader-config', () => {\n+  const { next, isTurbopack, isNextDev } = nextTestSetup({\n+    files: __dirname,\n+    skipDeployment: true,\n+    // we can't set `nextConfig` inline because it contains regexes that fail to serialize, it needs\n+    // to be set in a separate module (`next.config.ts`)\n+  })\n+\n+  if (!isTurbopack) {\n+    it('should only run the test in turbopack', () => {})\n+    return\n+  }\n+\n+  it('should replace modules with their loader-generated versions', async () => {\n+    const response = JSON.parse(await next.render('/api'))\n+    expect(response).toEqual({\n+      foo: 'default return value',\n+      bar: 'has export substring' + (isNextDev ? ' on dev' : ' on prod'),\n+    })\n+  })\n+})"
        },
        {
            "sha": "a22cba4e49d8d0075a2bce365ee2dd85c9329696",
            "filename": "test/e2e/turbopack-loader-config/next.config.ts",
            "status": "added",
            "additions": 62,
            "deletions": 0,
            "changes": 62,
            "blob_url": "https://github.com/vercel/next.js/blob/628540fbbc9cb2cce858cba63d56e973744f2f83/test%2Fe2e%2Fturbopack-loader-config%2Fnext.config.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/628540fbbc9cb2cce858cba63d56e973744f2f83/test%2Fe2e%2Fturbopack-loader-config%2Fnext.config.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fturbopack-loader-config%2Fnext.config.ts?ref=628540fbbc9cb2cce858cba63d56e973744f2f83",
            "patch": "@@ -0,0 +1,62 @@\n+export default {\n+  turbopack: {\n+    rules: {\n+      // an empty condition should match\n+      'foo.js': {\n+        condition: {},\n+        // use the shorthand syntax\n+        loaders: ['./webpack-loader-replace-with-stub.cjs'],\n+      },\n+      // this condition should not match\n+      'bar.js': {\n+        condition: 'foreign',\n+        loaders: [\n+          {\n+            loader: './webpack-loader-replace-with-stub.cjs',\n+            options: { returnValue: 'foreign' },\n+          },\n+        ],\n+      },\n+      // this condition should not match\n+      '{bar}.js': {\n+        condition: {\n+          not: { content: /export/ },\n+        },\n+        loaders: [\n+          {\n+            loader: './webpack-loader-replace-with-stub.cjs',\n+            options: { returnValue: 'missing export' },\n+          },\n+        ],\n+      },\n+      // this should match on dev\n+      '{bar.js}': {\n+        condition: {\n+          any: [\n+            {\n+              all: ['development', { not: { not: { content: /export/ } } }],\n+            },\n+          ],\n+        },\n+        loaders: [\n+          {\n+            loader: './webpack-loader-replace-with-stub.cjs',\n+            options: { returnValue: 'has export substring on dev' },\n+          },\n+        ],\n+      },\n+      // this should match on production\n+      'bar.{js}': {\n+        condition: {\n+          all: [{ not: 'development' }, { content: /export/ }],\n+        },\n+        loaders: [\n+          {\n+            loader: './webpack-loader-replace-with-stub.cjs',\n+            options: { returnValue: 'has export substring on prod' },\n+          },\n+        ],\n+      },\n+    },\n+  },\n+}"
        },
        {
            "sha": "eb3f38eda6dc5f583b6c23f50283cafb9e57b3a8",
            "filename": "test/e2e/turbopack-loader-config/webpack-loader-replace-with-stub.cjs",
            "status": "added",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/628540fbbc9cb2cce858cba63d56e973744f2f83/test%2Fe2e%2Fturbopack-loader-config%2Fwebpack-loader-replace-with-stub.cjs",
            "raw_url": "https://github.com/vercel/next.js/raw/628540fbbc9cb2cce858cba63d56e973744f2f83/test%2Fe2e%2Fturbopack-loader-config%2Fwebpack-loader-replace-with-stub.cjs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fturbopack-loader-config%2Fwebpack-loader-replace-with-stub.cjs?ref=628540fbbc9cb2cce858cba63d56e973744f2f83",
            "patch": "@@ -0,0 +1,8 @@\n+module.exports = function (content, _map, _meta) {\n+  const options = this.getOptions()\n+  if (!content.includes('untransformed')) {\n+    throw new Error('loader matched multiple times')\n+  }\n+  const returnValue = options?.returnValue ?? 'default return value'\n+  return `export default ${JSON.stringify(returnValue)}`\n+}"
        },
        {
            "sha": "b9094f72aa6f6d3a2833b2390180844fad92276f",
            "filename": "turbopack/crates/turbopack-node/src/transforms/webpack.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/628540fbbc9cb2cce858cba63d56e973744f2f83/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Fwebpack.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/628540fbbc9cb2cce858cba63d56e973744f2f83/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Fwebpack.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Fwebpack.rs?ref=628540fbbc9cb2cce858cba63d56e973744f2f83",
            "patch": "@@ -88,6 +88,7 @@ struct WebpackLoadersProcessingResult {\n )]\n pub struct WebpackLoaderItem {\n     pub loader: RcStr,\n+    #[serde(default)]\n     pub options: serde_json::Map<String, serde_json::Value>,\n }\n "
        },
        {
            "sha": "29d32864d3b1e0920b133ff95fc63c9e2548812b",
            "filename": "turbopack/crates/turbopack/Cargo.toml",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/628540fbbc9cb2cce858cba63d56e973744f2f83/turbopack%2Fcrates%2Fturbopack%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/628540fbbc9cb2cce858cba63d56e973744f2f83/turbopack%2Fcrates%2Fturbopack%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack%2FCargo.toml?ref=628540fbbc9cb2cce858cba63d56e973744f2f83",
            "patch": "@@ -18,6 +18,7 @@ workspace = true\n \n [dependencies]\n anyhow = { workspace = true }\n+either = { workspace = true }\n regex = { workspace = true }\n rustc-hash = { workspace = true }\n smallvec = { workspace = true }"
        },
        {
            "sha": "8c1af55029ca0f44eb33180ab7ce0edddfc4edd4",
            "filename": "turbopack/crates/turbopack/src/module_options/mod.rs",
            "status": "modified",
            "additions": 138,
            "deletions": 55,
            "changes": 193,
            "blob_url": "https://github.com/vercel/next.js/blob/628540fbbc9cb2cce858cba63d56e973744f2f83/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/628540fbbc9cb2cce858cba63d56e973744f2f83/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Fmod.rs?ref=628540fbbc9cb2cce858cba63d56e973744f2f83",
            "patch": "@@ -11,7 +11,7 @@ pub use module_options_context::*;\n pub use module_rule::*;\n pub use rule_condition::*;\n use turbo_rcstr::{RcStr, rcstr};\n-use turbo_tasks::{ResolvedVc, Vc};\n+use turbo_tasks::{IntoTraitRef, ResolvedVc, TryJoinIterExt, Vc};\n use turbo_tasks_fs::{\n     FileSystemPath,\n     glob::{Glob, GlobOptions},\n@@ -27,7 +27,10 @@ use turbopack_ecmascript::{\n     EcmascriptInputTransform, EcmascriptInputTransforms, EcmascriptOptions, SpecifiedModuleType,\n };\n use turbopack_mdx::MdxTransform;\n-use turbopack_node::transforms::{postcss::PostCssTransform, webpack::WebpackLoaders};\n+use turbopack_node::{\n+    execution_context::ExecutionContext,\n+    transforms::{postcss::PostCssTransform, webpack::WebpackLoaders},\n+};\n use turbopack_wasm::source::WebAssemblySourceType;\n \n use crate::{\n@@ -60,6 +63,80 @@ fn package_import_map_from_context(\n     import_map.cell()\n }\n \n+async fn rule_condition_from_webpack_condition_glob(\n+    execution_context: ResolvedVc<ExecutionContext>,\n+    glob: &RcStr,\n+) -> Result<RuleCondition> {\n+    Ok(if glob.contains('/') {\n+        RuleCondition::ResourcePathGlob {\n+            base: execution_context.project_path().owned().await?,\n+            glob: Glob::new(glob.clone(), GlobOptions::default()).await?,\n+        }\n+    } else {\n+        RuleCondition::ResourceBasePathGlob(Glob::new(glob.clone(), GlobOptions::default()).await?)\n+    })\n+}\n+\n+async fn rule_condition_from_webpack_condition(\n+    execution_context: ResolvedVc<ExecutionContext>,\n+    builtin_conditions: &dyn WebpackLoaderBuiltinConditionSet,\n+    webpack_loader_condition: &ConditionItem,\n+) -> Result<RuleCondition> {\n+    Ok(match webpack_loader_condition {\n+        ConditionItem::All(conds) => RuleCondition::All(\n+            conds\n+                .iter()\n+                .map(|c| {\n+                    rule_condition_from_webpack_condition(execution_context, builtin_conditions, c)\n+                })\n+                .try_join()\n+                .await?,\n+        ),\n+        ConditionItem::Any(conds) => RuleCondition::Any(\n+            conds\n+                .iter()\n+                .map(|c| {\n+                    rule_condition_from_webpack_condition(execution_context, builtin_conditions, c)\n+                })\n+                .try_join()\n+                .await?,\n+        ),\n+        ConditionItem::Not(cond) => RuleCondition::Not(Box::new(\n+            Box::pin(rule_condition_from_webpack_condition(\n+                execution_context,\n+                builtin_conditions,\n+                cond,\n+            ))\n+            .await?,\n+        )),\n+        ConditionItem::Builtin(name) => match builtin_conditions.match_condition(name) {\n+            WebpackLoaderBuiltinConditionSetMatch::Matched => RuleCondition::True,\n+            WebpackLoaderBuiltinConditionSetMatch::Unmatched => RuleCondition::False,\n+            WebpackLoaderBuiltinConditionSetMatch::Invalid => {\n+                // We don't expect the user to hit this because whatever deserailizes the user\n+                // configuration should validate conditions itself\n+                anyhow::bail!(\"{name:?} is not a valid built-in condition\")\n+            }\n+        },\n+        ConditionItem::Base { path, content } => {\n+            let mut rule_conditions = Vec::new();\n+            match &path {\n+                Some(ConditionPath::Glob(glob)) => rule_conditions.push(\n+                    rule_condition_from_webpack_condition_glob(execution_context, glob).await?,\n+                ),\n+                Some(ConditionPath::Regex(regex)) => {\n+                    rule_conditions.push(RuleCondition::ResourcePathEsRegex(regex.await?));\n+                }\n+                None => {}\n+            }\n+            if let Some(content) = content {\n+                rule_conditions.push(RuleCondition::ResourceContentEsRegex(content.await?));\n+            }\n+            RuleCondition::All(rule_conditions)\n+        }\n+    })\n+}\n+\n #[turbo_tasks::value(cell = \"new\", eq = \"manual\")]\n pub struct ModuleOptions {\n     pub rules: Vec<ModuleRule>,\n@@ -493,9 +570,17 @@ impl ModuleOptions {\n                         .context(\"need_path in ModuleOptions::new is incorrect\")?,\n                 )\n             };\n+            let builtin_conditions = webpack_loaders_options\n+                .builtin_conditions\n+                .into_trait_ref()\n+                .await?;\n             for (key, rule) in webpack_loaders_options.rules.await?.iter() {\n                 let mut rule_conditions = Vec::new();\n+\n                 if key.starts_with(\"#\") {\n+                    // Legacy (undocumented) condition reference syntax:\n+                    // https://www.notion.so/vercel/Turbopack-loader-rule-syntax-254e06b059c4809096d1e7c9afad278c\n+                    //\n                     // This is a custom marker requiring a corresponding condition entry\n                     let conditions = (*webpack_loaders_options.conditions.await?)\n                         .context(\n@@ -508,65 +593,63 @@ impl ModuleOptions {\n                         \"Expected a condition entry for the webpack loader rule matching {key}.\",\n                     )?;\n \n-                    let ConditionItem { path, content } = &condition;\n-\n-                    match &path {\n-                        Some(ConditionPath::Glob(glob)) => {\n-                            if glob.contains('/') {\n-                                rule_conditions.push(RuleCondition::ResourcePathGlob {\n-                                    base: execution_context.project_path().owned().await?,\n-                                    glob: Glob::new(glob.clone(), GlobOptions::default()).await?,\n-                                });\n-                            } else {\n-                                rule_conditions.push(RuleCondition::ResourceBasePathGlob(\n-                                    Glob::new(glob.clone(), GlobOptions::default()).await?,\n-                                ));\n-                            }\n-                        }\n-                        Some(ConditionPath::Regex(regex)) => {\n-                            rule_conditions.push(RuleCondition::ResourcePathEsRegex(regex.await?));\n-                        }\n-                        None => {}\n-                    }\n-                    if let Some(content) = content {\n-                        rule_conditions.push(RuleCondition::ResourceContentEsRegex(content.await?));\n-                    }\n-                } else if key.contains('/') {\n-                    rule_conditions.push(RuleCondition::ResourcePathGlob {\n-                        base: execution_context.project_path().owned().await?,\n-                        glob: Glob::new(key.clone(), GlobOptions::default()).await?,\n-                    });\n+                    rule_conditions.push(\n+                        rule_condition_from_webpack_condition(\n+                            execution_context,\n+                            &*builtin_conditions,\n+                            condition,\n+                        )\n+                        .await?,\n+                    )\n                 } else {\n-                    rule_conditions.push(RuleCondition::ResourceBasePathGlob(\n-                        Glob::new(key.clone(), GlobOptions::default()).await?,\n-                    ));\n+                    // prefer to add this condition ahead of the user-defined `condition` field,\n+                    // because we know it's cheap to check\n+                    rule_conditions.push(\n+                        rule_condition_from_webpack_condition_glob(execution_context, key).await?,\n+                    )\n                 };\n+\n+                if let Some(condition) = &rule.condition {\n+                    rule_conditions.push(\n+                        rule_condition_from_webpack_condition(\n+                            execution_context,\n+                            &*builtin_conditions,\n+                            condition,\n+                        )\n+                        .await?,\n+                    )\n+                }\n+\n                 rule_conditions.push(RuleCondition::not(RuleCondition::ResourceIsVirtualSource));\n                 rule_conditions.push(module_css_external_transform_conditions.clone());\n \n-                rules.push(ModuleRule::new(\n-                    RuleCondition::All(rule_conditions),\n-                    vec![ModuleRuleEffect::SourceTransforms(ResolvedVc::cell(vec![\n-                        ResolvedVc::upcast(\n-                            WebpackLoaders::new(\n-                                node_evaluate_asset_context(\n+                let mut all_rule_condition = RuleCondition::All(rule_conditions);\n+                all_rule_condition.flatten();\n+                if !matches!(all_rule_condition, RuleCondition::False) {\n+                    rules.push(ModuleRule::new(\n+                        all_rule_condition,\n+                        vec![ModuleRuleEffect::SourceTransforms(ResolvedVc::cell(vec![\n+                            ResolvedVc::upcast(\n+                                WebpackLoaders::new(\n+                                    node_evaluate_asset_context(\n+                                        *execution_context,\n+                                        Some(import_map),\n+                                        None,\n+                                        Layer::new(rcstr!(\"webpack_loaders\")),\n+                                        false,\n+                                    ),\n                                     *execution_context,\n-                                    Some(import_map),\n-                                    None,\n-                                    Layer::new(rcstr!(\"webpack_loaders\")),\n-                                    false,\n-                                ),\n-                                *execution_context,\n-                                *rule.loaders,\n-                                rule.rename_as.clone(),\n-                                resolve_options_context,\n-                                matches!(ecmascript_source_maps, SourceMapsType::Full),\n-                            )\n-                            .to_resolved()\n-                            .await?,\n-                        ),\n-                    ]))],\n-                ));\n+                                    *rule.loaders,\n+                                    rule.rename_as.clone(),\n+                                    resolve_options_context,\n+                                    matches!(ecmascript_source_maps, SourceMapsType::Full),\n+                                )\n+                                .to_resolved()\n+                                .await?,\n+                            ),\n+                        ]))],\n+                    ));\n+                }\n             }\n         }\n "
        },
        {
            "sha": "06aff3d2583043938934a57ee6de8dabd7769249",
            "filename": "turbopack/crates/turbopack/src/module_options/module_options_context.rs",
            "status": "modified",
            "additions": 49,
            "deletions": 3,
            "changes": 52,
            "blob_url": "https://github.com/vercel/next.js/blob/628540fbbc9cb2cce858cba63d56e973744f2f83/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Fmodule_options_context.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/628540fbbc9cb2cce858cba63d56e973744f2f83/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Fmodule_options_context.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Fmodule_options_context.rs?ref=628540fbbc9cb2cce858cba63d56e973744f2f83",
            "patch": "@@ -23,6 +23,7 @@ use crate::module_options::RuleCondition;\n pub struct LoaderRuleItem {\n     pub loaders: ResolvedVc<WebpackLoaderItems>,\n     pub rename_as: Option<RcStr>,\n+    pub condition: Option<ConditionItem>,\n }\n \n #[derive(Default)]\n@@ -49,19 +50,64 @@ pub enum ConditionPath {\n \n #[turbo_tasks::value(shared)]\n #[derive(Clone, Debug)]\n-pub struct ConditionItem {\n-    pub path: Option<ConditionPath>,\n-    pub content: Option<ResolvedVc<EsRegex>>,\n+pub enum ConditionItem {\n+    All(Box<[ConditionItem]>),\n+    Any(Box<[ConditionItem]>),\n+    Not(Box<ConditionItem>),\n+    Builtin(RcStr),\n+    Base {\n+        path: Option<ConditionPath>,\n+        content: Option<ResolvedVc<EsRegex>>,\n+    },\n }\n \n #[turbo_tasks::value(shared)]\n #[derive(Clone, Debug)]\n pub struct WebpackLoadersOptions {\n     pub rules: ResolvedVc<WebpackRules>,\n     pub conditions: ResolvedVc<OptionWebpackConditions>,\n+    pub builtin_conditions: ResolvedVc<Box<dyn WebpackLoaderBuiltinConditionSet>>,\n     pub loader_runner_package: Option<ResolvedVc<ImportMapping>>,\n }\n \n+pub enum WebpackLoaderBuiltinConditionSetMatch {\n+    Matched,\n+    Unmatched,\n+    /// The given condition is not supported by the framework.\n+    Invalid,\n+}\n+\n+/// A collection of framework-provided conditions for user (or framework) specified loader rules\n+/// ([`WebpackRules`]) to match against.\n+#[turbo_tasks::value_trait]\n+pub trait WebpackLoaderBuiltinConditionSet {\n+    /// Determines if the string representation of this condition is in the set. If it's not valid,\n+    /// an issue will be emitted as a collectible.\n+    fn match_condition(&self, condition: &str) -> WebpackLoaderBuiltinConditionSetMatch;\n+}\n+\n+/// A no-op implementation of `WebpackLoaderBuiltinConditionSet` that always returns\n+/// `WebpackLoaderBuiltinConditionSetMatch::Invalid`.\n+#[turbo_tasks::value]\n+pub struct EmptyWebpackLoaderBuiltinConditionSet;\n+\n+#[turbo_tasks::value_impl]\n+impl EmptyWebpackLoaderBuiltinConditionSet {\n+    #[turbo_tasks::function]\n+    fn new() -> Vc<Box<dyn WebpackLoaderBuiltinConditionSet>> {\n+        Vc::upcast::<Box<dyn WebpackLoaderBuiltinConditionSet>>(\n+            EmptyWebpackLoaderBuiltinConditionSet.cell(),\n+        )\n+    }\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl WebpackLoaderBuiltinConditionSet for EmptyWebpackLoaderBuiltinConditionSet {\n+    fn match_condition(&self, _condition: &str) -> WebpackLoaderBuiltinConditionSetMatch {\n+        WebpackLoaderBuiltinConditionSetMatch::Invalid\n+    }\n+}\n+\n /// The kind of decorators transform to use.\n /// [TODO]: might need bikeshed for the name (Ecma)\n #[derive(Clone, PartialEq, Eq, Debug, TraceRawVcs, Serialize, Deserialize, NonLocalValue)]"
        },
        {
            "sha": "41f074244363d3d8e4bc9304ae03ca8da877f918",
            "filename": "turbopack/crates/turbopack/src/module_options/rule_condition.rs",
            "status": "modified",
            "additions": 206,
            "deletions": 2,
            "changes": 208,
            "blob_url": "https://github.com/vercel/next.js/blob/628540fbbc9cb2cce858cba63d56e973744f2f83/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Frule_condition.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/628540fbbc9cb2cce858cba63d56e973744f2f83/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Frule_condition.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Frule_condition.rs?ref=628540fbbc9cb2cce858cba63d56e973744f2f83",
            "patch": "@@ -1,4 +1,10 @@\n+use std::{\n+    iter,\n+    mem::{replace, take},\n+};\n+\n use anyhow::{Result, bail};\n+use either::Either;\n use serde::{Deserialize, Serialize};\n use smallvec::SmallVec;\n use turbo_esregex::EsRegex;\n@@ -13,6 +19,8 @@ pub enum RuleCondition {\n     All(Vec<RuleCondition>),\n     Any(Vec<RuleCondition>),\n     Not(Box<RuleCondition>),\n+    True,\n+    False,\n     ReferenceType(ReferenceType),\n     ResourceIsVirtualSource,\n     ResourcePathEquals(FileSystemPath),\n@@ -52,9 +60,101 @@ impl RuleCondition {\n     pub fn not(condition: RuleCondition) -> RuleCondition {\n         RuleCondition::Not(Box::new(condition))\n     }\n-}\n \n-impl RuleCondition {\n+    /// Slightly optimize a `RuleCondition` by flattening nested `Any`, `All`, or `Not` variants.\n+    ///\n+    /// Does not apply general re-ordering of rules (which may also be a valid optimization using a\n+    /// cost heuristic), but does flatten constant `True` and `False` conditions, potentially\n+    /// skipping other rules.\n+    pub fn flatten(&mut self) {\n+        match self {\n+            RuleCondition::Any(conds) => {\n+                // fast path: flatten children in-place and avoid constructing an additional vec\n+                let mut needs_flattening = false;\n+                for c in conds.iter_mut() {\n+                    c.flatten();\n+                    if *c == RuleCondition::True {\n+                        // short-circuit: all conditions are side-effect free\n+                        *self = RuleCondition::True;\n+                        return;\n+                    }\n+                    needs_flattening = needs_flattening\n+                        || matches!(c, RuleCondition::Any(_) | RuleCondition::False);\n+                }\n+\n+                if needs_flattening {\n+                    *conds = take(conds)\n+                        .into_iter()\n+                        .flat_map(|c| match c {\n+                            RuleCondition::Any(nested) => {\n+                                debug_assert!(!nested.is_empty(), \"empty Any should be False\");\n+                                Either::Left(nested.into_iter())\n+                            }\n+                            RuleCondition::False => Either::Right(Either::Left(iter::empty())),\n+                            c => Either::Right(Either::Right(iter::once(c))),\n+                        })\n+                        .collect();\n+                }\n+\n+                match conds.len() {\n+                    0 => *self = RuleCondition::False,\n+                    1 => *self = take(conds).into_iter().next().unwrap(),\n+                    _ => {}\n+                }\n+            }\n+            RuleCondition::All(conds) => {\n+                // fast path: flatten children in-place and avoid constructing an additional vec\n+                let mut needs_flattening = false;\n+                for c in conds.iter_mut() {\n+                    c.flatten();\n+                    if *c == RuleCondition::False {\n+                        // short-circuit: all conditions are side-effect free\n+                        *self = RuleCondition::False;\n+                        return;\n+                    }\n+                    needs_flattening = needs_flattening\n+                        || matches!(c, RuleCondition::All(_) | RuleCondition::True);\n+                }\n+\n+                if needs_flattening {\n+                    *conds = take(conds)\n+                        .into_iter()\n+                        .flat_map(|c| match c {\n+                            RuleCondition::All(nested) => {\n+                                debug_assert!(!nested.is_empty(), \"empty All should be True\");\n+                                Either::Left(nested.into_iter())\n+                            }\n+                            RuleCondition::True => Either::Right(Either::Left(iter::empty())),\n+                            c => Either::Right(Either::Right(iter::once(c))),\n+                        })\n+                        .collect();\n+                }\n+\n+                match conds.len() {\n+                    0 => *self = RuleCondition::True,\n+                    1 => *self = take(conds).into_iter().next().unwrap(),\n+                    _ => {}\n+                }\n+            }\n+            RuleCondition::Not(cond) => {\n+                match &mut **cond {\n+                    // nested `Not`s negate each other\n+                    RuleCondition::Not(inner) => {\n+                        let inner = &mut **inner;\n+                        inner.flatten();\n+                        // Use `replace` with a dummy condition instead of `take` since\n+                        // `RuleCondition` doesn't implement `Default`.\n+                        *self = replace(inner, RuleCondition::False)\n+                    }\n+                    RuleCondition::True => *self = RuleCondition::False,\n+                    RuleCondition::False => *self = RuleCondition::True,\n+                    other => other.flatten(),\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+\n     pub async fn matches(\n         &self,\n         source: ResolvedVc<Box<dyn Source>>,\n@@ -108,6 +208,12 @@ impl RuleCondition {\n                         cond = inner.as_ref();\n                         continue;\n                     }\n+                    RuleCondition::True => {\n+                        return Ok(true);\n+                    }\n+                    RuleCondition::False => {\n+                        return Ok(false);\n+                    }\n                     RuleCondition::ReferenceType(condition_ty) => {\n                         return Ok(condition_ty.includes(reference_type));\n                     }\n@@ -240,6 +346,104 @@ pub mod tests {\n \n     use super::*;\n \n+    #[test]\n+    fn flatten_any_with_single_child_collapses() {\n+        let mut rc = RuleCondition::Any(vec![RuleCondition::True]);\n+        rc.flatten();\n+        assert_eq!(rc, RuleCondition::True);\n+\n+        let mut rc = RuleCondition::Any(vec![RuleCondition::ContentTypeEmpty]);\n+        rc.flatten();\n+        assert_eq!(rc, RuleCondition::ContentTypeEmpty);\n+    }\n+\n+    #[test]\n+    fn flatten_any_nested_and_false() {\n+        let mut rc = RuleCondition::Any(vec![\n+            RuleCondition::False,\n+            RuleCondition::Any(vec![RuleCondition::ContentTypeEmpty, RuleCondition::False]),\n+        ]);\n+        rc.flatten();\n+        assert_eq!(rc, RuleCondition::ContentTypeEmpty);\n+    }\n+\n+    #[test]\n+    fn flatten_any_short_circuits_on_true() {\n+        let mut rc = RuleCondition::Any(vec![\n+            RuleCondition::False,\n+            RuleCondition::True,\n+            RuleCondition::ContentTypeEmpty,\n+        ]);\n+        rc.flatten();\n+        assert_eq!(rc, RuleCondition::True);\n+    }\n+\n+    #[test]\n+    fn flatten_any_empty_becomes_false() {\n+        let mut rc = RuleCondition::Any(vec![]);\n+        rc.flatten();\n+        assert_eq!(rc, RuleCondition::False);\n+    }\n+\n+    #[test]\n+    fn flatten_all_with_single_child_collapses() {\n+        let mut rc = RuleCondition::All(vec![RuleCondition::ContentTypeEmpty]);\n+        rc.flatten();\n+        assert_eq!(rc, RuleCondition::ContentTypeEmpty);\n+\n+        let mut rc = RuleCondition::All(vec![RuleCondition::True]);\n+        rc.flatten();\n+        assert_eq!(rc, RuleCondition::True);\n+    }\n+\n+    #[test]\n+    fn flatten_all_nested_and_true() {\n+        let mut rc = RuleCondition::All(vec![\n+            RuleCondition::True,\n+            RuleCondition::All(vec![RuleCondition::ContentTypeEmpty, RuleCondition::True]),\n+        ]);\n+        rc.flatten();\n+        assert_eq!(rc, RuleCondition::ContentTypeEmpty);\n+    }\n+\n+    #[test]\n+    fn flatten_all_short_circuits_on_false() {\n+        let mut rc = RuleCondition::All(vec![\n+            RuleCondition::True,\n+            RuleCondition::False,\n+            RuleCondition::ContentTypeEmpty,\n+        ]);\n+        rc.flatten();\n+        assert_eq!(rc, RuleCondition::False);\n+    }\n+\n+    #[test]\n+    fn flatten_all_empty_becomes_true() {\n+        let mut rc = RuleCondition::All(vec![]);\n+        rc.flatten();\n+        assert_eq!(rc, RuleCondition::True);\n+    }\n+\n+    #[test]\n+    fn flatten_not_of_not() {\n+        let mut rc = RuleCondition::Not(Box::new(RuleCondition::Not(Box::new(\n+            RuleCondition::All(vec![RuleCondition::ContentTypeEmpty]),\n+        ))));\n+        rc.flatten();\n+        assert_eq!(rc, RuleCondition::ContentTypeEmpty);\n+    }\n+\n+    #[test]\n+    fn flatten_not_constants() {\n+        let mut rc = RuleCondition::Not(Box::new(RuleCondition::True));\n+        rc.flatten();\n+        assert_eq!(rc, RuleCondition::False);\n+\n+        let mut rc = RuleCondition::Not(Box::new(RuleCondition::False));\n+        rc.flatten();\n+        assert_eq!(rc, RuleCondition::True);\n+    }\n+\n     #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n     async fn test_rule_condition_leaves() {\n         crate::register();"
        }
    ],
    "stats": {
        "total": 1159,
        "additions": 938,
        "deletions": 221
    }
}