{
    "author": "sokra",
    "message": "Turbopack: add turbo_tasks::run to run in turbo tasks scope without a task (#83847)\n\n# What?\n\nrefactor try_read_task_cell to take option arguments instead of having an _untracked method\n\nadd turbo_tasks::run to run in turbo tasks scope without a task\n\nuse the new method in some test cases where it was possible",
    "sha": "c4603d2abe7ed8f70843bd62ddeae391b558e9c4",
    "files": [
        {
            "sha": "4fc0647055e6fe5f66cd59599a6a2df55b2fccc3",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 32,
            "deletions": 51,
            "changes": 83,
            "blob_url": "https://github.com/vercel/next.js/blob/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=c4603d2abe7ed8f70843bd62ddeae391b558e9c4",
            "patch": "@@ -415,7 +415,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n     unsafe fn connect_child_with_tx<'l, 'tx: 'l>(\n         &'l self,\n         tx: Option<&'l B::ReadTransaction<'tx>>,\n-        parent_task: TaskId,\n+        parent_task: Option<TaskId>,\n         child_task: TaskId,\n         turbo_tasks: &'l dyn TurboTasksBackendApi<TurboTasksBackend<B>>,\n     ) {\n@@ -426,7 +426,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n \n     fn connect_child(\n         &self,\n-        parent_task: TaskId,\n+        parent_task: Option<TaskId>,\n         child_task: TaskId,\n         turbo_tasks: &dyn TurboTasksBackendApi<TurboTasksBackend<B>>,\n     ) {\n@@ -444,9 +444,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         consistency: ReadConsistency,\n         turbo_tasks: &dyn TurboTasksBackendApi<TurboTasksBackend<B>>,\n     ) -> Result<Result<RawVc, EventListener>> {\n-        if let Some(reader) = reader {\n-            self.assert_not_persistent_calling_transient(reader, task_id, /* cell_id */ None);\n-        }\n+        self.assert_not_persistent_calling_transient(reader, task_id, /* cell_id */ None);\n \n         let mut ctx = self.execute_context(turbo_tasks);\n         let mut task = ctx.task(task_id, TaskDataCategory::All);\n@@ -754,9 +752,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         options: ReadCellOptions,\n         turbo_tasks: &dyn TurboTasksBackendApi<TurboTasksBackend<B>>,\n     ) -> Result<Result<TypedCellContent, EventListener>> {\n-        if let Some(reader) = reader {\n-            self.assert_not_persistent_calling_transient(reader, task_id, Some(cell));\n-        }\n+        self.assert_not_persistent_calling_transient(reader, task_id, Some(cell));\n \n         fn add_cell_dependency<B: BackingStorage>(\n             backend: &TurboTasksBackendInner<B>,\n@@ -1268,7 +1264,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n     fn get_or_create_persistent_task(\n         &self,\n         task_type: CachedTaskType,\n-        parent_task: TaskId,\n+        parent_task: Option<TaskId>,\n         turbo_tasks: &dyn TurboTasksBackendApi<TurboTasksBackend<B>>,\n     ) -> TaskId {\n         if let Some(task_id) = self.task_cache.lookup_forward(&task_type) {\n@@ -1328,10 +1324,12 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n     fn get_or_create_transient_task(\n         &self,\n         task_type: CachedTaskType,\n-        parent_task: TaskId,\n+        parent_task: Option<TaskId>,\n         turbo_tasks: &dyn TurboTasksBackendApi<TurboTasksBackend<B>>,\n     ) -> TaskId {\n-        if !parent_task.is_transient() {\n+        if let Some(parent_task) = parent_task\n+            && !parent_task.is_transient()\n+        {\n             self.panic_persistent_calling_transient(\n                 self.lookup_task_type(parent_task).as_deref(),\n                 Some(&task_type),\n@@ -2264,7 +2262,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         &self,\n         task_id: TaskId,\n         collectible_type: TraitTypeId,\n-        reader_id: TaskId,\n+        reader_id: Option<TaskId>,\n         turbo_tasks: &dyn TurboTasksBackendApi<TurboTasksBackend<B>>,\n     ) -> AutoMap<RawVc, i32, BuildHasherDefault<FxHasher>, 1> {\n         let mut ctx = self.execute_context(turbo_tasks);\n@@ -2312,13 +2310,15 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                     .entry(RawVc::TaskCell(collectible.task, collectible.cell))\n                     .or_insert(0) += count;\n             }\n-            let _ = task.add(CachedDataItem::CollectiblesDependent {\n-                collectible_type,\n-                task: reader_id,\n-                value: (),\n-            });\n+            if let Some(reader_id) = reader_id {\n+                let _ = task.add(CachedDataItem::CollectiblesDependent {\n+                    collectible_type,\n+                    task: reader_id,\n+                    value: (),\n+                });\n+            }\n         }\n-        {\n+        if let Some(reader_id) = reader_id {\n             let mut reader = ctx.task(reader_id, TaskDataCategory::Data);\n             let target = CollectiblesRef {\n                 task: task_id,\n@@ -2480,7 +2480,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n     fn connect_task(\n         &self,\n         task: TaskId,\n-        parent_task: TaskId,\n+        parent_task: Option<TaskId>,\n         turbo_tasks: &dyn TurboTasksBackendApi<TurboTasksBackend<B>>,\n     ) {\n         self.assert_not_persistent_calling_transient(parent_task, task, None);\n@@ -2737,13 +2737,15 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n \n     fn assert_not_persistent_calling_transient(\n         &self,\n-        parent_id: TaskId,\n+        parent_id: Option<TaskId>,\n         child_id: TaskId,\n         cell_id: Option<CellId>,\n     ) {\n-        if !parent_id.is_transient() && child_id.is_transient() {\n+        if !parent_id.is_none_or(|id| id.is_transient()) && child_id.is_transient() {\n             self.panic_persistent_calling_transient(\n-                self.lookup_task_type(parent_id).as_deref(),\n+                parent_id\n+                    .and_then(|id| self.lookup_task_type(id))\n+                    .as_deref(),\n                 self.lookup_task_type(child_id).as_deref(),\n                 cell_id,\n             );\n@@ -2828,7 +2830,7 @@ impl<B: BackingStorage> Backend for TurboTasksBackend<B> {\n     fn get_or_create_persistent_task(\n         &self,\n         task_type: CachedTaskType,\n-        parent_task: TaskId,\n+        parent_task: Option<TaskId>,\n         turbo_tasks: &dyn TurboTasksBackendApi<Self>,\n     ) -> TaskId {\n         self.0\n@@ -2838,7 +2840,7 @@ impl<B: BackingStorage> Backend for TurboTasksBackend<B> {\n     fn get_or_create_transient_task(\n         &self,\n         task_type: CachedTaskType,\n-        parent_task: TaskId,\n+        parent_task: Option<TaskId>,\n         turbo_tasks: &dyn TurboTasksBackendApi<Self>,\n     ) -> TaskId {\n         self.0\n@@ -2928,45 +2930,24 @@ impl<B: BackingStorage> Backend for TurboTasksBackend<B> {\n     fn try_read_task_output(\n         &self,\n         task_id: TaskId,\n-        reader: TaskId,\n-        consistency: ReadConsistency,\n-        turbo_tasks: &dyn TurboTasksBackendApi<Self>,\n-    ) -> Result<Result<RawVc, EventListener>> {\n-        self.0\n-            .try_read_task_output(task_id, Some(reader), consistency, turbo_tasks)\n-    }\n-\n-    fn try_read_task_output_untracked(\n-        &self,\n-        task_id: TaskId,\n+        reader: Option<TaskId>,\n         consistency: ReadConsistency,\n         turbo_tasks: &dyn TurboTasksBackendApi<Self>,\n     ) -> Result<Result<RawVc, EventListener>> {\n         self.0\n-            .try_read_task_output(task_id, None, consistency, turbo_tasks)\n+            .try_read_task_output(task_id, reader, consistency, turbo_tasks)\n     }\n \n     fn try_read_task_cell(\n         &self,\n         task_id: TaskId,\n         cell: CellId,\n-        reader: TaskId,\n-        options: ReadCellOptions,\n-        turbo_tasks: &dyn TurboTasksBackendApi<Self>,\n-    ) -> Result<Result<TypedCellContent, EventListener>> {\n-        self.0\n-            .try_read_task_cell(task_id, Some(reader), cell, options, turbo_tasks)\n-    }\n-\n-    fn try_read_task_cell_untracked(\n-        &self,\n-        task_id: TaskId,\n-        cell: CellId,\n+        reader: Option<TaskId>,\n         options: ReadCellOptions,\n         turbo_tasks: &dyn TurboTasksBackendApi<Self>,\n     ) -> Result<Result<TypedCellContent, EventListener>> {\n         self.0\n-            .try_read_task_cell(task_id, None, cell, options, turbo_tasks)\n+            .try_read_task_cell(task_id, reader, cell, options, turbo_tasks)\n     }\n \n     fn try_read_own_task_cell_untracked(\n@@ -2984,7 +2965,7 @@ impl<B: BackingStorage> Backend for TurboTasksBackend<B> {\n         &self,\n         task_id: TaskId,\n         collectible_type: TraitTypeId,\n-        reader: TaskId,\n+        reader: Option<TaskId>,\n         turbo_tasks: &dyn TurboTasksBackendApi<Self>,\n     ) -> AutoMap<RawVc, i32, BuildHasherDefault<FxHasher>, 1> {\n         self.0\n@@ -3056,7 +3037,7 @@ impl<B: BackingStorage> Backend for TurboTasksBackend<B> {\n         parent_task: TaskId,\n         turbo_tasks: &dyn TurboTasksBackendApi<Self>,\n     ) {\n-        self.0.connect_task(task, parent_task, turbo_tasks);\n+        self.0.connect_task(task, Some(parent_task), turbo_tasks);\n     }\n \n     fn create_transient_task("
        },
        {
            "sha": "e19766f28a6ef5a086fbd0f3463b9fbd6163c619",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/connect_child.rs",
            "status": "modified",
            "additions": 25,
            "deletions": 19,
            "changes": 44,
            "blob_url": "https://github.com/vercel/next.js/blob/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fconnect_child.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fconnect_child.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fconnect_child.rs?ref=c4603d2abe7ed8f70843bd62ddeae391b558e9c4",
            "patch": "@@ -23,31 +23,37 @@ pub enum ConnectChildOperation {\n }\n \n impl ConnectChildOperation {\n-    pub fn run(parent_task_id: TaskId, child_task_id: TaskId, mut ctx: impl ExecuteContext) {\n-        let mut parent_task = ctx.task(parent_task_id, TaskDataCategory::All);\n-        let Some(InProgressState::InProgress(box InProgressStateInner { new_children, .. })) =\n-            get_mut!(parent_task, InProgress)\n-        else {\n-            panic!(\"Task is not in progress while calling another task\");\n-        };\n+    pub fn run(\n+        parent_task_id: Option<TaskId>,\n+        child_task_id: TaskId,\n+        mut ctx: impl ExecuteContext,\n+    ) {\n+        if let Some(parent_task_id) = parent_task_id {\n+            let mut parent_task = ctx.task(parent_task_id, TaskDataCategory::All);\n+            let Some(InProgressState::InProgress(box InProgressStateInner {\n+                new_children, ..\n+            })) = get_mut!(parent_task, InProgress)\n+            else {\n+                panic!(\"Task is not in progress while calling another task\");\n+            };\n \n-        // Quick skip if the child was already connected before\n-        if !new_children.insert(child_task_id) {\n-            return;\n-        }\n+            // Quick skip if the child was already connected before\n+            if !new_children.insert(child_task_id) {\n+                return;\n+            }\n \n-        if parent_task.has_key(&CachedDataItemKey::Child {\n-            task: child_task_id,\n-        }) {\n-            // It is already connected, we can skip the rest\n-            return;\n+            if parent_task.has_key(&CachedDataItemKey::Child {\n+                task: child_task_id,\n+            }) {\n+                // It is already connected, we can skip the rest\n+                return;\n+            }\n         }\n-        drop(parent_task);\n \n         let mut queue = AggregationUpdateQueue::new();\n \n         // Handle the transient to persistent boundary by making the persistent task a root task\n-        if parent_task_id.is_transient() && !child_task_id.is_transient() {\n+        if parent_task_id.is_none_or(|id| id.is_transient()) && !child_task_id.is_transient() {\n             queue.push(AggregationUpdateJob::UpdateAggregationNumber {\n                 task_id: child_task_id,\n                 base_aggregation_number: u32::MAX,\n@@ -56,7 +62,7 @@ impl ConnectChildOperation {\n         }\n \n         // Immutable tasks cannot be invalidated, meaning that we never reschedule them.\n-        if ctx.should_track_activeness() {\n+        if ctx.should_track_activeness() && parent_task_id.is_some() {\n             queue.push(AggregationUpdateJob::IncreaseActiveCount {\n                 task: child_task_id,\n             });"
        },
        {
            "sha": "cab243e6c819180161c03d2d1ceacea765cc0c5b",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/all_in_one.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fall_in_one.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fall_in_one.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fall_in_one.rs?ref=c4603d2abe7ed8f70843bd62ddeae391b558e9c4",
            "patch": "@@ -5,13 +5,13 @@\n use anyhow::{Result, bail};\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{ResolvedVc, TaskInput, ValueToString, Vc};\n-use turbo_tasks_testing::{Registration, register, run};\n+use turbo_tasks_testing::{Registration, register, run_once};\n \n static REGISTRATION: Registration = register!();\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn all_in_one() {\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         let a: Vc<u32> = Vc::cell(4242);\n         assert_eq!(*a.await?, 4242);\n "
        },
        {
            "sha": "4f5ade278059b010e0679f662e46e46aff4d8d5e",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/basic.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fbasic.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fbasic.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fbasic.rs?ref=c4603d2abe7ed8f70843bd62ddeae391b558e9c4",
            "patch": "@@ -4,13 +4,13 @@\n \n use anyhow::Result;\n use turbo_tasks::Vc;\n-use turbo_tasks_testing::{Registration, register, run};\n+use turbo_tasks_testing::{Registration, register, run_once};\n \n static REGISTRATION: Registration = register!();\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn basic() {\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         let output1 = func_without_args();\n         assert_eq!(output1.await?.value, 123);\n "
        },
        {
            "sha": "5f81a317a2d765b065588c659860fe5250f0d145",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/bug.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fbug.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fbug.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fbug.rs?ref=c4603d2abe7ed8f70843bd62ddeae391b558e9c4",
            "patch": "@@ -5,7 +5,7 @@\n use anyhow::Result;\n use serde::{Deserialize, Serialize};\n use turbo_tasks::{NonLocalValue, Vc, trace::TraceRawVcs};\n-use turbo_tasks_testing::{Registration, register, run};\n+use turbo_tasks_testing::{Registration, register, run_once};\n \n static REGISTRATION: Registration = register!();\n \n@@ -27,7 +27,7 @@ struct TasksSpec(Vec<TaskSpec>);\n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn graph_bug() {\n     // see https://github.com/vercel/next.js/pull/79451\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         let spec = vec![\n             TaskSpec {\n                 references: vec!["
        },
        {
            "sha": "1c175e44ac6ae52eed06354fe5bebf447f7eb67a",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/bug2.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fbug2.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fbug2.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fbug2.rs?ref=c4603d2abe7ed8f70843bd62ddeae391b558e9c4",
            "patch": "@@ -7,7 +7,7 @@ use std::sync::Arc;\n use anyhow::Result;\n use serde::{Deserialize, Serialize};\n use turbo_tasks::{NonLocalValue, State, TaskInput, Vc, trace::TraceRawVcs};\n-use turbo_tasks_testing::{Registration, register, run};\n+use turbo_tasks_testing::{Registration, register, run_once};\n \n static REGISTRATION: Registration = register!();\n \n@@ -35,7 +35,7 @@ struct Iteration(State<usize>);\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn graph_bug() {\n-    run(&REGISTRATION, move || async move {\n+    run_once(&REGISTRATION, move || async move {\n         let spec = vec![\n             TaskSpec {\n                 references: vec![TaskReferenceSpec {"
        },
        {
            "sha": "5d496dc71f1f183031ac583de85dbf2fb50ff37a",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/call_types.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fcall_types.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fcall_types.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fcall_types.rs?ref=c4603d2abe7ed8f70843bd62ddeae391b558e9c4",
            "patch": "@@ -4,13 +4,13 @@\n \n use anyhow::Result;\n use turbo_tasks::Vc;\n-use turbo_tasks_testing::{Registration, register, run};\n+use turbo_tasks_testing::{Registration, register, run_once};\n \n static REGISTRATION: Registration = register!();\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn functions() {\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         assert_eq!(*fn_plain().await?, 42);\n         assert_eq!(*fn_arg(43).await?, 43);\n         assert_eq!(*fn_vc_arg(Vc::cell(44)).await?, 44);\n@@ -55,7 +55,7 @@ async fn async_fn_vc_arg(n: Vc<u32>) -> Result<Vc<u32>> {\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn methods() {\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         assert_eq!(*Value::static_method().await?, 42);\n         assert_eq!(*Value::async_static_method().await?, 42);\n \n@@ -108,7 +108,7 @@ impl Value {\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn trait_methods() {\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         assert_eq!(*Value::static_trait_method().await?, 42);\n         assert_eq!(*Value::async_static_trait_method().await?, 42);\n "
        },
        {
            "sha": "b7e8fe7977ef978cf61f0de318fd69dd297071b0",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/collectibles.rs",
            "status": "modified",
            "additions": 8,
            "deletions": 8,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fcollectibles.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fcollectibles.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fcollectibles.rs?ref=c4603d2abe7ed8f70843bd62ddeae391b558e9c4",
            "patch": "@@ -10,13 +10,13 @@ use rustc_hash::FxHashSet;\n use tokio::time::sleep;\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{CollectiblesSource, ResolvedVc, ValueToString, Vc, emit};\n-use turbo_tasks_testing::{Registration, register, run};\n+use turbo_tasks_testing::{Registration, register, run_once};\n \n static REGISTRATION: Registration = register!();\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn transitive_emitting() {\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         let result_op = my_transitive_emitting_function(rcstr!(\"\"), rcstr!(\"\"));\n         let result_val = result_op.connect().strongly_consistent().await?;\n         let list = result_op.peek_collectibles::<Box<dyn ValueToString>>();\n@@ -34,7 +34,7 @@ async fn transitive_emitting() {\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn transitive_emitting_indirect() {\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         let result_op = my_transitive_emitting_function(rcstr!(\"\"), rcstr!(\"\"));\n         let collectibles_op = my_transitive_emitting_function_collectibles(rcstr!(\"\"), rcstr!(\"\"));\n         let list = collectibles_op.connect().strongly_consistent().await?;\n@@ -52,7 +52,7 @@ async fn transitive_emitting_indirect() {\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn multi_emitting() {\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         let result_op = my_multi_emitting_function();\n         let result_val = result_op.connect().strongly_consistent().await?;\n         let list = result_op.peek_collectibles::<Box<dyn ValueToString>>();\n@@ -70,7 +70,7 @@ async fn multi_emitting() {\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn taking_collectibles() {\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         let result_op = my_collecting_function();\n         let result_val = result_op.connect().strongly_consistent().await?;\n         let list = result_op.take_collectibles::<Box<dyn ValueToString>>();\n@@ -86,7 +86,7 @@ async fn taking_collectibles() {\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn taking_collectibles_extra_layer() {\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         let result_op = my_collecting_function_indirect();\n         let result_val = result_op.connect().strongly_consistent().await?;\n         let list = result_op.take_collectibles::<Box<dyn ValueToString>>();\n@@ -102,7 +102,7 @@ async fn taking_collectibles_extra_layer() {\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn taking_collectibles_parallel() {\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         let result_op = my_transitive_emitting_function(rcstr!(\"\"), rcstr!(\"a\"));\n         let result_val = result_op.connect().strongly_consistent().await?;\n         let list = result_op.take_collectibles::<Box<dyn ValueToString>>();\n@@ -144,7 +144,7 @@ async fn taking_collectibles_parallel() {\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn taking_collectibles_with_resolve() {\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         let result_op = my_transitive_emitting_function_with_resolve(rcstr!(\"resolve\"));\n         result_op.connect().strongly_consistent().await?;\n         let list = result_op.take_collectibles::<Box<dyn ValueToString>>();"
        },
        {
            "sha": "2a992aa8d690d81e8fcf70363aa4b1b651806f31",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/debug.rs",
            "status": "modified",
            "additions": 10,
            "deletions": 10,
            "changes": 20,
            "blob_url": "https://github.com/vercel/next.js/blob/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fdebug.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fdebug.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fdebug.rs?ref=c4603d2abe7ed8f70843bd62ddeae391b558e9c4",
            "patch": "@@ -5,13 +5,13 @@\n use std::sync::Mutex;\n \n use turbo_tasks::{ResolvedVc, Vc, debug::ValueDebug};\n-use turbo_tasks_testing::{Registration, register, run};\n+use turbo_tasks_testing::{Registration, register, run_once};\n \n static REGISTRATION: Registration = register!();\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn primitive_debug() {\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         let a: Vc<u32> = Vc::cell(42);\n         assert_eq!(format!(\"{:?}\", a.dbg().await?), \"42\");\n         anyhow::Ok(())\n@@ -22,7 +22,7 @@ async fn primitive_debug() {\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn transparent_debug() {\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         let a: Vc<Transparent> = Transparent(42).cell();\n         assert_eq!(format!(\"{:?}\", a.dbg().await?), \"42\");\n \n@@ -34,7 +34,7 @@ async fn transparent_debug() {\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn enum_none_debug() {\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         let a: Vc<Enum> = Enum::None.cell();\n         assert_eq!(format!(\"{:?}\", a.dbg().await?), \"Enum :: None\");\n \n@@ -46,7 +46,7 @@ async fn enum_none_debug() {\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn enum_transparent_debug() {\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         let a: Vc<Enum> = Enum::Transparent(Transparent(42).resolved_cell()).cell();\n         assert_eq!(\n             format!(\"{:?}\", a.dbg().await?),\n@@ -62,7 +62,7 @@ async fn enum_transparent_debug() {\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn enum_inner_vc_debug() {\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         let a: Vc<Enum> = Enum::Enum(Enum::None.resolved_cell()).cell();\n         assert_eq!(\n             format!(\"{:?}\", a.dbg().await?),\n@@ -78,7 +78,7 @@ async fn enum_inner_vc_debug() {\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn struct_unit_debug() {\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         let a: Vc<StructUnit> = StructUnit.cell();\n         assert_eq!(format!(\"{:?}\", a.dbg().await?), \"StructUnit\");\n         anyhow::Ok(())\n@@ -89,7 +89,7 @@ async fn struct_unit_debug() {\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn struct_transparent_debug() {\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         let a: Vc<StructWithTransparent> = StructWithTransparent {\n             transparent: Transparent(42).resolved_cell(),\n         }\n@@ -108,7 +108,7 @@ async fn struct_transparent_debug() {\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn struct_vec_debug() {\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         let a: Vc<StructWithVec> = StructWithVec { vec: vec![] }.cell();\n         assert_eq!(\n             format!(\"{:?}\", a.dbg().await?),\n@@ -137,7 +137,7 @@ async fn struct_vec_debug() {\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn struct_ignore_debug() {\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         let a: Vc<StructWithIgnore> = StructWithIgnore {\n             dont_ignore: 42,\n             ignore: Mutex::new(()),"
        },
        {
            "sha": "3e6a893c16181ae9d3e8d149d0ddf8de38a9ec86",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/detached.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fdetached.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fdetached.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fdetached.rs?ref=c4603d2abe7ed8f70843bd62ddeae391b558e9c4",
            "patch": "@@ -11,13 +11,13 @@ use turbo_tasks::{\n     trace::{TraceRawVcs, TraceRawVcsContext},\n     turbo_tasks,\n };\n-use turbo_tasks_testing::{Registration, register, run};\n+use turbo_tasks_testing::{Registration, register, run_once};\n \n static REGISTRATION: Registration = register!();\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn test_spawns_detached() -> anyhow::Result<()> {\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         // HACK: The watch channel we use has an incorrect implementation of `TraceRawVcs`, just\n         // disable GC for the test so this can't cause any problems.\n         prevent_gc();\n@@ -84,7 +84,7 @@ async fn spawns_detached(\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn test_spawns_detached_changing() -> anyhow::Result<()> {\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         // HACK: The watch channel we use has an incorrect implementation of `TraceRawVcs`\n         prevent_gc();\n         // timeout: prevent the test from hanging, and fail instead if this is broken"
        },
        {
            "sha": "d8d455afef1da3c5a4d2981e64f734998f4d7e6c",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/dirty_in_progress.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fdirty_in_progress.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fdirty_in_progress.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fdirty_in_progress.rs?ref=c4603d2abe7ed8f70843bd62ddeae391b558e9c4",
            "patch": "@@ -7,13 +7,13 @@ use std::time::Duration;\n use anyhow::{Result, bail};\n use turbo_rcstr::RcStr;\n use turbo_tasks::{CollectiblesSource, ResolvedVc, State, ValueToString, Vc, emit};\n-use turbo_tasks_testing::{Registration, register, run};\n+use turbo_tasks_testing::{Registration, register, run_once};\n \n static REGISTRATION: Registration = register!();\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn dirty_in_progress() {\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         let cases = [\n             (1, 3, 2, 2, \"\"),\n             (11, 13, 12, 42, \"12\"),"
        },
        {
            "sha": "d10af67b3e28edba04f584f472ce5371ab224a4c",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/emptied_cells.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Femptied_cells.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Femptied_cells.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Femptied_cells.rs?ref=c4603d2abe7ed8f70843bd62ddeae391b558e9c4",
            "patch": "@@ -4,13 +4,13 @@\n \n use anyhow::Result;\n use turbo_tasks::{State, Vc};\n-use turbo_tasks_testing::{Registration, register, run};\n+use turbo_tasks_testing::{Registration, register, run_once};\n \n static REGISTRATION: Registration = register!();\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn recompute() {\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         let input = ChangingInput {\n             state: State::new(1),\n         }"
        },
        {
            "sha": "b0b67e969e0227816b7f7aa25914aaa7204176dc",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/filter_unused_args.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ffilter_unused_args.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ffilter_unused_args.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ffilter_unused_args.rs?ref=c4603d2abe7ed8f70843bd62ddeae391b558e9c4",
            "patch": "@@ -4,13 +4,13 @@\n \n use anyhow::Result;\n use turbo_tasks::Vc;\n-use turbo_tasks_testing::{Registration, register, run};\n+use turbo_tasks_testing::{Registration, register, run_once};\n \n static REGISTRATION: Registration = register!();\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn filtered_trait_method_args() -> Result<()> {\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         let uses_arg = UsesArg.cell();\n         assert_eq!(\n             uses_arg.method_with_arg(0).to_resolved().await?,"
        },
        {
            "sha": "6f17dc31b145b40365e66e7e3327f84fa84cc360",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/immutable.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fimmutable.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fimmutable.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fimmutable.rs?ref=c4603d2abe7ed8f70843bd62ddeae391b558e9c4",
            "patch": "@@ -4,13 +4,13 @@\n \n use anyhow::Result;\n use turbo_tasks::{State, Vc};\n-use turbo_tasks_testing::{Registration, register, run};\n+use turbo_tasks_testing::{Registration, register, run_once};\n \n static REGISTRATION: Registration = register!();\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn hidden_mutate() {\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         let input = create_input().resolve().await?;\n         input.await?.state.set(1);\n         let changing_value = compute(input);"
        },
        {
            "sha": "d704546f0de747e74678d76482c7155cfb853e58",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/local_tasks.rs",
            "status": "modified",
            "additions": 18,
            "deletions": 13,
            "changes": 31,
            "blob_url": "https://github.com/vercel/next.js/blob/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Flocal_tasks.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Flocal_tasks.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Flocal_tasks.rs?ref=c4603d2abe7ed8f70843bd62ddeae391b558e9c4",
            "patch": "@@ -4,31 +4,36 @@\n \n use anyhow::Result;\n use turbo_tasks::{Vc, test_helpers::current_task_for_testing};\n-use turbo_tasks_testing::{Registration, register, run};\n+use turbo_tasks_testing::{Registration, register, run_once};\n \n static REGISTRATION: Registration = register!();\n \n+fn task_id() -> u32 {\n+    if let Some(id) = current_task_for_testing() {\n+        *id\n+    } else {\n+        0\n+    }\n+}\n+\n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn test_local_task_id() -> Result<()> {\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         let local_vc = get_local_task_id();\n         assert!(local_vc.is_local());\n-        assert_eq!(*local_vc.await.unwrap(), *current_task_for_testing());\n+        assert_eq!(*local_vc.await.unwrap(), task_id());\n \n         let local_trait_vc = Foo {}.cell().get_local_task_id();\n         assert!(local_trait_vc.is_local());\n-        assert_eq!(*local_trait_vc.await.unwrap(), *current_task_for_testing());\n+        assert_eq!(*local_trait_vc.await.unwrap(), task_id());\n \n         let non_local_vc = get_non_local_task_id();\n         assert!(!non_local_vc.is_local());\n-        assert_ne!(*non_local_vc.await.unwrap(), *current_task_for_testing());\n+        assert_ne!(*non_local_vc.await.unwrap(), task_id());\n \n         let non_local_trait_vc = Foo {}.cell().get_non_local_task_id();\n         assert!(!non_local_trait_vc.is_local());\n-        assert_ne!(\n-            *non_local_trait_vc.await.unwrap(),\n-            *current_task_for_testing()\n-        );\n+        assert_ne!(*non_local_trait_vc.await.unwrap(), task_id());\n \n         Ok(())\n     })\n@@ -37,12 +42,12 @@ async fn test_local_task_id() -> Result<()> {\n \n #[turbo_tasks::function(local)]\n fn get_local_task_id() -> Vc<u32> {\n-    Vc::cell(*current_task_for_testing())\n+    Vc::cell(task_id())\n }\n \n #[turbo_tasks::function]\n fn get_non_local_task_id() -> Vc<u32> {\n-    Vc::cell(*current_task_for_testing())\n+    Vc::cell(task_id())\n }\n \n #[turbo_tasks::value_trait]\n@@ -59,11 +64,11 @@ struct Foo {}\n impl SomeTrait for Foo {\n     #[turbo_tasks::function(local)]\n     fn get_local_task_id(self: Vc<Self>) -> Vc<u32> {\n-        Vc::cell(*current_task_for_testing())\n+        Vc::cell(task_id())\n     }\n \n     #[turbo_tasks::function]\n     fn get_non_local_task_id(self: Vc<Self>) -> Vc<u32> {\n-        Vc::cell(*current_task_for_testing())\n+        Vc::cell(task_id())\n     }\n }"
        },
        {
            "sha": "7d626e78eeb77c9dc747ceac802b40aa74952f5f",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/panics.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fpanics.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fpanics.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fpanics.rs?ref=c4603d2abe7ed8f70843bd62ddeae391b558e9c4",
            "patch": "@@ -14,7 +14,7 @@ use turbo_tasks::{\n     backend::TurboTasksExecutionError,\n     panic_hooks::{handle_panic, register_panic_hook},\n };\n-use turbo_tasks_testing::{Registration, register, run_without_cache_check};\n+use turbo_tasks_testing::{Registration, register, run_once_without_cache_check};\n \n static REGISTRATION: Registration = register!();\n \n@@ -40,7 +40,8 @@ async fn test_panic_hook() {\n     });\n \n     let result =\n-        run_without_cache_check(&REGISTRATION, async move { anyhow::Ok(*double(3).await?) }).await;\n+        run_once_without_cache_check(&REGISTRATION, async move { anyhow::Ok(*double(3).await?) })\n+            .await;\n \n     assert!(hook_was_called.load(Ordering::SeqCst));\n "
        },
        {
            "sha": "111c1a22de9dac43f3ac182ca0e6006cb81954aa",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/performance.rs",
            "status": "modified",
            "additions": 12,
            "deletions": 12,
            "changes": 24,
            "blob_url": "https://github.com/vercel/next.js/blob/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fperformance.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fperformance.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fperformance.rs?ref=c4603d2abe7ed8f70843bd62ddeae391b558e9c4",
            "patch": "@@ -6,7 +6,7 @@ use std::{future::Future, time::Duration};\n \n use anyhow::Result;\n use turbo_tasks::{TransientInstance, Vc};\n-use turbo_tasks_testing::{Registration, register, run};\n+use turbo_tasks_testing::{Registration, register, run_once};\n \n static REGISTRATION: Registration = register!();\n \n@@ -147,7 +147,7 @@ async fn many_calls_to_many_children() {\n     if check_skip() {\n         return;\n     }\n-    run(&REGISTRATION, || {\n+    run_once(&REGISTRATION, || {\n         run_test(\n             || calls_many_children(TransientInstance::new(()), None).strongly_consistent(),\n             Duration::from_micros(100),\n@@ -162,7 +162,7 @@ async fn many_calls_to_uncached_many_children() {\n     if check_skip() {\n         return;\n     }\n-    run(&REGISTRATION, || {\n+    run_once(&REGISTRATION, || {\n         run_test(\n             || {\n                 calls_many_children(TransientInstance::new(()), Some(TransientInstance::new(())))\n@@ -194,7 +194,7 @@ async fn many_calls_to_big_graph_1() {\n     if check_skip() {\n         return;\n     }\n-    run(&REGISTRATION, || run_big_graph_test(vec![5, 8, 10, 15, 20]))\n+    run_once(&REGISTRATION, || run_big_graph_test(vec![5, 8, 10, 15, 20]))\n         .await\n         .unwrap();\n }\n@@ -204,7 +204,7 @@ async fn many_calls_to_big_graph_2() {\n     if check_skip() {\n         return;\n     }\n-    run(&REGISTRATION, || {\n+    run_once(&REGISTRATION, || {\n         run_big_graph_test(vec![2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2])\n     })\n     .await\n@@ -216,7 +216,7 @@ async fn many_calls_to_big_graph_3() {\n     if check_skip() {\n         return;\n     }\n-    run(&REGISTRATION, || run_big_graph_test(vec![1000, 3, 3, 3, 3]))\n+    run_once(&REGISTRATION, || run_big_graph_test(vec![1000, 3, 3, 3, 3]))\n         .await\n         .unwrap();\n }\n@@ -226,7 +226,7 @@ async fn many_calls_to_big_graph_4() {\n     if check_skip() {\n         return;\n     }\n-    run(&REGISTRATION, || run_big_graph_test(vec![3, 3, 3, 3, 1000]))\n+    run_once(&REGISTRATION, || run_big_graph_test(vec![3, 3, 3, 3, 1000]))\n         .await\n         .unwrap();\n }\n@@ -236,7 +236,7 @@ async fn many_calls_to_big_graph_5() {\n     if check_skip() {\n         return;\n     }\n-    run(&REGISTRATION, || {\n+    run_once(&REGISTRATION, || {\n         run_big_graph_test(vec![10, 10, 10, 10, 10])\n     })\n     .await\n@@ -248,7 +248,7 @@ async fn many_calls_to_big_graph_6() {\n     if check_skip() {\n         return;\n     }\n-    run(&REGISTRATION, || {\n+    run_once(&REGISTRATION, || {\n         run_big_graph_test(vec![2, 2, 2, 1000, 2, 2, 2])\n     })\n     .await\n@@ -260,7 +260,7 @@ async fn many_calls_to_big_graph_7() {\n     if check_skip() {\n         return;\n     }\n-    run(&REGISTRATION, || {\n+    run_once(&REGISTRATION, || {\n         run_big_graph_test(vec![\n             1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 3, 2, 1, 1, 1, 1, 5, 1, 1, 1, 200, 2, 1,\n             1, 1, 1, 1, 1, 1, 1, 1,\n@@ -275,7 +275,7 @@ async fn many_calls_to_big_graph_8() {\n     if check_skip() {\n         return;\n     }\n-    run(&REGISTRATION, || {\n+    run_once(&REGISTRATION, || {\n         run_big_graph_test(vec![200, 2, 2, 2, 2, 200])\n     })\n     .await\n@@ -287,7 +287,7 @@ async fn many_calls_to_big_graph_9() {\n     if check_skip() {\n         return;\n     }\n-    run(&REGISTRATION, || {\n+    run_once(&REGISTRATION, || {\n         run_big_graph_test(vec![10000, 1, 1, 2, 1, 1, 2, 2, 1, 1, 1, 1])\n     })\n     .await"
        },
        {
            "sha": "9cb38aceb9031e398c18d0547b30aa1bd6236b61",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/random_change.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Frandom_change.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Frandom_change.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Frandom_change.rs?ref=c4603d2abe7ed8f70843bd62ddeae391b558e9c4",
            "patch": "@@ -5,13 +5,13 @@\n use anyhow::{Result, bail};\n use rand::Rng;\n use turbo_tasks::{State, Vc};\n-use turbo_tasks_testing::{Registration, register, run};\n+use turbo_tasks_testing::{Registration, register, run_once};\n \n static REGISTRATION: Registration = register!();\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn random_change() {\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         let state = make_state();\n         let value = rand::rng().random_range(0..100);\n         state.await?.state.set(value);"
        },
        {
            "sha": "0aa9f3c8966e8332fc1a3f7487008eba21844345",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/read_ref_cell.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fread_ref_cell.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fread_ref_cell.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fread_ref_cell.rs?ref=c4603d2abe7ed8f70843bd62ddeae391b558e9c4",
            "patch": "@@ -6,13 +6,13 @@ use std::{collections::HashSet, mem::take, sync::Mutex};\n \n use anyhow::Result;\n use turbo_tasks::{Invalidator, ReadRef, Vc, get_invalidator};\n-use turbo_tasks_testing::{Registration, register, run};\n+use turbo_tasks_testing::{Registration, register, run_once};\n \n static REGISTRATION: Registration = register!();\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn read_ref() {\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         let counter = Counter::cell(Counter {\n             value: Mutex::new((0, Default::default())),\n         });"
        },
        {
            "sha": "39c2b261b6ff239b77b354b0a73edbd91ac7e3b9",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/recompute.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Frecompute.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Frecompute.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Frecompute.rs?ref=c4603d2abe7ed8f70843bd62ddeae391b558e9c4",
            "patch": "@@ -4,13 +4,13 @@\n \n use anyhow::Result;\n use turbo_tasks::{ResolvedVc, State, Vc};\n-use turbo_tasks_testing::{Registration, register, run};\n+use turbo_tasks_testing::{Registration, register, run_once};\n \n static REGISTRATION: Registration = register!();\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn recompute() {\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         let input = ChangingInput {\n             state: State::new(1),\n         }\n@@ -60,7 +60,7 @@ async fn recompute() {\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn immutable_analysis() {\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         let input = ChangingInput {\n             state: State::new(1),\n         }"
        },
        {
            "sha": "39b3b339a427c94effc1482f49f39796ee2d3564",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/recompute_collectibles.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Frecompute_collectibles.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Frecompute_collectibles.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Frecompute_collectibles.rs?ref=c4603d2abe7ed8f70843bd62ddeae391b558e9c4",
            "patch": "@@ -5,13 +5,13 @@\n use anyhow::{Result, bail};\n use turbo_rcstr::RcStr;\n use turbo_tasks::{CollectiblesSource, ResolvedVc, State, ValueToString, Vc, emit};\n-use turbo_tasks_testing::{Registration, register, run};\n+use turbo_tasks_testing::{Registration, register, run_once};\n \n static REGISTRATION: Registration = register!();\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn recompute() {\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         let input = ChangingInput::new(1).resolve().await?;\n         let input2 = ChangingInput::new(2).resolve().await?;\n         input.await?.state.set(1);"
        },
        {
            "sha": "4535c5d36a3256600d1c2a71b6af0455dac0e023",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/resolved_vc.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fresolved_vc.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fresolved_vc.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fresolved_vc.rs?ref=c4603d2abe7ed8f70843bd62ddeae391b558e9c4",
            "patch": "@@ -4,7 +4,7 @@\n \n use anyhow::Result;\n use turbo_tasks::{ReadRef, ResolvedVc, Vc};\n-use turbo_tasks_testing::{Registration, register, run};\n+use turbo_tasks_testing::{Registration, register, run_once};\n \n static REGISTRATION: Registration = register!();\n \n@@ -25,7 +25,7 @@ fn assert_resolved(input: ResolvedVc<u32>) {\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn test_conversion() -> Result<()> {\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         let unresolved: Vc<u32> = Vc::cell(42);\n         let resolved: ResolvedVc<u32> = unresolved.to_resolved().await?;\n         let _: Vc<u32> = *resolved;\n@@ -40,7 +40,7 @@ async fn test_conversion() -> Result<()> {\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn test_cell_construction() -> Result<()> {\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         let a: ResolvedVc<u32> = ResolvedVc::cell(42);\n         assert_eq!(*a.await?, 42);\n         let b: ResolvedVc<Wrapper> = Wrapper(42).resolved_cell();\n@@ -52,7 +52,7 @@ async fn test_cell_construction() -> Result<()> {\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn test_resolved_vc_as_arg() -> Result<()> {\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         let unresolved: Vc<u32> = returns_int(42);\n         assert!(!unresolved.is_resolved());\n         // calling a function should cause it's arguments to get resolved automatically\n@@ -64,7 +64,7 @@ async fn test_resolved_vc_as_arg() -> Result<()> {\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn test_into_future() -> Result<()> {\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         let mut resolved = ResolvedVc::cell(42);\n         let _: ReadRef<u32> = resolved.await?;\n         let _: ReadRef<u32> = (&resolved).await?;\n@@ -80,7 +80,7 @@ async fn test_into_future() -> Result<()> {\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn test_sidecast() -> Result<()> {\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         let concrete_value = ImplementsAAndB.resolved_cell();\n         let as_a = ResolvedVc::upcast::<Box<dyn TraitA>>(concrete_value);\n         let as_b = ResolvedVc::try_sidecast::<Box<dyn TraitB>>(as_a);"
        },
        {
            "sha": "bc32331d2b603b30b5c9429e05e24c99ccda230d",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/shrink_to_fit.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fshrink_to_fit.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fshrink_to_fit.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fshrink_to_fit.rs?ref=c4603d2abe7ed8f70843bd62ddeae391b558e9c4",
            "patch": "@@ -4,7 +4,7 @@\n \n use anyhow::Result;\n use turbo_tasks::Vc;\n-use turbo_tasks_testing::{Registration, register, run};\n+use turbo_tasks_testing::{Registration, register, run_once};\n \n static REGISTRATION: Registration = register!();\n \n@@ -13,7 +13,7 @@ struct Wrapper(Vec<u32>);\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn test_shrink_to_fit() -> Result<()> {\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         // `Vec::shrink_to_fit` is implicitly called when a cell is constructed.\n         let a: Vc<Wrapper> = Vc::cell(Vec::with_capacity(100));\n         assert_eq!(a.await?.capacity(), 0);"
        },
        {
            "sha": "7d0e9ff2ca95e489945632827bff46b2b7b1c73b",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/trace_transient.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftrace_transient.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftrace_transient.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftrace_transient.rs?ref=c4603d2abe7ed8f70843bd62ddeae391b558e9c4",
            "patch": "@@ -4,7 +4,7 @@\n use anyhow::Result;\n use serde::{Deserialize, Serialize};\n use turbo_tasks::{NonLocalValue, ResolvedVc, TaskInput, Vc, trace::TraceRawVcs};\n-use turbo_tasks_testing::{Registration, register, run_without_cache_check};\n+use turbo_tasks_testing::{Registration, register, run_once_without_cache_check};\n \n static REGISTRATION: Registration = register!();\n \n@@ -20,7 +20,7 @@ Adder::add_method (read cell of type turbo-tasks@turbo_tasks::primitives::u64)\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn test_trace_transient() {\n-    let result = run_without_cache_check(&REGISTRATION, async {\n+    let result = run_once_without_cache_check(&REGISTRATION, async {\n         read_incorrect_task_input_operation(IncorrectTaskInput(\n             Adder::new(Vc::cell(()))\n                 .add_method(Vc::cell(2), Vc::cell(3))"
        },
        {
            "sha": "9b1db6d86c24356a3aff127d4f85e9c4fb54a55a",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/trait_ref_cell.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftrait_ref_cell.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftrait_ref_cell.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftrait_ref_cell.rs?ref=c4603d2abe7ed8f70843bd62ddeae391b558e9c4",
            "patch": "@@ -6,13 +6,13 @@ use std::{collections::HashSet, mem::take, sync::Mutex};\n \n use anyhow::Result;\n use turbo_tasks::{IntoTraitRef, Invalidator, TraitRef, Vc, get_invalidator};\n-use turbo_tasks_testing::{Registration, register, run};\n+use turbo_tasks_testing::{Registration, register, run_once};\n \n static REGISTRATION: Registration = register!();\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn trait_ref() {\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         let counter = Counter::cell(Counter {\n             value: Mutex::new((0, Default::default())),\n         });"
        },
        {
            "sha": "b39c066c11d5aab2a72e1adbf946309eba1aed40",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/trait_ref_cell_mode.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftrait_ref_cell_mode.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftrait_ref_cell_mode.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftrait_ref_cell_mode.rs?ref=c4603d2abe7ed8f70843bd62ddeae391b558e9c4",
            "patch": "@@ -3,15 +3,15 @@\n \n use anyhow::Result;\n use turbo_tasks::{IntoTraitRef, State, TraitRef, Upcast, Vc};\n-use turbo_tasks_testing::{Registration, register, run};\n+use turbo_tasks_testing::{Registration, register, run_once};\n \n static REGISTRATION: Registration = register!();\n \n // Test that with `cell = \"shared\"`, the cell will be re-used as long as the\n // value is equal.\n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn test_trait_ref_shared_cell_mode() {\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         let input = CellIdSelector {\n             value: 42,\n             cell_idx: State::new(0),\n@@ -46,7 +46,7 @@ async fn test_trait_ref_shared_cell_mode() {\n // value is equal.\n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn test_trait_ref_new_cell_mode() {\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         let input = CellIdSelector {\n             value: 42,\n             cell_idx: State::new(0),"
        },
        {
            "sha": "3de197a1e7c4e3e602e348d0eba87863f21b543f",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/transient_collectible.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftransient_collectible.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftransient_collectible.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftransient_collectible.rs?ref=c4603d2abe7ed8f70843bd62ddeae391b558e9c4",
            "patch": "@@ -3,7 +3,7 @@\n \n use serde::{Deserialize, Serialize};\n use turbo_tasks::{NonLocalValue, ResolvedVc, TaskInput, trace::TraceRawVcs};\n-use turbo_tasks_testing::{Registration, register, run_without_cache_check};\n+use turbo_tasks_testing::{Registration, register, run_once_without_cache_check};\n \n static REGISTRATION: Registration = register!();\n \n@@ -12,7 +12,7 @@ const EXPECTED_MSG: &str =\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn test_transient_emit_from_persistent() {\n-    let result = run_without_cache_check(&REGISTRATION, async {\n+    let result = run_once_without_cache_check(&REGISTRATION, async {\n         emit_incorrect_task_input_operation(IncorrectTaskInput(U32Wrapper(123).resolved_cell()))\n             .read_strongly_consistent()\n             .await?;"
        },
        {
            "sha": "f76b206d238ea4c0cb4f53c13e99daac65fd62f9",
            "filename": "turbopack/crates/turbo-tasks-fetch/tests/fetch.rs",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-fetch%2Ftests%2Ffetch.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-fetch%2Ftests%2Ffetch.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fetch%2Ftests%2Ffetch.rs?ref=c4603d2abe7ed8f70843bd62ddeae391b558e9c4",
            "patch": "@@ -9,7 +9,7 @@ use turbo_tasks_fetch::{\n     FetchErrorKind,\n };\n use turbo_tasks_fs::{DiskFileSystem, FileSystem, FileSystemPath};\n-use turbo_tasks_testing::{Registration, register, run};\n+use turbo_tasks_testing::{Registration, register, run_once};\n use turbopack_core::issue::{Issue, IssueSeverity, StyledString};\n \n static REGISTRATION: Registration = register!(turbo_tasks_fetch::register);\n@@ -21,7 +21,7 @@ static GLOBAL_TEST_LOCK: TokioMutex<()> = TokioMutex::const_new(());\n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn basic_get() {\n     let _guard = GLOBAL_TEST_LOCK.lock().await;\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         let mut server = mockito::Server::new_async().await;\n         let resource_mock = server\n             .mock(\"GET\", \"/foo.woff\")\n@@ -52,7 +52,7 @@ async fn basic_get() {\n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn sends_user_agent() {\n     let _guard = GLOBAL_TEST_LOCK.lock().await;\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         let mut server = mockito::Server::new_async().await;\n         let resource_mock = server\n             .mock(\"GET\", \"/foo.woff\")\n@@ -88,7 +88,7 @@ async fn sends_user_agent() {\n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn invalidation_does_not_invalidate() {\n     let _guard = GLOBAL_TEST_LOCK.lock().await;\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         let mut server = mockito::Server::new_async().await;\n         let resource_mock = server\n             .mock(\"GET\", \"/foo.woff\")\n@@ -133,7 +133,7 @@ fn get_issue_context() -> Vc<FileSystemPath> {\n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn errors_on_failed_connection() {\n     let _guard = GLOBAL_TEST_LOCK.lock().await;\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         // Try to connect to port 0 on localhost, which is never valid and immediately returns\n         // `ECONNREFUSED`.\n         // Other values (e.g. domain name, reserved IP address block) may result in long timeouts.\n@@ -164,7 +164,7 @@ async fn errors_on_failed_connection() {\n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn errors_on_404() {\n     let _guard = GLOBAL_TEST_LOCK.lock().await;\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         let mut server = mockito::Server::new_async().await;\n         let resource_mock = server\n             .mock(\"GET\", \"/\")\n@@ -227,7 +227,7 @@ async fn client_cache() {\n     }\n \n     let _guard = GLOBAL_TEST_LOCK.lock().await;\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         __test_only_reqwest_client_cache_clear();\n         assert_eq!(__test_only_reqwest_client_cache_len(), 0);\n "
        },
        {
            "sha": "7fed26c3e5517fe7d575c5e07058b290519686ee",
            "filename": "turbopack/crates/turbo-tasks-macros-tests/tests/task_input.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-macros-tests%2Ftests%2Ftask_input.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-macros-tests%2Ftests%2Ftask_input.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros-tests%2Ftests%2Ftask_input.rs?ref=c4603d2abe7ed8f70843bd62ddeae391b558e9c4",
            "patch": "@@ -5,7 +5,7 @@\n \n use serde::{Deserialize, Serialize};\n use turbo_tasks::{Completion, ReadRef, TaskInput, Vc, trace::TraceRawVcs};\n-use turbo_tasks_testing::{Registration, register, run};\n+use turbo_tasks_testing::{Registration, register, run_once};\n \n static REGISTRATION: Registration = register!();\n \n@@ -20,7 +20,7 @@ fn one_unnamed_field(input: OneUnnamedField) -> Vc<Completion> {\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn tests() {\n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         assert!(ReadRef::ptr_eq(\n             &one_unnamed_field(OneUnnamedField(42)).await?,\n             &Completion::immutable().await?,"
        },
        {
            "sha": "b62acf99db0bd4c55ce998998401e24101aaf4b2",
            "filename": "turbopack/crates/turbo-tasks-macros-tests/tests/value_debug.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-macros-tests%2Ftests%2Fvalue_debug.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-macros-tests%2Ftests%2Fvalue_debug.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros-tests%2Ftests%2Fvalue_debug.rs?ref=c4603d2abe7ed8f70843bd62ddeae391b558e9c4",
            "patch": "@@ -1,7 +1,7 @@\n #![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n \n use turbo_tasks::debug::ValueDebugFormat;\n-use turbo_tasks_testing::{Registration, register, run};\n+use turbo_tasks_testing::{Registration, register, run_once};\n \n static REGISTRATION: Registration = register!();\n \n@@ -19,7 +19,7 @@ async fn ignored_indexes() {\n         i32,\n     );\n \n-    run(&REGISTRATION, || async {\n+    run_once(&REGISTRATION, || async {\n         let input = IgnoredIndexes(-1, 2, -3);\n         let debug = input.value_debug_format(usize::MAX).try_to_string().await?;\n         assert!(!debug.contains(\"-1\"));"
        },
        {
            "sha": "e3a327d1e664834eb9d2199b0bd285e0e7401db7",
            "filename": "turbopack/crates/turbo-tasks-testing/src/lib.rs",
            "status": "modified",
            "additions": 12,
            "deletions": 1,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-testing%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-testing%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-testing%2Fsrc%2Flib.rs?ref=c4603d2abe7ed8f70843bd62ddeae391b558e9c4",
            "patch": "@@ -25,7 +25,9 @@ use turbo_tasks::{\n     util::{SharedError, StaticOrArc},\n };\n \n-pub use crate::run::{Registration, run, run_with_tt, run_without_cache_check};\n+pub use crate::run::{\n+    Registration, run, run_once, run_once_without_cache_check, run_with_tt, run_without_cache_check,\n+};\n \n enum Task {\n     Spawned(Event),\n@@ -118,6 +120,15 @@ impl TurboTasksCallApi for VcStorage {\n         unreachable!()\n     }\n \n+    fn run(\n+        &self,\n+        _future: Pin<Box<dyn Future<Output = Result<()>> + Send + 'static>>,\n+    ) -> Pin<\n+        Box<dyn Future<Output = Result<(), turbo_tasks::backend::TurboTasksExecutionError>> + Send>,\n+    > {\n+        unreachable!()\n+    }\n+\n     fn run_once(\n         &self,\n         _future: std::pin::Pin<Box<dyn Future<Output = Result<()>> + Send + 'static>>,"
        },
        {
            "sha": "cdb2b529fbc6cde355041f18f808581da0cb23e1",
            "filename": "turbopack/crates/turbo-tasks-testing/src/run.rs",
            "status": "modified",
            "additions": 30,
            "deletions": 3,
            "changes": 33,
            "blob_url": "https://github.com/vercel/next.js/blob/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-testing%2Fsrc%2Frun.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks-testing%2Fsrc%2Frun.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-testing%2Fsrc%2Frun.rs?ref=c4603d2abe7ed8f70843bd62ddeae391b558e9c4",
            "patch": "@@ -1,7 +1,7 @@\n use std::{fmt::Debug, future::Future, sync::Arc};\n \n use anyhow::Result;\n-use turbo_tasks::{TurboTasksApi, run_once, trace::TraceRawVcs};\n+use turbo_tasks::{TurboTasksApi, trace::TraceRawVcs};\n \n pub struct Registration {\n     create_turbo_tasks: fn(&str, bool) -> Arc<dyn TurboTasksApi>,\n@@ -35,6 +35,20 @@ macro_rules! register {\n     }};\n }\n \n+pub async fn run_once_without_cache_check<T>(\n+    registration: &Registration,\n+    fut: impl Future<Output = T> + Send + 'static,\n+) -> T\n+where\n+    T: TraceRawVcs + Send + 'static,\n+{\n+    let name = closure_to_name(&fut);\n+    let tt = registration.create_turbo_tasks(&name, true);\n+    turbo_tasks::run_once(tt, async move { Ok(fut.await) })\n+        .await\n+        .unwrap()\n+}\n+\n pub async fn run_without_cache_check<T>(\n     registration: &Registration,\n     fut: impl Future<Output = T> + Send + 'static,\n@@ -44,14 +58,27 @@ where\n {\n     let name = closure_to_name(&fut);\n     let tt = registration.create_turbo_tasks(&name, true);\n-    run_once(tt, async move { Ok(fut.await) }).await.unwrap()\n+    turbo_tasks::run(tt, async move { Ok(fut.await) })\n+        .await\n+        .unwrap()\n }\n \n fn closure_to_name<T>(value: &T) -> String {\n     let name = std::any::type_name_of_val(value);\n     name.replace(\"::{{closure}}\", \"\").replace(\"::\", \"_\")\n }\n \n+pub async fn run_once<T, F>(\n+    registration: &Registration,\n+    fut: impl Fn() -> F + Send + 'static,\n+) -> Result<()>\n+where\n+    F: Future<Output = Result<T>> + Send + 'static,\n+    T: Debug + PartialEq + Eq + TraceRawVcs + Send + 'static,\n+{\n+    run_with_tt(registration, move |tt| turbo_tasks::run_once(tt, fut())).await\n+}\n+\n pub async fn run<T, F>(\n     registration: &Registration,\n     fut: impl Fn() -> F + Send + 'static,\n@@ -60,7 +87,7 @@ where\n     F: Future<Output = Result<T>> + Send + 'static,\n     T: Debug + PartialEq + Eq + TraceRawVcs + Send + 'static,\n {\n-    run_with_tt(registration, move |tt| run_once(tt, fut())).await\n+    run_with_tt(registration, move |tt| turbo_tasks::run(tt, fut())).await\n }\n \n pub async fn run_with_tt<T, F>("
        },
        {
            "sha": "a6fb733cfae311f82d39473107d4d95bd07437ff",
            "filename": "turbopack/crates/turbo-tasks/src/backend.rs",
            "status": "modified",
            "additions": 11,
            "deletions": 24,
            "changes": 35,
            "blob_url": "https://github.com/vercel/next.js/blob/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fbackend.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fbackend.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fbackend.rs?ref=c4603d2abe7ed8f70843bd62ddeae391b558e9c4",
            "patch": "@@ -564,38 +564,23 @@ pub trait Backend: Sync + Send {\n         turbo_tasks: &'a dyn TurboTasksBackendApi<Self>,\n     ) -> Pin<Box<dyn Future<Output = ()> + Send + 'a>>;\n \n+    /// INVALIDATION: Be careful with this, when reader is None, it will not track dependencies, so\n+    /// using it could break cache invalidation.\n     fn try_read_task_output(\n         &self,\n         task: TaskId,\n-        reader: TaskId,\n+        reader: Option<TaskId>,\n         consistency: ReadConsistency,\n         turbo_tasks: &dyn TurboTasksBackendApi<Self>,\n     ) -> Result<Result<RawVc, EventListener>>;\n \n-    /// INVALIDATION: Be careful with this, it will not track dependencies, so\n+    /// INVALIDATION: Be careful with this, when reader is None, it will not track dependencies, so\n     /// using it could break cache invalidation.\n-    fn try_read_task_output_untracked(\n-        &self,\n-        task: TaskId,\n-        consistency: ReadConsistency,\n-        turbo_tasks: &dyn TurboTasksBackendApi<Self>,\n-    ) -> Result<Result<RawVc, EventListener>>;\n-\n     fn try_read_task_cell(\n         &self,\n         task: TaskId,\n         index: CellId,\n-        reader: TaskId,\n-        options: ReadCellOptions,\n-        turbo_tasks: &dyn TurboTasksBackendApi<Self>,\n-    ) -> Result<Result<TypedCellContent, EventListener>>;\n-\n-    /// INVALIDATION: Be careful with this, it will not track dependencies, so\n-    /// using it could break cache invalidation.\n-    fn try_read_task_cell_untracked(\n-        &self,\n-        task: TaskId,\n-        index: CellId,\n+        reader: Option<TaskId>,\n         options: ReadCellOptions,\n         turbo_tasks: &dyn TurboTasksBackendApi<Self>,\n     ) -> Result<Result<TypedCellContent, EventListener>>;\n@@ -609,17 +594,19 @@ pub trait Backend: Sync + Send {\n         options: ReadCellOptions,\n         turbo_tasks: &dyn TurboTasksBackendApi<Self>,\n     ) -> Result<TypedCellContent> {\n-        match self.try_read_task_cell_untracked(current_task, index, options, turbo_tasks)? {\n+        match self.try_read_task_cell(current_task, index, None, options, turbo_tasks)? {\n             Ok(content) => Ok(content),\n             Err(_) => Ok(TypedCellContent(index.type_id, CellContent(None))),\n         }\n     }\n \n+    /// INVALIDATION: Be careful with this, when reader is None, it will not track dependencies, so\n+    /// using it could break cache invalidation.\n     fn read_task_collectibles(\n         &self,\n         task: TaskId,\n         trait_id: TraitTypeId,\n-        reader: TaskId,\n+        reader: Option<TaskId>,\n         turbo_tasks: &dyn TurboTasksBackendApi<Self>,\n     ) -> TaskCollectiblesMap;\n \n@@ -651,14 +638,14 @@ pub trait Backend: Sync + Send {\n     fn get_or_create_persistent_task(\n         &self,\n         task_type: CachedTaskType,\n-        parent_task: TaskId,\n+        parent_task: Option<TaskId>,\n         turbo_tasks: &dyn TurboTasksBackendApi<Self>,\n     ) -> TaskId;\n \n     fn get_or_create_transient_task(\n         &self,\n         task_type: CachedTaskType,\n-        parent_task: TaskId,\n+        parent_task: Option<TaskId>,\n         turbo_tasks: &dyn TurboTasksBackendApi<Self>,\n     ) -> TaskId;\n "
        },
        {
            "sha": "0df1f2d3f67f94101623ebaa2ecf49c23a6f70e4",
            "filename": "turbopack/crates/turbo-tasks/src/lib.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs?ref=c4603d2abe7ed8f70843bd62ddeae391b558e9c4",
            "patch": "@@ -110,8 +110,8 @@ pub use magic_any::MagicAny;\n pub use manager::{\n     CurrentCellRef, ReadConsistency, TaskPersistence, TurboTasks, TurboTasksApi,\n     TurboTasksBackendApi, TurboTasksCallApi, Unused, UpdateInfo, dynamic_call, emit, mark_finished,\n-    mark_root, mark_session_dependent, mark_stateful, prevent_gc, run_once, run_once_with_reason,\n-    trait_call, turbo_tasks, turbo_tasks_scope,\n+    mark_root, mark_session_dependent, mark_stateful, prevent_gc, run, run_once,\n+    run_once_with_reason, trait_call, turbo_tasks, turbo_tasks_scope,\n };\n pub use output::OutputContent;\n pub use raw_vc::{CellId, RawVc, ReadRawVcFuture, ResolveTypeError};"
        },
        {
            "sha": "966d6250daba0e8fefc6cb9be629fbe393eebe51",
            "filename": "turbopack/crates/turbo-tasks/src/manager.rs",
            "status": "modified",
            "additions": 119,
            "deletions": 30,
            "changes": 149,
            "blob_url": "https://github.com/vercel/next.js/blob/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c4603d2abe7ed8f70843bd62ddeae391b558e9c4/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs?ref=c4603d2abe7ed8f70843bd62ddeae391b558e9c4",
            "patch": "@@ -40,7 +40,6 @@ use crate::{\n     task_statistics::TaskStatisticsApi,\n     trace::TraceRawVcs,\n     util::{IdFactory, StaticOrArc},\n-    vc::ReadVcFuture,\n };\n \n /// Common base trait for [`TurboTasksApi`] and [`TurboTasksBackendApi`]. Provides APIs for creating\n@@ -74,6 +73,10 @@ pub trait TurboTasksCallApi: Sync + Send {\n         persistence: TaskPersistence,\n     ) -> RawVc;\n \n+    fn run(\n+        &self,\n+        future: Pin<Box<dyn Future<Output = Result<()>> + Send + 'static>>,\n+    ) -> Pin<Box<dyn Future<Output = Result<(), TurboTasksExecutionError>> + Send>>;\n     fn run_once(\n         &self,\n         future: Pin<Box<dyn Future<Output = Result<()>> + Send + 'static>>,\n@@ -342,7 +345,7 @@ pub struct TurboTasks<B: Backend + 'static> {\n /// - Is potentially cached.\n /// - The backend is aware of.\n struct CurrentTaskState {\n-    task_id: TaskId,\n+    task_id: Option<TaskId>,\n     execution_id: ExecutionId,\n \n     /// True if the current task has state in cells\n@@ -368,7 +371,7 @@ struct CurrentTaskState {\n impl CurrentTaskState {\n     fn new(task_id: TaskId, execution_id: ExecutionId) -> Self {\n         Self {\n-            task_id,\n+            task_id: Some(task_id),\n             execution_id,\n             stateful: false,\n             has_invalidator: false,\n@@ -378,6 +381,18 @@ impl CurrentTaskState {\n         }\n     }\n \n+    fn new_temporary(execution_id: ExecutionId) -> Self {\n+        Self {\n+            task_id: None,\n+            execution_id,\n+            stateful: false,\n+            has_invalidator: false,\n+            cell_counters: None,\n+            local_tasks: Vec::new(),\n+            local_task_tracker: TaskTracker::new(),\n+        }\n+    }\n+\n     fn assert_execution_id(&self, expected_execution_id: ExecutionId) {\n         if self.execution_id != expected_execution_id {\n             panic!(\n@@ -490,7 +505,7 @@ impl<B: Backend + 'static> TurboTasks<B> {\n     /// Creates a new root task, that is only executed once.\n     /// Dependencies will not invalidate the task.\n     #[track_caller]\n-    fn spawn_once_task<T, Fut>(&self, future: Fut) -> TaskId\n+    fn spawn_once_task<T, Fut>(&self, future: Fut)\n     where\n         T: ?Sized,\n         Fut: Future<Output = Result<Vc<T>>> + Send + 'static,\n@@ -503,33 +518,54 @@ impl<B: Backend + 'static> TurboTasks<B> {\n             self,\n         );\n         self.schedule(id);\n-        id\n     }\n \n     pub async fn run_once<T: TraceRawVcs + Send + 'static>(\n         &self,\n         future: impl Future<Output = Result<T>> + Send + 'static,\n     ) -> Result<T> {\n         let (tx, rx) = tokio::sync::oneshot::channel();\n-        let task_id = self.spawn_once_task(async move {\n+        self.spawn_once_task(async move {\n             let result = future.await?;\n             tx.send(result)\n                 .map_err(|_| anyhow!(\"unable to send result\"))?;\n             Ok(Completion::new())\n         });\n-        // INVALIDATION: A Once task will never invalidate, therefore we don't need to\n-        // track a dependency\n-        let raw_result =\n-            read_task_output_untracked(self, task_id, ReadConsistency::Eventual).await?;\n-        turbo_tasks_future_scope(\n-            self.pin(),\n-            ReadVcFuture::<Completion>::from(raw_result.into_read().untracked()),\n-        )\n-        .await?;\n \n         Ok(rx.await?)\n     }\n \n+    pub async fn run<T: TraceRawVcs + Send + 'static>(\n+        &self,\n+        future: impl Future<Output = Result<T>> + Send + 'static,\n+    ) -> Result<T, TurboTasksExecutionError> {\n+        // it's okay for execution ids to overflow and wrap, they're just used for an assert\n+        let execution_id = self.execution_id_factory.wrapping_get();\n+        let current_task_state =\n+            Arc::new(RwLock::new(CurrentTaskState::new_temporary(execution_id)));\n+\n+        TURBO_TASKS\n+            .scope(\n+                self.pin(),\n+                CURRENT_TASK_STATE.scope(current_task_state, async {\n+                    let (result, _duration, _alloc_info) = CaptureFuture::new(future).await;\n+\n+                    // wait for all spawned local tasks using `local` to finish\n+                    let ltt =\n+                        CURRENT_TASK_STATE.with(|ts| ts.read().unwrap().local_task_tracker.clone());\n+                    ltt.close();\n+                    ltt.wait().await;\n+\n+                    match result {\n+                        Ok(Ok(raw_vc)) => Ok(raw_vc),\n+                        Ok(Err(err)) => Err(err.into()),\n+                        Err(err) => Err(TurboTasksExecutionError::Panic(Arc::new(err))),\n+                    }\n+                }),\n+            )\n+            .await\n+    }\n+\n     pub fn start_once_process(&self, future: impl Future<Output = ()> + Send + 'static) {\n         let this = self.pin();\n         tokio::spawn(async move {\n@@ -570,7 +606,7 @@ impl<B: Backend + 'static> TurboTasks<B> {\n \n                 RawVc::TaskOutput(self.backend.get_or_create_transient_task(\n                     task_type,\n-                    current_task(\"turbo_function calls\"),\n+                    current_task_if_available(\"turbo_function calls\"),\n                     self,\n                 ))\n             }\n@@ -583,7 +619,7 @@ impl<B: Backend + 'static> TurboTasks<B> {\n \n                 RawVc::TaskOutput(self.backend.get_or_create_persistent_task(\n                     task_type,\n-                    current_task(\"turbo_function calls\"),\n+                    current_task_if_available(\"turbo_function calls\"),\n                     self,\n                 ))\n             }\n@@ -1117,6 +1153,15 @@ impl<B: Backend + 'static> TurboTasksCallApi for TurboTasks<B> {\n         self.trait_call(trait_method, this, arg, persistence)\n     }\n \n+    #[track_caller]\n+    fn run(\n+        &self,\n+        future: Pin<Box<dyn Future<Output = Result<()>> + Send + 'static>>,\n+    ) -> Pin<Box<dyn Future<Output = Result<(), TurboTasksExecutionError>> + Send>> {\n+        let this = self.pin();\n+        Box::pin(async move { this.run(future).await })\n+    }\n+\n     #[track_caller]\n     fn run_once(\n         &self,\n@@ -1170,8 +1215,12 @@ impl<B: Backend + 'static> TurboTasksApi for TurboTasks<B> {\n         task: TaskId,\n         consistency: ReadConsistency,\n     ) -> Result<Result<RawVc, EventListener>> {\n-        self.backend\n-            .try_read_task_output(task, current_task(\"reading Vcs\"), consistency, self)\n+        self.backend.try_read_task_output(\n+            task,\n+            current_task_if_available(\"reading Vcs\"),\n+            consistency,\n+            self,\n+        )\n     }\n \n     fn try_read_task_output_untracked(\n@@ -1180,7 +1229,7 @@ impl<B: Backend + 'static> TurboTasksApi for TurboTasks<B> {\n         consistency: ReadConsistency,\n     ) -> Result<Result<RawVc, EventListener>> {\n         self.backend\n-            .try_read_task_output_untracked(task, consistency, self)\n+            .try_read_task_output(task, None, consistency, self)\n     }\n \n     fn try_read_task_cell(\n@@ -1189,8 +1238,13 @@ impl<B: Backend + 'static> TurboTasksApi for TurboTasks<B> {\n         index: CellId,\n         options: ReadCellOptions,\n     ) -> Result<Result<TypedCellContent, EventListener>> {\n-        self.backend\n-            .try_read_task_cell(task, index, current_task(\"reading Vcs\"), options, self)\n+        self.backend.try_read_task_cell(\n+            task,\n+            index,\n+            current_task_if_available(\"reading Vcs\"),\n+            options,\n+            self,\n+        )\n     }\n \n     fn try_read_task_cell_untracked(\n@@ -1200,7 +1254,7 @@ impl<B: Backend + 'static> TurboTasksApi for TurboTasks<B> {\n         options: ReadCellOptions,\n     ) -> Result<Result<TypedCellContent, EventListener>> {\n         self.backend\n-            .try_read_task_cell_untracked(task, index, options, self)\n+            .try_read_task_cell(task, index, None, options, self)\n     }\n \n     fn try_read_own_task_cell_untracked(\n@@ -1238,7 +1292,7 @@ impl<B: Backend + 'static> TurboTasksApi for TurboTasks<B> {\n         self.backend.read_task_collectibles(\n             task,\n             trait_id,\n-            current_task(\"reading collectibles\"),\n+            current_task_if_available(\"reading collectibles\"),\n             self,\n         )\n     }\n@@ -1291,8 +1345,9 @@ impl<B: Backend + 'static> TurboTasksApi for TurboTasks<B> {\n     }\n \n     fn connect_task(&self, task: TaskId) {\n-        self.backend\n-            .connect_task(task, current_task(\"connecting task\"), self);\n+        if let Some(current_task) = current_task_if_available(\"connecting task\") {\n+            self.backend.connect_task(task, current_task, self);\n+        }\n     }\n \n     fn mark_own_task_as_finished(&self, task: TaskId) {\n@@ -1414,13 +1469,42 @@ impl<B: Backend + 'static> TurboTasksBackendApi<B> for TurboTasks<B> {\n     }\n }\n \n-pub(crate) fn current_task(from: &str) -> TaskId {\n+pub(crate) fn current_task_if_available(from: &str) -> Option<TaskId> {\n     match CURRENT_TASK_STATE.try_with(|ts| ts.read().unwrap().task_id) {\n         Ok(id) => id,\n-        Err(_) => panic!(\"{from} can only be used in the context of turbo_tasks task execution\"),\n+        Err(_) => panic!(\n+            \"{from} can only be used in the context of a turbo_tasks task execution or \\\n+             turbo_tasks run\"\n+        ),\n+    }\n+}\n+\n+pub(crate) fn current_task(from: &str) -> TaskId {\n+    match CURRENT_TASK_STATE.try_with(|ts| ts.read().unwrap().task_id) {\n+        Ok(Some(id)) => id,\n+        Ok(None) | Err(_) => {\n+            panic!(\"{from} can only be used in the context of a turbo_tasks task execution\")\n+        }\n     }\n }\n \n+pub async fn run<T: Send + 'static>(\n+    tt: Arc<dyn TurboTasksApi>,\n+    future: impl Future<Output = Result<T>> + Send + 'static,\n+) -> Result<T> {\n+    let (tx, rx) = tokio::sync::oneshot::channel();\n+\n+    tt.run(Box::pin(async move {\n+        let result = future.await?;\n+        tx.send(result)\n+            .map_err(|_| anyhow!(\"unable to send result\"))?;\n+        Ok(())\n+    }))\n+    .await?;\n+\n+    Ok(rx.await?)\n+}\n+\n pub async fn run_once<T: Send + 'static>(\n     tt: Arc<dyn TurboTasksApi>,\n     future: impl Future<Output = Result<T>> + Send + 'static,\n@@ -1528,7 +1612,7 @@ pub fn spawn_detached_for_testing(f: impl Future<Output = Result<()>> + Send + '\n     tokio::spawn(turbo_tasks().detached_for_testing(Box::pin(f.in_current_span())));\n }\n \n-pub fn current_task_for_testing() -> TaskId {\n+pub fn current_task_for_testing() -> Option<TaskId> {\n     CURRENT_TASK_STATE.with(|ts| ts.read().unwrap().task_id)\n }\n \n@@ -1566,7 +1650,12 @@ pub fn mark_stateful() -> SerializationInvalidator {\n             stateful, task_id, ..\n         } = &mut *cell.write().unwrap();\n         *stateful = true;\n-        SerializationInvalidator::new(*task_id)\n+        let Some(task_id) = *task_id else {\n+            panic!(\n+                \"mark_stateful() can only be used in the context of a turbo_tasks task execution\"\n+            );\n+        };\n+        SerializationInvalidator::new(task_id)\n     })\n }\n "
        }
    ],
    "stats": {
        "total": 577,
        "additions": 342,
        "deletions": 235
    }
}