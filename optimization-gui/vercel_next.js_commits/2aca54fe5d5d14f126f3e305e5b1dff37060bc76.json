{
    "author": "mischnic",
    "message": "Turbopack: scope hoisting bug with reexport-self-star (#86131)\n\nCloses PACK-5850\r\nCloses https://github.com/vercel/next.js/issues/86132\r\nCloses #86714\r\n\r\nThe problem was that you get this with scope hoisting:\r\n\r\n```js\r\n\"index.js\": () => {\r\n\r\n// foo.js\r\n\r\n// exports object read here\r\nconst self_import = turbopack_import(\"foo.js\")\r\n\r\n// exports object created here\r\n__turbopack_esm__([...], \"foo.js\")\r\n\r\n// index.js\r\n\r\n....\r\n}\r\n```\r\n\r\nwithout scope hoisting, that exports object is already initialized before the module factory runs\r\n```js\r\n\"foo.js\": () => { // exports initialized here\r\n\r\nconst self_import = turbopack_import(\"foo.js\")\r\n\r\n\r\n__turbopack_esm__([....]);\r\n}\r\n....\r\n```\r\n\r\nso let's fix it by making it hoist the `__turbopack_esm__` statement (just as we did before always) in the case of self-imports\r\n\r\n\r\n---\r\n\r\n\r\nThis bug is actually very similar to https://github.com/vercel/next.js/pull/82827. It also executes `data.js` twice.\r\n\r\nThe problem is that if a module imports itself,\r\n```js\r\n\"[project]/input/data.js [test] (ecmascript)\", ((__turbopack_context__) => {\r\n\"use strict\";\r\n\r\nvar __TURBOPACK__imported__module__$5b$project$2f$input$2f$data$2e$js__$5b$test$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i(\"[project]/input/data.js [test] (ecmascript) <locals>\");\r\nvar __TURBOPACK__imported__module__$5b$project$2f$input$2f$data$2e$js__$5b$test$5d$__$28$ecmascript$29$__ = __turbopack_context__.i(\"[project]/input/data.js [test] (ecmascript)\");\r\n__turbopack_context__.s([\r\n    \"Data\",\r\n    0,\r\n    __TURBOPACK__imported__module__$5b$project$2f$input$2f$data$2e$js__$5b$test$5d$__$28$ecmascript$29$__,\r\n    \"bar\",\r\n    ()=>__TURBOPACK__imported__module__$5b$project$2f$input$2f$data$2e$js__$5b$test$5d$__$28$ecmascript$29$__$3c$locals$3e$__[\"bar\"],\r\n    \"foo\",\r\n    ()=>__TURBOPACK__imported__module__$5b$project$2f$input$2f$data$2e$js__$5b$test$5d$__$28$ecmascript$29$__$3c$locals$3e$__[\"foo\"]\r\n]);\r\n}),\r\n```\r\nand with scope hoisting, the `import(\"id\")` happens before the `esm_export(..., \"id\")`:\r\n```js\r\nmodule.exports = [\r\n\"[project]/index.js [test] (ecmascript)\", ((__turbopack_context__) => {\r\n\"use strict\";\r\n\r\n// MERGED MODULE: [project]/index.js [test] (ecmascript)\r\n;\r\n// MERGED MODULE: [project]/data.js [test] (ecmascript) <locals>\r\n;\r\nfunction foo() {\r\n    return 'foo';\r\n}\r\nfunction bar() {\r\n    return 'bar';\r\n}\r\n;\r\n__turbopack_context__.s([\r\n    \"bar\",\r\n    ()=>bar,\r\n    \"foo\",\r\n    ()=>foo\r\n], \"[project]/data.js [test] (ecmascript) <locals>\");\r\n// MERGED MODULE: [project]/data.js [test] (ecmascript) <export * as Data>\r\n;\r\n// MERGED MODULE: [project]/data.js [test] (ecmascript)\r\n;\r\nvar __TURBOPACK__imported__module__$5b$project$2f$input$2f$data$2e$js__$5b$test$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i(\"[project]/data.js [test] (ecmascript) <locals>\");\r\nvar __TURBOPACK__imported__module__$5b$project$2f$input$2f$data$2e$js__$5b$test$5d$__$28$ecmascript$29$__ = __turbopack_context__.i(\"[project]/data.js [test] (ecmascript)\");\r\n__turbopack_context__.s([\r\n    \"Data\",\r\n    0,\r\n    __TURBOPACK__imported__module__$5b$project$2f$input$2f$data$2e$js__$5b$test$5d$__$28$ecmascript$29$__,\r\n    \"bar\",\r\n    ()=>bar,\r\n    \"foo\",\r\n    ()=>foo\r\n], \"[project]/data.js [test] (ecmascript)\");\r\n```",
    "sha": "2aca54fe5d5d14f126f3e305e5b1dff37060bc76",
    "files": [
        {
            "sha": "cbe229f25936c2371dcb678876b95d08fe2042cc",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/binding_usage_info.rs",
            "status": "modified",
            "additions": 10,
            "deletions": 3,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/2aca54fe5d5d14f126f3e305e5b1dff37060bc76/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fbinding_usage_info.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2aca54fe5d5d14f126f3e305e5b1dff37060bc76/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fbinding_usage_info.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fbinding_usage_info.rs?ref=2aca54fe5d5d14f126f3e305e5b1dff37060bc76",
            "patch": "@@ -197,15 +197,22 @@ pub async fn compute_binding_usage_info(\n         )?;\n \n         // Compute cycles and select modules to be 'circuit breakers'\n+        //\n+        // To break cycles we need to ensure that no importing module can observe a\n+        // partially populated exports object.\n+        //\n         // A circuit breaker module will need to eagerly export lazy getters for its exports to\n         // break an evaluation cycle all other modules can export values after defining them\n+        //\n+        // In particular, this is also needed with scope hoisting and self-imports, as in\n+        // that case `__turbopack_esm__` is what initializes the exports object. (Without\n+        // scope hoisting, the exports object is already populated before any executing the\n+        // module factory.)\n         let mut export_circuit_breakers = FxHashSet::default();\n+\n         graph.traverse_cycles(\n             |e| e.chunking_type.is_parallel(),\n             |cycle| {\n-                // To break cycles we need to ensure that no importing module can observe a\n-                // partially populated exports object.\n-\n                 // We could compute this based on the module graph via a DFS from each entry point\n                 // to the cycle.  Whatever node is hit first is an entry point to the cycle.\n                 // (scope hoisting does something similar) and then we would only need to"
        },
        {
            "sha": "10ac2d05053b8420b6fba5f6fe3262ce650943a2",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/mod.rs",
            "status": "modified",
            "additions": 65,
            "deletions": 3,
            "changes": 68,
            "blob_url": "https://github.com/vercel/next.js/blob/2aca54fe5d5d14f126f3e305e5b1dff37060bc76/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2aca54fe5d5d14f126f3e305e5b1dff37060bc76/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs?ref=2aca54fe5d5d14f126f3e305e5b1dff37060bc76",
            "patch": "@@ -413,14 +413,18 @@ impl SingleModuleGraph {\n         graph_idx: u32,\n         binding_usage: &'l Option<ReadRef<BindingUsageInfo>>,\n     ) -> Result<()> {\n-        // see https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n-        // but iteratively instead of recursively\n+        // See https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm, but\n+        // implemented iteratively instead of recursively.\n+        //\n+        // Compared to the standard Tarjan's, this also treated self-references (via\n+        // `has_self_loop`) as SCCs.\n \n         #[derive(Clone)]\n         struct NodeState {\n             index: u32,\n             lowlink: u32,\n             on_stack: bool,\n+            has_self_loop: bool,\n         }\n         enum VisitStep {\n             UnvisitedNode(NodeIndex),\n@@ -445,6 +449,7 @@ impl SingleModuleGraph {\n                             index,\n                             lowlink: index,\n                             on_stack: true,\n+                            has_self_loop: false,\n                         });\n                         index += 1;\n                         stack.push(node);\n@@ -468,6 +473,9 @@ impl SingleModuleGraph {\n                                     let index = node_state.index;\n                                     let parent_state = node_states[node.index()].as_mut().unwrap();\n                                     parent_state.lowlink = parent_state.lowlink.min(index);\n+                                    if succ == node {\n+                                        parent_state.has_self_loop = true;\n+                                    }\n                                 }\n                             } else {\n                                 visit_stack.push(VisitStep::EdgeAfterVisit {\n@@ -487,6 +495,7 @@ impl SingleModuleGraph {\n                     }\n                     VisitStep::AfterVisit(node) => {\n                         let node_state = node_states[node.index()].as_ref().unwrap();\n+                        let node_has_self_loop = node_state.has_self_loop;\n                         if node_state.lowlink == node_state.index {\n                             loop {\n                                 let poppped = stack.pop().unwrap();\n@@ -501,7 +510,7 @@ impl SingleModuleGraph {\n                                     break;\n                                 }\n                             }\n-                            if scc.len() > 1 {\n+                            if scc.len() > 1 || node_has_self_loop {\n                                 visit_cycle(&scc)?;\n                             }\n                             scc.clear();\n@@ -1341,6 +1350,7 @@ impl ModuleGraphRef {\n \n     /// Traverse all cycles in the graph (where the edge filter returns true for the whole cycle)\n     /// and call the visitor with the nodes in the cycle.\n+    /// Notably, module self-references are also treated as cycles.\n     pub fn traverse_cycles(\n         &self,\n         edge_filter: impl Fn(&RefData) -> bool,\n@@ -1997,6 +2007,58 @@ pub mod tests {\n         .await;\n     }\n \n+    #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n+    async fn test_traverse_cycles() {\n+        run_graph_test(\n+            vec![rcstr!(\"a.js\")],\n+            {\n+                let mut deps = FxHashMap::default();\n+                // The cycles are: (i, j, k), and (s) which a self-import\n+                //          a\n+                //      /   |    \\\n+                //     /i   s-\\   x\n+                //     |j   \\-/\n+                //     \\k\n+                deps.insert(\n+                    rcstr!(\"a.js\"),\n+                    vec![rcstr!(\"i.js\"), rcstr!(\"s.js\"), rcstr!(\"x.js\")],\n+                );\n+                deps.insert(rcstr!(\"i.js\"), vec![rcstr!(\"j.js\")]);\n+                deps.insert(rcstr!(\"j.js\"), vec![rcstr!(\"k.js\")]);\n+                deps.insert(rcstr!(\"k.js\"), vec![rcstr!(\"i.js\")]);\n+                deps.insert(rcstr!(\"s.js\"), vec![rcstr!(\"s.js\")]);\n+                deps\n+            },\n+            |graph, _, module_to_name| {\n+                let mut cycles = vec![];\n+\n+                graph.traverse_cycles(\n+                    |_| true,\n+                    |cycle| {\n+                        cycles.push(\n+                            cycle\n+                                .iter()\n+                                .map(|n| module_to_name.get(*n).unwrap().clone())\n+                                .collect::<Vec<_>>(),\n+                        );\n+                        Ok(())\n+                    },\n+                )?;\n+\n+                assert_eq!(\n+                    cycles,\n+                    vec![\n+                        vec![rcstr!(\"k.js\"), rcstr!(\"j.js\"), rcstr!(\"i.js\")],\n+                        vec![rcstr!(\"s.js\")]\n+                    ],\n+                );\n+\n+                Ok(())\n+            },\n+        )\n+        .await;\n+    }\n+\n     #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n     async fn test_reverse_edges_through_layered_graph() {\n         let tt = turbo_tasks::TurboTasks::new(TurboTasksBackend::new("
        },
        {
            "sha": "686ce61f9d208ebd9f2205e90639118c5d3b8d6c",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/module_batches.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/2aca54fe5d5d14f126f3e305e5b1dff37060bc76/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmodule_batches.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2aca54fe5d5d14f126f3e305e5b1dff37060bc76/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmodule_batches.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmodule_batches.rs?ref=2aca54fe5d5d14f126f3e305e5b1dff37060bc76",
            "patch": "@@ -395,9 +395,10 @@ pub async fn compute_module_batches(\n         module_graph.traverse_cycles(\n             |ref_data| ref_data.chunking_type.is_parallel(),\n             |cycle| {\n-                if cycle\n-                    .iter()\n-                    .any(|node| pre_batches.boundary_modules.contains(node))\n+                if cycle.len() > 1\n+                    && cycle\n+                        .iter()\n+                        .any(|node| pre_batches.boundary_modules.contains(node))\n                 {\n                     pre_batches\n                         .boundary_modules"
        },
        {
            "sha": "6a5bb384aaf0ba56a935839ae87ab1fe7290783b",
            "filename": "turbopack/crates/turbopack-tests/tests/execution/turbopack/exports/self-reexport-star/input/data.js",
            "status": "added",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/2aca54fe5d5d14f126f3e305e5b1dff37060bc76/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fexports%2Fself-reexport-star%2Finput%2Fdata.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2aca54fe5d5d14f126f3e305e5b1dff37060bc76/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fexports%2Fself-reexport-star%2Finput%2Fdata.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fexports%2Fself-reexport-star%2Finput%2Fdata.js?ref=2aca54fe5d5d14f126f3e305e5b1dff37060bc76",
            "patch": "@@ -0,0 +1,9 @@\n+export function foo() {\n+  return 'foo'\n+}\n+\n+export function bar() {\n+  return 'bar'\n+}\n+\n+export * as Data from './data'"
        },
        {
            "sha": "310eae820a69ea5b485c37d27aea03f2deb768bd",
            "filename": "turbopack/crates/turbopack-tests/tests/execution/turbopack/exports/self-reexport-star/input/index.js",
            "status": "added",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/2aca54fe5d5d14f126f3e305e5b1dff37060bc76/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fexports%2Fself-reexport-star%2Finput%2Findex.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2aca54fe5d5d14f126f3e305e5b1dff37060bc76/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fexports%2Fself-reexport-star%2Finput%2Findex.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fexports%2Fself-reexport-star%2Finput%2Findex.js?ref=2aca54fe5d5d14f126f3e305e5b1dff37060bc76",
            "patch": "@@ -0,0 +1,6 @@\n+import { Data } from './data'\n+\n+it('should re-export own namespace correctly', () => {\n+  expect(Data.foo()).toBe('foo')\n+  expect(Data.bar()).toBe('bar')\n+})"
        },
        {
            "sha": "9437f5a817160555acfa2e28572d12038ba4c143",
            "filename": "turbopack/crates/turbopack-tests/tests/execution/turbopack/exports/self-reexport-star/options.json",
            "status": "added",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/2aca54fe5d5d14f126f3e305e5b1dff37060bc76/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fexports%2Fself-reexport-star%2Foptions.json",
            "raw_url": "https://github.com/vercel/next.js/raw/2aca54fe5d5d14f126f3e305e5b1dff37060bc76/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fexports%2Fself-reexport-star%2Foptions.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution%2Fturbopack%2Fexports%2Fself-reexport-star%2Foptions.json?ref=2aca54fe5d5d14f126f3e305e5b1dff37060bc76",
            "patch": "@@ -0,0 +1,3 @@\n+{\n+  \"scopeHoisting\": true\n+}"
        }
    ],
    "stats": {
        "total": 106,
        "additions": 97,
        "deletions": 9
    }
}