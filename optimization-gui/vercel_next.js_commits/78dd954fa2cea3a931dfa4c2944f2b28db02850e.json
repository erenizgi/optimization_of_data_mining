{
    "author": "mischnic",
    "message": "Turbopack: remove unneeded manifests for API routes (#81536)",
    "sha": "78dd954fa2cea3a931dfa4c2944f2b28db02850e",
    "files": [
        {
            "sha": "5570a31ac31ef5509ce2b5f5ed3fd6c673479755",
            "filename": "crates/next-api/src/app.rs",
            "status": "modified",
            "additions": 38,
            "deletions": 28,
            "changes": 66,
            "blob_url": "https://github.com/vercel/next.js/blob/78dd954fa2cea3a931dfa4c2944f2b28db02850e/crates%2Fnext-api%2Fsrc%2Fapp.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/78dd954fa2cea3a931dfa4c2944f2b28db02850e/crates%2Fnext-api%2Fsrc%2Fapp.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fapp.rs?ref=78dd954fa2cea3a931dfa4c2944f2b28db02850e",
            "patch": "@@ -1162,30 +1162,33 @@ impl AppEndpoint {\n             None,\n             /// Emit the manifest for basic Next.js functionality (e.g. app-build-manifest.json)\n             Minimal,\n-            /// All manifests: `Minimal` plus client-references, next-dynamic, ...\n+            /// All manifests: `Minimal` plus next-font, next-dynamic, ...\n             Full,\n         }\n-        let (process_client_assets, process_ssr, emit_manifests) = match &this.ty {\n-            AppEndpointType::Page { ty, .. } => (\n-                true,\n-                matches!(ty, AppPageEndpointType::Html),\n-                if matches!(ty, AppPageEndpointType::Html) {\n-                    EmitManifests::Full\n-                } else {\n-                    EmitManifests::None\n-                },\n-            ),\n-            AppEndpointType::Route { .. } => (false, false, EmitManifests::Full),\n-            AppEndpointType::Metadata { metadata } => (\n-                false,\n-                false,\n-                if matches!(metadata, MetadataItem::Dynamic { .. }) {\n-                    EmitManifests::Full\n-                } else {\n-                    EmitManifests::Minimal\n-                },\n-            ),\n-        };\n+        let (process_client_assets, process_ssr, emit_manifests, emit_rsc_manifests) =\n+            match &this.ty {\n+                AppEndpointType::Page { ty, .. } => (\n+                    true,\n+                    matches!(ty, AppPageEndpointType::Html),\n+                    if matches!(ty, AppPageEndpointType::Html) {\n+                        EmitManifests::Full\n+                    } else {\n+                        EmitManifests::None\n+                    },\n+                    matches!(ty, AppPageEndpointType::Html),\n+                ),\n+                AppEndpointType::Route { .. } => (false, false, EmitManifests::Minimal, true),\n+                AppEndpointType::Metadata { metadata } => (\n+                    false,\n+                    false,\n+                    if matches!(metadata, MetadataItem::Dynamic { .. }) {\n+                        EmitManifests::Full\n+                    } else {\n+                        EmitManifests::Minimal\n+                    },\n+                    matches!(metadata, MetadataItem::Dynamic { .. }),\n+                ),\n+            };\n \n         let node_root = project.node_root().owned().await?;\n         let client_relative_path = project.client_relative_path().owned().await?;\n@@ -1434,7 +1437,7 @@ impl AppEndpoint {\n                 .runtime_chunking_context(process_client_assets, runtime),\n         )\n         .await?;\n-        if emit_manifests == EmitManifests::Full {\n+        if emit_rsc_manifests {\n             server_assets.insert(server_action_manifest.manifest);\n         }\n \n@@ -1460,7 +1463,7 @@ impl AppEndpoint {\n         // these references are important for turbotrace\n         let mut client_reference_manifest = None;\n \n-        if emit_manifests == EmitManifests::Full {\n+        if emit_rsc_manifests {\n             let entry_manifest =\n                 ClientReferenceManifest::build_output(ClientReferenceManifestOptions {\n                     node_root: node_root.clone(),\n@@ -1482,7 +1485,8 @@ impl AppEndpoint {\n                 middleware_assets.insert(entry_manifest);\n             }\n             client_reference_manifest = Some(entry_manifest);\n-\n+        }\n+        if emit_manifests == EmitManifests::Full {\n             let next_font_manifest_output = create_font_manifest(\n                 project.client_root().owned().await?,\n                 node_root.clone(),\n@@ -1504,11 +1508,16 @@ impl AppEndpoint {\n                 //\n                 // they are created in `setup-dev-bundler.ts`\n                 let mut file_paths_from_root = fxindexset![\n-                    rcstr!(\"server/server-reference-manifest.js\"),\n                     rcstr!(\"server/middleware-build-manifest.js\"),\n-                    rcstr!(\"server/next-font-manifest.js\"),\n                     rcstr!(\"server/interception-route-rewrite-manifest.js\"),\n                 ];\n+                if emit_manifests == EmitManifests::Full {\n+                    file_paths_from_root.insert(rcstr!(\"server/next-font-manifest.js\"));\n+                };\n+                if emit_rsc_manifests {\n+                    file_paths_from_root.insert(rcstr!(\"server/server-reference-manifest.js\"));\n+                }\n+\n                 let mut wasm_paths_from_root = fxindexset![];\n \n                 let node_root_value = node_root.clone();\n@@ -1556,7 +1565,8 @@ impl AppEndpoint {\n                     file_paths_from_root.extend(\n                         get_js_paths_from_root(&node_root_value, &loadable_manifest_output).await?,\n                     );\n-\n+                }\n+                if emit_manifests != EmitManifests::None {\n                     // create middleware manifest\n                     let named_regex = get_named_middleware_regex(&app_entry.pathname);\n                     let matchers = MiddlewareMatcher {"
        },
        {
            "sha": "68d50332f38c7af42162eaf805308558fb04ea62",
            "filename": "crates/next-api/src/pages.rs",
            "status": "modified",
            "additions": 89,
            "deletions": 70,
            "changes": 159,
            "blob_url": "https://github.com/vercel/next.js/blob/78dd954fa2cea3a931dfa4c2944f2b28db02850e/crates%2Fnext-api%2Fsrc%2Fpages.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/78dd954fa2cea3a931dfa4c2944f2b28db02850e/crates%2Fnext-api%2Fsrc%2Fpages.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fpages.rs?ref=78dd954fa2cea3a931dfa4c2944f2b28db02850e",
            "patch": "@@ -684,24 +684,26 @@ enum PageEndpointType {\n }\n \n #[derive(\n-    Copy,\n-    Clone,\n-    Serialize,\n-    Deserialize,\n-    PartialEq,\n-    Eq,\n-    Hash,\n-    Debug,\n-    TaskInput,\n-    TraceRawVcs,\n-    NonLocalValue,\n+    Copy, Clone, Serialize, Deserialize, PartialEq, Eq, Hash, Debug, TaskInput, TraceRawVcs,\n )]\n enum SsrChunkType {\n     Page,\n     Data,\n     Api,\n }\n \n+#[derive(\n+    Copy, Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize, TaskInput, TraceRawVcs,\n+)]\n+enum EmitManifests {\n+    /// Don't emit any manifests\n+    None,\n+    /// Emit the manifest for basic Next.js functionality (e.g. pages-manifest.json)\n+    Minimal,\n+    /// All manifests: `Minimal` plus server-reference-manifest, next/font, next/dynamic\n+    Full,\n+}\n+\n #[turbo_tasks::value_impl]\n impl PageEndpoint {\n     #[turbo_tasks::function]\n@@ -982,6 +984,7 @@ impl PageEndpoint {\n     async fn internal_ssr_chunk(\n         self: Vc<Self>,\n         ty: SsrChunkType,\n+        emit_manifests: EmitManifests,\n         node_path: FileSystemPath,\n         node_chunking_context: Vc<NodeJsChunkingContext>,\n         edge_chunking_context: Vc<Box<dyn ChunkingContext>>,\n@@ -1147,19 +1150,22 @@ impl PageEndpoint {\n                     .await?\n                     .is_production()\n                 {\n-                    let loadable_manifest_output =\n-                        self.react_loadable_manifest(*dynamic_import_entries, NextRuntime::NodeJs);\n+                    let additional_assets = if emit_manifests == EmitManifests::Full {\n+                        self.react_loadable_manifest(*dynamic_import_entries, NextRuntime::NodeJs)\n+                            .await?\n+                            .iter()\n+                            .map(|m| **m)\n+                            .collect()\n+                    } else {\n+                        vec![]\n+                    };\n \n                     ResolvedVc::cell(Some(ResolvedVc::upcast(\n                         NftJsonAsset::new(\n                             project,\n                             Some(this.original_name.clone()),\n                             *ssr_entry_chunk,\n-                            loadable_manifest_output\n-                                .await?\n-                                .iter()\n-                                .map(|m| **m)\n-                                .collect(),\n+                            additional_assets,\n                         )\n                         .to_resolved()\n                         .await?,\n@@ -1185,11 +1191,12 @@ impl PageEndpoint {\n     }\n \n     #[turbo_tasks::function]\n-    async fn ssr_chunk(self: Vc<Self>) -> Result<Vc<SsrChunk>> {\n+    async fn ssr_chunk(self: Vc<Self>, emit_manifests: EmitManifests) -> Result<Vc<SsrChunk>> {\n         let this = self.await?;\n         let project = this.pages_project.project();\n         Ok(self.internal_ssr_chunk(\n             SsrChunkType::Page,\n+            emit_manifests,\n             this.pages_project\n                 .project()\n                 .node_root()\n@@ -1203,10 +1210,11 @@ impl PageEndpoint {\n     }\n \n     #[turbo_tasks::function]\n-    async fn ssr_data_chunk(self: Vc<Self>) -> Result<Vc<SsrChunk>> {\n+    async fn ssr_data_chunk(self: Vc<Self>, emit_manifests: EmitManifests) -> Result<Vc<SsrChunk>> {\n         let this = self.await?;\n         Ok(self.internal_ssr_chunk(\n             SsrChunkType::Data,\n+            emit_manifests,\n             this.pages_project\n                 .project()\n                 .node_root()\n@@ -1220,10 +1228,11 @@ impl PageEndpoint {\n     }\n \n     #[turbo_tasks::function]\n-    async fn api_chunk(self: Vc<Self>) -> Result<Vc<SsrChunk>> {\n+    async fn api_chunk(self: Vc<Self>, emit_manifests: EmitManifests) -> Result<Vc<SsrChunk>> {\n         let this = self.await?;\n         Ok(self.internal_ssr_chunk(\n             SsrChunkType::Api,\n+            emit_manifests,\n             this.pages_project\n                 .project()\n                 .node_root()\n@@ -1348,6 +1357,12 @@ impl PageEndpoint {\n         let mut server_assets = vec![];\n         let mut client_assets = vec![];\n \n+        let emit_manifests = match this.ty {\n+            PageEndpointType::Html | PageEndpointType::SsrOnly => EmitManifests::Full,\n+            PageEndpointType::Api => EmitManifests::Minimal,\n+            PageEndpointType::Data => EmitManifests::None,\n+        };\n+\n         let ssr_chunk = match this.ty {\n             PageEndpointType::Html => {\n                 let client_chunks = *self.client_chunks().await?.assets;\n@@ -1361,13 +1376,12 @@ impl PageEndpoint {\n                 client_assets.push(page_loader);\n                 server_assets.push(build_manifest);\n                 server_assets.push(client_build_manifest);\n-                self.ssr_chunk()\n+                self.ssr_chunk(emit_manifests)\n             }\n-            PageEndpointType::Data => self.ssr_data_chunk(),\n-            PageEndpointType::Api => self.api_chunk(),\n-            PageEndpointType::SsrOnly => self.ssr_chunk(),\n+            PageEndpointType::Data => self.ssr_data_chunk(emit_manifests),\n+            PageEndpointType::Api => self.api_chunk(emit_manifests),\n+            PageEndpointType::SsrOnly => self.ssr_chunk(emit_manifests),\n         };\n-        let emit_manifests = !matches!(this.ty, PageEndpointType::Data);\n \n         let pathname = &this.pathname;\n         let original_name = &this.original_name;\n@@ -1376,18 +1390,21 @@ impl PageEndpoint {\n \n         let manifest_path_prefix = get_asset_prefix_from_pathname(pathname);\n         let node_root = this.pages_project.project().node_root().owned().await?;\n-        let next_font_manifest_output = create_font_manifest(\n-            this.pages_project.project().client_root().owned().await?,\n-            node_root.clone(),\n-            this.pages_project.pages_dir().owned().await?,\n-            original_name,\n-            &manifest_path_prefix,\n-            pathname,\n-            *client_assets,\n-            false,\n-        )\n-        .await?;\n-        server_assets.push(next_font_manifest_output);\n+\n+        if emit_manifests == EmitManifests::Full {\n+            let next_font_manifest_output = create_font_manifest(\n+                this.pages_project.project().client_root().owned().await?,\n+                node_root.clone(),\n+                this.pages_project.pages_dir().owned().await?,\n+                original_name,\n+                &manifest_path_prefix,\n+                pathname,\n+                *client_assets,\n+                false,\n+            )\n+            .await?;\n+            server_assets.push(next_font_manifest_output);\n+        }\n \n         if *this\n             .pages_project\n@@ -1425,10 +1442,11 @@ impl PageEndpoint {\n                     server_assets.push(*server_asset_trace_file);\n                 }\n \n-                if emit_manifests {\n+                if emit_manifests != EmitManifests::None {\n                     let pages_manifest = self.pages_manifest(*entry).to_resolved().await?;\n                     server_assets.push(pages_manifest);\n-\n+                }\n+                if emit_manifests == EmitManifests::Full {\n                     let loadable_manifest_output =\n                         self.react_loadable_manifest(*dynamic_import_entries, NextRuntime::NodeJs);\n                     server_assets.extend(loadable_manifest_output.await?.iter().copied());\n@@ -1446,47 +1464,48 @@ impl PageEndpoint {\n                 ref regions,\n             } => {\n                 let node_root = this.pages_project.project().node_root().owned().await?;\n-                if emit_manifests {\n+                if emit_manifests != EmitManifests::None {\n+                    // the next-edge-ssr-loader templates expect the manifests to be stored in\n+                    // global variables defined in these files\n+                    //\n+                    // they are created in `setup-dev-bundler.ts`\n+                    let mut file_paths_from_root = if emit_manifests == EmitManifests::Full {\n+                        fxindexset![\n+                            rcstr!(\"server/server-reference-manifest.js\"),\n+                            rcstr!(\"server/middleware-build-manifest.js\"),\n+                            rcstr!(\"server/next-font-manifest.js\"),\n+                        ]\n+                    } else {\n+                        fxindexset![]\n+                    };\n+\n                     let files_value = files.await?;\n                     if let Some(&file) = files_value.first() {\n                         let pages_manifest = self.pages_manifest(*file).to_resolved().await?;\n                         server_assets.push(pages_manifest);\n                     }\n                     server_assets.extend(files_value.iter().copied());\n-\n-                    let loadable_manifest_output = self\n-                        .react_loadable_manifest(*dynamic_import_entries, NextRuntime::Edge)\n-                        .await?;\n-                    server_assets.extend(loadable_manifest_output.iter().copied());\n-\n-                    // the next-edge-ssr-loader templates expect the manifests to be stored in\n-                    // global variables defined in these files\n-                    //\n-                    // they are created in `setup-dev-bundler.ts`\n-                    let mut file_paths_from_root = vec![\n-                        rcstr!(\"server/server-reference-manifest.js\"),\n-                        rcstr!(\"server/middleware-build-manifest.js\"),\n-                        rcstr!(\"server/next-font-manifest.js\"),\n-                    ];\n-                    let mut wasm_paths_from_root = fxindexset![];\n-\n-                    let node_root_value = node_root.clone();\n-\n-                    file_paths_from_root.extend(\n-                        get_js_paths_from_root(&node_root_value, &loadable_manifest_output).await?,\n-                    );\n-\n                     file_paths_from_root\n-                        .extend(get_js_paths_from_root(&node_root_value, &files_value).await?);\n+                        .extend(get_js_paths_from_root(&node_root, &files_value).await?);\n+\n+                    if emit_manifests == EmitManifests::Full {\n+                        let loadable_manifest_output = self\n+                            .react_loadable_manifest(*dynamic_import_entries, NextRuntime::Edge)\n+                            .await?;\n+                        server_assets.extend(loadable_manifest_output.iter().copied());\n+                        file_paths_from_root.extend(\n+                            get_js_paths_from_root(&node_root, &loadable_manifest_output).await?,\n+                        );\n+                    }\n \n                     let all_output_assets = all_assets_from_entries(*files).await?;\n \n-                    wasm_paths_from_root.extend(\n-                        get_wasm_paths_from_root(&node_root_value, &all_output_assets).await?,\n-                    );\n+                    let mut wasm_paths_from_root = fxindexset![];\n+                    wasm_paths_from_root\n+                        .extend(get_wasm_paths_from_root(&node_root, &all_output_assets).await?);\n \n                     let all_assets =\n-                        get_asset_paths_from_root(&node_root_value, &all_output_assets).await?;\n+                        get_asset_paths_from_root(&node_root, &all_output_assets).await?;\n \n                     let named_regex = get_named_middleware_regex(pathname).into();\n                     let matchers = MiddlewareMatcher {\n@@ -1507,7 +1526,7 @@ impl PageEndpoint {\n                     };\n \n                     let edge_function_definition = EdgeFunctionDefinition {\n-                        files: file_paths_from_root,\n+                        files: file_paths_from_root.into_iter().collect(),\n                         wasm: wasm_paths_to_bindings(wasm_paths_from_root).await?,\n                         assets: paths_to_bindings(all_assets),\n                         name: pathname.clone(),"
        }
    ],
    "stats": {
        "total": 225,
        "additions": 127,
        "deletions": 98
    }
}