{
    "author": "ijjk",
    "message": "Ensure outputs are correct with cache components in deployment adapters (#87018)\n\nUpdates our outputs to ensure we provide correct metadata and ISR pairs\nwhen cache components are enabled.\n\n---------\n\nCo-authored-by: vercel[bot] <35613825+vercel[bot]@users.noreply.github.com>",
    "sha": "dfd3c2600029ab1ec132fe0fc8d58706eec1e670",
    "files": [
        {
            "sha": "1526be6dbe1147ebdfc0b0c670e634165bf7d99a",
            "filename": "packages/next/src/build/adapter/build-complete.ts",
            "status": "modified",
            "additions": 114,
            "deletions": 60,
            "changes": 174,
            "blob_url": "https://github.com/vercel/next.js/blob/dfd3c2600029ab1ec132fe0fc8d58706eec1e670/packages%2Fnext%2Fsrc%2Fbuild%2Fadapter%2Fbuild-complete.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/dfd3c2600029ab1ec132fe0fc8d58706eec1e670/packages%2Fnext%2Fsrc%2Fbuild%2Fadapter%2Fbuild-complete.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fadapter%2Fbuild-complete.ts?ref=dfd3c2600029ab1ec132fe0fc8d58706eec1e670",
            "patch": "@@ -174,37 +174,50 @@ export interface AdapterOutput {\n     /**\n      * fallback is initial cache data generated during build for a prerender\n      */\n-    fallback?: {\n-      /**\n-       * path to the fallback file can be HTML/JSON/RSC\n-       */\n-      filePath: string\n-      /**\n-       * initialStatus is the status code that should be applied\n-       * when serving the fallback\n-       */\n-      initialStatus?: number\n-      /**\n-       * initialHeaders are the headers that should be sent when\n-       * serving the fallback\n-       */\n-      initialHeaders?: Record<string, string | string[]>\n-      /**\n-       * initial expiration is how long until the fallback entry\n-       * is considered expired and no longer valid to serve\n-       */\n-      initialExpiration?: number\n-      /**\n-       * initial revalidate is how long until the fallback is\n-       * considered stale and should be revalidated\n-       */\n-      initialRevalidate?: Revalidate\n-\n-      /**\n-       * postponedState is the PPR state when it postponed and is used for resuming\n-       */\n-      postponedState?: string\n-    }\n+    fallback?:\n+      | {\n+          /**\n+           * path to the fallback file can be HTML/JSON/RSC,\n+           */\n+          filePath: string\n+          /**\n+           * initialStatus is the status code that should be applied\n+           * when serving the fallback\n+           */\n+          initialStatus?: number\n+          /**\n+           * initialHeaders are the headers that should be sent when\n+           * serving the fallback\n+           */\n+          initialHeaders?: Record<string, string | string[]>\n+          /**\n+           * initial expiration is how long until the fallback entry\n+           * is considered expired and no longer valid to serve\n+           */\n+          initialExpiration?: number\n+          /**\n+           * initial revalidate is how long until the fallback is\n+           * considered stale and should be revalidated\n+           */\n+          initialRevalidate?: Revalidate\n+\n+          /**\n+           * postponedState is the PPR state when it postponed and is used for resuming\n+           */\n+          postponedState?: string\n+        }\n+      | {\n+          /*\n+        a fallback filePath can be omitted when postponedState is\n+        present which signals the fallback should just resume with\n+        the postpone state but doesn't have fallback to seed cache\n+      */\n+          postponedState: string\n+          initialExpiration?: number\n+          initialRevalidate?: Revalidate\n+          initialHeaders?: Record<string, string | string[]>\n+          initialStatus?: number\n+        }\n     /**\n      * config related to the route\n      */\n@@ -1164,7 +1177,6 @@ export async function handleBuildComplete({\n           initialRevalidateSeconds: initialRevalidate,\n           initialHeaders,\n           initialStatus,\n-          prefetchDataRoute,\n           dataRoute,\n           renderingMode,\n           allowHeader,\n@@ -1273,43 +1285,64 @@ export async function handleBuildComplete({\n         outputs.prerenders.push(initialOutput)\n \n         if (dataRoute) {\n-          let dataFilePath = path.join(\n+          let dataFilePath: string | undefined = path.join(\n             pagesDistDir,\n             `${normalizePagePath(route)}.json`\n           )\n+          let postponed = meta.postponed\n \n           if (isAppPage) {\n             // When experimental PPR is enabled, we expect that the data\n             // that should be served as a part of the prerender should\n             // be from the prefetch data route. If this isn't enabled\n             // for ppr, the only way to get the data is from the data\n             // route.\n-            dataFilePath = path.join(\n-              appDistDir,\n-              prefetchDataRoute &&\n-                renderingMode === RenderingMode.PARTIALLY_STATIC\n-                ? prefetchDataRoute\n-                : dataRoute\n-            )\n+            dataFilePath = path.join(appDistDir, dataRoute)\n           }\n \n-          outputs.prerenders.push({\n-            ...initialOutput,\n-            id: dataRoute,\n-            pathname: dataRoute,\n-            fallback: isNotFoundTrue\n-              ? undefined\n-              : {\n-                  ...initialOutput.fallback,\n-                  initialHeaders: {\n-                    ...initialOutput.fallback?.initialHeaders,\n-                    'content-type': isAppPage\n-                      ? rscContentTypeHeader\n-                      : JSON_CONTENT_TYPE_HEADER,\n+          if (\n+            renderingMode === RenderingMode.PARTIALLY_STATIC &&\n+            !(await cachedFilePathCheck(dataFilePath))\n+          ) {\n+            // TODO: allowQuery should diverge based on app client param\n+            // parsing flag\n+            outputs.prerenders.push({\n+              ...initialOutput,\n+              id: dataRoute,\n+              pathname: dataRoute,\n+              fallback: !postponed\n+                ? undefined\n+                : {\n+                    ...initialOutput.fallback,\n+                    postponedState: postponed,\n+                    initialHeaders: {\n+                      ...initialOutput.fallback?.initialHeaders,\n+                      'content-type': isAppPage\n+                        ? rscContentTypeHeader\n+                        : JSON_CONTENT_TYPE_HEADER,\n+                    },\n+                    filePath: undefined,\n                   },\n-                  filePath: dataFilePath,\n-                },\n-          })\n+            })\n+          } else {\n+            outputs.prerenders.push({\n+              ...initialOutput,\n+              id: dataRoute,\n+              pathname: dataRoute,\n+              fallback: isNotFoundTrue\n+                ? undefined\n+                : {\n+                    ...initialOutput.fallback,\n+                    initialHeaders: {\n+                      ...initialOutput.fallback?.initialHeaders,\n+                      'content-type': isAppPage\n+                        ? rscContentTypeHeader\n+                        : JSON_CONTENT_TYPE_HEADER,\n+                    },\n+                    filePath: dataFilePath,\n+                  },\n+            })\n+          }\n         }\n \n         if (isAppPage) {\n@@ -1325,13 +1358,16 @@ export async function handleBuildComplete({\n           fallbackRevalidate,\n           fallbackHeaders,\n           fallbackStatus,\n+          fallbackSourceRoute,\n           allowHeader,\n           dataRoute,\n           renderingMode,\n           experimentalBypassFor,\n         } = prerenderManifest.dynamicRoutes[dynamicRoute]\n \n-        const isAppPage = Boolean(appOutputMap[dynamicRoute])\n+        const srcRoute = fallbackSourceRoute || dynamicRoute\n+        const parentOutput = getParentOutput(srcRoute, dynamicRoute)\n+        const isAppPage = Boolean(appOutputMap[srcRoute])\n \n         const allowQuery = Object.values(\n           routesManifest.dynamicRoutes.find(\n@@ -1344,7 +1380,7 @@ export async function handleBuildComplete({\n           id: dynamicRoute,\n           type: AdapterOutputType.PRERENDER,\n           pathname: dynamicRoute,\n-          parentOutputId: getParentOutput(dynamicRoute, dynamicRoute).id,\n+          parentOutputId: parentOutput.id,\n           groupId: prerenderGroupId,\n           config: {\n             allowQuery,\n@@ -1380,7 +1416,25 @@ export async function handleBuildComplete({\n             await handleAppMeta(dynamicRoute, initialOutput, meta)\n           }\n \n-          if (dataRoute) {\n+          if (renderingMode === RenderingMode.PARTIALLY_STATIC) {\n+            outputs.prerenders.push({\n+              ...initialOutput,\n+              id: `${dynamicRoute}.rsc`,\n+              pathname: `${dynamicRoute}.rsc`,\n+              fallback: meta.postponed\n+                ? {\n+                    ...initialOutput.fallback,\n+                    postponedState: meta.postponed,\n+                    initialHeaders: {\n+                      ...initialOutput.fallback?.initialHeaders,\n+                      'content-type': isAppPage\n+                        ? rscContentTypeHeader\n+                        : JSON_CONTENT_TYPE_HEADER,\n+                    },\n+                  }\n+                : undefined,\n+            })\n+          } else if (dataRoute) {\n             outputs.prerenders.push({\n               ...initialOutput,\n               id: dataRoute,\n@@ -1521,7 +1575,7 @@ export async function handleBuildComplete({\n           route.page\n         ) + getDestinationQuery(route.routeKeys)\n \n-      if (appPageKeys && appPageKeys.length > 0 && config.cacheComponents) {\n+      if (appPageKeys && appPageKeys.length > 0) {\n         // If we have fallback root params (implying we've already\n         // emitted a rewrite for the /_tree request), or if the route\n         // has PPR enabled and client param parsing is enabled, then"
        },
        {
            "sha": "3cb0064a27fab2f18a820177acf07b7e3bfc2f5a",
            "filename": "packages/next/src/build/define-env.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/dfd3c2600029ab1ec132fe0fc8d58706eec1e670/packages%2Fnext%2Fsrc%2Fbuild%2Fdefine-env.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/dfd3c2600029ab1ec132fe0fc8d58706eec1e670/packages%2Fnext%2Fsrc%2Fbuild%2Fdefine-env.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fdefine-env.ts?ref=dfd3c2600029ab1ec132fe0fc8d58706eec1e670",
            "patch": "@@ -147,8 +147,6 @@ export function getDefineEnv({\n       : process.env.NEXT_RSPACK\n         ? 'Rspack'\n         : 'Webpack',\n-    // minimal mode is enforced when an adapter is configured\n-    'process.env.MINIMAL_MODE': Boolean(config.experimental.adapterPath),\n     // TODO: enforce `NODE_ENV` on `process.env`, and add a test:\n     'process.env.NODE_ENV':\n       dev || config.experimental.allowDevelopmentBuild"
        },
        {
            "sha": "50b21436b19492b1e83f2df9f586662076796ceb",
            "filename": "packages/next/src/build/templates/app-page.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 3,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/dfd3c2600029ab1ec132fe0fc8d58706eec1e670/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fapp-page.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/dfd3c2600029ab1ec132fe0fc8d58706eec1e670/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fapp-page.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fapp-page.ts?ref=dfd3c2600029ab1ec132fe0fc8d58706eec1e670",
            "patch": "@@ -121,9 +121,7 @@ export async function handler(\n   if (routeModule.isDev) {\n     addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint())\n   }\n-  const isMinimalMode = Boolean(\n-    process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode')\n-  )\n+  const isMinimalMode = Boolean(getRequestMeta(req, 'minimalMode'))\n \n   let srcPage = 'VAR_DEFINITION_PAGE'\n "
        },
        {
            "sha": "ec5380e6449ed37a08e9a6cd9cf99c1211543295",
            "filename": "packages/next/src/build/templates/app-route.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 3,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/dfd3c2600029ab1ec132fe0fc8d58706eec1e670/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fapp-route.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/dfd3c2600029ab1ec132fe0fc8d58706eec1e670/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fapp-route.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fapp-route.ts?ref=dfd3c2600029ab1ec132fe0fc8d58706eec1e670",
            "patch": "@@ -280,9 +280,7 @@ export async function handler(\n         }\n       })\n     }\n-    const isMinimalMode = Boolean(\n-      process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode')\n-    )\n+    const isMinimalMode = Boolean(getRequestMeta(req, 'minimalMode'))\n \n     const handleResponse = async (currentSpan?: Span) => {\n       const responseGenerator: ResponseGenerator = async ({"
        },
        {
            "sha": "ed10fac26a6ccf21da1d77e018ce569ae87eb474",
            "filename": "packages/next/src/server/route-modules/pages/pages-handler.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 3,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/dfd3c2600029ab1ec132fe0fc8d58706eec1e670/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Fpages%2Fpages-handler.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/dfd3c2600029ab1ec132fe0fc8d58706eec1e670/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Fpages%2Fpages-handler.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Fpages%2Fpages-handler.ts?ref=dfd3c2600029ab1ec132fe0fc8d58706eec1e670",
            "patch": "@@ -102,9 +102,7 @@ export const getHandler = ({\n       return\n     }\n \n-    const isMinimalMode = Boolean(\n-      process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode')\n-    )\n+    const isMinimalMode = Boolean(getRequestMeta(req, 'minimalMode'))\n \n     const render404 = async () => {\n       // TODO: should route-module itself handle rendering the 404"
        },
        {
            "sha": "39245272c51200e0c09aa16ed5b11cc769abf3fa",
            "filename": "packages/next/src/server/route-modules/route-module.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 4,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/dfd3c2600029ab1ec132fe0fc8d58706eec1e670/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Froute-module.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/dfd3c2600029ab1ec132fe0fc8d58706eec1e670/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Froute-module.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Froute-module.ts?ref=dfd3c2600029ab1ec132fe0fc8d58706eec1e670",
            "patch": "@@ -965,10 +965,7 @@ export abstract class RouteModule<\n \n   public getResponseCache(req: IncomingMessage | BaseNextRequest) {\n     if (!this.responseCache) {\n-      const minimalMode =\n-        (Boolean(process.env.MINIMAL_MODE) ||\n-          getRequestMeta(req, 'minimalMode')) ??\n-        false\n+      const minimalMode = getRequestMeta(req, 'minimalMode') ?? false\n       this.responseCache = new ResponseCache(minimalMode)\n     }\n     return this.responseCache"
        },
        {
            "sha": "bdaae733f7ab97baf561402468457f70f26195f1",
            "filename": "test/e2e/app-dir/cache-components/my-adapter.mjs",
            "status": "added",
            "additions": 181,
            "deletions": 0,
            "changes": 181,
            "blob_url": "https://github.com/vercel/next.js/blob/dfd3c2600029ab1ec132fe0fc8d58706eec1e670/test%2Fe2e%2Fapp-dir%2Fcache-components%2Fmy-adapter.mjs",
            "raw_url": "https://github.com/vercel/next.js/raw/dfd3c2600029ab1ec132fe0fc8d58706eec1e670/test%2Fe2e%2Fapp-dir%2Fcache-components%2Fmy-adapter.mjs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fcache-components%2Fmy-adapter.mjs?ref=dfd3c2600029ab1ec132fe0fc8d58706eec1e670",
            "patch": "@@ -0,0 +1,181 @@\n+/**\n+ * This adapter is not modifying outputs or the test\n+ * it is just adding additional assertions ensuring\n+ * we provide the expected outputs and file paths are valid\n+ */\n+import fs from 'fs'\n+\n+// @ts-check\n+/** @type {import('next').NextAdapter } */\n+const myAdapter = {\n+  name: 'my-custom-adapter',\n+  modifyConfig: (config, { phase }) => {\n+    if (process.env.NODE_ENV !== 'production') return config\n+    if (typeof phase !== 'string') {\n+      throw new Error(`invalid phase value provided to modifyConfig ${phase}`)\n+    }\n+    console.log('called modify config in adapter with phase', phase)\n+    return config\n+  },\n+  onBuildComplete: async (ctx) => {\n+    console.log('onBuildComplete called')\n+\n+    // Validate all output file paths exist on the filesystem\n+    const allOutputs = [\n+      ...ctx.outputs.pages,\n+      ...ctx.outputs.pagesApi,\n+      ...ctx.outputs.appPages,\n+      ...ctx.outputs.appRoutes,\n+      ...ctx.outputs.prerenders,\n+      ...ctx.outputs.staticFiles,\n+    ]\n+\n+    if (ctx.outputs.middleware) {\n+      allOutputs.push(ctx.outputs.middleware)\n+    }\n+\n+    const validationErrors = []\n+\n+    // Check that all filePaths in outputs exist\n+    for (const output of allOutputs) {\n+      if (output.filePath) {\n+        try {\n+          await fs.promises.access(output.filePath, fs.constants.F_OK)\n+        } catch (err) {\n+          validationErrors.push(\n+            `Missing file for output ${output.id}: ${output.filePath}`\n+          )\n+        }\n+      }\n+\n+      // Check fallback filePath for prerenders\n+      if (output.type === 'PRERENDER' && output.fallback) {\n+        if (output.fallback.filePath) {\n+          try {\n+            await fs.promises.access(\n+              output.fallback.filePath,\n+              fs.constants.F_OK\n+            )\n+          } catch (err) {\n+            validationErrors.push(\n+              `Missing fallback file for prerender ${output.id}: ${JSON.stringify(output, null, 2)}`\n+            )\n+          }\n+        } else if (!output.fallback.postponedState) {\n+          throw new Error(\n+            `Missing postponed state or filePath for prerender ${output.id} ${JSON.stringify(output, null, 2)}`\n+          )\n+        }\n+      }\n+\n+      // Check assets\n+      if (output.assets) {\n+        for (const [key, assetPath] of Object.entries(output.assets)) {\n+          try {\n+            await fs.promises.access(assetPath, fs.constants.F_OK)\n+          } catch (err) {\n+            validationErrors.push(\n+              `Missing asset file for output ${output.id} (${key}): ${assetPath}`\n+            )\n+          }\n+        }\n+      }\n+\n+      // Check wasmAssets\n+      if (output.wasmAssets) {\n+        for (const [key, wasmPath] of Object.entries(output.wasmAssets)) {\n+          try {\n+            await fs.promises.access(wasmPath, fs.constants.F_OK)\n+          } catch (err) {\n+            validationErrors.push(\n+              `Missing wasm file for output ${output.id} (${key}): ${wasmPath}`\n+            )\n+          }\n+        }\n+      }\n+    }\n+\n+    // Validate that segment routes are present in routing.dynamicRoutes\n+    // Segment routes match the pattern: .segments/.+.segment.rsc\n+    const segmentRoutes = ctx.routing.dynamicRoutes.filter((route) => {\n+      // Check if the source or destination contains segment routes\n+      return (\n+        route.sourceRegex.includes('.segments/') ||\n+        route.sourceRegex.includes('.segment.rsc')\n+      )\n+    })\n+\n+    // Ensure we have segment routes when we have app pages\n+    if (ctx.outputs.appPages.length > 0) {\n+      if (segmentRoutes.length === 0) {\n+        validationErrors.push(\n+          'Expected segment routes in routing.dynamicRoutes when app pages exist'\n+        )\n+      } else {\n+        console.log(\n+          `Found ${segmentRoutes.length} segment routes in routing.dynamicRoutes`\n+        )\n+      }\n+    }\n+\n+    // Validate that all appPages have matching .rsc and non .rsc pathnames\n+    const appPagePathnames = new Map()\n+    for (const appPage of ctx.outputs.appPages) {\n+      const pathname = appPage.pathname\n+      if (pathname.endsWith('.rsc')) {\n+        const basePathname = pathname.slice(0, -4) // Remove .rsc extension\n+        if (!appPagePathnames.has(basePathname)) {\n+          appPagePathnames.set(basePathname, { rsc: false, nonRsc: false })\n+        }\n+        appPagePathnames.get(basePathname).rsc = true\n+      } else {\n+        if (!appPagePathnames.has(pathname)) {\n+          appPagePathnames.set(pathname, { rsc: false, nonRsc: false })\n+        }\n+        appPagePathnames.get(pathname).nonRsc = true\n+      }\n+    }\n+\n+    // Check that each pathname has both .rsc and non .rsc versions\n+    for (const [pathname, versions] of appPagePathnames.entries()) {\n+      if (!versions.rsc) {\n+        validationErrors.push(\n+          `App page ${pathname} is missing corresponding .rsc pathname`\n+        )\n+      }\n+      if (!versions.nonRsc) {\n+        validationErrors.push(\n+          `App page ${pathname}.rsc is missing corresponding non .rsc pathname`\n+        )\n+      }\n+    }\n+\n+    if (appPagePathnames.size > 0) {\n+      console.log(\n+        `Validated ${appPagePathnames.size} app page pathname(s) have matching .rsc and non .rsc versions`\n+      )\n+    }\n+\n+    if (validationErrors.length > 0) {\n+      console.error('Validation errors:')\n+      for (const error of validationErrors) {\n+        console.error(`  - ${error}`)\n+      }\n+      throw new Error(\n+        `Adapter validation failed with ${validationErrors.length} error(s)`\n+      )\n+    }\n+\n+    console.log('Validation passed: All output files exist on filesystem')\n+    console.log(\n+      `Segment routes validated: ${segmentRoutes.length} routes found`\n+    )\n+\n+    await fs.promises.writeFile(\n+      'build-complete.json',\n+      JSON.stringify(ctx, null, 2)\n+    )\n+  },\n+}\n+\n+export default myAdapter"
        },
        {
            "sha": "d05012cdd262eecaba7152cd48b163e6dbda9c07",
            "filename": "test/e2e/app-dir/cache-components/next.config.js",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/dfd3c2600029ab1ec132fe0fc8d58706eec1e670/test%2Fe2e%2Fapp-dir%2Fcache-components%2Fnext.config.js",
            "raw_url": "https://github.com/vercel/next.js/raw/dfd3c2600029ab1ec132fe0fc8d58706eec1e670/test%2Fe2e%2Fapp-dir%2Fcache-components%2Fnext.config.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fcache-components%2Fnext.config.js?ref=dfd3c2600029ab1ec132fe0fc8d58706eec1e670",
            "patch": "@@ -3,6 +3,9 @@\n  */\n const nextConfig = {\n   cacheComponents: true,\n+  experimental: {\n+    adapterPath: require.resolve('./my-adapter.mjs'),\n+  },\n }\n \n module.exports = nextConfig"
        },
        {
            "sha": "543254f893e1a6378e0bddeac1bd93ef47934b76",
            "filename": "test/production/adapter-config/adapter-config.test.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 3,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/dfd3c2600029ab1ec132fe0fc8d58706eec1e670/test%2Fproduction%2Fadapter-config%2Fadapter-config.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/dfd3c2600029ab1ec132fe0fc8d58706eec1e670/test%2Fproduction%2Fadapter-config%2Fadapter-config.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fadapter-config%2Fadapter-config.test.ts?ref=dfd3c2600029ab1ec132fe0fc8d58706eec1e670",
            "patch": "@@ -110,10 +110,15 @@ describe('adapter-config', () => {\n       try {\n         expect(prerenderOutput.parentOutputId).toBeTruthy()\n         if (prerenderOutput.fallback) {\n-          const stats = await fs.promises.stat(\n+          if (\n+            'filePath' in prerenderOutput.fallback &&\n             prerenderOutput.fallback.filePath\n-          )\n-          expect(stats.isFile()).toBe(true)\n+          ) {\n+            const stats = await fs.promises.stat(\n+              prerenderOutput.fallback.filePath\n+            )\n+            expect(stats.isFile()).toBe(true)\n+          }\n           expect(prerenderOutput.fallback.initialRevalidate).toBeDefined()\n         }\n "
        },
        {
            "sha": "988e762ebdccb9551391d860a7821d717e57d17f",
            "filename": "test/production/adapter-config/my-adapter.mjs",
            "status": "modified",
            "additions": 169,
            "deletions": 0,
            "changes": 169,
            "blob_url": "https://github.com/vercel/next.js/blob/dfd3c2600029ab1ec132fe0fc8d58706eec1e670/test%2Fproduction%2Fadapter-config%2Fmy-adapter.mjs",
            "raw_url": "https://github.com/vercel/next.js/raw/dfd3c2600029ab1ec132fe0fc8d58706eec1e670/test%2Fproduction%2Fadapter-config%2Fmy-adapter.mjs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fadapter-config%2Fmy-adapter.mjs?ref=dfd3c2600029ab1ec132fe0fc8d58706eec1e670",
            "patch": "@@ -1,3 +1,8 @@\n+/**\n+ * This adapter is not modifying outputs or the test\n+ * it is just adding additional assertions ensuring\n+ * we provide the expected outputs and file paths are valid\n+ */\n import fs from 'fs'\n \n // @ts-check\n@@ -16,6 +21,170 @@ const myAdapter = {\n   onBuildComplete: async (ctx) => {\n     console.log('onBuildComplete called')\n \n+    // Validate all output file paths exist on the filesystem\n+    const allOutputs = [\n+      ...ctx.outputs.pages,\n+      ...ctx.outputs.pagesApi,\n+      ...ctx.outputs.appPages,\n+      ...ctx.outputs.appRoutes,\n+      ...ctx.outputs.prerenders,\n+      ...ctx.outputs.staticFiles,\n+    ]\n+\n+    if (ctx.outputs.middleware) {\n+      allOutputs.push(ctx.outputs.middleware)\n+    }\n+\n+    const validationErrors = []\n+\n+    // Check that all filePaths in outputs exist\n+    for (const output of allOutputs) {\n+      if (output.filePath) {\n+        try {\n+          await fs.promises.access(output.filePath, fs.constants.F_OK)\n+        } catch (err) {\n+          validationErrors.push(\n+            `Missing file for output ${output.id}: ${output.filePath}`\n+          )\n+        }\n+      }\n+\n+      // Check fallback filePath for prerenders\n+      if (output.type === 'PRERENDER' && output.fallback) {\n+        if (output.fallback.filePath) {\n+          try {\n+            await fs.promises.access(\n+              output.fallback.filePath,\n+              fs.constants.F_OK\n+            )\n+          } catch (err) {\n+            validationErrors.push(\n+              `Missing fallback file for prerender ${output.id}: ${JSON.stringify(output, null, 2)}`\n+            )\n+          }\n+        } else if (!output.fallback.postponedState) {\n+          throw new Error(\n+            `Missing postponed state or filePath for prerender ${output.id} ${JSON.stringify(output, null, 2)}`\n+          )\n+        }\n+      }\n+\n+      // Check assets\n+      if (output.assets) {\n+        for (const [key, assetPath] of Object.entries(output.assets)) {\n+          try {\n+            await fs.promises.access(assetPath, fs.constants.F_OK)\n+          } catch (err) {\n+            validationErrors.push(\n+              `Missing asset file for output ${output.id} (${key}): ${assetPath}`\n+            )\n+          }\n+        }\n+      }\n+\n+      // Check wasmAssets\n+      if (output.wasmAssets) {\n+        for (const [key, wasmPath] of Object.entries(output.wasmAssets)) {\n+          try {\n+            await fs.promises.access(wasmPath, fs.constants.F_OK)\n+          } catch (err) {\n+            validationErrors.push(\n+              `Missing wasm file for output ${output.id} (${key}): ${wasmPath}`\n+            )\n+          }\n+        }\n+      }\n+    }\n+\n+    // Validate that segment routes are present in routing.dynamicRoutes\n+    // Segment routes match the pattern: .segments/.+.segment.rsc\n+    const segmentRoutes = ctx.routing.dynamicRoutes.filter((route) => {\n+      // Check if the source or destination contains segment routes\n+      return (\n+        route.sourceRegex.includes('.segments/') ||\n+        route.sourceRegex.includes('.segment.rsc')\n+      )\n+    })\n+\n+    // Ensure we have segment routes when we have app pages\n+    if (ctx.outputs.appPages.length > 0) {\n+      if (segmentRoutes.length === 0) {\n+        validationErrors.push(\n+          'Expected segment routes in routing.dynamicRoutes when app pages exist'\n+        )\n+      } else {\n+        console.log(\n+          `Found ${segmentRoutes.length} segment routes in routing.dynamicRoutes`\n+        )\n+      }\n+    }\n+\n+    // Validate that all appPages have matching .rsc and non .rsc pathnames\n+    const appPagePathnames = new Map()\n+\n+    // Helper function to normalize /index to / for matching\n+    const normalizePathname = (pathname) => {\n+      if (pathname.endsWith('/index')) {\n+        return pathname.slice(0, -6) || '/'\n+      }\n+      return pathname\n+    }\n+\n+    for (const appPage of ctx.outputs.appPages) {\n+      const pathname = appPage.pathname\n+      if (pathname.endsWith('.rsc')) {\n+        const basePathname = normalizePathname(pathname.slice(0, -4)) // Remove .rsc extension and normalize\n+        if (!appPagePathnames.has(basePathname)) {\n+          appPagePathnames.set(basePathname, { rsc: false, nonRsc: false })\n+        }\n+        appPagePathnames.get(basePathname).rsc = true\n+      } else {\n+        const normalizedPathname = normalizePathname(pathname)\n+        if (!appPagePathnames.has(normalizedPathname)) {\n+          appPagePathnames.set(normalizedPathname, {\n+            rsc: false,\n+            nonRsc: false,\n+          })\n+        }\n+        appPagePathnames.get(normalizedPathname).nonRsc = true\n+      }\n+    }\n+\n+    // Check that each pathname has both .rsc and non .rsc versions\n+    for (const [pathname, versions] of appPagePathnames.entries()) {\n+      if (!versions.rsc) {\n+        validationErrors.push(\n+          `App page ${pathname} is missing corresponding .rsc pathname`\n+        )\n+      }\n+      if (!versions.nonRsc) {\n+        validationErrors.push(\n+          `App page ${pathname}.rsc is missing corresponding non .rsc pathname`\n+        )\n+      }\n+    }\n+\n+    if (appPagePathnames.size > 0) {\n+      console.log(\n+        `Validated ${appPagePathnames.size} app page pathname(s) have matching .rsc and non .rsc versions`\n+      )\n+    }\n+\n+    if (validationErrors.length > 0) {\n+      console.error('Validation errors:')\n+      for (const error of validationErrors) {\n+        console.error(`  - ${error}`)\n+      }\n+      throw new Error(\n+        `Adapter validation failed with ${validationErrors.length} error(s)`\n+      )\n+    }\n+\n+    console.log('Validation passed: All output files exist on filesystem')\n+    console.log(\n+      `Segment routes validated: ${segmentRoutes.length} routes found`\n+    )\n+\n     await fs.promises.writeFile(\n       'build-complete.json',\n       JSON.stringify(ctx, null, 2)"
        },
        {
            "sha": "f2ea84c2150bef280fcfb361da68bb926fbf05af",
            "filename": "test/production/adapter-config/next.config.mjs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/dfd3c2600029ab1ec132fe0fc8d58706eec1e670/test%2Fproduction%2Fadapter-config%2Fnext.config.mjs",
            "raw_url": "https://github.com/vercel/next.js/raw/dfd3c2600029ab1ec132fe0fc8d58706eec1e670/test%2Fproduction%2Fadapter-config%2Fnext.config.mjs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fadapter-config%2Fnext.config.mjs?ref=dfd3c2600029ab1ec132fe0fc8d58706eec1e670",
            "patch": "@@ -5,8 +5,8 @@ const require = Module.createRequire(import.meta.url)\n const nextConfig = {\n   experimental: {\n     adapterPath: require.resolve('./my-adapter.mjs'),\n-    cacheComponents: process.env.TEST_CACHE_COMPONENTS === '1',\n   },\n+  cacheComponents: process.env.TEST_CACHE_COMPONENTS === '1',\n   rewrites() {\n     return [\n       {"
        }
    ],
    "stats": {
        "total": 559,
        "additions": 480,
        "deletions": 79
    }
}