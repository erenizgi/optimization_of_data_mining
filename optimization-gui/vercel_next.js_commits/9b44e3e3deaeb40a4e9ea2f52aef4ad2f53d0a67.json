{
    "author": "sokra",
    "message": "Turbopack: avoid storing task data and task cache concurrenctly (#78775)\n\n### What?\n\nAvoid to concurrently write task data and task cache as it increases memory usage by a lot.",
    "sha": "9b44e3e3deaeb40a4e9ea2f52aef4ad2f53d0a67",
    "files": [
        {
            "sha": "76086f8a004bbbee13526b9cdc905be3f21c1336",
            "filename": "turbopack/crates/turbo-tasks-backend/src/kv_backing_storage.rs",
            "status": "modified",
            "additions": 67,
            "deletions": 75,
            "changes": 142,
            "blob_url": "https://github.com/vercel/next.js/blob/9b44e3e3deaeb40a4e9ea2f52aef4ad2f53d0a67/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fkv_backing_storage.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/9b44e3e3deaeb40a4e9ea2f52aef4ad2f53d0a67/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fkv_backing_storage.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fkv_backing_storage.rs?ref=9b44e3e3deaeb40a4e9ea2f52aef4ad2f53d0a67",
            "patch": "@@ -177,92 +177,84 @@ impl<T: KeyValueDatabase + Send + Sync + 'static> BackingStorage\n     {\n         let _span = tracing::trace_span!(\"save snapshot\", session_id = ?session_id, operations = operations.len());\n         let mut batch = self.database.write_batch()?;\n-        let mut task_items_result = Ok(Vec::new());\n \n         // Start organizing the updates in parallel\n         match &mut batch {\n             WriteBatch::Concurrent(ref batch, _) => {\n-                turbo_tasks::scope(|s| {\n-                    s.spawn(|_| {\n-                        let _span = tracing::trace_span!(\"update task meta\").entered();\n-                        task_items_result = process_task_data(snapshots, Some(batch));\n-                    });\n+                {\n+                    let _span = tracing::trace_span!(\"update task data\").entered();\n+                    process_task_data(snapshots, Some(batch))?;\n+                }\n \n-                    let mut next_task_id =\n-                        get_next_free_task_id::<\n-                            T::SerialWriteBatch<'_>,\n-                            T::ConcurrentWriteBatch<'_>,\n-                        >(&mut WriteBatchRef::concurrent(batch))?;\n+                let mut next_task_id = get_next_free_task_id::<\n+                    T::SerialWriteBatch<'_>,\n+                    T::ConcurrentWriteBatch<'_>,\n+                >(&mut WriteBatchRef::concurrent(batch))?;\n \n-                    {\n-                        let _span = tracing::trace_span!(\n-                            \"update task cache\",\n-                            items = task_cache_updates.iter().map(|m| m.len()).sum::<usize>()\n-                        )\n-                        .entered();\n-                        let result = task_cache_updates\n-                            .into_par_iter()\n-                            .with_max_len(1)\n-                            .map(|updates| {\n-                                let mut max_task_id = 0;\n-\n-                                let mut task_type_bytes = Vec::new();\n-                                for (task_type, task_id) in updates {\n-                                    let task_id: u32 = *task_id;\n-                                    serialize_task_type(&task_type, &mut task_type_bytes, task_id)?;\n-\n-                                    batch\n-                                        .put(\n-                                            KeySpace::ForwardTaskCache,\n-                                            WriteBuffer::Borrowed(&task_type_bytes),\n-                                            WriteBuffer::Borrowed(&task_id.to_le_bytes()),\n+                {\n+                    let _span = tracing::trace_span!(\n+                        \"update task cache\",\n+                        items = task_cache_updates.iter().map(|m| m.len()).sum::<usize>()\n+                    )\n+                    .entered();\n+                    let result = task_cache_updates\n+                        .into_par_iter()\n+                        .with_max_len(1)\n+                        .map(|updates| {\n+                            let mut max_task_id = 0;\n+\n+                            let mut task_type_bytes = Vec::new();\n+                            for (task_type, task_id) in updates {\n+                                let task_id: u32 = *task_id;\n+                                serialize_task_type(&task_type, &mut task_type_bytes, task_id)?;\n+\n+                                batch\n+                                    .put(\n+                                        KeySpace::ForwardTaskCache,\n+                                        WriteBuffer::Borrowed(&task_type_bytes),\n+                                        WriteBuffer::Borrowed(&task_id.to_le_bytes()),\n+                                    )\n+                                    .with_context(|| {\n+                                        anyhow!(\n+                                            \"Unable to write task cache {task_type:?} => {task_id}\"\n                                         )\n-                                        .with_context(|| {\n-                                            anyhow!(\n-                                                \"Unable to write task cache {task_type:?} => \\\n-                                                 {task_id}\"\n-                                            )\n-                                        })?;\n-                                    batch\n-                                        .put(\n-                                            KeySpace::ReverseTaskCache,\n-                                            WriteBuffer::Borrowed(IntKey::new(task_id).as_ref()),\n-                                            WriteBuffer::Borrowed(&task_type_bytes),\n+                                    })?;\n+                                batch\n+                                    .put(\n+                                        KeySpace::ReverseTaskCache,\n+                                        WriteBuffer::Borrowed(IntKey::new(task_id).as_ref()),\n+                                        WriteBuffer::Borrowed(&task_type_bytes),\n+                                    )\n+                                    .with_context(|| {\n+                                        anyhow!(\n+                                            \"Unable to write task cache {task_id} => {task_type:?}\"\n                                         )\n-                                        .with_context(|| {\n-                                            anyhow!(\n-                                                \"Unable to write task cache {task_id} => \\\n-                                                 {task_type:?}\"\n-                                            )\n-                                        })?;\n-                                    max_task_id = max_task_id.max(task_id + 1);\n-                                }\n-\n-                                Ok(max_task_id)\n-                            })\n-                            .reduce(\n-                                || Ok(0),\n-                                |a, b| -> anyhow::Result<_> {\n-                                    let a_max = a?;\n-                                    let b_max = b?;\n-                                    Ok(max(a_max, b_max))\n-                                },\n-                            )?;\n-                        next_task_id = next_task_id.max(result);\n-                    }\n-\n-                    save_infra::<T::SerialWriteBatch<'_>, T::ConcurrentWriteBatch<'_>>(\n-                        &mut WriteBatchRef::concurrent(batch),\n-                        next_task_id,\n-                        session_id,\n-                        operations,\n-                    )?;\n-                    anyhow::Ok(())\n-                })?;\n+                                    })?;\n+                                max_task_id = max_task_id.max(task_id + 1);\n+                            }\n+\n+                            Ok(max_task_id)\n+                        })\n+                        .reduce(\n+                            || Ok(0),\n+                            |a, b| -> anyhow::Result<_> {\n+                                let a_max = a?;\n+                                let b_max = b?;\n+                                Ok(max(a_max, b_max))\n+                            },\n+                        )?;\n+                    next_task_id = next_task_id.max(result);\n+                }\n \n-                task_items_result?;\n+                save_infra::<T::SerialWriteBatch<'_>, T::ConcurrentWriteBatch<'_>>(\n+                    &mut WriteBatchRef::concurrent(batch),\n+                    next_task_id,\n+                    session_id,\n+                    operations,\n+                )?;\n             }\n             WriteBatch::Serial(batch) => {\n+                let mut task_items_result = Ok(Vec::new());\n                 turbo_tasks::scope(|s| {\n                     s.spawn(|_| {\n                         task_items_result ="
        }
    ],
    "stats": {
        "total": 142,
        "additions": 67,
        "deletions": 75
    }
}