{
    "author": "acdlite",
    "message": "Reserve bandwidth for most recently hovered link  (#78362)\n\nThe prefetch scheduler limits the number of concurrent prefetch\nrequests, to avoid saturating browser's internal network queue. As a\nstarting point, I had previously hardcoded this to 3 — intentionally\nstingy, to leave room for additional optimizations.\n\nIn this PR, I allow the most recently hovered link to exceed the default\nlimit. This increased limit only applies to the *most recently* hovered\nlink; if a different link is hovered, the previous one is bumped back\ndown to the default.\n\nThe principle is that when hovering over a new link, we should have\nenough bandwidth to start prefetching its data. (In practice, because we\ndon't cancel in-progress requests, it's still possible that we'll fill\nup the queue, but this makes it less likely.)\n\nAs part of this change, I changed the implementation of the internal\nIntent priority level. Intent used to assigned to any link that was ever\nhovered over; it would never get bumped back down to Default, even on\nmouseexit. This was intentional at the time, but given this new\noptimizaiton, it makes more sense to downgrade previously hovered links\nto free up the bandwidth.",
    "sha": "4857fcee5795e551af18af10d744d8e40227f0bd",
    "files": [
        {
            "sha": "dc3c21010b53a74a8b121e34a47217ffda64692d",
            "filename": "packages/next/src/client/components/links.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 21,
            "changes": 28,
            "blob_url": "https://github.com/vercel/next.js/blob/4857fcee5795e551af18af10d744d8e40227f0bd/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Flinks.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/4857fcee5795e551af18af10d744d8e40227f0bd/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Flinks.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Flinks.ts?ref=4857fcee5795e551af18af10d744d8e40227f0bd",
            "patch": "@@ -25,7 +25,6 @@ type LinkOrFormInstanceShared = {\n   kind: PrefetchKind.AUTO | PrefetchKind.FULL\n \n   isVisible: boolean\n-  wasHoveredOrTouched: boolean\n \n   // The most recently initiated prefetch task. It may or may not have\n   // already completed. The same prefetch task object can be reused across\n@@ -152,7 +151,6 @@ export function mountLinkInstance(\n         router,\n         kind,\n         isVisible: false,\n-        wasHoveredOrTouched: false,\n         prefetchTask: null,\n         prefetchHref: prefetchURL.href,\n         setOptimisticLinkStatus,\n@@ -169,7 +167,6 @@ export function mountLinkInstance(\n     router,\n     kind,\n     isVisible: false,\n-    wasHoveredOrTouched: false,\n     prefetchTask: null,\n     prefetchHref: null,\n     setOptimisticLinkStatus,\n@@ -195,7 +192,6 @@ export function mountFormInstance(\n     router,\n     kind,\n     isVisible: false,\n-    wasHoveredOrTouched: false,\n     prefetchTask: null,\n     prefetchHref: prefetchURL.href,\n     setOptimisticLinkStatus: null,\n@@ -247,7 +243,7 @@ export function onLinkVisibilityChanged(element: Element, isVisible: boolean) {\n   } else {\n     prefetchableAndVisible.delete(instance)\n   }\n-  rescheduleLinkPrefetch(instance)\n+  rescheduleLinkPrefetch(instance, PrefetchPriority.Default)\n }\n \n export function onNavigationIntent(\n@@ -260,19 +256,21 @@ export function onNavigationIntent(\n   }\n   // Prefetch the link on hover/touchstart.\n   if (instance !== undefined) {\n-    instance.wasHoveredOrTouched = true\n     if (\n       process.env.__NEXT_DYNAMIC_ON_HOVER &&\n       unstable_upgradeToDynamicPrefetch\n     ) {\n       // Switch to a full, dynamic prefetch\n       instance.kind = PrefetchKind.FULL\n     }\n-    rescheduleLinkPrefetch(instance)\n+    rescheduleLinkPrefetch(instance, PrefetchPriority.Intent)\n   }\n }\n \n-function rescheduleLinkPrefetch(instance: PrefetchableInstance) {\n+function rescheduleLinkPrefetch(\n+  instance: PrefetchableInstance,\n+  priority: PrefetchPriority.Default | PrefetchPriority.Intent\n+) {\n   const existingPrefetchTask = instance.prefetchTask\n \n   if (!instance.isVisible) {\n@@ -295,15 +293,6 @@ function rescheduleLinkPrefetch(instance: PrefetchableInstance) {\n     return\n   }\n \n-  // In the Segment Cache implementation, we assign a higher priority level to\n-  // links that were at one point hovered or touched. Since the queue is last-\n-  // in-first-out, the highest priority Link is whichever one was hovered last.\n-  //\n-  // We also increase the relative priority of links whenever they re-enter the\n-  // viewport, as if they were being scheduled for the first time.\n-  const priority = instance.wasHoveredOrTouched\n-    ? PrefetchPriority.Intent\n-    : PrefetchPriority.Default\n   const appRouterState = getCurrentAppRouterState()\n   if (appRouterState !== null) {\n     const treeAtTimeOfPrefetch = appRouterState.tree\n@@ -355,14 +344,11 @@ export function pingVisibleLinks(\n       cancelPrefetchTask(task)\n     }\n     const cacheKey = createCacheKey(instance.prefetchHref, nextUrl)\n-    const priority = instance.wasHoveredOrTouched\n-      ? PrefetchPriority.Intent\n-      : PrefetchPriority.Default\n     instance.prefetchTask = scheduleSegmentPrefetchTask(\n       cacheKey,\n       tree,\n       instance.kind === PrefetchKind.FULL,\n-      priority,\n+      PrefetchPriority.Default,\n       null\n     )\n   }"
        },
        {
            "sha": "f0c1652ca599d0a80698cf15d0d3becd4d9900ca",
            "filename": "packages/next/src/client/components/segment-cache-impl/scheduler.ts",
            "status": "modified",
            "additions": 55,
            "deletions": 13,
            "changes": 68,
            "blob_url": "https://github.com/vercel/next.js/blob/4857fcee5795e551af18af10d744d8e40227f0bd/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fscheduler.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/4857fcee5795e551af18af10d744d8e40227f0bd/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fscheduler.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fscheduler.ts?ref=4857fcee5795e551af18af10d744d8e40227f0bd",
            "patch": "@@ -169,14 +169,16 @@ export type PrefetchSubtaskResult<T> = {\n \n const taskHeap: Array<PrefetchTask> = []\n \n-// This is intentionally low so that when a navigation happens, the browser's\n-// internal network queue is not already saturated with prefetch requests.\n-const MAX_CONCURRENT_PREFETCH_REQUESTS = 3\n let inProgressRequests = 0\n \n let sortIdCounter = 0\n let didScheduleMicrotask = false\n \n+// The most recently hovered (or touched, etc) link, i.e. the most recent task\n+// scheduled at Intent priority. There's only ever a single task at Intent\n+// priority at a time. We reserve special network bandwidth for this task only.\n+let mostRecentlyHoveredLink: PrefetchTask | null = null\n+\n /**\n  * Initiates a prefetch task for the given URL. If a prefetch for the same URL\n  * is already in progress, this will bump it to the top of the queue.\n@@ -210,6 +212,9 @@ export function schedulePrefetchTask(\n     onInvalidate,\n     _heapIndex: -1,\n   }\n+\n+  trackMostRecentlyHoveredLink(task)\n+\n   heapPush(taskHeap, task)\n \n   // Schedule an async task to process the queue.\n@@ -254,11 +259,16 @@ export function reschedulePrefetchTask(\n   // Assign a new sort ID to move it ahead of all other tasks at the same\n   // priority level. (Higher sort IDs are processed first.)\n   task.sortId = sortIdCounter++\n-  task.priority = priority\n+  task.priority =\n+    // If this task is the most recently hovered link, maintain its\n+    // Intent priority, even if the rescheduled priority is lower.\n+    task === mostRecentlyHoveredLink ? PrefetchPriority.Intent : priority\n \n   task.treeAtTimeOfPrefetch = treeAtTimeOfPrefetch\n   task.includeDynamicData = includeDynamicData\n \n+  trackMostRecentlyHoveredLink(task)\n+\n   if (task._heapIndex !== -1) {\n     // The task is already in the queue.\n     heapResift(taskHeap, task)\n@@ -286,11 +296,27 @@ export function isPrefetchTaskDirty(\n   )\n }\n \n+function trackMostRecentlyHoveredLink(task: PrefetchTask) {\n+  // Track the mostly recently hovered link, i.e. the most recently scheduled\n+  // task at Intent priority. There must only be one such task at a time.\n+  if (\n+    task.priority === PrefetchPriority.Intent &&\n+    task !== mostRecentlyHoveredLink\n+  ) {\n+    if (mostRecentlyHoveredLink !== null) {\n+      // Bump the previously hovered link's priority down to Default.\n+      if (mostRecentlyHoveredLink.priority !== PrefetchPriority.Background) {\n+        mostRecentlyHoveredLink.priority = PrefetchPriority.Default\n+        heapResift(taskHeap, mostRecentlyHoveredLink)\n+      }\n+    }\n+    mostRecentlyHoveredLink = task\n+  }\n+}\n+\n function ensureWorkIsScheduled() {\n-  if (didScheduleMicrotask || !hasNetworkBandwidth()) {\n-    // Either we already scheduled a task to process the queue, or there are\n-    // too many concurrent requests in progress. In the latter case, the\n-    // queue will resume processing once more bandwidth is available.\n+  if (didScheduleMicrotask) {\n+    // Already scheduled a task to process the queue\n     return\n   }\n   didScheduleMicrotask = true\n@@ -303,12 +329,28 @@ function ensureWorkIsScheduled() {\n  * cooperative limit — prefetch tasks should check this before issuing\n  * new requests.\n  */\n-function hasNetworkBandwidth(): boolean {\n+function hasNetworkBandwidth(task: PrefetchTask): boolean {\n   // TODO: Also check if there's an in-progress navigation. We should never\n   // add prefetch requests to the network queue if an actual navigation is\n   // taking place, to ensure there's sufficient bandwidth for render-blocking\n   // data and resources.\n-  return inProgressRequests < MAX_CONCURRENT_PREFETCH_REQUESTS\n+\n+  // TODO: Consider reserving some amount of bandwidth for static prefetches.\n+\n+  if (task.priority === PrefetchPriority.Intent) {\n+    // The most recently hovered link is allowed to exceed the default limit.\n+    //\n+    // The goal is to always have enough bandwidth to start a new prefetch\n+    // request when hovering over a link.\n+    //\n+    // However, because we don't abort in-progress requests, it's still possible\n+    // we'll run out of bandwidth. When links are hovered in quick succession,\n+    // there could be multiple hover requests running simultaneously.\n+    return inProgressRequests < 12\n+  }\n+\n+  // The default limit is lower than the limit for a hovered link.\n+  return inProgressRequests < 4\n }\n \n function spawnPrefetchSubtask<T>(\n@@ -375,7 +417,7 @@ function processQueueInMicrotask() {\n \n   // Process the task queue until we run out of network bandwidth.\n   let task = heapPeek(taskHeap)\n-  while (task !== null && hasNetworkBandwidth()) {\n+  while (task !== null && hasNetworkBandwidth(task)) {\n     task.cacheVersion = getCurrentCacheVersion()\n \n     const route = readOrCreateRouteCacheEntry(now, task)\n@@ -496,7 +538,7 @@ function pingRootRouteTree(\n         return PrefetchTaskExitStatus.Done\n       }\n       // Recursively fill in the segment tree.\n-      if (!hasNetworkBandwidth()) {\n+      if (!hasNetworkBandwidth(task)) {\n         // Stop prefetching segments until there's more bandwidth.\n         return PrefetchTaskExitStatus.InProgress\n       }\n@@ -565,7 +607,7 @@ function pingPPRRouteTree(\n   const segment = readOrCreateSegmentCacheEntry(now, task, route, tree.key)\n   pingPerSegment(now, task, route, segment, task.key, tree.key)\n   if (tree.slots !== null) {\n-    if (!hasNetworkBandwidth()) {\n+    if (!hasNetworkBandwidth(task)) {\n       // Stop prefetching segments until there's more bandwidth.\n       return PrefetchTaskExitStatus.InProgress\n     }"
        },
        {
            "sha": "54ca4bae9517d5b84796dd0228e48bedb8ff6b84",
            "filename": "packages/next/src/client/components/segment-cache.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/4857fcee5795e551af18af10d744d8e40227f0bd/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/4857fcee5795e551af18af10d744d8e40227f0bd/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache.ts?ref=4857fcee5795e551af18af10d744d8e40227f0bd",
            "patch": "@@ -118,9 +118,10 @@ export const enum NavigationResultTag {\n  */\n export const enum PrefetchPriority {\n   /**\n-   * Assigned to any visible link that was hovered/touched at some point. This\n-   * is not removed on mouse exit, because a link that was momentarily\n-   * hovered is more likely to to be interacted with than one that was not.\n+   * Assigned to the most recently hovered/touched link. Special network\n+   * bandwidth is reserved for this task only. There's only ever one Intent-\n+   * priority task at a time; when a new Intent task is scheduled, the previous\n+   * one is bumped down to Default.\n    */\n   Intent = 2,\n   /**"
        },
        {
            "sha": "bb50b14ba16cb6b9b8ac2eb72191f33225652436",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-scheduling/prefetch-scheduling.test.ts",
            "status": "modified",
            "additions": 59,
            "deletions": 50,
            "changes": 109,
            "blob_url": "https://github.com/vercel/next.js/blob/4857fcee5795e551af18af10d744d8e40227f0bd/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-scheduling%2Fprefetch-scheduling.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/4857fcee5795e551af18af10d744d8e40227f0bd/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-scheduling%2Fprefetch-scheduling.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-scheduling%2Fprefetch-scheduling.test.ts?ref=4857fcee5795e551af18af10d744d8e40227f0bd",
            "patch": "@@ -94,58 +94,67 @@ describe('segment cache prefetch scheduling', () => {\n     ])\n   })\n \n-  it(\n-    'even on mouseexit, any link that was previously hovered is prioritized ' +\n-      'over links that were never hovered at all',\n-    async () => {\n-      let act: ReturnType<typeof createRouterAct>\n-      const browser = await next.browser('/cancellation', {\n-        beforePageLoad(p: Playwright.Page) {\n-          act = createRouterAct(p)\n-        },\n-      })\n-\n-      const checkbox = await browser.elementByCss('input[type=\"checkbox\"]')\n-      await act(\n-        async () => {\n-          // Reveal the links to start prefetching, but block the responses from\n-          // reaching the client. This will initiate prefetches for the route\n-          // trees, but it won't start prefetching any segment data yet until the\n-          // trees have loaded.\n-          await act(async () => {\n-            await checkbox.click()\n-          }, 'block')\n-\n-          // Hover over a link to increase its relative priority.\n-          const link2 = await browser.elementByCss('a[href=\"/cancellation/2\"]')\n-          await link2.hover()\n+  it('reserve special bandwidth for the most recently hovered link', async () => {\n+    let act: ReturnType<typeof createRouterAct>\n+    const browser = await next.browser('/cancellation', {\n+      beforePageLoad(p: Playwright.Page) {\n+        act = createRouterAct(p)\n+      },\n+    })\n \n-          // Hover over a different link to increase its relative priority.\n-          const link5 = await browser.elementByCss('a[href=\"/cancellation/5\"]')\n-          await link5.hover()\n+    const checkbox = await browser.elementByCss('input[type=\"checkbox\"]')\n+    await act(async () => {\n+      // Reveal the links to start prefetching, but block the responses from\n+      // reaching the client. This will initiate prefetches for the route\n+      // trees, but it won't start prefetching any segment data yet until the\n+      // trees have loaded.\n+      await act(async () => {\n+        await checkbox.click()\n+      }, 'block')\n+\n+      // At this point, the network queue is already at max capacity, so\n+      // revealing more links won't initiate any new requests.\n+      await act(async () => {\n+        const showMoreLinksButton = await browser.elementById('show-more-links')\n+        await showMoreLinksButton.click()\n+      }, 'no-requests')\n+\n+      // However, when hovering over a link, the prefetch task is allowed to\n+      // exceed the default limit. So hovering over a link does initiate a\n+      // new request.\n+      await act(async () => {\n+        // Hover over a link. This will initiate a request for the route tree,\n+        // but before we're able to fetch the segments, we'll have already\n+        // hovered over a different link.\n+        const link2 = await browser.elementByCss('a[href=\"/cancellation/2\"]')\n+        await link2.hover()\n \n-          // Click on the \"Show More Links\" button to reveal additional links.\n-          // Even though these links are newer than the ones we hovered over,\n-          // the hovered links should be prefetched first.\n-          const showMoreLinksButton =\n-            await browser.elementById('show-more-links')\n-          await showMoreLinksButton.click()\n-        },\n-        // Assert that the segment data is prefetched in the expected order.\n-        [\n-          // The last link we hovered over should be the first to prefetch.\n-          { includes: 'Content of page 5' },\n-          // The second-to-last link we hovered over should come next.\n-          { includes: 'Content of page 2' },\n-          // Then assert on one of the links that were revealed when we click\n-          // the \"Show More Links\" button\n-          { includes: 'Content of page 10' },\n-          // Then assert on one of the other links that were revealed originally\n-          { includes: 'Content of page 4' },\n-        ]\n-      )\n-    }\n-  )\n+        // Immediately hover over a different link.\n+        const link3 = await browser.elementByCss('a[href=\"/cancellation/3\"]')\n+        await link3.hover()\n+      }, [\n+        // The most recently hovered link is allowed to finish loading its\n+        // segment data.\n+        { includes: 'Content of page 3' },\n+        // The previously hovered link was downgraded to the default priority,\n+        // so it should still be blocked.\n+        { includes: 'Content of page 2', block: 'reject' },\n+      ])\n+    }, [\n+      // Assert that everything else proceeds in the expected order. We don't\n+      // need to assert on every single prefetch response; I picked just a few\n+      // of them.\n+\n+      // The previously hovered link is the next to finish loading, because\n+      // even though it was downgraded to the default priority, it was still\n+      // moved ahead of the other default tasks.\n+      { includes: 'Content of page 2' },\n+      // Next are the links that were revealed by the \"Show More\" button.\n+      { includes: 'Content of page 8' },\n+      // Then the rest.\n+      { includes: 'Content of page 5' },\n+    ])\n+  })\n \n   it(\n     'cancels a viewport-initiated prefetch if the link leaves the viewport ' +"
        }
    ],
    "stats": {
        "total": 212,
        "additions": 125,
        "deletions": 87
    }
}