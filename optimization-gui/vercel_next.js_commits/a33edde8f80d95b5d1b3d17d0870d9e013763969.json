{
    "author": "unstubbable",
    "message": "Server actions should not read stale data after calling `revalidate*` (#76885)\n\nWhen a server action calls `revalidateTag`, or `revalidatePath` for the current route, and subsequently reads the cached data in the action itself (before rendering), we need to ensure that we don't return stale data for the affected `\"use cache\"` functions and/or `fetch` calls.\r\n\r\nPreviously, this was only guaranteed for the rendering phase after the action.\r\n\r\ncloses NAR-116",
    "sha": "a33edde8f80d95b5d1b3d17d0870d9e013763969",
    "files": [
        {
            "sha": "fd265819cc680c2c68118c1095b4e8a729d03007",
            "filename": "packages/next/src/server/lib/incremental-cache/index.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 3,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/a33edde8f80d95b5d1b3d17d0870d9e013763969/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fincremental-cache%2Findex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/a33edde8f80d95b5d1b3d17d0870d9e013763969/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fincremental-cache%2Findex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fincremental-cache%2Findex.ts?ref=a33edde8f80d95b5d1b3d17d0870d9e013763969",
            "patch": "@@ -35,6 +35,7 @@ import { InvariantError } from '../../../shared/lib/invariant-error'\n import type { Revalidate } from '../cache-control'\n import { updateImplicitTagsExpiration } from '../implicit-tags'\n import { getPreviouslyRevalidatedTags } from '../../server-utils'\n+import { workAsyncStorage } from '../../app-render/work-async-storage.external'\n \n export interface CacheHandlerContext {\n   fs?: CacheFs\n@@ -464,12 +465,15 @@ export class IncrementalCache implements IncrementalCacheType {\n         )\n       }\n \n+      const workStore = workAsyncStorage.getStore()\n       const combinedTags = [...(ctx.tags || []), ...(ctx.softTags || [])]\n       // if a tag was revalidated we don't return stale data\n       if (\n-        combinedTags.some((tag) => {\n-          return this.revalidatedTags?.includes(tag)\n-        })\n+        combinedTags.some(\n+          (tag) =>\n+            this.revalidatedTags?.includes(tag) ||\n+            workStore?.pendingRevalidatedTags?.includes(tag)\n+        )\n       ) {\n         return null\n       }"
        },
        {
            "sha": "c3c6a0f8298d482fd391c6f7523fda427d7736a3",
            "filename": "packages/next/src/server/use-cache/use-cache-wrapper.ts",
            "status": "modified",
            "additions": 50,
            "deletions": 15,
            "changes": 65,
            "blob_url": "https://github.com/vercel/next.js/blob/a33edde8f80d95b5d1b3d17d0870d9e013763969/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/a33edde8f80d95b5d1b3d17d0870d9e013763969/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts?ref=a33edde8f80d95b5d1b3d17d0870d9e013763969",
            "patch": "@@ -50,6 +50,7 @@ import {\n } from '../request/search-params'\n import type { Params } from '../request/params'\n import React from 'react'\n+import type { ImplicitTags } from '../lib/implicit-tags'\n \n type CacheKeyParts = [\n   buildId: string,\n@@ -698,21 +699,7 @@ export function cache(\n                 implicitTags?.tags ?? []\n               )\n \n-        if (\n-          entry &&\n-          // If the cache entry was tagged with a previously revalidated tag\n-          // (e.g. by a redirecting server action), we need to discard it.\n-          (entry.tags.some((tag) =>\n-            // TODO: Shouldn't we also consider pendingRevalidatedTags?\n-            // Curiously, this is currently not done for the incremental cache\n-            // handler. So a revalidating server action can read its own writes\n-            // only during subsequent rendering, but not in the action itself?\n-            workStore.previouslyRevalidatedTags.includes(tag)\n-          ) ||\n-            // If the cache entry was created before any of the implicit tags\n-            // were revalidated last, we need to discard it.\n-            (implicitTags && entry.timestamp <= implicitTags.expiration))\n-        ) {\n+        if (entry && shouldDiscardCacheEntry(entry, workStore, implicitTags)) {\n           entry = undefined\n         }\n \n@@ -937,3 +924,51 @@ function shouldForceRevalidate(\n \n   return false\n }\n+\n+function shouldDiscardCacheEntry(\n+  entry: CacheEntry,\n+  workStore: WorkStore,\n+  implicitTags: ImplicitTags | undefined\n+): boolean {\n+  // If the cache entry contains revalidated tags that the cache handler might\n+  // not know about yet, we need to discard it.\n+  if (entry.tags.some((tag) => isRecentlyRevalidatedTag(tag, workStore))) {\n+    return true\n+  }\n+\n+  if (implicitTags) {\n+    // If the cache entry was created before any of the implicit tags were\n+    // revalidated last, we also need to discard it.\n+    if (entry.timestamp <= implicitTags.expiration) {\n+      return true\n+    }\n+\n+    // Finally, if any of the implicit tags have been revalidated recently, we\n+    // also need to discard the cache entry.\n+    if (\n+      implicitTags.tags.some((tag) => isRecentlyRevalidatedTag(tag, workStore))\n+    ) {\n+      return true\n+    }\n+  }\n+\n+  return false\n+}\n+\n+function isRecentlyRevalidatedTag(tag: string, workStore: WorkStore): boolean {\n+  const { previouslyRevalidatedTags, pendingRevalidatedTags } = workStore\n+\n+  // Was the tag previously revalidated (e.g. by a redirecting server action)?\n+  if (previouslyRevalidatedTags.includes(tag)) {\n+    return true\n+  }\n+\n+  // It could also have been revalidated by the currently running server action.\n+  // In this case the revalidation might not have been propagated to the cache\n+  // handler yet, so we read it from the pending tags in the work store.\n+  if (pendingRevalidatedTags?.includes(tag)) {\n+    return true\n+  }\n+\n+  return false\n+}"
        },
        {
            "sha": "ad50c97db7db48c9aeca4f8e1e6c8f7f81bc292c",
            "filename": "test/e2e/app-dir/use-cache/app/cache-tag/page.tsx",
            "status": "modified",
            "additions": 0,
            "deletions": 6,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/a33edde8f80d95b5d1b3d17d0870d9e013763969/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2Fcache-tag%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/a33edde8f80d95b5d1b3d17d0870d9e013763969/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2Fcache-tag%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2Fcache-tag%2Fpage.tsx?ref=a33edde8f80d95b5d1b3d17d0870d9e013763969",
            "patch": "@@ -1,7 +1,6 @@\n import React from 'react'\n import { unstable_cacheTag as cacheTag } from 'next/cache'\n import { RevalidateButtons } from './buttons'\n-import Link from 'next/link'\n \n async function getCachedWithTag({\n   tag,\n@@ -54,11 +53,6 @@ export default async function Page() {\n       <p id=\"r1\">[r, c] {r1}</p>\n       <p id=\"r2\">[-] {r2}</p>\n       <RevalidateButtons />\n-      <p>\n-        <Link href=\"/revalidate-and-redirect\">\n-          Go to /revalidate-and-redirect\n-        </Link>\n-      </p>\n     </div>\n   )\n }"
        },
        {
            "sha": "2e19caba05eb5191aab3b87cd517465404ed6787",
            "filename": "test/e2e/app-dir/use-cache/app/revalidate-and-redirect/page.tsx",
            "status": "modified",
            "additions": 24,
            "deletions": 26,
            "changes": 50,
            "blob_url": "https://github.com/vercel/next.js/blob/a33edde8f80d95b5d1b3d17d0870d9e013763969/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2Frevalidate-and-redirect%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/a33edde8f80d95b5d1b3d17d0870d9e013763969/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2Frevalidate-and-redirect%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2Frevalidate-and-redirect%2Fpage.tsx?ref=a33edde8f80d95b5d1b3d17d0870d9e013763969",
            "patch": "@@ -1,31 +1,29 @@\n-import { revalidatePath, revalidateTag } from 'next/cache'\n-import { redirect } from 'next/navigation'\n+import React from 'react'\n+import { unstable_cacheTag as cacheTag } from 'next/cache'\n+import Link from 'next/link'\n+import { connection } from 'next/server'\n \n-export default function Page() {\n-  return (\n-    <form>\n-      <button\n-        id=\"revalidate-tag-redirect\"\n-        formAction={async () => {\n-          'use server'\n+async function getCachedValue() {\n+  'use cache'\n+  cacheTag('revalidate-and-redirect')\n+\n+  return Math.random()\n+}\n \n-          revalidateTag('a')\n-          redirect('/cache-tag')\n-        }}\n-      >\n-        Revalidate tag and redirect\n-      </button>{' '}\n-      <button\n-        id=\"revalidate-path-redirect\"\n-        formAction={async () => {\n-          'use server'\n+export default async function Page() {\n+  // Make the page dynamic, as we don't want to deal with ISR in this scenario.\n+  await connection()\n \n-          revalidatePath('/cache-tag')\n-          redirect('/cache-tag')\n-        }}\n-      >\n-        Revalidate path and redirect\n-      </button>\n-    </form>\n+  const a = await getCachedValue()\n+  const b = await getCachedValue()\n+\n+  return (\n+    <div>\n+      <p id=\"a\">{a}</p>\n+      <p id=\"b\">{b}</p>\n+      <Link href=\"/revalidate-and-redirect/redirect\">\n+        Go to /revalidate-and-redirect/redirect\n+      </Link>\n+    </div>\n   )\n }"
        },
        {
            "sha": "f96828fa42b43c94677b0e20cfda0390863e948b",
            "filename": "test/e2e/app-dir/use-cache/app/revalidate-and-redirect/redirect/page.tsx",
            "status": "added",
            "additions": 31,
            "deletions": 0,
            "changes": 31,
            "blob_url": "https://github.com/vercel/next.js/blob/a33edde8f80d95b5d1b3d17d0870d9e013763969/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2Frevalidate-and-redirect%2Fredirect%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/a33edde8f80d95b5d1b3d17d0870d9e013763969/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2Frevalidate-and-redirect%2Fredirect%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2Frevalidate-and-redirect%2Fredirect%2Fpage.tsx?ref=a33edde8f80d95b5d1b3d17d0870d9e013763969",
            "patch": "@@ -0,0 +1,31 @@\n+import { revalidatePath, revalidateTag } from 'next/cache'\n+import { redirect } from 'next/navigation'\n+\n+export default function Page() {\n+  return (\n+    <form>\n+      <button\n+        id=\"revalidate-tag-redirect\"\n+        formAction={async () => {\n+          'use server'\n+\n+          revalidateTag('revalidate-and-redirect')\n+          redirect('/revalidate-and-redirect')\n+        }}\n+      >\n+        Revalidate tag and redirect\n+      </button>{' '}\n+      <button\n+        id=\"revalidate-path-redirect\"\n+        formAction={async () => {\n+          'use server'\n+\n+          revalidatePath('/revalidate-and-redirect')\n+          redirect('/revalidate-and-redirect')\n+        }}\n+      >\n+        Revalidate path and redirect\n+      </button>\n+    </form>\n+  )\n+}"
        },
        {
            "sha": "6ba22d4f155b6e86d4d4a1e5e56cbaf13e1aff78",
            "filename": "test/e2e/app-dir/use-cache/app/revalidate-and-use/form.tsx",
            "status": "added",
            "additions": 47,
            "deletions": 0,
            "changes": 47,
            "blob_url": "https://github.com/vercel/next.js/blob/a33edde8f80d95b5d1b3d17d0870d9e013763969/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2Frevalidate-and-use%2Fform.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/a33edde8f80d95b5d1b3d17d0870d9e013763969/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2Frevalidate-and-use%2Fform.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2Frevalidate-and-use%2Fform.tsx?ref=a33edde8f80d95b5d1b3d17d0870d9e013763969",
            "patch": "@@ -0,0 +1,47 @@\n+'use client'\n+\n+import { useActionState } from 'react'\n+\n+export function Form({\n+  revalidateAction,\n+  initialValues,\n+}: {\n+  revalidateAction: (type: 'tag' | 'path') => Promise<[number, number, string]>\n+  initialValues: [number, number, string]\n+}) {\n+  const [\n+    [useCacheValue1, useCacheValue2, fetchedValue],\n+    revalidate,\n+    isPending,\n+  ] = useActionState(\n+    async (_state: [number, number, string], type: 'tag' | 'path') =>\n+      revalidateAction(type),\n+    initialValues\n+  )\n+\n+  return (\n+    <form>\n+      <p>\n+        before revalidate: <span id=\"use-cache-value-1\">{useCacheValue1}</span>\n+      </p>\n+      <p>\n+        after revalidate: <span id=\"use-cache-value-2\">{useCacheValue2}</span>\n+      </p>\n+      <p id=\"fetched-value\">{fetchedValue}</p>\n+      <button\n+        id=\"revalidate-tag\"\n+        formAction={() => revalidate('tag')}\n+        disabled={isPending}\n+      >\n+        Revalidate Tag\n+      </button>\n+      <button\n+        id=\"revalidate-path\"\n+        formAction={() => revalidate('path')}\n+        disabled={isPending}\n+      >\n+        Revalidate Path\n+      </button>\n+    </form>\n+  )\n+}"
        },
        {
            "sha": "77b10c50c1d6724abe6678fac89e05dab3b0a381",
            "filename": "test/e2e/app-dir/use-cache/app/revalidate-and-use/page.tsx",
            "status": "added",
            "additions": 47,
            "deletions": 0,
            "changes": 47,
            "blob_url": "https://github.com/vercel/next.js/blob/a33edde8f80d95b5d1b3d17d0870d9e013763969/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2Frevalidate-and-use%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/a33edde8f80d95b5d1b3d17d0870d9e013763969/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2Frevalidate-and-use%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2Frevalidate-and-use%2Fpage.tsx?ref=a33edde8f80d95b5d1b3d17d0870d9e013763969",
            "patch": "@@ -0,0 +1,47 @@\n+import { revalidatePath, revalidateTag, unstable_cacheTag } from 'next/cache'\n+import { Form } from './form'\n+import { connection } from 'next/server'\n+\n+async function fetchCachedValue() {\n+  return fetch('https://next-data-api-endpoint.vercel.app/api/random', {\n+    next: { tags: ['revalidate-and-use'], revalidate: false },\n+  }).then((res) => res.text())\n+}\n+\n+async function getCachedValue() {\n+  'use cache'\n+  unstable_cacheTag('revalidate-and-use')\n+  return Math.random()\n+}\n+\n+export default async function Page() {\n+  // Make the page dynamic, as we don't want to deal with ISR in this scenario.\n+  await connection()\n+\n+  return (\n+    <Form\n+      revalidateAction={async (type: 'tag' | 'path') => {\n+        'use server'\n+\n+        const initialCachedValue = await getCachedValue()\n+\n+        if (type === 'tag') {\n+          revalidateTag('revalidate-and-use')\n+        } else {\n+          revalidatePath('/revalidate-and-use')\n+        }\n+\n+        return Promise.all([\n+          initialCachedValue,\n+          getCachedValue(),\n+          fetchCachedValue(),\n+        ])\n+      }}\n+      initialValues={await Promise.all([\n+        getCachedValue(),\n+        getCachedValue(),\n+        fetchCachedValue(),\n+      ])}\n+    />\n+  )\n+}"
        },
        {
            "sha": "a0a1893e84c5747e7b650cd7d68aade47b671346",
            "filename": "test/e2e/app-dir/use-cache/use-cache.test.ts",
            "status": "modified",
            "additions": 81,
            "deletions": 27,
            "changes": 108,
            "blob_url": "https://github.com/vercel/next.js/blob/a33edde8f80d95b5d1b3d17d0870d9e013763969/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fuse-cache.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/a33edde8f80d95b5d1b3d17d0870d9e013763969/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fuse-cache.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fuse-cache.test.ts?ref=a33edde8f80d95b5d1b3d17d0870d9e013763969",
            "patch": "@@ -306,34 +306,36 @@ describe('use-cache', () => {\n     })\n \n     it('should revalidate caches after redirect', async () => {\n-      const browser = await next.browser('/cache-tag')\n-      const initial = await browser.elementById('a').text()\n+      const browser = await next.browser('/revalidate-and-redirect')\n+      const valueA = await browser.elementById('a').text()\n+      const valueB = await browser.elementById('b').text()\n \n-      if (!isNextDev) {\n-        // Bust the ISR cache first to populate the \"use cache\" in-memory cache for\n-        // the subsequent revalidations.\n-        await browser.elementById('revalidate-path').click()\n+      expect(valueA).toBe(valueB)\n \n-        await retry(async () => {\n-          expect(await browser.elementById('a').text()).not.toBe(initial)\n-        })\n-      }\n+      await browser\n+        .elementByCss('a[href=\"/revalidate-and-redirect/redirect\"]')\n+        .click()\n \n-      const valueA1 = await browser.elementById('a').text()\n-      const valueB1 = await browser.elementById('b').text()\n-      await browser.elementByCss('a[href=\"/revalidate-and-redirect\"]').click()\n       await browser.elementById('revalidate-tag-redirect').click()\n \n-      expect(await browser.elementById('a').text()).not.toBe(valueA1)\n-      expect(await browser.elementById('b').text()).toBe(valueB1)\n-      const valueA2 = await browser.elementById('a').text()\n+      const newValueA = await browser.elementById('a').text()\n+      const newValueB = await browser.elementById('b').text()\n \n-      await browser.elementByCss('a[href=\"/revalidate-and-redirect\"]').click()\n+      expect(newValueA).toBe(newValueB)\n+      expect(newValueA).not.toBe(valueA)\n+      expect(newValueB).toBe(newValueB)\n+\n+      await browser\n+        .elementByCss('a[href=\"/revalidate-and-redirect/redirect\"]')\n+        .click()\n       await browser.elementById('revalidate-path-redirect').click()\n \n-      expect(await browser.elementById('a').text()).not.toBe(valueA1)\n-      expect(await browser.elementById('a').text()).not.toBe(valueA2)\n-      expect(await browser.elementById('b').text()).not.toBe(valueB1)\n+      const finalValueA = await browser.elementById('a').text()\n+      const finalValueB = await browser.elementById('b').text()\n+\n+      expect(finalValueA).not.toBe(newValueA)\n+      expect(finalValueB).not.toBe(newValueB)\n+      expect(finalValueB).toBe(finalValueB)\n     })\n \n     it('should revalidate caches nested in unstable_cache', async () => {\n@@ -367,13 +369,15 @@ describe('use-cache', () => {\n     const browser = await next.browser('/on-demand-revalidate')\n     const initial = await browser.elementById('value').text()\n \n-    // Bust the ISR cache first to populate the \"use cache\" in-memory cache for\n-    // the subsequent on-demand revalidation.\n-    await browser.elementById('revalidate-path').click()\n+    if (!isNextDev) {\n+      // Bust the ISR cache first to populate the \"use cache\" in-memory cache\n+      // for the subsequent on-demand revalidation.\n+      await browser.elementById('revalidate-path').click()\n \n-    await retry(async () => {\n-      expect(await browser.elementById('value').text()).not.toBe(initial)\n-    })\n+      await retry(async () => {\n+        expect(await browser.elementById('value').text()).not.toBe(initial)\n+      })\n+    }\n \n     const value = await browser.elementById('value').text()\n \n@@ -386,6 +390,56 @@ describe('use-cache', () => {\n     })\n   })\n \n+  // TODO: Enable for deploy tests when upstream changes have been rolled out.\n+  if (!isNextDeploy) {\n+    it('should not use stale caches in server actions that have revalidated', async () => {\n+      const browser = await next.browser('/revalidate-and-use')\n+      const useCacheValue1 = await browser\n+        .elementById('use-cache-value-1')\n+        .text()\n+      const useCacheValue2 = await browser\n+        .elementById('use-cache-value-2')\n+        .text()\n+      const fetchedValue = await browser.elementById('fetched-value').text()\n+\n+      expect(useCacheValue1).toEqual(useCacheValue2)\n+\n+      await browser.elementById('revalidate-tag').click()\n+      await browser.waitForElementByCss('#revalidate-tag:enabled')\n+\n+      const useCacheValueBeforeRevalidation = await browser\n+        .elementById('use-cache-value-1')\n+        .text()\n+      const useCacheValueAfterRevalidation = await browser\n+        .elementById('use-cache-value-2')\n+        .text()\n+      const newFetchedValue = await browser.elementById('fetched-value').text()\n+\n+      expect(useCacheValueBeforeRevalidation).toBe(useCacheValue1)\n+      expect(useCacheValueBeforeRevalidation).toBe(useCacheValue2)\n+      expect(useCacheValueBeforeRevalidation).not.toBe(\n+        useCacheValueAfterRevalidation\n+      )\n+      expect(newFetchedValue).not.toBe(fetchedValue)\n+\n+      await browser.elementById('revalidate-path').click()\n+      await browser.waitForElementByCss('#revalidate-path:enabled')\n+\n+      expect(await browser.elementById('use-cache-value-1').text()).not.toBe(\n+        useCacheValueBeforeRevalidation\n+      )\n+      expect(await browser.elementById('use-cache-value-2').text()).not.toBe(\n+        useCacheValueAfterRevalidation\n+      )\n+      expect(await browser.elementById('use-cache-value-1').text()).not.toBe(\n+        await browser.elementById('use-cache-value-2').text()\n+      )\n+      expect(await browser.elementById('fetched-value').text()).not.toBe(\n+        newFetchedValue\n+      )\n+    })\n+  }\n+\n   if (isNextStart) {\n     it('should prerender fully cacheable pages as static HTML', async () => {\n       const prerenderManifest = JSON.parse(\n@@ -424,7 +478,7 @@ describe('use-cache', () => {\n         '/passed-to-client',\n         '/react-cache',\n         '/referential-equality',\n-        '/revalidate-and-redirect',\n+        '/revalidate-and-redirect/redirect',\n         '/rsc-payload',\n         '/static-class-method',\n         '/use-action-state',"
        }
    ],
    "stats": {
        "total": 364,
        "additions": 287,
        "deletions": 77
    }
}