{
    "author": "sokra",
    "message": "Turbopack: remove DirtyContainerCount from dirty_container_update (#86071)\n\n### What?\n\n* remove DirtyContainerCount from dirty_container_update\n* change dirty_container_update to track the current session only\n\nPreparation to split dirty count and current session clean count",
    "sha": "a1a8c25b240324635567752f8ad61ece95ec3be6",
    "files": [
        {
            "sha": "32cdbbf7ea00237c7b6a62bf6770c339fb9fac4e",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/a1a8c25b240324635567752f8ad61ece95ec3be6/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a1a8c25b240324635567752f8ad61ece95ec3be6/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=a1a8c25b240324635567752f8ad61ece95ec3be6",
            "patch": "@@ -2431,7 +2431,11 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                 }\n                 AggregationUpdateJob::data_update(\n                     &mut task,\n-                    AggregatedDataUpdate::new().dirty_container_update(task_id, aggregated_update),\n+                    AggregatedDataUpdate::new().dirty_container_update(\n+                        task_id,\n+                        aggregated_update.count,\n+                        aggregated_update.current_session_clean(ctx.session_id()),\n+                    ),\n                 )\n             } else {\n                 None"
        },
        {
            "sha": "d483ce43c6e45d6aa20291182c246d24d935b418",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/aggregation_update.rs",
            "status": "modified",
            "additions": 83,
            "deletions": 30,
            "changes": 113,
            "blob_url": "https://github.com/vercel/next.js/blob/a1a8c25b240324635567752f8ad61ece95ec3be6/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Faggregation_update.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a1a8c25b240324635567752f8ad61ece95ec3be6/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Faggregation_update.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Faggregation_update.rs?ref=a1a8c25b240324635567752f8ad61ece95ec3be6",
            "patch": "@@ -4,7 +4,7 @@ use std::{\n     hash::Hash,\n     mem::take,\n     num::NonZeroU32,\n-    ops::ControlFlow,\n+    ops::{ControlFlow, Deref},\n     thread::yield_now,\n     time::{Duration, Instant},\n };\n@@ -216,19 +216,41 @@ impl AggregationUpdateJob {\n     }\n }\n \n+#[derive(Default, Serialize, Deserialize, Clone, Copy, Debug)]\n+pub struct SessionDependent<T> {\n+    #[serde(skip, default)]\n+    pub value: T,\n+}\n+\n+impl<T> SessionDependent<T> {\n+    pub fn new(value: T) -> Self {\n+        Self { value }\n+    }\n+}\n+\n+impl<T> Deref for SessionDependent<T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.value\n+    }\n+}\n+\n /// Aggregated data update.\n #[derive(Default, Serialize, Deserialize, Clone, Debug)]\n pub struct AggregatedDataUpdate {\n     /// One of the inner tasks has changed its dirty state or aggregated dirty state.\n-    dirty_container_update: Option<(TaskId, DirtyContainerCount)>,\n+    /// (task id, dirty update, current session clean update)\n+    // TODO Serialize the current session clean update as 0\n+    dirty_container_update: Option<(TaskId, i32, SessionDependent<i32>)>,\n     /// One of the inner tasks has changed its collectibles count or aggregated collectibles count.\n     collectibles_update: Vec<(CollectibleRef, i32)>,\n }\n \n impl AggregatedDataUpdate {\n     /// Derives an `AggregatedDataUpdate` from a task. This is used when a task is connected to an\n     /// upper task.\n-    fn from_task(task: &mut impl TaskGuard) -> Self {\n+    fn from_task(task: &mut impl TaskGuard, current_session_id: SessionId) -> Self {\n         let aggregation = get_aggregation_number(task);\n         let mut dirty_container_count = Default::default();\n         let mut collectibles_update: Vec<_> =\n@@ -255,15 +277,20 @@ impl AggregatedDataUpdate {\n \n         let mut result = Self::new().collectibles_update(collectibles_update);\n         if !dirty_container_count.is_zero() {\n-            let DirtyContainerCount {\n-                count,\n-                count_in_session,\n-            } = dirty_container_count;\n             result = result.dirty_container_update(\n                 task.id(),\n-                DirtyContainerCount {\n-                    count: if count > 0 { 1 } else { 0 },\n-                    count_in_session: count_in_session.map(|(s, c)| (s, if c > 0 { 1 } else { 0 })),\n+                if dirty_container_count.count > 0 {\n+                    1\n+                } else {\n+                    0\n+                },\n+                if dirty_container_count.count > 0\n+                    && dirty_container_count.current_session_clean(current_session_id)\n+                        >= dirty_container_count.count\n+                {\n+                    1\n+                } else {\n+                    0\n                 },\n             );\n         }\n@@ -276,8 +303,9 @@ impl AggregatedDataUpdate {\n             dirty_container_update,\n             collectibles_update,\n         } = &mut self;\n-        if let Some((_, value)) = dirty_container_update.as_mut() {\n-            *value = value.negate()\n+        if let Some((_, value, current_session_clean_update)) = dirty_container_update.as_mut() {\n+            *value = -*value;\n+            current_session_clean_update.value = -current_session_clean_update.value;\n         }\n         for (_, value) in collectibles_update.iter_mut() {\n             *value = -*value;\n@@ -290,7 +318,7 @@ impl AggregatedDataUpdate {\n     fn apply(\n         &self,\n         task: &mut impl TaskGuard,\n-        session_id: SessionId,\n+        current_session_id: SessionId,\n         should_track_activeness: bool,\n         queue: &mut AggregationUpdateQueue,\n     ) -> AggregatedDataUpdate {\n@@ -299,25 +327,32 @@ impl AggregatedDataUpdate {\n             collectibles_update,\n         } = self;\n         let mut result = Self::default();\n-        if let Some((dirty_container_id, count)) = dirty_container_update {\n+        if let &Some((dirty_container_id, count, session_dependent_clean_update)) =\n+            dirty_container_update\n+        {\n             if should_track_activeness {\n                 // When a dirty container count is increased and the task is considered as active\n                 // we need to schedule the dirty tasks in the new dirty container\n-                let current_session_update = count.get(session_id);\n+                let current_session_update = count - *session_dependent_clean_update;\n                 if current_session_update > 0 && task.has_key(&CachedDataItemKey::Activeness {}) {\n-                    queue.push_find_and_schedule_dirty(*dirty_container_id)\n+                    queue.push_find_and_schedule_dirty(dirty_container_id)\n                 }\n             }\n \n             let mut aggregated_update = DirtyContainerCount::default();\n             update!(\n                 task,\n                 AggregatedDirtyContainer {\n-                    task: *dirty_container_id\n+                    task: dirty_container_id\n                 },\n                 |old: Option<DirtyContainerCount>| {\n                     let mut new = old.unwrap_or_default();\n-                    aggregated_update = new.update_count(count);\n+                    aggregated_update =\n+                        new.update_count(&DirtyContainerCount::from_current_session_clean(\n+                            count,\n+                            current_session_id,\n+                            *session_dependent_clean_update,\n+                        ));\n                     (!new.is_zero()).then_some(new)\n                 }\n             );\n@@ -337,12 +372,18 @@ impl AggregatedDataUpdate {\n                         new.undo_update_with_dirtyness_and_session(dirtyness, clean_in_session);\n                     }\n                     if !aggregated_update.is_zero() {\n-                        result.dirty_container_update = Some((task_id, aggregated_update));\n+                        result.dirty_container_update = Some((\n+                            task_id,\n+                            aggregated_update.count,\n+                            SessionDependent::new(\n+                                aggregated_update.current_session_clean(current_session_id),\n+                            ),\n+                        ));\n                     }\n                     (!new.is_zero()).then_some(new)\n                 });\n-                if let Some((_, count)) = result.dirty_container_update.as_ref()\n-                    && count.get(session_id) < 0\n+                if let Some((_, count, current_session_clean)) = result.dirty_container_update\n+                    && count - *current_session_clean < 0\n                 {\n                     // When the current task is no longer dirty, we need to fire the\n                     // aggregate root events and do some cleanup\n@@ -421,8 +462,17 @@ impl AggregatedDataUpdate {\n     }\n \n     /// Adds a dirty container update to the update.\n-    pub fn dirty_container_update(mut self, task_id: TaskId, count: DirtyContainerCount) -> Self {\n-        self.dirty_container_update = Some((task_id, count));\n+    pub fn dirty_container_update(\n+        mut self,\n+        task_id: TaskId,\n+        count: i32,\n+        current_session_clean_update: i32,\n+    ) -> Self {\n+        self.dirty_container_update = Some((\n+            task_id,\n+            count,\n+            SessionDependent::new(current_session_clean_update),\n+        ));\n         self\n     }\n \n@@ -1041,7 +1091,7 @@ impl AggregationUpdateQueue {\n                         }\n                         // When this is a new inner node, update aggregated data and\n                         // followers\n-                        let data = AggregatedDataUpdate::from_task(&mut task);\n+                        let data = AggregatedDataUpdate::from_task(&mut task, ctx.session_id());\n                         let followers = get_followers(&task);\n                         let diff = data.apply(\n                             &mut upper,\n@@ -1138,7 +1188,8 @@ impl AggregationUpdateQueue {\n \n                     // Since this is no longer an inner node, update the aggregated data and\n                     // followers\n-                    let data = AggregatedDataUpdate::from_task(&mut task).invert();\n+                    let data =\n+                        AggregatedDataUpdate::from_task(&mut task, ctx.session_id()).invert();\n                     let followers = get_followers(&task);\n                     let diff = data.apply(\n                         &mut upper,\n@@ -1311,7 +1362,8 @@ impl AggregationUpdateQueue {\n                 follower_in_upper\n             });\n             if !removed_uppers.is_empty() {\n-                let data = AggregatedDataUpdate::from_task(&mut follower).invert();\n+                let data =\n+                    AggregatedDataUpdate::from_task(&mut follower, ctx.session_id()).invert();\n                 let followers = get_followers(&follower);\n                 drop(follower);\n \n@@ -1473,7 +1525,8 @@ impl AggregationUpdateQueue {\n                     Some(old - 1)\n                 });\n                 if remove_upper {\n-                    let data = AggregatedDataUpdate::from_task(&mut follower).invert();\n+                    let data =\n+                        AggregatedDataUpdate::from_task(&mut follower, ctx.session_id()).invert();\n                     let followers = get_followers(&follower);\n                     drop(follower);\n \n@@ -1711,7 +1764,7 @@ impl AggregationUpdateQueue {\n                     self.push_optimize_task(new_follower_id);\n                 }\n \n-                let data = AggregatedDataUpdate::from_task(&mut follower);\n+                let data = AggregatedDataUpdate::from_task(&mut follower, ctx.session_id());\n                 let children = get_followers(&follower);\n                 drop(follower);\n \n@@ -1882,7 +1935,7 @@ impl AggregationUpdateQueue {\n                         }\n \n                         // It's a new upper\n-                        let data = AggregatedDataUpdate::from_task(&mut inner);\n+                        let data = AggregatedDataUpdate::from_task(&mut inner, ctx.session_id());\n                         let children = get_followers(&inner);\n                         let follower_aggregation_number = get_aggregation_number(&inner);\n                         drop(inner);\n@@ -2094,7 +2147,7 @@ impl AggregationUpdateQueue {\n                     self.push_optimize_task(new_follower_id);\n                 }\n                 // It's a new upper\n-                let data = AggregatedDataUpdate::from_task(&mut inner);\n+                let data = AggregatedDataUpdate::from_task(&mut inner, ctx.session_id());\n                 let followers = get_followers(&inner);\n                 drop(inner);\n "
        },
        {
            "sha": "da1f5f03093cd62ddbd962adb0c407dfd4517066",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/invalidate.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/a1a8c25b240324635567752f8ad61ece95ec3be6/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Finvalidate.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a1a8c25b240324635567752f8ad61ece95ec3be6/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Finvalidate.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Finvalidate.rs?ref=a1a8c25b240324635567752f8ad61ece95ec3be6",
            "patch": "@@ -299,7 +299,11 @@ pub fn make_task_dirty_internal(\n         if !aggregated_update.is_zero() {\n             queue.extend(AggregationUpdateJob::data_update(\n                 &mut task,\n-                AggregatedDataUpdate::new().dirty_container_update(task_id, aggregated_update),\n+                AggregatedDataUpdate::new().dirty_container_update(\n+                    task_id,\n+                    aggregated_update.count,\n+                    aggregated_update.current_session_clean(ctx.session_id()),\n+                ),\n             ));\n         }\n         !ctx.should_track_activeness() || task.has_key(&CachedDataItemKey::Activeness {})"
        },
        {
            "sha": "47db822e94bc370910eddd5396301a8be3e0ac3f",
            "filename": "turbopack/crates/turbo-tasks-backend/src/data.rs",
            "status": "modified",
            "additions": 20,
            "deletions": 0,
            "changes": 20,
            "blob_url": "https://github.com/vercel/next.js/blob/a1a8c25b240324635567752f8ad61ece95ec3be6/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdata.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a1a8c25b240324635567752f8ad61ece95ec3be6/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdata.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdata.rs?ref=a1a8c25b240324635567752f8ad61ece95ec3be6",
            "patch": "@@ -171,6 +171,26 @@ pub struct DirtyContainerCount {\n }\n \n impl DirtyContainerCount {\n+    pub fn from_current_session_clean(\n+        count: i32,\n+        current_session_id: SessionId,\n+        current_session_clean: i32,\n+    ) -> DirtyContainerCount {\n+        DirtyContainerCount {\n+            count,\n+            count_in_session: Some((current_session_id, count - current_session_clean)),\n+        }\n+    }\n+\n+    pub fn current_session_clean(&self, current_session_id: SessionId) -> i32 {\n+        if let Some((s, c)) = self.count_in_session\n+            && s == current_session_id\n+        {\n+            return self.count - c;\n+        }\n+        0\n+    }\n+\n     /// Get the count for a specific session. It's only expected to be asked for the current\n     /// session, since old session counts might be dropped.\n     pub fn get(&self, session: SessionId) -> i32 {"
        }
    ],
    "stats": {
        "total": 145,
        "additions": 113,
        "deletions": 32
    }
}