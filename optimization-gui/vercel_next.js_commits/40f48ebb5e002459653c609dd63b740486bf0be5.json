{
    "author": "bgw",
    "message": "Turbopack: Remove redundant log line, increase delay for compiling log message (#85133)\n\nWe've already got output logging for this stuff, and the \"compiling\" message is too noisy.\n\nOnly print `Compiling /...` it if the compilation takes more than 3s, stop printing `Compiled in` altogether.\n\nAfter this PR:\n<img width=\"1075\" height=\"335\" alt=\"Screenshot 2025-10-20 at 3 15 59 PM\" src=\"https://github.com/user-attachments/assets/34e87d18-8feb-4470-ae11-0d8e4b3a8a6b\" />\n\nRemoves this line:\n<img width=\"1095\" height=\"254\" alt=\"Screenshot 2025-10-20 at 3 17 56 PM\" src=\"https://github.com/user-attachments/assets/76fb795e-760a-4782-889a-dd98bcf09125\" />",
    "sha": "40f48ebb5e002459653c609dd63b740486bf0be5",
    "files": [
        {
            "sha": "0833421224d510bacd364646e84140428dc3308d",
            "filename": "packages/next/src/build/output/store.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 6,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/40f48ebb5e002459653c609dd63b740486bf0be5/packages%2Fnext%2Fsrc%2Fbuild%2Foutput%2Fstore.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/40f48ebb5e002459653c609dd63b740486bf0be5/packages%2Fnext%2Fsrc%2Fbuild%2Foutput%2Fstore.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Foutput%2Fstore.ts?ref=40f48ebb5e002459653c609dd63b740486bf0be5",
            "patch": "@@ -3,7 +3,7 @@ import { type Span, flushAllTraces, trace } from '../../trace'\n import { teardownTraceSubscriber } from '../swc'\n import * as Log from './log'\n \n-const MAX_LOG_SKIP_DURATION = 500 // 500ms\n+const MAX_LOG_SKIP_DURATION_MS = 3000\n \n export type OutputState =\n   | {\n@@ -109,7 +109,7 @@ store.subscribe((state) => {\n           trigger: trigger,\n         })\n         if (!loadingLogTimer) {\n-          // Only log compiling if compiled is not finished in 3 seconds\n+          // Only log compiling if compiled is not finished quickly\n           loadingLogTimer = setTimeout(() => {\n             if (\n               triggerUrl &&\n@@ -120,7 +120,7 @@ store.subscribe((state) => {\n             } else {\n               Log.wait(`Compiling ${trigger} ...`)\n             }\n-          }, MAX_LOG_SKIP_DURATION)\n+          }, MAX_LOG_SKIP_DURATION_MS)\n         }\n       }\n     }\n@@ -182,9 +182,6 @@ store.subscribe((state) => {\n       traceSpan.stop()\n       traceSpan = null\n     }\n-    Log.event(\n-      `Compiled${trigger ? ' ' + trigger : ''}${timeMessage}${modulesMessage}`\n-    )\n     trigger = ''\n   }\n "
        },
        {
            "sha": "0028e5acf0c501a9d3b616e03dbe6f2a111bfda3",
            "filename": "test/development/app-dir/cache-components-dev-errors/cache-components-dev-errors.test.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/40f48ebb5e002459653c609dd63b740486bf0be5/test%2Fdevelopment%2Fapp-dir%2Fcache-components-dev-errors%2Fcache-components-dev-errors.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/40f48ebb5e002459653c609dd63b740486bf0be5/test%2Fdevelopment%2Fapp-dir%2Fcache-components-dev-errors%2Fcache-components-dev-errors.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Fapp-dir%2Fcache-components-dev-errors%2Fcache-components-dev-errors.test.ts?ref=40f48ebb5e002459653c609dd63b740486bf0be5",
            "patch": "@@ -94,7 +94,7 @@ describe('Cache Components Dev Errors', () => {\n     })\n \n     expect(stripAnsi(next.cliOutput.slice(outputIndex))).toContain(\n-      `\\nError: Route \"/no-accessed-data\": ` +\n+      `Error: Route \"/no-accessed-data\": ` +\n         `A component accessed data, headers, params, searchParams, or a short-lived cache without a Suspense boundary nor a \"use cache\" above it. ` +\n         `See more info: https://nextjs.org/docs/messages/next-prerender-missing-suspense` +\n         '\\n    at Page (app/no-accessed-data/page.js:1:31)' +"
        },
        {
            "sha": "c5edff3febcd15c3ccf1d0e079e980817582491c",
            "filename": "test/development/basic/barrel-optimization/barrel-optimization-mui.test.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 15,
            "changes": 17,
            "blob_url": "https://github.com/vercel/next.js/blob/40f48ebb5e002459653c609dd63b740486bf0be5/test%2Fdevelopment%2Fbasic%2Fbarrel-optimization%2Fbarrel-optimization-mui.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/40f48ebb5e002459653c609dd63b740486bf0be5/test%2Fdevelopment%2Fbasic%2Fbarrel-optimization%2Fbarrel-optimization-mui.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Fbasic%2Fbarrel-optimization%2Fbarrel-optimization-mui.test.ts?ref=40f48ebb5e002459653c609dd63b740486bf0be5",
            "patch": "@@ -21,26 +21,13 @@ import { assertNoRedbox } from 'next-test-utils'\n       })\n \n       it('should support MUI', async () => {\n-        let logs = ''\n-        next.on('stdout', (log) => {\n-          logs += log\n-        })\n-\n         // Ensure that MUI is working\n         const $ = await next.render$('/mui')\n-        expect(await $('#button').text()).toContain('button')\n-        expect(await $('#typography').text()).toContain('typography')\n+        expect($('#button').text()).toContain('button')\n+        expect($('#typography').text()).toContain('typography')\n \n         const browser = await next.browser('/mui')\n         await assertNoRedbox(browser)\n-\n-        const modules = [...logs.matchAll(/\\((\\d+) modules\\)/g)]\n-        expect(modules.length).toBeGreaterThanOrEqual(1)\n-        for (const [, moduleCount] of modules) {\n-          // Ensure that the number of modules is less than 1500 - otherwise we're\n-          // importing the entire library.\n-          expect(parseInt(moduleCount)).toBeLessThan(1500)\n-        }\n       })\n     })\n   }"
        },
        {
            "sha": "659b8e4698d9ae95e96a02be096ba0c3e303647c",
            "filename": "test/development/basic/barrel-optimization/barrel-optimization.test.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 86,
            "changes": 86,
            "blob_url": "https://github.com/vercel/next.js/blob/40f48ebb5e002459653c609dd63b740486bf0be5/test%2Fdevelopment%2Fbasic%2Fbarrel-optimization%2Fbarrel-optimization.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/40f48ebb5e002459653c609dd63b740486bf0be5/test%2Fdevelopment%2Fbasic%2Fbarrel-optimization%2Fbarrel-optimization.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Fbasic%2Fbarrel-optimization%2Fbarrel-optimization.test.ts?ref=40f48ebb5e002459653c609dd63b740486bf0be5",
            "patch": "@@ -20,92 +20,6 @@ import { nextTestSetup } from 'e2e-utils'\n         },\n       })\n \n-      it('app - should render the icons correctly without creating all the modules', async () => {\n-        let logs = ''\n-        next.on('stdout', (log) => {\n-          logs += log\n-        })\n-\n-        const html = await next.render('/')\n-\n-        // Ensure the icons are rendered\n-        expect(html).toContain('<svg xmlns=\"http://www.w3.org/2000/svg\"')\n-\n-        const modules = [\n-          ...logs.matchAll(\n-            /Compiled (\\/[\\w-]*)*\\s*in \\d+(\\.\\d+)?(s|ms) \\((\\d+) modules\\)/g\n-          ),\n-        ]\n-\n-        expect(modules.length).toBeGreaterThanOrEqual(1)\n-        for (const [, , , , moduleCount] of modules) {\n-          // Ensure that the number of modules is less than 1500 - otherwise we're\n-          // importing the entire library.\n-          expect(parseInt(moduleCount)).toBeLessThan(1500)\n-        }\n-      })\n-\n-      it('pages - should render the icons correctly without creating all the modules', async () => {\n-        let logs = ''\n-        next.on('stdout', (log) => {\n-          logs += log\n-        })\n-\n-        const html = await next.render('/pages-route')\n-\n-        // Ensure the icons are rendered\n-        expect(html).toContain('<svg xmlns=\"http://www.w3.org/2000/svg\"')\n-\n-        const modules = [\n-          ...logs.matchAll(\n-            /Compiled (\\/[\\w-]+)*\\s*in \\d+(\\.\\d+)?(s|ms) \\((\\d+) modules\\)/g\n-          ),\n-        ]\n-\n-        expect(modules.length).toBeGreaterThanOrEqual(1)\n-        for (const [, , , , moduleCount] of modules) {\n-          // Ensure that the number of modules is less than 1500 - otherwise we're\n-          // importing the entire library.\n-          expect(parseInt(moduleCount)).toBeLessThan(1500)\n-        }\n-      })\n-\n-      it('app - should optimize recursive wildcard export mapping', async () => {\n-        let logs = ''\n-        next.on('stdout', (log) => {\n-          logs += log\n-        })\n-\n-        await next.render('/recursive-barrel-app')\n-\n-        const modules = [...logs.matchAll(/\\((\\d+) modules\\)/g)]\n-\n-        expect(modules.length).toBeGreaterThanOrEqual(1)\n-        for (const [, moduleCount] of modules) {\n-          // Ensure that the number of modules is less than 1500 - otherwise we're\n-          // importing the entire library.\n-          expect(parseInt(moduleCount)).toBeLessThan(1500)\n-        }\n-      })\n-\n-      it('pages - should optimize recursive wildcard export mapping', async () => {\n-        let logs = ''\n-        next.on('stdout', (log) => {\n-          logs += log\n-        })\n-\n-        await next.render('/recursive-barrel')\n-\n-        const modules = [...logs.matchAll(/\\((\\d+) modules\\)/g)]\n-\n-        expect(modules.length).toBeGreaterThanOrEqual(1)\n-        for (const [, moduleCount] of modules) {\n-          // Ensure that the number of modules is less than 1500 - otherwise we're\n-          // importing the entire library.\n-          expect(parseInt(moduleCount)).toBeLessThan(1500)\n-        }\n-      })\n-\n       it('should handle recursive wildcard exports', async () => {\n         const html = await next.render('/recursive')\n         expect(html).toContain('<h1>42</h1>')"
        },
        {
            "sha": "e3da81a94f954f655723bc43b3f2d2e7bcc21192",
            "filename": "test/development/basic/hmr/run-basic-hmr-test.util.ts",
            "status": "modified",
            "additions": 17,
            "deletions": 18,
            "changes": 35,
            "blob_url": "https://github.com/vercel/next.js/blob/40f48ebb5e002459653c609dd63b740486bf0be5/test%2Fdevelopment%2Fbasic%2Fhmr%2Frun-basic-hmr-test.util.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/40f48ebb5e002459653c609dd63b740486bf0be5/test%2Fdevelopment%2Fbasic%2Fhmr%2Frun-basic-hmr-test.util.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Fbasic%2Fhmr%2Frun-basic-hmr-test.util.ts?ref=40f48ebb5e002459653c609dd63b740486bf0be5",
            "patch": "@@ -10,7 +10,7 @@ export function runBasicHmrTest(nextConfig: {\n   basePath: string\n   assetPrefix: string\n }) {\n-  const { next } = nextTestSetup({\n+  const { next, isTurbopack } = nextTestSetup({\n     files: __dirname,\n     nextConfig,\n     patchFileDelay: 500,\n@@ -48,25 +48,26 @@ export function runBasicHmrTest(nextConfig: {\n       hello: 'world',\n     })\n   })\n-\n-  it('should have correct compile timing after fixing error', async () => {\n-    const pageName = 'pages/auto-export-is-ready.js'\n-    const originalContent = await next.readFile(pageName)\n-\n-    try {\n+  ;(isTurbopack ? it : it.skip)(\n+    'should have correct compile timing after fixing error',\n+    async () => {\n       const browser = await next.browser(basePath + '/auto-export-is-ready')\n-      const outputLength = next.cliOutput.length\n+      let outputLength\n       await next.patchFile(\n-        pageName,\n-        `import hello from 'non-existent'\\n` + originalContent\n+        'pages/auto-export-is-ready.js',\n+        (content) => `import hello from 'non-existent'\\n` + content,\n+        async () => {\n+          await assertHasRedbox(browser)\n+          await waitFor(3000)\n+          outputLength = next.cliOutput.length\n+        }\n       )\n-      await assertHasRedbox(browser)\n-      await waitFor(3000)\n-      await next.patchFile(pageName, originalContent)\n+\n+      let compileTimeStr\n       await retry(async () => {\n-        expect(next.cliOutput.substring(outputLength)).toMatch(/Compiled.*?/i)\n+        compileTimeStr = next.cliOutput.substring(outputLength)\n+        expect(compileTimeStr).toMatch(/Compiled.*?/i)\n       })\n-      const compileTimeStr = next.cliOutput.substring(outputLength)\n \n       const matches = [\n         ...compileTimeStr.match(/Compiled.*? in ([\\d.]{1,})\\s?(?:s|ms)/i),\n@@ -78,10 +79,8 @@ export function runBasicHmrTest(nextConfig: {\n         compileTimeMs = compileTimeMs * 1000\n       }\n       expect(compileTimeMs).toBeLessThan(3000)\n-    } finally {\n-      await next.patchFile(pageName, originalContent)\n     }\n-  })\n+  )\n \n   it('should reload the page when the server restarts', async () => {\n     const browser = await next.browser(basePath + '/hmr/about')"
        },
        {
            "sha": "1466fbdb69648f40fc34744a4b0d56688257c879",
            "filename": "test/development/basic/hmr/run-error-recovery-hmr-test.util.ts",
            "status": "modified",
            "additions": 325,
            "deletions": 435,
            "changes": 760,
            "blob_url": "https://github.com/vercel/next.js/blob/40f48ebb5e002459653c609dd63b740486bf0be5/test%2Fdevelopment%2Fbasic%2Fhmr%2Frun-error-recovery-hmr-test.util.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/40f48ebb5e002459653c609dd63b740486bf0be5/test%2Fdevelopment%2Fbasic%2Fhmr%2Frun-error-recovery-hmr-test.util.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Fbasic%2Fhmr%2Frun-error-recovery-hmr-test.util.ts?ref=40f48ebb5e002459653c609dd63b740486bf0be5",
            "patch": "@@ -26,82 +26,82 @@ export function runErrorRecoveryHmrTest(nextConfig: {\n   const { basePath } = nextConfig\n \n   it('should recover from 404 after a page has been added', async () => {\n-    const newPage = join('pages', 'hmr', 'new-page.js')\n+    const browser = await next.browser(basePath + '/hmr/new-page')\n \n-    try {\n-      const browser = await next.browser(basePath + '/hmr/new-page')\n+    expect(await browser.elementByCss('body').text()).toMatch(\n+      /This page could not be found/\n+    )\n \n-      expect(await browser.elementByCss('body').text()).toMatch(\n-        /This page could not be found/\n-      )\n-\n-      // Add the page\n-      await next.patchFile(\n-        newPage,\n-        'export default () => (<div id=\"new-page\">the-new-page</div>)'\n-      )\n+    expect(next.cliOutput).toContain('GET /hmr/new-page 404')\n+    let cliOutputLength = next.cliOutput.length\n \n-      await retry(async () => {\n-        expect(await getBrowserBodyText(browser)).toMatch(/the-new-page/)\n-      })\n-\n-      await next.deleteFile(newPage)\n-\n-      await retry(async () => {\n-        expect(await getBrowserBodyText(browser)).toMatch(\n-          /This page could not be found/\n+    // Add the page\n+    await next.patchFile(\n+      join('pages', 'hmr', 'new-page.js'),\n+      'export default () => (<div id=\"new-page\">the-new-page</div>)',\n+      async () => {\n+        await retry(async () => {\n+          expect(await getBrowserBodyText(browser)).toMatch(/the-new-page/)\n+        })\n+        expect(next.cliOutput.slice(cliOutputLength)).toContain(\n+          'GET /hmr/new-page 200'\n         )\n-      })\n-\n-      expect(next.cliOutput).toContain('Compiled /_error')\n-    } catch (err) {\n-      await next.deleteFile(newPage)\n-      throw err\n-    }\n-  })\n-\n-  it('should recover from 404 after a page has been added with dynamic segments', async () => {\n-    const newPage = join('pages', 'hmr', '[foo]', 'page.js')\n-\n-    try {\n-      const browser = await next.browser(basePath + '/hmr/foo/page')\n+        cliOutputLength = next.cliOutput.length\n+      }\n+    )\n \n-      expect(await browser.elementByCss('body').text()).toMatch(\n+    // page was deleted at the end of patchFile\n+    await retry(async () => {\n+      expect(await getBrowserBodyText(browser)).toMatch(\n         /This page could not be found/\n       )\n+    })\n+    expect(next.cliOutput.slice(cliOutputLength)).toContain(\n+      'GET /hmr/new-page 404'\n+    )\n+  })\n \n-      // Add the page\n-      await next.patchFile(\n-        newPage,\n-        'export default () => (<div id=\"new-page\">the-new-page</div>)'\n-      )\n+  it('should recover from 404 after a page has been added with dynamic segments', async () => {\n+    const browser = await next.browser(basePath + '/hmr/foo/page')\n \n-      await retry(async () => {\n-        expect(await getBrowserBodyText(browser)).toMatch(/the-new-page/)\n-      })\n+    expect(await browser.elementByCss('body').text()).toMatch(\n+      /This page could not be found/\n+    )\n \n-      await next.deleteFile(newPage)\n+    expect(next.cliOutput).toContain('GET /hmr/foo/page 404')\n+    let cliOutputLength = next.cliOutput.length\n \n-      await retry(async () => {\n-        expect(await getBrowserBodyText(browser)).toMatch(\n-          /This page could not be found/\n+    // Add the page\n+    await next.patchFile(\n+      join('pages', 'hmr', '[foo]', 'page.js'),\n+      'export default () => (<div id=\"new-page\">the-new-page</div>)',\n+      async () => {\n+        await retry(async () => {\n+          expect(await getBrowserBodyText(browser)).toMatch(/the-new-page/)\n+        })\n+        expect(next.cliOutput.slice(cliOutputLength)).toContain(\n+          'GET /hmr/foo/page 200'\n         )\n-      })\n+        cliOutputLength = next.cliOutput.length\n+      }\n+    )\n \n-      expect(next.cliOutput).toContain('Compiled /_error')\n-    } catch (err) {\n-      await next.deleteFile(newPage)\n-      throw err\n-    }\n+    // page was deleted at the end of patchFile\n+    await retry(async () => {\n+      expect(await getBrowserBodyText(browser)).toMatch(\n+        /This page could not be found/\n+      )\n+    })\n+    expect(next.cliOutput.slice(cliOutputLength)).toContain(\n+      'GET /hmr/foo/page 404'\n+    )\n   })\n   ;(process.env.IS_TURBOPACK_TEST ? it.skip : it)(\n     // this test fails frequently with turbopack\n     'should not continously poll a custom error page',\n     async () => {\n-      const errorPage = join('pages', '_error.js')\n-\n       await next.patchFile(\n-        errorPage,\n+        join('pages', '_error.js'),\n         outdent`\n           function Error({ statusCode, message, count }) {\n             return (\n@@ -121,49 +121,48 @@ export function runErrorRecoveryHmrTest(nextConfig: {\n           }\n \n           export default Error\n-        `\n-      )\n-\n-      try {\n-        // navigate to a 404 page\n-        await next.browser(basePath + '/does-not-exist')\n+        `,\n+        async () => {\n+          // navigate to a 404 page\n+          await next.browser(basePath + '/does-not-exist')\n \n-        await retry(() => {\n-          expect(next.cliOutput).toMatch(/getInitialProps called/)\n-        })\n+          await retry(() => {\n+            expect(next.cliOutput).toMatch(/getInitialProps called/)\n+          })\n \n-        const outputIndex = next.cliOutput.length\n+          const outputIndex = next.cliOutput.length\n \n-        // wait a few seconds to ensure polling didn't happen\n-        await waitFor(3000)\n+          // wait a few seconds to ensure polling didn't happen\n+          await waitFor(3000)\n \n-        const logOccurrences =\n-          next.cliOutput.slice(outputIndex).split('getInitialProps called')\n-            .length - 1\n-        expect(logOccurrences).toBe(0)\n-      } finally {\n-        await next.deleteFile(errorPage)\n-      }\n+          const logOccurrences =\n+            next.cliOutput.slice(outputIndex).split('getInitialProps called')\n+              .length - 1\n+          expect(logOccurrences).toBe(0)\n+        }\n+      )\n     }\n   )\n \n   it('should detect syntax errors and recover', async () => {\n     const browser = await next.browser(basePath + '/hmr/about2')\n-    const aboutPage = join('pages', 'hmr', 'about2.js')\n-    const aboutContent = await next.readFile(aboutPage)\n     await retry(async () => {\n       expect(await getBrowserBodyText(browser)).toMatch(\n         /This is the about page/\n       )\n     })\n \n-    await next.patchFile(aboutPage, aboutContent.replace('</div>', 'div'))\n-\n-    await assertHasRedbox(browser)\n-    const source = next.normalizeTestDirContent(await getRedboxSource(browser))\n+    await next.patchFile(\n+      join('pages', 'hmr', 'about2.js'),\n+      (content) => content.replace('</div>', 'div'),\n+      async () => {\n+        await assertHasRedbox(browser)\n+        const source = next.normalizeTestDirContent(\n+          await getRedboxSource(browser)\n+        )\n \n-    if (process.env.IS_TURBOPACK_TEST) {\n-      expect(source).toMatchInlineSnapshot(`\n+        if (process.env.IS_TURBOPACK_TEST) {\n+          expect(source).toMatchInlineSnapshot(`\n        \"./pages/hmr/about2.js (7:1)\n        Parsing ecmascript source code failed\n          5 |     div\n@@ -174,8 +173,8 @@ export function runErrorRecoveryHmrTest(nextConfig: {\n \n        Unexpected token. Did you mean \\`{'}'}\\` or \\`&rbrace;\\`?\"\n       `)\n-    } else if (process.env.NEXT_RSPACK) {\n-      expect(trimEndMultiline(source)).toMatchInlineSnapshot(`\n+        } else if (process.env.NEXT_RSPACK) {\n+          expect(trimEndMultiline(source)).toMatchInlineSnapshot(`\n        \"./pages/hmr/about2.js\n          × Module build failed:\n          ╰─▶   × Error:   x Unexpected token. Did you mean \\`{'}'}\\` or \\`&rbrace;\\`?\n@@ -200,8 +199,8 @@ export function runErrorRecoveryHmrTest(nextConfig: {\n        Import trace for requested module:\n        ./pages/hmr/about2.js\"\n       `)\n-    } else {\n-      expect(source).toMatchInlineSnapshot(`\n+        } else {\n+          expect(source).toMatchInlineSnapshot(`\n           \"./pages/hmr/about2.js\n           Error:   x Unexpected token. Did you mean \\`{'}'}\\` or \\`&rbrace;\\`?\n              ,-[7:1]\n@@ -224,9 +223,9 @@ export function runErrorRecoveryHmrTest(nextConfig: {\n           Import trace for requested module:\n           ./pages/hmr/about2.js\"\n         `)\n-    }\n-\n-    await next.patchFile(aboutPage, aboutContent)\n+        }\n+      }\n+    )\n \n     await retry(async () => {\n       expect(await getBrowserBodyText(browser)).toMatch(\n@@ -238,285 +237,212 @@ export function runErrorRecoveryHmrTest(nextConfig: {\n   if (!process.env.IS_TURBOPACK_TEST) {\n     // Turbopack doesn't have this restriction\n     it('should show the error on all pages', async () => {\n-      const aboutPage = join('pages', 'hmr', 'about2.js')\n-      const aboutContent = await next.readFile(aboutPage)\n       const browser = await next.browser(basePath + '/hmr/contact')\n-      try {\n-        await next.render(basePath + '/hmr/about2')\n-\n-        await next.patchFile(aboutPage, aboutContent.replace('</div>', 'div'))\n-\n-        // Ensure dev server has time to break:\n-        await new Promise((resolve) => setTimeout(resolve, 2000))\n-\n-        await assertHasRedbox(browser)\n-        expect(await getRedboxSource(browser)).toContain(\n-          \"Expected '</', got '<eof>'\"\n-        )\n+      await next.render(basePath + '/hmr/about2')\n \n-        await next.patchFile(aboutPage, aboutContent)\n-\n-        await retry(async () => {\n-          expect(await getBrowserBodyText(browser)).toMatch(\n-            /This is the contact page/\n+      await next.patchFile(\n+        join('pages', 'hmr', 'about2.js'),\n+        (content) => content.replace('</div>', 'div'),\n+        async () => {\n+          // Ensure dev server has time to break:\n+          await new Promise((resolve) => setTimeout(resolve, 2000))\n+\n+          await assertHasRedbox(browser)\n+          expect(await getRedboxSource(browser)).toContain(\n+            \"Expected '</', got '<eof>'\"\n           )\n-        })\n-      } catch (err) {\n-        await next.patchFile(aboutPage, aboutContent)\n-        if (browser) {\n-          await retry(async () => {\n-            expect(await getBrowserBodyText(browser)).toMatch(\n-              /This is the contact page/\n-            )\n-          })\n         }\n+      )\n \n-        throw err\n-      }\n+      await retry(async () => {\n+        expect(await getBrowserBodyText(browser)).toMatch(\n+          /This is the contact page/\n+        )\n+      })\n     })\n   }\n \n   it('should detect runtime errors on the module scope', async () => {\n     const browser = await next.browser(basePath + '/hmr/about3')\n-    const aboutPage = join('pages', 'hmr', 'about3.js')\n-    const aboutContent = await next.readFile(aboutPage)\n-    try {\n-      await retry(async () => {\n-        expect(await getBrowserBodyText(browser)).toMatch(\n-          /This is the about page/\n-        )\n-      })\n \n-      await next.patchFile(\n-        aboutPage,\n-        aboutContent.replace('export', 'aa=20;\\nexport')\n+    await retry(async () => {\n+      expect(await getBrowserBodyText(browser)).toMatch(\n+        /This is the about page/\n       )\n+    })\n \n-      await assertHasRedbox(browser)\n-      expect(await getRedboxHeader(browser)).toMatch(/aa is not defined/)\n-\n-      await next.patchFile(aboutPage, aboutContent)\n+    await next.patchFile(\n+      join('pages', 'hmr', 'about3.js'),\n+      (content) => content.replace('export', 'aa=20;\\nexport'),\n+      async () => {\n+        await assertHasRedbox(browser)\n+        expect(await getRedboxHeader(browser)).toMatch(/aa is not defined/)\n+      }\n+    )\n \n-      await retry(async () => {\n-        expect(await getBrowserBodyText(browser)).toMatch(\n-          /This is the about page/\n-        )\n-      })\n-    } finally {\n-      await next.patchFile(aboutPage, aboutContent)\n-    }\n+    await retry(async () => {\n+      expect(await getBrowserBodyText(browser)).toMatch(\n+        /This is the about page/\n+      )\n+    })\n   })\n \n   it('should recover from errors in the render function', async () => {\n     const browser = await next.browser(basePath + '/hmr/about4')\n-    const aboutPage = join('pages', 'hmr', 'about4.js')\n-    const aboutContent = await next.readFile(aboutPage)\n-    try {\n-      await retry(async () => {\n-        expect(await getBrowserBodyText(browser)).toMatch(\n-          /This is the about page/\n-        )\n-      })\n \n-      await next.patchFile(\n-        aboutPage,\n-        aboutContent.replace(\n-          'return',\n-          'throw new Error(\"an-expected-error\");\\nreturn'\n-        )\n+    await retry(async () => {\n+      expect(await getBrowserBodyText(browser)).toMatch(\n+        /This is the about page/\n       )\n+    })\n \n-      await assertHasRedbox(browser)\n-      expect(await getRedboxSource(browser)).toMatch(/an-expected-error/)\n-\n-      await next.patchFile(aboutPage, aboutContent)\n-\n-      await retry(async () => {\n-        expect(await getBrowserBodyText(browser)).toMatch(\n-          /This is the about page/\n-        )\n-      })\n-    } catch (err) {\n-      await next.patchFile(aboutPage, aboutContent)\n-      await retry(async () => {\n-        expect(await getBrowserBodyText(browser)).toMatch(\n-          /This is the about page/\n-        )\n-      })\n+    await next.patchFile(\n+      join('pages', 'hmr', 'about4.js'),\n+      (content) =>\n+        content.replace(\n+          'return',\n+          'throw new Error(\"an-expected-error\");\\nreturn'\n+        ),\n+      async () => {\n+        await assertHasRedbox(browser)\n+        expect(await getRedboxSource(browser)).toMatch(/an-expected-error/)\n+      }\n+    )\n \n-      throw err\n-    }\n+    await retry(async () => {\n+      expect(await getBrowserBodyText(browser)).toMatch(\n+        /This is the about page/\n+      )\n+    })\n   })\n \n   it('should recover after exporting an invalid page', async () => {\n     const browser = await next.browser(basePath + '/hmr/about5')\n-    const aboutPage = join('pages', 'hmr', 'about5.js')\n-    const aboutContent = await next.readFile(aboutPage)\n-    try {\n-      await retry(async () => {\n-        expect(await getBrowserBodyText(browser)).toMatch(\n-          /This is the about page/\n-        )\n-      })\n \n-      await next.patchFile(\n-        aboutPage,\n-        aboutContent.replace(\n+    await retry(async () => {\n+      expect(await getBrowserBodyText(browser)).toMatch(\n+        /This is the about page/\n+      )\n+    })\n+\n+    await next.patchFile(\n+      join('pages', 'hmr', 'about5.js'),\n+      (content) =>\n+        content.replace(\n           'export default',\n           'export default {};\\nexport const fn ='\n+        ),\n+      async () => {\n+        await assertHasRedbox(browser)\n+        expect(await getRedboxDescription(browser)).toMatchInlineSnapshot(\n+          `\"The default export is not a React Component in page: \"/hmr/about5\"\"`\n         )\n-      )\n+      }\n+    )\n \n-      await assertHasRedbox(browser)\n-      expect(await getRedboxDescription(browser)).toMatchInlineSnapshot(\n-        `\"The default export is not a React Component in page: \"/hmr/about5\"\"`\n+    await retry(async () => {\n+      expect(await getBrowserBodyText(browser)).toMatch(\n+        /This is the about page/\n       )\n-\n-      await next.patchFile(aboutPage, aboutContent)\n-\n-      await retry(async () => {\n-        expect(await getBrowserBodyText(browser)).toMatch(\n-          /This is the about page/\n-        )\n-      })\n-    } catch (err) {\n-      await next.patchFile(aboutPage, aboutContent)\n-\n-      await retry(async () => {\n-        expect(await getBrowserBodyText(browser)).toMatch(\n-          /This is the about page/\n-        )\n-      })\n-\n-      throw err\n-    }\n+    })\n   })\n \n   it('should recover after a bad return from the render function', async () => {\n     const browser = await next.browser(basePath + '/hmr/about6')\n-    const aboutPage = join('pages', 'hmr', 'about6.js')\n-    const aboutContent = await next.readFile(aboutPage)\n-    try {\n-      await retry(async () => {\n-        expect(await getBrowserBodyText(browser)).toMatch(\n-          /This is the about page/\n-        )\n-      })\n \n-      await next.patchFile(\n-        aboutPage,\n-        aboutContent.replace(\n+    await retry(async () => {\n+      expect(await getBrowserBodyText(browser)).toMatch(\n+        /This is the about page/\n+      )\n+    })\n+\n+    await next.patchFile(\n+      join('pages', 'hmr', 'about6.js'),\n+      (content) =>\n+        content.replace(\n           'export default',\n           'export default () => /search/;\\nexport const fn ='\n+        ),\n+      async () => {\n+        await assertHasRedbox(browser)\n+        // TODO: Replace this when webpack 5 is the default\n+        expect(await getRedboxHeader(browser)).toMatch(\n+          `Objects are not valid as a React child (found: [object RegExp]). If you meant to render a collection of children, use an array instead.`\n         )\n-      )\n+      }\n+    )\n \n-      await assertHasRedbox(browser)\n-      // TODO: Replace this when webpack 5 is the default\n-      expect(await getRedboxHeader(browser)).toMatch(\n-        `Objects are not valid as a React child (found: [object RegExp]). If you meant to render a collection of children, use an array instead.`\n+    await retry(async () => {\n+      expect(await getBrowserBodyText(browser)).toMatch(\n+        /This is the about page/\n       )\n-\n-      await next.patchFile(aboutPage, aboutContent)\n-\n-      await retry(async () => {\n-        expect(await getBrowserBodyText(browser)).toMatch(\n-          /This is the about page/\n-        )\n-      })\n-    } catch (err) {\n-      await next.patchFile(aboutPage, aboutContent)\n-\n-      await retry(async () => {\n-        expect(await getBrowserBodyText(browser)).toMatch(\n-          /This is the about page/\n-        )\n-      })\n-\n-      throw err\n-    }\n+    })\n   })\n \n   it('should recover after undefined exported as default', async () => {\n     const browser = await next.browser(basePath + '/hmr/about7')\n     const aboutPage = join('pages', 'hmr', 'about7.js')\n \n     const aboutContent = await next.readFile(aboutPage)\n-    try {\n-      await retry(async () => {\n-        expect(await getBrowserBodyText(browser)).toMatch(\n-          /This is the about page/\n-        )\n-      })\n-\n-      await next.patchFile(\n-        aboutPage,\n-        aboutContent.replace(\n-          'export default',\n-          'export default undefined;\\nexport const fn ='\n-        )\n-      )\n-\n-      await assertHasRedbox(browser)\n-      expect(await getRedboxDescription(browser)).toMatchInlineSnapshot(\n-        `\"The default export is not a React Component in page: \"/hmr/about7\"\"`\n+    await retry(async () => {\n+      expect(await getBrowserBodyText(browser)).toMatch(\n+        /This is the about page/\n       )\n+    })\n \n-      await next.patchFile(aboutPage, aboutContent)\n-\n-      await retry(async () => {\n-        expect(await getBrowserBodyText(browser)).toMatch(\n-          /This is the about page/\n-        )\n-      })\n-      await assertNoRedbox(browser)\n-    } catch (err) {\n-      await next.patchFile(aboutPage, aboutContent)\n-\n-      await retry(async () => {\n-        expect(await getBrowserBodyText(browser)).toMatch(\n-          /This is the about page/\n+    await next.patchFile(\n+      aboutPage,\n+      aboutContent.replace(\n+        'export default',\n+        'export default undefined;\\nexport const fn ='\n+      ),\n+      async () => {\n+        await assertHasRedbox(browser)\n+        expect(await getRedboxDescription(browser)).toMatchInlineSnapshot(\n+          `\"The default export is not a React Component in page: \"/hmr/about7\"\"`\n         )\n-      })\n+      }\n+    )\n \n-      throw err\n-    }\n+    await retry(async () => {\n+      expect(await getBrowserBodyText(browser)).toMatch(\n+        /This is the about page/\n+      )\n+    })\n+    await assertNoRedbox(browser)\n   })\n \n   it('should recover after webpack parse error in an imported file', async () => {\n     const browser = await next.browser(basePath + '/hmr/about8')\n-    const aboutPage = join('pages', 'hmr', 'about8.js')\n \n-    const aboutContent = await next.readFile(aboutPage)\n-    try {\n-      await retry(async () => {\n-        expect(await getBrowserBodyText(browser)).toMatch(\n-          /This is the about page/\n-        )\n-      })\n+    await retry(async () => {\n+      expect(await getBrowserBodyText(browser)).toMatch(\n+        /This is the about page/\n+      )\n+    })\n \n-      await next.patchFile(\n-        aboutPage,\n-        aboutContent.replace(\n+    await next.patchFile(\n+      join('pages', 'hmr', 'about8.js'),\n+      (content) =>\n+        content.replace(\n           'export default',\n           'import \"../../components/parse-error.xyz\"\\nexport default'\n-        )\n-      )\n-\n-      await assertHasRedbox(browser)\n-      expect(await getRedboxHeader(browser)).toMatch('Build Error')\n+        ),\n+      async () => {\n+        await assertHasRedbox(browser)\n+        expect(await getRedboxHeader(browser)).toMatch('Build Error')\n \n-      if (process.env.IS_TURBOPACK_TEST) {\n-        expect(await getRedboxSource(browser)).toMatchInlineSnapshot(`\n+        if (process.env.IS_TURBOPACK_TEST) {\n+          expect(await getRedboxSource(browser)).toMatchInlineSnapshot(`\n               \"./components/parse-error.xyz\n               Unknown module type\n               This module doesn't have an associated type. Use a known file extension, or register a loader for it.\n \n               Read more: https://nextjs.org/docs/app/api-reference/next-config-js/turbo#webpack-loaders\"\n             `)\n-      } else if (process.env.NEXT_RSPACK) {\n-        expect(trimEndMultiline(await getRedboxSource(browser)))\n-          .toMatchInlineSnapshot(`\n+        } else if (process.env.NEXT_RSPACK) {\n+          expect(trimEndMultiline(await getRedboxSource(browser)))\n+            .toMatchInlineSnapshot(`\n          \"./components/parse-error.xyz\n            × Module parse failed:\n            ╰─▶   × JavaScript parse error: Expression expected\n@@ -536,8 +462,8 @@ export function runErrorRecoveryHmrTest(nextConfig: {\n          ./components/parse-error.xyz\n          ./pages/hmr/about8.js\"\n         `)\n-      } else {\n-        expect(await getRedboxSource(browser)).toMatchInlineSnapshot(`\n+        } else {\n+          expect(await getRedboxSource(browser)).toMatchInlineSnapshot(`\n                       \"./components/parse-error.xyz\n                       Module parse failed: Unexpected token (3:0)\n                       You may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\n@@ -551,57 +477,43 @@ export function runErrorRecoveryHmrTest(nextConfig: {\n                       ./components/parse-error.xyz\n                       ./pages/hmr/about8.js\"\n                   `)\n+        }\n       }\n+    )\n \n-      await next.patchFile(aboutPage, aboutContent)\n-\n-      await retry(async () => {\n-        expect(await getBrowserBodyText(browser)).toMatch(\n-          /This is the about page/\n-        )\n-      })\n-      await assertNoRedbox(browser)\n-    } catch (err) {\n-      await next.patchFile(aboutPage, aboutContent)\n-\n-      await retry(async () => {\n-        expect(await getBrowserBodyText(browser)).toMatch(\n-          /This is the about page/\n-        )\n-      })\n-\n-      throw err\n-    }\n+    await retry(async () => {\n+      expect(await getBrowserBodyText(browser)).toMatch(\n+        /This is the about page/\n+      )\n+    })\n+    await assertNoRedbox(browser)\n   })\n \n   it('should recover after loader parse error in an imported file', async () => {\n     const browser = await next.browser(basePath + '/hmr/about9')\n-    const aboutPage = join('pages', 'hmr', 'about9.js')\n \n-    const aboutContent = await next.readFile(aboutPage)\n-    try {\n-      await retry(async () => {\n-        expect(await getBrowserBodyText(browser)).toMatch(\n-          /This is the about page/\n-        )\n-      })\n+    await retry(async () => {\n+      expect(await getBrowserBodyText(browser)).toMatch(\n+        /This is the about page/\n+      )\n+    })\n \n-      await next.patchFile(\n-        aboutPage,\n-        aboutContent.replace(\n+    await next.patchFile(\n+      join('pages', 'hmr', 'about9.js'),\n+      (content) =>\n+        content.replace(\n           'export default',\n           'import \"../../components/parse-error.js\"\\nexport default'\n-        )\n-      )\n-\n-      await assertHasRedbox(browser)\n-      expect(await getRedboxHeader(browser)).toMatch('Build Error')\n-      let redboxSource = await getRedboxSource(browser)\n+        ),\n+      async () => {\n+        await assertHasRedbox(browser)\n+        expect(await getRedboxHeader(browser)).toMatch('Build Error')\n+        let redboxSource = await getRedboxSource(browser)\n \n-      redboxSource = redboxSource.replace(`${next.testDir}`, '.')\n-      if (process.env.IS_TURBOPACK_TEST) {\n-        expect(next.normalizeTestDirContent(redboxSource))\n-          .toMatchInlineSnapshot(`\n+        redboxSource = redboxSource.replace(`${next.testDir}`, '.')\n+        if (process.env.IS_TURBOPACK_TEST) {\n+          expect(next.normalizeTestDirContent(redboxSource))\n+            .toMatchInlineSnapshot(`\n          \"./components/parse-error.js (3:1)\n          Parsing ecmascript source code failed\n            1 | This\n@@ -622,9 +534,9 @@ export function runErrorRecoveryHmrTest(nextConfig: {\n              ./components/parse-error.js\n              ./pages/hmr/about9.js\"\n         `)\n-      } else if (process.env.NEXT_RSPACK) {\n-        expect(trimEndMultiline(next.normalizeTestDirContent(redboxSource)))\n-          .toMatchInlineSnapshot(`\n+        } else if (process.env.NEXT_RSPACK) {\n+          expect(trimEndMultiline(next.normalizeTestDirContent(redboxSource)))\n+            .toMatchInlineSnapshot(`\n          \"./components/parse-error.js\n            × Module build failed:\n            ╰─▶   × Error:   x Expression expected\n@@ -645,11 +557,14 @@ export function runErrorRecoveryHmrTest(nextConfig: {\n          ./components/parse-error.js\n          ./pages/hmr/about9.js\"\n         `)\n-      } else {\n-        redboxSource = redboxSource.substring(0, redboxSource.indexOf('`----'))\n+        } else {\n+          redboxSource = redboxSource.substring(\n+            0,\n+            redboxSource.indexOf('`----')\n+          )\n \n-        expect(next.normalizeTestDirContent(redboxSource))\n-          .toMatchInlineSnapshot(`\n+          expect(next.normalizeTestDirContent(redboxSource))\n+            .toMatchInlineSnapshot(`\n             \"./components/parse-error.js\n             Error:   x Expression expected\n                ,-[3:1]\n@@ -661,107 +576,82 @@ export function runErrorRecoveryHmrTest(nextConfig: {\n              5 | js\n                \"\n           `)\n+        }\n       }\n+    )\n \n-      await next.patchFile(aboutPage, aboutContent)\n-\n-      await retry(async () => {\n-        expect(await getBrowserBodyText(browser)).toMatch(\n-          /This is the about page/\n-        )\n-      })\n-      await assertNoRedbox(browser)\n-    } catch (err) {\n-      await next.patchFile(aboutPage, aboutContent)\n-\n-      await retry(async () => {\n-        expect(await getBrowserBodyText(browser)).toMatch(\n-          /This is the about page/\n-        )\n-      })\n-    }\n+    await retry(async () => {\n+      expect(await getBrowserBodyText(browser)).toMatch(\n+        /This is the about page/\n+      )\n+    })\n+    await assertNoRedbox(browser)\n   })\n \n   it('should recover from errors in getInitialProps in client', async () => {\n     const browser = await next.browser(basePath + '/hmr')\n     const erroredPage = join('pages', 'hmr', 'error-in-gip.js')\n     const errorContent = await next.readFile(erroredPage)\n-    try {\n-      await browser.elementByCss('#error-in-gip-link').click()\n-\n-      await assertHasRedbox(browser)\n-      expect(await getRedboxDescription(browser)).toMatchInlineSnapshot(\n-        `\"an-expected-error-in-gip\"`\n-      )\n+    await browser.elementByCss('#error-in-gip-link').click()\n \n-      await next.patchFile(\n-        erroredPage,\n-        errorContent.replace('throw error', 'return {}')\n-      )\n-\n-      await retry(async () => {\n-        expect(await getBrowserBodyText(browser)).toMatch(/Hello/)\n-      })\n+    await assertHasRedbox(browser)\n+    expect(await getRedboxDescription(browser)).toMatchInlineSnapshot(\n+      `\"an-expected-error-in-gip\"`\n+    )\n+\n+    await next.patchFile(\n+      erroredPage,\n+      (content) => content.replace('throw error', 'return {}'),\n+      async () => {\n+        await retry(async () => {\n+          expect(await getBrowserBodyText(browser)).toMatch(/Hello/)\n+        })\n \n-      await next.patchFile(erroredPage, errorContent)\n+        await next.patchFile(erroredPage, errorContent)\n \n-      await retry(async () => {\n-        await browser.refresh()\n-        await waitFor(2000)\n-        const text = await getBrowserBodyText(browser)\n-        if (text.includes('Hello')) {\n-          throw new Error('waiting')\n-        }\n-        return expect(await getRedboxSource(browser)).toMatch(\n-          /an-expected-error-in-gip/\n-        )\n-      })\n-    } catch (err) {\n-      await next.patchFile(erroredPage, errorContent)\n-\n-      throw err\n-    }\n+        await retry(async () => {\n+          await browser.refresh()\n+          await waitFor(2000)\n+          const text = await getBrowserBodyText(browser)\n+          if (text.includes('Hello')) {\n+            throw new Error('waiting')\n+          }\n+          return expect(await getRedboxSource(browser)).toMatch(\n+            /an-expected-error-in-gip/\n+          )\n+        })\n+      }\n+    )\n   })\n \n   it('should recover after an error reported via SSR', async () => {\n     const browser = await next.browser(basePath + '/hmr/error-in-gip')\n-    const erroredPage = join('pages', 'hmr', 'error-in-gip.js')\n-    const errorContent = await next.readFile(erroredPage)\n-    try {\n-      await assertHasRedbox(browser)\n-      expect(await getRedboxDescription(browser)).toMatchInlineSnapshot(\n-        `\"an-expected-error-in-gip\"`\n-      )\n-\n-      const erroredPage = join('pages', 'hmr', 'error-in-gip.js')\n+    await assertHasRedbox(browser)\n+    expect(await getRedboxDescription(browser)).toMatchInlineSnapshot(\n+      `\"an-expected-error-in-gip\"`\n+    )\n+\n+    await next.patchFile(\n+      join('pages', 'hmr', 'error-in-gip.js'),\n+      (content) => content.replace('throw error', 'return {}'),\n+      async () => {\n+        await retry(async () => {\n+          expect(await getBrowserBodyText(browser)).toMatch(/Hello/)\n+        })\n+      }\n+    )\n \n-      await next.patchFile(\n-        erroredPage,\n-        errorContent.replace('throw error', 'return {}')\n+    await retry(async () => {\n+      await browser.refresh()\n+      await waitFor(2000)\n+      const text = await getBrowserBodyText(browser)\n+      if (text.includes('Hello')) {\n+        throw new Error('waiting')\n+      }\n+      return expect(await getRedboxSource(browser)).toMatch(\n+        /an-expected-error-in-gip/\n       )\n-\n-      await retry(async () => {\n-        expect(await getBrowserBodyText(browser)).toMatch(/Hello/)\n-      })\n-\n-      await next.patchFile(erroredPage, errorContent)\n-\n-      await retry(async () => {\n-        await browser.refresh()\n-        await waitFor(2000)\n-        const text = await getBrowserBodyText(browser)\n-        if (text.includes('Hello')) {\n-          throw new Error('waiting')\n-        }\n-        return expect(await getRedboxSource(browser)).toMatch(\n-          /an-expected-error-in-gip/\n-        )\n-      })\n-    } catch (err) {\n-      await next.patchFile(erroredPage, errorContent)\n-\n-      throw err\n-    }\n+    })\n   })\n \n   if (!process.env.IS_TURBOPACK_TEST) {"
        },
        {
            "sha": "a64958b6f3a6588ecda6786e048cdc9e1e10e7c3",
            "filename": "test/development/basic/hmr/run-hot-module-reload-hmr-test.util.ts",
            "status": "modified",
            "additions": 10,
            "deletions": 2,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/40f48ebb5e002459653c609dd63b740486bf0be5/test%2Fdevelopment%2Fbasic%2Fhmr%2Frun-hot-module-reload-hmr-test.util.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/40f48ebb5e002459653c609dd63b740486bf0be5/test%2Fdevelopment%2Fbasic%2Fhmr%2Frun-hot-module-reload-hmr-test.util.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Fbasic%2Fhmr%2Frun-hot-module-reload-hmr-test.util.ts?ref=40f48ebb5e002459653c609dd63b740486bf0be5",
            "patch": "@@ -22,6 +22,9 @@ export function runHotModuleReloadHmrTest(nextConfig: {\n         const text = await browser.elementByCss('p').text()\n         expect(text).toBe('This is the contact page.')\n \n+        expect(next.cliOutput).toMatch(/GET .*\\/hmr\\/contact 200/)\n+        let cliOutputLength = next.cliOutput.length\n+\n         // Rename the file to mimic a deleted page\n         await next.renameFile(contactPagePath, newContactPagePath)\n \n@@ -30,6 +33,10 @@ export function runHotModuleReloadHmrTest(nextConfig: {\n             /This page could not be found/\n           )\n         })\n+        expect(next.cliOutput.slice(cliOutputLength)).toMatch(\n+          /GET .*\\/hmr\\/contact 404/\n+        )\n+        cliOutputLength = next.cliOutput.length\n \n         // Rename the file back to the original filename\n         await next.renameFile(newContactPagePath, contactPagePath)\n@@ -40,8 +47,9 @@ export function runHotModuleReloadHmrTest(nextConfig: {\n             /This is the contact page/\n           )\n         })\n-\n-        expect(next.cliOutput).toContain('Compiled /_error')\n+        expect(next.cliOutput.slice(cliOutputLength)).toMatch(\n+          /GET .*\\/hmr\\/contact 200/\n+        )\n       } finally {\n         await next\n           .renameFile(newContactPagePath, contactPagePath)"
        },
        {
            "sha": "6c560357761e82847dfb7ec12a690779da42c377",
            "filename": "test/development/middleware-errors/index.test.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/40f48ebb5e002459653c609dd63b740486bf0be5/test%2Fdevelopment%2Fmiddleware-errors%2Findex.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/40f48ebb5e002459653c609dd63b740486bf0be5/test%2Fdevelopment%2Fmiddleware-errors%2Findex.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Fmiddleware-errors%2Findex.test.ts?ref=40f48ebb5e002459653c609dd63b740486bf0be5",
            "patch": "@@ -266,7 +266,7 @@ describe('middleware - development errors', () => {\n       await next.patchFile('middleware.js', `export default function () {}`)\n \n       retry(() => {\n-        expect(next.cliOutput.slice(lengthOfLogs)).toContain('✓ Compiled')\n+        expect(next.cliOutput.slice(lengthOfLogs)).toContain('GET / 200')\n       }, 10000) // middleware rebuild takes a while in CI\n \n       await assertNoRedbox(browser)"
        },
        {
            "sha": "7a369882d4de67129c639e67232ff7bb3cfaa3b3",
            "filename": "test/e2e/app-dir/app-compilation/index.test.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/40f48ebb5e002459653c609dd63b740486bf0be5/test%2Fe2e%2Fapp-dir%2Fapp-compilation%2Findex.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/40f48ebb5e002459653c609dd63b740486bf0be5/test%2Fe2e%2Fapp-dir%2Fapp-compilation%2Findex.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fapp-compilation%2Findex.test.ts?ref=40f48ebb5e002459653c609dd63b740486bf0be5",
            "patch": "@@ -37,7 +37,9 @@ describe('app dir', () => {\n         )\n \n         await retry(async () => {\n-          expect(next.cliOutput.slice(cliOutputLength)).toInclude('✓ Compiled')\n+          expect(next.cliOutput.slice(cliOutputLength)).toInclude(\n+            'GET /page-with-loading 200'\n+          )\n         })\n \n         // It should not have an error"
        },
        {
            "sha": "b0c080aadbe9a861b1198c83b5f4daeb19e48f35",
            "filename": "test/e2e/app-dir/app-middleware-proxy/app-middleware-proxy.test.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/40f48ebb5e002459653c609dd63b740486bf0be5/test%2Fe2e%2Fapp-dir%2Fapp-middleware-proxy%2Fapp-middleware-proxy.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/40f48ebb5e002459653c609dd63b740486bf0be5/test%2Fe2e%2Fapp-dir%2Fapp-middleware-proxy%2Fapp-middleware-proxy.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fapp-middleware-proxy%2Fapp-middleware-proxy.test.ts?ref=40f48ebb5e002459653c609dd63b740486bf0be5",
            "patch": "@@ -10,9 +10,11 @@ describe('app-dir with proxy', () => {\n   })\n \n   if (isNextDev) {\n-    it('should log Compiled proxy in', async () => {\n+    it('should log compilation time', async () => {\n       await next.browser('/')\n-      expect(next.cliOutput).toContain('Compiled proxy in')\n+      expect(next.cliOutput).toMatch(\n+        /GET \\/ 200 in .* \\(compile:.*, proxy.ts:.*, render:.*\\)/\n+      )\n     })\n   }\n "
        },
        {
            "sha": "2bf425a4527a4aaedaf008244f0268da960751df",
            "filename": "test/e2e/app-dir/cache-components-errors/cache-components-console-patch.test.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 8,
            "changes": 19,
            "blob_url": "https://github.com/vercel/next.js/blob/40f48ebb5e002459653c609dd63b740486bf0be5/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Fcache-components-console-patch.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/40f48ebb5e002459653c609dd63b740486bf0be5/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Fcache-components-console-patch.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Fcache-components-console-patch.test.ts?ref=40f48ebb5e002459653c609dd63b740486bf0be5",
            "patch": "@@ -1,5 +1,6 @@\n import { isNextDev, nextTestSetup } from 'e2e-utils'\n import { getPrerenderOutput } from './utils'\n+import stripAnsi from 'strip-ansi'\n \n describe('Cache Components Errors', () => {\n   const { next, isTurbopack, isNextStart, skipped } = nextTestSetup({\n@@ -32,15 +33,17 @@ describe('Cache Components Errors', () => {\n       if (isNextDev) {\n         it('does not warn about sync IO if console.log is patched to call new Date() internally', async () => {\n           await next.browser('/')\n-          let output = next.cliOutput\n-          expect(output).toContain('[<timestamp>]  ✓ Compiled')\n-          let index = output.indexOf('[<timestamp>]  ✓ Compiled')\n-          output = output.slice(index).trim()\n-          index = output.indexOf('\\n')\n-          output = output.slice(index).trim()\n+          let output = stripAnsi(next.cliOutput)\n+\n+          // trim off Next.js's startup logs\n+          const compilationMarker = /Ready in.*(\\n.*Compiling.*)?/\n+          expect(output).toMatch(compilationMarker)\n+          const match = compilationMarker.exec(output)\n+          output = output.slice(match.index + match[0].length).trim()\n+\n+          // trim off any logs after the HTTP request finished\n           expect(output).toContain('GET / 200')\n-          index = output.indexOf('GET / 200')\n-          const snapshot = output.slice(0, index).trim()\n+          const snapshot = output.slice(0, output.indexOf('GET / 200')).trim()\n \n           expect(snapshot).toMatchInlineSnapshot(`\n            \"[<timestamp>] This is a console log from a server component page"
        },
        {
            "sha": "07c6c9651c964128d5c43f72bab0bb615d2ea316",
            "filename": "test/e2e/app-dir/logging/fetch-logging.test.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/40f48ebb5e002459653c609dd63b740486bf0be5/test%2Fe2e%2Fapp-dir%2Flogging%2Ffetch-logging.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/40f48ebb5e002459653c609dd63b740486bf0be5/test%2Fe2e%2Fapp-dir%2Flogging%2Ffetch-logging.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Flogging%2Ffetch-logging.test.ts?ref=40f48ebb5e002459653c609dd63b740486bf0be5",
            "patch": "@@ -367,7 +367,7 @@ describe('app-dir - logging', () => {\n \n         await retry(() => {\n           const output = stripAnsi(next.cliOutput.slice(logLength))\n-          expect(output).toContain('/dynamic/[slug]/icon')\n+          expect(output).toContain('/dynamic/big/icon')\n           expect(output).not.toContain('/(group)')\n           expect(output).not.toContain('[__metadata_id__]')\n           expect(output).not.toContain('/route')"
        },
        {
            "sha": "90a3686756ce736f918ee97f43e6160ecad3f323",
            "filename": "test/e2e/app-dir/server-source-maps/server-source-maps.test.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 5,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/40f48ebb5e002459653c609dd63b740486bf0be5/test%2Fe2e%2Fapp-dir%2Fserver-source-maps%2Fserver-source-maps.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/40f48ebb5e002459653c609dd63b740486bf0be5/test%2Fe2e%2Fapp-dir%2Fserver-source-maps%2Fserver-source-maps.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fserver-source-maps%2Fserver-source-maps.test.ts?ref=40f48ebb5e002459653c609dd63b740486bf0be5",
            "patch": "@@ -320,7 +320,7 @@ describe('app-dir - server source maps', () => {\n \n       const cliOutput = stripAnsi(next.cliOutput.slice(outputIndex))\n       expect(cliOutput).toContain(\n-        '\\n ⨯ Error: ssr-throw' +\n+        '⨯ Error: ssr-throw' +\n           '\\n    at throwError (app/ssr-throw/Thrower.js:4:9)' +\n           '\\n    at Thrower (app/ssr-throw/Thrower.js:8:3)' +\n           '\\n  2 |' +\n@@ -441,8 +441,7 @@ describe('app-dir - server source maps', () => {\n       const cliOutput = stripAnsi(next.cliOutput.slice(outputIndex))\n       if (isTurbopack) {\n         expect(cliOutput).toContain(\n-          '' +\n-            '\\nError: module-evaluation' +\n+          'Error: module-evaluation' +\n             // TODO(veil): Should map to no name like you'd get with native stacks without a bundler.\n             '\\n    at module evaluation (app/module-evaluation/module.js:1:22)' +\n             // TODO(veil): Added frames from bundler should be sourcemapped (https://linear.app/vercel/issue/NDX-509/)\n@@ -451,8 +450,7 @@ describe('app-dir - server source maps', () => {\n         )\n       } else {\n         expect(cliOutput).toContain(\n-          '' +\n-            '\\nError: module-evaluation' +\n+          'Error: module-evaluation' +\n             // TODO(veil): Should map to no name like you'd get with native stacks without a bundler.\n             // TODO(veil): Location should be sourcemapped\n             '\\n    at eval (app/module-evaluation/module.js:1:22)' +"
        },
        {
            "sha": "8a81049a3e103ead00d70230f4f33bdcd2b60f36",
            "filename": "test/e2e/app-dir/use-cache-dev/use-cache-dev.test.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/40f48ebb5e002459653c609dd63b740486bf0be5/test%2Fe2e%2Fapp-dir%2Fuse-cache-dev%2Fuse-cache-dev.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/40f48ebb5e002459653c609dd63b740486bf0be5/test%2Fe2e%2Fapp-dir%2Fuse-cache-dev%2Fuse-cache-dev.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache-dev%2Fuse-cache-dev.test.ts?ref=40f48ebb5e002459653c609dd63b740486bf0be5",
            "patch": "@@ -149,7 +149,7 @@ describe('use-cache-dev', () => {\n       )\n \n       await retry(async () => {\n-        expect(next.cliOutput.slice(cliOutputLength)).toInclude('✓ Compiled')\n+        expect(next.cliOutput.slice(cliOutputLength)).toInclude('GET / 200')\n       }, 10_000)\n \n       cliOutputLength = next.cliOutput.length\n@@ -160,7 +160,7 @@ describe('use-cache-dev', () => {\n       )\n \n       await retry(async () => {\n-        expect(next.cliOutput.slice(cliOutputLength)).toInclude('✓ Compiled')\n+        expect(next.cliOutput.slice(cliOutputLength)).toInclude('GET / 200')\n       }, 10_000)\n     })\n "
        },
        {
            "sha": "f40b9021b540ea45b5c81f6232b4eb6ee8eed085",
            "filename": "test/e2e/fetch-failures-have-good-stack-traces-in-edge-runtime/fetch-failures-have-good-stack-traces-in-edge-runtime.test.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/40f48ebb5e002459653c609dd63b740486bf0be5/test%2Fe2e%2Ffetch-failures-have-good-stack-traces-in-edge-runtime%2Ffetch-failures-have-good-stack-traces-in-edge-runtime.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/40f48ebb5e002459653c609dd63b740486bf0be5/test%2Fe2e%2Ffetch-failures-have-good-stack-traces-in-edge-runtime%2Ffetch-failures-have-good-stack-traces-in-edge-runtime.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Ffetch-failures-have-good-stack-traces-in-edge-runtime%2Ffetch-failures-have-good-stack-traces-in-edge-runtime.test.ts?ref=40f48ebb5e002459653c609dd63b740486bf0be5",
            "patch": "@@ -29,8 +29,7 @@ describe('fetch failures have good stack traces in edge runtime', () => {\n       } else if (isNextDev) {\n         // eslint-disable-next-line jest/no-standalone-expect\n         expect(stripAnsi(next.cliOutput.slice(outputIndex))).toContain(\n-          '' +\n-            '\\n ⨯ Error [TypeError]: fetch failed' +\n+          '⨯ Error [TypeError]: fetch failed' +\n             '\\n    at anotherFetcher (src/fetcher.js:6:16)' +\n             '\\n    at fetcher (src/fetcher.js:2:16)' +\n             '\\n    at UnknownDomainEndpoint (pages/api/unknown-domain.js:6:16)' +"
        },
        {
            "sha": "cf67a74d6944b12199c8f9b7d41c54f7c3a6ec0c",
            "filename": "test/e2e/react-compiler/react-compiler.test.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/40f48ebb5e002459653c609dd63b740486bf0be5/test%2Fe2e%2Freact-compiler%2Freact-compiler.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/40f48ebb5e002459653c609dd63b740486bf0be5/test%2Fe2e%2Freact-compiler%2Freact-compiler.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Freact-compiler%2Freact-compiler.test.ts?ref=40f48ebb5e002459653c609dd63b740486bf0be5",
            "patch": "@@ -135,8 +135,7 @@ describe.each(['default', 'babelrc'] as const)(\n         // TODO(NDX-663): Unhelpful error message.\n         // Should say that the library should have a react-server entrypoint that doesn't use the React Compiler.\n         expect(cliOutput).toContain(\n-          '' +\n-            \"\\n ⨯ TypeError: Cannot read properties of undefined (reading 'H')\" +\n+          \"⨯ TypeError: Cannot read properties of undefined (reading 'H')\" +\n             // location not important. Just that this is the only frame.\n             // TODO: Stack should start at product code. Possible React limitation.\n             '\\n    at Container (**)' +"
        },
        {
            "sha": "b4316a91f7bec711b05a288ea00937c35ad6b971",
            "filename": "test/integration/next-image-new/middleware/test/index.test.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/40f48ebb5e002459653c609dd63b740486bf0be5/test%2Fintegration%2Fnext-image-new%2Fmiddleware%2Ftest%2Findex.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/40f48ebb5e002459653c609dd63b740486bf0be5/test%2Fintegration%2Fnext-image-new%2Fmiddleware%2Ftest%2Findex.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fintegration%2Fnext-image-new%2Fmiddleware%2Ftest%2Findex.test.ts?ref=40f48ebb5e002459653c609dd63b740486bf0be5",
            "patch": "@@ -1,7 +1,7 @@\n /* eslint-env jest */\n \n import { join } from 'path'\n-import { check, findPort, killApp, launchApp } from 'next-test-utils'\n+import { retry, findPort, killApp, launchApp } from 'next-test-utils'\n import webdriver from 'next-webdriver'\n \n const appDir = join(__dirname, '../')\n@@ -34,7 +34,9 @@ describe('Image with middleware in edge func', () => {\n         Attempted import error: 'preload' is not exported from 'react-dom' (imported as 'preload').\n        */\n         await webdriver(appPort, '/')\n-        await check(() => output, /compiled \\//i)\n+        await retry(async () => {\n+          expect(output).toContain('GET /')\n+        })\n         expect(output).not.toContain(\n           `'preload' is not exported from 'react-dom'`\n         )"
        },
        {
            "sha": "e146f93b138ad79c75aa33a06578c9787fb6b3f2",
            "filename": "test/integration/next-image-new/middleware/test/middleware-intercept-next-image.test.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/40f48ebb5e002459653c609dd63b740486bf0be5/test%2Fintegration%2Fnext-image-new%2Fmiddleware%2Ftest%2Fmiddleware-intercept-next-image.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/40f48ebb5e002459653c609dd63b740486bf0be5/test%2Fintegration%2Fnext-image-new%2Fmiddleware%2Ftest%2Fmiddleware-intercept-next-image.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fintegration%2Fnext-image-new%2Fmiddleware%2Ftest%2Fmiddleware-intercept-next-image.test.ts?ref=40f48ebb5e002459653c609dd63b740486bf0be5",
            "patch": "@@ -1,7 +1,7 @@\n /* eslint-env jest */\n \n import { join } from 'path'\n-import { check, findPort, killApp, launchApp } from 'next-test-utils'\n+import { findPort, killApp, launchApp, retry } from 'next-test-utils'\n import webdriver from 'next-webdriver'\n \n const appDir = join(__dirname, '../')\n@@ -33,7 +33,9 @@ describe('Image is intercepted by Middleware', () => {\n \n         await browser.waitForIdleNetwork()\n \n-        await check(() => output, /compiled \\//i)\n+        await retry(async () => {\n+          expect(output).toContain('GET /')\n+        })\n \n         expect(output).toContain(`x-_next-image: /small.jpg`)\n       })"
        }
    ],
    "stats": {
        "total": 984,
        "additions": 393,
        "deletions": 591
    }
}