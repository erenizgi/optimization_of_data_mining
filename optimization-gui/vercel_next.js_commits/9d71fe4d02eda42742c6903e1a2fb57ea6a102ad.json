{
    "author": "sokra",
    "message": "Turbopack: add concurrency limit to effects (#78725)\n\n### What?\n\nThis avoids trying to apply too many effect in parallel.",
    "sha": "9d71fe4d02eda42742c6903e1a2fb57ea6a102ad",
    "files": [
        {
            "sha": "7a90345f861975706600050a7920fda962164ecf",
            "filename": "turbopack/crates/turbo-tasks/src/effect.rs",
            "status": "modified",
            "additions": 15,
            "deletions": 12,
            "changes": 27,
            "blob_url": "https://github.com/vercel/next.js/blob/9d71fe4d02eda42742c6903e1a2fb57ea6a102ad/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Feffect.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/9d71fe4d02eda42742c6903e1a2fb57ea6a102ad/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Feffect.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Feffect.rs?ref=9d71fe4d02eda42742c6903e1a2fb57ea6a102ad",
            "patch": "@@ -2,6 +2,7 @@ use std::{borrow::Cow, future::Future, mem::replace, panic, pin::Pin};\n \n use anyhow::{anyhow, Result};\n use auto_hash_map::AutoSet;\n+use futures::{StreamExt, TryStreamExt};\n use parking_lot::Mutex;\n use rustc_hash::FxHashSet;\n use tracing::{Instrument, Span};\n@@ -17,6 +18,8 @@ use crate::{\n     CollectiblesSource, NonLocalValue, ReadRef, ResolvedVc, TryJoinIterExt,\n };\n \n+const APPLY_EFFECTS_CONCURRENCY_LIMIT: usize = 1024;\n+\n /// A trait to emit a task effect as collectible. This trait only has one\n /// implementation, `EffectInstance` and no other implementation is allowed.\n /// The trait is private to this module so that no other implementation can be\n@@ -168,17 +171,16 @@ pub async fn apply_effects(source: impl CollectiblesSource) -> Result<()> {\n     }\n     let span = tracing::info_span!(\"apply effects\", count = effects.len());\n     async move {\n-        effects\n-            .into_iter()\n-            .map(async |effect| {\n+        // Limit the concurrency of effects\n+        futures::stream::iter(effects)\n+            .map(Ok)\n+            .try_for_each_concurrent(APPLY_EFFECTS_CONCURRENCY_LIMIT, async |effect| {\n                 let Some(effect) = ResolvedVc::try_downcast_type::<EffectInstance>(effect) else {\n                     panic!(\"Effect must only be implemented by EffectInstance\");\n                 };\n                 effect.await?.apply().await\n             })\n-            .try_join()\n-            .await?;\n-        Ok(())\n+            .await\n     }\n     .instrument(span)\n     .await\n@@ -251,12 +253,13 @@ impl Effects {\n     pub async fn apply(&self) -> Result<()> {\n         let span = tracing::info_span!(\"apply effects\", count = self.effects.len());\n         async move {\n-            self.effects\n-                .iter()\n-                .map(async |effect| effect.apply().await)\n-                .try_join()\n-                .await?;\n-            Ok(())\n+            // Limit the concurrency of effects\n+            futures::stream::iter(self.effects.iter())\n+                .map(Ok)\n+                .try_for_each_concurrent(APPLY_EFFECTS_CONCURRENCY_LIMIT, async |effect| {\n+                    effect.apply().await\n+                })\n+                .await\n         }\n         .instrument(span)\n         .await"
        }
    ],
    "stats": {
        "total": 27,
        "additions": 15,
        "deletions": 12
    }
}