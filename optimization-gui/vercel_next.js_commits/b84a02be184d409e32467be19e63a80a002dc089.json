{
    "author": "sokra",
    "message": "Turbopack: use document.currentScript instead of chunk path literal (#77773)\n\n### What?\n\nInstead of embedding the chunk filename into the chunk itself (which is a probably for content hashing), use `document.currentScript` to grab the chunk path.",
    "sha": "b84a02be184d409e32467be19e63a80a002dc089",
    "files": [
        {
            "sha": "94a2b7f6d917d225bb11c8785580376edd1cdc41",
            "filename": "crates/next-core/src/next_client/context.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/b84a02be184d409e32467be19e63a80a002dc089/crates%2Fnext-core%2Fsrc%2Fnext_client%2Fcontext.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b84a02be184d409e32467be19e63a80a002dc089/crates%2Fnext-core%2Fsrc%2Fnext_client%2Fcontext.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_client%2Fcontext.rs?ref=b84a02be184d409e32467be19e63a80a002dc089",
            "patch": "@@ -13,7 +13,9 @@ use turbopack::{\n     },\n     resolve_options_context::ResolveOptionsContext,\n };\n-use turbopack_browser::{react_refresh::assert_can_resolve_react_refresh, BrowserChunkingContext};\n+use turbopack_browser::{\n+    react_refresh::assert_can_resolve_react_refresh, BrowserChunkingContext, CurrentChunkMethod,\n+};\n use turbopack_core::{\n     chunk::{\n         module_id_strategies::ModuleIdStrategy, ChunkingConfig, ChunkingContext, MinifyType,\n@@ -462,6 +464,7 @@ pub async fn get_client_chunking_context(\n         SourceMapsType::None\n     })\n     .asset_base_path(asset_prefix)\n+    .current_chunk_method(CurrentChunkMethod::DocumentCurrentScript)\n     .module_id_strategy(module_id_strategy);\n \n     if next_mode.is_development() {"
        },
        {
            "sha": "8b0b43d0de825dcae976549bed5032563012c901",
            "filename": "turbopack/crates/turbopack-browser/src/chunking_context.rs",
            "status": "modified",
            "additions": 23,
            "deletions": 0,
            "changes": 23,
            "blob_url": "https://github.com/vercel/next.js/blob/b84a02be184d409e32467be19e63a80a002dc089/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fchunking_context.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b84a02be184d409e32467be19e63a80a002dc089/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fchunking_context.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fchunking_context.rs?ref=b84a02be184d409e32467be19e63a80a002dc089",
            "patch": "@@ -32,6 +32,16 @@ use crate::ecmascript::{\n     list::asset::{EcmascriptDevChunkList, EcmascriptDevChunkListSource},\n };\n \n+#[turbo_tasks::value]\n+#[derive(Debug, Clone, Copy, Hash)]\n+pub enum CurrentChunkMethod {\n+    StringLiteral,\n+    DocumentCurrentScript,\n+}\n+\n+pub const CURRENT_CHUNK_METHOD_DOCUMENT_CURRENT_SCRIPT_EXPR: &str =\n+    \"typeof document === \\\"object\\\" ? document.currentScript : undefined\";\n+\n pub struct BrowserChunkingContextBuilder {\n     chunking_context: BrowserChunkingContext,\n }\n@@ -92,6 +102,11 @@ impl BrowserChunkingContextBuilder {\n         self\n     }\n \n+    pub fn current_chunk_method(mut self, method: CurrentChunkMethod) -> Self {\n+        self.chunking_context.current_chunk_method = method;\n+        self\n+    }\n+\n     pub fn module_id_strategy(\n         mut self,\n         module_id_strategy: ResolvedVc<Box<dyn ModuleIdStrategy>>,\n@@ -160,6 +175,8 @@ pub struct BrowserChunkingContext {\n     minify_type: MinifyType,\n     /// Whether to generate source maps\n     source_maps_type: SourceMapsType,\n+    /// Method to use when figuring out the current chunk src\n+    current_chunk_method: CurrentChunkMethod,\n     /// Whether to use manifest chunks for lazy compilation\n     manifest_chunks: bool,\n     /// The module id strategy to use\n@@ -198,6 +215,7 @@ impl BrowserChunkingContext {\n                 runtime_type,\n                 minify_type: MinifyType::NoMinify,\n                 source_maps_type: SourceMapsType::Full,\n+                current_chunk_method: CurrentChunkMethod::StringLiteral,\n                 manifest_chunks: false,\n                 module_id_strategy: ResolvedVc::upcast(DevModuleIdStrategy::new_resolved()),\n                 chunking_configs: Default::default(),\n@@ -297,6 +315,11 @@ impl BrowserChunkingContext {\n             },\n         )\n     }\n+\n+    #[turbo_tasks::function]\n+    pub fn current_chunk_method(&self) -> Vc<CurrentChunkMethod> {\n+        self.current_chunk_method.cell()\n+    }\n }\n \n #[turbo_tasks::value_impl]"
        },
        {
            "sha": "48a15635d477261939cab74e21e5c2208ffefd06",
            "filename": "turbopack/crates/turbopack-browser/src/ecmascript/content.rs",
            "status": "modified",
            "additions": 29,
            "deletions": 16,
            "changes": 45,
            "blob_url": "https://github.com/vercel/next.js/blob/b84a02be184d409e32467be19e63a80a002dc089/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fecmascript%2Fcontent.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b84a02be184d409e32467be19e63a80a002dc089/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fecmascript%2Fcontent.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fecmascript%2Fcontent.rs?ref=b84a02be184d409e32467be19e63a80a002dc089",
            "patch": "@@ -1,6 +1,7 @@\n use std::io::Write;\n \n use anyhow::{bail, Result};\n+use either::Either;\n use indoc::writedoc;\n use turbo_rcstr::RcStr;\n use turbo_tasks::{ResolvedVc, Vc};\n@@ -19,7 +20,10 @@ use super::{\n     chunk::EcmascriptBrowserChunk, content_entry::EcmascriptBrowserChunkContentEntries,\n     merged::merger::EcmascriptBrowserChunkContentMerger, version::EcmascriptBrowserChunkVersion,\n };\n-use crate::BrowserChunkingContext;\n+use crate::{\n+    chunking_context::{CurrentChunkMethod, CURRENT_CHUNK_METHOD_DOCUMENT_CURRENT_SCRIPT_EXPR},\n+    BrowserChunkingContext,\n+};\n \n #[turbo_tasks::value(serialization = \"none\")]\n pub struct EcmascriptBrowserChunkContent {\n@@ -67,21 +71,31 @@ impl EcmascriptBrowserChunkContent {\n     #[turbo_tasks::function]\n     async fn code(self: Vc<Self>) -> Result<Vc<Code>> {\n         let this = self.await?;\n-        let output_root = this.chunking_context.output_root().await?;\n         let source_maps = *this\n             .chunking_context\n             .reference_chunk_source_maps(*ResolvedVc::upcast(this.chunk))\n             .await?;\n-        let chunk_path_vc = this.chunk.path();\n-        let chunk_path = chunk_path_vc.await?;\n-        let chunk_server_path = if let Some(path) = output_root.get_path_to(&chunk_path) {\n-            path\n-        } else {\n-            bail!(\n-                \"chunk path {} is not in output root {}\",\n-                chunk_path.to_string(),\n-                output_root.to_string()\n-            );\n+        // Lifetime hack to pull out the var into this scope\n+        let chunk_path;\n+        let script_or_path = match *this.chunking_context.current_chunk_method().await? {\n+            CurrentChunkMethod::StringLiteral => {\n+                let output_root = this.chunking_context.output_root().await?;\n+                let chunk_path_vc = this.chunk.path();\n+                chunk_path = chunk_path_vc.await?;\n+                let chunk_server_path = if let Some(path) = output_root.get_path_to(&chunk_path) {\n+                    path\n+                } else {\n+                    bail!(\n+                        \"chunk path {} is not in output root {}\",\n+                        chunk_path.to_string(),\n+                        output_root.to_string()\n+                    );\n+                };\n+                Either::Left(StringifyJs(chunk_server_path))\n+            }\n+            CurrentChunkMethod::DocumentCurrentScript => {\n+                Either::Right(CURRENT_CHUNK_METHOD_DOCUMENT_CURRENT_SCRIPT_EXPR)\n+            }\n         };\n         let mut code = CodeBuilder::new(source_maps);\n \n@@ -95,9 +109,8 @@ impl EcmascriptBrowserChunkContent {\n         writedoc!(\n             code,\n             r#\"\n-                (globalThis.TURBOPACK = globalThis.TURBOPACK || []).push([{chunk_path}, {{\n-            \"#,\n-            chunk_path = StringifyJs(chunk_server_path)\n+                (globalThis.TURBOPACK = globalThis.TURBOPACK || []).push([{script_or_path}, {{\n+            \"#\n         )?;\n \n         let content = this.content.await?;\n@@ -115,7 +128,7 @@ impl EcmascriptBrowserChunkContent {\n         let mut code = code.build();\n \n         if let MinifyType::Minify { mangle } = this.chunking_context.await?.minify_type() {\n-            code = minify(&*chunk_path_vc.await?, &code, source_maps, mangle)?;\n+            code = minify(&code, source_maps, mangle)?;\n         }\n \n         Ok(code.cell())"
        },
        {
            "sha": "ad42afc184b0867544d92bd1de3d75612656b9a7",
            "filename": "turbopack/crates/turbopack-browser/src/ecmascript/evaluate/chunk.rs",
            "status": "modified",
            "additions": 28,
            "deletions": 15,
            "changes": 43,
            "blob_url": "https://github.com/vercel/next.js/blob/b84a02be184d409e32467be19e63a80a002dc089/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fecmascript%2Fevaluate%2Fchunk.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b84a02be184d409e32467be19e63a80a002dc089/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fecmascript%2Fevaluate%2Fchunk.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fecmascript%2Fevaluate%2Fchunk.rs?ref=b84a02be184d409e32467be19e63a80a002dc089",
            "patch": "@@ -1,6 +1,7 @@\n use std::io::Write;\n \n use anyhow::{bail, Result};\n+use either::Either;\n use indoc::writedoc;\n use serde::Serialize;\n use turbo_rcstr::RcStr;\n@@ -26,7 +27,10 @@ use turbopack_ecmascript::{\n };\n use turbopack_ecmascript_runtime::RuntimeType;\n \n-use crate::BrowserChunkingContext;\n+use crate::{\n+    chunking_context::{CurrentChunkMethod, CURRENT_CHUNK_METHOD_DOCUMENT_CURRENT_SCRIPT_EXPR},\n+    BrowserChunkingContext,\n+};\n \n /// An Ecmascript chunk that:\n /// * Contains the Turbopack browser runtime code; and\n@@ -74,22 +78,32 @@ impl EcmascriptBrowserEvaluateChunk {\n         let chunking_context = this.chunking_context.await?;\n         let environment = this.chunking_context.environment();\n \n-        let output_root = this.chunking_context.output_root().await?;\n         let output_root_to_root_path = this.chunking_context.output_root_to_root_path();\n         let source_maps = *this\n             .chunking_context\n             .reference_chunk_source_maps(Vc::upcast(self))\n             .await?;\n-        let chunk_path_vc = self.path();\n-        let chunk_path = chunk_path_vc.await?;\n-        let chunk_public_path = if let Some(path) = output_root.get_path_to(&chunk_path) {\n-            path\n-        } else {\n-            bail!(\n-                \"chunk path {} is not in output root {}\",\n-                chunk_path.to_string(),\n-                output_root.to_string()\n-            );\n+        // Lifetime hack to pull out the var into this scope\n+        let chunk_path;\n+        let script_or_path = match *this.chunking_context.current_chunk_method().await? {\n+            CurrentChunkMethod::StringLiteral => {\n+                let output_root = this.chunking_context.output_root().await?;\n+                let chunk_path_vc = self.path();\n+                chunk_path = chunk_path_vc.await?;\n+                let chunk_server_path = if let Some(path) = output_root.get_path_to(&chunk_path) {\n+                    path\n+                } else {\n+                    bail!(\n+                        \"chunk path {} is not in output root {}\",\n+                        chunk_path.to_string(),\n+                        output_root.to_string()\n+                    );\n+                };\n+                Either::Left(StringifyJs(chunk_server_path))\n+            }\n+            CurrentChunkMethod::DocumentCurrentScript => {\n+                Either::Right(CURRENT_CHUNK_METHOD_DOCUMENT_CURRENT_SCRIPT_EXPR)\n+            }\n         };\n \n         let other_chunks_data = self.chunks_data().await?;\n@@ -139,12 +153,11 @@ impl EcmascriptBrowserEvaluateChunk {\n             code,\n             r#\"\n                 (globalThis.TURBOPACK = globalThis.TURBOPACK || []).push([\n-                    {},\n+                    {script_or_path},\n                     {{}},\n                     {}\n                 ]);\n             \"#,\n-            StringifyJs(&chunk_public_path),\n             StringifyJs(&params),\n         )?;\n \n@@ -181,7 +194,7 @@ impl EcmascriptBrowserEvaluateChunk {\n         let mut code = code.build();\n \n         if let MinifyType::Minify { mangle } = this.chunking_context.await?.minify_type() {\n-            code = minify(&*chunk_path_vc.await?, &code, source_maps, mangle)?;\n+            code = minify(&code, source_maps, mangle)?;\n         }\n \n         Ok(code.cell())"
        },
        {
            "sha": "dccf1fa2482d5fe25e434a81bbe5a7dac86d5689",
            "filename": "turbopack/crates/turbopack-browser/src/ecmascript/list/content.rs",
            "status": "modified",
            "additions": 58,
            "deletions": 39,
            "changes": 97,
            "blob_url": "https://github.com/vercel/next.js/blob/b84a02be184d409e32467be19e63a80a002dc089/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fecmascript%2Flist%2Fcontent.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b84a02be184d409e32467be19e63a80a002dc089/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fecmascript%2Flist%2Fcontent.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fecmascript%2Flist%2Fcontent.rs?ref=b84a02be184d409e32467be19e63a80a002dc089",
            "patch": "@@ -1,9 +1,13 @@\n use std::io::Write;\n \n use anyhow::{Context, Result};\n+use either::Either;\n use indoc::writedoc;\n-use serde::Serialize;\n-use turbo_tasks::{FxIndexMap, IntoTraitRef, ResolvedVc, TryJoinIterExt, Vc};\n+use serde::{Deserialize, Serialize};\n+use turbo_rcstr::RcStr;\n+use turbo_tasks::{\n+    trace::TraceRawVcs, FxIndexMap, IntoTraitRef, NonLocalValue, ResolvedVc, TryJoinIterExt, Vc,\n+};\n use turbo_tasks_fs::File;\n use turbopack_core::{\n     asset::{Asset, AssetContent},\n@@ -21,11 +25,20 @@ use super::{\n     update::update_chunk_list,\n     version::EcmascriptDevChunkListVersion,\n };\n+use crate::chunking_context::{\n+    CurrentChunkMethod, CURRENT_CHUNK_METHOD_DOCUMENT_CURRENT_SCRIPT_EXPR,\n+};\n+\n+#[derive(Clone, Debug, Serialize, Deserialize, TraceRawVcs, PartialEq, Eq, NonLocalValue)]\n+enum CurrentChunkMethodWithData {\n+    StringLiteral(RcStr),\n+    DocumentCurrentScript,\n+}\n \n /// Contents of an [`EcmascriptDevChunkList`].\n #[turbo_tasks::value]\n pub(super) struct EcmascriptDevChunkListContent {\n-    chunk_list_path: String,\n+    current_chunk_method: CurrentChunkMethodWithData,\n     pub(super) chunks_contents: FxIndexMap<String, ResolvedVc<Box<dyn VersionedContent>>>,\n     source: EcmascriptDevChunkListSource,\n }\n@@ -37,25 +50,35 @@ impl EcmascriptDevChunkListContent {\n     pub async fn new(chunk_list: Vc<EcmascriptDevChunkList>) -> Result<Vc<Self>> {\n         let chunk_list_ref = chunk_list.await?;\n         let output_root = chunk_list_ref.chunking_context.output_root().await?;\n+        let current_chunk_method = match *chunk_list_ref\n+            .chunking_context\n+            .current_chunk_method()\n+            .await?\n+        {\n+            CurrentChunkMethod::StringLiteral => {\n+                let path = output_root\n+                    .get_path_to(&*chunk_list.path().await?)\n+                    .context(\"chunk list path not in output root\")?\n+                    .into();\n+                CurrentChunkMethodWithData::StringLiteral(path)\n+            }\n+            CurrentChunkMethod::DocumentCurrentScript => {\n+                CurrentChunkMethodWithData::DocumentCurrentScript\n+            }\n+        };\n         Ok(EcmascriptDevChunkListContent {\n-            chunk_list_path: output_root\n-                .get_path_to(&*chunk_list.path().await?)\n-                .context(\"chunk list path not in output root\")?\n-                .to_string(),\n+            current_chunk_method,\n             chunks_contents: chunk_list_ref\n                 .chunks\n                 .await?\n                 .iter()\n-                .map(|chunk| {\n-                    let output_root = output_root.clone();\n-                    async move {\n-                        Ok((\n-                            output_root\n-                                .get_path_to(&*chunk.path().await?)\n-                                .map(|path| path.to_string()),\n-                            chunk.versioned_content().to_resolved().await?,\n-                        ))\n-                    }\n+                .map(async |chunk| {\n+                    Ok((\n+                        output_root\n+                            .get_path_to(&*chunk.path().await?)\n+                            .map(|path| path.to_string()),\n+                        chunk.versioned_content().to_resolved().await?,\n+                    ))\n                 })\n                 .try_join()\n                 .await?\n@@ -111,10 +134,17 @@ impl EcmascriptDevChunkListContent {\n     pub(super) async fn code(self: Vc<Self>) -> Result<Vc<Code>> {\n         let this = self.await?;\n \n-        let params = EcmascriptDevChunkListParams {\n-            path: &this.chunk_list_path,\n-            chunks: this.chunks_contents.keys().map(|s| s.as_str()).collect(),\n-            source: this.source,\n+        let chunks = this\n+            .chunks_contents\n+            .keys()\n+            .map(|s| s.as_str())\n+            .collect::<Vec<_>>();\n+\n+        let script_or_path = match &this.current_chunk_method {\n+            CurrentChunkMethodWithData::StringLiteral(path) => Either::Left(StringifyJs(path)),\n+            CurrentChunkMethodWithData::DocumentCurrentScript => {\n+                Either::Right(CURRENT_CHUNK_METHOD_DOCUMENT_CURRENT_SCRIPT_EXPR)\n+            }\n         };\n \n         let mut code = CodeBuilder::default();\n@@ -125,14 +155,14 @@ impl EcmascriptDevChunkListContent {\n         writedoc!(\n             code,\n             r#\"\n-                (globalThis.TURBOPACK = globalThis.TURBOPACK || []).push([\n-                    {},\n-                    {{}},\n-                ]);\n-                (globalThis.TURBOPACK_CHUNK_LISTS = globalThis.TURBOPACK_CHUNK_LISTS || []).push({:#});\n+                (globalThis.TURBOPACK_CHUNK_LISTS = globalThis.TURBOPACK_CHUNK_LISTS || []).push({{\n+                    script: {script_or_path},\n+                    chunks: {:#},\n+                    source: {:#}\n+                }});\n             \"#,\n-            StringifyJs(&this.chunk_list_path),\n-            StringifyJs(&params),\n+            StringifyJs(&chunks),\n+            StringifyJs(&this.source),\n         )?;\n \n         Ok(Code::cell(code.build()))\n@@ -159,14 +189,3 @@ impl VersionedContent for EcmascriptDevChunkListContent {\n         update_chunk_list(self, from_version)\n     }\n }\n-\n-#[derive(Debug, Clone, Serialize)]\n-#[serde(rename_all = \"camelCase\")]\n-struct EcmascriptDevChunkListParams<'a> {\n-    /// Path to the chunk list to register.\n-    path: &'a str,\n-    /// All chunks that belong to the chunk list.\n-    chunks: Vec<&'a str>,\n-    /// Where this chunk list is from.\n-    source: EcmascriptDevChunkListSource,\n-}"
        },
        {
            "sha": "cd69cf4afa6d04dc6a0bd5b0d52ec78dfd24fd85",
            "filename": "turbopack/crates/turbopack-browser/src/lib.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/b84a02be184d409e32467be19e63a80a002dc089/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b84a02be184d409e32467be19e63a80a002dc089/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Flib.rs?ref=b84a02be184d409e32467be19e63a80a002dc089",
            "patch": "@@ -7,7 +7,9 @@ pub(crate) mod chunking_context;\n pub mod ecmascript;\n pub mod react_refresh;\n \n-pub use chunking_context::{BrowserChunkingContext, BrowserChunkingContextBuilder};\n+pub use chunking_context::{\n+    BrowserChunkingContext, BrowserChunkingContextBuilder, CurrentChunkMethod,\n+};\n \n pub fn register() {\n     turbo_tasks::register();"
        },
        {
            "sha": "8b6301ef0d4dbf508d871c15136bf14feb2d9013",
            "filename": "turbopack/crates/turbopack-ecmascript-runtime/js/src/browser/runtime/base/dev-base.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 20,
            "changes": 25,
            "blob_url": "https://github.com/vercel/next.js/blob/b84a02be184d409e32467be19e63a80a002dc089/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fbase%2Fdev-base.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/b84a02be184d409e32467be19e63a80a002dc089/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fbase%2Fdev-base.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fbase%2Fdev-base.ts?ref=b84a02be184d409e32467be19e63a80a002dc089",
            "patch": "@@ -20,10 +20,6 @@ const devModuleCache: ModuleCache<HotModule> = Object.create(null);\n type RefreshRuntimeGlobals =\n   import(\"@next/react-refresh-utils/dist/runtime\").RefreshRuntimeGlobals;\n \n-// Workers are loaded via blob object urls and aren't relative to the main context, this gets\n-// prefixed to chunk urls in the worker.\n-// declare var TURBOPACK_WORKER_LOCATION: string;\n-// declare var CHUNK_BASE_PATH: string;\n declare var $RefreshHelpers$: RefreshRuntimeGlobals[\"$RefreshHelpers$\"];\n declare var $RefreshReg$: RefreshRuntimeGlobals[\"$RefreshReg$\"];\n declare var $RefreshSig$: RefreshRuntimeGlobals[\"$RefreshSig$\"];\n@@ -1080,11 +1076,13 @@ function disposeChunk(chunkPath: ChunkPath): boolean {\n  * Subscribes to chunk list updates from the update server and applies them.\n  */\n function registerChunkList(\n-  chunkUpdateProvider: ChunkUpdateProvider,\n   chunkList: ChunkList\n ) {\n-  const chunkListPath = chunkList.path;\n-  chunkUpdateProvider.push([\n+  const chunkListScript = chunkList.script;\n+  const chunkListPath = getPathFromScript(chunkListScript);\n+  // The \"chunk\" is also registered to finish the loading in the backend\n+  BACKEND.registerChunk(chunkListPath as string as ChunkPath);\n+  globalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS!.push([\n     chunkListPath,\n     handleApply.bind(null, chunkListPath),\n   ]);\n@@ -1108,16 +1106,3 @@ function registerChunkList(\n }\n \n globalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS ??= [];\n-\n-const chunkListsToRegister = globalThis.TURBOPACK_CHUNK_LISTS;\n-if (Array.isArray(chunkListsToRegister)) {\n-  for (const chunkList of chunkListsToRegister) {\n-    registerChunkList(globalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS, chunkList);\n-  }\n-}\n-\n-globalThis.TURBOPACK_CHUNK_LISTS = {\n-  push: (chunkList) => {\n-    registerChunkList(globalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS!, chunkList);\n-  },\n-} satisfies ChunkListProvider;"
        },
        {
            "sha": "56a15c50f3d70223bb295177440e0dd1c3ab08c9",
            "filename": "turbopack/crates/turbopack-ecmascript-runtime/js/src/browser/runtime/base/runtime-base.ts",
            "status": "modified",
            "additions": 32,
            "deletions": 4,
            "changes": 36,
            "blob_url": "https://github.com/vercel/next.js/blob/b84a02be184d409e32467be19e63a80a002dc089/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fbase%2Fruntime-base.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/b84a02be184d409e32467be19e63a80a002dc089/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fbase%2Fruntime-base.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fbase%2Fruntime-base.ts?ref=b84a02be184d409e32467be19e63a80a002dc089",
            "patch": "@@ -11,9 +11,17 @@\n /// <reference path=\"../base/globals.d.ts\" />\n /// <reference path=\"../../../shared/runtime-utils.ts\" />\n \n+// Used in WebWorkers to tell the runtime about the chunk base path\n declare var TURBOPACK_WORKER_LOCATION: string;\n+// Used in WebWorkers to tell the runtime about the current chunk url since it can't be detected via document.currentScript\n+// Note it's stored in reversed order to use push and pop\n+declare var TURBOPACK_NEXT_CHUNK_URLS: ChunkUrl[] | undefined;\n+\n+// Injected by rust code\n declare var CHUNK_BASE_PATH: string;\n declare var CHUNK_SUFFIX_PATH: string;\n+\n+// Provided by build or dev base\n declare function instantiateModule(id: ModuleId, source: SourceInfo): Module;\n \n type RuntimeParams = {\n@@ -22,13 +30,13 @@ type RuntimeParams = {\n };\n \n type ChunkRegistration = [\n-  chunkPath: ChunkPath,\n+  chunkPath: ChunkScript,\n   chunkModules: ModuleFactories,\n   params: RuntimeParams | undefined\n ];\n \n type ChunkList = {\n-  path: ChunkListPath;\n+  script: ChunkListScript;\n   chunks: ChunkData[];\n   source: \"entry\" | \"dynamic\";\n };\n@@ -245,7 +253,9 @@ function resolveAbsolutePath(modulePath?: string): string {\n }\n \n function getWorkerBlobURL(chunks: ChunkPath[]): string {\n-  let bootstrap = `self.TURBOPACK_WORKER_LOCATION = ${JSON.stringify(location.origin)};importScripts(${chunks.map(c => (`self.TURBOPACK_WORKER_LOCATION + ${JSON.stringify(getChunkRelativeUrl(c))}`)).join(\", \")});`;\n+  let bootstrap = `self.TURBOPACK_WORKER_LOCATION = ${JSON.stringify(location.origin)};\n+self.TURBOPACK_NEXT_CHUNK_URLS = ${JSON.stringify(chunks.reverse().map(getChunkRelativeUrl), null, 2)};\n+importScripts(...self.TURBOPACK_NEXT_CHUNK_URLS.map(c => self.TURBOPACK_WORKER_LOCATION + c).reverse());`;\n   let blob = new Blob([bootstrap], { type: \"text/javascript\" });\n   return URL.createObjectURL(blob);\n }\n@@ -304,6 +314,23 @@ function getChunkRelativeUrl(chunkPath: ChunkPath | ChunkListPath): ChunkUrl {\n     .join(\"/\")}${CHUNK_SUFFIX_PATH}` as ChunkUrl;\n }\n \n+/**\n+ * Return the ChunkPath from a ChunkScript.\n+ */\n+function getPathFromScript(chunkScript: ChunkPath | ChunkScript): ChunkPath;\n+function getPathFromScript(chunkScript: ChunkListPath | ChunkListScript): ChunkListPath;\n+function getPathFromScript(chunkScript: ChunkPath | ChunkListPath | ChunkScript | ChunkListScript): ChunkPath | ChunkListPath {\n+  if (typeof chunkScript === \"string\") {\n+    return chunkScript as ChunkPath | ChunkListPath;\n+  }\n+  const chunkUrl = typeof TURBOPACK_NEXT_CHUNK_URLS !== \"undefined\"\n+    ? TURBOPACK_NEXT_CHUNK_URLS.pop()!\n+    : chunkScript.getAttribute(\"src\")!;\n+  const src = decodeURIComponent(chunkUrl.replace(/[?#].*$/, \"\"));\n+  const path = src.startsWith(CHUNK_BASE_PATH) ? src.slice(CHUNK_BASE_PATH.length) : src;\n+  return path as ChunkPath | ChunkListPath;\n+}\n+\n /**\n  * Marks a chunk list as a runtime chunk list. There can be more than one\n  * runtime chunk list. For instance, integration tests can have multiple chunk\n@@ -314,10 +341,11 @@ function markChunkListAsRuntime(chunkListPath: ChunkListPath) {\n }\n \n function registerChunk([\n-  chunkPath,\n+  chunkScript,\n   chunkModules,\n   runtimeParams,\n ]: ChunkRegistration) {\n+  const chunkPath = getPathFromScript(chunkScript);\n   for (const [moduleId, moduleFactory] of Object.entries(chunkModules)) {\n     if (!moduleFactories[moduleId]) {\n       moduleFactories[moduleId] = moduleFactory;"
        },
        {
            "sha": "5562602c44041bcd1fe67731fabcb0764ab70587",
            "filename": "turbopack/crates/turbopack-ecmascript-runtime/js/src/browser/runtime/dom/runtime-backend-dom.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/b84a02be184d409e32467be19e63a80a002dc089/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fdom%2Fruntime-backend-dom.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/b84a02be184d409e32467be19e63a80a002dc089/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fdom%2Fruntime-backend-dom.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fdom%2Fruntime-backend-dom.ts?ref=b84a02be184d409e32467be19e63a80a002dc089",
            "patch": "@@ -151,6 +151,7 @@ const chunkResolvers: Map<ChunkUrl, ChunkResolver> = new Map();\n       if (isCss(chunkUrl)) {\n         // ignore\n       } else if (isJs(chunkUrl)) {\n+        self.TURBOPACK_NEXT_CHUNK_URLS!.push(chunkUrl);\n         importScripts(TURBOPACK_WORKER_LOCATION + chunkUrl);\n       } else {\n         throw new Error(`can't infer type of chunk from URL ${chunkUrl} in worker`);"
        },
        {
            "sha": "d928611bd332316cf88cc98a89a77b6501537dd4",
            "filename": "turbopack/crates/turbopack-ecmascript-runtime/js/src/shared/runtime-types.d.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/b84a02be184d409e32467be19e63a80a002dc089/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fshared%2Fruntime-types.d.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/b84a02be184d409e32467be19e63a80a002dc089/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fshared%2Fruntime-types.d.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fshared%2Fruntime-types.d.ts?ref=b84a02be184d409e32467be19e63a80a002dc089",
            "patch": "@@ -7,8 +7,11 @@\n  * specific to the runtime context.\n  */\n \n+type CurrentScript = { getAttribute: (name: string) => string | null };\n type ChunkListPath = string & { readonly brand: unique symbol };\n+type ChunkListScript = CurrentScript & { readonly brand: unique symbol };\n type ChunkPath = string & { readonly brand: unique symbol };\n+type ChunkScript = CurrentScript & { readonly brand: unique symbol };\n type ChunkUrl = string & { readonly brand: unique symbol };\n type ModuleId = string;\n "
        },
        {
            "sha": "0eca0f2a2eefc3baee13bceaf19c1a895916a5e1",
            "filename": "turbopack/crates/turbopack-ecmascript-runtime/src/browser_runtime.rs",
            "status": "modified",
            "additions": 16,
            "deletions": 1,
            "changes": 17,
            "blob_url": "https://github.com/vercel/next.js/blob/b84a02be184d409e32467be19e63a80a002dc089/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fsrc%2Fbrowser_runtime.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b84a02be184d409e32467be19e63a80a002dc089/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fsrc%2Fbrowser_runtime.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fsrc%2Fbrowser_runtime.rs?ref=b84a02be184d409e32467be19e63a80a002dc089",
            "patch": "@@ -149,14 +149,29 @@ pub async fn get_browser_runtime_code(\n         );\n     }\n \n-    // Registering chunks depends on the BACKEND variable, which is set by the\n+    // Registering chunks and chunk lists depends on the BACKEND variable, which is set by the\n     // specific runtime code, hence it must be appended after it.\n     writedoc!(\n         code,\n         r#\"\n             const chunksToRegister = globalThis.TURBOPACK;\n             globalThis.TURBOPACK = {{ push: registerChunk }};\n             chunksToRegister.forEach(registerChunk);\n+        \"#\n+    )?;\n+    if matches!(*runtime_type, RuntimeType::Development) {\n+        writedoc!(\n+            code,\n+            r#\"\n+            const chunkListsToRegister = globalThis.TURBOPACK_CHUNK_LISTS || [];\n+            chunkListsToRegister.forEach(registerChunkList);\n+            globalThis.TURBOPACK_CHUNK_LISTS = {{ push: registerChunkList }};\n+        \"#\n+        )?;\n+    }\n+    writedoc!(\n+        code,\n+        r#\"\n             }})();\n         \"#\n     )?;"
        },
        {
            "sha": "a6de8f16e7465b63220ff57b296e5812e013fc3a",
            "filename": "turbopack/crates/turbopack-ecmascript/src/minify.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 3,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/b84a02be184d409e32467be19e63a80a002dc089/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fminify.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b84a02be184d409e32467be19e63a80a002dc089/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fminify.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fminify.rs?ref=b84a02be184d409e32467be19e63a80a002dc089",
            "patch": "@@ -23,21 +23,20 @@ use swc_core::{\n     },\n };\n use tracing::{instrument, Level};\n-use turbo_tasks_fs::FileSystemPath;\n use turbopack_core::code_builder::{Code, CodeBuilder};\n \n use crate::parse::generate_js_source_map;\n \n #[instrument(level = Level::INFO, skip_all)]\n-pub fn minify(path: &FileSystemPath, code: &Code, source_maps: bool, mangle: bool) -> Result<Code> {\n+pub fn minify(code: &Code, source_maps: bool, mangle: bool) -> Result<Code> {\n     let source_maps = source_maps\n         .then(|| code.generate_source_map_ref())\n         .transpose()?;\n \n     let cm = Arc::new(SwcSourceMap::new(FilePathMapping::empty()));\n     let (src, mut src_map_buf) = {\n         let fm = cm.new_source_file(\n-            FileName::Custom(path.path.to_string()).into(),\n+            FileName::Anon.into(),\n             code.source_code().to_str()?.into_owned(),\n         );\n "
        },
        {
            "sha": "3736dfbc8c37bb3c951422ad4df08b85fa247bea",
            "filename": "turbopack/crates/turbopack-nodejs/src/ecmascript/node/content.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/b84a02be184d409e32467be19e63a80a002dc089/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fcontent.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b84a02be184d409e32467be19e63a80a002dc089/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fcontent.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fcontent.rs?ref=b84a02be184d409e32467be19e63a80a002dc089",
            "patch": "@@ -52,7 +52,6 @@ impl EcmascriptBuildNodeChunkContent {\n             .chunking_context\n             .reference_chunk_source_maps(*ResolvedVc::upcast(this.chunk))\n             .await?;\n-        let chunk_path_vc = this.chunk.path();\n \n         let mut code = CodeBuilder::default();\n \n@@ -79,7 +78,7 @@ impl EcmascriptBuildNodeChunkContent {\n         let mut code = code.build();\n \n         if let MinifyType::Minify { mangle } = this.chunking_context.await?.minify_type() {\n-            code = minify(&*chunk_path_vc.await?, &code, source_maps, mangle)?;\n+            code = minify(&code, source_maps, mangle)?;\n         }\n \n         Ok(code.cell())"
        },
        {
            "sha": "d19681c7da3dfd20c644d328d4a7f9b8175007a3",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/runtime/default_dev_runtime/output/b1abf_turbopack-tests_tests_snapshot_runtime_default_dev_runtime_input_index_75df6705.js",
            "status": "modified",
            "additions": 25,
            "deletions": 16,
            "changes": 41,
            "blob_url": "https://github.com/vercel/next.js/blob/b84a02be184d409e32467be19e63a80a002dc089/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_dev_runtime%2Foutput%2Fb1abf_turbopack-tests_tests_snapshot_runtime_default_dev_runtime_input_index_75df6705.js",
            "raw_url": "https://github.com/vercel/next.js/raw/b84a02be184d409e32467be19e63a80a002dc089/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_dev_runtime%2Foutput%2Fb1abf_turbopack-tests_tests_snapshot_runtime_default_dev_runtime_input_index_75df6705.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_dev_runtime%2Foutput%2Fb1abf_turbopack-tests_tests_snapshot_runtime_default_dev_runtime_input_index_75df6705.js?ref=b84a02be184d409e32467be19e63a80a002dc089",
            "patch": "@@ -354,6 +354,7 @@ relativeURL.prototype = URL.prototype;\n  * shared runtime utils.\n  */ /* eslint-disable @typescript-eslint/no-unused-vars */ /// <reference path=\"../base/globals.d.ts\" />\n /// <reference path=\"../../../shared/runtime-utils.ts\" />\n+// Used in WebWorkers to tell the runtime about the chunk base path\n var SourceType = /*#__PURE__*/ function(SourceType) {\n     /**\n    * The module was instantiated because it was included in an evaluated chunk's\n@@ -493,7 +494,9 @@ async function loadChunkPath(source, chunkPath) {\n     return `/ROOT/${modulePath ?? \"\"}`;\n }\n function getWorkerBlobURL(chunks) {\n-    let bootstrap = `self.TURBOPACK_WORKER_LOCATION = ${JSON.stringify(location.origin)};importScripts(${chunks.map((c)=>`self.TURBOPACK_WORKER_LOCATION + ${JSON.stringify(getChunkRelativeUrl(c))}`).join(\", \")});`;\n+    let bootstrap = `self.TURBOPACK_WORKER_LOCATION = ${JSON.stringify(location.origin)};\n+self.TURBOPACK_NEXT_CHUNK_URLS = ${JSON.stringify(chunks.reverse().map(getChunkRelativeUrl), null, 2)};\n+importScripts(...self.TURBOPACK_NEXT_CHUNK_URLS.map(c => self.TURBOPACK_WORKER_LOCATION + c).reverse());`;\n     let blob = new Blob([\n         bootstrap\n     ], {\n@@ -547,14 +550,24 @@ function getWorkerBlobURL(chunks) {\n  */ function getChunkRelativeUrl(chunkPath) {\n     return `${CHUNK_BASE_PATH}${chunkPath.split(\"/\").map((p)=>encodeURIComponent(p)).join(\"/\")}${CHUNK_SUFFIX_PATH}`;\n }\n+function getPathFromScript(chunkScript) {\n+    if (typeof chunkScript === \"string\") {\n+        return chunkScript;\n+    }\n+    const chunkUrl = typeof TURBOPACK_NEXT_CHUNK_URLS !== \"undefined\" ? TURBOPACK_NEXT_CHUNK_URLS.pop() : chunkScript.getAttribute(\"src\");\n+    const src = decodeURIComponent(chunkUrl.replace(/[?#].*$/, \"\"));\n+    const path = src.startsWith(CHUNK_BASE_PATH) ? src.slice(CHUNK_BASE_PATH.length) : src;\n+    return path;\n+}\n /**\n  * Marks a chunk list as a runtime chunk list. There can be more than one\n  * runtime chunk list. For instance, integration tests can have multiple chunk\n  * groups loaded at runtime, each with its own chunk list.\n  */ function markChunkListAsRuntime(chunkListPath) {\n     runtimeChunkLists.add(chunkListPath);\n }\n-function registerChunk([chunkPath, chunkModules, runtimeParams]) {\n+function registerChunk([chunkScript, chunkModules, runtimeParams]) {\n+    const chunkPath = getPathFromScript(chunkScript);\n     for (const [moduleId, moduleFactory] of Object.entries(chunkModules)){\n         if (!moduleFactories[moduleId]) {\n             moduleFactories[moduleId] = moduleFactory;\n@@ -1375,9 +1388,12 @@ function createModuleHot(moduleId, hotData) {\n }\n /**\n  * Subscribes to chunk list updates from the update server and applies them.\n- */ function registerChunkList(chunkUpdateProvider, chunkList) {\n-    const chunkListPath = chunkList.path;\n-    chunkUpdateProvider.push([\n+ */ function registerChunkList(chunkList) {\n+    const chunkListScript = chunkList.script;\n+    const chunkListPath = getPathFromScript(chunkListScript);\n+    // The \"chunk\" is also registered to finish the loading in the backend\n+    BACKEND.registerChunk(chunkListPath);\n+    globalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS.push([\n         chunkListPath,\n         handleApply.bind(null, chunkListPath)\n     ]);\n@@ -1400,17 +1416,6 @@ function createModuleHot(moduleId, hotData) {\n     }\n }\n globalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS ??= [];\n-const chunkListsToRegister = globalThis.TURBOPACK_CHUNK_LISTS;\n-if (Array.isArray(chunkListsToRegister)) {\n-    for (const chunkList of chunkListsToRegister){\n-        registerChunkList(globalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS, chunkList);\n-    }\n-}\n-globalThis.TURBOPACK_CHUNK_LISTS = {\n-    push: (chunkList)=>{\n-        registerChunkList(globalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS, chunkList);\n-    }\n-};\n /**\n  * This file contains the runtime code specific to the Turbopack development\n  * ECMAScript DOM runtime.\n@@ -1518,6 +1523,7 @@ async function loadWebAssemblyModule(_source, wasmChunkPath) {\n             if (isCss(chunkUrl)) {\n             // ignore\n             } else if (isJs(chunkUrl)) {\n+                self.TURBOPACK_NEXT_CHUNK_URLS.push(chunkUrl);\n                 importScripts(TURBOPACK_WORKER_LOCATION + chunkUrl);\n             } else {\n                 throw new Error(`can't infer type of chunk from URL ${chunkUrl} in worker`);\n@@ -1669,6 +1675,9 @@ function _eval({ code, url, map }) {\n const chunksToRegister = globalThis.TURBOPACK;\n globalThis.TURBOPACK = { push: registerChunk };\n chunksToRegister.forEach(registerChunk);\n+const chunkListsToRegister = globalThis.TURBOPACK_CHUNK_LISTS || [];\n+chunkListsToRegister.forEach(registerChunkList);\n+globalThis.TURBOPACK_CHUNK_LISTS = { push: registerChunkList };\n })();\n \n "
        },
        {
            "sha": "de90b86ce35408643787e43a843004be86785a68",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/runtime/default_dev_runtime/output/b1abf_turbopack-tests_tests_snapshot_runtime_default_dev_runtime_input_index_75df6705.js.map",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/b84a02be184d409e32467be19e63a80a002dc089/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_dev_runtime%2Foutput%2Fb1abf_turbopack-tests_tests_snapshot_runtime_default_dev_runtime_input_index_75df6705.js.map",
            "raw_url": "https://github.com/vercel/next.js/raw/b84a02be184d409e32467be19e63a80a002dc089/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_dev_runtime%2Foutput%2Fb1abf_turbopack-tests_tests_snapshot_runtime_default_dev_runtime_input_index_75df6705.js.map",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_dev_runtime%2Foutput%2Fb1abf_turbopack-tests_tests_snapshot_runtime_default_dev_runtime_input_index_75df6705.js.map?ref=b84a02be184d409e32467be19e63a80a002dc089"
        }
    ],
    "stats": {
        "total": 356,
        "additions": 234,
        "deletions": 122
    }
}