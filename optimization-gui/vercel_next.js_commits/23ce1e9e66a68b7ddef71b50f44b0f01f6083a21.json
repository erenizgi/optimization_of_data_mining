{
    "author": "timneutkens",
    "message": "Turbopack Build: Refactor browserslist CSS test to not use .next folder (#80571)\n\n## What?\n\nRefactors the test to use a running instance and the browser accessible files that are part of the route, instead of trying to read from `.next`.",
    "sha": "23ce1e9e66a68b7ddef71b50f44b0f01f6083a21",
    "files": [
        {
            "sha": "9176cad5489f81c85682e3fd96805ee53d560477",
            "filename": "test/integration/css-features/test/browserslist.test.js",
            "status": "modified",
            "additions": 60,
            "deletions": 34,
            "changes": 94,
            "blob_url": "https://github.com/vercel/next.js/blob/23ce1e9e66a68b7ddef71b50f44b0f01f6083a21/test%2Fintegration%2Fcss-features%2Ftest%2Fbrowserslist.test.js",
            "raw_url": "https://github.com/vercel/next.js/raw/23ce1e9e66a68b7ddef71b50f44b0f01f6083a21/test%2Fintegration%2Fcss-features%2Ftest%2Fbrowserslist.test.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fintegration%2Fcss-features%2Ftest%2Fbrowserslist.test.js?ref=23ce1e9e66a68b7ddef71b50f44b0f01f6083a21",
            "patch": "@@ -1,8 +1,16 @@\n /* eslint-env jest */\n \n-import { readdir, readFile, remove } from 'fs-extra'\n-import { nextBuild } from 'next-test-utils'\n+import { remove } from 'fs-extra'\n+import {\n+  nextBuild,\n+  fetchViaHTTP,\n+  renderViaHTTP,\n+  findPort,\n+  nextStart,\n+  killApp,\n+} from 'next-test-utils'\n import { join } from 'path'\n+import cheerio from 'cheerio'\n \n const fixturesDir = join(__dirname, '../fixtures')\n \n@@ -12,32 +20,41 @@ describe('Browserslist: Old', () => {\n     () => {\n       const appDir = join(fixturesDir, 'browsers-old')\n \n-      let stdout\n-      let code\n+      let appPort\n+      let app\n       beforeAll(async () => {\n         await remove(join(appDir, '.next'))\n-        ;({ code, stdout } = await nextBuild(appDir, [], {\n+        const { code } = await nextBuild(appDir, [], {\n           stdout: true,\n-        }))\n+        })\n+        if (code !== 0) {\n+          throw new Error('Build failed')\n+        }\n+        appPort = await findPort()\n+        app = await nextStart(appDir, appPort)\n       })\n-\n-      it('should have compiled successfully', () => {\n-        expect(code).toBe(0)\n-        expect(stdout).toMatch(/Compiled successfully/)\n+      afterAll(async () => {\n+        await killApp(app)\n       })\n \n       it(`should've emitted a single CSS file`, async () => {\n-        const cssFolder = join(appDir, '.next/static/css')\n+        const content = await renderViaHTTP(appPort, '/')\n+        const $ = cheerio.load(content)\n+\n+        const cssSheet = $('link[rel=\"stylesheet\"]')\n+        expect(cssSheet.length).toBe(1)\n \n-        const files = await readdir(cssFolder)\n-        const cssFiles = files.filter((f) => /\\.css$/.test(f))\n+        const stylesheetUrl = cssSheet.attr('href')\n+\n+        const cssContent = await fetchViaHTTP(appPort, stylesheetUrl).then(\n+          (res) => res.text()\n+        )\n \n-        expect(cssFiles.length).toBe(1)\n-        const cssContent = await readFile(join(cssFolder, cssFiles[0]), 'utf8')\n+        const cssContentWithoutSourceMap = cssContent\n+          .replace(/\\/\\*.*?\\*\\/\\n?/g, '')\n+          .trim()\n \n-        expect(\n-          cssContent.replace(/\\/\\*.*?\\*\\//g, '').trim()\n-        ).toMatchInlineSnapshot(\n+        expect(cssContentWithoutSourceMap).toMatchInlineSnapshot(\n           `\"a{-webkit-animation:none 0s ease 0s 1 normal none running;animation:none 0s ease 0s 1 normal none running;-webkit-backface-visibility:visible;backface-visibility:visible;background:transparent none repeat 0 0/auto auto padding-box border-box scroll;border:none;border-collapse:separate;-webkit-border-image:none;border-image:none;-webkit-border-radius:0;border-radius:0;border-spacing:0;bottom:auto;-webkit-box-shadow:none;box-shadow:none;-webkit-box-sizing:content-box;box-sizing:content-box;caption-side:top;clear:none;clip:auto;color:#000;-webkit-columns:auto;-webkit-column-count:auto;-webkit-column-fill:balance;column-fill:balance;-webkit-column-gap:normal;column-gap:normal;-webkit-column-rule:medium none currentColor;column-rule:medium none currentColor;-webkit-column-span:1;column-span:1;-webkit-column-width:auto;columns:auto;content:normal;counter-increment:none;counter-reset:none;cursor:auto;direction:ltr;display:inline;empty-cells:show;float:none;font-family:serif;font-size:medium;font-style:normal;font-variant:normal;font-weight:400;font-stretch:normal;line-height:normal;height:auto;-ms-hyphens:none;hyphens:none;left:auto;letter-spacing:normal;list-style:disc none outside;margin:0;max-height:none;max-width:none;min-height:0;min-width:0;opacity:1;orphans:2;outline:medium none invert;overflow:visible;overflow-x:visible;overflow-y:visible;padding:0;page-break-after:auto;page-break-before:auto;page-break-inside:auto;-webkit-perspective:none;perspective:none;-webkit-perspective-origin:50% 50%;perspective-origin:50% 50%;position:static;right:auto;tab-size:8;table-layout:auto;text-align:left;text-align-last:auto;text-decoration:none;text-indent:0;text-shadow:none;text-transform:none;top:auto;-webkit-transform:none;transform:none;-webkit-transform-origin:50% 50% 0;transform-origin:50% 50% 0;-webkit-transform-style:flat;transform-style:flat;-webkit-transition:none 0s ease 0s;transition:none 0s ease 0s;unicode-bidi:normal;vertical-align:baseline;visibility:visible;white-space:normal;widows:2;width:auto;word-spacing:normal;z-index:auto;all:initial}@media (-webkit-min-device-pixel-ratio:2),(min-resolution:2dppx){.image{background-image:url(data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==)}}\"`\n         )\n       })\n@@ -51,32 +68,41 @@ describe('Browserslist: New', () => {\n     () => {\n       const appDir = join(fixturesDir, 'browsers-new')\n \n-      let stdout\n-      let code\n+      let appPort\n+      let app\n       beforeAll(async () => {\n         await remove(join(appDir, '.next'))\n-        ;({ code, stdout } = await nextBuild(appDir, [], {\n+        const { code } = await nextBuild(appDir, [], {\n           stdout: true,\n-        }))\n+        })\n+        if (code !== 0) {\n+          throw new Error('Build failed')\n+        }\n+        appPort = await findPort()\n+        app = await nextStart(appDir, appPort)\n       })\n-\n-      it('should have compiled successfully', () => {\n-        expect(code).toBe(0)\n-        expect(stdout).toMatch(/Compiled successfully/)\n+      afterAll(async () => {\n+        await killApp(app)\n       })\n \n       it(`should've emitted a single CSS file`, async () => {\n-        const cssFolder = join(appDir, '.next/static/css')\n+        const content = await renderViaHTTP(appPort, '/')\n+        const $ = cheerio.load(content)\n+\n+        const cssSheet = $('link[rel=\"stylesheet\"]')\n+        expect(cssSheet.length).toBe(1)\n \n-        const files = await readdir(cssFolder)\n-        const cssFiles = files.filter((f) => /\\.css$/.test(f))\n+        const stylesheetUrl = cssSheet.attr('href')\n+\n+        const cssContent = await fetchViaHTTP(appPort, stylesheetUrl).then(\n+          (res) => res.text()\n+        )\n \n-        expect(cssFiles.length).toBe(1)\n-        const cssContent = await readFile(join(cssFolder, cssFiles[0]), 'utf8')\n+        const cssContentWithoutSourceMap = cssContent\n+          .replace(/\\/\\*.*?\\*\\/\\n?/g, '')\n+          .trim()\n \n-        expect(\n-          cssContent.replace(/\\/\\*.*?\\*\\//g, '').trim()\n-        ).toMatchInlineSnapshot(\n+        expect(cssContentWithoutSourceMap).toMatchInlineSnapshot(\n           `\"a{all:initial}@media (min-resolution:2dppx){.image{background-image:url(data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==)}}\"`\n         )\n       })"
        }
    ],
    "stats": {
        "total": 94,
        "additions": 60,
        "deletions": 34
    }
}