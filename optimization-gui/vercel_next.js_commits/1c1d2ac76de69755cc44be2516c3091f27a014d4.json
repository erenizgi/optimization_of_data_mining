{
    "author": "sokra",
    "message": "Turbopack: Use separate meta and data modified flags (#78724)\n\n### What?\n\nWe store \"meta\" and \"data\" separately, so we also need separate modified flags for them. This way we avoid e. g. storing unmodified \"data\" when only \"meta\" was actually modified.",
    "sha": "1c1d2ac76de69755cc44be2516c3091f27a014d4",
    "files": [
        {
            "sha": "4611fc407e0da2c561926ab217a84319795e6c32",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 10,
            "deletions": 6,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/1c1d2ac76de69755cc44be2516c3091f27a014d4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1c1d2ac76de69755cc44be2516c3091f27a014d4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=1c1d2ac76de69755cc44be2516c3091f27a014d4",
            "patch": "@@ -869,25 +869,29 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                 return (task_id, None, None);\n             }\n             let len = inner.len();\n-            let mut meta = Vec::with_capacity(len);\n-            let mut data = Vec::with_capacity(len);\n+            let mut meta = inner.meta_modified.then(|| Vec::with_capacity(len));\n+            let mut data = inner.data_modified.then(|| Vec::with_capacity(len));\n             for (key, value) in inner.iter_all() {\n                 if key.is_persistent() && value.is_persistent() {\n                     match key.category() {\n                         TaskDataCategory::Meta => {\n-                            meta.push(CachedDataItem::from_key_and_value_ref(key, value))\n+                            if let Some(meta) = &mut meta {\n+                                meta.push(CachedDataItem::from_key_and_value_ref(key, value));\n+                            }\n                         }\n                         TaskDataCategory::Data => {\n-                            data.push(CachedDataItem::from_key_and_value_ref(key, value))\n+                            if let Some(data) = &mut data {\n+                                data.push(CachedDataItem::from_key_and_value_ref(key, value));\n+                            }\n                         }\n                         _ => {}\n                     }\n                 }\n             }\n             (\n                 task_id,\n-                inner.meta_restored.then(|| B::serialize(task_id, &meta)),\n-                inner.data_restored.then(|| B::serialize(task_id, &data)),\n+                meta.map(|meta| B::serialize(task_id, &meta)),\n+                data.map(|data| B::serialize(task_id, &data)),\n             )\n         };\n "
        },
        {
            "sha": "e1a43103929accd24c13bde62e7764624ce970ed",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/mod.rs",
            "status": "modified",
            "additions": 25,
            "deletions": 16,
            "changes": 41,
            "blob_url": "https://github.com/vercel/next.js/blob/1c1d2ac76de69755cc44be2516c3091f27a014d4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1c1d2ac76de69755cc44be2516c3091f27a014d4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs?ref=1c1d2ac76de69755cc44be2516c3091f27a014d4",
            "patch": "@@ -18,8 +18,8 @@ use turbo_tasks::{SessionId, TaskId, TurboTasksBackendApi};\n \n use crate::{\n     backend::{\n-        storage::StorageWriteGuard, OperationGuard, TaskDataCategory, TransientTask,\n-        TurboTasksBackend, TurboTasksBackendInner,\n+        storage::{SpecificTaskDataCategory, StorageWriteGuard},\n+        OperationGuard, TaskDataCategory, TransientTask, TurboTasksBackend, TurboTasksBackendInner,\n     },\n     backing_storage::BackingStorage,\n     data::{\n@@ -463,9 +463,10 @@ impl<B: BackingStorage> TaskGuard for TaskGuardImpl<'_, B> {\n     }\n \n     fn add(&mut self, item: CachedDataItem) -> bool {\n-        self.check_access(item.category());\n+        let category = item.category();\n+        self.check_access(category);\n         if !self.task_id.is_transient() && item.is_persistent() {\n-            self.task.track_modification();\n+            self.task.track_modification(category.into_specific());\n         }\n         self.task.add(item)\n     }\n@@ -477,9 +478,10 @@ impl<B: BackingStorage> TaskGuard for TaskGuardImpl<'_, B> {\n     }\n \n     fn insert(&mut self, item: CachedDataItem) -> Option<CachedDataItemValue> {\n-        self.check_access(item.category());\n+        let category = item.category();\n+        self.check_access(category);\n         if !self.task_id.is_transient() && item.is_persistent() {\n-            self.task.track_modification();\n+            self.task.track_modification(category.into_specific());\n         }\n         self.task.insert(item)\n     }\n@@ -489,17 +491,19 @@ impl<B: BackingStorage> TaskGuard for TaskGuardImpl<'_, B> {\n         key: CachedDataItemKey,\n         update: impl FnOnce(Option<CachedDataItemValue>) -> Option<CachedDataItemValue>,\n     ) {\n-        self.check_access(key.category());\n+        let category = key.category();\n+        self.check_access(category);\n         if !self.task_id.is_transient() && key.is_persistent() {\n-            self.task.track_modification();\n+            self.task.track_modification(category.into_specific());\n         }\n         self.task.update(key, update);\n     }\n \n     fn remove(&mut self, key: &CachedDataItemKey) -> Option<CachedDataItemValue> {\n-        self.check_access(key.category());\n+        let category = key.category();\n+        self.check_access(category);\n         if !self.task_id.is_transient() && key.is_persistent() {\n-            self.task.track_modification();\n+            self.task.track_modification(category.into_specific());\n         }\n         self.task.remove(key)\n     }\n@@ -510,9 +514,10 @@ impl<B: BackingStorage> TaskGuard for TaskGuardImpl<'_, B> {\n     }\n \n     fn get_mut(&mut self, key: &CachedDataItemKey) -> Option<CachedDataItemValueRefMut<'_>> {\n-        self.check_access(key.category());\n+        let category = key.category();\n+        self.check_access(category);\n         if !self.task_id.is_transient() && key.is_persistent() {\n-            self.task.track_modification();\n+            self.task.track_modification(category.into_specific());\n         }\n         self.task.get_mut(key)\n     }\n@@ -522,9 +527,10 @@ impl<B: BackingStorage> TaskGuard for TaskGuardImpl<'_, B> {\n         key: CachedDataItemKey,\n         insert: impl FnOnce() -> CachedDataItemValue,\n     ) -> CachedDataItemValueRefMut<'_> {\n-        self.check_access(key.category());\n+        let category = key.category();\n+        self.check_access(category);\n         if !self.task_id.is_transient() && key.is_persistent() {\n-            self.task.track_modification();\n+            self.task.track_modification(category.into_specific());\n         }\n         self.task.get_mut_or_insert_with(key, insert)\n     }\n@@ -561,14 +567,17 @@ impl<B: BackingStorage> TaskGuard for TaskGuardImpl<'_, B> {\n     {\n         self.check_access(ty.category());\n         if !self.task_id.is_transient() && ty.is_persistent() {\n-            self.task.track_modification();\n+            self.task.track_modification(ty.category().into_specific());\n         }\n         self.task.extract_if(ty, f)\n     }\n \n     fn invalidate_serialization(&mut self) {\n+        // TODO this causes race conditions, since we never know when a value is changed. We can't\n+        // \"snapshot\" the value correctly.\n         if !self.task_id.is_transient() {\n-            self.task.track_modification();\n+            self.task.track_modification(SpecificTaskDataCategory::Data);\n+            self.task.track_modification(SpecificTaskDataCategory::Meta);\n         }\n     }\n }"
        },
        {
            "sha": "2b27335055d22f80a701eddfe34eb850723988fe",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/storage.rs",
            "status": "modified",
            "additions": 89,
            "deletions": 26,
            "changes": 115,
            "blob_url": "https://github.com/vercel/next.js/blob/1c1d2ac76de69755cc44be2516c3091f27a014d4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fstorage.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1c1d2ac76de69755cc44be2516c3091f27a014d4/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fstorage.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fstorage.rs?ref=1c1d2ac76de69755cc44be2516c3091f27a014d4",
            "patch": "@@ -26,6 +26,22 @@ pub enum TaskDataCategory {\n     All,\n }\n \n+impl TaskDataCategory {\n+    pub fn into_specific(self) -> SpecificTaskDataCategory {\n+        match self {\n+            TaskDataCategory::Meta => SpecificTaskDataCategory::Meta,\n+            TaskDataCategory::Data => SpecificTaskDataCategory::Data,\n+            TaskDataCategory::All => unreachable!(),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub enum SpecificTaskDataCategory {\n+    Meta,\n+    Data,\n+}\n+\n impl IntoIterator for TaskDataCategory {\n     type Item = TaskDataCategory;\n \n@@ -77,9 +93,11 @@ bitfield! {\n     pub meta_restored, set_meta_restored: 0;\n     pub data_restored, set_data_restored: 1;\n     /// Item was modified before snapshot mode was entered.\n-    pub modified, set_modified: 2;\n+    pub meta_modified, set_meta_modified: 2;\n+    pub data_modified, set_data_modified: 3;\n     /// Item was modified after snapshot mode was entered. A snapshot was taken.\n-    pub snapshot, set_snapshot: 3;\n+    pub meta_snapshot, set_meta_snapshot: 4;\n+    pub data_snapshot, set_data_snapshot: 4;\n }\n \n impl InnerStorageState {\n@@ -105,6 +123,14 @@ impl InnerStorageState {\n             TaskDataCategory::All => self.meta_restored() && self.data_restored(),\n         }\n     }\n+\n+    pub fn any_snapshot(&self) -> bool {\n+        self.meta_snapshot() || self.data_snapshot()\n+    }\n+\n+    pub fn any_modified(&self) -> bool {\n+        self.meta_modified() || self.data_modified()\n+    }\n }\n \n pub struct InnerStorageSnapshot {\n@@ -113,8 +139,8 @@ pub struct InnerStorageSnapshot {\n     output: OptionStorage<OutputValue>,\n     upper: AutoMapStorage<TaskId, i32>,\n     dynamic: DynamicStorage,\n-    pub meta_restored: bool,\n-    pub data_restored: bool,\n+    pub meta_modified: bool,\n+    pub data_modified: bool,\n }\n \n impl From<&InnerStorage> for InnerStorageSnapshot {\n@@ -125,8 +151,8 @@ impl From<&InnerStorage> for InnerStorageSnapshot {\n             output: inner.output.clone(),\n             upper: inner.upper.clone(),\n             dynamic: inner.dynamic.snapshot_for_persisting(),\n-            meta_restored: inner.state.meta_restored(),\n-            data_restored: inner.state.data_restored(),\n+            meta_modified: inner.state.meta_modified(),\n+            data_modified: inner.state.data_modified(),\n         }\n     }\n }\n@@ -701,7 +727,9 @@ impl Storage {\n         // We also need to unset all the modified flags.\n         for key in removed_modified {\n             if let Some(mut inner) = self.map.get_mut(&key) {\n-                inner.state_mut().set_modified(false);\n+                let state = inner.state_mut();\n+                state.set_data_modified(false);\n+                state.set_meta_modified(false);\n             }\n         }\n \n@@ -728,8 +756,15 @@ impl Storage {\n         // And update the flags\n         for key in removed_snapshots {\n             if let Some(mut inner) = self.map.get_mut(&key) {\n-                inner.state_mut().set_snapshot(false);\n-                inner.state_mut().set_modified(true);\n+                let state = inner.state_mut();\n+                if state.meta_snapshot() {\n+                    state.set_meta_snapshot(false);\n+                    state.set_meta_modified(true);\n+                }\n+                if state.data_snapshot() {\n+                    state.set_data_snapshot(false);\n+                    state.set_data_modified(true);\n+                }\n             }\n         }\n \n@@ -779,35 +814,62 @@ pub struct StorageWriteGuard<'a> {\n \n impl StorageWriteGuard<'_> {\n     /// Tracks mutation of this task\n-    pub fn track_modification(&mut self) {\n-        if !self.inner.state().snapshot() {\n-            match (self.storage.snapshot_mode(), self.inner.state().modified()) {\n+    pub fn track_modification(&mut self, category: SpecificTaskDataCategory) {\n+        let state = self.inner.state();\n+        let snapshot = match category {\n+            SpecificTaskDataCategory::Meta => state.meta_snapshot(),\n+            SpecificTaskDataCategory::Data => state.data_snapshot(),\n+        };\n+        if !snapshot {\n+            let modified = match category {\n+                SpecificTaskDataCategory::Meta => state.meta_modified(),\n+                SpecificTaskDataCategory::Data => state.data_modified(),\n+            };\n+            match (self.storage.snapshot_mode(), modified) {\n                 (false, false) => {\n                     // Not in snapshot mode and item is unmodified\n-                    self.storage\n-                        .modified\n-                        .insert(*self.inner.key(), ModifiedState::Modified);\n-                    self.inner.state_mut().set_modified(true);\n+                    if !state.any_snapshot() && !state.any_modified() {\n+                        self.storage\n+                            .modified\n+                            .insert(*self.inner.key(), ModifiedState::Modified);\n+                    }\n+                    let state = self.inner.state_mut();\n+                    match category {\n+                        SpecificTaskDataCategory::Meta => state.set_meta_modified(true),\n+                        SpecificTaskDataCategory::Data => state.set_data_modified(true),\n+                    }\n                 }\n                 (false, true) => {\n                     // Not in snapshot mode and item is already modfied\n                     // Do nothing\n                 }\n                 (true, false) => {\n                     // In snapshot mode and item is unmodified (so it's not part of the snapshot)\n-                    self.storage\n-                        .modified\n-                        .insert(*self.inner.key(), ModifiedState::Snapshot(None));\n-                    self.inner.state_mut().set_snapshot(true);\n+                    if !state.any_snapshot() {\n+                        self.storage\n+                            .modified\n+                            .insert(*self.inner.key(), ModifiedState::Snapshot(None));\n+                    }\n+                    let state = self.inner.state_mut();\n+                    match category {\n+                        SpecificTaskDataCategory::Meta => state.set_meta_snapshot(true),\n+                        SpecificTaskDataCategory::Data => state.set_data_snapshot(true),\n+                    }\n                 }\n                 (true, true) => {\n                     // In snapshot mode and item is modified (so it's part of the snapshot)\n                     // We need to store the original version that is part of the snapshot\n-                    self.storage.modified.insert(\n-                        *self.inner.key(),\n-                        ModifiedState::Snapshot(Some(Box::new((&**self.inner).into()))),\n-                    );\n-                    self.inner.state_mut().set_snapshot(true);\n+                    if !state.any_snapshot() {\n+                        self.storage.modified.insert(\n+                            *self.inner.key(),\n+                            ModifiedState::Snapshot(Some(Box::new((&**self.inner).into()))),\n+                        );\n+                    }\n+                    let state = self.inner.state_mut();\n+                    match category {\n+                        SpecificTaskDataCategory::Meta => state.set_meta_snapshot(true),\n+                        SpecificTaskDataCategory::Data => state.set_data_snapshot(true),\n+                    }\n                 }\n             }\n         }\n@@ -1055,7 +1117,8 @@ where\n         }\n         while let Some(task_id) = self.modified.pop() {\n             let inner = self.storage.map.get(&task_id).unwrap();\n-            if !inner.state().snapshot() {\n+            let state = inner.state();\n+            if !state.any_snapshot() {\n                 let preprocessed = (self.preprocess)(task_id, &inner);\n                 drop(inner);\n                 return Some((self.process)(task_id, preprocessed));"
        }
    ],
    "stats": {
        "total": 172,
        "additions": 124,
        "deletions": 48
    }
}