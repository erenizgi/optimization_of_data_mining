{
    "author": "sokra",
    "message": "Turbopack: allow to read State from turbo_tasks::run (#83955)\n\n### What?\n\nAutomatically switch reading from state to untracked mode when in `turbo_tasks::run` (similar to reading from cells).",
    "sha": "1ee2861c037ac433ad22ccbe22059ee839dac846",
    "files": [
        {
            "sha": "3db4bc1c5bcf4f60e2e926ae85a4a421e4cca447",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/read_ref_cell.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/1ee2861c037ac433ad22ccbe22059ee839dac846/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fread_ref_cell.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1ee2861c037ac433ad22ccbe22059ee839dac846/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fread_ref_cell.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fread_ref_cell.rs?ref=1ee2861c037ac433ad22ccbe22059ee839dac846",
            "patch": "@@ -73,7 +73,7 @@ impl Counter {\n     #[turbo_tasks::function]\n     fn get_value(&self) -> Result<Vc<CounterValue>> {\n         let mut lock = self.value.lock().unwrap();\n-        lock.1.insert(get_invalidator());\n+        lock.1.insert(get_invalidator().unwrap());\n         Ok(Vc::cell(lock.0))\n     }\n }"
        },
        {
            "sha": "4f166fb8ab822bf3a251d9acd599e88167900595",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/trait_ref_cell.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/1ee2861c037ac433ad22ccbe22059ee839dac846/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftrait_ref_cell.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1ee2861c037ac433ad22ccbe22059ee839dac846/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftrait_ref_cell.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftrait_ref_cell.rs?ref=1ee2861c037ac433ad22ccbe22059ee839dac846",
            "patch": "@@ -90,7 +90,7 @@ impl CounterTrait for Counter {\n     #[turbo_tasks::function]\n     fn get_value(&self) -> Result<Vc<CounterValue>> {\n         let mut lock = self.value.lock().unwrap();\n-        lock.1.insert(get_invalidator());\n+        lock.1.insert(get_invalidator().unwrap());\n         Ok(Vc::cell(lock.0))\n     }\n "
        },
        {
            "sha": "0972b089f4745317343a8ae9705911af13de507e",
            "filename": "turbopack/crates/turbo-tasks-fs/src/lib.rs",
            "status": "modified",
            "additions": 30,
            "deletions": 18,
            "changes": 48,
            "blob_url": "https://github.com/vercel/next.js/blob/1ee2861c037ac433ad22ccbe22059ee839dac846/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1ee2861c037ac433ad22ccbe22059ee839dac846/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs?ref=1ee2861c037ac433ad22ccbe22059ee839dac846",
            "patch": "@@ -257,10 +257,11 @@ impl DiskFileSystemInner {\n     /// registers the path as an invalidator for the current task,\n     /// has to be called within a turbo-tasks function\n     fn register_read_invalidator(&self, path: &Path) -> Result<()> {\n-        let invalidator = turbo_tasks::get_invalidator();\n-        self.invalidator_map\n-            .insert(path.to_owned(), invalidator, None);\n-        self.watcher.ensure_watched_file(path, self.root_path())?;\n+        if let Some(invalidator) = turbo_tasks::get_invalidator() {\n+            self.invalidator_map\n+                .insert(path.to_owned(), invalidator, None);\n+            self.watcher.ensure_watched_file(path, self.root_path())?;\n+        }\n         Ok(())\n     }\n \n@@ -293,10 +294,11 @@ impl DiskFileSystemInner {\n     /// registers the path as an invalidator for the current task,\n     /// has to be called within a turbo-tasks function\n     fn register_dir_invalidator(&self, path: &Path) -> Result<()> {\n-        let invalidator = turbo_tasks::get_invalidator();\n-        self.dir_invalidator_map\n-            .insert(path.to_owned(), invalidator, None);\n-        self.watcher.ensure_watched_dir(path, self.root_path())?;\n+        if let Some(invalidator) = turbo_tasks::get_invalidator() {\n+            self.dir_invalidator_map\n+                .insert(path.to_owned(), invalidator, None);\n+            self.watcher.ensure_watched_dir(path, self.root_path())?;\n+        }\n         Ok(())\n     }\n \n@@ -712,11 +714,16 @@ impl FileSystem for DiskFileSystem {\n             let _lock = inner.lock_path(&full_path).await;\n \n             // Track the file, so that we will rewrite it if it ever changes.\n-            let old_invalidators = inner.register_write_invalidator(\n-                &full_path,\n-                invalidator,\n-                WriteContent::File(content.clone()),\n-            )?;\n+            let old_invalidators = invalidator\n+                .map(|invalidator| {\n+                    inner.register_write_invalidator(\n+                        &full_path,\n+                        invalidator,\n+                        WriteContent::File(content.clone()),\n+                    )\n+                })\n+                .transpose()?\n+                .unwrap_or_default();\n \n             // We perform an untracked comparison here, so that this write is not dependent\n             // on a read's Vc<FileContent> (and the memory it holds). Our untracked read can\n@@ -846,11 +853,16 @@ impl FileSystem for DiskFileSystem {\n \n             let _lock = inner.lock_path(&full_path).await;\n \n-            let old_invalidators = inner.register_write_invalidator(\n-                &full_path,\n-                invalidator,\n-                WriteContent::Link(content.clone()),\n-            )?;\n+            let old_invalidators = invalidator\n+                .map(|invalidator| {\n+                    inner.register_write_invalidator(\n+                        &full_path,\n+                        invalidator,\n+                        WriteContent::Link(content.clone()),\n+                    )\n+                })\n+                .transpose()?\n+                .unwrap_or_default();\n \n             // TODO(sokra) preform a untracked read here, register an invalidator and get\n             // all existing invalidators"
        },
        {
            "sha": "9531b6b10af899d00c2bd1f0c6c19125b78ff7e4",
            "filename": "turbopack/crates/turbo-tasks/src/invalidation.rs",
            "status": "modified",
            "additions": 13,
            "deletions": 8,
            "changes": 21,
            "blob_url": "https://github.com/vercel/next.js/blob/1ee2861c037ac433ad22ccbe22059ee839dac846/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Finvalidation.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1ee2861c037ac433ad22ccbe22059ee839dac846/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Finvalidation.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Finvalidation.rs?ref=1ee2861c037ac433ad22ccbe22059ee839dac846",
            "patch": "@@ -15,21 +15,26 @@ use turbo_dyn_eq_hash::{\n \n use crate::{\n     FxIndexMap, FxIndexSet, TaskId, TurboTasksApi,\n-    manager::{current_task, mark_invalidator, with_turbo_tasks},\n+    manager::{current_task_if_available, mark_invalidator, with_turbo_tasks},\n     trace::TraceRawVcs,\n     util::StaticOrArc,\n };\n \n /// Get an [`Invalidator`] that can be used to invalidate the current task\n /// based on external events.\n-pub fn get_invalidator() -> Invalidator {\n-    mark_invalidator();\n+/// Returns `None` if called outside of a task context.\n+pub fn get_invalidator() -> Option<Invalidator> {\n+    if let Some(task) = current_task_if_available(\"turbo_tasks::get_invalidator()\") {\n+        mark_invalidator();\n \n-    let handle = Handle::current();\n-    Invalidator {\n-        task: current_task(\"turbo_tasks::get_invalidator()\"),\n-        turbo_tasks: with_turbo_tasks(Arc::downgrade),\n-        handle,\n+        let handle = Handle::current();\n+        Some(Invalidator {\n+            task,\n+            turbo_tasks: with_turbo_tasks(Arc::downgrade),\n+            handle,\n+        })\n+    } else {\n+        None\n     }\n }\n "
        },
        {
            "sha": "9a490d9319e797152a936a639127b564009432ee",
            "filename": "turbopack/crates/turbo-tasks/src/state.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 2,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/1ee2861c037ac433ad22ccbe22059ee839dac846/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fstate.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1ee2861c037ac433ad22ccbe22059ee839dac846/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fstate.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fstate.rs?ref=1ee2861c037ac433ad22ccbe22059ee839dac846",
            "patch": "@@ -170,7 +170,9 @@ impl<T> State<T> {\n     pub fn get(&self) -> StateRef<'_, T> {\n         let invalidator = get_invalidator();\n         let mut inner = self.inner.lock();\n-        inner.add_invalidator(invalidator);\n+        if let Some(invalidator) = invalidator {\n+            inner.add_invalidator(invalidator);\n+        }\n         StateRef {\n             serialization_invalidator: Some(&self.serialization_invalidator),\n             inner,\n@@ -295,7 +297,9 @@ impl<T> TransientState<T> {\n         mark_session_dependent();\n         let invalidator = get_invalidator();\n         let mut inner = self.inner.lock();\n-        inner.add_invalidator(invalidator);\n+        if let Some(invalidator) = invalidator {\n+            inner.add_invalidator(invalidator);\n+        }\n         StateRef {\n             serialization_invalidator: None,\n             inner,"
        }
    ],
    "stats": {
        "total": 81,
        "additions": 51,
        "deletions": 30
    }
}