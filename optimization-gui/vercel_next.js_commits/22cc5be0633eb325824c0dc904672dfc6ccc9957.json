{
    "author": "icyJoseph",
    "message": "docs: cacheLife feedback (#86128)\n\n- Adjust nested behavior\n- Include conditional calls to cacheLife\n\n---------\n\nCo-authored-by: Ismael <ismael@vercel.com>",
    "sha": "22cc5be0633eb325824c0dc904672dfc6ccc9957",
    "files": [
        {
            "sha": "b18d4bbc35de920e1f8d901005778c78388658b3",
            "filename": "docs/01-app/03-api-reference/04-functions/cacheLife.mdx",
            "status": "modified",
            "additions": 92,
            "deletions": 15,
            "changes": 107,
            "blob_url": "https://github.com/vercel/next.js/blob/22cc5be0633eb325824c0dc904672dfc6ccc9957/docs%2F01-app%2F03-api-reference%2F04-functions%2FcacheLife.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/22cc5be0633eb325824c0dc904672dfc6ccc9957/docs%2F01-app%2F03-api-reference%2F04-functions%2FcacheLife.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-api-reference%2F04-functions%2FcacheLife.mdx?ref=22cc5be0633eb325824c0dc904672dfc6ccc9957",
            "patch": "@@ -37,6 +37,13 @@ const nextConfig = {\n export default nextConfig\n ```\n \n+`cacheLife` requires the `use cache` directive, which must be placed at the file level or at the top of an async function or component.\n+\n+> **Good to know**:\n+>\n+> - If used, `cacheLife` should be placed within the function whose output is being cached, even when the `use cache` directive is at file level\n+> - Only one `cacheLife` call should execute per function invocation. You can call `cacheLife` in different control flow branches, but ensure only one executes per run. See the [conditional cache lifetimes](#conditional-cache-lifetimes) example\n+\n ### Using preset profiles\n \n Next.js provides preset cache profiles that cover common caching needs. Each profile balances three factors:\n@@ -68,9 +75,7 @@ export default async function BlogPage() {\n }\n ```\n \n-The profile name tells Next.js how to cache the entire function's output. If you need more control over timing values, see the [Reference](#reference) section below.\n-\n-> **Good to know**: The `use cache` directive can be placed at the file level or at the top of a function or component, and `cacheLife` must be called within its scope.\n+The profile name tells Next.js how to cache the entire function's output. If you don't call `cacheLife`, the `default` profile is used. See [preset cache profiles](#preset-cache-profiles) for timing details.\n \n ## Reference\n \n@@ -368,37 +373,109 @@ export async function getRealtimeStats() {\n \n ### Nested caching behavior\n \n-When components with different cache profiles are nested, Next.js respects the shortest duration among them:\n+When you nest `use cache` directives (a cached function or component using another cached function or component), the outer cache's behavior depends on whether it has an explicit `cacheLife`.\n+\n+#### With explicit outer cacheLife\n+\n+The outer cache uses its own lifetime, regardless of inner cache lifetimes. When the outer cache hits, it returns the complete output including all nested data. An explicit `cacheLife` always takes precedence, whether it's longer or shorter than inner lifetimes.\n \n ```tsx filename=\"app/dashboard/page.tsx\"\n import { cacheLife } from 'next/cache'\n-import { RealtimeWidget } from './realtime-widget'\n+import { Widget } from './widget'\n \n export default async function Dashboard() {\n   'use cache'\n-  cacheLife('hours') // Dashboard cached for hours\n+  cacheLife('hours') // Outer scope sets its own lifetime\n \n   return (\n     <div>\n       <h1>Dashboard</h1>\n-      <RealtimeWidget />\n+      <Widget /> {/* Inner scope has 'minutes' lifetime */}\n     </div>\n   )\n }\n ```\n \n-```tsx filename=\"app/dashboard/realtime-widget.tsx\"\n-import { cacheLife } from 'next/cache'\n+#### Without explicit outer cacheLife\n+\n+If you don't call `cacheLife` in the outer cache, it uses the `default` profile (15 min revalidate). Inner caches with shorter lifetimes can reduce the outer cache's `default` lifetime. Inner caches with longer lifetimes cannot extend it beyond the default.\n+\n+```tsx filename=\"app/dashboard/page.tsx\"\n+import { Widget } from './widget'\n+\n+export default async function Dashboard() {\n+  'use cache'\n+  // No cacheLife call - uses default (15 min)\n+  // If Widget has 5 min → Dashboard becomes 5 min\n+  // If Widget has 1 hour → Dashboard stays 15 min\n+\n+  return (\n+    <div>\n+      <h1>Dashboard</h1>\n+      <Widget />\n+    </div>\n+  )\n+}\n+```\n \n-export async function RealtimeWidget() {\n+**It is recommended to specify an explicit `cacheLife`.** With explicit lifetime values, you can inspect a cached function or component and immediately know its behavior without tracing through nested caches. Without explicit lifetime values, the behavior becomes dependent on inner cache lifetimes, making it harder to reason about.\n+\n+### Conditional cache lifetimes\n+\n+You can call `cacheLife` conditionally in different code paths to set different cache durations based on your application logic:\n+\n+```tsx filename=\"lib/posts.ts\" highlight={14,19}\n+import { cacheLife, cacheTag } from 'next/cache'\n+\n+async function getPostContent(slug: string) {\n   'use cache'\n-  cacheLife('seconds') // Widget needs fresh data\n \n-  const data = await fetchRealtimeData()\n-  return <div>{data.value}</div>\n+  const post = await fetchPost(slug)\n+\n+  // Tag the cache entry for targeted revalidation\n+  cacheTag(`post-${slug}`)\n+\n+  if (!post) {\n+    // Content may not be published yet or could be in draft\n+    // Cache briefly to reduce database load\n+    cacheLife('minutes')\n+    return null\n+  }\n+\n+  // Published content can be cached longer\n+  cacheLife('days')\n+\n+  // Return only the necessary data to keep cache size minimal\n+  return post.data\n }\n ```\n \n-In this example, the outer `Dashboard` component specifies the `hours` profile, but it contains `RealtimeWidget` which uses the `seconds` profile. The shortest duration from the nested profiles takes precedence, ensuring the widget gets fresh data while the rest of the dashboard can be cached longer.\n+This pattern is useful when different outcomes need different cache durations, for example, when an item is missing but is likely to be available later.\n+\n+#### Using dynamic cache lifetimes from data\n+\n+If you want to calculate cache lifetime at runtime, for example by reading it from the fetched data, use an [inline cache profile](#inline-cache-profiles) object:\n \n-> **Good to know**: This shortest-duration behavior ensures that no part of your page serves stale data longer than its most frequently updated component requires.\n+```tsx filename=\"lib/posts.ts\" highlight={15,16,17}\n+import { cacheLife, cacheTag } from 'next/cache'\n+\n+async function getPostContent(slug: string) {\n+  'use cache'\n+\n+  const post = await fetchPost(slug)\n+  cacheTag(`post-${slug}`)\n+\n+  if (!post) {\n+    cacheLife('minutes')\n+    return null\n+  }\n+\n+  // Use cache timing from CMS data directly as an object\n+  cacheLife({\n+    // Ensure post.revalidateSeconds is a number in seconds\n+    revalidate: post.revalidateSeconds ?? 3600,\n+  })\n+\n+  return post.data\n+}\n+```"
        }
    ],
    "stats": {
        "total": 107,
        "additions": 92,
        "deletions": 15
    }
}