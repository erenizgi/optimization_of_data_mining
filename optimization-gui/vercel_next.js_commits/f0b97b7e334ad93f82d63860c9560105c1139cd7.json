{
    "author": "lukesandberg",
    "message": "[Turbopack] clean up `completion.rs` a bit (#84863)\n\n* `all` is dead\n* `unchanged` is dead\n* `wrap` should be private",
    "sha": "f0b97b7e334ad93f82d63860c9560105c1139cd7",
    "files": [
        {
            "sha": "821630af22f8fbdf61b899eee5228e1d8409f112",
            "filename": "turbopack/crates/turbo-tasks/src/completion.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 26,
            "changes": 28,
            "blob_url": "https://github.com/vercel/next.js/blob/f0b97b7e334ad93f82d63860c9560105c1139cd7/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fcompletion.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f0b97b7e334ad93f82d63860c9560105c1139cd7/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fcompletion.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fcompletion.rs?ref=f0b97b7e334ad93f82d63860c9560105c1139cd7",
            "patch": "@@ -1,6 +1,6 @@\n use anyhow::Result;\n \n-use crate::{self as turbo_tasks, RawVc, ResolvedVc, TryJoinIterExt, Vc};\n+use crate::{self as turbo_tasks, ResolvedVc, TryJoinIterExt, Vc};\n \n /// Just an empty type, but it's never equal to itself.\n ///\n@@ -30,37 +30,13 @@ impl Completion {\n     pub fn new() -> Vc<Self> {\n         Completion::cell(Completion)\n     }\n-\n-    /// Uses the previous completion. Can be used to cancel without triggering a\n-    /// new invalidation.\n-    pub fn unchanged() -> Vc<Self> {\n-        // This is the same code that Completion::cell uses except that it\n-        // only updates the cell when it is empty (Completion::cell opted-out of\n-        // that via `#[turbo_tasks::value(cell = \"new\")]`)\n-        let cell = turbo_tasks::macro_helpers::find_cell_by_type(\n-            <Completion as crate::VcValueType>::get_value_type_id(),\n-        );\n-        cell.conditional_update(|old| old.is_none().then_some(Completion));\n-        let raw: RawVc = cell.into();\n-        raw.into()\n-    }\n }\n \n #[turbo_tasks::value(transparent)]\n pub struct Completions(Vec<ResolvedVc<Completion>>);\n \n #[turbo_tasks::value_impl]\n impl Completions {\n-    /// Merges multiple completions into one. The passed list will be part of\n-    /// the cache key, so this function should not be used with varying lists.\n-    ///\n-    /// Varying lists should use `Vc::cell(list).completed()`\n-    /// instead.\n-    #[turbo_tasks::function]\n-    pub fn all(completions: Vec<ResolvedVc<Completion>>) -> Vc<Completion> {\n-        Vc::<Completions>::cell(completions).completed()\n-    }\n-\n     /// Merges the list of completions into one.\n     #[turbo_tasks::function]\n     pub async fn completed(&self) -> anyhow::Result<Vc<Completion>> {\n@@ -91,7 +67,7 @@ impl Completions {\n }\n \n #[turbo_tasks::function]\n-pub async fn wrap(completion: Vc<Completion>) -> Result<Vc<Completion>> {\n+async fn wrap(completion: Vc<Completion>) -> Result<Vc<Completion>> {\n     completion.await?;\n     Ok(Completion::new())\n }"
        }
    ],
    "stats": {
        "total": 28,
        "additions": 2,
        "deletions": 26
    }
}