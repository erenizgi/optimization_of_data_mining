{
    "author": "bgw",
    "message": "Turbopack: chore: Remove dead RouteMatcher stuff (#85784)\n\nTurns out this is all dead code, so delete it!\n\nIt looks like this was added back in https://github.com/vercel/turborepo/pull/3448, probably when Turbopack was trying to rewrite larger parts of Next.js than ended up happening.",
    "sha": "e989fcb8b5e756162b1b4704f61205b9a3af4237",
    "files": [
        {
            "sha": "995324669edea3336eb41d519b32eedc79d8400b",
            "filename": "crates/next-core/src/lib.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/e989fcb8b5e756162b1b4704f61205b9a3af4237/crates%2Fnext-core%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e989fcb8b5e756162b1b4704f61205b9a3af4237/crates%2Fnext-core%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Flib.rs?ref=e989fcb8b5e756162b1b4704f61205b9a3af4237",
            "patch": "@@ -27,7 +27,6 @@ mod next_import_map;\n pub mod next_manifests;\n pub mod next_pages;\n mod next_root_params;\n-mod next_route_matcher;\n pub mod next_server;\n pub mod next_server_component;\n pub mod next_server_utility;"
        },
        {
            "sha": "5839a948626e8230647ddeebdbdeec5d4b29d674",
            "filename": "crates/next-core/src/next_route_matcher/all.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 15,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/67aa5f3d281705e64940b43b43408f580ad6f3b0/crates%2Fnext-core%2Fsrc%2Fnext_route_matcher%2Fall.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/67aa5f3d281705e64940b43b43408f580ad6f3b0/crates%2Fnext-core%2Fsrc%2Fnext_route_matcher%2Fall.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_route_matcher%2Fall.rs?ref=67aa5f3d281705e64940b43b43408f580ad6f3b0",
            "patch": "@@ -1,15 +0,0 @@\n-use serde::{Deserialize, Serialize};\n-use turbopack_node::route_matcher::{Params, RouteMatcherRef};\n-\n-#[derive(Debug, Serialize, Deserialize, Eq, PartialEq)]\n-pub struct AllMatch;\n-\n-impl RouteMatcherRef for AllMatch {\n-    fn matches(&self, _path: &str) -> bool {\n-        true\n-    }\n-\n-    fn params(&self, _path: &str) -> Params {\n-        Params(Some(Default::default()))\n-    }\n-}"
        },
        {
            "sha": "9593930ee43c099866bf94215a92f3a3cdc55bef",
            "filename": "crates/next-core/src/next_route_matcher/mod.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 182,
            "changes": 182,
            "blob_url": "https://github.com/vercel/next.js/blob/67aa5f3d281705e64940b43b43408f580ad6f3b0/crates%2Fnext-core%2Fsrc%2Fnext_route_matcher%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/67aa5f3d281705e64940b43b43408f580ad6f3b0/crates%2Fnext-core%2Fsrc%2Fnext_route_matcher%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_route_matcher%2Fmod.rs?ref=67aa5f3d281705e64940b43b43408f580ad6f3b0",
            "patch": "@@ -1,182 +0,0 @@\n-use anyhow::{Result, bail};\n-use turbo_rcstr::RcStr;\n-use turbo_tasks::{ResolvedVc, Vc};\n-use turbopack_node::route_matcher::{Params, RouteMatcher, RouteMatcherRef};\n-\n-use self::{\n-    all::AllMatch,\n-    path_regex::{PathRegex, PathRegexBuilder},\n-    prefix_suffix::PrefixSuffixMatcher,\n-};\n-\n-mod all;\n-mod path_regex;\n-mod prefix_suffix;\n-\n-/// A route matcher that matches a path against an exact route.\n-#[turbo_tasks::value]\n-pub(crate) struct NextExactMatcher {\n-    path: ResolvedVc<RcStr>,\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl NextExactMatcher {\n-    #[turbo_tasks::function]\n-    pub fn new(path: ResolvedVc<RcStr>) -> Vc<Self> {\n-        Self::cell(NextExactMatcher { path })\n-    }\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl RouteMatcher for NextExactMatcher {\n-    #[turbo_tasks::function]\n-    async fn matches(&self, path: RcStr) -> Result<Vc<bool>> {\n-        Ok(Vc::cell(path == *self.path.await?))\n-    }\n-\n-    #[turbo_tasks::function]\n-    async fn params(&self, path: RcStr) -> Result<Vc<Params>> {\n-        Ok(Vc::cell(if path == *self.path.await? {\n-            Some(Default::default())\n-        } else {\n-            None\n-        }))\n-    }\n-}\n-\n-/// A route matcher that matches a path against a route regex.\n-#[turbo_tasks::value]\n-pub(crate) struct NextParamsMatcher {\n-    #[turbo_tasks(trace_ignore)]\n-    matcher: PathRegex,\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl NextParamsMatcher {\n-    #[turbo_tasks::function]\n-    pub async fn new(path: ResolvedVc<RcStr>) -> Result<Vc<Self>> {\n-        Ok(Self::cell(NextParamsMatcher {\n-            matcher: build_path_regex(path.await?.as_str())?,\n-        }))\n-    }\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl RouteMatcher for NextParamsMatcher {\n-    #[turbo_tasks::function]\n-    fn matches(&self, path: RcStr) -> Vc<bool> {\n-        Vc::cell(self.matcher.matches(&path))\n-    }\n-\n-    #[turbo_tasks::function]\n-    fn params(&self, path: RcStr) -> Vc<Params> {\n-        Params::cell(self.matcher.params(&path))\n-    }\n-}\n-\n-/// A route matcher that strips a prefix and a suffix from a path before\n-/// matching it against a route regex.\n-#[turbo_tasks::value]\n-pub(crate) struct NextPrefixSuffixParamsMatcher {\n-    #[turbo_tasks(trace_ignore)]\n-    matcher: PrefixSuffixMatcher<PathRegex>,\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl NextPrefixSuffixParamsMatcher {\n-    /// Converts a filename within the server root into a regular expression\n-    /// with named capture groups for every dynamic segment.\n-    #[turbo_tasks::function]\n-    pub async fn new(path: ResolvedVc<RcStr>, prefix: RcStr, suffix: RcStr) -> Result<Vc<Self>> {\n-        Ok(Self::cell(NextPrefixSuffixParamsMatcher {\n-            matcher: PrefixSuffixMatcher::new(\n-                prefix.to_string(),\n-                suffix.to_string(),\n-                build_path_regex(path.await?.as_str())?,\n-            ),\n-        }))\n-    }\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl RouteMatcher for NextPrefixSuffixParamsMatcher {\n-    #[turbo_tasks::function]\n-    fn matches(&self, path: RcStr) -> Vc<bool> {\n-        Vc::cell(self.matcher.matches(&path))\n-    }\n-\n-    #[turbo_tasks::function]\n-    fn params(&self, path: RcStr) -> Vc<Params> {\n-        Params::cell(self.matcher.params(&path))\n-    }\n-}\n-\n-/// A route matcher that matches against all paths.\n-#[turbo_tasks::value]\n-pub(crate) struct NextFallbackMatcher {\n-    #[turbo_tasks(trace_ignore)]\n-    matcher: AllMatch,\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl NextFallbackMatcher {\n-    #[turbo_tasks::function]\n-    pub fn new() -> Vc<Self> {\n-        Self::cell(NextFallbackMatcher { matcher: AllMatch })\n-    }\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl RouteMatcher for NextFallbackMatcher {\n-    #[turbo_tasks::function]\n-    fn matches(&self, path: RcStr) -> Vc<bool> {\n-        Vc::cell(self.matcher.matches(&path))\n-    }\n-\n-    #[turbo_tasks::function]\n-    fn params(&self, path: RcStr) -> Vc<Params> {\n-        Params::cell(self.matcher.params(&path))\n-    }\n-}\n-\n-/// Converts a filename within the server root into a regular expression\n-/// with named capture groups for every dynamic segment.\n-fn build_path_regex(path: &str) -> Result<PathRegex> {\n-    let mut path_regex = PathRegexBuilder::new();\n-    for segment in path.split('/') {\n-        if let Some(segment) = segment.strip_prefix('[') {\n-            if let Some(segment) = segment.strip_prefix(\"[...\") {\n-                if let Some((placeholder, rem)) = segment.split_once(\"]]\") {\n-                    path_regex.push_optional_catch_all(placeholder, rem);\n-                } else {\n-                    bail!(\n-                        \"path ({}) contains '[[' without matching ']]' at '[[...{}'\",\n-                        path,\n-                        segment\n-                    );\n-                }\n-            } else if let Some(segment) = segment.strip_prefix(\"...\") {\n-                if let Some((placeholder, rem)) = segment.split_once(']') {\n-                    path_regex.push_catch_all(placeholder, rem);\n-                } else {\n-                    bail!(\n-                        \"path ({}) contains '[' without matching ']' at '[...{}'\",\n-                        path,\n-                        segment\n-                    );\n-                }\n-            } else if let Some((placeholder, rem)) = segment.split_once(']') {\n-                path_regex.push_dynamic_segment(placeholder, rem);\n-            } else {\n-                bail!(\n-                    \"path ({}) contains '[' without matching ']' at '[{}'\",\n-                    path,\n-                    segment\n-                );\n-            }\n-        } else {\n-            path_regex.push_static_segment(segment);\n-        }\n-    }\n-    path_regex.build()\n-}"
        },
        {
            "sha": "ec5b5a37925800e7e9c61a0b7dbfb016f1d58cdf",
            "filename": "crates/next-core/src/next_route_matcher/path_regex.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 166,
            "changes": 166,
            "blob_url": "https://github.com/vercel/next.js/blob/67aa5f3d281705e64940b43b43408f580ad6f3b0/crates%2Fnext-core%2Fsrc%2Fnext_route_matcher%2Fpath_regex.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/67aa5f3d281705e64940b43b43408f580ad6f3b0/crates%2Fnext-core%2Fsrc%2Fnext_route_matcher%2Fpath_regex.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_route_matcher%2Fpath_regex.rs?ref=67aa5f3d281705e64940b43b43408f580ad6f3b0",
            "patch": "@@ -1,166 +0,0 @@\n-use anyhow::{Context, Result};\n-use serde::{Deserialize, Serialize};\n-use turbo_tasks::primitives::Regex;\n-use turbopack_node::route_matcher::{Param, Params, RouteMatcherRef};\n-\n-/// A regular expression that matches a path, with named capture groups for the\n-/// dynamic parts of the path.\n-#[derive(Debug, Serialize, Deserialize, Eq, PartialEq)]\n-pub struct PathRegex {\n-    regex: Regex,\n-    named_params: Vec<NamedParam>,\n-}\n-\n-#[derive(Debug, Serialize, Deserialize, Eq, PartialEq)]\n-struct NamedParam {\n-    name: String,\n-    kind: NamedParamKind,\n-}\n-\n-#[derive(Debug, Serialize, Deserialize, Eq, PartialEq)]\n-enum NamedParamKind {\n-    Single,\n-    Multi,\n-}\n-\n-impl std::fmt::Display for PathRegex {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        write!(f, \"{}\", self.regex.as_str())\n-    }\n-}\n-\n-impl RouteMatcherRef for PathRegex {\n-    fn matches(&self, path: &str) -> bool {\n-        self.regex.is_match(path)\n-    }\n-\n-    fn params(&self, path: &str) -> Params {\n-        Params(self.regex.captures(path).map(|capture| {\n-            self.named_params\n-                .iter()\n-                .enumerate()\n-                .filter_map(|(idx, param)| {\n-                    if param.name.is_empty() {\n-                        return None;\n-                    }\n-                    let value = capture.get(idx + 1)?;\n-                    Some((\n-                        param.name.as_str().into(),\n-                        match param.kind {\n-                            NamedParamKind::Single => Param::Single(value.as_str().into()),\n-                            NamedParamKind::Multi => Param::Multi(\n-                                value\n-                                    .as_str()\n-                                    .split('/')\n-                                    .map(|segment| segment.into())\n-                                    .collect(),\n-                            ),\n-                        },\n-                    ))\n-                })\n-                .collect()\n-        }))\n-    }\n-}\n-\n-/// Builder for [PathRegex].\n-pub struct PathRegexBuilder {\n-    regex_str: String,\n-    named_params: Vec<NamedParam>,\n-}\n-\n-impl PathRegexBuilder {\n-    /// Creates a new [PathRegexBuilder].\n-    pub fn new() -> Self {\n-        Self {\n-            regex_str: \"^\".to_string(),\n-            named_params: Default::default(),\n-        }\n-    }\n-\n-    fn include_slash(&self) -> bool {\n-        self.regex_str.len() > 1\n-    }\n-\n-    fn push_str(&mut self, str: &str) {\n-        self.regex_str.push_str(str);\n-    }\n-\n-    /// Pushes an optional catch all segment to the regex.\n-    pub fn push_optional_catch_all<N, R>(&mut self, name: N, rem: R)\n-    where\n-        N: Into<String>,\n-        R: AsRef<str>,\n-    {\n-        self.push_str(if self.include_slash() {\n-            \"(?:/([^?]+))?\"\n-        } else {\n-            \"([^?]+)?\"\n-        });\n-        self.push_str(&regex::escape(rem.as_ref()));\n-        self.named_params.push(NamedParam {\n-            name: name.into(),\n-            kind: NamedParamKind::Multi,\n-        });\n-    }\n-\n-    /// Pushes a catch all segment to the regex.\n-    pub fn push_catch_all<N, R>(&mut self, name: N, rem: R)\n-    where\n-        N: Into<String>,\n-        R: AsRef<str>,\n-    {\n-        if self.include_slash() {\n-            self.push_str(\"/\");\n-        }\n-        self.push_str(\"([^?]+)\");\n-        self.push_str(&regex::escape(rem.as_ref()));\n-        self.named_params.push(NamedParam {\n-            name: name.into(),\n-            kind: NamedParamKind::Multi,\n-        });\n-    }\n-\n-    /// Pushes a dynamic segment to the regex.\n-    pub fn push_dynamic_segment<N, R>(&mut self, name: N, rem: R)\n-    where\n-        N: Into<String>,\n-        R: AsRef<str>,\n-    {\n-        if self.include_slash() {\n-            self.push_str(\"/\");\n-        }\n-        self.push_str(\"([^?/]+)\");\n-        self.push_str(&regex::escape(rem.as_ref()));\n-        self.named_params.push(NamedParam {\n-            name: name.into(),\n-            kind: NamedParamKind::Single,\n-        });\n-    }\n-\n-    /// Pushes a static segment to the regex.\n-    pub fn push_static_segment<S>(&mut self, segment: S)\n-    where\n-        S: AsRef<str>,\n-    {\n-        if self.include_slash() {\n-            self.push_str(\"/\");\n-        }\n-        self.push_str(&regex::escape(segment.as_ref()));\n-    }\n-\n-    /// Builds and returns the [PathRegex].\n-    pub fn build(mut self) -> Result<PathRegex> {\n-        self.regex_str += \"$\";\n-        Ok(PathRegex {\n-            regex: Regex(regex::Regex::new(&self.regex_str).with_context(|| \"invalid path regex\")?),\n-            named_params: self.named_params,\n-        })\n-    }\n-}\n-\n-impl Default for PathRegexBuilder {\n-    fn default() -> Self {\n-        Self::new()\n-    }\n-}"
        },
        {
            "sha": "a87271c3d564e9cde8facd12417c45c41dd5a492",
            "filename": "crates/next-core/src/next_route_matcher/prefix_suffix.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 54,
            "changes": 54,
            "blob_url": "https://github.com/vercel/next.js/blob/67aa5f3d281705e64940b43b43408f580ad6f3b0/crates%2Fnext-core%2Fsrc%2Fnext_route_matcher%2Fprefix_suffix.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/67aa5f3d281705e64940b43b43408f580ad6f3b0/crates%2Fnext-core%2Fsrc%2Fnext_route_matcher%2Fprefix_suffix.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_route_matcher%2Fprefix_suffix.rs?ref=67aa5f3d281705e64940b43b43408f580ad6f3b0",
            "patch": "@@ -1,54 +0,0 @@\n-use serde::{Deserialize, Serialize};\n-use turbopack_node::route_matcher::{Params, RouteMatcherRef};\n-\n-/// A composite route matcher that matches a path if it has a given prefix and\n-/// suffix.\n-#[derive(Debug, Serialize, Deserialize, Eq, PartialEq)]\n-pub struct PrefixSuffixMatcher<T>\n-where\n-    T: RouteMatcherRef,\n-{\n-    prefix: String,\n-    suffix: String,\n-    inner: T,\n-}\n-\n-impl<T> PrefixSuffixMatcher<T>\n-where\n-    T: RouteMatcherRef,\n-{\n-    /// Creates a new [PrefixSuffixMatcher].\n-    pub fn new(prefix: String, suffix: String, inner: T) -> Self {\n-        Self {\n-            prefix,\n-            suffix,\n-            inner,\n-        }\n-    }\n-\n-    fn strip_prefix_and_suffix<'b>(&self, path: &'b str) -> Option<&'b str> {\n-        path.strip_prefix(self.prefix.as_str())?\n-            .strip_suffix(self.suffix.as_str())\n-    }\n-}\n-\n-impl<T> RouteMatcherRef for PrefixSuffixMatcher<T>\n-where\n-    T: RouteMatcherRef,\n-{\n-    fn matches(&self, path: &str) -> bool {\n-        if let Some(path) = self.strip_prefix_and_suffix(path) {\n-            self.inner.matches(path)\n-        } else {\n-            false\n-        }\n-    }\n-\n-    fn params(&self, path: &str) -> Params {\n-        if let Some(path) = self.strip_prefix_and_suffix(path) {\n-            self.inner.params(path)\n-        } else {\n-            Params(None)\n-        }\n-    }\n-}"
        },
        {
            "sha": "ba0fb54f6b68e0a5b29188a163cd296b049b653f",
            "filename": "turbopack/crates/turbopack-node/src/lib.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/e989fcb8b5e756162b1b4704f61205b9a3af4237/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e989fcb8b5e756162b1b4704f61205b9a3af4237/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Flib.rs?ref=e989fcb8b5e756162b1b4704f61205b9a3af4237",
            "patch": "@@ -32,7 +32,6 @@ pub mod evaluate;\n pub mod execution_context;\n mod heap_queue;\n mod pool;\n-pub mod route_matcher;\n pub mod source_map;\n pub mod transforms;\n "
        },
        {
            "sha": "e8807097b1d96e7ed84048a64fb30b35ecef539c",
            "filename": "turbopack/crates/turbopack-node/src/route_matcher.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 35,
            "changes": 35,
            "blob_url": "https://github.com/vercel/next.js/blob/67aa5f3d281705e64940b43b43408f580ad6f3b0/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Froute_matcher.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/67aa5f3d281705e64940b43b43408f580ad6f3b0/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Froute_matcher.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Froute_matcher.rs?ref=67aa5f3d281705e64940b43b43408f580ad6f3b0",
            "patch": "@@ -1,35 +0,0 @@\n-use turbo_rcstr::RcStr;\n-use turbo_tasks::{FxIndexMap, Vc};\n-\n-#[turbo_tasks::value]\n-#[derive(Debug, Clone)]\n-#[serde(untagged)]\n-pub enum Param {\n-    Single(RcStr),\n-    Multi(Vec<RcStr>),\n-}\n-\n-#[turbo_tasks::value(transparent)]\n-#[derive(Debug, Clone)]\n-pub struct Params(pub Option<FxIndexMap<RcStr, Param>>);\n-\n-/// Extracts parameters from a URL path.\n-pub trait RouteMatcherRef {\n-    /// Returns whether the given path is a match for the route.\n-    fn matches(&self, path: &str) -> bool;\n-\n-    /// Returns the parameters extracted from the given path.\n-    fn params(&self, path: &str) -> Params;\n-}\n-\n-/// Extracts parameters from a URL path (Vc version)\n-#[turbo_tasks::value_trait]\n-pub trait RouteMatcher {\n-    /// Returns whether the given path is a match for the route.\n-    #[turbo_tasks::function]\n-    fn matches(self: Vc<Self>, path: RcStr) -> Vc<bool>;\n-\n-    /// Returns the parameters extracted from the given path.\n-    #[turbo_tasks::function]\n-    fn params(self: Vc<Self>, path: RcStr) -> Vc<Params>;\n-}"
        }
    ],
    "stats": {
        "total": 454,
        "additions": 0,
        "deletions": 454
    }
}