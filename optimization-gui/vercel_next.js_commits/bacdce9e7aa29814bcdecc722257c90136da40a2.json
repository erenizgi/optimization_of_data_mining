{
    "author": "bgw",
    "message": "Turbopack: Use `Path`/`PathBuf` for all of the invalidation logic (#82132)\n\nCommon convention in our codebase is that `Path`/`PathBuf` are used for raw OS-level paths, and `RcStr` is used for normalized paths exposed by `turbo_tasks_fs`.\n\nThese are raw OS paths, so we should use `Path`/`PathBuf`.\n\nThis has some benefits in that it makes the implementation of https://github.com/vercel/next.js/pull/82133 easier, because `Path`'s `Ord` implementation is better for our use-case.",
    "sha": "bacdce9e7aa29814bcdecc722257c90136da40a2",
    "files": [
        {
            "sha": "ec4964a5a3595cdafe6f067f544322fca4c0db70",
            "filename": "crates/next-api/src/project.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 4,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/bacdce9e7aa29814bcdecc722257c90136da40a2/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/bacdce9e7aa29814bcdecc722257c90136da40a2/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fproject.rs?ref=bacdce9e7aa29814bcdecc722257c90136da40a2",
            "patch": "@@ -323,14 +323,15 @@ impl ProjectContainer {\n                 .await?;\n         } else {\n             project_fs.invalidate_with_reason(|path| invalidation::Initialize {\n-                path: RcStr::from(path),\n+                // this path is just used for display purposes\n+                path: RcStr::from(path.to_string_lossy()),\n             });\n         }\n         let output_fs = output_fs_operation(project)\n             .read_strongly_consistent()\n             .await?;\n         output_fs.invalidate_with_reason(|path| invalidation::Initialize {\n-            path: RcStr::from(path),\n+            path: RcStr::from(path.to_string_lossy()),\n         });\n         Ok(())\n     }\n@@ -421,13 +422,14 @@ impl ProjectContainer {\n                     .await?;\n             } else {\n                 project_fs.invalidate_with_reason(|path| invalidation::Initialize {\n-                    path: RcStr::from(path),\n+                    // this path is just used for display purposes\n+                    path: RcStr::from(path.to_string_lossy()),\n                 });\n             }\n         }\n         if !ReadRef::ptr_eq(&prev_output_fs, &output_fs) {\n             prev_output_fs.invalidate_with_reason(|path| invalidation::Initialize {\n-                path: RcStr::from(path),\n+                path: RcStr::from(path.to_string_lossy()),\n             });\n         }\n "
        },
        {
            "sha": "c5c3bf8630c7e2e1cfb7825f34a2370f916db16d",
            "filename": "turbopack/crates/turbo-tasks-fs/src/invalidator_map.rs",
            "status": "modified",
            "additions": 16,
            "deletions": 5,
            "changes": 21,
            "blob_url": "https://github.com/vercel/next.js/blob/bacdce9e7aa29814bcdecc722257c90136da40a2/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Finvalidator_map.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/bacdce9e7aa29814bcdecc722257c90136da40a2/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Finvalidator_map.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Finvalidator_map.rs?ref=bacdce9e7aa29814bcdecc722257c90136da40a2",
            "patch": "@@ -1,4 +1,7 @@\n-use std::sync::{LockResult, Mutex, MutexGuard};\n+use std::{\n+    path::PathBuf,\n+    sync::{LockResult, Mutex, MutexGuard},\n+};\n \n use concurrent_queue::ConcurrentQueue;\n use rustc_hash::FxHashMap;\n@@ -13,10 +16,10 @@ pub enum WriteContent {\n     Link(ReadRef<LinkContent>),\n }\n \n-type InnerMap = FxHashMap<String, FxHashMap<Invalidator, Option<WriteContent>>>;\n+type InnerMap = FxHashMap<PathBuf, FxHashMap<Invalidator, Option<WriteContent>>>;\n \n pub struct InvalidatorMap {\n-    queue: ConcurrentQueue<(String, Invalidator, Option<WriteContent>)>,\n+    queue: ConcurrentQueue<(PathBuf, Invalidator, Option<WriteContent>)>,\n     map: Mutex<InnerMap>,\n }\n \n@@ -44,7 +47,7 @@ impl InvalidatorMap {\n \n     pub fn insert(\n         &self,\n-        key: String,\n+        key: PathBuf,\n         invalidator: Invalidator,\n         write_content: Option<WriteContent>,\n     ) {\n@@ -66,7 +69,15 @@ impl Serialize for InvalidatorMap {\n     where\n         S: serde::Serializer,\n     {\n-        serializer.serialize_newtype_struct(\"InvalidatorMap\", &*self.lock().unwrap())\n+        // TODO: This stores absolute `PathBuf`s, which are machine-specific. This should\n+        // normalize/denormalize paths relative to the disk filesystem root.\n+        //\n+        // Potential optimization: We invalidate all fs reads immediately upon resuming from a\n+        // persisted cache, but we don't invalidate the fs writes. Those read invalidations trigger\n+        // re-inserts into the `InvalidatorMap`. If we knew that certain invalidators were only\n+        // needed for reads, we could potentially avoid serializing those paths entirely.\n+        let inner: &InnerMap = &self.lock().unwrap();\n+        serializer.serialize_newtype_struct(\"InvalidatorMap\", inner)\n     }\n }\n "
        },
        {
            "sha": "2893e0b6092410258a744cf17cdc30d2cf44850d",
            "filename": "turbopack/crates/turbo-tasks-fs/src/lib.rs",
            "status": "modified",
            "additions": 16,
            "deletions": 18,
            "changes": 34,
            "blob_url": "https://github.com/vercel/next.js/blob/bacdce9e7aa29814bcdecc722257c90136da40a2/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/bacdce9e7aa29814bcdecc722257c90136da40a2/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs?ref=bacdce9e7aa29814bcdecc722257c90136da40a2",
            "patch": "@@ -254,7 +254,7 @@ impl DiskFileSystemInner {\n     fn register_read_invalidator(&self, path: &Path) -> Result<()> {\n         let invalidator = turbo_tasks::get_invalidator();\n         self.invalidator_map\n-            .insert(path_to_key(path), invalidator, None);\n+            .insert(path.to_owned(), invalidator, None);\n         if let Some(non_recursive) = &self.watcher.non_recursive_state\n             && let Some(dir) = path.parent()\n         {\n@@ -273,7 +273,7 @@ impl DiskFileSystemInner {\n         write_content: WriteContent,\n     ) -> Result<Vec<(Invalidator, Option<WriteContent>)>> {\n         let mut invalidator_map = self.invalidator_map.lock().unwrap();\n-        let invalidators = invalidator_map.entry(path_to_key(path)).or_default();\n+        let invalidators = invalidator_map.entry(path.to_owned()).or_default();\n         let old_invalidators = invalidators\n             .extract_if(|i, old_write_content| {\n                 i == &invalidator\n@@ -298,7 +298,7 @@ impl DiskFileSystemInner {\n     fn register_dir_invalidator(&self, path: &Path) -> Result<()> {\n         let invalidator = turbo_tasks::get_invalidator();\n         self.dir_invalidator_map\n-            .insert(path_to_key(path), invalidator, None);\n+            .insert(path.to_owned(), invalidator, None);\n         if let Some(non_recursive) = &self.watcher.non_recursive_state {\n             non_recursive.ensure_watching(&self.watcher, path, self.root_path())?;\n         }\n@@ -333,7 +333,7 @@ impl DiskFileSystemInner {\n     /// Calls the given\n     fn invalidate_with_reason<R: InvalidationReason + Clone>(\n         &self,\n-        reason: impl Fn(String) -> R + Sync,\n+        reason: impl Fn(&Path) -> R + Sync,\n     ) {\n         let _span = tracing::info_span!(\"invalidate filesystem\", name = &*self.root).entered();\n         let span = tracing::Span::current();\n@@ -345,7 +345,7 @@ impl DiskFileSystemInner {\n             .chain(dir_invalidator_map.into_par_iter())\n             .flat_map(|(path, invalidators)| {\n                 let _span = span.clone().entered();\n-                let reason_for_path = reason(path);\n+                let reason_for_path = reason(&path);\n                 invalidators\n                     .into_par_iter()\n                     .map(move |i| (reason_for_path.clone(), i))\n@@ -449,7 +449,7 @@ impl DiskFileSystem {\n \n     pub fn invalidate_with_reason<R: InvalidationReason + Clone>(\n         &self,\n-        reason: impl Fn(String) -> R + Sync,\n+        reason: impl Fn(&Path) -> R + Sync,\n     ) {\n         self.inner.invalidate_with_reason(reason);\n     }\n@@ -504,10 +504,6 @@ fn format_absolute_fs_path(path: &Path, name: &str, root_path: &Path) -> Option<\n     }\n }\n \n-pub fn path_to_key(path: impl AsRef<Path>) -> String {\n-    path.as_ref().to_string_lossy().to_string()\n-}\n-\n #[turbo_tasks::value_impl]\n impl DiskFileSystem {\n     /// Create a new instance of `DiskFileSystem`.\n@@ -756,11 +752,12 @@ impl FileSystem for DiskFileSystem {\n                 .await?;\n             if compare == FileComparison::Equal {\n                 if !old_invalidators.is_empty() {\n-                    let key = path_to_key(&full_path);\n                     for (invalidator, write_content) in old_invalidators {\n-                        inner\n-                            .invalidator_map\n-                            .insert(key.clone(), invalidator, write_content);\n+                        inner.invalidator_map.insert(\n+                            full_path.clone().into_owned(),\n+                            invalidator,\n+                            write_content,\n+                        );\n                     }\n                 }\n                 return Ok(());\n@@ -899,11 +896,12 @@ impl FileSystem for DiskFileSystem {\n             };\n             if is_equal {\n                 if !old_invalidators.is_empty() {\n-                    let key = path_to_key(&full_path);\n                     for (invalidator, write_content) in old_invalidators {\n-                        inner\n-                            .invalidator_map\n-                            .insert(key.clone(), invalidator, write_content);\n+                        inner.invalidator_map.insert(\n+                            full_path.clone().into_owned(),\n+                            invalidator,\n+                            write_content,\n+                        );\n                     }\n                 }\n                 return Ok(());"
        },
        {
            "sha": "646703b3a05a1e01011c73d20bc5abead208fc75",
            "filename": "turbopack/crates/turbo-tasks-fs/src/watcher.rs",
            "status": "modified",
            "additions": 8,
            "deletions": 9,
            "changes": 17,
            "blob_url": "https://github.com/vercel/next.js/blob/bacdce9e7aa29814bcdecc722257c90136da40a2/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fwatcher.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/bacdce9e7aa29814bcdecc722257c90136da40a2/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fwatcher.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fwatcher.rs?ref=bacdce9e7aa29814bcdecc722257c90136da40a2",
            "patch": "@@ -30,7 +30,6 @@ use crate::{\n     DiskFileSystemInner, format_absolute_fs_path,\n     invalidation::{WatchChange, WatchStart},\n     invalidator_map::WriteContent,\n-    path_to_key,\n };\n \n static WATCH_RECURSIVE_MODE: LazyLock<RecursiveMode> = LazyLock::new(|| {\n@@ -279,7 +278,8 @@ impl DiskWatcher {\n                     let _span = span.clone().entered();\n                     let reason = WatchStart {\n                         name: fs_inner.name.clone(),\n-                        path: path.into(),\n+                        // this path is just used for display purposes\n+                        path: RcStr::from(path.to_string_lossy()),\n                     };\n                     invalidators\n                         .into_par_iter()\n@@ -374,7 +374,8 @@ impl DiskWatcher {\n \n                             if report_invalidation_reason {\n                                 inner.invalidate_with_reason(|path| InvalidateRescan {\n-                                    path: RcStr::from(path),\n+                                    // this path is just used for display purposes\n+                                    path: RcStr::from(path.to_string_lossy()),\n                                 });\n                             } else {\n                                 inner.invalidate();\n@@ -601,12 +602,11 @@ fn invalidate(\n fn invalidate_path(\n     inner: &DiskFileSystemInner,\n     report_invalidation_reason: bool,\n-    invalidator_map: &mut FxHashMap<String, FxHashMap<Invalidator, Option<WriteContent>>>,\n+    invalidator_map: &mut FxHashMap<PathBuf, FxHashMap<Invalidator, Option<WriteContent>>>,\n     paths: impl Iterator<Item = PathBuf>,\n ) {\n     for path in paths {\n-        let key = path_to_key(&path);\n-        if let Some(invalidators) = invalidator_map.remove(&key) {\n+        if let Some(invalidators) = invalidator_map.remove(&path) {\n             invalidators\n                 .into_iter()\n                 .for_each(|(i, _)| invalidate(inner, report_invalidation_reason, &path, i));\n@@ -617,12 +617,11 @@ fn invalidate_path(\n fn invalidate_path_and_children_execute(\n     inner: &DiskFileSystemInner,\n     report_invalidation_reason: bool,\n-    invalidator_map: &mut FxHashMap<String, FxHashMap<Invalidator, Option<WriteContent>>>,\n+    invalidator_map: &mut FxHashMap<PathBuf, FxHashMap<Invalidator, Option<WriteContent>>>,\n     paths: impl Iterator<Item = PathBuf>,\n ) {\n     for path in paths {\n-        let path_key = path_to_key(&path);\n-        for (_, invalidators) in invalidator_map.extract_if(|key, _| key.starts_with(&path_key)) {\n+        for (_, invalidators) in invalidator_map.extract_if(|key, _| key.starts_with(&path)) {\n             invalidators\n                 .into_iter()\n                 .for_each(|(i, _)| invalidate(inner, report_invalidation_reason, &path, i));"
        }
    ],
    "stats": {
        "total": 82,
        "additions": 46,
        "deletions": 36
    }
}