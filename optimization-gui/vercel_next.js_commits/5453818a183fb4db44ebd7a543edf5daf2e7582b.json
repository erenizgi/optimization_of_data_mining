{
    "author": "timneutkens",
    "message": "Turbopack: Add __turbopack_load_by_url__ (#76814)\n\nWork in progress for PACK-4071 (implementing `config.deploymentId`)\n\n- [x] Implement `?dpl={config.deploymentId}` in client references\nmanifest\n- [x] Implement `?dpl={config.deploymentId}` in Turbopack chunk loading \n- [x] Add `__turbopack_load_by_url__`\n- [ ] Change react-dom-turbopack to use __turbopack_load_by_url__\n\nLast item will be a follow-up PR to this one, given it's already a large\nenough change in chunk loading right now.\n\n<!-- Thanks for opening a PR! Your contribution is much appreciated.\nTo make sure your PR is handled as smoothly as possible we request that\nyou follow the checklist sections below.\nChoose the right checklist for the change(s) that you're making:\n\n## For Contributors\n\n### Improving Documentation\n\n- Run `pnpm prettier-fix` to fix formatting issues before opening the\nPR.\n- Read the Docs Contribution Guide to ensure your contribution follows\nthe docs guidelines:\nhttps://nextjs.org/docs/community/contribution-guide\n\n### Adding or Updating Examples\n\n- The \"examples guidelines\" are followed from our contributing doc\nhttps://github.com/vercel/next.js/blob/canary/contributing/examples/adding-examples.md\n- Make sure the linting passes by running `pnpm build && pnpm lint`. See\nhttps://github.com/vercel/next.js/blob/canary/contributing/repository/linting.md\n\n### Fixing a bug\n\n- Related issues linked using `fixes #number`\n- Tests added. See:\nhttps://github.com/vercel/next.js/blob/canary/contributing/core/testing.md#writing-tests-for-nextjs\n- Errors have a helpful link attached, see\nhttps://github.com/vercel/next.js/blob/canary/contributing.md\n\n### Adding a feature\n\n- Implements an existing feature request or RFC. Make sure the feature\nrequest has been accepted for implementation before opening a PR. (A\ndiscussion must be opened, see\nhttps://github.com/vercel/next.js/discussions/new?category=ideas)\n- Related issues/discussions are linked using `fixes #number`\n- e2e tests added\n(https://github.com/vercel/next.js/blob/canary/contributing/core/testing.md#writing-tests-for-nextjs)\n- Documentation added\n- Telemetry added. In case of a feature if it's used or not.\n- Errors have a helpful link attached, see\nhttps://github.com/vercel/next.js/blob/canary/contributing.md\n\n\n## For Maintainers\n\n- Minimal description (aim for explaining to someone not on the team to\nunderstand the PR)\n- When linking to a Slack thread, you might want to share details of the\nconclusion\n- Link both the Linear (Fixes NEXT-xxx) and the GitHub issues\n- Add review comments if necessary to explain to the reviewer the logic\nbehind a change\n\n### What?\n\n### Why?\n\n### How?\n\nCloses NEXT-\nFixes #\n\n-->",
    "sha": "5453818a183fb4db44ebd7a543edf5daf2e7582b",
    "files": [
        {
            "sha": "f84c998c07ca3ba172fba0c17119352c4f15df52",
            "filename": "crates/next-api/src/project.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/5453818a183fb4db44ebd7a543edf5daf2e7582b/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5453818a183fb4db44ebd7a543edf5daf2e7582b/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fproject.rs?ref=5453818a183fb4db44ebd7a543edf5daf2e7582b",
            "patch": "@@ -966,6 +966,7 @@ impl Project {\n             self.client_relative_path(),\n             Vc::cell(\"/ROOT\".into()),\n             self.next_config().computed_asset_prefix(),\n+            self.next_config().chunk_suffix_path(),\n             self.client_compile_time_info().environment(),\n             self.next_mode(),\n             self.module_id_strategy(),"
        },
        {
            "sha": "8bfaf79c9ed45abbc59ac774e25b46cc5340c337",
            "filename": "crates/next-core/src/next_client/context.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/5453818a183fb4db44ebd7a543edf5daf2e7582b/crates%2Fnext-core%2Fsrc%2Fnext_client%2Fcontext.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5453818a183fb4db44ebd7a543edf5daf2e7582b/crates%2Fnext-core%2Fsrc%2Fnext_client%2Fcontext.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_client%2Fcontext.rs?ref=5453818a183fb4db44ebd7a543edf5daf2e7582b",
            "patch": "@@ -415,6 +415,7 @@ pub async fn get_client_chunking_context(\n     client_root: ResolvedVc<FileSystemPath>,\n     client_root_to_root_path: ResolvedVc<RcStr>,\n     asset_prefix: ResolvedVc<Option<RcStr>>,\n+    chunk_suffix_path: ResolvedVc<Option<RcStr>>,\n     environment: ResolvedVc<Environment>,\n     mode: Vc<NextMode>,\n     module_id_strategy: ResolvedVc<Box<dyn ModuleIdStrategy>>,\n@@ -437,6 +438,7 @@ pub async fn get_client_chunking_context(\n         next_mode.runtime_type(),\n     )\n     .chunk_base_path(asset_prefix)\n+    .chunk_suffix_path(chunk_suffix_path)\n     .minify_type(if *minify.await? {\n         MinifyType::Minify {\n             mangle: !*no_mangling.await?,"
        },
        {
            "sha": "b4b8cd44e14c4696eeb87dd4ac3df87ab006d5d4",
            "filename": "crates/next-core/src/next_config.rs",
            "status": "modified",
            "additions": 12,
            "deletions": 3,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/5453818a183fb4db44ebd7a543edf5daf2e7582b/crates%2Fnext-core%2Fsrc%2Fnext_config.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5453818a183fb4db44ebd7a543edf5daf2e7582b/crates%2Fnext-core%2Fsrc%2Fnext_config.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_config.rs?ref=5453818a183fb4db44ebd7a543edf5daf2e7582b",
            "patch": "@@ -83,6 +83,7 @@ pub struct NextConfig {\n     pub transpile_packages: Option<Vec<RcStr>>,\n     pub modularize_imports: Option<FxIndexMap<String, ModularizeImportPackageConfig>>,\n     pub dist_dir: Option<RcStr>,\n+    pub deployment_id: Option<RcStr>,\n     sass_options: Option<serde_json::Value>,\n     pub trailing_slash: Option<bool>,\n     pub asset_prefix: Option<RcStr>,\n@@ -670,9 +671,6 @@ pub struct ExperimentalConfig {\n     turbo: Option<ExperimentalTurboConfig>,\n     external_middleware_rewrites_resolve: Option<bool>,\n     scroll_restoration: Option<bool>,\n-    use_deployment_id: Option<bool>,\n-    use_deployment_id_server_actions: Option<bool>,\n-    deployment_id: Option<RcStr>,\n     manual_client_base_path: Option<bool>,\n     optimistic_client_cache: Option<bool>,\n     middleware_prefetch: Option<MiddlewarePrefetchType>,\n@@ -1393,6 +1391,17 @@ impl NextConfig {\n         )))\n     }\n \n+    /// Returns the suffix to use for chunk loading.\n+    #[turbo_tasks::function]\n+    pub async fn chunk_suffix_path(self: Vc<Self>) -> Result<Vc<Option<RcStr>>> {\n+        let this = self.await?;\n+\n+        match &this.deployment_id {\n+            Some(deployment_id) => Ok(Vc::cell(Some(format!(\"?dpl={}\", deployment_id).into()))),\n+            None => Ok(Vc::cell(None)),\n+        }\n+    }\n+\n     #[turbo_tasks::function]\n     pub fn enable_ppr(&self) -> Vc<bool> {\n         Vc::cell("
        },
        {
            "sha": "8dd90585caa5c6e828ded90f35a2074b70ddc8f8",
            "filename": "crates/next-core/src/next_manifests/client_reference_manifest.rs",
            "status": "modified",
            "additions": 11,
            "deletions": 1,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/5453818a183fb4db44ebd7a543edf5daf2e7582b/crates%2Fnext-core%2Fsrc%2Fnext_manifests%2Fclient_reference_manifest.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5453818a183fb4db44ebd7a543edf5daf2e7582b/crates%2Fnext-core%2Fsrc%2Fnext_manifests%2Fclient_reference_manifest.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_manifests%2Fclient_reference_manifest.rs?ref=5453818a183fb4db44ebd7a543edf5daf2e7582b",
            "patch": "@@ -71,12 +71,19 @@ impl ClientReferenceManifest {\n         async move {\n             let mut entry_manifest: ClientReferenceManifest = Default::default();\n             let mut references = FxIndexSet::default();\n-            entry_manifest.module_loading.prefix = next_config\n+            let chunk_suffix_path = next_config.chunk_suffix_path().await?;\n+            let prefix_path = next_config\n                 .computed_asset_prefix()\n                 .await?\n                 .as_ref()\n                 .map(|p| p.clone())\n                 .unwrap_or_default();\n+            let suffix_path = chunk_suffix_path\n+                .as_ref()\n+                .map(|p| p.to_string())\n+                .unwrap_or(\"\".into());\n+\n+            entry_manifest.module_loading.prefix = prefix_path;\n \n             entry_manifest.module_loading.cross_origin = next_config\n                 .await?\n@@ -195,6 +202,7 @@ impl ClientReferenceManifest {\n                             // It's possible that a chunk also emits CSS files, that will\n                             // be handled separatedly.\n                             .filter(|path| path.ends_with(\".js\"))\n+                            .map(|path| format!(\"{}{}\", path, suffix_path))\n                             .map(RcStr::from)\n                             .collect::<Vec<_>>();\n \n@@ -355,6 +363,8 @@ impl ClientReferenceManifest {\n \n                 for (chunk, chunk_path) in client_chunks_with_path {\n                     if let Some(path) = client_relative_path.get_path_to(&chunk_path) {\n+                        // The entry CSS files and entry JS files don't have prefix and suffix\n+                        // applied because it is added by Nex.js during rendering.\n                         let path = path.into();\n                         if chunk_path.extension_ref() == Some(\"css\") {\n                             entry_css_files_with_chunk.push((path, chunk));"
        },
        {
            "sha": "118e5aabf5e58a1b41449051aab64e701883d3ff",
            "filename": "packages/next/src/server/app-render/get-asset-query-string.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/5453818a183fb4db44ebd7a543edf5daf2e7582b/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fget-asset-query-string.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/5453818a183fb4db44ebd7a543edf5daf2e7582b/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fget-asset-query-string.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fget-asset-query-string.ts?ref=5453818a183fb4db44ebd7a543edf5daf2e7582b",
            "patch": "@@ -2,6 +2,7 @@ import type { AppRenderContext } from './app-render'\n \n const isDev = process.env.NODE_ENV === 'development'\n const isTurbopack = !!process.env.TURBOPACK\n+\n export function getAssetQueryString(\n   ctx: AppRenderContext,\n   addTimestamp: boolean\n@@ -12,12 +13,13 @@ export function getAssetQueryString(\n   // reload assets when a new RSC response is received.\n   // Turbopack handles HMR of assets itself and react doesn't need to reload them\n   // so this approach is not needed for Turbopack.\n-  if (isDev && !isTurbopack && addTimestamp) {\n+  const shouldAddVersion = isDev && !isTurbopack && addTimestamp\n+  if (shouldAddVersion) {\n     qs += `?v=${ctx.requestTimestamp}`\n   }\n \n   if (ctx.renderOpts.deploymentId) {\n-    qs += `${isDev ? '&' : '?'}dpl=${ctx.renderOpts.deploymentId}`\n+    qs += `${shouldAddVersion ? '&' : '?'}dpl=${ctx.renderOpts.deploymentId}`\n   }\n   return qs\n }"
        },
        {
            "sha": "4ec05c2540bed387473378f00d4cf0d6bcd9295d",
            "filename": "packages/next/taskfile.js",
            "status": "modified",
            "additions": 11,
            "deletions": 5,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/5453818a183fb4db44ebd7a543edf5daf2e7582b/packages%2Fnext%2Ftaskfile.js",
            "raw_url": "https://github.com/vercel/next.js/raw/5453818a183fb4db44ebd7a543edf5daf2e7582b/packages%2Fnext%2Ftaskfile.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Ftaskfile.js?ref=5453818a183fb4db44ebd7a543edf5daf2e7582b",
            "patch": "@@ -1787,11 +1787,17 @@ export async function copy_vendor_react(task_) {\n         // bundles have unique constraints like a runtime bundle. For browser builds this\n         // package will be bundled alongside user code and we don't need to introduce the extra\n         // indirection\n-        if (\n-          (file.base.startsWith('react-server-dom-turbopack-client') &&\n-            !file.base.startsWith(\n-              'react-server-dom-turbopack-client.browser'\n-            )) ||\n+\n+        if (file.base.startsWith('react-server-dom-turbopack-client.browser')) {\n+          const source = file.data.toString()\n+          let newSource = source.replace(\n+            /__turbopack_load__/g,\n+            '__turbopack_load__'\n+          )\n+\n+          file.data = newSource\n+        } else if (\n+          file.base.startsWith('react-server-dom-turbopack-client') ||\n           (file.base.startsWith('react-server-dom-turbopack-server') &&\n             !file.base.startsWith('react-server-dom-turbopack-server.browser'))\n         ) {"
        },
        {
            "sha": "0d2fe54aa9a52af8a3fe34323bb3410871bf74b7",
            "filename": "test/turbopack-build-tests-manifest.json",
            "status": "modified",
            "additions": 3,
            "deletions": 4,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/5453818a183fb4db44ebd7a543edf5daf2e7582b/test%2Fturbopack-build-tests-manifest.json",
            "raw_url": "https://github.com/vercel/next.js/raw/5453818a183fb4db44ebd7a543edf5daf2e7582b/test%2Fturbopack-build-tests-manifest.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fturbopack-build-tests-manifest.json?ref=5453818a183fb4db44ebd7a543edf5daf2e7582b",
            "patch": "@@ -17873,7 +17873,8 @@\n       \"runtimeError\": false\n     },\n     \"test/production/deployment-id-handling/deployment-id-handling.test.ts\": {\n-      \"passed\": [\n+      \"passed\": [],\n+      \"failed\": [\n         \"deployment-id-handling disabled should not append dpl query to all assets for /\",\n         \"deployment-id-handling disabled should not append dpl query to all assets for /from-app\",\n         \"deployment-id-handling disabled should not append dpl query to all assets for /from-app/edge\",\n@@ -17883,9 +17884,7 @@\n         \"deployment-id-handling enabled with CUSTOM_DEPLOYMENT_ID should have deployment id env available\",\n         \"deployment-id-handling enabled with NEXT_DEPLOYMENT_ID should contain deployment id in RSC payload request headers\",\n         \"deployment-id-handling enabled with NEXT_DEPLOYMENT_ID should contain deployment id in prefetch request\",\n-        \"deployment-id-handling enabled with NEXT_DEPLOYMENT_ID should have deployment id env available\"\n-      ],\n-      \"failed\": [\n+        \"deployment-id-handling enabled with NEXT_DEPLOYMENT_ID should have deployment id env available\",\n         \"deployment-id-handling enabled with CUSTOM_DEPLOYMENT_ID should append dpl query to all assets correctly for /\",\n         \"deployment-id-handling enabled with CUSTOM_DEPLOYMENT_ID should append dpl query to all assets correctly for /from-app\",\n         \"deployment-id-handling enabled with CUSTOM_DEPLOYMENT_ID should append dpl query to all assets correctly for /from-app/edge\","
        },
        {
            "sha": "b01cf4cc20b33d92f9413126930483df3308005a",
            "filename": "turbopack/crates/turbopack-browser/src/chunking_context.rs",
            "status": "modified",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/5453818a183fb4db44ebd7a543edf5daf2e7582b/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fchunking_context.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5453818a183fb4db44ebd7a543edf5daf2e7582b/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fchunking_context.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fchunking_context.rs?ref=5453818a183fb4db44ebd7a543edf5daf2e7582b",
            "patch": "@@ -67,6 +67,11 @@ impl BrowserChunkingContextBuilder {\n         self\n     }\n \n+    pub fn chunk_suffix_path(mut self, chunk_suffix_path: ResolvedVc<Option<RcStr>>) -> Self {\n+        self.chunking_context.chunk_suffix_path = chunk_suffix_path;\n+        self\n+    }\n+\n     pub fn runtime_type(mut self, runtime_type: RuntimeType) -> Self {\n         self.chunking_context.runtime_type = runtime_type;\n         self\n@@ -135,6 +140,9 @@ pub struct BrowserChunkingContext {\n     /// Base path that will be prepended to all chunk URLs when loading them.\n     /// This path will not appear in chunk paths or chunk data.\n     chunk_base_path: ResolvedVc<Option<RcStr>>,\n+    /// Suffix path that will be appended to all chunk URLs when loading them.\n+    /// This path will not appear in chunk paths or chunk data.\n+    chunk_suffix_path: ResolvedVc<Option<RcStr>>,\n     /// URL prefix that will be prepended to all static asset URLs when loading\n     /// them.\n     asset_base_path: ResolvedVc<Option<RcStr>>,\n@@ -180,6 +188,7 @@ impl BrowserChunkingContext {\n                 should_use_file_source_map_uris: false,\n                 asset_root_path,\n                 chunk_base_path: ResolvedVc::cell(None),\n+                chunk_suffix_path: ResolvedVc::cell(None),\n                 asset_base_path: ResolvedVc::cell(None),\n                 enable_hot_module_replacement: false,\n                 enable_tracing: false,\n@@ -209,6 +218,11 @@ impl BrowserChunkingContext {\n         *self.chunk_base_path\n     }\n \n+    /// Returns the asset suffix path.\n+    pub fn chunk_suffix_path(&self) -> Vc<Option<RcStr>> {\n+        *self.chunk_suffix_path\n+    }\n+\n     /// Returns the minify type.\n     pub fn source_maps_type(&self) -> SourceMapsType {\n         self.source_maps_type"
        },
        {
            "sha": "0cd8fef4af38f2d312a6a681bbbb219aa901098c",
            "filename": "turbopack/crates/turbopack-browser/src/ecmascript/evaluate/chunk.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/5453818a183fb4db44ebd7a543edf5daf2e7582b/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fecmascript%2Fevaluate%2Fchunk.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5453818a183fb4db44ebd7a543edf5daf2e7582b/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fecmascript%2Fevaluate%2Fchunk.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fecmascript%2Fevaluate%2Fchunk.rs?ref=5453818a183fb4db44ebd7a543edf5daf2e7582b",
            "patch": "@@ -153,6 +153,7 @@ impl EcmascriptBrowserEvaluateChunk {\n                 let runtime_code = turbopack_ecmascript_runtime::get_browser_runtime_code(\n                     environment,\n                     chunking_context.chunk_base_path(),\n+                    chunking_context.chunk_suffix_path(),\n                     Value::new(chunking_context.runtime_type()),\n                     output_root_to_root_path,\n                     source_maps,\n@@ -163,6 +164,7 @@ impl EcmascriptBrowserEvaluateChunk {\n                 let runtime_code = turbopack_ecmascript_runtime::get_browser_runtime_code(\n                     environment,\n                     chunking_context.chunk_base_path(),\n+                    chunking_context.chunk_suffix_path(),\n                     Value::new(chunking_context.runtime_type()),\n                     output_root_to_root_path,\n                     source_maps,"
        },
        {
            "sha": "c520cb340ae0124233849239dd9bf0a56fe7fbe9",
            "filename": "turbopack/crates/turbopack-ecmascript-runtime/js/src/browser/dev/hmr-client/hmr-client.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/5453818a183fb4db44ebd7a543edf5daf2e7582b/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fdev%2Fhmr-client%2Fhmr-client.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/5453818a183fb4db44ebd7a543edf5daf2e7582b/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fdev%2Fhmr-client%2Fhmr-client.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fdev%2Fhmr-client%2Fhmr-client.ts?ref=5453818a183fb4db44ebd7a543edf5daf2e7582b",
            "patch": "@@ -61,7 +61,7 @@ export function connect({\n     throw new Error(\"A separate HMR handler was already registered\");\n   }\n   globalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS = {\n-    push: ([chunkPath, callback]: [ChunkPath, UpdateCallback]) => {\n+    push: ([chunkPath, callback]: [ChunkListPath, UpdateCallback]) => {\n       subscribeToChunkUpdate(chunkPath, sendMessage, callback);\n     },\n   };\n@@ -202,7 +202,7 @@ function mergeChunkListChunks(\n ): Record<ChunkPath, ChunkUpdate> {\n   const chunks: Record<ChunkPath, ChunkUpdate> = {};\n \n-  for (const [chunkPath, chunkUpdateA] of Object.entries(chunksA)) {\n+  for (const [chunkPath, chunkUpdateA] of Object.entries(chunksA) as Array<[ChunkPath, ChunkUpdate]>) {\n     const chunkUpdateB = chunksB[chunkPath];\n     if (chunkUpdateB != null) {\n       const mergedUpdate = mergeChunkUpdates(chunkUpdateA, chunkUpdateB);\n@@ -214,7 +214,7 @@ function mergeChunkListChunks(\n     }\n   }\n \n-  for (const [chunkPath, chunkUpdateB] of Object.entries(chunksB)) {\n+  for (const [chunkPath, chunkUpdateB] of Object.entries(chunksB) as Array<[ChunkPath, ChunkUpdate]>) {\n     if (chunks[chunkPath] == null) {\n       chunks[chunkPath] = chunkUpdateB;\n     }\n@@ -280,7 +280,7 @@ function mergeEcmascriptChunksUpdates(\n \n   const chunks: Record<ChunkPath, EcmascriptMergedChunkUpdate> = {};\n \n-  for (const [chunkPath, chunkUpdateA] of Object.entries(chunksA)) {\n+  for (const [chunkPath, chunkUpdateA] of Object.entries(chunksA) as Array<[ChunkPath, EcmascriptMergedChunkUpdate]>) {\n     const chunkUpdateB = chunksB[chunkPath];\n     if (chunkUpdateB != null) {\n       const mergedUpdate = mergeEcmascriptChunkUpdates(\n@@ -295,7 +295,7 @@ function mergeEcmascriptChunksUpdates(\n     }\n   }\n \n-  for (const [chunkPath, chunkUpdateB] of Object.entries(chunksB)) {\n+  for (const [chunkPath, chunkUpdateB] of Object.entries(chunksB) as Array<[ChunkPath, EcmascriptMergedChunkUpdate]>) {\n     if (chunks[chunkPath] == null) {\n       chunks[chunkPath] = chunkUpdateB;\n     }\n@@ -530,13 +530,13 @@ function finalizeUpdate() {\n }\n \n function subscribeToChunkUpdate(\n-  chunkPath: ChunkPath,\n+  chunkListPath: ChunkListPath,\n   sendMessage: SendMessage,\n   callback: UpdateCallback\n ): () => void {\n   return subscribeToUpdate(\n     {\n-      path: chunkPath,\n+      path: chunkListPath,\n     },\n     sendMessage,\n     callback"
        },
        {
            "sha": "7762bad3b05e149b056db5684f2f2f21fa286692",
            "filename": "turbopack/crates/turbopack-ecmascript-runtime/js/src/browser/runtime/base/build-base.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/5453818a183fb4db44ebd7a543edf5daf2e7582b/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fbase%2Fbuild-base.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/5453818a183fb4db44ebd7a543edf5daf2e7582b/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fbase%2Fbuild-base.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fbase%2Fbuild-base.ts?ref=5453818a183fb4db44ebd7a543edf5daf2e7582b",
            "patch": "@@ -118,6 +118,7 @@ function instantiateModule(id: ModuleId, source: SourceInfo): Module {\n         c: moduleCache,\n         M: moduleFactories,\n         l: loadChunk.bind(null, sourceInfo),\n+        L: loadChunkByUrl.bind(null, sourceInfo),\n         w: loadWebAssembly.bind(null, sourceInfo),\n         u: loadWebAssemblyModule.bind(null, sourceInfo),\n         g: globalThis,"
        },
        {
            "sha": "61e48c79ccaeaa8b2340f07339f0549f1c62da2e",
            "filename": "turbopack/crates/turbopack-ecmascript-runtime/js/src/browser/runtime/base/dev-base.ts",
            "status": "modified",
            "additions": 26,
            "deletions": 19,
            "changes": 45,
            "blob_url": "https://github.com/vercel/next.js/blob/5453818a183fb4db44ebd7a543edf5daf2e7582b/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fbase%2Fdev-base.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/5453818a183fb4db44ebd7a543edf5daf2e7582b/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fbase%2Fdev-base.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fbase%2Fdev-base.ts?ref=5453818a183fb4db44ebd7a543edf5daf2e7582b",
            "patch": "@@ -51,8 +51,8 @@ type ModuleFactory = (\n ) => undefined\n \n interface DevRuntimeBackend {\n-  reloadChunk?: (chunkPath: ChunkPath) => Promise<void>;\n-  unloadChunk?: (chunkPath: ChunkPath) => void;\n+  reloadChunk?: (chunkUrl: ChunkUrl) => Promise<void>;\n+  unloadChunk?: (chunkUrl: ChunkUrl) => void;\n   restart: () => void;\n }\n \n@@ -219,6 +219,7 @@ function instantiateModule(id: ModuleId, source: SourceInfo): Module {\n           c: devModuleCache,\n           M: moduleFactories,\n           l: loadChunk.bind(null, sourceInfo),\n+          L: loadChunkByUrl.bind(null, sourceInfo),\n           w: loadWebAssembly.bind(null, sourceInfo),\n           u: loadWebAssemblyModule.bind(null, sourceInfo),\n           g: globalThis,\n@@ -596,16 +597,18 @@ function applyChunkListUpdate(update: ChunkListUpdate) {\n   }\n \n   if (update.chunks != null) {\n-    for (const [chunkPath, chunkUpdate] of Object.entries(update.chunks)) {\n+    for (const [chunkPath, chunkUpdate] of Object.entries(update.chunks) as Array<[ChunkPath, ChunkUpdate]>) {\n+      const chunkUrl = getChunkRelativeUrl(chunkPath);\n+\n       switch (chunkUpdate.type) {\n         case \"added\":\n-          BACKEND.loadChunk(chunkPath, { type: SourceType.Update });\n+          BACKEND.loadChunk(chunkUrl, { type: SourceType.Update });\n           break;\n         case \"total\":\n-          DEV_BACKEND.reloadChunk?.(chunkPath);\n+          DEV_BACKEND.reloadChunk?.(chunkUrl);\n           break;\n         case \"deleted\":\n-          DEV_BACKEND.unloadChunk?.(chunkPath);\n+          DEV_BACKEND.unloadChunk?.(chunkUrl);\n           break;\n         case \"partial\":\n           invariant(\n@@ -705,7 +708,7 @@ function computeChangedModules(\n   const modified = new Map();\n   const deleted: Set<ModuleId> = new Set();\n \n-  for (const [chunkPath, mergedChunkUpdate] of Object.entries(updates)) {\n+  for (const [chunkPath, mergedChunkUpdate] of Object.entries(updates) as Array<[ChunkPath, EcmascriptMergedChunkUpdate]>) {\n     switch (mergedChunkUpdate.type) {\n       case \"added\": {\n         const updateAdded = new Set(mergedChunkUpdate.modules);\n@@ -873,7 +876,7 @@ function getAffectedModuleEffects(moduleId: ModuleId): ModuleEffect {\n   };\n }\n \n-function handleApply(chunkListPath: ChunkPath, update: ServerMessage) {\n+function handleApply(chunkListPath: ChunkListPath, update: ServerMessage) {\n   switch (update.type) {\n     case \"partial\": {\n       // This indicates that the update is can be applied to the current state of the application.\n@@ -1014,7 +1017,7 @@ function removeModuleFromChunk(\n /**\n  * Disposes of a chunk list and its corresponding exclusive chunks.\n  */\n-function disposeChunkList(chunkListPath: ChunkPath): boolean {\n+function disposeChunkList(chunkListPath: ChunkListPath): boolean {\n   const chunkPaths = chunkListChunksMap.get(chunkListPath);\n   if (chunkPaths == null) {\n     return false;\n@@ -1033,7 +1036,9 @@ function disposeChunkList(chunkListPath: ChunkPath): boolean {\n \n   // We must also dispose of the chunk list's chunk itself to ensure it may\n   // be reloaded properly in the future.\n-  DEV_BACKEND.unloadChunk?.(chunkListPath);\n+  const chunkListUrl = getChunkRelativeUrl(chunkListPath)\n+\n+  DEV_BACKEND.unloadChunk?.(chunkListUrl);\n \n   return true;\n }\n@@ -1044,9 +1049,10 @@ function disposeChunkList(chunkListPath: ChunkPath): boolean {\n  * @returns Whether the chunk was disposed of.\n  */\n function disposeChunk(chunkPath: ChunkPath): boolean {\n+  const chunkUrl = getChunkRelativeUrl(chunkPath)\n   // This should happen whether the chunk has any modules in it or not.\n   // For instance, CSS chunks have no modules in them, but they still need to be unloaded.\n-  DEV_BACKEND.unloadChunk?.(chunkPath);\n+  DEV_BACKEND.unloadChunk?.(chunkUrl);\n \n   const chunkModules = chunkModulesMap.get(chunkPath);\n   if (chunkModules == null) {\n@@ -1077,26 +1083,27 @@ function registerChunkList(\n   chunkUpdateProvider: ChunkUpdateProvider,\n   chunkList: ChunkList\n ) {\n+  const chunkListPath = chunkList.path;\n   chunkUpdateProvider.push([\n-    chunkList.path,\n-    handleApply.bind(null, chunkList.path),\n+    chunkListPath,\n+    handleApply.bind(null, chunkListPath),\n   ]);\n \n   // Adding chunks to chunk lists and vice versa.\n-  const chunks = new Set(chunkList.chunks.map(getChunkPath));\n-  chunkListChunksMap.set(chunkList.path, chunks);\n-  for (const chunkPath of chunks) {\n+  const chunkPaths = new Set(chunkList.chunks.map(getChunkPath));\n+  chunkListChunksMap.set(chunkListPath, chunkPaths);\n+  for (const chunkPath of chunkPaths) {\n     let chunkChunkLists = chunkChunkListsMap.get(chunkPath);\n     if (!chunkChunkLists) {\n-      chunkChunkLists = new Set([chunkList.path]);\n+      chunkChunkLists = new Set([chunkListPath]);\n       chunkChunkListsMap.set(chunkPath, chunkChunkLists);\n     } else {\n-      chunkChunkLists.add(chunkList.path);\n+      chunkChunkLists.add(chunkListPath);\n     }\n   }\n \n   if (chunkList.source === \"entry\") {\n-    markChunkListAsRuntime(chunkList.path);\n+    markChunkListAsRuntime(chunkListPath);\n   }\n }\n "
        },
        {
            "sha": "289102e3c60be4dbd4620e87e6a19a88ae36f351",
            "filename": "turbopack/crates/turbopack-ecmascript-runtime/js/src/browser/runtime/base/dev-globals.d.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/5453818a183fb4db44ebd7a543edf5daf2e7582b/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fbase%2Fdev-globals.d.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/5453818a183fb4db44ebd7a543edf5daf2e7582b/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fbase%2Fdev-globals.d.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fbase%2Fdev-globals.d.ts?ref=5453818a183fb4db44ebd7a543edf5daf2e7582b",
            "patch": "@@ -8,12 +8,12 @@\n type UpdateCallback = (update: ServerMessage) => void;\n \n type ChunkUpdateProvider = {\n-  push: (registration: [ChunkPath, UpdateCallback]) => void;\n+  push: (registration: [ChunkListPath, UpdateCallback]) => void;\n };\n \n declare var TURBOPACK_CHUNK_UPDATE_LISTENERS:\n   | ChunkUpdateProvider\n-  | [ChunkPath, UpdateCallback][]\n+  | [ChunkListPath, UpdateCallback][]\n   | undefined;\n // This is used by the Next.js integration test suite to notify it when HMR\n // updates have been completed."
        },
        {
            "sha": "8a91c01f0fdcf840311d25447f0ee3fb830d10ab",
            "filename": "turbopack/crates/turbopack-ecmascript-runtime/js/src/browser/runtime/base/runtime-base.ts",
            "status": "modified",
            "additions": 39,
            "deletions": 17,
            "changes": 56,
            "blob_url": "https://github.com/vercel/next.js/blob/5453818a183fb4db44ebd7a543edf5daf2e7582b/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fbase%2Fruntime-base.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/5453818a183fb4db44ebd7a543edf5daf2e7582b/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fbase%2Fruntime-base.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fbase%2Fruntime-base.ts?ref=5453818a183fb4db44ebd7a543edf5daf2e7582b",
            "patch": "@@ -13,6 +13,7 @@\n \n declare var TURBOPACK_WORKER_LOCATION: string;\n declare var CHUNK_BASE_PATH: string;\n+declare var CHUNK_SUFFIX_PATH: string;\n declare function instantiateModule(id: ModuleId, source: SourceInfo): Module;\n \n type RuntimeParams = {\n@@ -27,7 +28,7 @@ type ChunkRegistration = [\n ];\n \n type ChunkList = {\n-  path: ChunkPath;\n+  path: ChunkListPath;\n   chunks: ChunkData[];\n   source: \"entry\" | \"dynamic\";\n };\n@@ -65,12 +66,12 @@ type SourceInfo =\n \n interface RuntimeBackend {\n   registerChunk: (chunkPath: ChunkPath, params?: RuntimeParams) => void;\n-  loadChunk: (chunkPath: ChunkPath, source: SourceInfo) => Promise<void>;\n+  loadChunk: (chunkUrl: ChunkUrl, source: SourceInfo) => Promise<void>;\n }\n \n interface DevRuntimeBackend {\n-  reloadChunk?: (chunkPath: ChunkPath) => Promise<void>;\n-  unloadChunk?: (chunkPath: ChunkPath) => void;\n+  reloadChunk?: (chunkUrl: ChunkUrl) => Promise<void>;\n+  unloadChunk?: (chunkUrl: ChunkUrl) => void;\n   restart: () => void;\n }\n \n@@ -90,21 +91,21 @@ const moduleChunksMap: Map<ModuleId, Set<ChunkPath>> = new Map();\n /**\n  * Map from a chunk path to all modules it contains.\n  */\n-const chunkModulesMap: Map<ModuleId, Set<ChunkPath>> = new Map();\n+const chunkModulesMap: Map<ChunkPath, Set<ModuleId>> = new Map();\n /**\n  * Chunk lists that contain a runtime. When these chunk lists receive an update\n  * that can't be reconciled with the current state of the page, we need to\n  * reload the runtime entirely.\n  */\n-const runtimeChunkLists: Set<ChunkPath> = new Set();\n+const runtimeChunkLists: Set<ChunkListPath> = new Set();\n /**\n  * Map from a chunk list to the chunk paths it contains.\n  */\n-const chunkListChunksMap: Map<ChunkPath, Set<ChunkPath>> = new Map();\n+const chunkListChunksMap: Map<ChunkListPath, Set<ChunkPath>> = new Map();\n /**\n  * Map from a chunk path to the chunk lists it belongs to.\n  */\n-const chunkChunkListsMap: Map<ChunkPath, Set<ChunkPath>> = new Map();\n+const chunkChunkListsMap: Map<ChunkPath, Set<ChunkListPath>> = new Map();\n \n const availableModules: Map<ModuleId, Promise<any> | true> = new Map();\n \n@@ -184,12 +185,9 @@ async function loadChunk(\n   return promise;\n }\n \n-async function loadChunkPath(\n-  source: SourceInfo,\n-  chunkPath: ChunkPath\n-): Promise<any> {\n+async function loadChunkByUrl(source: SourceInfo, chunkUrl: ChunkUrl) {\n   try {\n-    await BACKEND.loadChunk(chunkPath, source);\n+    await BACKEND.loadChunk(chunkUrl, source);\n   } catch (error) {\n     let loadReason;\n     switch (source.type) {\n@@ -206,7 +204,7 @@ async function loadChunkPath(\n         invariant(source, (source) => `Unknown source type: ${source?.type}`);\n     }\n     throw new Error(\n-      `Failed to load chunk ${chunkPath} ${loadReason}${\n+      `Failed to load chunk ${chunkUrl} ${loadReason}${\n         error ? `: ${error}` : \"\"\n       }`,\n       error\n@@ -218,6 +216,14 @@ async function loadChunkPath(\n   }\n }\n \n+async function loadChunkPath(\n+  source: SourceInfo,\n+  chunkPath: ChunkPath\n+): Promise<any> {\n+  const url = getChunkRelativeUrl(chunkPath);\n+  return loadChunkByUrl(source, url);\n+}\n+\n /**\n  * Returns an absolute url to an asset.\n  */\n@@ -292,19 +298,19 @@ function instantiateRuntimeModule(\n /**\n  * Returns the URL relative to the origin where a chunk can be fetched from.\n  */\n-function getChunkRelativeUrl(chunkPath: ChunkPath): string {\n+function getChunkRelativeUrl(chunkPath: ChunkPath | ChunkListPath): ChunkUrl {\n   return `${CHUNK_BASE_PATH}${chunkPath\n     .split(\"/\")\n     .map((p) => encodeURIComponent(p))\n-    .join(\"/\")}`;\n+    .join(\"/\")}${CHUNK_SUFFIX_PATH}` as ChunkUrl;\n }\n \n /**\n  * Marks a chunk list as a runtime chunk list. There can be more than one\n  * runtime chunk list. For instance, integration tests can have multiple chunk\n  * groups loaded at runtime, each with its own chunk list.\n  */\n-function markChunkListAsRuntime(chunkListPath: ChunkPath) {\n+function markChunkListAsRuntime(chunkListPath: ChunkListPath) {\n   runtimeChunkLists.add(chunkListPath);\n }\n \n@@ -322,3 +328,19 @@ function registerChunk([\n \n   return BACKEND.registerChunk(chunkPath, runtimeParams);\n }\n+\n+const regexJsUrl = /\\.js(?:\\?[^#]*)?(?:#.*)?$/;\n+/**\n+ * Checks if a given path/URL ends with .js, optionally followed by ?query or #fragment.\n+ */\n+function isJs(chunkUrlOrPath: ChunkUrl | ChunkPath): boolean {\n+  return regexJsUrl.test(chunkUrlOrPath);\n+}\n+\n+const regexCssUrl = /\\.css(?:\\?[^#]*)?(?:#.*)?$/;\n+/**\n+ * Checks if a given path/URL ends with .css, optionally followed by ?query or #fragment.\n+ */\n+function isCss(chunkUrl: ChunkUrl): boolean {\n+  return regexCssUrl.test(chunkUrl);\n+}"
        },
        {
            "sha": "ddc0fb4d2a5707691b4f711f0b4aed347758a295",
            "filename": "turbopack/crates/turbopack-ecmascript-runtime/js/src/browser/runtime/dom/dev-backend-dom.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 14,
            "changes": 25,
            "blob_url": "https://github.com/vercel/next.js/blob/5453818a183fb4db44ebd7a543edf5daf2e7582b/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fdom%2Fdev-backend-dom.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/5453818a183fb4db44ebd7a543edf5daf2e7582b/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fdom%2Fdev-backend-dom.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fdom%2Fdev-backend-dom.ts?ref=5453818a183fb4db44ebd7a543edf5daf2e7582b",
            "patch": "@@ -16,21 +16,20 @@ let DEV_BACKEND: DevRuntimeBackend;\n \n (() => {\n   DEV_BACKEND = {\n-    unloadChunk(chunkPath) {\n-      deleteResolver(chunkPath);\n+    unloadChunk(chunkUrl) {\n+      deleteResolver(chunkUrl);\n \n-      const chunkUrl = getChunkRelativeUrl(chunkPath);\n       // TODO(PACK-2140): remove this once all filenames are guaranteed to be escaped.\n       const decodedChunkUrl = decodeURI(chunkUrl);\n \n-      if (chunkPath.endsWith(\".css\")) {\n+      if (isCss(chunkUrl)) {\n         const links = document.querySelectorAll(\n           `link[href=\"${chunkUrl}\"],link[href^=\"${chunkUrl}?\"],link[href=\"${decodedChunkUrl}\"],link[href^=\"${decodedChunkUrl}?\"]`\n         );\n         for (const link of Array.from(links)) {\n           link.remove();\n         }\n-      } else if (chunkPath.endsWith(\".js\")) {\n+      } else if (isJs(chunkUrl)) {\n         // Unloading a JS chunk would have no effect, as it lives in the JS\n         // runtime once evaluated.\n         // However, we still want to remove the script tag from the DOM to keep\n@@ -42,26 +41,24 @@ let DEV_BACKEND: DevRuntimeBackend;\n           script.remove();\n         }\n       } else {\n-        throw new Error(`can't infer type of chunk from path ${chunkPath}`);\n+        throw new Error(`can't infer type of chunk from URL ${chunkUrl}`);\n       }\n     },\n \n-    reloadChunk(chunkPath) {\n+    reloadChunk(chunkUrl) {\n       return new Promise<void>((resolve, reject) => {\n-        if (!chunkPath.endsWith(\".css\")) {\n+        if (!isCss(chunkUrl)) {\n           reject(new Error(\"The DOM backend can only reload CSS chunks\"));\n           return;\n         }\n \n-        const chunkUrl = getChunkRelativeUrl(chunkPath);\n         const decodedChunkUrl = decodeURI(chunkUrl);\n-\n         const previousLinks = document.querySelectorAll(\n           `link[rel=stylesheet][href=\"${chunkUrl}\"],link[rel=stylesheet][href^=\"${chunkUrl}?\"],link[rel=stylesheet][href=\"${decodedChunkUrl}\"],link[rel=stylesheet][href^=\"${decodedChunkUrl}?\"]`\n         );\n \n         if (previousLinks.length === 0) {\n-          reject(new Error(`No link element found for chunk ${chunkPath}`));\n+          reject(new Error(`No link element found for chunk ${chunkUrl}`));\n           return;\n         }\n \n@@ -108,14 +105,14 @@ let DEV_BACKEND: DevRuntimeBackend;\n     restart: () => self.location.reload(),\n   };\n \n-  function deleteResolver(chunkPath: ChunkPath) {\n-    chunkResolvers.delete(chunkPath);\n+  function deleteResolver(chunkUrl: ChunkUrl) {\n+    chunkResolvers.delete(chunkUrl);\n   }\n })();\n \n function _eval({ code, url, map }: EcmascriptModuleEntry): ModuleFactory {\n   code += `\\n\\n//# sourceURL=${encodeURI(\n-    location.origin + CHUNK_BASE_PATH + url\n+    location.origin + CHUNK_BASE_PATH + url + CHUNK_SUFFIX_PATH\n   )}`;\n   if (map) {\n     code += `\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,${btoa("
        },
        {
            "sha": "7050e489c301dc4682d0770a569a82f93dfa13f0",
            "filename": "turbopack/crates/turbopack-ecmascript-runtime/js/src/browser/runtime/dom/runtime-backend-dom.ts",
            "status": "modified",
            "additions": 34,
            "deletions": 25,
            "changes": 59,
            "blob_url": "https://github.com/vercel/next.js/blob/5453818a183fb4db44ebd7a543edf5daf2e7582b/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fdom%2Fruntime-backend-dom.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/5453818a183fb4db44ebd7a543edf5daf2e7582b/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fdom%2Fruntime-backend-dom.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fdom%2Fruntime-backend-dom.ts?ref=5453818a183fb4db44ebd7a543edf5daf2e7582b",
            "patch": "@@ -51,22 +51,26 @@ async function loadWebAssemblyModule(\n /**\n  * Maps chunk paths to the corresponding resolver.\n  */\n-const chunkResolvers: Map<ChunkPath, ChunkResolver> = new Map();\n+const chunkResolvers: Map<ChunkUrl, ChunkResolver> = new Map();\n \n (() => {\n   BACKEND = {\n     async registerChunk(chunkPath, params) {\n-      const resolver = getOrCreateResolver(chunkPath);\n+      const chunkUrl = getChunkRelativeUrl(chunkPath);\n+\n+      const resolver = getOrCreateResolver(chunkUrl);\n       resolver.resolve();\n \n       if (params == null) {\n         return;\n       }\n \n       for (const otherChunkData of params.otherChunks) {\n-        const otherChunkPath = getChunkPath(otherChunkData);\n+        const otherChunkPath = getChunkPath(otherChunkData)\n+        const otherChunkUrl = getChunkRelativeUrl(otherChunkPath);\n+\n         // Chunk might have started loading, so we want to avoid triggering another load.\n-        getOrCreateResolver(otherChunkPath);\n+        getOrCreateResolver(otherChunkUrl);\n       }\n \n       // This waits for chunks to be loaded, but also marks included items as available.\n@@ -83,13 +87,17 @@ const chunkResolvers: Map<ChunkPath, ChunkResolver> = new Map();\n       }\n     },\n \n-    loadChunk(chunkPath, source) {\n-      return doLoadChunk(chunkPath, source);\n+    /**\n+     * Loads the given chunk, and returns a promise that resolves once the chunk\n+     * has been loaded.\n+    */\n+    loadChunk(chunkUrl, source) {\n+      return doLoadChunk(chunkUrl, source);\n     },\n   };\n \n-  function getOrCreateResolver(chunkPath: ChunkPath): ChunkResolver {\n-    let resolver = chunkResolvers.get(chunkPath);\n+  function getOrCreateResolver(chunkUrl: ChunkUrl): ChunkResolver {\n+    let resolver = chunkResolvers.get(chunkUrl);\n     if (!resolver) {\n       let resolve: () => void;\n       let reject: (error?: Error) => void;\n@@ -106,17 +114,17 @@ const chunkResolvers: Map<ChunkPath, ChunkResolver> = new Map();\n         },\n         reject: reject!,\n       };\n-      chunkResolvers.set(chunkPath, resolver);\n+      chunkResolvers.set(chunkUrl, resolver);\n     }\n     return resolver;\n   }\n \n-  /**\n-   * Loads the given chunk, and returns a promise that resolves once the chunk\n-   * has been loaded.\n-   */\n-  async function doLoadChunk(chunkPath: ChunkPath, source: SourceInfo) {\n-    const resolver = getOrCreateResolver(chunkPath);\n+   /**\n+    * Loads the given chunk, and returns a promise that resolves once the chunk\n+    * has been loaded.\n+    */\n+  function doLoadChunk(chunkUrl: ChunkUrl, source: SourceInfo) {\n+    const resolver = getOrCreateResolver(chunkUrl);\n     if (resolver.resolved) {\n       return resolver.promise;\n     }\n@@ -125,7 +133,7 @@ const chunkResolvers: Map<ChunkPath, ChunkResolver> = new Map();\n       // We don't need to load chunks references from runtime code, as they're already\n       // present in the DOM.\n \n-      if (chunkPath.endsWith(\".css\")) {\n+      if (isCss(chunkUrl)) {\n         // CSS chunks do not register themselves, and as such must be marked as\n         // loaded instantly.\n         resolver.resolve();\n@@ -138,20 +146,20 @@ const chunkResolvers: Map<ChunkPath, ChunkResolver> = new Map();\n       return resolver.promise;\n     }\n \n-    const chunkUrl = getChunkRelativeUrl(chunkPath);\n-    const decodedChunkUrl = decodeURI(chunkUrl);\n-\n     if (typeof importScripts === \"function\") {\n       // We're in a web worker\n-      if (chunkPath.endsWith(\".css\")) {\n+      if (isCss(chunkUrl)) {\n         // ignore\n-      } else if (chunkPath.endsWith(\".js\")) {\n+      } else if (isJs(chunkUrl)) {\n         importScripts(TURBOPACK_WORKER_LOCATION + chunkUrl);\n       } else {\n-        throw new Error(`can't infer type of chunk from path ${chunkPath} in worker`);\n+        throw new Error(`can't infer type of chunk from URL ${chunkUrl} in worker`);\n       }\n     } else {\n-      if (chunkPath.endsWith(\".css\")) {\n+      // TODO(PACK-2140): remove this once all filenames are guaranteed to be escaped.\n+      const decodedChunkUrl = decodeURI(chunkUrl);\n+\n+      if (isCss(chunkUrl)) {\n         const previousLinks = document.querySelectorAll(\n           `link[rel=stylesheet][href=\"${chunkUrl}\"],link[rel=stylesheet][href^=\"${chunkUrl}?\"],link[rel=stylesheet][href=\"${decodedChunkUrl}\"],link[rel=stylesheet][href^=\"${decodedChunkUrl}?\"]`\n         );\n@@ -173,7 +181,7 @@ const chunkResolvers: Map<ChunkPath, ChunkResolver> = new Map();\n           };\n           document.body.appendChild(link);\n         }\n-      } else if (chunkPath.endsWith(\".js\")) {\n+      } else if (isJs(chunkUrl)) {\n         const previousScripts = document.querySelectorAll(\n           `script[src=\"${chunkUrl}\"],script[src^=\"${chunkUrl}?\"],script[src=\"${decodedChunkUrl}\"],script[src^=\"${decodedChunkUrl}?\"]`\n         );\n@@ -197,10 +205,11 @@ const chunkResolvers: Map<ChunkPath, ChunkResolver> = new Map();\n           document.body.appendChild(script);\n         }\n       } else {\n-        throw new Error(`can't infer type of chunk from path ${chunkPath}`);\n+        throw new Error(`can't infer type of chunk from URL ${chunkUrl}`);\n       }\n     }\n \n     return resolver.promise;\n   }\n+\n })();"
        },
        {
            "sha": "fbc931f5faa03cbeac016330af5fc984c5b55871",
            "filename": "turbopack/crates/turbopack-ecmascript-runtime/js/src/browser/runtime/edge/runtime-backend-edge.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/5453818a183fb4db44ebd7a543edf5daf2e7582b/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fedge%2Fruntime-backend-edge.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/5453818a183fb4db44ebd7a543edf5daf2e7582b/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fedge%2Fruntime-backend-edge.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fedge%2Fruntime-backend-edge.ts?ref=5453818a183fb4db44ebd7a543edf5daf2e7582b",
            "patch": "@@ -112,14 +112,14 @@ async function loadWebAssemblyModule(\n           chunkPath,\n           params.otherChunks.filter((chunk) =>\n             // The none runtime can only handle JS chunks, so we only wait for these\n-            getChunkPath(chunk).endsWith(\".js\")\n+            isJs(getChunkPath(chunk))\n           ),\n           params.runtimeModuleIds\n         );\n       }\n     },\n \n-    loadChunk(_chunkPath, _fromChunkPath) {\n+    loadChunk(_chunkUrl, _source) {\n       throw new Error(\"chunk loading is not supported\");\n     },\n   };"
        },
        {
            "sha": "e07abd2e46ce4ea3b15656e0b9e61357e1d18f60",
            "filename": "turbopack/crates/turbopack-ecmascript-runtime/js/src/nodejs/runtime.ts",
            "status": "modified",
            "additions": 16,
            "deletions": 2,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/5453818a183fb4db44ebd7a543edf5daf2e7582b/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fnodejs%2Fruntime.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/5453818a183fb4db44ebd7a543edf5daf2e7582b/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fnodejs%2Fruntime.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fnodejs%2Fruntime.ts?ref=5453818a183fb4db44ebd7a543edf5daf2e7582b",
            "patch": "@@ -94,7 +94,7 @@ function loadChunk(chunkData: ChunkData, source?: SourceInfo): void {\n }\n \n function loadChunkPath(chunkPath: ChunkPath, source?: SourceInfo): void {\n-  if (!chunkPath.endsWith(\".js\")) {\n+  if (!isJs(chunkPath)) {\n     // We only support loading JS chunks in Node.js.\n     // This branch can be hit when trying to load a CSS chunk.\n     return;\n@@ -127,7 +127,7 @@ async function loadChunkAsync(\n   chunkData: ChunkData\n ): Promise<any> {\n   const chunkPath = typeof chunkData === \"string\" ? chunkData : chunkData.path;\n-  if (!chunkPath.endsWith(\".js\")) {\n+  if (!isJs(chunkPath)) {\n     // We only support loading JS chunks in Node.js.\n     // This branch can be hit when trying to load a CSS chunk.\n     return;\n@@ -173,6 +173,11 @@ async function loadChunkAsync(\n   }\n }\n \n+async function loadChunkAsyncByUrl(source: SourceInfo, chunkUrl: string) {\n+  const path = url.fileURLToPath(new URL(chunkUrl, RUNTIME_ROOT)) as ChunkPath;\n+  return loadChunkAsync(source, path);\n+}\n+\n function loadWebAssembly(chunkPath: ChunkPath, imports: WebAssembly.Imports) {\n   const resolved = path.resolve(RUNTIME_ROOT, chunkPath);\n \n@@ -256,6 +261,7 @@ function instantiateModule(id: ModuleId, source: SourceInfo): ModuleWithDirectio\n       c: moduleCache,\n       M: moduleFactories,\n       l: loadChunkAsync.bind(null, { type: SourceType.Parent, parentId: id }),\n+      L: loadChunkAsyncByUrl.bind(null, { type: SourceType.Parent, parentId: id }),\n       w: loadWebAssembly,\n       u: loadWebAssemblyModule,\n       g: globalThis,\n@@ -337,6 +343,14 @@ function getOrInstantiateRuntimeModule(\n   return instantiateRuntimeModule(moduleId, chunkPath);\n }\n \n+const regexJsUrl = /\\.js(?:\\?[^#]*)?(?:#.*)?$/;\n+/**\n+ * Checks if a given path/URL ends with .js, optionally followed by ?query or #fragment.\n+ */\n+function isJs(chunkUrlOrPath: ChunkUrl | ChunkPath): boolean {\n+  return regexJsUrl.test(chunkUrlOrPath);\n+}\n+\n module.exports = {\n   getOrInstantiateRuntimeModule,\n   loadChunk,"
        },
        {
            "sha": "a01a713010ddecba080432b89306168bfe7c7a41",
            "filename": "turbopack/crates/turbopack-ecmascript-runtime/js/src/shared/runtime-types.d.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/5453818a183fb4db44ebd7a543edf5daf2e7582b/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fshared%2Fruntime-types.d.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/5453818a183fb4db44ebd7a543edf5daf2e7582b/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fshared%2Fruntime-types.d.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fshared%2Fruntime-types.d.ts?ref=5453818a183fb4db44ebd7a543edf5daf2e7582b",
            "patch": "@@ -7,7 +7,9 @@\n  * specific to the runtime context.\n  */\n \n-type ChunkPath = string;\n+type ChunkListPath = string & { readonly brand: unique symbol };\n+type ChunkPath = string & { readonly brand: unique symbol };\n+type ChunkUrl = string & { readonly brand: unique symbol };\n type ModuleId = string;\n \n interface Exports {\n@@ -37,6 +39,7 @@ type ExportNamespace = (namespace: any) => void;\n type DynamicExport = (object: Record<string, any>) => void;\n \n type LoadChunk = (chunkPath: ChunkPath) => Promise<any> | undefined;\n+type LoadChunkByUrl = (chunkUrl: ChunkUrl) => Promise<any> | undefined;\n type LoadWebAssembly = (\n   wasmChunkPath: ChunkPath,\n   imports: WebAssembly.Imports\n@@ -95,6 +98,7 @@ interface TurbopackBaseContext<M> {\n   c: ModuleCache<M>;\n   M: ModuleFactories;\n   l: LoadChunk;\n+  L: LoadChunkByUrl;\n   w: LoadWebAssembly;\n   u: LoadWebAssemblyModule;\n   g: typeof globalThis;"
        },
        {
            "sha": "4c7b2f67a4d3b794ae8a97abd8e940173befaf01",
            "filename": "turbopack/crates/turbopack-ecmascript-runtime/src/browser_runtime.rs",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/5453818a183fb4db44ebd7a543edf5daf2e7582b/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fsrc%2Fbrowser_runtime.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5453818a183fb4db44ebd7a543edf5daf2e7582b/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fsrc%2Fbrowser_runtime.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fsrc%2Fbrowser_runtime.rs?ref=5453818a183fb4db44ebd7a543edf5daf2e7582b",
            "patch": "@@ -18,6 +18,7 @@ use crate::{asset_context::get_runtime_asset_context, embed_js::embed_static_cod\n pub async fn get_browser_runtime_code(\n     environment: Vc<Environment>,\n     chunk_base_path: Vc<Option<RcStr>>,\n+    chunk_suffix_path: Vc<Option<RcStr>>,\n     runtime_type: Value<RuntimeType>,\n     output_root_to_root_path: Vc<RcStr>,\n     generate_source_map: bool,\n@@ -80,6 +81,10 @@ pub async fn get_browser_runtime_code(\n     let relative_root_path = output_root_to_root_path.await?;\n     let chunk_base_path = &*chunk_base_path.await?;\n     let chunk_base_path = chunk_base_path.as_ref().map_or_else(|| \"\", |f| f.as_str());\n+    let chunk_suffix_path = &*chunk_suffix_path.await?;\n+    let chunk_suffix_path = chunk_suffix_path\n+        .as_ref()\n+        .map_or_else(|| \"\", |f| f.as_str());\n \n     writedoc!(\n         code,\n@@ -90,10 +95,12 @@ pub async fn get_browser_runtime_code(\n             }}\n \n             const CHUNK_BASE_PATH = {};\n+            const CHUNK_SUFFIX_PATH = {};\n             const RELATIVE_ROOT_PATH = {};\n             const RUNTIME_PUBLIC_PATH = {};\n         \"#,\n         StringifyJs(chunk_base_path),\n+        StringifyJs(chunk_suffix_path),\n         StringifyJs(relative_root_path.as_str()),\n         StringifyJs(chunk_base_path),\n     )?;"
        },
        {
            "sha": "aeca34d79988873652b827fe2742b2c1cf842e0b",
            "filename": "turbopack/crates/turbopack-ecmascript/src/runtime_functions.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/5453818a183fb4db44ebd7a543edf5daf2e7582b/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fruntime_functions.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5453818a183fb4db44ebd7a543edf5daf2e7582b/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fruntime_functions.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fruntime_functions.rs?ref=5453818a183fb4db44ebd7a543edf5daf2e7582b",
            "patch": "@@ -54,6 +54,8 @@ pub const TURBOPACK_MODULES: &TurbopackRuntimeFunctionShortcut =\n     &TurbopackRuntimeFunctionShortcut::new(\"__turbopack_context__.M\", \"M\");\n pub const TURBOPACK_LOAD: &TurbopackRuntimeFunctionShortcut =\n     &TurbopackRuntimeFunctionShortcut::new(\"__turbopack_context__.l\", \"l\");\n+pub const TURBOPACK_LOAD_BY_URL: &TurbopackRuntimeFunctionShortcut =\n+    &TurbopackRuntimeFunctionShortcut::new(\"__turbopack_context__.L\", \"L\");\n pub const TURBOPACK_DYNAMIC: &TurbopackRuntimeFunctionShortcut =\n     &TurbopackRuntimeFunctionShortcut::new(\"__turbopack_context__.j\", \"j\");\n pub const TURBOPACK_RESOLVE_ABSOLUTE_PATH: &TurbopackRuntimeFunctionShortcut =\n@@ -77,7 +79,7 @@ pub const TURBOPACK_REQUIRE_STUB: &TurbopackRuntimeFunctionShortcut =\n pub const TURBOPACK_REQUIRE_REAL: &TurbopackRuntimeFunctionShortcut =\n     &TurbopackRuntimeFunctionShortcut::new(\"__turbopack_context__.t\", \"t\");\n \n-pub const TUBROPACK_RUNTIME_FUNCTION_SHORTCUTS: [(&str, &TurbopackRuntimeFunctionShortcut); 20] = [\n+pub const TUBROPACK_RUNTIME_FUNCTION_SHORTCUTS: [(&str, &TurbopackRuntimeFunctionShortcut); 21] = [\n     (\"__turbopack_require__\", TURBOPACK_REQUIRE),\n     (\"__turbopack_module_context__\", TURBOPACK_MODULE_CONTEXT),\n     (\"__turbopack_import__\", TURBOPACK_IMPORT),\n@@ -87,6 +89,7 @@ pub const TUBROPACK_RUNTIME_FUNCTION_SHORTCUTS: [(&str, &TurbopackRuntimeFunctio\n     (\"__turbopack_cache__\", TURBOPACK_CACHE),\n     (\"__turbopack_modules__\", TURBOPACK_MODULES),\n     (\"__turbopack_load__\", TURBOPACK_LOAD),\n+    (\"__turbopack_load_by_url__\", TURBOPACK_LOAD_BY_URL),\n     (\"__turbopack_dynamic__\", TURBOPACK_DYNAMIC),\n     (\n         \"__turbopack_resolve_absolute_path__\","
        },
        {
            "sha": "310acc90c23c832df7b2d76c083e3b18a4ba3e25",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/runtime/default_build_runtime/output/[turbopack]_runtime.js",
            "status": "modified",
            "additions": 17,
            "deletions": 3,
            "changes": 20,
            "blob_url": "https://github.com/vercel/next.js/blob/5453818a183fb4db44ebd7a543edf5daf2e7582b/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_build_runtime%2Foutput%2F%5Bturbopack%5D_runtime.js",
            "raw_url": "https://github.com/vercel/next.js/raw/5453818a183fb4db44ebd7a543edf5daf2e7582b/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_build_runtime%2Foutput%2F%5Bturbopack%5D_runtime.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_build_runtime%2Foutput%2F%5Bturbopack%5D_runtime.js?ref=5453818a183fb4db44ebd7a543edf5daf2e7582b",
            "patch": "@@ -466,7 +466,7 @@ function loadChunk(chunkData, source) {\n     }\n }\n function loadChunkPath(chunkPath, source) {\n-    if (!chunkPath.endsWith(\".js\")) {\n+    if (!isJs(chunkPath)) {\n         // We only support loading JS chunks in Node.js.\n         // This branch can be hit when trying to load a CSS chunk.\n         return;\n@@ -491,7 +491,7 @@ function loadChunkPath(chunkPath, source) {\n }\n async function loadChunkAsync(source, chunkData) {\n     const chunkPath = typeof chunkData === \"string\" ? chunkData : chunkData.path;\n-    if (!chunkPath.endsWith(\".js\")) {\n+    if (!isJs(chunkPath)) {\n         // We only support loading JS chunks in Node.js.\n         // This branch can be hit when trying to load a CSS chunk.\n         return;\n@@ -529,6 +529,10 @@ async function loadChunkAsync(source, chunkData) {\n         });\n     }\n }\n+async function loadChunkAsyncByUrl(source, chunkUrl) {\n+    const path1 = url.fileURLToPath(new URL(chunkUrl, RUNTIME_ROOT));\n+    return loadChunkAsync(source, path1);\n+}\n function loadWebAssembly(chunkPath, imports) {\n     const resolved = path.resolve(RUNTIME_ROOT, chunkPath);\n     return instantiateWebAssemblyFromPath(resolved, imports);\n@@ -607,6 +611,10 @@ function instantiateModule(id, source) {\n                 type: 1,\n                 parentId: id\n             }),\n+            L: loadChunkAsyncByUrl.bind(null, {\n+                type: 1,\n+                parentId: id\n+            }),\n             w: loadWebAssembly,\n             u: loadWebAssemblyModule,\n             g: globalThis,\n@@ -668,7 +676,13 @@ function getOrInstantiateRuntimeModule(moduleId, chunkPath) {\n     }\n     return instantiateRuntimeModule(moduleId, chunkPath);\n }\n+const regexJsUrl = /\\.js(?:\\?[^#]*)?(?:#.*)?$/;\n+/**\n+ * Checks if a given path/URL ends with .js, optionally followed by ?query or #fragment.\n+ */ function isJs(chunkUrlOrPath) {\n+    return regexJsUrl.test(chunkUrlOrPath);\n+}\n module.exports = {\n     getOrInstantiateRuntimeModule,\n     loadChunk\n-};\n+};\n\\ No newline at end of file"
        },
        {
            "sha": "a86fd5bf32c5e97e36f7ab91c7d1d124491bf07d",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/runtime/default_build_runtime/output/[turbopack]_runtime.js.map",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/5453818a183fb4db44ebd7a543edf5daf2e7582b/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_build_runtime%2Foutput%2F%5Bturbopack%5D_runtime.js.map",
            "raw_url": "https://github.com/vercel/next.js/raw/5453818a183fb4db44ebd7a543edf5daf2e7582b/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_build_runtime%2Foutput%2F%5Bturbopack%5D_runtime.js.map",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_build_runtime%2Foutput%2F%5Bturbopack%5D_runtime.js.map?ref=5453818a183fb4db44ebd7a543edf5daf2e7582b",
            "patch": "@@ -6,5 +6,5 @@\n     {\"offset\": {\"line\": 338, \"column\": 0}, \"map\": {\"version\":3,\"sources\":[\"turbopack:///[turbopack]/shared-node/base-externals-utils.ts\"],\"sourcesContent\":[\"/* eslint-disable @typescript-eslint/no-unused-vars */\\n\\n/// <reference path=\\\"../shared/runtime-utils.ts\\\" />\\n\\n/// A 'base' utilities to support runtime can have externals.\\n/// Currently this is for node.js / edge runtime both.\\n/// If a fn requires node.js specific behavior, it should be placed in `node-external-utils` instead.\\n\\nasync function externalImport(id: ModuleId) {\\n  let raw\\n  try {\\n    raw = await import(id)\\n  } catch (err) {\\n    // TODO(alexkirsz) This can happen when a client-side module tries to load\\n    // an external module we don't provide a shim for (e.g. querystring, url).\\n    // For now, we fail semi-silently, but in the future this should be a\\n    // compilation error.\\n    throw new Error(`Failed to load external module ${id}: ${err}`)\\n  }\\n\\n  if (raw && raw.__esModule && raw.default && 'default' in raw.default) {\\n    return interopEsm(raw.default, createNS(raw), true)\\n  }\\n\\n  return raw\\n}\\n\\nfunction externalRequire(\\n  id: ModuleId,\\n  thunk: () => any,\\n  esm: boolean = false\\n): Exports | EsmNamespaceObject {\\n  let raw\\n  try {\\n    raw = thunk()\\n  } catch (err) {\\n    // TODO(alexkirsz) This can happen when a client-side module tries to load\\n    // an external module we don't provide a shim for (e.g. querystring, url).\\n    // For now, we fail semi-silently, but in the future this should be a\\n    // compilation error.\\n    throw new Error(`Failed to load external module ${id}: ${err}`)\\n  }\\n\\n  if (!esm || raw.__esModule) {\\n    return raw\\n  }\\n\\n  return interopEsm(raw, createNS(raw), true)\\n}\\n\\nexternalRequire.resolve = (\\n  id: string,\\n  options?: {\\n    paths?: string[]\\n  }\\n) => {\\n  return require.resolve(id, options)\\n}\\n\"],\"names\":[],\"mappings\":\"AAAA,oDAAoD,GAEpD,mDAAmD;AAEnD,6DAA6D;AAC7D,sDAAsD;AACtD,qGAAqG;AAErG,eAAe,eAAe,EAAY;IACxC,IAAI;IACJ,IAAI;QACF,MAAM,MAAM,MAAM,CAAC;IACrB,EAAE,OAAO,KAAK;QACZ,0EAA0E;QAC1E,0EAA0E;QAC1E,qEAAqE;QACrE,qBAAqB;QACrB,MAAM,IAAI,MAAM,CAAC,+BAA+B,EAAE,GAAG,EAAE,EAAE,KAAK;IAChE;IAEA,IAAI,OAAO,IAAI,UAAU,IAAI,IAAI,OAAO,IAAI,aAAa,IAAI,OAAO,EAAE;QACpE,OAAO,WAAW,IAAI,OAAO,EAAE,SAAS,MAAM;IAChD;IAEA,OAAO;AACT;AAEA,SAAS,gBACP,EAAY,EACZ,KAAgB,EAChB,MAAe,KAAK;IAEpB,IAAI;IACJ,IAAI;QACF,MAAM;IACR,EAAE,OAAO,KAAK;QACZ,0EAA0E;QAC1E,0EAA0E;QAC1E,qEAAqE;QACrE,qBAAqB;QACrB,MAAM,IAAI,MAAM,CAAC,+BAA+B,EAAE,GAAG,EAAE,EAAE,KAAK;IAChE;IAEA,IAAI,CAAC,OAAO,IAAI,UAAU,EAAE;QAC1B,OAAO;IACT;IAEA,OAAO,WAAW,KAAK,SAAS,MAAM;AACxC;AAEA,gBAAgB,OAAO,GAAG,CACxB,IACA;IAIA,OAAO,QAAQ,OAAO,CAAC,IAAI;AAC7B\",\"ignoreList\":[0]}},\n     {\"offset\": {\"line\": 377, \"column\": 0}, \"map\": {\"version\":3,\"sources\":[\"turbopack:///[turbopack]/shared-node/node-externals-utils.ts\"],\"sourcesContent\":[\"/* eslint-disable @typescript-eslint/no-unused-vars */\\n\\ndeclare var RUNTIME_PUBLIC_PATH: string;\\ndeclare var RELATIVE_ROOT_PATH: string;\\ndeclare var ASSET_PREFIX: string;\\n\\nconst path = require(\\\"path\\\");\\n\\nconst relativePathToRuntimeRoot = path.relative(RUNTIME_PUBLIC_PATH, \\\".\\\");\\n// Compute the relative path to the `distDir`.\\nconst relativePathToDistRoot = path.join(\\n  relativePathToRuntimeRoot,\\n  RELATIVE_ROOT_PATH\\n);\\nconst RUNTIME_ROOT = path.resolve(__filename, relativePathToRuntimeRoot);\\n// Compute the absolute path to the root, by stripping distDir from the absolute path to this file.\\nconst ABSOLUTE_ROOT = path.resolve(__filename, relativePathToDistRoot);\\n\\n/**\\n * Returns an absolute path to the given module path.\\n * Module path should be relative, either path to a file or a directory.\\n *\\n * This fn allows to calculate an absolute path for some global static values, such as\\n * `__dirname` or `import.meta.url` that Turbopack will not embeds in compile time.\\n * See ImportMetaBinding::code_generation for the usage.\\n */\\nfunction resolveAbsolutePath(modulePath?: string): string {\\n  if (modulePath) {\\n    return path.join(ABSOLUTE_ROOT, modulePath);\\n  }\\n  return ABSOLUTE_ROOT;\\n}\\n\"],\"names\":[],\"mappings\":\"AAAA,oDAAoD,GAMpD,MAAM,OAAO,QAAQ;AAErB,MAAM,4BAA4B,KAAK,QAAQ,CAAC,qBAAqB;AACrE,8CAA8C;AAC9C,MAAM,yBAAyB,KAAK,IAAI,CACtC,2BACA;AAEF,MAAM,eAAe,KAAK,OAAO,CAAC,YAAY;AAC9C,mGAAmG;AACnG,MAAM,gBAAgB,KAAK,OAAO,CAAC,YAAY;AAE/C;;;;;;;CAOC,GACD,SAAS,oBAAoB,UAAmB;IAC9C,IAAI,YAAY;QACd,OAAO,KAAK,IAAI,CAAC,eAAe;IAClC;IACA,OAAO;AACT\",\"ignoreList\":[0]}},\n     {\"offset\": {\"line\": 397, \"column\": 0}, \"map\": {\"version\":3,\"sources\":[\"turbopack:///[turbopack]/shared-node/node-wasm-utils.ts\"],\"sourcesContent\":[\"/* eslint-disable @typescript-eslint/no-unused-vars */\\n\\n/// <reference path=\\\"../shared/runtime-utils.ts\\\" />\\n\\nfunction readWebAssemblyAsResponse(path: string) {\\n  const { createReadStream } = require(\\\"fs\\\") as typeof import(\\\"fs\\\");\\n  const { Readable } = require(\\\"stream\\\") as typeof import(\\\"stream\\\");\\n\\n  const stream = createReadStream(path);\\n\\n  // @ts-ignore unfortunately there's a slight type mismatch with the stream.\\n  return new Response(Readable.toWeb(stream), {\\n    headers: {\\n      \\\"content-type\\\": \\\"application/wasm\\\",\\n    },\\n  });\\n}\\n\\nasync function compileWebAssemblyFromPath(\\n  path: string\\n): Promise<WebAssembly.Module> {\\n  const response = readWebAssemblyAsResponse(path);\\n\\n  return await WebAssembly.compileStreaming(response);\\n}\\n\\nasync function instantiateWebAssemblyFromPath(\\n  path: string,\\n  importsObj: WebAssembly.Imports\\n): Promise<Exports> {\\n  const response = readWebAssemblyAsResponse(path);\\n\\n  const { instance } = await WebAssembly.instantiateStreaming(\\n    response,\\n    importsObj\\n  );\\n\\n  return instance.exports;\\n}\\n\"],\"names\":[],\"mappings\":\"AAAA,oDAAoD,GAEpD,mDAAmD;AAEnD,SAAS,0BAA0B,IAAY;IAC7C,MAAM,EAAE,gBAAgB,EAAE,GAAG,QAAQ;IACrC,MAAM,EAAE,QAAQ,EAAE,GAAG,QAAQ;IAE7B,MAAM,SAAS,iBAAiB;IAEhC,2EAA2E;IAC3E,OAAO,IAAI,SAAS,SAAS,KAAK,CAAC,SAAS;QAC1C,SAAS;YACP,gBAAgB;QAClB;IACF;AACF;AAEA,eAAe,2BACb,IAAY;IAEZ,MAAM,WAAW,0BAA0B;IAE3C,OAAO,MAAM,YAAY,gBAAgB,CAAC;AAC5C;AAEA,eAAe,+BACb,IAAY,EACZ,UAA+B;IAE/B,MAAM,WAAW,0BAA0B;IAE3C,MAAM,EAAE,QAAQ,EAAE,GAAG,MAAM,YAAY,oBAAoB,CACzD,UACA;IAGF,OAAO,SAAS,OAAO;AACzB\",\"ignoreList\":[0]}},\n-    {\"offset\": {\"line\": 418, \"column\": 0}, \"map\": {\"version\":3,\"sources\":[\"turbopack:///[turbopack]/nodejs/runtime.ts\"],\"sourcesContent\":[\"/* eslint-disable @typescript-eslint/no-unused-vars */\\n\\n/// <reference path=\\\"../shared/runtime-utils.ts\\\" />\\n/// <reference path=\\\"../shared-node/base-externals-utils.ts\\\" />\\n/// <reference path=\\\"../shared-node/node-externals-utils.ts\\\" />\\n/// <reference path=\\\"../shared-node/node-wasm-utils.ts\\\" />\\n\\nenum SourceType {\\n  /**\\n   * The module was instantiated because it was included in an evaluated chunk's\\n   * runtime.\\n   */\\n  Runtime = 0,\\n  /**\\n   * The module was instantiated because a parent module imported it.\\n   */\\n  Parent = 1,\\n}\\n\\ntype SourceInfo =\\n  | {\\n      type: SourceType.Runtime;\\n      chunkPath: ChunkPath;\\n    }\\n  | {\\n      type: SourceType.Parent;\\n      parentId: ModuleId;\\n    };\\n\\nfunction stringifySourceInfo(source: SourceInfo): string {\\n  switch (source.type) {\\n    case SourceType.Runtime:\\n      return `runtime for chunk ${source.chunkPath}`;\\n    case SourceType.Parent:\\n      return `parent module ${source.parentId}`;\\n    default:\\n      invariant(source, (source) => `Unknown source type: ${source?.type}`);\\n  }\\n}\\n\\ntype ExternalRequire = (\\n  id: ModuleId,\\n  thunk: () => any,\\n  esm?: boolean\\n) => Exports | EsmNamespaceObject;\\ntype ExternalImport = (id: ModuleId) => Promise<Exports | EsmNamespaceObject>;\\n\\ninterface TurbopackNodeBuildContext extends TurbopackBaseContext<Module> {\\n  R: ResolvePathFromModule;\\n  x: ExternalRequire;\\n  y: ExternalImport;\\n}\\n\\ntype ModuleFactory = (\\n  this: Module[\\\"exports\\\"],\\n  context: TurbopackNodeBuildContext\\n) => undefined;\\n\\nconst url = require(\\\"url\\\") as typeof import('url');\\nconst fs = require(\\\"fs/promises\\\") as typeof import('fs/promises');\\n\\nconst moduleFactories: ModuleFactories = Object.create(null);\\nconst moduleCache: ModuleCache<ModuleWithDirection> = Object.create(null);\\n\\n/**\\n * Returns an absolute path to the given module's id.\\n */\\nfunction createResolvePathFromModule(\\n  resolver: (moduleId: string) => Exports\\n): (moduleId: string) => string {\\n  return function resolvePathFromModule(moduleId: string): string {\\n    const exported = resolver(moduleId);\\n    const exportedPath = exported?.default ?? exported;\\n    if (typeof exportedPath !== \\\"string\\\") {\\n      return exported as any;\\n    }\\n\\n    const strippedAssetPrefix = exportedPath.slice(ASSET_PREFIX.length);\\n    const resolved = path.resolve(\\n      RUNTIME_ROOT,\\n      strippedAssetPrefix\\n    );\\n\\n    return url.pathToFileURL(resolved).href;\\n  };\\n}\\n\\nfunction loadChunk(chunkData: ChunkData, source?: SourceInfo): void {\\n  if (typeof chunkData === \\\"string\\\") {\\n    return loadChunkPath(chunkData, source);\\n  } else {\\n    return loadChunkPath(chunkData.path, source);\\n  }\\n}\\n\\nfunction loadChunkPath(chunkPath: ChunkPath, source?: SourceInfo): void {\\n  if (!chunkPath.endsWith(\\\".js\\\")) {\\n    // We only support loading JS chunks in Node.js.\\n    // This branch can be hit when trying to load a CSS chunk.\\n    return;\\n  }\\n\\n  try {\\n    const resolved = path.resolve(RUNTIME_ROOT, chunkPath);\\n    const chunkModules: ModuleFactories = require(resolved);\\n\\n    for (const [moduleId, moduleFactory] of Object.entries(chunkModules)) {\\n      if (!moduleFactories[moduleId]) {\\n        moduleFactories[moduleId] = moduleFactory;\\n      }\\n    }\\n  } catch (e) {\\n    let errorMessage = `Failed to load chunk ${chunkPath}`;\\n\\n    if (source) {\\n      errorMessage += ` from ${stringifySourceInfo(source)}`;\\n    }\\n\\n    throw new Error(errorMessage, {\\n      cause: e,\\n    });\\n  }\\n}\\n\\nasync function loadChunkAsync(\\n  source: SourceInfo,\\n  chunkData: ChunkData\\n): Promise<any> {\\n  const chunkPath = typeof chunkData === \\\"string\\\" ? chunkData : chunkData.path;\\n  if (!chunkPath.endsWith(\\\".js\\\")) {\\n    // We only support loading JS chunks in Node.js.\\n    // This branch can be hit when trying to load a CSS chunk.\\n    return;\\n  }\\n\\n  const resolved = path.resolve(RUNTIME_ROOT, chunkPath);\\n\\n  try {\\n    const contents = await fs.readFile(resolved, \\\"utf-8\\\");\\n\\n    const localRequire = (id: string) => {\\n      let resolvedId = require.resolve(id, {paths: [path.dirname(resolved)]});\\n      return require(resolvedId);\\n    }\\n    const module = {\\n      exports: {},\\n    };\\n    // TODO: Use vm.runInThisContext once our minimal supported Node.js version includes https://github.com/nodejs/node/pull/52153\\n    // eslint-disable-next-line no-eval -- Can't use vm.runInThisContext due to https://github.com/nodejs/node/issues/52102\\n    (0, eval)(\\n      \\\"(function(module, exports, require, __dirname, __filename) {\\\" +\\n        contents +\\n        \\\"\\\\n})\\\" +\\n        \\\"\\\\n//# sourceURL=\\\" + url.pathToFileURL(resolved),\\n    )(module, module.exports, localRequire, path.dirname(resolved), resolved);\\n\\n    const chunkModules: ModuleFactories = module.exports;\\n    for (const [moduleId, moduleFactory] of Object.entries(chunkModules)) {\\n      if (!moduleFactories[moduleId]) {\\n        moduleFactories[moduleId] = moduleFactory;\\n      }\\n    }\\n  } catch (e) {\\n    let errorMessage = `Failed to load chunk ${chunkPath}`;\\n\\n    if (source) {\\n      errorMessage += ` from ${stringifySourceInfo(source)}`;\\n    }\\n\\n    throw new Error(errorMessage, {\\n      cause: e,\\n    });\\n  }\\n}\\n\\nfunction loadWebAssembly(chunkPath: ChunkPath, imports: WebAssembly.Imports) {\\n  const resolved = path.resolve(RUNTIME_ROOT, chunkPath);\\n\\n  return instantiateWebAssemblyFromPath(resolved, imports);\\n}\\n\\nfunction loadWebAssemblyModule(chunkPath: ChunkPath) {\\n  const resolved = path.resolve(RUNTIME_ROOT, chunkPath);\\n\\n  return compileWebAssemblyFromPath(resolved);\\n}\\n\\nfunction getWorkerBlobURL(_chunks: ChunkPath[]): string {\\n  throw new Error(\\\"Worker blobs are not implemented yet for Node.js\\\");\\n}\\n\\nfunction instantiateModule(id: ModuleId, source: SourceInfo): ModuleWithDirection {\\n  const moduleFactory = moduleFactories[id];\\n  if (typeof moduleFactory !== \\\"function\\\") {\\n    // This can happen if modules incorrectly handle HMR disposes/updates,\\n    // e.g. when they keep a `setTimeout` around which still executes old code\\n    // and contains e.g. a `require(\\\"something\\\")` call.\\n    let instantiationReason;\\n    switch (source.type) {\\n      case SourceType.Runtime:\\n        instantiationReason = `as a runtime entry of chunk ${source.chunkPath}`;\\n        break;\\n      case SourceType.Parent:\\n        instantiationReason = `because it was required from module ${source.parentId}`;\\n        break;\\n      default:\\n        invariant(source, (source) => `Unknown source type: ${source?.type}`);\\n    }\\n    throw new Error(\\n      `Module ${id} was instantiated ${instantiationReason}, but the module factory is not available. It might have been deleted in an HMR update.`\\n    );\\n  }\\n\\n  let parents: ModuleId[];\\n  switch (source.type) {\\n    case SourceType.Runtime:\\n      parents = [];\\n      break;\\n    case SourceType.Parent:\\n      // No need to add this module as a child of the parent module here, this\\n      // has already been taken care of in `getOrInstantiateModuleFromParent`.\\n      parents = [source.parentId];\\n      break;\\n    default:\\n      invariant(source, (source) => `Unknown source type: ${source?.type}`);\\n  }\\n\\n  const module: ModuleWithDirection = {\\n    exports: {},\\n    error: undefined,\\n    loaded: false,\\n    id,\\n    parents,\\n    children: [],\\n    namespaceObject: undefined,\\n  };\\n  moduleCache[id] = module;\\n\\n  // NOTE(alexkirsz) This can fail when the module encounters a runtime error.\\n  try {\\n    const r = commonJsRequire.bind(null, module);\\n    moduleFactory.call(module.exports, {\\n      a: asyncModule.bind(null, module),\\n      e: module.exports,\\n      r,\\n      t: runtimeRequire,\\n      x: externalRequire,\\n      y: externalImport,\\n      f: moduleContext,\\n      i: esmImport.bind(null, module),\\n      s: esmExport.bind(null, module, module.exports),\\n      j: dynamicExport.bind(null, module, module.exports),\\n      v: exportValue.bind(null, module),\\n      n: exportNamespace.bind(null, module),\\n      m: module,\\n      c: moduleCache,\\n      M: moduleFactories,\\n      l: loadChunkAsync.bind(null, { type: SourceType.Parent, parentId: id }),\\n      w: loadWebAssembly,\\n      u: loadWebAssemblyModule,\\n      g: globalThis,\\n      P: resolveAbsolutePath,\\n      U: relativeURL,\\n      R: createResolvePathFromModule(r),\\n      b: getWorkerBlobURL,\\n      z: requireStub,\\n      __dirname: typeof module.id === \\\"string\\\" ? module.id.replace(/(^|\\\\/)\\\\/+$/, \\\"\\\") : module.id\\n    });\\n  } catch (error) {\\n    module.error = error as any;\\n    throw error;\\n  }\\n\\n  module.loaded = true;\\n  if (module.namespaceObject && module.exports !== module.namespaceObject) {\\n    // in case of a circular dependency: cjs1 -> esm2 -> cjs1\\n    interopEsm(module.exports, module.namespaceObject);\\n  }\\n\\n  return module;\\n}\\n\\n/**\\n * Retrieves a module from the cache, or instantiate it if it is not cached.\\n */\\n// @ts-ignore\\nfunction getOrInstantiateModuleFromParent(\\n  id: ModuleId,\\n  sourceModule: ModuleWithDirection\\n): ModuleWithDirection {\\n  const module = moduleCache[id];\\n\\n  if (sourceModule.children.indexOf(id) === -1) {\\n    sourceModule.children.push(id);\\n  }\\n\\n  if (module) {\\n    if (module.parents.indexOf(sourceModule.id) === -1) {\\n      module.parents.push(sourceModule.id);\\n    }\\n\\n    return module;\\n  }\\n\\n  return instantiateModule(id, {\\n    type: SourceType.Parent,\\n    parentId: sourceModule.id,\\n  });\\n}\\n\\n/**\\n * Instantiates a runtime module.\\n */\\nfunction instantiateRuntimeModule(\\n  moduleId: ModuleId,\\n  chunkPath: ChunkPath\\n): Module {\\n  return instantiateModule(moduleId, { type: SourceType.Runtime, chunkPath });\\n}\\n\\n/**\\n * Retrieves a module from the cache, or instantiate it as a runtime module if it is not cached.\\n */\\n// @ts-ignore TypeScript doesn't separate this module space from the browser runtime\\nfunction getOrInstantiateRuntimeModule(\\n  moduleId: ModuleId,\\n  chunkPath: ChunkPath\\n): Module {\\n  const module = moduleCache[moduleId];\\n  if (module) {\\n    if (module.error) {\\n      throw module.error;\\n    }\\n    return module;\\n  }\\n\\n  return instantiateRuntimeModule(moduleId, chunkPath);\\n}\\n\\nmodule.exports = {\\n  getOrInstantiateRuntimeModule,\\n  loadChunk,\\n};\\n\"],\"names\":[],\"mappings\":\"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\",\"ignoreList\":[0]}}]\n+    {\"offset\": {\"line\": 418, \"column\": 0}, \"map\": {\"version\":3,\"sources\":[\"turbopack:///[turbopack]/nodejs/runtime.ts\"],\"sourcesContent\":[\"/* eslint-disable @typescript-eslint/no-unused-vars */\\n\\n/// <reference path=\\\"../shared/runtime-utils.ts\\\" />\\n/// <reference path=\\\"../shared-node/base-externals-utils.ts\\\" />\\n/// <reference path=\\\"../shared-node/node-externals-utils.ts\\\" />\\n/// <reference path=\\\"../shared-node/node-wasm-utils.ts\\\" />\\n\\nenum SourceType {\\n  /**\\n   * The module was instantiated because it was included in an evaluated chunk's\\n   * runtime.\\n   */\\n  Runtime = 0,\\n  /**\\n   * The module was instantiated because a parent module imported it.\\n   */\\n  Parent = 1,\\n}\\n\\ntype SourceInfo =\\n  | {\\n      type: SourceType.Runtime;\\n      chunkPath: ChunkPath;\\n    }\\n  | {\\n      type: SourceType.Parent;\\n      parentId: ModuleId;\\n    };\\n\\nfunction stringifySourceInfo(source: SourceInfo): string {\\n  switch (source.type) {\\n    case SourceType.Runtime:\\n      return `runtime for chunk ${source.chunkPath}`;\\n    case SourceType.Parent:\\n      return `parent module ${source.parentId}`;\\n    default:\\n      invariant(source, (source) => `Unknown source type: ${source?.type}`);\\n  }\\n}\\n\\ntype ExternalRequire = (\\n  id: ModuleId,\\n  thunk: () => any,\\n  esm?: boolean\\n) => Exports | EsmNamespaceObject;\\ntype ExternalImport = (id: ModuleId) => Promise<Exports | EsmNamespaceObject>;\\n\\ninterface TurbopackNodeBuildContext extends TurbopackBaseContext<Module> {\\n  R: ResolvePathFromModule;\\n  x: ExternalRequire;\\n  y: ExternalImport;\\n}\\n\\ntype ModuleFactory = (\\n  this: Module[\\\"exports\\\"],\\n  context: TurbopackNodeBuildContext\\n) => undefined;\\n\\nconst url = require(\\\"url\\\") as typeof import('url');\\nconst fs = require(\\\"fs/promises\\\") as typeof import('fs/promises');\\n\\nconst moduleFactories: ModuleFactories = Object.create(null);\\nconst moduleCache: ModuleCache<ModuleWithDirection> = Object.create(null);\\n\\n/**\\n * Returns an absolute path to the given module's id.\\n */\\nfunction createResolvePathFromModule(\\n  resolver: (moduleId: string) => Exports\\n): (moduleId: string) => string {\\n  return function resolvePathFromModule(moduleId: string): string {\\n    const exported = resolver(moduleId);\\n    const exportedPath = exported?.default ?? exported;\\n    if (typeof exportedPath !== \\\"string\\\") {\\n      return exported as any;\\n    }\\n\\n    const strippedAssetPrefix = exportedPath.slice(ASSET_PREFIX.length);\\n    const resolved = path.resolve(\\n      RUNTIME_ROOT,\\n      strippedAssetPrefix\\n    );\\n\\n    return url.pathToFileURL(resolved).href;\\n  };\\n}\\n\\nfunction loadChunk(chunkData: ChunkData, source?: SourceInfo): void {\\n  if (typeof chunkData === \\\"string\\\") {\\n    return loadChunkPath(chunkData, source);\\n  } else {\\n    return loadChunkPath(chunkData.path, source);\\n  }\\n}\\n\\nfunction loadChunkPath(chunkPath: ChunkPath, source?: SourceInfo): void {\\n  if (!isJs(chunkPath)) {\\n    // We only support loading JS chunks in Node.js.\\n    // This branch can be hit when trying to load a CSS chunk.\\n    return;\\n  }\\n\\n  try {\\n    const resolved = path.resolve(RUNTIME_ROOT, chunkPath);\\n    const chunkModules: ModuleFactories = require(resolved);\\n\\n    for (const [moduleId, moduleFactory] of Object.entries(chunkModules)) {\\n      if (!moduleFactories[moduleId]) {\\n        moduleFactories[moduleId] = moduleFactory;\\n      }\\n    }\\n  } catch (e) {\\n    let errorMessage = `Failed to load chunk ${chunkPath}`;\\n\\n    if (source) {\\n      errorMessage += ` from ${stringifySourceInfo(source)}`;\\n    }\\n\\n    throw new Error(errorMessage, {\\n      cause: e,\\n    });\\n  }\\n}\\n\\nasync function loadChunkAsync(\\n  source: SourceInfo,\\n  chunkData: ChunkData\\n): Promise<any> {\\n  const chunkPath = typeof chunkData === \\\"string\\\" ? chunkData : chunkData.path;\\n  if (!isJs(chunkPath)) {\\n    // We only support loading JS chunks in Node.js.\\n    // This branch can be hit when trying to load a CSS chunk.\\n    return;\\n  }\\n\\n  const resolved = path.resolve(RUNTIME_ROOT, chunkPath);\\n\\n  try {\\n    const contents = await fs.readFile(resolved, \\\"utf-8\\\");\\n\\n    const localRequire = (id: string) => {\\n      let resolvedId = require.resolve(id, {paths: [path.dirname(resolved)]});\\n      return require(resolvedId);\\n    }\\n    const module = {\\n      exports: {},\\n    };\\n    // TODO: Use vm.runInThisContext once our minimal supported Node.js version includes https://github.com/nodejs/node/pull/52153\\n    // eslint-disable-next-line no-eval -- Can't use vm.runInThisContext due to https://github.com/nodejs/node/issues/52102\\n    (0, eval)(\\n      \\\"(function(module, exports, require, __dirname, __filename) {\\\" +\\n        contents +\\n        \\\"\\\\n})\\\" +\\n        \\\"\\\\n//# sourceURL=\\\" + url.pathToFileURL(resolved),\\n    )(module, module.exports, localRequire, path.dirname(resolved), resolved);\\n\\n    const chunkModules: ModuleFactories = module.exports;\\n    for (const [moduleId, moduleFactory] of Object.entries(chunkModules)) {\\n      if (!moduleFactories[moduleId]) {\\n        moduleFactories[moduleId] = moduleFactory;\\n      }\\n    }\\n  } catch (e) {\\n    let errorMessage = `Failed to load chunk ${chunkPath}`;\\n\\n    if (source) {\\n      errorMessage += ` from ${stringifySourceInfo(source)}`;\\n    }\\n\\n    throw new Error(errorMessage, {\\n      cause: e,\\n    });\\n  }\\n}\\n\\nasync function loadChunkAsyncByUrl(source: SourceInfo, chunkUrl: string) {\\n  const path = url.fileURLToPath(new URL(chunkUrl, RUNTIME_ROOT)) as ChunkPath;\\n  return loadChunkAsync(source, path);\\n}\\n\\nfunction loadWebAssembly(chunkPath: ChunkPath, imports: WebAssembly.Imports) {\\n  const resolved = path.resolve(RUNTIME_ROOT, chunkPath);\\n\\n  return instantiateWebAssemblyFromPath(resolved, imports);\\n}\\n\\nfunction loadWebAssemblyModule(chunkPath: ChunkPath) {\\n  const resolved = path.resolve(RUNTIME_ROOT, chunkPath);\\n\\n  return compileWebAssemblyFromPath(resolved);\\n}\\n\\nfunction getWorkerBlobURL(_chunks: ChunkPath[]): string {\\n  throw new Error(\\\"Worker blobs are not implemented yet for Node.js\\\");\\n}\\n\\nfunction instantiateModule(id: ModuleId, source: SourceInfo): ModuleWithDirection {\\n  const moduleFactory = moduleFactories[id];\\n  if (typeof moduleFactory !== \\\"function\\\") {\\n    // This can happen if modules incorrectly handle HMR disposes/updates,\\n    // e.g. when they keep a `setTimeout` around which still executes old code\\n    // and contains e.g. a `require(\\\"something\\\")` call.\\n    let instantiationReason;\\n    switch (source.type) {\\n      case SourceType.Runtime:\\n        instantiationReason = `as a runtime entry of chunk ${source.chunkPath}`;\\n        break;\\n      case SourceType.Parent:\\n        instantiationReason = `because it was required from module ${source.parentId}`;\\n        break;\\n      default:\\n        invariant(source, (source) => `Unknown source type: ${source?.type}`);\\n    }\\n    throw new Error(\\n      `Module ${id} was instantiated ${instantiationReason}, but the module factory is not available. It might have been deleted in an HMR update.`\\n    );\\n  }\\n\\n  let parents: ModuleId[];\\n  switch (source.type) {\\n    case SourceType.Runtime:\\n      parents = [];\\n      break;\\n    case SourceType.Parent:\\n      // No need to add this module as a child of the parent module here, this\\n      // has already been taken care of in `getOrInstantiateModuleFromParent`.\\n      parents = [source.parentId];\\n      break;\\n    default:\\n      invariant(source, (source) => `Unknown source type: ${source?.type}`);\\n  }\\n\\n  const module: ModuleWithDirection = {\\n    exports: {},\\n    error: undefined,\\n    loaded: false,\\n    id,\\n    parents,\\n    children: [],\\n    namespaceObject: undefined,\\n  };\\n  moduleCache[id] = module;\\n\\n  // NOTE(alexkirsz) This can fail when the module encounters a runtime error.\\n  try {\\n    const r = commonJsRequire.bind(null, module);\\n    moduleFactory.call(module.exports, {\\n      a: asyncModule.bind(null, module),\\n      e: module.exports,\\n      r,\\n      t: runtimeRequire,\\n      x: externalRequire,\\n      y: externalImport,\\n      f: moduleContext,\\n      i: esmImport.bind(null, module),\\n      s: esmExport.bind(null, module, module.exports),\\n      j: dynamicExport.bind(null, module, module.exports),\\n      v: exportValue.bind(null, module),\\n      n: exportNamespace.bind(null, module),\\n      m: module,\\n      c: moduleCache,\\n      M: moduleFactories,\\n      l: loadChunkAsync.bind(null, { type: SourceType.Parent, parentId: id }),\\n      L: loadChunkAsyncByUrl.bind(null, { type: SourceType.Parent, parentId: id }),\\n      w: loadWebAssembly,\\n      u: loadWebAssemblyModule,\\n      g: globalThis,\\n      P: resolveAbsolutePath,\\n      U: relativeURL,\\n      R: createResolvePathFromModule(r),\\n      b: getWorkerBlobURL,\\n      z: requireStub,\\n      __dirname: typeof module.id === \\\"string\\\" ? module.id.replace(/(^|\\\\/)\\\\/+$/, \\\"\\\") : module.id\\n    });\\n  } catch (error) {\\n    module.error = error as any;\\n    throw error;\\n  }\\n\\n  module.loaded = true;\\n  if (module.namespaceObject && module.exports !== module.namespaceObject) {\\n    // in case of a circular dependency: cjs1 -> esm2 -> cjs1\\n    interopEsm(module.exports, module.namespaceObject);\\n  }\\n\\n  return module;\\n}\\n\\n/**\\n * Retrieves a module from the cache, or instantiate it if it is not cached.\\n */\\n// @ts-ignore\\nfunction getOrInstantiateModuleFromParent(\\n  id: ModuleId,\\n  sourceModule: ModuleWithDirection\\n): ModuleWithDirection {\\n  const module = moduleCache[id];\\n\\n  if (sourceModule.children.indexOf(id) === -1) {\\n    sourceModule.children.push(id);\\n  }\\n\\n  if (module) {\\n    if (module.parents.indexOf(sourceModule.id) === -1) {\\n      module.parents.push(sourceModule.id);\\n    }\\n\\n    return module;\\n  }\\n\\n  return instantiateModule(id, {\\n    type: SourceType.Parent,\\n    parentId: sourceModule.id,\\n  });\\n}\\n\\n/**\\n * Instantiates a runtime module.\\n */\\nfunction instantiateRuntimeModule(\\n  moduleId: ModuleId,\\n  chunkPath: ChunkPath\\n): Module {\\n  return instantiateModule(moduleId, { type: SourceType.Runtime, chunkPath });\\n}\\n\\n/**\\n * Retrieves a module from the cache, or instantiate it as a runtime module if it is not cached.\\n */\\n// @ts-ignore TypeScript doesn't separate this module space from the browser runtime\\nfunction getOrInstantiateRuntimeModule(\\n  moduleId: ModuleId,\\n  chunkPath: ChunkPath\\n): Module {\\n  const module = moduleCache[moduleId];\\n  if (module) {\\n    if (module.error) {\\n      throw module.error;\\n    }\\n    return module;\\n  }\\n\\n  return instantiateRuntimeModule(moduleId, chunkPath);\\n}\\n\\nconst regexJsUrl = /\\\\.js(?:\\\\?[^#]*)?(?:#.*)?$/;\\n/**\\n * Checks if a given path/URL ends with .js, optionally followed by ?query or #fragment.\\n */\\nfunction isJs(chunkUrlOrPath: ChunkUrl | ChunkPath): boolean {\\n  return regexJsUrl.test(chunkUrlOrPath);\\n}\\n\\nmodule.exports = {\\n  getOrInstantiateRuntimeModule,\\n  loadChunk,\\n};\\n\"],\"names\":[],\"mappings\":\"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\",\"ignoreList\":[0]}}]\n }\n\\ No newline at end of file"
        },
        {
            "sha": "547f9dabf2a0f07a3565ab0119f971e957d6e7ba",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/runtime/default_dev_runtime/output/b1abf_turbopack-tests_tests_snapshot_runtime_default_dev_runtime_input_index_40a89bd6.js",
            "status": "modified",
            "additions": 75,
            "deletions": 50,
            "changes": 125,
            "blob_url": "https://github.com/vercel/next.js/blob/5453818a183fb4db44ebd7a543edf5daf2e7582b/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_dev_runtime%2Foutput%2Fb1abf_turbopack-tests_tests_snapshot_runtime_default_dev_runtime_input_index_40a89bd6.js",
            "raw_url": "https://github.com/vercel/next.js/raw/5453818a183fb4db44ebd7a543edf5daf2e7582b/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_dev_runtime%2Foutput%2Fb1abf_turbopack-tests_tests_snapshot_runtime_default_dev_runtime_input_index_40a89bd6.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_dev_runtime%2Foutput%2Fb1abf_turbopack-tests_tests_snapshot_runtime_default_dev_runtime_input_index_40a89bd6.js?ref=5453818a183fb4db44ebd7a543edf5daf2e7582b",
            "patch": "@@ -9,6 +9,7 @@ if (!Array.isArray(globalThis.TURBOPACK)) {\n }\n \n const CHUNK_BASE_PATH = \"\";\n+const CHUNK_SUFFIX_PATH = \"\";\n const RELATIVE_ROOT_PATH = \"../../../../../../..\";\n const RUNTIME_PUBLIC_PATH = \"\";\n /**\n@@ -451,9 +452,9 @@ async function loadChunk(source, chunkData) {\n     }\n     return promise;\n }\n-async function loadChunkPath(source, chunkPath) {\n+async function loadChunkByUrl(source, chunkUrl) {\n     try {\n-        await BACKEND.loadChunk(chunkPath, source);\n+        await BACKEND.loadChunk(chunkUrl, source);\n     } catch (error) {\n         let loadReason;\n         switch(source.type){\n@@ -469,11 +470,15 @@ async function loadChunkPath(source, chunkPath) {\n             default:\n                 invariant(source, (source)=>`Unknown source type: ${source?.type}`);\n         }\n-        throw new Error(`Failed to load chunk ${chunkPath} ${loadReason}${error ? `: ${error}` : \"\"}`, error ? {\n+        throw new Error(`Failed to load chunk ${chunkUrl} ${loadReason}${error ? `: ${error}` : \"\"}`, error ? {\n             cause: error\n         } : undefined);\n     }\n }\n+async function loadChunkPath(source, chunkPath) {\n+    const url = getChunkRelativeUrl(chunkPath);\n+    return loadChunkByUrl(source, url);\n+}\n /**\n  * Returns an absolute url to an asset.\n  */ function createResolvePathFromModule(resolver) {\n@@ -541,7 +546,7 @@ function getWorkerBlobURL(chunks) {\n /**\n  * Returns the URL relative to the origin where a chunk can be fetched from.\n  */ function getChunkRelativeUrl(chunkPath) {\n-    return `${CHUNK_BASE_PATH}${chunkPath.split(\"/\").map((p)=>encodeURIComponent(p)).join(\"/\")}`;\n+    return `${CHUNK_BASE_PATH}${chunkPath.split(\"/\").map((p)=>encodeURIComponent(p)).join(\"/\")}${CHUNK_SUFFIX_PATH}`;\n }\n /**\n  * Marks a chunk list as a runtime chunk list. There can be more than one\n@@ -559,6 +564,18 @@ function registerChunk([chunkPath, chunkModules, runtimeParams]) {\n     }\n     return BACKEND.registerChunk(chunkPath, runtimeParams);\n }\n+const regexJsUrl = /\\.js(?:\\?[^#]*)?(?:#.*)?$/;\n+/**\n+ * Checks if a given path/URL ends with .js, optionally followed by ?query or #fragment.\n+ */ function isJs(chunkUrlOrPath) {\n+    return regexJsUrl.test(chunkUrlOrPath);\n+}\n+const regexCssUrl = /\\.css(?:\\?[^#]*)?(?:#.*)?$/;\n+/**\n+ * Checks if a given path/URL ends with .css, optionally followed by ?query or #fragment.\n+ */ function isCss(chunkUrl) {\n+    return regexCssUrl.test(chunkUrl);\n+}\n /// <reference path=\"./dev-globals.d.ts\" />\n /// <reference path=\"./dev-protocol.d.ts\" />\n /// <reference path=\"./dev-extensions.ts\" />\n@@ -705,6 +722,7 @@ function instantiateModule(id, source) {\n                 c: devModuleCache,\n                 M: moduleFactories,\n                 l: loadChunk.bind(null, sourceInfo),\n+                L: loadChunkByUrl.bind(null, sourceInfo),\n                 w: loadWebAssembly.bind(null, sourceInfo),\n                 u: loadWebAssemblyModule.bind(null, sourceInfo),\n                 g: globalThis,\n@@ -997,17 +1015,18 @@ function applyChunkListUpdate(update) {\n     }\n     if (update.chunks != null) {\n         for (const [chunkPath, chunkUpdate] of Object.entries(update.chunks)){\n+            const chunkUrl = getChunkRelativeUrl(chunkPath);\n             switch(chunkUpdate.type){\n                 case \"added\":\n-                    BACKEND.loadChunk(chunkPath, {\n+                    BACKEND.loadChunk(chunkUrl, {\n                         type: SourceType.Update\n                     });\n                     break;\n                 case \"total\":\n-                    DEV_BACKEND.reloadChunk?.(chunkPath);\n+                    DEV_BACKEND.reloadChunk?.(chunkUrl);\n                     break;\n                 case \"deleted\":\n-                    DEV_BACKEND.unloadChunk?.(chunkPath);\n+                    DEV_BACKEND.unloadChunk?.(chunkUrl);\n                     break;\n                 case \"partial\":\n                     invariant(chunkUpdate.instruction, (instruction)=>`Unknown partial instruction: ${JSON.stringify(instruction)}.`);\n@@ -1325,17 +1344,19 @@ function createModuleHot(moduleId, hotData) {\n     }\n     // We must also dispose of the chunk list's chunk itself to ensure it may\n     // be reloaded properly in the future.\n-    DEV_BACKEND.unloadChunk?.(chunkListPath);\n+    const chunkListUrl = getChunkRelativeUrl(chunkListPath);\n+    DEV_BACKEND.unloadChunk?.(chunkListUrl);\n     return true;\n }\n /**\n  * Disposes of a chunk and its corresponding exclusive modules.\n  *\n  * @returns Whether the chunk was disposed of.\n  */ function disposeChunk(chunkPath) {\n+    const chunkUrl = getChunkRelativeUrl(chunkPath);\n     // This should happen whether the chunk has any modules in it or not.\n     // For instance, CSS chunks have no modules in them, but they still need to be unloaded.\n-    DEV_BACKEND.unloadChunk?.(chunkPath);\n+    DEV_BACKEND.unloadChunk?.(chunkUrl);\n     const chunkModules = chunkModulesMap.get(chunkPath);\n     if (chunkModules == null) {\n         return false;\n@@ -1356,26 +1377,27 @@ function createModuleHot(moduleId, hotData) {\n /**\n  * Subscribes to chunk list updates from the update server and applies them.\n  */ function registerChunkList(chunkUpdateProvider, chunkList) {\n+    const chunkListPath = chunkList.path;\n     chunkUpdateProvider.push([\n-        chunkList.path,\n-        handleApply.bind(null, chunkList.path)\n+        chunkListPath,\n+        handleApply.bind(null, chunkListPath)\n     ]);\n     // Adding chunks to chunk lists and vice versa.\n-    const chunks = new Set(chunkList.chunks.map(getChunkPath));\n-    chunkListChunksMap.set(chunkList.path, chunks);\n-    for (const chunkPath of chunks){\n+    const chunkPaths = new Set(chunkList.chunks.map(getChunkPath));\n+    chunkListChunksMap.set(chunkListPath, chunkPaths);\n+    for (const chunkPath of chunkPaths){\n         let chunkChunkLists = chunkChunkListsMap.get(chunkPath);\n         if (!chunkChunkLists) {\n             chunkChunkLists = new Set([\n-                chunkList.path\n+                chunkListPath\n             ]);\n             chunkChunkListsMap.set(chunkPath, chunkChunkLists);\n         } else {\n-            chunkChunkLists.add(chunkList.path);\n+            chunkChunkLists.add(chunkListPath);\n         }\n     }\n     if (chunkList.source === \"entry\") {\n-        markChunkListAsRuntime(chunkList.path);\n+        markChunkListAsRuntime(chunkListPath);\n     }\n }\n globalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS ??= [];\n@@ -1419,15 +1441,17 @@ async function loadWebAssemblyModule(_source, wasmChunkPath) {\n (()=>{\n     BACKEND = {\n         async registerChunk (chunkPath, params) {\n-            const resolver = getOrCreateResolver(chunkPath);\n+            const chunkUrl = getChunkRelativeUrl(chunkPath);\n+            const resolver = getOrCreateResolver(chunkUrl);\n             resolver.resolve();\n             if (params == null) {\n                 return;\n             }\n             for (const otherChunkData of params.otherChunks){\n                 const otherChunkPath = getChunkPath(otherChunkData);\n+                const otherChunkUrl = getChunkRelativeUrl(otherChunkPath);\n                 // Chunk might have started loading, so we want to avoid triggering another load.\n-                getOrCreateResolver(otherChunkPath);\n+                getOrCreateResolver(otherChunkUrl);\n             }\n             // This waits for chunks to be loaded, but also marks included items as available.\n             await Promise.all(params.otherChunks.map((otherChunkData)=>loadChunk({\n@@ -1440,12 +1464,15 @@ async function loadWebAssemblyModule(_source, wasmChunkPath) {\n                 }\n             }\n         },\n-        loadChunk (chunkPath, source) {\n-            return doLoadChunk(chunkPath, source);\n+        /**\n+     * Loads the given chunk, and returns a promise that resolves once the chunk\n+     * has been loaded.\n+    */ loadChunk (chunkUrl, source) {\n+            return doLoadChunk(chunkUrl, source);\n         }\n     };\n-    function getOrCreateResolver(chunkPath) {\n-        let resolver = chunkResolvers.get(chunkPath);\n+    function getOrCreateResolver(chunkUrl) {\n+        let resolver = chunkResolvers.get(chunkUrl);\n         if (!resolver) {\n             let resolve;\n             let reject;\n@@ -1462,22 +1489,22 @@ async function loadWebAssemblyModule(_source, wasmChunkPath) {\n                 },\n                 reject: reject\n             };\n-            chunkResolvers.set(chunkPath, resolver);\n+            chunkResolvers.set(chunkUrl, resolver);\n         }\n         return resolver;\n     }\n     /**\n-   * Loads the given chunk, and returns a promise that resolves once the chunk\n-   * has been loaded.\n-   */ async function doLoadChunk(chunkPath, source) {\n-        const resolver = getOrCreateResolver(chunkPath);\n+    * Loads the given chunk, and returns a promise that resolves once the chunk\n+    * has been loaded.\n+    */ function doLoadChunk(chunkUrl, source) {\n+        const resolver = getOrCreateResolver(chunkUrl);\n         if (resolver.resolved) {\n             return resolver.promise;\n         }\n         if (source.type === SourceType.Runtime) {\n             // We don't need to load chunks references from runtime code, as they're already\n             // present in the DOM.\n-            if (chunkPath.endsWith(\".css\")) {\n+            if (isCss(chunkUrl)) {\n                 // CSS chunks do not register themselves, and as such must be marked as\n                 // loaded instantly.\n                 resolver.resolve();\n@@ -1487,19 +1514,19 @@ async function loadWebAssemblyModule(_source, wasmChunkPath) {\n             // `resolver.resolve()` in this branch.\n             return resolver.promise;\n         }\n-        const chunkUrl = getChunkRelativeUrl(chunkPath);\n-        const decodedChunkUrl = decodeURI(chunkUrl);\n         if (typeof importScripts === \"function\") {\n             // We're in a web worker\n-            if (chunkPath.endsWith(\".css\")) {\n+            if (isCss(chunkUrl)) {\n             // ignore\n-            } else if (chunkPath.endsWith(\".js\")) {\n+            } else if (isJs(chunkUrl)) {\n                 importScripts(TURBOPACK_WORKER_LOCATION + chunkUrl);\n             } else {\n-                throw new Error(`can't infer type of chunk from path ${chunkPath} in worker`);\n+                throw new Error(`can't infer type of chunk from URL ${chunkUrl} in worker`);\n             }\n         } else {\n-            if (chunkPath.endsWith(\".css\")) {\n+            // TODO(PACK-2140): remove this once all filenames are guaranteed to be escaped.\n+            const decodedChunkUrl = decodeURI(chunkUrl);\n+            if (isCss(chunkUrl)) {\n                 const previousLinks = document.querySelectorAll(`link[rel=stylesheet][href=\"${chunkUrl}\"],link[rel=stylesheet][href^=\"${chunkUrl}?\"],link[rel=stylesheet][href=\"${decodedChunkUrl}\"],link[rel=stylesheet][href^=\"${decodedChunkUrl}?\"]`);\n                 if (previousLinks.length > 0) {\n                     // CSS chunks do not register themselves, and as such must be marked as\n@@ -1519,7 +1546,7 @@ async function loadWebAssemblyModule(_source, wasmChunkPath) {\n                     };\n                     document.body.appendChild(link);\n                 }\n-            } else if (chunkPath.endsWith(\".js\")) {\n+            } else if (isJs(chunkUrl)) {\n                 const previousScripts = document.querySelectorAll(`script[src=\"${chunkUrl}\"],script[src^=\"${chunkUrl}?\"],script[src=\"${decodedChunkUrl}\"],script[src^=\"${decodedChunkUrl}?\"]`);\n                 if (previousScripts.length > 0) {\n                     // There is this edge where the script already failed loading, but we\n@@ -1541,7 +1568,7 @@ async function loadWebAssemblyModule(_source, wasmChunkPath) {\n                     document.body.appendChild(script);\n                 }\n             } else {\n-                throw new Error(`can't infer type of chunk from path ${chunkPath}`);\n+                throw new Error(`can't infer type of chunk from URL ${chunkUrl}`);\n             }\n         }\n         return resolver.promise;\n@@ -1559,17 +1586,16 @@ async function loadWebAssemblyModule(_source, wasmChunkPath) {\n let DEV_BACKEND;\n (()=>{\n     DEV_BACKEND = {\n-        unloadChunk (chunkPath) {\n-            deleteResolver(chunkPath);\n-            const chunkUrl = getChunkRelativeUrl(chunkPath);\n+        unloadChunk (chunkUrl) {\n+            deleteResolver(chunkUrl);\n             // TODO(PACK-2140): remove this once all filenames are guaranteed to be escaped.\n             const decodedChunkUrl = decodeURI(chunkUrl);\n-            if (chunkPath.endsWith(\".css\")) {\n+            if (isCss(chunkUrl)) {\n                 const links = document.querySelectorAll(`link[href=\"${chunkUrl}\"],link[href^=\"${chunkUrl}?\"],link[href=\"${decodedChunkUrl}\"],link[href^=\"${decodedChunkUrl}?\"]`);\n                 for (const link of Array.from(links)){\n                     link.remove();\n                 }\n-            } else if (chunkPath.endsWith(\".js\")) {\n+            } else if (isJs(chunkUrl)) {\n                 // Unloading a JS chunk would have no effect, as it lives in the JS\n                 // runtime once evaluated.\n                 // However, we still want to remove the script tag from the DOM to keep\n@@ -1579,20 +1605,19 @@ let DEV_BACKEND;\n                     script.remove();\n                 }\n             } else {\n-                throw new Error(`can't infer type of chunk from path ${chunkPath}`);\n+                throw new Error(`can't infer type of chunk from URL ${chunkUrl}`);\n             }\n         },\n-        reloadChunk (chunkPath) {\n+        reloadChunk (chunkUrl) {\n             return new Promise((resolve, reject)=>{\n-                if (!chunkPath.endsWith(\".css\")) {\n+                if (!isCss(chunkUrl)) {\n                     reject(new Error(\"The DOM backend can only reload CSS chunks\"));\n                     return;\n                 }\n-                const chunkUrl = getChunkRelativeUrl(chunkPath);\n                 const decodedChunkUrl = decodeURI(chunkUrl);\n                 const previousLinks = document.querySelectorAll(`link[rel=stylesheet][href=\"${chunkUrl}\"],link[rel=stylesheet][href^=\"${chunkUrl}?\"],link[rel=stylesheet][href=\"${decodedChunkUrl}\"],link[rel=stylesheet][href^=\"${decodedChunkUrl}?\"]`);\n                 if (previousLinks.length === 0) {\n-                    reject(new Error(`No link element found for chunk ${chunkPath}`));\n+                    reject(new Error(`No link element found for chunk ${chunkUrl}`));\n                     return;\n                 }\n                 const link = document.createElement(\"link\");\n@@ -1628,12 +1653,12 @@ let DEV_BACKEND;\n         },\n         restart: ()=>self.location.reload()\n     };\n-    function deleteResolver(chunkPath) {\n-        chunkResolvers.delete(chunkPath);\n+    function deleteResolver(chunkUrl) {\n+        chunkResolvers.delete(chunkUrl);\n     }\n })();\n function _eval({ code, url, map }) {\n-    code += `\\n\\n//# sourceURL=${encodeURI(location.origin + CHUNK_BASE_PATH + url)}`;\n+    code += `\\n\\n//# sourceURL=${encodeURI(location.origin + CHUNK_BASE_PATH + url + CHUNK_SUFFIX_PATH)}`;\n     if (map) {\n         code += `\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,${btoa(// btoa doesn't handle nonlatin characters, so escape them as \\x sequences\n         // See https://stackoverflow.com/a/26603875"
        },
        {
            "sha": "bee752b4fae1693ae4ac75e88af7ac775329f0e1",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/runtime/default_dev_runtime/output/b1abf_turbopack-tests_tests_snapshot_runtime_default_dev_runtime_input_index_40a89bd6.js.map",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/5453818a183fb4db44ebd7a543edf5daf2e7582b/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_dev_runtime%2Foutput%2Fb1abf_turbopack-tests_tests_snapshot_runtime_default_dev_runtime_input_index_40a89bd6.js.map",
            "raw_url": "https://github.com/vercel/next.js/raw/5453818a183fb4db44ebd7a543edf5daf2e7582b/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_dev_runtime%2Foutput%2Fb1abf_turbopack-tests_tests_snapshot_runtime_default_dev_runtime_input_index_40a89bd6.js.map",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_dev_runtime%2Foutput%2Fb1abf_turbopack-tests_tests_snapshot_runtime_default_dev_runtime_input_index_40a89bd6.js.map?ref=5453818a183fb4db44ebd7a543edf5daf2e7582b"
        }
    ],
    "stats": {
        "total": 476,
        "additions": 312,
        "deletions": 164
    }
}