{
    "author": "kdy1",
    "message": "fix(turbopack): Fix usage of `HELPERS` of SWC (#80791)\n\n### What?\n\nConvert `Helpers` to `HelperData`, which is `: Send + Sync` so safe to\npass around between threads.\n\n### Why?\n\nIt's not `Send + Sync`, so we should not pass it between threads like\nthis",
    "sha": "7fea36c002007312dda3209214af24644abd162b",
    "files": [
        {
            "sha": "1f84e6503afa31479dfaa0c1629f94aa8cd5d4f2",
            "filename": "turbopack/crates/turbopack-ecmascript/src/parse.rs",
            "status": "modified",
            "additions": 17,
            "deletions": 7,
            "changes": 24,
            "blob_url": "https://github.com/vercel/next.js/blob/7fea36c002007312dda3209214af24644abd162b/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fparse.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/7fea36c002007312dda3209214af24644abd162b/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fparse.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fparse.rs?ref=7fea36c002007312dda3209214af24644abd162b",
            "patch": "@@ -390,6 +390,8 @@ async fn parse_file_content(\n                 EcmascriptModuleAssetType::Typescript { .. }\n                     | EcmascriptModuleAssetType::TypescriptDeclaration\n             );\n+\n+            let helpers=Helpers::new(true);\n             let span = tracing::trace_span!(\"swc_resolver\").entered();\n \n             parsed_program.visit_mut_with(&mut resolver(\n@@ -414,14 +416,19 @@ async fn parse_file_content(\n             parsed_program.mutate(swc_core::ecma::lints::rules::lint_pass(rules));\n             drop(span);\n \n-            parsed_program.mutate(swc_core::ecma::transforms::proposal::explicit_resource_management::explicit_resource_management());\n+            HELPERS.set(&helpers, || {\n+                parsed_program.mutate(\n+                    swc_core::ecma::transforms::proposal::explicit_resource_management::explicit_resource_management(),\n+                );\n+            });\n \n             let var_with_ts_declare = if is_typescript {\n                 VarDeclWithTsDeclareCollector::collect(&parsed_program)\n             } else {\n                 FxHashSet::default()\n             };\n \n+            let mut helpers = helpers.data();\n             let transform_context = TransformContext {\n                 comments: &comments,\n                 source_map: &source_map,\n@@ -436,8 +443,8 @@ async fn parse_file_content(\n             let span = tracing::trace_span!(\"transforms\");\n             async {\n                 for transform in transforms.iter() {\n-                    transform\n-                        .apply(&mut parsed_program, &transform_context)\n+                    helpers = transform\n+                        .apply(&mut parsed_program, &transform_context, helpers)\n                         .await?;\n                 }\n                 anyhow::Ok(())\n@@ -461,9 +468,12 @@ async fn parse_file_content(\n                 return Ok(ParseResult::Unparseable { messages });\n             }\n \n-            parsed_program.visit_mut_with(\n-                &mut swc_core::ecma::transforms::base::helpers::inject_helpers(unresolved_mark),\n-            );\n+            let helpers = Helpers::from_data(helpers);\n+            HELPERS.set(&helpers, || {\n+                parsed_program.mutate(\n+                    swc_core::ecma::transforms::base::helpers::inject_helpers(unresolved_mark),\n+                );\n+            });\n \n             let eval_context = EvalContext::new(\n                 &parsed_program,\n@@ -486,7 +496,7 @@ async fn parse_file_content(\n         },\n         |f, cx| {\n             GLOBALS.set(globals_ref, || {\n-                HANDLER.set(&handler, || HELPERS.set(&Helpers::new(true), || f.poll(cx)))\n+                HANDLER.set(&handler, || f.poll(cx))\n             })\n         },\n     )"
        },
        {
            "sha": "ca161a2a29f4797de87e4a748c01b155089ff6e8",
            "filename": "turbopack/crates/turbopack-ecmascript/src/transform/mod.rs",
            "status": "modified",
            "additions": 69,
            "deletions": 29,
            "changes": 98,
            "blob_url": "https://github.com/vercel/next.js/blob/7fea36c002007312dda3209214af24644abd162b/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftransform%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/7fea36c002007312dda3209214af24644abd162b/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftransform%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftransform%2Fmod.rs?ref=7fea36c002007312dda3209214af24644abd162b",
            "patch": "@@ -8,9 +8,16 @@ use swc_core::{\n     base::SwcComments,\n     common::{Mark, SourceMap, comments::Comments},\n     ecma::{\n-        ast::{ModuleItem, Program},\n+        ast::{ModuleItem, Pass, Program},\n         preset_env::{self, Targets},\n-        transforms::{base::assumptions::Assumptions, optimization::inline_globals, react::react},\n+        transforms::{\n+            base::{\n+                assumptions::Assumptions,\n+                helpers::{HELPERS, HelperData, Helpers},\n+            },\n+            optimization::inline_globals,\n+            react::react,\n+        },\n     },\n     quote,\n };\n@@ -116,26 +123,36 @@ pub struct TransformContext<'a> {\n }\n \n impl EcmascriptInputTransform {\n-    pub async fn apply(&self, program: &mut Program, ctx: &TransformContext<'_>) -> Result<()> {\n+    pub async fn apply(\n+        &self,\n+        program: &mut Program,\n+        ctx: &TransformContext<'_>,\n+        helpers: HelperData,\n+    ) -> Result<HelperData> {\n         let &TransformContext {\n             comments,\n             source_map,\n             top_level_mark,\n             unresolved_mark,\n             ..\n         } = ctx;\n-        match self {\n+\n+        Ok(match self {\n             EcmascriptInputTransform::GlobalTypeofs { window_value } => {\n                 let mut typeofs: FxHashMap<Atom, Atom> = Default::default();\n                 typeofs.insert(Atom::from(\"window\"), Atom::from(&**window_value));\n \n-                program.mutate(inline_globals(\n-                    unresolved_mark,\n-                    Default::default(),\n-                    Default::default(),\n-                    Default::default(),\n-                    Arc::new(typeofs),\n-                ));\n+                apply_transform(\n+                    program,\n+                    helpers,\n+                    inline_globals(\n+                        unresolved_mark,\n+                        Default::default(),\n+                        Default::default(),\n+                        Default::default(),\n+                        Arc::new(typeofs),\n+                    ),\n+                )\n             }\n             EcmascriptInputTransform::React {\n                 development,\n@@ -178,13 +195,17 @@ impl EcmascriptInputTransform {\n \n                 // Explicit type annotation to ensure that we don't duplicate transforms in the\n                 // final binary\n-                program.mutate(react::<&dyn Comments>(\n-                    source_map.clone(),\n-                    Some(&comments),\n-                    config,\n-                    top_level_mark,\n-                    unresolved_mark,\n-                ));\n+                let helpers = apply_transform(\n+                    program,\n+                    helpers,\n+                    react::<&dyn Comments>(\n+                        source_map.clone(),\n+                        Some(&comments),\n+                        config,\n+                        top_level_mark,\n+                        unresolved_mark,\n+                    ),\n+                );\n \n                 if *refresh {\n                     let stmt = quote!(\n@@ -204,6 +225,8 @@ impl EcmascriptInputTransform {\n                         }\n                     }\n                 }\n+\n+                helpers\n             }\n             EcmascriptInputTransform::PresetEnv(env) => {\n                 let versions = env.runtime_versions().await?;\n@@ -217,20 +240,28 @@ impl EcmascriptInputTransform {\n \n                 // Explicit type annotation to ensure that we don't duplicate transforms in the\n                 // final binary\n-                program.mutate(preset_env::transform_from_env::<&'_ dyn Comments>(\n-                    top_level_mark,\n-                    Some(&comments),\n-                    config,\n-                    Assumptions::default(),\n-                ));\n+                apply_transform(\n+                    program,\n+                    helpers,\n+                    preset_env::transform_from_env::<&'_ dyn Comments>(\n+                        top_level_mark,\n+                        Some(&comments),\n+                        config,\n+                        Assumptions::default(),\n+                    ),\n+                )\n             }\n             EcmascriptInputTransform::TypeScript {\n                 // TODO(WEB-1213)\n                 use_define_for_class_fields: _use_define_for_class_fields,\n             } => {\n                 use swc_core::ecma::transforms::typescript::typescript;\n                 let config = Default::default();\n-                program.mutate(typescript(config, unresolved_mark, top_level_mark));\n+                apply_transform(\n+                    program,\n+                    helpers,\n+                    typescript(config, unresolved_mark, top_level_mark),\n+                )\n             }\n             EcmascriptInputTransform::Decorators {\n                 is_legacy,\n@@ -246,16 +277,25 @@ impl EcmascriptInputTransform {\n                     ..Default::default()\n                 };\n \n-                program.mutate(decorators(config));\n+                apply_transform(program, helpers, decorators(config))\n             }\n             EcmascriptInputTransform::Plugin(transform) => {\n-                transform.await?.transform(program, ctx).await?\n+                // We cannot pass helpers to plugins, so we return them as is\n+                transform.await?.transform(program, ctx).await?;\n+                helpers\n             }\n-        }\n-        Ok(())\n+        })\n     }\n }\n \n+fn apply_transform(program: &mut Program, helpers: HelperData, op: impl Pass) -> HelperData {\n+    let helpers = Helpers::from_data(helpers);\n+    HELPERS.set(&helpers, || {\n+        program.mutate(op);\n+    });\n+    helpers.data()\n+}\n+\n pub fn remove_shebang(program: &mut Program) {\n     match program {\n         Program::Module(m) => {"
        }
    ],
    "stats": {
        "total": 122,
        "additions": 86,
        "deletions": 36
    }
}