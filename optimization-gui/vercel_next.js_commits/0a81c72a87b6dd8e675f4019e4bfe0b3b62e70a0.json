{
    "author": "mischnic",
    "message": "Turbopack: use depth as priority for merged module info (#83909)\n\nmodule_count: 63896\r\n\r\nvisit_count of the `traverse_edges_fixed_point_with_priority`:\r\n- before: 277.620\r\n- with +depth: 1.250.882\r\n- with -depth (this PR): 184.697",
    "sha": "0a81c72a87b6dd8e675f4019e4bfe0b3b62e70a0",
    "files": [
        {
            "sha": "30776faf17985b8c063a7edaef8d48591e08c042",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/chunk_group_info.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/0a81c72a87b6dd8e675f4019e4bfe0b3b62e70a0/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fchunk_group_info.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0a81c72a87b6dd8e675f4019e4bfe0b3b62e70a0/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fchunk_group_info.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fchunk_group_info.rs?ref=0a81c72a87b6dd8e675f4019e4bfe0b3b62e70a0",
            "patch": "@@ -405,7 +405,8 @@ pub async fn compute_chunk_group_info(graph: &ModuleGraphRef) -> Result<Vc<Chunk\n \n         // First, compute the depth for each module in the graph\n         let module_depth: FxHashMap<ResolvedVc<Box<dyn Module>>, usize> = {\n-            let mut module_depth = FxHashMap::default();\n+            let mut module_depth =\n+                FxHashMap::with_capacity_and_hasher(module_count, Default::default());\n             graph.traverse_edges_from_entries_bfs(\n                 entries.iter().flat_map(|e| e.entries()),\n                 |parent, node| {"
        },
        {
            "sha": "f2a598eda7221a157fa9ce4a050e730d350cc5b3",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/merged_modules.rs",
            "status": "modified",
            "additions": 35,
            "deletions": 2,
            "changes": 37,
            "blob_url": "https://github.com/vercel/next.js/blob/0a81c72a87b6dd8e675f4019e4bfe0b3b62e70a0/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmerged_modules.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0a81c72a87b6dd8e675f4019e4bfe0b3b62e70a0/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmerged_modules.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmerged_modules.rs?ref=0a81c72a87b6dd8e675f4019e4bfe0b3b62e70a0",
            "patch": "@@ -88,6 +88,30 @@ pub async fn compute_merged_modules(module_graph: Vc<ModuleGraph>) -> Result<Vc<\n             .flat_map(|g| g.entries())\n             .collect::<Vec<_>>();\n \n+        // First, compute the depth for each module in the graph\n+        let module_depth = {\n+            let _inner_span = tracing::info_span!(\"compute depth\").entered();\n+\n+            let mut module_depth =\n+                FxHashMap::with_capacity_and_hasher(module_count, Default::default());\n+            module_graph.traverse_edges_from_entries_bfs(\n+                entries.iter().copied(),\n+                |parent, node| {\n+                    if let Some((parent, _)) = parent {\n+                        let parent_depth = *module_depth\n+                            .get(&parent.module)\n+                            .context(\"Module depth not found\")?;\n+                        module_depth.entry(node.module).or_insert(parent_depth + 1);\n+                    } else {\n+                        module_depth.insert(node.module, 0);\n+                    };\n+\n+                    Ok(GraphTraversalAction::Continue)\n+                },\n+            )?;\n+            module_depth\n+        };\n+\n         // For each module, the indices in the bitmap store which merge group entry modules\n         // transitively import that module. The bitmap can be treated as an opaque value, merging\n         // all modules with the same bitmap.\n@@ -121,7 +145,10 @@ pub async fn compute_merged_modules(module_graph: Vc<ModuleGraph>) -> Result<Vc<\n \n         let mut next_index = 0u32;\n         let visit_count = module_graph.traverse_edges_fixed_point_with_priority(\n-            entries.iter().map(|e| (*e, 0)),\n+            entries\n+                .iter()\n+                .map(|e| Ok((*e, -*module_depth.get(e).context(\"Module depth not found\")?)))\n+                .collect::<Result<Vec<_>>>()?,\n             &mut (),\n             |parent_info: Option<(&'_ SingleModuleGraphModuleNode, &'_ RefData)>,\n              node: &'_ SingleModuleGraphModuleNode,\n@@ -196,7 +223,13 @@ pub async fn compute_merged_modules(module_graph: Vc<ModuleGraph>) -> Result<Vc<\n                     }\n                 })\n             },\n-            |_, _| Ok(0),\n+            |successor, _| {\n+                // Invert the ordering here. High priority values get visited first, and we want to\n+                // visit the low-depth nodes first, as we are propagating bitmaps downwards.\n+                Ok(-*module_depth\n+                    .get(&successor.module)\n+                    .context(\"Module depth not found\")?)\n+            },\n         )?;\n \n         drop(inner_span);"
        }
    ],
    "stats": {
        "total": 40,
        "additions": 37,
        "deletions": 3
    }
}