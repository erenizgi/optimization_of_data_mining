{
    "author": "gnoff",
    "message": "[dynamicIO] only abort once per prerender (#77747)\n\nPrior to this change multiple sync dynamic APIs could trigger multiple\naborts. Generally this isn't a problem however it is wasteful compute\nand blocks a later refactor where we stop explicitly tracking whether\nthe sync dynamic access is what caused the prerender to abort or not. To\nachieve better perf and future semantics we now only abort if the\nprerender is not yet aborted. In effect this means that there can only\nbe one sync abort error per prerender in RSC and SSR respectively.\n\n---------\n\nCo-authored-by: Hendrik Liebau <mail@hendrik-liebau.de>",
    "sha": "5dd95e3352482a7f14eb7b006dd0663413901337",
    "files": [
        {
            "sha": "405770c9c104b5280696f33d3875ca90201edec0",
            "filename": "packages/next/src/server/app-render/dynamic-rendering.ts",
            "status": "modified",
            "additions": 19,
            "deletions": 11,
            "changes": 30,
            "blob_url": "https://github.com/vercel/next.js/blob/5dd95e3352482a7f14eb7b006dd0663413901337/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fdynamic-rendering.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/5dd95e3352482a7f14eb7b006dd0663413901337/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fdynamic-rendering.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fdynamic-rendering.ts?ref=5dd95e3352482a7f14eb7b006dd0663413901337",
            "patch": "@@ -294,7 +294,7 @@ export function abortOnSynchronousPlatformIOAccess(\n       dynamicTracking.syncDynamicErrorWithStack = errorWithStack\n     }\n   }\n-  return abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore)\n+  abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore)\n }\n \n export function trackSynchronousPlatformIOAccessInDev(\n@@ -321,19 +321,27 @@ export function abortAndThrowOnSynchronousRequestDataAccess(\n   errorWithStack: Error,\n   prerenderStore: PrerenderStoreModern\n ): never {\n-  const dynamicTracking = prerenderStore.dynamicTracking\n-  if (dynamicTracking) {\n-    if (dynamicTracking.syncDynamicErrorWithStack === null) {\n-      dynamicTracking.syncDynamicExpression = expression\n-      dynamicTracking.syncDynamicErrorWithStack = errorWithStack\n-      if (prerenderStore.validating === true) {\n-        // We always log Request Access in dev at the point of calling the function\n-        // So we mark the dynamic validation as not requiring it to be printed\n-        dynamicTracking.syncDynamicLogged = true\n+  const prerenderSignal = prerenderStore.controller.signal\n+  if (prerenderSignal.aborted === false) {\n+    // TODO it would be better to move this aborted check into the callsite so we can avoid making\n+    // the error object when it isn't relevant to the aborting of the prerender however\n+    // since we need the throw semantics regardless of whether we abort it is easier to land\n+    // this way. See how this was handled with `abortOnSynchronousPlatformIOAccess` for a closer\n+    // to ideal implementation\n+    const dynamicTracking = prerenderStore.dynamicTracking\n+    if (dynamicTracking) {\n+      if (dynamicTracking.syncDynamicErrorWithStack === null) {\n+        dynamicTracking.syncDynamicExpression = expression\n+        dynamicTracking.syncDynamicErrorWithStack = errorWithStack\n+        if (prerenderStore.validating === true) {\n+          // We always log Request Access in dev at the point of calling the function\n+          // So we mark the dynamic validation as not requiring it to be printed\n+          dynamicTracking.syncDynamicLogged = true\n+        }\n       }\n     }\n+    abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore)\n   }\n-  abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore)\n   throw createPrerenderInterruptedError(\n     `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`\n   )"
        },
        {
            "sha": "ee3a2e0b2cea218f4ca9a0bfd490f02fb8140172",
            "filename": "packages/next/src/server/node-environment-extensions/utils.tsx",
            "status": "modified",
            "additions": 30,
            "deletions": 25,
            "changes": 55,
            "blob_url": "https://github.com/vercel/next.js/blob/5dd95e3352482a7f14eb7b006dd0663413901337/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Futils.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/5dd95e3352482a7f14eb7b006dd0663413901337/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Futils.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Futils.tsx?ref=5dd95e3352482a7f14eb7b006dd0663413901337",
            "patch": "@@ -12,32 +12,37 @@ export function io(expression: string, type: ApiType) {\n   const workUnitStore = workUnitAsyncStorage.getStore()\n   if (workUnitStore) {\n     if (workUnitStore.type === 'prerender') {\n-      const workStore = workAsyncStorage.getStore()\n-      if (workStore) {\n-        let message: string\n-        switch (type) {\n-          case 'time':\n-            message = `Route \"${workStore.route}\" used ${expression} instead of using \\`performance\\` or without explicitly calling \\`await connection()\\` beforehand. See more info here: https://nextjs.org/docs/messages/next-prerender-current-time`\n-            break\n-          case 'random':\n-            message = `Route \"${workStore.route}\" used ${expression} outside of \\`\"use cache\"\\` and without explicitly calling \\`await connection()\\` beforehand. See more info here: https://nextjs.org/docs/messages/next-prerender-random`\n-            break\n-          case 'crypto':\n-            message = `Route \"${workStore.route}\" used ${expression} outside of \\`\"use cache\"\\` and without explicitly calling \\`await connection()\\` beforehand. See more info here: https://nextjs.org/docs/messages/next-prerender-crypto`\n-            break\n-          default:\n-            throw new InvariantError(\n-              'Unknown expression type in abortOnSynchronousPlatformIOAccess.'\n-            )\n-        }\n-        const errorWithStack = new Error(message)\n+      const prerenderSignal = workUnitStore.controller.signal\n+      if (prerenderSignal.aborted === false) {\n+        // If the prerender signal is already aborted we don't need to construct any stacks\n+        // because something else actually terminated the prerender.\n+        const workStore = workAsyncStorage.getStore()\n+        if (workStore) {\n+          let message: string\n+          switch (type) {\n+            case 'time':\n+              message = `Route \"${workStore.route}\" used ${expression} instead of using \\`performance\\` or without explicitly calling \\`await connection()\\` beforehand. See more info here: https://nextjs.org/docs/messages/next-prerender-current-time`\n+              break\n+            case 'random':\n+              message = `Route \"${workStore.route}\" used ${expression} outside of \\`\"use cache\"\\` and without explicitly calling \\`await connection()\\` beforehand. See more info here: https://nextjs.org/docs/messages/next-prerender-random`\n+              break\n+            case 'crypto':\n+              message = `Route \"${workStore.route}\" used ${expression} outside of \\`\"use cache\"\\` and without explicitly calling \\`await connection()\\` beforehand. See more info here: https://nextjs.org/docs/messages/next-prerender-crypto`\n+              break\n+            default:\n+              throw new InvariantError(\n+                'Unknown expression type in abortOnSynchronousPlatformIOAccess.'\n+              )\n+          }\n+          const errorWithStack = new Error(message)\n \n-        abortOnSynchronousPlatformIOAccess(\n-          workStore.route,\n-          expression,\n-          errorWithStack,\n-          workUnitStore\n-        )\n+          abortOnSynchronousPlatformIOAccess(\n+            workStore.route,\n+            expression,\n+            errorWithStack,\n+            workUnitStore\n+          )\n+        }\n       }\n     } else if (\n       workUnitStore.type === 'request' &&"
        }
    ],
    "stats": {
        "total": 85,
        "additions": 49,
        "deletions": 36
    }
}