{
    "author": "sokra",
    "message": "Turbopack: Stop persisting background task correctly on stop (#82727)\n\n### What?\n\nFixes a race condition with the persisting background tasks when stopping the backend.",
    "sha": "2bddb9166e8549153d2f1ca9fb3682f40c6728e5",
    "files": [
        {
            "sha": "cd7ad19c1f829eabe51264782cc8cc011e03d669",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 30,
            "deletions": 29,
            "changes": 59,
            "blob_url": "https://github.com/vercel/next.js/blob/2bddb9166e8549153d2f1ca9fb3682f40c6728e5/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2bddb9166e8549153d2f1ca9fb3682f40c6728e5/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=2bddb9166e8549153d2f1ca9fb3682f40c6728e5",
            "patch": "@@ -2137,36 +2137,37 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                     let until = last_snapshot + time;\n                     if until > Instant::now() {\n                         let mut stop_listener = self.stopping_event.listen();\n-                        if !self.stopping.load(Ordering::Acquire) {\n-                            let mut idle_start_listener = self.idle_start_event.listen();\n-                            let mut idle_end_listener = self.idle_end_event.listen();\n-                            let mut idle_time = if turbo_tasks.is_idle() {\n-                                Instant::now() + IDLE_TIMEOUT\n-                            } else {\n-                                far_future()\n-                            };\n-                            loop {\n-                                tokio::select! {\n-                                    _ = &mut stop_listener => {\n-                                        break;\n-                                    },\n-                                    _ = &mut idle_start_listener => {\n-                                        idle_time = Instant::now() + IDLE_TIMEOUT;\n-                                        idle_start_listener = self.idle_start_event.listen()\n-                                    },\n-                                    _ = &mut idle_end_listener => {\n-                                        idle_time = until + IDLE_TIMEOUT;\n-                                        idle_end_listener = self.idle_end_event.listen()\n-                                    },\n-                                    _ = tokio::time::sleep_until(until) => {\n+                        if self.stopping.load(Ordering::Acquire) {\n+                            return;\n+                        }\n+                        let mut idle_start_listener = self.idle_start_event.listen();\n+                        let mut idle_end_listener = self.idle_end_event.listen();\n+                        let mut idle_time = if turbo_tasks.is_idle() {\n+                            Instant::now() + IDLE_TIMEOUT\n+                        } else {\n+                            far_future()\n+                        };\n+                        loop {\n+                            tokio::select! {\n+                                _ = &mut stop_listener => {\n+                                    return;\n+                                },\n+                                _ = &mut idle_start_listener => {\n+                                    idle_time = Instant::now() + IDLE_TIMEOUT;\n+                                    idle_start_listener = self.idle_start_event.listen()\n+                                },\n+                                _ = &mut idle_end_listener => {\n+                                    idle_time = until + IDLE_TIMEOUT;\n+                                    idle_end_listener = self.idle_end_event.listen()\n+                                },\n+                                _ = tokio::time::sleep_until(until) => {\n+                                    break;\n+                                },\n+                                _ = tokio::time::sleep_until(idle_time) => {\n+                                    if turbo_tasks.is_idle() {\n                                         break;\n-                                    },\n-                                    _ = tokio::time::sleep_until(idle_time) => {\n-                                        if turbo_tasks.is_idle() {\n-                                            break;\n-                                        }\n-                                    },\n-                                }\n+                                    }\n+                                },\n                             }\n                         }\n                     }"
        }
    ],
    "stats": {
        "total": 59,
        "additions": 30,
        "deletions": 29
    }
}