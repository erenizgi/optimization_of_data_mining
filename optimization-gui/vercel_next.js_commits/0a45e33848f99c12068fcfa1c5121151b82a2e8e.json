{
    "author": "huozhi",
    "message": "[perf] cache load config results (#80570)\n\nThis PR is a perf improvement that we only need to load Next.js config once per process. For config schema validation we also only execute once. I noticed that config-schema is executed 3 times, in the 1st root process, and twice when the router-server load configs.\r\n\r\n* For `loadConfig` it needs module loading, config parsing, save the expensive effort to only execute once\r\n* Always validate config schema if possible and don't be silent, but only do it once is the parent process. We use `process.send` to check if it's in the root or forked process.",
    "sha": "0a45e33848f99c12068fcfa1c5121151b82a2e8e",
    "files": [
        {
            "sha": "549e75bdee7514eaa5a8fd1eed4a7acf75bad55b",
            "filename": "packages/next/src/cli/next-dev.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/0a45e33848f99c12068fcfa1c5121151b82a2e8e/packages%2Fnext%2Fsrc%2Fcli%2Fnext-dev.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/0a45e33848f99c12068fcfa1c5121151b82a2e8e/packages%2Fnext%2Fsrc%2Fcli%2Fnext-dev.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcli%2Fnext-dev.ts?ref=0a45e33848f99c12068fcfa1c5121151b82a2e8e",
            "patch": "@@ -219,7 +219,9 @@ const nextDev = async (\n   // some set-ups that rely on listening on other interfaces\n   const host = options.hostname\n \n-  config = await loadConfig(PHASE_DEVELOPMENT_SERVER, dir)\n+  config = await loadConfig(PHASE_DEVELOPMENT_SERVER, dir, {\n+    silent: false,\n+  })\n \n   if (\n     options.experimentalUploadTrace &&"
        },
        {
            "sha": "ccdc235beb854d170d130cd0c3d42d7b01472381",
            "filename": "packages/next/src/server/config.test.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 2,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/0a45e33848f99c12068fcfa1c5121151b82a2e8e/packages%2Fnext%2Fsrc%2Fserver%2Fconfig.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/0a45e33848f99c12068fcfa1c5121151b82a2e8e/packages%2Fnext%2Fsrc%2Fserver%2Fconfig.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fconfig.test.ts?ref=0a45e33848f99c12068fcfa1c5121151b82a2e8e",
            "patch": "@@ -1,6 +1,15 @@\n-import loadConfig from './config'\n-\n describe('loadConfig', () => {\n+  let loadConfig: typeof import('./config').default\n+\n+  beforeEach(async () => {\n+    // Reset the module cache to ensure each test gets a fresh config load\n+    // This is important because config.ts now has a module-level configCache\n+    jest.resetModules()\n+\n+    // Dynamically import the module after reset to get a fresh instance\n+    const configModule = await import('./config')\n+    loadConfig = configModule.default\n+  })\n   describe('nextConfig.images defaults', () => {\n     it('should assign a `images.remotePatterns` when using assetPrefix', async () => {\n       const result = await loadConfig('', __dirname, {"
        },
        {
            "sha": "7d50e7a82a04fb37256d00fabe610c535d5e12fa",
            "filename": "packages/next/src/server/config.ts",
            "status": "modified",
            "additions": 121,
            "deletions": 14,
            "changes": 135,
            "blob_url": "https://github.com/vercel/next.js/blob/0a45e33848f99c12068fcfa1c5121151b82a2e8e/packages%2Fnext%2Fsrc%2Fserver%2Fconfig.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/0a45e33848f99c12068fcfa1c5121151b82a2e8e/packages%2Fnext%2Fsrc%2Fserver%2Fconfig.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fconfig.ts?ref=0a45e33848f99c12068fcfa1c5121151b82a2e8e",
            "patch": "@@ -39,6 +39,7 @@ import { HTML_LIMITED_BOT_UA_RE_STRING } from '../shared/lib/router/utils/is-bot\n import { findDir } from '../lib/find-pages-dir'\n import { CanaryOnlyError, isStableBuild } from '../shared/lib/canary-only'\n import { interopDefault } from '../lib/interop-default'\n+import { djb2Hash } from '../shared/lib/hash'\n \n export { normalizeConfig } from './config-shared'\n export type { DomainLocale, NextConfig } from './config-shared'\n@@ -1164,6 +1165,38 @@ async function applyModifyConfig(\n   return config\n }\n \n+// Cache config with keys to handle multiple configurations (e.g., multi-zone)\n+const configCache = new Map<\n+  string,\n+  {\n+    rawConfig: any\n+    config: NextConfigComplete\n+    configuredExperimentalFeatures: ConfiguredExperimentalFeature[]\n+  }\n+>()\n+\n+// Generate cache key based on parameters that affect config output\n+// We need a unique key for cache because there can be multiple values\n+function getCacheKey(\n+  phase: string,\n+  dir: string,\n+  customConfig?: object | null,\n+  reactProductionProfiling?: boolean,\n+  debugPrerender?: boolean\n+): string {\n+  // The next.config.js is unique per project, so we can use the dir as the major key\n+  // to generate the unique config key.\n+  const keyData = JSON.stringify({\n+    dir,\n+    phase,\n+    hasCustomConfig: Boolean(customConfig),\n+    reactProductionProfiling: Boolean(reactProductionProfiling),\n+    debugPrerender: Boolean(debugPrerender),\n+  })\n+\n+  return djb2Hash(keyData).toString(36)\n+}\n+\n export default async function loadConfig(\n   phase: string,\n   dir: string,\n@@ -1185,6 +1218,32 @@ export default async function loadConfig(\n     debugPrerender?: boolean\n   } = {}\n ): Promise<NextConfigComplete> {\n+  // Generate cache key based on parameters that affect config output\n+  const cacheKey = getCacheKey(\n+    phase,\n+    dir,\n+    customConfig,\n+    reactProductionProfiling,\n+    debugPrerender\n+  )\n+\n+  // Check if we have a cached result\n+  const cachedResult = configCache.get(cacheKey)\n+  if (cachedResult) {\n+    // Call the experimental features callback if provided\n+    if (reportExperimentalFeatures) {\n+      reportExperimentalFeatures(cachedResult.configuredExperimentalFeatures)\n+    }\n+\n+    // Return raw config if requested and available\n+    if (rawConfig && cachedResult.rawConfig) {\n+      return cachedResult.rawConfig\n+    }\n+\n+    return cachedResult.config\n+  }\n+\n+  // Original implementation continues below...\n   if (!process.env.__NEXT_PRIVATE_RENDER_WORKER) {\n     try {\n       loadWebpackHook()\n@@ -1200,7 +1259,18 @@ export default async function loadConfig(\n   if (process.env.__NEXT_PRIVATE_STANDALONE_CONFIG) {\n     // we don't apply assignDefaults or modifyConfig here as it\n     // has already been applied\n-    return JSON.parse(process.env.__NEXT_PRIVATE_STANDALONE_CONFIG)\n+    const standaloneConfig = JSON.parse(\n+      process.env.__NEXT_PRIVATE_STANDALONE_CONFIG\n+    )\n+\n+    // Cache the standalone config\n+    configCache.set(cacheKey, {\n+      config: standaloneConfig,\n+      rawConfig: standaloneConfig,\n+      configuredExperimentalFeatures: [],\n+    })\n+\n+    return standaloneConfig\n   }\n \n   const curLog = silent\n@@ -1214,9 +1284,10 @@ export default async function loadConfig(\n   loadEnvConfig(dir, phase === PHASE_DEVELOPMENT_SERVER, curLog)\n \n   let configFileName = 'next.config.js'\n+  const configuredExperimentalFeatures: ConfiguredExperimentalFeature[] = []\n \n   if (customConfig) {\n-    return await applyModifyConfig(\n+    const config = await applyModifyConfig(\n       assignDefaults(\n         dir,\n         {\n@@ -1229,10 +1300,20 @@ export default async function loadConfig(\n       phase,\n       silent\n     )\n+\n+    // Cache the custom config result\n+    configCache.set(cacheKey, {\n+      config,\n+      rawConfig: customConfig,\n+      configuredExperimentalFeatures,\n+    })\n+\n+    reportExperimentalFeatures?.(configuredExperimentalFeatures)\n+\n+    return config\n   }\n \n   const path = await findUp(CONFIG_FILES, { cwd: dir })\n-  const configuredExperimentalFeatures: ConfiguredExperimentalFeature[] = []\n \n   // If config file was found\n   if (path?.length) {\n@@ -1269,6 +1350,15 @@ export default async function loadConfig(\n       updateInitialEnv(newEnv)\n \n       if (rawConfig) {\n+        // Cache the raw config\n+        configCache.set(cacheKey, {\n+          config: userConfigModule as NextConfigComplete,\n+          rawConfig: userConfigModule,\n+          configuredExperimentalFeatures,\n+        })\n+\n+        reportExperimentalFeatures?.(configuredExperimentalFeatures)\n+\n         return userConfigModule\n       }\n     } catch (err) {\n@@ -1286,7 +1376,7 @@ export default async function loadConfig(\n       )) as NextConfig\n     )\n \n-    if (reportExperimentalFeatures && loadedConfig.experimental) {\n+    if (loadedConfig.experimental) {\n       for (const name of Object.keys(\n         loadedConfig.experimental\n       ) as (keyof ExperimentalConfig)[]) {\n@@ -1308,13 +1398,16 @@ export default async function loadConfig(\n     // Clone a new userConfig each time to avoid mutating the original\n     const userConfig = cloneObject(loadedConfig) as NextConfig\n \n-    if (!process.env.NEXT_MINIMAL) {\n+    // Always validate the config against schema in non minimal mode.\n+    // Only validate once in the root Next.js process, not in forked processes.\n+    const isRootProcess = typeof process.send !== 'function'\n+    if (!process.env.NEXT_MINIMAL && isRootProcess) {\n       // We only validate the config against schema in non minimal mode\n       const { configSchema } =\n         require('./config-schema') as typeof import('./config-schema')\n       const state = configSchema.safeParse(userConfig)\n \n-      if (state.success === false) {\n+      if (!state.success) {\n         // error message header\n         const messages = [`Invalid ${configFileName} options detected: `]\n \n@@ -1426,9 +1519,7 @@ export default async function loadConfig(\n \n     enforceExperimentalFeatures(userConfig, {\n       isDefaultConfig: false,\n-      configuredExperimentalFeatures: reportExperimentalFeatures\n-        ? configuredExperimentalFeatures\n-        : undefined,\n+      configuredExperimentalFeatures,\n       debugPrerender,\n       phase,\n     })\n@@ -1444,11 +1535,20 @@ export default async function loadConfig(\n       silent\n     ) as NextConfigComplete\n \n+    const finalConfig = await applyModifyConfig(completeConfig, phase, silent)\n+\n+    // Cache the final result\n+    configCache.set(cacheKey, {\n+      config: finalConfig,\n+      rawConfig: userConfigModule, // Store the original user config module\n+      configuredExperimentalFeatures,\n+    })\n+\n     if (reportExperimentalFeatures) {\n       reportExperimentalFeatures(configuredExperimentalFeatures)\n     }\n \n-    return await applyModifyConfig(completeConfig, phase, silent)\n+    return finalConfig\n   } else {\n     const configBaseName = basename(CONFIG_FILES[0], extname(CONFIG_FILES[0]))\n     const unsupportedConfig = findUp.sync(\n@@ -1475,9 +1575,7 @@ export default async function loadConfig(\n \n   enforceExperimentalFeatures(clonedDefaultConfig, {\n     isDefaultConfig: true,\n-    configuredExperimentalFeatures: reportExperimentalFeatures\n-      ? configuredExperimentalFeatures\n-      : undefined,\n+    configuredExperimentalFeatures,\n     debugPrerender,\n     phase,\n   })\n@@ -1492,11 +1590,20 @@ export default async function loadConfig(\n \n   setHttpClientAndAgentOptions(completeConfig)\n \n+  const finalConfig = await applyModifyConfig(completeConfig, phase, silent)\n+\n+  // Cache the default config result\n+  configCache.set(cacheKey, {\n+    config: finalConfig,\n+    rawConfig: clonedDefaultConfig,\n+    configuredExperimentalFeatures,\n+  })\n+\n   if (reportExperimentalFeatures) {\n     reportExperimentalFeatures(configuredExperimentalFeatures)\n   }\n \n-  return await applyModifyConfig(completeConfig, phase, silent)\n+  return finalConfig\n }\n \n export type ConfiguredExperimentalFeature = {"
        },
        {
            "sha": "d0962e642af89d7570449c66fb74320ad04e09d7",
            "filename": "test/development/config-validation/index.test.ts",
            "status": "added",
            "additions": 54,
            "deletions": 0,
            "changes": 54,
            "blob_url": "https://github.com/vercel/next.js/blob/0a45e33848f99c12068fcfa1c5121151b82a2e8e/test%2Fdevelopment%2Fconfig-validation%2Findex.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/0a45e33848f99c12068fcfa1c5121151b82a2e8e/test%2Fdevelopment%2Fconfig-validation%2Findex.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Fconfig-validation%2Findex.test.ts?ref=0a45e33848f99c12068fcfa1c5121151b82a2e8e",
            "patch": "@@ -0,0 +1,54 @@\n+import stripAnsi from 'strip-ansi'\n+import { nextTestSetup } from 'e2e-utils'\n+\n+describe('config validation - validation only runs once', () => {\n+  const { next } = nextTestSetup({\n+    files: {\n+      'pages/index.js': `\n+    export default function Page() {\n+      return <p>hello world</p>\n+    }\n+    `,\n+      'next.config.js': `\n+    module.exports = {\n+      invalidOption: 'shouldTriggerValidation',\n+      anotherBadKey: 'anotherBadValue'\n+    }\n+    `,\n+    },\n+  })\n+\n+  it('should validate config only once in root process', async () => {\n+    await next.fetch('/')\n+    const output = stripAnsi(next.cliOutput)\n+    const validationHeaderMatches = output.match(\n+      /Invalid next\\.config\\.js options detected:/g\n+    )\n+    const validationHeaderCount = validationHeaderMatches\n+      ? validationHeaderMatches.length\n+      : 0\n+\n+    // Count occurrences of specific invalid option mentions\n+    const invalidOptionMatches = output.match(/invalidOption/g)\n+    const invalidOptionCount = invalidOptionMatches\n+      ? invalidOptionMatches.length\n+      : 0\n+\n+    const anotherBadKeyMatches = output.match(/anotherBadKey/g)\n+    const anotherBadKeyCount = anotherBadKeyMatches\n+      ? anotherBadKeyMatches.length\n+      : 0\n+\n+    // Expect validation to have occurred\n+    expect(output).toContain('Invalid next.config.js options detected')\n+    expect(output).toContain('invalidOption')\n+    expect(output).toContain('anotherBadKey')\n+\n+    // Expect validation header to appear only once (not multiple times from different processes)\n+    expect(validationHeaderCount).toBe(1)\n+\n+    // Each invalid option should also appear only once in the validation output\n+    expect(invalidOptionCount).toBe(1)\n+    expect(anotherBadKeyCount).toBe(1)\n+  })\n+})"
        },
        {
            "sha": "9e63ded76eedef2df27d822e6ebd6715e2190d00",
            "filename": "test/unit/isolated/config.test.ts",
            "status": "modified",
            "additions": 15,
            "deletions": 5,
            "changes": 20,
            "blob_url": "https://github.com/vercel/next.js/blob/0a45e33848f99c12068fcfa1c5121151b82a2e8e/test%2Funit%2Fisolated%2Fconfig.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/0a45e33848f99c12068fcfa1c5121151b82a2e8e/test%2Funit%2Fisolated%2Fconfig.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Funit%2Fisolated%2Fconfig.test.ts?ref=0a45e33848f99c12068fcfa1c5121151b82a2e8e",
            "patch": "@@ -1,6 +1,5 @@\n /* eslint-env jest */\n import { join } from 'path'\n-import loadConfig from 'next/dist/server/config'\n import { PHASE_DEVELOPMENT_SERVER } from 'next/constants'\n \n const pathToConfig = join(__dirname, '_resolvedata', 'without-function')\n@@ -11,6 +10,17 @@ const pathToConfigFn = join(__dirname, '_resolvedata', 'with-function')\n process.env.__NEXT_TEST_MODE = 'jest'\n \n describe('config', () => {\n+  let loadConfig: typeof import('next/dist/server/config').default\n+\n+  beforeEach(async () => {\n+    // Reset the module cache to ensure each test gets a fresh config load\n+    // This is important because config.ts now has a module-level configCache\n+    jest.resetModules()\n+\n+    // Dynamically import the module after reset to get a fresh instance\n+    const configModule = await import('next/dist/server/config')\n+    loadConfig = configModule.default\n+  })\n   it('Should get the configuration', async () => {\n     const config = await loadConfig(PHASE_DEVELOPMENT_SERVER, pathToConfig)\n     expect(config.customConfig).toBe(true)\n@@ -33,7 +43,7 @@ describe('config', () => {\n   })\n \n   it('Should pass the customConfig correctly', async () => {\n-    const config = await loadConfig(PHASE_DEVELOPMENT_SERVER, null, {\n+    const config = await loadConfig(PHASE_DEVELOPMENT_SERVER, '<rootDir>', {\n       customConfig: {\n         customConfigKey: 'customConfigValue',\n       },\n@@ -42,7 +52,7 @@ describe('config', () => {\n   })\n \n   it('Should assign object defaults deeply to customConfig', async () => {\n-    const config = await loadConfig(PHASE_DEVELOPMENT_SERVER, null, {\n+    const config = await loadConfig(PHASE_DEVELOPMENT_SERVER, '<rootDir>', {\n       customConfig: {\n         customConfig: true,\n         onDemandEntries: { custom: true },\n@@ -53,7 +63,7 @@ describe('config', () => {\n   })\n \n   it('Should allow setting objects which do not have defaults', async () => {\n-    const config = await loadConfig(PHASE_DEVELOPMENT_SERVER, null, {\n+    const config = await loadConfig(PHASE_DEVELOPMENT_SERVER, '<rootDir>', {\n       customConfig: {\n         bogusSetting: { custom: true },\n       },\n@@ -63,7 +73,7 @@ describe('config', () => {\n   })\n \n   it('Should override defaults for arrays from user arrays', async () => {\n-    const config = await loadConfig(PHASE_DEVELOPMENT_SERVER, null, {\n+    const config = await loadConfig(PHASE_DEVELOPMENT_SERVER, '<rootDir>', {\n       customConfig: {\n         pageExtensions: ['.bogus'],\n       },"
        }
    ],
    "stats": {
        "total": 226,
        "additions": 204,
        "deletions": 22
    }
}