{
    "author": "bgw",
    "message": "fix(turbo-persistence): Atomically mark old versioned directories for deletion before deleting them (#80082)\n\nThis uses a trick similar to what I did in https://app.graphite.dev/github/pr/vercel/next.js/79425 to mark the directory for deletion using an atomic operation (a directory rename in this case) before deleting it, so that we can resume the deletion upon restart if we're interrupted while deleting the directory.\n\nThis may be important as deleting large directories can take some time.\n\nI think this is the source of these user reports: https://vercel.slack.com/archives/C046HAU4H7F/p1748616184765179",
    "sha": "1a42db2b21522ce7d0b3536a9a7edbf6b4522a0c",
    "files": [
        {
            "sha": "f580cbc1fac1e093fa136e421b5663dec76b3e9f",
            "filename": "Cargo.lock",
            "status": "modified",
            "additions": 29,
            "deletions": 8,
            "changes": 37,
            "blob_url": "https://github.com/vercel/next.js/blob/1a42db2b21522ce7d0b3536a9a7edbf6b4522a0c/Cargo.lock",
            "raw_url": "https://github.com/vercel/next.js/raw/1a42db2b21522ce7d0b3536a9a7edbf6b4522a0c/Cargo.lock",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/Cargo.lock?ref=1a42db2b21522ce7d0b3536a9a7edbf6b4522a0c",
            "patch": "@@ -2308,12 +2308,12 @@ dependencies = [\n \n [[package]]\n name = \"errno\"\n-version = \"0.3.8\"\n+version = \"0.3.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a258e46cdc063eb8519c00b9fc845fc47bcfca4130e2f08e88665ceda8474245\"\n+checksum = \"cea14ef9355e3beab063703aa9dab15afd25f0667c341310c1e5274bb1d0da18\"\n dependencies = [\n  \"libc\",\n- \"windows-sys 0.52.0\",\n+ \"windows-sys 0.59.0\",\n ]\n \n [[package]]\n@@ -3033,7 +3033,7 @@ dependencies = [\n  \"httpdate\",\n  \"itoa\",\n  \"pin-project-lite\",\n- \"socket2 0.4.9\",\n+ \"socket2 0.5.8\",\n  \"tokio\",\n  \"tower-service\",\n  \"tracing\",\n@@ -4039,6 +4039,12 @@ version = \"0.4.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"78b3ae25bc7c8c38cec158d1f2757ee79e9b3740fbc7ccf0e59e4b08d793fa89\"\n \n+[[package]]\n+name = \"linux-raw-sys\"\n+version = \"0.9.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"cd945864f07fe9f5371a27ad7b52a172b4b499999f1d97574c9fa68373937e12\"\n+\n [[package]]\n name = \"litemap\"\n version = \"0.7.4\"\n@@ -6478,6 +6484,19 @@ dependencies = [\n  \"windows-sys 0.52.0\",\n ]\n \n+[[package]]\n+name = \"rustix\"\n+version = \"1.0.7\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c71e83d6afe7ff64890ec6b71d6a69bb8a610ab78ce364b3352876bb4c801266\"\n+dependencies = [\n+ \"bitflags 2.9.0\",\n+ \"errno\",\n+ \"libc\",\n+ \"linux-raw-sys 0.9.4\",\n+ \"windows-sys 0.59.0\",\n+]\n+\n [[package]]\n name = \"rustls\"\n version = \"0.20.9\"\n@@ -8820,14 +8839,14 @@ checksum = \"1ac9aa371f599d22256307c24a9d748c041e548cbf599f35d890f9d365361790\"\n \n [[package]]\n name = \"tempfile\"\n-version = \"3.14.0\"\n+version = \"3.20.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"28cce251fcbc87fac86a866eeb0d6c2d536fc16d06f184bb61aeae11aa4cee0c\"\n+checksum = \"e8a64e3985349f2441a1a9ef0b853f869006c3855f2cda6862a94d26ebb9d6a1\"\n dependencies = [\n- \"cfg-if\",\n  \"fastrand 2.2.0\",\n+ \"getrandom 0.3.2\",\n  \"once_cell\",\n- \"rustix 0.38.41\",\n+ \"rustix 1.0.7\",\n  \"windows-sys 0.59.0\",\n ]\n \n@@ -9611,11 +9630,13 @@ dependencies = [\n  \"rand 0.9.0\",\n  \"rayon\",\n  \"regex\",\n+ \"rstest\",\n  \"rustc-hash 2.1.1\",\n  \"serde\",\n  \"serde_json\",\n  \"serde_path_to_error\",\n  \"smallvec\",\n+ \"tempfile\",\n  \"thread_local\",\n  \"tokio\",\n  \"tracing\","
        },
        {
            "sha": "057f8ec9a3bc5ec3c6d040c99fb87ce48e36da39",
            "filename": "Cargo.toml",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/1a42db2b21522ce7d0b3536a9a7edbf6b4522a0c/Cargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/1a42db2b21522ce7d0b3536a9a7edbf6b4522a0c/Cargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/Cargo.toml?ref=1a42db2b21522ce7d0b3536a9a7edbf6b4522a0c",
            "patch": "@@ -406,7 +406,7 @@ sourcemap = \"9.2.2\"\n strsim = \"0.11.1\"\n shrink-to-fit = \"0.2.10\"\n syn = \"2.0.100\"\n-tempfile = \"3.3.0\"\n+tempfile = \"3.20.0\"\n thread_local = \"1.1.8\"\n thiserror = \"1.0.48\"\n tokio = \"1.43.0\""
        },
        {
            "sha": "bef7fac892f0fd29f22f801970ec1cade99dee38",
            "filename": "turbopack/crates/turbo-persistence/Cargo.toml",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/1a42db2b21522ce7d0b3536a9a7edbf6b4522a0c/turbopack%2Fcrates%2Fturbo-persistence%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/1a42db2b21522ce7d0b3536a9a7edbf6b4522a0c/turbopack%2Fcrates%2Fturbo-persistence%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-persistence%2FCargo.toml?ref=1a42db2b21522ce7d0b3536a9a7edbf6b4522a0c",
            "patch": "@@ -31,7 +31,7 @@ zstd = { version = \"0.13.2\", features = [\"zdict_builder\"] }\n \n [dev-dependencies]\n rand = { workspace = true, features = [\"small_rng\"] }\n-tempfile = \"3.14.0\"\n+tempfile = { workspace = true }\n \n [lints]\n workspace = true"
        },
        {
            "sha": "095f689d57d46d06365b631cfb1cc76bb3086021",
            "filename": "turbopack/crates/turbo-tasks-backend/Cargo.toml",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/1a42db2b21522ce7d0b3536a9a7edbf6b4522a0c/turbopack%2Fcrates%2Fturbo-tasks-backend%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/1a42db2b21522ce7d0b3536a9a7edbf6b4522a0c/turbopack%2Fcrates%2Fturbo-tasks-backend%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2FCargo.toml?ref=1a42db2b21522ce7d0b3536a9a7edbf6b4522a0c",
            "patch": "@@ -55,6 +55,8 @@ turbo-tasks-testing = { workspace = true }\n criterion = { workspace = true, features = [\"async_tokio\"] }\n regex = { workspace = true }\n serde_json = { workspace = true }\n+tempfile = { workspace = true }\n+rstest = { workspace = true }\n \n [build-dependencies]\n turbo-tasks-build = { workspace = true }"
        },
        {
            "sha": "d523108f548a91453d18022721c9f0e070d47d37",
            "filename": "turbopack/crates/turbo-tasks-backend/src/database/db_versioning.rs",
            "status": "modified",
            "additions": 159,
            "deletions": 39,
            "changes": 198,
            "blob_url": "https://github.com/vercel/next.js/blob/1a42db2b21522ce7d0b3536a9a7edbf6b4522a0c/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdatabase%2Fdb_versioning.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1a42db2b21522ce7d0b3536a9a7edbf6b4522a0c/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdatabase%2Fdb_versioning.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdatabase%2Fdb_versioning.rs?ref=1a42db2b21522ce7d0b3536a9a7edbf6b4522a0c",
            "patch": "@@ -1,6 +1,7 @@\n use std::{\n     env,\n-    fs::{metadata, read_dir, remove_dir_all},\n+    ffi::{OsStr, OsString},\n+    fs::{DirEntry, read_dir, remove_dir_all, rename},\n     path::{Path, PathBuf},\n     time::Duration,\n };\n@@ -21,10 +22,23 @@ pub struct GitVersionInfo<'a> {\n }\n \n /// Specifies many databases that have a different version than the current one are retained.\n-/// For example if MAX_OTHER_DB_VERSIONS is 2, there can be at most 3 databases in the directory,\n-/// the current one and two older/newer ones. On CI it never keeps any other versions.\n-const MAX_OTHER_DB_VERSIONS: usize = 2;\n+/// For example if `DEFAULT_MAX_OTHER_DB_VERSIONS` is 2, there can be at most 3 databases in the\n+/// directory, the current one and two older/newer ones. On CI it never keeps any other versions.\n+const DEFAULT_MAX_OTHER_DB_VERSIONS: usize = 2;\n \n+/// Directories are prefixed with this before being deleted, so that if we fail to fully delete the\n+/// directory, we can pick up where we left off last time.\n+const DELETION_PREFIX: &str = \"__stale_\";\n+\n+/// Given a base path, creates a version directory for the given `version_info`. Automatically\n+/// cleans up old/stale databases.\n+///\n+/// **Envrionment Variables**\n+/// - `TURBO_ENGINE_VERSION`: Forces use of a specific database version.\n+/// - `TURBO_ENGINE_IGNORE_DIRTY`: Enable persistent caching in a dirty git repository. Otherwise a\n+///   temporary directory is created.\n+/// - `TURBO_ENGINE_DISABLE_VERSIONING`: Ignores versioning and always uses the same \"unversioned\"\n+///   database when set.\n pub fn handle_db_versioning(\n     base_path: &Path,\n     version_info: &GitVersionInfo,\n@@ -33,9 +47,6 @@ pub fn handle_db_versioning(\n     if let Ok(version) = env::var(\"TURBO_ENGINE_VERSION\") {\n         return Ok(base_path.join(version));\n     }\n-    // Database versioning. Pass `TURBO_ENGINE_IGNORE_DIRTY` at runtime to ignore a\n-    // dirty git repository. Pass `TURBO_ENGINE_DISABLE_VERSIONING` at runtime to disable\n-    // versioning and always use the same database.\n     let ignore_dirty = env::var(\"TURBO_ENGINE_IGNORE_DIRTY\").ok().is_some();\n     let disabled_versioning = env::var(\"TURBO_ENGINE_DISABLE_VERSIONING\").ok().is_some();\n     let version = if disabled_versioning {\n@@ -63,48 +74,157 @@ pub fn handle_db_versioning(\n     if let Some(version) = version {\n         path = base_path.join(version);\n \n-        let max_other_db_versions = if is_ci { 0 } else { MAX_OTHER_DB_VERSIONS };\n+        let max_other_db_versions = if is_ci {\n+            0\n+        } else {\n+            DEFAULT_MAX_OTHER_DB_VERSIONS\n+        };\n \n-        // Remove old databases if needed\n         if let Ok(read_dir) = read_dir(base_path) {\n-            let old_dbs = read_dir\n-                .filter_map(|entry| {\n-                    let entry = entry.ok()?;\n-                    if !entry.file_type().ok()?.is_dir() {\n-                        return None;\n+            let mut old_dbs = Vec::new();\n+            for entry in read_dir {\n+                let Ok(entry) = entry else { continue };\n+\n+                // skip our target version (if it exists)\n+                let name = entry.file_name();\n+                if name == version {\n+                    continue;\n+                }\n+\n+                // skip non-directories\n+                let Ok(file_type) = entry.file_type() else {\n+                    continue;\n+                };\n+                if !file_type.is_dir() {\n+                    continue;\n+                }\n+\n+                // Find and try to finish removing any partially deleted directories\n+                if name\n+                    .as_encoded_bytes()\n+                    .starts_with(AsRef::<OsStr>::as_ref(DELETION_PREFIX).as_encoded_bytes())\n+                {\n+                    // failures during cleanup of a cache directory are not fatal\n+                    let _ = remove_dir_all(entry.path());\n+                    continue;\n+                }\n+\n+                old_dbs.push(entry);\n+            }\n+\n+            if old_dbs.len() > max_other_db_versions {\n+                old_dbs.sort_by_cached_key(|entry| {\n+                    fn get_age(e: &DirEntry) -> Result<Duration> {\n+                        let m = e.metadata()?;\n+                        // Maybe change this: We care more about the atime/mtime of the files inside\n+                        // the directory than the directory itself. atime is also fragile because it\n+                        // can be impacted by recursive scanning tools (e.g. ripgrep). It might be\n+                        // better for us to always explicitly touch a specific file inside the\n+                        // versioned directory when reading the cache, and then use that file's\n+                        // mtime.\n+                        Ok(m.accessed().or_else(|_| m.modified())?.elapsed()?)\n                     }\n-                    let name = entry.file_name();\n-                    let name = name.to_string_lossy();\n-                    if name == version {\n-                        return None;\n+                    get_age(entry).unwrap_or(Duration::MAX)\n+                });\n+                for entry in old_dbs.into_iter().skip(max_other_db_versions) {\n+                    let mut new_name = OsString::from(DELETION_PREFIX);\n+                    new_name.push(entry.file_name());\n+                    let new_path = base_path.join(new_name);\n+                    // rename first, it's an atomic operation\n+                    let rename_result = rename(entry.path(), &new_path);\n+                    // Only try to delete the files if the rename succeeded, it's not safe to delete\n+                    // contents if we didn't manage to first poison the directory by renaming it.\n+                    if rename_result.is_ok() {\n+                        // It's okay if this fails, as we've already poisoned the directory.\n+                        let _ = remove_dir_all(&new_path);\n                     }\n-                    Some(entry.path())\n-                })\n-                .collect::<Vec<_>>();\n-            if old_dbs.len() > max_other_db_versions {\n-                let mut old_dbs = old_dbs\n-                    .iter()\n-                    .map(|p| {\n-                        fn get_age(p: &Path) -> Result<Duration> {\n-                            let m = metadata(p)?;\n-                            Ok(m.accessed().or_else(|_| m.modified())?.elapsed()?)\n-                        }\n-                        (\n-                            p,\n-                            get_age(p).unwrap_or(Duration::from_secs(10 * 356 * 24 * 60 * 60)),\n-                        )\n-                    })\n-                    .collect::<Vec<_>>();\n-                old_dbs.sort_by_key(|(_, age)| *age);\n-                for (p, _) in old_dbs.into_iter().skip(max_other_db_versions) {\n-                    let _ = remove_dir_all(p);\n                 }\n             }\n         }\n     } else {\n         path = base_path.join(\"temp\");\n-        let _ = remove_dir_all(&path);\n+        // propagate errors: if this fails we may have stale files left over in the temp directory\n+        remove_dir_all(&path)?;\n     }\n \n     Ok(path)\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use std::{fs, thread::sleep};\n+\n+    use rstest::rstest;\n+    use tempfile::TempDir;\n+\n+    use super::*;\n+\n+    fn count_entries(base_path: &Path) -> usize {\n+        fs::read_dir(base_path)\n+            .unwrap()\n+            .collect::<Result<Vec<_>, _>>()\n+            .unwrap()\n+            .len()\n+    }\n+\n+    #[rstest]\n+    #[case::not_ci(false, DEFAULT_MAX_OTHER_DB_VERSIONS)]\n+    #[case::ci(true, 0)]\n+    fn test_max_versions(#[case] is_ci: bool, #[case] max_other_db_versions: usize) {\n+        let tmp_dir = TempDir::new().unwrap();\n+        let base_path = tmp_dir.path();\n+        let current_version_name = \"mock-version\";\n+\n+        let version_info = GitVersionInfo {\n+            describe: current_version_name,\n+            dirty: false,\n+        };\n+\n+        fs::create_dir(base_path.join(current_version_name)).unwrap();\n+\n+        // sleep to ensure `current_version_name` has the oldest atime/mtime\n+        // it should be preserved regardless of atime/mtime\n+        sleep(Duration::from_millis(100));\n+\n+        let num_other_dirs = max_other_db_versions + 3;\n+        for i in 0..num_other_dirs {\n+            fs::create_dir(base_path.join(format!(\"other-dir-{i}\"))).unwrap();\n+        }\n+\n+        assert_eq!(\n+            count_entries(base_path),\n+            num_other_dirs + 1, // +1 for current version\n+        );\n+\n+        let versioned_path = handle_db_versioning(base_path, &version_info, is_ci).unwrap();\n+\n+        assert_eq!(versioned_path, base_path.join(current_version_name));\n+        assert!(base_path.join(current_version_name).exists());\n+        assert_eq!(\n+            count_entries(base_path),\n+            max_other_db_versions + 1, // +1 for current version\n+        );\n+    }\n+\n+    #[test]\n+    fn test_cleanup_of_prefixed_items() {\n+        let tmp_dir = TempDir::new().unwrap();\n+        let base_path = tmp_dir.path();\n+        let current_version_name = \"mock-version\";\n+\n+        let version_info = GitVersionInfo {\n+            describe: current_version_name,\n+            dirty: false,\n+        };\n+\n+        for i in 0..5 {\n+            fs::create_dir(base_path.join(format!(\"{DELETION_PREFIX}other-dir-{i}\"))).unwrap();\n+        }\n+\n+        assert_eq!(count_entries(base_path), 5);\n+\n+        handle_db_versioning(base_path, &version_info, /* is_ci */ false).unwrap();\n+\n+        assert_eq!(count_entries(base_path), 0);\n+    }\n+}"
        }
    ],
    "stats": {
        "total": 241,
        "additions": 192,
        "deletions": 49
    }
}