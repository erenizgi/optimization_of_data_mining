{
    "author": "bgw",
    "message": "feat(turbopack): Invalidate the persistent cache upon panic (#80225)\n\nThis is intended as a band-aid \"fix\" for persistent caching where issues stick around after restarts of the development server. It builds on top of the same codepath we're using for the explicit cache clearing button in the devtools.\n\nAs part of this work, this adds a centralized registry for dynamically-registered panic hooks.\n\n## Notes & Next Steps\n\n- I'll disable this behavior for Vercel employees in front, so that we continue to get valuable bug reports.\n- I'll follow up with some warning message in the terminal so that the subsequent restart of `next dev` will warn the user that the persistent cache was cleared and that's why build may be slow.\n- We've got a some in-progress work handed to me from @wbinnssmith for better logging of anonymized (uncaught) panics to telemetry, so that should be useful in cases like this.\n- Yes, this will still invalidate the cache on caught panics. I'm not 100% sure that's the behavior we want, but I think it is.\n\n## Test Plan\n\nBuilt with:\n\n```\npnpm pack-next -p ~/front/apps/vercel-site\ncd ~/front\npnpm i\npnpm turbo --filter=vercel-site dev\n```\n\nRestarted a few times and looked at the persistent cache files and saw that they keep accumulating.\n\nThen, deleted a random `.sst` file, restarted, and observed a bunch of panics. Saw that the invalidation file was written. Restarted the server again and saw that it recovered itself by clearing the cache.",
    "sha": "4250c5b318be660a94ce58252ab9dcb68a992741",
    "files": [
        {
            "sha": "e340ae7edb3640f5da7de566c501e88a54326287",
            "filename": "crates/napi/src/lib.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/4250c5b318be660a94ce58252ab9dcb68a992741/crates%2Fnapi%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4250c5b318be660a94ce58252ab9dcb68a992741/crates%2Fnapi%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnapi%2Fsrc%2Flib.rs?ref=4250c5b318be660a94ce58252ab9dcb68a992741",
            "patch": "@@ -72,7 +72,7 @@ fn init() {\n     use std::panic::{set_hook, take_hook};\n \n     use tokio::runtime::Builder;\n-    use turbo_tasks::handle_panic;\n+    use turbo_tasks::panic_hooks::handle_panic;\n     use turbo_tasks_malloc::TurboMalloc;\n \n     let prev_hook = take_hook();"
        },
        {
            "sha": "7eb82f8b890e8d1aa09cd9f7d1cebd3edc906dd3",
            "filename": "turbopack/crates/turbo-tasks-backend/src/kv_backing_storage.rs",
            "status": "modified",
            "additions": 128,
            "deletions": 34,
            "changes": 162,
            "blob_url": "https://github.com/vercel/next.js/blob/4250c5b318be660a94ce58252ab9dcb68a992741/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fkv_backing_storage.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4250c5b318be660a94ce58252ab9dcb68a992741/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fkv_backing_storage.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fkv_backing_storage.rs?ref=4250c5b318be660a94ce58252ab9dcb68a992741",
            "patch": "@@ -1,11 +1,22 @@\n-use std::{borrow::Borrow, cmp::max, path::PathBuf, sync::Arc};\n+use std::{\n+    borrow::Borrow,\n+    cmp::max,\n+    env,\n+    path::PathBuf,\n+    sync::{Arc, LazyLock, Mutex, PoisonError, Weak},\n+};\n \n use anyhow::{Context, Result, anyhow};\n use rayon::iter::{IndexedParallelIterator, IntoParallelIterator, ParallelIterator};\n use serde::{Deserialize, Serialize};\n use smallvec::SmallVec;\n use tracing::Span;\n-use turbo_tasks::{SessionId, TaskId, backend::CachedTaskType, turbo_tasks_scope};\n+use turbo_tasks::{\n+    SessionId, TaskId,\n+    backend::CachedTaskType,\n+    panic_hooks::{PanicHookGuard, register_panic_hook},\n+    turbo_tasks_scope,\n+};\n \n use crate::{\n     GitVersionInfo,\n@@ -83,18 +94,48 @@ fn as_u32(bytes: impl Borrow<[u8]>) -> Result<u32> {\n     Ok(n)\n }\n \n-pub struct KeyValueDatabaseBackingStorage<T: KeyValueDatabase> {\n+// We want to invalidate the cache on panic for most users, but this is a band-aid to underlying\n+// problems in turbo-tasks.\n+//\n+// If we invalidate the cache upon panic and it \"fixes\" the issue upon restart, users typically\n+// won't report bugs to us, and we'll never find root-causes for these problems.\n+//\n+// These overrides let us avoid the cache invalidation / error suppression within Vercel so that we\n+// feel these pain points and fix the root causes of bugs.\n+fn should_invalidate_on_panic() -> bool {\n+    fn env_is_falsy(key: &str) -> bool {\n+        env::var_os(key)\n+            .is_none_or(|value| [\"\".as_ref(), \"0\".as_ref(), \"false\".as_ref()].contains(&&*value))\n+    }\n+    static SHOULD_INVALIDATE: LazyLock<bool> = LazyLock::new(|| {\n+        env_is_falsy(\"TURBO_ENGINE_SKIP_INVALIDATE_ON_PANIC\") && env_is_falsy(\"__NEXT_TEST_MODE\")\n+    });\n+    *SHOULD_INVALIDATE\n+}\n+\n+pub struct KeyValueDatabaseBackingStorageInner<T: KeyValueDatabase> {\n     database: T,\n     /// Used when calling [`BackingStorage::invalidate`]. Can be `None` in the memory-only/no-op\n     /// storage case.\n     base_path: Option<PathBuf>,\n+    /// Used to skip calling [`invalidate_db`] when the database has already been invalidated.\n+    invalidated: Mutex<bool>,\n+    _panic_hook_guard: Option<PanicHookGuard>,\n+}\n+\n+pub struct KeyValueDatabaseBackingStorage<T: KeyValueDatabase> {\n+    inner: Arc<KeyValueDatabaseBackingStorageInner<T>>,\n }\n \n impl<T: KeyValueDatabase> KeyValueDatabaseBackingStorage<T> {\n     pub fn new_in_memory(database: T) -> Self {\n         Self {\n-            database,\n-            base_path: None,\n+            inner: Arc::new(KeyValueDatabaseBackingStorageInner {\n+                database,\n+                base_path: None,\n+                invalidated: Mutex::new(false),\n+                _panic_hook_guard: None,\n+            }),\n         }\n     }\n \n@@ -103,15 +144,44 @@ impl<T: KeyValueDatabase> KeyValueDatabaseBackingStorage<T> {\n         version_info: &GitVersionInfo,\n         is_ci: bool,\n         database: impl FnOnce(PathBuf) -> Result<T>,\n-    ) -> Result<Self> {\n+    ) -> Result<Self>\n+    where\n+        T: Send + Sync + 'static,\n+    {\n         check_db_invalidation_and_cleanup(&base_path)?;\n         let versioned_path = handle_db_versioning(&base_path, version_info, is_ci)?;\n+        let database = (database)(versioned_path)?;\n         Ok(Self {\n-            database: (database)(versioned_path)?,\n-            base_path: Some(base_path),\n+            inner: Arc::new_cyclic(\n+                move |weak_inner: &Weak<KeyValueDatabaseBackingStorageInner<T>>| {\n+                    let panic_hook_guard = if should_invalidate_on_panic() {\n+                        let weak_inner = weak_inner.clone();\n+                        Some(register_panic_hook(Box::new(move |_| {\n+                            let Some(inner) = weak_inner.upgrade() else {\n+                                return;\n+                            };\n+                            // If a panic happened that must mean something deep inside of turbopack\n+                            // or turbo-tasks failed, and it may be hard to recover. We don't want\n+                            // the cache to stick around, as that may persist bugs. Make a\n+                            // best-effort attempt to invalidate the database (ignoring failures).\n+                            let _ = inner.invalidate();\n+                        })))\n+                    } else {\n+                        None\n+                    };\n+                    KeyValueDatabaseBackingStorageInner {\n+                        database,\n+                        base_path: Some(base_path),\n+                        invalidated: Mutex::new(false),\n+                        _panic_hook_guard: panic_hook_guard,\n+                    }\n+                },\n+            ),\n         })\n     }\n+}\n \n+impl<T: KeyValueDatabase> KeyValueDatabaseBackingStorageInner<T> {\n     fn with_tx<R>(\n         &self,\n         tx: Option<&T::ReadTransaction<'_>>,\n@@ -126,14 +196,38 @@ impl<T: KeyValueDatabase> KeyValueDatabaseBackingStorage<T> {\n             Ok(r)\n         }\n     }\n-}\n \n-fn get_infra_u32(database: &impl KeyValueDatabase, key: u32) -> Result<Option<u32>> {\n-    let tx = database.begin_read_transaction()?;\n-    database\n-        .get(&tx, KeySpace::Infra, IntKey::new(key).as_ref())?\n-        .map(as_u32)\n-        .transpose()\n+    fn invalidate(&self) -> Result<()> {\n+        // `base_path` can be `None` for a `NoopKvDb`\n+        if let Some(base_path) = &self.base_path {\n+            // Invalidation could happen frequently if there's a bunch of panics. We only need to\n+            // invalidate once, so grab a lock.\n+            let mut invalidated_guard = self\n+                .invalidated\n+                .lock()\n+                .unwrap_or_else(PoisonError::into_inner);\n+            if *invalidated_guard {\n+                return Ok(());\n+            }\n+            // Invalidate first, as it's a very fast atomic operation. `prevent_writes` is allowed\n+            // to be slower (e.g. wait for a lock) and is allowed to corrupt the database with\n+            // partial writes.\n+            invalidate_db(base_path)?;\n+            self.database.prevent_writes();\n+            // Avoid redundant invalidations from future panics\n+            *invalidated_guard = true;\n+        }\n+        Ok(())\n+    }\n+\n+    /// Used to read the previous session id and the next free task ID from the database.\n+    fn get_infra_u32(&self, key: u32) -> Result<Option<u32>> {\n+        let tx = self.database.begin_read_transaction()?;\n+        self.database\n+            .get(&tx, KeySpace::Infra, IntKey::new(key).as_ref())?\n+            .map(as_u32)\n+            .transpose()\n+    }\n }\n \n impl<T: KeyValueDatabase + Send + Sync + 'static> BackingStorage\n@@ -149,15 +243,17 @@ impl<T: KeyValueDatabase + Send + Sync + 'static> BackingStorage\n \n     fn next_free_task_id(&self) -> Result<TaskId> {\n         Ok(TaskId::try_from(\n-            get_infra_u32(&self.database, META_KEY_NEXT_FREE_TASK_ID)\n+            self.inner\n+                .get_infra_u32(META_KEY_NEXT_FREE_TASK_ID)\n                 .context(\"Unable to read next free task id from database\")?\n                 .unwrap_or(1),\n         )?)\n     }\n \n     fn next_session_id(&self) -> Result<SessionId> {\n         Ok(SessionId::try_from(\n-            get_infra_u32(&self.database, META_KEY_SESSION_ID)\n+            self.inner\n+                .get_infra_u32(META_KEY_SESSION_ID)\n                 .context(\"Unable to read session id from database\")?\n                 .unwrap_or(0)\n                 + 1,\n@@ -178,7 +274,7 @@ impl<T: KeyValueDatabase + Send + Sync + 'static> BackingStorage\n             let operations = deserialize_with_good_error(operations.borrow())?;\n             Ok(operations)\n         }\n-        get(&self.database).context(\"Unable to read uncompleted operations from database\")\n+        get(&self.inner.database).context(\"Unable to read uncompleted operations from database\")\n     }\n \n     fn serialize(task: TaskId, data: &Vec<CachedDataItem>) -> Result<SmallVec<[u8; 16]>> {\n@@ -203,7 +299,7 @@ impl<T: KeyValueDatabase + Send + Sync + 'static> BackingStorage\n             + Sync,\n     {\n         let _span = tracing::trace_span!(\"save snapshot\", session_id = ?session_id, operations = operations.len());\n-        let mut batch = self.database.write_batch()?;\n+        let mut batch = self.inner.database.write_batch()?;\n \n         // Start organizing the updates in parallel\n         match &mut batch {\n@@ -380,14 +476,15 @@ impl<T: KeyValueDatabase + Send + Sync + 'static> BackingStorage\n     }\n \n     fn start_read_transaction(&self) -> Option<Self::ReadTransaction<'_>> {\n-        self.database.begin_read_transaction().ok()\n+        self.inner.database.begin_read_transaction().ok()\n     }\n \n     unsafe fn forward_lookup_task_cache(\n         &self,\n         tx: Option<&T::ReadTransaction<'_>>,\n         task_type: &CachedTaskType,\n     ) -> Result<Option<TaskId>> {\n+        let inner = &*self.inner;\n         fn lookup<D: KeyValueDatabase>(\n             database: &D,\n             tx: &D::ReadTransaction<'_>,\n@@ -401,12 +498,13 @@ impl<T: KeyValueDatabase + Send + Sync + 'static> BackingStorage\n             let id = TaskId::try_from(u32::from_le_bytes(bytes)).unwrap();\n             Ok(Some(id))\n         }\n-        if self.database.is_empty() {\n+        if inner.database.is_empty() {\n             // Checking if the database is empty is a performance optimization\n             // to avoid serializing the task type.\n             return Ok(None);\n         }\n-        self.with_tx(tx, |tx| lookup(&self.database, tx, task_type))\n+        inner\n+            .with_tx(tx, |tx| lookup(&self.inner.database, tx, task_type))\n             .with_context(|| format!(\"Looking up task id for {task_type:?} from database failed\"))\n     }\n \n@@ -415,6 +513,7 @@ impl<T: KeyValueDatabase + Send + Sync + 'static> BackingStorage\n         tx: Option<&T::ReadTransaction<'_>>,\n         task_id: TaskId,\n     ) -> Result<Option<Arc<CachedTaskType>>> {\n+        let inner = &*self.inner;\n         fn lookup<D: KeyValueDatabase>(\n             database: &D,\n             tx: &D::ReadTransaction<'_>,\n@@ -430,7 +529,8 @@ impl<T: KeyValueDatabase + Send + Sync + 'static> BackingStorage\n             };\n             Ok(Some(deserialize_with_good_error(bytes.borrow())?))\n         }\n-        self.with_tx(tx, |tx| lookup(&self.database, tx, task_id))\n+        inner\n+            .with_tx(tx, |tx| lookup(&inner.database, tx, task_id))\n             .with_context(|| format!(\"Looking up task type for {task_id} from database failed\"))\n     }\n \n@@ -440,6 +540,7 @@ impl<T: KeyValueDatabase + Send + Sync + 'static> BackingStorage\n         task_id: TaskId,\n         category: TaskDataCategory,\n     ) -> Result<Vec<CachedDataItem>> {\n+        let inner = &*self.inner;\n         fn lookup<D: KeyValueDatabase>(\n             database: &D,\n             tx: &D::ReadTransaction<'_>,\n@@ -461,24 +562,17 @@ impl<T: KeyValueDatabase + Send + Sync + 'static> BackingStorage\n             let result: Vec<CachedDataItem> = deserialize_with_good_error(bytes.borrow())?;\n             Ok(result)\n         }\n-        self.with_tx(tx, |tx| lookup(&self.database, tx, task_id, category))\n+        inner\n+            .with_tx(tx, |tx| lookup(&inner.database, tx, task_id, category))\n             .with_context(|| format!(\"Looking up data for {task_id} from database failed\"))\n     }\n \n     fn invalidate(&self) -> Result<()> {\n-        // `base_path` can be `None` for a `NoopKvDb`\n-        if let Some(base_path) = &self.base_path {\n-            // Invalidate first, as it's a very fast atomic operation. `prevent_writes` is allowed\n-            // to be slower (e.g. wait for a lock) and is allowed to corrupt the database with\n-            // partial writes.\n-            invalidate_db(base_path)?;\n-            self.database.prevent_writes()\n-        }\n-        Ok(())\n+        self.inner.invalidate()\n     }\n \n     fn shutdown(&self) -> Result<()> {\n-        self.database.shutdown()\n+        self.inner.database.shutdown()\n     }\n }\n "
        },
        {
            "sha": "d321e825f1430d826ce075307e0cd3f72b74c1ba",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/panics.rs",
            "status": "modified",
            "additions": 22,
            "deletions": 3,
            "changes": 25,
            "blob_url": "https://github.com/vercel/next.js/blob/4250c5b318be660a94ce58252ab9dcb68a992741/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fpanics.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4250c5b318be660a94ce58252ab9dcb68a992741/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fpanics.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fpanics.rs?ref=4250c5b318be660a94ce58252ab9dcb68a992741",
            "patch": "@@ -1,30 +1,49 @@\n use core::panic;\n use std::{\n     panic::{set_hook, take_hook},\n-    sync::LazyLock,\n+    sync::{\n+        Arc, LazyLock,\n+        atomic::{AtomicBool, Ordering},\n+    },\n };\n \n use anyhow::Result;\n use regex::Regex;\n-use turbo_tasks::{Vc, backend::TurboTasksExecutionError, handle_panic};\n+use turbo_tasks::{\n+    Vc,\n+    backend::TurboTasksExecutionError,\n+    panic_hooks::{handle_panic, register_panic_hook},\n+};\n use turbo_tasks_testing::{Registration, register, run_without_cache_check};\n \n static REGISTRATION: Registration = register!();\n \n static FILE_PATH_REGEX: LazyLock<Regex> =\n     LazyLock::new(|| Regex::new(r\"panics\\.rs:\\d+:\\d+$\").unwrap());\n \n+// DO NOT ADD MORE TESTS TO THIS FILE!\n+//\n+// This test depends on the process-wide global panic handler. This test must be run in its own\n+// process in isolation of any other tests.\n #[tokio::test]\n-async fn test_panics_include_location() {\n+async fn test_panic_hook() {\n     let prev_hook = take_hook();\n     set_hook(Box::new(move |info| {\n         handle_panic(info);\n         prev_hook(info);\n     }));\n \n+    let hook_was_called = Arc::new(AtomicBool::new(false));\n+    let _hook_guard = register_panic_hook({\n+        let hook_was_called = hook_was_called.clone();\n+        Box::new(move |_| hook_was_called.store(true, Ordering::SeqCst))\n+    });\n+\n     let result =\n         run_without_cache_check(&REGISTRATION, async move { anyhow::Ok(*double(3).await?) }).await;\n \n+    assert!(hook_was_called.load(Ordering::SeqCst));\n+\n     let error = result.unwrap_err();\n     let root_cause = error.root_cause();\n "
        },
        {
            "sha": "6bd646f942794bd1ad0b7509123dc90356077753",
            "filename": "turbopack/crates/turbo-tasks/src/capture_future.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/4250c5b318be660a94ce58252ab9dcb68a992741/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fcapture_future.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4250c5b318be660a94ce58252ab9dcb68a992741/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fcapture_future.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fcapture_future.rs?ref=4250c5b318be660a94ce58252ab9dcb68a992741",
            "patch": "@@ -14,7 +14,7 @@ use pin_project_lite::pin_project;\n use serde::{Deserialize, Serialize};\n use turbo_tasks_malloc::{AllocationInfo, TurboMalloc};\n \n-use crate::{LAST_ERROR_LOCATION, backend::TurboTasksExecutionErrorMessage};\n+use crate::{backend::TurboTasksExecutionErrorMessage, panic_hooks::LAST_ERROR_LOCATION};\n \n struct ThreadLocalData {\n     duration: Duration,"
        },
        {
            "sha": "c3bfddc188128c4f4cc40e9c997f369f458ad70d",
            "filename": "turbopack/crates/turbo-tasks/src/lib.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 15,
            "changes": 17,
            "blob_url": "https://github.com/vercel/next.js/blob/4250c5b318be660a94ce58252ab9dcb68a992741/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4250c5b318be660a94ce58252ab9dcb68a992741/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs?ref=4250c5b318be660a94ce58252ab9dcb68a992741",
            "patch": "@@ -28,7 +28,6 @@\n \n #![feature(trivial_bounds)]\n #![feature(min_specialization)]\n-#![feature(thread_local)]\n #![feature(try_trait_v2)]\n #![deny(unsafe_op_in_unsafe_fn)]\n #![feature(error_generic_member_access)]\n@@ -63,6 +62,7 @@ mod native_function;\n mod no_move_vec;\n mod once_map;\n mod output;\n+pub mod panic_hooks;\n pub mod persisted_graph;\n pub mod primitives;\n mod raw_vc;\n@@ -84,7 +84,7 @@ mod value;\n mod value_type;\n mod vc;\n \n-use std::{cell::RefCell, hash::BuildHasherDefault, panic};\n+use std::hash::BuildHasherDefault;\n \n pub use anyhow::{Error, Result};\n use auto_hash_map::AutoSet;\n@@ -302,19 +302,6 @@ pub mod test_helpers {\n     pub use super::manager::{current_task_for_testing, with_turbo_tasks_for_testing};\n }\n \n-thread_local! {\n-    /// The location of the last error that occurred in the current thread.\n-    ///\n-    /// Used for debugging when errors are sent to telemetry\n-    pub(crate) static LAST_ERROR_LOCATION: RefCell<Option<String>> = const { RefCell::new(None) };\n-}\n-\n-pub fn handle_panic(info: &panic::PanicHookInfo<'_>) {\n-    LAST_ERROR_LOCATION.with_borrow_mut(|loc| {\n-        *loc = info.location().map(|l| l.to_string());\n-    });\n-}\n-\n pub fn register() {\n     include!(concat!(env!(\"OUT_DIR\"), \"/register.rs\"));\n }"
        },
        {
            "sha": "a2fabc14acb2d9c9f1e1993646ca6fcfa0d42713",
            "filename": "turbopack/crates/turbo-tasks/src/panic_hooks.rs",
            "status": "added",
            "additions": 102,
            "deletions": 0,
            "changes": 102,
            "blob_url": "https://github.com/vercel/next.js/blob/4250c5b318be660a94ce58252ab9dcb68a992741/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fpanic_hooks.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4250c5b318be660a94ce58252ab9dcb68a992741/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fpanic_hooks.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fpanic_hooks.rs?ref=4250c5b318be660a94ce58252ab9dcb68a992741",
            "patch": "@@ -0,0 +1,102 @@\n+//! Provides a central registry for safe runtime registration and de-registration of panic hooks.\n+//!\n+//! Registered hooks are called in an arbitrary order.\n+//!\n+//! This is used inside `turbo-tasks-backend` to invalidate the persistent cache if a panic occurs\n+//! anywhere inside of Turbopack. That panic hook must be dynamically registered as it contains a\n+//! reference to the database.\n+//!\n+//! The program using turbo-tasks must call [`std::panic::set_hook`] with [`handle_panic`] exactly\n+//! once for these registered panic handlers to function. Short-lived programs or code that does not\n+//! fully control its execution environment (like unit tests) may choose not to do this, so these\n+//! panic hooks are best-effort.\n+//!\n+//! It's recommended that when adding this global panic handler (or any other panic handler) that:\n+//! - You call it as early in the program as possible, to avoid race conditions with other threads.\n+//! - The new panic handler should call any existing panic handler.\n+//!\n+//! ```\n+//! use std::panic::{set_hook, take_hook};\n+//! use turbo_tasks::panic_hooks::handle_panic;\n+//!\n+//! let prev_hook = take_hook();\n+//! set_hook(Box::new(move |info| {\n+//!     handle_panic(info);\n+//!     prev_hook(info);\n+//! }));\n+//! ```\n+//!\n+//! This code is not particularly well-optimized under the assumption that panics are a rare\n+//! occurrence.\n+\n+use std::{\n+    cell::RefCell,\n+    collections::HashMap,\n+    hash::{BuildHasherDefault, DefaultHasher},\n+    num::NonZeroU64,\n+    panic::PanicHookInfo,\n+    sync::{Arc, RwLock},\n+};\n+\n+use crate::util::IdFactory;\n+\n+thread_local! {\n+    /// The location of the last error that occurred in the current thread.\n+    ///\n+    /// Used for debugging when errors are sent to telemetry.\n+    pub(crate) static LAST_ERROR_LOCATION: RefCell<Option<String>> = const { RefCell::new(None) };\n+}\n+\n+static HOOK_ID_FACTORY: IdFactory<NonZeroU64> =\n+    IdFactory::new_const(NonZeroU64::MIN, NonZeroU64::MAX);\n+\n+// We could use a `DashMap` or the `slab` crate, but we anticipate that setting up and tearing down\n+// hooks is rare.\n+static PANIC_HOOKS: RwLock<HashMap<NonZeroU64, ArcPanicHook, BuildHasherDefault<DefaultHasher>>> =\n+    RwLock::new(HashMap::with_hasher(BuildHasherDefault::new()));\n+\n+pub type PanicHook = Box<dyn Fn(&PanicHookInfo<'_>) + Sync + Send + 'static>;\n+pub type ArcPanicHook = Arc<dyn Fn(&PanicHookInfo<'_>) + Sync + Send + 'static>;\n+\n+/// This function should be registered as the global panic handler using [`std::panic::set_hook`].\n+/// See [the module-level documentation][self] for usage examples.\n+pub fn handle_panic(info: &PanicHookInfo<'_>) {\n+    // we only want to do this once-per-process, so hard-code it here instead of using a dynamically\n+    // registered panic hook\n+    LAST_ERROR_LOCATION.with_borrow_mut(|loc| {\n+        *loc = info.location().map(|l| l.to_string());\n+    });\n+\n+    // Collect and clone all the hooks and drop the lock guard so that we can avoid risks of\n+    // deadlocks due to potentially re-entrant calls to `register_panic_hook` or\n+    // `PanicHookGuard::drop`. This is expensive, but this should be a cold codepath.\n+    let hooks: Vec<ArcPanicHook> = PANIC_HOOKS.read().unwrap().values().cloned().collect();\n+    for hook in hooks {\n+        (hook)(info);\n+    }\n+}\n+\n+/// Registers a hook to be called when a panic occurs. Panic hooks are called in the order that they\n+/// are registered. Dropping the returned [`PanicHookGuard`] removes the registered hook.\n+///\n+/// In the case that the panic hook refers to the object that contains the [`PanicHookGuard`], make\n+/// sure to use [`std::sync::Weak`] to avoid leaks. [`Arc::new_cyclic`] may be useful in\n+/// constructing such an object.\n+pub fn register_panic_hook(hook: PanicHook) -> PanicHookGuard {\n+    let id = HOOK_ID_FACTORY.get();\n+    PANIC_HOOKS.write().unwrap().insert(id, Arc::from(hook));\n+    PanicHookGuard { id }\n+}\n+\n+/// A guard returned from [`register_panic_hook`] that cleans up the panic hook when dropped.\n+#[must_use = \"If the guard is not stored somewhere, it will be immediately dropped and the panic \\\n+              hook will be immediately cleaned up\"]\n+pub struct PanicHookGuard {\n+    id: NonZeroU64,\n+}\n+\n+impl Drop for PanicHookGuard {\n+    fn drop(&mut self) {\n+        PANIC_HOOKS.write().unwrap().remove(&self.id);\n+    }\n+}"
        }
    ],
    "stats": {
        "total": 310,
        "additions": 256,
        "deletions": 54
    }
}