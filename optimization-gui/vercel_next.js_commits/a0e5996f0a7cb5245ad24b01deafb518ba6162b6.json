{
    "author": "gnoff",
    "message": "[Cache Components] Allow sync IO inside console methods  (#83843)\n\nconsole methods may be patched to do things like add a timestamp to the\nlog row. While we can't determine the meaning of reading the current\ntime in arbitrary contexts we can know with reasonable certainty that\nany sync IO inside a console method is not being used in the logical\noutput of the program. To account for this we can make a special\naffordance for sync IO inside of these methods that allows them to run\nwithout interrupting the prerender early.\n\nTo do this we patch these properties on the console global and set up a\nwrapper in the setter. This wrapper will make any assigned function into\nanother function that exits the `workUnitAsyncStorage` scope before\nexecuting the wrapped function. This will allow `new Date()` and other\nsync IO APIs to be called in the internal implementation of these\nmethods without triggering an error while prerendering.\n\nFixes NAR-403",
    "sha": "a0e5996f0a7cb5245ad24b01deafb518ba6162b6",
    "files": [
        {
            "sha": "a45a7834743472652ffd376d4165e93913a0c011",
            "filename": ".vscode/settings.json",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/a0e5996f0a7cb5245ad24b01deafb518ba6162b6/.vscode%2Fsettings.json",
            "raw_url": "https://github.com/vercel/next.js/raw/a0e5996f0a7cb5245ad24b01deafb518ba6162b6/.vscode%2Fsettings.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/.vscode%2Fsettings.json?ref=a0e5996f0a7cb5245ad24b01deafb518ba6162b6",
            "patch": "@@ -62,6 +62,7 @@\n     \"packages/next/src/server/app-render/dynamic-access-async-storage-instance.ts\",\n     \"packages/next/src/server/app-render/work-async-storage-instance.ts\",\n     \"packages/next/src/server/app-render/work-unit-async-storage-instance.ts\",\n+    \"packages/next/src/server/app-render/dev-logs-async-storage-instance.ts\",\n     \"packages/next/src/client/components/segment-cache-impl/*\"\n   ],\n   // Disable TypeScript surveys."
        },
        {
            "sha": "ec58249fcd9e2d5dd33338890d2b4758a71b6571",
            "filename": "packages/next/src/server/app-render/app-render.tsx",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/a0e5996f0a7cb5245ad24b01deafb518ba6162b6/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/a0e5996f0a7cb5245ad24b01deafb518ba6162b6/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx?ref=a0e5996f0a7cb5245ad24b01deafb518ba6162b6",
            "patch": "@@ -174,6 +174,7 @@ import {\n   workUnitAsyncStorage,\n   type PrerenderStore,\n } from './work-unit-async-storage.external'\n+import { devLogsAsyncStorage } from './dev-logs-async-storage.external'\n import { CacheSignal } from './cache-signal'\n import { getTracedMetadata } from '../lib/trace/utils'\n import { InvariantError } from '../../shared/lib/invariant-error'\n@@ -2302,7 +2303,9 @@ async function renderToStream(\n         }\n       )\n \n-      spawnDynamicValidationInDev(\n+      devLogsAsyncStorage.run(\n+        { dim: true },\n+        spawnDynamicValidationInDev,\n         resolveValidation,\n         tree,\n         ctx,"
        },
        {
            "sha": "fd9282c1fee403c4aadd8e0b957af8ccbccd25d5",
            "filename": "packages/next/src/server/app-render/dev-logs-async-storage-instance.ts",
            "status": "added",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/a0e5996f0a7cb5245ad24b01deafb518ba6162b6/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fdev-logs-async-storage-instance.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/a0e5996f0a7cb5245ad24b01deafb518ba6162b6/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fdev-logs-async-storage-instance.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fdev-logs-async-storage-instance.ts?ref=a0e5996f0a7cb5245ad24b01deafb518ba6162b6",
            "patch": "@@ -0,0 +1,5 @@\n+import { createAsyncLocalStorage } from './async-local-storage'\n+import type { DevLogsAsyncStorage } from './dev-logs-async-storage.external'\n+\n+export const devLogsAsyncStorageInstance: DevLogsAsyncStorage =\n+  createAsyncLocalStorage()"
        },
        {
            "sha": "67344452fd83dbe03b698ef57c1684d432f5cfa2",
            "filename": "packages/next/src/server/app-render/dev-logs-async-storage.external.ts",
            "status": "added",
            "additions": 17,
            "deletions": 0,
            "changes": 17,
            "blob_url": "https://github.com/vercel/next.js/blob/a0e5996f0a7cb5245ad24b01deafb518ba6162b6/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fdev-logs-async-storage.external.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/a0e5996f0a7cb5245ad24b01deafb518ba6162b6/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fdev-logs-async-storage.external.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fdev-logs-async-storage.external.ts?ref=a0e5996f0a7cb5245ad24b01deafb518ba6162b6",
            "patch": "@@ -0,0 +1,17 @@\n+import type { AsyncLocalStorage } from 'async_hooks'\n+\n+// Share the instance module in the next-shared layer\n+import { devLogsAsyncStorageInstance } from './dev-logs-async-storage-instance' with { 'turbopack-transition': 'next-shared' }\n+\n+export interface DevLogsStore {\n+  /**\n+   * if true the color of logs output will be dimmed to indicate the log is\n+   * from a repeat or validation render that is not typically relevant to\n+   * the primary action the server is taking.\n+   */\n+  readonly dim: boolean\n+}\n+\n+export type DevLogsAsyncStorage = AsyncLocalStorage<DevLogsStore>\n+\n+export { devLogsAsyncStorageInstance as devLogsAsyncStorage }"
        },
        {
            "sha": "3c513a4a80afa18b21b0a40900d2d5b80961cae3",
            "filename": "packages/next/src/server/node-environment-extensions/console-dev.tsx",
            "status": "modified",
            "additions": 6,
            "deletions": 19,
            "changes": 25,
            "blob_url": "https://github.com/vercel/next.js/blob/a0e5996f0a7cb5245ad24b01deafb518ba6162b6/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Fconsole-dev.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/a0e5996f0a7cb5245ad24b01deafb518ba6162b6/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Fconsole-dev.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Fconsole-dev.tsx?ref=a0e5996f0a7cb5245ad24b01deafb518ba6162b6",
            "patch": "@@ -1,5 +1,5 @@\n import { dim } from '../../lib/picocolors'\n-import { workUnitAsyncStorage } from '../app-render/work-unit-async-storage.external'\n+import { devLogsAsyncStorage } from '../app-render/dev-logs-async-storage.external'\n \n type InterceptableConsoleMethod =\n   | 'error'\n@@ -163,25 +163,12 @@ function patchConsoleMethodDEV(methodName: InterceptableConsoleMethod): void {\n     const originalMethod = descriptor.value\n     const originalName = Object.getOwnPropertyDescriptor(originalMethod, 'name')\n     const wrapperMethod = function (this: typeof console, ...args: any[]) {\n-      const workUnitStore = workUnitAsyncStorage.getStore()\n+      const devLogsStore = devLogsAsyncStorage.getStore()\n \n-      switch (workUnitStore?.type) {\n-        case 'prerender':\n-        case 'prerender-client':\n-        case 'prerender-runtime':\n-          originalMethod.apply(this, dimConsoleCall(methodName, args))\n-          break\n-        case 'prerender-ppr':\n-        case 'prerender-legacy':\n-        case 'request':\n-        case 'cache':\n-        case 'private-cache':\n-        case 'unstable-cache':\n-        case undefined:\n-          originalMethod.apply(this, args)\n-          break\n-        default:\n-          workUnitStore satisfies never\n+      if (devLogsStore?.dim === true) {\n+        return originalMethod.apply(this, dimConsoleCall(methodName, args))\n+      } else {\n+        return originalMethod.apply(this, args)\n       }\n     }\n     if (originalName) {"
        },
        {
            "sha": "31124eeede20cceafcda772b650d490cc194c350",
            "filename": "packages/next/src/server/node-environment-extensions/console-exit.test.ts",
            "status": "added",
            "additions": 689,
            "deletions": 0,
            "changes": 689,
            "blob_url": "https://github.com/vercel/next.js/blob/a0e5996f0a7cb5245ad24b01deafb518ba6162b6/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Fconsole-exit.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/a0e5996f0a7cb5245ad24b01deafb518ba6162b6/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Fconsole-exit.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Fconsole-exit.test.ts?ref=a0e5996f0a7cb5245ad24b01deafb518ba6162b6",
            "patch": "@@ -0,0 +1,689 @@\n+/**\n+ * Testing console patching in Jest requires isolation since console methods are heavily used\n+ * by the test runner itself. We use the same worker thread strategy as unhandled-rejection.test.ts\n+ * to ensure our patches don't interfere with Jest's own console usage.\n+ *\n+ * @jest-environment node\n+ */\n+\n+/* eslint-disable @next/internal/typechecked-require */\n+\n+type ReportableResult =\n+  | ConsoleCallReport\n+  | ErrorReport\n+  | OutputReport\n+  | SerializableDataReport\n+\n+type ConsoleCallReport = {\n+  type: 'console-call'\n+  method: string\n+  input: string\n+}\n+\n+type ErrorReport = { type: 'error'; message: string }\n+type OutputReport = { type: 'output'; message: string }\n+type SerializableDataReport = {\n+  type: 'serialized'\n+  key: string\n+  data: string | number | boolean\n+}\n+\n+declare global {\n+  function reportResult(result: ReportableResult): void\n+}\n+\n+import type { WorkUnitStore } from '../app-render/work-unit-async-storage.external'\n+import { Worker } from 'node:worker_threads'\n+\n+type WorkerResult = {\n+  exitCode: number\n+  stderr: string\n+  consoleCalls: Array<{ method: string; input: string }>\n+  data: Record<string, unknown>\n+  messages: Array<ReportableResult>\n+}\n+\n+export function runWorkerCode(fn: Function): Promise<WorkerResult> {\n+  return new Promise((resolve, reject) => {\n+    const script = `\n+      const { parentPort } = require('node:worker_threads');\n+      (async () => {\n+        const { AsyncLocalStorage } = require('node:async_hooks');\n+        // We need to put this on the global because Next.js does not import it\n+        // from node directly to be compatible with edge runtimes.\n+        globalThis.AsyncLocalStorage = AsyncLocalStorage;\n+\n+        global.reportResult = (value) => {\n+          parentPort?.postMessage(value);\n+        };\n+\n+        const fn = (${fn.toString()});\n+        try {\n+          const out = await fn();\n+          await new Promise(r => setImmediate(r));\n+          reportResult({ type: 'result', out });\n+        } catch (e) {\n+          reportResult({ type: 'error', message: String(e && e.message || e) });\n+        }\n+      })();\n+    `\n+\n+    const w = new Worker(script, {\n+      eval: true,\n+      workerData: null,\n+      argv: [],\n+      execArgv: [],\n+      stderr: true,\n+      stdout: false,\n+    })\n+\n+    const messages: Array<ReportableResult> = []\n+    const consoleCalls: Array<{ method: string; input: string }> = []\n+    const data = {} as Record<string, unknown>\n+    let stderr = ''\n+\n+    w.on('message', (m) => {\n+      messages.push(m)\n+      switch (m.type) {\n+        case 'console-call':\n+          consoleCalls.push({\n+            method: m.method,\n+            input: m.input,\n+          })\n+          break\n+        case 'serialized':\n+          data[m.key] = JSON.parse(m.data)\n+          break\n+        default:\n+          break\n+      }\n+    })\n+    w.on('error', (err) => console.error('Worker error', err))\n+    w.on('error', reject)\n+    w.stderr?.on('data', (b) => (stderr += String(b)))\n+    w.on('exit', (code) =>\n+      resolve({\n+        exitCode: code ?? -1,\n+        consoleCalls,\n+        data,\n+        messages,\n+        stderr,\n+      })\n+    )\n+  })\n+}\n+\n+describe('console-exit patches', () => {\n+  describe('basic functionality', () => {\n+    it('should wrap existing console methods to exit workUnit storage', async () => {\n+      async function testForWorker() {\n+        const {\n+          workUnitAsyncStorage,\n+        } = require('next/dist/server/app-render/work-unit-async-storage.external')\n+\n+        // First, replace console.log to track what storage context it runs in\n+        console.log = function (...args) {\n+          const store = workUnitAsyncStorage.getStore()\n+          reportResult({\n+            type: 'console-call',\n+            method: 'log',\n+            input: `${store ? '[Store]' : '[No Store]'}: ${args.join(' ')}`,\n+          })\n+        }\n+\n+        // Install patches - this wraps the current console.log\n+        require('next/dist/server/node-environment-extensions/console-exit')\n+\n+        // Test outside storage context\n+        console.log('outside')\n+\n+        // Test inside storage context - should show [No Store] because wrapping exits storage\n+        workUnitAsyncStorage.run({ type: 'prerender' } as WorkUnitStore, () => {\n+          console.log('inside')\n+        })\n+      }\n+\n+      const { consoleCalls, exitCode } = await runWorkerCode(testForWorker)\n+\n+      expect(exitCode).toBe(0)\n+      // Both should show [No Store] because the wrapped console.log exits storage\n+      expect(consoleCalls).toEqual([\n+        { method: 'log', input: '[No Store]: outside' },\n+        { method: 'log', input: '[No Store]: inside' },\n+      ])\n+    })\n+\n+    it('should not wrap console methods assigned after patching', async () => {\n+      async function testForWorker() {\n+        const {\n+          workUnitAsyncStorage,\n+        } = require('next/dist/server/app-render/work-unit-async-storage.external')\n+\n+        // Install patches first\n+        require('next/dist/server/node-environment-extensions/console-exit')\n+\n+        // Assign a new console.log after patching - this will NOT be wrapped\n+        console.log = function (...args) {\n+          const store = workUnitAsyncStorage.getStore()\n+          reportResult({\n+            type: 'console-call',\n+            method: 'log',\n+            input: `${store ? '[Store]' : '[No Store]'}: ${args.join(' ')}`,\n+          })\n+        }\n+\n+        // Test outside storage context\n+        console.log('outside')\n+\n+        // Test inside storage context - should show [Store] because new assignment is not wrapped\n+        workUnitAsyncStorage.run({ type: 'prerender' } as WorkUnitStore, () => {\n+          console.log('inside')\n+        })\n+      }\n+\n+      const { consoleCalls, exitCode } = await runWorkerCode(testForWorker)\n+\n+      expect(exitCode).toBe(0)\n+      // New assignments after patching are NOT wrapped, so they preserve storage context\n+      expect(consoleCalls).toEqual([\n+        { method: 'log', input: '[No Store]: outside' },\n+        { method: 'log', input: '[Store]: inside' },\n+      ])\n+    })\n+\n+    it('should preserve function properties and behavior', async () => {\n+      async function testForWorker() {\n+        reportResult({\n+          type: 'serialized',\n+          key: 'originalName',\n+          data: JSON.stringify(console.log.name),\n+        })\n+\n+        reportResult({\n+          type: 'serialized',\n+          key: 'originalLength',\n+          data: JSON.stringify(console.log.length),\n+        })\n+\n+        // install patch\n+        require('next/dist/server/node-environment-extensions/console-exit')\n+\n+        // Test that patched methods preserve name and other properties\n+        reportResult({\n+          type: 'serialized',\n+          key: 'patchedName',\n+          data: JSON.stringify(console.log.name),\n+        })\n+\n+        reportResult({\n+          type: 'serialized',\n+          key: 'patchedLength',\n+          data: JSON.stringify(console.log.length),\n+        })\n+      }\n+\n+      const { data, exitCode } = await runWorkerCode(testForWorker)\n+\n+      expect(exitCode).toBe(0)\n+      expect(data.patchedName).toBe('log')\n+      expect(data.patchedName).toBe(data.originalName)\n+      expect(data.patchedLength).toBe(data.originalLength)\n+    })\n+  })\n+\n+  describe('multiple console methods', () => {\n+    it(`should patch the log method`, async () => {\n+      async function testForWorker() {\n+        const {\n+          workUnitAsyncStorage,\n+        } = require('next/dist/server/app-render/work-unit-async-storage.external')\n+\n+        console.log = function (...args: Array<any>) {\n+          const store = workUnitAsyncStorage.getStore()\n+          reportResult({\n+            type: 'console-call',\n+            method: 'log',\n+            input: `${store ? '[Store]' : '[No Store]'}: ${args.join(' ')}`,\n+          })\n+        }\n+\n+        require('next/dist/server/node-environment-extensions/console-exit')\n+\n+        workUnitAsyncStorage.run({ type: 'request' } as WorkUnitStore, () => {\n+          console.log('inside')\n+        })\n+        console.log('outside')\n+      }\n+\n+      const { consoleCalls, exitCode } = await runWorkerCode(testForWorker)\n+\n+      expect(exitCode).toBe(0)\n+      expect(consoleCalls).toEqual([\n+        { method: 'log', input: `[No Store]: inside` },\n+        { method: 'log', input: `[No Store]: outside` },\n+      ])\n+    })\n+\n+    it(`should patch the error method`, async () => {\n+      async function testForWorker() {\n+        const {\n+          workUnitAsyncStorage,\n+        } = require('next/dist/server/app-render/work-unit-async-storage.external')\n+\n+        console.error = function (...args: Array<any>) {\n+          const store = workUnitAsyncStorage.getStore()\n+          reportResult({\n+            type: 'console-call',\n+            method: 'error',\n+            input: `${store ? '[Store]' : '[No Store]'}: ${args.join(' ')}`,\n+          })\n+        }\n+\n+        require('next/dist/server/node-environment-extensions/console-exit')\n+\n+        workUnitAsyncStorage.run({ type: 'request' } as WorkUnitStore, () => {\n+          console.error('inside')\n+        })\n+        console.error('outside')\n+      }\n+\n+      const { consoleCalls, exitCode } = await runWorkerCode(testForWorker)\n+\n+      expect(exitCode).toBe(0)\n+      expect(consoleCalls).toEqual([\n+        { method: 'error', input: `[No Store]: inside` },\n+        { method: 'error', input: `[No Store]: outside` },\n+      ])\n+    })\n+\n+    it(`should patch the warn method`, async () => {\n+      async function testForWorker() {\n+        const {\n+          workUnitAsyncStorage,\n+        } = require('next/dist/server/app-render/work-unit-async-storage.external')\n+\n+        console.warn = function (...args: Array<any>) {\n+          const store = workUnitAsyncStorage.getStore()\n+          reportResult({\n+            type: 'console-call',\n+            method: 'warn',\n+            input: `${store ? '[Store]' : '[No Store]'}: ${args.join(' ')}`,\n+          })\n+        }\n+\n+        require('next/dist/server/node-environment-extensions/console-exit')\n+\n+        workUnitAsyncStorage.run({ type: 'request' } as WorkUnitStore, () => {\n+          console.warn('inside')\n+        })\n+        console.warn('outside')\n+      }\n+\n+      const { consoleCalls, exitCode } = await runWorkerCode(testForWorker)\n+\n+      expect(exitCode).toBe(0)\n+      expect(consoleCalls).toEqual([\n+        { method: 'warn', input: `[No Store]: inside` },\n+        { method: 'warn', input: `[No Store]: outside` },\n+      ])\n+    })\n+\n+    it(`should patch the info method`, async () => {\n+      async function testForWorker() {\n+        const {\n+          workUnitAsyncStorage,\n+        } = require('next/dist/server/app-render/work-unit-async-storage.external')\n+\n+        console.info = function (...args: Array<any>) {\n+          const store = workUnitAsyncStorage.getStore()\n+          reportResult({\n+            type: 'console-call',\n+            method: 'info',\n+            input: `${store ? '[Store]' : '[No Store]'}: ${args.join(' ')}`,\n+          })\n+        }\n+\n+        require('next/dist/server/node-environment-extensions/console-exit')\n+\n+        workUnitAsyncStorage.run({ type: 'request' } as WorkUnitStore, () => {\n+          console.info('inside')\n+        })\n+        console.info('outside')\n+      }\n+\n+      const { consoleCalls, exitCode } = await runWorkerCode(testForWorker)\n+\n+      expect(exitCode).toBe(0)\n+      expect(consoleCalls).toEqual([\n+        { method: 'info', input: `[No Store]: inside` },\n+        { method: 'info', input: `[No Store]: outside` },\n+      ])\n+    })\n+\n+    it(`should patch the debug method`, async () => {\n+      async function testForWorker() {\n+        const {\n+          workUnitAsyncStorage,\n+        } = require('next/dist/server/app-render/work-unit-async-storage.external')\n+\n+        console.debug = function (...args: Array<any>) {\n+          const store = workUnitAsyncStorage.getStore()\n+          reportResult({\n+            type: 'console-call',\n+            method: 'debug',\n+            input: `${store ? '[Store]' : '[No Store]'}: ${args.join(' ')}`,\n+          })\n+        }\n+\n+        require('next/dist/server/node-environment-extensions/console-exit')\n+\n+        workUnitAsyncStorage.run({ type: 'request' } as WorkUnitStore, () => {\n+          console.debug('inside')\n+        })\n+        console.debug('outside')\n+      }\n+\n+      const { consoleCalls, exitCode } = await runWorkerCode(testForWorker)\n+\n+      expect(exitCode).toBe(0)\n+      expect(consoleCalls).toEqual([\n+        { method: 'debug', input: `[No Store]: inside` },\n+        { method: 'debug', input: `[No Store]: outside` },\n+      ])\n+    })\n+\n+    it(`should patch the trace method`, async () => {\n+      async function testForWorker() {\n+        const {\n+          workUnitAsyncStorage,\n+        } = require('next/dist/server/app-render/work-unit-async-storage.external')\n+\n+        console.trace = function (...args: Array<any>) {\n+          const store = workUnitAsyncStorage.getStore()\n+          reportResult({\n+            type: 'console-call',\n+            method: 'trace',\n+            input: `${store ? '[Store]' : '[No Store]'}: ${args.join(' ')}`,\n+          })\n+        }\n+\n+        require('next/dist/server/node-environment-extensions/console-exit')\n+\n+        workUnitAsyncStorage.run({ type: 'request' } as WorkUnitStore, () => {\n+          console.trace('inside')\n+        })\n+        console.trace('outside')\n+      }\n+\n+      const { consoleCalls, exitCode } = await runWorkerCode(testForWorker)\n+\n+      expect(exitCode).toBe(0)\n+      expect(consoleCalls).toEqual([\n+        { method: 'trace', input: `[No Store]: inside` },\n+        { method: 'trace', input: `[No Store]: outside` },\n+      ])\n+    })\n+\n+    it(`should patch the dir method`, async () => {\n+      async function testForWorker() {\n+        const {\n+          workUnitAsyncStorage,\n+        } = require('next/dist/server/app-render/work-unit-async-storage.external')\n+\n+        console.dir = function (...args: Array<any>) {\n+          const store = workUnitAsyncStorage.getStore()\n+          reportResult({\n+            type: 'console-call',\n+            method: 'dir',\n+            input: `${store ? '[Store]' : '[No Store]'}: ${args.join(' ')}`,\n+          })\n+        }\n+\n+        require('next/dist/server/node-environment-extensions/console-exit')\n+\n+        workUnitAsyncStorage.run({ type: 'request' } as WorkUnitStore, () => {\n+          console.dir('inside')\n+        })\n+        console.dir('outside')\n+      }\n+\n+      const { consoleCalls, exitCode } = await runWorkerCode(testForWorker)\n+\n+      expect(exitCode).toBe(0)\n+      expect(consoleCalls).toEqual([\n+        { method: 'dir', input: `[No Store]: inside` },\n+        { method: 'dir', input: `[No Store]: outside` },\n+      ])\n+    })\n+\n+    it(`should patch the dirxml method`, async () => {\n+      async function testForWorker() {\n+        const {\n+          workUnitAsyncStorage,\n+        } = require('next/dist/server/app-render/work-unit-async-storage.external')\n+\n+        console.dirxml = function (...args: Array<any>) {\n+          const store = workUnitAsyncStorage.getStore()\n+          reportResult({\n+            type: 'console-call',\n+            method: 'dirxml',\n+            input: `${store ? '[Store]' : '[No Store]'}: ${args.join(' ')}`,\n+          })\n+        }\n+\n+        require('next/dist/server/node-environment-extensions/console-exit')\n+\n+        workUnitAsyncStorage.run({ type: 'request' } as WorkUnitStore, () => {\n+          console.dirxml('inside')\n+        })\n+        console.dirxml('outside')\n+      }\n+\n+      const { consoleCalls, exitCode } = await runWorkerCode(testForWorker)\n+\n+      expect(exitCode).toBe(0)\n+      expect(consoleCalls).toEqual([\n+        { method: 'dirxml', input: `[No Store]: inside` },\n+        { method: 'dirxml', input: `[No Store]: outside` },\n+      ])\n+    })\n+\n+    it(`should patch the table method`, async () => {\n+      async function testForWorker() {\n+        const {\n+          workUnitAsyncStorage,\n+        } = require('next/dist/server/app-render/work-unit-async-storage.external')\n+\n+        console.table = function (...args: Array<any>) {\n+          const store = workUnitAsyncStorage.getStore()\n+          reportResult({\n+            type: 'console-call',\n+            method: 'table',\n+            input: `${store ? '[Store]' : '[No Store]'}: ${args.join(' ')}`,\n+          })\n+        }\n+\n+        require('next/dist/server/node-environment-extensions/console-exit')\n+\n+        workUnitAsyncStorage.run({ type: 'request' } as WorkUnitStore, () => {\n+          console.table('inside')\n+        })\n+        console.table('outside')\n+      }\n+\n+      const { consoleCalls, exitCode } = await runWorkerCode(testForWorker)\n+\n+      expect(exitCode).toBe(0)\n+      expect(consoleCalls).toEqual([\n+        { method: 'table', input: `[No Store]: inside` },\n+        { method: 'table', input: `[No Store]: outside` },\n+      ])\n+    })\n+\n+    it(`should patch the assert method`, async () => {\n+      async function testForWorker() {\n+        const {\n+          workUnitAsyncStorage,\n+        } = require('next/dist/server/app-render/work-unit-async-storage.external')\n+\n+        console.assert = function (...args: Array<any>) {\n+          const store = workUnitAsyncStorage.getStore()\n+          reportResult({\n+            type: 'console-call',\n+            method: 'assert',\n+            input: `${store ? '[Store]' : '[No Store]'}: ${args.join(' ')}`,\n+          })\n+        }\n+\n+        require('next/dist/server/node-environment-extensions/console-exit')\n+\n+        workUnitAsyncStorage.run({ type: 'request' } as WorkUnitStore, () => {\n+          console.assert('inside')\n+        })\n+        console.assert('outside')\n+      }\n+\n+      const { consoleCalls, exitCode } = await runWorkerCode(testForWorker)\n+\n+      expect(exitCode).toBe(0)\n+      expect(consoleCalls).toEqual([\n+        { method: 'assert', input: `[No Store]: inside` },\n+        { method: 'assert', input: `[No Store]: outside` },\n+      ])\n+    })\n+\n+    it(`should patch the group method`, async () => {\n+      async function testForWorker() {\n+        const {\n+          workUnitAsyncStorage,\n+        } = require('next/dist/server/app-render/work-unit-async-storage.external')\n+\n+        console.group = function (...args: Array<any>) {\n+          const store = workUnitAsyncStorage.getStore()\n+          reportResult({\n+            type: 'console-call',\n+            method: 'group',\n+            input: `${store ? '[Store]' : '[No Store]'}: ${args.join(' ')}`,\n+          })\n+        }\n+\n+        require('next/dist/server/node-environment-extensions/console-exit')\n+\n+        workUnitAsyncStorage.run({ type: 'request' } as WorkUnitStore, () => {\n+          console.group('inside')\n+        })\n+        console.group('outside')\n+      }\n+\n+      const { consoleCalls, exitCode } = await runWorkerCode(testForWorker)\n+\n+      expect(exitCode).toBe(0)\n+      expect(consoleCalls).toEqual([\n+        { method: 'group', input: `[No Store]: inside` },\n+        { method: 'group', input: `[No Store]: outside` },\n+      ])\n+    })\n+\n+    it(`should patch the groupCollapsed method`, async () => {\n+      async function testForWorker() {\n+        const {\n+          workUnitAsyncStorage,\n+        } = require('next/dist/server/app-render/work-unit-async-storage.external')\n+\n+        console.groupCollapsed = function (...args: Array<any>) {\n+          const store = workUnitAsyncStorage.getStore()\n+          reportResult({\n+            type: 'console-call',\n+            method: 'groupCollapsed',\n+            input: `${store ? '[Store]' : '[No Store]'}: ${args.join(' ')}`,\n+          })\n+        }\n+\n+        require('next/dist/server/node-environment-extensions/console-exit')\n+\n+        workUnitAsyncStorage.run({ type: 'request' } as WorkUnitStore, () => {\n+          console.groupCollapsed('inside')\n+        })\n+        console.groupCollapsed('outside')\n+      }\n+\n+      const { consoleCalls, exitCode } = await runWorkerCode(testForWorker)\n+\n+      expect(exitCode).toBe(0)\n+      expect(consoleCalls).toEqual([\n+        { method: 'groupCollapsed', input: `[No Store]: inside` },\n+        { method: 'groupCollapsed', input: `[No Store]: outside` },\n+      ])\n+    })\n+\n+    it(`should patch the groupEnd method`, async () => {\n+      async function testForWorker() {\n+        const {\n+          workUnitAsyncStorage,\n+        } = require('next/dist/server/app-render/work-unit-async-storage.external')\n+\n+        console.groupEnd = function () {\n+          const store = workUnitAsyncStorage.getStore()\n+          reportResult({\n+            type: 'console-call',\n+            method: 'groupEnd',\n+            input: `${store ? '[Store]' : '[No Store]'}`,\n+          })\n+        }\n+\n+        require('next/dist/server/node-environment-extensions/console-exit')\n+\n+        workUnitAsyncStorage.run({ type: 'request' } as WorkUnitStore, () => {\n+          console.groupEnd()\n+        })\n+        console.groupEnd()\n+      }\n+\n+      const { consoleCalls, exitCode } = await runWorkerCode(testForWorker)\n+\n+      expect(exitCode).toBe(0)\n+      expect(consoleCalls).toEqual([\n+        { method: 'groupEnd', input: `[No Store]` },\n+        { method: 'groupEnd', input: `[No Store]` },\n+      ])\n+    })\n+\n+    it('should not wrap arbitrary function property assignments', async () => {\n+      async function testForWorker() {\n+        const {\n+          workUnitAsyncStorage,\n+        } = require('next/dist/server/app-render/work-unit-async-storage.external')\n+\n+        // Assign an arbitrary function property that shouldn't be wrapped\n+        // @ts-expect-error - intentionally assigning a custom property\n+        console.customFunc = function customFunc(...args: Array<any>) {\n+          const store = workUnitAsyncStorage.getStore()\n+          reportResult({\n+            type: 'console-call',\n+            method: 'customFunc',\n+            input: `${store ? '[Store]' : '[No Store]'}: ${args.join(' ')}`,\n+          })\n+        }\n+\n+        require('next/dist/server/node-environment-extensions/console-exit')\n+\n+        workUnitAsyncStorage.run({ type: 'request' } as WorkUnitStore, () => {\n+          // @ts-expect-error - calling our custom property\n+          console.customFunc('inside')\n+        })\n+\n+        // @ts-expect-error - calling our custom property\n+        console.customFunc('outside')\n+      }\n+\n+      const { consoleCalls, exitCode } = await runWorkerCode(testForWorker)\n+\n+      expect(exitCode).toBe(0)\n+      // The custom function should NOT be wrapped, so it should execute WITH store context\n+      expect(consoleCalls).toEqual([\n+        { method: 'customFunc', input: `[Store]: inside` },\n+        { method: 'customFunc', input: `[No Store]: outside` },\n+      ])\n+    })\n+  })\n+})"
        },
        {
            "sha": "5306b8f19734229c7ca32bc7e1955b2655d9f863",
            "filename": "packages/next/src/server/node-environment-extensions/console-exit.tsx",
            "status": "added",
            "additions": 55,
            "deletions": 0,
            "changes": 55,
            "blob_url": "https://github.com/vercel/next.js/blob/a0e5996f0a7cb5245ad24b01deafb518ba6162b6/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Fconsole-exit.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/a0e5996f0a7cb5245ad24b01deafb518ba6162b6/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Fconsole-exit.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Fconsole-exit.tsx?ref=a0e5996f0a7cb5245ad24b01deafb518ba6162b6",
            "patch": "@@ -0,0 +1,55 @@\n+/**\n+ * Patches console methods to exit the workUnitAsyncStorage so that inside the host implementation\n+ * sync IO can be called. This is relevant for example with runtimes that patch console methods to\n+ * prepend a timestamp to the log output.\n+ *\n+ * Note that this will only exit for already installed patched console methods. If you further patch\n+ * the console method after this and add any sync IO there it will trigger sync IO warnings while prerendering.\n+ *\n+ * This is a pragmatic concession because layering the patches if you install your own log implementation\n+ * after they are installed is very tricky to do correctly because the order matters\n+ */\n+\n+import { workUnitAsyncStorage } from '../app-render/work-unit-async-storage.external'\n+\n+type ConsoleMethodName = keyof Console\n+\n+function patchConsoleMethod(methodName: ConsoleMethodName): void {\n+  const descriptor = Object.getOwnPropertyDescriptor(console, methodName)\n+  if (\n+    descriptor &&\n+    (descriptor.configurable || descriptor.writable) &&\n+    typeof descriptor.value === 'function'\n+  ) {\n+    const originalMethod = descriptor.value\n+    const originalName = Object.getOwnPropertyDescriptor(originalMethod, 'name')\n+    let wrapperMethod = function (...args: any[]) {\n+      return workUnitAsyncStorage.exit(() =>\n+        originalMethod.apply(console, args)\n+      )\n+    }\n+    if (originalName) {\n+      Object.defineProperty(wrapperMethod, 'name', originalName)\n+    }\n+    Object.defineProperty(console, methodName, {\n+      value: wrapperMethod,\n+    })\n+  }\n+}\n+\n+// We patch the same methods that React and our dev patch do.\n+// We may find other methods that could benefit from patching but if\n+// they exist we ought to consider patching them in all three places\n+patchConsoleMethod('error')\n+patchConsoleMethod('assert')\n+patchConsoleMethod('debug')\n+patchConsoleMethod('dir')\n+patchConsoleMethod('dirxml')\n+patchConsoleMethod('group')\n+patchConsoleMethod('groupCollapsed')\n+patchConsoleMethod('groupEnd')\n+patchConsoleMethod('info')\n+patchConsoleMethod('log')\n+patchConsoleMethod('table')\n+patchConsoleMethod('trace')\n+patchConsoleMethod('warn')"
        },
        {
            "sha": "d7ab85cc07f7314eb2a1e3a0a042603d0e5b5f38",
            "filename": "packages/next/src/server/node-environment.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/a0e5996f0a7cb5245ad24b01deafb518ba6162b6/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/a0e5996f0a7cb5245ad24b01deafb518ba6162b6/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment.ts?ref=a0e5996f0a7cb5245ad24b01deafb518ba6162b6",
            "patch": "@@ -5,6 +5,7 @@ import './node-environment-baseline'\n // Import as early as possible so that unexpected errors in other extensions are properly formatted.\n // Has to come after baseline since error-inspect requires AsyncLocalStorage that baseline provides.\n import './node-environment-extensions/error-inspect'\n+import './node-environment-extensions/console-exit'\n import './node-environment-extensions/unhandled-rejection'\n import './node-environment-extensions/random'\n import './node-environment-extensions/date'"
        },
        {
            "sha": "504cf5e36e962f15aab7073aa0e957baf8c61954",
            "filename": "test/e2e/app-dir/cache-components-errors/cache-components-console-patch.test.ts",
            "status": "added",
            "additions": 81,
            "deletions": 0,
            "changes": 81,
            "blob_url": "https://github.com/vercel/next.js/blob/a0e5996f0a7cb5245ad24b01deafb518ba6162b6/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Fcache-components-console-patch.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/a0e5996f0a7cb5245ad24b01deafb518ba6162b6/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Fcache-components-console-patch.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Fcache-components-console-patch.test.ts?ref=a0e5996f0a7cb5245ad24b01deafb518ba6162b6",
            "patch": "@@ -0,0 +1,81 @@\n+import { isNextDev, nextTestSetup } from 'e2e-utils'\n+import { getPrerenderOutput } from './utils'\n+\n+describe('Cache Components Errors', () => {\n+  const { next, isTurbopack, isNextStart, skipped } = nextTestSetup({\n+    files: __dirname + '/fixtures/console-patch',\n+    skipDeployment: true,\n+    skipStart: !isNextDev,\n+    env: {\n+      NEXT_USE_UNHANDLED_REJECTION_FILTER: 'enabled',\n+      NODE_OPTIONS: '--require ./patch-console.js',\n+    },\n+  })\n+\n+  if (skipped) {\n+    return\n+  }\n+\n+  let cliOutputLength: number\n+\n+  beforeEach(async () => {\n+    cliOutputLength = next.cliOutput.length\n+  })\n+\n+  afterEach(async () => {\n+    if (isNextStart) {\n+      await next.stop()\n+    }\n+  })\n+\n+  describe('Sync IO in console methods', () => {\n+    describe('Console Patching', () => {\n+      if (isNextDev) {\n+        it('does not warn about sync IO if console.log is patched to call new Date() internally', async () => {\n+          await next.browser('/')\n+          let output = next.cliOutput\n+          expect(output).toContain('[<timestamp>]  ✓ Compiled')\n+          let index = output.indexOf('[<timestamp>]  ✓ Compiled')\n+          output = output.slice(index).trim()\n+          index = output.indexOf('\\n')\n+          output = output.slice(index).trim()\n+          expect(output).toContain('GET / 200')\n+          index = output.indexOf('GET / 200')\n+          const snapshot = output.slice(0, index).trim()\n+\n+          expect(snapshot).toMatchInlineSnapshot(`\n+           \"[<timestamp>] This is a console log from a server component page\n+           [<timestamp>] This is a console log from a server component page\n+           [<timestamp>] This is a console log from a server component page\"\n+          `)\n+        })\n+      } else {\n+        it('does not fail the build for Sync IO if console.log is patched to call new Date() internally', async () => {\n+          try {\n+            await next.build()\n+          } catch {}\n+\n+          const output = getPrerenderOutput(\n+            next.cliOutput.slice(cliOutputLength),\n+            { isMinified: true }\n+          )\n+\n+          if (isTurbopack) {\n+            expect(output).toMatchInlineSnapshot(`\n+             \"[<timestamp>] This is a console log from a server component page\n+             [<timestamp>] This is a console log from a server component page\n+             [<timestamp>]\"\n+            `)\n+          } else {\n+            expect(output).toMatchInlineSnapshot(`\n+                        \"[<timestamp>] This is a console log from a server component page\n+                        [<timestamp>] This is a console log from a server component page\n+                        [<timestamp>]    Collecting build traces ...\n+                        [<timestamp>]\"\n+                      `)\n+          }\n+        })\n+      }\n+    })\n+  })\n+})"
        },
        {
            "sha": "745e32b8a8d235ef098d1a265f57c0254df40b5d",
            "filename": "test/e2e/app-dir/cache-components-errors/fixtures/console-patch/app/layout.tsx",
            "status": "added",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/a0e5996f0a7cb5245ad24b01deafb518ba6162b6/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Ffixtures%2Fconsole-patch%2Fapp%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/a0e5996f0a7cb5245ad24b01deafb518ba6162b6/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Ffixtures%2Fconsole-patch%2Fapp%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Ffixtures%2Fconsole-patch%2Fapp%2Flayout.tsx?ref=a0e5996f0a7cb5245ad24b01deafb518ba6162b6",
            "patch": "@@ -0,0 +1,9 @@\n+export default function Root({ children }: { children: React.ReactNode }) {\n+  return (\n+    <html>\n+      <body>\n+        <main>{children}</main>\n+      </body>\n+    </html>\n+  )\n+}"
        },
        {
            "sha": "6db4fbdaa51909c492f26454dcae63e02c20a2c7",
            "filename": "test/e2e/app-dir/cache-components-errors/fixtures/console-patch/app/page.tsx",
            "status": "added",
            "additions": 12,
            "deletions": 0,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/a0e5996f0a7cb5245ad24b01deafb518ba6162b6/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Ffixtures%2Fconsole-patch%2Fapp%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/a0e5996f0a7cb5245ad24b01deafb518ba6162b6/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Ffixtures%2Fconsole-patch%2Fapp%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Ffixtures%2Fconsole-patch%2Fapp%2Fpage.tsx?ref=a0e5996f0a7cb5245ad24b01deafb518ba6162b6",
            "patch": "@@ -0,0 +1,12 @@\n+export default async function Page() {\n+  console.log('This is a console log from a server component page')\n+  return (\n+    <div>\n+      This page uses a console.log that has been patched before Next.js runs to\n+      include a timestamp in the log line. It does not actually print the\n+      timestamp because we want the assertions to be stable but we are asserting\n+      that this sync IO does not interrupt the prerender when Cache Components\n+      are enabled\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "30a826fdacc568ffb8cd6641fe15330a3c9d618d",
            "filename": "test/e2e/app-dir/cache-components-errors/fixtures/console-patch/next.config.js",
            "status": "added",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/a0e5996f0a7cb5245ad24b01deafb518ba6162b6/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Ffixtures%2Fconsole-patch%2Fnext.config.js",
            "raw_url": "https://github.com/vercel/next.js/raw/a0e5996f0a7cb5245ad24b01deafb518ba6162b6/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Ffixtures%2Fconsole-patch%2Fnext.config.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Ffixtures%2Fconsole-patch%2Fnext.config.js?ref=a0e5996f0a7cb5245ad24b01deafb518ba6162b6",
            "patch": "@@ -0,0 +1,10 @@\n+/**\n+ * @type {import('next').NextConfig}\n+ */\n+const nextConfig = {\n+  experimental: {\n+    cacheComponents: true,\n+  },\n+}\n+\n+module.exports = nextConfig"
        },
        {
            "sha": "7fdbc48695b20d6d47091c7da6b02c0f3e350318",
            "filename": "test/e2e/app-dir/cache-components-errors/fixtures/console-patch/patch-console.js",
            "status": "added",
            "additions": 12,
            "deletions": 0,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/a0e5996f0a7cb5245ad24b01deafb518ba6162b6/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Ffixtures%2Fconsole-patch%2Fpatch-console.js",
            "raw_url": "https://github.com/vercel/next.js/raw/a0e5996f0a7cb5245ad24b01deafb518ba6162b6/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Ffixtures%2Fconsole-patch%2Fpatch-console.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Ffixtures%2Fconsole-patch%2Fpatch-console.js?ref=a0e5996f0a7cb5245ad24b01deafb518ba6162b6",
            "patch": "@@ -0,0 +1,12 @@\n+const originalLog = console.log.bind(console)\n+\n+console.log = (...args) => {\n+  new Date()\n+  Math.random()\n+  if (typeof args[0] === 'string') {\n+    const firstArg = '[<timestamp>] ' + args[0]\n+    originalLog(firstArg, ...args.slice(1))\n+  } else {\n+    originalLog('[<timestamp>] ', ...args)\n+  }\n+}"
        }
    ],
    "stats": {
        "total": 922,
        "additions": 902,
        "deletions": 20
    }
}