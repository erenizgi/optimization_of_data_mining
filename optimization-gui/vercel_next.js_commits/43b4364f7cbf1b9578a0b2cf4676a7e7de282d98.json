{
    "author": "bgw",
    "message": "Turbopack: Generalize `ImportedBinding` effect creation to avoid as much special-casing of SimpleAssignTarget (#81653)\n\nThere was some logic here that checked for the existence of `SimpleAssignTarget`, and using that to bail out of `visit_ident`. That doesn't scale well to pattern assignments, but it turns out that we don't need to bail out, we just need to fix the codegen.\n\nWithout this, https://github.com/vercel/next.js/pull/81654 breaks the test cases.",
    "sha": "43b4364f7cbf1b9578a0b2cf4676a7e7de282d98",
    "files": [
        {
            "sha": "94aa656807bfae6bb2867b3560f9ba6000d0a813",
            "filename": "turbopack/crates/turbopack-ecmascript/src/analyzer/graph.rs",
            "status": "modified",
            "additions": 45,
            "deletions": 53,
            "changes": 98,
            "blob_url": "https://github.com/vercel/next.js/blob/43b4364f7cbf1b9578a0b2cf4676a7e7de282d98/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fanalyzer%2Fgraph.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/43b4364f7cbf1b9578a0b2cf4676a7e7de282d98/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fanalyzer%2Fgraph.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fanalyzer%2Fgraph.rs?ref=43b4364f7cbf1b9578a0b2cf4676a7e7de282d98",
            "patch": "@@ -1312,6 +1312,14 @@ impl Analyzer<'_> {\n }\n \n impl VisitAstPath for Analyzer<'_> {\n+    fn visit_import_specifier<'ast: 'r, 'r>(\n+        &mut self,\n+        _import_specifier: &'ast ImportSpecifier,\n+        _ast_path: &mut AstNodePath<AstParentNodeRef<'r>>,\n+    ) {\n+        // Skip these nodes entirely: We gather imports in a separate pass\n+    }\n+\n     fn visit_assign_expr<'ast: 'r, 'r>(\n         &mut self,\n         n: &'ast AssignExpr,\n@@ -1837,71 +1845,55 @@ impl VisitAstPath for Analyzer<'_> {\n         ident: &'ast Ident,\n         ast_path: &mut AstNodePath<AstParentNodeRef<'r>>,\n     ) {\n-        if !(matches!(\n-            ast_path.last(),\n-            Some(AstParentNodeRef::Expr(_, ExprField::Ident))\n-                | Some(AstParentNodeRef::Prop(_, PropField::Shorthand))\n-        ) || matches!(\n-            ast_path.get(ast_path.len() - 2),\n-            Some(AstParentNodeRef::SimpleAssignTarget(\n-                _,\n-                SimpleAssignTargetField::Ident,\n-            ))\n-        )) {\n-            return;\n-        }\n+        // Note: `Ident` is (generally) only used for nodes referencing a variable, as it has scope\n+        // information. In other cases (e.g. object literals, properties of member expressions),\n+        // `IdentName` is used instead.\n \n+        // Note: The `Ident` children of `ImportSpecifier` are not visited because\n+        // `visit_import_specifier` bails out.\n+\n+        // Attempt to add import effects.\n         if let Some((esm_reference_index, export)) =\n             self.eval_context.imports.get_binding(&ident.to_id())\n         {\n+            // Optimization: Look for a MemberExpr to see if we only access a few members from the\n+            // module, add those specific effects instead of depending on the entire module.\n+            //\n+            // export.is_none() checks for a namespace import (*).\n             if export.is_none()\n                 && !self\n                     .eval_context\n                     .imports\n                     .should_import_all(esm_reference_index)\n-            {\n-                // export.is_none() checks for a namespace import.\n-\n-                // Note: This is optimization that can be applied if we don't need to\n-                // import all bindings\n-                if let Some(AstParentNodeRef::MemberExpr(member, MemberExprField::Obj)) =\n+                && let Some(AstParentNodeRef::MemberExpr(member, MemberExprField::Obj)) =\n                     ast_path.get(ast_path.len() - 2)\n-                {\n-                    // Skip if it's on the LHS of assignment\n-                    let is_lhs = matches!(\n-                        ast_path.get(ast_path.len() - 3),\n-                        Some(AstParentNodeRef::SimpleAssignTarget(\n-                            _,\n-                            SimpleAssignTargetField::Member\n-                        ))\n-                    );\n-\n-                    if !is_lhs\n-                        && let Some(prop) = self.eval_context.eval_member_prop(&member.prop)\n-                        && let Some(prop_str) = prop.as_str()\n-                    {\n-                        // a namespace member access like\n-                        // `import * as ns from \"...\"; ns.exportName`\n-                        self.add_effect(Effect::ImportedBinding {\n-                            esm_reference_index,\n-                            export: Some(prop_str.into()),\n-                            ast_path: as_parent_path_skip(ast_path, 1),\n-                            span: member.span(),\n-                            in_try: is_in_try(ast_path),\n-                        });\n-                        return;\n-                    }\n-                }\n+                && let Some(prop) = self.eval_context.eval_member_prop(&member.prop)\n+                && let Some(prop_str) = prop.as_str()\n+            {\n+                // a namespace member access like\n+                // `import * as ns from \"...\"; ns.exportName`\n+                self.add_effect(Effect::ImportedBinding {\n+                    esm_reference_index,\n+                    export: Some(prop_str.into()),\n+                    // point to the MemberExpression instead\n+                    ast_path: as_parent_path_skip(ast_path, 1),\n+                    span: member.span(),\n+                    in_try: is_in_try(ast_path),\n+                });\n+            } else {\n+                self.add_effect(Effect::ImportedBinding {\n+                    esm_reference_index,\n+                    export,\n+                    ast_path: as_parent_path(ast_path),\n+                    span: ident.span(),\n+                    in_try: is_in_try(ast_path),\n+                })\n             }\n+            return;\n+        }\n \n-            self.add_effect(Effect::ImportedBinding {\n-                esm_reference_index,\n-                export,\n-                ast_path: as_parent_path(ast_path),\n-                span: ident.span(),\n-                in_try: is_in_try(ast_path),\n-            })\n-        } else if is_unresolved(ident, self.eval_context.unresolved_mark)\n+        // If this variable is unresolved, track it as a free (unbound) variable\n+        if is_unresolved(ident, self.eval_context.unresolved_mark)\n             || self.eval_context.force_free_values.contains(&ident.to_id())\n         {\n             self.add_effect(Effect::FreeVar {"
        },
        {
            "sha": "d485342c84b20a744e9be627a3faf1abbde1c0c9",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/esm/binding.rs",
            "status": "modified",
            "additions": 27,
            "deletions": 36,
            "changes": 63,
            "blob_url": "https://github.com/vercel/next.js/blob/43b4364f7cbf1b9578a0b2cf4676a7e7de282d98/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fbinding.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/43b4364f7cbf1b9578a0b2cf4676a7e7de282d98/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fbinding.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fbinding.rs?ref=43b4364f7cbf1b9578a0b2cf4676a7e7de282d98",
            "patch": "@@ -149,46 +149,37 @@ impl EsmBinding {\n                     ));\n                     break;\n                 }\n-                Some(swc_core::ecma::visit::AstParentKind::BindingIdent(\n-                    swc_core::ecma::visit::fields::BindingIdentField::Id,\n-                )) => {\n+                // We need to handle LHS because of code like\n+                // (function (RouteKind1){})(RouteKind || RouteKind = {})\n+                Some(swc_core::ecma::visit::AstParentKind::SimpleAssignTarget(_)) => {\n                     ast_path.pop();\n \n-                    // We need to handle LHS because of code like\n-                    // (function (RouteKind1){})(RouteKind || RouteKind = {})\n-                    if let Some(swc_core::ecma::visit::AstParentKind::SimpleAssignTarget(\n-                        swc_core::ecma::visit::fields::SimpleAssignTargetField::Ident,\n-                    )) = ast_path.last()\n-                    {\n-                        ast_path.pop();\n-\n-                        visitors.push(create_visitor!(\n-                            exact,\n-                            ast_path,\n-                            visit_mut_simple_assign_target,\n-                            |l: &mut SimpleAssignTarget| {\n-                                use swc_core::common::Spanned;\n-                                match &imported_ident {\n-                                    ImportedIdent::Module(imported_ident) => {\n-                                        *l = imported_ident\n-                                            .as_expr_individual(l.span())\n-                                            .map_either(\n-                                                |i| SimpleAssignTarget::Ident(i.into()),\n-                                                SimpleAssignTarget::Member,\n-                                            )\n-                                            .into_inner();\n-                                    }\n-                                    ImportedIdent::None => {\n-                                        // Do nothing, cannot assign to `undefined`\n-                                    }\n-                                    ImportedIdent::Unresolvable => {\n-                                        // Do nothing, the reference will insert a throw\n-                                    }\n+                    visitors.push(create_visitor!(\n+                        exact,\n+                        ast_path,\n+                        visit_mut_simple_assign_target,\n+                        |l: &mut SimpleAssignTarget| {\n+                            use swc_core::common::Spanned;\n+                            match &imported_ident {\n+                                ImportedIdent::Module(imported_ident) => {\n+                                    *l = imported_ident\n+                                        .as_expr_individual(l.span())\n+                                        .map_either(\n+                                            |i| SimpleAssignTarget::Ident(i.into()),\n+                                            SimpleAssignTarget::Member,\n+                                        )\n+                                        .into_inner();\n+                                }\n+                                ImportedIdent::None => {\n+                                    // Do nothing, cannot assign to `undefined`\n+                                }\n+                                ImportedIdent::Unresolvable => {\n+                                    // Do nothing, the reference will insert a throw\n                                 }\n                             }\n-                        ));\n-                        break;\n-                    }\n+                        }\n+                    ));\n+                    break;\n                 }\n                 Some(_) => {\n                     ast_path.pop();"
        }
    ],
    "stats": {
        "total": 161,
        "additions": 72,
        "deletions": 89
    }
}