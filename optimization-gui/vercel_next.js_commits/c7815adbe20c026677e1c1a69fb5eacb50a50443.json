{
    "author": "sokra",
    "message": "Turbopack: cache directory creation (#78729)\n\n### What?\n\nCalling create directory for every written file is very expensive.\n\nInstead keep a memory cache of already created directories.",
    "sha": "c7815adbe20c026677e1c1a69fb5eacb50a50443",
    "files": [
        {
            "sha": "0750ddc2e0be4ecb53198940f2a1d407cf41d50d",
            "filename": "turbopack/crates/turbo-tasks-fs/src/lib.rs",
            "status": "modified",
            "additions": 46,
            "deletions": 30,
            "changes": 76,
            "blob_url": "https://github.com/vercel/next.js/blob/c7815adbe20c026677e1c1a69fb5eacb50a50443/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c7815adbe20c026677e1c1a69fb5eacb50a50443/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs?ref=c7815adbe20c026677e1c1a69fb5eacb50a50443",
            "patch": "@@ -48,6 +48,7 @@ use mime::Mime;\n use rayon::iter::{IntoParallelIterator, ParallelIterator};\n pub use read_glob::ReadGlobResult;\n use read_glob::{read_glob, track_glob};\n+use rustc_hash::FxHashSet;\n use serde::{Deserialize, Serialize};\n use serde_json::Value;\n use tokio::{\n@@ -59,8 +60,8 @@ use tracing::Instrument;\n use turbo_rcstr::RcStr;\n use turbo_tasks::{\n     debug::ValueDebugFormat, effect, mark_session_dependent, mark_stateful, trace::TraceRawVcs,\n-    Completion, InvalidationReason, Invalidator, NonLocalValue, ReadRef, ResolvedVc, ValueToString,\n-    Vc,\n+    ApplyEffectsContext, Completion, InvalidationReason, Invalidator, NonLocalValue, ReadRef,\n+    ResolvedVc, ValueToString, Vc,\n };\n use turbo_tasks_hash::{\n     hash_xxh3_hash128, hash_xxh3_hash64, DeterministicHash, DeterministicHasher,\n@@ -208,6 +209,12 @@ pub trait FileSystem: ValueToString {\n     fn metadata(self: Vc<Self>, fs_path: Vc<FileSystemPath>) -> Vc<FileMeta>;\n }\n \n+#[derive(Default)]\n+struct DiskFileSystemApplyContext {\n+    /// A cache of already created directories to avoid creating them multiple times.\n+    created_directories: FxHashSet<PathBuf>,\n+}\n+\n #[derive(Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue)]\n struct DiskFileSystemInner {\n     pub name: RcStr,\n@@ -393,6 +400,29 @@ impl DiskFileSystemInner {\n \n         Ok(())\n     }\n+\n+    async fn create_directory(self: &Arc<Self>, directory: &Path) -> Result<()> {\n+        let already_created = ApplyEffectsContext::with_or_insert_with(\n+            DiskFileSystemApplyContext::default,\n+            |fs_context| fs_context.created_directories.contains(directory),\n+        );\n+        if !already_created {\n+            let func = |p: &Path| std::fs::create_dir_all(p);\n+            retry_blocking(directory, func)\n+                .concurrency_limited(&self.semaphore)\n+                .instrument(tracing::info_span!(\n+                    \"create directory\",\n+                    path = display(directory.display())\n+                ))\n+                .await?;\n+            ApplyEffectsContext::with(|fs_context: &mut DiskFileSystemApplyContext| {\n+                fs_context\n+                    .created_directories\n+                    .insert(directory.to_path_buf())\n+            });\n+        }\n+        Ok(())\n+    }\n }\n \n #[turbo_tasks::value(cell = \"new\", eq = \"manual\")]\n@@ -735,20 +765,13 @@ impl FileSystem for DiskFileSystem {\n                     let create_directory = compare == FileComparison::Create;\n                     if create_directory {\n                         if let Some(parent) = full_path.parent() {\n-                            retry_blocking(parent, |p| std::fs::create_dir_all(p))\n-                                .concurrency_limited(&inner.semaphore)\n-                                .instrument(tracing::info_span!(\n-                                    \"create directory\",\n-                                    path = display(parent.display())\n-                                ))\n-                                .await\n-                                .with_context(|| {\n-                                    format!(\n-                                        \"failed to create directory {} for write to {}\",\n-                                        parent.display(),\n-                                        full_path.display()\n-                                    )\n-                                })?;\n+                            inner.create_directory(parent).await.with_context(|| {\n+                                format!(\n+                                    \"failed to create directory {} for write to {}\",\n+                                    parent.display(),\n+                                    full_path.display()\n+                                )\n+                            })?;\n                         }\n                     }\n                     let full_path_to_write = full_path.clone();\n@@ -872,20 +895,13 @@ impl FileSystem for DiskFileSystem {\n                     let create_directory = old_content.is_none();\n                     if create_directory {\n                         if let Some(parent) = full_path.parent() {\n-                            retry_blocking(parent, |path| std::fs::create_dir_all(path))\n-                                .concurrency_limited(&inner.semaphore)\n-                                .instrument(tracing::info_span!(\n-                                    \"create directory\",\n-                                    path = display(parent.display())\n-                                ))\n-                                .await\n-                                .with_context(|| {\n-                                    format!(\n-                                        \"failed to create directory {} for write to {}\",\n-                                        parent.display(),\n-                                        full_path.display()\n-                                    )\n-                                })?;\n+                            inner.create_directory(parent).await.with_context(|| {\n+                                format!(\n+                                    \"failed to create directory {} for write link to {}\",\n+                                    parent.display(),\n+                                    full_path.display()\n+                                )\n+                            })?;\n                         }\n                     }\n "
        },
        {
            "sha": "ed9bb2820309705f2e868676291a62108c6b415d",
            "filename": "turbopack/crates/turbo-tasks/src/effect.rs",
            "status": "modified",
            "additions": 103,
            "deletions": 28,
            "changes": 131,
            "blob_url": "https://github.com/vercel/next.js/blob/c7815adbe20c026677e1c1a69fb5eacb50a50443/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Feffect.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c7815adbe20c026677e1c1a69fb5eacb50a50443/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Feffect.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Feffect.rs?ref=c7815adbe20c026677e1c1a69fb5eacb50a50443",
            "patch": "@@ -1,10 +1,19 @@\n-use std::{borrow::Cow, future::Future, mem::replace, panic, pin::Pin};\n+use std::{\n+    any::{Any, TypeId},\n+    borrow::Cow,\n+    future::Future,\n+    mem::replace,\n+    panic,\n+    pin::Pin,\n+    sync::Arc,\n+};\n \n use anyhow::{anyhow, Result};\n use auto_hash_map::AutoSet;\n use futures::{StreamExt, TryStreamExt};\n use parking_lot::Mutex;\n-use rustc_hash::FxHashSet;\n+use rustc_hash::{FxHashMap, FxHashSet};\n+use tokio::task_local;\n use tracing::{Instrument, Span};\n \n use crate::{\n@@ -90,10 +99,10 @@ impl EffectInstance {\n                     listener.await;\n                 }\n                 State::NotStarted(EffectInner { future }) => {\n-                    let join_handle = tokio::spawn(\n+                    let join_handle = tokio::spawn(ApplyEffectsContext::in_current_scope(\n                         turbo_tasks_future_scope(turbo_tasks::turbo_tasks(), future)\n                             .instrument(Span::current()),\n-                    );\n+                    ));\n                     let result = match join_handle.await {\n                         Ok(Err(err)) => Err(SharedError::new(err)),\n                         Err(err) => {\n@@ -170,20 +179,22 @@ pub async fn apply_effects(source: impl CollectiblesSource) -> Result<()> {\n         return Ok(());\n     }\n     let span = tracing::info_span!(\"apply effects\", count = effects.len());\n-    async move {\n-        // Limit the concurrency of effects\n-        futures::stream::iter(effects)\n-            .map(Ok)\n-            .try_for_each_concurrent(APPLY_EFFECTS_CONCURRENCY_LIMIT, async |effect| {\n-                let Some(effect) = ResolvedVc::try_downcast_type::<EffectInstance>(effect) else {\n-                    panic!(\"Effect must only be implemented by EffectInstance\");\n-                };\n-                effect.await?.apply().await\n-            })\n-            .await\n-    }\n-    .instrument(span)\n-    .await\n+    APPLY_EFFECTS_CONTEXT\n+        .scope(Default::default(), async move {\n+            // Limit the concurrency of effects\n+            futures::stream::iter(effects)\n+                .map(Ok)\n+                .try_for_each_concurrent(APPLY_EFFECTS_CONCURRENCY_LIMIT, async |effect| {\n+                    let Some(effect) = ResolvedVc::try_downcast_type::<EffectInstance>(effect)\n+                    else {\n+                        panic!(\"Effect must only be implemented by EffectInstance\");\n+                    };\n+                    effect.await?.apply().await\n+                })\n+                .await\n+        })\n+        .instrument(span)\n+        .await\n }\n \n /// Capture effects from an turbo-tasks operation. Since this captures collectibles it might\n@@ -252,17 +263,81 @@ impl Effects {\n     /// Applies all effects that have been captured by this struct.\n     pub async fn apply(&self) -> Result<()> {\n         let span = tracing::info_span!(\"apply effects\", count = self.effects.len());\n-        async move {\n-            // Limit the concurrency of effects\n-            futures::stream::iter(self.effects.iter())\n-                .map(Ok)\n-                .try_for_each_concurrent(APPLY_EFFECTS_CONCURRENCY_LIMIT, async |effect| {\n-                    effect.apply().await\n+        APPLY_EFFECTS_CONTEXT\n+            .scope(Default::default(), async move {\n+                // Limit the concurrency of effects\n+                futures::stream::iter(self.effects.iter())\n+                    .map(Ok)\n+                    .try_for_each_concurrent(APPLY_EFFECTS_CONCURRENCY_LIMIT, async |effect| {\n+                        effect.apply().await\n+                    })\n+                    .await\n+            })\n+            .instrument(span)\n+            .await\n+    }\n+}\n+\n+task_local! {\n+    /// The context of the current effects application.\n+    static APPLY_EFFECTS_CONTEXT: Arc<Mutex<ApplyEffectsContext>>;\n+}\n+\n+#[derive(Default)]\n+pub struct ApplyEffectsContext {\n+    data: FxHashMap<TypeId, Box<dyn Any + Send + Sync>>,\n+}\n+\n+impl ApplyEffectsContext {\n+    fn in_current_scope<F: Future>(f: F) -> impl Future<Output = F::Output> {\n+        let current = Self::current();\n+        APPLY_EFFECTS_CONTEXT.scope(current, f)\n+    }\n+\n+    fn current() -> Arc<Mutex<Self>> {\n+        APPLY_EFFECTS_CONTEXT\n+            .try_with(|mutex| mutex.clone())\n+            .expect(\"No effect context found\")\n+    }\n+\n+    fn with_context<T, F: FnOnce(&mut Self) -> T>(f: F) -> T {\n+        APPLY_EFFECTS_CONTEXT\n+            .try_with(|mutex| f(&mut mutex.lock()))\n+            .expect(\"No effect context found\")\n+    }\n+\n+    pub fn set<T: Any + Send + Sync>(value: T) {\n+        Self::with_context(|this| {\n+            this.data.insert(TypeId::of::<T>(), Box::new(value));\n+        })\n+    }\n+\n+    pub fn with<T: Any + Send + Sync, R>(f: impl FnOnce(&mut T) -> R) -> Option<R> {\n+        Self::with_context(|this| {\n+            this.data\n+                .get_mut(&TypeId::of::<T>())\n+                .map(|value| {\n+                    // Safety: the map is keyed by TypeId\n+                    unsafe { value.downcast_mut_unchecked() }\n                 })\n-                .await\n-        }\n-        .instrument(span)\n-        .await\n+                .map(f)\n+        })\n+    }\n+\n+    pub fn with_or_insert_with<T: Any + Send + Sync, R>(\n+        insert_with: impl FnOnce() -> T,\n+        f: impl FnOnce(&mut T) -> R,\n+    ) -> R {\n+        Self::with_context(|this| {\n+            let value = this.data.entry(TypeId::of::<T>()).or_insert_with(|| {\n+                let value = insert_with();\n+                Box::new(value)\n+            });\n+            f(\n+                // Safety: the map is keyed by TypeId\n+                unsafe { value.downcast_mut_unchecked() },\n+            )\n+        })\n     }\n }\n "
        },
        {
            "sha": "17c016f813fc8a4012e556235fd84cea406ba90d",
            "filename": "turbopack/crates/turbo-tasks/src/lib.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/c7815adbe20c026677e1c1a69fb5eacb50a50443/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c7815adbe20c026677e1c1a69fb5eacb50a50443/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs?ref=c7815adbe20c026677e1c1a69fb5eacb50a50443",
            "patch": "@@ -36,6 +36,7 @@\n #![feature(arbitrary_self_types_pointers)]\n #![feature(new_zeroed_alloc)]\n #![feature(never_type)]\n+#![feature(downcast_unchecked)]\n \n pub mod backend;\n mod capture_future;\n@@ -89,7 +90,7 @@ use auto_hash_map::AutoSet;\n pub use collectibles::CollectiblesSource;\n pub use completion::{Completion, Completions};\n pub use display::ValueToString;\n-pub use effect::{apply_effects, effect, get_effects, Effects};\n+pub use effect::{apply_effects, effect, get_effects, ApplyEffectsContext, Effects};\n pub use id::{\n     ExecutionId, FunctionId, LocalTaskId, SessionId, TaskId, TraitTypeId, ValueTypeId,\n     TRANSIENT_TASK_BIT,"
        }
    ],
    "stats": {
        "total": 210,
        "additions": 151,
        "deletions": 59
    }
}