{
    "author": "bgw",
    "message": "Turbopack: Add cache for reqwest clients (#81742)\n\nWe need a cache because:\n- This will allow us to enable HTTP keep-alive in a subsequent PR which would allow connection-reuse.\n- Using `rustls-tls-native` may make client construction far more expensive: #79060\n\nClients don't fit turbo-task's caching architecture and are not serializable, so the cache lives outside of turbo-tasks. I'm re-using the https://docs.rs/quick_cache/latest/quick_cache/ crate for this, which we already pull in for turbo-persistence.",
    "sha": "9d44731ae34ac60f9db3b5c36b4d4060e5d29af1",
    "files": [
        {
            "sha": "8c08c8c0dfcc0e6f6f1da4889e5243bebc48352f",
            "filename": "Cargo.lock",
            "status": "modified",
            "additions": 5,
            "deletions": 3,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/9d44731ae34ac60f9db3b5c36b4d4060e5d29af1/Cargo.lock",
            "raw_url": "https://github.com/vercel/next.js/raw/9d44731ae34ac60f9db3b5c36b4d4060e5d29af1/Cargo.lock",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/Cargo.lock?ref=9d44731ae34ac60f9db3b5c36b4d4060e5d29af1",
            "patch": "@@ -2799,7 +2799,7 @@ dependencies = [\n  \"httpdate\",\n  \"itoa\",\n  \"pin-project-lite\",\n- \"socket2 0.4.9\",\n+ \"socket2 0.5.10\",\n  \"tokio\",\n  \"tower-service\",\n  \"tracing\",\n@@ -5460,9 +5460,9 @@ checksum = \"a993555f31e5a609f617c12db6250dedcac1b0a85076912c436e6fc9b2c8e6a3\"\n \n [[package]]\n name = \"quick_cache\"\n-version = \"0.6.11\"\n+version = \"0.6.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0af25b4e960ffdf0dead61cf0cec0c2e44c76927bf933ab4f02e2858fb449397\"\n+checksum = \"6b450dad8382b1b95061d5ca1eb792081fb082adf48c678791fe917509596d5f\"\n dependencies = [\n  \"ahash 0.8.12\",\n  \"equivalent\",\n@@ -9338,7 +9338,9 @@ version = \"0.1.0\"\n dependencies = [\n  \"anyhow\",\n  \"mockito\",\n+ \"quick_cache\",\n  \"reqwest 0.12.20\",\n+ \"serde\",\n  \"tokio\",\n  \"turbo-rcstr\",\n  \"turbo-tasks\","
        },
        {
            "sha": "4ecf8109c7c7e416447afb03bc771066c82d1b74",
            "filename": "Cargo.toml",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/9d44731ae34ac60f9db3b5c36b4d4060e5d29af1/Cargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/9d44731ae34ac60f9db3b5c36b4d4060e5d29af1/Cargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/Cargo.toml?ref=9d44731ae34ac60f9db3b5c36b4d4060e5d29af1",
            "patch": "@@ -390,6 +390,7 @@ pin-project-lite = \"0.2.9\"\n postcard = \"1.0.4\"\n proc-macro2 = \"1.0.79\"\n qstring = \"0.7.2\"\n+quick_cache = { version = \"0.6.14\" }\n quote = \"1.0.23\"\n rand = \"0.9.0\"\n rayon = \"1.10.0\""
        },
        {
            "sha": "85ac1e7b42e029a5342e655b8ce064a7044bf5a1",
            "filename": "crates/next-core/src/next_font/google/mod.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/9d44731ae34ac60f9db3b5c36b4d4060e5d29af1/crates%2Fnext-core%2Fsrc%2Fnext_font%2Fgoogle%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/9d44731ae34ac60f9db3b5c36b4d4060e5d29af1/crates%2Fnext-core%2Fsrc%2Fnext_font%2Fgoogle%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_font%2Fgoogle%2Fmod.rs?ref=9d44731ae34ac60f9db3b5c36b4d4060e5d29af1",
            "patch": "@@ -9,7 +9,7 @@ use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{Completion, FxIndexMap, ResolvedVc, Vc};\n use turbo_tasks_bytes::stream::SingleValue;\n use turbo_tasks_env::{CommandLineProcessEnv, ProcessEnv};\n-use turbo_tasks_fetch::{HttpResponseBody, fetch};\n+use turbo_tasks_fetch::{HttpResponseBody, ReqwestClientConfig, fetch};\n use turbo_tasks_fs::{\n     DiskFileSystem, File, FileContent, FileSystem, FileSystemPath,\n     json::parse_json_with_source_context,\n@@ -663,7 +663,7 @@ async fn fetch_from_google_fonts(\n     let result = fetch(\n         url,\n         Some(rcstr!(USER_AGENT_FOR_GOOGLE_FONTS)),\n-        Vc::cell(None),\n+        ReqwestClientConfig { proxy: None }.cell(),\n     )\n     .await?;\n "
        },
        {
            "sha": "c3e26489251baa8cab0ca3bb0ebc5385e9c09fd3",
            "filename": "turbopack/crates/turbo-persistence/Cargo.toml",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/9d44731ae34ac60f9db3b5c36b4d4060e5d29af1/turbopack%2Fcrates%2Fturbo-persistence%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/9d44731ae34ac60f9db3b5c36b4d4060e5d29af1/turbopack%2Fcrates%2Fturbo-persistence%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-persistence%2FCargo.toml?ref=9d44731ae34ac60f9db3b5c36b4d4060e5d29af1",
            "patch": "@@ -21,7 +21,7 @@ lzzzz = \"1.1.0\"\n memmap2 = \"0.9.5\"\n parking_lot = { workspace = true }\n qfilter = { version = \"0.2.4\", features = [\"serde\"] }\n-quick_cache = { version = \"0.6.9\" }\n+quick_cache = { workspace = true }\n rayon = { workspace = true }\n rustc-hash = { workspace = true }\n smallvec = { workspace = true}"
        },
        {
            "sha": "5aec449b4fda86066c84d04e6ec33aa49faab7cb",
            "filename": "turbopack/crates/turbo-tasks-fetch/Cargo.toml",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/9d44731ae34ac60f9db3b5c36b4d4060e5d29af1/turbopack%2Fcrates%2Fturbo-tasks-fetch%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/9d44731ae34ac60f9db3b5c36b4d4060e5d29af1/turbopack%2Fcrates%2Fturbo-tasks-fetch%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fetch%2FCargo.toml?ref=9d44731ae34ac60f9db3b5c36b4d4060e5d29af1",
            "patch": "@@ -25,7 +25,9 @@ reqwest = { workspace = true, features = [\"rustls-tls\"] }\n \n [dependencies]\n anyhow = { workspace = true }\n+quick_cache = { workspace = true }\n reqwest = { workspace = true }\n+serde = { workspace = true }\n tokio = { workspace = true }\n turbo-rcstr = { workspace = true }\n turbo-tasks = { workspace = true }"
        },
        {
            "sha": "259d3f005f45d8f4c95edf43749a192e260b5d0f",
            "filename": "turbopack/crates/turbo-tasks-fetch/src/lib.rs",
            "status": "modified",
            "additions": 38,
            "deletions": 43,
            "changes": 81,
            "blob_url": "https://github.com/vercel/next.js/blob/9d44731ae34ac60f9db3b5c36b4d4060e5d29af1/turbopack%2Fcrates%2Fturbo-tasks-fetch%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/9d44731ae34ac60f9db3b5c36b4d4060e5d29af1/turbopack%2Fcrates%2Fturbo-tasks-fetch%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fetch%2Fsrc%2Flib.rs?ref=9d44731ae34ac60f9db3b5c36b4d4060e5d29af1",
            "patch": "@@ -2,12 +2,20 @@\n #![feature(arbitrary_self_types)]\n #![feature(arbitrary_self_types_pointers)]\n \n+mod reqwest_client_cache;\n+\n use anyhow::Result;\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{ResolvedVc, Vc, duration_span, mark_session_dependent};\n use turbo_tasks_fs::FileSystemPath;\n use turbopack_core::issue::{Issue, IssueSeverity, IssueStage, OptionStyledString, StyledString};\n \n+use crate::reqwest_client_cache::try_get_cached_reqwest_client;\n+pub use crate::reqwest_client_cache::{\n+    __test_only_reqwest_client_cache_clear, __test_only_reqwest_client_cache_len, ProxyConfig,\n+    ReqwestClientConfig,\n+};\n+\n pub fn register() {\n     turbo_tasks::register();\n     turbo_tasks_fs::register();\n@@ -38,60 +46,47 @@ impl HttpResponseBody {\n     }\n }\n \n-#[turbo_tasks::value(shared)]\n-#[derive(Debug)]\n-pub enum ProxyConfig {\n-    Http(String),\n-    Https(String),\n-}\n-\n-#[turbo_tasks::value(transparent)]\n-pub struct OptionProxyConfig(Option<ProxyConfig>);\n-\n #[turbo_tasks::function(network)]\n pub async fn fetch(\n     url: RcStr,\n     user_agent: Option<RcStr>,\n-    proxy_option: Vc<OptionProxyConfig>,\n+    client_config: Vc<ReqwestClientConfig>,\n ) -> Result<Vc<FetchResult>> {\n-    let proxy_option = &*proxy_option.await?;\n+    let url_ref = &*url;\n+    let client_config = client_config.await?;\n+    let response_result: reqwest::Result<HttpResponse> = async move {\n+        let client = try_get_cached_reqwest_client(client_config)?;\n+\n+        let mut builder = client.get(url_ref);\n+        if let Some(user_agent) = user_agent {\n+            builder = builder.header(\"User-Agent\", user_agent.as_str());\n+        }\n \n-    let client_builder = reqwest::Client::builder();\n-    let client_builder = match proxy_option {\n-        Some(ProxyConfig::Http(proxy)) => client_builder.proxy(reqwest::Proxy::http(proxy)?),\n-        Some(ProxyConfig::Https(proxy)) => client_builder.proxy(reqwest::Proxy::https(proxy)?),\n-        _ => client_builder,\n-    };\n+        let response = {\n+            let _span = duration_span!(\"fetch request\", url = url_ref);\n+            builder.send().await\n+        }\n+        .and_then(|r| r.error_for_status())?;\n \n-    let client = client_builder.build()?;\n+        let status = response.status().as_u16();\n \n-    let mut builder = client.get(url.as_str());\n-    if let Some(user_agent) = user_agent {\n-        builder = builder.header(\"User-Agent\", user_agent.as_str());\n-    }\n+        let body = {\n+            let _span = duration_span!(\"fetch response\", url = url_ref);\n+            response.bytes().await?\n+        }\n+        .to_vec();\n \n-    let response = {\n-        let _span = duration_span!(\"fetch request\", url = url.as_str());\n-        builder.send().await\n+        Ok(HttpResponse {\n+            status,\n+            body: HttpResponseBody(body).resolved_cell(),\n+        })\n     }\n-    .and_then(|r| r.error_for_status());\n-    match response {\n-        Ok(response) => {\n-            let status = response.status().as_u16();\n-\n-            let body = {\n-                let _span = duration_span!(\"fetch response\", url = url.as_str());\n-                response.bytes().await?\n-            }\n-            .to_vec();\n-\n-            Ok(Vc::cell(Ok(HttpResponse {\n-                status,\n-                body: HttpResponseBody(body).resolved_cell(),\n-            }\n-            .resolved_cell())))\n-        }\n+    .await;\n+\n+    match response_result {\n+        Ok(resp) => Ok(Vc::cell(Ok(resp.resolved_cell()))),\n         Err(err) => {\n+            // the client failed to construct or the HTTP request failed\n             mark_session_dependent();\n             Ok(Vc::cell(Err(\n                 FetchError::from_reqwest_error(&err, &url).resolved_cell()"
        },
        {
            "sha": "2a695dc640f9de83f8b2e15e2c1b59b16ec0b17e",
            "filename": "turbopack/crates/turbo-tasks-fetch/src/reqwest_client_cache.rs",
            "status": "added",
            "additions": 74,
            "deletions": 0,
            "changes": 74,
            "blob_url": "https://github.com/vercel/next.js/blob/9d44731ae34ac60f9db3b5c36b4d4060e5d29af1/turbopack%2Fcrates%2Fturbo-tasks-fetch%2Fsrc%2Freqwest_client_cache.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/9d44731ae34ac60f9db3b5c36b4d4060e5d29af1/turbopack%2Fcrates%2Fturbo-tasks-fetch%2Fsrc%2Freqwest_client_cache.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fetch%2Fsrc%2Freqwest_client_cache.rs?ref=9d44731ae34ac60f9db3b5c36b4d4060e5d29af1",
            "patch": "@@ -0,0 +1,74 @@\n+use std::{hash::Hash, sync::LazyLock};\n+\n+use quick_cache::sync::Cache;\n+use serde::{Deserialize, Serialize};\n+use turbo_rcstr::RcStr;\n+use turbo_tasks::{NonLocalValue, ReadRef, trace::TraceRawVcs};\n+\n+const MAX_CLIENTS: usize = 16;\n+static CLIENT_CACHE: LazyLock<Cache<ReadRef<ReqwestClientConfig>, reqwest::Client>> =\n+    LazyLock::new(|| Cache::new(MAX_CLIENTS));\n+\n+#[derive(Hash, PartialEq, Eq, Serialize, Deserialize, NonLocalValue, Debug, TraceRawVcs)]\n+pub enum ProxyConfig {\n+    Http(RcStr),\n+    Https(RcStr),\n+}\n+\n+/// Represents the configuration needed to construct a [`reqwest::Client`].\n+///\n+/// This is used to cache clients keyed by their configuration, so the configuration should contain\n+/// as few fields as possible and change infrequently.\n+///\n+/// This is needed because [`reqwest::ClientBuilder`] does not implement the required traits. This\n+/// factory cannot be a closure because closures do not implement `Eq` or `Hash`.\n+#[turbo_tasks::value(shared)]\n+#[derive(Hash)]\n+pub struct ReqwestClientConfig {\n+    pub proxy: Option<ProxyConfig>,\n+}\n+\n+impl ReqwestClientConfig {\n+    fn try_build(&self) -> reqwest::Result<reqwest::Client> {\n+        let mut client_builder = reqwest::Client::builder();\n+        match &self.proxy {\n+            Some(ProxyConfig::Http(proxy)) => {\n+                client_builder = client_builder.proxy(reqwest::Proxy::http(proxy.as_str())?)\n+            }\n+            Some(ProxyConfig::Https(proxy)) => {\n+                client_builder = client_builder.proxy(reqwest::Proxy::https(proxy.as_str())?)\n+            }\n+            None => {}\n+        };\n+        client_builder.build()\n+    }\n+}\n+\n+/// Given a config, returns a cached instance if it exists, otherwise constructs a new one.\n+///\n+/// The cache is bound in size to prevent accidental blowups or leaks. However, in practice, very\n+/// few clients should be created, likely only when the bundler configuration changes.\n+///\n+/// Client construction is largely deterministic, aside from changes to system TLS configuration.\n+///\n+/// The reqwest client fails to construct if the TLS backend cannot be initialized, or the resolver\n+/// cannot load the system configuration. These failures should be treated as cached for some amount\n+/// of time, but ultimately transient (e.g. using [`turbo_tasks::mark_session_dependent`]).\n+pub fn try_get_cached_reqwest_client(\n+    config: ReadRef<ReqwestClientConfig>,\n+) -> reqwest::Result<reqwest::Client> {\n+    CLIENT_CACHE.get_or_insert_with(&config, {\n+        let config = ReadRef::clone(&config);\n+        move || config.try_build()\n+    })\n+}\n+\n+#[doc(hidden)]\n+pub fn __test_only_reqwest_client_cache_clear() {\n+    CLIENT_CACHE.clear()\n+}\n+\n+#[doc(hidden)]\n+pub fn __test_only_reqwest_client_cache_len() -> usize {\n+    CLIENT_CACHE.len()\n+}"
        },
        {
            "sha": "d32431550cd0dac6ec6934db307034bc108a6366",
            "filename": "turbopack/crates/turbo-tasks-fetch/tests/fetch.rs",
            "status": "modified",
            "additions": 86,
            "deletions": 10,
            "changes": 96,
            "blob_url": "https://github.com/vercel/next.js/blob/9d44731ae34ac60f9db3b5c36b4d4060e5d29af1/turbopack%2Fcrates%2Fturbo-tasks-fetch%2Ftests%2Ffetch.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/9d44731ae34ac60f9db3b5c36b4d4060e5d29af1/turbopack%2Fcrates%2Fturbo-tasks-fetch%2Ftests%2Ffetch.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fetch%2Ftests%2Ffetch.rs?ref=9d44731ae34ac60f9db3b5c36b4d4060e5d29af1",
            "patch": "@@ -1,17 +1,26 @@\n #![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n #![cfg(test)]\n \n+use tokio::sync::Mutex as TokioMutex;\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::Vc;\n-use turbo_tasks_fetch::{FetchErrorKind, fetch};\n+use turbo_tasks_fetch::{\n+    __test_only_reqwest_client_cache_clear, __test_only_reqwest_client_cache_len, FetchErrorKind,\n+    ProxyConfig, ReqwestClientConfig, fetch,\n+};\n use turbo_tasks_fs::{DiskFileSystem, FileSystem, FileSystemPath};\n use turbo_tasks_testing::{Registration, register, run};\n use turbopack_core::issue::{Issue, IssueSeverity, StyledString};\n \n static REGISTRATION: Registration = register!(turbo_tasks_fetch::register);\n \n+/// We inspect information about the global client cache, so *every* test in this process *must*\n+/// acquire and hold this lock to prevent potential flakiness.\n+static GLOBAL_TEST_LOCK: TokioMutex<()> = TokioMutex::const_new(());\n+\n #[tokio::test]\n async fn basic_get() {\n+    let _guard = GLOBAL_TEST_LOCK.lock().await;\n     run(&REGISTRATION, || async {\n         let mut server = mockito::Server::new_async().await;\n         let resource_mock = server\n@@ -20,10 +29,11 @@ async fn basic_get() {\n             .create_async()\n             .await;\n \n+        let config_vc = ReqwestClientConfig { proxy: None }.cell();\n         let response = &*fetch(\n             RcStr::from(format!(\"{}/foo.woff\", server.url())),\n             /* user_agent */ None,\n-            /* proxy */ Vc::cell(None),\n+            config_vc,\n         )\n         .await?\n         .unwrap()\n@@ -41,6 +51,7 @@ async fn basic_get() {\n \n #[tokio::test]\n async fn sends_user_agent() {\n+    let _guard = GLOBAL_TEST_LOCK.lock().await;\n     run(&REGISTRATION, || async {\n         let mut server = mockito::Server::new_async().await;\n         let resource_mock = server\n@@ -52,10 +63,11 @@ async fn sends_user_agent() {\n \n         eprintln!(\"{}\", server.url());\n \n+        let config_vc = ReqwestClientConfig { proxy: None }.cell();\n         let response = &*fetch(\n             RcStr::from(format!(\"{}/foo.woff\", server.url())),\n             Some(rcstr!(\"mock-user-agent\")),\n-            /* proxy */ Vc::cell(None),\n+            config_vc,\n         )\n         .await?\n         .unwrap()\n@@ -75,6 +87,7 @@ async fn sends_user_agent() {\n // TODO: Implement invalidation that respects Cache-Control headers.\n #[tokio::test]\n async fn invalidation_does_not_invalidate() {\n+    let _guard = GLOBAL_TEST_LOCK.lock().await;\n     run(&REGISTRATION, || async {\n         let mut server = mockito::Server::new_async().await;\n         let resource_mock = server\n@@ -85,8 +98,8 @@ async fn invalidation_does_not_invalidate() {\n             .await;\n \n         let url = RcStr::from(format!(\"{}/foo.woff\", server.url()));\n-        let proxy_vc = Vc::cell(None);\n-        let response = &*fetch(url.clone(), /* user_agent */ None, proxy_vc)\n+        let config_vc = ReqwestClientConfig { proxy: None }.cell();\n+        let response = &*fetch(url.clone(), /* user_agent */ None, config_vc)\n             .await?\n             .unwrap()\n             .await?;\n@@ -96,7 +109,7 @@ async fn invalidation_does_not_invalidate() {\n         assert_eq!(response.status, 200);\n         assert_eq!(*response.body.to_string().await?, \"responsebody\");\n \n-        let second_response = &*fetch(url.clone(), /* user_agent */ None, proxy_vc)\n+        let second_response = &*fetch(url.clone(), /* user_agent */ None, config_vc)\n             .await?\n             .unwrap()\n             .await?;\n@@ -111,14 +124,20 @@ async fn invalidation_does_not_invalidate() {\n     .unwrap()\n }\n \n+fn get_issue_context() -> Vc<FileSystemPath> {\n+    DiskFileSystem::new(rcstr!(\"root\"), rcstr!(\"/\"), vec![]).root()\n+}\n+\n #[tokio::test]\n async fn errors_on_failed_connection() {\n+    let _guard = GLOBAL_TEST_LOCK.lock().await;\n     run(&REGISTRATION, || async {\n         // Try to connect to port 0 on localhost, which is never valid and immediately returns\n         // `ECONNREFUSED`.\n         // Other values (e.g. domain name, reserved IP address block) may result in long timeouts.\n         let url = rcstr!(\"http://127.0.0.1:0/foo.woff\");\n-        let response_vc = fetch(url.clone(), None, Vc::cell(None));\n+        let config_vc = ReqwestClientConfig { proxy: None }.cell();\n+        let response_vc = fetch(url.clone(), None, config_vc);\n         let err_vc = &*response_vc.await?.unwrap_err();\n         let err = err_vc.await?;\n \n@@ -142,6 +161,7 @@ async fn errors_on_failed_connection() {\n \n #[tokio::test]\n async fn errors_on_404() {\n+    let _guard = GLOBAL_TEST_LOCK.lock().await;\n     run(&REGISTRATION, || async {\n         let mut server = mockito::Server::new_async().await;\n         let resource_mock = server\n@@ -151,7 +171,8 @@ async fn errors_on_404() {\n             .await;\n \n         let url = RcStr::from(server.url());\n-        let response_vc = fetch(url.clone(), None, Vc::cell(None));\n+        let config_vc = ReqwestClientConfig { proxy: None }.cell();\n+        let response_vc = fetch(url.clone(), None, config_vc);\n         let err_vc = &*response_vc.await?.unwrap_err();\n         let err = err_vc.await?;\n \n@@ -173,6 +194,61 @@ async fn errors_on_404() {\n     .unwrap()\n }\n \n-fn get_issue_context() -> Vc<FileSystemPath> {\n-    DiskFileSystem::new(rcstr!(\"root\"), rcstr!(\"/\"), vec![]).root()\n+#[tokio::test]\n+async fn client_cache() {\n+    // a simple fetch that should always succeed\n+    async fn simple_fetch(path: &str, config: ReqwestClientConfig) -> anyhow::Result<()> {\n+        let mut server = mockito::Server::new_async().await;\n+        let _resource_mock = server\n+            .mock(\"GET\", &*format!(\"/{path}\"))\n+            .with_body(\"responsebody\")\n+            .create_async()\n+            .await;\n+\n+        let url = RcStr::from(format!(\"{}/{}\", server.url(), path));\n+        let response = match &*fetch(url.clone(), /* user_agent */ None, config.cell()).await? {\n+            Ok(resp) => resp.await?,\n+            Err(_err) => {\n+                anyhow::bail!(\"fetch error\")\n+            }\n+        };\n+\n+        if response.status != 200 {\n+            anyhow::bail!(\"non-200 status code\")\n+        }\n+\n+        anyhow::Ok(())\n+    }\n+\n+    let _guard = GLOBAL_TEST_LOCK.lock().await;\n+    run(&REGISTRATION, || async {\n+        __test_only_reqwest_client_cache_clear();\n+        assert_eq!(__test_only_reqwest_client_cache_len(), 0);\n+\n+        simple_fetch(\"/foo\", ReqwestClientConfig { proxy: None })\n+            .await\n+            .unwrap();\n+        assert_eq!(__test_only_reqwest_client_cache_len(), 1);\n+\n+        // the client is reused if the config is the same (by equality)\n+        simple_fetch(\"/bar\", ReqwestClientConfig { proxy: None })\n+            .await\n+            .unwrap();\n+        assert_eq!(__test_only_reqwest_client_cache_len(), 1);\n+\n+        // the client is recreated if the config is different\n+        simple_fetch(\n+            \"/bar\",\n+            ReqwestClientConfig {\n+                proxy: Some(ProxyConfig::Http(RcStr::from(\"http://127.0.0.1:0/\"))),\n+            },\n+        )\n+        .await\n+        .unwrap_err();\n+        assert_eq!(__test_only_reqwest_client_cache_len(), 2);\n+\n+        Ok(())\n+    })\n+    .await\n+    .unwrap()\n }"
        }
    ],
    "stats": {
        "total": 268,
        "additions": 209,
        "deletions": 59
    }
}