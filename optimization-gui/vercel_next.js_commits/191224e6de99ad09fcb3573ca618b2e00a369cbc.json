{
    "author": "mischnic",
    "message": "Turbopack: defer sourcemaps processing to codegen (#78855)\n\nCloses PACK-3434\n\n```\n    // TODO This is too eagerly generating the source map. We should store a GenerateSourceMap\n    // instead and only actually generate the SourceMap when it's needed. This would allow to avoid\n    // generating the source map when a module is never included in the final bundle. It allows\n    // analysis to finish earlier which makes references available earlier which benefits\n    // parallelism. When SourceMaps are emitted it moves that generation work to the code generation\n    // phase which is more parallelizable.\n```",
    "sha": "191224e6de99ad09fcb3573ca618b2e00a369cbc",
    "files": [
        {
            "sha": "eab9f87f7a9d8a7e50479b88b419ab2085583ed3",
            "filename": "turbopack/crates/turbopack-ecmascript/src/lib.rs",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/191224e6de99ad09fcb3573ca618b2e00a369cbc/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/191224e6de99ad09fcb3573ca618b2e00a369cbc/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs?ref=191224e6de99ad09fcb3573ca618b2e00a369cbc",
            "patch": "@@ -86,7 +86,7 @@ use turbopack_core::{\n         FindContextFileResult,\n     },\n     source::Source,\n-    source_map::OptionStringifiedSourceMap,\n+    source_map::GenerateSourceMap,\n };\n // TODO remove this\n pub use turbopack_resolve::ecmascript as resolve;\n@@ -819,7 +819,7 @@ pub struct EcmascriptModuleContentOptions {\n     code_generation: ResolvedVc<CodeGens>,\n     async_module: ResolvedVc<OptionAsyncModule>,\n     generate_source_map: bool,\n-    original_source_map: ResolvedVc<OptionStringifiedSourceMap>,\n+    original_source_map: Option<ResolvedVc<Box<dyn GenerateSourceMap>>>,\n     exports: ResolvedVc<EcmascriptExports>,\n     async_module_info: Option<ResolvedVc<AsyncModuleInfo>>,\n }\n@@ -945,7 +945,7 @@ impl EcmascriptModuleContent {\n             specified_module_type,\n             vec![],\n             generate_source_map,\n-            OptionStringifiedSourceMap::none().to_resolved().await?,\n+            None,\n         )\n         .await?;\n         emit_content(content).await\n@@ -958,7 +958,7 @@ struct CodeGenResult {\n     comments: Either<ImmutableComments, Arc<ImmutableComments>>,\n     is_esm: bool,\n     generate_source_map: bool,\n-    original_source_map: Option<ResolvedVc<OptionStringifiedSourceMap>>,\n+    original_source_map: Option<ResolvedVc<Box<dyn GenerateSourceMap>>>,\n }\n \n async fn process_parse_result(\n@@ -967,7 +967,7 @@ async fn process_parse_result(\n     specified_module_type: SpecifiedModuleType,\n     code_gens: Vec<CodeGeneration>,\n     generate_source_map: bool,\n-    original_source_map: ResolvedVc<OptionStringifiedSourceMap>,\n+    original_source_map: Option<ResolvedVc<Box<dyn GenerateSourceMap>>>,\n ) -> Result<CodeGenResult> {\n     let parsed = parsed.final_read_hint().await?;\n \n@@ -1025,7 +1025,7 @@ async fn process_parse_result(\n                 comments,\n                 is_esm,\n                 generate_source_map,\n-                original_source_map: Some(original_source_map),\n+                original_source_map,\n             }\n         }\n         ParseResult::Unparseable { messages } => {\n@@ -1130,7 +1130,7 @@ async fn emit_content(content: CodeGenResult) -> Result<Vc<EcmascriptModuleConte\n             Some(generate_js_source_map(\n                 source_map.clone(),\n                 mappings,\n-                original_source_map.await?.as_ref(),\n+                original_source_map.generate_source_map().await?.as_ref(),\n             )?)\n         } else {\n             Some(generate_js_source_map(source_map.clone(), mappings, None)?)"
        },
        {
            "sha": "7c751f99a012abaccfa67982ca9fb717269b9312",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/mod.rs",
            "status": "modified",
            "additions": 16,
            "deletions": 39,
            "changes": 55,
            "blob_url": "https://github.com/vercel/next.js/blob/191224e6de99ad09fcb3573ca618b2e00a369cbc/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/191224e6de99ad09fcb3573ca618b2e00a369cbc/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fmod.rs?ref=191224e6de99ad09fcb3573ca618b2e00a369cbc",
            "patch": "@@ -56,7 +56,7 @@ use turbo_tasks::{\n     trace::TraceRawVcs, FxIndexMap, FxIndexSet, NonLocalValue, ReadRef, ResolvedVc, TaskInput,\n     TryJoinIterExt, Upcast, Value, ValueToString, Vc,\n };\n-use turbo_tasks_fs::{rope::Rope, FileSystemPath};\n+use turbo_tasks_fs::FileSystemPath;\n use turbopack_core::{\n     compile_time_info::{\n         CompileTimeInfo, DefineableNameSegment, FreeVarReference, FreeVarReferences,\n@@ -76,9 +76,7 @@ use turbopack_core::{\n         resolve, FindContextFileResult, ModulePart,\n     },\n     source::Source,\n-    source_map::{\n-        utils::resolve_source_map_sources, GenerateSourceMap, OptionStringifiedSourceMap,\n-    },\n+    source_map::GenerateSourceMap,\n };\n use turbopack_resolve::{\n     ecmascript::{apply_cjs_specific_options, cjs_resolve_source},\n@@ -148,6 +146,7 @@ use crate::{\n         node::PackageJsonReference,\n         require_context::{RequireContextAssetReference, RequireContextMap},\n         type_issue::SpecifiedModuleTypeIssue,\n+        util::InlineSourceMap,\n     },\n     runtime_functions::{\n         TUBROPACK_RUNTIME_FUNCTION_SHORTCUTS, TURBOPACK_EXPORT_NAMESPACE, TURBOPACK_EXPORT_VALUE,\n@@ -174,7 +173,7 @@ pub struct AnalyzeEcmascriptModuleResult {\n     pub has_side_effect_free_directive: bool,\n     /// `true` when the analysis was successful.\n     pub successful: bool,\n-    pub source_map: ResolvedVc<OptionStringifiedSourceMap>,\n+    pub source_map: Option<ResolvedVc<Box<dyn GenerateSourceMap>>>,\n }\n \n #[turbo_tasks::value_impl]\n@@ -223,7 +222,7 @@ pub struct AnalyzeEcmascriptModuleResultBuilder {\n     exports: EcmascriptExports,\n     async_module: ResolvedVc<OptionAsyncModule>,\n     successful: bool,\n-    source_map: Option<ResolvedVc<OptionStringifiedSourceMap>>,\n+    source_map: Option<ResolvedVc<Box<dyn GenerateSourceMap>>>,\n     has_side_effect_free_directive: bool,\n }\n \n@@ -289,7 +288,7 @@ impl AnalyzeEcmascriptModuleResultBuilder {\n     }\n \n     /// Sets the analysis result ES export.\n-    pub fn set_source_map(&mut self, source_map: ResolvedVc<OptionStringifiedSourceMap>) {\n+    pub fn set_source_map(&mut self, source_map: ResolvedVc<Box<dyn GenerateSourceMap>>) {\n         self.source_map = Some(source_map);\n     }\n \n@@ -401,12 +400,6 @@ impl AnalyzeEcmascriptModuleResultBuilder {\n \n         let references: Vec<_> = self.references.into_iter().collect();\n \n-        let source_map = if let Some(source_map) = self.source_map {\n-            source_map\n-        } else {\n-            OptionStringifiedSourceMap::none().to_resolved().await?\n-        };\n-\n         self.code_gens.shrink_to_fit();\n         Ok(AnalyzeEcmascriptModuleResult::cell(\n             AnalyzeEcmascriptModuleResult {\n@@ -424,7 +417,7 @@ impl AnalyzeEcmascriptModuleResultBuilder {\n                 async_module: self.async_module,\n                 has_side_effect_free_directive: self.has_side_effect_free_directive,\n                 successful: self.successful,\n-                source_map,\n+                source_map: self.source_map,\n             },\n         ))\n     }\n@@ -705,27 +698,24 @@ pub(crate) async fn analyse_ecmascript_module_internal(\n                         .to_resolved()\n                         .await?;\n                     analysis.add_reference(reference);\n-                    let source_map = reference.generate_source_map();\n-                    analysis.set_source_map(source_map.to_resolved().await?);\n+                    analysis.set_source_map(ResolvedVc::upcast(reference));\n                     source_map_from_comment = true;\n                 } else if JSON_DATA_URL_BASE64.is_match(path) {\n-                    let source_map = maybe_decode_data_url(path.into());\n-                    let source_map =\n-                        resolve_source_map_sources(source_map.as_ref(), origin_path).await?;\n-                    analysis.set_source_map(ResolvedVc::cell(source_map));\n+                    analysis.set_source_map(ResolvedVc::upcast(\n+                        InlineSourceMap {\n+                            origin_path: origin_path.to_resolved().await?,\n+                            source_map: path.into(),\n+                        }\n+                        .resolved_cell(),\n+                    ));\n                     source_map_from_comment = true;\n                 }\n             }\n             if !source_map_from_comment {\n                 if let Some(generate_source_map) =\n                     ResolvedVc::try_sidecast::<Box<dyn GenerateSourceMap>>(source)\n                 {\n-                    analysis.set_source_map(\n-                        generate_source_map\n-                            .generate_source_map()\n-                            .to_resolved()\n-                            .await?,\n-                    );\n+                    analysis.set_source_map(generate_source_map);\n                 }\n             }\n             anyhow::Ok(())\n@@ -3665,16 +3655,3 @@ fn is_invoking_node_process_eval(args: &[JsValue]) -> bool {\n \n     false\n }\n-\n-fn maybe_decode_data_url(url: RcStr) -> Option<Rope> {\n-    const DATA_PREAMBLE: &str = \"data:application/json;base64,\";\n-\n-    if !url.starts_with(DATA_PREAMBLE) {\n-        return None;\n-    }\n-    let data_b64 = &url[DATA_PREAMBLE.len()..];\n-    data_encoding::BASE64\n-        .decode(data_b64.as_bytes())\n-        .ok()\n-        .map(Rope::from)\n-}"
        },
        {
            "sha": "eba48358ad97debab672328b937460fb5dd6cb7c",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/util.rs",
            "status": "modified",
            "additions": 40,
            "deletions": 2,
            "changes": 42,
            "blob_url": "https://github.com/vercel/next.js/blob/191224e6de99ad09fcb3573ca618b2e00a369cbc/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Futil.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/191224e6de99ad09fcb3573ca618b2e00a369cbc/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Futil.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Futil.rs?ref=191224e6de99ad09fcb3573ca618b2e00a369cbc",
            "patch": "@@ -1,8 +1,14 @@\n use anyhow::Result;\n use swc_core::{ecma::ast::Expr, quote};\n use turbo_rcstr::RcStr;\n-use turbo_tasks::Vc;\n-use turbopack_core::resolve::parse::Request;\n+use turbo_tasks::{ResolvedVc, Vc};\n+use turbo_tasks_fs::{rope::Rope, FileSystemPath};\n+use turbopack_core::{\n+    resolve::parse::Request,\n+    source_map::{\n+        utils::resolve_source_map_sources, GenerateSourceMap, OptionStringifiedSourceMap,\n+    },\n+};\n \n /// Creates a IIFE expression that throws a \"Cannot find module\" error for the\n /// given request string\n@@ -36,3 +42,35 @@ pub async fn request_to_string(request: Vc<Request>) -> Result<Vc<RcStr>> {\n             .unwrap_or_else(|| \"unknown\".into()),\n     ))\n }\n+\n+#[turbo_tasks::value(shared)]\n+#[derive(Debug, Clone)]\n+pub struct InlineSourceMap {\n+    /// The file path of the module containing the sourcemap data URL\n+    pub origin_path: ResolvedVc<FileSystemPath>,\n+    /// The Base64 encoded JSON sourcemap string\n+    pub source_map: RcStr,\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl GenerateSourceMap for InlineSourceMap {\n+    #[turbo_tasks::function]\n+    pub async fn generate_source_map(&self) -> Result<Vc<OptionStringifiedSourceMap>> {\n+        let source_map = maybe_decode_data_url(&self.source_map);\n+        let source_map = resolve_source_map_sources(source_map.as_ref(), *self.origin_path).await?;\n+        Ok(Vc::cell(source_map))\n+    }\n+}\n+\n+fn maybe_decode_data_url(url: &str) -> Option<Rope> {\n+    const DATA_PREAMBLE: &str = \"data:application/json;base64,\";\n+\n+    if !url.starts_with(DATA_PREAMBLE) {\n+        return None;\n+    }\n+    let data_b64 = &url[DATA_PREAMBLE.len()..];\n+    data_encoding::BASE64\n+        .decode(data_b64.as_bytes())\n+        .ok()\n+        .map(Rope::from)\n+}"
        },
        {
            "sha": "06b2b51bb4218f7861b4aace741498ec2aa88034",
            "filename": "turbopack/crates/turbopack-ecmascript/src/side_effect_optimization/facade/module.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/191224e6de99ad09fcb3573ca618b2e00a369cbc/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Ffacade%2Fmodule.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/191224e6de99ad09fcb3573ca618b2e00a369cbc/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Ffacade%2Fmodule.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Ffacade%2Fmodule.rs?ref=191224e6de99ad09fcb3573ca618b2e00a369cbc",
            "patch": "@@ -11,7 +11,6 @@ use turbopack_core::{\n     module_graph::ModuleGraph,\n     reference::ModuleReferences,\n     resolve::ModulePart,\n-    source_map::OptionStringifiedSourceMap,\n };\n \n use super::chunk_item::EcmascriptModuleFacadeChunkItem;\n@@ -224,7 +223,7 @@ impl EcmascriptAnalyzable for EcmascriptModuleFacadeModule {\n             code_generation: CodeGens::empty().to_resolved().await?,\n             async_module: ResolvedVc::cell(Some(self.async_module().to_resolved().await?)),\n             generate_source_map: false,\n-            original_source_map: OptionStringifiedSourceMap::none().to_resolved().await?,\n+            original_source_map: None,\n             exports: self.get_exports().to_resolved().await?,\n             async_module_info,\n         }"
        }
    ],
    "stats": {
        "total": 114,
        "additions": 64,
        "deletions": 50
    }
}