{
    "author": "mischnic",
    "message": "Turbopack: prevent ParseResult recomputation (#81244)\n\nThere was a mistake here: `process_parse_result` consumes the `ParseResult` via `ReadRef::try_unwrap`, but then inside of that, `EsmExports ::code_gen` does another read of the same cell with `parse_result.await?`. That required a recomputation because the cell was destroyed shortly before.\r\nDon't do that anymore.\r\n\r\nNow, this is the only remaining recomputation, but that is somewhat expected (multiple facade modules have the same empty `ParseResult`):\r\n\r\n![Bildschirmfoto 2025-07-03 um 16 18 15](https://github.com/user-attachments/assets/468e1ef6-3e5a-4508-be48-da037bd44263)",
    "sha": "1c677a233b50d71d9f428dfcd5f4b343b3dcb2cd",
    "files": [
        {
            "sha": "c388e6358dd13f0fae899168b0673e70ef72f315",
            "filename": "turbopack/crates/turbopack-ecmascript/src/lib.rs",
            "status": "modified",
            "additions": 46,
            "deletions": 21,
            "changes": 67,
            "blob_url": "https://github.com/vercel/next.js/blob/1c677a233b50d71d9f428dfcd5f4b343b3dcb2cd/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1c677a233b50d71d9f428dfcd5f4b343b3dcb2cd/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs?ref=1c677a233b50d71d9f428dfcd5f4b343b3dcb2cd",
            "patch": "@@ -870,9 +870,11 @@ impl EcmascriptModuleContentOptions {\n     async fn merged_code_gens(\n         &self,\n         scope_hoisting_context: ScopeHoistingContext<'_>,\n+        eval_context: &EvalContext,\n     ) -> Result<Vec<CodeGeneration>> {\n+        // Don't read `parsed` here again, it will cause a recomputation as `process_parse_result`\n+        // has consumed the cell already.\n         let EcmascriptModuleContentOptions {\n-            parsed,\n             module,\n             chunking_context,\n             references,\n@@ -906,7 +908,7 @@ impl EcmascriptModuleContentOptions {\n                             .code_generation(\n                                 **chunking_context,\n                                 scope_hoisting_context,\n-                                Some(**parsed),\n+                                eval_context,\n                                 *module,\n                             )\n                             .await?,\n@@ -1096,7 +1098,6 @@ impl EcmascriptModuleContent {\n                     modules_header_width,\n                     comments,\n                 },\n-                export_contexts: None,\n                 is_esm: true,\n                 strict: true,\n                 original_source_map: CodeGenResultOriginalSourceMap::ScopeHoisting(\n@@ -1274,8 +1275,9 @@ async fn merge_modules(\n             Ok((\n                 *module,\n                 content\n-                    .export_contexts\n+                    .scope_hoisting_syntax_contexts\n                     .as_ref()\n+                    .map(|(_, export_contexts)| export_contexts)\n                     .context(\"expected exports contexts\")?,\n             ))\n         })\n@@ -1294,7 +1296,7 @@ async fn merge_modules(\n              program: &mut Program| {\n                 let _ = tracing::trace_span!(\"prepare module\").entered();\n                 if let CodeGenResult {\n-                    scope_hoisting_syntax_contexts: Some(module_contexts),\n+                    scope_hoisting_syntax_contexts: Some((module_contexts, _)),\n                     ..\n                 } = content\n                 {\n@@ -1555,14 +1557,16 @@ struct CodeGenResult {\n     program: Program,\n     source_map: CodeGenResultSourceMap,\n     comments: CodeGenResultComments,\n-    /// `eval_context.imports.exports`\n-    export_contexts: Option<FxHashMap<RcStr, Id>>,\n     is_esm: bool,\n     strict: bool,\n     original_source_map: CodeGenResultOriginalSourceMap,\n     minify: MinifyType,\n-    scope_hoisting_syntax_contexts:\n-        Option<FxDashMap<ResolvedVc<Box<dyn EcmascriptChunkPlaceable + 'static>>, SyntaxContext>>,\n+    #[allow(clippy::type_complexity)]\n+    /// (Map<Module, corresponding context for imports>, `eval_context.imports.exports`)\n+    scope_hoisting_syntax_contexts: Option<(\n+        FxDashMap<ResolvedVc<Box<dyn EcmascriptChunkPlaceable + 'static>>, SyntaxContext>,\n+        FxHashMap<RcStr, Id>,\n+    )>,\n }\n \n struct ScopeHoistingOptions<'a> {\n@@ -1584,22 +1588,21 @@ async fn process_parse_result(\n     with_consumed_parse_result(\n         parsed,\n         async |mut program, source_map, globals, eval_context, comments| -> Result<CodeGenResult> {\n-            let (top_level_mark, is_esm, strict, export_contexts) = eval_context\n+            let (top_level_mark, is_esm, strict) = eval_context\n+                .as_ref()\n                 .map_either(\n                     |e| {\n                         (\n                             e.top_level_mark,\n                             e.is_esm(specified_module_type),\n                             e.imports.strict,\n-                            Cow::Owned(e.imports.exports),\n                         )\n                     },\n                     |e| {\n                         (\n                             e.top_level_mark,\n                             e.is_esm(specified_module_type),\n                             e.imports.strict,\n-                            Cow::Borrowed(&e.imports.exports),\n                         )\n                     },\n                 )\n@@ -1617,7 +1620,23 @@ async fn process_parse_result(\n                         is_import_mark,\n                         globals,\n                     };\n-                    let code_gens = options.unwrap().merged_code_gens(ctx).await?;\n+                    let code_gens = options\n+                        .unwrap()\n+                        .merged_code_gens(\n+                            ctx,\n+                            match &eval_context {\n+                                Either::Left(e) => e,\n+                                Either::Right(e) => e,\n+                            },\n+                        )\n+                        .await?;\n+\n+                    let export_contexts = eval_context\n+                        .map_either(\n+                            |e| Cow::Owned(e.imports.exports),\n+                            |e| Cow::Borrowed(&e.imports.exports),\n+                        )\n+                        .into_inner();\n                     let preserved_exports =\n                         match &*scope_hoisting_options.module.get_exports().await? {\n                             EcmascriptExports::EsmExports(exports) => exports\n@@ -1652,12 +1671,21 @@ async fn process_parse_result(\n                             is_import_mark,\n                             module_syntax_contexts_cache,\n                             preserved_exports,\n+                            export_contexts,\n                         )),\n                         prepend_ident_comment,\n                     )\n                 } else if let Some(options) = options {\n                     (\n-                        options.merged_code_gens(ScopeHoistingContext::None).await?,\n+                        options\n+                            .merged_code_gens(\n+                                ScopeHoistingContext::None,\n+                                match &eval_context {\n+                                    Either::Left(e) => e,\n+                                    Either::Right(e) => e,\n+                                },\n+                            )\n+                            .await?,\n                         None,\n                         None,\n                     )\n@@ -1696,7 +1724,7 @@ async fn process_parse_result(\n                     }\n                 }\n \n-                if let Some((is_import_mark, _, preserved_exports)) = &retain_syntax_context {\n+                if let Some((is_import_mark, _, preserved_exports, _)) = &retain_syntax_context {\n                     program.visit_mut_with(&mut hygiene_rename_only(\n                         Some(top_level_mark),\n                         *is_import_mark,\n@@ -1733,13 +1761,13 @@ async fn process_parse_result(\n                     comments,\n                     extra_comments,\n                 },\n-                // TODO ideally don't clone here at all\n-                export_contexts: Some(export_contexts.into_owned()),\n                 is_esm,\n                 strict,\n                 original_source_map: CodeGenResultOriginalSourceMap::Single(original_source_map),\n                 minify,\n-                scope_hoisting_syntax_contexts: retain_syntax_context.map(|(_, ctxts, _)| ctxts),\n+                scope_hoisting_syntax_contexts: retain_syntax_context\n+                    // TODO ideally don't clone here\n+                    .map(|(_, ctxts, _, export_contexts)| (ctxts, export_contexts.into_owned())),\n             })\n         },\n         async |parse_result| -> Result<CodeGenResult> {\n@@ -1769,7 +1797,6 @@ async fn process_parse_result(\n                         }),\n                         source_map: CodeGenResultSourceMap::None,\n                         comments: CodeGenResultComments::Empty,\n-                        export_contexts: None,\n                         is_esm: false,\n                         strict: false,\n                         original_source_map: CodeGenResultOriginalSourceMap::Single(None),\n@@ -1796,7 +1823,6 @@ async fn process_parse_result(\n                         }),\n                         source_map: CodeGenResultSourceMap::None,\n                         comments: CodeGenResultComments::Empty,\n-                        export_contexts: None,\n                         is_esm: false,\n                         strict: false,\n                         original_source_map: CodeGenResultOriginalSourceMap::Single(None),\n@@ -1891,7 +1917,6 @@ async fn emit_content(\n         strict,\n         original_source_map,\n         minify,\n-        export_contexts: _,\n         scope_hoisting_syntax_contexts: _,\n     } = content;\n "
        },
        {
            "sha": "242cbfc1cc7cd2c54b3863c14a1d1079f7c50908",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/esm/export.rs",
            "status": "modified",
            "additions": 11,
            "deletions": 25,
            "changes": 36,
            "blob_url": "https://github.com/vercel/next.js/blob/1c677a233b50d71d9f428dfcd5f4b343b3dcb2cd/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fexport.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1c677a233b50d71d9f428dfcd5f4b343b3dcb2cd/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fexport.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fexport.rs?ref=1c677a233b50d71d9f428dfcd5f4b343b3dcb2cd",
            "patch": "@@ -30,10 +30,10 @@ use turbopack_core::{\n use super::base::ReferencedAsset;\n use crate::{\n     EcmascriptModuleAsset, ScopeHoistingContext,\n+    analyzer::graph::EvalContext,\n     chunk::{EcmascriptChunkPlaceable, EcmascriptExports},\n     code_gen::{CodeGeneration, CodeGenerationHoistedStmt},\n     magic_identifier,\n-    parse::ParseResult,\n     runtime_functions::{TURBOPACK_DYNAMIC, TURBOPACK_ESM},\n     tree_shake::asset::EcmascriptModulePartAsset,\n     utils::module_id_to_lit,\n@@ -555,7 +555,7 @@ impl EsmExports {\n         self: Vc<Self>,\n         chunking_context: Vc<Box<dyn ChunkingContext>>,\n         scope_hoisting_context: ScopeHoistingContext<'_>,\n-        parsed: Option<Vc<ParseResult>>,\n+        eval_context: &EvalContext,\n         module: ResolvedVc<Box<dyn EcmascriptChunkPlaceable>>,\n     ) -> Result<CodeGeneration> {\n         let export_usage_info = chunking_context.module_export_usage(*ResolvedVc::upcast(module));\n@@ -570,12 +570,6 @@ impl EsmExports {\n             return Ok(CodeGeneration::empty());\n         }\n \n-        let parsed = if let Some(parsed) = parsed {\n-            Some(parsed.await?)\n-        } else {\n-            None\n-        };\n-\n         let mut dynamic_exports = Vec::<Box<Expr>>::new();\n         {\n             let id = if let Some(module) = scope_hoisting_context.module()\n@@ -620,24 +614,16 @@ impl EsmExports {\n                     // TODO ideally, this information would just be stored in\n                     // EsmExport::LocalBinding and we wouldn't have to re-correlated this\n                     // information with eval_context.imports.exports to get the syntax context.\n-                    let binding = if let Some(parsed) = &parsed {\n-                        if let ParseResult::Ok { eval_context, .. } = &**parsed {\n-                            if let Some((local, ctxt)) = eval_context.imports.exports.get(exported)\n-                            {\n-                                Some((Cow::Borrowed(local.as_str()), *ctxt))\n-                            } else {\n-                                bail!(\n-                                    \"Expected export to be in eval context {:?} {:?}\",\n-                                    exported,\n-                                    eval_context.imports,\n-                                )\n-                            }\n+                    let binding =\n+                        if let Some((local, ctxt)) = eval_context.imports.exports.get(exported) {\n+                            Some((Cow::Borrowed(local.as_str()), *ctxt))\n                         } else {\n-                            None\n-                        }\n-                    } else {\n-                        None\n-                    };\n+                            bail!(\n+                                \"Expected export to be in eval context {:?} {:?}\",\n+                                exported,\n+                                eval_context.imports,\n+                            )\n+                        };\n                     let (local, ctxt) = binding.unwrap_or_else(|| {\n                         // Fallback, shouldn't happen in practice\n                         ("
        }
    ],
    "stats": {
        "total": 103,
        "additions": 57,
        "deletions": 46
    }
}