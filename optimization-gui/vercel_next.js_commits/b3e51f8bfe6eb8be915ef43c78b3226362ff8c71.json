{
    "author": "sokra",
    "message": "Turbopack: Use TransientCellData for non-serializable cells (#86069)\n\nUse TransientCellData for non-serializable cells\n\nuse SharedReference to reduce size\n\n<!-- Thanks for opening a PR! Your contribution is much appreciated.\nTo make sure your PR is handled as smoothly as possible we request that you follow the checklist sections below.\nChoose the right checklist for the change(s) that you're making:\n\n## For Contributors\n\n### Improving Documentation\n\n- Run `pnpm prettier-fix` to fix formatting issues before opening the PR.\n- Read the Docs Contribution Guide to ensure your contribution follows the docs guidelines: https://nextjs.org/docs/community/contribution-guide\n\n### Fixing a bug\n\n- Related issues linked using `fixes #number`\n- Tests added. See: https://github.com/vercel/next.js/blob/canary/contributing/core/testing.md#writing-tests-for-nextjs\n- Errors have a helpful link attached, see https://github.com/vercel/next.js/blob/canary/contributing.md\n\n### Adding a feature\n\n- Implements an existing feature request or RFC. Make sure the feature request has been accepted for implementation before opening a PR. (A discussion must be opened, see https://github.com/vercel/next.js/discussions/new?category=ideas)\n- Related issues/discussions are linked using `fixes #number`\n- e2e tests added (https://github.com/vercel/next.js/blob/canary/contributing/core/testing.md#writing-tests-for-nextjs)\n- Documentation added\n- Telemetry added. In case of a feature if it's used or not.\n- Errors have a helpful link attached, see https://github.com/vercel/next.js/blob/canary/contributing.md\n\n\n## For Maintainers\n\n- Minimal description (aim for explaining to someone not on the team to understand the PR)\n- When linking to a Slack thread, you might want to share details of the conclusion\n- Link both the Linear (Fixes NEXT-xxx) and the GitHub issues\n- Add review comments if necessary to explain to the reviewer the logic behind a change\n\n### What?\n\n### Why?\n\n### How?\n\nCloses NEXT-\nFixes #\n\n-->",
    "sha": "b3e51f8bfe6eb8be915ef43c78b3226362ff8c71",
    "files": [
        {
            "sha": "6451b4bfe2e42e0152842b5a08a9a3568a26d9c1",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 37,
            "deletions": 15,
            "changes": 52,
            "blob_url": "https://github.com/vercel/next.js/blob/b3e51f8bfe6eb8be915ef43c78b3226362ff8c71/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b3e51f8bfe6eb8be915ef43c78b3226362ff8c71/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=b3e51f8bfe6eb8be915ef43c78b3226362ff8c71",
            "patch": "@@ -817,9 +817,15 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             }\n         }\n \n+        let ReadCellOptions {\n+            is_serializable_cell_content,\n+            tracking,\n+            final_read_hint,\n+        } = options;\n+\n         let mut ctx = self.execute_context(turbo_tasks);\n         let (mut task, reader_task) = if self.should_track_dependencies()\n-            && !matches!(options.tracking, ReadTracking::Untracked)\n+            && !matches!(tracking, ReadTracking::Untracked)\n             && let Some(reader_id) = reader\n             && reader_id != task_id\n         {\n@@ -832,16 +838,13 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             (ctx.task(task_id, TaskDataCategory::Data), None)\n         };\n \n-        let content = if options.final_read_hint {\n-            remove!(task, CellData { cell })\n-        } else if let Some(content) = get!(task, CellData { cell }) {\n-            let content = content.clone();\n-            Some(content)\n+        let content = if final_read_hint {\n+            task.remove_cell_data(is_serializable_cell_content, cell)\n         } else {\n-            None\n+            task.get_cell_data(is_serializable_cell_content, cell)\n         };\n         if let Some(content) = content {\n-            if options.tracking.should_track(false) {\n+            if tracking.should_track(false) {\n                 add_cell_dependency(task_id, task, reader, reader_task, cell);\n             }\n             return Ok(Ok(TypedCellContent(\n@@ -868,7 +871,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         )\n         .copied();\n         let Some(max_id) = max_id else {\n-            if options.tracking.should_track(true) {\n+            if tracking.should_track(true) {\n                 add_cell_dependency(task_id, task, reader, reader_task, cell);\n             }\n             bail!(\n@@ -877,7 +880,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             );\n         };\n         if cell.index >= max_id {\n-            if options.tracking.should_track(true) {\n+            if tracking.should_track(true) {\n                 add_cell_dependency(task_id, task, reader, reader_task, cell);\n             }\n             bail!(\n@@ -2019,6 +2022,14 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                             .get(&cell.type_id).is_none_or(|start_index| cell.index >= *start_index))\n             }));\n         }\n+        if task_id.is_transient() || iter_many!(task, TransientCellData { cell }\n+            if cell_counters.get(&cell.type_id).is_none_or(|start_index| cell.index >= *start_index) => cell\n+        ).count() > 0 {\n+            removed_data.extend(task.extract_if(CachedDataItemType::TransientCellData, |key, _| {\n+                matches!(key, CachedDataItemKey::TransientCellData { cell } if cell_counters\n+                            .get(&cell.type_id).is_none_or(|start_index| cell.index >= *start_index))\n+            }));\n+        }\n \n         old_edges.extend(\n             task.iter(CachedDataItemType::OutdatedCollectible)\n@@ -2459,6 +2470,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n     fn task_execution_completed_cleanup(&self, ctx: &mut impl ExecuteContext<'_>, task_id: TaskId) {\n         let mut task = ctx.task(task_id, TaskDataCategory::All);\n         task.shrink_to_fit(CachedDataItemType::CellData);\n+        task.shrink_to_fit(CachedDataItemType::TransientCellData);\n         task.shrink_to_fit(CachedDataItemType::CellTypeMaxIndex);\n         task.shrink_to_fit(CachedDataItemType::CellDependency);\n         task.shrink_to_fit(CachedDataItemType::OutputDependency);\n@@ -2594,13 +2606,14 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         &self,\n         task_id: TaskId,\n         cell: CellId,\n-        _options: ReadCellOptions,\n+        options: ReadCellOptions,\n         turbo_tasks: &dyn TurboTasksBackendApi<TurboTasksBackend<B>>,\n     ) -> Result<TypedCellContent> {\n         let mut ctx = self.execute_context(turbo_tasks);\n         let task = ctx.task(task_id, TaskDataCategory::Data);\n-        if let Some(content) = get!(task, CellData { cell }) {\n-            Ok(CellContent(Some(content.reference.clone())).into_typed(cell.type_id))\n+        if let Some(content) = task.get_cell_data(options.is_serializable_cell_content, cell) {\n+            debug_assert!(content.type_id == cell.type_id, \"Cell type ID mismatch\");\n+            Ok(CellContent(Some(content.reference)).into_typed(cell.type_id))\n         } else {\n             Ok(CellContent(None).into_typed(cell.type_id))\n         }\n@@ -2741,6 +2754,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         &self,\n         task_id: TaskId,\n         cell: CellId,\n+        is_serializable_cell_content: bool,\n         content: CellContent,\n         verification_mode: VerificationMode,\n         turbo_tasks: &dyn TurboTasksBackendApi<TurboTasksBackend<B>>,\n@@ -2749,6 +2763,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             task_id,\n             cell,\n             content,\n+            is_serializable_cell_content,\n             verification_mode,\n             self.execute_context(turbo_tasks),\n         );\n@@ -3336,12 +3351,19 @@ impl<B: BackingStorage> Backend for TurboTasksBackend<B> {\n         &self,\n         task_id: TaskId,\n         cell: CellId,\n+        is_serializable_cell_content: bool,\n         content: CellContent,\n         verification_mode: VerificationMode,\n         turbo_tasks: &dyn TurboTasksBackendApi<Self>,\n     ) {\n-        self.0\n-            .update_task_cell(task_id, cell, content, verification_mode, turbo_tasks);\n+        self.0.update_task_cell(\n+            task_id,\n+            cell,\n+            is_serializable_cell_content,\n+            content,\n+            verification_mode,\n+            turbo_tasks,\n+        );\n     }\n \n     fn mark_own_task_as_finished("
        },
        {
            "sha": "32c0e45d3f75aa553f9d5cbeaf64b610f4d24631",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/mod.rs",
            "status": "modified",
            "additions": 33,
            "deletions": 2,
            "changes": 35,
            "blob_url": "https://github.com/vercel/next.js/blob/b3e51f8bfe6eb8be915ef43c78b3226362ff8c71/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b3e51f8bfe6eb8be915ef43c78b3226362ff8c71/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs?ref=b3e51f8bfe6eb8be915ef43c78b3226362ff8c71",
            "patch": "@@ -14,13 +14,15 @@ use std::{\n };\n \n use serde::{Deserialize, Serialize};\n-use turbo_tasks::{FxIndexMap, KeyValuePair, TaskId, TurboTasksBackendApi};\n+use turbo_tasks::{\n+    CellId, FxIndexMap, KeyValuePair, TaskId, TurboTasksBackendApi, TypedSharedReference,\n+};\n \n use crate::{\n     backend::{\n         OperationGuard, TaskDataCategory, TransientTask, TurboTasksBackend, TurboTasksBackendInner,\n         TurboTasksBackendJob,\n-        storage::{SpecificTaskDataCategory, StorageWriteGuard, get, iter_many},\n+        storage::{SpecificTaskDataCategory, StorageWriteGuard, get, iter_many, remove},\n     },\n     backing_storage::BackingStorage,\n     data::{\n@@ -467,6 +469,35 @@ pub trait TaskGuard: Debug {\n             .unwrap_or_default();\n         dirty_count > clean_count\n     }\n+    fn remove_cell_data(\n+        &mut self,\n+        is_serializable_cell_content: bool,\n+        cell: CellId,\n+    ) -> Option<TypedSharedReference> {\n+        if is_serializable_cell_content {\n+            remove!(self, CellData { cell })\n+        } else {\n+            remove!(self, TransientCellData { cell }).map(|sr| sr.into_typed(cell.type_id))\n+        }\n+    }\n+    fn get_cell_data(\n+        &self,\n+        is_serializable_cell_content: bool,\n+        cell: CellId,\n+    ) -> Option<TypedSharedReference> {\n+        if is_serializable_cell_content {\n+            get!(self, CellData { cell }).cloned()\n+        } else {\n+            get!(self, TransientCellData { cell }).map(|sr| sr.clone().into_typed(cell.type_id))\n+        }\n+    }\n+    fn has_cell_data(&self, is_serializable_cell_content: bool, cell: CellId) -> bool {\n+        if is_serializable_cell_content {\n+            self.has_key(&CachedDataItemKey::CellData { cell })\n+        } else {\n+            self.has_key(&CachedDataItemKey::TransientCellData { cell })\n+        }\n+    }\n }\n \n pub struct TaskGuardImpl<'a, B: BackingStorage> {"
        },
        {
            "sha": "3a5b50b80c148c7918a8ab1211430f5ecabc1fad",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/update_cell.rs",
            "status": "modified",
            "additions": 27,
            "deletions": 13,
            "changes": 40,
            "blob_url": "https://github.com/vercel/next.js/blob/b3e51f8bfe6eb8be915ef43c78b3226362ff8c71/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fupdate_cell.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b3e51f8bfe6eb8be915ef43c78b3226362ff8c71/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fupdate_cell.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fupdate_cell.rs?ref=b3e51f8bfe6eb8be915ef43c78b3226362ff8c71",
            "patch": "@@ -15,7 +15,7 @@ use crate::{\n             AggregationUpdateQueue, ExecuteContext, Operation, TaskGuard,\n             invalidate::make_task_dirty_internal,\n         },\n-        storage::{get, get_many, remove},\n+        storage::{get_many, remove},\n     },\n     data::{CachedDataItem, CachedDataItemKey, CellRef},\n };\n@@ -24,12 +24,14 @@ use crate::{\n #[allow(clippy::large_enum_variant)]\n pub enum UpdateCellOperation {\n     InvalidateWhenCellDependency {\n+        is_serializable_cell_content: bool,\n         cell_ref: CellRef,\n         dependent_tasks: SmallVec<[TaskId; 4]>,\n         content: Option<TypedSharedReference>,\n         queue: AggregationUpdateQueue,\n     },\n     FinalCellChange {\n+        is_serializable_cell_content: bool,\n         cell_ref: CellRef,\n         content: Option<TypedSharedReference>,\n         queue: AggregationUpdateQueue,\n@@ -46,6 +48,7 @@ impl UpdateCellOperation {\n         task_id: TaskId,\n         cell: CellId,\n         content: CellContent,\n+        is_serializable_cell_content: bool,\n         #[cfg(feature = \"verify_determinism\")] verification_mode: VerificationMode,\n         #[cfg(not(feature = \"verify_determinism\"))] _verification_mode: VerificationMode,\n         mut ctx: impl ExecuteContext,\n@@ -64,18 +67,17 @@ impl UpdateCellOperation {\n         let assume_unchanged =\n             !ctx.should_track_dependencies() || !task.has_key(&CachedDataItemKey::Dirty {});\n \n-        let old_content = get!(task, CellData { cell });\n-\n         if assume_unchanged {\n-            if old_content.is_some() {\n+            let has_old_content = task.has_cell_data(is_serializable_cell_content, cell);\n+            if has_old_content {\n                 // Never update cells when recomputing if they already have a value.\n                 // It's not expected that content changes during recomputation.\n \n                 // Check if this assumption holds.\n                 #[cfg(feature = \"verify_determinism\")]\n                 if !is_stateful\n                     && matches!(verification_mode, VerificationMode::EqualityCheck)\n-                    && content.as_ref() != old_content\n+                    && content != task.get_cell_data(is_serializable_cell_content, cell)\n                 {\n                     let task_description = ctx.get_task_description(task_id);\n                     let cell_type = turbo_tasks::registry::get_value_type(cell.type_id).global_name;\n@@ -115,12 +117,16 @@ impl UpdateCellOperation {\n                 // tasks and after that set the new cell content. When the cell content is unset,\n                 // readers will wait for it to be set via InProgressCell.\n \n-                let old_content = task.remove(&CachedDataItemKey::CellData { cell });\n+                let old_content = task.remove(&CachedDataItemKey::cell_data(\n+                    is_serializable_cell_content,\n+                    cell,\n+                ));\n \n                 drop(task);\n                 drop(old_content);\n \n                 UpdateCellOperation::InvalidateWhenCellDependency {\n+                    is_serializable_cell_content,\n                     cell_ref: CellRef {\n                         task: task_id,\n                         cell,\n@@ -138,12 +144,16 @@ impl UpdateCellOperation {\n         // So we can just update the cell content.\n \n         let old_content = if let Some(new_content) = content {\n-            task.insert(CachedDataItem::CellData {\n+            task.insert(CachedDataItem::cell_data(\n+                is_serializable_cell_content,\n                 cell,\n-                value: new_content,\n-            })\n+                new_content,\n+            ))\n         } else {\n-            task.remove(&CachedDataItemKey::CellData { cell })\n+            task.remove(&CachedDataItemKey::cell_data(\n+                is_serializable_cell_content,\n+                cell,\n+            ))\n         };\n \n         let in_progress_cell = remove!(task, InProgressCell { cell });\n@@ -163,6 +173,7 @@ impl Operation for UpdateCellOperation {\n             ctx.operation_suspend_point(&self);\n             match self {\n                 UpdateCellOperation::InvalidateWhenCellDependency {\n+                    is_serializable_cell_content,\n                     cell_ref,\n                     ref mut dependent_tasks,\n                     ref mut content,\n@@ -203,24 +214,27 @@ impl Operation for UpdateCellOperation {\n                     }\n                     if dependent_tasks.is_empty() {\n                         self = UpdateCellOperation::FinalCellChange {\n+                            is_serializable_cell_content,\n                             cell_ref,\n                             content: take(content),\n                             queue: take(queue),\n                         };\n                     }\n                 }\n                 UpdateCellOperation::FinalCellChange {\n+                    is_serializable_cell_content,\n                     cell_ref: CellRef { task, cell },\n                     content,\n                     ref mut queue,\n                 } => {\n                     let mut task = ctx.task(task, TaskDataCategory::Data);\n \n                     if let Some(content) = content {\n-                        task.add_new(CachedDataItem::CellData {\n+                        task.add_new(CachedDataItem::cell_data(\n+                            is_serializable_cell_content,\n                             cell,\n-                            value: content,\n-                        })\n+                            content,\n+                        ));\n                     }\n \n                     let in_progress_cell = remove!(task, InProgressCell { cell });"
        },
        {
            "sha": "b2c97a1079101767c1aa8be87e627c0e4b6f39a1",
            "filename": "turbopack/crates/turbo-tasks-backend/src/data.rs",
            "status": "modified",
            "additions": 35,
            "deletions": 6,
            "changes": 41,
            "blob_url": "https://github.com/vercel/next.js/blob/b3e51f8bfe6eb8be915ef43c78b3226362ff8c71/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdata.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b3e51f8bfe6eb8be915ef43c78b3226362ff8c71/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdata.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdata.rs?ref=b3e51f8bfe6eb8be915ef43c78b3226362ff8c71",
            "patch": "@@ -1,11 +1,10 @@\n use rustc_hash::FxHashSet;\n use serde::{Deserialize, Serialize};\n use turbo_tasks::{\n-    CellId, KeyValuePair, TaskExecutionReason, TaskId, TraitTypeId, TypedSharedReference,\n-    ValueTypeId,\n+    CellId, KeyValuePair, SharedReference, TaskExecutionReason, TaskId, TraitTypeId,\n+    TypedSharedReference, ValueTypeId,\n     backend::TurboTasksExecutionError,\n     event::{Event, EventListener},\n-    registry,\n };\n \n use crate::{\n@@ -244,6 +243,11 @@ pub enum CachedDataItem {\n         cell: CellId,\n         value: TypedSharedReference,\n     },\n+    #[serde(skip)]\n+    TransientCellData {\n+        cell: CellId,\n+        value: SharedReference,\n+    },\n     CellTypeMaxIndex {\n         cell_type: ValueTypeId,\n         value: u32,\n@@ -364,6 +368,21 @@ pub enum CachedDataItem {\n }\n \n impl CachedDataItem {\n+    pub fn cell_data(\n+        is_serializable_cell_content: bool,\n+        cell: CellId,\n+        value: TypedSharedReference,\n+    ) -> Self {\n+        if is_serializable_cell_content {\n+            CachedDataItem::CellData { cell, value }\n+        } else {\n+            CachedDataItem::TransientCellData {\n+                cell,\n+                value: value.into_untyped(),\n+            }\n+        }\n+    }\n+\n     pub fn is_persistent(&self) -> bool {\n         match self {\n             CachedDataItem::Output { value } => value.is_transient(),\n@@ -374,6 +393,7 @@ impl CachedDataItem {\n             CachedDataItem::CurrentSessionClean { .. } => false,\n             CachedDataItem::Child { task, .. } => !task.is_transient(),\n             CachedDataItem::CellData { .. } => true,\n+            CachedDataItem::TransientCellData { .. } => false,\n             CachedDataItem::CellTypeMaxIndex { .. } => true,\n             CachedDataItem::OutputDependency { target, .. } => !target.is_transient(),\n             CachedDataItem::CellDependency { target, .. } => !target.task.is_transient(),\n@@ -471,6 +491,7 @@ impl CachedDataItem {\n             | Self::OutdatedOutputDependency { .. }\n             | Self::OutdatedCellDependency { .. }\n             | Self::OutdatedCollectiblesDependency { .. }\n+            | Self::TransientCellData { .. }\n             | Self::CurrentSessionClean { .. }\n             | Self::AggregatedCurrentSessionCleanContainer { .. }\n             | Self::AggregatedCurrentSessionCleanContainerCount { .. }\n@@ -486,6 +507,14 @@ impl CachedDataItem {\n }\n \n impl CachedDataItemKey {\n+    pub fn cell_data(is_serializable_cell_content: bool, cell: CellId) -> Self {\n+        if is_serializable_cell_content {\n+            CachedDataItemKey::CellData { cell }\n+        } else {\n+            CachedDataItemKey::TransientCellData { cell }\n+        }\n+    }\n+\n     pub fn is_persistent(&self) -> bool {\n         match self {\n             CachedDataItemKey::Output { .. } => true,\n@@ -496,6 +525,7 @@ impl CachedDataItemKey {\n             CachedDataItemKey::CurrentSessionClean { .. } => false,\n             CachedDataItemKey::Child { task, .. } => !task.is_transient(),\n             CachedDataItemKey::CellData { .. } => true,\n+            CachedDataItemKey::TransientCellData { .. } => false,\n             CachedDataItemKey::CellTypeMaxIndex { .. } => true,\n             CachedDataItemKey::OutputDependency { target, .. } => !target.is_transient(),\n             CachedDataItemKey::CellDependency { target, .. } => !target.task.is_transient(),\n@@ -561,6 +591,7 @@ impl CachedDataItemType {\n             | Self::OutdatedOutputDependency { .. }\n             | Self::OutdatedCellDependency { .. }\n             | Self::OutdatedCollectiblesDependency { .. }\n+            | Self::TransientCellData { .. }\n             | Self::CurrentSessionClean { .. }\n             | Self::AggregatedCurrentSessionCleanContainer { .. }\n             | Self::AggregatedCurrentSessionCleanContainerCount { .. }\n@@ -600,6 +631,7 @@ impl CachedDataItemType {\n             | Self::CurrentSessionClean\n             | Self::AggregatedCurrentSessionCleanContainer\n             | Self::AggregatedCurrentSessionCleanContainerCount\n+            | Self::TransientCellData\n             | Self::OutdatedCollectible\n             | Self::OutdatedOutputDependency\n             | Self::OutdatedCellDependency\n@@ -621,9 +653,6 @@ impl CachedDataItemValueRef<'_> {\n     pub fn is_persistent(&self) -> bool {\n         match self {\n             CachedDataItemValueRef::Output { value } => !value.is_transient(),\n-            CachedDataItemValueRef::CellData { value } => {\n-                registry::get_value_type(value.type_id).is_serializable()\n-            }\n             _ => true,\n         }\n     }"
        },
        {
            "sha": "156d7cb686338842de2dc3c5fd98a5722769b19e",
            "filename": "turbopack/crates/turbo-tasks-macros/src/generic_type_macro.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/b3e51f8bfe6eb8be915ef43c78b3226362ff8c71/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fgeneric_type_macro.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b3e51f8bfe6eb8be915ef43c78b3226362ff8c71/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fgeneric_type_macro.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fgeneric_type_macro.rs?ref=b3e51f8bfe6eb8be915ef43c78b3226362ff8c71",
            "patch": "@@ -80,6 +80,7 @@ pub fn generic_type(input: TokenStream) -> TokenStream {\n         quote! {\n             turbo_tasks::ValueType::new_with_any_serialization::<#repr>(#name)\n         },\n+        quote! { true },\n     );\n \n     quote! {"
        },
        {
            "sha": "dbd0011e695cbf89172a6234d18100f8661439d4",
            "filename": "turbopack/crates/turbo-tasks-macros/src/primitive_macro.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/b3e51f8bfe6eb8be915ef43c78b3226362ff8c71/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fprimitive_macro.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b3e51f8bfe6eb8be915ef43c78b3226362ff8c71/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fprimitive_macro.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fprimitive_macro.rs?ref=b3e51f8bfe6eb8be915ef43c78b3226362ff8c71",
            "patch": "@@ -48,6 +48,7 @@ pub fn primitive(input: TokenStream) -> TokenStream {\n         quote! {\n             turbo_tasks::ValueType::new_with_any_serialization::<#ty>(#name)\n         },\n+        quote! { true },\n     );\n \n     let value_default_impl = quote! {"
        },
        {
            "sha": "b028ed309dbcab4e2cb17be8048b1c77c7fbe092",
            "filename": "turbopack/crates/turbo-tasks-macros/src/value_macro.rs",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/b3e51f8bfe6eb8be915ef43c78b3226362ff8c71/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_macro.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b3e51f8bfe6eb8be915ef43c78b3226362ff8c71/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_macro.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_macro.rs?ref=b3e51f8bfe6eb8be915ef43c78b3226362ff8c71",
            "patch": "@@ -349,6 +349,10 @@ pub fn value(args: TokenStream, input: TokenStream) -> TokenStream {\n             }\n         }\n     };\n+    let has_serialization = match serialization_mode {\n+        SerializationMode::None => quote! { false },\n+        SerializationMode::Auto | SerializationMode::Custom => quote! { true },\n+    };\n \n     let value_debug_impl = if inner_type.is_some() {\n         // For transparent values, we defer directly to the inner type's `ValueDebug`\n@@ -380,6 +384,7 @@ pub fn value(args: TokenStream, input: TokenStream) -> TokenStream {\n         read,\n         cell_mode,\n         new_value_type,\n+        has_serialization,\n     );\n \n     let expanded = quote! {\n@@ -405,6 +410,7 @@ pub fn value_type_and_register(\n     read: proc_macro2::TokenStream,\n     cell_mode: proc_macro2::TokenStream,\n     new_value_type: proc_macro2::TokenStream,\n+    has_serialization: proc_macro2::TokenStream,\n ) -> proc_macro2::TokenStream {\n     let value_type_ident = get_value_type_ident(ident);\n \n@@ -438,6 +444,10 @@ pub fn value_type_and_register(\n \n                 *ident\n             }\n+\n+            fn has_serialization() -> bool {\n+                #has_serialization\n+            }\n         }\n     }\n }"
        },
        {
            "sha": "2ce5d7b3791e96f757a74027b7988e2a47c84005",
            "filename": "turbopack/crates/turbo-tasks-testing/src/lib.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/b3e51f8bfe6eb8be915ef43c78b3226362ff8c71/turbopack%2Fcrates%2Fturbo-tasks-testing%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b3e51f8bfe6eb8be915ef43c78b3226362ff8c71/turbopack%2Fcrates%2Fturbo-tasks-testing%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-testing%2Fsrc%2Flib.rs?ref=b3e51f8bfe6eb8be915ef43c78b3226362ff8c71",
            "patch": "@@ -265,6 +265,7 @@ impl TurboTasksApi for VcStorage {\n         &self,\n         task: TaskId,\n         index: CellId,\n+        _is_serializable_cell_content: bool,\n         content: CellContent,\n         _verification_mode: VerificationMode,\n     ) {"
        },
        {
            "sha": "2113ea7c89e390672f08ac10a4bdad0a5797b3ff",
            "filename": "turbopack/crates/turbo-tasks/src/backend.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/b3e51f8bfe6eb8be915ef43c78b3226362ff8c71/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fbackend.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b3e51f8bfe6eb8be915ef43c78b3226362ff8c71/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fbackend.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fbackend.rs?ref=b3e51f8bfe6eb8be915ef43c78b3226362ff8c71",
            "patch": "@@ -634,6 +634,7 @@ pub trait Backend: Sync + Send {\n         &self,\n         task: TaskId,\n         index: CellId,\n+        is_serializable_cell_content: bool,\n         content: CellContent,\n         verification_mode: VerificationMode,\n         turbo_tasks: &dyn TurboTasksBackendApi<Self>,"
        },
        {
            "sha": "6987608d30603ecff5ba79203ffe9881b9b2d95b",
            "filename": "turbopack/crates/turbo-tasks/src/macro_helpers.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/b3e51f8bfe6eb8be915ef43c78b3226362ff8c71/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmacro_helpers.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b3e51f8bfe6eb8be915ef43c78b3226362ff8c71/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmacro_helpers.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmacro_helpers.rs?ref=b3e51f8bfe6eb8be915ef43c78b3226362ff8c71",
            "patch": "@@ -14,7 +14,7 @@ use crate::{\n pub use crate::{\n     global_name, inventory_submit,\n     magic_any::MagicAny,\n-    manager::{find_cell_by_type, spawn_detached_for_testing},\n+    manager::{find_cell_by_id, find_cell_by_type, spawn_detached_for_testing},\n     native_function::{\n         CollectableFunction, NativeFunction, downcast_args_owned, downcast_args_ref,\n     },"
        },
        {
            "sha": "270b97a53466eb65351d19a262327841618fbc5d",
            "filename": "turbopack/crates/turbo-tasks/src/manager.rs",
            "status": "modified",
            "additions": 24,
            "deletions": 5,
            "changes": 29,
            "blob_url": "https://github.com/vercel/next.js/blob/b3e51f8bfe6eb8be915ef43c78b3226362ff8c71/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b3e51f8bfe6eb8be915ef43c78b3226362ff8c71/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs?ref=b3e51f8bfe6eb8be915ef43c78b3226362ff8c71",
            "patch": "@@ -159,6 +159,7 @@ pub trait TurboTasksApi: TurboTasksCallApi + Sync + Send {\n         &self,\n         task: TaskId,\n         index: CellId,\n+        is_serializable_cell_content: bool,\n         content: CellContent,\n         verification_mode: VerificationMode,\n     );\n@@ -1355,11 +1356,18 @@ impl<B: Backend + 'static> TurboTasksApi for TurboTasks<B> {\n         &self,\n         task: TaskId,\n         index: CellId,\n+        is_serializable_cell_content: bool,\n         content: CellContent,\n         verification_mode: VerificationMode,\n     ) {\n-        self.backend\n-            .update_task_cell(task, index, content, verification_mode, self);\n+        self.backend.update_task_cell(\n+            task,\n+            index,\n+            is_serializable_cell_content,\n+            content,\n+            verification_mode,\n+            self,\n+        );\n     }\n \n     fn connect_task(&self, task: TaskId) {\n@@ -1733,6 +1741,7 @@ pub(crate) async fn read_task_cell(\n pub struct CurrentCellRef {\n     current_task: TaskId,\n     index: CellId,\n+    is_serializable_cell_content: bool,\n }\n \n type VcReadRepr<T> = <<T as VcValueType>::Read as VcRead<T>>::Repr;\n@@ -1767,7 +1776,8 @@ impl CurrentCellRef {\n                 ReadCellOptions {\n                     // INVALIDATION: Reading our own cell must be untracked\n                     tracking: ReadTracking::Untracked,\n-                    ..Default::default()\n+                    is_serializable_cell_content: self.is_serializable_cell_content,\n+                    final_read_hint: false,\n                 },\n             )\n             .ok();\n@@ -1776,6 +1786,7 @@ impl CurrentCellRef {\n             tt.update_own_task_cell(\n                 self.current_task,\n                 self.index,\n+                self.is_serializable_cell_content,\n                 CellContent(Some(update)),\n                 VerificationMode::EqualityCheck,\n             )\n@@ -1868,6 +1879,7 @@ impl CurrentCellRef {\n         tt.update_own_task_cell(\n             self.current_task,\n             self.index,\n+            self.is_serializable_cell_content,\n             CellContent(Some(SharedReference::new(triomphe::Arc::new(\n                 <T::Read as VcRead<T>>::value_to_repr(new_value),\n             )))),\n@@ -1897,7 +1909,8 @@ impl CurrentCellRef {\n                     ReadCellOptions {\n                         // INVALIDATION: Reading our own cell must be untracked\n                         tracking: ReadTracking::Untracked,\n-                        ..Default::default()\n+                        is_serializable_cell_content: self.is_serializable_cell_content,\n+                        final_read_hint: false,\n                     },\n                 )\n                 .ok();\n@@ -1914,6 +1927,7 @@ impl CurrentCellRef {\n             tt.update_own_task_cell(\n                 self.current_task,\n                 self.index,\n+                self.is_serializable_cell_content,\n                 CellContent(Some(shared_ref)),\n                 verification_mode,\n             )\n@@ -1927,7 +1941,11 @@ impl From<CurrentCellRef> for RawVc {\n     }\n }\n \n-pub fn find_cell_by_type(ty: ValueTypeId) -> CurrentCellRef {\n+pub fn find_cell_by_type<T: VcValueType>() -> CurrentCellRef {\n+    find_cell_by_id(T::get_value_type_id(), T::has_serialization())\n+}\n+\n+pub fn find_cell_by_id(ty: ValueTypeId, is_serializable_cell_content: bool) -> CurrentCellRef {\n     CURRENT_TASK_STATE.with(|ts| {\n         let current_task = current_task(\"celling turbo_tasks values\");\n         let mut ts = ts.write().unwrap();\n@@ -1938,6 +1956,7 @@ pub fn find_cell_by_type(ty: ValueTypeId) -> CurrentCellRef {\n         CurrentCellRef {\n             current_task,\n             index: CellId { type_id: ty, index },\n+            is_serializable_cell_content,\n         }\n     })\n }"
        },
        {
            "sha": "72b440c55190588b8b56e46173653a536fbf535c",
            "filename": "turbopack/crates/turbo-tasks/src/raw_vc.rs",
            "status": "modified",
            "additions": 40,
            "deletions": 13,
            "changes": 53,
            "blob_url": "https://github.com/vercel/next.js/blob/b3e51f8bfe6eb8be915ef43c78b3226362ff8c71/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fraw_vc.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b3e51f8bfe6eb8be915ef43c78b3226362ff8c71/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fraw_vc.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fraw_vc.rs?ref=b3e51f8bfe6eb8be915ef43c78b3226362ff8c71",
            "patch": "@@ -147,10 +147,16 @@ impl RawVc {\n         }\n     }\n \n-    pub(crate) fn into_read(self) -> ReadRawVcFuture {\n+    pub(crate) fn into_read(self, is_serializable_cell_content: bool) -> ReadRawVcFuture {\n         // returns a custom future to have something concrete and sized\n         // this avoids boxing in IntoFuture\n-        ReadRawVcFuture::new(self)\n+        ReadRawVcFuture::new(self, Some(is_serializable_cell_content))\n+    }\n+\n+    pub(crate) fn into_read_with_unknown_is_serializable_cell_content(self) -> ReadRawVcFuture {\n+        // returns a custom future to have something concrete and sized\n+        // this avoids boxing in IntoFuture\n+        ReadRawVcFuture::new(self, None)\n     }\n \n     pub(crate) async fn resolve_trait(\n@@ -193,15 +199,26 @@ impl RawVc {\n                         .map_err(|source| ResolveTypeError::TaskError { source })?;\n                 }\n                 RawVc::TaskCell(task, index) => {\n-                    let content = read_task_cell(&*tt, task, index, ReadCellOptions::default())\n-                        .await\n-                        .map_err(|source| ResolveTypeError::ReadError { source })?;\n-                    if let TypedCellContent(value_type, CellContent(Some(_))) = content {\n-                        return Ok(if conditional(value_type).0 {\n-                            Some(RawVc::TaskCell(task, index))\n-                        } else {\n-                            None\n-                        });\n+                    let (ok, value_type) = conditional(index.type_id);\n+                    if !ok {\n+                        return Ok(None);\n+                    }\n+                    let value_type =\n+                        value_type.unwrap_or_else(|| registry::get_value_type(index.type_id));\n+                    let content = read_task_cell(\n+                        &*tt,\n+                        task,\n+                        index,\n+                        ReadCellOptions {\n+                            is_serializable_cell_content: value_type.is_serializable(),\n+                            final_read_hint: false,\n+                            tracking: ReadTracking::default(),\n+                        },\n+                    )\n+                    .await\n+                    .map_err(|source| ResolveTypeError::ReadError { source })?;\n+                    if let TypedCellContent(_, CellContent(Some(_))) = content {\n+                        return Ok(Some(RawVc::TaskCell(task, index)));\n                     } else {\n                         return Err(ResolveTypeError::NoContent);\n                     }\n@@ -362,15 +379,20 @@ pub struct ReadRawVcFuture {\n     current: RawVc,\n     read_output_options: ReadOutputOptions,\n     read_cell_options: ReadCellOptions,\n+    is_serializable_cell_content_unknown: bool,\n     listener: Option<EventListener>,\n }\n \n impl ReadRawVcFuture {\n-    pub(crate) fn new(vc: RawVc) -> Self {\n+    pub(crate) fn new(vc: RawVc, is_serializable_cell_content: Option<bool>) -> Self {\n         ReadRawVcFuture {\n             current: vc,\n             read_output_options: ReadOutputOptions::default(),\n-            read_cell_options: ReadCellOptions::default(),\n+            read_cell_options: ReadCellOptions {\n+                is_serializable_cell_content: is_serializable_cell_content.unwrap_or(false),\n+                ..Default::default()\n+            },\n+            is_serializable_cell_content_unknown: is_serializable_cell_content.is_none(),\n             listener: None,\n         }\n     }\n@@ -441,6 +463,11 @@ impl Future for ReadRawVcFuture {\n                         }\n                     }\n                     RawVc::TaskCell(task, index) => {\n+                        if this.is_serializable_cell_content_unknown {\n+                            let value_type = registry::get_value_type(index.type_id);\n+                            this.read_cell_options.is_serializable_cell_content =\n+                                value_type.is_serializable();\n+                        }\n                         let read_result =\n                             tt.try_read_task_cell(task, index, this.read_cell_options);\n                         match read_result {"
        },
        {
            "sha": "49364688c956924de06f3cadf72e74fc41a67bb1",
            "filename": "turbopack/crates/turbo-tasks/src/read_options.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/b3e51f8bfe6eb8be915ef43c78b3226362ff8c71/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fread_options.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b3e51f8bfe6eb8be915ef43c78b3226362ff8c71/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fread_options.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fread_options.rs?ref=b3e51f8bfe6eb8be915ef43c78b3226362ff8c71",
            "patch": "@@ -3,6 +3,7 @@ use crate::{ReadConsistency, ReadTracking};\n #[derive(Clone, Copy, Debug, Default)]\n pub struct ReadCellOptions {\n     pub tracking: ReadTracking,\n+    pub is_serializable_cell_content: bool,\n     pub final_read_hint: bool,\n }\n "
        },
        {
            "sha": "d79f0ae8ad193b7ac76f5d421463c935531693a2",
            "filename": "turbopack/crates/turbo-tasks/src/task/function.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/b3e51f8bfe6eb8be915ef43c78b3226362ff8c71/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask%2Ffunction.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b3e51f8bfe6eb8be915ef43c78b3226362ff8c71/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask%2Ffunction.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask%2Ffunction.rs?ref=b3e51f8bfe6eb8be915ef43c78b3226362ff8c71",
            "patch": "@@ -416,6 +416,10 @@ mod tests {\n             fn get_value_type_id() -> crate::ValueTypeId {\n                 todo!()\n             }\n+\n+            fn has_serialization() -> bool {\n+                false\n+            }\n         }\n \n         trait AsyncTrait {"
        },
        {
            "sha": "6180a31e1563dc8c6bcb7b0d05e17f2e0b02fad8",
            "filename": "turbopack/crates/turbo-tasks/src/task/local_task.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 8,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/b3e51f8bfe6eb8be915ef43c78b3226362ff8c71/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask%2Flocal_task.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b3e51f8bfe6eb8be915ef43c78b3226362ff8c71/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask%2Flocal_task.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask%2Flocal_task.rs?ref=b3e51f8bfe6eb8be915ef43c78b3226362ff8c71",
            "patch": "@@ -3,12 +3,8 @@ use std::{fmt, sync::Arc};\n use anyhow::{Result, anyhow};\n \n use crate::{\n-    MagicAny, OutputContent, RawVc, TaskPersistence, TraitMethod, TurboTasksBackendApi,\n-    ValueTypeId,\n-    backend::{Backend, TypedCellContent},\n-    event::Event,\n-    macro_helpers::NativeFunction,\n-    registry,\n+    CellId, MagicAny, OutputContent, RawVc, TaskPersistence, TraitMethod, TurboTasksBackendApi,\n+    ValueTypeId, backend::Backend, event::Event, macro_helpers::NativeFunction, registry,\n };\n \n /// A potentially in-flight local task stored in `CurrentGlobalTaskState::local_tasks`.\n@@ -75,9 +71,11 @@ impl LocalTaskType {\n         turbo_tasks: Arc<dyn TurboTasksBackendApi<B>>,\n     ) -> Result<RawVc> {\n         let this = this.resolve().await?;\n-        let TypedCellContent(this_ty, _) = this.into_read().await?;\n+        let RawVc::TaskCell(_, CellId { type_id, .. }) = this else {\n+            return Err(anyhow!(\"Trait method receiver must be a cell\"));\n+        };\n \n-        let native_fn = Self::resolve_trait_method_from_value(trait_method, this_ty)?;\n+        let native_fn = Self::resolve_trait_method_from_value(trait_method, type_id)?;\n         let arg = native_fn.arg_meta.filter_and_resolve(arg).await?;\n         Ok(turbo_tasks.native_call(native_fn, Some(this), arg, persistence))\n     }"
        },
        {
            "sha": "e583a2a4fb4f8cb65a8611431d26cd7950a54e2f",
            "filename": "turbopack/crates/turbo-tasks/src/trait_ref.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/b3e51f8bfe6eb8be915ef43c78b3226362ff8c71/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftrait_ref.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b3e51f8bfe6eb8be915ef43c78b3226362ff8c71/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftrait_ref.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftrait_ref.rs?ref=b3e51f8bfe6eb8be915ef43c78b3226362ff8c71",
            "patch": "@@ -157,6 +157,8 @@ where\n     type Future = ReadVcFuture<T, VcValueTraitCast<T>>;\n \n     fn into_trait_ref(self) -> Self::Future {\n-        self.node.into_read().into()\n+        self.node\n+            .into_read_with_unknown_is_serializable_cell_content()\n+            .into()\n     }\n }"
        },
        {
            "sha": "cbcc030861044c47881fd9a5aec6d84338142a33",
            "filename": "turbopack/crates/turbo-tasks/src/vc/cell_mode.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/b3e51f8bfe6eb8be915ef43c78b3226362ff8c71/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fvc%2Fcell_mode.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b3e51f8bfe6eb8be915ef43c78b3226362ff8c71/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fvc%2Fcell_mode.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fvc%2Fcell_mode.rs?ref=b3e51f8bfe6eb8be915ef43c78b3226362ff8c71",
            "patch": "@@ -39,7 +39,7 @@ where\n     T: VcValueType,\n {\n     fn cell(inner: VcReadTarget<T>) -> Vc<T> {\n-        let cell = find_cell_by_type(T::get_value_type_id());\n+        let cell = find_cell_by_type::<T>();\n         cell.update(\n             <T::Read as VcRead<T>>::target_to_value(inner),\n             VerificationMode::Skip,\n@@ -52,7 +52,7 @@ where\n \n     fn raw_cell(content: TypedSharedReference) -> RawVc {\n         debug_assert_repr::<T>(&content);\n-        let cell = find_cell_by_type(content.type_id);\n+        let cell = find_cell_by_type::<T>();\n         cell.update_with_shared_reference(content.reference, VerificationMode::Skip);\n         cell.into()\n     }\n@@ -69,7 +69,7 @@ where\n     T: VcValueType + PartialEq,\n {\n     fn cell(inner: VcReadTarget<T>) -> Vc<T> {\n-        let cell = find_cell_by_type(T::get_value_type_id());\n+        let cell = find_cell_by_type::<T>();\n         cell.compare_and_update(<T::Read as VcRead<T>>::target_to_value(inner));\n         Vc {\n             node: cell.into(),\n@@ -79,7 +79,7 @@ where\n \n     fn raw_cell(content: TypedSharedReference) -> RawVc {\n         debug_assert_repr::<T>(&content);\n-        let cell = find_cell_by_type(content.type_id);\n+        let cell = find_cell_by_type::<T>();\n         cell.compare_and_update_with_shared_reference::<T>(content.reference);\n         cell.into()\n     }"
        },
        {
            "sha": "81884a0827f9a8dfabee0c0232e7130664612cfb",
            "filename": "turbopack/crates/turbo-tasks/src/vc/mod.rs",
            "status": "modified",
            "additions": 14,
            "deletions": 5,
            "changes": 19,
            "blob_url": "https://github.com/vercel/next.js/blob/b3e51f8bfe6eb8be915ef43c78b3226362ff8c71/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fvc%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b3e51f8bfe6eb8be915ef43c78b3226362ff8c71/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fvc%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fvc%2Fmod.rs?ref=b3e51f8bfe6eb8be915ef43c78b3226362ff8c71",
            "patch": "@@ -611,7 +611,7 @@ macro_rules! into_future {\n             type Output = <ReadVcFuture<T> as Future>::Output;\n             type IntoFuture = ReadVcFuture<T>;\n             fn into_future(self) -> Self::IntoFuture {\n-                self.node.into_read().into()\n+                self.node.into_read(T::has_serialization()).into()\n             }\n         }\n     };\n@@ -629,21 +629,30 @@ where\n     #[cfg(feature = \"non_operation_vc_strongly_consistent\")]\n     #[must_use]\n     pub fn strongly_consistent(self) -> ReadVcFuture<T> {\n-        self.node.into_read().strongly_consistent().into()\n+        self.node\n+            .into_read(T::has_serialization())\n+            .strongly_consistent()\n+            .into()\n     }\n \n     /// Returns a untracked read of the value. This will not invalidate the current function when\n     /// the read value changed.\n     #[must_use]\n     pub fn untracked(self) -> ReadVcFuture<T> {\n-        self.node.into_read().untracked().into()\n+        self.node\n+            .into_read(T::has_serialization())\n+            .untracked()\n+            .into()\n     }\n \n     /// Read the value with the hint that this is the final read of the value. This might drop the\n     /// cell content. Future reads might need to recompute the value.\n     #[must_use]\n     pub fn final_read_hint(self) -> ReadVcFuture<T> {\n-        self.node.into_read().final_read_hint().into()\n+        self.node\n+            .into_read(T::has_serialization())\n+            .final_read_hint()\n+            .into()\n     }\n }\n \n@@ -654,7 +663,7 @@ where\n {\n     /// Read the value and returns a owned version of it. It might clone the value.\n     pub fn owned(self) -> ReadOwnedVcFuture<T> {\n-        let future: ReadVcFuture<T> = self.node.into_read().into();\n+        let future: ReadVcFuture<T> = self.node.into_read(T::has_serialization()).into();\n         future.owned()\n     }\n }"
        },
        {
            "sha": "fbaacffa173bd51d1b5a912abb679fc9f83f8dfa",
            "filename": "turbopack/crates/turbo-tasks/src/vc/operation.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/b3e51f8bfe6eb8be915ef43c78b3226362ff8c71/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fvc%2Foperation.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b3e51f8bfe6eb8be915ef43c78b3226362ff8c71/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fvc%2Foperation.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fvc%2Foperation.rs?ref=b3e51f8bfe6eb8be915ef43c78b3226362ff8c71",
            "patch": "@@ -130,7 +130,11 @@ impl<T: ?Sized> OperationVc<T> {\n     where\n         T: VcValueType,\n     {\n-        self.connect().node.into_read().strongly_consistent().into()\n+        self.connect()\n+            .node\n+            .into_read(T::has_serialization())\n+            .strongly_consistent()\n+            .into()\n     }\n }\n "
        },
        {
            "sha": "c4c5cdd95b92c9bc95ae2bd04e17a1c16f2f177a",
            "filename": "turbopack/crates/turbo-tasks/src/vc/traits.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/b3e51f8bfe6eb8be915ef43c78b3226362ff8c71/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fvc%2Ftraits.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b3e51f8bfe6eb8be915ef43c78b3226362ff8c71/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fvc%2Ftraits.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fvc%2Ftraits.rs?ref=b3e51f8bfe6eb8be915ef43c78b3226362ff8c71",
            "patch": "@@ -22,6 +22,8 @@ pub unsafe trait VcValueType: ShrinkToFit + Sized + Send + Sync + 'static {\n \n     /// Returns the type id of the value type.\n     fn get_value_type_id() -> ValueTypeId;\n+\n+    fn has_serialization() -> bool;\n }\n \n /// A trait implemented on all values trait object references that can be put"
        }
    ],
    "stats": {
        "total": 324,
        "additions": 250,
        "deletions": 74
    }
}