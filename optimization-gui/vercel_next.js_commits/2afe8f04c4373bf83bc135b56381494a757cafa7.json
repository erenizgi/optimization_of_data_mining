{
    "author": "lubieowoce",
    "message": "[Segment Cache] set fetchStrategy on segments from a dynamic request (#82059)\n\nFor non-PPR routes and full prefetches, we fetch multiple segments with one dynamic request. Then, we deconstruct the response into segments and create segment cache entries for them. However, when doing this, we weren't correctly setting the fetch strategy for these cache entries, leaving it at the default (`PPR`).\n\nThe most correct way to model this is to simulate the flow that a normal segment prefetch would go through -- we create an empty segment, upgrade it to a pending one (which requires setting `fetchStrategy`) and finally fulfill it.\n\nI've adjusted `fulfillSegmentCacheEntry` to only accept pending segments so that it's not possible to have a fulfilled segment whose fetch strategy wasn't set, like we were doing before.",
    "sha": "2afe8f04c4373bf83bc135b56381494a757cafa7",
    "files": [
        {
            "sha": "1649b34cecf46f9519f7a7f9a1b8771f6301ac89",
            "filename": "packages/next/src/client/components/segment-cache-impl/cache.ts",
            "status": "modified",
            "additions": 23,
            "deletions": 4,
            "changes": 27,
            "blob_url": "https://github.com/vercel/next.js/blob/2afe8f04c4373bf83bc135b56381494a757cafa7/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/2afe8f04c4373bf83bc135b56381494a757cafa7/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts?ref=2afe8f04c4373bf83bc135b56381494a757cafa7",
            "patch": "@@ -805,7 +805,7 @@ function fulfillRouteCacheEntry(\n }\n \n function fulfillSegmentCacheEntry(\n-  segmentCacheEntry: EmptySegmentCacheEntry | PendingSegmentCacheEntry,\n+  segmentCacheEntry: PendingSegmentCacheEntry,\n   rsc: React.ReactNode,\n   loading: LoadingModuleData | Promise<LoadingModuleData>,\n   staleAt: number,\n@@ -1186,6 +1186,9 @@ export async function fetchRouteOnCacheMiss(\n       writeDynamicTreeResponseIntoCache(\n         Date.now(),\n         task,\n+        // The non-PPR response format is what we'd get if we prefetched these segments\n+        // using the LoadingBoundary fetch strategy, so mark their cache entries accordingly.\n+        FetchStrategy.LoadingBoundary,\n         response,\n         serverData,\n         entry,\n@@ -1347,7 +1350,7 @@ export async function fetchSegmentOnCacheMiss(\n export async function fetchSegmentPrefetchesUsingDynamicRequest(\n   task: PrefetchTask,\n   route: FulfilledRouteCacheEntry,\n-  fetchStrategy: FetchStrategy,\n+  fetchStrategy: FetchStrategy.LoadingBoundary | FetchStrategy.Full,\n   dynamicRequestTree: FlightRouterState,\n   spawnedEntries: Map<string, PendingSegmentCacheEntry>\n ): Promise<PrefetchSubtaskResult<null> | null> {\n@@ -1427,6 +1430,7 @@ export async function fetchSegmentPrefetchesUsingDynamicRequest(\n     fulfilledEntries = writeDynamicRenderResponseIntoCache(\n       Date.now(),\n       task,\n+      fetchStrategy,\n       response,\n       serverData,\n       isResponsePartial,\n@@ -1446,6 +1450,7 @@ export async function fetchSegmentPrefetchesUsingDynamicRequest(\n function writeDynamicTreeResponseIntoCache(\n   now: number,\n   task: PrefetchTask,\n+  fetchStrategy: FetchStrategy.LoadingBoundary | FetchStrategy.Full,\n   response: RSCResponse,\n   serverData: NavigationFlightResponse,\n   entry: PendingRouteCacheEntry,\n@@ -1516,6 +1521,7 @@ function writeDynamicTreeResponseIntoCache(\n   writeDynamicRenderResponseIntoCache(\n     now,\n     task,\n+    fetchStrategy,\n     response,\n     serverData,\n     isResponsePartial,\n@@ -1542,6 +1548,7 @@ function rejectSegmentEntriesIfStillPending(\n function writeDynamicRenderResponseIntoCache(\n   now: number,\n   task: PrefetchTask,\n+  fetchStrategy: FetchStrategy.LoadingBoundary | FetchStrategy.Full,\n   response: RSCResponse,\n   serverData: NavigationFlightResponse,\n   isResponsePartial: boolean,\n@@ -1600,6 +1607,7 @@ function writeDynamicRenderResponseIntoCache(\n       writeSeedDataIntoCache(\n         now,\n         task,\n+        fetchStrategy,\n         route,\n         staleAt,\n         seedData,\n@@ -1648,6 +1656,7 @@ function writeDynamicRenderResponseIntoCache(\n function writeSeedDataIntoCache(\n   now: number,\n   task: PrefetchTask,\n+  fetchStrategy: FetchStrategy.LoadingBoundary | FetchStrategy.Full,\n   route: FulfilledRouteCacheEntry,\n   staleAt: number,\n   seedData: CacheNodeSeedData,\n@@ -1684,12 +1693,21 @@ function writeSeedDataIntoCache(\n     if (possiblyNewEntry.status === EntryStatus.Empty) {\n       // Confirmed this is a new entry. We can fulfill it.\n       const newEntry = possiblyNewEntry\n-      fulfillSegmentCacheEntry(newEntry, rsc, loading, staleAt, isPartial)\n+      fulfillSegmentCacheEntry(\n+        upgradeToPendingSegment(newEntry, fetchStrategy),\n+        rsc,\n+        loading,\n+        staleAt,\n+        isPartial\n+      )\n     } else {\n       // There was already an entry in the cache. But we may be able to\n       // replace it with the new one from the server.\n       const newEntry = fulfillSegmentCacheEntry(\n-        createDetachedSegmentCacheEntry(staleAt),\n+        upgradeToPendingSegment(\n+          createDetachedSegmentCacheEntry(staleAt),\n+          fetchStrategy\n+        ),\n         rsc,\n         loading,\n         staleAt,\n@@ -1712,6 +1730,7 @@ function writeSeedDataIntoCache(\n         writeSeedDataIntoCache(\n           now,\n           task,\n+          fetchStrategy,\n           route,\n           staleAt,\n           childSeedData,"
        }
    ],
    "stats": {
        "total": 27,
        "additions": 23,
        "deletions": 4
    }
}