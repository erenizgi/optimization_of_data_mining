{
    "author": "mischnic",
    "message": "Reapply \"Turbopack: layout segment optimization for Pages\" (#77339) (#77696)\n\nA clean revert of the revert #77339 of #74815\r\n\r\nCloses PACK-3715",
    "sha": "48725b22c742430bf83a554ab9095d9ffebee32b",
    "files": [
        {
            "sha": "3a845431e95322a0ded1766900cc908b4054435e",
            "filename": "crates/next-api/src/pages.rs",
            "status": "modified",
            "additions": 144,
            "deletions": 45,
            "changes": 189,
            "blob_url": "https://github.com/vercel/next.js/blob/48725b22c742430bf83a554ab9095d9ffebee32b/crates%2Fnext-api%2Fsrc%2Fpages.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/48725b22c742430bf83a554ab9095d9ffebee32b/crates%2Fnext-api%2Fsrc%2Fpages.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fpages.rs?ref=48725b22c742430bf83a554ab9095d9ffebee32b",
            "patch": "@@ -31,7 +31,7 @@ use tracing::Instrument;\n use turbo_rcstr::RcStr;\n use turbo_tasks::{\n     fxindexmap, trace::TraceRawVcs, Completion, FxIndexMap, NonLocalValue, ResolvedVc, TaskInput,\n-    Value, Vc,\n+    Value, ValueToString, Vc,\n };\n use turbo_tasks_fs::{\n     self, File, FileContent, FileSystem, FileSystemPath, FileSystemPathOption, VirtualFileSystem,\n@@ -46,15 +46,15 @@ use turbopack_core::{\n     asset::AssetContent,\n     chunk::{\n         availability_info::AvailabilityInfo, ChunkGroupResult, ChunkingContext, ChunkingContextExt,\n-        EntryChunkGroupResult, EvaluatableAsset, EvaluatableAssets,\n+        EvaluatableAsset, EvaluatableAssets,\n     },\n     context::AssetContext,\n     file_source::FileSource,\n     ident::AssetIdent,\n     module::Module,\n     module_graph::{\n         chunk_group_info::{ChunkGroup, ChunkGroupEntry},\n-        GraphEntries, ModuleGraph,\n+        GraphEntries, ModuleGraph, SingleModuleGraph, VisitedModules,\n     },\n     output::{OptionOutputAsset, OutputAsset, OutputAssets},\n     reference_type::{EcmaScriptModulesReferenceSubType, EntryReferenceSubType, ReferenceType},\n@@ -772,7 +772,45 @@ impl PageEndpoint {\n         let this = self.await?;\n         let project = this.pages_project.project();\n         let evaluatable_assets = self.client_evaluatable_assets();\n-        Ok(project.module_graph_for_entries(evaluatable_assets))\n+        Ok(project.module_graph_for_modules(evaluatable_assets))\n+    }\n+\n+    #[turbo_tasks::function]\n+    async fn ssr_module_graph(self: Vc<Self>) -> Result<Vc<ModuleGraph>> {\n+        let this = self.await?;\n+        let project = this.pages_project.project();\n+\n+        if *project.per_page_module_graph().await? {\n+            let ssr_chunk_module = self.internal_ssr_chunk_module().await?;\n+            // Implements layout segment optimization to compute a graph \"chain\" for document, app,\n+            // page\n+            let mut graphs = vec![];\n+            let mut visited_modules = VisitedModules::empty();\n+            for module in [\n+                ssr_chunk_module.document_module,\n+                ssr_chunk_module.app_module,\n+            ]\n+            .into_iter()\n+            .flatten()\n+            {\n+                let graph = SingleModuleGraph::new_with_entries_visited_intern(\n+                    vec![ChunkGroupEntry::Shared(module)],\n+                    visited_modules,\n+                );\n+                graphs.push(graph);\n+                visited_modules = visited_modules.concatenate(graph);\n+            }\n+\n+            let graph = SingleModuleGraph::new_with_entries_visited_intern(\n+                vec![ChunkGroupEntry::Entry(vec![ssr_chunk_module.ssr_module])],\n+                visited_modules,\n+            );\n+            graphs.push(graph);\n+\n+            Ok(ModuleGraph::from_graphs(graphs))\n+        } else {\n+            Ok(*project.whole_app_module_graphs().await?.full)\n+        }\n     }\n \n     #[turbo_tasks::function]\n@@ -852,10 +890,8 @@ impl PageEndpoint {\n             .module();\n \n         let config = parse_config_from_source(ssr_module, NextRuntime::default()).await?;\n-        let is_edge = matches!(config.runtime, NextRuntime::Edge);\n-\n-        let ssr_module = if is_edge {\n-            create_page_ssr_entry_module(\n+        Ok(if config.runtime == NextRuntime::Edge {\n+            let modules = create_page_ssr_entry_module(\n                 *this.pathname,\n                 reference_type,\n                 project_root,\n@@ -866,15 +902,28 @@ impl PageEndpoint {\n                 config.runtime,\n                 this.pages_project.project().next_config(),\n             )\n+            .await?;\n+\n+            InternalSsrChunkModule {\n+                ssr_module: modules.ssr_module,\n+                app_module: modules.app_module,\n+                document_module: modules.document_module,\n+                runtime: config.runtime,\n+            }\n         } else {\n             let pathname = &**this.pathname.await?;\n \n             // `/_app` and `/_document` never get rendered directly so they don't need to be\n             // wrapped in the route module.\n             if pathname == \"/_app\" || pathname == \"/_document\" {\n-                ssr_module\n+                InternalSsrChunkModule {\n+                    ssr_module: ssr_module.to_resolved().await?,\n+                    app_module: None,\n+                    document_module: None,\n+                    runtime: config.runtime,\n+                }\n             } else {\n-                create_page_ssr_entry_module(\n+                let modules = create_page_ssr_entry_module(\n                     *this.pathname,\n                     reference_type,\n                     project_root,\n@@ -885,12 +934,14 @@ impl PageEndpoint {\n                     config.runtime,\n                     this.pages_project.project().next_config(),\n                 )\n+                .await?;\n+                InternalSsrChunkModule {\n+                    ssr_module: modules.ssr_module,\n+                    app_module: modules.app_module,\n+                    document_module: modules.document_module,\n+                    runtime: config.runtime,\n+                }\n             }\n-        };\n-\n-        Ok(InternalSsrChunkModule {\n-            ssr_module: ssr_module.to_resolved().await?,\n-            runtime: config.runtime,\n         }\n         .cell())\n     }\n@@ -900,7 +951,7 @@ impl PageEndpoint {\n         self: Vc<Self>,\n         ty: SsrChunkType,\n         node_path: Vc<FileSystemPath>,\n-        chunking_context: Vc<NodeJsChunkingContext>,\n+        node_chunking_context: Vc<NodeJsChunkingContext>,\n         edge_chunking_context: Vc<Box<dyn ChunkingContext>>,\n         runtime_entries: Vc<EvaluatableAssets>,\n         edge_runtime_entries: Vc<EvaluatableAssets>,\n@@ -910,14 +961,16 @@ impl PageEndpoint {\n \n             let InternalSsrChunkModule {\n                 ssr_module,\n+                app_module,\n+                document_module,\n                 runtime,\n             } = *self.internal_ssr_chunk_module().await?;\n \n             let project = this.pages_project.project();\n             // The SSR and Client Graphs are not connected in Pages Router.\n             // We are only interested in get_next_dynamic_imports_for_endpoint at the\n             // moment, which only needs the client graph anyway.\n-            let module_graph = project.module_graph(*ssr_module);\n+            let ssr_module_graph = self.ssr_module_graph();\n \n             let next_dynamic_imports = if let PageEndpointType::Html = this.ty {\n                 let client_availability_info = self.client_chunks().await?.availability_info;\n@@ -952,6 +1005,40 @@ impl PageEndpoint {\n                 DynamicImportedChunks::default().resolved_cell()\n             };\n \n+            let chunking_context: Vc<Box<dyn ChunkingContext>> = match runtime {\n+                NextRuntime::NodeJs => Vc::upcast(node_chunking_context),\n+                NextRuntime::Edge => Vc::upcast(edge_chunking_context),\n+            };\n+\n+            let mut current_chunks = OutputAssets::empty();\n+            let mut current_availability_info = AvailabilityInfo::Root;\n+            for layout in [document_module, app_module].iter().flatten().copied() {\n+                let span = tracing::trace_span!(\n+                    \"layout segment\",\n+                    name = display(layout.ident().to_string().await?)\n+                );\n+                async {\n+                    let chunk_group = chunking_context\n+                        .chunk_group(\n+                            layout.ident(),\n+                            ChunkGroup::Shared(layout),\n+                            ssr_module_graph,\n+                            Value::new(current_availability_info),\n+                        )\n+                        .await?;\n+\n+                    current_chunks = current_chunks\n+                        .concatenate(*chunk_group.assets)\n+                        .resolve()\n+                        .await?;\n+                    current_availability_info = chunk_group.availability_info;\n+\n+                    anyhow::Ok(())\n+                }\n+                .instrument(span)\n+                .await?;\n+            }\n+\n             let ssr_module_evaluatable = ResolvedVc::try_sidecast(ssr_module)\n                 .context(\"could not process page loader entry module\")?;\n             let is_edge = matches!(runtime, NextRuntime::Edge);\n@@ -962,18 +1049,15 @@ impl PageEndpoint {\n                     .map(|m| ResolvedVc::upcast(*m))\n                     .chain(std::iter::once(ResolvedVc::upcast(ssr_module_evaluatable)));\n \n-                let edge_files = edge_chunking_context\n-                    .evaluated_chunk_group_assets(\n-                        ssr_module.ident(),\n-                        ChunkGroup::Entry(evaluatable_assets.collect()),\n-                        module_graph,\n-                        Value::new(AvailabilityInfo::Root),\n-                    )\n-                    .to_resolved()\n-                    .await?;\n+                let edge_files = edge_chunking_context.evaluated_chunk_group_assets(\n+                    ssr_module.ident(),\n+                    ChunkGroup::Entry(evaluatable_assets.collect()),\n+                    ssr_module_graph,\n+                    Value::new(current_availability_info),\n+                );\n \n                 Ok(SsrChunk::Edge {\n-                    files: edge_files,\n+                    files: current_chunks.concatenate(edge_files).to_resolved().await?,\n                     dynamic_import_entries,\n                 }\n                 .cell())\n@@ -984,17 +1068,15 @@ impl PageEndpoint {\n \n                 let ssr_entry_chunk_path_string: RcStr = format!(\"pages{asset_path}\").into();\n                 let ssr_entry_chunk_path = node_path.join(ssr_entry_chunk_path_string);\n-                let EntryChunkGroupResult {\n-                    asset: ssr_entry_chunk,\n-                    ..\n-                } = *chunking_context\n-                    .entry_chunk_group(\n+                let ssr_entry_chunk = node_chunking_context\n+                    .entry_chunk_group_asset(\n                         ssr_entry_chunk_path,\n                         runtime_entries.with_entry(*ssr_module_evaluatable),\n-                        module_graph,\n-                        OutputAssets::empty(),\n-                        Value::new(AvailabilityInfo::Root),\n+                        ssr_module_graph,\n+                        current_chunks,\n+                        Value::new(current_availability_info),\n                     )\n+                    .to_resolved()\n                     .await?;\n \n                 let server_asset_trace_file = if this\n@@ -1364,6 +1446,8 @@ impl PageEndpoint {\n #[turbo_tasks::value]\n pub struct InternalSsrChunkModule {\n     pub ssr_module: ResolvedVc<Box<dyn Module>>,\n+    pub app_module: Option<ResolvedVc<Box<dyn Module>>>,\n+    pub document_module: Option<ResolvedVc<Box<dyn Module>>>,\n     pub runtime: NextRuntime,\n }\n \n@@ -1467,17 +1551,32 @@ impl Endpoint for PageEndpoint {\n         let this = self.await?;\n \n         let ssr_chunk_module = self.internal_ssr_chunk_module().await?;\n-        let mut modules = vec![ChunkGroupEntry::Entry(vec![ssr_chunk_module.ssr_module])];\n \n-        if let PageEndpointType::Html = this.ty {\n-            modules.push(ChunkGroupEntry::Entry(\n-                self.client_evaluatable_assets()\n-                    .await?\n-                    .iter()\n-                    .map(|m| ResolvedVc::upcast(*m))\n-                    .collect(),\n-            ));\n-        }\n+        let shared_entries = [\n+            ssr_chunk_module.document_module,\n+            ssr_chunk_module.app_module,\n+        ];\n+\n+        let modules = shared_entries\n+            .into_iter()\n+            .flatten()\n+            .map(ChunkGroupEntry::Shared)\n+            .chain(std::iter::once(ChunkGroupEntry::Entry(vec![\n+                ssr_chunk_module.ssr_module,\n+            ])))\n+            .chain(if this.ty == PageEndpointType::Html {\n+                Some(ChunkGroupEntry::Entry(\n+                    self.client_evaluatable_assets()\n+                        .await?\n+                        .iter()\n+                        .map(|m| ResolvedVc::upcast(*m))\n+                        .collect(),\n+                ))\n+                .into_iter()\n+            } else {\n+                None.into_iter()\n+            })\n+            .collect::<Vec<_>>();\n \n         Ok(Vc::cell(modules))\n     }"
        },
        {
            "sha": "88ef18cbf6d89b02a2f8cf65d4e1aa3b04df8c5b",
            "filename": "crates/next-api/src/project.rs",
            "status": "modified",
            "additions": 13,
            "deletions": 1,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/48725b22c742430bf83a554ab9095d9ffebee32b/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/48725b22c742430bf83a554ab9095d9ffebee32b/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fproject.rs?ref=48725b22c742430bf83a554ab9095d9ffebee32b",
            "patch": "@@ -895,7 +895,7 @@ impl Project {\n     }\n \n     #[turbo_tasks::function]\n-    pub async fn module_graph_for_entries(\n+    pub async fn module_graph_for_modules(\n         self: Vc<Self>,\n         evaluatable_assets: Vc<EvaluatableAssets>,\n     ) -> Result<Vc<ModuleGraph>> {\n@@ -912,6 +912,18 @@ impl Project {\n         })\n     }\n \n+    #[turbo_tasks::function]\n+    pub async fn module_graph_for_entries(\n+        self: Vc<Self>,\n+        entries: Vc<GraphEntries>,\n+    ) -> Result<Vc<ModuleGraph>> {\n+        Ok(if *self.per_page_module_graph().await? {\n+            ModuleGraph::from_modules(entries)\n+        } else {\n+            *self.whole_app_module_graphs().await?.full\n+        })\n+    }\n+\n     #[turbo_tasks::function]\n     pub async fn whole_app_module_graphs(self: ResolvedVc<Self>) -> Result<Vc<ModuleGraphs>> {\n         async move {"
        },
        {
            "sha": "aecfe32d78dfc98ac162b25e7091dbd13509bb65",
            "filename": "crates/next-core/src/next_pages/page_entry.rs",
            "status": "modified",
            "additions": 26,
            "deletions": 14,
            "changes": 40,
            "blob_url": "https://github.com/vercel/next.js/blob/48725b22c742430bf83a554ab9095d9ffebee32b/crates%2Fnext-core%2Fsrc%2Fnext_pages%2Fpage_entry.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/48725b22c742430bf83a554ab9095d9ffebee32b/crates%2Fnext-core%2Fsrc%2Fnext_pages%2Fpage_entry.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_pages%2Fpage_entry.rs?ref=48725b22c742430bf83a554ab9095d9ffebee32b",
            "patch": "@@ -23,6 +23,13 @@ use crate::{\n     util::{file_content_rope, load_next_js_template, NextRuntime},\n };\n \n+#[turbo_tasks::value]\n+pub struct PageSsrEntryModule {\n+    pub ssr_module: ResolvedVc<Box<dyn Module>>,\n+    pub app_module: Option<ResolvedVc<Box<dyn Module>>>,\n+    pub document_module: Option<ResolvedVc<Box<dyn Module>>>,\n+}\n+\n #[turbo_tasks::function]\n pub async fn create_page_ssr_entry_module(\n     pathname: Vc<RcStr>,\n@@ -34,7 +41,7 @@ pub async fn create_page_ssr_entry_module(\n     pages_structure: Vc<PagesStructure>,\n     runtime: NextRuntime,\n     next_config: Vc<NextConfig>,\n-) -> Result<Vc<Box<dyn Module>>> {\n+) -> Result<Vc<PageSsrEntryModule>> {\n     let definition_page = &*next_original_name.await?;\n     let definition_pathname = &*pathname.await?;\n \n@@ -118,28 +125,28 @@ pub async fn create_page_ssr_entry_module(\n \n     let pages_structure_ref = pages_structure.await?;\n \n-    if reference_type == ReferenceType::Entry(EntryReferenceSubType::Page) {\n-        inner_assets.insert(\n-            INNER_DOCUMENT.into(),\n-            process_global_item(\n+    let (app_module, document_module) =\n+        if reference_type == ReferenceType::Entry(EntryReferenceSubType::Page) {\n+            let document_module = process_global_item(\n                 *pages_structure_ref.document,\n                 Value::new(reference_type.clone()),\n                 ssr_module_context,\n             )\n             .to_resolved()\n-            .await?,\n-        );\n-        inner_assets.insert(\n-            INNER_APP.into(),\n-            process_global_item(\n+            .await?;\n+            let app_module = process_global_item(\n                 *pages_structure_ref.app,\n                 Value::new(reference_type.clone()),\n                 ssr_module_context,\n             )\n             .to_resolved()\n-            .await?,\n-        );\n-    }\n+            .await?;\n+            inner_assets.insert(INNER_DOCUMENT.into(), document_module);\n+            inner_assets.insert(INNER_APP.into(), app_module);\n+            (Some(app_module), Some(document_module))\n+        } else {\n+            (None, None)\n+        };\n \n     let mut ssr_module = ssr_module_context\n         .process(\n@@ -170,7 +177,12 @@ pub async fn create_page_ssr_entry_module(\n         }\n     }\n \n-    Ok(ssr_module)\n+    Ok(PageSsrEntryModule {\n+        ssr_module: ssr_module.to_resolved().await?,\n+        app_module,\n+        document_module,\n+    }\n+    .cell())\n }\n \n #[turbo_tasks::function]"
        },
        {
            "sha": "fe1a3ef7b38a1431826f55f573cc02cfe07e4279",
            "filename": "packages/next/src/server/dev/hot-reloader-turbopack.ts",
            "status": "modified",
            "additions": 13,
            "deletions": 9,
            "changes": 22,
            "blob_url": "https://github.com/vercel/next.js/blob/48725b22c742430bf83a554ab9095d9ffebee32b/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fhot-reloader-turbopack.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/48725b22c742430bf83a554ab9095d9ffebee32b/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fhot-reloader-turbopack.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fhot-reloader-turbopack.ts?ref=48725b22c742430bf83a554ab9095d9ffebee32b",
            "patch": "@@ -296,7 +296,7 @@ export async function createHotReloaderTurbopack(\n       // Always clear the cache, don't check if files have changed\n       force?: boolean\n     } = {}\n-  ): void {\n+  ): boolean {\n     if (force) {\n       for (const { path, contentHash } of writtenEndpoint.serverPaths) {\n         serverPathState.set(path, contentHash)\n@@ -328,7 +328,7 @@ export async function createHotReloaderTurbopack(\n       }\n \n       if (!hasChange) {\n-        return\n+        return false\n       }\n     }\n \n@@ -351,7 +351,7 @@ export async function createHotReloaderTurbopack(\n       deleteCache(file)\n     }\n \n-    return\n+    return true\n   }\n \n   const buildingIds = new Set()\n@@ -601,9 +601,9 @@ export async function createHotReloaderTurbopack(\n           serverFields,\n \n           hooks: {\n-            handleWrittenEndpoint: (id, result) => {\n+            handleWrittenEndpoint: (id, result, forceDeleteCache) => {\n               currentWrittenEntrypoints.set(id, result)\n-              clearRequireCache(id, result)\n+              return clearRequireCache(id, result, { force: forceDeleteCache })\n             },\n             propagateServerField: propagateServerField.bind(null, opts),\n             sendHmr,\n@@ -997,10 +997,12 @@ export async function createHotReloaderTurbopack(\n                 logErrors: true,\n                 hooks: {\n                   subscribeToChanges,\n-                  handleWrittenEndpoint: (id, result) => {\n-                    clearRequireCache(id, result)\n+                  handleWrittenEndpoint: (id, result, forceDeleteCache) => {\n                     currentWrittenEntrypoints.set(id, result)\n                     assetMapper.setPathsForKey(id, result.clientPaths)\n+                    return clearRequireCache(id, result, {\n+                      force: forceDeleteCache,\n+                    })\n                   },\n                 },\n               })\n@@ -1061,10 +1063,12 @@ export async function createHotReloaderTurbopack(\n \n               hooks: {\n                 subscribeToChanges,\n-                handleWrittenEndpoint: (id, result) => {\n+                handleWrittenEndpoint: (id, result, forceDeleteCache) => {\n                   currentWrittenEntrypoints.set(id, result)\n-                  clearRequireCache(id, result)\n                   assetMapper.setPathsForKey(id, result.clientPaths)\n+                  return clearRequireCache(id, result, {\n+                    force: forceDeleteCache,\n+                  })\n                 },\n               },\n             })"
        },
        {
            "sha": "ee8792c316cb0a84142f2a0dbb48e99467dcd014",
            "filename": "packages/next/src/server/dev/turbopack-utils.ts",
            "status": "modified",
            "additions": 25,
            "deletions": 13,
            "changes": 38,
            "blob_url": "https://github.com/vercel/next.js/blob/48725b22c742430bf83a554ab9095d9ffebee32b/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fturbopack-utils.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/48725b22c742430bf83a554ab9095d9ffebee32b/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fturbopack-utils.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fturbopack-utils.ts?ref=48725b22c742430bf83a554ab9095d9ffebee32b",
            "patch": "@@ -98,8 +98,9 @@ export type ChangeSubscriptions = Map<\n \n export type HandleWrittenEndpoint = (\n   key: EntryKey,\n-  result: TurbopackResult<WrittenEndpoint>\n-) => void\n+  result: TurbopackResult<WrittenEndpoint>,\n+  forceDeleteCache: boolean\n+) => boolean\n \n export type StartChangeSubscription = (\n   key: EntryKey,\n@@ -177,11 +178,17 @@ export async function handleRouteType({\n       const serverKey = getEntryKey('pages', 'server', page)\n \n       try {\n+        // In the best case scenario, Turbopack chunks document, app, page separately in that order,\n+        // so it can happen that the chunks of document change, but the chunks of app and page\n+        // don't. We still need to reload the page chunks in that case though, otherwise the version\n+        // of the document or app component export from the pages template is stale.\n+        let documentOrAppChanged = false\n         if (entrypoints.global.app) {\n           const key = getEntryKey('pages', 'server', '_app')\n \n           const writtenEndpoint = await entrypoints.global.app.writeToDisk()\n-          hooks?.handleWrittenEndpoint(key, writtenEndpoint)\n+          documentOrAppChanged ||=\n+            hooks?.handleWrittenEndpoint(key, writtenEndpoint, false) ?? false\n           processIssues(\n             currentEntryIssues,\n             key,\n@@ -198,7 +205,8 @@ export async function handleRouteType({\n \n           const writtenEndpoint =\n             await entrypoints.global.document.writeToDisk()\n-          hooks?.handleWrittenEndpoint(key, writtenEndpoint)\n+          documentOrAppChanged ||=\n+            hooks?.handleWrittenEndpoint(key, writtenEndpoint, false) ?? false\n           processIssues(\n             currentEntryIssues,\n             key,\n@@ -210,7 +218,11 @@ export async function handleRouteType({\n         await manifestLoader.loadPagesManifest('_document')\n \n         const writtenEndpoint = await route.htmlEndpoint.writeToDisk()\n-        hooks?.handleWrittenEndpoint(serverKey, writtenEndpoint)\n+        hooks?.handleWrittenEndpoint(\n+          serverKey,\n+          writtenEndpoint,\n+          documentOrAppChanged\n+        )\n \n         const type = writtenEndpoint?.type\n \n@@ -308,7 +320,7 @@ export async function handleRouteType({\n       const key = getEntryKey('pages', 'server', page)\n \n       const writtenEndpoint = await route.endpoint.writeToDisk()\n-      hooks?.handleWrittenEndpoint(key, writtenEndpoint)\n+      hooks?.handleWrittenEndpoint(key, writtenEndpoint, false)\n \n       const type = writtenEndpoint.type\n \n@@ -333,7 +345,7 @@ export async function handleRouteType({\n       const key = getEntryKey('app', 'server', page)\n \n       const writtenEndpoint = await route.htmlEndpoint.writeToDisk()\n-      hooks?.handleWrittenEndpoint(key, writtenEndpoint)\n+      hooks?.handleWrittenEndpoint(key, writtenEndpoint, false)\n \n       if (dev) {\n         // TODO subscriptions should only be caused by the WebSocket connections\n@@ -396,7 +408,7 @@ export async function handleRouteType({\n       const key = getEntryKey('app', 'server', page)\n \n       const writtenEndpoint = await route.endpoint.writeToDisk()\n-      hooks?.handleWrittenEndpoint(key, writtenEndpoint)\n+      hooks?.handleWrittenEndpoint(key, writtenEndpoint, false)\n \n       const type = writtenEndpoint.type\n \n@@ -654,7 +666,7 @@ export async function handleEntrypoints({\n       const key = getEntryKey('root', 'server', name)\n \n       const writtenEndpoint = await instrumentation[prop].writeToDisk()\n-      dev.hooks.handleWrittenEndpoint(key, writtenEndpoint)\n+      dev.hooks.handleWrittenEndpoint(key, writtenEndpoint, false)\n       processIssues(currentEntryIssues, key, writtenEndpoint, false, logErrors)\n     }\n     await processInstrumentation('instrumentation.nodeJs', 'nodeJs')\n@@ -689,7 +701,7 @@ export async function handleEntrypoints({\n \n     async function processMiddleware() {\n       const writtenEndpoint = await endpoint.writeToDisk()\n-      dev.hooks.handleWrittenEndpoint(key, writtenEndpoint)\n+      dev.hooks.handleWrittenEndpoint(key, writtenEndpoint, false)\n       processIssues(currentEntryIssues, key, writtenEndpoint, false, logErrors)\n       await manifestLoader.loadMiddlewareManifest('middleware', 'middleware')\n       const middlewareConfig =\n@@ -840,7 +852,7 @@ export async function handlePagesErrorRoute({\n     const key = getEntryKey('pages', 'server', '_app')\n \n     const writtenEndpoint = await entrypoints.global.app.writeToDisk()\n-    hooks.handleWrittenEndpoint(key, writtenEndpoint)\n+    hooks.handleWrittenEndpoint(key, writtenEndpoint, false)\n     hooks.subscribeToChanges(\n       key,\n       false,\n@@ -867,7 +879,7 @@ export async function handlePagesErrorRoute({\n     const key = getEntryKey('pages', 'server', '_document')\n \n     const writtenEndpoint = await entrypoints.global.document.writeToDisk()\n-    hooks.handleWrittenEndpoint(key, writtenEndpoint)\n+    hooks.handleWrittenEndpoint(key, writtenEndpoint, false)\n     hooks.subscribeToChanges(\n       key,\n       false,\n@@ -893,7 +905,7 @@ export async function handlePagesErrorRoute({\n     const key = getEntryKey('pages', 'server', '_error')\n \n     const writtenEndpoint = await entrypoints.global.error.writeToDisk()\n-    hooks.handleWrittenEndpoint(key, writtenEndpoint)\n+    hooks.handleWrittenEndpoint(key, writtenEndpoint, false)\n     hooks.subscribeToChanges(\n       key,\n       false,"
        },
        {
            "sha": "5b68d879f413d0f65514e9fc7f3a62ec658e9918",
            "filename": "test/e2e/app-document/client.test.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/48725b22c742430bf83a554ab9095d9ffebee32b/test%2Fe2e%2Fapp-document%2Fclient.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/48725b22c742430bf83a554ab9095d9ffebee32b/test%2Fe2e%2Fapp-document%2Fclient.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-document%2Fclient.test.ts?ref=48725b22c742430bf83a554ab9095d9ffebee32b",
            "patch": "@@ -1,7 +1,7 @@\n import { retry } from 'next-test-utils'\n import { nextTestSetup } from 'e2e-utils'\n \n-describe('Client side', () => {\n+describe('Document and App - Client side', () => {\n   const { next, isNextDev } = nextTestSetup({\n     files: __dirname,\n     skipDeployment: true,"
        },
        {
            "sha": "ef1aaf8fbc329496c8675f71b57aab85b9ab3e18",
            "filename": "test/e2e/app-document/csp.test.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/48725b22c742430bf83a554ab9095d9ffebee32b/test%2Fe2e%2Fapp-document%2Fcsp.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/48725b22c742430bf83a554ab9095d9ffebee32b/test%2Fe2e%2Fapp-document%2Fcsp.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-document%2Fcsp.test.ts?ref=48725b22c742430bf83a554ab9095d9ffebee32b",
            "patch": "@@ -1,6 +1,6 @@\n import { nextTestSetup } from 'e2e-utils'\n \n-describe('With CSP enabled', () => {\n+describe('Document and App - With CSP enabled', () => {\n   const { next } = nextTestSetup({\n     files: __dirname,\n   })"
        },
        {
            "sha": "12bb8c0d3dac5b64104977723c578e80169c258d",
            "filename": "test/e2e/app-document/rendering.test.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/48725b22c742430bf83a554ab9095d9ffebee32b/test%2Fe2e%2Fapp-document%2Frendering.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/48725b22c742430bf83a554ab9095d9ffebee32b/test%2Fe2e%2Fapp-document%2Frendering.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-document%2Frendering.test.ts?ref=48725b22c742430bf83a554ab9095d9ffebee32b",
            "patch": "@@ -1,7 +1,7 @@\n import { retry } from 'next-test-utils'\n import { nextTestSetup } from 'e2e-utils'\n \n-describe('app-document - Rendering via HTTP', () => {\n+describe('Document and App - Rendering via HTTP', () => {\n   const { next, isNextDev } = nextTestSetup({\n     files: __dirname,\n   })"
        }
    ],
    "stats": {
        "total": 309,
        "additions": 224,
        "deletions": 85
    }
}