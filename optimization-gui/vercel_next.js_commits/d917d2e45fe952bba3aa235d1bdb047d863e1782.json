{
    "author": "lukesandberg",
    "message": "[turbopack] Prevent accidental access to `.next` (#84714)\n\nCertain patterns in source code cause turbopack to scan the project directories for resources.  This can go wrong when one of those patterns can traverse into .next (oroborous!).\n\nThere is no usecase for turbopack to read files from the distDir during analysis and we can prevent that with a simple filter at the FileSystem layer which is what this PR does.  Given the recent `build/dev` split this is a little subtle, so i added a new property to `NextConfigComplete` so we always pass the original `distDir` down even when we are performing the `dev` split.\n\nThe semantics of this are implemented at the filesystem layer which means:\n* writing into a 'denied_path' is an error\n* reading a denied path is 'not found'\n* reading the parent directory of a denied path filters it.\n\nCloses PACK-5593",
    "sha": "d917d2e45fe952bba3aa235d1bdb047d863e1782",
    "files": [
        {
            "sha": "165f352fcf9f250bdf674cf34f8f9dc60bcc71a8",
            "filename": "Cargo.lock",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/d917d2e45fe952bba3aa235d1bdb047d863e1782/Cargo.lock",
            "raw_url": "https://github.com/vercel/next.js/raw/d917d2e45fe952bba3aa235d1bdb047d863e1782/Cargo.lock",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/Cargo.lock?ref=d917d2e45fe952bba3aa235d1bdb047d863e1782",
            "patch": "@@ -9525,6 +9525,7 @@ dependencies = [\n  \"turbo-tasks-env\",\n  \"turbo-tasks-fs\",\n  \"turbo-tasks-malloc\",\n+ \"turbo-unix-path\",\n  \"turbopack\",\n  \"turbopack-bench\",\n  \"turbopack-browser\","
        },
        {
            "sha": "711edd448137d33159337f1d98d358ef420008d3",
            "filename": "crates/napi/src/next_api/project.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/d917d2e45fe952bba3aa235d1bdb047d863e1782/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d917d2e45fe952bba3aa235d1bdb047d863e1782/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs?ref=d917d2e45fe952bba3aa235d1bdb047d863e1782",
            "patch": "@@ -574,7 +574,7 @@ async fn benchmark_file_io(turbo_tasks: NextTurboTasks, directory: FileSystemPat\n         ))?\n         .await?;\n \n-    let directory = fs.to_sys_path(directory)?;\n+    let directory = fs.to_sys_path(&directory);\n     let temp_path = directory.join(format!(\n         \"tmp_file_io_benchmark_{:x}\",\n         rand::random::<u128>()"
        },
        {
            "sha": "bfdaeecc2b52bc54ab01cfe123f058aad77dab4f",
            "filename": "crates/next-api/src/nft_json.rs",
            "status": "modified",
            "additions": 22,
            "deletions": 22,
            "changes": 44,
            "blob_url": "https://github.com/vercel/next.js/blob/d917d2e45fe952bba3aa235d1bdb047d863e1782/crates%2Fnext-api%2Fsrc%2Fnft_json.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d917d2e45fe952bba3aa235d1bdb047d863e1782/crates%2Fnext-api%2Fsrc%2Fnft_json.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fnft_json.rs?ref=d917d2e45fe952bba3aa235d1bdb047d863e1782",
            "patch": "@@ -82,19 +82,17 @@ fn get_output_specifier(\n     ident_folder_in_project_fs: &FileSystemPath,\n     output_root: &FileSystemPath,\n     project_root: &FileSystemPath,\n-) -> Result<Option<RcStr>> {\n+) -> Result<RcStr> {\n     // include assets in the outputs such as referenced chunks\n     if path_ref.is_inside_ref(output_root) {\n-        return Ok(Some(ident_folder.get_relative_path_to(path_ref).unwrap()));\n+        return Ok(ident_folder.get_relative_path_to(path_ref).unwrap());\n     }\n \n     // include assets in the project root such as images and traced references (externals)\n     if path_ref.is_inside_ref(project_root) {\n-        return Ok(Some(\n-            ident_folder_in_project_fs\n-                .get_relative_path_to(path_ref)\n-                .unwrap(),\n-        ));\n+        return Ok(ident_folder_in_project_fs\n+            .get_relative_path_to(path_ref)\n+            .unwrap());\n     }\n \n     // This should effectively be unreachable\n@@ -234,15 +232,20 @@ impl Asset for NftJsonAsset {\n             };\n \n             // Collect base assets first\n-            for referenced_chunk in\n-                all_assets_from_entries_filtered(Vc::cell(entries), Some(client_root), exclude_glob)\n-                    .await?\n-            {\n-                if chunk.eq(referenced_chunk) {\n+            let all_assets = all_assets_from_entries_filtered(\n+                Vc::cell(entries),\n+                Some(client_root),\n+                exclude_glob,\n+            )\n+            .await?;\n+\n+            for referenced_chunk in all_assets.iter().copied() {\n+                if chunk.eq(&referenced_chunk) {\n                     continue;\n                 }\n \n                 let referenced_chunk_path = referenced_chunk.path().await?;\n+\n                 if referenced_chunk_path.has_extension(\".map\") {\n                     continue;\n                 }\n@@ -279,16 +282,13 @@ impl Asset for NftJsonAsset {\n                     }\n                 }\n \n-                let Some(specifier) = get_output_specifier(\n+                let specifier = get_output_specifier(\n                     &referenced_chunk_path,\n                     &ident_folder,\n                     &ident_folder_in_project_fs,\n                     &output_root_ref,\n                     &project_root_ref,\n-                )?\n-                else {\n-                    continue;\n-                };\n+                )?;\n \n                 result.insert(specifier);\n             }\n@@ -357,7 +357,7 @@ impl Asset for NftJsonAsset {\n /// The glob walker in turbopack is somewhat naive so we handle relative path directives first so\n /// traversal doesn't need to consider them and can just traverse 'down' the tree.\n /// The main alternative is to merge glob evaluation with directory traversal which is what the npm\n-/// `glob` package does, but this would be a substantial rewrite.`\n+/// `glob` package does, but this would be a substantial rewrite.\n pub(crate) fn relativize_glob(\n     glob: &str,\n     relative_to: FileSystemPath,\n@@ -478,12 +478,12 @@ async fn get_referenced_server_assets(\n     client_root: Option<FileSystemPath>,\n     exclude_glob: Option<ReadRef<Glob>>,\n ) -> Result<Vec<(ResolvedVc<Box<dyn OutputAsset>>, Option<ReadRef<RcStr>>)>> {\n-    asset\n-        .references()\n-        .await?\n-        .iter()\n+    let refs = asset.references().await?;\n+\n+    refs.iter()\n         .map(async |asset| {\n             let asset_path = asset.path().await?;\n+\n             if let Some(client_root) = &client_root\n                 && asset_path.is_inside_ref(client_root)\n             {"
        },
        {
            "sha": "8933da1c050827ff893d231bb45ab1d733f5485f",
            "filename": "crates/next-api/src/project.rs",
            "status": "modified",
            "additions": 25,
            "deletions": 8,
            "changes": 33,
            "blob_url": "https://github.com/vercel/next.js/blob/d917d2e45fe952bba3aa235d1bdb047d863e1782/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d917d2e45fe952bba3aa235d1bdb047d863e1782/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fproject.rs?ref=d917d2e45fe952bba3aa235d1bdb047d863e1782",
            "patch": "@@ -479,18 +479,15 @@ impl ProjectContainer {\n             current_node_js_version = options.current_node_js_version.clone();\n         }\n \n-        let dist_dir = next_config\n-            .dist_dir()\n-            .await?\n-            .as_ref()\n-            .map_or_else(|| rcstr!(\".next\"), |d| d.clone());\n-\n+        let dist_dir = next_config.dist_dir().owned().await?;\n+        let dist_dir_root = next_config.dist_dir_root().owned().await?;\n         Ok(Project {\n             root_path,\n             project_path,\n             watch,\n             next_config: next_config.to_resolved().await?,\n             dist_dir,\n+            dist_dir_root,\n             env: ResolvedVc::upcast(env_map.to_resolved().await?),\n             define_env: define_env.to_resolved().await?,\n             browserslist_query,\n@@ -554,6 +551,11 @@ pub struct Project {\n     /// E.g. `.next`\n     dist_dir: RcStr,\n \n+    /// The root directory of the distDir. Generally the same as `distDir` but when\n+    /// `isolatedDevBuild` is true it is the parent directory of `distDir`.  This is used to\n+    /// ensure that the bundler doesn't traverse into the output directory.\n+    dist_dir_root: RcStr,\n+\n     /// Filesystem watcher options.\n     watch: WatchOptions,\n \n@@ -668,8 +670,23 @@ impl Project {\n     }\n \n     #[turbo_tasks::function]\n-    pub fn project_fs(&self) -> Vc<DiskFileSystem> {\n-        DiskFileSystem::new(PROJECT_FILESYSTEM_NAME.into(), self.root_path.clone())\n+    pub fn project_fs(&self) -> Result<Vc<DiskFileSystem>> {\n+        let denied_path = match join_path(&self.project_path, &self.dist_dir_root) {\n+            Some(dist_dir_root) => dist_dir_root.into(),\n+            None => {\n+                bail!(\n+                    \"Invalid distDirRoot: {:?}. distDirRoot should not navigate out of the \\\n+                     projectPath.\",\n+                    self.dist_dir_root\n+                );\n+            }\n+        };\n+\n+        Ok(DiskFileSystem::new_with_denied_path(\n+            rcstr!(PROJECT_FILESYSTEM_NAME),\n+            self.root_path.clone(),\n+            denied_path,\n+        ))\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "f7ad3ee0b90e791e2cb91ce6ccd905cbcd7b1d85",
            "filename": "crates/next-core/src/next_config.rs",
            "status": "modified",
            "additions": 7,
            "deletions": 2,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/d917d2e45fe952bba3aa235d1bdb047d863e1782/crates%2Fnext-core%2Fsrc%2Fnext_config.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d917d2e45fe952bba3aa235d1bdb047d863e1782/crates%2Fnext-core%2Fsrc%2Fnext_config.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_config.rs?ref=d917d2e45fe952bba3aa235d1bdb047d863e1782",
            "patch": "@@ -96,7 +96,8 @@ pub struct NextConfig {\n     react_strict_mode: Option<bool>,\n     transpile_packages: Option<Vec<RcStr>>,\n     modularize_imports: Option<FxIndexMap<String, ModularizeImportPackageConfig>>,\n-    dist_dir: Option<RcStr>,\n+    dist_dir: RcStr,\n+    dist_dir_root: RcStr,\n     deployment_id: Option<RcStr>,\n     sass_options: Option<serde_json::Value>,\n     trailing_slash: Option<bool>,\n@@ -1590,9 +1591,13 @@ impl NextConfig {\n     }\n \n     #[turbo_tasks::function]\n-    pub fn dist_dir(&self) -> Vc<Option<RcStr>> {\n+    pub fn dist_dir(&self) -> Vc<RcStr> {\n         Vc::cell(self.dist_dir.clone())\n     }\n+    #[turbo_tasks::function]\n+    pub fn dist_dir_root(&self) -> Vc<RcStr> {\n+        Vc::cell(self.dist_dir_root.clone())\n+    }\n \n     #[turbo_tasks::function]\n     pub fn experimental_cache_handlers("
        },
        {
            "sha": "f51f721d36288ff66eadf0b08d3c3ad88c9e6a56",
            "filename": "examples/with-turbopack/tsconfig.json",
            "status": "modified",
            "additions": 7,
            "deletions": 2,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/d917d2e45fe952bba3aa235d1bdb047d863e1782/examples%2Fwith-turbopack%2Ftsconfig.json",
            "raw_url": "https://github.com/vercel/next.js/raw/d917d2e45fe952bba3aa235d1bdb047d863e1782/examples%2Fwith-turbopack%2Ftsconfig.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/examples%2Fwith-turbopack%2Ftsconfig.json?ref=d917d2e45fe952bba3aa235d1bdb047d863e1782",
            "patch": "@@ -13,8 +13,13 @@\n     \"resolveJsonModule\": true,\n     \"isolatedModules\": true,\n     \"jsx\": \"react-jsx\",\n-    \"incremental\": true\n+    \"incremental\": true,\n+    \"plugins\": [\n+      {\n+        \"name\": \"next\"\n+      }\n+    ]\n   },\n-  \"include\": [\"next-env.d.ts\", \"**/*.ts\", \"**/*.tsx\"],\n+  \"include\": [\"next-env.d.ts\", \"**/*.ts\", \"**/*.tsx\", \".next/types/**/*.ts\"],\n   \"exclude\": [\"node_modules\"]\n }"
        },
        {
            "sha": "d964875f9de73bf09aa50f5b6da8f7422a79f4e0",
            "filename": "packages/next/src/server/config-shared.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/d917d2e45fe952bba3aa235d1bdb047d863e1782/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d917d2e45fe952bba3aa235d1bdb047d863e1782/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts?ref=d917d2e45fe952bba3aa235d1bdb047d863e1782",
            "patch": "@@ -25,6 +25,10 @@ export type NextConfigComplete = Required<Omit<NextConfig, 'configFile'>> & {\n   // because it's not defined in NextConfigComplete.experimental\n   htmlLimitedBots: string | undefined\n   experimental: ExperimentalConfig\n+  // The root directory of the distDir. Generally the same as `distDir` but when `isolatedDevBuild`\n+  // is true it is the parent directory of `distDir`.  This is used to ensure that the bundler doesn't\n+  // traverse into the output directory.\n+  distDirRoot: string\n }\n \n export type I18NDomains = readonly DomainLocale[]"
        },
        {
            "sha": "92b4bb219639850a7d2c6de6c3509762397e5f18",
            "filename": "packages/next/src/server/config.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/d917d2e45fe952bba3aa235d1bdb047d863e1782/packages%2Fnext%2Fsrc%2Fserver%2Fconfig.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d917d2e45fe952bba3aa235d1bdb047d863e1782/packages%2Fnext%2Fsrc%2Fserver%2Fconfig.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fconfig.ts?ref=d917d2e45fe952bba3aa235d1bdb047d863e1782",
            "patch": "@@ -1293,6 +1293,8 @@ function assignDefaultsAndValidate(\n     result.experimental.useCache = result.experimental.cacheComponents\n   }\n \n+  // Store the distDirRoot in the config before it is modified by the isolatedDevBuild flag\n+  ;(result as NextConfigComplete).distDirRoot = result.distDir\n   if (\n     phase === PHASE_DEVELOPMENT_SERVER &&\n     result.experimental?.isolatedDevBuild"
        },
        {
            "sha": "6dbe58431eb58b5e9ed3d65259c105f1236e3aa5",
            "filename": "test/production/next-server-nft/app/dynamic-read/page.tsx",
            "status": "added",
            "additions": 23,
            "deletions": 0,
            "changes": 23,
            "blob_url": "https://github.com/vercel/next.js/blob/d917d2e45fe952bba3aa235d1bdb047d863e1782/test%2Fproduction%2Fnext-server-nft%2Fapp%2Fdynamic-read%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/d917d2e45fe952bba3aa235d1bdb047d863e1782/test%2Fproduction%2Fnext-server-nft%2Fapp%2Fdynamic-read%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fnext-server-nft%2Fapp%2Fdynamic-read%2Fpage.tsx?ref=d917d2e45fe952bba3aa235d1bdb047d863e1782",
            "patch": "@@ -0,0 +1,23 @@\n+import fs from 'fs'\n+import path from 'path'\n+\n+export default async function Page() {\n+  let config = 'file from .next not found'\n+  try {\n+    const rootConfig = fs.readFileSync(\n+      path.join(__dirname, '../../', '.next', globalThis.afile),\n+      'utf-8'\n+    )\n+    config = `Config loaded: ${rootConfig.substring(0, 50)}...`\n+  } catch (error) {\n+    config = `File from next not found (this is expected in test)`\n+  }\n+\n+  return (\n+    <div>\n+      <h1>Dynamic File Read Test</h1>\n+      <p>This page uses dynamic fs.readFileSync that trace into odd places</p>\n+      <p>{config}</p>\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "1853fcd6ab79ce20563d8631d3e825db63f0e7fc",
            "filename": "test/production/next-server-nft/next-server-nft.test.ts",
            "status": "modified",
            "additions": 40,
            "deletions": 10,
            "changes": 50,
            "blob_url": "https://github.com/vercel/next.js/blob/d917d2e45fe952bba3aa235d1bdb047d863e1782/test%2Fproduction%2Fnext-server-nft%2Fnext-server-nft.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d917d2e45fe952bba3aa235d1bdb047d863e1782/test%2Fproduction%2Fnext-server-nft%2Fnext-server-nft.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fnext-server-nft%2Fnext-server-nft.test.ts?ref=d917d2e45fe952bba3aa235d1bdb047d863e1782",
            "patch": "@@ -26,8 +26,8 @@ const isReact18 = parseInt(process.env.NEXT_TEST_REACT_VERSION) === 18\n     }\n \n     async function readNormalizedNFT(name) {\n-      let data = await next.readJSON(name)\n-      let result = [\n+      const data = await next.readJSON(name)\n+      const result = [\n         ...new Set(\n           data.files\n             .filter((file: string) => {\n@@ -39,9 +39,14 @@ const isReact18 = parseInt(process.env.NEXT_TEST_REACT_VERSION) === 18\n               }\n \n               // Filter out the many symlinks that power node_modules\n-              let fileAbsolute = path.join(next.testDir, name, '..', file)\n-              if (fs.lstatSync(fileAbsolute).isSymbolicLink()) {\n-                return false\n+              const fileAbsolute = path.join(next.testDir, name, '..', file)\n+              try {\n+                if (fs.lstatSync(fileAbsolute).isSymbolicLink()) {\n+                  return false\n+                }\n+              } catch (e) {\n+                // File doesn't exist - this is a bug in the NFT generation!\n+                // Keep it in the list so the test can catch it\n               }\n               return true\n             })\n@@ -59,8 +64,8 @@ const isReact18 = parseInt(process.env.NEXT_TEST_REACT_VERSION) === 18\n               }\n \n               // Strip double node_modules to simplify output\n-              let firstNodeModules = file.indexOf('/node_modules/')\n-              let lastNodeModules = file.lastIndexOf('/node_modules/')\n+              const firstNodeModules = file.indexOf('/node_modules/')\n+              const lastNodeModules = file.lastIndexOf('/node_modules/')\n               if (firstNodeModules !== lastNodeModules) {\n                 return file.slice(lastNodeModules)\n               }\n@@ -74,12 +79,12 @@ const isReact18 = parseInt(process.env.NEXT_TEST_REACT_VERSION) === 18\n     }\n \n     it('should not trace too many files in next-server.js.nft.json', async () => {\n-      let trace = await readNormalizedNFT('.next/next-server.js.nft.json')\n+      const trace = await readNormalizedNFT('.next/next-server.js.nft.json')\n \n       // Group the entries together so that the snapshot doesn't change too often.\n       // This trace contains quite a lot of files that aren't actually needed. But there isn't much\n       // that Turbopack itself can do about that.\n-      let traceGrouped = [\n+      const traceGrouped = [\n         ...new Set(\n           trace.map((file: string) => {\n             if (file.startsWith('/node_modules/next/')) {\n@@ -228,8 +233,33 @@ const isReact18 = parseInt(process.env.NEXT_TEST_REACT_VERSION) === 18\n       `)\n     })\n \n+    it('should not include .next directory in traces despite dynamic fs operations', async () => {\n+      // This test verifies that the denied_path feature prevents the .next directory\n+      // from being included in traces. The app/dynamic-read page uses dynamic fs.readFileSync\n+      // with path.join(process.cwd(), ...) which could theoretically read any file.\n+\n+      // Check the page-specific trace that has the dynamic fs operations\n+      const pageTrace = await readNormalizedNFT(\n+        '.next/server/app/dynamic-read/page.js.nft.json'\n+      )\n+\n+      // Snapshot the non-node_modules and non-chunks files to see what's being traced\n+      // We also filter out chunks because their names change with every build\n+      const nonNodeModulesFiles = pageTrace.filter(\n+        (file: string) =>\n+          !file.includes('/node_modules/') && !file.includes('/chunks/')\n+      )\n+\n+      expect(nonNodeModulesFiles).toMatchInlineSnapshot(`\n+       [\n+         \"./page/react-loadable-manifest.json\",\n+         \"./page_client-reference-manifest.js\",\n+       ]\n+      `)\n+    })\n+\n     it('should not trace too many files in next-minimal-server.js.nft.json', async () => {\n-      let trace = await readNormalizedNFT(\n+      const trace = await readNormalizedNFT(\n         '.next/next-minimal-server.js.nft.json'\n       )\n       expect(trace).toMatchInlineSnapshot(`"
        },
        {
            "sha": "f8ef86715d498f274843ebfad5a7d899e63b396b",
            "filename": "turbopack/crates/turbo-tasks-fs/src/lib.rs",
            "status": "modified",
            "additions": 419,
            "deletions": 14,
            "changes": 433,
            "blob_url": "https://github.com/vercel/next.js/blob/d917d2e45fe952bba3aa235d1bdb047d863e1782/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d917d2e45fe952bba3aa235d1bdb047d863e1782/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs?ref=d917d2e45fe952bba3aa235d1bdb047d863e1782",
            "patch": "@@ -262,6 +262,9 @@ struct DiskFileSystemInner {\n \n     #[turbo_tasks(debug_ignore, trace_ignore)]\n     watcher: DiskWatcher,\n+    /// A root path that we do not allow access to from this filesystem.\n+    /// Useful for things like output directories to prevent accidental ouroboros situations.\n+    denied_path: Option<RcStr>,\n }\n \n impl DiskFileSystemInner {\n@@ -271,6 +274,29 @@ impl DiskFileSystemInner {\n         simplified(Path::new(&*self.root))\n     }\n \n+    /// Checks if a path is within the denied path\n+    /// Returns true if the path should be treated as non-existent\n+    ///\n+    /// Since denied_path is guaranteed to be:\n+    /// - normalized (no ../ traversals)\n+    /// - using unix separators (/)\n+    /// - relative to the fs root\n+    ///\n+    /// We can efficiently check using string operations\n+    fn is_path_denied(&self, path: &FileSystemPath) -> bool {\n+        let Some(denied_path) = &self.denied_path else {\n+            return false;\n+        };\n+        // If the path starts with the denied path then there are three cases\n+        // * they are equal => denied\n+        // * root relative path is a descendant which means the next character is a / => denied\n+        // * anything else => not denied (covers denying `.next` but allowing `.next2`)\n+        let path = &path.path;\n+        path.starts_with(denied_path.as_str())\n+            && (path.len() == denied_path.len()\n+                || path.as_bytes().get(denied_path.len()) == Some(&b'/'))\n+    }\n+\n     /// registers the path as an invalidator for the current task,\n     /// has to be called within a turbo-tasks function\n     fn register_read_invalidator(&self, path: &Path) -> Result<()> {\n@@ -525,13 +551,13 @@ impl DiskFileSystem {\n         })\n     }\n \n-    pub fn to_sys_path(&self, fs_path: FileSystemPath) -> Result<PathBuf> {\n+    pub fn to_sys_path(&self, fs_path: &FileSystemPath) -> PathBuf {\n         let path = self.inner.root_path();\n-        Ok(if fs_path.path.is_empty() {\n+        if fs_path.path.is_empty() {\n             path.to_path_buf()\n         } else {\n             path.join(&*unix_to_sys(&fs_path.path))\n-        })\n+        }\n     }\n }\n \n@@ -555,16 +581,39 @@ fn format_absolute_fs_path(path: &Path, name: &str, root_path: &Path) -> Option<\n     }\n }\n \n-#[turbo_tasks::value_impl]\n impl DiskFileSystem {\n     /// Create a new instance of `DiskFileSystem`.\n     /// # Arguments\n     ///\n     /// * `name` - Name of the filesystem.\n     /// * `root` - Path to the given filesystem's root. Should be\n     ///   [canonicalized][std::fs::canonicalize].\n+    pub fn new(name: RcStr, root: RcStr) -> Vc<Self> {\n+        Self::new_internal(name, root, None)\n+    }\n+\n+    /// Create a new instance of `DiskFileSystem`.\n+    /// # Arguments\n+    ///\n+    /// * `name` - Name of the filesystem.\n+    /// * `root` - Path to the given filesystem's root. Should be\n+    ///   [canonicalized][std::fs::canonicalize].\n+    /// * `denied_path` - A path within this filesystem that is not allowed to be accessed or\n+    ///   navigated into.  This must be normalized, non-empty and relative to the fs root.\n+    pub fn new_with_denied_path(name: RcStr, root: RcStr, denied_path: RcStr) -> Vc<Self> {\n+        debug_assert!(!denied_path.is_empty(), \"denied_path must not be empty\");\n+        debug_assert!(\n+            normalize_path(&denied_path).as_deref() == Some(&*denied_path),\n+            \"denied_path must be normalized: {denied_path:?}\"\n+        );\n+        Self::new_internal(name, root, Some(denied_path))\n+    }\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl DiskFileSystem {\n     #[turbo_tasks::function]\n-    pub fn new(name: RcStr, root: RcStr) -> Result<Vc<Self>> {\n+    fn new_internal(name: RcStr, root: RcStr, denied_path: Option<RcStr>) -> Vc<Self> {\n         mark_stateful();\n \n         let instance = DiskFileSystem {\n@@ -577,10 +626,11 @@ impl DiskFileSystem {\n                 dir_invalidator_map: InvalidatorMap::new(),\n                 semaphore: create_semaphore(),\n                 watcher: DiskWatcher::new(),\n+                denied_path,\n             }),\n         };\n \n-        Ok(Self::cell(instance))\n+        Self::cell(instance)\n     }\n }\n \n@@ -595,7 +645,13 @@ impl FileSystem for DiskFileSystem {\n     #[turbo_tasks::function(fs)]\n     async fn read(&self, fs_path: FileSystemPath) -> Result<Vc<FileContent>> {\n         mark_session_dependent();\n-        let full_path = self.to_sys_path(fs_path)?;\n+\n+        // Check if path is denied - if so, treat as NotFound\n+        if self.inner.is_path_denied(&fs_path) {\n+            return Ok(FileContent::NotFound.cell());\n+        }\n+        let full_path = self.to_sys_path(&fs_path);\n+\n         self.inner.register_read_invalidator(&full_path)?;\n \n         let _lock = self.inner.lock_path(&full_path).await;\n@@ -621,7 +677,13 @@ impl FileSystem for DiskFileSystem {\n     #[turbo_tasks::function(fs)]\n     async fn raw_read_dir(&self, fs_path: FileSystemPath) -> Result<Vc<RawDirectoryContent>> {\n         mark_session_dependent();\n-        let full_path = self.to_sys_path(fs_path)?;\n+\n+        // Check if directory itself is denied - if so, treat as NotFound\n+        if self.inner.is_path_denied(&fs_path) {\n+            return Ok(RawDirectoryContent::not_found());\n+        }\n+        let full_path = self.to_sys_path(&fs_path);\n+\n         self.inner.register_dir_invalidator(&full_path)?;\n \n         // we use the sync std function here as it's a lot faster (600%) in\n@@ -646,6 +708,32 @@ impl FileSystem for DiskFileSystem {\n                 bail!(anyhow!(e).context(format!(\"reading dir {}\", full_path.display())))\n             }\n         };\n+        let denied_entry = match self.inner.denied_path.as_ref() {\n+            Some(denied_path) => {\n+                // If we have a denied path, we need to see if the current directory is a prefix of\n+                // the denied path meaning that it is possible that some directory entry needs to be\n+                // filtered. we do this first to avoid string manipulation on every\n+                // iteration of the directory entries. So while expanding `foo/bar`,\n+                // if `foo/bar/baz` is denied, we filter out `baz`.\n+                // But if foo/bar/baz/qux is denied we don't filter anything from this level.\n+                let dir_path = fs_path.path.as_str();\n+                if denied_path.starts_with(dir_path) {\n+                    let denied_path_suffix =\n+                        if denied_path.as_bytes().get(dir_path.len()) == Some(&b'/') {\n+                            Some(&denied_path[dir_path.len() + 1..])\n+                        } else if dir_path.is_empty() {\n+                            Some(denied_path.as_str())\n+                        } else {\n+                            None\n+                        };\n+                    // if the suffix is `foo/bar` we cannot filter foo from this level\n+                    denied_path_suffix.filter(|s| !s.contains('/'))\n+                } else {\n+                    None\n+                }\n+            }\n+            None => None,\n+        };\n \n         let entries = read_dir\n             .filter_map(|r| {\n@@ -655,7 +743,13 @@ impl FileSystem for DiskFileSystem {\n                 };\n \n                 // we filter out any non unicode names\n-                let file_name = e.file_name().to_str()?.into();\n+                let file_name: RcStr = e.file_name().to_str()?.into();\n+                // Filter out denied entries\n+                if let Some(denied_name) = denied_entry\n+                    && denied_name == file_name.as_str()\n+                {\n+                    return None;\n+                }\n \n                 let entry = match e.file_type() {\n                     Ok(t) if t.is_file() => RawDirectoryEntry::File,\n@@ -676,7 +770,13 @@ impl FileSystem for DiskFileSystem {\n     #[turbo_tasks::function(fs)]\n     async fn read_link(&self, fs_path: FileSystemPath) -> Result<Vc<LinkContent>> {\n         mark_session_dependent();\n-        let full_path = self.to_sys_path(fs_path.clone())?;\n+\n+        // Check if path is denied - if so, treat as NotFound\n+        if self.inner.is_path_denied(&fs_path) {\n+            return Ok(LinkContent::NotFound.cell());\n+        }\n+        let full_path = self.to_sys_path(&fs_path);\n+\n         self.inner.register_read_invalidator(&full_path)?;\n \n         let _lock = self.inner.lock_path(&full_path).await;\n@@ -766,8 +866,17 @@ impl FileSystem for DiskFileSystem {\n         // `write` purely declares a side effect and does not need to be reexecuted in the next\n         // session. All side effects are reexecuted in general.\n \n-        let full_path = self.to_sys_path(fs_path)?;\n+        // Check if path is denied - if so, return an error\n+        if self.inner.is_path_denied(&fs_path) {\n+            bail!(\n+                \"Cannot write to denied path: {}\",\n+                fs_path.value_to_string().await?\n+            );\n+        }\n+        let full_path = self.to_sys_path(&fs_path);\n+\n         let content = content.await?;\n+\n         let inner = self.inner.clone();\n         let invalidator = turbo_tasks::get_invalidator();\n \n@@ -906,7 +1015,15 @@ impl FileSystem for DiskFileSystem {\n         // `write_link` purely declares a side effect and does not need to be reexecuted in the next\n         // session. All side effects are reexecuted in general.\n \n-        let full_path = self.to_sys_path(fs_path)?;\n+        // Check if path is denied - if so, return an error\n+        if self.inner.is_path_denied(&fs_path) {\n+            bail!(\n+                \"Cannot write link to denied path: {}\",\n+                fs_path.value_to_string().await?\n+            );\n+        }\n+        let full_path = self.to_sys_path(&fs_path);\n+\n         let content = target.await?;\n         let inner = self.inner.clone();\n         let invalidator = turbo_tasks::get_invalidator();\n@@ -1035,7 +1152,16 @@ impl FileSystem for DiskFileSystem {\n     #[turbo_tasks::function(fs)]\n     async fn metadata(&self, fs_path: FileSystemPath) -> Result<Vc<FileMeta>> {\n         mark_session_dependent();\n-        let full_path = self.to_sys_path(fs_path)?;\n+        let full_path = self.to_sys_path(&fs_path);\n+\n+        // Check if path is denied - if so, return an error (metadata shouldn't be readable)\n+        if self.inner.is_path_denied(&fs_path) {\n+            bail!(\n+                \"Cannot read metadata from denied path: {}\",\n+                fs_path.value_to_string().await?\n+            );\n+        }\n+\n         self.inner.register_read_invalidator(&full_path)?;\n \n         let _lock = self.inner.lock_path(&full_path).await;\n@@ -2374,7 +2500,7 @@ pub async fn to_sys_path(mut path: FileSystemPath) -> Result<Option<PathBuf>> {\n         }\n \n         if let Some(fs) = ResolvedVc::try_downcast_type::<DiskFileSystem>(path.fs) {\n-            let sys_path = fs.await?.to_sys_path(path)?;\n+            let sys_path = fs.await?.to_sys_path(&path);\n             return Ok(Some(sys_path));\n         }\n \n@@ -2710,4 +2836,283 @@ mod tests {\n         .await\n         .unwrap();\n     }\n+\n+    // Test helpers for denied_path tests\n+    #[cfg(test)]\n+    mod denied_path_tests {\n+        use std::{\n+            fs::{File, create_dir_all},\n+            io::Write,\n+        };\n+\n+        use turbo_rcstr::{RcStr, rcstr};\n+        use turbo_tasks_backend::{BackendOptions, TurboTasksBackend, noop_backing_storage};\n+\n+        use crate::{\n+            DirectoryContent, DiskFileSystem, File as TurboFile, FileContent, FileSystem,\n+            FileSystemPath,\n+            glob::{Glob, GlobOptions},\n+        };\n+\n+        /// Helper to set up a test filesystem with denied_path\n+        /// Creates the filesystem structure on disk and returns paths\n+        fn setup_test_fs() -> (tempfile::TempDir, RcStr, RcStr) {\n+            let scratch = tempfile::tempdir().unwrap();\n+            let path = scratch.path();\n+\n+            // Create standard test structure:\n+            // /allowed_file.txt\n+            // /allowed_dir/file.txt\n+            // /other_file.txt\n+            // /denied_dir/secret.txt\n+            // /denied_dir/nested/deep.txt\n+            File::create_new(path.join(\"allowed_file.txt\"))\n+                .unwrap()\n+                .write_all(b\"allowed content\")\n+                .unwrap();\n+\n+            create_dir_all(path.join(\"allowed_dir\")).unwrap();\n+            File::create_new(path.join(\"allowed_dir/file.txt\"))\n+                .unwrap()\n+                .write_all(b\"allowed dir content\")\n+                .unwrap();\n+\n+            File::create_new(path.join(\"other_file.txt\"))\n+                .unwrap()\n+                .write_all(b\"other content\")\n+                .unwrap();\n+\n+            create_dir_all(path.join(\"denied_dir/nested\")).unwrap();\n+            File::create_new(path.join(\"denied_dir/secret.txt\"))\n+                .unwrap()\n+                .write_all(b\"secret content\")\n+                .unwrap();\n+            File::create_new(path.join(\"denied_dir/nested/deep.txt\"))\n+                .unwrap()\n+                .write_all(b\"deep secret\")\n+                .unwrap();\n+\n+            let root: RcStr = path.to_str().unwrap().into();\n+            // denied_path should be relative to root, using unix separators\n+            let denied_path: RcStr = rcstr!(\"denied_dir\");\n+\n+            (scratch, root, denied_path)\n+        }\n+\n+        #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n+        async fn test_denied_path_read() {\n+            let (_scratch, root, denied_path) = setup_test_fs();\n+            let tt = turbo_tasks::TurboTasks::new(TurboTasksBackend::new(\n+                BackendOptions::default(),\n+                noop_backing_storage(),\n+            ));\n+\n+            tt.run_once(async {\n+                let fs = DiskFileSystem::new_with_denied_path(rcstr!(\"test\"), root, denied_path);\n+                let root_path = fs.root().await?;\n+\n+                // Test 1: Reading allowed file should work\n+                let allowed_file = root_path.join(\"allowed_file.txt\")?;\n+                let content = allowed_file.read().await?;\n+                assert!(\n+                    matches!(&*content, FileContent::Content(_)),\n+                    \"allowed file should be readable\"\n+                );\n+\n+                // Test 2: Direct read of denied file should return NotFound\n+                let denied_file = root_path.join(\"denied_dir/secret.txt\")?;\n+                let content = denied_file.read().await?;\n+                assert!(\n+                    matches!(&*content, FileContent::NotFound),\n+                    \"denied file should return NotFound, got {:?}\",\n+                    content\n+                );\n+\n+                // Test 3: Reading nested denied file should return NotFound\n+                let nested_denied = root_path.join(\"denied_dir/nested/deep.txt\")?;\n+                let content = nested_denied.read().await?;\n+                assert!(\n+                    matches!(&*content, FileContent::NotFound),\n+                    \"nested denied file should return NotFound\"\n+                );\n+\n+                // Test 4: Reading the denied directory itself should return NotFound\n+                let denied_dir = root_path.join(\"denied_dir\")?;\n+                let content = denied_dir.read().await?;\n+                assert!(\n+                    matches!(&*content, FileContent::NotFound),\n+                    \"denied directory should return NotFound\"\n+                );\n+\n+                anyhow::Ok(())\n+            })\n+            .await\n+            .unwrap();\n+        }\n+\n+        #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n+        async fn test_denied_path_read_dir() {\n+            let (_scratch, root, denied_path) = setup_test_fs();\n+            let tt = turbo_tasks::TurboTasks::new(TurboTasksBackend::new(\n+                BackendOptions::default(),\n+                noop_backing_storage(),\n+            ));\n+\n+            tt.run_once(async {\n+                let fs = DiskFileSystem::new_with_denied_path(rcstr!(\"test\"), root, denied_path);\n+                let root_path = fs.root().await?;\n+\n+                // Test: read_dir on root should not include denied_dir\n+                let dir_content = root_path.read_dir().await?;\n+                match &*dir_content {\n+                    DirectoryContent::Entries(entries) => {\n+                        assert!(\n+                            entries.contains_key(&rcstr!(\"allowed_dir\")),\n+                            \"allowed_dir should be visible\"\n+                        );\n+                        assert!(\n+                            entries.contains_key(&rcstr!(\"other_file.txt\")),\n+                            \"other_file.txt should be visible\"\n+                        );\n+                        assert!(\n+                            entries.contains_key(&rcstr!(\"allowed_file.txt\")),\n+                            \"allowed_file.txt should be visible\"\n+                        );\n+                        assert!(\n+                            !entries.contains_key(&rcstr!(\"denied_dir\")),\n+                            \"denied_dir should NOT be visible in read_dir\"\n+                        );\n+                    }\n+                    DirectoryContent::NotFound => panic!(\"root directory should exist\"),\n+                }\n+\n+                // Test: read_dir on denied_dir should return NotFound\n+                let denied_dir = root_path.join(\"denied_dir\")?;\n+                let dir_content = denied_dir.read_dir().await?;\n+                assert!(\n+                    matches!(&*dir_content, DirectoryContent::NotFound),\n+                    \"denied_dir read_dir should return NotFound\"\n+                );\n+\n+                anyhow::Ok(())\n+            })\n+            .await\n+            .unwrap();\n+        }\n+\n+        #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n+        async fn test_denied_path_read_glob() {\n+            let (_scratch, root, denied_path) = setup_test_fs();\n+            let tt = turbo_tasks::TurboTasks::new(TurboTasksBackend::new(\n+                BackendOptions::default(),\n+                noop_backing_storage(),\n+            ));\n+\n+            tt.run_once(async {\n+                let fs = DiskFileSystem::new_with_denied_path(rcstr!(\"test\"), root, denied_path);\n+                let root_path = fs.root().await?;\n+\n+                // Test: read_glob with ** should not reveal denied files\n+                let glob_result = root_path\n+                    .read_glob(Glob::new(rcstr!(\"**/*.txt\"), GlobOptions::default()))\n+                    .await?;\n+\n+                // Check top level results\n+                assert!(\n+                    glob_result.results.contains_key(\"allowed_file.txt\"),\n+                    \"allowed_file.txt should be found\"\n+                );\n+                assert!(\n+                    glob_result.results.contains_key(\"other_file.txt\"),\n+                    \"other_file.txt should be found\"\n+                );\n+                assert!(\n+                    !glob_result.results.contains_key(\"denied_dir\"),\n+                    \"denied_dir should NOT appear in glob results\"\n+                );\n+\n+                // Check that denied_dir doesn't appear in inner results\n+                assert!(\n+                    !glob_result.inner.contains_key(\"denied_dir\"),\n+                    \"denied_dir should NOT appear in glob inner results\"\n+                );\n+\n+                // Verify allowed_dir is present (to ensure we're not filtering everything)\n+                assert!(\n+                    glob_result.inner.contains_key(\"allowed_dir\"),\n+                    \"allowed_dir directory should be present\"\n+                );\n+                let sub_inner = glob_result.inner.get(\"allowed_dir\").unwrap().await?;\n+                assert!(\n+                    sub_inner.results.contains_key(\"file.txt\"),\n+                    \"allowed_dir/file.txt should be found\"\n+                );\n+\n+                anyhow::Ok(())\n+            })\n+            .await\n+            .unwrap();\n+        }\n+\n+        #[turbo_tasks::function(operation)]\n+        async fn write_file(path: FileSystemPath, contents: RcStr) -> anyhow::Result<()> {\n+            path.write(\n+                FileContent::Content(TurboFile::from_bytes(contents.to_string().into_bytes()))\n+                    .cell(),\n+            )\n+            .await?;\n+            Ok(())\n+        }\n+\n+        #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n+        async fn test_denied_path_write() {\n+            use turbo_tasks::apply_effects;\n+\n+            let (_scratch, root, denied_path) = setup_test_fs();\n+            let tt = turbo_tasks::TurboTasks::new(TurboTasksBackend::new(\n+                BackendOptions::default(),\n+                noop_backing_storage(),\n+            ));\n+\n+            tt.run_once(async {\n+                let fs = DiskFileSystem::new_with_denied_path(rcstr!(\"test\"), root, denied_path);\n+                let root_path = fs.root().await?;\n+\n+                // Test 1: Writing to allowed directory should work\n+                let allowed_file = root_path.join(\"allowed_dir/new_file.txt\")?;\n+                let write_result = write_file(allowed_file.clone(), rcstr!(\"test content\"));\n+                write_result.read_strongly_consistent().await?;\n+                apply_effects(write_result).await?;\n+\n+                // Verify it was written\n+                let read_content = allowed_file.read().await?;\n+                assert!(\n+                    matches!(&*read_content, FileContent::Content(_)),\n+                    \"allowed file write should succeed\"\n+                );\n+\n+                // Test 2: Writing to denied directory should fail\n+                let denied_file = root_path.join(\"denied_dir/forbidden.txt\")?;\n+                let write_result = write_file(denied_file, rcstr!(\"forbidden\"));\n+                let result = write_result.read_strongly_consistent().await;\n+                assert!(\n+                    result.is_err(),\n+                    \"writing to denied path should return an error\"\n+                );\n+\n+                // Test 3: Writing to nested denied path should fail\n+                let nested_denied = root_path.join(\"denied_dir/nested/file.txt\")?;\n+                let write_result = write_file(nested_denied, rcstr!(\"nested\"));\n+                let result = write_result.read_strongly_consistent().await;\n+                assert!(\n+                    result.is_err(),\n+                    \"writing to nested denied path should return an error\"\n+                );\n+\n+                anyhow::Ok(())\n+            })\n+            .await\n+            .unwrap();\n+        }\n+    }\n }"
        },
        {
            "sha": "8bd568f77a8a757f4e625e3a0fa3f337ebc4c81d",
            "filename": "turbopack/crates/turbo-tasks-fs/src/util.rs",
            "status": "modified",
            "additions": 16,
            "deletions": 14,
            "changes": 30,
            "blob_url": "https://github.com/vercel/next.js/blob/d917d2e45fe952bba3aa235d1bdb047d863e1782/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Futil.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d917d2e45fe952bba3aa235d1bdb047d863e1782/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Futil.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Futil.rs?ref=d917d2e45fe952bba3aa235d1bdb047d863e1782",
            "patch": "@@ -28,20 +28,21 @@ pub async fn uri_from_file(root: FileSystemPath, path: Option<&str>) -> Result<S\n         .context(\"Expected root to have a DiskFileSystem\")?\n         .await?;\n \n+    let path = match path {\n+        Some(path) => root.join(path)?,\n+        None => root,\n+    };\n+\n+    let sys_path = root_fs.to_sys_path(&path);\n+    let sys_path = sys_path.to_string_lossy();\n+\n     Ok(format!(\n         \"file://{}\",\n-        &sys_to_unix(\n-            &root_fs\n-                .to_sys_path(match path {\n-                    Some(path) => root.join(path)?,\n-                    None => root,\n-                })?\n-                .to_string_lossy()\n-        )\n-        .split('/')\n-        .map(|s| urlencoding::encode(s))\n-        .collect::<Vec<_>>()\n-        .join(\"/\")\n+        sys_to_unix(&sys_path)\n+            .split('/')\n+            .map(|s| urlencoding::encode(s))\n+            .collect::<Vec<_>>()\n+            .join(\"/\")\n     ))\n }\n \n@@ -52,10 +53,11 @@ pub async fn uri_from_file(root: FileSystemPath, path: Option<&str>) -> Result<S\n         .context(\"Expected root to have a DiskFileSystem\")?\n         .await?;\n \n-    let sys_path = root_fs.to_sys_path(match path {\n+    let sys_path = match path {\n         Some(path) => root.join(path.into())?,\n         None => root,\n-    })?;\n+    };\n+    let sys_path = root_fs.to_sys_path(&sys_path);\n \n     let raw_path = sys_path.to_string_lossy().to_string();\n     let normalized_path = raw_path.replace('\\\\', \"/\");"
        },
        {
            "sha": "64dfac9a1c7242629f28ee356a34419005d4fec0",
            "filename": "turbopack/crates/turbo-unix-path/src/lib.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/d917d2e45fe952bba3aa235d1bdb047d863e1782/turbopack%2Fcrates%2Fturbo-unix-path%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d917d2e45fe952bba3aa235d1bdb047d863e1782/turbopack%2Fcrates%2Fturbo-unix-path%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-unix-path%2Fsrc%2Flib.rs?ref=d917d2e45fe952bba3aa235d1bdb047d863e1782",
            "patch": "@@ -34,6 +34,7 @@ pub fn unix_to_sys(path: &str) -> Cow<'_, str> {\n /// Paths are concatenated with /.\n ///\n /// see also [normalize_path] for normalization.\n+/// Returns `None` if the joined path would leave the filesystem root.\n pub fn join_path(fs_path: &str, join: &str) -> Option<String> {\n     // Paths that we join are written as source code (eg, `join_path(fs_path, \"foo/bar.js\")`) and\n     // it's expected that they will never contain a backslash."
        },
        {
            "sha": "4548dc2a3e653c5541592cb6f62643e67d2fcae9",
            "filename": "turbopack/crates/turbopack-cli/Cargo.toml",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/d917d2e45fe952bba3aa235d1bdb047d863e1782/turbopack%2Fcrates%2Fturbopack-cli%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/d917d2e45fe952bba3aa235d1bdb047d863e1782/turbopack%2Fcrates%2Fturbopack-cli%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-cli%2FCargo.toml?ref=d917d2e45fe952bba3aa235d1bdb047d863e1782",
            "patch": "@@ -53,6 +53,7 @@ turbo-rcstr = { workspace = true }\n turbo-tasks = { workspace = true }\n turbo-tasks-backend = { workspace = true }\n turbo-tasks-env = { workspace = true }\n+turbo-unix-path = { workspace = true }\n turbo-tasks-fs = { workspace = true }\n turbo-tasks-malloc = { workspace = true, default-features = false }\n turbopack = { workspace = true }"
        },
        {
            "sha": "a8ff9c00aae17a4516aaf2c41ae64787d48b0245",
            "filename": "turbopack/crates/turbopack-cli/src/build/mod.rs",
            "status": "modified",
            "additions": 11,
            "deletions": 3,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/d917d2e45fe952bba3aa235d1bdb047d863e1782/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fbuild%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d917d2e45fe952bba3aa235d1bdb047d863e1782/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fbuild%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fbuild%2Fmod.rs?ref=d917d2e45fe952bba3aa235d1bdb047d863e1782",
            "patch": "@@ -14,6 +14,7 @@ use turbo_tasks_backend::{\n     BackendOptions, NoopBackingStorage, TurboTasksBackend, noop_backing_storage,\n };\n use turbo_tasks_fs::FileSystem;\n+use turbo_unix_path::join_path;\n use turbopack::{\n     css::chunk::CssChunkType, ecmascript::chunk::EcmascriptChunkType,\n     global_module_ids::get_global_module_id_strategy,\n@@ -195,21 +196,28 @@ async fn build_internal(\n     scope_hoist: bool,\n ) -> Result<Vc<()>> {\n     let output_fs = output_fs(project_dir.clone());\n-    let project_fs = project_fs(root_dir.clone(), /* watch= */ false);\n+    const OUTPUT_DIR: &str = \"dist\";\n     let project_relative = project_dir.strip_prefix(&*root_dir).unwrap();\n     let project_relative: RcStr = project_relative\n         .strip_prefix(MAIN_SEPARATOR)\n         .unwrap_or(project_relative)\n         .replace(MAIN_SEPARATOR, \"/\")\n         .into();\n+    let project_fs = project_fs(\n+        root_dir.clone(),\n+        /* watch= */ false,\n+        join_path(project_relative.as_str(), OUTPUT_DIR)\n+            .unwrap()\n+            .into(),\n+    );\n     let root_path = project_fs.root().owned().await?;\n     let project_path = root_path.join(&project_relative)?;\n-    let build_output_root = output_fs.root().await?.join(\"dist\")?;\n+    let build_output_root = output_fs.root().await?.join(OUTPUT_DIR)?;\n \n     let node_env = NodeEnv::Production.cell();\n \n     let build_output_root_to_root_path = project_path\n-        .join(\"dist\")?\n+        .join(OUTPUT_DIR)?\n         .get_relative_path_to(&root_path)\n         .context(\"Project path is in root path\")?;\n "
        },
        {
            "sha": "143f520913c2ba844764fd46a18e6f12730e39e7",
            "filename": "turbopack/crates/turbopack-cli/src/dev/mod.rs",
            "status": "modified",
            "additions": 11,
            "deletions": 3,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/d917d2e45fe952bba3aa235d1bdb047d863e1782/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fdev%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d917d2e45fe952bba3aa235d1bdb047d863e1782/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fdev%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fdev%2Fmod.rs?ref=d917d2e45fe952bba3aa235d1bdb047d863e1782",
            "patch": "@@ -22,6 +22,7 @@ use turbo_tasks_backend::{\n };\n use turbo_tasks_fs::FileSystem;\n use turbo_tasks_malloc::TurboMalloc;\n+use turbo_unix_path::join_path;\n use turbopack::evaluate_context::node_build_environment;\n use turbopack_cli_utils::issue::{ConsoleUi, LogOptions};\n use turbopack_core::{\n@@ -265,15 +266,22 @@ async fn source(\n         .into();\n \n     let output_fs = output_fs(project_dir);\n-    let fs: Vc<Box<dyn FileSystem>> = project_fs(root_dir, /* watch= */ true);\n+    const OUTPUT_DIR: &str = \".turbopack/build\";\n+    let fs: Vc<Box<dyn FileSystem>> = project_fs(\n+        root_dir,\n+        /* watch= */ true,\n+        join_path(project_relative.as_str(), OUTPUT_DIR)\n+            .unwrap()\n+            .into(),\n+    );\n     let root_path = fs.root().owned().await?;\n     let project_path = root_path.join(&project_relative)?;\n \n     let env = load_env(root_path.clone());\n-    let build_output_root = output_fs.root().await?.join(\".turbopack/build\")?;\n+    let build_output_root = output_fs.root().await?.join(OUTPUT_DIR)?;\n \n     let build_output_root_to_root_path = project_path\n-        .join(\".turbopack/build\")?\n+        .join(OUTPUT_DIR)?\n         .get_relative_path_to(&root_path)\n         .context(\"Project path is in root path\")?;\n     let build_output_root_to_root_path = build_output_root_to_root_path;"
        },
        {
            "sha": "5d533b7b492c3685fd7e4236e9628aeacf1a7e54",
            "filename": "turbopack/crates/turbopack-cli/src/util.rs",
            "status": "modified",
            "additions": 7,
            "deletions": 2,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/d917d2e45fe952bba3aa235d1bdb047d863e1782/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Futil.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d917d2e45fe952bba3aa235d1bdb047d863e1782/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Futil.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Futil.rs?ref=d917d2e45fe952bba3aa235d1bdb047d863e1782",
            "patch": "@@ -60,8 +60,13 @@ pub fn normalize_entries(entries: &Option<Vec<String>>) -> Vec<RcStr> {\n }\n \n #[turbo_tasks::function]\n-pub async fn project_fs(project_dir: RcStr, watch: bool) -> Result<Vc<Box<dyn FileSystem>>> {\n-    let disk_fs = DiskFileSystem::new(rcstr!(\"project\"), project_dir);\n+pub async fn project_fs(\n+    project_dir: RcStr,\n+    watch: bool,\n+    denied_root_path: RcStr,\n+) -> Result<Vc<Box<dyn FileSystem>>> {\n+    let disk_fs =\n+        DiskFileSystem::new_with_denied_path(rcstr!(\"project\"), project_dir, denied_root_path);\n     if watch {\n         disk_fs.await?.start_watching(None).await?;\n     }"
        },
        {
            "sha": "f7424131764dcf39649a92d542b83499d1f0ad2f",
            "filename": "turbopack/crates/turbopack-nft/src/nft.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/d917d2e45fe952bba3aa235d1bdb047d863e1782/turbopack%2Fcrates%2Fturbopack-nft%2Fsrc%2Fnft.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d917d2e45fe952bba3aa235d1bdb047d863e1782/turbopack%2Fcrates%2Fturbopack-nft%2Fsrc%2Fnft.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-nft%2Fsrc%2Fnft.rs?ref=d917d2e45fe952bba3aa235d1bdb047d863e1782",
            "patch": "@@ -102,7 +102,7 @@ async fn node_file_trace_operation(\n         .cell(),\n         ResolveOptionsContext {\n             enable_node_native_modules: true,\n-            enable_node_modules: Some(input_dir.clone()),\n+            enable_node_modules: Some(input_dir),\n             custom_conditions: vec![rcstr!(\"node\")],\n             loose_errors: true,\n             collect_affecting_sources: true,"
        }
    ],
    "stats": {
        "total": 681,
        "additions": 599,
        "deletions": 82
    }
}