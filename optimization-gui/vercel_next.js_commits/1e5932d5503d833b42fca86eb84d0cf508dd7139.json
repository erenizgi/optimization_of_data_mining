{
    "author": "lubieowoce",
    "message": "[Runtime prefetch] resolve runtime APIs in a separate task (#82475)\n\nIn a runtime prefetch, sync IO is dangerous, because it makes us abort\nthe whole prerender. If this abort happens early, a runtime prefetch can\nend up giving us *less* data than a static prefetch. To prevent this, we\ncan split the final prerender into two separate tasks (which i'm calling\n\"stages\" in the code):\n1. The static stage (task 1). This is meant to be equivalent to what\nwe'd do during build, so runtime APIs like `cookies()` aren't resolved\nyet. This lets us render everything that's reachable statically. We\nshould not hit a sync IO here -- if we had, it would've also caused an\nerror during build.\n2. The runtime stage (task 2). Here, we allow `cookies()` (and all other\nruntime APIs available in a runtime prerender) to resolve. We might\nencounter sync IO errors here (e.g. `await cookies(); Date.now()`),\nwhich will make the result suboptimal, but still usable.",
    "sha": "1e5932d5503d833b42fca86eb84d0cf508dd7139",
    "files": [
        {
            "sha": "936302f7816a1778feb8f3004e1c87d2b148b3fa",
            "filename": "packages/next/errors.json",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/1e5932d5503d833b42fca86eb84d0cf508dd7139/packages%2Fnext%2Ferrors.json",
            "raw_url": "https://github.com/vercel/next.js/raw/1e5932d5503d833b42fca86eb84d0cf508dd7139/packages%2Fnext%2Ferrors.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Ferrors.json?ref=1e5932d5503d833b42fca86eb84d0cf508dd7139",
            "patch": "@@ -775,5 +775,6 @@\n   \"774\": \"Route %s used %s outside of a Server Component. This is not allowed.\",\n   \"775\": \"Node.js instrumentation extensions should not be loaded in the Edge runtime.\",\n   \"776\": \"`unstable_isUnrecognizedActionError` can only be used on the client.\",\n-  \"777\": \"Invariant: failed to find source route %s for prerender %s\"\n+  \"777\": \"Invariant: failed to find source route %s for prerender %s\",\n+  \"778\": \"`prerenderAndAbortInSequentialTasksWithStages` should not be called in edge runtime.\"\n }"
        },
        {
            "sha": "884a84aeb46a16c4e42a5f137c26edaf579bf088",
            "filename": "packages/next/src/client/components/segment-cache-impl/cache.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 11,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/1e5932d5503d833b42fca86eb84d0cf508dd7139/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1e5932d5503d833b42fca86eb84d0cf508dd7139/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts?ref=1e5932d5503d833b42fca86eb84d0cf508dd7139",
            "patch": "@@ -78,6 +78,7 @@ import {\n   doesExportedHtmlMatchBuildId,\n } from '../../../shared/lib/segment-cache/output-export-prefetch-encoding'\n import { FetchStrategy } from '../segment-cache'\n+import { createPromiseWithResolvers } from '../../../shared/lib/promise-with-resolvers'\n \n // A note on async/await when working in the prefetch cache:\n //\n@@ -2050,17 +2051,6 @@ function addSegmentPathToUrlInOutputExportMode(\n   return url\n }\n \n-function createPromiseWithResolvers<T>(): PromiseWithResolvers<T> {\n-  // Shim of Stage 4 Promise.withResolvers proposal\n-  let resolve: (value: T | PromiseLike<T>) => void\n-  let reject: (reason: any) => void\n-  const promise = new Promise<T>((res, rej) => {\n-    resolve = res\n-    reject = rej\n-  })\n-  return { resolve: resolve!, reject: reject!, promise }\n-}\n-\n /**\n  * Checks whether the new fetch strategy is likely to provide more content than the old one.\n  *"
        },
        {
            "sha": "b8bdc955621378fb33ab4e2021ed721da91d8977",
            "filename": "packages/next/src/server/app-render/app-render-prerender-utils.ts",
            "status": "modified",
            "additions": 35,
            "deletions": 0,
            "changes": 35,
            "blob_url": "https://github.com/vercel/next.js/blob/1e5932d5503d833b42fca86eb84d0cf508dd7139/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render-prerender-utils.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1e5932d5503d833b42fca86eb84d0cf508dd7139/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render-prerender-utils.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render-prerender-utils.ts?ref=1e5932d5503d833b42fca86eb84d0cf508dd7139",
            "patch": "@@ -31,6 +31,41 @@ export function prerenderAndAbortInSequentialTasks<R>(\n   }\n }\n \n+/**\n+ * Like `prerenderAndAbortInSequentialTasks`, but with another task between `prerender` and `abort`,\n+ * which allows us to move a part of the render into a separate task.\n+ */\n+export function prerenderAndAbortInSequentialTasksWithStages<R>(\n+  prerender: () => Promise<R>,\n+  advanceStage: () => void,\n+  abort: () => void\n+): Promise<R> {\n+  if (process.env.NEXT_RUNTIME === 'edge') {\n+    throw new InvariantError(\n+      '`prerenderAndAbortInSequentialTasksWithStages` should not be called in edge runtime.'\n+    )\n+  } else {\n+    return new Promise((resolve, reject) => {\n+      let pendingResult: Promise<R>\n+      setImmediate(() => {\n+        try {\n+          pendingResult = prerender()\n+          pendingResult.catch(() => {})\n+        } catch (err) {\n+          reject(err)\n+        }\n+      })\n+      setImmediate(() => {\n+        advanceStage()\n+      })\n+      setImmediate(() => {\n+        abort()\n+        resolve(pendingResult)\n+      })\n+    })\n+  }\n+}\n+\n // React's RSC prerender function will emit an incomplete flight stream when using `prerender`. If the connection\n // closes then whatever hanging chunks exist will be errored. This is because prerender (an experimental feature)\n // has not yet implemented a concept of resume. For now we will simulate a paused connection by wrapping the stream"
        },
        {
            "sha": "02897a6194e1310a9ba2868e3f613f7433429676",
            "filename": "packages/next/src/server/app-render/app-render.tsx",
            "status": "modified",
            "additions": 25,
            "deletions": 2,
            "changes": 27,
            "blob_url": "https://github.com/vercel/next.js/blob/1e5932d5503d833b42fca86eb84d0cf508dd7139/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1e5932d5503d833b42fca86eb84d0cf508dd7139/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx?ref=1e5932d5503d833b42fca86eb84d0cf508dd7139",
            "patch": "@@ -155,7 +155,10 @@ import { createMutableActionQueue } from '../../client/components/app-router-ins\n import { getRevalidateReason } from '../instrumentation/utils'\n import { PAGE_SEGMENT_KEY } from '../../shared/lib/segment'\n import type { FallbackRouteParams } from '../request/fallback-params'\n-import { processPrelude } from './app-render-prerender-utils'\n+import {\n+  prerenderAndAbortInSequentialTasksWithStages,\n+  processPrelude,\n+} from './app-render-prerender-utils'\n import {\n   type ReactServerPrerenderResult,\n   ReactServerResult,\n@@ -200,6 +203,7 @@ import { getRequestMeta } from '../request-meta'\n import { getDynamicParam } from '../../shared/lib/router/utils/get-dynamic-param'\n import type { ExperimentalConfig } from '../config-shared'\n import type { Params } from '../request/params'\n+import { createPromiseWithResolvers } from '../../shared/lib/promise-with-resolvers'\n \n export type GetDynamicParamFromSegment = (\n   // [slug] / [[slug]] / [...slug]\n@@ -711,6 +715,8 @@ async function prospectiveRuntimeServerPrerender(\n     prerenderResumeDataCache,\n     hmrRefreshHash: undefined,\n     captureOwnerStack: undefined,\n+    // We only need task sequencing in the final prerender.\n+    runtimeStagePromise: null,\n     // These are not present in regular prerenders, but allowed in a runtime prerender.\n     cookies,\n     draftMode,\n@@ -821,6 +827,9 @@ async function finalRuntimeServerPrerender(\n     isDebugDynamicAccesses\n   )\n \n+  const { promise: runtimeStagePromise, resolve: resolveBlockedRuntimeAPIs } =\n+    createPromiseWithResolvers<void>()\n+\n   const finalServerPrerenderStore: PrerenderStoreModernRuntime = {\n     type: 'prerender-runtime',\n     phase: 'render',\n@@ -841,6 +850,8 @@ async function finalRuntimeServerPrerender(\n     renderResumeDataCache,\n     hmrRefreshHash: undefined,\n     captureOwnerStack: undefined,\n+    // Used to separate the \"Static\" stage from the \"Runtime\" stage.\n+    runtimeStagePromise,\n     // These are not present in regular prerenders, but allowed in a runtime prerender.\n     cookies,\n     draftMode,\n@@ -852,8 +863,9 @@ async function finalRuntimeServerPrerender(\n   )\n \n   let prerenderIsPending = true\n-  const result = await prerenderAndAbortInSequentialTasks(\n+  const result = await prerenderAndAbortInSequentialTasksWithStages(\n     async () => {\n+      // Static stage\n       const prerenderResult = await workUnitAsyncStorage.run(\n         finalServerPrerenderStore,\n         ComponentMod.prerender,\n@@ -869,6 +881,17 @@ async function finalRuntimeServerPrerender(\n       return prerenderResult\n     },\n     () => {\n+      // Advance to the runtime stage.\n+      //\n+      // We make runtime APIs hang during the first task (above), and unblock them in the following task (here).\n+      // This makes sure that, at this point, we'll have finished all the static parts (what we'd prerender statically).\n+      // We know that they don't contain any incorrect sync IO, because that'd have caused a build error.\n+      // After we unblock Runtime APIs, if we encounter sync IO (e.g. `await cookies(); Date.now()`),\n+      // we'll abort, but we'll produce at least as much output as a static prerender would.\n+      resolveBlockedRuntimeAPIs()\n+    },\n+    () => {\n+      // Abort.\n       if (finalServerController.signal.aborted) {\n         // If the server controller is already aborted we must have called something\n         // that required aborting the prerender synchronously such as with new Date()"
        },
        {
            "sha": "54ab827733705cc543dfef1f7bf6fbc4590e53bf",
            "filename": "packages/next/src/server/app-render/dynamic-rendering.ts",
            "status": "modified",
            "additions": 30,
            "deletions": 3,
            "changes": 33,
            "blob_url": "https://github.com/vercel/next.js/blob/1e5932d5503d833b42fca86eb84d0cf508dd7139/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fdynamic-rendering.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1e5932d5503d833b42fca86eb84d0cf508dd7139/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fdynamic-rendering.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fdynamic-rendering.ts?ref=1e5932d5503d833b42fca86eb84d0cf508dd7139",
            "patch": "@@ -26,14 +26,18 @@ import type {\n   RequestStore,\n   PrerenderStoreLegacy,\n   PrerenderStoreModern,\n+  PrerenderStoreModernRuntime,\n } from '../app-render/work-unit-async-storage.external'\n \n // Once postpone is in stable we should switch to importing the postpone export directly\n import React from 'react'\n \n import { DynamicServerError } from '../../client/components/hooks-server-context'\n import { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\n-import { workUnitAsyncStorage } from './work-unit-async-storage.external'\n+import {\n+  getRuntimeStagePromise,\n+  workUnitAsyncStorage,\n+} from './work-unit-async-storage.external'\n import { workAsyncStorage } from '../app-render/work-async-storage.external'\n import { makeHangingPromise } from '../dynamic-rendering-utils'\n import {\n@@ -548,12 +552,25 @@ export function createHangingInputAbortSignal(\n         })\n       } else {\n         // Otherwise we're in the final render and we should already have all\n-        // our caches filled. We might still be waiting on some microtasks so we\n+        // our caches filled.\n+        // If the prerender uses stages, we have wait until the runtime stage,\n+        // at which point all runtime inputs will be resolved.\n+        // (otherwise, a runtime prerender might consider `cookies()` hanging\n+        //  even though they'd resolve in the next task.)\n+        //\n+        // We might still be waiting on some microtasks so we\n         // wait one tick before giving up. When we give up, we still want to\n         // render the content of this cache as deeply as we can so that we can\n         // suspend as deeply as possible in the tree or not at all if we don't\n         // end up waiting for the input.\n-        scheduleOnNextTick(() => controller.abort())\n+        const runtimeStagePromise = getRuntimeStagePromise(workUnitStore)\n+        if (runtimeStagePromise) {\n+          runtimeStagePromise.then(() =>\n+            scheduleOnNextTick(() => controller.abort())\n+          )\n+        } else {\n+          scheduleOnNextTick(() => controller.abort())\n+        }\n       }\n \n       return controller.signal\n@@ -824,3 +841,13 @@ export function throwIfDisallowedDynamic(\n     }\n   }\n }\n+\n+export function delayUntilRuntimeStage<T>(\n+  prerenderStore: PrerenderStoreModernRuntime,\n+  result: Promise<T>\n+): Promise<T> {\n+  if (prerenderStore.runtimeStagePromise) {\n+    return prerenderStore.runtimeStagePromise.then(() => result)\n+  }\n+  return result\n+}"
        },
        {
            "sha": "bdf3015ac82972bff4e6c7eb867af39d354ce79b",
            "filename": "packages/next/src/server/app-render/work-unit-async-storage.external.ts",
            "status": "modified",
            "additions": 44,
            "deletions": 0,
            "changes": 44,
            "blob_url": "https://github.com/vercel/next.js/blob/1e5932d5503d833b42fca86eb84d0cf508dd7139/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwork-unit-async-storage.external.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1e5932d5503d833b42fca86eb84d0cf508dd7139/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwork-unit-async-storage.external.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwork-unit-async-storage.external.ts?ref=1e5932d5503d833b42fca86eb84d0cf508dd7139",
            "patch": "@@ -106,6 +106,18 @@ export interface PrerenderStoreModernRuntime\n   extends PrerenderStoreModernCommon {\n   readonly type: 'prerender-runtime'\n \n+  /**\n+   * A runtime prerender resolves APIs in two tasks:\n+   *\n+   * 1. Static data (available in a static prerender)\n+   * 2. Runtime data (available in a runtime prerender)\n+   *\n+   * This separation is achieved by awaiting this promise in \"runtime\" APIs.\n+   * In the final prerender, the promise will be resolved during the second task,\n+   * and the render will be aborted in the task that follows it.\n+   */\n+  readonly runtimeStagePromise: Promise<void> | null\n+\n   readonly cookies: RequestStore['cookies']\n   readonly draftMode: RequestStore['draftMode']\n }\n@@ -268,6 +280,18 @@ export interface PublicUseCacheStore extends CommonUseCacheStore {\n export interface PrivateUseCacheStore extends CommonUseCacheStore {\n   readonly type: 'private-cache'\n \n+  /**\n+   * A runtime prerender resolves APIs in two tasks:\n+   *\n+   * 1. Static data (available in a static prerender)\n+   * 2. Runtime data (available in a runtime prerender)\n+   *\n+   * This separation is achieved by awaiting this promise in \"runtime\" APIs.\n+   * In the final prerender, the promise will be resolved during the second task,\n+   * and the render will be aborted in the task that follows it.\n+   */\n+  readonly runtimeStagePromise: Promise<void> | null\n+\n   /**\n    * As opposed to the public cache store, the private cache store is allowed to\n    * access the request cookies.\n@@ -486,3 +510,23 @@ export function getCacheSignal(\n       return workUnitStore satisfies never\n   }\n }\n+\n+export function getRuntimeStagePromise(\n+  workUnitStore: WorkUnitStore\n+): Promise<void> | null {\n+  switch (workUnitStore.type) {\n+    case 'prerender-runtime':\n+    case 'private-cache':\n+      return workUnitStore.runtimeStagePromise\n+    case 'prerender':\n+    case 'prerender-client':\n+    case 'prerender-ppr':\n+    case 'prerender-legacy':\n+    case 'request':\n+    case 'cache':\n+    case 'unstable-cache':\n+      return null\n+    default:\n+      return workUnitStore satisfies never\n+  }\n+}"
        },
        {
            "sha": "450147f7ff5c79b20164cd4968fcb1e0463f76c9",
            "filename": "packages/next/src/server/request/cookies.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/1e5932d5503d833b42fca86eb84d0cf508dd7139/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fcookies.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1e5932d5503d833b42fca86eb84d0cf508dd7139/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fcookies.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fcookies.ts?ref=1e5932d5503d833b42fca86eb84d0cf508dd7139",
            "patch": "@@ -15,6 +15,7 @@ import {\n   type PrerenderStoreModern,\n } from '../app-render/work-unit-async-storage.external'\n import {\n+  delayUntilRuntimeStage,\n   postponeWithTracking,\n   throwToInterruptStaticGeneration,\n   trackDynamicDataInDynamicRender,\n@@ -118,6 +119,10 @@ export function cookies(): Promise<ReadonlyRequestCookies> {\n             workUnitStore\n           )\n         case 'prerender-runtime':\n+          return delayUntilRuntimeStage(\n+            workUnitStore,\n+            makeUntrackedExoticCookies(workUnitStore.cookies)\n+          )\n         case 'private-cache':\n           return makeUntrackedExoticCookies(workUnitStore.cookies)\n         case 'request':"
        },
        {
            "sha": "064fecbe746ab9a9b80ea5faff81d9cc357c9409",
            "filename": "packages/next/src/server/request/draft-mode.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/1e5932d5503d833b42fca86eb84d0cf508dd7139/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fdraft-mode.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1e5932d5503d833b42fca86eb84d0cf508dd7139/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fdraft-mode.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fdraft-mode.ts?ref=1e5932d5503d833b42fca86eb84d0cf508dd7139",
            "patch": "@@ -12,6 +12,7 @@ import {\n import { workUnitAsyncStorage } from '../app-render/work-unit-async-storage.external'\n import {\n   abortAndThrowOnSynchronousRequestDataAccess,\n+  delayUntilRuntimeStage,\n   postponeWithTracking,\n   trackDynamicDataInDynamicRender,\n   trackSynchronousRequestDataAccessInDev,\n@@ -56,6 +57,11 @@ export function draftMode(): Promise<DraftMode> {\n \n   switch (workUnitStore.type) {\n     case 'prerender-runtime':\n+      // TODO(runtime-ppr): does it make sense to delay this? normally it's always microtasky\n+      return delayUntilRuntimeStage(\n+        workUnitStore,\n+        createOrGetCachedDraftMode(workUnitStore.draftMode, workStore)\n+      )\n     case 'request':\n       return createOrGetCachedDraftMode(workUnitStore.draftMode, workStore)\n "
        },
        {
            "sha": "dbae1d59b45797e8d8c9bd61b319f5f32c836411",
            "filename": "packages/next/src/server/request/params.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/1e5932d5503d833b42fca86eb84d0cf508dd7139/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fparams.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1e5932d5503d833b42fca86eb84d0cf508dd7139/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fparams.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fparams.ts?ref=1e5932d5503d833b42fca86eb84d0cf508dd7139",
            "patch": "@@ -9,6 +9,7 @@ import {\n   throwToInterruptStaticGeneration,\n   postponeWithTracking,\n   trackSynchronousRequestDataAccessInDev,\n+  delayUntilRuntimeStage,\n } from '../app-render/dynamic-rendering'\n \n import {\n@@ -114,6 +115,10 @@ export function createServerParamsForRoute(\n           'createServerParamsForRoute should not be called in cache contexts.'\n         )\n       case 'prerender-runtime':\n+        return delayUntilRuntimeStage(\n+          workUnitStore,\n+          createRenderParams(underlyingParams, workStore)\n+        )\n       case 'request':\n         break\n       default:\n@@ -142,6 +147,10 @@ export function createServerParamsForServerSegment(\n           'createServerParamsForServerSegment should not be called in cache contexts.'\n         )\n       case 'prerender-runtime':\n+        return delayUntilRuntimeStage(\n+          workUnitStore,\n+          createRenderParams(underlyingParams, workStore)\n+        )\n       case 'request':\n         break\n       default:"
        },
        {
            "sha": "16c80977cd0d2a80473eb7abb9d7bb69725a7887",
            "filename": "packages/next/src/server/request/pathname.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/1e5932d5503d833b42fca86eb84d0cf508dd7139/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fpathname.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1e5932d5503d833b42fca86eb84d0cf508dd7139/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fpathname.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fpathname.ts?ref=1e5932d5503d833b42fca86eb84d0cf508dd7139",
            "patch": "@@ -1,6 +1,7 @@\n import type { WorkStore } from '../app-render/work-async-storage.external'\n \n import {\n+  delayUntilRuntimeStage,\n   postponeWithTracking,\n   type DynamicTrackingState,\n } from '../app-render/dynamic-rendering'\n@@ -37,6 +38,10 @@ export function createServerPathnameForMetadata(\n         )\n \n       case 'prerender-runtime':\n+        return delayUntilRuntimeStage(\n+          workUnitStore,\n+          createRenderPathname(underlyingPathname)\n+        )\n       case 'request':\n         break\n       default:"
        },
        {
            "sha": "27fed1583f18b564004c53b67372419e35456c68",
            "filename": "packages/next/src/server/request/search-params.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/1e5932d5503d833b42fca86eb84d0cf508dd7139/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fsearch-params.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1e5932d5503d833b42fca86eb84d0cf508dd7139/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fsearch-params.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fsearch-params.ts?ref=1e5932d5503d833b42fca86eb84d0cf508dd7139",
            "patch": "@@ -7,6 +7,7 @@ import {\n   trackDynamicDataInDynamicRender,\n   annotateDynamicAccess,\n   trackSynchronousRequestDataAccessInDev,\n+  delayUntilRuntimeStage,\n } from '../app-render/dynamic-rendering'\n \n import {\n@@ -114,6 +115,10 @@ export function createServerSearchParamsForServerPage(\n           'createServerSearchParamsForServerPage should not be called in cache contexts.'\n         )\n       case 'prerender-runtime':\n+        return delayUntilRuntimeStage(\n+          workUnitStore,\n+          createRenderSearchParams(underlyingSearchParams, workStore)\n+        )\n       case 'request':\n         break\n       default:"
        },
        {
            "sha": "52b11fd25cab58432f32ea354cc1de4cc5c936f0",
            "filename": "packages/next/src/server/use-cache/use-cache-wrapper.ts",
            "status": "modified",
            "additions": 35,
            "deletions": 1,
            "changes": 36,
            "blob_url": "https://github.com/vercel/next.js/blob/1e5932d5503d833b42fca86eb84d0cf508dd7139/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1e5932d5503d833b42fca86eb84d0cf508dd7139/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts?ref=1e5932d5503d833b42fca86eb84d0cf508dd7139",
            "patch": "@@ -34,6 +34,7 @@ import {\n   getCacheSignal,\n   isHmrRefresh,\n   getServerComponentsHmrCache,\n+  getRuntimeStagePromise,\n } from '../app-render/work-unit-async-storage.external'\n \n import { makeHangingPromise } from '../dynamic-rendering-utils'\n@@ -199,6 +200,7 @@ function createUseCacheStore(\n         outerWorkUnitStore\n       ),\n       forceRevalidate: shouldForceRevalidate(workStore, outerWorkUnitStore),\n+      runtimeStagePromise: getRuntimeStagePromise(outerWorkUnitStore),\n       draftMode: getDraftModeProviderForCacheScope(\n         workStore,\n         outerWorkUnitStore\n@@ -953,6 +955,17 @@ export function cache(\n         ? createHangingInputAbortSignal(workUnitStore)\n         : undefined\n \n+      // In a runtime prerender, we have to make sure that APIs that would hang during a static prerender\n+      // are resolved with a delay, in the runtime stage. Private caches are one of these.\n+      if (cacheContext.kind === 'private') {\n+        const runtimeStagePromise = getRuntimeStagePromise(\n+          cacheContext.outerWorkUnitStore\n+        )\n+        if (runtimeStagePromise) {\n+          await runtimeStagePromise\n+        }\n+      }\n+\n       let isPageOrLayout = false\n \n       // For page and layout components, the cache function is overwritten,\n@@ -1068,6 +1081,14 @@ export function cache(\n \n       switch (workUnitStore?.type) {\n         case 'prerender-runtime':\n+        // We're currently only using `dynamicAccessAsyncStorage` for params,\n+        // which are always available in a runtime prerender, so they will never hang,\n+        // effectively making the tracking below a no-op.\n+        // However, a runtime prerender shares a lot of the semantics with a static prerender,\n+        // and might need to follow this codepath in the future\n+        // if we start using `dynamicAccessAsyncStorage` for other APIs.\n+        //\n+        // fallthrough\n         case 'prerender':\n           if (!isPageOrLayout) {\n             // If the \"use cache\" function is not a page or a layout, we need to\n@@ -1156,7 +1177,14 @@ export function cache(\n                     workStore.route,\n                     'dynamic \"use cache\"'\n                   )\n-                case 'prerender-runtime':\n+                case 'prerender-runtime': {\n+                  // In a runtime prerender, we have to make sure that APIs that would hang during a static prerender\n+                  // are resolved with a delay, in the runtime stage.\n+                  if (workUnitStore.runtimeStagePromise) {\n+                    await workUnitStore.runtimeStagePromise\n+                  }\n+                  break\n+                }\n                 case 'prerender-ppr':\n                 case 'prerender-legacy':\n                 case 'request':\n@@ -1338,6 +1366,12 @@ export function cache(\n                 'dynamic \"use cache\"'\n               )\n             case 'prerender-runtime':\n+              // In a runtime prerender, we have to make sure that APIs that would hang during a static prerender\n+              // are resolved with a delay, in the runtime stage.\n+              if (workUnitStore.runtimeStagePromise) {\n+                await workUnitStore.runtimeStagePromise\n+              }\n+              break\n             case 'prerender-ppr':\n             case 'prerender-legacy':\n             case 'request':"
        },
        {
            "sha": "acaa2f04f8a2aa70fd65701bded36d1807f375a3",
            "filename": "packages/next/src/shared/lib/promise-with-resolvers.ts",
            "status": "added",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/1e5932d5503d833b42fca86eb84d0cf508dd7139/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fpromise-with-resolvers.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1e5932d5503d833b42fca86eb84d0cf508dd7139/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fpromise-with-resolvers.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fpromise-with-resolvers.ts?ref=1e5932d5503d833b42fca86eb84d0cf508dd7139",
            "patch": "@@ -0,0 +1,10 @@\n+export function createPromiseWithResolvers<T>(): PromiseWithResolvers<T> {\n+  // Shim of Stage 4 Promise.withResolvers proposal\n+  let resolve: (value: T | PromiseLike<T>) => void\n+  let reject: (reason: any) => void\n+  const promise = new Promise<T>((res, rej) => {\n+    resolve = res\n+    reject = rej\n+  })\n+  return { resolve: resolve!, reject: reject!, promise }\n+}"
        },
        {
            "sha": "54b66be9a1a57a4eb0141867c5b9576b0bd188a7",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-runtime/app/(default)/errors/page.tsx",
            "status": "added",
            "additions": 53,
            "deletions": 0,
            "changes": 53,
            "blob_url": "https://github.com/vercel/next.js/blob/1e5932d5503d833b42fca86eb84d0cf508dd7139/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Ferrors%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1e5932d5503d833b42fca86eb84d0cf508dd7139/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Ferrors%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Ferrors%2Fpage.tsx?ref=1e5932d5503d833b42fca86eb84d0cf508dd7139",
            "patch": "@@ -0,0 +1,53 @@\n+import { DebugLinkAccordion } from '../../../components/link-accordion'\n+\n+export default async function Page() {\n+  return (\n+    <main>\n+      <h1>Errors</h1>\n+\n+      <h2>thrown errors</h2>\n+      <ul>\n+        <li>\n+          <DebugLinkAccordion\n+            href=\"/errors/error-after-cookies\"\n+            prefetch={true}\n+          />\n+        </li>\n+      </ul>\n+\n+      <h2>sync IO</h2>\n+      <ul>\n+        <li>\n+          <DebugLinkAccordion\n+            href=\"/errors/sync-io-after-runtime-api/cookies\"\n+            prefetch={true}\n+          />\n+        </li>\n+        <li>\n+          <DebugLinkAccordion\n+            href=\"/errors/sync-io-after-runtime-api/dynamic-params/123\"\n+            prefetch={true}\n+          />\n+        </li>\n+        <li>\n+          <DebugLinkAccordion\n+            href=\"/errors/sync-io-after-runtime-api/search-params?foo=bar\"\n+            prefetch={true}\n+          />\n+        </li>\n+        <li>\n+          <DebugLinkAccordion\n+            href=\"/errors/sync-io-after-runtime-api/private-cache\"\n+            prefetch={true}\n+          />\n+        </li>\n+        <li>\n+          <DebugLinkAccordion\n+            href=\"/errors/sync-io-after-runtime-api/quickly-expiring-public-cache\"\n+            prefetch={true}\n+          />\n+        </li>\n+      </ul>\n+    </main>\n+  )\n+}"
        },
        {
            "sha": "e08ffd65878e2a61af78053f1fc96c7c9b4ebcbf",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-runtime/app/(default)/errors/sync-io-after-runtime-api/cookies/page.tsx",
            "status": "renamed",
            "additions": 5,
            "deletions": 7,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/1e5932d5503d833b42fca86eb84d0cf508dd7139/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Ferrors%2Fsync-io-after-runtime-api%2Fcookies%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1e5932d5503d833b42fca86eb84d0cf508dd7139/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Ferrors%2Fsync-io-after-runtime-api%2Fcookies%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Ferrors%2Fsync-io-after-runtime-api%2Fcookies%2Fpage.tsx?ref=1e5932d5503d833b42fca86eb84d0cf508dd7139",
            "patch": "@@ -1,25 +1,23 @@\n import { cookies } from 'next/headers'\n import { Suspense } from 'react'\n-import { cachedDelay, DebugRenderKind } from '../../../shared'\n+import { DebugRenderKind } from '../../../../shared'\n \n export default async function Page() {\n   return (\n     <main>\n       <DebugRenderKind />\n       <p id=\"intro\">\n         This page performs sync IO after a cookies() call, so we should only see\n-        the error in a runtime prefetch or a navigation (and not during\n-        prerendering / prefetching)\n+        the error in a runtime prefetch\n       </p>\n       <Suspense fallback={<div style={{ color: 'grey' }}>Loading 1...</div>}>\n-        <One />\n+        <RuntimePrefetchable />\n       </Suspense>\n     </main>\n   )\n }\n \n-async function One() {\n-  const cookieStore = await cookies()\n-  await cachedDelay(['/cookies', cookieStore.get('user-agent')?.value])\n+async function RuntimePrefetchable() {\n+  await cookies()\n   return <div id=\"timestamp\">Timestamp: {Date.now()}</div>\n }",
            "previous_filename": "test/e2e/app-dir/segment-cache/prefetch-runtime/app/(default)/errors/sync-io-after-cookies/page.tsx"
        },
        {
            "sha": "5f678cd36c11a5fb8c97bfae2144fe5f8971d3ab",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-runtime/app/(default)/errors/sync-io-after-runtime-api/dynamic-params/[id]/page.tsx",
            "status": "added",
            "additions": 30,
            "deletions": 0,
            "changes": 30,
            "blob_url": "https://github.com/vercel/next.js/blob/1e5932d5503d833b42fca86eb84d0cf508dd7139/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Ferrors%2Fsync-io-after-runtime-api%2Fdynamic-params%2F%5Bid%5D%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1e5932d5503d833b42fca86eb84d0cf508dd7139/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Ferrors%2Fsync-io-after-runtime-api%2Fdynamic-params%2F%5Bid%5D%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Ferrors%2Fsync-io-after-runtime-api%2Fdynamic-params%2F%5Bid%5D%2Fpage.tsx?ref=1e5932d5503d833b42fca86eb84d0cf508dd7139",
            "patch": "@@ -0,0 +1,30 @@\n+import { Suspense } from 'react'\n+import { DebugRenderKind } from '../../../../../shared'\n+import { workUnitAsyncStorage } from 'next/dist/server/app-render/work-unit-async-storage.external'\n+\n+type Params = { id: string }\n+\n+export default async function Page({ params }: { params: Promise<Params> }) {\n+  return (\n+    <main>\n+      <DebugRenderKind />\n+      <p id=\"intro\">\n+        This page performs sync IO after awaiting params, so we should only see\n+        the error in a runtime prefetch\n+      </p>\n+      <Suspense fallback={<div style={{ color: 'grey' }}>Loading 1...</div>}>\n+        <RuntimePrefetchable params={params} />\n+      </Suspense>\n+    </main>\n+  )\n+}\n+\n+async function RuntimePrefetchable({ params }: { params: Promise<Params> }) {\n+  const res = await params\n+  console.log(\n+    'RuntimePrefetchable :: awaited params',\n+    res,\n+    workUnitAsyncStorage.getStore()\n+  )\n+  return <div id=\"timestamp\">Timestamp: {Date.now()}</div>\n+}"
        },
        {
            "sha": "2221cff966703b702103319af9f3b362db3b9022",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-runtime/app/(default)/errors/sync-io-after-runtime-api/private-cache/page.tsx",
            "status": "added",
            "additions": 27,
            "deletions": 0,
            "changes": 27,
            "blob_url": "https://github.com/vercel/next.js/blob/1e5932d5503d833b42fca86eb84d0cf508dd7139/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Ferrors%2Fsync-io-after-runtime-api%2Fprivate-cache%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1e5932d5503d833b42fca86eb84d0cf508dd7139/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Ferrors%2Fsync-io-after-runtime-api%2Fprivate-cache%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Ferrors%2Fsync-io-after-runtime-api%2Fprivate-cache%2Fpage.tsx?ref=1e5932d5503d833b42fca86eb84d0cf508dd7139",
            "patch": "@@ -0,0 +1,27 @@\n+import { Suspense } from 'react'\n+import { cachedDelay, DebugRenderKind } from '../../../../shared'\n+\n+export default async function Page() {\n+  return (\n+    <main>\n+      <DebugRenderKind />\n+      <p id=\"intro\">\n+        This page performs sync IO after awaiting a private cache, so we should\n+        only see the error in a runtime prefetch\n+      </p>\n+      <Suspense fallback={<div style={{ color: 'grey' }}>Loading 1...</div>}>\n+        <RuntimePrefetchable />\n+      </Suspense>\n+    </main>\n+  )\n+}\n+\n+async function RuntimePrefetchable() {\n+  await privateCache()\n+  return <div id=\"timestamp\">Timestamp: {Date.now()}</div>\n+}\n+\n+async function privateCache() {\n+  'use cache: private'\n+  await cachedDelay([__dirname])\n+}"
        },
        {
            "sha": "b80d583ffcc3987ff5296083bf5f9e9edde0a4bb",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-runtime/app/(default)/errors/sync-io-after-runtime-api/quickly-expiring-public-cache/page.tsx",
            "status": "added",
            "additions": 29,
            "deletions": 0,
            "changes": 29,
            "blob_url": "https://github.com/vercel/next.js/blob/1e5932d5503d833b42fca86eb84d0cf508dd7139/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Ferrors%2Fsync-io-after-runtime-api%2Fquickly-expiring-public-cache%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1e5932d5503d833b42fca86eb84d0cf508dd7139/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Ferrors%2Fsync-io-after-runtime-api%2Fquickly-expiring-public-cache%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Ferrors%2Fsync-io-after-runtime-api%2Fquickly-expiring-public-cache%2Fpage.tsx?ref=1e5932d5503d833b42fca86eb84d0cf508dd7139",
            "patch": "@@ -0,0 +1,29 @@\n+import { Suspense } from 'react'\n+import { cachedDelay, DebugRenderKind } from '../../../../shared'\n+import { unstable_cacheLife } from 'next/cache'\n+\n+export default async function Page() {\n+  return (\n+    <main>\n+      <DebugRenderKind />\n+      <p id=\"intro\">\n+        This page performs sync IO after awaiting a quickly-expiring public\n+        cache, so we should only see the error in a runtime prefetch\n+      </p>\n+      <Suspense fallback={<div style={{ color: 'grey' }}>Loading 1...</div>}>\n+        <RuntimePrefetchable />\n+      </Suspense>\n+    </main>\n+  )\n+}\n+\n+async function RuntimePrefetchable() {\n+  await publicCache()\n+  return <div id=\"timestamp\">Timestamp: {Date.now()}</div>\n+}\n+\n+async function publicCache() {\n+  'use cache'\n+  unstable_cacheLife('seconds')\n+  await cachedDelay([__dirname])\n+}"
        },
        {
            "sha": "61fdff36a79dfa06eb288695d6b8b154019e050c",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-runtime/app/(default)/errors/sync-io-after-runtime-api/search-params/page.tsx",
            "status": "added",
            "additions": 32,
            "deletions": 0,
            "changes": 32,
            "blob_url": "https://github.com/vercel/next.js/blob/1e5932d5503d833b42fca86eb84d0cf508dd7139/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Ferrors%2Fsync-io-after-runtime-api%2Fsearch-params%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1e5932d5503d833b42fca86eb84d0cf508dd7139/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Ferrors%2Fsync-io-after-runtime-api%2Fsearch-params%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Ferrors%2Fsync-io-after-runtime-api%2Fsearch-params%2Fpage.tsx?ref=1e5932d5503d833b42fca86eb84d0cf508dd7139",
            "patch": "@@ -0,0 +1,32 @@\n+import { Suspense } from 'react'\n+import { DebugRenderKind } from '../../../../shared'\n+\n+type AnySearchParams = { [key: string]: string | string[] | undefined }\n+\n+export default async function Page({\n+  searchParams,\n+}: {\n+  searchParams: Promise<AnySearchParams>\n+}) {\n+  return (\n+    <main>\n+      <DebugRenderKind />\n+      <p id=\"intro\">\n+        This page performs sync IO after awaiting searchParams, so we should\n+        only see the error in a runtime prefetch\n+      </p>\n+      <Suspense fallback={<div style={{ color: 'grey' }}>Loading 1...</div>}>\n+        <RuntimePrefetchable searchParams={searchParams} />\n+      </Suspense>\n+    </main>\n+  )\n+}\n+\n+async function RuntimePrefetchable({\n+  searchParams,\n+}: {\n+  searchParams: Promise<AnySearchParams>\n+}) {\n+  await searchParams\n+  return <div id=\"timestamp\">Timestamp: {Date.now()}</div>\n+}"
        },
        {
            "sha": "9e7bed6cc81afe2c1e521f8138f1cffb62f57369",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-runtime/app/(default)/page.tsx",
            "status": "modified",
            "additions": 62,
            "deletions": 16,
            "changes": 78,
            "blob_url": "https://github.com/vercel/next.js/blob/1e5932d5503d833b42fca86eb84d0cf508dd7139/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1e5932d5503d833b42fca86eb84d0cf508dd7139/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fpage.tsx?ref=1e5932d5503d833b42fca86eb84d0cf508dd7139",
            "patch": "@@ -136,6 +136,68 @@ export default async function Page() {\n         </li>\n       </ul>\n \n+      <h2>\n+        <code>runtime promise passed to public cache</code>\n+      </h2>\n+      <ul>\n+        <li>\n+          cookies() promise passed to public cache + dynamic content\n+          <ul>\n+            <li>\n+              <DebugLinkAccordion\n+                href=\"/passed-to-public-cache/cookies\"\n+                prefetch={true}\n+              />\n+            </li>\n+          </ul>\n+        </li>\n+        <li>\n+          dynamic params promise passed to public cache + dynamic content\n+          <ul>\n+            <li>\n+              <DebugLinkAccordion\n+                href=\"/passed-to-public-cache/dynamic-params/123\"\n+                prefetch={true}\n+              />\n+            </li>\n+            <li>\n+              <DebugLinkAccordion\n+                href=\"/passed-to-public-cache/dynamic-params/456\"\n+                prefetch={true}\n+              />\n+            </li>\n+          </ul>\n+        </li>\n+        <li>\n+          search params promise passed to public cache + dynamic content\n+          <ul>\n+            <li>\n+              <DebugLinkAccordion\n+                href=\"/passed-to-public-cache/search-params?searchParam=123\"\n+                prefetch={true}\n+              />\n+            </li>\n+            <li>\n+              <DebugLinkAccordion\n+                href=\"/passed-to-public-cache/search-params?searchParam=456\"\n+                prefetch={true}\n+              />\n+            </li>\n+          </ul>\n+        </li>\n+        <li>\n+          only cookies passed to public cache (no dynamic content)\n+          <ul>\n+            <li>\n+              <DebugLinkAccordion\n+                href=\"/passed-to-public-cache/cookies-only\"\n+                prefetch={true}\n+              />\n+            </li>\n+          </ul>\n+        </li>\n+      </ul>\n+\n       <h2>short-lived caches</h2>\n       <ul>\n         <li>\n@@ -231,22 +293,6 @@ export default async function Page() {\n           <DebugLinkAccordion href=\"/fully-static\" prefetch={true} />\n         </li>\n       </ul>\n-\n-      <h2>errors</h2>\n-      <ul>\n-        <li>\n-          <DebugLinkAccordion\n-            href=\"/errors/error-after-cookies\"\n-            prefetch={true}\n-          />\n-        </li>\n-        <li>\n-          <DebugLinkAccordion\n-            href=\"/errors/sync-io-after-cookies\"\n-            prefetch={true}\n-          />\n-        </li>\n-      </ul>\n     </main>\n   )\n }"
        },
        {
            "sha": "f41cc55eabd9c96304d5d37a5e9bb9b70ab8e6f7",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-runtime/app/(default)/passed-to-public-cache/cookies-only/page.tsx",
            "status": "added",
            "additions": 42,
            "deletions": 0,
            "changes": 42,
            "blob_url": "https://github.com/vercel/next.js/blob/1e5932d5503d833b42fca86eb84d0cf508dd7139/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fpassed-to-public-cache%2Fcookies-only%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1e5932d5503d833b42fca86eb84d0cf508dd7139/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fpassed-to-public-cache%2Fcookies-only%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fpassed-to-public-cache%2Fcookies-only%2Fpage.tsx?ref=1e5932d5503d833b42fca86eb84d0cf508dd7139",
            "patch": "@@ -0,0 +1,42 @@\n+import { cookies } from 'next/headers'\n+import { Suspense } from 'react'\n+import { cachedDelay, DebugRenderKind } from '../../../shared'\n+\n+export default async function Page() {\n+  return (\n+    <main>\n+      <DebugRenderKind />\n+      <p>\n+        This page uses cookies (from a private cache) and no uncached IO, So it\n+        should be completely prefetchable with a runtime prefetch.\n+      </p>\n+      <Suspense fallback={<div style={{ color: 'grey' }}>Loading 1...</div>}>\n+        <RuntimePrefetchable />\n+      </Suspense>\n+    </main>\n+  )\n+}\n+\n+async function RuntimePrefetchable() {\n+  await cookies() // Guard from being statically prerendered, which would make the cache hang\n+\n+  // We've already awaited cookies, but we still want to make sure\n+  // that the cache doesn't consider them a hanging promise\n+  const cookieValue = await publicCache(\n+    cookies().then(\n+      (cookieStore) => cookieStore.get('testCookie')?.value ?? null\n+    )\n+  )\n+  return (\n+    <div style={{ border: '1px solid blue', padding: '1em' }}>\n+      <div id=\"cookie-value\">{`Cookie: ${cookieValue}`}</div>\n+    </div>\n+  )\n+}\n+\n+async function publicCache(cookiePromise: Promise<string | null>) {\n+  'use cache'\n+  const cookieValue = await cookiePromise\n+  await cachedDelay([__filename, cookieValue])\n+  return cookieValue\n+}"
        },
        {
            "sha": "368412c1dda0118eebeffd869bf1946592f5fc5f",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-runtime/app/(default)/passed-to-public-cache/cookies/page.tsx",
            "status": "added",
            "additions": 68,
            "deletions": 0,
            "changes": 68,
            "blob_url": "https://github.com/vercel/next.js/blob/1e5932d5503d833b42fca86eb84d0cf508dd7139/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fpassed-to-public-cache%2Fcookies%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1e5932d5503d833b42fca86eb84d0cf508dd7139/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fpassed-to-public-cache%2Fcookies%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fpassed-to-public-cache%2Fcookies%2Fpage.tsx?ref=1e5932d5503d833b42fca86eb84d0cf508dd7139",
            "patch": "@@ -0,0 +1,68 @@\n+import { cookies } from 'next/headers'\n+import { Suspense } from 'react'\n+import { cachedDelay, DebugRenderKind } from '../../../shared'\n+import { connection } from 'next/server'\n+\n+export default async function Page() {\n+  return (\n+    <main>\n+      <DebugRenderKind />\n+      <p>\n+        This page passes cookies to a public cache, and uses some uncached IO,\n+        so parts of it should be prefetchable with a runtime prefetch.\n+      </p>\n+      <Suspense fallback={<div style={{ color: 'grey' }}>Loading 1...</div>}>\n+        <RuntimePrefetchable />\n+      </Suspense>\n+      <form\n+        action={async (formData: FormData) => {\n+          'use server'\n+          const cookieStore = await cookies()\n+          const cookieValue = formData.get('cookie') as string | null\n+          if (cookieValue) {\n+            cookieStore.set('testCookie', cookieValue)\n+          }\n+        }}\n+      >\n+        <input type=\"text\" name=\"cookie\" />\n+        <button type=\"submit\">Update cookie</button>\n+      </form>\n+    </main>\n+  )\n+}\n+\n+async function RuntimePrefetchable() {\n+  await cookies() // Guard from being statically prerendered, which would make the cache hang\n+\n+  // We've already awaited cookies, but we still want to make sure\n+  // that the cache doesn't consider them a hanging promise\n+  const cookieValue = await publicCache(\n+    cookies().then(\n+      (cookieStore) => cookieStore.get('testCookie')?.value ?? null\n+    )\n+  )\n+  return (\n+    <div style={{ border: '1px solid blue', padding: '1em' }}>\n+      <div id=\"cookie-value\">{`Cookie: ${cookieValue}`}</div>\n+      <Suspense fallback={<div style={{ color: 'grey' }}>Loading 2...</div>}>\n+        <Dynamic />\n+      </Suspense>\n+    </div>\n+  )\n+}\n+\n+async function publicCache(cookiePromise: Promise<string | null>) {\n+  'use cache'\n+  const cookieValue = await cookiePromise\n+  await cachedDelay([__filename, cookieValue])\n+  return cookieValue\n+}\n+\n+async function Dynamic() {\n+  await connection()\n+  return (\n+    <div style={{ border: '1px solid tomato', padding: '1em' }}>\n+      <div id=\"dynamic-content\">Dynamic content</div>\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "f284d196edaf9ee8d127e7f5183b97ea50ead929",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-runtime/app/(default)/passed-to-public-cache/dynamic-params/[id]/page.tsx",
            "status": "added",
            "additions": 52,
            "deletions": 0,
            "changes": 52,
            "blob_url": "https://github.com/vercel/next.js/blob/1e5932d5503d833b42fca86eb84d0cf508dd7139/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fpassed-to-public-cache%2Fdynamic-params%2F%5Bid%5D%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1e5932d5503d833b42fca86eb84d0cf508dd7139/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fpassed-to-public-cache%2Fdynamic-params%2F%5Bid%5D%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fpassed-to-public-cache%2Fdynamic-params%2F%5Bid%5D%2Fpage.tsx?ref=1e5932d5503d833b42fca86eb84d0cf508dd7139",
            "patch": "@@ -0,0 +1,52 @@\n+import { Suspense } from 'react'\n+import { cachedDelay, DebugRenderKind } from '../../../../shared'\n+import { connection } from 'next/server'\n+import { cookies } from 'next/headers'\n+\n+type Params = { id: string }\n+\n+export default async function Page({ params }: { params: Promise<Params> }) {\n+  return (\n+    <main>\n+      <DebugRenderKind />\n+      <p>\n+        This page passes dynamic params to a public cache, and uses some\n+        uncached IO, so parts of it should be prefetchable with a runtime\n+        prefetch.\n+      </p>\n+      <Suspense fallback={<div style={{ color: 'grey' }}>Loading 1...</div>}>\n+        <RuntimePrefetchable params={params} />\n+      </Suspense>\n+    </main>\n+  )\n+}\n+\n+async function RuntimePrefetchable({ params }: { params: Promise<Params> }) {\n+  await cookies() // Guard from being statically prerendered, which would make the cache hang\n+\n+  const id = await publicCache(params)\n+  return (\n+    <div style={{ border: '1px solid blue', padding: '1em' }}>\n+      <div id=\"param-value\">{`Param: ${id}`}</div>\n+      <Suspense fallback={<div style={{ color: 'grey' }}>Loading 2...</div>}>\n+        <Dynamic />\n+      </Suspense>\n+    </div>\n+  )\n+}\n+\n+async function publicCache(params: Promise<Params>) {\n+  'use cache'\n+  const { id } = await params\n+  await cachedDelay([__filename, id])\n+  return id\n+}\n+\n+async function Dynamic() {\n+  await connection()\n+  return (\n+    <div style={{ border: '1px solid tomato', padding: '1em' }}>\n+      <div id=\"dynamic-content\">Dynamic content</div>\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "641d8b6dec817a054613dccb099083793bfe5c42",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-runtime/app/(default)/passed-to-public-cache/search-params/page.tsx",
            "status": "added",
            "additions": 59,
            "deletions": 0,
            "changes": 59,
            "blob_url": "https://github.com/vercel/next.js/blob/1e5932d5503d833b42fca86eb84d0cf508dd7139/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fpassed-to-public-cache%2Fsearch-params%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1e5932d5503d833b42fca86eb84d0cf508dd7139/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fpassed-to-public-cache%2Fsearch-params%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2F(default)%2Fpassed-to-public-cache%2Fsearch-params%2Fpage.tsx?ref=1e5932d5503d833b42fca86eb84d0cf508dd7139",
            "patch": "@@ -0,0 +1,59 @@\n+import { Suspense } from 'react'\n+import { cachedDelay, DebugRenderKind } from '../../../shared'\n+import { connection } from 'next/server'\n+import { cookies } from 'next/headers'\n+\n+type AnySearchParams = { [key: string]: string | string[] | undefined }\n+\n+export default async function Page({\n+  searchParams,\n+}: {\n+  searchParams: Promise<AnySearchParams>\n+}) {\n+  return (\n+    <main>\n+      <DebugRenderKind />\n+      <p>\n+        This page passes search params to a public cache, and uses some uncached\n+        IO, so parts of it should be prefetchable with a runtime prefetch.\n+      </p>\n+      <Suspense fallback={<div style={{ color: 'grey' }}>Loading 1...</div>}>\n+        <RuntimePrefetchable searchParams={searchParams} />\n+      </Suspense>\n+    </main>\n+  )\n+}\n+\n+async function RuntimePrefetchable({\n+  searchParams,\n+}: {\n+  searchParams: Promise<AnySearchParams>\n+}) {\n+  await cookies() // Guard from being statically prerendered, which would make the cache hang\n+\n+  const searchParam = await publicCache(searchParams)\n+  return (\n+    <div style={{ border: '1px solid blue', padding: '1em' }}>\n+      <div id=\"search-param-value\">{`Search param: ${searchParam}`}</div>\n+      <Suspense fallback={<div style={{ color: 'grey' }}>Loading 2...</div>}>\n+        <Dynamic />\n+      </Suspense>\n+    </div>\n+  )\n+}\n+\n+async function publicCache(searchParams: Promise<AnySearchParams>) {\n+  'use cache'\n+  const { searchParam } = await searchParams\n+  await cachedDelay([__filename, searchParam])\n+  return searchParam\n+}\n+\n+async function Dynamic() {\n+  await connection()\n+  return (\n+    <div style={{ border: '1px solid tomato', padding: '1em' }}>\n+      <div id=\"dynamic-content\">Dynamic content</div>\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "ac4052c4530e71a5392ccdc3a02537c5eedd23a8",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-runtime/app/with-root-param/[lang]/page.tsx",
            "status": "modified",
            "additions": 23,
            "deletions": 0,
            "changes": 23,
            "blob_url": "https://github.com/vercel/next.js/blob/1e5932d5503d833b42fca86eb84d0cf508dd7139/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2Fwith-root-param%2F%5Blang%5D%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1e5932d5503d833b42fca86eb84d0cf508dd7139/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2Fwith-root-param%2F%5Blang%5D%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2Fwith-root-param%2F%5Blang%5D%2Fpage.tsx?ref=1e5932d5503d833b42fca86eb84d0cf508dd7139",
            "patch": "@@ -51,6 +51,29 @@ export default async function Page() {\n           </ul>\n         </li>\n       </ul>\n+\n+      <h2>\n+        <code>promise passed to public cache</code>\n+      </h2>\n+      <ul>\n+        <li>\n+          root params + dynamic content\n+          <ul>\n+            <li>\n+              <DebugLinkAccordion\n+                href={`/with-root-param/${currentLang}/passed-to-public-cache/root-params`}\n+                prefetch={true}\n+              />\n+            </li>\n+            <li>\n+              <DebugLinkAccordion\n+                href={`/with-root-param/${otherLang}/passed-to-public-cache/root-params`}\n+                prefetch={true}\n+              />\n+            </li>\n+          </ul>\n+        </li>\n+      </ul>\n     </main>\n   )\n }"
        },
        {
            "sha": "b8890c6bccc39cf6f26be216902d71bc40941efe",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-runtime/app/with-root-param/[lang]/passed-to-public-cache/root-params/page.tsx",
            "status": "added",
            "additions": 50,
            "deletions": 0,
            "changes": 50,
            "blob_url": "https://github.com/vercel/next.js/blob/1e5932d5503d833b42fca86eb84d0cf508dd7139/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2Fwith-root-param%2F%5Blang%5D%2Fpassed-to-public-cache%2Froot-params%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1e5932d5503d833b42fca86eb84d0cf508dd7139/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2Fwith-root-param%2F%5Blang%5D%2Fpassed-to-public-cache%2Froot-params%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fapp%2Fwith-root-param%2F%5Blang%5D%2Fpassed-to-public-cache%2Froot-params%2Fpage.tsx?ref=1e5932d5503d833b42fca86eb84d0cf508dd7139",
            "patch": "@@ -0,0 +1,50 @@\n+import { Suspense } from 'react'\n+import { cachedDelay, DebugRenderKind, uncachedIO } from '../../../../shared'\n+import { connection } from 'next/server'\n+import { lang } from 'next/root-params'\n+\n+export default async function Page() {\n+  return (\n+    <main>\n+      <DebugRenderKind />\n+      <p>\n+        This page uses root params (passed to a private cache) and some uncached\n+        IO. Root params should always be available in static prerenders, so a\n+        runtime prefetch should have them too, and they should not be considered\n+        a hanging input.\n+      </p>\n+      <Suspense fallback=\"Loading 1...\">\n+        <DynamicallyPrefetchable />\n+      </Suspense>\n+    </main>\n+  )\n+}\n+\n+async function DynamicallyPrefetchable() {\n+  const currentLang = await publicCache(lang())\n+  return (\n+    <div style={{ border: '1px solid blue', padding: '1em' }}>\n+      <div id=\"root-param-value\">{`Lang: ${currentLang}`}</div>\n+      <Suspense fallback={<div style={{ color: 'grey' }}>Loading 2...</div>}>\n+        <Dynamic />\n+      </Suspense>\n+    </div>\n+  )\n+}\n+\n+async function publicCache(currentLangPromise: Promise<string>) {\n+  'use cache'\n+  const currentLang = await currentLangPromise\n+  await cachedDelay([__filename, currentLang])\n+  return currentLang\n+}\n+\n+async function Dynamic() {\n+  await uncachedIO()\n+  await connection()\n+  return (\n+    <div style={{ border: '1px solid tomato', padding: '1em' }}>\n+      <div id=\"dynamic-content\">Dynamic content</div>\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "18f27e0bae6f5066475fa805312f9f1341b8f535",
            "filename": "test/e2e/app-dir/segment-cache/prefetch-runtime/prefetch-runtime.test.ts",
            "status": "modified",
            "additions": 127,
            "deletions": 66,
            "changes": 193,
            "blob_url": "https://github.com/vercel/next.js/blob/1e5932d5503d833b42fca86eb84d0cf508dd7139/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fprefetch-runtime.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1e5932d5503d833b42fca86eb84d0cf508dd7139/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fprefetch-runtime.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fprefetch-runtime%2Fprefetch-runtime.test.ts?ref=1e5932d5503d833b42fca86eb84d0cf508dd7139",
            "patch": "@@ -11,9 +11,36 @@ describe('<Link prefetch={true}> (runtime prefetch)', () => {\n     return\n   }\n \n+  let currentCliOutputIndex = 0\n+  beforeEach(() => {\n+    resetCliOutput()\n+  })\n+\n+  const getCliOutput = () => {\n+    if (next.cliOutput.length < currentCliOutputIndex) {\n+      // cliOutput shrank since we started the test, so something (like a `sandbox`) reset the logs\n+      currentCliOutputIndex = 0\n+    }\n+    return next.cliOutput.slice(currentCliOutputIndex)\n+  }\n+\n+  const resetCliOutput = () => {\n+    currentCliOutputIndex = next.cliOutput.length\n+  }\n+\n   describe.each([\n-    { description: 'in a page', prefix: 'in-page' },\n-    { description: 'in a private cache', prefix: 'in-private-cache' },\n+    {\n+      description: 'in a page',\n+      prefix: 'in-page',\n+    },\n+    {\n+      description: 'in a private cache',\n+      prefix: 'in-private-cache',\n+    },\n+    {\n+      description: 'passed to a public cache',\n+      prefix: 'passed-to-public-cache',\n+    },\n   ])('$description', ({ prefix }) => {\n     it('includes dynamic params, but not dynamic content', async () => {\n       let page: Playwright.Page\n@@ -951,82 +978,116 @@ describe('<Link prefetch={true}> (runtime prefetch)', () => {\n   })\n \n   describe('errors', () => {\n-    it('aborts the prerender and logs an error when sync IO is used after cookies()', async () => {\n-      // In a runtime prefetch, we might encounter sync IO usages that weren't caught during build,\n-      // because they were hidden behind e.g. a cookies() call.\n-      // We currently have no way to catch these statically.\n-      // In that case, we should abort the prerender, but still return partial content.\n-\n-      // TODO: this doesn't work as well as it could, see comment before the navigation\n-\n-      let page: Playwright.Page\n-      const browser = await next.browser('/', {\n-        beforePageLoad(p: Playwright.Page) {\n-          page = p\n-        },\n-      })\n-      const act = createRouterAct(page)\n+    it.each([\n+      {\n+        description: 'when sync IO is used after awaiting cookies()',\n+        path: '/errors/sync-io-after-runtime-api/cookies',\n+      },\n+      // TODO(dynamic-ppr):\n+      // A tree prefetch for \"/dynamic-params/123\" currently causes it to be prerendered on demand,\n+      // meaning that we end up statically prerendering it with all the params included.\n+      // Because of this, `await params` doesn't hang in the static prerender, so we hit the sync IO error behind it.\n+      // This error somehow causes an infinite redirect loop between two different `?_rsc` URLs.\n+      // Investigate this separately or wait until we start always using fallback params for route trees.\n+      //\n+      // {\n+      //   description: 'when sync IO is used after awaiting dynamic params',\n+      //   path: '/errors/sync-io-after-runtime-api/dynamic-params/123',\n+      // },\n+      {\n+        description: 'when sync IO is used after awaiting searchParams',\n+        path: '/errors/sync-io-after-runtime-api/search-params?foo=bar',\n+      },\n+      {\n+        description: 'when sync IO is used after awaiting a private cache',\n+        path: '/errors/sync-io-after-runtime-api/private-cache',\n+      },\n+      {\n+        description:\n+          'when sync IO is used after awaiting a quickly-expiring public cache',\n+        path: '/errors/sync-io-after-runtime-api/quickly-expiring-public-cache',\n+      },\n+    ])(\n+      'aborts the prerender and logs an error $description',\n+      async ({ path }) => {\n+        // In a runtime prefetch, we might encounter sync IO usages that weren't caught during build,\n+        // because they were hidden behind e.g. a cookies() call.\n+        // We currently have no way to catch these statically.\n+        // In that case, we should abort the prerender, but still return partial content.\n \n-      const STATIC_CONTENT = 'This page performs sync IO after a cookies() call'\n+        // TODO: this doesn't work as well as it could, see comment before the navigation\n \n-      // Reveal the link to trigger a runtime prefetch\n-      await act(async () => {\n-        const linkToggle = await browser.elementByCss(\n-          `input[data-prefetch=\"runtime\"][data-link-accordion=\"/errors/sync-io-after-cookies\"]`\n-        )\n-        await linkToggle.click()\n-      }, [\n-        // Should include the shell\n-        {\n-          includes: STATIC_CONTENT,\n-        },\n-        // Should abort the render when sync IO is encountered,\n-        // so this should never be included\n-        {\n-          includes: 'Timestamp',\n-          block: 'reject',\n-        },\n-      ])\n+        let page: Playwright.Page\n+        const browser = await next.browser('/errors', {\n+          beforePageLoad(p: Playwright.Page) {\n+            page = p\n+          },\n+        })\n+        const act = createRouterAct(page)\n \n-      if (!isNextDeploy) {\n-        expect(next.cliOutput).toContain(\n-          'Error: Route \"/errors/sync-io-after-cookies\" used `Date.now()` instead of using `performance` or without explicitly calling `await connection()` beforehand.'\n-        )\n-      }\n+        const STATIC_CONTENT = 'This page performs sync IO after'\n \n-      // TODO(runtime-ppr): we should be able to display the (aborted, partial) prefetched contents before navigating,\n-      // but it seems like when we abort the render, we're also inadvertently cutting off some promises related to metadata\n-      // which end up suspending on the client and blocking react from rendering.\n-      // Ideally, we'd be able to use the partial result, but this is an error scenario and we don't crash,\n-      // so i'm just settling for that for now.\n+        // Reveal the link to trigger a runtime prefetch\n+        await act(async () => {\n+          const linkToggle = await browser.elementByCss(\n+            `input[data-prefetch=\"runtime\"][data-link-accordion=\"${path}\"]`\n+          )\n+          await linkToggle.click()\n+        }, [\n+          // Should include the shell\n+          {\n+            includes: STATIC_CONTENT,\n+          },\n+          // Should abort the render when sync IO is encountered,\n+          // so this should never be included\n+          {\n+            includes: 'Timestamp',\n+            block: 'reject',\n+          },\n+        ])\n \n-      // Navigate to the page\n-      await act(\n-        async () => {\n-          await browser\n-            .elementByCss(`a[href=\"/errors/sync-io-after-cookies\"]`)\n-            .click()\n-        },\n-        {\n-          includes: 'Timestamp',\n+        if (!isNextDeploy) {\n+          expect(getCliOutput()).toMatch(\n+            /Error: Route \".*?\" used `Date\\.now\\(\\)` instead of using `performance` or without explicitly calling `await connection\\(\\)` beforehand\\./\n+          )\n         }\n-      )\n \n-      // After navigating, we should see the sync IO result that we omitted from the prefetch.\n-      expect(await browser.elementById('intro').text()).toInclude(\n-        STATIC_CONTENT\n-      )\n-      expect(await browser.elementById('timestamp').text()).toMatch(\n-        /Timestamp: \\d+/\n-      )\n-    })\n+        // Navigate to the page\n+        await act(async () => {\n+          await act(\n+            async () => {\n+              await browser.elementByCss(`a[href=\"${path}\"]`).click()\n+            },\n+            {\n+              // Temporarily block the navigation request.\n+              includes: 'Timestamp',\n+              block: true,\n+            }\n+          )\n+          // We aborted the render because of sync IO, so we won't display the timestamp,\n+          // but due to the way we sequence tasks, we should've at least finished rendering the static parts.\n+          expect(await browser.elementsByCss('#timestamp')).toHaveLength(0)\n+          expect(await browser.elementById('intro').text()).toInclude(\n+            STATIC_CONTENT\n+          )\n+        })\n+\n+        // After navigating, we should see the sync IO result that we omitted from the prefetch.\n+        expect(await browser.elementById('intro').text()).toInclude(\n+          STATIC_CONTENT\n+        )\n+        expect(await browser.elementById('timestamp').text()).toMatch(\n+          /Timestamp: \\d+/\n+        )\n+      }\n+    )\n \n     it('should trigger error boundaries for errors that occurred in runtime-prefetched content', async () => {\n       // A thrown error in the prerender should not stop us from sending a prefetch response.\n       // This should work without any extra effort, but I'm adding a test for it as a sanity check.\n \n       let page: Playwright.Page\n-      const browser = await next.browser('/', {\n+      const browser = await next.browser('/errors', {\n         beforePageLoad(p: Playwright.Page) {\n           page = p\n         },\n@@ -1049,7 +1110,7 @@ describe('<Link prefetch={true}> (runtime prefetch)', () => {\n       ])\n \n       if (!isNextDeploy) {\n-        expect(next.cliOutput).toContain('Error: Kaboom')\n+        expect(getCliOutput()).toContain('Error: Kaboom')\n       }\n \n       // Navigate to the page. We already have the paged cached."
        }
    ],
    "stats": {
        "total": 978,
        "additions": 871,
        "deletions": 107
    }
}