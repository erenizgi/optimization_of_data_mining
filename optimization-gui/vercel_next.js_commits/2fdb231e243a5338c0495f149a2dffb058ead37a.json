{
    "author": "lukesandberg",
    "message": "[turbopack] Avoid returning multiple requests when performing file extension substitution (#86520)\n\nIf we modify user patterns with filename extension alternates, we should ensure we only produce one result.\n\ne.g. given\n\n```\nsrc/\n     foo.js\n     foo.ts\n     foo.json\n```\n\nIf `fullySpecified=false` then `import foo` should produce `foo.js`, not `foo.js` and `foo.json`\n\nsimilarly if your tsconfig sets `\"moduleResolution\":\"nodeNext\"` and you import `foo.js` it should produce `foo.ts`, but not `[foo.ts, foo.js]`.\n\nThe core problem is that we expand a user supplied pattern with alternates and then we need to only produce matches that 'correspond' to the original pattern.  To accomplish this I implemented an 'undo stack' so that when we examine a match produced by `read_matches` we can transform the request key back into something that matches the original pattern.\n\nThis neatly solves the issue of accidentally producing multiple matches with the same base filename.  Consider the pattern `./foo.js`, we expand the pattern to `./foo.{ts,tsx,js}` and then produce two matches `[(./foo.ts, foo.ts), (./foo.js, foo.js)]` our undo stack will transform the `./foo.ts` key back into `./foo.js` and then the alternate merging logic will pick the first one for each key!\n\nThe nice thing about the 'key' based approach is that it does the right thing for dynamic requests as well.\n\nFinally, the new 'undo stack' based approach is much more composable than the old 'sequence of conditions' based approach so now it is trivial to produce all matches in parallel.",
    "sha": "2fdb231e243a5338c0495f149a2dffb058ead37a",
    "files": [
        {
            "sha": "4aa1af0d1a0eb6e82a38af70739e818661506cc7",
            "filename": "turbopack/crates/turbopack-core/src/resolve/mod.rs",
            "status": "modified",
            "additions": 223,
            "deletions": 144,
            "changes": 367,
            "blob_url": "https://github.com/vercel/next.js/blob/2fdb231e243a5338c0495f149a2dffb058ead37a/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2fdb231e243a5338c0495f149a2dffb058ead37a/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fmod.rs?ref=2fdb231e243a5338c0495f149a2dffb058ead37a",
            "patch": "@@ -3,14 +3,17 @@ use std::{\n     collections::BTreeMap,\n     fmt::{Display, Formatter, Write},\n     future::Future,\n-    iter::once,\n+    iter::{empty, once},\n };\n \n use anyhow::{Result, bail};\n use auto_hash_map::AutoSet;\n use bincode::{Decode, Encode};\n+use either::Either;\n+use once_cell::sync::Lazy;\n use rustc_hash::{FxHashMap, FxHashSet};\n use serde::{Deserialize, Serialize};\n+use smallvec::SmallVec;\n use tracing::{Instrument, Level};\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{\n@@ -2247,19 +2250,133 @@ async fn resolve_relative_request(\n \n     let mut new_path = path_pattern.clone();\n \n+    // A small tree to 'undo' the set of modifications we make to patterns, ensuring that we produce\n+    // correct request keys\n+    #[derive(Eq, PartialEq, Clone, Hash, Debug)]\n+    enum RequestKeyTransform {\n+        /// A leaf node for 'no change'\n+        None,\n+        /// We added a fragment to the request and thus need to potentially remove it when matching\n+        AddedFragment,\n+        // We added an extension to the request and thus need to potentially remove it when\n+        // matching\n+        AddedExtension {\n+            /// The extension that was added\n+            ext: RcStr,\n+            /// This modification can be composed with others\n+            /// In reality just `None' or `AddedFragment``\n+            next: Vec<RequestKeyTransform>,\n+        },\n+        ReplacedExtension {\n+            /// The extension that was replaced, to figure out the original you need to query\n+            /// [TS_EXTENSION_REPLACEMENTS]\n+            ext: RcStr,\n+            /// This modification can be composed with others\n+            /// In just [AddedExtension], [None] or [AddedFragment]\n+            next: Vec<RequestKeyTransform>,\n+        },\n+    }\n+\n+    impl RequestKeyTransform {\n+        /// Modifies the matched pattern using the modification rules and produces results if they\n+        /// match the supplied [pattern]\n+        fn undo(\n+            &self,\n+            matched_pattern: &RcStr,\n+            fragment: &RcStr,\n+            pattern: &Pattern,\n+        ) -> impl Iterator<Item = (RcStr, RcStr)> {\n+            let mut result = SmallVec::new();\n+            self.apply_internal(matched_pattern, fragment, pattern, &mut result);\n+            result.into_iter()\n+        }\n+\n+        fn apply_internal(\n+            &self,\n+            matched_pattern: &RcStr,\n+            fragment: &RcStr,\n+            pattern: &Pattern,\n+            result: &mut SmallVec<[(RcStr, RcStr); 2]>,\n+        ) {\n+            match self {\n+                RequestKeyTransform::None => {\n+                    if pattern.is_match(matched_pattern.as_str()) {\n+                        result.push((matched_pattern.clone(), fragment.clone()));\n+                    }\n+                }\n+                RequestKeyTransform::AddedFragment => {\n+                    debug_assert!(\n+                        !fragment.is_empty(),\n+                        \"can only have an AddedFragment modification if there was a fragment\"\n+                    );\n+                    if let Some(stripped_pattern) = matched_pattern.strip_suffix(fragment.as_str())\n+                        && pattern.is_match(stripped_pattern)\n+                    {\n+                        result.push((stripped_pattern.into(), RcStr::default()));\n+                    }\n+                }\n+                RequestKeyTransform::AddedExtension { ext, next } => {\n+                    if let Some(stripped_pattern) = matched_pattern.strip_suffix(ext.as_str()) {\n+                        let stripped_pattern: RcStr = stripped_pattern.into();\n+                        Self::apply_all(next, &stripped_pattern, fragment, pattern, result);\n+                    }\n+                }\n+                RequestKeyTransform::ReplacedExtension { ext, next } => {\n+                    if let Some(stripped_pattern) = matched_pattern.strip_suffix(ext.as_str()) {\n+                        let replaced_pattern: RcStr = format!(\n+                            \"{stripped_pattern}{old_ext}\",\n+                            old_ext = TS_EXTENSION_REPLACEMENTS.reverse.get(ext).unwrap()\n+                        )\n+                        .into();\n+                        Self::apply_all(next, &replaced_pattern, fragment, pattern, result);\n+                    }\n+                }\n+            }\n+        }\n+\n+        fn apply_all(\n+            list: &[RequestKeyTransform],\n+            matched_pattern: &RcStr,\n+            fragment: &RcStr,\n+            pattern: &Pattern,\n+            result: &mut SmallVec<[(RcStr, RcStr); 2]>,\n+        ) {\n+            list.iter()\n+                .for_each(|pm| pm.apply_internal(matched_pattern, fragment, pattern, result));\n+        }\n+    }\n+\n+    let mut modifications = Vec::new();\n+    modifications.push(RequestKeyTransform::None);\n+\n     // Fragments are a bit odd. `require()` allows importing files with literal `#` characters in\n     // them, but `import` treats it like a url and drops it from resolution. So we need to consider\n     // both cases here.\n     if !fragment.is_empty() {\n+        modifications.push(RequestKeyTransform::AddedFragment);\n         new_path.push(Pattern::Alternatives(vec![\n             Pattern::Constant(RcStr::default()),\n             Pattern::Constant(fragment.clone()),\n         ]));\n     }\n \n     if !options_value.fully_specified {\n+        // For each current set of modifications append an extension modification\n+        modifications =\n+            modifications\n+                .iter()\n+                .cloned()\n+                .chain(options_value.extensions.iter().map(|ext| {\n+                    RequestKeyTransform::AddedExtension {\n+                        ext: ext.clone(),\n+                        next: modifications.clone(),\n+                    }\n+                }))\n+                .collect();\n         // Add the extensions as alternatives to the path\n         // read_matches keeps the order of alternatives intact\n+        // TODO: if the pattern has a dynamic suffix then this 'ordering' doesn't work since we just\n+        // take the slowpath and return everything from the directory in `read_matches`\n         new_path.push(Pattern::Alternatives(\n             once(Pattern::Constant(RcStr::default()))\n                 .chain(\n@@ -2273,48 +2390,78 @@ async fn resolve_relative_request(\n         new_path.normalize();\n     };\n \n+    struct ExtensionReplacements {\n+        forward: FxHashMap<RcStr, SmallVec<[RcStr; 3]>>,\n+        reverse: FxHashMap<RcStr, RcStr>,\n+    }\n+    static TS_EXTENSION_REPLACEMENTS: Lazy<ExtensionReplacements> = Lazy::new(|| {\n+        let mut forward = FxHashMap::default();\n+        forward.insert(\n+            rcstr!(\".js\"),\n+            SmallVec::from_vec(vec![rcstr!(\".ts\"), rcstr!(\".tsx\"), rcstr!(\".js\")]),\n+        );\n+\n+        forward.insert(\n+            rcstr!(\".mjs\"),\n+            SmallVec::from_vec(vec![rcstr!(\".mts\"), rcstr!(\".mjs\")]),\n+        );\n+\n+        forward.insert(\n+            rcstr!(\".cjs\"),\n+            SmallVec::from_vec(vec![rcstr!(\".cts\"), rcstr!(\".cjs\")]),\n+        );\n+        let reverse = forward\n+            .iter()\n+            .flat_map(|(k, v)| v.iter().map(|v: &RcStr| (v.clone(), k.clone())))\n+            .collect::<FxHashMap<_, _>>();\n+        ExtensionReplacements { forward, reverse }\n+    });\n+\n     if options_value.enable_typescript_with_output_extension {\n-        new_path.replace_final_constants(&|c: &RcStr| -> Option<Pattern> {\n-            let (base, replacement) = match c.rsplit_once(\".\") {\n-                Some((base, \"js\")) => (\n-                    base,\n-                    vec![\n-                        Pattern::Constant(rcstr!(\".ts\")),\n-                        Pattern::Constant(rcstr!(\".tsx\")),\n-                        Pattern::Constant(rcstr!(\".js\")),\n-                    ],\n-                ),\n-                Some((base, \"mjs\")) => (\n-                    base,\n-                    vec![\n-                        Pattern::Constant(rcstr!(\".mts\")),\n-                        Pattern::Constant(rcstr!(\".mjs\")),\n-                    ],\n-                ),\n-                Some((base, \"cjs\")) => (\n-                    base,\n-                    vec![\n-                        Pattern::Constant(rcstr!(\".cts\")),\n-                        Pattern::Constant(rcstr!(\".cjs\")),\n-                    ],\n-                ),\n-                _ => {\n-                    return None;\n+        // there are at most 4 possible replacements (the size of the reverse map)\n+        let mut replaced_extensions = SmallVec::<[RcStr; 4]>::new();\n+        let replaced = new_path.replace_final_constants(&mut |c: &RcStr| -> Option<Pattern> {\n+            let (base, ext) = c.split_at(c.rfind('.')?);\n+\n+            let (ext, replacements) = TS_EXTENSION_REPLACEMENTS.forward.get_key_value(ext)?;\n+            for replacement in replacements {\n+                if replacement != ext && !replaced_extensions.contains(replacement) {\n+                    replaced_extensions.push(replacement.clone());\n+                    debug_assert!(replaced_extensions.len() <= replaced_extensions.inline_size());\n                 }\n-            };\n+            }\n+\n+            let replacements = replacements\n+                .iter()\n+                .cloned()\n+                .map(Pattern::Constant)\n+                .collect();\n+\n             if base.is_empty() {\n-                Some(Pattern::Alternatives(replacement))\n+                Some(Pattern::Alternatives(replacements))\n             } else {\n                 Some(Pattern::Concatenation(vec![\n                     Pattern::Constant(base.into()),\n-                    Pattern::Alternatives(replacement),\n+                    Pattern::Alternatives(replacements),\n                 ]))\n             }\n         });\n-        new_path.normalize();\n+        if replaced {\n+            // For each current set of modifications append an extension replacement modification\n+            modifications = modifications\n+                .iter()\n+                .cloned()\n+                .chain(replaced_extensions.iter().map(|ext| {\n+                    RequestKeyTransform::ReplacedExtension {\n+                        ext: ext.clone(),\n+                        next: modifications.clone(),\n+                    }\n+                }))\n+                .collect();\n+            new_path.normalize();\n+        }\n     }\n \n-    let mut results = Vec::new();\n     let matches = read_matches(\n         lookup_path.clone(),\n         rcstr!(\"\"),\n@@ -2324,100 +2471,40 @@ async fn resolve_relative_request(\n     .await?;\n \n     // This loop is necessary to 'undo' the modifications to 'new_path' that were performed above.\n-    // e.g. we added extensions but these shouldn't be part of the request key so remove them\n-    // TODO: this logic is not completely correct because it fails to account for the extension\n-    // replacement logic that we perform conditionally.\n-\n-    for m in matches.iter() {\n-        if let PatternMatch::File(matched_pattern, path) = m {\n-            let mut pushed = false;\n-            if !options_value.fully_specified {\n-                for ext in options_value.extensions.iter() {\n-                    let Some(matched_pattern) = matched_pattern.strip_suffix(&**ext) else {\n-                        continue;\n-                    };\n-\n-                    if !fragment.is_empty() {\n-                        // If the fragment is not empty, we need to strip it from the matched\n-                        // pattern so it matches path_pattern\n-                        if let Some(matched_pattern) =\n-                            matched_pattern.strip_suffix(fragment.as_str())\n-                            && path_pattern.is_match(matched_pattern)\n-                        {\n-                            results.push(\n-                                resolved(\n-                                    RequestKey::new(matched_pattern.into()),\n-                                    path.clone(),\n-                                    lookup_path.clone(),\n-                                    request,\n-                                    options_value,\n-                                    options,\n-                                    query.clone(),\n-                                    RcStr::default(),\n-                                )\n-                                .await?,\n-                            );\n-                            pushed = true;\n-                        }\n-                    }\n-                    if path_pattern.is_match(matched_pattern) {\n-                        results.push(\n-                            resolved(\n-                                RequestKey::new(matched_pattern.into()),\n-                                path.clone(),\n-                                lookup_path.clone(),\n-                                request,\n-                                options_value,\n-                                options,\n-                                query.clone(),\n-                                fragment.clone(),\n-                            )\n-                            .await?,\n-                        );\n-                        pushed = true;\n-                    }\n-                }\n-            }\n-            if !fragment.is_empty() {\n-                // If the fragment is not empty, we need to strip it from the matched pattern so it\n-                // matches the original pattern\n-                if let Some(matched_pattern) = matched_pattern.strip_suffix(fragment.as_str())\n-                    && path_pattern.is_match(matched_pattern)\n-                {\n-                    results.push(\n-                        resolved(\n-                            RequestKey::new(matched_pattern.into()),\n-                            path.clone(),\n-                            lookup_path.clone(),\n-                            request,\n-                            options_value,\n-                            options,\n-                            query.clone(),\n-                            RcStr::default(),\n-                        )\n-                        .await?,\n-                    );\n-                    pushed = true;\n-                }\n+    // e.g. we added extensions but these shouldn't be part of the request key so remove them.\n+\n+    let mut keys = FxHashSet::default();\n+    let mut results = matches\n+        .iter()\n+        .flat_map(|m| {\n+            if let PatternMatch::File(matched_pattern, path) = m {\n+                Either::Left(\n+                    modifications\n+                        .iter()\n+                        .flat_map(|m| m.undo(matched_pattern, &fragment, path_pattern))\n+                        .map(move |result| (result, path)),\n+                )\n+            } else {\n+                Either::Right(empty())\n             }\n+        })\n+        // Dedupe here before calling `resolved`\n+        .filter(move |((matched_pattern, _), _)| keys.insert(matched_pattern.clone()))\n+        .map(|((matched_pattern, fragment), path)| {\n+            resolved(\n+                RequestKey::new(matched_pattern),\n+                path.clone(),\n+                lookup_path.clone(),\n+                request,\n+                options_value,\n+                options,\n+                query.clone(),\n+                fragment,\n+            )\n+        })\n+        .try_join()\n+        .await?;\n \n-            if !pushed || path_pattern.is_match(matched_pattern) {\n-                results.push(\n-                    resolved(\n-                        RequestKey::new(matched_pattern.clone()),\n-                        path.clone(),\n-                        lookup_path.clone(),\n-                        request,\n-                        options_value,\n-                        options,\n-                        query.clone(),\n-                        fragment.clone(),\n-                    )\n-                    .await?,\n-                );\n-            }\n-        }\n-    }\n     // Directory matches must be resolved AFTER file matches\n     for m in matches.iter() {\n         if let PatternMatch::Directory(matched_pattern, path) = m {\n@@ -3375,12 +3462,7 @@ mod tests {\n             pattern: rcstr!(\"./foo.js\").into(),\n             enable_typescript_with_output_extension: true,\n             fully_specified: false,\n-            expected: vec![\n-                // WRONG: request key is incorrect\n-                (\"./foo.ts\", \"foo.ts\"),\n-                // WRONG: shouldn't produce the .js file\n-                (\"./foo.js\", \"foo.js\"),\n-            ],\n+            expected: vec![(\"./foo.js\", \"foo.ts\")],\n         })\n         .await;\n     }\n@@ -3454,13 +3536,9 @@ mod tests {\n             pattern: rcstr!(\"./client#component.js\").into(),\n             enable_typescript_with_output_extension: true,\n             fully_specified: false,\n-            expected: vec![\n-                // The request key is fundamentally ambiguous.  It depends on whether or not we\n-                // consider this fragment to be part of the request pattern\n-                (\"./client#component.ts\", \"client#component.ts\"),\n-                // WRONG: js file should not be produced\n-                (\"./client\", \"client#component.js\"),\n-            ],\n+            // Whether or not this request key is correct somewhat ambiguous.  It depends on whether\n+            // or not we consider this fragment to be part of the request pattern\n+            expected: vec![(\"./client\", \"client#component.ts\")],\n         })\n         .await;\n     }\n@@ -3506,11 +3584,8 @@ mod tests {\n             enable_typescript_with_output_extension: true,\n             fully_specified: false,\n             expected: vec![\n-                // WRONG: request key doesn't match pattern\n-                (\"./src/foo.ts\", \"src/foo.ts\"),\n+                (\"./src/foo.js\", \"src/foo.ts\"),\n                 (\"./src/bar.js\", \"src/bar.js\"),\n-                // WRONG: source file is redundant with extension rewriting\n-                (\"./src/foo.js\", \"src/foo.js\"),\n             ],\n         })\n         .await;\n@@ -3530,11 +3605,15 @@ mod tests {\n             enable_typescript_with_output_extension: true,\n             fully_specified: false,\n             expected: vec![\n-                (\"./src/bar\", \"src/bar.js\"),\n                 (\"./src/bar.js\", \"src/bar.js\"),\n-                // WRONG: all three should point at the .ts file\n-                (\"./src/foo\", \"src/foo.js\"),\n+                (\"./src/bar\", \"src/bar.js\"),\n+                // TODO: all three should point at the .ts file\n+                // This happens because read_matches returns the `.js` file first simply because we\n+                // match every file in the directory with this pattern. To address we would need to\n+                // sort read_matches after the fact, or otherwise change how we modify dynamic\n+                // patterns.\n                 (\"./src/foo.js\", \"src/foo.js\"),\n+                (\"./src/foo\", \"src/foo.js\"),\n                 (\"./src/foo.ts\", \"src/foo.ts\"),\n             ],\n         })"
        },
        {
            "sha": "e39be7cacbf69128b208af32e01423ea25690c98",
            "filename": "turbopack/crates/turbopack-core/src/resolve/pattern.rs",
            "status": "modified",
            "additions": 9,
            "deletions": 5,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/2fdb231e243a5338c0495f149a2dffb058ead37a/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fpattern.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2fdb231e243a5338c0495f149a2dffb058ead37a/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fpattern.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fpattern.rs?ref=2fdb231e243a5338c0495f149a2dffb058ead37a",
            "patch": "@@ -1229,7 +1229,10 @@ impl Pattern {\n     /// Calls `cb` on all constants that are at the end of the pattern and\n     /// replaces the given final constant with the returned pattern. Returns\n     /// true if replacements were performed.\n-    pub fn replace_final_constants(&mut self, cb: &impl Fn(&RcStr) -> Option<Pattern>) -> bool {\n+    pub fn replace_final_constants(\n+        &mut self,\n+        cb: &mut impl FnMut(&RcStr) -> Option<Pattern>,\n+    ) -> bool {\n         let mut replaced = false;\n         match self {\n             Pattern::Constant(c) => {\n@@ -1524,6 +1527,7 @@ impl PatternMatch {\n // TODO this isn't super efficient\n // avoid storing a large list of matches\n #[turbo_tasks::value(transparent)]\n+#[derive(Debug)]\n pub struct PatternMatches(Vec<PatternMatch>);\n \n /// Find all files or directories that match the provided `pattern` with the\n@@ -2492,12 +2496,12 @@ mod tests {\n \n     #[test]\n     fn replace_final_constants() {\n-        fn f(mut p: Pattern, cb: &impl Fn(&RcStr) -> Option<Pattern>) -> Pattern {\n+        fn f(mut p: Pattern, cb: &mut impl FnMut(&RcStr) -> Option<Pattern>) -> Pattern {\n             p.replace_final_constants(cb);\n             p\n         }\n \n-        let js_to_ts_tsx = |c: &RcStr| -> Option<Pattern> {\n+        let mut js_to_ts_tsx = |c: &RcStr| -> Option<Pattern> {\n             c.strip_suffix(\".js\").map(|rest| {\n                 let new_ending = Pattern::Alternatives(vec![\n                     Pattern::Constant(rcstr!(\".ts\")),\n@@ -2523,7 +2527,7 @@ mod tests {\n                         Pattern::Constant(rcstr!(\".node\")),\n                     ])\n                 ]),\n-                &js_to_ts_tsx\n+                &mut js_to_ts_tsx\n             ),\n             Pattern::Concatenation(vec![\n                 Pattern::Constant(rcstr!(\".\")),\n@@ -2546,7 +2550,7 @@ mod tests {\n                     Pattern::Constant(rcstr!(\"/\")),\n                     Pattern::Constant(rcstr!(\"abc.js\")),\n                 ]),\n-                &js_to_ts_tsx\n+                &mut js_to_ts_tsx\n             ),\n             Pattern::Concatenation(vec![\n                 Pattern::Constant(rcstr!(\".\")),"
        },
        {
            "sha": "0e92b249e975a7475cc8e1dcd225b46a2bbfd81b",
            "filename": "turbopack/crates/turbopack-tracing/tests/node-file-trace.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/2fdb231e243a5338c0495f149a2dffb058ead37a/turbopack%2Fcrates%2Fturbopack-tracing%2Ftests%2Fnode-file-trace.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2fdb231e243a5338c0495f149a2dffb058ead37a/turbopack%2Fcrates%2Fturbopack-tracing%2Ftests%2Fnode-file-trace.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tracing%2Ftests%2Fnode-file-trace.rs?ref=2fdb231e243a5338c0495f149a2dffb058ead37a",
            "patch": "@@ -40,6 +40,7 @@ use turbopack::{\n     },\n };\n use turbopack_core::{\n+    chunk::SourceMapsType,\n     compile_time_info::CompileTimeInfo,\n     context::AssetContext,\n     environment::{Environment, ExecutionEnvironment, NodeJsEnvironment},\n@@ -373,10 +374,12 @@ async fn node_file_trace_operation(\n                 enable_typescript_transform: Some(\n                     TypescriptTransformOptions::default().resolved_cell(),\n                 ),\n+                // enable_types is required here to ensure .d.ts files are collected.\n                 enable_types: true,\n                 ..Default::default()\n             },\n             css: CssOptionsContext {\n+                source_maps: SourceMapsType::None,\n                 enable_raw_css: true,\n                 ..Default::default()\n             },"
        },
        {
            "sha": "e2b5925488db7c32589079c3737cd32b8b3d2109",
            "filename": "turbopack/crates/turbopack-tracing/tests/unit.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/2fdb231e243a5338c0495f149a2dffb058ead37a/turbopack%2Fcrates%2Fturbopack-tracing%2Ftests%2Funit.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2fdb231e243a5338c0495f149a2dffb058ead37a/turbopack%2Fcrates%2Fturbopack-tracing%2Ftests%2Funit.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tracing%2Ftests%2Funit.rs?ref=2fdb231e243a5338c0495f149a2dffb058ead37a",
            "patch": "@@ -21,6 +21,7 @@ use turbopack::{\n     },\n };\n use turbopack_core::{\n+    chunk::SourceMapsType,\n     compile_time_info::CompileTimeInfo,\n     context::AssetContext,\n     environment::{Environment, ExecutionEnvironment, NodeJsEnvironment},\n@@ -212,6 +213,7 @@ async fn node_file_trace_operation(package_root: RcStr, input: RcStr) -> Result<\n                 ..Default::default()\n             },\n             css: CssOptionsContext {\n+                source_maps: SourceMapsType::None,\n                 enable_raw_css: true,\n                 ..Default::default()\n             },"
        }
    ],
    "stats": {
        "total": 386,
        "additions": 237,
        "deletions": 149
    }
}