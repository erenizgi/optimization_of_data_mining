{
    "author": "sokra",
    "message": "Turbopack: flatten sourceInfo to avoid objects, reorder args, compress node.js entry (#81545)\n\n### What?\r\n\r\nThis avoids creating many temporary objects for SourceInfo during module inititalization\r\n\r\nPart of PACK-5057",
    "sha": "dcca55ba269a347ba01732cb5fd0e00e68d44674",
    "files": [
        {
            "sha": "3502b7db0f210351996409c77ad7248710755a04",
            "filename": "test/e2e/app-dir/actions/app-action.test.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/dcca55ba269a347ba01732cb5fd0e00e68d44674/test%2Fe2e%2Fapp-dir%2Factions%2Fapp-action.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/dcca55ba269a347ba01732cb5fd0e00e68d44674/test%2Fe2e%2Fapp-dir%2Factions%2Fapp-action.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Factions%2Fapp-action.test.ts?ref=dcca55ba269a347ba01732cb5fd0e00e68d44674",
            "patch": "@@ -1002,7 +1002,7 @@ describe('app-dir action handling', () => {\n         { encoding: 'utf8' }\n       )\n       if (isTurbopack) {\n-        const chunkPaths = pageBundle.matchAll(/loadChunk\\(\"([^\"]*)\"\\)/g)\n+        const chunkPaths = pageBundle.matchAll(/R\\.c\\(\"([^\"]*)\"\\)/g)\n         const reads = [...chunkPaths].map(async (match) => {\n           const bundle = await fs.readFile(\n             join(next.testDir, '.next', ...match[1].split(/[\\\\/]/g)),"
        },
        {
            "sha": "af923da36edc69c0d928be6c491201b0e590c2fc",
            "filename": "turbopack/crates/turbopack-ecmascript-runtime/js/src/browser/runtime/base/build-base.ts",
            "status": "modified",
            "additions": 25,
            "deletions": 20,
            "changes": 45,
            "blob_url": "https://github.com/vercel/next.js/blob/dcca55ba269a347ba01732cb5fd0e00e68d44674/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fbase%2Fbuild-base.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/dcca55ba269a347ba01732cb5fd0e00e68d44674/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fbase%2Fbuild-base.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fbase%2Fbuild-base.ts?ref=dcca55ba269a347ba01732cb5fd0e00e68d44674",
            "patch": "@@ -11,8 +11,8 @@ const moduleCache: ModuleCache<Module> = {}\n // @ts-ignore\n // eslint-disable-next-line @typescript-eslint/no-unused-vars\n function getOrInstantiateRuntimeModule(\n-  moduleId: ModuleId,\n-  chunkPath: ChunkPath\n+  chunkPath: ChunkPath,\n+  moduleId: ModuleId\n ): Module {\n   const module = moduleCache[moduleId]\n   if (module) {\n@@ -22,7 +22,7 @@ function getOrInstantiateRuntimeModule(\n     return module\n   }\n \n-  return instantiateModule(moduleId, { type: SourceType.Runtime, chunkPath })\n+  return instantiateModule(moduleId, SourceType.Runtime, chunkPath)\n }\n \n /**\n@@ -40,38 +40,42 @@ const getOrInstantiateModuleFromParent: GetOrInstantiateModuleFromParent<\n     return module\n   }\n \n-  return instantiateModule(id, {\n-    type: SourceType.Parent,\n-    parentId: sourceModule.id,\n-  })\n+  return instantiateModule(id, SourceType.Parent, sourceModule.id)\n }\n \n-function instantiateModule(id: ModuleId, source: SourceInfo): Module {\n+function instantiateModule(\n+  id: ModuleId,\n+  sourceType: SourceType,\n+  sourceData: SourceData\n+): Module {\n   const moduleFactory = moduleFactories[id]\n   if (typeof moduleFactory !== 'function') {\n     // This can happen if modules incorrectly handle HMR disposes/updates,\n     // e.g. when they keep a `setTimeout` around which still executes old code\n     // and contains e.g. a `require(\"something\")` call.\n     let instantiationReason\n-    switch (source.type) {\n+    switch (sourceType) {\n       case SourceType.Runtime:\n-        instantiationReason = `as a runtime entry of chunk ${source.chunkPath}`\n+        instantiationReason = `as a runtime entry of chunk ${sourceData}`\n         break\n       case SourceType.Parent:\n-        instantiationReason = `because it was required from module ${source.parentId}`\n+        instantiationReason = `because it was required from module ${sourceData}`\n         break\n       case SourceType.Update:\n         instantiationReason = 'because of an HMR update'\n         break\n       default:\n-        invariant(source, (source) => `Unknown source type: ${source?.type}`)\n+        invariant(\n+          sourceType,\n+          (sourceType) => `Unknown source type: ${sourceType}`\n+        )\n     }\n     throw new Error(\n       `Module ${id} was instantiated ${instantiationReason}, but the module factory is not available. It might have been deleted in an HMR update.`\n     )\n   }\n \n-  switch (source.type) {\n+  switch (sourceType) {\n     case SourceType.Runtime:\n       runtimeModules.add(id)\n       break\n@@ -82,7 +86,10 @@ function instantiateModule(id: ModuleId, source: SourceInfo): Module {\n     case SourceType.Update:\n       throw new Error('Unexpected')\n     default:\n-      invariant(source, (source) => `Unknown source type: ${source?.type}`)\n+      invariant(\n+        sourceType,\n+        (sourceType) => `Unknown source type: ${sourceType}`\n+      )\n   }\n \n   const module: Module = {\n@@ -97,8 +104,6 @@ function instantiateModule(id: ModuleId, source: SourceInfo): Module {\n \n   // NOTE(alexkirsz) This can fail when the module encounters a runtime error.\n   try {\n-    const sourceInfo: SourceInfo = { type: SourceType.Parent, parentId: id }\n-\n     const r = commonJsRequire.bind(null, module)\n     moduleFactory(\n       augmentContext({\n@@ -115,10 +120,10 @@ function instantiateModule(id: ModuleId, source: SourceInfo): Module {\n         m: module,\n         c: moduleCache,\n         M: moduleFactories,\n-        l: loadChunk.bind(null, sourceInfo),\n-        L: loadChunkByUrl.bind(null, sourceInfo),\n-        w: loadWebAssembly.bind(null, sourceInfo),\n-        u: loadWebAssemblyModule.bind(null, sourceInfo),\n+        l: loadChunk.bind(null, SourceType.Parent, id),\n+        L: loadChunkByUrl.bind(null, SourceType.Parent, id),\n+        w: loadWebAssembly.bind(null, SourceType.Parent, id),\n+        u: loadWebAssemblyModule.bind(null, SourceType.Parent, id),\n         P: resolveAbsolutePath,\n         U: relativeURL,\n         R: createResolvePathFromModule(r),"
        },
        {
            "sha": "bfee8e44c20bf9bdc0bde5ef3ec7208d7ec0dec0",
            "filename": "turbopack/crates/turbopack-ecmascript-runtime/js/src/browser/runtime/base/dev-base.ts",
            "status": "modified",
            "additions": 33,
            "deletions": 27,
            "changes": 60,
            "blob_url": "https://github.com/vercel/next.js/blob/dcca55ba269a347ba01732cb5fd0e00e68d44674/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fbase%2Fdev-base.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/dcca55ba269a347ba01732cb5fd0e00e68d44674/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fbase%2Fdev-base.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fbase%2Fdev-base.ts?ref=dcca55ba269a347ba01732cb5fd0e00e68d44674",
            "patch": "@@ -81,8 +81,8 @@ const queuedInvalidatedModules: Set<ModuleId> = new Set()\n  */\n // @ts-ignore\n function getOrInstantiateRuntimeModule(\n-  moduleId: ModuleId,\n-  chunkPath: ChunkPath\n+  chunkPath: ChunkPath,\n+  moduleId: ModuleId\n ): Module {\n   const module = devModuleCache[moduleId]\n   if (module) {\n@@ -93,7 +93,7 @@ function getOrInstantiateRuntimeModule(\n   }\n \n   // @ts-ignore\n-  return instantiateModule(moduleId, { type: SourceType.Runtime, chunkPath })\n+  return instantiateModule(moduleId, SourceType.Runtime, chunkPath)\n }\n \n /**\n@@ -123,13 +123,14 @@ const getOrInstantiateModuleFromParent: GetOrInstantiateModuleFromParent<\n     return module\n   }\n \n-  return instantiateModule(id, {\n-    type: SourceType.Parent,\n-    parentId: sourceModule.id,\n-  })\n+  return instantiateModule(id, SourceType.Parent, sourceModule.id)\n }\n \n-function instantiateModule(moduleId: ModuleId, source: SourceInfo): Module {\n+function instantiateModule(\n+  moduleId: ModuleId,\n+  sourceType: SourceType,\n+  sourceData: SourceData\n+): Module {\n   // We are in development, this is always a string.\n   let id = moduleId as string\n \n@@ -139,18 +140,21 @@ function instantiateModule(moduleId: ModuleId, source: SourceInfo): Module {\n     // e.g. when they keep a `setTimeout` around which still executes old code\n     // and contains e.g. a `require(\"something\")` call.\n     let instantiationReason\n-    switch (source.type) {\n+    switch (sourceType) {\n       case SourceType.Runtime:\n-        instantiationReason = `as a runtime entry of chunk ${source.chunkPath}`\n+        instantiationReason = `as a runtime entry of chunk ${sourceData}`\n         break\n       case SourceType.Parent:\n-        instantiationReason = `because it was required from module ${source.parentId}`\n+        instantiationReason = `because it was required from module ${sourceData}`\n         break\n       case SourceType.Update:\n         instantiationReason = 'because of an HMR update'\n         break\n       default:\n-        invariant(source, (source) => `Unknown source type: ${source?.type}`)\n+        invariant(\n+          sourceType,\n+          (sourceType) => `Unknown source type: ${sourceType}`\n+        )\n     }\n     throw new Error(\n       `Module ${id} was instantiated ${instantiationReason}, but the module factory is not available. It might have been deleted in an HMR update.`\n@@ -161,21 +165,24 @@ function instantiateModule(moduleId: ModuleId, source: SourceInfo): Module {\n   const { hot, hotState } = createModuleHot(id, hotData)\n \n   let parents: ModuleId[]\n-  switch (source.type) {\n+  switch (sourceType) {\n     case SourceType.Runtime:\n       runtimeModules.add(id)\n       parents = []\n       break\n     case SourceType.Parent:\n       // No need to add this module as a child of the parent module here, this\n       // has already been taken care of in `getOrInstantiateModuleFromParent`.\n-      parents = [source.parentId]\n+      parents = [sourceData as ModuleId]\n       break\n     case SourceType.Update:\n-      parents = source.parents || []\n+      parents = (sourceData as ModuleId[]) || []\n       break\n     default:\n-      invariant(source, (source) => `Unknown source type: ${source?.type}`)\n+      invariant(\n+        sourceType,\n+        (sourceType) => `Unknown source type: ${sourceType}`\n+      )\n   }\n \n   const module: HotModule = {\n@@ -194,8 +201,6 @@ function instantiateModule(moduleId: ModuleId, source: SourceInfo): Module {\n \n   // NOTE(alexkirsz) This can fail when the module encounters a runtime error.\n   try {\n-    const sourceInfo: SourceInfo = { type: SourceType.Parent, parentId: id }\n-\n     runModuleExecutionHooks(module, (refresh) => {\n       const r = commonJsRequire.bind(null, module)\n       moduleFactory(\n@@ -214,10 +219,10 @@ function instantiateModule(moduleId: ModuleId, source: SourceInfo): Module {\n           c: devModuleCache,\n           C: null,\n           M: moduleFactories,\n-          l: loadChunk.bind(null, sourceInfo),\n-          L: loadChunkByUrl.bind(null, sourceInfo),\n-          w: loadWebAssembly.bind(null, sourceInfo),\n-          u: loadWebAssemblyModule.bind(null, sourceInfo),\n+          l: loadChunk.bind(null, SourceType.Parent, id),\n+          L: loadChunkByUrl.bind(null, SourceType.Parent, id),\n+          w: loadWebAssembly.bind(null, SourceType.Parent, id),\n+          u: loadWebAssemblyModule.bind(null, SourceType.Parent, id),\n           P: resolveAbsolutePath,\n           U: relativeURL,\n           k: refresh,\n@@ -557,10 +562,11 @@ function applyPhase(\n   // Re-instantiate all outdated self-accepted modules.\n   for (const { moduleId, errorHandler } of outdatedSelfAcceptedModules) {\n     try {\n-      instantiateModule(moduleId, {\n-        type: SourceType.Update,\n-        parents: outdatedModuleParents.get(moduleId),\n-      })\n+      instantiateModule(\n+        moduleId,\n+        SourceType.Update,\n+        outdatedModuleParents.get(moduleId)\n+      )\n     } catch (err) {\n       if (typeof errorHandler === 'function') {\n         try {\n@@ -607,7 +613,7 @@ function applyChunkListUpdate(update: ChunkListUpdate) {\n \n       switch (chunkUpdate.type) {\n         case 'added':\n-          BACKEND.loadChunkCached(chunkUrl, { type: SourceType.Update })\n+          BACKEND.loadChunkCached(SourceType.Update, undefined, chunkUrl)\n           break\n         case 'total':\n           DEV_BACKEND.reloadChunk?.(chunkUrl)"
        },
        {
            "sha": "a54d297b1c8b5c32d33def707a14ac0167ba99dd",
            "filename": "turbopack/crates/turbopack-ecmascript-runtime/js/src/browser/runtime/base/dummy.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/dcca55ba269a347ba01732cb5fd0e00e68d44674/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fbase%2Fdummy.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/dcca55ba269a347ba01732cb5fd0e00e68d44674/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fbase%2Fdummy.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fbase%2Fdummy.ts?ref=dcca55ba269a347ba01732cb5fd0e00e68d44674",
            "patch": "@@ -12,13 +12,15 @@\n \n declare var BACKEND: RuntimeBackend\n declare var loadWebAssembly: (\n-  source: SourceInfo,\n+  sourceType: SourceType,\n+  sourceData: SourceData,\n   wasmChunkPath: ChunkPath,\n   edgeModule: () => WebAssembly.Module,\n   imports: WebAssembly.Imports\n ) => Exports\n declare var loadWebAssemblyModule: (\n-  source: SourceInfo,\n+  sourceType: SourceType,\n+  sourceData: SourceData,\n   wasmChunkPath: ChunkPath,\n   edgeModule: () => WebAssembly.Module\n ) => WebAssembly.Module"
        },
        {
            "sha": "8889fd84af06fca534a690a6405b7f5d6dd20225",
            "filename": "turbopack/crates/turbopack-ecmascript-runtime/js/src/browser/runtime/base/runtime-base.ts",
            "status": "modified",
            "additions": 36,
            "deletions": 29,
            "changes": 65,
            "blob_url": "https://github.com/vercel/next.js/blob/dcca55ba269a347ba01732cb5fd0e00e68d44674/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fbase%2Fruntime-base.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/dcca55ba269a347ba01732cb5fd0e00e68d44674/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fbase%2Fruntime-base.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fbase%2Fruntime-base.ts?ref=dcca55ba269a347ba01732cb5fd0e00e68d44674",
            "patch": "@@ -22,7 +22,11 @@ declare var CHUNK_BASE_PATH: string\n declare var CHUNK_SUFFIX_PATH: string\n \n // Provided by build or dev base\n-declare function instantiateModule(id: ModuleId, source: SourceInfo): Module\n+declare function instantiateModule(\n+  id: ModuleId,\n+  sourceType: SourceType,\n+  sourceData: SourceData\n+): Module\n \n type RuntimeParams = {\n   otherChunks: ChunkData[]\n@@ -45,39 +49,33 @@ enum SourceType {\n   /**\n    * The module was instantiated because it was included in an evaluated chunk's\n    * runtime.\n+   * SourceData is a ChunkPath.\n    */\n   Runtime = 0,\n   /**\n    * The module was instantiated because a parent module imported it.\n+   * SourceData is a ModuleId.\n    */\n   Parent = 1,\n   /**\n    * The module was instantiated because it was included in a chunk's hot module\n    * update.\n+   * SourceData is an array of ModuleIds or undefined.\n    */\n   Update = 2,\n }\n \n-type SourceInfo =\n-  | {\n-      type: SourceType.Runtime\n-      chunkPath: ChunkPath\n-    }\n-  | {\n-      type: SourceType.Parent\n-      parentId: ModuleId\n-    }\n-  | {\n-      type: SourceType.Update\n-      parents?: ModuleId[]\n-    }\n-\n+type SourceData = ChunkPath | ModuleId | ModuleId[] | undefined\n interface RuntimeBackend {\n   registerChunk: (chunkPath: ChunkPath, params?: RuntimeParams) => void\n   /**\n    * Returns the same Promise for the same chunk URL.\n    */\n-  loadChunkCached: (chunkUrl: ChunkUrl, source: SourceInfo) => Promise<void>\n+  loadChunkCached: (\n+    sourceType: SourceType,\n+    sourceData: SourceData,\n+    chunkUrl: ChunkUrl\n+  ) => Promise<void>\n }\n \n interface DevRuntimeBackend {\n@@ -123,11 +121,12 @@ const availableModules: Map<ModuleId, Promise<any> | true> = new Map()\n const availableModuleChunks: Map<ChunkPath, Promise<any> | true> = new Map()\n \n async function loadChunk(\n-  source: SourceInfo,\n+  sourceType: SourceType,\n+  sourceData: SourceData,\n   chunkData: ChunkData\n ): Promise<any> {\n   if (typeof chunkData === 'string') {\n-    return loadChunkPath(source, chunkData)\n+    return loadChunkPath(sourceType, sourceData, chunkData)\n   }\n \n   const includedList = chunkData.included || []\n@@ -166,7 +165,7 @@ async function loadChunk(\n     }\n \n     for (const moduleChunkToLoad of moduleChunksToLoad) {\n-      const promise = loadChunkPath(source, moduleChunkToLoad)\n+      const promise = loadChunkPath(sourceType, sourceData, moduleChunkToLoad)\n \n       availableModuleChunks.set(moduleChunkToLoad, promise)\n \n@@ -175,7 +174,7 @@ async function loadChunk(\n \n     promise = Promise.all(moduleChunksPromises)\n   } else {\n-    promise = loadChunkPath(source, chunkData.path)\n+    promise = loadChunkPath(sourceType, sourceData, chunkData.path)\n \n     // Mark all included module chunks as loading if they are not already loaded or loading.\n     for (const includedModuleChunk of includedModuleChunksList) {\n@@ -202,8 +201,12 @@ const instrumentedBackendLoadChunks = new WeakMap<\n   Promise<any> | typeof loadedChunk\n >()\n // Do not make this async. React relies on referential equality of the returned Promise.\n-function loadChunkByUrl(source: SourceInfo, chunkUrl: ChunkUrl): Promise<any> {\n-  const thenable = BACKEND.loadChunkCached(chunkUrl, source)\n+function loadChunkByUrl(\n+  sourceType: SourceType,\n+  sourceData: SourceData,\n+  chunkUrl: ChunkUrl\n+): Promise<any> {\n+  const thenable = BACKEND.loadChunkCached(sourceType, sourceData, chunkUrl)\n   let entry = instrumentedBackendLoadChunks.get(thenable)\n   if (entry === undefined) {\n     const resolve = instrumentedBackendLoadChunks.set.bind(\n@@ -213,18 +216,21 @@ function loadChunkByUrl(source: SourceInfo, chunkUrl: ChunkUrl): Promise<any> {\n     )\n     entry = thenable.then(resolve).catch((error) => {\n       let loadReason\n-      switch (source.type) {\n+      switch (sourceType) {\n         case SourceType.Runtime:\n-          loadReason = `as a runtime dependency of chunk ${source.chunkPath}`\n+          loadReason = `as a runtime dependency of chunk ${sourceData}`\n           break\n         case SourceType.Parent:\n-          loadReason = `from module ${source.parentId}`\n+          loadReason = `from module ${sourceData}`\n           break\n         case SourceType.Update:\n           loadReason = 'from an HMR update'\n           break\n         default:\n-          invariant(source, (source) => `Unknown source type: ${source?.type}`)\n+          invariant(\n+            sourceType,\n+            (sourceType) => `Unknown source type: ${sourceType}`\n+          )\n       }\n       throw new Error(\n         `Failed to load chunk ${chunkUrl} ${loadReason}${\n@@ -244,11 +250,12 @@ function loadChunkByUrl(source: SourceInfo, chunkUrl: ChunkUrl): Promise<any> {\n }\n \n async function loadChunkPath(\n-  source: SourceInfo,\n+  sourceType: SourceType,\n+  sourceData: SourceData,\n   chunkPath: ChunkPath\n ): Promise<any> {\n   const url = getChunkRelativeUrl(chunkPath)\n-  return loadChunkByUrl(source, url)\n+  return loadChunkByUrl(sourceType, sourceData, url)\n }\n \n /**\n@@ -327,7 +334,7 @@ function instantiateRuntimeModule(\n   moduleId: ModuleId,\n   chunkPath: ChunkPath\n ): Module {\n-  return instantiateModule(moduleId, { type: SourceType.Runtime, chunkPath })\n+  return instantiateModule(moduleId, SourceType.Runtime, chunkPath)\n }\n /**\n  * Returns the URL relative to the origin where a chunk can be fetched from."
        },
        {
            "sha": "de8569f2d603537059ba4a0a7eca3883cf3f7575",
            "filename": "turbopack/crates/turbopack-ecmascript-runtime/js/src/browser/runtime/dom/runtime-backend-dom.ts",
            "status": "modified",
            "additions": 18,
            "deletions": 8,
            "changes": 26,
            "blob_url": "https://github.com/vercel/next.js/blob/dcca55ba269a347ba01732cb5fd0e00e68d44674/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fdom%2Fruntime-backend-dom.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/dcca55ba269a347ba01732cb5fd0e00e68d44674/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fdom%2Fruntime-backend-dom.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fdom%2Fruntime-backend-dom.ts?ref=dcca55ba269a347ba01732cb5fd0e00e68d44674",
            "patch": "@@ -29,7 +29,8 @@ function fetchWebAssembly(wasmChunkPath: ChunkPath) {\n }\n \n async function loadWebAssembly(\n-  _source: unknown,\n+  _sourceType: SourceType,\n+  _sourceData: SourceData,\n   wasmChunkPath: ChunkPath,\n   _edgeModule: () => WebAssembly.Module,\n   importsObj: WebAssembly.Imports\n@@ -42,7 +43,8 @@ async function loadWebAssembly(\n }\n \n async function loadWebAssemblyModule(\n-  _source: unknown,\n+  _sourceType: SourceType,\n+  _sourceData: SourceData,\n   wasmChunkPath: ChunkPath,\n   _edgeModule: () => WebAssembly.Module\n ): Promise<WebAssembly.Module> {\n@@ -79,13 +81,13 @@ const chunkResolvers: Map<ChunkUrl, ChunkResolver> = new Map()\n       // This waits for chunks to be loaded, but also marks included items as available.\n       await Promise.all(\n         params.otherChunks.map((otherChunkData) =>\n-          loadChunk({ type: SourceType.Runtime, chunkPath }, otherChunkData)\n+          loadChunk(SourceType.Runtime, chunkPath, otherChunkData)\n         )\n       )\n \n       if (params.runtimeModuleIds.length > 0) {\n         for (const moduleId of params.runtimeModuleIds) {\n-          getOrInstantiateRuntimeModule(moduleId, chunkPath)\n+          getOrInstantiateRuntimeModule(chunkPath, moduleId)\n         }\n       }\n     },\n@@ -94,8 +96,12 @@ const chunkResolvers: Map<ChunkUrl, ChunkResolver> = new Map()\n      * Loads the given chunk, and returns a promise that resolves once the chunk\n      * has been loaded.\n      */\n-    loadChunkCached(chunkUrl, source) {\n-      return doLoadChunk(chunkUrl, source)\n+    loadChunkCached(\n+      sourceType: SourceType,\n+      sourceData: SourceData,\n+      chunkUrl: ChunkUrl\n+    ) {\n+      return doLoadChunk(sourceType, sourceData, chunkUrl)\n     },\n   }\n \n@@ -127,13 +133,17 @@ const chunkResolvers: Map<ChunkUrl, ChunkResolver> = new Map()\n    * Loads the given chunk, and returns a promise that resolves once the chunk\n    * has been loaded.\n    */\n-  function doLoadChunk(chunkUrl: ChunkUrl, source: SourceInfo) {\n+  function doLoadChunk(\n+    sourceType: SourceType,\n+    _sourceData: SourceData,\n+    chunkUrl: ChunkUrl\n+  ) {\n     const resolver = getOrCreateResolver(chunkUrl)\n     if (resolver.loadingStarted) {\n       return resolver.promise\n     }\n \n-    if (source.type === SourceType.Runtime) {\n+    if (sourceType === SourceType.Runtime) {\n       // We don't need to load chunks references from runtime code, as they're already\n       // present in the DOM.\n       resolver.loadingStarted = true"
        },
        {
            "sha": "4565a4abdb464e54272a8d46dcec764e9caee304",
            "filename": "turbopack/crates/turbopack-ecmascript-runtime/js/src/browser/runtime/edge/runtime-backend-edge.ts",
            "status": "modified",
            "additions": 16,
            "deletions": 5,
            "changes": 21,
            "blob_url": "https://github.com/vercel/next.js/blob/dcca55ba269a347ba01732cb5fd0e00e68d44674/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fedge%2Fruntime-backend-edge.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/dcca55ba269a347ba01732cb5fd0e00e68d44674/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fedge%2Fruntime-backend-edge.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fedge%2Fruntime-backend-edge.ts?ref=dcca55ba269a347ba01732cb5fd0e00e68d44674",
            "patch": "@@ -43,12 +43,18 @@ function augmentContext(\n }\n \n async function loadWebAssembly(\n-  source: SourceInfo,\n+  sourceType: SourceType,\n+  sourceData: SourceData,\n   chunkPath: ChunkPath,\n   edgeModule: () => WebAssembly.Module,\n   imports: WebAssembly.Imports\n ): Promise<Exports> {\n-  const module = await loadWebAssemblyModule(source, chunkPath, edgeModule)\n+  const module = await loadWebAssemblyModule(\n+    sourceType,\n+    sourceData,\n+    chunkPath,\n+    edgeModule\n+  )\n \n   return await WebAssembly.instantiate(module, imports)\n }\n@@ -66,7 +72,8 @@ function getFileStem(path: string): string {\n }\n \n async function loadWebAssemblyModule(\n-  _source: SourceInfo,\n+  _sourceType: SourceType,\n+  _sourceData: SourceData,\n   chunkPath: ChunkPath,\n   edgeModule: () => WebAssembly.Module\n ): Promise<WebAssembly.Module> {\n@@ -117,7 +124,11 @@ async function loadWebAssemblyModule(\n       }\n     },\n \n-    loadChunkCached(_chunkUrl, _source) {\n+    loadChunkCached(\n+      _sourceType: SourceType,\n+      _sourceData: SourceData,\n+      _chunkUrl: ChunkUrl\n+    ) {\n       throw new Error('chunk loading is not supported')\n     },\n   }\n@@ -189,7 +200,7 @@ async function loadWebAssemblyModule(\n     chunkPath: ChunkPath\n   ) {\n     for (const moduleId of runtimeModuleIds) {\n-      getOrInstantiateRuntimeModule(moduleId, chunkPath)\n+      getOrInstantiateRuntimeModule(chunkPath, moduleId)\n     }\n   }\n })()"
        },
        {
            "sha": "6e7cb7fc6a27d84118929fe44ebfb7eee43a675d",
            "filename": "turbopack/crates/turbopack-ecmascript-runtime/js/src/nodejs/runtime.ts",
            "status": "modified",
            "additions": 65,
            "deletions": 50,
            "changes": 115,
            "blob_url": "https://github.com/vercel/next.js/blob/dcca55ba269a347ba01732cb5fd0e00e68d44674/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fnodejs%2Fruntime.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/dcca55ba269a347ba01732cb5fd0e00e68d44674/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fnodejs%2Fruntime.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fnodejs%2Fruntime.ts?ref=dcca55ba269a347ba01732cb5fd0e00e68d44674",
            "patch": "@@ -9,34 +9,34 @@ enum SourceType {\n   /**\n    * The module was instantiated because it was included in an evaluated chunk's\n    * runtime.\n+   * SourceData is a ChunkPath.\n    */\n   Runtime = 0,\n   /**\n    * The module was instantiated because a parent module imported it.\n+   * SourceData is a ModuleId.\n    */\n   Parent = 1,\n }\n \n-type SourceInfo =\n-  | {\n-      type: SourceType.Runtime\n-      chunkPath: ChunkPath\n-    }\n-  | {\n-      type: SourceType.Parent\n-      parentId: ModuleId\n-    }\n+type SourceData = ChunkPath | ModuleId\n \n process.env.TURBOPACK = '1'\n \n-function stringifySourceInfo(source: SourceInfo): string {\n-  switch (source.type) {\n+function stringifySourceInfo(\n+  sourceType: SourceType,\n+  sourceData: SourceData\n+): string {\n+  switch (sourceType) {\n     case SourceType.Runtime:\n-      return `runtime for chunk ${source.chunkPath}`\n+      return `runtime for chunk ${sourceData}`\n     case SourceType.Parent:\n-      return `parent module ${source.parentId}`\n+      return `parent module ${sourceData}`\n     default:\n-      invariant(source, (source) => `Unknown source type: ${source?.type}`)\n+      invariant(\n+        sourceType,\n+        (sourceType) => `Unknown source type: ${sourceType}`\n+      )\n   }\n }\n \n@@ -84,11 +84,15 @@ function createResolvePathFromModule(\n   }\n }\n \n-function loadChunk(chunkData: ChunkData, source?: SourceInfo): void {\n+function loadChunk(\n+  sourceType: SourceType,\n+  sourceData: SourceData,\n+  chunkData: ChunkData\n+): void {\n   if (typeof chunkData === 'string') {\n-    loadChunkPath(chunkData, source)\n+    loadChunkPath(sourceType, sourceData, chunkData)\n   } else {\n-    loadChunkPath(chunkData.path, source)\n+    loadChunkPath(sourceType, sourceData, chunkData.path)\n   }\n }\n \n@@ -101,7 +105,11 @@ function clearChunkCache() {\n   chunkCache.clear()\n }\n \n-function loadChunkPath(chunkPath: ChunkPath, source?: SourceInfo): void {\n+function loadChunkPath(\n+  sourceType: SourceType,\n+  sourceData: SourceData,\n+  chunkPath: ChunkPath\n+): void {\n   if (!isJs(chunkPath)) {\n     // We only support loading JS chunks in Node.js.\n     // This branch can be hit when trying to load a CSS chunk.\n@@ -133,8 +141,8 @@ function loadChunkPath(chunkPath: ChunkPath, source?: SourceInfo): void {\n   } catch (e) {\n     let errorMessage = `Failed to load chunk ${chunkPath}`\n \n-    if (source) {\n-      errorMessage += ` from ${stringifySourceInfo(source)}`\n+    if (sourceType !== undefined) {\n+      errorMessage += ` from ${stringifySourceInfo(sourceType, sourceData)}`\n     }\n \n     throw new Error(errorMessage, {\n@@ -166,7 +174,8 @@ function loadChunkUncached(chunkPath: ChunkPath) {\n }\n \n function loadChunkAsync(\n-  source: SourceInfo,\n+  sourceType: SourceType,\n+  sourceData: SourceData,\n   chunkData: ChunkData\n ): Promise<void> {\n   const chunkPath = typeof chunkData === 'string' ? chunkData : chunkData.path\n@@ -184,8 +193,8 @@ function loadChunkAsync(\n       entry = loadedChunk\n     } catch (e) {\n       let errorMessage = `Failed to load chunk ${chunkPath}`\n-      if (source) {\n-        errorMessage += ` from ${stringifySourceInfo(source)}`\n+      if (sourceType !== undefined) {\n+        errorMessage += ` from ${stringifySourceInfo(sourceType, sourceData)}`\n       }\n \n       // Cache the failure promise, future requests will also get this same rejection\n@@ -201,9 +210,13 @@ function loadChunkAsync(\n   return entry\n }\n \n-function loadChunkAsyncByUrl(source: SourceInfo, chunkUrl: string) {\n+function loadChunkAsyncByUrl(\n+  sourceType: SourceType,\n+  sourceData: SourceData,\n+  chunkUrl: string\n+) {\n   const path = url.fileURLToPath(new URL(chunkUrl, RUNTIME_ROOT)) as ChunkPath\n-  return loadChunkAsync(source, path)\n+  return loadChunkAsync(sourceType, sourceData, path)\n }\n \n function loadWebAssembly(\n@@ -229,25 +242,32 @@ function getWorkerBlobURL(_chunks: ChunkPath[]): string {\n   throw new Error('Worker blobs are not implemented yet for Node.js')\n }\n \n-function instantiateModule(id: ModuleId, source: SourceInfo): Module {\n+function instantiateModule(\n+  id: ModuleId,\n+  sourceType: SourceType,\n+  sourceData: SourceData\n+): Module {\n   const moduleFactory = moduleFactories[id]\n   if (typeof moduleFactory !== 'function') {\n     // This can happen if modules incorrectly handle HMR disposes/updates,\n     // e.g. when they keep a `setTimeout` around which still executes old code\n     // and contains e.g. a `require(\"something\")` call.\n     let instantiationReason\n-    switch (source.type) {\n+    switch (sourceType) {\n       case SourceType.Runtime:\n-        instantiationReason = `as a runtime entry of chunk ${source.chunkPath}`\n+        instantiationReason = `as a runtime entry of chunk ${sourceData}`\n         break\n       case SourceType.Parent:\n-        instantiationReason = `because it was required from module ${source.parentId}`\n+        instantiationReason = `because it was required from module ${sourceData}`\n         break\n       default:\n-        invariant(source, (source) => `Unknown source type: ${source?.type}`)\n+        invariant(\n+          sourceType,\n+          (sourceType) => `Unknown source type: ${sourceType}`\n+        )\n     }\n     throw new Error(\n-      `Module ${id} was instantiated ${instantiationReason}, but the module factory is not available. It might have been deleted in an HMR update.`\n+      `Module ${id} was instantiated ${instantiationReason}, but the module factory is not available.`\n     )\n   }\n \n@@ -279,11 +299,8 @@ function instantiateModule(id: ModuleId, source: SourceInfo): Module {\n       m: module,\n       c: moduleCache,\n       M: moduleFactories,\n-      l: loadChunkAsync.bind(null, { type: SourceType.Parent, parentId: id }),\n-      L: loadChunkAsyncByUrl.bind(null, {\n-        type: SourceType.Parent,\n-        parentId: id,\n-      }),\n+      l: loadChunkAsync.bind(null, SourceType.Parent, id),\n+      L: loadChunkAsyncByUrl.bind(null, SourceType.Parent, id),\n       C: clearChunkCache,\n       w: loadWebAssembly,\n       u: loadWebAssemblyModule,\n@@ -321,29 +338,26 @@ function getOrInstantiateModuleFromParent(\n     return module\n   }\n \n-  return instantiateModule(id, {\n-    type: SourceType.Parent,\n-    parentId: sourceModule.id,\n-  })\n+  return instantiateModule(id, SourceType.Parent, sourceModule.id)\n }\n \n /**\n  * Instantiates a runtime module.\n  */\n function instantiateRuntimeModule(\n-  moduleId: ModuleId,\n-  chunkPath: ChunkPath\n+  chunkPath: ChunkPath,\n+  moduleId: ModuleId\n ): Module {\n-  return instantiateModule(moduleId, { type: SourceType.Runtime, chunkPath })\n+  return instantiateModule(moduleId, SourceType.Runtime, chunkPath)\n }\n \n /**\n  * Retrieves a module from the cache, or instantiate it as a runtime module if it is not cached.\n  */\n // @ts-ignore TypeScript doesn't separate this module space from the browser runtime\n function getOrInstantiateRuntimeModule(\n-  moduleId: ModuleId,\n-  chunkPath: ChunkPath\n+  chunkPath: ChunkPath,\n+  moduleId: ModuleId\n ): Module {\n   const module = moduleCache[moduleId]\n   if (module) {\n@@ -353,7 +367,7 @@ function getOrInstantiateRuntimeModule(\n     return module\n   }\n \n-  return instantiateRuntimeModule(moduleId, chunkPath)\n+  return instantiateRuntimeModule(chunkPath, moduleId)\n }\n \n const regexJsUrl = /\\.js(?:\\?[^#]*)?(?:#.*)?$/\n@@ -364,7 +378,8 @@ function isJs(chunkUrlOrPath: ChunkUrl | ChunkPath): boolean {\n   return regexJsUrl.test(chunkUrlOrPath)\n }\n \n-module.exports = {\n-  getOrInstantiateRuntimeModule,\n-  loadChunk,\n-}\n+module.exports = (sourcePath: ChunkPath) => ({\n+  m: (id: ModuleId) => getOrInstantiateRuntimeModule(sourcePath, id),\n+  c: (chunkData: ChunkData) =>\n+    loadChunk(SourceType.Runtime, sourcePath, chunkData),\n+})"
        },
        {
            "sha": "6d01c007a645820d1dcab6e2c5143ddc32f6ac80",
            "filename": "turbopack/crates/turbopack-ecmascript-runtime/js/src/shared/runtime-utils.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/dcca55ba269a347ba01732cb5fd0e00e68d44674/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fshared%2Fruntime-utils.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/dcca55ba269a347ba01732cb5fd0e00e68d44674/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fshared%2Fruntime-utils.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fshared%2Fruntime-utils.ts?ref=dcca55ba269a347ba01732cb5fd0e00e68d44674",
            "patch": "@@ -44,8 +44,8 @@ type GetOrInstantiateModuleFromParent<M extends Module> = (\n ) => M\n \n declare function getOrInstantiateRuntimeModule(\n-  moduleId: ModuleId,\n-  chunkPath: ChunkPath\n+  chunkPath: ChunkPath,\n+  moduleId: ModuleId\n ): Module\n \n const hasOwnProperty = Object.prototype.hasOwnProperty"
        },
        {
            "sha": "5c6c8422301d4b4bfc1a9bfe4a93f88d3b815b6b",
            "filename": "turbopack/crates/turbopack-nodejs/src/ecmascript/node/entry/chunk.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 7,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/dcca55ba269a347ba01732cb5fd0e00e68d44674/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fentry%2Fchunk.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/dcca55ba269a347ba01732cb5fd0e00e68d44674/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fentry%2Fchunk.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fentry%2Fchunk.rs?ref=dcca55ba269a347ba01732cb5fd0e00e68d44674",
            "patch": "@@ -86,11 +86,10 @@ impl EcmascriptBuildNodeEntryChunk {\n         writedoc!(\n             code,\n             r#\"\n-                const CHUNK_PUBLIC_PATH = {};\n-                const runtime = require({});\n+                var R=require({})({})\n             \"#,\n+            StringifyJs(&*runtime_relative_path),\n             StringifyJs(chunk_public_path),\n-            StringifyJs(&*runtime_relative_path)\n         )?;\n \n         let other_chunks = this.other_chunks.await?;\n@@ -102,7 +101,7 @@ impl EcmascriptBuildNodeEntryChunk {\n                     // TODO(WEB-1112) This should call `require()` directly, perhaps as an argument\n                     // to `loadChunk`.\n                     r#\"\n-                        runtime.loadChunk({});\n+                        R.c({})\n                     \"#,\n                     StringifyJs(&other_chunk_public_path)\n                 )?;\n@@ -121,7 +120,7 @@ impl EcmascriptBuildNodeEntryChunk {\n                 writedoc!(\n                     code,\n                     r#\"\n-                        runtime.getOrInstantiateRuntimeModule({}, CHUNK_PUBLIC_PATH);\n+                        R.m({})\n                     \"#,\n                     StringifyJs(&*runtime_module_id),\n                 )?;\n@@ -136,8 +135,8 @@ impl EcmascriptBuildNodeEntryChunk {\n         writedoc!(\n             code,\n             r#\"\n-                    module.exports = runtime.getOrInstantiateRuntimeModule({}, CHUNK_PUBLIC_PATH).exports;\n-                \"#,\n+                module.exports=R.m({}).exports\n+            \"#,\n             StringifyJs(&*runtime_module_id),\n         )?;\n "
        },
        {
            "sha": "dc06b8e7d0d6826abe88e8bedd389113bc6a5ffa",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/basic/async_chunk_build/output/index.entry.js",
            "status": "modified",
            "additions": 5,
            "deletions": 6,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/dcca55ba269a347ba01732cb5fd0e00e68d44674/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fbasic%2Fasync_chunk_build%2Foutput%2Findex.entry.js",
            "raw_url": "https://github.com/vercel/next.js/raw/dcca55ba269a347ba01732cb5fd0e00e68d44674/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fbasic%2Fasync_chunk_build%2Foutput%2Findex.entry.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fbasic%2Fasync_chunk_build%2Foutput%2Findex.entry.js?ref=dcca55ba269a347ba01732cb5fd0e00e68d44674",
            "patch": "@@ -1,6 +1,5 @@\n-const CHUNK_PUBLIC_PATH = \"output/index.entry.js\";\n-const runtime = require(\"./[turbopack]_runtime.js\");\n-runtime.loadChunk(\"output/b1abf_turbopack-tests_tests_snapshot_basic_async_chunk_build_input_import_2a82c7a5.js\");\n-runtime.loadChunk(\"output/4e721_crates_turbopack-tests_tests_snapshot_basic_async_chunk_build_input_1e41378a._.js\");\n-runtime.getOrInstantiateRuntimeModule(\"[project]/turbopack/crates/turbopack-tests/tests/snapshot/basic/async_chunk_build/input/index.js [test] (ecmascript)\", CHUNK_PUBLIC_PATH);\n-module.exports = runtime.getOrInstantiateRuntimeModule(\"[project]/turbopack/crates/turbopack-tests/tests/snapshot/basic/async_chunk_build/input/index.js [test] (ecmascript)\", CHUNK_PUBLIC_PATH).exports;\n\\ No newline at end of file\n+var R=require(\"./[turbopack]_runtime.js\")(\"output/index.entry.js\")\n+R.c(\"output/b1abf_turbopack-tests_tests_snapshot_basic_async_chunk_build_input_import_2a82c7a5.js\")\n+R.c(\"output/4e721_crates_turbopack-tests_tests_snapshot_basic_async_chunk_build_input_1e41378a._.js\")\n+R.m(\"[project]/turbopack/crates/turbopack-tests/tests/snapshot/basic/async_chunk_build/input/index.js [test] (ecmascript)\")\n+module.exports=R.m(\"[project]/turbopack/crates/turbopack-tests/tests/snapshot/basic/async_chunk_build/input/index.js [test] (ecmascript)\").exports\n\\ No newline at end of file"
        },
        {
            "sha": "afe1382c8412b308c10e91a9f69066c6354f56ae",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/basic/ecmascript_minify/output/index.entry.js",
            "status": "modified",
            "additions": 4,
            "deletions": 5,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/dcca55ba269a347ba01732cb5fd0e00e68d44674/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fbasic%2Fecmascript_minify%2Foutput%2Findex.entry.js",
            "raw_url": "https://github.com/vercel/next.js/raw/dcca55ba269a347ba01732cb5fd0e00e68d44674/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fbasic%2Fecmascript_minify%2Foutput%2Findex.entry.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fbasic%2Fecmascript_minify%2Foutput%2Findex.entry.js?ref=dcca55ba269a347ba01732cb5fd0e00e68d44674",
            "patch": "@@ -1,5 +1,4 @@\n-const CHUNK_PUBLIC_PATH = \"output/index.entry.js\";\n-const runtime = require(\"./[turbopack]_runtime.js\");\n-runtime.loadChunk(\"output/b1abf_turbopack-tests_tests_snapshot_basic_ecmascript_minify_input_index_6869f84f.js\");\n-runtime.getOrInstantiateRuntimeModule(\"[project]/turbopack/crates/turbopack-tests/tests/snapshot/basic/ecmascript_minify/input/index.js [test] (ecmascript)\", CHUNK_PUBLIC_PATH);\n-module.exports = runtime.getOrInstantiateRuntimeModule(\"[project]/turbopack/crates/turbopack-tests/tests/snapshot/basic/ecmascript_minify/input/index.js [test] (ecmascript)\", CHUNK_PUBLIC_PATH).exports;\n\\ No newline at end of file\n+var R=require(\"./[turbopack]_runtime.js\")(\"output/index.entry.js\")\n+R.c(\"output/b1abf_turbopack-tests_tests_snapshot_basic_ecmascript_minify_input_index_6869f84f.js\")\n+R.m(\"[project]/turbopack/crates/turbopack-tests/tests/snapshot/basic/ecmascript_minify/input/index.js [test] (ecmascript)\")\n+module.exports=R.m(\"[project]/turbopack/crates/turbopack-tests/tests/snapshot/basic/ecmascript_minify/input/index.js [test] (ecmascript)\").exports\n\\ No newline at end of file"
        },
        {
            "sha": "60e7754212175f821f6170264d9e6a3e9faeea6a",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/runtime/default_build_runtime/output/[turbopack]_runtime.js",
            "status": "modified",
            "additions": 35,
            "deletions": 45,
            "changes": 80,
            "blob_url": "https://github.com/vercel/next.js/blob/dcca55ba269a347ba01732cb5fd0e00e68d44674/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_build_runtime%2Foutput%2F%5Bturbopack%5D_runtime.js",
            "raw_url": "https://github.com/vercel/next.js/raw/dcca55ba269a347ba01732cb5fd0e00e68d44674/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_build_runtime%2Foutput%2F%5Bturbopack%5D_runtime.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_build_runtime%2Foutput%2F%5Bturbopack%5D_runtime.js?ref=dcca55ba269a347ba01732cb5fd0e00e68d44674",
            "patch": "@@ -453,21 +453,23 @@ var SourceType = /*#__PURE__*/ function(SourceType) {\n     /**\n    * The module was instantiated because it was included in an evaluated chunk's\n    * runtime.\n+   * SourceData is a ChunkPath.\n    */ SourceType[SourceType[\"Runtime\"] = 0] = \"Runtime\";\n     /**\n    * The module was instantiated because a parent module imported it.\n+   * SourceData is a ModuleId.\n    */ SourceType[SourceType[\"Parent\"] = 1] = \"Parent\";\n     return SourceType;\n }(SourceType || {});\n process.env.TURBOPACK = '1';\n-function stringifySourceInfo(source) {\n-    switch(source.type){\n+function stringifySourceInfo(sourceType, sourceData) {\n+    switch(sourceType){\n         case 0:\n-            return `runtime for chunk ${source.chunkPath}`;\n+            return `runtime for chunk ${sourceData}`;\n         case 1:\n-            return `parent module ${source.parentId}`;\n+            return `parent module ${sourceData}`;\n         default:\n-            invariant(source, (source)=>`Unknown source type: ${source?.type}`);\n+            invariant(sourceType, (sourceType)=>`Unknown source type: ${sourceType}`);\n     }\n }\n const url = require('url');\n@@ -488,11 +490,11 @@ const moduleCache = Object.create(null);\n         return url.pathToFileURL(resolved).href;\n     };\n }\n-function loadChunk(chunkData, source) {\n+function loadChunk(sourceType, sourceData, chunkData) {\n     if (typeof chunkData === 'string') {\n-        loadChunkPath(chunkData, source);\n+        loadChunkPath(sourceType, sourceData, chunkData);\n     } else {\n-        loadChunkPath(chunkData.path, source);\n+        loadChunkPath(sourceType, sourceData, chunkData.path);\n     }\n }\n const loadedChunks = new Set();\n@@ -502,7 +504,7 @@ const chunkCache = new Map();\n function clearChunkCache() {\n     chunkCache.clear();\n }\n-function loadChunkPath(chunkPath, source) {\n+function loadChunkPath(sourceType, sourceData, chunkPath) {\n     if (!isJs(chunkPath)) {\n         // We only support loading JS chunks in Node.js.\n         // This branch can be hit when trying to load a CSS chunk.\n@@ -530,8 +532,8 @@ function loadChunkPath(chunkPath, source) {\n         loadedChunks.add(chunkPath);\n     } catch (e) {\n         let errorMessage = `Failed to load chunk ${chunkPath}`;\n-        if (source) {\n-            errorMessage += ` from ${stringifySourceInfo(source)}`;\n+        if (sourceType !== undefined) {\n+            errorMessage += ` from ${stringifySourceInfo(sourceType, sourceData)}`;\n         }\n         throw new Error(errorMessage, {\n             cause: e\n@@ -558,7 +560,7 @@ function loadChunkUncached(chunkPath) {\n         }\n     }\n }\n-function loadChunkAsync(source, chunkData) {\n+function loadChunkAsync(sourceType, sourceData, chunkData) {\n     const chunkPath = typeof chunkData === 'string' ? chunkData : chunkData.path;\n     if (!isJs(chunkPath)) {\n         // We only support loading JS chunks in Node.js.\n@@ -573,8 +575,8 @@ function loadChunkAsync(source, chunkData) {\n             entry = loadedChunk;\n         } catch (e) {\n             let errorMessage = `Failed to load chunk ${chunkPath}`;\n-            if (source) {\n-                errorMessage += ` from ${stringifySourceInfo(source)}`;\n+            if (sourceType !== undefined) {\n+                errorMessage += ` from ${stringifySourceInfo(sourceType, sourceData)}`;\n             }\n             // Cache the failure promise, future requests will also get this same rejection\n             entry = Promise.reject(new Error(errorMessage, {\n@@ -586,9 +588,9 @@ function loadChunkAsync(source, chunkData) {\n     // TODO: Return an instrumented Promise that React can use instead of relying on referential equality.\n     return entry;\n }\n-function loadChunkAsyncByUrl(source, chunkUrl) {\n+function loadChunkAsyncByUrl(sourceType, sourceData, chunkUrl) {\n     const path1 = url.fileURLToPath(new URL(chunkUrl, RUNTIME_ROOT));\n-    return loadChunkAsync(source, path1);\n+    return loadChunkAsync(sourceType, sourceData, path1);\n }\n function loadWebAssembly(chunkPath, _edgeModule, imports) {\n     const resolved = path.resolve(RUNTIME_ROOT, chunkPath);\n@@ -601,24 +603,24 @@ function loadWebAssemblyModule(chunkPath, _edgeModule) {\n function getWorkerBlobURL(_chunks) {\n     throw new Error('Worker blobs are not implemented yet for Node.js');\n }\n-function instantiateModule(id, source) {\n+function instantiateModule(id, sourceType, sourceData) {\n     const moduleFactory = moduleFactories[id];\n     if (typeof moduleFactory !== 'function') {\n         // This can happen if modules incorrectly handle HMR disposes/updates,\n         // e.g. when they keep a `setTimeout` around which still executes old code\n         // and contains e.g. a `require(\"something\")` call.\n         let instantiationReason;\n-        switch(source.type){\n+        switch(sourceType){\n             case 0:\n-                instantiationReason = `as a runtime entry of chunk ${source.chunkPath}`;\n+                instantiationReason = `as a runtime entry of chunk ${sourceData}`;\n                 break;\n             case 1:\n-                instantiationReason = `because it was required from module ${source.parentId}`;\n+                instantiationReason = `because it was required from module ${sourceData}`;\n                 break;\n             default:\n-                invariant(source, (source)=>`Unknown source type: ${source?.type}`);\n+                invariant(sourceType, (sourceType)=>`Unknown source type: ${sourceType}`);\n         }\n-        throw new Error(`Module ${id} was instantiated ${instantiationReason}, but the module factory is not available. It might have been deleted in an HMR update.`);\n+        throw new Error(`Module ${id} was instantiated ${instantiationReason}, but the module factory is not available.`);\n     }\n     const module1 = {\n         exports: {},\n@@ -647,14 +649,8 @@ function instantiateModule(id, source) {\n             m: module1,\n             c: moduleCache,\n             M: moduleFactories,\n-            l: loadChunkAsync.bind(null, {\n-                type: 1,\n-                parentId: id\n-            }),\n-            L: loadChunkAsyncByUrl.bind(null, {\n-                type: 1,\n-                parentId: id\n-            }),\n+            l: loadChunkAsync.bind(null, 1, id),\n+            L: loadChunkAsyncByUrl.bind(null, 1, id),\n             C: clearChunkCache,\n             w: loadWebAssembly,\n             u: loadWebAssemblyModule,\n@@ -683,42 +679,36 @@ function getOrInstantiateModuleFromParent(id, sourceModule) {\n     if (module1) {\n         return module1;\n     }\n-    return instantiateModule(id, {\n-        type: 1,\n-        parentId: sourceModule.id\n-    });\n+    return instantiateModule(id, 1, sourceModule.id);\n }\n /**\n  * Instantiates a runtime module.\n- */ function instantiateRuntimeModule(moduleId, chunkPath) {\n-    return instantiateModule(moduleId, {\n-        type: 0,\n-        chunkPath\n-    });\n+ */ function instantiateRuntimeModule(chunkPath, moduleId) {\n+    return instantiateModule(moduleId, 0, chunkPath);\n }\n /**\n  * Retrieves a module from the cache, or instantiate it as a runtime module if it is not cached.\n  */ // @ts-ignore TypeScript doesn't separate this module space from the browser runtime\n-function getOrInstantiateRuntimeModule(moduleId, chunkPath) {\n+function getOrInstantiateRuntimeModule(chunkPath, moduleId) {\n     const module1 = moduleCache[moduleId];\n     if (module1) {\n         if (module1.error) {\n             throw module1.error;\n         }\n         return module1;\n     }\n-    return instantiateRuntimeModule(moduleId, chunkPath);\n+    return instantiateRuntimeModule(chunkPath, moduleId);\n }\n const regexJsUrl = /\\.js(?:\\?[^#]*)?(?:#.*)?$/;\n /**\n  * Checks if a given path/URL ends with .js, optionally followed by ?query or #fragment.\n  */ function isJs(chunkUrlOrPath) {\n     return regexJsUrl.test(chunkUrlOrPath);\n }\n-module.exports = {\n-    getOrInstantiateRuntimeModule,\n-    loadChunk\n-};\n+module.exports = (sourcePath)=>({\n+        m: (id)=>getOrInstantiateRuntimeModule(sourcePath, id),\n+        c: (chunkData)=>loadChunk(0, sourcePath, chunkData)\n+    });\n \n \n //# sourceMappingURL=%5Bturbopack%5D_runtime.js.map\n\\ No newline at end of file"
        },
        {
            "sha": "73ae4ebf56e10024b8e68d84a02491745d7a1413",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/runtime/default_build_runtime/output/[turbopack]_runtime.js.map",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/dcca55ba269a347ba01732cb5fd0e00e68d44674/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_build_runtime%2Foutput%2F%5Bturbopack%5D_runtime.js.map",
            "raw_url": "https://github.com/vercel/next.js/raw/dcca55ba269a347ba01732cb5fd0e00e68d44674/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_build_runtime%2Foutput%2F%5Bturbopack%5D_runtime.js.map",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_build_runtime%2Foutput%2F%5Bturbopack%5D_runtime.js.map?ref=dcca55ba269a347ba01732cb5fd0e00e68d44674",
            "patch": "@@ -2,9 +2,9 @@\n   \"version\": 3,\n   \"sources\": [],\n   \"sections\": [\n-    {\"offset\": {\"line\": 3, \"column\": 0}, \"map\": {\"version\":3,\"sources\":[\"turbopack:///[turbopack]/shared/runtime-utils.ts\"],\"sourcesContent\":[\"/**\\n * This file contains runtime types and functions that are shared between all\\n * TurboPack ECMAScript runtimes.\\n *\\n * It will be prepended to the runtime code of each runtime.\\n */\\n\\n/* eslint-disable @typescript-eslint/no-unused-vars */\\n\\n/// <reference path=\\\"./runtime-types.d.ts\\\" />\\n\\ntype EsmNamespaceObject = Record<string, any>\\n\\n// @ts-ignore Defined in `dev-base.ts`\\ndeclare function getOrInstantiateModuleFromParent<M>(\\n  id: ModuleId,\\n  sourceModule: M\\n): M\\n\\nconst REEXPORTED_OBJECTS = Symbol('reexported objects')\\n\\ntype ModuleContextMap = Record<ModuleId, ModuleContextEntry>\\n\\ninterface ModuleContextEntry {\\n  id: () => ModuleId\\n  module: () => any\\n}\\n\\ninterface ModuleContext {\\n  // require call\\n  (moduleId: ModuleId): Exports | EsmNamespaceObject\\n\\n  // async import call\\n  import(moduleId: ModuleId): Promise<Exports | EsmNamespaceObject>\\n\\n  keys(): ModuleId[]\\n\\n  resolve(moduleId: ModuleId): ModuleId\\n}\\n\\ntype GetOrInstantiateModuleFromParent<M extends Module> = (\\n  moduleId: M['id'],\\n  parentModule: M\\n) => M\\n\\ndeclare function getOrInstantiateRuntimeModule(\\n  moduleId: ModuleId,\\n  chunkPath: ChunkPath\\n): Module\\n\\nconst hasOwnProperty = Object.prototype.hasOwnProperty\\nconst toStringTag = typeof Symbol !== 'undefined' && Symbol.toStringTag\\n\\nfunction defineProp(\\n  obj: any,\\n  name: PropertyKey,\\n  options: PropertyDescriptor & ThisType<any>\\n) {\\n  if (!hasOwnProperty.call(obj, name)) Object.defineProperty(obj, name, options)\\n}\\n\\nfunction getOverwrittenModule(\\n  moduleCache: ModuleCache<Module>,\\n  id: ModuleId\\n): Module {\\n  let module = moduleCache[id]\\n  if (!module) {\\n    // This is invoked when a module is merged into another module, thus it wasn't invoked via\\n    // instantiateModule and the cache entry wasn't created yet.\\n    module = {\\n      exports: {},\\n      error: undefined,\\n      loaded: false,\\n      id,\\n      namespaceObject: undefined,\\n    }\\n    moduleCache[id] = module\\n  }\\n  return module\\n}\\n\\n/**\\n * Adds the getters to the exports object.\\n */\\nfunction esm(\\n  exports: Exports,\\n  getters: Record<string, (() => any) | [() => any, (v: any) => void]>\\n) {\\n  defineProp(exports, '__esModule', { value: true })\\n  if (toStringTag) defineProp(exports, toStringTag, { value: 'Module' })\\n  for (const key in getters) {\\n    const item = getters[key]\\n    if (Array.isArray(item)) {\\n      defineProp(exports, key, {\\n        get: item[0],\\n        set: item[1],\\n        enumerable: true,\\n      })\\n    } else {\\n      defineProp(exports, key, { get: item, enumerable: true })\\n    }\\n  }\\n  Object.seal(exports)\\n}\\n\\n/**\\n * Makes the module an ESM with exports\\n */\\nfunction esmExport(\\n  module: Module,\\n  exports: Exports,\\n  moduleCache: ModuleCache<Module>,\\n  getters: Record<string, () => any>,\\n  id: ModuleId | undefined\\n) {\\n  if (id != null) {\\n    module = getOverwrittenModule(moduleCache, id)\\n    exports = module.exports\\n  }\\n  module.namespaceObject = module.exports\\n  esm(exports, getters)\\n}\\n\\nfunction ensureDynamicExports(module: Module, exports: Exports) {\\n  let reexportedObjects = module[REEXPORTED_OBJECTS]\\n\\n  if (!reexportedObjects) {\\n    reexportedObjects = module[REEXPORTED_OBJECTS] = []\\n    module.exports = module.namespaceObject = new Proxy(exports, {\\n      get(target, prop) {\\n        if (\\n          hasOwnProperty.call(target, prop) ||\\n          prop === 'default' ||\\n          prop === '__esModule'\\n        ) {\\n          return Reflect.get(target, prop)\\n        }\\n        for (const obj of reexportedObjects!) {\\n          const value = Reflect.get(obj, prop)\\n          if (value !== undefined) return value\\n        }\\n        return undefined\\n      },\\n      ownKeys(target) {\\n        const keys = Reflect.ownKeys(target)\\n        for (const obj of reexportedObjects!) {\\n          for (const key of Reflect.ownKeys(obj)) {\\n            if (key !== 'default' && !keys.includes(key)) keys.push(key)\\n          }\\n        }\\n        return keys\\n      },\\n    })\\n  }\\n}\\n\\n/**\\n * Dynamically exports properties from an object\\n */\\nfunction dynamicExport(\\n  module: Module,\\n  exports: Exports,\\n  moduleCache: ModuleCache<Module>,\\n  object: Record<string, any>,\\n  id: ModuleId | undefined\\n) {\\n  if (id != null) {\\n    module = getOverwrittenModule(moduleCache, id)\\n    exports = module.exports\\n  }\\n  ensureDynamicExports(module, exports)\\n\\n  if (typeof object === 'object' && object !== null) {\\n    module[REEXPORTED_OBJECTS]!.push(object)\\n  }\\n}\\n\\nfunction exportValue(\\n  module: Module,\\n  moduleCache: ModuleCache<Module>,\\n  value: any,\\n  id: ModuleId | undefined\\n) {\\n  if (id != null) {\\n    module = getOverwrittenModule(moduleCache, id)\\n  }\\n  module.exports = value\\n}\\n\\nfunction exportNamespace(\\n  module: Module,\\n  moduleCache: ModuleCache<Module>,\\n  namespace: any,\\n  id: ModuleId | undefined\\n) {\\n  if (id != null) {\\n    module = getOverwrittenModule(moduleCache, id)\\n  }\\n  module.exports = module.namespaceObject = namespace\\n}\\n\\nfunction createGetter(obj: Record<string | symbol, any>, key: string | symbol) {\\n  return () => obj[key]\\n}\\n\\n/**\\n * @returns prototype of the object\\n */\\nconst getProto: (obj: any) => any = Object.getPrototypeOf\\n  ? (obj) => Object.getPrototypeOf(obj)\\n  : (obj) => obj.__proto__\\n\\n/** Prototypes that are not expanded for exports */\\nconst LEAF_PROTOTYPES = [null, getProto({}), getProto([]), getProto(getProto)]\\n\\n/**\\n * @param raw\\n * @param ns\\n * @param allowExportDefault\\n *   * `false`: will have the raw module as default export\\n *   * `true`: will have the default property as default export\\n */\\nfunction interopEsm(\\n  raw: Exports,\\n  ns: EsmNamespaceObject,\\n  allowExportDefault?: boolean\\n) {\\n  const getters: { [s: string]: () => any } = Object.create(null)\\n  for (\\n    let current = raw;\\n    (typeof current === 'object' || typeof current === 'function') &&\\n    !LEAF_PROTOTYPES.includes(current);\\n    current = getProto(current)\\n  ) {\\n    for (const key of Object.getOwnPropertyNames(current)) {\\n      getters[key] = createGetter(raw, key)\\n    }\\n  }\\n\\n  // this is not really correct\\n  // we should set the `default` getter if the imported module is a `.cjs file`\\n  if (!(allowExportDefault && 'default' in getters)) {\\n    getters['default'] = () => raw\\n  }\\n\\n  esm(ns, getters)\\n  return ns\\n}\\n\\nfunction createNS(raw: Module['exports']): EsmNamespaceObject {\\n  if (typeof raw === 'function') {\\n    return function (this: any, ...args: any[]) {\\n      return raw.apply(this, args)\\n    }\\n  } else {\\n    return Object.create(null)\\n  }\\n}\\n\\nfunction esmImport(\\n  sourceModule: Module,\\n  id: ModuleId\\n): Exclude<Module['namespaceObject'], undefined> {\\n  const module = getOrInstantiateModuleFromParent(id, sourceModule)\\n  if (module.error) throw module.error\\n\\n  // any ES module has to have `module.namespaceObject` defined.\\n  if (module.namespaceObject) return module.namespaceObject\\n\\n  // only ESM can be an async module, so we don't need to worry about exports being a promise here.\\n  const raw = module.exports\\n  return (module.namespaceObject = interopEsm(\\n    raw,\\n    createNS(raw),\\n    raw && (raw as any).__esModule\\n  ))\\n}\\n\\n// Add a simple runtime require so that environments without one can still pass\\n// `typeof require` CommonJS checks so that exports are correctly registered.\\nconst runtimeRequire =\\n  // @ts-ignore\\n  typeof require === 'function'\\n    ? // @ts-ignore\\n      require\\n    : function require() {\\n        throw new Error('Unexpected use of runtime require')\\n      }\\n\\nfunction commonJsRequire(sourceModule: Module, id: ModuleId): Exports {\\n  const module = getOrInstantiateModuleFromParent(id, sourceModule)\\n  if (module.error) throw module.error\\n  return module.exports\\n}\\n\\n/**\\n * `require.context` and require/import expression runtime.\\n */\\nfunction moduleContext(map: ModuleContextMap): ModuleContext {\\n  function moduleContext(id: ModuleId): Exports {\\n    if (hasOwnProperty.call(map, id)) {\\n      return map[id].module()\\n    }\\n\\n    const e = new Error(`Cannot find module '${id}'`)\\n    ;(e as any).code = 'MODULE_NOT_FOUND'\\n    throw e\\n  }\\n\\n  moduleContext.keys = (): ModuleId[] => {\\n    return Object.keys(map)\\n  }\\n\\n  moduleContext.resolve = (id: ModuleId): ModuleId => {\\n    if (hasOwnProperty.call(map, id)) {\\n      return map[id].id()\\n    }\\n\\n    const e = new Error(`Cannot find module '${id}'`)\\n    ;(e as any).code = 'MODULE_NOT_FOUND'\\n    throw e\\n  }\\n\\n  moduleContext.import = async (id: ModuleId) => {\\n    return await (moduleContext(id) as Promise<Exports>)\\n  }\\n\\n  return moduleContext\\n}\\n\\n/**\\n * Returns the path of a chunk defined by its data.\\n */\\nfunction getChunkPath(chunkData: ChunkData): ChunkPath {\\n  return typeof chunkData === 'string' ? chunkData : chunkData.path\\n}\\n\\nfunction isPromise<T = any>(maybePromise: any): maybePromise is Promise<T> {\\n  return (\\n    maybePromise != null &&\\n    typeof maybePromise === 'object' &&\\n    'then' in maybePromise &&\\n    typeof maybePromise.then === 'function'\\n  )\\n}\\n\\nfunction isAsyncModuleExt<T extends {}>(obj: T): obj is AsyncModuleExt & T {\\n  return turbopackQueues in obj\\n}\\n\\nfunction createPromise<T>() {\\n  let resolve: (value: T | PromiseLike<T>) => void\\n  let reject: (reason?: any) => void\\n\\n  const promise = new Promise<T>((res, rej) => {\\n    reject = rej\\n    resolve = res\\n  })\\n\\n  return {\\n    promise,\\n    resolve: resolve!,\\n    reject: reject!,\\n  }\\n}\\n\\n// everything below is adapted from webpack\\n// https://github.com/webpack/webpack/blob/6be4065ade1e252c1d8dcba4af0f43e32af1bdc1/lib/runtime/AsyncModuleRuntimeModule.js#L13\\n\\nconst turbopackQueues = Symbol('turbopack queues')\\nconst turbopackExports = Symbol('turbopack exports')\\nconst turbopackError = Symbol('turbopack error')\\n\\nconst enum QueueStatus {\\n  Unknown = -1,\\n  Unresolved = 0,\\n  Resolved = 1,\\n}\\n\\ntype AsyncQueueFn = (() => void) & { queueCount: number }\\ntype AsyncQueue = AsyncQueueFn[] & {\\n  status: QueueStatus\\n}\\n\\nfunction resolveQueue(queue?: AsyncQueue) {\\n  if (queue && queue.status !== QueueStatus.Resolved) {\\n    queue.status = QueueStatus.Resolved\\n    queue.forEach((fn) => fn.queueCount--)\\n    queue.forEach((fn) => (fn.queueCount-- ? fn.queueCount++ : fn()))\\n  }\\n}\\n\\ntype Dep = Exports | AsyncModulePromise | Promise<Exports>\\n\\ntype AsyncModuleExt = {\\n  [turbopackQueues]: (fn: (queue: AsyncQueue) => void) => void\\n  [turbopackExports]: Exports\\n  [turbopackError]?: any\\n}\\n\\ntype AsyncModulePromise<T = Exports> = Promise<T> & AsyncModuleExt\\n\\nfunction wrapDeps(deps: Dep[]): AsyncModuleExt[] {\\n  return deps.map((dep): AsyncModuleExt => {\\n    if (dep !== null && typeof dep === 'object') {\\n      if (isAsyncModuleExt(dep)) return dep\\n      if (isPromise(dep)) {\\n        const queue: AsyncQueue = Object.assign([], {\\n          status: QueueStatus.Unresolved,\\n        })\\n\\n        const obj: AsyncModuleExt = {\\n          [turbopackExports]: {},\\n          [turbopackQueues]: (fn: (queue: AsyncQueue) => void) => fn(queue),\\n        }\\n\\n        dep.then(\\n          (res) => {\\n            obj[turbopackExports] = res\\n            resolveQueue(queue)\\n          },\\n          (err) => {\\n            obj[turbopackError] = err\\n            resolveQueue(queue)\\n          }\\n        )\\n\\n        return obj\\n      }\\n    }\\n\\n    return {\\n      [turbopackExports]: dep,\\n      [turbopackQueues]: () => {},\\n    }\\n  })\\n}\\n\\nfunction asyncModule(\\n  module: Module,\\n  body: (\\n    handleAsyncDependencies: (\\n      deps: Dep[]\\n    ) => Exports[] | Promise<() => Exports[]>,\\n    asyncResult: (err?: any) => void\\n  ) => void,\\n  hasAwait: boolean\\n) {\\n  const queue: AsyncQueue | undefined = hasAwait\\n    ? Object.assign([], { status: QueueStatus.Unknown })\\n    : undefined\\n\\n  const depQueues: Set<AsyncQueue> = new Set()\\n\\n  const { resolve, reject, promise: rawPromise } = createPromise<Exports>()\\n\\n  const promise: AsyncModulePromise = Object.assign(rawPromise, {\\n    [turbopackExports]: module.exports,\\n    [turbopackQueues]: (fn) => {\\n      queue && fn(queue)\\n      depQueues.forEach(fn)\\n      promise['catch'](() => {})\\n    },\\n  } satisfies AsyncModuleExt)\\n\\n  const attributes: PropertyDescriptor = {\\n    get(): any {\\n      return promise\\n    },\\n    set(v: any) {\\n      // Calling `esmExport` leads to this.\\n      if (v !== promise) {\\n        promise[turbopackExports] = v\\n      }\\n    },\\n  }\\n\\n  Object.defineProperty(module, 'exports', attributes)\\n  Object.defineProperty(module, 'namespaceObject', attributes)\\n\\n  function handleAsyncDependencies(deps: Dep[]) {\\n    const currentDeps = wrapDeps(deps)\\n\\n    const getResult = () =>\\n      currentDeps.map((d) => {\\n        if (d[turbopackError]) throw d[turbopackError]\\n        return d[turbopackExports]\\n      })\\n\\n    const { promise, resolve } = createPromise<() => Exports[]>()\\n\\n    const fn: AsyncQueueFn = Object.assign(() => resolve(getResult), {\\n      queueCount: 0,\\n    })\\n\\n    function fnQueue(q: AsyncQueue) {\\n      if (q !== queue && !depQueues.has(q)) {\\n        depQueues.add(q)\\n        if (q && q.status === QueueStatus.Unresolved) {\\n          fn.queueCount++\\n          q.push(fn)\\n        }\\n      }\\n    }\\n\\n    currentDeps.map((dep) => dep[turbopackQueues](fnQueue))\\n\\n    return fn.queueCount ? promise : getResult()\\n  }\\n\\n  function asyncResult(err?: any) {\\n    if (err) {\\n      reject((promise[turbopackError] = err))\\n    } else {\\n      resolve(promise[turbopackExports])\\n    }\\n\\n    resolveQueue(queue)\\n  }\\n\\n  body(handleAsyncDependencies, asyncResult)\\n\\n  if (queue && queue.status === QueueStatus.Unknown) {\\n    queue.status = QueueStatus.Unresolved\\n  }\\n}\\n\\n/**\\n * A pseudo \\\"fake\\\" URL object to resolve to its relative path.\\n *\\n * When UrlRewriteBehavior is set to relative, calls to the `new URL()` will construct url without base using this\\n * runtime function to generate context-agnostic urls between different rendering context, i.e ssr / client to avoid\\n * hydration mismatch.\\n *\\n * This is based on webpack's existing implementation:\\n * https://github.com/webpack/webpack/blob/87660921808566ef3b8796f8df61bd79fc026108/lib/runtime/RelativeUrlRuntimeModule.js\\n */\\nconst relativeURL = function relativeURL(this: any, inputUrl: string) {\\n  const realUrl = new URL(inputUrl, 'x:/')\\n  const values: Record<string, any> = {}\\n  for (const key in realUrl) values[key] = (realUrl as any)[key]\\n  values.href = inputUrl\\n  values.pathname = inputUrl.replace(/[?#].*/, '')\\n  values.origin = values.protocol = ''\\n  values.toString = values.toJSON = (..._args: Array<any>) => inputUrl\\n  for (const key in values)\\n    Object.defineProperty(this, key, {\\n      enumerable: true,\\n      configurable: true,\\n      value: values[key],\\n    })\\n}\\n\\nrelativeURL.prototype = URL.prototype\\n\\n/**\\n * Utility function to ensure all variants of an enum are handled.\\n */\\nfunction invariant(never: never, computeMessage: (arg: any) => string): never {\\n  throw new Error(`Invariant: ${computeMessage(never)}`)\\n}\\n\\n/**\\n * A stub function to make `require` available but non-functional in ESM.\\n */\\nfunction requireStub(_moduleId: ModuleId): never {\\n  throw new Error('dynamic usage of require is not supported')\\n}\\n\"],\"names\":[],\"mappings\":\"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\",\"ignoreList\":[0]}},\n+    {\"offset\": {\"line\": 3, \"column\": 0}, \"map\": {\"version\":3,\"sources\":[\"turbopack:///[turbopack]/shared/runtime-utils.ts\"],\"sourcesContent\":[\"/**\\n * This file contains runtime types and functions that are shared between all\\n * TurboPack ECMAScript runtimes.\\n *\\n * It will be prepended to the runtime code of each runtime.\\n */\\n\\n/* eslint-disable @typescript-eslint/no-unused-vars */\\n\\n/// <reference path=\\\"./runtime-types.d.ts\\\" />\\n\\ntype EsmNamespaceObject = Record<string, any>\\n\\n// @ts-ignore Defined in `dev-base.ts`\\ndeclare function getOrInstantiateModuleFromParent<M>(\\n  id: ModuleId,\\n  sourceModule: M\\n): M\\n\\nconst REEXPORTED_OBJECTS = Symbol('reexported objects')\\n\\ntype ModuleContextMap = Record<ModuleId, ModuleContextEntry>\\n\\ninterface ModuleContextEntry {\\n  id: () => ModuleId\\n  module: () => any\\n}\\n\\ninterface ModuleContext {\\n  // require call\\n  (moduleId: ModuleId): Exports | EsmNamespaceObject\\n\\n  // async import call\\n  import(moduleId: ModuleId): Promise<Exports | EsmNamespaceObject>\\n\\n  keys(): ModuleId[]\\n\\n  resolve(moduleId: ModuleId): ModuleId\\n}\\n\\ntype GetOrInstantiateModuleFromParent<M extends Module> = (\\n  moduleId: M['id'],\\n  parentModule: M\\n) => M\\n\\ndeclare function getOrInstantiateRuntimeModule(\\n  chunkPath: ChunkPath,\\n  moduleId: ModuleId\\n): Module\\n\\nconst hasOwnProperty = Object.prototype.hasOwnProperty\\nconst toStringTag = typeof Symbol !== 'undefined' && Symbol.toStringTag\\n\\nfunction defineProp(\\n  obj: any,\\n  name: PropertyKey,\\n  options: PropertyDescriptor & ThisType<any>\\n) {\\n  if (!hasOwnProperty.call(obj, name)) Object.defineProperty(obj, name, options)\\n}\\n\\nfunction getOverwrittenModule(\\n  moduleCache: ModuleCache<Module>,\\n  id: ModuleId\\n): Module {\\n  let module = moduleCache[id]\\n  if (!module) {\\n    // This is invoked when a module is merged into another module, thus it wasn't invoked via\\n    // instantiateModule and the cache entry wasn't created yet.\\n    module = {\\n      exports: {},\\n      error: undefined,\\n      loaded: false,\\n      id,\\n      namespaceObject: undefined,\\n    }\\n    moduleCache[id] = module\\n  }\\n  return module\\n}\\n\\n/**\\n * Adds the getters to the exports object.\\n */\\nfunction esm(\\n  exports: Exports,\\n  getters: Record<string, (() => any) | [() => any, (v: any) => void]>\\n) {\\n  defineProp(exports, '__esModule', { value: true })\\n  if (toStringTag) defineProp(exports, toStringTag, { value: 'Module' })\\n  for (const key in getters) {\\n    const item = getters[key]\\n    if (Array.isArray(item)) {\\n      defineProp(exports, key, {\\n        get: item[0],\\n        set: item[1],\\n        enumerable: true,\\n      })\\n    } else {\\n      defineProp(exports, key, { get: item, enumerable: true })\\n    }\\n  }\\n  Object.seal(exports)\\n}\\n\\n/**\\n * Makes the module an ESM with exports\\n */\\nfunction esmExport(\\n  module: Module,\\n  exports: Exports,\\n  moduleCache: ModuleCache<Module>,\\n  getters: Record<string, () => any>,\\n  id: ModuleId | undefined\\n) {\\n  if (id != null) {\\n    module = getOverwrittenModule(moduleCache, id)\\n    exports = module.exports\\n  }\\n  module.namespaceObject = module.exports\\n  esm(exports, getters)\\n}\\n\\nfunction ensureDynamicExports(module: Module, exports: Exports) {\\n  let reexportedObjects = module[REEXPORTED_OBJECTS]\\n\\n  if (!reexportedObjects) {\\n    reexportedObjects = module[REEXPORTED_OBJECTS] = []\\n    module.exports = module.namespaceObject = new Proxy(exports, {\\n      get(target, prop) {\\n        if (\\n          hasOwnProperty.call(target, prop) ||\\n          prop === 'default' ||\\n          prop === '__esModule'\\n        ) {\\n          return Reflect.get(target, prop)\\n        }\\n        for (const obj of reexportedObjects!) {\\n          const value = Reflect.get(obj, prop)\\n          if (value !== undefined) return value\\n        }\\n        return undefined\\n      },\\n      ownKeys(target) {\\n        const keys = Reflect.ownKeys(target)\\n        for (const obj of reexportedObjects!) {\\n          for (const key of Reflect.ownKeys(obj)) {\\n            if (key !== 'default' && !keys.includes(key)) keys.push(key)\\n          }\\n        }\\n        return keys\\n      },\\n    })\\n  }\\n}\\n\\n/**\\n * Dynamically exports properties from an object\\n */\\nfunction dynamicExport(\\n  module: Module,\\n  exports: Exports,\\n  moduleCache: ModuleCache<Module>,\\n  object: Record<string, any>,\\n  id: ModuleId | undefined\\n) {\\n  if (id != null) {\\n    module = getOverwrittenModule(moduleCache, id)\\n    exports = module.exports\\n  }\\n  ensureDynamicExports(module, exports)\\n\\n  if (typeof object === 'object' && object !== null) {\\n    module[REEXPORTED_OBJECTS]!.push(object)\\n  }\\n}\\n\\nfunction exportValue(\\n  module: Module,\\n  moduleCache: ModuleCache<Module>,\\n  value: any,\\n  id: ModuleId | undefined\\n) {\\n  if (id != null) {\\n    module = getOverwrittenModule(moduleCache, id)\\n  }\\n  module.exports = value\\n}\\n\\nfunction exportNamespace(\\n  module: Module,\\n  moduleCache: ModuleCache<Module>,\\n  namespace: any,\\n  id: ModuleId | undefined\\n) {\\n  if (id != null) {\\n    module = getOverwrittenModule(moduleCache, id)\\n  }\\n  module.exports = module.namespaceObject = namespace\\n}\\n\\nfunction createGetter(obj: Record<string | symbol, any>, key: string | symbol) {\\n  return () => obj[key]\\n}\\n\\n/**\\n * @returns prototype of the object\\n */\\nconst getProto: (obj: any) => any = Object.getPrototypeOf\\n  ? (obj) => Object.getPrototypeOf(obj)\\n  : (obj) => obj.__proto__\\n\\n/** Prototypes that are not expanded for exports */\\nconst LEAF_PROTOTYPES = [null, getProto({}), getProto([]), getProto(getProto)]\\n\\n/**\\n * @param raw\\n * @param ns\\n * @param allowExportDefault\\n *   * `false`: will have the raw module as default export\\n *   * `true`: will have the default property as default export\\n */\\nfunction interopEsm(\\n  raw: Exports,\\n  ns: EsmNamespaceObject,\\n  allowExportDefault?: boolean\\n) {\\n  const getters: { [s: string]: () => any } = Object.create(null)\\n  for (\\n    let current = raw;\\n    (typeof current === 'object' || typeof current === 'function') &&\\n    !LEAF_PROTOTYPES.includes(current);\\n    current = getProto(current)\\n  ) {\\n    for (const key of Object.getOwnPropertyNames(current)) {\\n      getters[key] = createGetter(raw, key)\\n    }\\n  }\\n\\n  // this is not really correct\\n  // we should set the `default` getter if the imported module is a `.cjs file`\\n  if (!(allowExportDefault && 'default' in getters)) {\\n    getters['default'] = () => raw\\n  }\\n\\n  esm(ns, getters)\\n  return ns\\n}\\n\\nfunction createNS(raw: Module['exports']): EsmNamespaceObject {\\n  if (typeof raw === 'function') {\\n    return function (this: any, ...args: any[]) {\\n      return raw.apply(this, args)\\n    }\\n  } else {\\n    return Object.create(null)\\n  }\\n}\\n\\nfunction esmImport(\\n  sourceModule: Module,\\n  id: ModuleId\\n): Exclude<Module['namespaceObject'], undefined> {\\n  const module = getOrInstantiateModuleFromParent(id, sourceModule)\\n  if (module.error) throw module.error\\n\\n  // any ES module has to have `module.namespaceObject` defined.\\n  if (module.namespaceObject) return module.namespaceObject\\n\\n  // only ESM can be an async module, so we don't need to worry about exports being a promise here.\\n  const raw = module.exports\\n  return (module.namespaceObject = interopEsm(\\n    raw,\\n    createNS(raw),\\n    raw && (raw as any).__esModule\\n  ))\\n}\\n\\n// Add a simple runtime require so that environments without one can still pass\\n// `typeof require` CommonJS checks so that exports are correctly registered.\\nconst runtimeRequire =\\n  // @ts-ignore\\n  typeof require === 'function'\\n    ? // @ts-ignore\\n      require\\n    : function require() {\\n        throw new Error('Unexpected use of runtime require')\\n      }\\n\\nfunction commonJsRequire(sourceModule: Module, id: ModuleId): Exports {\\n  const module = getOrInstantiateModuleFromParent(id, sourceModule)\\n  if (module.error) throw module.error\\n  return module.exports\\n}\\n\\n/**\\n * `require.context` and require/import expression runtime.\\n */\\nfunction moduleContext(map: ModuleContextMap): ModuleContext {\\n  function moduleContext(id: ModuleId): Exports {\\n    if (hasOwnProperty.call(map, id)) {\\n      return map[id].module()\\n    }\\n\\n    const e = new Error(`Cannot find module '${id}'`)\\n    ;(e as any).code = 'MODULE_NOT_FOUND'\\n    throw e\\n  }\\n\\n  moduleContext.keys = (): ModuleId[] => {\\n    return Object.keys(map)\\n  }\\n\\n  moduleContext.resolve = (id: ModuleId): ModuleId => {\\n    if (hasOwnProperty.call(map, id)) {\\n      return map[id].id()\\n    }\\n\\n    const e = new Error(`Cannot find module '${id}'`)\\n    ;(e as any).code = 'MODULE_NOT_FOUND'\\n    throw e\\n  }\\n\\n  moduleContext.import = async (id: ModuleId) => {\\n    return await (moduleContext(id) as Promise<Exports>)\\n  }\\n\\n  return moduleContext\\n}\\n\\n/**\\n * Returns the path of a chunk defined by its data.\\n */\\nfunction getChunkPath(chunkData: ChunkData): ChunkPath {\\n  return typeof chunkData === 'string' ? chunkData : chunkData.path\\n}\\n\\nfunction isPromise<T = any>(maybePromise: any): maybePromise is Promise<T> {\\n  return (\\n    maybePromise != null &&\\n    typeof maybePromise === 'object' &&\\n    'then' in maybePromise &&\\n    typeof maybePromise.then === 'function'\\n  )\\n}\\n\\nfunction isAsyncModuleExt<T extends {}>(obj: T): obj is AsyncModuleExt & T {\\n  return turbopackQueues in obj\\n}\\n\\nfunction createPromise<T>() {\\n  let resolve: (value: T | PromiseLike<T>) => void\\n  let reject: (reason?: any) => void\\n\\n  const promise = new Promise<T>((res, rej) => {\\n    reject = rej\\n    resolve = res\\n  })\\n\\n  return {\\n    promise,\\n    resolve: resolve!,\\n    reject: reject!,\\n  }\\n}\\n\\n// everything below is adapted from webpack\\n// https://github.com/webpack/webpack/blob/6be4065ade1e252c1d8dcba4af0f43e32af1bdc1/lib/runtime/AsyncModuleRuntimeModule.js#L13\\n\\nconst turbopackQueues = Symbol('turbopack queues')\\nconst turbopackExports = Symbol('turbopack exports')\\nconst turbopackError = Symbol('turbopack error')\\n\\nconst enum QueueStatus {\\n  Unknown = -1,\\n  Unresolved = 0,\\n  Resolved = 1,\\n}\\n\\ntype AsyncQueueFn = (() => void) & { queueCount: number }\\ntype AsyncQueue = AsyncQueueFn[] & {\\n  status: QueueStatus\\n}\\n\\nfunction resolveQueue(queue?: AsyncQueue) {\\n  if (queue && queue.status !== QueueStatus.Resolved) {\\n    queue.status = QueueStatus.Resolved\\n    queue.forEach((fn) => fn.queueCount--)\\n    queue.forEach((fn) => (fn.queueCount-- ? fn.queueCount++ : fn()))\\n  }\\n}\\n\\ntype Dep = Exports | AsyncModulePromise | Promise<Exports>\\n\\ntype AsyncModuleExt = {\\n  [turbopackQueues]: (fn: (queue: AsyncQueue) => void) => void\\n  [turbopackExports]: Exports\\n  [turbopackError]?: any\\n}\\n\\ntype AsyncModulePromise<T = Exports> = Promise<T> & AsyncModuleExt\\n\\nfunction wrapDeps(deps: Dep[]): AsyncModuleExt[] {\\n  return deps.map((dep): AsyncModuleExt => {\\n    if (dep !== null && typeof dep === 'object') {\\n      if (isAsyncModuleExt(dep)) return dep\\n      if (isPromise(dep)) {\\n        const queue: AsyncQueue = Object.assign([], {\\n          status: QueueStatus.Unresolved,\\n        })\\n\\n        const obj: AsyncModuleExt = {\\n          [turbopackExports]: {},\\n          [turbopackQueues]: (fn: (queue: AsyncQueue) => void) => fn(queue),\\n        }\\n\\n        dep.then(\\n          (res) => {\\n            obj[turbopackExports] = res\\n            resolveQueue(queue)\\n          },\\n          (err) => {\\n            obj[turbopackError] = err\\n            resolveQueue(queue)\\n          }\\n        )\\n\\n        return obj\\n      }\\n    }\\n\\n    return {\\n      [turbopackExports]: dep,\\n      [turbopackQueues]: () => {},\\n    }\\n  })\\n}\\n\\nfunction asyncModule(\\n  module: Module,\\n  body: (\\n    handleAsyncDependencies: (\\n      deps: Dep[]\\n    ) => Exports[] | Promise<() => Exports[]>,\\n    asyncResult: (err?: any) => void\\n  ) => void,\\n  hasAwait: boolean\\n) {\\n  const queue: AsyncQueue | undefined = hasAwait\\n    ? Object.assign([], { status: QueueStatus.Unknown })\\n    : undefined\\n\\n  const depQueues: Set<AsyncQueue> = new Set()\\n\\n  const { resolve, reject, promise: rawPromise } = createPromise<Exports>()\\n\\n  const promise: AsyncModulePromise = Object.assign(rawPromise, {\\n    [turbopackExports]: module.exports,\\n    [turbopackQueues]: (fn) => {\\n      queue && fn(queue)\\n      depQueues.forEach(fn)\\n      promise['catch'](() => {})\\n    },\\n  } satisfies AsyncModuleExt)\\n\\n  const attributes: PropertyDescriptor = {\\n    get(): any {\\n      return promise\\n    },\\n    set(v: any) {\\n      // Calling `esmExport` leads to this.\\n      if (v !== promise) {\\n        promise[turbopackExports] = v\\n      }\\n    },\\n  }\\n\\n  Object.defineProperty(module, 'exports', attributes)\\n  Object.defineProperty(module, 'namespaceObject', attributes)\\n\\n  function handleAsyncDependencies(deps: Dep[]) {\\n    const currentDeps = wrapDeps(deps)\\n\\n    const getResult = () =>\\n      currentDeps.map((d) => {\\n        if (d[turbopackError]) throw d[turbopackError]\\n        return d[turbopackExports]\\n      })\\n\\n    const { promise, resolve } = createPromise<() => Exports[]>()\\n\\n    const fn: AsyncQueueFn = Object.assign(() => resolve(getResult), {\\n      queueCount: 0,\\n    })\\n\\n    function fnQueue(q: AsyncQueue) {\\n      if (q !== queue && !depQueues.has(q)) {\\n        depQueues.add(q)\\n        if (q && q.status === QueueStatus.Unresolved) {\\n          fn.queueCount++\\n          q.push(fn)\\n        }\\n      }\\n    }\\n\\n    currentDeps.map((dep) => dep[turbopackQueues](fnQueue))\\n\\n    return fn.queueCount ? promise : getResult()\\n  }\\n\\n  function asyncResult(err?: any) {\\n    if (err) {\\n      reject((promise[turbopackError] = err))\\n    } else {\\n      resolve(promise[turbopackExports])\\n    }\\n\\n    resolveQueue(queue)\\n  }\\n\\n  body(handleAsyncDependencies, asyncResult)\\n\\n  if (queue && queue.status === QueueStatus.Unknown) {\\n    queue.status = QueueStatus.Unresolved\\n  }\\n}\\n\\n/**\\n * A pseudo \\\"fake\\\" URL object to resolve to its relative path.\\n *\\n * When UrlRewriteBehavior is set to relative, calls to the `new URL()` will construct url without base using this\\n * runtime function to generate context-agnostic urls between different rendering context, i.e ssr / client to avoid\\n * hydration mismatch.\\n *\\n * This is based on webpack's existing implementation:\\n * https://github.com/webpack/webpack/blob/87660921808566ef3b8796f8df61bd79fc026108/lib/runtime/RelativeUrlRuntimeModule.js\\n */\\nconst relativeURL = function relativeURL(this: any, inputUrl: string) {\\n  const realUrl = new URL(inputUrl, 'x:/')\\n  const values: Record<string, any> = {}\\n  for (const key in realUrl) values[key] = (realUrl as any)[key]\\n  values.href = inputUrl\\n  values.pathname = inputUrl.replace(/[?#].*/, '')\\n  values.origin = values.protocol = ''\\n  values.toString = values.toJSON = (..._args: Array<any>) => inputUrl\\n  for (const key in values)\\n    Object.defineProperty(this, key, {\\n      enumerable: true,\\n      configurable: true,\\n      value: values[key],\\n    })\\n}\\n\\nrelativeURL.prototype = URL.prototype\\n\\n/**\\n * Utility function to ensure all variants of an enum are handled.\\n */\\nfunction invariant(never: never, computeMessage: (arg: any) => string): never {\\n  throw new Error(`Invariant: ${computeMessage(never)}`)\\n}\\n\\n/**\\n * A stub function to make `require` available but non-functional in ESM.\\n */\\nfunction requireStub(_moduleId: ModuleId): never {\\n  throw new Error('dynamic usage of require is not supported')\\n}\\n\"],\"names\":[],\"mappings\":\"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\",\"ignoreList\":[0]}},\n     {\"offset\": {\"line\": 367, \"column\": 0}, \"map\": {\"version\":3,\"sources\":[\"turbopack:///[turbopack]/shared-node/base-externals-utils.ts\"],\"sourcesContent\":[\"/* eslint-disable @typescript-eslint/no-unused-vars */\\n\\n/// <reference path=\\\"../shared/runtime-utils.ts\\\" />\\n\\n/// A 'base' utilities to support runtime can have externals.\\n/// Currently this is for node.js / edge runtime both.\\n/// If a fn requires node.js specific behavior, it should be placed in `node-external-utils` instead.\\n\\nasync function externalImport(id: DependencySpecifier) {\\n  let raw\\n  try {\\n    raw = await import(id)\\n  } catch (err) {\\n    // TODO(alexkirsz) This can happen when a client-side module tries to load\\n    // an external module we don't provide a shim for (e.g. querystring, url).\\n    // For now, we fail semi-silently, but in the future this should be a\\n    // compilation error.\\n    throw new Error(`Failed to load external module ${id}: ${err}`)\\n  }\\n\\n  if (raw && raw.__esModule && raw.default && 'default' in raw.default) {\\n    return interopEsm(raw.default, createNS(raw), true)\\n  }\\n\\n  return raw\\n}\\n\\nfunction externalRequire(\\n  id: ModuleId,\\n  thunk: () => any,\\n  esm: boolean = false\\n): Exports | EsmNamespaceObject {\\n  let raw\\n  try {\\n    raw = thunk()\\n  } catch (err) {\\n    // TODO(alexkirsz) This can happen when a client-side module tries to load\\n    // an external module we don't provide a shim for (e.g. querystring, url).\\n    // For now, we fail semi-silently, but in the future this should be a\\n    // compilation error.\\n    throw new Error(`Failed to load external module ${id}: ${err}`)\\n  }\\n\\n  if (!esm || raw.__esModule) {\\n    return raw\\n  }\\n\\n  return interopEsm(raw, createNS(raw), true)\\n}\\n\\nexternalRequire.resolve = (\\n  id: string,\\n  options?: {\\n    paths?: string[]\\n  }\\n) => {\\n  return require.resolve(id, options)\\n}\\n\"],\"names\":[],\"mappings\":\"AAAA,oDAAoD,GAEpD,mDAAmD;AAEnD,6DAA6D;AAC7D,sDAAsD;AACtD,qGAAqG;AAErG,eAAe,eAAe,EAAuB;IACnD,IAAI;IACJ,IAAI;QACF,MAAM,MAAM,MAAM,CAAC;IACrB,EAAE,OAAO,KAAK;QACZ,0EAA0E;QAC1E,0EAA0E;QAC1E,qEAAqE;QACrE,qBAAqB;QACrB,MAAM,IAAI,MAAM,CAAC,+BAA+B,EAAE,GAAG,EAAE,EAAE,KAAK;IAChE;IAEA,IAAI,OAAO,IAAI,UAAU,IAAI,IAAI,OAAO,IAAI,aAAa,IAAI,OAAO,EAAE;QACpE,OAAO,WAAW,IAAI,OAAO,EAAE,SAAS,MAAM;IAChD;IAEA,OAAO;AACT;AAEA,SAAS,gBACP,EAAY,EACZ,KAAgB,EAChB,MAAe,KAAK;IAEpB,IAAI;IACJ,IAAI;QACF,MAAM;IACR,EAAE,OAAO,KAAK;QACZ,0EAA0E;QAC1E,0EAA0E;QAC1E,qEAAqE;QACrE,qBAAqB;QACrB,MAAM,IAAI,MAAM,CAAC,+BAA+B,EAAE,GAAG,EAAE,EAAE,KAAK;IAChE;IAEA,IAAI,CAAC,OAAO,IAAI,UAAU,EAAE;QAC1B,OAAO;IACT;IAEA,OAAO,WAAW,KAAK,SAAS,MAAM;AACxC;AAEA,gBAAgB,OAAO,GAAG,CACxB,IACA;IAIA,OAAO,QAAQ,OAAO,CAAC,IAAI;AAC7B\",\"ignoreList\":[0]}},\n     {\"offset\": {\"line\": 406, \"column\": 0}, \"map\": {\"version\":3,\"sources\":[\"turbopack:///[turbopack]/shared-node/node-externals-utils.ts\"],\"sourcesContent\":[\"/* eslint-disable @typescript-eslint/no-unused-vars */\\n\\ndeclare var RUNTIME_PUBLIC_PATH: string\\ndeclare var RELATIVE_ROOT_PATH: string\\ndeclare var ASSET_PREFIX: string\\n\\nconst path = require('path')\\n\\nconst relativePathToRuntimeRoot = path.relative(RUNTIME_PUBLIC_PATH, '.')\\n// Compute the relative path to the `distDir`.\\nconst relativePathToDistRoot = path.join(\\n  relativePathToRuntimeRoot,\\n  RELATIVE_ROOT_PATH\\n)\\nconst RUNTIME_ROOT = path.resolve(__filename, relativePathToRuntimeRoot)\\n// Compute the absolute path to the root, by stripping distDir from the absolute path to this file.\\nconst ABSOLUTE_ROOT = path.resolve(__filename, relativePathToDistRoot)\\n\\n/**\\n * Returns an absolute path to the given module path.\\n * Module path should be relative, either path to a file or a directory.\\n *\\n * This fn allows to calculate an absolute path for some global static values, such as\\n * `__dirname` or `import.meta.url` that Turbopack will not embeds in compile time.\\n * See ImportMetaBinding::code_generation for the usage.\\n */\\nfunction resolveAbsolutePath(modulePath?: string): string {\\n  if (modulePath) {\\n    return path.join(ABSOLUTE_ROOT, modulePath)\\n  }\\n  return ABSOLUTE_ROOT\\n}\\n\"],\"names\":[],\"mappings\":\"AAAA,oDAAoD,GAMpD,MAAM,OAAO,QAAQ;AAErB,MAAM,4BAA4B,KAAK,QAAQ,CAAC,qBAAqB;AACrE,8CAA8C;AAC9C,MAAM,yBAAyB,KAAK,IAAI,CACtC,2BACA;AAEF,MAAM,eAAe,KAAK,OAAO,CAAC,YAAY;AAC9C,mGAAmG;AACnG,MAAM,gBAAgB,KAAK,OAAO,CAAC,YAAY;AAE/C;;;;;;;CAOC,GACD,SAAS,oBAAoB,UAAmB;IAC9C,IAAI,YAAY;QACd,OAAO,KAAK,IAAI,CAAC,eAAe;IAClC;IACA,OAAO;AACT\",\"ignoreList\":[0]}},\n     {\"offset\": {\"line\": 426, \"column\": 0}, \"map\": {\"version\":3,\"sources\":[\"turbopack:///[turbopack]/shared-node/node-wasm-utils.ts\"],\"sourcesContent\":[\"/* eslint-disable @typescript-eslint/no-unused-vars */\\n\\n/// <reference path=\\\"../shared/runtime-utils.ts\\\" />\\n\\nfunction readWebAssemblyAsResponse(path: string) {\\n  const { createReadStream } = require('fs') as typeof import('fs')\\n  const { Readable } = require('stream') as typeof import('stream')\\n\\n  const stream = createReadStream(path)\\n\\n  // @ts-ignore unfortunately there's a slight type mismatch with the stream.\\n  return new Response(Readable.toWeb(stream), {\\n    headers: {\\n      'content-type': 'application/wasm',\\n    },\\n  })\\n}\\n\\nasync function compileWebAssemblyFromPath(\\n  path: string\\n): Promise<WebAssembly.Module> {\\n  const response = readWebAssemblyAsResponse(path)\\n\\n  return await WebAssembly.compileStreaming(response)\\n}\\n\\nasync function instantiateWebAssemblyFromPath(\\n  path: string,\\n  importsObj: WebAssembly.Imports\\n): Promise<Exports> {\\n  const response = readWebAssemblyAsResponse(path)\\n\\n  const { instance } = await WebAssembly.instantiateStreaming(\\n    response,\\n    importsObj\\n  )\\n\\n  return instance.exports\\n}\\n\"],\"names\":[],\"mappings\":\"AAAA,oDAAoD,GAEpD,mDAAmD;AAEnD,SAAS,0BAA0B,IAAY;IAC7C,MAAM,EAAE,gBAAgB,EAAE,GAAG,QAAQ;IACrC,MAAM,EAAE,QAAQ,EAAE,GAAG,QAAQ;IAE7B,MAAM,SAAS,iBAAiB;IAEhC,2EAA2E;IAC3E,OAAO,IAAI,SAAS,SAAS,KAAK,CAAC,SAAS;QAC1C,SAAS;YACP,gBAAgB;QAClB;IACF;AACF;AAEA,eAAe,2BACb,IAAY;IAEZ,MAAM,WAAW,0BAA0B;IAE3C,OAAO,MAAM,YAAY,gBAAgB,CAAC;AAC5C;AAEA,eAAe,+BACb,IAAY,EACZ,UAA+B;IAE/B,MAAM,WAAW,0BAA0B;IAE3C,MAAM,EAAE,QAAQ,EAAE,GAAG,MAAM,YAAY,oBAAoB,CACzD,UACA;IAGF,OAAO,SAAS,OAAO;AACzB\",\"ignoreList\":[0]}},\n-    {\"offset\": {\"line\": 447, \"column\": 0}, \"map\": {\"version\":3,\"sources\":[\"turbopack:///[turbopack]/nodejs/runtime.ts\"],\"sourcesContent\":[\"/* eslint-disable @typescript-eslint/no-unused-vars */\\n\\n/// <reference path=\\\"../shared/runtime-utils.ts\\\" />\\n/// <reference path=\\\"../shared-node/base-externals-utils.ts\\\" />\\n/// <reference path=\\\"../shared-node/node-externals-utils.ts\\\" />\\n/// <reference path=\\\"../shared-node/node-wasm-utils.ts\\\" />\\n\\nenum SourceType {\\n  /**\\n   * The module was instantiated because it was included in an evaluated chunk's\\n   * runtime.\\n   */\\n  Runtime = 0,\\n  /**\\n   * The module was instantiated because a parent module imported it.\\n   */\\n  Parent = 1,\\n}\\n\\ntype SourceInfo =\\n  | {\\n      type: SourceType.Runtime\\n      chunkPath: ChunkPath\\n    }\\n  | {\\n      type: SourceType.Parent\\n      parentId: ModuleId\\n    }\\n\\nprocess.env.TURBOPACK = '1'\\n\\nfunction stringifySourceInfo(source: SourceInfo): string {\\n  switch (source.type) {\\n    case SourceType.Runtime:\\n      return `runtime for chunk ${source.chunkPath}`\\n    case SourceType.Parent:\\n      return `parent module ${source.parentId}`\\n    default:\\n      invariant(source, (source) => `Unknown source type: ${source?.type}`)\\n  }\\n}\\n\\ntype ExternalRequire = (\\n  id: ModuleId,\\n  thunk: () => any,\\n  esm?: boolean\\n) => Exports | EsmNamespaceObject\\ntype ExternalImport = (id: ModuleId) => Promise<Exports | EsmNamespaceObject>\\n\\ninterface TurbopackNodeBuildContext extends TurbopackBaseContext<Module> {\\n  R: ResolvePathFromModule\\n  x: ExternalRequire\\n  y: ExternalImport\\n}\\n\\ntype ModuleFactory = (\\n  this: Module['exports'],\\n  context: TurbopackNodeBuildContext\\n) => unknown\\n\\nconst url = require('url') as typeof import('url')\\nconst fs = require('fs/promises') as typeof import('fs/promises')\\n\\nconst moduleFactories: ModuleFactories = Object.create(null)\\nconst moduleCache: ModuleCache<Module> = Object.create(null)\\n\\n/**\\n * Returns an absolute path to the given module's id.\\n */\\nfunction createResolvePathFromModule(\\n  resolver: (moduleId: string) => Exports\\n): (moduleId: string) => string {\\n  return function resolvePathFromModule(moduleId: string): string {\\n    const exported = resolver(moduleId)\\n    const exportedPath = exported?.default ?? exported\\n    if (typeof exportedPath !== 'string') {\\n      return exported as any\\n    }\\n\\n    const strippedAssetPrefix = exportedPath.slice(ASSET_PREFIX.length)\\n    const resolved = path.resolve(RUNTIME_ROOT, strippedAssetPrefix)\\n\\n    return url.pathToFileURL(resolved).href\\n  }\\n}\\n\\nfunction loadChunk(chunkData: ChunkData, source?: SourceInfo): void {\\n  if (typeof chunkData === 'string') {\\n    loadChunkPath(chunkData, source)\\n  } else {\\n    loadChunkPath(chunkData.path, source)\\n  }\\n}\\n\\nconst loadedChunks = new Set<ChunkPath>()\\nconst unsupportedLoadChunk = Promise.resolve(undefined)\\nconst loadedChunk: Promise<void> = Promise.resolve(undefined)\\nconst chunkCache = new Map<ChunkPath, Promise<void>>()\\n\\nfunction clearChunkCache() {\\n  chunkCache.clear()\\n}\\n\\nfunction loadChunkPath(chunkPath: ChunkPath, source?: SourceInfo): void {\\n  if (!isJs(chunkPath)) {\\n    // We only support loading JS chunks in Node.js.\\n    // This branch can be hit when trying to load a CSS chunk.\\n    return\\n  }\\n\\n  if (loadedChunks.has(chunkPath)) {\\n    return\\n  }\\n\\n  try {\\n    const resolved = path.resolve(RUNTIME_ROOT, chunkPath)\\n    const chunkModules: CompressedModuleFactories = require(resolved)\\n\\n    for (const [moduleId, moduleFactory] of Object.entries(chunkModules)) {\\n      if (!moduleFactories[moduleId]) {\\n        if (Array.isArray(moduleFactory)) {\\n          const [moduleFactoryFn, otherIds] = moduleFactory\\n          moduleFactories[moduleId] = moduleFactoryFn\\n          for (const otherModuleId of otherIds) {\\n            moduleFactories[otherModuleId] = moduleFactoryFn\\n          }\\n        } else {\\n          moduleFactories[moduleId] = moduleFactory\\n        }\\n      }\\n    }\\n    loadedChunks.add(chunkPath)\\n  } catch (e) {\\n    let errorMessage = `Failed to load chunk ${chunkPath}`\\n\\n    if (source) {\\n      errorMessage += ` from ${stringifySourceInfo(source)}`\\n    }\\n\\n    throw new Error(errorMessage, {\\n      cause: e,\\n    })\\n  }\\n}\\n\\nfunction loadChunkUncached(chunkPath: ChunkPath) {\\n  // resolve to an absolute path to simplify `require` handling\\n  const resolved = path.resolve(RUNTIME_ROOT, chunkPath)\\n\\n  // TODO: consider switching to `import()` to enable concurrent chunk loading and async file io\\n  // However this is incompatible with hot reloading (since `import` doesn't use the require cache)\\n  const chunkModules: CompressedModuleFactories = require(resolved)\\n  for (const [moduleId, moduleFactory] of Object.entries(chunkModules)) {\\n    if (!moduleFactories[moduleId]) {\\n      if (Array.isArray(moduleFactory)) {\\n        const [moduleFactoryFn, otherIds] = moduleFactory\\n        moduleFactories[moduleId] = moduleFactoryFn\\n        for (const otherModuleId of otherIds) {\\n          moduleFactories[otherModuleId] = moduleFactoryFn\\n        }\\n      } else {\\n        moduleFactories[moduleId] = moduleFactory\\n      }\\n    }\\n  }\\n}\\n\\nfunction loadChunkAsync(\\n  source: SourceInfo,\\n  chunkData: ChunkData\\n): Promise<void> {\\n  const chunkPath = typeof chunkData === 'string' ? chunkData : chunkData.path\\n  if (!isJs(chunkPath)) {\\n    // We only support loading JS chunks in Node.js.\\n    // This branch can be hit when trying to load a CSS chunk.\\n    return unsupportedLoadChunk\\n  }\\n\\n  let entry = chunkCache.get(chunkPath)\\n  if (entry === undefined) {\\n    try {\\n      // Load the chunk synchronously\\n      loadChunkUncached(chunkPath)\\n      entry = loadedChunk\\n    } catch (e) {\\n      let errorMessage = `Failed to load chunk ${chunkPath}`\\n      if (source) {\\n        errorMessage += ` from ${stringifySourceInfo(source)}`\\n      }\\n\\n      // Cache the failure promise, future requests will also get this same rejection\\n      entry = Promise.reject(\\n        new Error(errorMessage, {\\n          cause: e,\\n        })\\n      )\\n    }\\n    chunkCache.set(chunkPath, entry)\\n  }\\n  // TODO: Return an instrumented Promise that React can use instead of relying on referential equality.\\n  return entry\\n}\\n\\nfunction loadChunkAsyncByUrl(source: SourceInfo, chunkUrl: string) {\\n  const path = url.fileURLToPath(new URL(chunkUrl, RUNTIME_ROOT)) as ChunkPath\\n  return loadChunkAsync(source, path)\\n}\\n\\nfunction loadWebAssembly(\\n  chunkPath: ChunkPath,\\n  _edgeModule: () => WebAssembly.Module,\\n  imports: WebAssembly.Imports\\n) {\\n  const resolved = path.resolve(RUNTIME_ROOT, chunkPath)\\n\\n  return instantiateWebAssemblyFromPath(resolved, imports)\\n}\\n\\nfunction loadWebAssemblyModule(\\n  chunkPath: ChunkPath,\\n  _edgeModule: () => WebAssembly.Module\\n) {\\n  const resolved = path.resolve(RUNTIME_ROOT, chunkPath)\\n\\n  return compileWebAssemblyFromPath(resolved)\\n}\\n\\nfunction getWorkerBlobURL(_chunks: ChunkPath[]): string {\\n  throw new Error('Worker blobs are not implemented yet for Node.js')\\n}\\n\\nfunction instantiateModule(id: ModuleId, source: SourceInfo): Module {\\n  const moduleFactory = moduleFactories[id]\\n  if (typeof moduleFactory !== 'function') {\\n    // This can happen if modules incorrectly handle HMR disposes/updates,\\n    // e.g. when they keep a `setTimeout` around which still executes old code\\n    // and contains e.g. a `require(\\\"something\\\")` call.\\n    let instantiationReason\\n    switch (source.type) {\\n      case SourceType.Runtime:\\n        instantiationReason = `as a runtime entry of chunk ${source.chunkPath}`\\n        break\\n      case SourceType.Parent:\\n        instantiationReason = `because it was required from module ${source.parentId}`\\n        break\\n      default:\\n        invariant(source, (source) => `Unknown source type: ${source?.type}`)\\n    }\\n    throw new Error(\\n      `Module ${id} was instantiated ${instantiationReason}, but the module factory is not available. It might have been deleted in an HMR update.`\\n    )\\n  }\\n\\n  const module: Module = {\\n    exports: {},\\n    error: undefined,\\n    loaded: false,\\n    id,\\n    namespaceObject: undefined,\\n  }\\n  moduleCache[id] = module\\n\\n  // NOTE(alexkirsz) This can fail when the module encounters a runtime error.\\n  try {\\n    const r = commonJsRequire.bind(null, module)\\n    moduleFactory.call(module.exports, {\\n      a: asyncModule.bind(null, module),\\n      e: module.exports,\\n      r,\\n      t: runtimeRequire,\\n      x: externalRequire,\\n      y: externalImport,\\n      f: moduleContext,\\n      i: esmImport.bind(null, module),\\n      s: esmExport.bind(null, module, module.exports, moduleCache),\\n      j: dynamicExport.bind(null, module, module.exports, moduleCache),\\n      v: exportValue.bind(null, module, moduleCache),\\n      n: exportNamespace.bind(null, module, moduleCache),\\n      m: module,\\n      c: moduleCache,\\n      M: moduleFactories,\\n      l: loadChunkAsync.bind(null, { type: SourceType.Parent, parentId: id }),\\n      L: loadChunkAsyncByUrl.bind(null, {\\n        type: SourceType.Parent,\\n        parentId: id,\\n      }),\\n      C: clearChunkCache,\\n      w: loadWebAssembly,\\n      u: loadWebAssemblyModule,\\n      P: resolveAbsolutePath,\\n      U: relativeURL,\\n      R: createResolvePathFromModule(r),\\n      b: getWorkerBlobURL,\\n      z: requireStub,\\n    })\\n  } catch (error) {\\n    module.error = error as any\\n    throw error\\n  }\\n\\n  module.loaded = true\\n  if (module.namespaceObject && module.exports !== module.namespaceObject) {\\n    // in case of a circular dependency: cjs1 -> esm2 -> cjs1\\n    interopEsm(module.exports, module.namespaceObject)\\n  }\\n\\n  return module\\n}\\n\\n/**\\n * Retrieves a module from the cache, or instantiate it if it is not cached.\\n */\\n// @ts-ignore\\nfunction getOrInstantiateModuleFromParent(\\n  id: ModuleId,\\n  sourceModule: Module\\n): Module {\\n  const module = moduleCache[id]\\n\\n  if (module) {\\n    return module\\n  }\\n\\n  return instantiateModule(id, {\\n    type: SourceType.Parent,\\n    parentId: sourceModule.id,\\n  })\\n}\\n\\n/**\\n * Instantiates a runtime module.\\n */\\nfunction instantiateRuntimeModule(\\n  moduleId: ModuleId,\\n  chunkPath: ChunkPath\\n): Module {\\n  return instantiateModule(moduleId, { type: SourceType.Runtime, chunkPath })\\n}\\n\\n/**\\n * Retrieves a module from the cache, or instantiate it as a runtime module if it is not cached.\\n */\\n// @ts-ignore TypeScript doesn't separate this module space from the browser runtime\\nfunction getOrInstantiateRuntimeModule(\\n  moduleId: ModuleId,\\n  chunkPath: ChunkPath\\n): Module {\\n  const module = moduleCache[moduleId]\\n  if (module) {\\n    if (module.error) {\\n      throw module.error\\n    }\\n    return module\\n  }\\n\\n  return instantiateRuntimeModule(moduleId, chunkPath)\\n}\\n\\nconst regexJsUrl = /\\\\.js(?:\\\\?[^#]*)?(?:#.*)?$/\\n/**\\n * Checks if a given path/URL ends with .js, optionally followed by ?query or #fragment.\\n */\\nfunction isJs(chunkUrlOrPath: ChunkUrl | ChunkPath): boolean {\\n  return regexJsUrl.test(chunkUrlOrPath)\\n}\\n\\nmodule.exports = {\\n  getOrInstantiateRuntimeModule,\\n  loadChunk,\\n}\\n\"],\"names\":[],\"mappings\":\"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\",\"ignoreList\":[0]}}]\n+    {\"offset\": {\"line\": 447, \"column\": 0}, \"map\": {\"version\":3,\"sources\":[\"turbopack:///[turbopack]/nodejs/runtime.ts\"],\"sourcesContent\":[\"/* eslint-disable @typescript-eslint/no-unused-vars */\\n\\n/// <reference path=\\\"../shared/runtime-utils.ts\\\" />\\n/// <reference path=\\\"../shared-node/base-externals-utils.ts\\\" />\\n/// <reference path=\\\"../shared-node/node-externals-utils.ts\\\" />\\n/// <reference path=\\\"../shared-node/node-wasm-utils.ts\\\" />\\n\\nenum SourceType {\\n  /**\\n   * The module was instantiated because it was included in an evaluated chunk's\\n   * runtime.\\n   * SourceData is a ChunkPath.\\n   */\\n  Runtime = 0,\\n  /**\\n   * The module was instantiated because a parent module imported it.\\n   * SourceData is a ModuleId.\\n   */\\n  Parent = 1,\\n}\\n\\ntype SourceData = ChunkPath | ModuleId\\n\\nprocess.env.TURBOPACK = '1'\\n\\nfunction stringifySourceInfo(\\n  sourceType: SourceType,\\n  sourceData: SourceData\\n): string {\\n  switch (sourceType) {\\n    case SourceType.Runtime:\\n      return `runtime for chunk ${sourceData}`\\n    case SourceType.Parent:\\n      return `parent module ${sourceData}`\\n    default:\\n      invariant(\\n        sourceType,\\n        (sourceType) => `Unknown source type: ${sourceType}`\\n      )\\n  }\\n}\\n\\ntype ExternalRequire = (\\n  id: ModuleId,\\n  thunk: () => any,\\n  esm?: boolean\\n) => Exports | EsmNamespaceObject\\ntype ExternalImport = (id: ModuleId) => Promise<Exports | EsmNamespaceObject>\\n\\ninterface TurbopackNodeBuildContext extends TurbopackBaseContext<Module> {\\n  R: ResolvePathFromModule\\n  x: ExternalRequire\\n  y: ExternalImport\\n}\\n\\ntype ModuleFactory = (\\n  this: Module['exports'],\\n  context: TurbopackNodeBuildContext\\n) => unknown\\n\\nconst url = require('url') as typeof import('url')\\nconst fs = require('fs/promises') as typeof import('fs/promises')\\n\\nconst moduleFactories: ModuleFactories = Object.create(null)\\nconst moduleCache: ModuleCache<Module> = Object.create(null)\\n\\n/**\\n * Returns an absolute path to the given module's id.\\n */\\nfunction createResolvePathFromModule(\\n  resolver: (moduleId: string) => Exports\\n): (moduleId: string) => string {\\n  return function resolvePathFromModule(moduleId: string): string {\\n    const exported = resolver(moduleId)\\n    const exportedPath = exported?.default ?? exported\\n    if (typeof exportedPath !== 'string') {\\n      return exported as any\\n    }\\n\\n    const strippedAssetPrefix = exportedPath.slice(ASSET_PREFIX.length)\\n    const resolved = path.resolve(RUNTIME_ROOT, strippedAssetPrefix)\\n\\n    return url.pathToFileURL(resolved).href\\n  }\\n}\\n\\nfunction loadChunk(\\n  sourceType: SourceType,\\n  sourceData: SourceData,\\n  chunkData: ChunkData\\n): void {\\n  if (typeof chunkData === 'string') {\\n    loadChunkPath(sourceType, sourceData, chunkData)\\n  } else {\\n    loadChunkPath(sourceType, sourceData, chunkData.path)\\n  }\\n}\\n\\nconst loadedChunks = new Set<ChunkPath>()\\nconst unsupportedLoadChunk = Promise.resolve(undefined)\\nconst loadedChunk: Promise<void> = Promise.resolve(undefined)\\nconst chunkCache = new Map<ChunkPath, Promise<void>>()\\n\\nfunction clearChunkCache() {\\n  chunkCache.clear()\\n}\\n\\nfunction loadChunkPath(\\n  sourceType: SourceType,\\n  sourceData: SourceData,\\n  chunkPath: ChunkPath\\n): void {\\n  if (!isJs(chunkPath)) {\\n    // We only support loading JS chunks in Node.js.\\n    // This branch can be hit when trying to load a CSS chunk.\\n    return\\n  }\\n\\n  if (loadedChunks.has(chunkPath)) {\\n    return\\n  }\\n\\n  try {\\n    const resolved = path.resolve(RUNTIME_ROOT, chunkPath)\\n    const chunkModules: CompressedModuleFactories = require(resolved)\\n\\n    for (const [moduleId, moduleFactory] of Object.entries(chunkModules)) {\\n      if (!moduleFactories[moduleId]) {\\n        if (Array.isArray(moduleFactory)) {\\n          const [moduleFactoryFn, otherIds] = moduleFactory\\n          moduleFactories[moduleId] = moduleFactoryFn\\n          for (const otherModuleId of otherIds) {\\n            moduleFactories[otherModuleId] = moduleFactoryFn\\n          }\\n        } else {\\n          moduleFactories[moduleId] = moduleFactory\\n        }\\n      }\\n    }\\n    loadedChunks.add(chunkPath)\\n  } catch (e) {\\n    let errorMessage = `Failed to load chunk ${chunkPath}`\\n\\n    if (sourceType !== undefined) {\\n      errorMessage += ` from ${stringifySourceInfo(sourceType, sourceData)}`\\n    }\\n\\n    throw new Error(errorMessage, {\\n      cause: e,\\n    })\\n  }\\n}\\n\\nfunction loadChunkUncached(chunkPath: ChunkPath) {\\n  // resolve to an absolute path to simplify `require` handling\\n  const resolved = path.resolve(RUNTIME_ROOT, chunkPath)\\n\\n  // TODO: consider switching to `import()` to enable concurrent chunk loading and async file io\\n  // However this is incompatible with hot reloading (since `import` doesn't use the require cache)\\n  const chunkModules: CompressedModuleFactories = require(resolved)\\n  for (const [moduleId, moduleFactory] of Object.entries(chunkModules)) {\\n    if (!moduleFactories[moduleId]) {\\n      if (Array.isArray(moduleFactory)) {\\n        const [moduleFactoryFn, otherIds] = moduleFactory\\n        moduleFactories[moduleId] = moduleFactoryFn\\n        for (const otherModuleId of otherIds) {\\n          moduleFactories[otherModuleId] = moduleFactoryFn\\n        }\\n      } else {\\n        moduleFactories[moduleId] = moduleFactory\\n      }\\n    }\\n  }\\n}\\n\\nfunction loadChunkAsync(\\n  sourceType: SourceType,\\n  sourceData: SourceData,\\n  chunkData: ChunkData\\n): Promise<void> {\\n  const chunkPath = typeof chunkData === 'string' ? chunkData : chunkData.path\\n  if (!isJs(chunkPath)) {\\n    // We only support loading JS chunks in Node.js.\\n    // This branch can be hit when trying to load a CSS chunk.\\n    return unsupportedLoadChunk\\n  }\\n\\n  let entry = chunkCache.get(chunkPath)\\n  if (entry === undefined) {\\n    try {\\n      // Load the chunk synchronously\\n      loadChunkUncached(chunkPath)\\n      entry = loadedChunk\\n    } catch (e) {\\n      let errorMessage = `Failed to load chunk ${chunkPath}`\\n      if (sourceType !== undefined) {\\n        errorMessage += ` from ${stringifySourceInfo(sourceType, sourceData)}`\\n      }\\n\\n      // Cache the failure promise, future requests will also get this same rejection\\n      entry = Promise.reject(\\n        new Error(errorMessage, {\\n          cause: e,\\n        })\\n      )\\n    }\\n    chunkCache.set(chunkPath, entry)\\n  }\\n  // TODO: Return an instrumented Promise that React can use instead of relying on referential equality.\\n  return entry\\n}\\n\\nfunction loadChunkAsyncByUrl(\\n  sourceType: SourceType,\\n  sourceData: SourceData,\\n  chunkUrl: string\\n) {\\n  const path = url.fileURLToPath(new URL(chunkUrl, RUNTIME_ROOT)) as ChunkPath\\n  return loadChunkAsync(sourceType, sourceData, path)\\n}\\n\\nfunction loadWebAssembly(\\n  chunkPath: ChunkPath,\\n  _edgeModule: () => WebAssembly.Module,\\n  imports: WebAssembly.Imports\\n) {\\n  const resolved = path.resolve(RUNTIME_ROOT, chunkPath)\\n\\n  return instantiateWebAssemblyFromPath(resolved, imports)\\n}\\n\\nfunction loadWebAssemblyModule(\\n  chunkPath: ChunkPath,\\n  _edgeModule: () => WebAssembly.Module\\n) {\\n  const resolved = path.resolve(RUNTIME_ROOT, chunkPath)\\n\\n  return compileWebAssemblyFromPath(resolved)\\n}\\n\\nfunction getWorkerBlobURL(_chunks: ChunkPath[]): string {\\n  throw new Error('Worker blobs are not implemented yet for Node.js')\\n}\\n\\nfunction instantiateModule(\\n  id: ModuleId,\\n  sourceType: SourceType,\\n  sourceData: SourceData\\n): Module {\\n  const moduleFactory = moduleFactories[id]\\n  if (typeof moduleFactory !== 'function') {\\n    // This can happen if modules incorrectly handle HMR disposes/updates,\\n    // e.g. when they keep a `setTimeout` around which still executes old code\\n    // and contains e.g. a `require(\\\"something\\\")` call.\\n    let instantiationReason\\n    switch (sourceType) {\\n      case SourceType.Runtime:\\n        instantiationReason = `as a runtime entry of chunk ${sourceData}`\\n        break\\n      case SourceType.Parent:\\n        instantiationReason = `because it was required from module ${sourceData}`\\n        break\\n      default:\\n        invariant(\\n          sourceType,\\n          (sourceType) => `Unknown source type: ${sourceType}`\\n        )\\n    }\\n    throw new Error(\\n      `Module ${id} was instantiated ${instantiationReason}, but the module factory is not available.`\\n    )\\n  }\\n\\n  const module: Module = {\\n    exports: {},\\n    error: undefined,\\n    loaded: false,\\n    id,\\n    namespaceObject: undefined,\\n  }\\n  moduleCache[id] = module\\n\\n  // NOTE(alexkirsz) This can fail when the module encounters a runtime error.\\n  try {\\n    const r = commonJsRequire.bind(null, module)\\n    moduleFactory.call(module.exports, {\\n      a: asyncModule.bind(null, module),\\n      e: module.exports,\\n      r,\\n      t: runtimeRequire,\\n      x: externalRequire,\\n      y: externalImport,\\n      f: moduleContext,\\n      i: esmImport.bind(null, module),\\n      s: esmExport.bind(null, module, module.exports, moduleCache),\\n      j: dynamicExport.bind(null, module, module.exports, moduleCache),\\n      v: exportValue.bind(null, module, moduleCache),\\n      n: exportNamespace.bind(null, module, moduleCache),\\n      m: module,\\n      c: moduleCache,\\n      M: moduleFactories,\\n      l: loadChunkAsync.bind(null, SourceType.Parent, id),\\n      L: loadChunkAsyncByUrl.bind(null, SourceType.Parent, id),\\n      C: clearChunkCache,\\n      w: loadWebAssembly,\\n      u: loadWebAssemblyModule,\\n      P: resolveAbsolutePath,\\n      U: relativeURL,\\n      R: createResolvePathFromModule(r),\\n      b: getWorkerBlobURL,\\n      z: requireStub,\\n    })\\n  } catch (error) {\\n    module.error = error as any\\n    throw error\\n  }\\n\\n  module.loaded = true\\n  if (module.namespaceObject && module.exports !== module.namespaceObject) {\\n    // in case of a circular dependency: cjs1 -> esm2 -> cjs1\\n    interopEsm(module.exports, module.namespaceObject)\\n  }\\n\\n  return module\\n}\\n\\n/**\\n * Retrieves a module from the cache, or instantiate it if it is not cached.\\n */\\n// @ts-ignore\\nfunction getOrInstantiateModuleFromParent(\\n  id: ModuleId,\\n  sourceModule: Module\\n): Module {\\n  const module = moduleCache[id]\\n\\n  if (module) {\\n    return module\\n  }\\n\\n  return instantiateModule(id, SourceType.Parent, sourceModule.id)\\n}\\n\\n/**\\n * Instantiates a runtime module.\\n */\\nfunction instantiateRuntimeModule(\\n  chunkPath: ChunkPath,\\n  moduleId: ModuleId\\n): Module {\\n  return instantiateModule(moduleId, SourceType.Runtime, chunkPath)\\n}\\n\\n/**\\n * Retrieves a module from the cache, or instantiate it as a runtime module if it is not cached.\\n */\\n// @ts-ignore TypeScript doesn't separate this module space from the browser runtime\\nfunction getOrInstantiateRuntimeModule(\\n  chunkPath: ChunkPath,\\n  moduleId: ModuleId\\n): Module {\\n  const module = moduleCache[moduleId]\\n  if (module) {\\n    if (module.error) {\\n      throw module.error\\n    }\\n    return module\\n  }\\n\\n  return instantiateRuntimeModule(chunkPath, moduleId)\\n}\\n\\nconst regexJsUrl = /\\\\.js(?:\\\\?[^#]*)?(?:#.*)?$/\\n/**\\n * Checks if a given path/URL ends with .js, optionally followed by ?query or #fragment.\\n */\\nfunction isJs(chunkUrlOrPath: ChunkUrl | ChunkPath): boolean {\\n  return regexJsUrl.test(chunkUrlOrPath)\\n}\\n\\nmodule.exports = (sourcePath: ChunkPath) => ({\\n  m: (id: ModuleId) => getOrInstantiateRuntimeModule(sourcePath, id),\\n  c: (chunkData: ChunkData) =>\\n    loadChunk(SourceType.Runtime, sourcePath, chunkData),\\n})\\n\"],\"names\":[],\"mappings\":\"AAAA,oDAAoD,GAEpD,mDAAmD;AACnD,+DAA+D;AAC/D,+DAA+D;AAC/D,0DAA0D;AAE1D,IAAA,AAAK,oCAAA;IACH;;;;GAIC;IAED;;;GAGC;WAVE;EAAA;AAgBL,QAAQ,GAAG,CAAC,SAAS,GAAG;AAExB,SAAS,oBACP,UAAsB,EACtB,UAAsB;IAEtB,OAAQ;QACN;YACE,OAAO,CAAC,kBAAkB,EAAE,YAAY;QAC1C;YACE,OAAO,CAAC,cAAc,EAAE,YAAY;QACtC;YACE,UACE,YACA,CAAC,aAAe,CAAC,qBAAqB,EAAE,YAAY;IAE1D;AACF;AAoBA,MAAM,MAAM,QAAQ;AACpB,MAAM,KAAK,QAAQ;AAEnB,MAAM,kBAAmC,OAAO,MAAM,CAAC;AACvD,MAAM,cAAmC,OAAO,MAAM,CAAC;AAEvD;;CAEC,GACD,SAAS,4BACP,QAAuC;IAEvC,OAAO,SAAS,sBAAsB,QAAgB;QACpD,MAAM,WAAW,SAAS;QAC1B,MAAM,eAAe,UAAU,WAAW;QAC1C,IAAI,OAAO,iBAAiB,UAAU;YACpC,OAAO;QACT;QAEA,MAAM,sBAAsB,aAAa,KAAK,CAAC,aAAa,MAAM;QAClE,MAAM,WAAW,KAAK,OAAO,CAAC,cAAc;QAE5C,OAAO,IAAI,aAAa,CAAC,UAAU,IAAI;IACzC;AACF;AAEA,SAAS,UACP,UAAsB,EACtB,UAAsB,EACtB,SAAoB;IAEpB,IAAI,OAAO,cAAc,UAAU;QACjC,cAAc,YAAY,YAAY;IACxC,OAAO;QACL,cAAc,YAAY,YAAY,UAAU,IAAI;IACtD;AACF;AAEA,MAAM,eAAe,IAAI;AACzB,MAAM,uBAAuB,QAAQ,OAAO,CAAC;AAC7C,MAAM,cAA6B,QAAQ,OAAO,CAAC;AACnD,MAAM,aAAa,IAAI;AAEvB,SAAS;IACP,WAAW,KAAK;AAClB;AAEA,SAAS,cACP,UAAsB,EACtB,UAAsB,EACtB,SAAoB;IAEpB,IAAI,CAAC,KAAK,YAAY;QACpB,gDAAgD;QAChD,0DAA0D;QAC1D;IACF;IAEA,IAAI,aAAa,GAAG,CAAC,YAAY;QAC/B;IACF;IAEA,IAAI;QACF,MAAM,WAAW,KAAK,OAAO,CAAC,cAAc;QAC5C,MAAM,eAA0C,QAAQ;QAExD,KAAK,MAAM,CAAC,UAAU,cAAc,IAAI,OAAO,OAAO,CAAC,cAAe;YACpE,IAAI,CAAC,eAAe,CAAC,SAAS,EAAE;gBAC9B,IAAI,MAAM,OAAO,CAAC,gBAAgB;oBAChC,MAAM,CAAC,iBAAiB,SAAS,GAAG;oBACpC,eAAe,CAAC,SAAS,GAAG;oBAC5B,KAAK,MAAM,iBAAiB,SAAU;wBACpC,eAAe,CAAC,cAAc,GAAG;oBACnC;gBACF,OAAO;oBACL,eAAe,CAAC,SAAS,GAAG;gBAC9B;YACF;QACF;QACA,aAAa,GAAG,CAAC;IACnB,EAAE,OAAO,GAAG;QACV,IAAI,eAAe,CAAC,qBAAqB,EAAE,WAAW;QAEtD,IAAI,eAAe,WAAW;YAC5B,gBAAgB,CAAC,MAAM,EAAE,oBAAoB,YAAY,aAAa;QACxE;QAEA,MAAM,IAAI,MAAM,cAAc;YAC5B,OAAO;QACT;IACF;AACF;AAEA,SAAS,kBAAkB,SAAoB;IAC7C,6DAA6D;IAC7D,MAAM,WAAW,KAAK,OAAO,CAAC,cAAc;IAE5C,8FAA8F;IAC9F,iGAAiG;IACjG,MAAM,eAA0C,QAAQ;IACxD,KAAK,MAAM,CAAC,UAAU,cAAc,IAAI,OAAO,OAAO,CAAC,cAAe;QACpE,IAAI,CAAC,eAAe,CAAC,SAAS,EAAE;YAC9B,IAAI,MAAM,OAAO,CAAC,gBAAgB;gBAChC,MAAM,CAAC,iBAAiB,SAAS,GAAG;gBACpC,eAAe,CAAC,SAAS,GAAG;gBAC5B,KAAK,MAAM,iBAAiB,SAAU;oBACpC,eAAe,CAAC,cAAc,GAAG;gBACnC;YACF,OAAO;gBACL,eAAe,CAAC,SAAS,GAAG;YAC9B;QACF;IACF;AACF;AAEA,SAAS,eACP,UAAsB,EACtB,UAAsB,EACtB,SAAoB;IAEpB,MAAM,YAAY,OAAO,cAAc,WAAW,YAAY,UAAU,IAAI;IAC5E,IAAI,CAAC,KAAK,YAAY;QACpB,gDAAgD;QAChD,0DAA0D;QAC1D,OAAO;IACT;IAEA,IAAI,QAAQ,WAAW,GAAG,CAAC;IAC3B,IAAI,UAAU,WAAW;QACvB,IAAI;YACF,+BAA+B;YAC/B,kBAAkB;YAClB,QAAQ;QACV,EAAE,OAAO,GAAG;YACV,IAAI,eAAe,CAAC,qBAAqB,EAAE,WAAW;YACtD,IAAI,eAAe,WAAW;gBAC5B,gBAAgB,CAAC,MAAM,EAAE,oBAAoB,YAAY,aAAa;YACxE;YAEA,+EAA+E;YAC/E,QAAQ,QAAQ,MAAM,CACpB,IAAI,MAAM,cAAc;gBACtB,OAAO;YACT;QAEJ;QACA,WAAW,GAAG,CAAC,WAAW;IAC5B;IACA,sGAAsG;IACtG,OAAO;AACT;AAEA,SAAS,oBACP,UAAsB,EACtB,UAAsB,EACtB,QAAgB;IAEhB,MAAM,QAAO,IAAI,aAAa,CAAC,IAAI,IAAI,UAAU;IACjD,OAAO,eAAe,YAAY,YAAY;AAChD;AAEA,SAAS,gBACP,SAAoB,EACpB,WAAqC,EACrC,OAA4B;IAE5B,MAAM,WAAW,KAAK,OAAO,CAAC,cAAc;IAE5C,OAAO,+BAA+B,UAAU;AAClD;AAEA,SAAS,sBACP,SAAoB,EACpB,WAAqC;IAErC,MAAM,WAAW,KAAK,OAAO,CAAC,cAAc;IAE5C,OAAO,2BAA2B;AACpC;AAEA,SAAS,iBAAiB,OAAoB;IAC5C,MAAM,IAAI,MAAM;AAClB;AAEA,SAAS,kBACP,EAAY,EACZ,UAAsB,EACtB,UAAsB;IAEtB,MAAM,gBAAgB,eAAe,CAAC,GAAG;IACzC,IAAI,OAAO,kBAAkB,YAAY;QACvC,sEAAsE;QACtE,0EAA0E;QAC1E,mDAAmD;QACnD,IAAI;QACJ,OAAQ;YACN;gBACE,sBAAsB,CAAC,4BAA4B,EAAE,YAAY;gBACjE;YACF;gBACE,sBAAsB,CAAC,oCAAoC,EAAE,YAAY;gBACzE;YACF;gBACE,UACE,YACA,CAAC,aAAe,CAAC,qBAAqB,EAAE,YAAY;QAE1D;QACA,MAAM,IAAI,MACR,CAAC,OAAO,EAAE,GAAG,kBAAkB,EAAE,oBAAoB,0CAA0C,CAAC;IAEpG;IAEA,MAAM,UAAiB;QACrB,SAAS,CAAC;QACV,OAAO;QACP,QAAQ;QACR;QACA,iBAAiB;IACnB;IACA,WAAW,CAAC,GAAG,GAAG;IAElB,4EAA4E;IAC5E,IAAI;QACF,MAAM,IAAI,gBAAgB,IAAI,CAAC,MAAM;QACrC,cAAc,IAAI,CAAC,QAAO,OAAO,EAAE;YACjC,GAAG,YAAY,IAAI,CAAC,MAAM;YAC1B,GAAG,QAAO,OAAO;YACjB;YACA,GAAG;YACH,GAAG;YACH,GAAG;YACH,GAAG;YACH,GAAG,UAAU,IAAI,CAAC,MAAM;YACxB,GAAG,UAAU,IAAI,CAAC,MAAM,SAAQ,QAAO,OAAO,EAAE;YAChD,GAAG,cAAc,IAAI,CAAC,MAAM,SAAQ,QAAO,OAAO,EAAE;YACpD,GAAG,YAAY,IAAI,CAAC,MAAM,SAAQ;YAClC,GAAG,gBAAgB,IAAI,CAAC,MAAM,SAAQ;YACtC,GAAG;YACH,GAAG;YACH,GAAG;YACH,GAAG,eAAe,IAAI,CAAC,SAAyB;YAChD,GAAG,oBAAoB,IAAI,CAAC,SAAyB;YACrD,GAAG;YACH,GAAG;YACH,GAAG;YACH,GAAG;YACH,GAAG;YACH,GAAG,4BAA4B;YAC/B,GAAG;YACH,GAAG;QACL;IACF,EAAE,OAAO,OAAO;QACd,QAAO,KAAK,GAAG;QACf,MAAM;IACR;IAEA,QAAO,MAAM,GAAG;IAChB,IAAI,QAAO,eAAe,IAAI,QAAO,OAAO,KAAK,QAAO,eAAe,EAAE;QACvE,yDAAyD;QACzD,WAAW,QAAO,OAAO,EAAE,QAAO,eAAe;IACnD;IAEA,OAAO;AACT;AAEA;;CAEC,GACD,aAAa;AACb,SAAS,iCACP,EAAY,EACZ,YAAoB;IAEpB,MAAM,UAAS,WAAW,CAAC,GAAG;IAE9B,IAAI,SAAQ;QACV,OAAO;IACT;IAEA,OAAO,kBAAkB,OAAuB,aAAa,EAAE;AACjE;AAEA;;CAEC,GACD,SAAS,yBACP,SAAoB,EACpB,QAAkB;IAElB,OAAO,kBAAkB,aAA8B;AACzD;AAEA;;CAEC,GACD,oFAAoF;AACpF,SAAS,8BACP,SAAoB,EACpB,QAAkB;IAElB,MAAM,UAAS,WAAW,CAAC,SAAS;IACpC,IAAI,SAAQ;QACV,IAAI,QAAO,KAAK,EAAE;YAChB,MAAM,QAAO,KAAK;QACpB;QACA,OAAO;IACT;IAEA,OAAO,yBAAyB,WAAW;AAC7C;AAEA,MAAM,aAAa;AACnB;;CAEC,GACD,SAAS,KAAK,cAAoC;IAChD,OAAO,WAAW,IAAI,CAAC;AACzB;AAEA,OAAO,OAAO,GAAG,CAAC,aAA0B,CAAC;QAC3C,GAAG,CAAC,KAAiB,8BAA8B,YAAY;QAC/D,GAAG,CAAC,YACF,aAA8B,YAAY;IAC9C,CAAC\",\"ignoreList\":[0]}}]\n }\n\\ No newline at end of file"
        },
        {
            "sha": "2eff81ab8f57ac21254dda411fcad5919d409885",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/runtime/default_build_runtime/output/index.entry.js",
            "status": "modified",
            "additions": 4,
            "deletions": 5,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/dcca55ba269a347ba01732cb5fd0e00e68d44674/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_build_runtime%2Foutput%2Findex.entry.js",
            "raw_url": "https://github.com/vercel/next.js/raw/dcca55ba269a347ba01732cb5fd0e00e68d44674/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_build_runtime%2Foutput%2Findex.entry.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_build_runtime%2Foutput%2Findex.entry.js?ref=dcca55ba269a347ba01732cb5fd0e00e68d44674",
            "patch": "@@ -1,5 +1,4 @@\n-const CHUNK_PUBLIC_PATH = \"output/index.entry.js\";\n-const runtime = require(\"./[turbopack]_runtime.js\");\n-runtime.loadChunk(\"output/4c35f_tests_snapshot_runtime_default_build_runtime_input_index_ba3c9491.js\");\n-runtime.getOrInstantiateRuntimeModule(\"[project]/turbopack/crates/turbopack-tests/tests/snapshot/runtime/default_build_runtime/input/index.js [test] (ecmascript)\", CHUNK_PUBLIC_PATH);\n-module.exports = runtime.getOrInstantiateRuntimeModule(\"[project]/turbopack/crates/turbopack-tests/tests/snapshot/runtime/default_build_runtime/input/index.js [test] (ecmascript)\", CHUNK_PUBLIC_PATH).exports;\n\\ No newline at end of file\n+var R=require(\"./[turbopack]_runtime.js\")(\"output/index.entry.js\")\n+R.c(\"output/4c35f_tests_snapshot_runtime_default_build_runtime_input_index_ba3c9491.js\")\n+R.m(\"[project]/turbopack/crates/turbopack-tests/tests/snapshot/runtime/default_build_runtime/input/index.js [test] (ecmascript)\")\n+module.exports=R.m(\"[project]/turbopack/crates/turbopack-tests/tests/snapshot/runtime/default_build_runtime/input/index.js [test] (ecmascript)\").exports\n\\ No newline at end of file"
        },
        {
            "sha": "734dc2bd95707d80b4e1512546e1453953cf675d",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/runtime/default_dev_runtime/output/a5fc1_turbopack-tests_tests_snapshot_runtime_default_dev_runtime_input_index_73aab4ae.js",
            "status": "modified",
            "additions": 42,
            "deletions": 60,
            "changes": 102,
            "blob_url": "https://github.com/vercel/next.js/blob/dcca55ba269a347ba01732cb5fd0e00e68d44674/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_dev_runtime%2Foutput%2Fa5fc1_turbopack-tests_tests_snapshot_runtime_default_dev_runtime_input_index_73aab4ae.js",
            "raw_url": "https://github.com/vercel/next.js/raw/dcca55ba269a347ba01732cb5fd0e00e68d44674/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_dev_runtime%2Foutput%2Fa5fc1_turbopack-tests_tests_snapshot_runtime_default_dev_runtime_input_index_73aab4ae.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_dev_runtime%2Foutput%2Fa5fc1_turbopack-tests_tests_snapshot_runtime_default_dev_runtime_input_index_73aab4ae.js?ref=dcca55ba269a347ba01732cb5fd0e00e68d44674",
            "patch": "@@ -389,13 +389,16 @@ var SourceType = /*#__PURE__*/ function(SourceType) {\n     /**\n    * The module was instantiated because it was included in an evaluated chunk's\n    * runtime.\n+   * SourceData is a ChunkPath.\n    */ SourceType[SourceType[\"Runtime\"] = 0] = \"Runtime\";\n     /**\n    * The module was instantiated because a parent module imported it.\n+   * SourceData is a ModuleId.\n    */ SourceType[SourceType[\"Parent\"] = 1] = \"Parent\";\n     /**\n    * The module was instantiated because it was included in a chunk's hot module\n    * update.\n+   * SourceData is an array of ModuleIds or undefined.\n    */ SourceType[SourceType[\"Update\"] = 2] = \"Update\";\n     return SourceType;\n }(SourceType || {});\n@@ -426,9 +429,9 @@ const moduleFactories = Object.create(null);\n  */ const chunkChunkListsMap = new Map();\n const availableModules = new Map();\n const availableModuleChunks = new Map();\n-async function loadChunk(source, chunkData) {\n+async function loadChunk(sourceType, sourceData, chunkData) {\n     if (typeof chunkData === 'string') {\n-        return loadChunkPath(source, chunkData);\n+        return loadChunkPath(sourceType, sourceData, chunkData);\n     }\n     const includedList = chunkData.included || [];\n     const modulesPromises = includedList.map((included)=>{\n@@ -459,13 +462,13 @@ async function loadChunk(source, chunkData) {\n             }\n         }\n         for (const moduleChunkToLoad of moduleChunksToLoad){\n-            const promise = loadChunkPath(source, moduleChunkToLoad);\n+            const promise = loadChunkPath(sourceType, sourceData, moduleChunkToLoad);\n             availableModuleChunks.set(moduleChunkToLoad, promise);\n             moduleChunksPromises.push(promise);\n         }\n         promise = Promise.all(moduleChunksPromises);\n     } else {\n-        promise = loadChunkPath(source, chunkData.path);\n+        promise = loadChunkPath(sourceType, sourceData, chunkData.path);\n         // Mark all included module chunks as loading if they are not already loaded or loading.\n         for (const includedModuleChunk of includedModuleChunksList){\n             if (!availableModuleChunks.has(includedModuleChunk)) {\n@@ -485,25 +488,25 @@ async function loadChunk(source, chunkData) {\n const loadedChunk = Promise.resolve(undefined);\n const instrumentedBackendLoadChunks = new WeakMap();\n // Do not make this async. React relies on referential equality of the returned Promise.\n-function loadChunkByUrl(source, chunkUrl) {\n-    const thenable = BACKEND.loadChunkCached(chunkUrl, source);\n+function loadChunkByUrl(sourceType, sourceData, chunkUrl) {\n+    const thenable = BACKEND.loadChunkCached(sourceType, sourceData, chunkUrl);\n     let entry = instrumentedBackendLoadChunks.get(thenable);\n     if (entry === undefined) {\n         const resolve = instrumentedBackendLoadChunks.set.bind(instrumentedBackendLoadChunks, thenable, loadedChunk);\n         entry = thenable.then(resolve).catch((error)=>{\n             let loadReason;\n-            switch(source.type){\n+            switch(sourceType){\n                 case 0:\n-                    loadReason = `as a runtime dependency of chunk ${source.chunkPath}`;\n+                    loadReason = `as a runtime dependency of chunk ${sourceData}`;\n                     break;\n                 case 1:\n-                    loadReason = `from module ${source.parentId}`;\n+                    loadReason = `from module ${sourceData}`;\n                     break;\n                 case 2:\n                     loadReason = 'from an HMR update';\n                     break;\n                 default:\n-                    invariant(source, (source)=>`Unknown source type: ${source?.type}`);\n+                    invariant(sourceType, (sourceType)=>`Unknown source type: ${sourceType}`);\n             }\n             throw new Error(`Failed to load chunk ${chunkUrl} ${loadReason}${error ? `: ${error}` : ''}`, error ? {\n                 cause: error\n@@ -513,9 +516,9 @@ function loadChunkByUrl(source, chunkUrl) {\n     }\n     return entry;\n }\n-async function loadChunkPath(source, chunkPath) {\n+async function loadChunkPath(sourceType, sourceData, chunkPath) {\n     const url = getChunkRelativeUrl(chunkPath);\n-    return loadChunkByUrl(source, url);\n+    return loadChunkByUrl(sourceType, sourceData, url);\n }\n /**\n  * Returns an absolute url to an asset.\n@@ -583,10 +586,7 @@ importScripts(...self.TURBOPACK_NEXT_CHUNK_URLS.map(c => self.TURBOPACK_WORKER_L\n /**\n  * Instantiates a runtime module.\n  */ function instantiateRuntimeModule(moduleId, chunkPath) {\n-    return instantiateModule(moduleId, {\n-        type: 0,\n-        chunkPath\n-    });\n+    return instantiateModule(moduleId, 0, chunkPath);\n }\n /**\n  * Returns the URL relative to the origin where a chunk can be fetched from.\n@@ -670,7 +670,7 @@ class UpdateApplyError extends Error {\n /**\n  * Gets or instantiates a runtime module.\n  */ // @ts-ignore\n-function getOrInstantiateRuntimeModule(moduleId, chunkPath) {\n+function getOrInstantiateRuntimeModule(chunkPath, moduleId) {\n     const module = devModuleCache[moduleId];\n     if (module) {\n         if (module.error) {\n@@ -679,10 +679,7 @@ function getOrInstantiateRuntimeModule(moduleId, chunkPath) {\n         return module;\n     }\n     // @ts-ignore\n-    return instantiateModule(moduleId, {\n-        type: SourceType.Runtime,\n-        chunkPath\n-    });\n+    return instantiateModule(moduleId, SourceType.Runtime, chunkPath);\n }\n /**\n  * Retrieves a module from the cache, or instantiate it if it is not cached.\n@@ -701,12 +698,9 @@ const getOrInstantiateModuleFromParent = (id, sourceModule)=>{\n         }\n         return module;\n     }\n-    return instantiateModule(id, {\n-        type: SourceType.Parent,\n-        parentId: sourceModule.id\n-    });\n+    return instantiateModule(id, SourceType.Parent, sourceModule.id);\n };\n-function instantiateModule(moduleId, source) {\n+function instantiateModule(moduleId, sourceType, sourceData) {\n     // We are in development, this is always a string.\n     let id = moduleId;\n     const moduleFactory = moduleFactories[id];\n@@ -715,25 +709,25 @@ function instantiateModule(moduleId, source) {\n         // e.g. when they keep a `setTimeout` around which still executes old code\n         // and contains e.g. a `require(\"something\")` call.\n         let instantiationReason;\n-        switch(source.type){\n+        switch(sourceType){\n             case SourceType.Runtime:\n-                instantiationReason = `as a runtime entry of chunk ${source.chunkPath}`;\n+                instantiationReason = `as a runtime entry of chunk ${sourceData}`;\n                 break;\n             case SourceType.Parent:\n-                instantiationReason = `because it was required from module ${source.parentId}`;\n+                instantiationReason = `because it was required from module ${sourceData}`;\n                 break;\n             case SourceType.Update:\n                 instantiationReason = 'because of an HMR update';\n                 break;\n             default:\n-                invariant(source, (source)=>`Unknown source type: ${source?.type}`);\n+                invariant(sourceType, (sourceType)=>`Unknown source type: ${sourceType}`);\n         }\n         throw new Error(`Module ${id} was instantiated ${instantiationReason}, but the module factory is not available. It might have been deleted in an HMR update.`);\n     }\n     const hotData = moduleHotData.get(id);\n     const { hot, hotState } = createModuleHot(id, hotData);\n     let parents;\n-    switch(source.type){\n+    switch(sourceType){\n         case SourceType.Runtime:\n             runtimeModules.add(id);\n             parents = [];\n@@ -742,14 +736,14 @@ function instantiateModule(moduleId, source) {\n             // No need to add this module as a child of the parent module here, this\n             // has already been taken care of in `getOrInstantiateModuleFromParent`.\n             parents = [\n-                source.parentId\n+                sourceData\n             ];\n             break;\n         case SourceType.Update:\n-            parents = source.parents || [];\n+            parents = sourceData || [];\n             break;\n         default:\n-            invariant(source, (source)=>`Unknown source type: ${source?.type}`);\n+            invariant(sourceType, (sourceType)=>`Unknown source type: ${sourceType}`);\n     }\n     const module = {\n         exports: {},\n@@ -765,10 +759,6 @@ function instantiateModule(moduleId, source) {\n     moduleHotState.set(module, hotState);\n     // NOTE(alexkirsz) This can fail when the module encounters a runtime error.\n     try {\n-        const sourceInfo = {\n-            type: SourceType.Parent,\n-            parentId: id\n-        };\n         runModuleExecutionHooks(module, (refresh)=>{\n             const r = commonJsRequire.bind(null, module);\n             moduleFactory(augmentContext({\n@@ -786,10 +776,10 @@ function instantiateModule(moduleId, source) {\n                 c: devModuleCache,\n                 C: null,\n                 M: moduleFactories,\n-                l: loadChunk.bind(null, sourceInfo),\n-                L: loadChunkByUrl.bind(null, sourceInfo),\n-                w: loadWebAssembly.bind(null, sourceInfo),\n-                u: loadWebAssemblyModule.bind(null, sourceInfo),\n+                l: loadChunk.bind(null, SourceType.Parent, id),\n+                L: loadChunkByUrl.bind(null, SourceType.Parent, id),\n+                w: loadWebAssembly.bind(null, SourceType.Parent, id),\n+                u: loadWebAssemblyModule.bind(null, SourceType.Parent, id),\n                 P: resolveAbsolutePath,\n                 U: relativeURL,\n                 k: refresh,\n@@ -1043,10 +1033,7 @@ function applyPhase(outdatedSelfAcceptedModules, newModuleFactories, outdatedMod\n     // Re-instantiate all outdated self-accepted modules.\n     for (const { moduleId, errorHandler } of outdatedSelfAcceptedModules){\n         try {\n-            instantiateModule(moduleId, {\n-                type: SourceType.Update,\n-                parents: outdatedModuleParents.get(moduleId)\n-            });\n+            instantiateModule(moduleId, SourceType.Update, outdatedModuleParents.get(moduleId));\n         } catch (err) {\n             if (typeof errorHandler === 'function') {\n                 try {\n@@ -1090,9 +1077,7 @@ function applyChunkListUpdate(update) {\n             const chunkUrl = getChunkRelativeUrl(chunkPath);\n             switch(chunkUpdate.type){\n                 case 'added':\n-                    BACKEND.loadChunkCached(chunkUrl, {\n-                        type: SourceType.Update\n-                    });\n+                    BACKEND.loadChunkCached(SourceType.Update, undefined, chunkUrl);\n                     break;\n                 case 'total':\n                     DEV_BACKEND.reloadChunk?.(chunkUrl);\n@@ -1490,12 +1475,12 @@ function augmentContext(context) {\n function fetchWebAssembly(wasmChunkPath) {\n     return fetch(getChunkRelativeUrl(wasmChunkPath));\n }\n-async function loadWebAssembly(_source, wasmChunkPath, _edgeModule, importsObj) {\n+async function loadWebAssembly(_sourceType, _sourceData, wasmChunkPath, _edgeModule, importsObj) {\n     const req = fetchWebAssembly(wasmChunkPath);\n     const { instance } = await WebAssembly.instantiateStreaming(req, importsObj);\n     return instance.exports;\n }\n-async function loadWebAssemblyModule(_source, wasmChunkPath, _edgeModule) {\n+async function loadWebAssemblyModule(_sourceType, _sourceData, wasmChunkPath, _edgeModule) {\n     const req = fetchWebAssembly(wasmChunkPath);\n     return await WebAssembly.compileStreaming(req);\n }\n@@ -1518,21 +1503,18 @@ async function loadWebAssemblyModule(_source, wasmChunkPath, _edgeModule) {\n                 getOrCreateResolver(otherChunkUrl);\n             }\n             // This waits for chunks to be loaded, but also marks included items as available.\n-            await Promise.all(params.otherChunks.map((otherChunkData)=>loadChunk({\n-                    type: SourceType.Runtime,\n-                    chunkPath\n-                }, otherChunkData)));\n+            await Promise.all(params.otherChunks.map((otherChunkData)=>loadChunk(SourceType.Runtime, chunkPath, otherChunkData)));\n             if (params.runtimeModuleIds.length > 0) {\n                 for (const moduleId of params.runtimeModuleIds){\n-                    getOrInstantiateRuntimeModule(moduleId, chunkPath);\n+                    getOrInstantiateRuntimeModule(chunkPath, moduleId);\n                 }\n             }\n         },\n         /**\n      * Loads the given chunk, and returns a promise that resolves once the chunk\n      * has been loaded.\n-     */ loadChunkCached (chunkUrl, source) {\n-            return doLoadChunk(chunkUrl, source);\n+     */ loadChunkCached (sourceType, sourceData, chunkUrl) {\n+            return doLoadChunk(sourceType, sourceData, chunkUrl);\n         }\n     };\n     function getOrCreateResolver(chunkUrl) {\n@@ -1561,12 +1543,12 @@ async function loadWebAssemblyModule(_source, wasmChunkPath, _edgeModule) {\n     /**\n    * Loads the given chunk, and returns a promise that resolves once the chunk\n    * has been loaded.\n-   */ function doLoadChunk(chunkUrl, source) {\n+   */ function doLoadChunk(sourceType, _sourceData, chunkUrl) {\n         const resolver = getOrCreateResolver(chunkUrl);\n         if (resolver.loadingStarted) {\n             return resolver.promise;\n         }\n-        if (source.type === SourceType.Runtime) {\n+        if (sourceType === SourceType.Runtime) {\n             // We don't need to load chunks references from runtime code, as they're already\n             // present in the DOM.\n             resolver.loadingStarted = true;"
        },
        {
            "sha": "932a72098c642151fb3bbce65bf0972db1c13242",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/runtime/default_dev_runtime/output/b1abf_turbopack-tests_tests_snapshot_runtime_default_dev_runtime_input_index_73aab4ae.js.map",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/dcca55ba269a347ba01732cb5fd0e00e68d44674/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_dev_runtime%2Foutput%2Fb1abf_turbopack-tests_tests_snapshot_runtime_default_dev_runtime_input_index_73aab4ae.js.map",
            "raw_url": "https://github.com/vercel/next.js/raw/dcca55ba269a347ba01732cb5fd0e00e68d44674/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_dev_runtime%2Foutput%2Fb1abf_turbopack-tests_tests_snapshot_runtime_default_dev_runtime_input_index_73aab4ae.js.map",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_dev_runtime%2Foutput%2Fb1abf_turbopack-tests_tests_snapshot_runtime_default_dev_runtime_input_index_73aab4ae.js.map?ref=dcca55ba269a347ba01732cb5fd0e00e68d44674"
        }
    ],
    "stats": {
        "total": 582,
        "additions": 303,
        "deletions": 279
    }
}