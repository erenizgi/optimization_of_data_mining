{
    "author": "lukesandberg",
    "message": "[turbopack] Delete the `read_glob` function (#79166)\n\nWhy? This was only used for unit tests and an example.  Also, the API was a little strange, it would end up creating a `Vc` that depended on all the directories with matches and produced a value that modeled the matching directory tree.\n\nHappy to replace the example... I wasn't really sure what those were used for.",
    "sha": "5d73b2f3612a7d4e762d036d39a6d5feedb77681",
    "files": [
        {
            "sha": "c82d5dd830a7795fc659495069d5c70f8dc8ca47",
            "filename": "turbopack/crates/turbo-tasks-fs/examples/hash_glob.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 120,
            "changes": 120,
            "blob_url": "https://github.com/vercel/next.js/blob/15942fcc72f442911a5cbb9b18070a16241a2709/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fexamples%2Fhash_glob.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/15942fcc72f442911a5cbb9b18070a16241a2709/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fexamples%2Fhash_glob.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fexamples%2Fhash_glob.rs?ref=15942fcc72f442911a5cbb9b18070a16241a2709",
            "patch": "@@ -1,120 +0,0 @@\n-#![feature(trivial_bounds)]\n-#![allow(clippy::needless_return)] // clippy false positive\n-\n-use std::{\n-    collections::BTreeMap,\n-    env::current_dir,\n-    io::Read,\n-    time::{Duration, Instant},\n-};\n-\n-use anyhow::Result;\n-use sha2::{Digest, Sha256};\n-use turbo_rcstr::RcStr;\n-use turbo_tasks::{ReadConsistency, TurboTasks, UpdateInfo, Vc, util::FormatDuration};\n-use turbo_tasks_fs::{\n-    DirectoryEntry, DiskFileSystem, FileContent, FileSystem, FileSystemPath, ReadGlobResult,\n-    glob::Glob, register,\n-};\n-use turbo_tasks_memory::MemoryBackend;\n-\n-#[tokio::main]\n-async fn main() -> Result<()> {\n-    register();\n-    include!(concat!(env!(\"OUT_DIR\"), \"/register_example_hash_glob.rs\"));\n-\n-    let tt = TurboTasks::new(MemoryBackend::default());\n-    let start = Instant::now();\n-\n-    let task = tt.spawn_root_task(|| {\n-        Box::pin(async {\n-            let root = current_dir().unwrap().to_str().unwrap().into();\n-            let disk_fs = DiskFileSystem::new(\"project\".into(), root, vec![]);\n-            disk_fs.await?.start_watching(None).await?;\n-\n-            // Smart Pointer cast\n-            let fs: Vc<Box<dyn FileSystem>> = Vc::upcast(disk_fs);\n-            let input = fs.root().join(\"crates\".into());\n-            let glob = Glob::new(\"**/*.rs\".into());\n-            let glob_result = input.read_glob(glob, true);\n-            let dir_hash = hash_glob_result(glob_result);\n-            print_hash(dir_hash).await?;\n-            Ok::<Vc<()>, _>(Default::default())\n-        })\n-    });\n-    tt.wait_task_completion(task, ReadConsistency::Strong)\n-        .await\n-        .unwrap();\n-    println!(\"done in {}\", FormatDuration(start.elapsed()));\n-\n-    loop {\n-        let UpdateInfo {\n-            duration, tasks, ..\n-        } = tt\n-            .get_or_wait_aggregated_update_info(Duration::from_millis(100))\n-            .await;\n-        println!(\"updated {} tasks in {}\", tasks, FormatDuration(duration));\n-    }\n-}\n-\n-#[turbo_tasks::function]\n-pub fn empty_string() -> Vc<RcStr> {\n-    Vc::cell(Default::default())\n-}\n-\n-#[turbo_tasks::function]\n-async fn print_hash(dir_hash: Vc<RcStr>) -> Result<Vc<()>> {\n-    println!(\"DIR HASH: {}\", dir_hash.await?.as_str());\n-    Ok(Default::default())\n-}\n-\n-#[turbo_tasks::function]\n-async fn hash_glob_result(result: Vc<ReadGlobResult>) -> Result<Vc<RcStr>> {\n-    let result = result.await?;\n-    let mut hashes = BTreeMap::new();\n-    for (name, entry) in result.results.iter() {\n-        if let DirectoryEntry::File(path) = entry {\n-            hashes.insert(name, hash_file(**path).owned().await?);\n-        }\n-    }\n-    for (name, result) in result.inner.iter() {\n-        let hash = hash_glob_result(**result).owned().await?;\n-        if !hash.is_empty() {\n-            hashes.insert(name, hash);\n-        }\n-    }\n-    if hashes.is_empty() {\n-        return Ok(empty_string());\n-    }\n-    let hash = hash_content(\n-        &mut hashes\n-            .into_values()\n-            .collect::<Vec<RcStr>>()\n-            .join(\",\")\n-            .as_bytes(),\n-    );\n-    Ok(hash)\n-}\n-\n-#[turbo_tasks::function]\n-async fn hash_file(file_path: Vc<FileSystemPath>) -> Result<Vc<RcStr>> {\n-    let content = file_path.read().await?;\n-    Ok(match &*content {\n-        FileContent::Content(file) => hash_content(&mut file.read()),\n-        FileContent::NotFound => {\n-            // report error\n-            Vc::cell(Default::default())\n-        }\n-    })\n-}\n-\n-fn hash_content<R: Read>(content: &mut R) -> Vc<RcStr> {\n-    let mut hasher = Sha256::new();\n-    let mut buf = [0; 1024];\n-    while let Ok(size) = content.read(&mut buf) {\n-        hasher.update(&buf[0..size]);\n-    }\n-    let result = format!(\"{:x}\", hasher.finalize());\n-\n-    Vc::cell(result.into())\n-}"
        },
        {
            "sha": "c9d6d2d56d37a69791212d06b573d1f63e2b363a",
            "filename": "turbopack/crates/turbo-tasks-fs/src/lib.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 11,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/5d73b2f3612a7d4e762d036d39a6d5feedb77681/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5d73b2f3612a7d4e762d036d39a6d5feedb77681/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs?ref=5d73b2f3612a7d4e762d036d39a6d5feedb77681",
            "patch": "@@ -46,8 +46,7 @@ use invalidator_map::InvalidatorMap;\n use jsonc_parser::{ParseOptions, parse_to_serde_value};\n use mime::Mime;\n use rayon::iter::{IntoParallelIterator, ParallelIterator};\n-pub use read_glob::ReadGlobResult;\n-use read_glob::{read_glob, track_glob};\n+use read_glob::track_glob;\n use rustc_hash::FxHashSet;\n use serde::{Deserialize, Serialize};\n use serde_json::Value;\n@@ -1263,15 +1262,6 @@ impl FileSystemPath {\n         Ok(FileSystemPathOption::none())\n     }\n \n-    #[turbo_tasks::function]\n-    pub fn read_glob(\n-        self: Vc<Self>,\n-        glob: Vc<Glob>,\n-        include_dot_files: bool,\n-    ) -> Vc<ReadGlobResult> {\n-        read_glob(self, glob, include_dot_files)\n-    }\n-\n     // Tracks all files and directories matching the glob\n     // Follows symlinks as though they were part of the original hierarchy.\n     #[turbo_tasks::function]"
        },
        {
            "sha": "e7e6ddb3f125b6f4ca9b1b467a4d9b83774e6fbc",
            "filename": "turbopack/crates/turbo-tasks-fs/src/read_glob.rs",
            "status": "modified",
            "additions": 49,
            "deletions": 230,
            "changes": 279,
            "blob_url": "https://github.com/vercel/next.js/blob/5d73b2f3612a7d4e762d036d39a6d5feedb77681/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fread_glob.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5d73b2f3612a7d4e762d036d39a6d5feedb77681/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fread_glob.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fread_glob.rs?ref=5d73b2f3612a7d4e762d036d39a6d5feedb77681",
            "patch": "@@ -1,85 +1,10 @@\n use anyhow::{Result, bail};\n use futures::try_join;\n-use rustc_hash::FxHashMap;\n use turbo_rcstr::RcStr;\n-use turbo_tasks::{Completion, ResolvedVc, TryJoinIterExt, Vc};\n+use turbo_tasks::{Completion, TryJoinIterExt, Vc};\n \n use crate::{DirectoryContent, DirectoryEntry, FileSystem, FileSystemPath, glob::Glob};\n \n-#[turbo_tasks::value]\n-#[derive(Default, Debug)]\n-pub struct ReadGlobResult {\n-    pub results: FxHashMap<String, DirectoryEntry>,\n-    pub inner: FxHashMap<String, ResolvedVc<ReadGlobResult>>,\n-}\n-\n-/// Reads matches of a glob pattern.\n-///\n-/// DETERMINISM: Result is in random order. Either sort result or do not depend\n-/// on the order.\n-#[turbo_tasks::function(fs)]\n-pub async fn read_glob(\n-    directory: Vc<FileSystemPath>,\n-    glob: Vc<Glob>,\n-    include_dot_files: bool,\n-) -> Result<Vc<ReadGlobResult>> {\n-    Ok(*read_glob_internal(\"\", directory, glob, include_dot_files).await?)\n-}\n-\n-#[turbo_tasks::function(fs)]\n-async fn read_glob_inner(\n-    prefix: RcStr,\n-    directory: Vc<FileSystemPath>,\n-    glob: Vc<Glob>,\n-    include_dot_files: bool,\n-) -> Result<Vc<ReadGlobResult>> {\n-    Ok(*read_glob_internal(&prefix, directory, glob, include_dot_files).await?)\n-}\n-\n-// The `prefix` represents the relative directory path where symlinks are not resolve.\n-async fn read_glob_internal(\n-    prefix: &str,\n-    directory: Vc<FileSystemPath>,\n-    glob: Vc<Glob>,\n-    include_dot_files: bool,\n-) -> Result<ResolvedVc<ReadGlobResult>> {\n-    let dir = directory.read_dir().await?;\n-    let mut result = ReadGlobResult::default();\n-    let glob_value = glob.await?;\n-    match &*dir {\n-        DirectoryContent::Entries(entries) => {\n-            for (segment, entry) in entries.iter() {\n-                if !include_dot_files && segment.starts_with('.') {\n-                    continue;\n-                }\n-                // This is redundant with logic inside of `read_dir` but here we track it separately\n-                // so we don't follow symlinks.\n-                let entry_path: RcStr = if prefix.is_empty() {\n-                    segment.clone()\n-                } else {\n-                    format!(\"{prefix}/{segment}\").into()\n-                };\n-                let entry = resolve_symlink_safely(entry).await?;\n-                if glob_value.execute(&entry_path) {\n-                    result.results.insert(entry_path.to_string(), entry);\n-                }\n-                if let DirectoryEntry::Directory(path) = entry {\n-                    if glob_value.match_in_directory(&entry_path) {\n-                        result.inner.insert(\n-                            entry_path.to_string(),\n-                            read_glob_inner(entry_path, *path, glob, include_dot_files)\n-                                .to_resolved()\n-                                .await?,\n-                        );\n-                    }\n-                }\n-            }\n-        }\n-        DirectoryContent::NotFound => {}\n-    }\n-    Ok(ReadGlobResult::resolved_cell(result))\n-}\n-\n // Resolve a symlink checking for recursion.\n async fn resolve_symlink_safely(entry: &DirectoryEntry) -> Result<DirectoryEntry> {\n     let resolved_entry = entry.resolve_symlink().await?;\n@@ -204,177 +129,61 @@ pub mod tests {\n     use turbo_tasks::{Completion, ReadRef, ResolvedVc, Vc, apply_effects};\n     use turbo_tasks_backend::{BackendOptions, TurboTasksBackend, noop_backing_storage};\n \n-    use crate::{\n-        DirectoryEntry, DiskFileSystem, FileContent, FileSystem, FileSystemPath, glob::Glob,\n-    };\n-\n-    #[tokio::test]\n-    async fn read_glob_basic() {\n-        crate::register();\n-        let scratch = tempfile::tempdir().unwrap();\n-        {\n-            // Create a simple directory with 2 files, a subdirectory and a dotfile\n-            let path = scratch.path();\n-            File::create_new(path.join(\"foo\"))\n-                .unwrap()\n-                .write_all(b\"foo\")\n-                .unwrap();\n-            create_dir(path.join(\"sub\")).unwrap();\n-            File::create_new(path.join(\"sub/bar\"))\n-                .unwrap()\n-                .write_all(b\"bar\")\n-                .unwrap();\n-            // Add a dotfile\n-            File::create_new(path.join(\"sub/.gitignore\"))\n-                .unwrap()\n-                .write_all(b\"ignore\")\n-                .unwrap();\n-        }\n-        let tt = turbo_tasks::TurboTasks::new(TurboTasksBackend::new(\n-            BackendOptions::default(),\n-            noop_backing_storage(),\n-        ));\n-        let path: RcStr = scratch.path().to_str().unwrap().into();\n-        tt.run_once(async {\n-            let fs = Vc::upcast::<Box<dyn FileSystem>>(DiskFileSystem::new(\n-                \"temp\".into(),\n-                path,\n-                Vec::new(),\n-            ));\n-            let read_dir = fs\n-                .root()\n-                .read_glob(Glob::new(\"**\".into()), false)\n-                .await\n-                .unwrap();\n-            assert_eq!(read_dir.results.len(), 2);\n-            assert_eq!(\n-                read_dir.results.get(\"foo\"),\n-                Some(&DirectoryEntry::File(\n-                    fs.root().join(\"foo\".into()).to_resolved().await?\n-                ))\n-            );\n-            assert_eq!(\n-                read_dir.results.get(\"sub\"),\n-                Some(&DirectoryEntry::Directory(\n-                    fs.root().join(\"sub\".into()).to_resolved().await?\n-                ))\n-            );\n-            assert_eq!(read_dir.inner.len(), 1);\n-            let inner = &*read_dir.inner.get(\"sub\").unwrap().await?;\n-            assert_eq!(inner.results.len(), 1);\n-            assert_eq!(\n-                inner.results.get(\"sub/bar\"),\n-                Some(&DirectoryEntry::File(\n-                    fs.root().join(\"sub/bar\".into()).to_resolved().await?\n-                ))\n-            );\n-            assert_eq!(inner.inner.len(), 0);\n-\n-            // Now with a more specific pattern\n-            let read_dir = fs\n-                .root()\n-                .read_glob(Glob::new(\"**/bar\".into()), false)\n-                .await\n-                .unwrap();\n-            assert_eq!(read_dir.results.len(), 0);\n-            assert_eq!(read_dir.inner.len(), 1);\n-            let inner = &*read_dir.inner.get(\"sub\").unwrap().await?;\n-            assert_eq!(inner.results.len(), 1);\n-            assert_eq!(\n-                inner.results.get(\"sub/bar\"),\n-                Some(&DirectoryEntry::File(\n-                    fs.root().join(\"sub/bar\".into()).to_resolved().await?\n-                ))\n-            );\n-            assert_eq!(inner.inner.len(), 0);\n-\n-            anyhow::Ok(())\n-        })\n-        .await\n-        .unwrap();\n-    }\n-\n-    #[cfg(unix)]\n-    #[tokio::test]\n-    async fn read_glob_symlinks() {\n-        crate::register();\n-        let scratch = tempfile::tempdir().unwrap();\n-        {\n-            use std::os::unix::fs::symlink;\n-\n-            // Create a simple directory with 1 file and a symlink pointing at at a file in a\n-            // subdirectory\n-            let path = scratch.path();\n-            create_dir(path.join(\"sub\")).unwrap();\n-            let foo = path.join(\"sub/foo.js\");\n-            File::create_new(&foo).unwrap().write_all(b\"foo\").unwrap();\n-            symlink(&foo, path.join(\"link.js\")).unwrap();\n-        }\n-        let tt = turbo_tasks::TurboTasks::new(TurboTasksBackend::new(\n-            BackendOptions::default(),\n-            noop_backing_storage(),\n-        ));\n-        let path: RcStr = scratch.path().to_str().unwrap().into();\n-        tt.run_once(async {\n-            let fs = Vc::upcast::<Box<dyn FileSystem>>(DiskFileSystem::new(\n-                \"temp\".into(),\n-                path,\n-                Vec::new(),\n-            ));\n-            let read_dir = fs\n-                .root()\n-                .read_glob(Glob::new(\"*.js\".into()), false)\n-                .await\n-                .unwrap();\n-            assert_eq!(read_dir.results.len(), 1);\n-            assert_eq!(\n-                read_dir.results.get(\"link.js\"),\n-                Some(&DirectoryEntry::File(\n-                    fs.root().join(\"sub/foo.js\".into()).to_resolved().await?\n-                ))\n-            );\n-            assert_eq!(read_dir.inner.len(), 0);\n-\n-            anyhow::Ok(())\n-        })\n-        .await\n-        .unwrap();\n-    }\n+    use crate::{DiskFileSystem, FileContent, FileSystem, FileSystemPath, glob::Glob};\n \n     #[turbo_tasks::function(operation)]\n     pub async fn delete(path: ResolvedVc<FileSystemPath>) -> anyhow::Result<()> {\n         path.write(FileContent::NotFound.cell()).await?;\n         Ok(())\n     }\n+    #[turbo_tasks::function(operation)]\n+    pub async fn write(path: ResolvedVc<FileSystemPath>, contents: RcStr) -> anyhow::Result<()> {\n+        path.write(\n+            FileContent::Content(crate::File::from_bytes(contents.to_string().into_bytes())).cell(),\n+        )\n+        .await?;\n+        Ok(())\n+    }\n \n     #[turbo_tasks::function(operation)]\n     pub async fn track_star_star_glob(path: ResolvedVc<FileSystemPath>) -> Vc<Completion> {\n         path.track_glob(Glob::new(\"**\".into()), false)\n     }\n \n+    #[cfg(unix)]\n     #[tokio::test]\n     async fn track_glob_invalidations() {\n+        use std::os::unix::fs::symlink;\n         crate::register();\n         let scratch = tempfile::tempdir().unwrap();\n \n         // Create a simple directory with 2 files, a subdirectory and a dotfile\n         let path = scratch.path();\n-        File::create_new(path.join(\"foo\"))\n+        let dir = path.join(\"dir\");\n+        create_dir(&dir).unwrap();\n+        File::create_new(dir.join(\"foo\"))\n             .unwrap()\n             .write_all(b\"foo\")\n             .unwrap();\n-        create_dir(path.join(\"sub\")).unwrap();\n-        File::create_new(path.join(\"sub/bar\"))\n+        create_dir(dir.join(\"sub\")).unwrap();\n+        File::create_new(dir.join(\"sub/bar\"))\n             .unwrap()\n             .write_all(b\"bar\")\n             .unwrap();\n         // Add a dotfile\n-        create_dir(path.join(\"sub/.vim\")).unwrap();\n-        let gitignore = path.join(\"sub/.vim/.gitignore\");\n+        create_dir(dir.join(\"sub/.vim\")).unwrap();\n+        let gitignore = dir.join(\"sub/.vim/.gitignore\");\n         File::create_new(&gitignore)\n             .unwrap()\n             .write_all(b\"ignore\")\n             .unwrap();\n+        // put a link in the dir that points at a file in the root.\n+        let link_target = path.join(\"link_target.js\");\n+        File::create_new(&link_target)\n+            .unwrap()\n+            .write_all(b\"link_target\")\n+            .unwrap();\n+        symlink(&link_target, dir.join(\"link.js\")).unwrap();\n \n         let tt = turbo_tasks::TurboTasks::new(TurboTasksBackend::new(\n             BackendOptions::default(),\n@@ -387,35 +196,45 @@ pub mod tests {\n                 path,\n                 Vec::new(),\n             ));\n-            let read_dir = track_star_star_glob(fs.root().to_resolved().await?)\n-                .read_strongly_consistent()\n-                .await?;\n+            let dir = fs.root().join(\"dir\".into()).to_resolved().await?;\n+            let read_dir = track_star_star_glob(dir).read_strongly_consistent().await?;\n \n             // Delete a file that we shouldn't be tracking\n             let delete_result = delete(\n                 fs.root()\n-                    .join(\"sub/.vim/.gitignore\".into())\n+                    .join(\"dir/sub/.vim/.gitignore\".into())\n                     .to_resolved()\n                     .await?,\n             );\n             delete_result.read_strongly_consistent().await?;\n             apply_effects(delete_result).await?;\n \n-            let read_dir2 = track_star_star_glob(fs.root().to_resolved().await?)\n-                .read_strongly_consistent()\n-                .await?;\n+            let read_dir2 = track_star_star_glob(dir).read_strongly_consistent().await?;\n             assert!(ReadRef::ptr_eq(&read_dir, &read_dir2));\n \n             // Delete a file that we should be tracking\n-            let delete_result = delete(fs.root().join(\"foo\".into()).to_resolved().await?);\n+            let delete_result = delete(fs.root().join(\"dir/foo\".into()).to_resolved().await?);\n             delete_result.read_strongly_consistent().await?;\n             apply_effects(delete_result).await?;\n \n-            let read_dir2 = track_star_star_glob(fs.root().to_resolved().await?)\n-                .read_strongly_consistent()\n-                .await?;\n+            let read_dir2 = track_star_star_glob(dir).read_strongly_consistent().await?;\n \n             assert!(!ReadRef::ptr_eq(&read_dir, &read_dir2));\n+\n+            // Modify a symlink target file\n+            let write_result = write(\n+                fs.root()\n+                    .join(\"link_target.js\".into())\n+                    .to_resolved()\n+                    .await?,\n+                \"new_contents\".into(),\n+            );\n+            write_result.read_strongly_consistent().await?;\n+            apply_effects(write_result).await?;\n+            let read_dir3 = track_star_star_glob(dir).read_strongly_consistent().await?;\n+\n+            assert!(!ReadRef::ptr_eq(&read_dir3, &read_dir2));\n+\n             anyhow::Ok(())\n         })\n         .await\n@@ -424,7 +243,7 @@ pub mod tests {\n \n     #[cfg(unix)]\n     #[tokio::test]\n-    async fn read_glob_symlinks_loop() {\n+    async fn track_glob_symlinks_loop() {\n         crate::register();\n         let scratch = tempfile::tempdir().unwrap();\n         {\n@@ -453,7 +272,7 @@ pub mod tests {\n             ));\n             let err = fs\n                 .root()\n-                .read_glob(Glob::new(\"**\".into()), false)\n+                .track_glob(Glob::new(\"**\".into()), false)\n                 .await\n                 .expect_err(\"Should have detected an infinite loop\");\n "
        }
    ],
    "stats": {
        "total": 411,
        "additions": 50,
        "deletions": 361
    }
}