{
    "author": "huozhi",
    "message": "[turbopack] move edge entry wrapper to build template (#86699)\n\nMove the edge-wrapper virtual module to templates",
    "sha": "32dd05612a1d8b36bf932c781345c636f52ef8c7",
    "files": [
        {
            "sha": "e7d8b17703c733bd4bb4ad63a1c539d9543907cc",
            "filename": "crates/next-core/src/next_edge/entry.rs",
            "status": "modified",
            "additions": 19,
            "deletions": 42,
            "changes": 61,
            "blob_url": "https://github.com/vercel/next.js/blob/32dd05612a1d8b36bf932c781345c636f52ef8c7/crates%2Fnext-core%2Fsrc%2Fnext_edge%2Fentry.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/32dd05612a1d8b36bf932c781345c636f52ef8c7/crates%2Fnext-core%2Fsrc%2Fnext_edge%2Fentry.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_edge%2Fentry.rs?ref=32dd05612a1d8b36bf932c781345c636f52ef8c7",
            "patch": "@@ -1,62 +1,39 @@\n use anyhow::Result;\n-use indoc::formatdoc;\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{ResolvedVc, Vc, fxindexmap};\n-use turbo_tasks_fs::{File, FileContent, FileSystemPath};\n-use turbopack_core::{\n-    asset::AssetContent, context::AssetContext, module::Module, reference_type::ReferenceType,\n-    virtual_source::VirtualSource,\n-};\n-use turbopack_ecmascript::utils::StringifyJs;\n+use turbo_tasks_fs::FileSystemPath;\n+use turbopack_core::{context::AssetContext, module::Module, reference_type::ReferenceType};\n+\n+use crate::util::load_next_js_template_no_imports;\n \n #[turbo_tasks::function]\n-pub fn wrap_edge_entry(\n+pub async fn wrap_edge_entry(\n     asset_context: Vc<Box<dyn AssetContext>>,\n     project_root: FileSystemPath,\n     entry: ResolvedVc<Box<dyn Module>>,\n     pathname: RcStr,\n ) -> Result<Vc<Box<dyn Module>>> {\n-    // The wrapped module could be an async module, we handle that with the proxy\n-    // here. The comma expression makes sure we don't call the function with the\n-    // module as the \"this\" arg.\n-    // Turn exports into functions that are also a thenable. This way you can await the whole object\n-    // or  exports (e.g. for Components) or call them directly as though they are async functions\n-    // (e.g. edge functions/middleware, this is what the Edge Runtime does).\n-    // Catch promise to prevent UnhandledPromiseRejectionWarning, this will be propagated through\n-    // the awaited export(s) anyway.\n-    let source = formatdoc!(\n-        r#\"\n-            self._ENTRIES ||= {{}};\n-            const modProm = import('MODULE');\n-            modProm.catch(() => {{}});\n-            self._ENTRIES[{}] = new Proxy(modProm, {{\n-                get(modProm, name) {{\n-                    if (name === \"then\") {{\n-                        return (res, rej) => modProm.then(res, rej);\n-                    }}\n-                    let result = (...args) => modProm.then((mod) => (0, mod[name])(...args));\n-                    result.then = (res, rej) => modProm.then((mod) => mod[name]).then(res, rej);\n-                    return result;\n-                }},\n-            }});\n-        \"#,\n-        StringifyJs(&format_args!(\"middleware_{pathname}\"))\n-    );\n-    let file = File::from(source);\n-\n-    // TODO(alexkirsz) Figure out how to name this virtual asset.\n-    let virtual_source = VirtualSource::new(\n-        project_root.join(\"edge-wrapper.js\")?,\n-        AssetContent::file(FileContent::Content(file).cell()),\n-    );\n+    // The actual wrapper lives in the Next.js templates directory as `edge-wrapper.js`.\n+    // We use the template expansion helper so this code is kept in sync with other\n+    // Next.js runtime templates. This particular template does not have any imports\n+    // of its own, so we use the variant that allows templates without relative\n+    // imports to be rewritten.\n+    let template_source = load_next_js_template_no_imports(\n+        \"edge-wrapper.js\",\n+        project_root,\n+        &[(\"VAR_ENTRY_NAME\", &format!(\"middleware_{pathname}\"))],\n+        &[],\n+        &[],\n+    )\n+    .await?;\n \n     let inner_assets = fxindexmap! {\n         rcstr!(\"MODULE\") => entry\n     };\n \n     Ok(asset_context\n         .process(\n-            Vc::upcast(virtual_source),\n+            template_source,\n             ReferenceType::Internal(ResolvedVc::cell(inner_assets)),\n         )\n         .module())"
        },
        {
            "sha": "126930c931acb6a4001c2a7df5afb0ca04f216e2",
            "filename": "crates/next-core/src/util.rs",
            "status": "modified",
            "additions": 36,
            "deletions": 1,
            "changes": 37,
            "blob_url": "https://github.com/vercel/next.js/blob/32dd05612a1d8b36bf932c781345c636f52ef8c7/crates%2Fnext-core%2Fsrc%2Futil.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/32dd05612a1d8b36bf932c781345c636f52ef8c7/crates%2Fnext-core%2Fsrc%2Futil.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Futil.rs?ref=32dd05612a1d8b36bf932c781345c636f52ef8c7",
            "patch": "@@ -1,7 +1,7 @@\n use std::{fmt::Display, str::FromStr};\n \n use anyhow::{Result, anyhow, bail};\n-use next_taskless::expand_next_js_template;\n+use next_taskless::{expand_next_js_template, expand_next_js_template_no_imports};\n use serde::{Deserialize, Serialize, de::DeserializeOwned};\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{FxIndexMap, NonLocalValue, TaskInput, Vc, trace::TraceRawVcs};\n@@ -268,6 +268,41 @@ pub async fn load_next_js_template(\n     Ok(Vc::upcast(source))\n }\n \n+/// Loads a next.js template but does **not** require that any relative imports are present\n+/// or rewritten. This is intended for small internal templates that do not have their own\n+/// imports but still use template variables/injections.\n+pub async fn load_next_js_template_no_imports(\n+    template_path: &str,\n+    project_path: FileSystemPath,\n+    replacements: &[(&str, &str)],\n+    injections: &[(&str, &str)],\n+    imports: &[(&str, Option<&str>)],\n+) -> Result<Vc<Box<dyn Source>>> {\n+    let template_path = virtual_next_js_template_path(project_path.clone(), template_path).await?;\n+\n+    let content = file_content_rope(template_path.read()).await?;\n+    let content = content.to_str()?;\n+\n+    let package_root = get_next_package(project_path).await?;\n+\n+    let content = expand_next_js_template_no_imports(\n+        &content,\n+        &template_path.path,\n+        &package_root.path,\n+        replacements.iter().copied(),\n+        injections.iter().copied(),\n+        imports.iter().copied(),\n+    )?;\n+\n+    let file = File::from(content);\n+    let source = VirtualSource::new(\n+        template_path,\n+        AssetContent::file(FileContent::Content(file).cell()),\n+    );\n+\n+    Ok(Vc::upcast(source))\n+}\n+\n #[turbo_tasks::function]\n pub async fn file_content_rope(content: Vc<FileContent>) -> Result<Vc<Rope>> {\n     let content = &*content.await?;"
        },
        {
            "sha": "58f7f1745912afa66b21c729d19cb9fb18115e81",
            "filename": "crates/next-taskless/src/lib.rs",
            "status": "modified",
            "additions": 47,
            "deletions": 4,
            "changes": 51,
            "blob_url": "https://github.com/vercel/next.js/blob/32dd05612a1d8b36bf932c781345c636f52ef8c7/crates%2Fnext-taskless%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/32dd05612a1d8b36bf932c781345c636f52ef8c7/crates%2Fnext-taskless%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-taskless%2Fsrc%2Flib.rs?ref=32dd05612a1d8b36bf932c781345c636f52ef8c7",
            "patch": "@@ -25,6 +25,48 @@ pub fn expand_next_js_template<'a>(\n     replacements: impl IntoIterator<Item = (&'a str, &'a str)>,\n     injections: impl IntoIterator<Item = (&'a str, &'a str)>,\n     imports: impl IntoIterator<Item = (&'a str, Option<&'a str>)>,\n+) -> Result<String> {\n+    expand_next_js_template_inner(\n+        content,\n+        template_path,\n+        next_package_dir_path,\n+        replacements,\n+        injections,\n+        imports,\n+        true,\n+    )\n+}\n+\n+/// Same as [`expand_next_js_template`], but does not enforce that at least one relative\n+/// import is present and rewritten. This is useful for very small templates that only\n+/// use template variables/injections and have no imports of their own.\n+pub fn expand_next_js_template_no_imports<'a>(\n+    content: &str,\n+    template_path: &str,\n+    next_package_dir_path: &str,\n+    replacements: impl IntoIterator<Item = (&'a str, &'a str)>,\n+    injections: impl IntoIterator<Item = (&'a str, &'a str)>,\n+    imports: impl IntoIterator<Item = (&'a str, Option<&'a str>)>,\n+) -> Result<String> {\n+    expand_next_js_template_inner(\n+        content,\n+        template_path,\n+        next_package_dir_path,\n+        replacements,\n+        injections,\n+        imports,\n+        false,\n+    )\n+}\n+\n+fn expand_next_js_template_inner<'a>(\n+    content: &str,\n+    template_path: &str,\n+    next_package_dir_path: &str,\n+    replacements: impl IntoIterator<Item = (&'a str, &'a str)>,\n+    injections: impl IntoIterator<Item = (&'a str, &'a str)>,\n+    imports: impl IntoIterator<Item = (&'a str, Option<&'a str>)>,\n+    require_import_replacement: bool,\n ) -> Result<String> {\n     let template_parent_path = normalize_path(get_parent_path(template_path))\n         .context(\"failed to normalize template path\")?;\n@@ -92,10 +134,11 @@ pub fn expand_next_js_template<'a>(\n     })\n     .context(\"replacing imports failed\")?;\n \n-    // Verify that at least one import was replaced. It's the case today where every template file\n-    // has at least one import to update, so this ensures that we don't accidentally remove the\n-    // import replacement code or use the wrong template file.\n-    if count == 0 {\n+    // Verify that at least one import was replaced when required. It's the case today where every\n+    // template file (except a few small internal helpers) has at least one import to update, so\n+    // this ensures that we don't accidentally remove the import replacement code or use the wrong\n+    // template file.\n+    if require_import_replacement && count == 0 {\n         bail!(\"Invariant: Expected to replace at least one import\")\n     }\n "
        },
        {
            "sha": "3b2987af8f07e587a4dd83c9bf4b6d18c3ea3ede",
            "filename": "packages/next/src/build/templates/edge-wrapper.js",
            "status": "added",
            "additions": 23,
            "deletions": 0,
            "changes": 23,
            "blob_url": "https://github.com/vercel/next.js/blob/32dd05612a1d8b36bf932c781345c636f52ef8c7/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fedge-wrapper.js",
            "raw_url": "https://github.com/vercel/next.js/raw/32dd05612a1d8b36bf932c781345c636f52ef8c7/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fedge-wrapper.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fedge-wrapper.js?ref=32dd05612a1d8b36bf932c781345c636f52ef8c7",
            "patch": "@@ -0,0 +1,23 @@\n+// The wrapped module could be an async module, we handle that with the proxy\n+// here. The comma expression makes sure we don't call the function with the\n+// module as the \"this\" arg.\n+// Turn exports into functions that are also a thenable. This way you can await the whole object\n+// or  exports (e.g. for Components) or call them directly as though they are async functions\n+// (e.g. edge functions/middleware, this is what the Edge Runtime does).\n+// Catch promise to prevent UnhandledPromiseRejectionWarning, this will be propagated through\n+// the awaited export(s) anyway.\n+self._ENTRIES ||= {}\n+const modProm = import('MODULE')\n+modProm.catch(() => {})\n+self._ENTRIES['VAR_ENTRY_NAME'] = new Proxy(modProm, {\n+  get(innerModProm, name) {\n+    if (name === 'then') {\n+      return (res, rej) => innerModProm.then(res, rej)\n+    }\n+    let result = (...args) =>\n+      innerModProm.then((mod) => (0, mod[name])(...args))\n+    result.then = (res, rej) =>\n+      innerModProm.then((mod) => mod[name]).then(res, rej)\n+    return result\n+  },\n+})"
        }
    ],
    "stats": {
        "total": 172,
        "additions": 125,
        "deletions": 47
    }
}