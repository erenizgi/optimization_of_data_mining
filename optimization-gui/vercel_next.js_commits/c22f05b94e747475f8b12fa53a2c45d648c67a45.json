{
    "author": "icyJoseph",
    "message": "docs: cache life rework (#85224)\n\nCo-authored-by: vercel[bot] <35613825+vercel[bot]@users.noreply.github.com>",
    "sha": "c22f05b94e747475f8b12fa53a2c45d648c67a45",
    "files": [
        {
            "sha": "8523e456825eee97ed98bb716fb080890fdbf0ed",
            "filename": "docs/01-app/03-api-reference/04-functions/cacheLife.mdx",
            "status": "modified",
            "additions": 249,
            "deletions": 79,
            "changes": 328,
            "blob_url": "https://github.com/vercel/next.js/blob/c22f05b94e747475f8b12fa53a2c45d648c67a45/docs%2F01-app%2F03-api-reference%2F04-functions%2FcacheLife.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/c22f05b94e747475f8b12fa53a2c45d648c67a45/docs%2F01-app%2F03-api-reference%2F04-functions%2FcacheLife.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-api-reference%2F04-functions%2FcacheLife.mdx?ref=c22f05b94e747475f8b12fa53a2c45d648c67a45",
            "patch": "@@ -15,7 +15,9 @@ The `cacheLife` function is used to set the cache lifetime of a function or comp\n \n ## Usage\n \n-To use `cacheLife`, enable the [`cacheComponents` flag](/docs/app/api-reference/config/next-config-js/cacheComponents) in your `next.config.js` file:\n+### Basic setup\n+\n+To use `cacheLife`, first enable the [`cacheComponents` flag](/docs/app/api-reference/config/next-config-js/cacheComponents) in your `next.config.js` file:\n \n ```ts filename=\"next.config.ts\" switcher\n import type { NextConfig } from 'next'\n@@ -35,79 +37,105 @@ const nextConfig = {\n export default nextConfig\n ```\n \n-Then, import and invoke the `cacheLife` function within the scope of the function or component:\n+### Using preset profiles\n \n-```tsx filename=\"app/page.tsx\" highlight={5} switcher\n-'use cache'\n-import { cacheLife } from 'next/cache'\n+Next.js provides preset cache profiles that cover common caching needs. Each profile balances three factors:\n \n-export default async function Page() {\n-  cacheLife('hours')\n-  return <div>Page</div>\n-}\n-```\n+- How long users see cached content without checking for updates (client-side)\n+- How often fresh content is generated on the server\n+- When old content expires completely\n+\n+Choose a profile based on how frequently your content changes:\n \n-```jsx filename=\"app/page.js\" highlight={5} switcher\n+- **`seconds`** - Real-time data (stock prices, live scores)\n+- **`minutes`** - Frequently updated (social feeds, news)\n+- **`hours`** - Multiple daily updates (product inventory, weather)\n+- **`days`** - Daily updates (blog posts, articles)\n+- **`weeks`** - Weekly updates (podcasts, newsletters)\n+- **`max`** - Rarely changes (legal pages, archived content)\n+\n+Import `cacheLife` and pass a profile name:\n+\n+```tsx filename=\"app/blog/page.tsx\" highlight={1,5}\n 'use cache'\n import { cacheLife } from 'next/cache'\n \n-export default async function Page() {\n-  cacheLife('hours')\n-  return <div>Page</div>\n+export default async function BlogPage() {\n+  cacheLife('days') // Blog content updated daily\n+\n+  const posts = await getBlogPosts()\n+  return <div>{/* render posts */}</div>\n }\n ```\n \n+The profile name tells Next.js how to cache the entire function's output. If you need more control over timing values, see the [Reference](#reference) section below.\n+\n+> **Good to know**: The `use cache` directive can be placed at the file level or at the top of a function or component, and `cacheLife` must be called within its scope.\n+\n ## Reference\n \n-### Default cache profiles\n+### Cache profile properties\n \n-Next.js provides a set of named cache profiles modeled on various timescales. If you don't specify a cache profile in the `cacheLife` function alongside the `use cache` directive, Next.js will automatically apply the `default` cache profile.\n+Cache profiles control caching behavior through three timing properties:\n \n-However, we recommend always adding a cache profile when using the `use cache` directive to explicitly define caching behavior.\n+- **[`stale`](#stale)**: How long the client can use cached data without checking the server\n+- **[`revalidate`](#revalidate)**: After this time, the next request will trigger a background refresh\n+- **[`expire`](#expire)**: After this time with no requests, the next one waits for fresh content\n \n-| **Profile** | `stale`    | `revalidate` | `expire` | **Description**                                                          |\n-| ----------- | ---------- | ------------ | -------- | ------------------------------------------------------------------------ |\n-| `default`   | 5 minutes  | 15 minutes   | 1 year   | Default profile, suitable for content that doesn't need frequent updates |\n-| `seconds`   | 30 seconds | 1 second     | 1 minute | For rapidly changing content requiring near real-time updates            |\n-| `minutes`   | 5 minutes  | 1 minute     | 1 hour   | For content that updates frequently within an hour                       |\n-| `hours`     | 5 minutes  | 1 hour       | 1 day    | For content that updates daily but can be slightly stale                 |\n-| `days`      | 5 minutes  | 1 day        | 1 week   | For content that updates weekly but can be a day old                     |\n-| `weeks`     | 5 minutes  | 1 week       | 30 days  | For content that updates monthly but can be a week old                   |\n-| `max`       | 5 minutes  | 30 days      | 1 year   | For very stable content that rarely needs updating                       |\n+#### `stale`\n \n-The string values used to reference cache profiles don't carry inherent meaning; instead they serve as semantic labels. This allows you to better understand and manage your cached content within your codebase.\n+**Client-side:** How long the client can use cached data without checking the server.\n \n-> **Good to know:** Updating the [`staleTimes`](/docs/app/api-reference/config/next-config-js/staleTimes) and [`expireTime`](/docs/app/api-reference/config/next-config-js/expireTime) config options also updates the `stale` and `expire` properties of the `default` cache profile.\n+During this time, the client-side router displays cached content immediately without any network request. After this period expires, the router must check with the server on the next navigation or request. This provides instant page loads from the client cache, but data may be outdated.\n \n-### Custom cache profiles\n+```tsx\n+cacheLife({ stale: 300 }) // 5 minutes\n+```\n \n-You can configure custom cache profiles by adding them to the [`cacheLife`](/docs/app/api-reference/config/next-config-js/cacheLife) option in your `next.config.ts` file.\n+#### `revalidate`\n \n-Cache profiles are objects that contain the following properties:\n+How often the server regenerates cached content in the background.\n \n-| **Property** | **Value** | **Description**                                                                                                             | **Requirement**                             |\n-| ------------ | --------- | --------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------- |\n-| `stale`      | `number`  | Duration the client should cache a value without checking the server.                                                       | Optional                                    |\n-| `revalidate` | `number`  | Frequency at which the cache should refresh on the server; stale values may be served while revalidating.                   | Optional                                    |\n-| `expire`     | `number`  | Maximum duration for which a value can remain stale before switching to dynamic fetching; must be longer than `revalidate`. | Optional - Must be longer than `revalidate` |\n+- When a request arrives after this period, the server:\n+  1. Serves the cached version immediately (if available)\n+  2. Regenerates content in the background\n+  3. Updates the cache with fresh content\n+- Similar to [Incremental Static Regeneration (ISR)](/docs/app/guides/incremental-static-regeneration)\n \n-The \"stale\" property differs from the [`staleTimes`](/docs/app/api-reference/config/next-config-js/staleTimes) setting in that it specifically controls client-side router caching. While `staleTimes` is a global setting that affects all instances of both dynamic and static data, the `cacheLife` configuration allows you to define \"stale\" times on a per-function or per-route basis.\n+```tsx\n+cacheLife({ revalidate: 900 }) // 15 minutes\n+```\n \n-### `stale` time in the client router cache\n+#### `expire`\n \n-The \"stale\" property does not set the `Cache-control: max-age` header. Instead, it controls the client-side router cache. The server sends this value to the client via the `x-nextjs-stale-time` response header (in seconds), which the client router uses to determine how long to cache the route before needing to revalidate.\n+Maximum time before the server must regenerate cached content.\n \n-**The client enforces a minimum stale time of 30 seconds**: This ensures that prefetched data remains usable long enough for users to click on links after they've been prefetched. Without this minimum, very short stale times would cause prefetched data to expire before it could be used, making prefetching ineffective.\n+- After this period with no traffic, the server regenerates content synchronously on the next request\n+- When you set both `revalidate` and `expire`, `expire` must be longer than `revalidate`. Next.js validates this and raises an error for invalid configurations.\n \n-This minimum only applies to time-based expiration. When you call [`revalidateTag`](/docs/app/api-reference/functions/revalidateTag), [`revalidatePath`](/docs/app/api-reference/functions/revalidatePath), [`updateTag`](/docs/app/api-reference/functions/updateTag), or [`refresh`](/docs/app/api-reference/functions/refresh) from a Server Action, the entire client cache is immediately cleared, bypassing the stale time entirely.\n+```tsx\n+cacheLife({ expire: 3600 }) // 1 hour\n+```\n \n-## Examples\n+### Preset cache profiles\n \n-### Defining reusable cache profiles\n+If you don't specify a profile, Next.js uses the `default` profile. We recommend explicitly setting a profile to make caching behavior clear.\n \n-You can create a reusable cache profile by defining them in your `next.config.ts` file. Choose a name that suits your use case and set values for the `stale`, `revalidate`, and `expire` properties. You can create as many custom cache profiles as needed. Each profile can be referenced by its name as a string value passed to the `cacheLife` function.\n+| **Profile** | **Use Case**                           | `stale`    | `revalidate` | `expire` |\n+| ----------- | -------------------------------------- | ---------- | ------------ | -------- |\n+| `default`   | Standard content                       | 5 minutes  | 15 minutes   | 1 year   |\n+| `seconds`   | Real-time data                         | 30 seconds | 1 second     | 1 minute |\n+| `minutes`   | Frequently updated content             | 5 minutes  | 1 minute     | 1 hour   |\n+| `hours`     | Content updated multiple times per day | 5 minutes  | 1 hour       | 1 day    |\n+| `days`      | Content updated daily                  | 5 minutes  | 1 day        | 1 week   |\n+| `weeks`     | Content updated weekly                 | 5 minutes  | 1 week       | 30 days  |\n+| `max`       | Stable content that rarely changes     | 5 minutes  | 30 days      | 1 year   |\n \n-```ts filename=\"next.config.ts\" switcher\n+### Custom cache profiles\n+\n+Define reusable cache profiles in your `next.config.ts` file:\n+\n+```ts filename=\"next.config.ts\"\n import type { NextConfig } from 'next'\n \n const nextConfig: NextConfig = {\n@@ -121,7 +149,7 @@ const nextConfig: NextConfig = {\n   },\n }\n \n-module.exports = nextConfig\n+export default nextConfig\n ```\n \n ```js filename=\"next.config.js\" switcher\n@@ -157,7 +185,7 @@ While the default cache profiles provide a useful way to think about how fresh o\n \n You can override the default named cache profiles by creating a new configuration with the same name as the defaults.\n \n-The example below shows how to override the default “days” cache profile:\n+The example below shows how to override the default `\"days\"` cache profile:\n \n ```ts filename=\"next.config.ts\"\n const nextConfig = {\n@@ -171,79 +199,221 @@ const nextConfig = {\n   },\n }\n \n-module.exports = nextConfig\n+export default nextConfig\n ```\n \n-### Defining cache profiles inline\n+You can also override the preset profiles by using the same name:\n \n-For specific use cases, you can set a custom cache profile by passing an object to the `cacheLife` function:\n+```ts filename=\"next.config.ts\"\n+const nextConfig = {\n+  cacheComponents: true,\n+  cacheLife: {\n+    // Override the 'days' profile\n+    days: {\n+      stale: 3600, // 1 hour\n+      revalidate: 900, // 15 minutes\n+      expire: 86400, // 1 day\n+    },\n+  },\n+}\n+```\n+\n+### Inline cache profiles\n+\n+For one-off cases, pass a profile object directly to `cacheLife`:\n \n-```tsx filename=\"app/page.tsx\" highlight={5-9} switcher\n+```tsx filename=\"app/page.tsx\"\n 'use cache'\n import { cacheLife } from 'next/cache'\n \n export default async function Page() {\n   cacheLife({\n-    stale: 3600, // 1 hour\n-    revalidate: 900, // 15 minutes\n-    expire: 86400, // 1 day\n+    stale: 3600,\n+    revalidate: 900,\n+    expire: 86400,\n   })\n \n   return <div>Page</div>\n }\n ```\n \n-```jsx filename=\"app/page.js\" highlight={5-9} switcher\n-'use cache'\n+Inline profiles apply only to the specific function or component. For reusable configurations, define custom profiles in `next.config.ts`.\n+\n+Using `cacheLife({})` with an empty object applies the `default` profile values.\n+\n+### Client router cache behavior\n+\n+The `stale` property controls the client-side router cache, not the `Cache-Control` header:\n+\n+- The server sends the stale time via the `x-nextjs-stale-time` response header\n+- The client router uses this value to determine when to revalidate\n+- **Minimum of 30 seconds is enforced** to ensure prefetched links remain usable\n+\n+This 30-second minimum prevents prefetched data from expiring before users can click on links. It only applies to time-based expiration.\n+\n+When you call revalidation functions from a Server Action ([`revalidateTag`](/docs/app/api-reference/functions/revalidateTag), [`revalidatePath`](/docs/app/api-reference/functions/revalidatePath), [`updateTag`](/docs/app/api-reference/functions/updateTag), or [`refresh`](/docs/app/api-reference/functions/refresh)), the entire client cache is immediately cleared, bypassing the stale time.\n+\n+> **Good to know**: The `stale` property in `cacheLife` differs from [`staleTimes`](/docs/app/api-reference/config/next-config-js/staleTimes). While `staleTimes` is a global setting affecting all routes, `cacheLife` allows per-function or per-route configuration. Updating `staleTimes.static` also updates the `stale` value of the `default` cache profile.\n+\n+## Examples\n+\n+### Using preset profiles\n+\n+The simplest way to configure caching is using preset profiles. Choose one that matches your content's update pattern:\n+\n+```tsx filename=\"app/blog/[slug]/page.tsx\"\n import { cacheLife } from 'next/cache'\n \n-export default async function Page() {\n+export default async function BlogPost() {\n+  'use cache'\n+  cacheLife('days') // Blog posts updated daily\n+\n+  const post = await fetchBlogPost()\n+  return <article>{post.content}</article>\n+}\n+```\n+\n+```tsx filename=\"app/products/[id]/page.tsx\"\n+import { cacheLife } from 'next/cache'\n+\n+export default async function ProductPage() {\n+  'use cache'\n+  cacheLife('hours') // Product data updated multiple times per day\n+\n+  const product = await fetchProduct()\n+  return <div>{product.name}</div>\n+}\n+```\n+\n+### Custom profiles for specific needs\n+\n+Define custom profiles when preset options don't match your requirements:\n+\n+```ts filename=\"next.config.ts\"\n+import type { NextConfig } from 'next'\n+\n+const nextConfig: NextConfig = {\n+  cacheComponents: true,\n+  cacheLife: {\n+    editorial: {\n+      stale: 600, // 10 minutes\n+      revalidate: 3600, // 1 hour\n+      expire: 86400, // 1 day\n+    },\n+    marketing: {\n+      stale: 300, // 5 minutes\n+      revalidate: 1800, // 30 minutes\n+      expire: 43200, // 12 hours\n+    },\n+  },\n+}\n+\n+export default nextConfig\n+```\n+\n+Then use these profiles throughout your application:\n+\n+```tsx filename=\"app/editorial/page.tsx\"\n+import { cacheLife } from 'next/cache'\n+\n+export default async function EditorialPage() {\n+  'use cache'\n+  cacheLife('editorial')\n+  // ...\n+}\n+```\n+\n+### Inline profiles for unique cases\n+\n+Use inline profiles when a specific function needs one-off caching behavior:\n+\n+```tsx filename=\"app/api/limited-offer/route.ts\"\n+import { cacheLife } from 'next/cache'\n+import { getDb } from '@lib/db'\n+\n+async function getLimitedOffer() {\n+  'use cache'\n+\n   cacheLife({\n-    stale: 3600, // 1 hour\n-    revalidate: 900, // 15 minutes\n-    expire: 86400, // 1 day\n+    stale: 60, // 1 minute\n+    revalidate: 300, // 5 minutes\n+    expire: 3600, // 1 hour\n   })\n \n-  return <div>Page</div>\n+  const offer = await getDb().offer.findFirst({\n+    where: { type: 'limited' },\n+    orderBy: { created_at: 'desc' },\n+  })\n+\n+  return offer\n+}\n+\n+export async function GET() {\n+  const offer = await getLimitedOffer()\n+\n+  return Response.json(offer)\n+}\n+```\n+\n+### Caching individual functions\n+\n+Apply caching to utility functions for granular control:\n+\n+```tsx filename=\"lib/api.ts\"\n+import { cacheLife } from 'next/cache'\n+\n+export async function getSettings() {\n+  'use cache'\n+  cacheLife('max') // Settings rarely change\n+\n+  return await fetchSettings()\n }\n ```\n \n-This inline cache profile will only be applied to the function or file it was created in. If you want to reuse the same profile throughout your application, you can [add the configuration](#defining-reusable-cache-profiles) to the `cacheLife` property of your `next.config.ts` file.\n+```tsx filename=\"lib/stats.ts\"\n+import { cacheLife } from 'next/cache'\n \n-### Nested usage of `use cache` and `cacheLife`\n+export async function getRealtimeStats() {\n+  'use cache'\n+  cacheLife('seconds') // Stats update constantly\n+\n+  return await fetchStats()\n+}\n+```\n \n-When defining multiple caching behaviors in the same route or component tree, if the inner caches specify their own `cacheLife` profile, the outer cache will respect the shortest cache duration among them. **This applies only if the outer cache does not have its own explicit `cacheLife` profile defined.**\n+### Nested caching behavior\n \n-For example, if you add the `use cache` directive to your page, without specifying a cache profile, the default cache profile will be applied implicitly (`cacheLife(”default”)`). If a component imported into the page also uses the `use cache` directive with its own cache profile, the outer and inner cache profiles are compared, and shortest duration set in the profiles will be applied.\n+When components with different cache profiles are nested, Next.js respects the shortest duration among them:\n \n-```tsx filename=\"app/components/parent.tsx\" highlight={5,6}\n-// Parent component\n+```tsx filename=\"app/dashboard/page.tsx\"\n import { cacheLife } from 'next/cache'\n-import { ChildComponent } from './child'\n+import { RealtimeWidget } from './realtime-widget'\n \n-export async function ParentComponent() {\n+export default async function Dashboard() {\n   'use cache'\n-  cacheLife('days')\n+  cacheLife('hours') // Dashboard cached for hours\n \n   return (\n     <div>\n-      <ChildComponent />\n+      <h1>Dashboard</h1>\n+      <RealtimeWidget />\n     </div>\n   )\n }\n ```\n \n-And in a separate file, we defined the Child component that was imported:\n-\n-```tsx filename=\"app/components/child.tsx\" highlight={4,5}\n-// Child component\n+```tsx filename=\"app/dashboard/realtime-widget.tsx\"\n import { cacheLife } from 'next/cache'\n \n-export async function ChildComponent() {\n+export async function RealtimeWidget() {\n   'use cache'\n-  cacheLife('hours')\n-  return <div>Child Content</div>\n+  cacheLife('seconds') // Widget needs fresh data\n \n-  // This component's cache will respect the shorter 'hours' profile\n+  const data = await fetchRealtimeData()\n+  return <div>{data.value}</div>\n }\n ```\n+\n+In this example, the outer `Dashboard` component specifies the `hours` profile, but it contains `RealtimeWidget` which uses the `seconds` profile. The shortest duration from the nested profiles takes precedence, ensuring the widget gets fresh data while the rest of the dashboard can be cached longer.\n+\n+> **Good to know**: This shortest-duration behavior ensures that no part of your page serves stale data longer than its most frequently updated component requires."
        }
    ],
    "stats": {
        "total": 328,
        "additions": 249,
        "deletions": 79
    }
}