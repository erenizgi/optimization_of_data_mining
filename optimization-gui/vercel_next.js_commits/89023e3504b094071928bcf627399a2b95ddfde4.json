{
    "author": "sokra",
    "message": "Turbopack: handle non chunkable modules in module batches (#77282)\n\n### What?\n\nFix the handling of non-chunkable modules in module batches",
    "sha": "89023e3504b094071928bcf627399a2b95ddfde4",
    "files": [
        {
            "sha": "f955e0e62fc27fd7d3269e36ea690c056f98fe8e",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/module_batches.rs",
            "status": "modified",
            "additions": 54,
            "deletions": 46,
            "changes": 100,
            "blob_url": "https://github.com/vercel/next.js/blob/89023e3504b094071928bcf627399a2b95ddfde4/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmodule_batches.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/89023e3504b094071928bcf627399a2b95ddfde4/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmodule_batches.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmodule_batches.rs?ref=89023e3504b094071928bcf627399a2b95ddfde4",
            "patch": "@@ -186,7 +186,7 @@ type PreBatchIndex = usize;\n \n #[derive(Hash, PartialEq, Eq, Clone, Debug)]\n enum PreBatchItem {\n-    ParallelModule(ResolvedVc<Box<dyn ChunkableModule>>),\n+    ParallelModule(ResolvedVc<Box<dyn Module>>),\n     ParallelReference(PreBatchIndex),\n     NonParallelEdge(ChunkingType, ResolvedVc<Box<dyn Module>>),\n }\n@@ -212,7 +212,7 @@ struct TraversalState<'l> {\n \n struct PreBatches {\n     batches: Vec<PreBatch>,\n-    entries: FxHashMap<ResolvedVc<Box<dyn ChunkableModule>>, PreBatchIndex>,\n+    entries: FxHashMap<ResolvedVc<Box<dyn Module>>, PreBatchIndex>,\n     single_module_entries: FxIndexSet<ResolvedVc<Box<dyn Module>>>,\n }\n \n@@ -227,9 +227,9 @@ impl PreBatches {\n \n     fn ensure_pre_batch_for_module(\n         &mut self,\n-        module: ResolvedVc<Box<dyn ChunkableModule>>,\n+        module: ResolvedVc<Box<dyn Module>>,\n         chunk_groups: &RoaringBitmapWrapper,\n-        queue: &mut VecDeque<(ResolvedVc<Box<dyn ChunkableModule>>, PreBatchIndex)>,\n+        queue: &mut VecDeque<(ResolvedVc<Box<dyn Module>>, PreBatchIndex)>,\n     ) -> PreBatchIndex {\n         match self.entries.entry(module) {\n             Entry::Vacant(e) => {\n@@ -246,10 +246,10 @@ impl PreBatches {\n \n     async fn get_pre_batch_items(\n         &mut self,\n-        entry: ResolvedVc<Box<dyn ChunkableModule>>,\n+        entry: ResolvedVc<Box<dyn Module>>,\n         chunk_group_info: &ChunkGroupInfo,\n         module_graph: &ModuleGraph,\n-        queue: &mut VecDeque<(ResolvedVc<Box<dyn ChunkableModule>>, PreBatchIndex)>,\n+        queue: &mut VecDeque<(ResolvedVc<Box<dyn Module>>, PreBatchIndex)>,\n     ) -> Result<Vec<PreBatchItem>> {\n         let entry_chunk_groups = chunk_group_info\n             .module_chunk_groups\n@@ -266,43 +266,34 @@ impl PreBatches {\n                 &mut state,\n                 |parent_info, node, state| {\n                     let ty = parent_info.map_or(&ChunkingType::Parallel, |(_, ty)| ty);\n+                    let module = node.module;\n                     if !ty.is_parallel() {\n                         state.items.push(PreBatchItem::NonParallelEdge(\n                             ty.without_inherit_async(),\n-                            node.module,\n+                            module,\n                         ));\n                         return Ok(GraphTraversalAction::Exclude);\n                     }\n-                    let Some(chunkable_module) = ResolvedVc::try_downcast(node.module) else {\n-                        return Ok(GraphTraversalAction::Skip);\n-                    };\n-                    let chunk_groups = chunk_group_info\n-                        .module_chunk_groups\n-                        .get(&node.module)\n-                        .context(\"all modules need to have chunk group info\")?;\n-                    if chunk_groups != entry_chunk_groups {\n-                        let idx = state.this.ensure_pre_batch_for_module(\n-                            chunkable_module,\n-                            chunk_groups,\n-                            queue,\n-                        );\n-                        state.items.push(PreBatchItem::ParallelReference(idx));\n-                        return Ok(GraphTraversalAction::Exclude);\n-                    }\n-                    if visited.insert(chunkable_module) {\n+                    if visited.insert(module) {\n+                        let chunk_groups = chunk_group_info\n+                            .module_chunk_groups\n+                            .get(&module)\n+                            .context(\"all modules need to have chunk group info\")?;\n+                        if chunk_groups != entry_chunk_groups {\n+                            let idx =\n+                                state\n+                                    .this\n+                                    .ensure_pre_batch_for_module(module, chunk_groups, queue);\n+                            state.items.push(PreBatchItem::ParallelReference(idx));\n+                            return Ok(GraphTraversalAction::Exclude);\n+                        }\n                         Ok(GraphTraversalAction::Continue)\n                     } else {\n                         Ok(GraphTraversalAction::Exclude)\n                     }\n                 },\n-                |parent_info, node, state| {\n-                    let ty = parent_info.map_or(&ChunkingType::Parallel, |(_, ty)| ty);\n-                    let item = if let Some(chunkable_module) = ResolvedVc::try_downcast(node.module)\n-                    {\n-                        PreBatchItem::ParallelModule(chunkable_module)\n-                    } else {\n-                        PreBatchItem::NonParallelEdge(ty.without_inherit_async(), node.module)\n-                    };\n+                |_, node, state| {\n+                    let item = PreBatchItem::ParallelModule(node.module);\n                     state.items.push(item);\n                 },\n             )\n@@ -330,8 +321,7 @@ pub async fn compute_module_batches(\n         let module_graph = module_graph.await?;\n \n         let mut pre_batches = PreBatches::new();\n-        let mut queue: VecDeque<(ResolvedVc<Box<dyn ChunkableModule>>, PreBatchIndex)> =\n-            VecDeque::new();\n+        let mut queue: VecDeque<(ResolvedVc<Box<dyn Module>>, PreBatchIndex)> = VecDeque::new();\n \n         // Start with the entries\n         for chunk_group in &chunk_group_info.chunk_groups {\n@@ -393,7 +383,7 @@ pub async fn compute_module_batches(\n                             pre_batches.single_module_entries.insert(*module);\n                         }\n                     }\n-                    _ => {}\n+                    PreBatchItem::ParallelReference(_) => {}\n                 }\n             }\n         }\n@@ -513,28 +503,43 @@ pub async fn compute_module_batches(\n \n         let mut edges_count = 0;\n \n-        // Since batches can only have references followed by a list of parallel modules, we need to\n-        // split batches that have modules before references.\n+        // Since batches can only have references followed by a list of parallel chunkable modules,\n+        // we need to split batches that have modules before references.\n         for i in 0..pre_batches.batches.len() {\n             let items = take(&mut pre_batches.batches[i].items);\n             let mut new_items =\n                 FxIndexSet::with_capacity_and_hasher(items.len(), Default::default());\n             enum Mode {\n-                ParallelModule,\n+                ParallelChunkableModule,\n                 Other,\n             }\n             let mut mode = Mode::Other;\n             for item in items {\n-                match (&mode, &item) {\n-                    (_, PreBatchItem::ParallelModule(_)) => {\n-                        mode = Mode::ParallelModule;\n+                let chunkable_module = if let PreBatchItem::ParallelModule(module) = &item {\n+                    ResolvedVc::try_downcast::<Box<dyn ChunkableModule>>(*module)\n+                } else {\n+                    None\n+                };\n+                let item = if let PreBatchItem::ParallelModule(module) = item {\n+                    if chunkable_module.is_some() {\n+                        PreBatchItem::ParallelModule(module)\n+                    } else {\n+                        pre_batches.single_module_entries.insert(module);\n+                        PreBatchItem::NonParallelEdge(ChunkingType::Parallel, module)\n+                    }\n+                } else {\n+                    item\n+                };\n+                match (&mode, chunkable_module) {\n+                    (_, Some(_)) => {\n+                        mode = Mode::ParallelChunkableModule;\n                         new_items.insert(item);\n                     }\n                     (Mode::Other, _) => {\n                         edges_count += 1;\n                         new_items.insert(item);\n                     }\n-                    (Mode::ParallelModule, _) => {\n+                    (Mode::ParallelChunkableModule, _) => {\n                         // Split the batch\n                         let idx = pre_batches.batches.len();\n                         let mut new_batch =\n@@ -543,7 +548,7 @@ pub async fn compute_module_batches(\n                         pre_batches.batches.push(new_batch);\n                         edges_count += 1;\n                         new_items.insert(PreBatchItem::ParallelReference(idx));\n-                        if matches!(item, PreBatchItem::ParallelModule(_)) {\n+                        if chunkable_module.is_some() {\n                             new_items.insert(item);\n                         } else {\n                             edges_count += 1;\n@@ -572,9 +577,12 @@ pub async fn compute_module_batches(\n             .iter_mut()\n             .enumerate()\n             .map(async |(i, pre_batch)| {\n-                let mut modules = pre_batch.items.iter().filter_map(|item| match item {\n-                    PreBatchItem::ParallelModule(module) => Some(*module),\n-                    _ => None,\n+                let mut modules = pre_batch.items.iter().filter_map(|item| {\n+                    if let PreBatchItem::ParallelModule(module) = item {\n+                        ResolvedVc::try_downcast(*module)\n+                    } else {\n+                        None\n+                    }\n                 });\n                 let Some(first) = modules.next() else {\n                     return Ok(ModuleOrBatch::None(i));"
        }
    ],
    "stats": {
        "total": 100,
        "additions": 54,
        "deletions": 46
    }
}