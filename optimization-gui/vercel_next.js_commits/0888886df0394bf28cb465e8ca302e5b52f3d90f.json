{
    "author": "mischnic",
    "message": "Turbopack: correctly apply generate_source_map with scope hoisting (#81060)\n\nDon't generate source maps if the corresponding merged module specified that (i.e. have different values of `generate_source_map: bool` inside a single AST.",
    "sha": "0888886df0394bf28cb465e8ca302e5b52f3d90f",
    "files": [
        {
            "sha": "a3b44239cf79b8656a6ae3667a8526cbb2e71fcb",
            "filename": "turbopack/crates/turbopack-ecmascript/src/lib.rs",
            "status": "modified",
            "additions": 51,
            "deletions": 19,
            "changes": 70,
            "blob_url": "https://github.com/vercel/next.js/blob/0888886df0394bf28cb465e8ca302e5b52f3d90f/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0888886df0394bf28cb465e8ca302e5b52f3d90f/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs?ref=0888886df0394bf28cb465e8ca302e5b52f3d90f",
            "patch": "@@ -1123,7 +1123,8 @@ impl EcmascriptModuleContent {\n         let (merged_ast, comments, source_maps, original_source_maps) =\n             merge_modules(contents, &entry_points, &globals_merged).await?;\n \n-        // Use the options from an arbitrary module, since they should all be the same.\n+        // Use the options from an arbitrary module, since they should all be the same with regards\n+        // to minify_type and chunking_context.\n         let options = module_options.last().unwrap().await?;\n \n         let modules_header_width = modules.len().next_power_of_two().trailing_zeros();\n@@ -1140,7 +1141,6 @@ impl EcmascriptModuleContent {\n             export_contexts: None,\n             is_esm: true,\n             strict: true,\n-            generate_source_map: options.generate_source_map,\n             original_source_map: CodeGenResultOriginalSourceMap::ScopeHoisting(\n                 original_source_maps,\n             ),\n@@ -1543,7 +1543,6 @@ struct CodeGenResult {\n     export_contexts: Option<FxHashMap<RcStr, Id>>,\n     is_esm: bool,\n     strict: bool,\n-    generate_source_map: bool,\n     original_source_map: CodeGenResultOriginalSourceMap,\n     minify: MinifyType,\n     scope_hoisting_syntax_contexts:\n@@ -1715,8 +1714,12 @@ async fn process_parse_result(\n \n             Ok(CodeGenResult {\n                 program,\n-                source_map: CodeGenResultSourceMap::Single {\n-                    source_map: source_map.clone(),\n+                source_map: if generate_source_map {\n+                    CodeGenResultSourceMap::Single {\n+                        source_map: source_map.clone(),\n+                    }\n+                } else {\n+                    CodeGenResultSourceMap::None\n                 },\n                 comments: CodeGenResultComments::Single {\n                     comments,\n@@ -1726,7 +1729,6 @@ async fn process_parse_result(\n                 export_contexts: Some(export_contexts.into_owned()),\n                 is_esm,\n                 strict,\n-                generate_source_map,\n                 original_source_map: CodeGenResultOriginalSourceMap::Single(original_source_map),\n                 minify,\n                 scope_hoisting_syntax_contexts: retain_syntax_context.map(|(_, ctxts, _)| ctxts),\n@@ -1757,12 +1759,11 @@ async fn process_parse_result(\n                             body,\n                             shebang: None,\n                         }),\n-                        source_map: CodeGenResultSourceMap::default(),\n+                        source_map: CodeGenResultSourceMap::None,\n                         comments: CodeGenResultComments::Empty,\n                         export_contexts: None,\n                         is_esm: false,\n                         strict: false,\n-                        generate_source_map: false,\n                         original_source_map: CodeGenResultOriginalSourceMap::Single(None),\n                         minify: MinifyType::NoMinify,\n                         scope_hoisting_syntax_contexts: None,\n@@ -1785,12 +1786,11 @@ async fn process_parse_result(\n                             body,\n                             shebang: None,\n                         }),\n-                        source_map: CodeGenResultSourceMap::default(),\n+                        source_map: CodeGenResultSourceMap::None,\n                         comments: CodeGenResultComments::Empty,\n                         export_contexts: None,\n                         is_esm: false,\n                         strict: false,\n-                        generate_source_map: false,\n                         original_source_map: CodeGenResultOriginalSourceMap::Single(None),\n                         minify: MinifyType::NoMinify,\n                         scope_hoisting_syntax_contexts: None,\n@@ -1881,13 +1881,14 @@ async fn emit_content(\n         comments,\n         is_esm,\n         strict,\n-        generate_source_map,\n         original_source_map,\n         minify,\n         export_contexts: _,\n         scope_hoisting_syntax_contexts: _,\n     } = content;\n \n+    let generate_source_map = source_map.is_some();\n+\n     let mut bytes: Vec<u8> = vec![];\n     // TODO: Insert this as a sourceless segment so that sourcemaps aren't affected.\n     // = format!(\"/* {} */\\n\", self.module.path().to_string().await?).into_bytes();\n@@ -2056,7 +2057,11 @@ fn hygiene_rename_only(\n     )\n }\n \n+#[derive(Default)]\n enum CodeGenResultSourceMap {\n+    #[default]\n+    /// No source map should be generated for this module\n+    None,\n     Single {\n         source_map: Arc<SourceMap>,\n     },\n@@ -2068,9 +2073,20 @@ enum CodeGenResultSourceMap {\n     },\n }\n \n+impl CodeGenResultSourceMap {\n+    fn is_some(&self) -> bool {\n+        match self {\n+            CodeGenResultSourceMap::None => false,\n+            CodeGenResultSourceMap::Single { .. }\n+            | CodeGenResultSourceMap::ScopeHoisting { .. } => true,\n+        }\n+    }\n+}\n+\n impl Debug for CodeGenResultSourceMap {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         match self {\n+            CodeGenResultSourceMap::None => write!(f, \"CodeGenResultSourceMap::None\"),\n             CodeGenResultSourceMap::Single { source_map } => {\n                 write!(\n                     f,\n@@ -2090,20 +2106,13 @@ impl Debug for CodeGenResultSourceMap {\n     }\n }\n \n-impl Default for CodeGenResultSourceMap {\n-    fn default() -> Self {\n-        CodeGenResultSourceMap::Single {\n-            source_map: Arc::new(SourceMap::default()),\n-        }\n-    }\n-}\n-\n impl Files for CodeGenResultSourceMap {\n     fn try_lookup_source_file(\n         &self,\n         pos: BytePos,\n     ) -> Result<Option<Arc<SourceFile>>, SourceMapLookupError> {\n         match self {\n+            CodeGenResultSourceMap::None => Ok(None),\n             CodeGenResultSourceMap::Single { source_map } => source_map.try_lookup_source_file(pos),\n             CodeGenResultSourceMap::ScopeHoisting {\n                 modules_header_width,\n@@ -2118,6 +2127,7 @@ impl Files for CodeGenResultSourceMap {\n \n     fn is_in_file(&self, f: &Arc<SourceFile>, raw_pos: BytePos) -> bool {\n         match self {\n+            CodeGenResultSourceMap::None => false,\n             CodeGenResultSourceMap::Single { .. } => f.start_pos <= raw_pos && raw_pos < f.end_pos,\n             CodeGenResultSourceMap::ScopeHoisting { .. } => {\n                 // let (module, pos) = CodeGenResultComments::decode_bytepos(*modules_header_width,\n@@ -2132,6 +2142,7 @@ impl Files for CodeGenResultSourceMap {\n \n     fn map_raw_pos(&self, pos: BytePos) -> BytePos {\n         match self {\n+            CodeGenResultSourceMap::None => BytePos::DUMMY,\n             CodeGenResultSourceMap::Single { .. } => pos,\n             CodeGenResultSourceMap::ScopeHoisting {\n                 modules_header_width,\n@@ -2144,6 +2155,9 @@ impl Files for CodeGenResultSourceMap {\n impl SourceMapper for CodeGenResultSourceMap {\n     fn lookup_char_pos(&self, pos: BytePos) -> Loc {\n         match self {\n+            CodeGenResultSourceMap::None => {\n+                panic!(\"CodeGenResultSourceMap::None cannot lookup_char_pos\")\n+            }\n             CodeGenResultSourceMap::Single { source_map } => source_map.lookup_char_pos(pos),\n             CodeGenResultSourceMap::ScopeHoisting {\n                 modules_header_width,\n@@ -2157,6 +2171,9 @@ impl SourceMapper for CodeGenResultSourceMap {\n     }\n     fn span_to_lines(&self, sp: Span) -> FileLinesResult {\n         match self {\n+            CodeGenResultSourceMap::None => {\n+                panic!(\"CodeGenResultSourceMap::None cannot span_to_lines\")\n+            }\n             CodeGenResultSourceMap::Single { source_map } => source_map.span_to_lines(sp),\n             CodeGenResultSourceMap::ScopeHoisting {\n                 modules_header_width,\n@@ -2173,6 +2190,9 @@ impl SourceMapper for CodeGenResultSourceMap {\n     }\n     fn span_to_string(&self, sp: Span) -> String {\n         match self {\n+            CodeGenResultSourceMap::None => {\n+                panic!(\"CodeGenResultSourceMap::None cannot span_to_string\")\n+            }\n             CodeGenResultSourceMap::Single { source_map } => source_map.span_to_string(sp),\n             CodeGenResultSourceMap::ScopeHoisting {\n                 modules_header_width,\n@@ -2189,6 +2209,9 @@ impl SourceMapper for CodeGenResultSourceMap {\n     }\n     fn span_to_filename(&self, sp: Span) -> Arc<FileName> {\n         match self {\n+            CodeGenResultSourceMap::None => {\n+                panic!(\"CodeGenResultSourceMap::None cannot span_to_filename\")\n+            }\n             CodeGenResultSourceMap::Single { source_map } => source_map.span_to_filename(sp),\n             CodeGenResultSourceMap::ScopeHoisting {\n                 modules_header_width,\n@@ -2205,6 +2228,9 @@ impl SourceMapper for CodeGenResultSourceMap {\n     }\n     fn merge_spans(&self, sp_lhs: Span, sp_rhs: Span) -> Option<Span> {\n         match self {\n+            CodeGenResultSourceMap::None => {\n+                panic!(\"CodeGenResultSourceMap::None cannot merge_spans\")\n+            }\n             CodeGenResultSourceMap::Single { source_map } => source_map.merge_spans(sp_lhs, sp_rhs),\n             CodeGenResultSourceMap::ScopeHoisting {\n                 modules_header_width,\n@@ -2234,6 +2260,9 @@ impl SourceMapper for CodeGenResultSourceMap {\n     }\n     fn call_span_if_macro(&self, sp: Span) -> Span {\n         match self {\n+            CodeGenResultSourceMap::None => {\n+                panic!(\"CodeGenResultSourceMap::None cannot call_span_if_macro\")\n+            }\n             CodeGenResultSourceMap::Single { source_map } => source_map.call_span_if_macro(sp),\n             CodeGenResultSourceMap::ScopeHoisting {\n                 modules_header_width,\n@@ -2253,6 +2282,9 @@ impl SourceMapper for CodeGenResultSourceMap {\n     }\n     fn span_to_snippet(&self, sp: Span) -> Result<String, Box<SpanSnippetError>> {\n         match self {\n+            CodeGenResultSourceMap::None => {\n+                panic!(\"CodeGenResultSourceMap::None cannot span_to_snippet\")\n+            }\n             CodeGenResultSourceMap::Single { source_map } => source_map.span_to_snippet(sp),\n             CodeGenResultSourceMap::ScopeHoisting {\n                 modules_header_width,"
        }
    ],
    "stats": {
        "total": 70,
        "additions": 51,
        "deletions": 19
    }
}