{
    "author": "bgw",
    "message": "fix(napi): Use strong consistency for the entire project_trace_source function (#79917)\n\nThis function does a few more `Vc` reads than just looking up the source map, so it's better to move the entire thing inside one strongly-consistent operation.\n\nThis was an attempt to fix a loop (tracing an error -> react fast refresh -> triggers the same error again -> ...) https://vercel.slack.com/archives/C046HAU4H7F/p1747837763588429, though it doesn't seem like this fixes it.",
    "sha": "f30797f8fb682ff7777018ddab077647f844d9d0",
    "files": [
        {
            "sha": "068b413157eefc87d0a0bd05e08b6ffecb6cc028",
            "filename": "crates/napi/src/next_api/project.rs",
            "status": "modified",
            "additions": 125,
            "deletions": 104,
            "changes": 229,
            "blob_url": "https://github.com/vercel/next.js/blob/f30797f8fb682ff7777018ddab077647f844d9d0/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f30797f8fb682ff7777018ddab077647f844d9d0/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs?ref=f30797f8fb682ff7777018ddab077647f844d9d0",
            "patch": "@@ -1,4 +1,4 @@\n-use std::{io::Write, path::PathBuf, sync::Arc, thread, time::Duration};\n+use std::{borrow::Cow, io::Write, path::PathBuf, sync::Arc, thread, time::Duration};\n \n use anyhow::{Context, Result, anyhow, bail};\n use napi::{\n@@ -24,14 +24,16 @@ use next_core::tracing_presets::{\n };\n use once_cell::sync::Lazy;\n use rand::Rng;\n+use serde::{Deserialize, Serialize};\n use tokio::{io::AsyncWriteExt, time::Instant};\n use tracing::Instrument;\n use tracing_subscriber::{Registry, layer::SubscriberExt, util::SubscriberInitExt};\n use turbo_rcstr::RcStr;\n use turbo_tasks::{\n-    Completion, Effects, FxIndexSet, OperationVc, ReadRef, ResolvedVc, TransientInstance,\n-    TryJoinIterExt, UpdateInfo, Vc, get_effects,\n+    Completion, Effects, FxIndexSet, NonLocalValue, OperationValue, OperationVc, ReadRef,\n+    ResolvedVc, TaskInput, TransientInstance, TryJoinIterExt, UpdateInfo, Vc, get_effects,\n     message_queue::{CompilationEvent, Severity, TimingEvent},\n+    trace::TraceRawVcs,\n };\n use turbo_tasks_fs::{\n     DiskFileSystem, FileContent, FileSystem, FileSystemPath, get_relative_path_to,\n@@ -43,7 +45,7 @@ use turbopack_core::{\n     error::PrettyPrintError,\n     issue::PlainIssue,\n     output::{OutputAsset, OutputAssets},\n-    source_map::{OptionSourceMap, OptionStringifiedSourceMap, SourceMap, Token},\n+    source_map::{OptionStringifiedSourceMap, SourceMap, Token},\n     version::{PartialUpdate, TotalUpdate, Update, VersionState},\n };\n use turbopack_ecmascript_hmr_protocol::{ClientUpdateInstruction, ResourceIdentifier};\n@@ -448,7 +450,7 @@ pub async fn project_new(\n     ))\n }\n \n-#[derive(Debug, Clone, serde::Serialize)]\n+#[derive(Debug, Clone, Serialize)]\n struct SlowFilesystemEvent {\n     directory: String,\n     duration_ms: u128,\n@@ -1326,21 +1328,36 @@ pub fn project_compilation_events_subscribe(\n     Ok(())\n }\n \n-#[turbo_tasks::value]\n-#[derive(Debug)]\n #[napi(object)]\n+#[derive(\n+    Clone,\n+    Debug,\n+    Deserialize,\n+    Eq,\n+    Hash,\n+    NonLocalValue,\n+    OperationValue,\n+    PartialEq,\n+    Serialize,\n+    TaskInput,\n+    TraceRawVcs,\n+)]\n pub struct StackFrame {\n     pub is_server: bool,\n     pub is_internal: Option<bool>,\n-    pub original_file: Option<String>,\n+    pub original_file: Option<RcStr>,\n     pub file: RcStr,\n-    // 1-indexed, unlike source map tokens\n+    /// 1-indexed, unlike source map tokens\n     pub line: Option<u32>,\n-    // 1-indexed, unlike source map tokens\n+    /// 1-indexed, unlike source map tokens\n     pub column: Option<u32>,\n     pub method_name: Option<RcStr>,\n }\n \n+#[turbo_tasks::value(transparent)]\n+#[derive(Clone)]\n+pub struct OptionStackFrame(Option<StackFrame>);\n+\n #[turbo_tasks::function]\n pub async fn get_source_map_rope(\n     container: Vc<ProjectContainer>,\n@@ -1407,12 +1424,97 @@ pub fn get_source_map_rope_operation(\n }\n \n #[turbo_tasks::function(operation)]\n-pub fn get_source_map_operation(\n+pub async fn project_trace_source_operation(\n     container: ResolvedVc<ProjectContainer>,\n-    file_path: RcStr,\n-) -> Vc<OptionSourceMap> {\n-    let map = get_source_map_rope(*container, file_path);\n-    SourceMap::new_from_rope_cached(map)\n+    frame: StackFrame,\n+    current_directory_file_url: RcStr,\n+) -> Result<Vc<OptionStackFrame>> {\n+    let Some(map) =\n+        &*SourceMap::new_from_rope_cached(get_source_map_rope(*container, frame.file)).await?\n+    else {\n+        return Ok(Vc::cell(None));\n+    };\n+\n+    let Some(line) = frame.line else {\n+        return Ok(Vc::cell(None));\n+    };\n+\n+    let token = map\n+        .lookup_token(\n+            line.saturating_sub(1),\n+            frame.column.unwrap_or(1).saturating_sub(1),\n+        )\n+        .await?;\n+\n+    let (original_file, line, column, method_name) = match token {\n+        Token::Original(token) => (\n+            match urlencoding::decode(&token.original_file)? {\n+                Cow::Borrowed(_) => token.original_file,\n+                Cow::Owned(original_file) => RcStr::from(original_file),\n+            },\n+            // JS stack frames are 1-indexed, source map tokens are 0-indexed\n+            Some(token.original_line + 1),\n+            Some(token.original_column + 1),\n+            token.name,\n+        ),\n+        Token::Synthetic(token) => {\n+            let Some(original_file) = token.guessed_original_file else {\n+                return Ok(Vc::cell(None));\n+            };\n+            (original_file, None, None, None)\n+        }\n+    };\n+\n+    let project_root_uri =\n+        uri_from_file(container.project().project_root_path(), None).await? + \"/\";\n+    let (file, original_file, is_internal) =\n+        if let Some(source_file) = original_file.strip_prefix(&project_root_uri) {\n+            // Client code uses file://\n+            (\n+                RcStr::from(\n+                    get_relative_path_to(&current_directory_file_url, &original_file)\n+                        // TODO(sokra) remove this to include a ./ here to make it a relative path\n+                        .trim_start_matches(\"./\"),\n+                ),\n+                Some(RcStr::from(source_file)),\n+                false,\n+            )\n+        } else if let Some(source_file) = original_file.strip_prefix(&*SOURCE_MAP_PREFIX_PROJECT) {\n+            // Server code uses turbopack:///[project]\n+            // TODO should this also be file://?\n+            (\n+                RcStr::from(\n+                    get_relative_path_to(\n+                        &current_directory_file_url,\n+                        &format!(\"{project_root_uri}{source_file}\"),\n+                    )\n+                    // TODO(sokra) remove this to include a ./ here to make it a relative path\n+                    .trim_start_matches(\"./\"),\n+                ),\n+                Some(RcStr::from(source_file)),\n+                false,\n+            )\n+        } else if let Some(source_file) = original_file.strip_prefix(&*SOURCE_MAP_PREFIX) {\n+            // All other code like turbopack:///[turbopack] is internal code\n+            // TODO(veil): Should the protocol be preserved?\n+            (RcStr::from(source_file), None, true)\n+        } else {\n+            bail!(\n+                \"Original file ({}) outside project ({})\",\n+                original_file,\n+                project_root_uri\n+            )\n+        };\n+\n+    Ok(Vc::cell(Some(StackFrame {\n+        file,\n+        original_file,\n+        method_name,\n+        line,\n+        column,\n+        is_server: frame.is_server,\n+        is_internal: Some(is_internal),\n+    })))\n }\n \n #[napi]\n@@ -1425,98 +1527,17 @@ pub async fn project_trace_source(\n     let container = project.container;\n     let traced_frame = turbo_tasks\n         .run_once(async move {\n-            let Some(map) = &*get_source_map_operation(container, frame.file)\n-                .read_strongly_consistent()\n-                .await?\n-            else {\n-                return Ok(None);\n-            };\n-\n-            let Some(line) = frame.line else {\n-                return Ok(None);\n-            };\n-\n-            let token = map\n-                .lookup_token(\n-                    line.saturating_sub(1),\n-                    frame.column.unwrap_or(1).saturating_sub(1),\n-                )\n-                .await?;\n-\n-            let (original_file, line, column, name) = match token {\n-                Token::Original(token) => (\n-                    urlencoding::decode(&token.original_file)?.into_owned(),\n-                    // JS stack frames are 1-indexed, source map tokens are 0-indexed\n-                    Some(token.original_line + 1),\n-                    Some(token.original_column + 1),\n-                    token.name.clone(),\n-                ),\n-                Token::Synthetic(token) => {\n-                    let Some(file) = &token.guessed_original_file else {\n-                        return Ok(None);\n-                    };\n-                    (file.to_owned(), None, None, None)\n-                }\n-            };\n-\n-            let project_root_uri =\n-                uri_from_file(project.container.project().project_root_path(), None).await? + \"/\";\n-            let (file, original_file, is_internal) = if let Some(source_file) =\n-                original_file.strip_prefix(&project_root_uri)\n-            {\n-                // Client code uses file://\n-                (\n-                    RcStr::from(\n-                        get_relative_path_to(&current_directory_file_url, &original_file)\n-                            // TODO(sokra) remove this to include a ./ here to make it a relative\n-                            // path\n-                            .trim_start_matches(\"./\"),\n-                    ),\n-                    Some(source_file.to_string()),\n-                    false,\n-                )\n-            } else if let Some(source_file) =\n-                original_file.strip_prefix(&*SOURCE_MAP_PREFIX_PROJECT)\n-            {\n-                // Server code uses turbopack:///[project]\n-                // TODO should this also be file://?\n-                (\n-                    RcStr::from(\n-                        get_relative_path_to(\n-                            &current_directory_file_url,\n-                            &format!(\"{project_root_uri}{source_file}\"),\n-                        )\n-                        // TODO(sokra) remove this to include a ./ here to make it a relative path\n-                        .trim_start_matches(\"./\"),\n-                    ),\n-                    Some(source_file.to_string()),\n-                    false,\n-                )\n-            } else if let Some(source_file) = original_file.strip_prefix(&*SOURCE_MAP_PREFIX) {\n-                // All other code like turbopack:///[turbopack] is internal code\n-                // TODO(veil): Should the protocol be preserved?\n-                (RcStr::from(source_file), None, true)\n-            } else {\n-                bail!(\n-                    \"Original file ({}) outside project ({})\",\n-                    original_file,\n-                    project_root_uri\n-                )\n-            };\n-\n-            Ok(Some(StackFrame {\n-                file,\n-                original_file,\n-                method_name: name,\n-                line,\n-                column,\n-                is_server: frame.is_server,\n-                is_internal: Some(is_internal),\n-            }))\n+            project_trace_source_operation(\n+                container,\n+                frame,\n+                RcStr::from(current_directory_file_url),\n+            )\n+            .read_strongly_consistent()\n+            .await\n         })\n         .await\n         .map_err(|e| napi::Error::from_reason(PrettyPrintError(&e).to_string()))?;\n-    Ok(traced_frame)\n+    Ok(ReadRef::into_owned(traced_frame))\n }\n \n #[napi]"
        },
        {
            "sha": "022607fa3b7ffe78c960337a40bd1f0f0493275d",
            "filename": "packages/next/src/build/swc/generated-native.d.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/f30797f8fb682ff7777018ddab077647f844d9d0/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Fgenerated-native.d.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f30797f8fb682ff7777018ddab077647f844d9d0/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Fgenerated-native.d.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Fgenerated-native.d.ts?ref=f30797f8fb682ff7777018ddab077647f844d9d0",
            "patch": "@@ -319,9 +319,11 @@ export declare function projectCompilationEventsSubscribe(\n export interface StackFrame {\n   isServer: boolean\n   isInternal?: boolean\n-  originalFile?: string\n+  originalFile?: RcStr\n   file: RcStr\n+  /** 1-indexed, unlike source map tokens */\n   line?: number\n+  /** 1-indexed, unlike source map tokens */\n   column?: number\n   methodName?: RcStr\n }"
        },
        {
            "sha": "01704f2fc64b84bd09ccfff1048181f20c5316e7",
            "filename": "turbopack/crates/turbopack-core/src/source_map/mod.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 7,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/f30797f8fb682ff7777018ddab077647f844d9d0/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fsource_map%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f30797f8fb682ff7777018ddab077647f844d9d0/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fsource_map%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fsource_map%2Fmod.rs?ref=f30797f8fb682ff7777018ddab077647f844d9d0",
            "patch": "@@ -116,7 +116,7 @@ pub struct TokenWithSource {\n pub struct SyntheticToken {\n     pub generated_line: u32,\n     pub generated_column: u32,\n-    pub guessed_original_file: Option<String>,\n+    pub guessed_original_file: Option<RcStr>,\n }\n \n /// An OriginalToken represents a region of the generated file that exists in\n@@ -126,7 +126,7 @@ pub struct SyntheticToken {\n pub struct OriginalToken {\n     pub generated_line: u32,\n     pub generated_column: u32,\n-    pub original_file: String,\n+    pub original_file: RcStr,\n     pub original_line: u32,\n     pub original_column: u32,\n     pub name: Option<RcStr>,\n@@ -154,10 +154,9 @@ impl From<sourcemap::Token<'_>> for Token {\n             Token::Original(OriginalToken {\n                 generated_line: t.get_dst_line(),\n                 generated_column: t.get_dst_col(),\n-                original_file: t\n-                    .get_source()\n-                    .expect(\"already checked token has source\")\n-                    .to_string(),\n+                original_file: RcStr::from(\n+                    t.get_source().expect(\"already checked token has source\"),\n+                ),\n                 original_line: t.get_src_line(),\n                 original_column: t.get_src_col(),\n                 name: t.get_name().map(RcStr::from),\n@@ -574,7 +573,7 @@ impl SourceMap {\n                     if let DecodedMap::Regular(map) = &map.map.0 {\n                         if map.get_source_count() == 1 {\n                             let source = map.sources().next().unwrap();\n-                            *guessed_original_file = Some(source.to_string());\n+                            *guessed_original_file = Some(RcStr::from(source));\n                         }\n                     }\n                 }"
        },
        {
            "sha": "8b177477577a324feb22f533e0a11399f82964cf",
            "filename": "turbopack/crates/turbopack-node/src/source_map/trace.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/f30797f8fb682ff7777018ddab077647f844d9d0/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fsource_map%2Ftrace.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f30797f8fb682ff7777018ddab077647f844d9d0/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fsource_map%2Ftrace.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fsource_map%2Ftrace.rs?ref=f30797f8fb682ff7777018ddab077647f844d9d0",
            "patch": "@@ -102,7 +102,7 @@ pub async fn trace_source_map(\n         .await?;\n     let result = match token {\n         Token::Original(t) => TraceResult::Found(StackFrame {\n-            file: t.original_file.clone().into(),\n+            file: Cow::Owned(t.original_file.into_owned()),\n             line: Some(t.original_line.saturating_add(1)),\n             column: Some(t.original_column.saturating_add(1)),\n             name: t"
        }
    ],
    "stats": {
        "total": 248,
        "additions": 135,
        "deletions": 113
    }
}