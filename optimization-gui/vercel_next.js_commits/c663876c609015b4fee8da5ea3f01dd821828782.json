{
    "author": "gnoff",
    "message": "Refactor metadata and viewport preloading (#77400)\n\nmetadata and viewport are attempted to be resolved concurrently even\nwhen async functions are used via `generateMetadata` and\n`generateViewport`. We call this preloading because we initiate the\ngeneration ahead of time but if it turns out that any particular\ngenerator requires the parent resolved values we can progressively\nreveal these to each pending generator. This PR refactors the code a bit\nto simplify and clarify this process. This is setting the stage to later\nseparate out the resolution of viewport from metadata since only\nviewport is now blocking the root.",
    "sha": "c663876c609015b4fee8da5ea3f01dd821828782",
    "files": [
        {
            "sha": "7d1866fdc89bb5f289a9e612e27270c9a062ad4e",
            "filename": "packages/next/src/lib/metadata/clone-metadata.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 2,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/c663876c609015b4fee8da5ea3f01dd821828782/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Fclone-metadata.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/c663876c609015b4fee8da5ea3f01dd821828782/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Fclone-metadata.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Fclone-metadata.ts?ref=c663876c609015b4fee8da5ea3f01dd821828782",
            "patch": "@@ -1,4 +1,7 @@\n-import type { ResolvedMetadata } from './types/metadata-interface'\n+import type {\n+  ResolvedMetadata,\n+  ResolvedViewport,\n+} from './types/metadata-interface'\n \n const TYPE_URL = '__METADATA_URL'\n \n@@ -17,7 +20,9 @@ function reviver(_key: string, val: any) {\n   return val\n }\n \n-export function cloneMetadata(metadata: ResolvedMetadata): ResolvedMetadata {\n+export function cloneMetadata<T extends ResolvedMetadata | ResolvedViewport>(\n+  metadata: T\n+): T {\n   const jsonString = JSON.stringify(metadata, replacer)\n   return JSON.parse(jsonString, reviver)\n }"
        },
        {
            "sha": "9e0ed2df792618d2f2334b0f7cced9b4547699fd",
            "filename": "packages/next/src/lib/metadata/resolve-metadata.ts",
            "status": "modified",
            "additions": 122,
            "deletions": 112,
            "changes": 234,
            "blob_url": "https://github.com/vercel/next.js/blob/c663876c609015b4fee8da5ea3f01dd821828782/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Fresolve-metadata.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/c663876c609015b4fee8da5ea3f01dd821828782/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Fresolve-metadata.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Fresolve-metadata.ts?ref=c663876c609015b4fee8da5ea3f01dd821828782",
            "patch": "@@ -682,119 +682,94 @@ function postProcessMetadata(\n   return metadata\n }\n \n-type DataResolver<Data, ResolvedData> = (\n-  parent: Promise<ResolvedData>\n-) => Data | Promise<Data>\n-\n-function collectMetadataExportPreloading<Data, ResolvedData>(\n-  results: (Data | Promise<Data>)[],\n-  dynamicMetadataExportFn: DataResolver<Data, ResolvedData>,\n-  resolvers: ((value: ResolvedData) => void)[]\n-) {\n-  const result = dynamicMetadataExportFn(\n-    new Promise<any>((resolve) => {\n-      resolvers.push(resolve)\n-    })\n-  )\n+type Result<T> = null | T | Promise<null | T> | PromiseLike<null | T>\n+\n+function prerenderMetadata(metadataItems: MetadataItems) {\n+  // If the index is a function then it is a resolver and the next slot\n+  // is the corresponding result. If the index is not a function it is the result\n+  // itself.\n+  const resolversAndResults: Array<\n+    ((value: ResolvedMetadata) => void) | Result<Metadata>\n+  > = []\n+  for (let i = 0; i < metadataItems.length; i++) {\n+    const metadataExport = metadataItems[i][0]\n+    getResult(resolversAndResults, metadataExport)\n+  }\n+  return resolversAndResults\n+}\n \n-  if (result instanceof Promise) {\n-    // since we eager execute generateMetadata and\n-    // they can reject at anytime we need to ensure\n-    // we attach the catch handler right away to\n-    // prevent unhandled rejections crashing the process\n-    result.catch((err) => {\n-      return {\n-        __nextError: err,\n-      }\n-    })\n+function prerenderViewport(metadataItems: MetadataItems) {\n+  // If the index is a function then it is a resolver and the next slot\n+  // is the corresponding result. If the index is not a function it is the result\n+  // itself.\n+  const resolversAndResults: Array<\n+    ((value: ResolvedViewport) => void) | Result<Viewport>\n+  > = []\n+  for (let i = 0; i < metadataItems.length; i++) {\n+    const viewportExport = metadataItems[i][2]\n+    getResult(resolversAndResults, viewportExport)\n   }\n-  results.push(result)\n+  return resolversAndResults\n }\n \n-async function getMetadataFromExport<Data, ResolvedData>(\n-  getPreloadMetadataExport: (\n-    metadataItem: NonNullable<MetadataItems[number]>\n-  ) => Data | DataResolver<Data, ResolvedData> | null,\n-  dynamicMetadataResolveState: {\n-    resolvers: ((value: ResolvedData) => void)[]\n-    resolvingIndex: number\n-  },\n-  metadataItems: MetadataItems,\n-  currentIndex: number,\n-  resolvedMetadata: ResolvedData,\n-  metadataResults: (Data | Promise<Data>)[]\n+type Resolved<T> = T extends Metadata ? ResolvedMetadata : ResolvedViewport\n+\n+function getResult<T extends Metadata | Viewport>(\n+  resolversAndResults: Array<((value: Resolved<T>) => void) | Result<T>>,\n+  exportForResult: null | T | ((parent: Promise<Resolved<T>>) => Result<T>)\n ) {\n-  const metadataExport = getPreloadMetadataExport(metadataItems[currentIndex])\n-  const dynamicMetadataResolvers = dynamicMetadataResolveState.resolvers\n-  let metadata: Data | null = null\n-  if (typeof metadataExport === 'function') {\n-    // Only preload at the beginning when resolves are empty\n-    if (!dynamicMetadataResolvers.length) {\n-      for (let j = currentIndex; j < metadataItems.length; j++) {\n-        const preloadMetadataExport = getPreloadMetadataExport(metadataItems[j])\n-        // call each `generateMetadata function concurrently and stash their resolver\n-        if (typeof preloadMetadataExport === 'function') {\n-          collectMetadataExportPreloading<Data, ResolvedData>(\n-            metadataResults,\n-            preloadMetadataExport as DataResolver<Data, ResolvedData>,\n-            dynamicMetadataResolvers\n-          )\n+  if (typeof exportForResult === 'function') {\n+    const result = exportForResult(\n+      new Promise<Resolved<T>>((resolve) => resolversAndResults.push(resolve))\n+    )\n+    resolversAndResults.push(result)\n+    if (result instanceof Promise) {\n+      // since we eager execute generateMetadata and\n+      // they can reject at anytime we need to ensure\n+      // we attach the catch handler right away to\n+      // prevent unhandled rejections crashing the process\n+      result.catch((err) => {\n+        return {\n+          __nextError: err,\n         }\n-      }\n+      })\n     }\n+  } else if (typeof exportForResult === 'object') {\n+    resolversAndResults.push(exportForResult)\n+  } else {\n+    resolversAndResults.push(null)\n+  }\n+}\n \n-    const resolveParent =\n-      dynamicMetadataResolvers[dynamicMetadataResolveState.resolvingIndex]\n-    const metadataResult =\n-      metadataResults[dynamicMetadataResolveState.resolvingIndex++]\n-\n-    // In dev we clone and freeze to prevent relying on mutating resolvedMetadata directly.\n-    // In prod we just pass resolvedMetadata through without any copying.\n-    const currentResolvedMetadata =\n-      process.env.NODE_ENV === 'development'\n-        ? Object.freeze(\n-            require('./clone-metadata').cloneMetadata(resolvedMetadata)\n-          )\n-        : resolvedMetadata\n-\n-    // This resolve should unblock the generateMetadata function if it awaited the parent\n-    // argument. If it didn't await the parent argument it might already have a value since it was\n-    // called concurrently. Regardless we await the return value before continuing on to the next layer\n-    resolveParent(currentResolvedMetadata)\n-    metadata =\n-      metadataResult instanceof Promise ? await metadataResult : metadataResult\n-\n-    if (metadata && typeof metadata === 'object' && '__nextError' in metadata) {\n-      // re-throw caught metadata error from preloading\n-      throw metadata['__nextError']\n-    }\n-  } else if (metadataExport !== null && typeof metadataExport === 'object') {\n-    // This metadataExport is the object form\n-    metadata = metadataExport\n+function resolvePendingResult<\n+  ResolvedType extends ResolvedMetadata | ResolvedViewport,\n+>(\n+  parentResult: ResolvedType,\n+  resolveParentResult: (value: ResolvedType) => void\n+): void {\n+  // In dev we clone and freeze to prevent relying on mutating resolvedMetadata directly.\n+  // In prod we just pass resolvedMetadata through without any copying.\n+  if (process.env.NODE_ENV === 'development') {\n+    parentResult = require('../../shared/lib/deep-freeze').deepFreeze(\n+      require('./clone-metadata').cloneMetadata(parentResult)\n+    )\n   }\n \n-  return metadata\n+  resolveParentResult(parentResult)\n }\n \n export async function accumulateMetadata(\n   metadataItems: MetadataItems,\n   metadataContext: MetadataContext\n ): Promise<ResolvedMetadata> {\n   const resolvedMetadata = createDefaultMetadata()\n-  const metadataResults: (Metadata | Promise<Metadata>)[] = []\n \n   let titleTemplates: TitleTemplates = {\n     title: null,\n     twitter: null,\n     openGraph: null,\n   }\n \n-  // Loop over all metadata items again, merging synchronously any static object exports,\n-  // awaiting any static promise exports, and resolving parent metadata and awaiting any generated metadata\n-  const dynamicMetadataResolvers = {\n-    resolvers: [],\n-    resolvingIndex: 0,\n-  }\n   const buildState = {\n     warnings: new Set<string>(),\n   }\n@@ -807,24 +782,39 @@ export async function accumulateMetadata(\n     icon: [],\n     apple: [],\n   }\n+\n+  const resolversAndResults = prerenderMetadata(metadataItems)\n+  let resultIndex = 0\n+\n   for (let i = 0; i < metadataItems.length; i++) {\n     const staticFilesMetadata = metadataItems[i][1]\n-\n     // Treat favicon as special case, it should be the first icon in the list\n     // i <= 1 represents root layout, and if current page is also at root\n     if (i <= 1 && isFavicon(staticFilesMetadata?.icon?.[0])) {\n       const iconMod = staticFilesMetadata?.icon?.shift()\n       if (i === 0) favicon = iconMod\n     }\n \n-    const metadata = await getMetadataFromExport<Metadata, ResolvedMetadata>(\n-      (metadataItem) => metadataItem[0],\n-      dynamicMetadataResolvers,\n-      metadataItems,\n-      i,\n-      resolvedMetadata,\n-      metadataResults\n-    )\n+    let pendingMetadata = resolversAndResults[resultIndex++]\n+    if (typeof pendingMetadata === 'function') {\n+      // This metadata item had a `generateMetadata` and\n+      // we need to provide the currently resolved metadata\n+      // to it before we continue;\n+      const resolveParentMetadata = pendingMetadata\n+      // we know that the next item is a result if this item\n+      // was a resolver\n+      pendingMetadata = resolversAndResults[resultIndex++] as Result<Metadata>\n+\n+      resolvePendingResult(resolvedMetadata, resolveParentMetadata)\n+    }\n+    // Otherwise the item was either null or a static export\n+\n+    let metadata: Metadata | null\n+    if (isPromiseLike(pendingMetadata)) {\n+      metadata = await pendingMetadata\n+    } else {\n+      metadata = pendingMetadata\n+    }\n \n     mergeMetadata({\n       target: resolvedMetadata,\n@@ -885,20 +875,30 @@ export async function accumulateViewport(\n ): Promise<ResolvedViewport> {\n   const resolvedViewport: ResolvedViewport = createDefaultViewport()\n \n-  const viewportResults: (Viewport | Promise<Viewport>)[] = []\n-  const dynamicMetadataResolvers = {\n-    resolvers: [],\n-    resolvingIndex: 0,\n-  }\n-  for (let i = 0; i < metadataItems.length; i++) {\n-    const viewport = await getMetadataFromExport<Viewport, ResolvedViewport>(\n-      (metadataItem) => metadataItem[2],\n-      dynamicMetadataResolvers,\n-      metadataItems,\n-      i,\n-      resolvedViewport,\n-      viewportResults\n-    )\n+  const resolversAndResults = prerenderViewport(metadataItems)\n+  let i = 0\n+\n+  while (i < resolversAndResults.length) {\n+    let pendingViewport = resolversAndResults[i++]\n+    if (typeof pendingViewport === 'function') {\n+      // this viewport item had a `generateViewport` and\n+      // we need to provide the currently resolved viewport\n+      // to it before we continue;\n+      const resolveParentViewport = pendingViewport\n+      // we know that the next item is a result if this item\n+      // was a resolver\n+      pendingViewport = resolversAndResults[i++] as Result<Viewport>\n+\n+      resolvePendingResult(resolvedViewport, resolveParentViewport)\n+    }\n+    // Otherwise the item was either null or a static export\n+\n+    let viewport: Viewport | null\n+    if (isPromiseLike(pendingViewport)) {\n+      viewport = await pendingViewport\n+    } else {\n+      viewport = pendingViewport\n+    }\n \n     mergeViewport({\n       target: resolvedViewport,\n@@ -948,3 +948,13 @@ export async function resolveViewport(\n   )\n   return accumulateViewport(metadataItems)\n }\n+\n+function isPromiseLike<T>(\n+  value: unknown | PromiseLike<T>\n+): value is PromiseLike<T> {\n+  return (\n+    typeof value === 'object' &&\n+    value !== null &&\n+    typeof (value as PromiseLike<unknown>).then === 'function'\n+  )\n+}"
        }
    ],
    "stats": {
        "total": 243,
        "additions": 129,
        "deletions": 114
    }
}