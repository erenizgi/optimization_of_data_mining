{
    "author": "acdlite",
    "message": "Re-implement Server Action reducer (#86367)\n\nRewrite of the Server Action reducer to use the PPR/Segment Cache\nnavigation implementation, rather than the old lazy fetch\nimplementation.\n\nServer Actions may trigger a revalidation, a redirect, or both. They may\nalso invalidate the cache. The behavior could be naively implemented\nusing router.refresh() and router.push(). Semantically, the routing\nbehavior is equivalent.\n\nThe main difference is that the server that invokes the action may also\nsend back new data for the page within the same response. Compared to a\nseparate request, this data is more likely to be consistent with any\ndata that may have been mutated by the action, due to global data\npropagation races. (It's also faster since it avoids an extra server\nwaterfall.)\n\nSo, navigations initiated by a Server action must be able to \"seed\" the\nnavigation with the data it just received from the server. I've added a\nnew internal method, navigateToSeededRoute, that implements this\nbehavior.",
    "sha": "e760fa231d913a93518f38ff94214b2d1defd751",
    "files": [
        {
            "sha": "43eedef8a4163e4c9f61d5d1a2e9d98ba40f2f8a",
            "filename": "packages/next/src/client/components/router-reducer/ppr-navigations.ts",
            "status": "modified",
            "additions": 78,
            "deletions": 3,
            "changes": 81,
            "blob_url": "https://github.com/vercel/next.js/blob/e760fa231d913a93518f38ff94214b2d1defd751/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fppr-navigations.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/e760fa231d913a93518f38ff94214b2d1defd751/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fppr-navigations.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fppr-navigations.ts?ref=e760fa231d913a93518f38ff94214b2d1defd751",
            "patch": "@@ -51,7 +51,7 @@ export type NavigationTask = {\n }\n \n export type NavigationRequestAccumulation = {\n-  scrollableSegments: Array<FlightSegmentPath>\n+  scrollableSegments: Array<FlightSegmentPath> | null\n   separateRefreshUrls: Set<string> | null\n }\n \n@@ -91,6 +91,8 @@ export function startPPRNavigation(\n   oldRouterState: FlightRouterState,\n   newRouterState: FlightRouterState,\n   shouldRefreshDynamicData: boolean,\n+  seedData: CacheNodeSeedData | null,\n+  seedHead: HeadData | null,\n   prefetchData: CacheNodeSeedData | null,\n   prefetchHead: HeadData | null,\n   isPrefetchHeadPartial: boolean,\n@@ -108,6 +110,8 @@ export function startPPRNavigation(\n     newRouterState,\n     shouldRefreshDynamicData,\n     didFindRootLayout,\n+    seedData,\n+    seedHead,\n     prefetchData,\n     prefetchHead,\n     isPrefetchHeadPartial,\n@@ -128,6 +132,8 @@ function updateCacheNodeOnNavigation(\n   newRouterState: FlightRouterState,\n   shouldRefreshDynamicData: boolean,\n   didFindRootLayout: boolean,\n+  seedData: CacheNodeSeedData | null,\n+  seedHead: HeadData | null,\n   prefetchData: CacheNodeSeedData | null,\n   prefetchHead: HeadData | null,\n   isPrefetchHeadPartial: boolean,\n@@ -193,6 +199,8 @@ function updateCacheNodeOnNavigation(\n       newRouterState,\n       oldCacheNode,\n       shouldRefreshDynamicData,\n+      seedData,\n+      seedHead,\n       prefetchData,\n       prefetchHead,\n       isPrefetchHeadPartial,\n@@ -216,6 +224,7 @@ function updateCacheNodeOnNavigation(\n \n   const newRouterStateChildren = newRouterState[1]\n   const oldRouterStateChildren = oldRouterState[1]\n+  const seedDataChildren = seedData !== null ? seedData[1] : null\n   const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null\n \n   // We're currently traversing the part of the tree that was also part of\n@@ -264,6 +273,28 @@ function updateCacheNodeOnNavigation(\n     // Reuse the existing CacheNode\n     newCacheNode = reuseDynamicCacheNode(oldCacheNode, newParallelRoutes)\n     needsDynamicRequest = false\n+  } else if (seedData !== null) {\n+    // If this navigation was the result of an action, then check if the\n+    // server sent back data in the action response. We should favor using\n+    // that, rather than performing a separate request. This is both better\n+    // for performance and it's more likely to be consistent with any\n+    // writes that were just performed by the action, compared to a\n+    // separate request.\n+    const seedRsc = seedData[0]\n+    const seedLoading = seedData[2]\n+    const isSeedRscPartial = false\n+    const isSeedHeadPartial = seedHead === null\n+    newCacheNode = readCacheNodeFromSeedData(\n+      seedRsc,\n+      seedLoading,\n+      isSeedRscPartial,\n+      seedHead,\n+      isSeedHeadPartial,\n+      isLeafSegment,\n+      newParallelRoutes,\n+      navigatedAt\n+    )\n+    needsDynamicRequest = isLeafSegment && isSeedHeadPartial\n   } else if (prefetchData !== null) {\n     // Consult the prefetch cache.\n     const prefetchRsc = prefetchData[0]\n@@ -357,12 +388,16 @@ function updateCacheNodeOnNavigation(\n       oldParallelRoutes !== undefined\n         ? oldParallelRoutes.get(parallelRouteKey)\n         : undefined\n+\n+    let seedDataChild: CacheNodeSeedData | void | null =\n+      seedDataChildren !== null ? seedDataChildren[parallelRouteKey] : null\n     let prefetchDataChild: CacheNodeSeedData | void | null =\n       prefetchDataChildren !== null\n         ? prefetchDataChildren[parallelRouteKey]\n         : null\n \n     let newSegmentChild = newRouterStateChild[0]\n+    let seedHeadChild = seedHead\n     let prefetchHeadChild = prefetchHead\n     let isPrefetchHeadPartialChild = isPrefetchHeadPartial\n     if (newSegmentChild === DEFAULT_SEGMENT_KEY) {\n@@ -377,6 +412,8 @@ function updateCacheNodeOnNavigation(\n \n       // Since we're switching to a different route tree, these are no\n       // longer valid, because they correspond to the outer tree.\n+      seedDataChild = null\n+      seedHeadChild = null\n       prefetchDataChild = null\n       prefetchHeadChild = null\n       isPrefetchHeadPartialChild = false\n@@ -396,6 +433,8 @@ function updateCacheNodeOnNavigation(\n       newRouterStateChild,\n       shouldRefreshDynamicData,\n       childDidFindRootLayout,\n+      seedDataChild ?? null,\n+      seedHeadChild,\n       prefetchDataChild ?? null,\n       prefetchHeadChild,\n       isPrefetchHeadPartialChild,\n@@ -421,7 +460,9 @@ function updateCacheNodeOnNavigation(\n     taskChildren.set(parallelRouteKey, taskChild)\n     const newCacheNodeChild = taskChild.node\n     if (newCacheNodeChild !== null) {\n-      const newSegmentMapChild: ChildSegmentMap = new Map(oldSegmentMapChild)\n+      const newSegmentMapChild: ChildSegmentMap = new Map(\n+        shouldRefreshDynamicData ? undefined : oldSegmentMapChild\n+      )\n       newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild)\n       newParallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n     }\n@@ -471,6 +512,8 @@ function createCacheNodeOnNavigation(\n   newRouterState: FlightRouterState,\n   oldCacheNode: CacheNode | void,\n   shouldRefreshDynamicData: boolean,\n+  seedData: CacheNodeSeedData | null,\n+  seedHead: HeadData | null,\n   prefetchData: CacheNodeSeedData | null,\n   prefetchHead: HeadData | null,\n   isPrefetchHeadPartial: boolean,\n@@ -497,6 +540,7 @@ function createCacheNodeOnNavigation(\n \n   const newRouterStateChildren = newRouterState[1]\n   const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null\n+  const seedDataChildren = seedData !== null ? seedData[1] : null\n   const oldParallelRoutes =\n     oldCacheNode !== undefined ? oldCacheNode.parallelRoutes : undefined\n   const newParallelRoutes = new Map(\n@@ -514,6 +558,9 @@ function createCacheNodeOnNavigation(\n     // TODO: We should use a string to represent the segment path instead of\n     // an array. We already use a string representation for the path when\n     // accessing the Segment Cache, so we can use the same one.\n+    if (accumulation.scrollableSegments === null) {\n+      accumulation.scrollableSegments = []\n+    }\n     accumulation.scrollableSegments.push(segmentPath)\n   }\n \n@@ -534,6 +581,28 @@ function createCacheNodeOnNavigation(\n     // Reuse the existing CacheNode\n     newCacheNode = reuseDynamicCacheNode(oldCacheNode, newParallelRoutes)\n     needsDynamicRequest = false\n+  } else if (seedData !== null) {\n+    // If this navigation was the result of an action, then check if the\n+    // server sent back data in the action response. We should favor using\n+    // that, rather than performing a separate request. This is both better\n+    // for performance and it's more likely to be consistent with any\n+    // writes that were just performed by the action, compared to a\n+    // separate request.\n+    const seedRsc = seedData[0]\n+    const seedLoading = seedData[2]\n+    const isSeedRscPartial = false\n+    const isSeedHeadPartial = seedHead === null\n+    newCacheNode = readCacheNodeFromSeedData(\n+      seedRsc,\n+      seedLoading,\n+      isSeedRscPartial,\n+      seedHead,\n+      isSeedHeadPartial,\n+      isLeafSegment,\n+      newParallelRoutes,\n+      navigatedAt\n+    )\n+    needsDynamicRequest = isLeafSegment && isSeedHeadPartial\n   } else if (prefetchData !== null) {\n     // Consult the prefetch cache.\n     const prefetchRsc = prefetchData[0]\n@@ -578,6 +647,8 @@ function createCacheNodeOnNavigation(\n       oldParallelRoutes !== undefined\n         ? oldParallelRoutes.get(parallelRouteKey)\n         : undefined\n+    const seedDataChild: CacheNodeSeedData | void | null =\n+      seedDataChildren !== null ? seedDataChildren[parallelRouteKey] : null\n     const prefetchDataChild: CacheNodeSeedData | void | null =\n       prefetchDataChildren !== null\n         ? prefetchDataChildren[parallelRouteKey]\n@@ -596,6 +667,8 @@ function createCacheNodeOnNavigation(\n       newRouterStateChild,\n       oldCacheNodeChild,\n       shouldRefreshDynamicData,\n+      seedDataChild ?? null,\n+      seedHead,\n       prefetchDataChild ?? null,\n       prefetchHead,\n       isPrefetchHeadPartial,\n@@ -611,7 +684,9 @@ function createCacheNodeOnNavigation(\n     taskChildren.set(parallelRouteKey, taskChild)\n     const newCacheNodeChild = taskChild.node\n     if (newCacheNodeChild !== null) {\n-      const newSegmentMapChild: ChildSegmentMap = new Map(oldSegmentMapChild)\n+      const newSegmentMapChild: ChildSegmentMap = new Map(\n+        shouldRefreshDynamicData ? undefined : oldSegmentMapChild\n+      )\n       newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild)\n       newParallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n     }"
        },
        {
            "sha": "b8df489e0da0336a594528fb39dd0d5c9d6dc3f6",
            "filename": "packages/next/src/client/components/router-reducer/reducers/navigate-reducer.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/e760fa231d913a93518f38ff94214b2d1defd751/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fnavigate-reducer.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/e760fa231d913a93518f38ff94214b2d1defd751/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fnavigate-reducer.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fnavigate-reducer.ts?ref=e760fa231d913a93518f38ff94214b2d1defd751",
            "patch": "@@ -161,12 +161,14 @@ export function navigateReducer(\n   // implementation. Eventually we'll rewrite the router reducer to a\n   // state machine.\n   const currentUrl = new URL(state.canonicalUrl, location.origin)\n+  const shouldRefreshDynamicData = false\n   const result = navigateUsingSegmentCache(\n     url,\n     currentUrl,\n     state.cache,\n     state.tree,\n     state.nextUrl,\n+    shouldRefreshDynamicData,\n     shouldScroll,\n     mutable\n   )"
        },
        {
            "sha": "20242629a0d43707189ec6f4c418bcfa662d76b9",
            "filename": "packages/next/src/client/components/router-reducer/reducers/refresh-reducer.ts",
            "status": "modified",
            "additions": 31,
            "deletions": 6,
            "changes": 37,
            "blob_url": "https://github.com/vercel/next.js/blob/e760fa231d913a93518f38ff94214b2d1defd751/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Frefresh-reducer.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/e760fa231d913a93518f38ff94214b2d1defd751/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Frefresh-reducer.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Frefresh-reducer.ts?ref=e760fa231d913a93518f38ff94214b2d1defd751",
            "patch": "@@ -5,8 +5,9 @@ import type {\n   RefreshAction,\n } from '../router-reducer-types'\n import { handleNavigationResult } from './navigate-reducer'\n-import { refresh as refreshUsingSegmentCache } from '../../segment-cache/navigation'\n+import { navigateToSeededRoute } from '../../segment-cache/navigation'\n import { revalidateEntireCache } from '../../segment-cache/cache'\n+import { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'\n \n export function refreshReducer(\n   state: ReadonlyReducerState,\n@@ -19,14 +20,38 @@ export function refreshReducer(\n   const currentRouterState = state.tree\n   revalidateEntireCache(currentNextUrl, currentRouterState)\n \n+  // We always send the last next-url, not the current when performing a dynamic\n+  // request. This is because we update the next-url after a navigation, but we\n+  // want the same interception route to be matched that used the last next-url.\n+  const nextUrlForRefresh = hasInterceptionRouteInCurrentTree(state.tree)\n+    ? state.previousNextUrl || currentNextUrl\n+    : null\n+\n+  // A refresh is modeled as a navigation to the current URL, but where any\n+  // existing dynamic data (including in shared layouts) is re-fetched.\n   const currentUrl = new URL(state.canonicalUrl, action.origin)\n-  const result = refreshUsingSegmentCache(\n+  const url = currentUrl\n+  const currentFlightRouterState = state.tree\n+  const shouldScroll = true\n+  const shouldRefreshDynamicData = true\n+\n+  const seedFlightRouterState = state.tree\n+  const seedRenderedSearch = state.renderedSearch\n+  const seedData = null\n+  const seedHead = null\n+\n+  const result = navigateToSeededRoute(\n+    url,\n     currentUrl,\n     state.cache,\n-    state.tree,\n-    state.nextUrl,\n-    state.renderedSearch,\n-    state.canonicalUrl\n+    currentFlightRouterState,\n+    seedFlightRouterState,\n+    seedRenderedSearch,\n+    seedData,\n+    seedHead,\n+    shouldRefreshDynamicData,\n+    nextUrlForRefresh,\n+    shouldScroll\n   )\n \n   const mutable: Mutable = {}"
        },
        {
            "sha": "4cf354d3e6375409136fc1849ff2e39e10de3a63",
            "filename": "packages/next/src/client/components/router-reducer/reducers/server-action-reducer.ts",
            "status": "modified",
            "additions": 155,
            "deletions": 143,
            "changes": 298,
            "blob_url": "https://github.com/vercel/next.js/blob/e760fa231d913a93518f38ff94214b2d1defd751/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fserver-action-reducer.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/e760fa231d913a93518f38ff94214b2d1defd751/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fserver-action-reducer.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fserver-action-reducer.ts?ref=e760fa231d913a93518f38ff94214b2d1defd751",
            "patch": "@@ -32,16 +32,8 @@ import type {\n } from '../router-reducer-types'\n import { assignLocation } from '../../../assign-location'\n import { createHrefFromUrl } from '../create-href-from-url'\n-import { handleExternalUrl } from './navigate-reducer'\n-import { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\n-import { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\n-import type { CacheNode } from '../../../../shared/lib/app-router-types'\n-import { handleMutable } from '../handle-mutable'\n-import { fillLazyItemsTillLeafWithHead } from '../fill-lazy-items-till-leaf-with-head'\n-import { createEmptyCacheNode } from '../../app-router'\n+import { handleExternalUrl, handleNavigationResult } from './navigate-reducer'\n import { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'\n-import { handleSegmentMismatch } from '../handle-segment-mismatch'\n-import { refreshInactiveParallelSegments } from '../refetch-inactive-parallel-segments'\n import {\n   normalizeFlightData,\n   prepareFlightRouterStateForRequest,\n@@ -57,6 +49,11 @@ import {\n } from '../../../../shared/lib/server-reference-info'\n import { revalidateEntireCache } from '../../segment-cache/cache'\n import { getDeploymentId } from '../../../../shared/lib/deployment-id'\n+import {\n+  navigateToSeededRoute,\n+  navigate as navigateUsingSegmentCache,\n+} from '../../segment-cache/navigation'\n+import type { NormalizedSearch } from '../../segment-cache/cache-key'\n \n const createFromFetch =\n   createFromFetchBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromFetch']\n@@ -74,11 +71,16 @@ if (\n   ).createDebugChannel\n }\n \n+// TODO: Refactor to be a discriminated union. Or just get rid of it;\n+// fetchServerAction only has one caller, no reason this intermediate type has\n+// to exist.\n type FetchServerActionResult = {\n   redirectLocation: URL | undefined\n   redirectType: RedirectType | undefined\n   actionResult: ActionResult | undefined\n   actionFlightData: NormalizedFlightData[] | string | undefined\n+  actionFlightDataRenderedSearch: NormalizedSearch | undefined\n+  actionFlightDataCouldBeIntercepted: boolean | undefined\n   isPrerender: boolean\n   revalidatedParts: {\n     tag: boolean\n@@ -166,7 +168,7 @@ async function fetchServerAction(\n     revalidatedParts = {\n       paths: revalidatedHeader[0] || [],\n       tag: !!revalidatedHeader[1],\n-      cookie: revalidatedHeader[2],\n+      cookie: !!revalidatedHeader[2],\n     }\n   } catch (e) {\n     revalidatedParts = NO_REVALIDATED_PARTS\n@@ -200,6 +202,8 @@ async function fetchServerAction(\n \n   let actionResult: FetchServerActionResult['actionResult']\n   let actionFlightData: FetchServerActionResult['actionFlightData']\n+  let actionFlightDataRenderedSearch: FetchServerActionResult['actionFlightDataRenderedSearch']\n+  let actionFlightDataCouldBeIntercepted: FetchServerActionResult['actionFlightDataCouldBeIntercepted']\n \n   if (isRscResponse) {\n     const response: ActionFlightResponse = await createFromFetch(\n@@ -214,16 +218,25 @@ async function fetchServerAction(\n \n     // An internal redirect can send an RSC response, but does not have a useful `actionResult`.\n     actionResult = redirectLocation ? undefined : response.a\n-    actionFlightData = normalizeFlightData(response.f)\n+    const maybeFlightData = normalizeFlightData(response.f)\n+    if (maybeFlightData !== '') {\n+      actionFlightData = maybeFlightData\n+      actionFlightDataRenderedSearch = response.q as NormalizedSearch\n+      actionFlightDataCouldBeIntercepted = response.i\n+    }\n   } else {\n     // An external redirect doesn't contain RSC data.\n     actionResult = undefined\n     actionFlightData = undefined\n+    actionFlightDataRenderedSearch = undefined\n+    actionFlightDataCouldBeIntercepted = undefined\n   }\n \n   return {\n     actionResult,\n     actionFlightData,\n+    actionFlightDataRenderedSearch,\n+    actionFlightDataCouldBeIntercepted,\n     redirectLocation,\n     redirectType,\n     revalidatedParts,\n@@ -248,8 +261,6 @@ export function serverActionReducer(\n   const { resolve, reject } = action\n   const mutable: ServerActionMutable = {}\n \n-  let currentTree = state.tree\n-\n   mutable.preserveCustomHistoryState = false\n \n   // only pass along the `nextUrl` param (used for interception routes) if the current route was intercepted.\n@@ -267,161 +278,47 @@ export function serverActionReducer(\n       ? state.previousNextUrl || state.nextUrl\n       : null\n \n-  const navigatedAt = Date.now()\n-\n   return fetchServerAction(state, nextUrl, action).then(\n     async ({\n       actionResult,\n       actionFlightData: flightData,\n+      actionFlightDataRenderedSearch: flightDataRenderedSearch,\n+      actionFlightDataCouldBeIntercepted: flightDataCouldBeIntercepted,\n       redirectLocation,\n       redirectType,\n       revalidatedParts,\n     }) => {\n-      let redirectHref: string | undefined\n-\n-      // honor the redirect type instead of defaulting to push in case of server actions.\n-      if (redirectLocation) {\n-        if (redirectType === RedirectType.replace) {\n-          state.pushRef.pendingPush = false\n-          mutable.pendingPush = false\n-        } else {\n-          state.pushRef.pendingPush = true\n-          mutable.pendingPush = true\n-        }\n-\n-        redirectHref = createHrefFromUrl(redirectLocation, false)\n-        mutable.canonicalUrl = redirectHref\n-      }\n-\n-      if (!flightData) {\n-        resolve(actionResult)\n-\n-        // If there is a redirect but no flight data we need to do a mpaNavigation.\n-        if (redirectLocation) {\n-          return handleExternalUrl(\n-            state,\n-            mutable,\n-            redirectLocation.href,\n-            state.pushRef.pendingPush\n-          )\n-        }\n-        return state\n-      }\n-\n-      if (typeof flightData === 'string') {\n-        // Handle case when navigating to page in `pages` from `app`\n-        resolve(actionResult)\n-\n-        return handleExternalUrl(\n-          state,\n-          mutable,\n-          flightData,\n-          state.pushRef.pendingPush\n-        )\n-      }\n-\n-      const actionRevalidated =\n+      const actionDidRevalidateCache =\n         revalidatedParts.paths.length > 0 ||\n         revalidatedParts.tag ||\n         revalidatedParts.cookie\n \n-      // Store whether this action triggered any revalidation\n-      // The action queue will use this information to potentially\n-      // trigger a refresh action if the action was discarded\n-      // (ie, due to a navigation, before the action completed)\n-      if (actionRevalidated) {\n+      if (actionDidRevalidateCache) {\n+        // Store whether this action triggered any revalidation\n+        // The action queue will use this information to potentially\n+        // trigger a refresh action if the action was discarded\n+        // (ie, due to a navigation, before the action completed)\n         action.didRevalidate = true\n-      }\n-\n-      for (const normalizedFlightData of flightData) {\n-        const {\n-          tree: treePatch,\n-          seedData: cacheNodeSeedData,\n-          head,\n-          isRootRender,\n-        } = normalizedFlightData\n-\n-        if (!isRootRender) {\n-          // TODO-APP: handle this case better\n-          console.log('SERVER ACTION APPLY FAILED')\n-          resolve(actionResult)\n-\n-          return state\n-        }\n-\n-        // Given the path can only have two items the items are only the router state and rsc for the root.\n-        const newTree = applyRouterStatePatchToTree(\n-          // TODO-APP: remove ''\n-          [''],\n-          currentTree,\n-          treePatch,\n-          redirectHref ? redirectHref : state.canonicalUrl\n-        )\n-\n-        if (newTree === null) {\n-          resolve(actionResult)\n \n-          return handleSegmentMismatch(state, action, treePatch)\n-        }\n-\n-        if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n-          resolve(actionResult)\n-\n-          return handleExternalUrl(\n-            state,\n-            mutable,\n-            redirectHref || state.canonicalUrl,\n-            state.pushRef.pendingPush\n-          )\n-        }\n-\n-        // The server sent back RSC data for the server action, so we need to apply it to the cache.\n-        if (cacheNodeSeedData !== null) {\n-          const rsc = cacheNodeSeedData[0]\n-          const cache: CacheNode = createEmptyCacheNode()\n-          cache.rsc = rsc\n-          cache.prefetchRsc = null\n-          cache.loading = cacheNodeSeedData[2]\n-          fillLazyItemsTillLeafWithHead(\n-            navigatedAt,\n-            cache,\n-            // Existing cache is not passed in as server actions have to invalidate the entire cache.\n-            undefined,\n-            treePatch,\n-            cacheNodeSeedData,\n-            head\n-          )\n-\n-          mutable.cache = cache\n-          revalidateEntireCache(state.nextUrl, newTree)\n-          if (actionRevalidated) {\n-            await refreshInactiveParallelSegments({\n-              navigatedAt,\n-              state,\n-              updatedTree: newTree,\n-              updatedCache: cache,\n-              includeNextUrl: Boolean(nextUrl),\n-              canonicalUrl: mutable.canonicalUrl || state.canonicalUrl,\n-            })\n-          }\n-        }\n-\n-        mutable.patchedTree = newTree\n-        currentTree = newTree\n+        // If there was a revalidation, evict the entire prefetch cache.\n+        // TODO: Evict only segments with matching tags and/or paths.\n+        revalidateEntireCache(nextUrl, state.tree)\n       }\n \n-      if (redirectLocation && redirectHref) {\n+      if (redirectLocation !== undefined) {\n         // If the action triggered a redirect, the action promise will be rejected with\n         // a redirect so that it's handled by RedirectBoundary as we won't have a valid\n         // action result to resolve the promise with. This will effectively reset the state of\n         // the component that called the action as the error boundary will remount the tree.\n         // The status code doesn't matter here as the action handler will have already sent\n         // a response with the correct status code.\n+        const redirectHref = createHrefFromUrl(redirectLocation, false)\n+        const resolvedRedirectType = redirectType || RedirectType.push\n         const redirectError = getRedirectError(\n           hasBasePath(redirectHref)\n             ? removeBasePath(redirectHref)\n             : redirectHref,\n-          redirectType || RedirectType.push\n+          resolvedRedirectType\n         )\n         // We mark the error as handled because we don't want the redirect to be tried later by\n         // the RedirectBoundary, in case the user goes back and `Activity` triggers the redirect\n@@ -431,10 +328,125 @@ export function serverActionReducer(\n         ;(redirectError as any).handled = true\n         reject(redirectError)\n       } else {\n+        // If there's no redirect, resolve the action with the result.\n         resolve(actionResult)\n       }\n \n-      return handleMutable(state, mutable)\n+      const pendingPush = redirectType !== RedirectType.replace\n+      state.pushRef.pendingPush = pendingPush\n+      mutable.pendingPush = pendingPush\n+\n+      // Check if we can bail out without updating any state.\n+      if (\n+        // Did the action trigger a redirect?\n+        redirectLocation === undefined &&\n+        // Did the action revalidate any data?\n+        !actionDidRevalidateCache &&\n+        // Did the server render new data?\n+        flightData === undefined\n+      ) {\n+        // The action did not trigger any revalidations or redirects. No\n+        // navigation is required.\n+        return state\n+      }\n+\n+      if (flightData === undefined && redirectLocation !== undefined) {\n+        // The server redirected, but did not send any Flight data. This implies\n+        // an external redirect.\n+        // TODO: We should refactor the action response type to be more explicit\n+        // about the various response types.\n+        return handleExternalUrl(\n+          state,\n+          mutable,\n+          redirectLocation.href,\n+          pendingPush\n+        )\n+      }\n+\n+      if (typeof flightData === 'string') {\n+        // If the flight data is just a string, something earlier in the\n+        // response handling triggered an external redirect.\n+        return handleExternalUrl(state, mutable, flightData, pendingPush)\n+      }\n+\n+      // The action triggered a navigation — either a redirect, a revalidation,\n+      // or both.\n+\n+      // If there was no redirect, then the target URL is the same as the\n+      // current URL.\n+      const currentUrl = new URL(state.canonicalUrl, location.origin)\n+      const redirectUrl =\n+        redirectLocation !== undefined ? redirectLocation : currentUrl\n+      const currentFlightRouterState = state.tree\n+      const shouldScroll = true\n+\n+      // If the action triggered a revalidation of the cache, we should also\n+      // refresh all the dynamic data.\n+      const shouldRefreshDynamicData = actionDidRevalidateCache\n+\n+      // The server may have sent back new data. If so, we will perform a\n+      // \"seeded\" navigation that uses the data from the response.\n+      if (flightData !== undefined) {\n+        const normalizedFlightData = flightData[0]\n+        if (\n+          normalizedFlightData !== undefined &&\n+          // TODO: Currently the server always renders from the root in\n+          // response to a Server Action. In the case of a normal redirect\n+          // with no revalidation, it should skip over the shared layouts.\n+          normalizedFlightData.isRootRender &&\n+          flightDataRenderedSearch !== undefined &&\n+          flightDataCouldBeIntercepted !== undefined\n+        ) {\n+          // The server sent back new route data as part of the response. We\n+          // will use this to render the new page. If this happens to be only a\n+          // subset of the data needed to render the new page, we'll initiate a\n+          // new fetch, like we would for a normal navigation.\n+          const seedFlightRouterState = normalizedFlightData.tree\n+          const seedRenderedSearch = flightDataRenderedSearch\n+          const seedData = normalizedFlightData.seedData\n+          const seedHead = normalizedFlightData.head\n+          const result = navigateToSeededRoute(\n+            redirectUrl,\n+            currentUrl,\n+            state.cache,\n+            currentFlightRouterState,\n+            seedFlightRouterState,\n+            seedRenderedSearch,\n+            seedData,\n+            seedHead,\n+            shouldRefreshDynamicData,\n+            nextUrl,\n+            shouldScroll\n+          )\n+          return handleNavigationResult(\n+            redirectUrl,\n+            state,\n+            mutable,\n+            pendingPush,\n+            result\n+          )\n+        }\n+      }\n+\n+      // The server did not send back new data. We'll perform a regular, non-\n+      // seeded navigation — effectively the same as <Link> or router.push().\n+      const result = navigateUsingSegmentCache(\n+        redirectUrl,\n+        currentUrl,\n+        state.cache,\n+        currentFlightRouterState,\n+        nextUrl,\n+        shouldRefreshDynamicData,\n+        shouldScroll,\n+        mutable\n+      )\n+      return handleNavigationResult(\n+        redirectUrl,\n+        state,\n+        mutable,\n+        pendingPush,\n+        result\n+      )\n     },\n     (e: any) => {\n       // When the server action is rejected we don't update the state and instead call the reject handler of the promise."
        },
        {
            "sha": "3ce368e71a7baabd542141801b1224a07cd24213",
            "filename": "packages/next/src/client/components/segment-cache/navigation.ts",
            "status": "modified",
            "additions": 65,
            "deletions": 61,
            "changes": 126,
            "blob_url": "https://github.com/vercel/next.js/blob/e760fa231d913a93518f38ff94214b2d1defd751/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fnavigation.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/e760fa231d913a93518f38ff94214b2d1defd751/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fnavigation.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fnavigation.ts?ref=e760fa231d913a93518f38ff94214b2d1defd751",
            "patch": "@@ -29,7 +29,6 @@ import {\n import { createCacheKey } from './cache-key'\n import { addSearchParamsIfPageSegment } from '../../../shared/lib/segment'\n import { NavigationResultTag } from './types'\n-import { hasInterceptionRouteInCurrentTree } from '../router-reducer/reducers/has-interception-route-in-current-tree'\n \n type MPANavigationResult = {\n   tag: NavigationResultTag.MPA\n@@ -73,6 +72,7 @@ export function navigate(\n   currentCacheNode: CacheNode | null,\n   currentFlightRouterState: FlightRouterState,\n   nextUrl: string | null,\n+  shouldRefreshDynamicData: boolean,\n   shouldScroll: boolean,\n   accumulation: { collectedDebugInfo?: Array<unknown> }\n ): NavigationResult {\n@@ -97,13 +97,7 @@ export function navigate(\n   // Also note that this only refreshes the dynamic data, not static/ cached\n   // data. If the page segment is fully static and prefetched, the request is\n   // skipped. (This is also how refresh() works.)\n-  const isSamePageNavigation =\n-    // TODO: This is not the only place we read from the location, but we should\n-    // consider storing the current URL in the router state instead of reading\n-    // from the location object. In practice I don't think this matters much\n-    // since we keep them in sync anyway, but having two sources of truth can\n-    // lead to subtle bugs and race conditions.\n-    href === window.location.href\n+  const isSamePageNavigation = href === currentUrl.href\n \n   const cacheKey = createCacheKey(href, nextUrl)\n   const route = readRouteCacheEntry(now, cacheKey)\n@@ -137,6 +131,7 @@ export function navigate(\n       isPrefetchHeadPartial,\n       newCanonicalUrl,\n       renderedSearch,\n+      shouldRefreshDynamicData,\n       shouldScroll,\n       url.hash\n     )\n@@ -181,6 +176,7 @@ export function navigate(\n         isPrefetchHeadPartial,\n         newCanonicalUrl,\n         newRenderedSearch,\n+        shouldRefreshDynamicData,\n         shouldScroll,\n         url.hash\n       )\n@@ -202,89 +198,75 @@ export function navigate(\n       isSamePageNavigation,\n       currentCacheNode,\n       currentFlightRouterState,\n+      shouldRefreshDynamicData,\n       shouldScroll,\n       url.hash,\n       collectedDebugInfo\n     ),\n   }\n }\n \n-export function refresh(\n+export function navigateToSeededRoute(\n+  url: URL,\n   currentUrl: URL,\n   currentCacheNode: CacheNode,\n   currentFlightRouterState: FlightRouterState,\n-  currentNextUrl: string | null,\n-  currentRenderedSearch: string,\n-  currentCanonicalUrl: string\n+  seedFlightRouterState: FlightRouterState,\n+  seedRenderedSearch: string,\n+  seedData: CacheNodeSeedData | null,\n+  seedHead: HeadData | null,\n+  shouldRefreshDynamicData: boolean,\n+  nextUrl: string | null,\n+  shouldScroll: boolean\n ): SuccessfulNavigationResult | MPANavigationResult {\n-  // A refresh is a special case of a navigation where all the dynamic data\n-  // on the current router is re-fetched. Most of the logic is handled within\n-  // the ppr-navigations module. The main difference here is that we set\n-  // shouldRefreshDynamicData to true.\n+  // A version of navigate() that accepts the target route tree as an argument\n+  // rather than reading it from the prefetch cache.\n   const now = Date.now()\n-  const shouldScroll = true\n+  const canonicalUrl = createHrefFromUrl(url)\n   const accumulation: NavigationRequestAccumulation = {\n-    scrollableSegments: [],\n+    scrollableSegments: null,\n     separateRefreshUrls: null,\n   }\n-  const shouldRefreshDynamicData = true\n+  const isSamePageNavigation = url.href === currentUrl.href\n   const task = startPPRNavigation(\n     now,\n     currentUrl,\n     currentCacheNode,\n     currentFlightRouterState,\n-    currentFlightRouterState,\n+    seedFlightRouterState,\n     shouldRefreshDynamicData,\n+    seedData,\n+    seedHead,\n     null,\n     null,\n     false,\n-    true,\n+    isSamePageNavigation,\n     accumulation\n   )\n   if (task !== null) {\n     if (task.dynamicRequestTree !== null) {\n-      // If the current tree was intercepted, the nextUrl should be included in\n-      // the request. This is to ensure that the refresh request doesn't get\n-      // intercepted, accidentally triggering the interception route.\n-      // TODO: This logic was copied from the old implementation. It works, but\n-      // a simpler way to model this would be to track whether any navigation\n-      // has occurred since the initial (SSR) navigation, since that's the only\n-      // one that should not be intercepted.\n-      const includeNextUrl = hasInterceptionRouteInCurrentTree(\n-        currentFlightRouterState\n-      )\n       listenForDynamicRequest(\n-        currentUrl,\n-        includeNextUrl ? currentNextUrl : null,\n+        url,\n+        nextUrl,\n         task,\n         task.dynamicRequestTree,\n         null,\n         accumulation\n       )\n     }\n-\n-    const newTree = task.route\n-    const newCacheNode = task.node\n-    // Re-render with the new data. All the other data remains the same.\n-    return {\n-      tag: NavigationResultTag.Success,\n-      data: {\n-        flightRouterState: newTree,\n-        cacheNode: newCacheNode,\n-        canonicalUrl: currentCanonicalUrl,\n-        renderedSearch: currentRenderedSearch,\n-        // During a refresh, we don't set the `scrollableSegments`. See\n-        // corresponding comment in navigate-reducer.ts for context.\n-        scrollableSegments: null,\n-        shouldScroll,\n-        hash: currentUrl.hash,\n-      },\n-    }\n+    return navigationTaskToResult(\n+      task,\n+      canonicalUrl,\n+      seedRenderedSearch,\n+      accumulation.scrollableSegments,\n+      shouldScroll,\n+      url.hash\n+    )\n   }\n   // Could not perform a SPA navigation. Revert to a full-page (MPA) navigation.\n   return {\n     tag: NavigationResultTag.MPA,\n-    data: currentCanonicalUrl,\n+    data: canonicalUrl,\n   }\n }\n \n@@ -302,6 +284,7 @@ function navigateUsingPrefetchedRouteTree(\n   isPrefetchHeadPartial: boolean,\n   canonicalUrl: string,\n   renderedSearch: string,\n+  shouldRefreshDynamicData: boolean,\n   shouldScroll: boolean,\n   hash: string\n ): SuccessfulNavigationResult | MPANavigationResult {\n@@ -312,17 +295,20 @@ function navigateUsingPrefetchedRouteTree(\n   // read from the Segment Cache directly. It's only structured this way for now\n   // so we can share code with the old prefetching implementation.\n   const accumulation: NavigationRequestAccumulation = {\n-    scrollableSegments: [],\n+    scrollableSegments: null,\n     separateRefreshUrls: null,\n   }\n-  const shouldRefreshDynamicData = false\n+  const seedData = null\n+  const seedHead = null\n   const task = startPPRNavigation(\n     now,\n     currentUrl,\n     currentCacheNode,\n     currentFlightRouterState,\n     prefetchFlightRouterState,\n     shouldRefreshDynamicData,\n+    seedData,\n+    seedHead,\n     prefetchSeedData,\n     prefetchHead,\n     isPrefetchHeadPartial,\n@@ -360,7 +346,7 @@ function navigationTaskToResult(\n   task: NavigationTask,\n   canonicalUrl: string,\n   renderedSearch: string,\n-  scrollableSegments: Array<FlightSegmentPath>,\n+  scrollableSegments: Array<FlightSegmentPath> | null,\n   shouldScroll: boolean,\n   hash: string\n ): SuccessfulNavigationResult | MPANavigationResult {\n@@ -506,6 +492,18 @@ function readHeadSnapshotFromCache(\n   return { rsc, isPartial }\n }\n \n+// Used to request all the dynamic data for a route, rather than just a subset,\n+// e.g. during a refresh or a revalidation. Typically this gets constructed\n+// during the normal flow when diffing the route tree, but for an unprefetched\n+// navigation, where we don't know the structure of the target route, we use\n+// this instead.\n+const DynamicRequestTreeForEntireRoute: FlightRouterState = [\n+  '',\n+  {},\n+  null,\n+  'refetch',\n+]\n+\n async function navigateDynamicallyWithNoPrefetch(\n   now: number,\n   url: URL,\n@@ -514,6 +512,7 @@ async function navigateDynamicallyWithNoPrefetch(\n   isSamePageNavigation: boolean,\n   currentCacheNode: CacheNode | null,\n   currentFlightRouterState: FlightRouterState,\n+  shouldRefreshDynamicData: boolean,\n   shouldScroll: boolean,\n   hash: string,\n   collectedDebugInfo: Array<unknown>\n@@ -531,7 +530,9 @@ async function navigateDynamicallyWithNoPrefetch(\n   // navigation), except we use a single server response for both stages.\n \n   const promiseForDynamicServerResponse = fetchServerResponse(url, {\n-    flightRouterState: currentFlightRouterState,\n+    flightRouterState: shouldRefreshDynamicData\n+      ? DynamicRequestTreeForEntireRoute\n+      : currentFlightRouterState,\n     nextUrl,\n   })\n   const result = await promiseForDynamicServerResponse\n@@ -562,26 +563,29 @@ async function navigateDynamicallyWithNoPrefetch(\n     flightData\n   )\n \n-  // In our simulated prefetch payload, we pretend that there's no seed data\n+  // In our simulated prefetch payload, we pretend that there's no prefetch data\n   // nor a prefetch head.\n-  const prefetchSeedData = null\n+  const seedData = null\n+  const seedHead = null\n+  const prefetchData = null\n   const prefetchHead = null\n   const isPrefetchHeadPartial = true\n \n   // Now we proceed exactly as we would for normal navigation.\n   const accumulation: NavigationRequestAccumulation = {\n-    scrollableSegments: [],\n+    scrollableSegments: null,\n     separateRefreshUrls: null,\n   }\n-  const shouldRefreshDynamicData = false\n   const task = startPPRNavigation(\n     now,\n     currentUrl,\n     currentCacheNode,\n     currentFlightRouterState,\n     prefetchFlightRouterState,\n     shouldRefreshDynamicData,\n-    prefetchSeedData,\n+    seedData,\n+    seedHead,\n+    prefetchData,\n     prefetchHead,\n     isPrefetchHeadPartial,\n     isSamePageNavigation,"
        },
        {
            "sha": "b21bf2dc5be5a10b29611b385a6e3a39f3473a34",
            "filename": "packages/next/src/server/app-render/app-render.tsx",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/e760fa231d913a93518f38ff94214b2d1defd751/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/e760fa231d913a93518f38ff94214b2d1defd751/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx?ref=e760fa231d913a93518f38ff94214b2d1defd751",
            "patch": "@@ -532,6 +532,10 @@ async function generateDynamicRSCPayload(\n     ).map((path) => path.slice(1)) // remove the '' (root) segment\n   }\n \n+  const varyHeader = ctx.res.getHeader('vary')\n+  const couldBeIntercepted =\n+    typeof varyHeader === 'string' && varyHeader.includes(NEXT_URL)\n+\n   // If we have an action result, then this is a server action response.\n   // We can rely on this because `ActionResult` will always be a promise, even if\n   // the result is falsey.\n@@ -540,13 +544,17 @@ async function generateDynamicRSCPayload(\n       a: options.actionResult,\n       f: flightData,\n       b: ctx.sharedContext.buildId,\n+      q: getRenderedSearch(query),\n+      i: !!couldBeIntercepted,\n     }\n   }\n \n   // Otherwise, it's a regular RSC response.\n   const baseResponse = {\n     b: ctx.sharedContext.buildId,\n     f: flightData,\n+    q: getRenderedSearch(query),\n+    i: !!couldBeIntercepted,\n     S: workStore.isStaticGeneration,\n   }\n "
        },
        {
            "sha": "6d28eee58931b407a09cc0113efd2f22c5b67e80",
            "filename": "packages/next/src/shared/lib/app-router-types.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/e760fa231d913a93518f38ff94214b2d1defd751/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fapp-router-types.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/e760fa231d913a93518f38ff94214b2d1defd751/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fapp-router-types.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fapp-router-types.ts?ref=e760fa231d913a93518f38ff94214b2d1defd751",
            "patch": "@@ -300,6 +300,10 @@ export type NavigationFlightResponse = {\n   f: FlightData\n   /** prerendered */\n   S: boolean\n+  /** renderedSearch */\n+  q: string\n+  /** couldBeIntercepted */\n+  i: boolean\n   /** runtimePrefetch - [isPartial, staleTime]. Only present in runtime prefetch responses. */\n   rp?: [boolean, number]\n }\n@@ -312,6 +316,10 @@ export type ActionFlightResponse = {\n   b: string\n   /** flightData */\n   f: FlightData\n+  /** renderedSearch */\n+  q: string\n+  /** couldBeIntercepted */\n+  i: boolean\n }\n \n export type RSCPayload ="
        }
    ],
    "stats": {
        "total": 560,
        "additions": 347,
        "deletions": 213
    }
}