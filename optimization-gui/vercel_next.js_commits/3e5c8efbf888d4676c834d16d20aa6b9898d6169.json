{
    "author": "sokra",
    "message": "Turbopack: delete broken hmr benchmark (#83882)\n\n### What?\n\nThe benchmark is very broken:\n\n* It doesn't await the run_once, so the code never runs\n* project_path is incorrect so it doesn't find routes\n* The returned Duration is never used as divan doesn't support custom benches\n* `hmr_update` doesn't wait for an HMR update to happen as it just returns \"no update\"\n* It uses `\"next\": \"^15.0.0\"` so JS and Rust code are incompatible with each other\n\nIt's easier to remove the benchmark than to fix it. It never worked anyway.\n\nEventually we probably want a e2e benchmark running next.js anyway.",
    "sha": "3e5c8efbf888d4676c834d16d20aa6b9898d6169",
    "files": [
        {
            "sha": "3f7c5339ed01559698d97238933e6833a247aa50",
            "filename": ".github/workflows/turbopack-benchmark.yml",
            "status": "modified",
            "additions": 0,
            "deletions": 23,
            "changes": 23,
            "blob_url": "https://github.com/vercel/next.js/blob/3e5c8efbf888d4676c834d16d20aa6b9898d6169/.github%2Fworkflows%2Fturbopack-benchmark.yml",
            "raw_url": "https://github.com/vercel/next.js/raw/3e5c8efbf888d4676c834d16d20aa6b9898d6169/.github%2Fworkflows%2Fturbopack-benchmark.yml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/.github%2Fworkflows%2Fturbopack-benchmark.yml?ref=3e5c8efbf888d4676c834d16d20aa6b9898d6169",
            "patch": "@@ -27,29 +27,6 @@ env:\n   TURBO_TOKEN: ${{ secrets.HOSTED_TURBO_TOKEN }}\n \n jobs:\n-  benchmark-tiny:\n-    name: Benchmark Rust Crates (tiny)\n-    runs-on: ubuntu-latest\n-    steps:\n-      - uses: actions/checkout@v4\n-\n-      - name: Setup Rust toolchain\n-        uses: ./.github/actions/setup-rust\n-\n-      - name: Install cargo-codspeed\n-        uses: taiki-e/install-action@v2\n-        with:\n-          tool: cargo-codspeed@2.10.1\n-\n-      - name: Build app build benchmarks\n-        run: cargo codspeed build -p next-api\n-\n-      - name: Run the benchmarks\n-        uses: CodSpeedHQ/action@v3\n-        with:\n-          run: cargo codspeed run\n-          token: ${{ secrets.CODSPEED_TOKEN }}\n-\n   benchmark-small-apps:\n     name: Benchmark Rust Crates (small apps)\n     runs-on: ['self-hosted', 'linux', 'x64', 'metal']"
        },
        {
            "sha": "c40c5b0a2a39cd767f4ad0910ae263b02531b5fb",
            "filename": "Cargo.lock",
            "status": "modified",
            "additions": 0,
            "deletions": 74,
            "changes": 74,
            "blob_url": "https://github.com/vercel/next.js/blob/3e5c8efbf888d4676c834d16d20aa6b9898d6169/Cargo.lock",
            "raw_url": "https://github.com/vercel/next.js/raw/3e5c8efbf888d4676c834d16d20aa6b9898d6169/Cargo.lock",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/Cargo.lock?ref=3e5c8efbf888d4676c834d16d20aa6b9898d6169",
            "patch": "@@ -1124,7 +1124,6 @@ dependencies = [\n  \"anstyle\",\n  \"clap_lex\",\n  \"strsim 0.11.1\",\n- \"terminal_size\",\n ]\n \n [[package]]\n@@ -1223,46 +1222,6 @@ dependencies = [\n  \"walkdir\",\n ]\n \n-[[package]]\n-name = \"codspeed-divan-compat\"\n-version = \"3.0.5\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"adf64eda57508448d59efd940bad62ede7c50b0d451a150b8d6a0eca642792a6\"\n-dependencies = [\n- \"codspeed\",\n- \"codspeed-divan-compat-macros\",\n- \"codspeed-divan-compat-walltime\",\n-]\n-\n-[[package]]\n-name = \"codspeed-divan-compat-macros\"\n-version = \"3.0.5\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"058167258e819b16a4ba601fdfe270349ef191154758dbce122c62a698f70ba8\"\n-dependencies = [\n- \"divan-macros\",\n- \"itertools 0.14.0\",\n- \"proc-macro-crate\",\n- \"proc-macro2\",\n- \"quote\",\n- \"syn 2.0.104\",\n-]\n-\n-[[package]]\n-name = \"codspeed-divan-compat-walltime\"\n-version = \"3.0.5\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"48f9866ee3a4ef9d2868823ea5811886763af244f2df584ca247f49281c43f1f\"\n-dependencies = [\n- \"cfg-if\",\n- \"clap\",\n- \"codspeed\",\n- \"condtype\",\n- \"divan-macros\",\n- \"libc\",\n- \"regex-lite\",\n-]\n-\n [[package]]\n name = \"color_quant\"\n version = \"1.1.0\"\n@@ -1317,12 +1276,6 @@ dependencies = [\n  \"crossbeam-utils\",\n ]\n \n-[[package]]\n-name = \"condtype\"\n-version = \"1.3.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"baf0a07a401f374238ab8e2f11a104d2851bf9ce711ec69804834de8af45c7af\"\n-\n [[package]]\n name = \"console\"\n version = \"0.15.10\"\n@@ -2048,17 +2001,6 @@ dependencies = [\n  \"syn 2.0.104\",\n ]\n \n-[[package]]\n-name = \"divan-macros\"\n-version = \"0.1.17\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8dc51d98e636f5e3b0759a39257458b22619cac7e96d932da6eeb052891bb67c\"\n-dependencies = [\n- \"proc-macro2\",\n- \"quote\",\n- \"syn 2.0.104\",\n-]\n-\n [[package]]\n name = \"document-features\"\n version = \"0.2.10\"\n@@ -3392,15 +3334,6 @@ dependencies = [\n  \"either\",\n ]\n \n-[[package]]\n-name = \"itertools\"\n-version = \"0.14.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2b192c782037fadd9cfa75548310488aabdbf3d2da73885b31bd0abd03351285\"\n-dependencies = [\n- \"either\",\n-]\n-\n [[package]]\n name = \"itoa\"\n version = \"1.0.9\"\n@@ -4267,7 +4200,6 @@ name = \"next-api\"\n version = \"0.1.0\"\n dependencies = [\n  \"anyhow\",\n- \"codspeed-divan-compat\",\n  \"either\",\n  \"futures\",\n  \"indexmap 2.9.0\",\n@@ -5797,12 +5729,6 @@ dependencies = [\n  \"regex-syntax 0.8.5\",\n ]\n \n-[[package]]\n-name = \"regex-lite\"\n-version = \"0.1.6\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"53a49587ad06b26609c52e423de037e7f57f20d53535d66e08c695f347df952a\"\n-\n [[package]]\n name = \"regex-syntax\"\n version = \"0.6.29\""
        },
        {
            "sha": "d923744cfb0812c349693c73b8559f964623b3bc",
            "filename": "Cargo.toml",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/3e5c8efbf888d4676c834d16d20aa6b9898d6169/Cargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/3e5c8efbf888d4676c834d16d20aa6b9898d6169/Cargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/Cargo.toml?ref=3e5c8efbf888d4676c834d16d20aa6b9898d6169",
            "patch": "@@ -356,7 +356,6 @@ criterion = { package = \"codspeed-criterion-compat\", version = \"3.0.5\" }\n crossbeam-channel = \"0.5.8\"\n dashmap = \"6.1.0\"\n data-encoding = \"2.3.3\"\n-divan = { package = \"codspeed-divan-compat\", version = \"3.0.5\" }\n dhat = { version = \"0.3.2\" }\n dunce = \"1.0.3\"\n either = \"1.9.0\""
        },
        {
            "sha": "b7fab892310c05740e61c804b0dea64a07b24897",
            "filename": "crates/next-api/Cargo.toml",
            "status": "modified",
            "additions": 0,
            "deletions": 6,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/3e5c8efbf888d4676c834d16d20aa6b9898d6169/crates%2Fnext-api%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/3e5c8efbf888d4676c834d16d20aa6b9898d6169/crates%2Fnext-api%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2FCargo.toml?ref=3e5c8efbf888d4676c834d16d20aa6b9898d6169",
            "patch": "@@ -9,10 +9,6 @@ autobenches = false\n [lib]\n bench = false\n \n-[[bench]]\n-name = \"hmr\"\n-harness = false\n-\n [lints]\n workspace = true\n \n@@ -44,12 +40,10 @@ turbopack-wasm = { workspace = true }\n \n [dev-dependencies]\n turbo-tasks-malloc = { workspace = true }\n-divan = { workspace = true }\n tokio = { workspace = true }\n tempfile = { workspace = true }\n turbo-tasks-backend = { workspace = true }\n \n-\n [build-dependencies]\n anyhow = { workspace = true }\n vergen = { workspace = true }"
        },
        {
            "sha": "3cbeccce3850c576d3165f143d30b8ba4075552a",
            "filename": "crates/next-api/benches/hmr.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 481,
            "changes": 481,
            "blob_url": "https://github.com/vercel/next.js/blob/a32aed998a1c2d9700ead862d3bd896b25600d5b/crates%2Fnext-api%2Fbenches%2Fhmr.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a32aed998a1c2d9700ead862d3bd896b25600d5b/crates%2Fnext-api%2Fbenches%2Fhmr.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fbenches%2Fhmr.rs?ref=a32aed998a1c2d9700ead862d3bd896b25600d5b",
            "patch": "@@ -1,481 +0,0 @@\n-use std::{\n-    cell::RefCell,\n-    fs::{create_dir_all, write},\n-    mem::forget,\n-    path::{Path, PathBuf},\n-    process::Command,\n-    sync::Arc,\n-    time::{Duration, Instant},\n-};\n-\n-use anyhow::{Context, Result};\n-use next_api::{\n-    project::{DefineEnv, DraftModeOptions, ProjectContainer, ProjectOptions, WatchOptions},\n-    route::endpoint_write_to_disk,\n-};\n-use serde_json::json;\n-use tempfile::TempDir;\n-use tokio::runtime::Runtime;\n-use turbo_rcstr::{RcStr, rcstr};\n-use turbo_tasks::{\n-    TransientInstance, TurboTasks, TurboTasksApi, Vc, backend::Backend, trace::TraceRawVcs,\n-};\n-use turbo_tasks_backend::noop_backing_storage;\n-\n-pub struct HmrBenchmark {\n-    test_app: TestApp,\n-    project_container: Vc<ProjectContainer>,\n-}\n-\n-#[derive(Debug)]\n-pub struct TestApp {\n-    _path: PathBuf,\n-    /// Prevent temp directory from being dropped\n-    _dir: TempDir,\n-    modules: Vec<(PathBuf, usize)>,\n-}\n-\n-impl TestApp {\n-    pub fn path(&self) -> &Path {\n-        &self._path\n-    }\n-\n-    pub fn modules(&self) -> &[(PathBuf, usize)] {\n-        &self.modules\n-    }\n-}\n-\n-fn create_test_app(module_count: usize) -> Result<TestApp> {\n-    let temp_dir = tempfile::tempdir().context(\"Failed to create temp directory\")?;\n-    let base_path = temp_dir.path().to_path_buf();\n-\n-    // Create basic Next.js structure\n-    let pages_dir = base_path.join(\"pages\");\n-    let app_dir = base_path.join(\"app\");\n-    let src_dir = base_path.join(\"src\");\n-\n-    create_dir_all(&pages_dir)?;\n-    create_dir_all(&app_dir)?;\n-    create_dir_all(&src_dir)?;\n-\n-    let mut modules = Vec::new();\n-\n-    // Create index page\n-    let index_content = r#\"import React from 'react';\n-\n-export default function Home() {\n-    return <div>Hello World</div>;\n-}\n-\"#;\n-    let index_path = pages_dir.join(\"index.js\");\n-    write(&index_path, index_content)?;\n-    modules.push((index_path, 0));\n-\n-    // Create app layout\n-    let layout_content = r#\"export default function RootLayout({ children }) {\n-    return (\n-        <html>\n-            <body>{children}</body>\n-        </html>\n-    );\n-}\n-\"#;\n-    let layout_path = app_dir.join(\"layout.js\");\n-    write(&layout_path, layout_content)?;\n-    modules.push((layout_path, 0));\n-\n-    // Create app page\n-    let app_page_content = r#\"export default function Page() {\n-    return <div>App Router Page</div>;\n-}\n-\"#;\n-    let app_page_path = app_dir.join(\"page.js\");\n-    write(&app_page_path, app_page_content)?;\n-    modules.push((app_page_path, 0));\n-\n-    // Create additional modules based on module_count\n-    for i in 3..module_count {\n-        let component_content = format!(\n-            r#\"import React from 'react';\n-\n-export default function Component{i}() {{\n-    return <div>Component {i}</div>;\n-}}\n-\"#\n-        );\n-\n-        let component_path = src_dir.join(format!(\"component{i}.js\"));\n-        write(&component_path, component_content)?;\n-        modules.push((component_path, 1));\n-    }\n-\n-    // Create package.json\n-    let package_json = r#\"{\n-    \"name\": \"hmr-test-app\",\n-    \"version\": \"1.0.0\",\n-    \"dependencies\": {\n-        \"react\": \"^19.0.0\",\n-        \"react-dom\": \"^19.0.0\",\n-        \"next\": \"^15.0.0\"\n-    }\n-}\n-\"#;\n-    write(base_path.join(\"package.json\"), package_json)?;\n-\n-    // Create next.config.js\n-    let next_config = \"module.exports = {}\";\n-    write(base_path.join(\"next.config.js\"), next_config)?;\n-\n-    // Run `npm install`\n-    let output = Command::new(\"npm\")\n-        .current_dir(&base_path)\n-        .args([\"install\"])\n-        .output()?;\n-\n-    if !output.status.success() {\n-        return Err(anyhow::anyhow!(\"Failed to run `npm install`\"));\n-    }\n-\n-    Ok(TestApp {\n-        _path: base_path,\n-        _dir: temp_dir,\n-        modules,\n-    })\n-}\n-\n-fn load_next_config() -> RcStr {\n-    serde_json::to_string(&json!({\n-        \"sassOptions\": {\n-\n-        },\n-    }))\n-    .unwrap()\n-    .into()\n-}\n-\n-fn runtime() -> Runtime {\n-    thread_local! {\n-        static LAST_SWC_ATOM_GC_TIME: RefCell<Option<Instant>> = const { RefCell::new(None) };\n-    }\n-\n-    tokio::runtime::Builder::new_multi_thread()\n-        .enable_all()\n-        .on_thread_stop(|| {\n-            turbo_tasks_malloc::TurboMalloc::thread_stop();\n-        })\n-        .on_thread_park(|| {\n-            LAST_SWC_ATOM_GC_TIME.with_borrow_mut(|cell| {\n-                if cell.is_none_or(|t| t.elapsed() > Duration::from_secs(2)) {\n-                    swc_core::ecma::atoms::hstr::global_atom_store_gc();\n-                    *cell = Some(Instant::now());\n-                }\n-            });\n-        })\n-        .build()\n-        .context(\"Failed to build tokio runtime\")\n-        .unwrap()\n-}\n-\n-impl HmrBenchmark {\n-    pub async fn new(module_count: usize) -> Result<Self> {\n-        let test_app = create_test_app(module_count)?;\n-\n-        let project_container = {\n-            let container = ProjectContainer::new(rcstr!(\"hmr-benchmark\"), true)\n-                .to_resolved()\n-                .await?;\n-\n-            let project_path = test_app.path().to_string_lossy().to_string();\n-            let root_path = test_app.path().to_string_lossy().to_string();\n-\n-            let options = ProjectOptions {\n-                root_path: RcStr::from(root_path),\n-                project_path: RcStr::from(project_path.clone()),\n-                next_config: load_next_config(),\n-                env: vec![],\n-                define_env: DefineEnv {\n-                    client: vec![],\n-                    edge: vec![],\n-                    nodejs: vec![],\n-                },\n-                watch: WatchOptions {\n-                    enable: true,\n-                    poll_interval: None,\n-                },\n-                dev: true,\n-                encryption_key: rcstr!(\"test-key\"),\n-                build_id: rcstr!(\"development\"),\n-                preview_props: DraftModeOptions {\n-                    preview_mode_id: rcstr!(\"development\"),\n-                    preview_mode_encryption_key: rcstr!(\"test-key\"),\n-                    preview_mode_signing_key: rcstr!(\"test-key\"),\n-                },\n-                browserslist_query: rcstr!(\"last 2 versions\"),\n-                no_mangling: false,\n-                current_node_js_version: RcStr::from(\"18.0.0\"),\n-            };\n-\n-            container.initialize(options).await?;\n-            Ok::<_, anyhow::Error>(container)\n-        }?;\n-\n-        Ok(Self {\n-            test_app,\n-            project_container: *project_container,\n-        })\n-    }\n-\n-    /// Simulate file changes for HMR testing\n-    pub fn make_file_change(&self, file_path: &Path, change_id: usize) -> Result<()> {\n-        let mut content =\n-            std::fs::read_to_string(file_path).context(\"Failed to read file content\")?;\n-\n-        // Add a comment with a unique identifier to trigger HMR\n-        let change_marker = format!(\"// HMR_CHANGE_{change_id}\\n\");\n-        content.push_str(&change_marker);\n-\n-        std::fs::write(file_path, content).context(\"Failed to write modified content\")?;\n-\n-        Ok(())\n-    }\n-\n-    /// Benchmark HMR update detection and processing\n-    pub async fn benchmark_hmr_update(&self, num_updates: usize) -> Result<Duration> {\n-        // Get entrypoints to trigger initial compilation\n-        let entrypoints = self.project_container.entrypoints();\n-        let initial_result = entrypoints.await?;\n-\n-        // Check if we have routes available\n-        if initial_result.routes.is_empty() {\n-            return Err(anyhow::anyhow!(\"No routes found in entrypoints\"));\n-        }\n-\n-        // Get HMR identifiers\n-        let hmr_identifiers = self.project_container.hmr_identifiers();\n-        let identifiers = hmr_identifiers.await?;\n-\n-        if identifiers.is_empty() {\n-            return Err(anyhow::anyhow!(\"No HMR identifiers found\"));\n-        }\n-\n-        // Get project to access HMR methods\n-        let project = self.project_container.project();\n-\n-        // Create multiple sessions to simulate real HMR usage\n-        let mut update_durations = Vec::new();\n-\n-        for i in 0..num_updates {\n-            let update_start = Instant::now();\n-\n-            // Use different identifiers for each update\n-            let identifier = &identifiers[i % identifiers.len()];\n-\n-            // Get version state for this update\n-            let session = TransientInstance::new(());\n-            let version_state = project.hmr_version_state(identifier.clone(), session);\n-\n-            // Pick a module file to change\n-            let module_index = i % self.test_app.modules().len();\n-            let (module_path, _) = &self.test_app.modules()[module_index];\n-\n-            // Make a file change\n-            self.make_file_change(module_path, i)?;\n-\n-            // Wait for HMR update and measure time\n-            let _update_result = project\n-                .hmr_update(identifier.clone(), version_state)\n-                .await?;\n-\n-            update_durations.push(update_start.elapsed());\n-        }\n-\n-        Ok(update_durations.iter().sum::<Duration>())\n-    }\n-\n-    /// Benchmark HMR subscription and event handling\n-    pub async fn benchmark_hmr_subscription(&self) -> Result<Duration> {\n-        let start_time = Instant::now();\n-\n-        // Get entrypoints first\n-        let entrypoints = self.project_container.entrypoints();\n-        let _initial_result = entrypoints.await?;\n-\n-        // Get HMR identifiers\n-        let hmr_identifiers = self.project_container.hmr_identifiers();\n-        let identifiers = hmr_identifiers.await?;\n-\n-        if identifiers.is_empty() {\n-            return Err(anyhow::anyhow!(\"No HMR identifiers found\"));\n-        }\n-\n-        let project = self.project_container.project();\n-\n-        // Test subscription to multiple identifiers\n-        let mut version_states = Vec::new();\n-        for identifier in identifiers.iter().take(5) {\n-            // Test with first 5 identifiers\n-            let session = TransientInstance::new(());\n-            let version_state = project.hmr_version_state(identifier.clone(), session);\n-            version_states.push((identifier.clone(), version_state));\n-        }\n-\n-        // Simulate multiple rapid updates\n-        for (i, (identifier, version_state)) in version_states.iter().enumerate() {\n-            // Make a file change\n-            if let Some((module_path, _)) = self.test_app.modules().get(i) {\n-                self.make_file_change(module_path, i * 100)?;\n-\n-                // Check for update\n-                let _update_result = project\n-                    .hmr_update(identifier.clone(), *version_state)\n-                    .await?;\n-            }\n-        }\n-\n-        Ok(start_time.elapsed())\n-    }\n-\n-    /// Benchmark initial project setup and entrypoint detection\n-    pub async fn benchmark_initial_compilation(&self) -> Result<Duration> {\n-        let start_time = Instant::now();\n-\n-        let entrypoints = self.project_container.entrypoints();\n-        let result = entrypoints.await?;\n-\n-        for route in result.routes.values() {\n-            match route {\n-                next_api::route::Route::Page {\n-                    html_endpoint,\n-                    data_endpoint,\n-                } => {\n-                    let _ = endpoint_write_to_disk(**html_endpoint).await?;\n-                    let _ = endpoint_write_to_disk(**data_endpoint).await?;\n-                }\n-                next_api::route::Route::PageApi { endpoint } => {\n-                    let _ = endpoint_write_to_disk(**endpoint).await?;\n-                }\n-                next_api::route::Route::AppPage(app_page_routes) => {\n-                    for route in app_page_routes.iter() {\n-                        let _ = endpoint_write_to_disk(*route.html_endpoint).await?;\n-                        let _ = endpoint_write_to_disk(*route.rsc_endpoint).await?;\n-                    }\n-                }\n-                next_api::route::Route::AppRoute { endpoint, .. } => {\n-                    let _ = endpoint_write_to_disk(**endpoint).await?;\n-                }\n-                next_api::route::Route::Conflict => {}\n-            }\n-        }\n-\n-        Ok(start_time.elapsed())\n-    }\n-\n-    /// Get the number of modules in the test app\n-    pub fn module_count(&self) -> usize {\n-        self.test_app.modules().len()\n-    }\n-}\n-\n-async fn setup_benchmark(module_count: usize) -> HmrBenchmark {\n-    HmrBenchmark::new(module_count).await.unwrap()\n-}\n-\n-fn setup_runtime() -> Runtime {\n-    runtime()\n-}\n-\n-fn setup_turbo_tasks() -> Arc<TurboTasks<impl Backend>> {\n-    TurboTasks::new(turbo_tasks_backend::TurboTasksBackend::new(\n-        turbo_tasks_backend::BackendOptions {\n-            storage_mode: None,\n-            dependency_tracking: true,\n-            ..Default::default()\n-        },\n-        noop_backing_storage(),\n-    ))\n-}\n-\n-#[derive(TraceRawVcs)]\n-struct Setup {\n-    #[turbo_tasks(trace_ignore)]\n-    rt: Arc<Runtime>,\n-    #[turbo_tasks(trace_ignore)]\n-    tt: Arc<dyn TurboTasksApi>,\n-    #[turbo_tasks(trace_ignore)]\n-    benchmark: HmrBenchmark,\n-}\n-\n-fn setup_everything(module_count: usize) -> Arc<Setup> {\n-    let rt = Arc::new(setup_runtime());\n-    let tt = setup_turbo_tasks();\n-\n-    let arc = rt.clone().block_on(async move {\n-        tt.clone()\n-            .run_once(async move {\n-                let benchmark = setup_benchmark(module_count).await;\n-                benchmark.benchmark_initial_compilation().await.unwrap();\n-\n-                Ok(Arc::new(Setup { rt, tt, benchmark }))\n-            })\n-            .await\n-            .unwrap()\n-    });\n-\n-    // I don't know why this is needed, but it is required to avoid dropping tokio runtime from\n-    // async scope\n-    forget(arc.clone());\n-    arc\n-}\n-\n-fn bench_update(bencher: divan::Bencher, module_count: usize, num_updates: usize) {\n-    let s = setup_everything(module_count);\n-\n-    bencher\n-        .with_inputs(|| {\n-            let setup = s.clone();\n-\n-            setup.clone().rt.block_on(async move {\n-                setup.clone().tt.run_once(Box::pin(async move {\n-                    let _ = setup\n-                        .benchmark\n-                        .benchmark_initial_compilation()\n-                        .await\n-                        .unwrap();\n-                    Ok(())\n-                }));\n-            });\n-\n-            s.clone()\n-        })\n-        .bench_values(|setup| {\n-            setup.clone().rt.block_on(async move {\n-                setup.clone().tt.run_once(Box::pin(async move {\n-                    setup\n-                        .benchmark\n-                        .benchmark_hmr_update(num_updates)\n-                        .await\n-                        .unwrap();\n-                    Ok(())\n-                }));\n-            })\n-        });\n-}\n-\n-#[divan::bench(sample_size = 10000, max_time = 60)]\n-fn hmr_updates_small_5(bencher: divan::Bencher) {\n-    bench_update(bencher, 100, 5);\n-}\n-\n-#[divan::bench(sample_size = 10000, max_time = 60)]\n-fn hmr_updates_medium_10(bencher: divan::Bencher) {\n-    bench_update(bencher, 200, 10);\n-}\n-\n-#[divan::bench(sample_size = 10000, max_time = 60)]\n-fn hmr_updates_large_20(bencher: divan::Bencher) {\n-    bench_update(bencher, 500, 20);\n-}\n-\n-fn main() {\n-    divan::main();\n-}"
        }
    ],
    "stats": {
        "total": 585,
        "additions": 0,
        "deletions": 585
    }
}