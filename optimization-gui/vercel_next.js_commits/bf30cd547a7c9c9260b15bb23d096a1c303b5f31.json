{
    "author": "sokra",
    "message": "Turbopack: improve aggregation update performance (#87317)\n\n### What?\n\nWhen expanding the followers of a list of followers, we often have duplicates.\nThis adds deduplication and a count for the followers of followers and makes these updates way more efficient.",
    "sha": "bf30cd547a7c9c9260b15bb23d096a1c303b5f31",
    "files": [
        {
            "sha": "555668f022e3144f2036d01e1703546da5e1a87f",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/aggregation_update.rs",
            "status": "modified",
            "additions": 122,
            "deletions": 49,
            "changes": 171,
            "blob_url": "https://github.com/vercel/next.js/blob/bf30cd547a7c9c9260b15bb23d096a1c303b5f31/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Faggregation_update.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/bf30cd547a7c9c9260b15bb23d096a1c303b5f31/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Faggregation_update.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Faggregation_update.rs?ref=bf30cd547a7c9c9260b15bb23d096a1c303b5f31",
            "patch": "@@ -46,6 +46,7 @@ const MAX_COUNT_BEFORE_YIELD: usize = 1000;\n const MAX_UPPERS_FOLLOWER_PRODUCT: usize = 31;\n \n type TaskIdVec = SmallVec<[TaskId; 4]>;\n+type TaskIdWithCountVec = SmallVec<[(TaskId, u32); 2]>;\n \n /// Returns true, when a node is aggregating its children and a partial subgraph.\n pub fn is_aggregating_node(aggregation_number: u32) -> bool {\n@@ -226,11 +227,21 @@ pub enum AggregationUpdateJob {\n         upper_ids: TaskIdVec,\n         new_follower_id: TaskId,\n     },\n+    /// Notifies multiple upper tasks that one of its inner tasks has a new follower.\n+    InnerOfUppersHasNewFollowerWithCount {\n+        upper_ids: TaskIdWithCountVec,\n+        new_follower_id: TaskId,\n+    },\n     /// Notifies an upper task that one of its inner tasks has new followers.\n     InnerOfUpperHasNewFollowers {\n         upper_id: TaskId,\n         new_follower_ids: TaskIdVec,\n     },\n+    /// Notifies an upper task that one of its inner tasks has new followers.\n+    InnerOfUpperHasNewFollowersWithCount {\n+        upper_id: TaskId,\n+        new_follower_ids: TaskIdWithCountVec,\n+    },\n     /// Notifies multiple upper tasks that one of its inner tasks has new followers.\n     InnerOfUppersHasNewFollowers(Box<InnerOfUppersHasNewFollowersJob>),\n     /// Notifies multiple upper tasks that one of its inner tasks has lost a follower.\n@@ -1026,6 +1037,7 @@ impl AggregationUpdateQueue {\n                             ctx,\n                             new_follower_ids[0],\n                             upper_ids[0],\n+                            1,\n                         );\n                     } else if uppers > followers {\n                         if let Some(new_follower_id) = new_follower_ids.pop() {\n@@ -1058,7 +1070,18 @@ impl AggregationUpdateQueue {\n                     new_follower_id,\n                 } => {\n                     if upper_ids.len() == 1 {\n-                        self.inner_of_upper_has_new_follower(ctx, new_follower_id, upper_ids[0]);\n+                        self.inner_of_upper_has_new_follower(ctx, new_follower_id, upper_ids[0], 1);\n+                    } else {\n+                        self.inner_of_uppers_has_new_follower(ctx, new_follower_id, upper_ids);\n+                    }\n+                }\n+                AggregationUpdateJob::InnerOfUppersHasNewFollowerWithCount {\n+                    upper_ids,\n+                    new_follower_id,\n+                } => {\n+                    if upper_ids.len() == 1 {\n+                        let (id, count) = upper_ids[0];\n+                        self.inner_of_upper_has_new_follower(ctx, new_follower_id, id, count);\n                     } else {\n                         self.inner_of_uppers_has_new_follower(ctx, new_follower_id, upper_ids);\n                     }\n@@ -1068,7 +1091,18 @@ impl AggregationUpdateQueue {\n                     new_follower_ids,\n                 } => {\n                     if new_follower_ids.len() == 1 {\n-                        self.inner_of_upper_has_new_follower(ctx, new_follower_ids[0], upper_id);\n+                        self.inner_of_upper_has_new_follower(ctx, new_follower_ids[0], upper_id, 1);\n+                    } else {\n+                        self.inner_of_upper_has_new_followers(ctx, new_follower_ids, upper_id);\n+                    }\n+                }\n+                AggregationUpdateJob::InnerOfUpperHasNewFollowersWithCount {\n+                    upper_id,\n+                    new_follower_ids,\n+                } => {\n+                    if new_follower_ids.len() == 1 {\n+                        let (id, count) = new_follower_ids[0];\n+                        self.inner_of_upper_has_new_follower(ctx, id, upper_id, count);\n                     } else {\n                         self.inner_of_upper_has_new_followers(ctx, new_follower_ids, upper_id);\n                     }\n@@ -1077,7 +1111,7 @@ impl AggregationUpdateQueue {\n                     upper_id,\n                     new_follower_id,\n                 } => {\n-                    self.inner_of_upper_has_new_follower(ctx, new_follower_id, upper_id);\n+                    self.inner_of_upper_has_new_follower(ctx, new_follower_id, upper_id, 1);\n                 }\n                 AggregationUpdateJob::InnerOfUppersLostFollowers(mut boxed) => {\n                     let InnerOfUppersLostFollowersJob {\n@@ -1826,11 +1860,11 @@ impl AggregationUpdateQueue {\n         }\n     }\n \n-    fn inner_of_uppers_has_new_follower(\n+    fn inner_of_uppers_has_new_follower<T: TaskIdWithOptionalCount, const N: usize>(\n         &mut self,\n         ctx: &mut impl ExecuteContext,\n         new_follower_id: TaskId,\n-        mut upper_ids: TaskIdVec,\n+        mut upper_ids: SmallVec<[T; N]>,\n     ) {\n         #[cfg(feature = \"trace_aggregation_update\")]\n         let _span =\n@@ -1844,11 +1878,12 @@ impl AggregationUpdateQueue {\n             );\n             get_aggregation_number(&follower)\n         };\n-        let mut upper_upper_ids_with_new_follower = SmallVec::new();\n+        let mut upper_upper_ids_with_new_follower = FxHashMap::default();\n         let mut tasks_for_which_increment_active_count = SmallVec::new();\n         let mut is_active = false;\n \n-        swap_retain(&mut upper_ids, |&mut upper_id| {\n+        swap_retain(&mut upper_ids, |upper_item| {\n+            let (upper_id, count) = upper_item.task_id_and_count();\n             let mut upper = ctx.task(\n                 upper_id,\n                 // For performance reasons this should stay `Meta` and not `All`\n@@ -1866,7 +1901,7 @@ impl AggregationUpdateQueue {\n                     Follower {\n                         task: new_follower_id\n                     },\n-                    1\n+                    count\n                 ) {\n                     // May optimize the task\n                     if count!(upper, Follower).is_power_of_two() {\n@@ -1882,7 +1917,11 @@ impl AggregationUpdateQueue {\n                         }\n                     }\n                     // notify uppers about new follower\n-                    upper_upper_ids_with_new_follower.extend(iter_uppers(&upper));\n+                    for upper_id in iter_uppers(&upper) {\n+                        *upper_upper_ids_with_new_follower\n+                            .entry(upper_id)\n+                            .or_insert(0) += 1;\n+                    }\n                 }\n \n                 // Balancing is only needed when they are equal. This is not perfect from\n@@ -1913,8 +1952,9 @@ impl AggregationUpdateQueue {\n             );\n             let mut uppers_count: Option<usize> = None;\n             let mut persistent_uppers = 0;\n-            swap_retain(&mut upper_ids, |&mut upper_id| {\n-                if update_count!(follower, Upper { task: upper_id }, 1) {\n+            swap_retain(&mut upper_ids, |upper_item| {\n+                let (upper_id, count) = upper_item.task_id_and_count();\n+                if update_count!(follower, Upper { task: upper_id }, count) {\n                     // It's a new upper\n                     let uppers_count = uppers_count.get_or_insert_with(|| {\n                         let count =\n@@ -1950,33 +1990,37 @@ impl AggregationUpdateQueue {\n                 if has_data || !is_active {\n                     // add data to upper\n                     // For performance reasons this should stay `Meta` and not `All`\n-                    ctx.for_each_task_meta(upper_ids.iter().copied(), |mut upper, ctx| {\n-                        if has_data {\n-                            let diff = data.apply(&mut upper, ctx.should_track_activeness(), self);\n-                            if !diff.is_empty() {\n-                                let upper_ids = get_uppers(&upper);\n-                                self.push(\n-                                    AggregatedDataUpdateJob {\n-                                        upper_ids,\n-                                        update: diff,\n-                                    }\n-                                    .into(),\n-                                )\n+                    ctx.for_each_task_meta(\n+                        upper_ids.iter().map(|entry| entry.task_id()),\n+                        |mut upper, ctx| {\n+                            if has_data {\n+                                let diff =\n+                                    data.apply(&mut upper, ctx.should_track_activeness(), self);\n+                                if !diff.is_empty() {\n+                                    let upper_ids = get_uppers(&upper);\n+                                    self.push(\n+                                        AggregatedDataUpdateJob {\n+                                            upper_ids,\n+                                            update: diff,\n+                                        }\n+                                        .into(),\n+                                    )\n+                                }\n                             }\n-                        }\n-                        if !is_active {\n-                            // We need to check this again, since this might have changed in the\n-                            // meantime due to race conditions\n-                            if upper.has_key(&CachedDataItemKey::Activeness {}) {\n-                                is_active = true;\n+                            if !is_active {\n+                                // We need to check this again, since this might have changed in the\n+                                // meantime due to race conditions\n+                                if upper.has_key(&CachedDataItemKey::Activeness {}) {\n+                                    is_active = true;\n+                                }\n                             }\n-                        }\n-                    });\n+                        },\n+                    );\n                 }\n                 if !children.is_empty() {\n                     self.push(\n                         InnerOfUppersHasNewFollowersJob {\n-                            upper_ids: upper_ids.clone(),\n+                            upper_ids: upper_ids.into_iter().map(|entry| entry.task_id()).collect(),\n                             new_follower_ids: children,\n                         }\n                         .into(),\n@@ -1997,17 +2041,17 @@ impl AggregationUpdateQueue {\n         if !upper_upper_ids_with_new_follower.is_empty() {\n             #[cfg(feature = \"trace_aggregation_update\")]\n             let _span = trace_span!(\"new follower\").entered();\n-            self.push(AggregationUpdateJob::InnerOfUppersHasNewFollower {\n-                upper_ids: upper_upper_ids_with_new_follower,\n+            self.push(AggregationUpdateJob::InnerOfUppersHasNewFollowerWithCount {\n+                upper_ids: upper_upper_ids_with_new_follower.into_iter().collect(),\n                 new_follower_id,\n             });\n         }\n     }\n \n-    fn inner_of_upper_has_new_followers(\n+    fn inner_of_upper_has_new_followers<T: TaskIdWithOptionalCount, const N: usize>(\n         &mut self,\n         ctx: &mut impl ExecuteContext,\n-        new_follower_ids: TaskIdVec,\n+        new_follower_ids: SmallVec<[T; N]>,\n         upper_id: TaskId,\n     ) {\n         #[cfg(feature = \"trace_aggregation_update\")]\n@@ -2019,13 +2063,14 @@ impl AggregationUpdateQueue {\n \n         let mut followers_with_aggregation_number = new_follower_ids\n             .into_iter()\n-            .map(|new_follower_id| {\n+            .map(|new_follower_entry| {\n+                let (new_follower_id, count) = new_follower_entry.task_id_and_count();\n                 let follower = ctx.task(\n                     new_follower_id,\n                     // For performance reasons this should stay `Meta` and not `All`\n                     TaskDataCategory::Meta,\n                 );\n-                (new_follower_id, get_aggregation_number(&follower))\n+                (new_follower_id, count, get_aggregation_number(&follower))\n             })\n             .collect::<SmallVec<[_; 4]>>();\n \n@@ -2050,13 +2095,13 @@ impl AggregationUpdateQueue {\n \n             if !is_root_node(upper_aggregation_number) {\n                 followers_with_aggregation_number.retain(\n-                    |(follower_id, follower_aggregation_number)| {\n+                    |(follower_id, count, follower_aggregation_number)| {\n                         if upper_aggregation_number > *follower_aggregation_number {\n                             // It's an inner node, continue with the list\n                             return true;\n                         }\n                         // It's a follower of the upper node\n-                        if update_count!(upper, Follower { task: *follower_id }, 1) {\n+                        if update_count!(upper, Follower { task: *follower_id }, *count) {\n                             // May optimize the task\n                             if count!(upper, Follower).is_power_of_two() {\n                                 self.push_optimize_task(upper_id);\n@@ -2089,16 +2134,16 @@ impl AggregationUpdateQueue {\n             #[cfg(feature = \"trace_aggregation_update\")]\n             let _span = trace_span!(\"new inner\").entered();\n             let mut upper_data_updates = Vec::new();\n-            let mut upper_new_followers = SmallVec::new();\n+            let mut upper_new_followers = FxHashMap::default();\n             swap_retain(\n                 &mut inner_tasks_with_aggregation_number,\n-                |&mut (inner_id, _)| {\n+                |&mut (inner_id, count, _)| {\n                     let mut inner = ctx.task(\n                         inner_id,\n                         // For performance reasons this should stay `Meta` and not `All`\n                         TaskDataCategory::Meta,\n                     );\n-                    if update_count!(inner, Upper { task: upper_id }, 1) {\n+                    if update_count!(inner, Upper { task: upper_id }, count) {\n                         if count!(inner, Upper).is_power_of_two() {\n                             self.push_optimize_task(inner_id);\n                         }\n@@ -2112,7 +2157,9 @@ impl AggregationUpdateQueue {\n                         if !data.is_empty() {\n                             upper_data_updates.push(data);\n                         }\n-                        upper_new_followers.extend(children);\n+                        for &child_id in &children {\n+                            *upper_new_followers.entry(child_id).or_insert(0) += 1;\n+                        }\n \n                         // Balancing is only needed when they are equal (or could have become equal\n                         // in the meantime). This is not perfect from\n@@ -2134,9 +2181,9 @@ impl AggregationUpdateQueue {\n             );\n \n             if !upper_new_followers.is_empty() {\n-                self.push(AggregationUpdateJob::InnerOfUpperHasNewFollowers {\n+                self.push(AggregationUpdateJob::InnerOfUpperHasNewFollowersWithCount {\n                     upper_id,\n-                    new_follower_ids: upper_new_followers,\n+                    new_follower_ids: upper_new_followers.into_iter().collect(),\n                 });\n             }\n             if !upper_data_updates.is_empty() {\n@@ -2192,7 +2239,7 @@ impl AggregationUpdateQueue {\n                     self.extend_find_and_schedule_dirty(\n                         inner_tasks_with_aggregation_number\n                             .into_iter()\n-                            .map(|(id, _)| id),\n+                            .map(|(id, _, _)| id),\n                     );\n                 }\n             }\n@@ -2225,6 +2272,7 @@ impl AggregationUpdateQueue {\n         ctx: &mut impl ExecuteContext,\n         new_follower_id: TaskId,\n         upper_id: TaskId,\n+        count: u32,\n     ) {\n         #[cfg(feature = \"trace_aggregation_update\")]\n         let _span = trace_span!(\"process new follower\").entered();\n@@ -2258,7 +2306,7 @@ impl AggregationUpdateQueue {\n                 Follower {\n                     task: new_follower_id\n                 },\n-                1\n+                count\n             ) {\n                 // May optimize the task\n                 if count!(upper, Follower).is_power_of_two() {\n@@ -2306,7 +2354,7 @@ impl AggregationUpdateQueue {\n                 // For performance reasons this should stay `Meta` and not `All`\n                 TaskDataCategory::Meta,\n             );\n-            if update_count!(inner, Upper { task: upper_id }, 1) {\n+            if update_count!(inner, Upper { task: upper_id }, count) {\n                 if count!(inner, Upper).is_power_of_two() {\n                     self.push_optimize_task(new_follower_id);\n                 }\n@@ -2685,6 +2733,31 @@ impl Operation for AggregationUpdateQueue {\n     }\n }\n \n+trait TaskIdWithOptionalCount {\n+    fn task_id(&self) -> TaskId;\n+    fn task_id_and_count(&self) -> (TaskId, u32);\n+}\n+\n+impl TaskIdWithOptionalCount for TaskId {\n+    fn task_id(&self) -> TaskId {\n+        *self\n+    }\n+\n+    fn task_id_and_count(&self) -> (TaskId, u32) {\n+        (*self, 1)\n+    }\n+}\n+\n+impl TaskIdWithOptionalCount for (TaskId, u32) {\n+    fn task_id(&self) -> TaskId {\n+        self.0\n+    }\n+\n+    fn task_id_and_count(&self) -> (TaskId, u32) {\n+        (self.0, self.1)\n+    }\n+}\n+\n struct RetryTimeout;\n \n const MAX_YIELD_DURATION: Duration = Duration::from_millis(1);"
        }
    ],
    "stats": {
        "total": 171,
        "additions": 122,
        "deletions": 49
    }
}