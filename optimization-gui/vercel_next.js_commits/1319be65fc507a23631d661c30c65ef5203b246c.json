{
    "author": "unstubbable",
    "message": "Disable `\"use cache\"` deploy tests (#79586)",
    "sha": "1319be65fc507a23631d661c30c65ef5203b246c",
    "files": [
        {
            "sha": "7f3d59a6141d83f87e5b4f75ac40ad9bf33d3ee9",
            "filename": "test/e2e/app-dir/use-cache/use-cache.test.ts",
            "status": "modified",
            "additions": 218,
            "deletions": 227,
            "changes": 445,
            "blob_url": "https://github.com/vercel/next.js/blob/1319be65fc507a23631d661c30c65ef5203b246c/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fuse-cache.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1319be65fc507a23631d661c30c65ef5203b246c/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fuse-cache.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fuse-cache.test.ts?ref=1319be65fc507a23631d661c30c65ef5203b246c",
            "patch": "@@ -13,9 +13,16 @@ const GENERIC_RSC_ERROR =\n   'An error occurred in the Server Components render. The specific message is omitted in production builds to avoid leaking sensitive details. A digest property is included on this error instance which may provide additional details about the nature of the error.'\n \n describe('use-cache', () => {\n-  const { next, isNextDev, isNextDeploy, isNextStart } = nextTestSetup({\n-    files: __dirname,\n-  })\n+  const { next, isNextDev, isNextDeploy, isNextStart, skipped } = nextTestSetup(\n+    {\n+      files: __dirname,\n+      skipDeployment: true,\n+    }\n+  )\n+\n+  if (skipped) {\n+    return\n+  }\n \n   it('should cache results', async () => {\n     const browser = await next.browser(`/?n=1`)\n@@ -158,47 +165,44 @@ describe('use-cache', () => {\n     }\n   })\n \n-  // TODO: Enable for deploy tests when upstream changes have been rolled out.\n-  if (!isNextDeploy) {\n-    it('should cache results in route handlers', async () => {\n-      const response = await next.fetch('/api')\n-      const { rand1, rand2 } = await response.json()\n+  it('should cache results in route handlers', async () => {\n+    const response = await next.fetch('/api')\n+    const { rand1, rand2 } = await response.json()\n \n-      expect(rand1).toEqual(rand2)\n-    })\n+    expect(rand1).toEqual(rand2)\n+  })\n \n-    it('should revalidate before redirecting in a route handlers', async () => {\n-      const initialValues = await next.fetch('/api').then((res) => res.json())\n+  it('should revalidate before redirecting in a route handlers', async () => {\n+    const initialValues = await next.fetch('/api').then((res) => res.json())\n \n-      const values = await next\n-        .fetch('/api/revalidate-redirect')\n-        .then((res) => res.json())\n+    const values = await next\n+      .fetch('/api/revalidate-redirect')\n+      .then((res) => res.json())\n \n-      if (isNextDeploy) {\n-        try {\n-          expect(values).not.toEqual(initialValues)\n-        } catch {\n-          // When deployed, we currently don't have a strong guarantee that the\n-          // revalidations are propagated fully (as we do for redirecting server\n-          // actions). This is because, for route handlers, the redirect occurs\n-          // client-side, which prevents us from using the same technique as for\n-          // server actions, which involves sending a revalidate token as a\n-          // request header. This token must not leak to the client. However,\n-          // eventually the revalidation will be propagated, and a refresh should\n-          // show fresh data.\n-          await retry(async () => {\n-            const refreshedValues = await next\n-              .fetch('/api')\n-              .then((res) => res.json())\n-\n-            expect(refreshedValues).not.toEqual(initialValues)\n-          })\n-        }\n-      } else {\n+    if (isNextDeploy) {\n+      try {\n         expect(values).not.toEqual(initialValues)\n+      } catch {\n+        // When deployed, we currently don't have a strong guarantee that the\n+        // revalidations are propagated fully (as we do for redirecting server\n+        // actions). This is because, for route handlers, the redirect occurs\n+        // client-side, which prevents us from using the same technique as for\n+        // server actions, which involves sending a revalidate token as a\n+        // request header. This token must not leak to the client. However,\n+        // eventually the revalidation will be propagated, and a refresh should\n+        // show fresh data.\n+        await retry(async () => {\n+          const refreshedValues = await next\n+            .fetch('/api')\n+            .then((res) => res.json())\n+\n+          expect(refreshedValues).not.toEqual(initialValues)\n+        })\n       }\n-    })\n-  }\n+    } else {\n+      expect(values).not.toEqual(initialValues)\n+    }\n+  })\n \n   it('should cache results for cached functions imported from client components', async () => {\n     const browser = await next.browser('/imported-from-client')\n@@ -244,161 +248,158 @@ describe('use-cache', () => {\n     })\n   })\n \n-  // TODO: pending tags handling on deploy\n-  if (!isNextDeploy) {\n-    it('should update after unstable_expireTag correctly', async () => {\n-      const browser = await next.browser('/cache-tag')\n-      const initial = await browser.elementByCss('#a').text()\n-\n-      if (!isNextDev) {\n-        // Bust the ISR cache first, to populate the in-memory cache for the\n-        // subsequent unstable_expireTag calls.\n-        await browser.elementByCss('#revalidate-path').click()\n-        await retry(async () => {\n-          expect(await browser.elementByCss('#a').text()).not.toBe(initial)\n-        })\n-      }\n-\n-      let valueA = await browser.elementByCss('#a').text()\n-      let valueB = await browser.elementByCss('#b').text()\n-      let valueF1 = await browser.elementByCss('#f1').text()\n-      let valueF2 = await browser.elementByCss('#f2').text()\n-      let valueR1 = await browser.elementByCss('#r1').text()\n-      let valueR2 = await browser.elementByCss('#r2').text()\n-\n-      await browser.elementByCss('#revalidate-a').click()\n-      await retry(async () => {\n-        expect(await browser.elementByCss('#a').text()).not.toBe(valueA)\n-        expect(await browser.elementByCss('#b').text()).toBe(valueB)\n-        expect(await browser.elementByCss('#f1').text()).toBe(valueF1)\n-        expect(await browser.elementByCss('#f2').text()).toBe(valueF2)\n-        expect(await browser.elementByCss('#r1').text()).toBe(valueR1)\n-        expect(await browser.elementByCss('#r2').text()).toBe(valueR2)\n-      })\n+  it('should update after unstable_expireTag correctly', async () => {\n+    const browser = await next.browser('/cache-tag')\n+    const initial = await browser.elementByCss('#a').text()\n \n-      valueA = await browser.elementByCss('#a').text()\n-\n-      await browser.elementByCss('#revalidate-b').click()\n+    if (!isNextDev) {\n+      // Bust the ISR cache first, to populate the in-memory cache for the\n+      // subsequent unstable_expireTag calls.\n+      await browser.elementByCss('#revalidate-path').click()\n       await retry(async () => {\n-        expect(await browser.elementByCss('#a').text()).toBe(valueA)\n-        expect(await browser.elementByCss('#b').text()).not.toBe(valueB)\n-        expect(await browser.elementByCss('#f1').text()).toBe(valueF1)\n-        expect(await browser.elementByCss('#f2').text()).toBe(valueF2)\n-        expect(await browser.elementByCss('#r1').text()).toBe(valueR1)\n-        expect(await browser.elementByCss('#r2').text()).toBe(valueR2)\n+        expect(await browser.elementByCss('#a').text()).not.toBe(initial)\n       })\n+    }\n \n-      valueB = await browser.elementByCss('#b').text()\n+    let valueA = await browser.elementByCss('#a').text()\n+    let valueB = await browser.elementByCss('#b').text()\n+    let valueF1 = await browser.elementByCss('#f1').text()\n+    let valueF2 = await browser.elementByCss('#f2').text()\n+    let valueR1 = await browser.elementByCss('#r1').text()\n+    let valueR2 = await browser.elementByCss('#r2').text()\n \n-      await browser.elementByCss('#revalidate-c').click()\n-      await retry(async () => {\n-        expect(await browser.elementByCss('#a').text()).not.toBe(valueA)\n-        expect(await browser.elementByCss('#b').text()).not.toBe(valueB)\n-        expect(await browser.elementByCss('#f1').text()).not.toBe(valueF1)\n-        expect(await browser.elementByCss('#f2').text()).toBe(valueF2)\n-        expect(await browser.elementByCss('#r1').text()).not.toBe(valueR1)\n-        expect(await browser.elementByCss('#r2').text()).toBe(valueR2)\n-      })\n+    await browser.elementByCss('#revalidate-a').click()\n+    await retry(async () => {\n+      expect(await browser.elementByCss('#a').text()).not.toBe(valueA)\n+      expect(await browser.elementByCss('#b').text()).toBe(valueB)\n+      expect(await browser.elementByCss('#f1').text()).toBe(valueF1)\n+      expect(await browser.elementByCss('#f2').text()).toBe(valueF2)\n+      expect(await browser.elementByCss('#r1').text()).toBe(valueR1)\n+      expect(await browser.elementByCss('#r2').text()).toBe(valueR2)\n+    })\n \n-      valueA = await browser.elementByCss('#a').text()\n-      valueB = await browser.elementByCss('#b').text()\n-      valueF1 = await browser.elementByCss('#f1').text()\n-      valueR1 = await browser.elementByCss('#r1').text()\n+    valueA = await browser.elementByCss('#a').text()\n \n-      await browser.elementByCss('#revalidate-f').click()\n-      await retry(async () => {\n-        expect(await browser.elementByCss('#a').text()).toBe(valueA)\n-        expect(await browser.elementByCss('#b').text()).toBe(valueB)\n-        expect(await browser.elementByCss('#f1').text()).not.toBe(valueF1)\n-        expect(await browser.elementByCss('#f2').text()).toBe(valueF2)\n-        expect(await browser.elementByCss('#r1').text()).toBe(valueR1)\n-        expect(await browser.elementByCss('#r2').text()).toBe(valueR2)\n-      })\n+    await browser.elementByCss('#revalidate-b').click()\n+    await retry(async () => {\n+      expect(await browser.elementByCss('#a').text()).toBe(valueA)\n+      expect(await browser.elementByCss('#b').text()).not.toBe(valueB)\n+      expect(await browser.elementByCss('#f1').text()).toBe(valueF1)\n+      expect(await browser.elementByCss('#f2').text()).toBe(valueF2)\n+      expect(await browser.elementByCss('#r1').text()).toBe(valueR1)\n+      expect(await browser.elementByCss('#r2').text()).toBe(valueR2)\n+    })\n \n-      valueF1 = await browser.elementByCss('#f1').text()\n+    valueB = await browser.elementByCss('#b').text()\n \n-      await browser.elementByCss('#revalidate-r').click()\n-      await retry(async () => {\n-        expect(await browser.elementByCss('#a').text()).toBe(valueA)\n-        expect(await browser.elementByCss('#b').text()).toBe(valueB)\n-        expect(await browser.elementByCss('#f1').text()).toBe(valueF1)\n-        expect(await browser.elementByCss('#f2').text()).toBe(valueF2)\n-        expect(await browser.elementByCss('#r1').text()).not.toBe(valueR1)\n-        expect(await browser.elementByCss('#r2').text()).toBe(valueR2)\n-      })\n+    await browser.elementByCss('#revalidate-c').click()\n+    await retry(async () => {\n+      expect(await browser.elementByCss('#a').text()).not.toBe(valueA)\n+      expect(await browser.elementByCss('#b').text()).not.toBe(valueB)\n+      expect(await browser.elementByCss('#f1').text()).not.toBe(valueF1)\n+      expect(await browser.elementByCss('#f2').text()).toBe(valueF2)\n+      expect(await browser.elementByCss('#r1').text()).not.toBe(valueR1)\n+      expect(await browser.elementByCss('#r2').text()).toBe(valueR2)\n+    })\n \n-      valueR1 = await browser.elementByCss('#r1').text()\n+    valueA = await browser.elementByCss('#a').text()\n+    valueB = await browser.elementByCss('#b').text()\n+    valueF1 = await browser.elementByCss('#f1').text()\n+    valueR1 = await browser.elementByCss('#r1').text()\n \n-      await browser.elementByCss('#revalidate-path').click()\n-      await retry(async () => {\n-        expect(await browser.elementByCss('#a').text()).not.toBe(valueA)\n-        expect(await browser.elementByCss('#b').text()).not.toBe(valueB)\n-        expect(await browser.elementByCss('#f1').text()).not.toBe(valueF1)\n-        expect(await browser.elementByCss('#f2').text()).not.toBe(valueF2)\n-        expect(await browser.elementByCss('#r1').text()).not.toBe(valueR1)\n-        expect(await browser.elementByCss('#r2').text()).not.toBe(valueR2)\n-      })\n+    await browser.elementByCss('#revalidate-f').click()\n+    await retry(async () => {\n+      expect(await browser.elementByCss('#a').text()).toBe(valueA)\n+      expect(await browser.elementByCss('#b').text()).toBe(valueB)\n+      expect(await browser.elementByCss('#f1').text()).not.toBe(valueF1)\n+      expect(await browser.elementByCss('#f2').text()).toBe(valueF2)\n+      expect(await browser.elementByCss('#r1').text()).toBe(valueR1)\n+      expect(await browser.elementByCss('#r2').text()).toBe(valueR2)\n     })\n \n-    it('should revalidate caches after redirect', async () => {\n-      const browser = await next.browser('/revalidate-and-redirect')\n-      const valueA = await browser.elementById('a').text()\n-      const valueB = await browser.elementById('b').text()\n+    valueF1 = await browser.elementByCss('#f1').text()\n \n-      expect(valueA).toBe(valueB)\n+    await browser.elementByCss('#revalidate-r').click()\n+    await retry(async () => {\n+      expect(await browser.elementByCss('#a').text()).toBe(valueA)\n+      expect(await browser.elementByCss('#b').text()).toBe(valueB)\n+      expect(await browser.elementByCss('#f1').text()).toBe(valueF1)\n+      expect(await browser.elementByCss('#f2').text()).toBe(valueF2)\n+      expect(await browser.elementByCss('#r1').text()).not.toBe(valueR1)\n+      expect(await browser.elementByCss('#r2').text()).toBe(valueR2)\n+    })\n \n-      await browser\n-        .elementByCss('a[href=\"/revalidate-and-redirect/redirect\"]')\n-        .click()\n+    valueR1 = await browser.elementByCss('#r1').text()\n \n-      await browser.elementById('revalidate-tag-redirect').click()\n+    await browser.elementByCss('#revalidate-path').click()\n+    await retry(async () => {\n+      expect(await browser.elementByCss('#a').text()).not.toBe(valueA)\n+      expect(await browser.elementByCss('#b').text()).not.toBe(valueB)\n+      expect(await browser.elementByCss('#f1').text()).not.toBe(valueF1)\n+      expect(await browser.elementByCss('#f2').text()).not.toBe(valueF2)\n+      expect(await browser.elementByCss('#r1').text()).not.toBe(valueR1)\n+      expect(await browser.elementByCss('#r2').text()).not.toBe(valueR2)\n+    })\n+  })\n \n-      const newValueA = await browser.elementById('a').text()\n-      const newValueB = await browser.elementById('b').text()\n+  it('should revalidate caches after redirect', async () => {\n+    const browser = await next.browser('/revalidate-and-redirect')\n+    const valueA = await browser.elementById('a').text()\n+    const valueB = await browser.elementById('b').text()\n \n-      expect(newValueA).toBe(newValueB)\n-      expect(newValueA).not.toBe(valueA)\n-      expect(newValueB).toBe(newValueB)\n+    expect(valueA).toBe(valueB)\n \n-      await browser\n-        .elementByCss('a[href=\"/revalidate-and-redirect/redirect\"]')\n-        .click()\n-      await browser.elementById('revalidate-path-redirect').click()\n+    await browser\n+      .elementByCss('a[href=\"/revalidate-and-redirect/redirect\"]')\n+      .click()\n \n-      const finalValueA = await browser.elementById('a').text()\n-      const finalValueB = await browser.elementById('b').text()\n+    await browser.elementById('revalidate-tag-redirect').click()\n \n-      expect(finalValueA).not.toBe(newValueA)\n-      expect(finalValueB).not.toBe(newValueB)\n-      expect(finalValueB).toBe(finalValueB)\n-    })\n+    const newValueA = await browser.elementById('a').text()\n+    const newValueB = await browser.elementById('b').text()\n \n-    it('should revalidate caches nested in unstable_cache', async () => {\n-      const browser = await next.browser('/nested-in-unstable-cache')\n-      const initial = await browser.elementByCss('p').text()\n+    expect(newValueA).toBe(newValueB)\n+    expect(newValueA).not.toBe(valueA)\n+    expect(newValueB).toBe(newValueB)\n \n-      if (!isNextDev) {\n-        // Bust the ISR cache first to populate the \"use cache\" in-memory cache for\n-        // the subsequent revalidations.\n-        await browser.elementByCss('button').click()\n+    await browser\n+      .elementByCss('a[href=\"/revalidate-and-redirect/redirect\"]')\n+      .click()\n+    await browser.elementById('revalidate-path-redirect').click()\n \n-        await retry(async () => {\n-          expect(await browser.elementByCss('p').text()).not.toBe(initial)\n-        })\n-      }\n+    const finalValueA = await browser.elementById('a').text()\n+    const finalValueB = await browser.elementById('b').text()\n \n-      const value = await browser.elementByCss('p').text()\n+    expect(finalValueA).not.toBe(newValueA)\n+    expect(finalValueB).not.toBe(newValueB)\n+    expect(finalValueB).toBe(finalValueB)\n+  })\n \n-      await browser.refresh()\n-      expect(await browser.elementByCss('p').text()).toBe(value)\n+  it('should revalidate caches nested in unstable_cache', async () => {\n+    const browser = await next.browser('/nested-in-unstable-cache')\n+    const initial = await browser.elementByCss('p').text()\n \n+    if (!isNextDev) {\n+      // Bust the ISR cache first to populate the \"use cache\" in-memory cache for\n+      // the subsequent revalidations.\n       await browser.elementByCss('button').click()\n \n       await retry(async () => {\n-        expect(await browser.elementByCss('p').text()).not.toBe(value)\n+        expect(await browser.elementByCss('p').text()).not.toBe(initial)\n       })\n+    }\n+\n+    const value = await browser.elementByCss('p').text()\n+\n+    await browser.refresh()\n+    expect(await browser.elementByCss('p').text()).toBe(value)\n+\n+    await browser.elementByCss('button').click()\n+\n+    await retry(async () => {\n+      expect(await browser.elementByCss('p').text()).not.toBe(value)\n     })\n-  }\n+  })\n \n   it('should revalidate caches during on-demand revalidation', async () => {\n     const browser = await next.browser('/on-demand-revalidate')\n@@ -425,55 +426,48 @@ describe('use-cache', () => {\n     })\n   })\n \n-  // TODO: Enable for deploy tests when upstream changes have been rolled out.\n-  if (!isNextDeploy) {\n-    it('should not use stale caches in server actions that have revalidated', async () => {\n-      const browser = await next.browser('/revalidate-and-use')\n-      const useCacheValue1 = await browser\n-        .elementById('use-cache-value-1')\n-        .text()\n-      const useCacheValue2 = await browser\n-        .elementById('use-cache-value-2')\n-        .text()\n-      const fetchedValue = await browser.elementById('fetched-value').text()\n-\n-      expect(useCacheValue1).toEqual(useCacheValue2)\n-\n-      await browser.elementById('revalidate-tag').click()\n-      await browser.waitForElementByCss('#revalidate-tag:enabled')\n-\n-      const useCacheValueBeforeRevalidation = await browser\n-        .elementById('use-cache-value-1')\n-        .text()\n-      const useCacheValueAfterRevalidation = await browser\n-        .elementById('use-cache-value-2')\n-        .text()\n-      const newFetchedValue = await browser.elementById('fetched-value').text()\n-\n-      expect(useCacheValueBeforeRevalidation).toBe(useCacheValue1)\n-      expect(useCacheValueBeforeRevalidation).toBe(useCacheValue2)\n-      expect(useCacheValueBeforeRevalidation).not.toBe(\n-        useCacheValueAfterRevalidation\n-      )\n-      expect(newFetchedValue).not.toBe(fetchedValue)\n+  it('should not use stale caches in server actions that have revalidated', async () => {\n+    const browser = await next.browser('/revalidate-and-use')\n+    const useCacheValue1 = await browser.elementById('use-cache-value-1').text()\n+    const useCacheValue2 = await browser.elementById('use-cache-value-2').text()\n+    const fetchedValue = await browser.elementById('fetched-value').text()\n+\n+    expect(useCacheValue1).toEqual(useCacheValue2)\n+\n+    await browser.elementById('revalidate-tag').click()\n+    await browser.waitForElementByCss('#revalidate-tag:enabled')\n+\n+    const useCacheValueBeforeRevalidation = await browser\n+      .elementById('use-cache-value-1')\n+      .text()\n+    const useCacheValueAfterRevalidation = await browser\n+      .elementById('use-cache-value-2')\n+      .text()\n+    const newFetchedValue = await browser.elementById('fetched-value').text()\n+\n+    expect(useCacheValueBeforeRevalidation).toBe(useCacheValue1)\n+    expect(useCacheValueBeforeRevalidation).toBe(useCacheValue2)\n+    expect(useCacheValueBeforeRevalidation).not.toBe(\n+      useCacheValueAfterRevalidation\n+    )\n+    expect(newFetchedValue).not.toBe(fetchedValue)\n \n-      await browser.elementById('revalidate-path').click()\n-      await browser.waitForElementByCss('#revalidate-path:enabled')\n+    await browser.elementById('revalidate-path').click()\n+    await browser.waitForElementByCss('#revalidate-path:enabled')\n \n-      expect(await browser.elementById('use-cache-value-1').text()).not.toBe(\n-        useCacheValueBeforeRevalidation\n-      )\n-      expect(await browser.elementById('use-cache-value-2').text()).not.toBe(\n-        useCacheValueAfterRevalidation\n-      )\n-      expect(await browser.elementById('use-cache-value-1').text()).not.toBe(\n-        await browser.elementById('use-cache-value-2').text()\n-      )\n-      expect(await browser.elementById('fetched-value').text()).not.toBe(\n-        newFetchedValue\n-      )\n-    })\n-  }\n+    expect(await browser.elementById('use-cache-value-1').text()).not.toBe(\n+      useCacheValueBeforeRevalidation\n+    )\n+    expect(await browser.elementById('use-cache-value-2').text()).not.toBe(\n+      useCacheValueAfterRevalidation\n+    )\n+    expect(await browser.elementById('use-cache-value-1').text()).not.toBe(\n+      await browser.elementById('use-cache-value-2').text()\n+    )\n+    expect(await browser.elementById('fetched-value').text()).not.toBe(\n+      newFetchedValue\n+    )\n+  })\n \n   if (isNextStart) {\n     it('should prerender fully cacheable pages as static HTML', async () => {\n@@ -591,33 +585,30 @@ describe('use-cache', () => {\n     })\n   })\n \n-  // TODO(useCache): Re-activate for deploy tests when NAR-85 is resolved.\n-  if (!isNextDeploy) {\n-    it('should be able to revalidate a page using unstable_expireTag', async () => {\n-      const browser = await next.browser(`/form`)\n-      const time1 = await browser.waitForElementByCss('#t').text()\n+  it('should be able to revalidate a page using unstable_expireTag', async () => {\n+    const browser = await next.browser(`/form`)\n+    const time1 = await browser.waitForElementByCss('#t').text()\n \n-      await browser.loadPage(new URL(`/form`, next.url).toString())\n+    await browser.loadPage(new URL(`/form`, next.url).toString())\n \n-      const time2 = await browser.waitForElementByCss('#t').text()\n+    const time2 = await browser.waitForElementByCss('#t').text()\n \n-      expect(time1).toBe(time2)\n+    expect(time1).toBe(time2)\n \n-      await browser.elementByCss('#refresh').click()\n+    await browser.elementByCss('#refresh').click()\n \n-      await waitFor(500)\n+    await waitFor(500)\n \n-      const time3 = await browser.waitForElementByCss('#t').text()\n+    const time3 = await browser.waitForElementByCss('#t').text()\n \n-      expect(time3).not.toBe(time2)\n+    expect(time3).not.toBe(time2)\n \n-      // Reloading again should ideally be the same value but because the Action seeds\n-      // the cache with real params as the argument it has a different cache key.\n-      // await browser.loadPage(new URL(`/form?c`, next.url).toString())\n-      // const time4 = await browser.waitForElementByCss('#t').text()\n-      // expect(time4).toBe(time3);\n-    })\n-  }\n+    // Reloading again should ideally be the same value but because the Action seeds\n+    // the cache with real params as the argument it has a different cache key.\n+    // await browser.loadPage(new URL(`/form?c`, next.url).toString())\n+    // const time4 = await browser.waitForElementByCss('#t').text()\n+    // expect(time4).toBe(time3);\n+  })\n \n   it('should use revalidate config in fetch', async () => {\n     const browser = await next.browser('/fetch-revalidate')"
        }
    ],
    "stats": {
        "total": 445,
        "additions": 218,
        "deletions": 227
    }
}