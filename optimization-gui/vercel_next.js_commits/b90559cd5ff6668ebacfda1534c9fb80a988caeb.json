{
    "author": "lukesandberg",
    "message": "[turbopack] Remove a bunch of dead code from the source map implementation (#84318)\n\nThe `SourceMap::Sectioned` enum was only used recursively.  once i noticed that a bunch of dead code fell out.\n\nPart-of PACK-417",
    "sha": "b90559cd5ff6668ebacfda1534c9fb80a988caeb",
    "files": [
        {
            "sha": "fdb0b866d22a5c046eab8d0321fbe9e93c3034cf",
            "filename": "crates/napi/src/next_api/project.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 6,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/b90559cd5ff6668ebacfda1534c9fb80a988caeb/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b90559cd5ff6668ebacfda1534c9fb80a988caeb/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs?ref=b90559cd5ff6668ebacfda1534c9fb80a988caeb",
            "patch": "@@ -1491,12 +1491,10 @@ pub async fn project_trace_source_operation(\n         return Ok(Vc::cell(None));\n     };\n \n-    let token = map\n-        .lookup_token(\n-            line.saturating_sub(1),\n-            frame.column.unwrap_or(1).saturating_sub(1),\n-        )\n-        .await?;\n+    let token = map.lookup_token(\n+        line.saturating_sub(1),\n+        frame.column.unwrap_or(1).saturating_sub(1),\n+    );\n \n     let (original_file, line, column, method_name) = match token {\n         Token::Original(token) => ("
        },
        {
            "sha": "749410787cd31494727bcc7859f232c737764660",
            "filename": "turbopack/crates/turbopack-core/src/source_map/mod.rs",
            "status": "modified",
            "additions": 75,
            "deletions": 275,
            "changes": 350,
            "blob_url": "https://github.com/vercel/next.js/blob/b90559cd5ff6668ebacfda1534c9fb80a988caeb/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fsource_map%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b90559cd5ff6668ebacfda1534c9fb80a988caeb/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fsource_map%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fsource_map%2Fmod.rs?ref=b90559cd5ff6668ebacfda1534c9fb80a988caeb",
            "patch": "@@ -63,14 +63,18 @@ pub trait GenerateSourceMap {\n /// The distinction between the source map spec's [sourcemap::Index] and our\n /// [SourceMap::Sectioned] is whether the sections are represented with Vcs\n /// pointers.\n-#[turbo_tasks::value(shared, cell = \"new\")]\n+#[turbo_tasks::value(shared, cell = \"new\", eq = \"manual\")]\n #[derive(Debug)]\n-pub enum SourceMap {\n+pub struct SourceMap {\n     /// A decoded source map contains no Vcs.\n-    Decoded(#[turbo_tasks(trace_ignore)] InnerSourceMap),\n-    /// A sectioned source map contains many (possibly recursive) maps covering\n-    /// different regions of the file.\n-    Sectioned(#[turbo_tasks(trace_ignore)] SectionedSourceMap),\n+    #[turbo_tasks(trace_ignore)]\n+    map: Arc<CrateMapWrapper>,\n+}\n+impl Eq for SourceMap {}\n+impl PartialEq for SourceMap {\n+    fn eq(&self, other: &Self) -> bool {\n+        Arc::ptr_eq(&self.map, &other.map)\n+    }\n }\n \n #[turbo_tasks::value(transparent)]\n@@ -207,49 +211,23 @@ impl TryInto<swc_sourcemap::RawToken> for Token {\n }\n \n impl SourceMap {\n-    pub fn empty_uncelled() -> Self {\n-        let mut builder = SourceMapBuilder::new(None);\n-        builder.add(0, 0, 0, 0, None, None, false);\n-        SourceMap::new_regular(builder.into_sourcemap())\n-    }\n-\n     /// Creates a new SourceMap::Decoded Vc out of a [RegularMap] instance.\n-    pub fn new_regular(map: RegularMap) -> Self {\n+    fn new_regular(map: RegularMap) -> Self {\n         Self::new_decoded(DecodedMap::Regular(map))\n     }\n \n     /// Creates a new SourceMap::Decoded Vc out of a [DecodedMap] instance.\n-    pub fn new_decoded(map: DecodedMap) -> Self {\n-        SourceMap::Decoded(InnerSourceMap::new(map))\n-    }\n-\n-    /// Creates a new SourceMap::Sectioned Vc out of a collection of source map\n-    /// sections.\n-    pub fn new_sectioned(sections: Vec<SourceMapSection>) -> Self {\n-        SourceMap::Sectioned(SectionedSourceMap::new(sections))\n+    fn new_decoded(map: DecodedMap) -> Self {\n+        SourceMap {\n+            map: Arc::new(CrateMapWrapper(map)),\n+        }\n     }\n \n     pub fn new_from_rope(content: &Rope) -> Result<Option<Self>> {\n         let Ok(map) = DecodedMap::from_reader(content.read()) else {\n             return Ok(None);\n         };\n-        Ok(Some(SourceMap::Decoded(InnerSourceMap::new(map))))\n-    }\n-\n-    pub async fn new_from_file(file: FileSystemPath) -> Result<Option<Self>> {\n-        let read = file.read();\n-        Self::new_from_file_content(read).await\n-    }\n-\n-    pub async fn new_from_file_content(content: Vc<FileContent>) -> Result<Option<Self>> {\n-        let content = &content.await?;\n-        let Some(contents) = content.as_content() else {\n-            return Ok(None);\n-        };\n-        let Ok(map) = DecodedMap::from_reader(contents.read()) else {\n-            return Ok(None);\n-        };\n-        Ok(Some(SourceMap::Decoded(InnerSourceMap::new(map))))\n+        Ok(Some(SourceMap::new_decoded(map)))\n     }\n }\n \n@@ -269,27 +247,8 @@ impl SourceMap {\n }\n \n impl SourceMap {\n-    pub async fn to_source_map(&self) -> Result<Arc<CrateMapWrapper>> {\n-        Ok(match self {\n-            Self::Decoded(m) => m.map.clone(),\n-            Self::Sectioned(m) => {\n-                let wrapped = m.to_crate_wrapper().await?;\n-                let sections = wrapped\n-                    .sections\n-                    .iter()\n-                    .map(|s| {\n-                        swc_sourcemap::SourceMapSection::new(\n-                            (s.offset.line, s.offset.column),\n-                            None,\n-                            Some(s.map.0.clone()),\n-                        )\n-                    })\n-                    .collect::<Vec<swc_sourcemap::SourceMapSection>>();\n-                Arc::new(CrateMapWrapper(DecodedMap::Index(SourceMapIndex::new(\n-                    None, sections,\n-                ))))\n-            }\n-        })\n+    pub fn to_source_map(&self) -> Arc<CrateMapWrapper> {\n+        self.map.clone()\n     }\n }\n \n@@ -356,50 +315,31 @@ impl SourceMap {\n             rope += \"}\";\n         }\n \n-        rope += \"]\n-}\";\n+        rope += \"]\";\n+\n+        rope += \"\\n}\";\n \n         Ok(rope.build())\n     }\n \n     /// Stringifies the source map into JSON bytes.\n-    pub async fn to_rope(&self) -> Result<Rope> {\n-        let rope = match self {\n-            SourceMap::Decoded(r) => {\n-                let mut bytes = vec![];\n-                r.0.to_writer(&mut bytes)?;\n-                Rope::from(bytes)\n-            }\n-\n-            SourceMap::Sectioned(s) => {\n-                let sections = s\n-                    .sections\n-                    .iter()\n-                    .map(async |s| Ok((s.offset, s.map.to_rope().await?)))\n-                    .try_join()\n-                    .await?;\n-\n-                Self::sections_to_rope(sections)?\n-            }\n-        };\n-        Ok(rope)\n+    pub fn to_rope(&self) -> Result<Rope> {\n+        let mut bytes = vec![];\n+        self.map.0.to_writer(&mut bytes)?;\n+        Ok(Rope::from(bytes))\n     }\n \n     /// Traces a generated line/column into an mapping token representing either\n     /// synthetic code or user-authored original code.\n-    pub async fn lookup_token(&self, line: u32, column: u32) -> Result<Token> {\n-        let (token, _) = self\n-            .lookup_token_and_source_internal(line, column, true)\n-            .await?;\n-        Ok(token)\n+    pub fn lookup_token(&self, line: u32, column: u32) -> Token {\n+        let (token, _) = self.lookup_token_and_source_internal(line, column, true);\n+        token\n     }\n \n     /// Traces a generated line/column into an mapping token representing either\n     /// synthetic code or user-authored original code.\n     pub async fn lookup_token_and_source(&self, line: u32, column: u32) -> Result<TokenWithSource> {\n-        let (token, content) = self\n-            .lookup_token_and_source_internal(line, column, true)\n-            .await?;\n+        let (token, content) = self.lookup_token_and_source_internal(line, column, true);\n         Ok(TokenWithSource {\n             token,\n             source_content: match content {\n@@ -465,9 +405,10 @@ impl SourceMap {\n             let mut new_sources = Vec::with_capacity(count);\n             let mut new_source_contents = Vec::with_capacity(count);\n             for (source, source_content) in sources.into_iter().zip(source_contents.into_iter()) {\n-                let (source, name) = resolve_source(source, source_content, origin.clone()).await?;\n+                let (source, source_content) =\n+                    resolve_source(source, source_content, origin.clone()).await?;\n                 new_sources.push(source);\n-                new_source_contents.push(Some(name));\n+                new_source_contents.push(Some(source_content));\n             }\n             let mut map =\n                 RegularMap::new(file, tokens, names, new_sources, Some(new_source_contents));\n@@ -529,20 +470,9 @@ impl SourceMap {\n                 }\n             }))\n         }\n-        Ok(match self {\n-            Self::Decoded(m) => {\n-                let map = Box::pin(decoded_map_with_resolved_sources(&m.map, origin)).await?;\n-                Self::Decoded(InnerSourceMap::new(map.0))\n-            }\n-            Self::Sectioned(m) => {\n-                let mut sections = Vec::with_capacity(m.sections.len());\n-                for section in &m.sections {\n-                    let map = Box::pin(section.map.with_resolved_sources(origin.clone())).await?;\n-                    sections.push(SourceMapSection::new(section.offset, map));\n-                }\n-                SourceMap::new_sectioned(sections)\n-            }\n-        })\n+\n+        let map = Box::pin(decoded_map_with_resolved_sources(&self.map, origin)).await?;\n+        Ok(Self::new_decoded(map.0))\n     }\n }\n \n@@ -559,143 +489,67 @@ async fn sourcemap_content_source(path: RcStr, content: RcStr) -> Result<Vc<Box<\n }\n \n impl SourceMap {\n-    async fn lookup_token_and_source_internal(\n+    fn lookup_token_and_source_internal(\n         &self,\n         line: u32,\n         column: u32,\n         need_source_content: bool,\n-    ) -> Result<(Token, Option<Vc<Box<dyn Source>>>)> {\n+    ) -> (Token, Option<Vc<Box<dyn Source>>>) {\n         let mut content: Option<Vc<Box<dyn Source>>> = None;\n \n-        let token: Token = match self {\n-            SourceMap::Decoded(map) => {\n-                let tok = map.lookup_token(line, column);\n-                let mut token = tok.map(Token::from).unwrap_or_else(|| {\n-                    Token::Synthetic(SyntheticToken {\n-                        generated_line: line,\n-                        generated_column: column,\n-                        guessed_original_file: None,\n-                    })\n-                });\n-\n-                if let Token::Synthetic(SyntheticToken {\n-                    guessed_original_file,\n-                    ..\n-                }) = &mut token\n-                    && let DecodedMap::Regular(map) = &map.map.0\n-                    && map.get_source_count() == 1\n-                {\n-                    let source = map.sources().next().unwrap().clone();\n-                    *guessed_original_file = Some(RcStr::from(source));\n-                }\n-\n-                if need_source_content\n-                    && content.is_none()\n-                    && let Some(map) = map.map.as_regular_source_map()\n-                {\n-                    content = tok.and_then(|tok| {\n-                        let src_id = tok.get_src_id();\n-\n-                        let name = map.get_source(src_id);\n-                        let content = map.get_source_contents(src_id);\n-\n-                        let (name, content) = name.zip(content)?;\n-                        Some(sourcemap_content_source(\n-                            name.clone().into(),\n-                            content.clone().into(),\n-                        ))\n-                    });\n-                }\n-\n-                token\n-            }\n-\n-            SourceMap::Sectioned(map) => {\n-                let len = map.sections.len();\n-                let mut low = 0;\n-                let mut high = len;\n-                let pos = SourcePos { line, column };\n-\n-                // A \"greatest lower bound\" binary search. We're looking for the closest section\n-                // offset <= to our line/col.\n-                while low < high {\n-                    let mid = (low + high) / 2;\n-                    if pos < map.sections[mid].offset {\n-                        high = mid;\n-                    } else {\n-                        low = mid + 1;\n-                    }\n-                }\n-\n-                // Our GLB search will return the section immediately to the right of the\n-                // section we actually want to recurse into, because the binary search does not\n-                // early exit on an exact match (it'll `low = mid + 1`).\n-                if low > 0 && low <= len {\n-                    let SourceMapSection { map, offset } = &map.sections[low - 1];\n-                    // We're looking for the position `l` lines into region covered by this\n-                    // sourcemap's section.\n-                    let l = line - offset.line;\n-                    // The source map starts offset by the section's column only on its first line.\n-                    // On the 2nd+ line, the source map covers starting at column 0.\n-                    let c = if line == offset.line {\n-                        column - offset.column\n-                    } else {\n-                        column\n-                    };\n+        let token: Token = {\n+            let map = &self.map;\n \n-                    if need_source_content {\n-                        let result = Box::pin(map.lookup_token_and_source(l, c)).await?;\n-                        return Ok((result.token, result.source_content.map(|v| *v)));\n-                    } else {\n-                        return Ok((Box::pin(map.lookup_token(l, c)).await?, None));\n-                    }\n-                }\n+            let tok = map.lookup_token(line, column);\n+            let mut token = tok.map(Token::from).unwrap_or_else(|| {\n                 Token::Synthetic(SyntheticToken {\n                     generated_line: line,\n                     generated_column: column,\n                     guessed_original_file: None,\n                 })\n+            });\n+\n+            if let Token::Synthetic(SyntheticToken {\n+                guessed_original_file,\n+                ..\n+            }) = &mut token\n+                && let DecodedMap::Regular(map) = &map.0\n+                && map.get_source_count() == 1\n+            {\n+                let source = map.sources().next().unwrap().clone();\n+                *guessed_original_file = Some(RcStr::from(source));\n             }\n+\n+            if need_source_content\n+                && content.is_none()\n+                && let Some(map) = map.as_regular_source_map()\n+            {\n+                content = tok.and_then(|tok| {\n+                    let src_id = tok.get_src_id();\n+\n+                    let name = map.get_source(src_id);\n+                    let content = map.get_source_contents(src_id);\n+\n+                    let (name, content) = name.zip(content)?;\n+                    Some(sourcemap_content_source(\n+                        name.clone().into(),\n+                        content.clone().into(),\n+                    ))\n+                });\n+            }\n+\n+            token\n         };\n \n-        Ok((token, content))\n+        (token, content)\n     }\n }\n \n #[turbo_tasks::value_impl]\n impl GenerateSourceMap for SourceMap {\n     #[turbo_tasks::function]\n-    async fn generate_source_map(self: ResolvedVc<Self>) -> Result<Vc<OptionStringifiedSourceMap>> {\n-        Ok(Vc::cell(Some(self.await?.to_rope().await?)))\n-    }\n-}\n-\n-/// A regular source map covers an entire file.\n-#[derive(Clone, Debug, Serialize, Deserialize)]\n-pub struct InnerSourceMap {\n-    map: Arc<CrateMapWrapper>,\n-}\n-\n-impl InnerSourceMap {\n-    pub fn new(map: DecodedMap) -> Self {\n-        InnerSourceMap {\n-            map: Arc::new(CrateMapWrapper(map)),\n-        }\n-    }\n-}\n-\n-impl Deref for InnerSourceMap {\n-    type Target = Arc<CrateMapWrapper>;\n-\n-    fn deref(&self) -> &Self::Target {\n-        &self.map\n-    }\n-}\n-\n-impl Eq for InnerSourceMap {}\n-impl PartialEq for InnerSourceMap {\n-    fn eq(&self, other: &Self) -> bool {\n-        Arc::ptr_eq(&self.map, &other.map)\n+    fn generate_source_map(&self) -> Result<Vc<OptionStringifiedSourceMap>> {\n+        Ok(Vc::cell(Some(self.to_rope()?)))\n     }\n }\n \n@@ -727,17 +581,6 @@ pub struct RegularMapWrapper(RegularMap);\n unsafe impl Send for RegularMapWrapper {}\n unsafe impl Sync for RegularMapWrapper {}\n \n-#[derive(Debug)]\n-pub struct CrateIndexWrapper {\n-    pub sections: Vec<CrateSectionWrapper>,\n-}\n-\n-#[derive(Debug)]\n-pub struct CrateSectionWrapper {\n-    pub offset: SourcePos,\n-    pub map: Arc<CrateMapWrapper>,\n-}\n-\n impl CrateMapWrapper {\n     pub fn as_regular_source_map(&self) -> Option<Cow<'_, RegularMap>> {\n         match &self.0 {\n@@ -773,46 +616,3 @@ impl<'de> Deserialize<'de> for CrateMapWrapper {\n         Ok(CrateMapWrapper(map))\n     }\n }\n-\n-/// A sectioned source map contains many (possibly recursive) maps covering\n-/// different regions of the file.\n-#[derive(Eq, PartialEq, Debug, Serialize, Deserialize)]\n-pub struct SectionedSourceMap {\n-    sections: Vec<SourceMapSection>,\n-}\n-\n-impl SectionedSourceMap {\n-    pub fn new(sections: Vec<SourceMapSection>) -> Self {\n-        Self { sections }\n-    }\n-\n-    pub async fn to_crate_wrapper(&self) -> Result<CrateIndexWrapper> {\n-        let mut sections = Vec::with_capacity(self.sections.len());\n-        for section in &self.sections {\n-            sections.push(section.to_crate_wrapper().await?);\n-        }\n-        Ok(CrateIndexWrapper { sections })\n-    }\n-}\n-\n-/// A section of a larger sectioned source map, which applies at source\n-/// positions >= the offset (until the next section starts).\n-#[derive(Eq, PartialEq, Debug, Serialize, Deserialize)]\n-pub struct SourceMapSection {\n-    offset: SourcePos,\n-    map: SourceMap,\n-}\n-\n-impl SourceMapSection {\n-    pub fn new(offset: SourcePos, map: SourceMap) -> Self {\n-        Self { offset, map }\n-    }\n-\n-    pub async fn to_crate_wrapper(&self) -> Result<CrateSectionWrapper> {\n-        let map = Box::pin(self.map.to_source_map()).await?;\n-        Ok(CrateSectionWrapper {\n-            offset: self.offset,\n-            map,\n-        })\n-    }\n-}"
        },
        {
            "sha": "58b2584b095a8a08d8e59488e826a47789254b19",
            "filename": "turbopack/crates/turbopack-node/src/source_map/mod.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/b90559cd5ff6668ebacfda1534c9fb80a988caeb/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fsource_map%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b90559cd5ff6668ebacfda1534c9fb80a988caeb/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fsource_map%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fsource_map%2Fmod.rs?ref=b90559cd5ff6668ebacfda1534c9fb80a988caeb",
            "patch": "@@ -232,7 +232,7 @@ async fn resolve_source_mapping(\n     let Some(sm) = &*SourceMap::new_from_rope_cached(sm).await? else {\n         return Ok(ResolvedSourceMapping::NoSourceMap);\n     };\n-    let trace = trace_source_map(sm, line, column, name.map(|s| &**s)).await?;\n+    let trace = trace_source_map(sm, line, column, name.map(|s| &**s));\n     match trace {\n         TraceResult::Found(frame) => {\n             let lib_code = frame.file.contains(\"/node_modules/\");"
        },
        {
            "sha": "cd336d5afc49ca547b3da80e3e10f99b715f5ee2",
            "filename": "turbopack/crates/turbopack-node/src/source_map/trace.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 10,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/b90559cd5ff6668ebacfda1534c9fb80a988caeb/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fsource_map%2Ftrace.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b90559cd5ff6668ebacfda1534c9fb80a988caeb/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fsource_map%2Ftrace.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fsource_map%2Ftrace.rs?ref=b90559cd5ff6668ebacfda1534c9fb80a988caeb",
            "patch": "@@ -1,6 +1,5 @@\n use std::{borrow::Cow, fmt::Display};\n \n-use anyhow::Result;\n use serde::{Deserialize, Serialize};\n use turbopack_core::source_map::{SourceMap, Token};\n use turbopack_ecmascript::magic_identifier::unmangle_identifiers;\n@@ -91,16 +90,14 @@ pub enum TraceResult {\n /// memory hog, it'd be so much faster if we could just directly access\n /// the individual sections of the JS file's map without the\n /// serialization.\n-pub async fn trace_source_map(\n+pub fn trace_source_map(\n     map: &SourceMap,\n     line: u32,\n     column: u32,\n     name: Option<&str>,\n-) -> Result<TraceResult> {\n-    let token = map\n-        .lookup_token(line.saturating_sub(1), column.saturating_sub(1))\n-        .await?;\n-    let result = match token {\n+) -> TraceResult {\n+    let token = map.lookup_token(line.saturating_sub(1), column.saturating_sub(1));\n+    match token {\n         Token::Original(t) => TraceResult::Found(StackFrame {\n             file: Cow::Owned(t.original_file.into_owned()),\n             line: Some(t.original_line.saturating_add(1)),\n@@ -113,7 +110,5 @@ pub async fn trace_source_map(\n                 .map(Cow::Owned),\n         }),\n         _ => TraceResult::NotFound,\n-    };\n-\n-    Ok(result)\n+    }\n }"
        }
    ],
    "stats": {
        "total": 377,
        "additions": 85,
        "deletions": 292
    }
}