{
    "author": "mischnic",
    "message": "Turbopack: fix export collection (#80203)\n\nThis was slightly broken, as I noticed while debugging scope hoisting",
    "sha": "4272eb0aedc9ce2e6b744bf3e682332ca3824a26",
    "files": [
        {
            "sha": "0acf6788da80cd95ab131491b0315637d4ea5f19",
            "filename": "turbopack/crates/turbopack-ecmascript/src/analyzer/imports.rs",
            "status": "modified",
            "additions": 37,
            "deletions": 20,
            "changes": 57,
            "blob_url": "https://github.com/vercel/next.js/blob/4272eb0aedc9ce2e6b744bf3e682332ca3824a26/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fanalyzer%2Fimports.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4272eb0aedc9ce2e6b744bf3e682332ca3824a26/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fanalyzer%2Fimports.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fanalyzer%2Fimports.rs?ref=4272eb0aedc9ce2e6b744bf3e682332ca3824a26",
            "patch": "@@ -3,7 +3,7 @@ use std::{collections::BTreeMap, fmt::Display};\n use once_cell::sync::Lazy;\n use rustc_hash::{FxHashMap, FxHashSet};\n use swc_core::{\n-    common::{BytePos, Span, Spanned, comments::Comments, source_map::SmallPos},\n+    common::{BytePos, Span, Spanned, SyntaxContext, comments::Comments, source_map::SmallPos},\n     ecma::{\n         ast::*,\n         atoms::{Atom, atom},\n@@ -19,6 +19,7 @@ use super::{JsValue, ModuleValue, top_level_await::has_top_level_await};\n use crate::{\n     SpecifiedModuleType,\n     analyzer::{ConstantValue, ObjectPart},\n+    magic_identifier,\n     tree_shake::{PartId, find_turbopack_part_id_in_asserts},\n };\n \n@@ -447,10 +448,10 @@ impl Analyzer<'_> {\n     }\n }\n \n-fn to_word(name: &ModuleExportName) -> Atom {\n+fn export_as_atom(name: &ModuleExportName) -> &Atom {\n     match name {\n-        ModuleExportName::Ident(ident) => ident.sym.clone(),\n-        ModuleExportName::Str(str) => str.value.clone(),\n+        ModuleExportName::Ident(ident) => &ident.sym,\n+        ModuleExportName::Str(s) => &s.value,\n     }\n }\n \n@@ -542,6 +543,7 @@ impl Visit for Analyzer<'_> {\n         self.data.has_exports = true;\n \n         let Some(ref src) = export.src else {\n+            export.visit_children_with(self);\n             return;\n         };\n \n@@ -575,7 +577,7 @@ impl Visit for Analyzer<'_> {\n                     self.data.reexports.push((\n                         i,\n                         Reexport::Namespace {\n-                            exported: to_word(&n.name),\n+                            exported: export_as_atom(&n.name).clone(),\n                         },\n                     ));\n                 }\n@@ -592,8 +594,9 @@ impl Visit for Analyzer<'_> {\n                     self.data.reexports.push((\n                         i,\n                         Reexport::Named {\n-                            imported: to_word(&n.orig),\n-                            exported: to_word(n.exported.as_ref().unwrap_or(&n.orig)),\n+                            imported: export_as_atom(&n.orig).clone(),\n+                            exported: export_as_atom(n.exported.as_ref().unwrap_or(&n.orig))\n+                                .clone(),\n                         },\n                     ));\n                 }\n@@ -637,6 +640,15 @@ impl Visit for Analyzer<'_> {\n             // only visit children if we potentially need to mark import / requires\n             n.visit_children_with(self);\n         }\n+\n+        self.data.exports.insert(\n+            rcstr!(\"default\"),\n+            (\n+                // `EsmModuleItem::code_generation` inserts this variable.\n+                magic_identifier::mangle(\"default export\").into(),\n+                SyntaxContext::empty(),\n+            ),\n+        );\n     }\n     fn visit_export_default_expr(&mut self, n: &ExportDefaultExpr) {\n         self.data.has_exports = true;\n@@ -645,14 +657,27 @@ impl Visit for Analyzer<'_> {\n             // only visit children if we potentially need to mark import / requires\n             n.visit_children_with(self);\n         }\n+\n+        self.data.exports.insert(\n+            rcstr!(\"default\"),\n+            (\n+                // `EsmModuleItem::code_generation` inserts this variable.\n+                magic_identifier::mangle(\"default export\").into(),\n+                SyntaxContext::empty(),\n+            ),\n+        );\n     }\n \n     fn visit_export_named_specifier(&mut self, n: &ExportNamedSpecifier) {\n-        if let ModuleExportName::Ident(ident) = &n.exported.as_ref().unwrap_or(&n.orig) {\n-            self.data\n-                .exports\n-                .insert(ident.sym.as_str().into(), ident.to_id());\n-        }\n+        let ModuleExportName::Ident(local) = &n.orig else {\n+            // This is only possible for re-exports, but they are already handled earlier in\n+            // visit_named_export.\n+            unreachable!(\"string reexports should have been already handled in visit_named_export\");\n+        };\n+        let exported = n.exported.as_ref().unwrap_or(&n.orig);\n+        self.data\n+            .exports\n+            .insert(export_as_atom(exported).as_str().into(), local.to_id());\n     }\n \n     fn visit_export_default_specifier(&mut self, n: &ExportDefaultSpecifier) {\n@@ -661,14 +686,6 @@ impl Visit for Analyzer<'_> {\n             .insert(rcstr!(\"default\"), n.exported.to_id());\n     }\n \n-    fn visit_export_namespace_specifier(&mut self, n: &ExportNamespaceSpecifier) {\n-        if let ModuleExportName::Ident(ident) = &n.name {\n-            self.data\n-                .exports\n-                .insert(ident.sym.as_str().into(), ident.to_id());\n-        }\n-    }\n-\n     fn visit_program(&mut self, m: &Program) {\n         self.data.has_top_level_await = has_top_level_await(m).is_some();\n "
        },
        {
            "sha": "da0e02b1862f186972b563d8bf2d574211dedd52",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/esm/export.rs",
            "status": "modified",
            "additions": 31,
            "deletions": 14,
            "changes": 45,
            "blob_url": "https://github.com/vercel/next.js/blob/4272eb0aedc9ce2e6b744bf3e682332ca3824a26/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fexport.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4272eb0aedc9ce2e6b744bf3e682332ca3824a26/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fexport.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fexport.rs?ref=4272eb0aedc9ce2e6b744bf3e682332ca3824a26",
            "patch": "@@ -1,10 +1,10 @@\n use std::{borrow::Cow, collections::BTreeMap, ops::ControlFlow};\n \n-use anyhow::Result;\n+use anyhow::{Result, bail};\n use rustc_hash::FxHashSet;\n use serde::{Deserialize, Serialize};\n use swc_core::{\n-    common::DUMMY_SP,\n+    common::{DUMMY_SP, SyntaxContext},\n     ecma::ast::{\n         AssignTarget, ComputedPropName, Expr, ExprStmt, Ident, KeyValueProp, Lit, MemberExpr,\n         MemberProp, ObjectLit, Prop, PropName, PropOrSpread, SimpleAssignTarget, Stmt, Str,\n@@ -565,21 +565,38 @@ impl EsmExports {\n                     \"(() => { throw new Error(\\\"Failed binding. See build errors!\\\"); })\" as Expr,\n                 )),\n                 EsmExport::LocalBinding(name, mutable) => {\n-                    let local = if name == \"default\" {\n-                        Cow::Owned(magic_identifier::mangle(\"default export\"))\n+                    // TODO ideally, this information would just be stored in\n+                    // EsmExport::LocalBinding and we wouldn't have to re-correlated this\n+                    // information with eval_context.imports.exports to get the syntax context.\n+                    let binding = if let Some(parsed) = &parsed {\n+                        if let ParseResult::Ok { eval_context, .. } = &**parsed {\n+                            if let Some((local, ctxt)) = eval_context.imports.exports.get(exported)\n+                            {\n+                                Some((Cow::Borrowed(local.as_str()), *ctxt))\n+                            } else {\n+                                bail!(\n+                                    \"Expected export to be in eval context {:?} {:?}\",\n+                                    exported,\n+                                    eval_context.imports,\n+                                )\n+                            }\n+                        } else {\n+                            None\n+                        }\n                     } else {\n-                        Cow::Borrowed(name.as_str())\n+                        None\n                     };\n-                    let ctxt = parsed\n-                        .as_ref()\n-                        .and_then(|parsed| {\n-                            if let ParseResult::Ok { eval_context, .. } = &**parsed {\n-                                eval_context.imports.exports.get(name).map(|id| id.1)\n+                    let (local, ctxt) = binding.unwrap_or_else(|| {\n+                        // Fallback, shouldn't happen in practice\n+                        (\n+                            if name == \"default\" {\n+                                Cow::Owned(magic_identifier::mangle(\"default export\"))\n                             } else {\n-                                None\n-                            }\n-                        })\n-                        .unwrap_or_default();\n+                                Cow::Borrowed(name.as_str())\n+                            },\n+                            SyntaxContext::empty(),\n+                        )\n+                    });\n \n                     if *mutable {\n                         Some(quote!("
        }
    ],
    "stats": {
        "total": 102,
        "additions": 68,
        "deletions": 34
    }
}