{
    "author": "mischnic",
    "message": "Turbopack: less CodeGenerateable for references (#75963)\n\nGet rid of `CodeGenerateable` for `EsmExports` and all references, except for `EsmAssetReference`, which unfortunately represents 99% of all references, but is also the most complicated one (esp regarding order and tree shaking).\r\n\r\n```\r\ntesting against 0293c96cf32\r\n\r\n\r\ncanary 71d8bfcc1f\r\n14.8gb\r\n529.67s user 81.57s system 883% cpu 1:09.18 total\r\n\r\nmischnic/codegen-fewer-tasks 72eba1ead2\r\n14.8gb\r\n533.13s user 82.01s system 874% cpu 1:10.32 total\r\n\r\nmischnic/codegen-fewer-tasks don't store twice\r\n14.6gb\r\n529.85s user 82.35s system 875% cpu 1:09.90 total\r\n```",
    "sha": "d854b8b12ea78298f7b077c27c98b168cdf07a96",
    "files": [
        {
            "sha": "84e613a58a949daeda1175baabe0ac4a04702982",
            "filename": "turbopack/crates/turbopack-core/src/environment.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/d854b8b12ea78298f7b077c27c98b168cdf07a96/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fenvironment.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d854b8b12ea78298f7b077c27c98b168cdf07a96/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fenvironment.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fenvironment.rs?ref=d854b8b12ea78298f7b077c27c98b168cdf07a96",
            "patch": "@@ -6,15 +6,15 @@ use std::{\n use anyhow::{anyhow, Context, Result};\n use swc_core::ecma::preset_env::{Version, Versions};\n use turbo_rcstr::RcStr;\n-use turbo_tasks::{ResolvedVc, Value, Vc};\n+use turbo_tasks::{ResolvedVc, TaskInput, Value, Vc};\n use turbo_tasks_env::ProcessEnv;\n \n use crate::target::CompileTarget;\n \n static DEFAULT_NODEJS_VERSION: &str = \"16.0.0\";\n \n #[turbo_tasks::value]\n-#[derive(Default)]\n+#[derive(Clone, Copy, Default, Hash, TaskInput, Debug)]\n pub enum Rendering {\n     #[default]\n     None,"
        },
        {
            "sha": "60ff5eb0aaced2ed80307f05df499b87d343e7d0",
            "filename": "turbopack/crates/turbopack-ecmascript/src/code_gen.rs",
            "status": "modified",
            "additions": 38,
            "deletions": 7,
            "changes": 45,
            "blob_url": "https://github.com/vercel/next.js/blob/d854b8b12ea78298f7b077c27c98b168cdf07a96/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fcode_gen.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d854b8b12ea78298f7b077c27c98b168cdf07a96/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fcode_gen.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fcode_gen.rs?ref=d854b8b12ea78298f7b077c27c98b168cdf07a96",
            "patch": "@@ -5,19 +5,30 @@ use swc_core::ecma::{\n     visit::{AstParentKind, VisitMut},\n };\n use turbo_rcstr::RcStr;\n-use turbo_tasks::{debug::ValueDebugFormat, trace::TraceRawVcs, NonLocalValue, Vc};\n-use turbopack_core::{chunk::ChunkingContext, module_graph::ModuleGraph};\n+use turbo_tasks::{debug::ValueDebugFormat, trace::TraceRawVcs, NonLocalValue, ResolvedVc, Vc};\n+use turbopack_core::{\n+    chunk::ChunkingContext, module_graph::ModuleGraph, reference::ModuleReference,\n+};\n \n use crate::references::{\n     amd::AmdDefineWithDependenciesCodeGen,\n-    cjs::CjsRequireCacheAccess,\n+    cjs::{\n+        CjsRequireAssetReferenceCodeGen, CjsRequireCacheAccess,\n+        CjsRequireResolveAssetReferenceCodeGen,\n+    },\n     constant_condition::ConstantConditionCodeGen,\n     constant_value::ConstantValueCodeGen,\n     dynamic_expression::DynamicExpression,\n-    esm::{EsmBinding, EsmModuleItem, ImportMetaBinding, ImportMetaRef},\n+    esm::{\n+        dynamic::EsmAsyncAssetReferenceCodeGen, module_id::EsmModuleIdAssetReferenceCodeGen,\n+        url::UrlAssetReferenceCodeGen, EsmBinding, EsmModuleItem, ImportMetaBinding, ImportMetaRef,\n+    },\n     ident::IdentReplacement,\n     member::MemberReplacement,\n+    require_context::RequireContextAssetReferenceCodeGen,\n     unreachable::Unreachable,\n+    worker::WorkerAssetReferenceCodeGen,\n+    AstPath,\n };\n \n /// impl of code generation inferred from a ModuleReference.\n@@ -39,11 +50,10 @@ pub struct CodeGeneration {\n }\n \n impl CodeGeneration {\n-    pub fn empty() -> Vc<Self> {\n+    pub fn empty() -> Self {\n         CodeGeneration {\n             ..Default::default()\n         }\n-        .cell()\n     }\n \n     pub fn new(\n@@ -109,7 +119,7 @@ pub trait CodeGenerateable {\n \n #[derive(PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue)]\n pub enum CodeGen {\n-    // AMD occurs very rarely and makes the enum more than 2x bigger\n+    // AMD occurs very rarely and makes the enum much bigger\n     AmdDefineWithDependenciesCodeGen(Box<AmdDefineWithDependenciesCodeGen>),\n     CjsRequireCacheAccess(CjsRequireCacheAccess),\n     ConstantConditionCodeGen(ConstantConditionCodeGen),\n@@ -122,6 +132,13 @@ pub enum CodeGen {\n     ImportMetaRef(ImportMetaRef),\n     MemberReplacement(MemberReplacement),\n     Unreachable(Unreachable),\n+    CjsRequireAssetReferenceCodeGen(CjsRequireAssetReferenceCodeGen),\n+    CjsRequireResolveAssetReferenceCodeGen(CjsRequireResolveAssetReferenceCodeGen),\n+    EsmAsyncAssetReferenceCodeGen(EsmAsyncAssetReferenceCodeGen),\n+    EsmModuleIdAssetReferenceCodeGen(EsmModuleIdAssetReferenceCodeGen),\n+    RequireContextAssetReferenceCodeGen(RequireContextAssetReferenceCodeGen),\n+    UrlAssetReferenceCodeGen(UrlAssetReferenceCodeGen),\n+    WorkerAssetReferenceCodeGen(WorkerAssetReferenceCodeGen),\n }\n \n impl CodeGen {\n@@ -143,13 +160,27 @@ impl CodeGen {\n             Self::ImportMetaRef(v) => v.code_generation(g, ctx).await,\n             Self::MemberReplacement(v) => v.code_generation(g, ctx).await,\n             Self::Unreachable(v) => v.code_generation(g, ctx).await,\n+            Self::CjsRequireAssetReferenceCodeGen(v) => v.code_generation(g, ctx).await,\n+            Self::CjsRequireResolveAssetReferenceCodeGen(v) => v.code_generation(g, ctx).await,\n+            Self::EsmAsyncAssetReferenceCodeGen(v) => v.code_generation(g, ctx).await,\n+            Self::EsmModuleIdAssetReferenceCodeGen(v) => v.code_generation(g, ctx).await,\n+            Self::RequireContextAssetReferenceCodeGen(v) => v.code_generation(g, ctx).await,\n+            Self::UrlAssetReferenceCodeGen(v) => v.code_generation(g, ctx).await,\n+            Self::WorkerAssetReferenceCodeGen(v) => v.code_generation(g, ctx).await,\n         }\n     }\n }\n \n #[turbo_tasks::value(transparent)]\n pub struct CodeGens(Vec<CodeGen>);\n \n+pub trait IntoCodeGenReference {\n+    fn into_code_gen_reference(\n+        self,\n+        path: AstPath,\n+    ) -> (ResolvedVc<Box<dyn ModuleReference>>, CodeGen);\n+}\n+\n pub fn path_to(\n     path: &[AstParentKind],\n     f: impl FnMut(&AstParentKind) -> bool,"
        },
        {
            "sha": "5199e6257f8c0761ac46f34950a6d7e0c08b1a0b",
            "filename": "turbopack/crates/turbopack-ecmascript/src/lib.rs",
            "status": "modified",
            "additions": 31,
            "deletions": 12,
            "changes": 43,
            "blob_url": "https://github.com/vercel/next.js/blob/d854b8b12ea78298f7b077c27c98b168cdf07a96/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d854b8b12ea78298f7b077c27c98b168cdf07a96/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs?ref=d854b8b12ea78298f7b077c27c98b168cdf07a96",
            "patch": "@@ -780,17 +780,32 @@ impl EcmascriptModuleContent {\n                 code_gen_cells.push(code_gen.code_generation(module_graph, chunking_context));\n             }\n         }\n-        if let Some(async_module) = *async_module.await? {\n-            code_gen_cells.push(async_module.code_generation(\n-                async_module_info,\n-                references,\n-                module_graph,\n-                chunking_context,\n-            ));\n-        }\n-        if let EcmascriptExports::EsmExports(exports) = *exports.await? {\n-            code_gen_cells.push(exports.code_generation(module_graph, chunking_context));\n-        }\n+\n+        let additional_code_gens = [\n+            if let Some(async_module) = &*async_module.await? {\n+                Some(\n+                    async_module\n+                        .code_generation(\n+                            async_module_info,\n+                            references,\n+                            module_graph,\n+                            chunking_context,\n+                        )\n+                        .await?,\n+                )\n+            } else {\n+                None\n+            },\n+            if let EcmascriptExports::EsmExports(exports) = *exports.await? {\n+                Some(\n+                    exports\n+                        .code_generation(module_graph, chunking_context)\n+                        .await?,\n+                )\n+            } else {\n+                None\n+            },\n+        ];\n \n         let code_gens = code_generation\n             .await?\n@@ -800,7 +815,11 @@ impl EcmascriptModuleContent {\n             .await?;\n         let code_gen_cells = code_gen_cells.into_iter().try_join().await?;\n \n-        let code_gens = code_gen_cells.iter().map(|c| &**c).chain(code_gens.iter());\n+        let code_gens = code_gen_cells\n+            .iter()\n+            .map(|c| &**c)\n+            .chain(additional_code_gens.iter().flatten())\n+            .chain(code_gens.iter());\n         gen_content_with_code_gens(\n             parsed,\n             ident,"
        },
        {
            "sha": "64bbc095d111d76c42f474826c6fd39739c3020e",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/async_module.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/d854b8b12ea78298f7b077c27c98b168cdf07a96/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fasync_module.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d854b8b12ea78298f7b077c27c98b168cdf07a96/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fasync_module.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fasync_module.rs?ref=d854b8b12ea78298f7b077c27c98b168cdf07a96",
            "patch": "@@ -190,15 +190,16 @@ impl AsyncModule {\n             has_top_level_await: self.has_top_level_await,\n         }))\n     }\n+}\n \n-    #[turbo_tasks::function]\n+impl AsyncModule {\n     pub async fn code_generation(\n         self: Vc<Self>,\n         async_module_info: Option<Vc<AsyncModuleInfo>>,\n         references: Vc<ModuleReferences>,\n         module_graph: Vc<ModuleGraph>,\n         chunking_context: Vc<Box<dyn ChunkingContext>>,\n-    ) -> Result<Vc<CodeGeneration>> {\n+    ) -> Result<CodeGeneration> {\n         if let Some(async_module_info) = async_module_info {\n             let async_idents = self\n                 .get_async_idents(\n@@ -245,7 +246,7 @@ impl AsyncModule {\n                                 type_ann: None,\n                             }.into(),\n                         )),\n-                ].to_vec()).cell());\n+                ].to_vec()));\n             }\n         }\n "
        },
        {
            "sha": "a047d0c6ec9a55fe293157ef0e35f124ed7a9078",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/cjs.rs",
            "status": "modified",
            "additions": 68,
            "deletions": 45,
            "changes": 113,
            "blob_url": "https://github.com/vercel/next.js/blob/d854b8b12ea78298f7b077c27c98b168cdf07a96/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fcjs.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d854b8b12ea78298f7b077c27c98b168cdf07a96/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fcjs.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fcjs.rs?ref=d854b8b12ea78298f7b077c27c98b168cdf07a96",
            "patch": "@@ -19,7 +19,7 @@ use turbopack_core::{\n use turbopack_resolve::ecmascript::cjs_resolve;\n \n use crate::{\n-    code_gen::{CodeGen, CodeGenerateable, CodeGeneration},\n+    code_gen::{CodeGen, CodeGeneration, IntoCodeGenReference},\n     create_visitor,\n     references::{\n         pattern_mapping::{PatternMapping, ResolveType},\n@@ -86,28 +86,23 @@ impl ChunkableModuleReference for CjsAssetReference {}\n pub struct CjsRequireAssetReference {\n     pub origin: ResolvedVc<Box<dyn ResolveOrigin>>,\n     pub request: ResolvedVc<Request>,\n-    pub path: AstPath,\n     pub issue_source: IssueSource,\n     pub in_try: bool,\n }\n \n-#[turbo_tasks::value_impl]\n impl CjsRequireAssetReference {\n-    #[turbo_tasks::function]\n     pub fn new(\n         origin: ResolvedVc<Box<dyn ResolveOrigin>>,\n         request: ResolvedVc<Request>,\n-        path: AstPath,\n         issue_source: IssueSource,\n         in_try: bool,\n-    ) -> Vc<Self> {\n-        Self::cell(CjsRequireAssetReference {\n+    ) -> Self {\n+        CjsRequireAssetReference {\n             origin,\n             request,\n-            path,\n             issue_source,\n             in_try,\n-        })\n+        }\n     }\n }\n \n@@ -137,25 +132,42 @@ impl ValueToString for CjsRequireAssetReference {\n #[turbo_tasks::value_impl]\n impl ChunkableModuleReference for CjsRequireAssetReference {}\n \n-#[turbo_tasks::value_impl]\n-impl CodeGenerateable for CjsRequireAssetReference {\n-    #[turbo_tasks::function]\n-    async fn code_generation(\n+impl IntoCodeGenReference for CjsRequireAssetReference {\n+    fn into_code_gen_reference(\n+        self,\n+        path: AstPath,\n+    ) -> (ResolvedVc<Box<dyn ModuleReference>>, CodeGen) {\n+        let reference = self.resolved_cell();\n+        (\n+            ResolvedVc::upcast(reference),\n+            CodeGen::CjsRequireAssetReferenceCodeGen(CjsRequireAssetReferenceCodeGen {\n+                reference,\n+                path,\n+            }),\n+        )\n+    }\n+}\n+\n+#[derive(PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue)]\n+pub struct CjsRequireAssetReferenceCodeGen {\n+    reference: ResolvedVc<CjsRequireAssetReference>,\n+    path: AstPath,\n+}\n+\n+impl CjsRequireAssetReferenceCodeGen {\n+    pub async fn code_generation(\n         &self,\n         module_graph: Vc<ModuleGraph>,\n         chunking_context: Vc<Box<dyn ChunkingContext>>,\n-    ) -> Result<Vc<CodeGeneration>> {\n+    ) -> Result<CodeGeneration> {\n+        let reference = self.reference.await?;\n+\n         let pm = PatternMapping::resolve_request(\n-            *self.request,\n-            *self.origin,\n+            *reference.request,\n+            *reference.origin,\n             module_graph,\n             Vc::upcast(chunking_context),\n-            cjs_resolve(\n-                *self.origin,\n-                *self.request,\n-                Some(self.issue_source.clone()),\n-                self.in_try,\n-            ),\n+            self.reference.resolve_reference(),\n             ResolveType::ChunkItem,\n         )\n         .await?;\n@@ -185,7 +197,7 @@ impl CodeGenerateable for CjsRequireAssetReference {\n             );\n         }));\n \n-        Ok(CodeGeneration::visitors(visitors).cell())\n+        Ok(CodeGeneration::visitors(visitors))\n     }\n }\n \n@@ -194,28 +206,23 @@ impl CodeGenerateable for CjsRequireAssetReference {\n pub struct CjsRequireResolveAssetReference {\n     pub origin: ResolvedVc<Box<dyn ResolveOrigin>>,\n     pub request: ResolvedVc<Request>,\n-    pub path: AstPath,\n     pub issue_source: IssueSource,\n     pub in_try: bool,\n }\n \n-#[turbo_tasks::value_impl]\n impl CjsRequireResolveAssetReference {\n-    #[turbo_tasks::function]\n     pub fn new(\n         origin: ResolvedVc<Box<dyn ResolveOrigin>>,\n         request: ResolvedVc<Request>,\n-        path: AstPath,\n         issue_source: IssueSource,\n         in_try: bool,\n-    ) -> Vc<Self> {\n-        Self::cell(CjsRequireResolveAssetReference {\n+    ) -> Self {\n+        CjsRequireResolveAssetReference {\n             origin,\n             request,\n-            path,\n             issue_source,\n             in_try,\n-        })\n+        }\n     }\n }\n \n@@ -245,25 +252,41 @@ impl ValueToString for CjsRequireResolveAssetReference {\n #[turbo_tasks::value_impl]\n impl ChunkableModuleReference for CjsRequireResolveAssetReference {}\n \n-#[turbo_tasks::value_impl]\n-impl CodeGenerateable for CjsRequireResolveAssetReference {\n-    #[turbo_tasks::function]\n-    async fn code_generation(\n+impl IntoCodeGenReference for CjsRequireResolveAssetReference {\n+    fn into_code_gen_reference(\n+        self,\n+        path: AstPath,\n+    ) -> (ResolvedVc<Box<dyn ModuleReference>>, CodeGen) {\n+        let reference = self.resolved_cell();\n+        (\n+            ResolvedVc::upcast(reference),\n+            CodeGen::CjsRequireResolveAssetReferenceCodeGen(\n+                CjsRequireResolveAssetReferenceCodeGen { reference, path },\n+            ),\n+        )\n+    }\n+}\n+\n+#[derive(PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue)]\n+pub struct CjsRequireResolveAssetReferenceCodeGen {\n+    reference: ResolvedVc<CjsRequireResolveAssetReference>,\n+    path: AstPath,\n+}\n+\n+impl CjsRequireResolveAssetReferenceCodeGen {\n+    pub async fn code_generation(\n         &self,\n         module_graph: Vc<ModuleGraph>,\n         chunking_context: Vc<Box<dyn ChunkingContext>>,\n-    ) -> Result<Vc<CodeGeneration>> {\n+    ) -> Result<CodeGeneration> {\n+        let reference = self.reference.await?;\n+\n         let pm = PatternMapping::resolve_request(\n-            *self.request,\n-            *self.origin,\n+            *reference.request,\n+            *reference.origin,\n             module_graph,\n             Vc::upcast(chunking_context),\n-            cjs_resolve(\n-                *self.origin,\n-                *self.request,\n-                Some(self.issue_source.clone()),\n-                self.in_try,\n-            ),\n+            self.reference.resolve_reference(),\n             ResolveType::ChunkItem,\n         )\n         .await?;\n@@ -297,7 +320,7 @@ impl CodeGenerateable for CjsRequireResolveAssetReference {\n             // but we can ignore that as it will be recomputed anyway.\n         }));\n \n-        Ok(CodeGeneration::visitors(visitors).cell())\n+        Ok(CodeGeneration::visitors(visitors))\n     }\n }\n "
        },
        {
            "sha": "29d03a5748dd0b4ae68ecc298b15120c601e5304",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/esm/base.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/d854b8b12ea78298f7b077c27c98b168cdf07a96/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fbase.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d854b8b12ea78298f7b077c27c98b168cdf07a96/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fbase.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fbase.rs?ref=d854b8b12ea78298f7b077c27c98b168cdf07a96",
            "patch": "@@ -110,7 +110,7 @@ impl ReferencedAsset {\n     }\n }\n \n-#[turbo_tasks::value]\n+#[turbo_tasks::value(shared)]\n #[derive(Hash, Debug)]\n pub struct EsmAssetReference {\n     pub origin: ResolvedVc<Box<dyn ResolveOrigin>>,\n@@ -139,15 +139,15 @@ impl EsmAssetReference {\n         annotations: Value<ImportAnnotations>,\n         export_name: Option<ModulePart>,\n         import_externals: bool,\n-    ) -> Vc<Self> {\n-        Self::cell(EsmAssetReference {\n+    ) -> Self {\n+        EsmAssetReference {\n             origin,\n             request,\n             issue_source,\n             annotations: annotations.into_value(),\n             export_name,\n             import_externals,\n-        })\n+        }\n     }\n }\n \n@@ -394,7 +394,7 @@ impl CodeGenerateable for EsmAssetReference {\n         if let Some((key, stmt)) = result {\n             Ok(CodeGeneration::hoisted_stmt(key, stmt).cell())\n         } else {\n-            Ok(CodeGeneration::empty())\n+            Ok(CodeGeneration::empty().cell())\n         }\n     }\n }"
        },
        {
            "sha": "5cc3779658cc87346f88555038a75a78a0cbcda1",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/esm/dynamic.rs",
            "status": "modified",
            "additions": 41,
            "deletions": 27,
            "changes": 68,
            "blob_url": "https://github.com/vercel/next.js/blob/d854b8b12ea78298f7b077c27c98b168cdf07a96/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fdynamic.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d854b8b12ea78298f7b077c27c98b168cdf07a96/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fdynamic.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fdynamic.rs?ref=d854b8b12ea78298f7b077c27c98b168cdf07a96",
            "patch": "@@ -1,11 +1,15 @@\n use anyhow::Result;\n+use serde::{Deserialize, Serialize};\n use swc_core::{\n     common::{util::take::Take, DUMMY_SP},\n     ecma::ast::{CallExpr, Callee, Expr, ExprOrSpread, Lit},\n     quote_expr,\n };\n use turbo_rcstr::RcStr;\n-use turbo_tasks::{ResolvedVc, Value, ValueToString, Vc};\n+use turbo_tasks::{\n+    debug::ValueDebugFormat, trace::TraceRawVcs, NonLocalValue, ResolvedVc, Value, ValueToString,\n+    Vc,\n+};\n use turbopack_core::{\n     chunk::{ChunkableModuleReference, ChunkingContext, ChunkingType, ChunkingTypeOption},\n     environment::ChunkLoading,\n@@ -24,7 +28,7 @@ use turbopack_resolve::ecmascript::esm_resolve;\n use super::super::pattern_mapping::{PatternMapping, ResolveType};\n use crate::{\n     analyzer::imports::ImportAnnotations,\n-    code_gen::{CodeGenerateable, CodeGeneration},\n+    code_gen::{CodeGen, CodeGeneration, IntoCodeGenReference},\n     create_visitor,\n     references::AstPath,\n };\n@@ -34,7 +38,6 @@ use crate::{\n pub struct EsmAsyncAssetReference {\n     pub origin: ResolvedVc<Box<dyn ResolveOrigin>>,\n     pub request: ResolvedVc<Request>,\n-    pub path: AstPath,\n     pub annotations: ImportAnnotations,\n     pub issue_source: IssueSource,\n     pub in_try: bool,\n@@ -51,27 +54,23 @@ impl EsmAsyncAssetReference {\n     }\n }\n \n-#[turbo_tasks::value_impl]\n impl EsmAsyncAssetReference {\n-    #[turbo_tasks::function]\n     pub fn new(\n         origin: ResolvedVc<Box<dyn ResolveOrigin>>,\n         request: ResolvedVc<Request>,\n-        path: AstPath,\n         issue_source: IssueSource,\n         annotations: Value<ImportAnnotations>,\n         in_try: bool,\n         import_externals: bool,\n-    ) -> Vc<Self> {\n-        Self::cell(EsmAsyncAssetReference {\n+    ) -> Self {\n+        EsmAsyncAssetReference {\n             origin,\n             request,\n-            path,\n             issue_source,\n             annotations: annotations.into_value(),\n             in_try,\n             import_externals,\n-        })\n+        }\n     }\n }\n \n@@ -108,27 +107,42 @@ impl ChunkableModuleReference for EsmAsyncAssetReference {\n     }\n }\n \n-#[turbo_tasks::value_impl]\n-impl CodeGenerateable for EsmAsyncAssetReference {\n-    #[turbo_tasks::function]\n-    async fn code_generation(\n+impl IntoCodeGenReference for EsmAsyncAssetReference {\n+    fn into_code_gen_reference(\n+        self,\n+        path: AstPath,\n+    ) -> (ResolvedVc<Box<dyn ModuleReference>>, CodeGen) {\n+        let reference = self.resolved_cell();\n+        (\n+            ResolvedVc::upcast(reference),\n+            CodeGen::EsmAsyncAssetReferenceCodeGen(EsmAsyncAssetReferenceCodeGen {\n+                reference,\n+                path,\n+            }),\n+        )\n+    }\n+}\n+\n+#[derive(PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue)]\n+pub struct EsmAsyncAssetReferenceCodeGen {\n+    path: AstPath,\n+    reference: ResolvedVc<EsmAsyncAssetReference>,\n+}\n+\n+impl EsmAsyncAssetReferenceCodeGen {\n+    pub async fn code_generation(\n         &self,\n         module_graph: Vc<ModuleGraph>,\n         chunking_context: Vc<Box<dyn ChunkingContext>>,\n-    ) -> Result<Vc<CodeGeneration>> {\n+    ) -> Result<CodeGeneration> {\n+        let reference = self.reference.await?;\n+\n         let pm = PatternMapping::resolve_request(\n-            *self.request,\n-            *self.origin,\n+            *reference.request,\n+            *reference.origin,\n             module_graph,\n             Vc::upcast(chunking_context),\n-            esm_resolve(\n-                self.get_origin().resolve().await?,\n-                *self.request,\n-                Value::new(EcmaScriptModulesReferenceSubType::DynamicImport),\n-                self.in_try,\n-                Some(self.issue_source.clone()),\n-            )\n-            .await?,\n+            self.reference.resolve_reference(),\n             if matches!(\n                 *chunking_context.environment().chunk_loading().await?,\n                 ChunkLoading::Edge\n@@ -140,7 +154,7 @@ impl CodeGenerateable for EsmAsyncAssetReference {\n         )\n         .await?;\n \n-        let import_externals = self.import_externals;\n+        let import_externals = reference.import_externals;\n \n         let visitor = create_visitor!(self.path, visit_mut_expr(expr: &mut Expr) {\n             let old_expr = expr.take();\n@@ -176,6 +190,6 @@ impl CodeGenerateable for EsmAsyncAssetReference {\n             });\n         });\n \n-        Ok(CodeGeneration::visitors(vec![visitor]).cell())\n+        Ok(CodeGeneration::visitors(vec![visitor]))\n     }\n }"
        },
        {
            "sha": "24b98e361a783f5251b64f0eab61e2a0da5fa158",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/esm/export.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 8,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/d854b8b12ea78298f7b077c27c98b168cdf07a96/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fexport.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d854b8b12ea78298f7b077c27c98b168cdf07a96/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fexport.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fexport.rs?ref=d854b8b12ea78298f7b077c27c98b168cdf07a96",
            "patch": "@@ -29,7 +29,7 @@ use turbopack_core::{\n use super::base::ReferencedAsset;\n use crate::{\n     chunk::{EcmascriptChunkPlaceable, EcmascriptExports},\n-    code_gen::{CodeGenerateable, CodeGeneration, CodeGenerationHoistedStmt},\n+    code_gen::{CodeGeneration, CodeGenerationHoistedStmt},\n     magic_identifier,\n     runtime_functions::{TURBOPACK_DYNAMIC, TURBOPACK_ESM},\n };\n@@ -489,14 +489,12 @@ impl EsmExports {\n     }\n }\n \n-#[turbo_tasks::value_impl]\n-impl CodeGenerateable for EsmExports {\n-    #[turbo_tasks::function]\n-    async fn code_generation(\n+impl EsmExports {\n+    pub async fn code_generation(\n         self: Vc<Self>,\n         module_graph: Vc<ModuleGraph>,\n         chunking_context: Vc<Box<dyn ChunkingContext>>,\n-    ) -> Result<Vc<CodeGeneration>> {\n+    ) -> Result<CodeGeneration> {\n         let expanded = self.expand_exports().await?;\n \n         let mut dynamic_exports = Vec::<Box<Expr>>::new();\n@@ -639,7 +637,6 @@ impl CodeGenerateable for EsmExports {\n                     getters: Expr = getters.clone()\n                 ),\n             )],\n-        )\n-        .cell())\n+        ))\n     }\n }"
        },
        {
            "sha": "86d1668eb3581e68fac15efd279c4973ad926fe9",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/esm/module_id.rs",
            "status": "modified",
            "additions": 42,
            "deletions": 24,
            "changes": 66,
            "blob_url": "https://github.com/vercel/next.js/blob/d854b8b12ea78298f7b077c27c98b168cdf07a96/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fmodule_id.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d854b8b12ea78298f7b077c27c98b168cdf07a96/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fmodule_id.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fmodule_id.rs?ref=d854b8b12ea78298f7b077c27c98b168cdf07a96",
            "patch": "@@ -1,7 +1,10 @@\n use anyhow::Result;\n+use serde::{Deserialize, Serialize};\n use swc_core::quote;\n use turbo_rcstr::RcStr;\n-use turbo_tasks::{ResolvedVc, ValueToString, Vc};\n+use turbo_tasks::{\n+    debug::ValueDebugFormat, trace::TraceRawVcs, NonLocalValue, ResolvedVc, ValueToString, Vc,\n+};\n use turbopack_core::{\n     chunk::{\n         ChunkItemExt, ChunkableModule, ChunkableModuleReference, ChunkingContext,\n@@ -14,7 +17,7 @@ use turbopack_core::{\n \n use super::{base::ReferencedAsset, EsmAssetReference};\n use crate::{\n-    code_gen::{CodeGenerateable, CodeGeneration},\n+    code_gen::{CodeGen, CodeGeneration, IntoCodeGenReference},\n     create_visitor,\n     references::AstPath,\n     utils::module_id_to_lit,\n@@ -24,14 +27,11 @@ use crate::{\n #[derive(Hash, Debug)]\n pub struct EsmModuleIdAssetReference {\n     inner: ResolvedVc<EsmAssetReference>,\n-    ast_path: AstPath,\n }\n \n-#[turbo_tasks::value_impl]\n impl EsmModuleIdAssetReference {\n-    #[turbo_tasks::function]\n-    pub fn new(inner: ResolvedVc<EsmAssetReference>, ast_path: AstPath) -> Vc<Self> {\n-        Self::cell(EsmModuleIdAssetReference { inner, ast_path })\n+    pub fn new(inner: ResolvedVc<EsmAssetReference>) -> Self {\n+        EsmModuleIdAssetReference { inner }\n     }\n }\n \n@@ -61,38 +61,56 @@ impl ChunkableModuleReference for EsmModuleIdAssetReference {\n     }\n }\n \n-#[turbo_tasks::value_impl]\n-impl CodeGenerateable for EsmModuleIdAssetReference {\n-    #[turbo_tasks::function]\n-    async fn code_generation(\n+impl IntoCodeGenReference for EsmModuleIdAssetReference {\n+    fn into_code_gen_reference(\n+        self,\n+        path: AstPath,\n+    ) -> (ResolvedVc<Box<dyn ModuleReference>>, CodeGen) {\n+        let reference = self.resolved_cell();\n+        (\n+            ResolvedVc::upcast(reference),\n+            CodeGen::EsmModuleIdAssetReferenceCodeGen(EsmModuleIdAssetReferenceCodeGen {\n+                reference,\n+                path,\n+            }),\n+        )\n+    }\n+}\n+\n+#[derive(PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue)]\n+pub struct EsmModuleIdAssetReferenceCodeGen {\n+    path: AstPath,\n+    reference: ResolvedVc<EsmModuleIdAssetReference>,\n+}\n+\n+impl EsmModuleIdAssetReferenceCodeGen {\n+    pub async fn code_generation(\n         &self,\n         module_graph: Vc<ModuleGraph>,\n         chunking_context: Vc<Box<dyn ChunkingContext>>,\n-    ) -> Result<Vc<CodeGeneration>> {\n+    ) -> Result<CodeGeneration> {\n         let mut visitors = Vec::new();\n \n-        if let ReferencedAsset::Some(asset) = &*self.inner.get_referenced_asset().await? {\n+        if let ReferencedAsset::Some(asset) =\n+            &*self.reference.await?.inner.get_referenced_asset().await?\n+        {\n             let id = asset\n                 .as_chunk_item(module_graph, Vc::upcast(chunking_context))\n                 .id()\n                 .await?;\n             let id = module_id_to_lit(&id);\n-            visitors.push(\n-                create_visitor!(self.ast_path, visit_mut_expr(expr: &mut Expr) {\n-                    *expr = id.clone()\n-                }),\n-            );\n+            visitors.push(create_visitor!(self.path, visit_mut_expr(expr: &mut Expr) {\n+                *expr = id.clone()\n+            }));\n         } else {\n             // If the referenced asset can't be found, replace the expression with null.\n             // This can happen if the referenced asset is an external, or doesn't resolve\n             // to anything.\n-            visitors.push(\n-                create_visitor!(self.ast_path, visit_mut_expr(expr: &mut Expr) {\n-                    *expr = quote!(\"null\" as Expr);\n-                }),\n-            );\n+            visitors.push(create_visitor!(self.path, visit_mut_expr(expr: &mut Expr) {\n+                *expr = quote!(\"null\" as Expr);\n+            }));\n         }\n \n-        Ok(CodeGeneration::visitors(visitors).cell())\n+        Ok(CodeGeneration::visitors(visitors))\n     }\n }"
        },
        {
            "sha": "039de6bccb373e492f254f473bf73b65e08fd81f",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/esm/url.rs",
            "status": "modified",
            "additions": 40,
            "deletions": 28,
            "changes": 68,
            "blob_url": "https://github.com/vercel/next.js/blob/d854b8b12ea78298f7b077c27c98b168cdf07a96/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Furl.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d854b8b12ea78298f7b077c27c98b168cdf07a96/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Furl.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Furl.rs?ref=d854b8b12ea78298f7b077c27c98b168cdf07a96",
            "patch": "@@ -6,7 +6,8 @@ use swc_core::{\n };\n use turbo_rcstr::RcStr;\n use turbo_tasks::{\n-    trace::TraceRawVcs, NonLocalValue, ResolvedVc, TaskInput, Value, ValueToString, Vc,\n+    debug::ValueDebugFormat, trace::TraceRawVcs, NonLocalValue, ResolvedVc, TaskInput, Value,\n+    ValueToString, Vc,\n };\n use turbopack_core::{\n     chunk::{\n@@ -25,7 +26,7 @@ use turbopack_core::{\n \n use super::base::ReferencedAsset;\n use crate::{\n-    code_gen::{CodeGenerateable, CodeGeneration},\n+    code_gen::{CodeGen, CodeGeneration, IntoCodeGenReference},\n     create_visitor,\n     references::AstPath,\n     runtime_functions::{\n@@ -68,38 +69,31 @@ pub enum UrlRewriteBehavior {\n pub struct UrlAssetReference {\n     origin: ResolvedVc<Box<dyn ResolveOrigin>>,\n     request: ResolvedVc<Request>,\n-    rendering: ResolvedVc<Rendering>,\n-    ast_path: AstPath,\n+    rendering: Rendering,\n     issue_source: IssueSource,\n     in_try: bool,\n     url_rewrite_behavior: UrlRewriteBehavior,\n }\n \n-#[turbo_tasks::value_impl]\n impl UrlAssetReference {\n-    #[turbo_tasks::function]\n     pub fn new(\n         origin: ResolvedVc<Box<dyn ResolveOrigin>>,\n         request: ResolvedVc<Request>,\n-        rendering: ResolvedVc<Rendering>,\n-        ast_path: AstPath,\n+        rendering: Rendering,\n         issue_source: IssueSource,\n         in_try: bool,\n         url_rewrite_behavior: UrlRewriteBehavior,\n-    ) -> Vc<Self> {\n+    ) -> Self {\n         UrlAssetReference {\n             origin,\n             request,\n             rendering,\n-            ast_path,\n             issue_source,\n             in_try,\n             url_rewrite_behavior,\n         }\n-        .cell()\n     }\n \n-    #[turbo_tasks::function]\n     pub(crate) fn get_referenced_asset(self: Vc<Self>) -> Vc<ReferencedAsset> {\n         ReferencedAsset::from_resolve_result(self.resolve_reference())\n     }\n@@ -137,8 +131,26 @@ impl ChunkableModuleReference for UrlAssetReference {\n     }\n }\n \n-#[turbo_tasks::value_impl]\n-impl CodeGenerateable for UrlAssetReference {\n+impl IntoCodeGenReference for UrlAssetReference {\n+    fn into_code_gen_reference(\n+        self,\n+        path: AstPath,\n+    ) -> (ResolvedVc<Box<dyn ModuleReference>>, CodeGen) {\n+        let reference = self.resolved_cell();\n+        (\n+            ResolvedVc::upcast(reference),\n+            CodeGen::UrlAssetReferenceCodeGen(UrlAssetReferenceCodeGen { reference, path }),\n+        )\n+    }\n+}\n+\n+#[derive(PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue)]\n+pub struct UrlAssetReferenceCodeGen {\n+    reference: ResolvedVc<UrlAssetReference>,\n+    path: AstPath,\n+}\n+\n+impl UrlAssetReferenceCodeGen {\n     /// Rewrites call to the `new URL()` ctor depends on the current\n     /// conditions. Generated code will point to the output path of the asset,\n     /// as similar to the webpack's behavior. This is based on the\n@@ -156,18 +168,18 @@ impl CodeGenerateable for UrlAssetReference {\n     │ None                          │ new URL(url, base)                                                      │ new URL(url, base)                             │ new URL(url, base)    │\n     └───────────────────────────────┴─────────────────────────────────────────────────────────────────────────┴────────────────────────────────────────────────┴───────────────────────┘\n     */\n-    #[turbo_tasks::function]\n-    async fn code_generation(\n-        self: Vc<Self>,\n+    pub async fn code_generation(\n+        &self,\n         module_graph: Vc<ModuleGraph>,\n         chunking_context: Vc<Box<dyn ChunkingContext>>,\n-    ) -> Result<Vc<CodeGeneration>> {\n-        let this = self.await?;\n+    ) -> Result<CodeGeneration> {\n         let mut visitors = vec![];\n \n-        match this.url_rewrite_behavior {\n+        let reference = self.reference.await?;\n+\n+        match reference.url_rewrite_behavior {\n             UrlRewriteBehavior::Relative => {\n-                let referenced_asset = self.get_referenced_asset().await?;\n+                let referenced_asset = self.reference.get_referenced_asset().await?;\n \n                 // if the referenced url is in the module graph of turbopack, replace it into\n                 // the chunk item will be emitted into output path to point the\n@@ -184,7 +196,7 @@ impl CodeGenerateable for UrlAssetReference {\n                             .id()\n                             .await?;\n \n-                        visitors.push(create_visitor!(this.ast_path, visit_mut_expr(new_expr: &mut Expr) {\n+                        visitors.push(create_visitor!(self.path, visit_mut_expr(new_expr: &mut Expr) {\n                             let should_rewrite_to_relative = if let Expr::New(NewExpr { args: Some(args), .. }) = new_expr {\n                                 matches!(args.first(), Some(ExprOrSpread { .. }))\n                             } else {\n@@ -203,7 +215,7 @@ impl CodeGenerateable for UrlAssetReference {\n                     }\n                     ReferencedAsset::External(request, ExternalType::Url) => {\n                         let request = request.to_string();\n-                        visitors.push(create_visitor!(this.ast_path, visit_mut_expr(new_expr: &mut Expr) {\n+                        visitors.push(create_visitor!(self.path, visit_mut_expr(new_expr: &mut Expr) {\n                             let should_rewrite_to_relative = if let Expr::New(NewExpr { args: Some(args), .. }) = new_expr {\n                                 matches!(args.first(), Some(ExprOrSpread { .. }))\n                             } else {\n@@ -230,15 +242,15 @@ impl CodeGenerateable for UrlAssetReference {\n                 }\n             }\n             UrlRewriteBehavior::Full => {\n-                let referenced_asset = self.get_referenced_asset().await?;\n+                let referenced_asset = self.reference.get_referenced_asset().await?;\n \n                 // For rendering environments (CSR), we rewrite the `import.meta.url` to\n                 // be a location.origin because it allows us to access files from the root of\n                 // the dev server.\n                 //\n                 // By default for the remaining environments, turbopack's runtime have overriden\n                 // `import.meta.url`.\n-                let rewrite_url_base = match &*this.rendering.await? {\n+                let rewrite_url_base = match reference.rendering {\n                     Rendering::Client => Some(quote!(\"location.origin\" as Expr)),\n                     Rendering::None | Rendering::Server => None,\n                 };\n@@ -274,7 +286,7 @@ impl CodeGenerateable for UrlAssetReference {\n                             )\n                         };\n \n-                        visitors.push(create_visitor!(this.ast_path, visit_mut_expr(new_expr: &mut Expr) {\n+                        visitors.push(create_visitor!(self.path, visit_mut_expr(new_expr: &mut Expr) {\n                             if let Expr::New(NewExpr { args: Some(args), .. }) = new_expr {\n                                 if let Some(ExprOrSpread { box expr, spread: None }) = args.get_mut(0) {\n                                     *expr = url_segment_resolver.clone();\n@@ -294,7 +306,7 @@ impl CodeGenerateable for UrlAssetReference {\n                     }\n                     ReferencedAsset::External(request, ExternalType::Url) => {\n                         let request = request.to_string();\n-                        visitors.push(create_visitor!(this.ast_path, visit_mut_expr(new_expr: &mut Expr) {\n+                        visitors.push(create_visitor!(self.path, visit_mut_expr(new_expr: &mut Expr) {\n                             if let Expr::New(NewExpr { args: Some(args), .. }) = new_expr {\n                                 if let Some(ExprOrSpread { box expr, spread: None }) = args.get_mut(0) {\n                                     *expr = request.as_str().into()\n@@ -323,6 +335,6 @@ impl CodeGenerateable for UrlAssetReference {\n             }\n         };\n \n-        Ok(CodeGeneration::visitors(visitors).cell())\n+        Ok(CodeGeneration::visitors(visitors))\n     }\n }"
        },
        {
            "sha": "0c850d032eef25ff79860e6eb2d3e372128e4a2e",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/mod.rs",
            "status": "modified",
            "additions": 101,
            "deletions": 111,
            "changes": 212,
            "blob_url": "https://github.com/vercel/next.js/blob/d854b8b12ea78298f7b077c27c98b168cdf07a96/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d854b8b12ea78298f7b077c27c98b168cdf07a96/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fmod.rs?ref=d854b8b12ea78298f7b077c27c98b168cdf07a96",
            "patch": "@@ -129,7 +129,7 @@ use crate::{\n         ConstantNumber, ConstantString, JsValueUrlKind, RequireContextValue,\n     },\n     chunk::EcmascriptExports,\n-    code_gen::{CodeGen, CodeGens},\n+    code_gen::{CodeGen, CodeGens, IntoCodeGenReference},\n     magic_identifier,\n     parse::parse,\n     references::{\n@@ -204,23 +204,24 @@ impl AnalyzeEcmascriptModuleResultBuilder {\n         self.local_references.insert(r);\n     }\n \n-    /// Adds an asset reference to the analysis result.\n-    pub fn add_import_reference(\n-        &mut self,\n-        reference: ResolvedVc<impl Upcast<Box<dyn ModuleReference>>>,\n-    ) {\n-        self.references.insert(ResolvedVc::upcast(reference));\n+    /// Adds an asset reference with codegen to the analysis result.\n+    pub fn add_reference_code_gen<R: IntoCodeGenReference>(&mut self, reference: R, path: AstPath) {\n+        let (reference, code_gen) = reference.into_code_gen_reference(path);\n+        self.add_reference(reference);\n+        self.add_code_gen(code_gen);\n     }\n \n-    /// Adds an reexport reference to the analysis result.\n-    pub fn add_local_reference(\n+    /// Adds a reference belonging to ESM imports to the analysis result.\n+    /// If you're unsure about which function to use, use `add_reference()`\n+    pub fn add_non_local_reference(\n         &mut self,\n         reference: ResolvedVc<impl Upcast<Box<dyn ModuleReference>>>,\n     ) {\n-        self.local_references.insert(ResolvedVc::upcast(reference));\n+        self.references.insert(ResolvedVc::upcast(reference));\n     }\n \n     /// Adds an reexport reference to the analysis result.\n+    /// If you're unsure about which function to use, use `add_reference()`\n     pub fn add_reexport_reference(\n         &mut self,\n         reference: ResolvedVc<impl Upcast<Box<dyn ModuleReference>>>,\n@@ -230,6 +231,7 @@ impl AnalyzeEcmascriptModuleResultBuilder {\n     }\n \n     /// Adds an evaluation reference to the analysis result.\n+    /// If you're unsure about which function to use, use `add_reference()`\n     pub fn add_evaluation_reference(&mut self, reference: ResolvedVc<EsmAssetReference>) {\n         self.evaluation_references\n             .insert(ResolvedVc::upcast(reference));\n@@ -484,6 +486,9 @@ pub(crate) async fn analyse_ecmascript_module_internal(\n     .await?;\n \n     let mut import_references = Vec::new();\n+    // Ad-hoc created import references that are resolved `import * as x from ...; x.foo` accesses\n+    // This caches repeated access because EsmAssetReference::new is not a turbo task function.\n+    let mut import_references_namespace_rewritten = FxIndexMap::default();\n \n     let pos = program.span().lo;\n     if analyze_types {\n@@ -591,12 +596,11 @@ pub(crate) async fn analyse_ecmascript_module_internal(\n         set_handler_and_globals(&handler, globals, || create_graph(program, eval_context))\n     };\n \n-    let mut evaluation_references = Vec::new();\n-\n     let span = tracing::info_span!(\"esm import references\");\n     async {\n-        for (i, r) in eval_context.imports.references().enumerate() {\n-            let r = EsmAssetReference::new(\n+        for r in eval_context.imports.references() {\n+            let mut should_add_evaluation = false;\n+            let reference = EsmAssetReference::new(\n                 origin,\n                 Request::parse(Value::new(RcStr::from(&*r.module_path).into()))\n                     .to_resolved()\n@@ -608,20 +612,20 @@ pub(crate) async fn analyse_ecmascript_module_internal(\n                 match options.tree_shaking_mode {\n                     Some(TreeShakingMode::ModuleFragments) => match &r.imported_symbol {\n                         ImportedSymbol::ModuleEvaluation => {\n-                            evaluation_references.push(i);\n+                            should_add_evaluation = true;\n                             Some(ModulePart::evaluation())\n                         }\n                         ImportedSymbol::Symbol(name) => Some(ModulePart::export((&**name).into())),\n                         ImportedSymbol::PartEvaluation(part_id) => {\n-                            evaluation_references.push(i);\n+                            should_add_evaluation = true;\n                             Some(ModulePart::internal_evaluation(*part_id))\n                         }\n                         ImportedSymbol::Part(part_id) => Some(ModulePart::internal(*part_id)),\n                         ImportedSymbol::Exports => Some(ModulePart::exports()),\n                     },\n                     Some(TreeShakingMode::ReexportsOnly) => match &r.imported_symbol {\n                         ImportedSymbol::ModuleEvaluation => {\n-                            evaluation_references.push(i);\n+                            should_add_evaluation = true;\n                             Some(ModulePart::evaluation())\n                         }\n                         ImportedSymbol::Symbol(name) => Some(ModulePart::export((&**name).into())),\n@@ -631,23 +635,20 @@ pub(crate) async fn analyse_ecmascript_module_internal(\n                         ImportedSymbol::Exports => None,\n                     },\n                     None => {\n-                        evaluation_references.push(i);\n+                        should_add_evaluation = true;\n                         None\n                     }\n                 },\n                 import_externals,\n             )\n-            .to_resolved()\n-            .await?;\n+            .resolved_cell();\n \n-            import_references.push(r);\n-        }\n-        for i in evaluation_references {\n-            let reference = import_references[i];\n-            analysis.add_evaluation_reference(reference);\n-            analysis.add_import_reference(reference);\n+            import_references.push(reference);\n+            if should_add_evaluation {\n+                analysis.add_evaluation_reference(reference);\n+                analysis.add_non_local_reference(reference);\n+            }\n         }\n-\n         anyhow::Ok(())\n     }\n     .instrument(span)\n@@ -661,13 +662,13 @@ pub(crate) async fn analyse_ecmascript_module_internal(\n                 let mut visitor =\n                     ModuleReferencesVisitor::new(eval_context, &import_references, &mut analysis);\n \n+                let mut esm_star_exports: Vec<ResolvedVc<Box<dyn ModuleReference>>> = vec![];\n+\n                 for (i, reexport) in eval_context.imports.reexports() {\n                     let import_ref = import_references[i];\n                     match reexport {\n                         Reexport::Star => {\n-                            visitor\n-                                .esm_star_exports\n-                                .push(ResolvedVc::upcast(import_ref));\n+                            esm_star_exports.push(ResolvedVc::upcast(import_ref));\n                         }\n                         Reexport::Namespace { exported: n } => {\n                             visitor.esm_exports.insert(\n@@ -698,7 +699,7 @@ pub(crate) async fn analyse_ecmascript_module_internal(\n                     visitor.webpack_entry,\n                     visitor.webpack_chunks,\n                     visitor.esm_exports,\n-                    visitor.esm_star_exports,\n+                    esm_star_exports,\n                 )\n             });\n \n@@ -707,18 +708,18 @@ pub(crate) async fn analyse_ecmascript_module_internal(\n                 EsmExport::LocalBinding(..) => {}\n                 EsmExport::ImportedNamespace(reference) => {\n                     analysis.add_reexport_reference(reference);\n-                    analysis.add_import_reference(reference);\n+                    analysis.add_non_local_reference(reference);\n                 }\n                 EsmExport::ImportedBinding(reference, ..) => {\n                     analysis.add_reexport_reference(reference);\n-                    analysis.add_import_reference(reference);\n+                    analysis.add_non_local_reference(reference);\n                 }\n                 EsmExport::Error => {}\n             }\n         }\n         for reference in &esm_star_exports {\n             analysis.add_reexport_reference(*reference);\n-            analysis.add_import_reference(*reference);\n+            analysis.add_non_local_reference(*reference);\n         }\n         let exports = if !esm_exports.is_empty() || !esm_star_exports.is_empty() {\n             if specified_type == SpecifiedModuleType::CommonJs {\n@@ -1235,40 +1236,42 @@ pub(crate) async fn analyse_ecmascript_module_internal(\n                     span: _,\n                     in_try: _,\n                 } => {\n-                    if let Some(&r) = import_references.get(esm_reference_index) {\n-                        if let Some(\"__turbopack_module_id__\") = export.as_deref() {\n-                            analysis.add_reference(\n-                                EsmModuleIdAssetReference::new(*r, ast_path.into())\n-                                    .to_resolved()\n-                                    .await?,\n-                            )\n-                        } else {\n-                            let r = match options.tree_shaking_mode {\n-                                Some(TreeShakingMode::ReexportsOnly) => {\n-                                    let r_ref = r.await?;\n-                                    if r_ref.export_name.is_none() && export.is_some() {\n-                                        let export = export.clone().unwrap();\n-                                        EsmAssetReference::new(\n-                                            r_ref.origin,\n-                                            r_ref.request,\n-                                            r_ref.issue_source.clone(),\n-                                            Value::new(r_ref.annotations.clone()),\n-                                            Some(ModulePart::export(export)),\n-                                            r_ref.import_externals,\n-                                        )\n-                                        .to_resolved()\n-                                        .await?\n-                                    } else {\n-                                        r\n-                                    }\n-                                }\n-                                _ => r,\n-                            };\n+                    let Some(mut r) = import_references.get(esm_reference_index).copied() else {\n+                        continue;\n+                    };\n \n-                            analysis.add_local_reference(r);\n-                            analysis.add_import_reference(r);\n-                            analysis.add_code_gen(EsmBinding::new(r, export, ast_path.into()));\n+                    if let Some(\"__turbopack_module_id__\") = export.as_deref() {\n+                        analysis.add_reference_code_gen(\n+                            EsmModuleIdAssetReference::new(r),\n+                            ast_path.into(),\n+                        )\n+                    } else {\n+                        if matches!(\n+                            options.tree_shaking_mode,\n+                            Some(TreeShakingMode::ReexportsOnly)\n+                        ) {\n+                            let r_ref = r.await?;\n+                            if r_ref.export_name.is_none() && export.is_some() {\n+                                if let Some(export) = &export {\n+                                    r = *import_references_namespace_rewritten\n+                                        .entry((esm_reference_index, export.clone()))\n+                                        .or_insert_with(|| {\n+                                            EsmAssetReference::new(\n+                                                r_ref.origin,\n+                                                r_ref.request,\n+                                                r_ref.issue_source.clone(),\n+                                                Value::new(r_ref.annotations.clone()),\n+                                                Some(ModulePart::export(export.clone())),\n+                                                r_ref.import_externals,\n+                                            )\n+                                            .resolved_cell()\n+                                        });\n+                                }\n+                            }\n                         }\n+\n+                        analysis.add_reference(r);\n+                        analysis.add_code_gen(EsmBinding::new(r, export, ast_path.into()));\n                     }\n                 }\n                 Effect::TypeOf {\n@@ -1446,18 +1449,16 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                                 return Ok(());\n                             }\n                         }\n-                        analysis.add_reference(\n+                        analysis.add_reference_code_gen(\n                             UrlAssetReference::new(\n-                                *origin,\n-                                Request::parse(Value::new(pat)),\n-                                compile_time_info.environment().rendering(),\n-                                ast_path.to_vec().into(),\n+                                origin,\n+                                Request::parse(Value::new(pat)).to_resolved().await?,\n+                                *compile_time_info.environment().rendering().await?,\n                                 issue_source(source, span),\n                                 in_try,\n                                 url_rewrite_behavior.unwrap_or(UrlRewriteBehavior::Relative),\n-                            )\n-                            .to_resolved()\n-                            .await?,\n+                            ),\n+                            ast_path.to_vec().into(),\n                         );\n                     }\n                 }\n@@ -1482,16 +1483,14 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                     }\n \n                     if *compile_time_info.environment().rendering().await? == Rendering::Client {\n-                        analysis.add_reference(\n+                        analysis.add_reference_code_gen(\n                             WorkerAssetReference::new(\n-                                *origin,\n-                                Request::parse(Value::new(pat)),\n-                                ast_path.to_vec().into(),\n+                                origin,\n+                                Request::parse(Value::new(pat)).to_resolved().await?,\n                                 issue_source(source, span),\n                                 in_try,\n-                            )\n-                            .to_resolved()\n-                            .await?,\n+                            ),\n+                            ast_path.to_vec().into(),\n                         );\n                     }\n \n@@ -1581,18 +1580,16 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                         return Ok(());\n                     }\n                 }\n-                analysis.add_reference(\n+                analysis.add_reference_code_gen(\n                     EsmAsyncAssetReference::new(\n-                        *origin,\n-                        Request::parse(Value::new(pat)),\n-                        ast_path.to_vec().into(),\n+                        origin,\n+                        Request::parse(Value::new(pat)).to_resolved().await?,\n                         issue_source(source, span),\n                         Value::new(import_annotations),\n                         in_try,\n                         state.import_externals,\n-                    )\n-                    .to_resolved()\n-                    .await?,\n+                    ),\n+                    ast_path.to_vec().into(),\n                 );\n                 return Ok(());\n             }\n@@ -1623,16 +1620,14 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                         return Ok(());\n                     }\n                 }\n-                analysis.add_reference(\n+                analysis.add_reference_code_gen(\n                     CjsRequireAssetReference::new(\n-                        *origin,\n-                        Request::parse(Value::new(pat)),\n-                        ast_path.to_vec().into(),\n+                        origin,\n+                        Request::parse(Value::new(pat)).to_resolved().await?,\n                         issue_source(source, span),\n                         in_try,\n-                    )\n-                    .to_resolved()\n-                    .await?,\n+                    ),\n+                    ast_path.to_vec().into(),\n                 );\n                 return Ok(());\n             }\n@@ -1677,16 +1672,14 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                         return Ok(());\n                     }\n                 }\n-                analysis.add_reference(\n+                analysis.add_reference_code_gen(\n                     CjsRequireResolveAssetReference::new(\n-                        *origin,\n-                        Request::parse(Value::new(pat)),\n-                        ast_path.to_vec().into(),\n+                        origin,\n+                        Request::parse(Value::new(pat)).to_resolved().await?,\n                         issue_source(source, span),\n                         in_try,\n-                    )\n-                    .to_resolved()\n-                    .await?,\n+                    ),\n+                    ast_path.to_vec().into(),\n                 );\n                 return Ok(());\n             }\n@@ -1720,19 +1713,18 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                 }\n             };\n \n-            analysis.add_reference(\n+            analysis.add_reference_code_gen(\n                 RequireContextAssetReference::new(\n-                    *source,\n-                    *origin,\n+                    source,\n+                    origin,\n                     options.dir,\n                     options.include_subdirs,\n                     Vc::cell(options.filter),\n-                    ast_path.to_vec().into(),\n                     Some(issue_source(source, span)),\n                     in_try,\n                 )\n-                .to_resolved()\n                 .await?,\n+                ast_path.to_vec().into(),\n             );\n         }\n \n@@ -2442,8 +2434,8 @@ async fn handle_free_var_reference(\n                 },\n                 state.import_externals,\n             )\n-            .to_resolved()\n-            .await?;\n+            .resolved_cell();\n+\n             analysis.add_reference(esm_reference);\n             analysis.add_code_gen(EsmBinding::new(\n                 esm_reference,\n@@ -2970,7 +2962,6 @@ struct ModuleReferencesVisitor<'a> {\n     import_references: &'a [ResolvedVc<EsmAssetReference>],\n     analysis: &'a mut AnalyzeEcmascriptModuleResultBuilder,\n     esm_exports: BTreeMap<RcStr, EsmExport>,\n-    esm_star_exports: Vec<ResolvedVc<Box<dyn ModuleReference>>>,\n     webpack_runtime: Option<(RcStr, Span)>,\n     webpack_entry: bool,\n     webpack_chunks: Vec<Lit>,\n@@ -2988,7 +2979,6 @@ impl<'a> ModuleReferencesVisitor<'a> {\n             import_references,\n             analysis,\n             esm_exports: BTreeMap::new(),\n-            esm_star_exports: Vec::new(),\n             webpack_runtime: None,\n             webpack_entry: false,\n             webpack_chunks: Vec::new(),"
        },
        {
            "sha": "d2c0de2d0612609543e6867b19f74ce47c030d15",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/require_context.rs",
            "status": "modified",
            "additions": 38,
            "deletions": 17,
            "changes": 55,
            "blob_url": "https://github.com/vercel/next.js/blob/d854b8b12ea78298f7b077c27c98b168cdf07a96/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Frequire_context.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d854b8b12ea78298f7b077c27c98b168cdf07a96/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Frequire_context.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Frequire_context.rs?ref=d854b8b12ea78298f7b077c27c98b168cdf07a96",
            "patch": "@@ -1,6 +1,7 @@\n use std::{borrow::Cow, collections::VecDeque, sync::Arc};\n \n use anyhow::{bail, Result};\n+use serde::{Deserialize, Serialize};\n use swc_core::{\n     common::DUMMY_SP,\n     ecma::{\n@@ -13,7 +14,10 @@ use swc_core::{\n     quote, quote_expr,\n };\n use turbo_rcstr::RcStr;\n-use turbo_tasks::{primitives::Regex, FxIndexMap, ResolvedVc, Value, ValueToString, Vc};\n+use turbo_tasks::{\n+    debug::ValueDebugFormat, primitives::Regex, trace::TraceRawVcs, FxIndexMap, NonLocalValue,\n+    ResolvedVc, Value, ValueToString, Vc,\n+};\n use turbo_tasks_fs::{DirectoryContent, DirectoryEntry, FileSystemPath};\n use turbopack_core::{\n     asset::{Asset, AssetContent},\n@@ -35,15 +39,15 @@ use crate::{\n     chunk::{\n         EcmascriptChunkItem, EcmascriptChunkItemContent, EcmascriptChunkType, EcmascriptExports,\n     },\n-    code_gen::CodeGeneration,\n+    code_gen::{CodeGen, CodeGeneration, IntoCodeGenReference},\n     create_visitor,\n     references::{\n         pattern_mapping::{PatternMapping, ResolveType},\n         AstPath,\n     },\n     runtime_functions::{TURBOPACK_EXPORT_VALUE, TURBOPACK_MODULE_CONTEXT, TURBOPACK_REQUIRE},\n     utils::module_id_to_lit,\n-    CodeGenerateable, EcmascriptChunkPlaceable,\n+    EcmascriptChunkPlaceable,\n };\n \n #[turbo_tasks::value]\n@@ -212,24 +216,20 @@ pub struct RequireContextAssetReference {\n     pub dir: RcStr,\n     pub include_subdirs: bool,\n \n-    pub path: AstPath,\n     pub issue_source: Option<IssueSource>,\n     pub in_try: bool,\n }\n \n-#[turbo_tasks::value_impl]\n impl RequireContextAssetReference {\n-    #[turbo_tasks::function]\n     pub async fn new(\n         source: ResolvedVc<Box<dyn Source>>,\n         origin: ResolvedVc<Box<dyn ResolveOrigin>>,\n         dir: RcStr,\n         include_subdirs: bool,\n         filter: Vc<Regex>,\n-        path: AstPath,\n         issue_source: Option<IssueSource>,\n         in_try: bool,\n-    ) -> Result<Vc<Self>> {\n+    ) -> Result<Self> {\n         let map = RequireContextMap::generate(\n             *origin,\n             origin.origin_path().parent().join(dir.clone()),\n@@ -250,14 +250,13 @@ impl RequireContextAssetReference {\n         }\n         .resolved_cell();\n \n-        Ok(Self::cell(RequireContextAssetReference {\n+        Ok(RequireContextAssetReference {\n             inner,\n             dir,\n             include_subdirs,\n-            path,\n             issue_source,\n             in_try,\n-        }))\n+        })\n     }\n }\n \n@@ -287,15 +286,37 @@ impl ValueToString for RequireContextAssetReference {\n #[turbo_tasks::value_impl]\n impl ChunkableModuleReference for RequireContextAssetReference {}\n \n-#[turbo_tasks::value_impl]\n-impl CodeGenerateable for RequireContextAssetReference {\n-    #[turbo_tasks::function]\n-    async fn code_generation(\n+impl IntoCodeGenReference for RequireContextAssetReference {\n+    fn into_code_gen_reference(\n+        self,\n+        path: AstPath,\n+    ) -> (ResolvedVc<Box<dyn ModuleReference>>, CodeGen) {\n+        let reference = self.resolved_cell();\n+        (\n+            ResolvedVc::upcast(reference),\n+            CodeGen::RequireContextAssetReferenceCodeGen(RequireContextAssetReferenceCodeGen {\n+                reference,\n+                path,\n+            }),\n+        )\n+    }\n+}\n+\n+#[derive(PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue)]\n+pub struct RequireContextAssetReferenceCodeGen {\n+    path: AstPath,\n+    reference: ResolvedVc<RequireContextAssetReference>,\n+}\n+\n+impl RequireContextAssetReferenceCodeGen {\n+    pub async fn code_generation(\n         &self,\n         module_graph: Vc<ModuleGraph>,\n         chunking_context: Vc<Box<dyn ChunkingContext>>,\n-    ) -> Result<Vc<CodeGeneration>> {\n+    ) -> Result<CodeGeneration> {\n         let chunk_item = self\n+            .reference\n+            .await?\n             .inner\n             .as_chunk_item(module_graph, Vc::upcast(chunking_context));\n         let module_id = chunk_item.id().owned().await?;\n@@ -313,7 +334,7 @@ impl CodeGenerateable for RequireContextAssetReference {\n             }\n         }));\n \n-        Ok(CodeGeneration::visitors(visitors).cell())\n+        Ok(CodeGeneration::visitors(visitors))\n     }\n }\n "
        },
        {
            "sha": "fa03a5d7ba5ddf06d6fea8efb4c7d7a2c9c7f6b3",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/worker.rs",
            "status": "modified",
            "additions": 33,
            "deletions": 17,
            "changes": 50,
            "blob_url": "https://github.com/vercel/next.js/blob/d854b8b12ea78298f7b077c27c98b168cdf07a96/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fworker.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d854b8b12ea78298f7b077c27c98b168cdf07a96/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fworker.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fworker.rs?ref=d854b8b12ea78298f7b077c27c98b168cdf07a96",
            "patch": "@@ -1,11 +1,15 @@\n use anyhow::{bail, Result};\n+use serde::{Deserialize, Serialize};\n use swc_core::{\n     common::util::take::Take,\n     ecma::ast::{Expr, ExprOrSpread, Lit, NewExpr},\n     quote_expr,\n };\n use turbo_rcstr::RcStr;\n-use turbo_tasks::{ResolvedVc, Value, ValueToString, Vc};\n+use turbo_tasks::{\n+    debug::ValueDebugFormat, trace::TraceRawVcs, NonLocalValue, ResolvedVc, Value, ValueToString,\n+    Vc,\n+};\n use turbopack_core::{\n     chunk::{ChunkableModule, ChunkableModuleReference, ChunkingContext},\n     issue::{code_gen::CodeGenerationIssue, IssueExt, IssueSeverity, IssueSource, StyledString},\n@@ -17,7 +21,7 @@ use turbopack_core::{\n };\n \n use crate::{\n-    code_gen::{CodeGenerateable, CodeGeneration},\n+    code_gen::{CodeGen, CodeGeneration, IntoCodeGenReference},\n     create_visitor,\n     references::AstPath,\n     runtime_functions::TURBOPACK_REQUIRE,\n@@ -29,28 +33,23 @@ use crate::{\n pub struct WorkerAssetReference {\n     pub origin: ResolvedVc<Box<dyn ResolveOrigin>>,\n     pub request: ResolvedVc<Request>,\n-    pub path: AstPath,\n     pub issue_source: IssueSource,\n     pub in_try: bool,\n }\n \n-#[turbo_tasks::value_impl]\n impl WorkerAssetReference {\n-    #[turbo_tasks::function]\n     pub fn new(\n         origin: ResolvedVc<Box<dyn ResolveOrigin>>,\n         request: ResolvedVc<Request>,\n-        path: AstPath,\n         issue_source: IssueSource,\n         in_try: bool,\n-    ) -> Vc<Self> {\n-        Self::cell(WorkerAssetReference {\n+    ) -> Self {\n+        WorkerAssetReference {\n             origin,\n             request,\n-            path,\n             issue_source,\n             in_try,\n-        })\n+        }\n     }\n }\n \n@@ -115,15 +114,32 @@ impl ValueToString for WorkerAssetReference {\n #[turbo_tasks::value_impl]\n impl ChunkableModuleReference for WorkerAssetReference {}\n \n-#[turbo_tasks::value_impl]\n-impl CodeGenerateable for WorkerAssetReference {\n-    #[turbo_tasks::function]\n-    async fn code_generation(\n+impl IntoCodeGenReference for WorkerAssetReference {\n+    fn into_code_gen_reference(\n+        self,\n+        path: AstPath,\n+    ) -> (ResolvedVc<Box<dyn ModuleReference>>, CodeGen) {\n+        let reference = self.resolved_cell();\n+        (\n+            ResolvedVc::upcast(reference),\n+            CodeGen::WorkerAssetReferenceCodeGen(WorkerAssetReferenceCodeGen { reference, path }),\n+        )\n+    }\n+}\n+\n+#[derive(PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue)]\n+pub struct WorkerAssetReferenceCodeGen {\n+    reference: ResolvedVc<WorkerAssetReference>,\n+    path: AstPath,\n+}\n+\n+impl WorkerAssetReferenceCodeGen {\n+    pub async fn code_generation(\n         &self,\n         _module_graph: Vc<ModuleGraph>,\n         chunking_context: Vc<Box<dyn ChunkingContext>>,\n-    ) -> Result<Vc<CodeGeneration>> {\n-        let Some(loader) = self.worker_loader_module().await? else {\n+    ) -> Result<CodeGeneration> {\n+        let Some(loader) = self.reference.await?.worker_loader_module().await? else {\n             bail!(\"Worker loader could not be created\");\n         };\n \n@@ -174,6 +190,6 @@ impl CodeGenerateable for WorkerAssetReference {\n             );\n         });\n \n-        Ok(CodeGeneration::visitors(vec![visitor]).cell())\n+        Ok(CodeGeneration::visitors(vec![visitor]))\n     }\n }"
        },
        {
            "sha": "668e184df6685c904ec2094ece436aeb26288e16",
            "filename": "turbopack/crates/turbopack-ecmascript/src/side_effect_optimization/facade/chunk_item.rs",
            "status": "modified",
            "additions": 22,
            "deletions": 11,
            "changes": 33,
            "blob_url": "https://github.com/vercel/next.js/blob/d854b8b12ea78298f7b077c27c98b168cdf07a96/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Ffacade%2Fchunk_item.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d854b8b12ea78298f7b077c27c98b168cdf07a96/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Ffacade%2Fchunk_item.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Ffacade%2Fchunk_item.rs?ref=d854b8b12ea78298f7b077c27c98b168cdf07a96",
            "patch": "@@ -69,21 +69,32 @@ impl EcmascriptChunkItem for EcmascriptModuleFacadeChunkItem {\n \n         let references = self.module.references();\n         let references_ref = references.await?;\n-        let mut code_gens = Vec::with_capacity(references_ref.len() + 2);\n+        let mut code_gens_cells = Vec::with_capacity(references_ref.len() + 2);\n         for r in &references_ref {\n             if let Some(code_gen) = ResolvedVc::try_sidecast::<Box<dyn CodeGenerateable>>(*r) {\n-                code_gens.push(code_gen.code_generation(*self.module_graph, *chunking_context));\n+                code_gens_cells\n+                    .push(code_gen.code_generation(*self.module_graph, *chunking_context));\n             }\n         }\n-        code_gens.push(self.module.async_module().code_generation(\n-            async_module_info,\n-            references,\n-            *self.module_graph,\n-            *chunking_context,\n-        ));\n-        code_gens.push(exports.code_generation(*self.module_graph, *chunking_context));\n-        let code_gens = code_gens.into_iter().try_join().await?;\n-        let code_gens = code_gens.iter().map(|cg| &**cg);\n+        let additional_code_gens = [\n+            self.module\n+                .async_module()\n+                .code_generation(\n+                    async_module_info,\n+                    references,\n+                    *self.module_graph,\n+                    *chunking_context,\n+                )\n+                .await?,\n+            exports\n+                .code_generation(*self.module_graph, *chunking_context)\n+                .await?,\n+        ];\n+        let code_gen_cells = code_gens_cells.into_iter().try_join().await?;\n+        let code_gens = code_gen_cells\n+            .iter()\n+            .map(|cg| &**cg)\n+            .chain(additional_code_gens.iter());\n \n         let mut program = Program::Module(swc_core::ecma::ast::Module::dummy());\n         process_content_with_code_gens(&mut program, &Globals::new(), None, code_gens);"
        }
    ],
    "stats": {
        "total": 787,
        "additions": 470,
        "deletions": 317
    }
}