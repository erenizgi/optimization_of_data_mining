{
    "author": "sokra",
    "message": "Turbopack: split task_execution_completed into multiple methods (#84170)\n\n### What?\n\nCode organization. Also makes it more visible in cpu profiles.",
    "sha": "c5d973404d7a89d756023afd455fdba832c8c6cd",
    "files": [
        {
            "sha": "701b88a4614c9b400ff58574078e382022caac5c",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 91,
            "deletions": 24,
            "changes": 115,
            "blob_url": "https://github.com/vercel/next.js/blob/c5d973404d7a89d756023afd455fdba832c8c6cd/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c5d973404d7a89d756023afd455fdba832c8c6cd/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=c5d973404d7a89d756023afd455fdba832c8c6cd",
            "patch": "@@ -25,7 +25,7 @@ use parking_lot::{Condvar, Mutex};\n use rustc_hash::{FxHashMap, FxHashSet, FxHasher};\n use smallvec::{SmallVec, smallvec};\n use tokio::time::{Duration, Instant};\n-use tracing::{field::Empty, info_span};\n+use tracing::{Span, field::Empty, info_span};\n use turbo_tasks::{\n     CellId, FxDashMap, FxIndexMap, KeyValuePair, RawVc, ReadCellOptions, ReadConsistency,\n     SessionId, TRANSIENT_TASK_BIT, TaskExecutionReason, TaskId, TraitTypeId, TurboTasksBackendApi,\n@@ -415,6 +415,13 @@ impl<B: BackingStorage> Drop for OperationGuard<'_, B> {\n     }\n }\n \n+/// Intermediate result of step 1 of task execution completion.\n+struct TaskExecutionCompletePrepareResult {\n+    pub new_children: FxHashSet<TaskId>,\n+    pub removed_data: Vec<CachedDataItem>,\n+    pub is_now_immutable: bool,\n+}\n+\n // Operations\n impl<B: BackingStorage> TurboTasksBackendInner<B> {\n     /// # Safety\n@@ -1724,8 +1731,54 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n \n         self.track_task_duration(task_id, duration);\n \n-        //// STEP 1 ////\n+        let Some(TaskExecutionCompletePrepareResult {\n+            new_children,\n+            mut removed_data,\n+            is_now_immutable,\n+        }) = self.task_execution_completed_prepare(\n+            &mut ctx,\n+            &span,\n+            task_id,\n+            cell_counters,\n+            stateful,\n+            has_invalidator,\n+        )\n+        else {\n+            // Task was stale and has been rescheduled\n+            return true;\n+        };\n+\n+        // When restoring from persistent caching the following might not be executed (since we can\n+        // suspend in `CleanupOldEdgesOperation`), but that's ok as the task is still dirty and\n+        // would be executed again.\n+\n+        if self.task_execution_completed_connect(&mut ctx, task_id, new_children, is_now_immutable)\n+        {\n+            // Task was stale and has been rescheduled\n+            return true;\n+        }\n+\n+        if self.task_execution_completed_finish(&mut ctx, task_id, &mut removed_data) {\n+            // Task was stale and has been rescheduled\n+            return true;\n+        }\n+\n+        drop(removed_data);\n+\n+        self.task_execution_completed_cleanup(&mut ctx, task_id);\n+\n+        false\n+    }\n \n+    fn task_execution_completed_prepare(\n+        &self,\n+        ctx: &mut impl ExecuteContext<'_>,\n+        span: &Span,\n+        task_id: TaskId,\n+        cell_counters: &AutoMap<ValueTypeId, u32, BuildHasherDefault<FxHasher>, 8>,\n+        stateful: bool,\n+        has_invalidator: bool,\n+    ) -> Option<TaskExecutionCompletePrepareResult> {\n         let mut task = ctx.task(task_id, TaskDataCategory::All);\n         let Some(in_progress) = get_mut!(task, InProgress) else {\n             panic!(\"Task execution completed, but task is not in progress: {task:#?}\");\n@@ -1772,9 +1825,9 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                 AggregationUpdateJob::DecreaseActiveCounts {\n                     task_ids: new_children.into_iter().collect(),\n                 },\n-                &mut ctx,\n+                ctx,\n             );\n-            return true;\n+            return None;\n         }\n \n         if cfg!(not(feature = \"no_fast_stale\")) || !stale {\n@@ -1848,13 +1901,11 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             None\n         };\n \n-        // Prepare all new children\n         if has_children {\n+            // Prepare all new children\n             prepare_new_children(task_id, &mut task, &new_children, &mut queue);\n-        }\n \n-        // Filter actual new children\n-        if has_children {\n+            // Filter actual new children\n             old_edges.extend(\n                 iter_many!(task, Child { task } => task)\n                     .filter(|task| !new_children.remove(task))\n@@ -1931,15 +1982,23 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             // Remove outdated edges first, before removing in_progress+dirty flag.\n             // We need to make sure all outdated edges are removed before the task can potentially\n             // be scheduled and executed again\n-            CleanupOldEdgesOperation::run(task_id, old_edges, queue, &mut ctx);\n+            CleanupOldEdgesOperation::run(task_id, old_edges, queue, ctx);\n         }\n \n-        // When restoring from persistent caching the following might not be executed (since we can\n-        // suspend in `CleanupOldEdgesOperation`), but that's ok as the task is still dirty and\n-        // would be executed again.\n-\n-        //// STEP 2 ////\n+        Some(TaskExecutionCompletePrepareResult {\n+            new_children,\n+            removed_data,\n+            is_now_immutable,\n+        })\n+    }\n \n+    fn task_execution_completed_connect(\n+        &self,\n+        ctx: &mut impl ExecuteContext<'_>,\n+        task_id: TaskId,\n+        new_children: FxHashSet<TaskId>,\n+        is_now_immutable: bool,\n+    ) -> bool {\n         let mut task = ctx.task(task_id, TaskDataCategory::All);\n         let Some(in_progress) = get!(task, InProgress) else {\n             panic!(\"Task execution completed, but task is not in progress: {task:#?}\");\n@@ -1975,7 +2034,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                 AggregationUpdateJob::DecreaseActiveCounts {\n                     task_ids: new_children.into_iter().collect(),\n                 },\n-                &mut ctx,\n+                ctx,\n             );\n             return true;\n         }\n@@ -1988,7 +2047,8 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n \n         let mut queue = AggregationUpdateQueue::new();\n \n-        if has_children {\n+        let has_new_children = !new_children.is_empty();\n+        if has_new_children {\n             let has_active_count = ctx.should_track_activeness()\n                 && get!(task, Activeness).map_or(false, |activeness| activeness.active_counter > 0);\n             connect_children(\n@@ -2003,12 +2063,21 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n \n         drop(task);\n \n-        if has_children {\n+        if has_new_children {\n             #[cfg(feature = \"trace_task_completion\")]\n             let _span = tracing::trace_span!(\"connect new children\").entered();\n-            queue.execute(&mut ctx);\n+            queue.execute(ctx);\n         }\n \n+        false\n+    }\n+\n+    fn task_execution_completed_finish(\n+        &self,\n+        ctx: &mut impl ExecuteContext<'_>,\n+        task_id: TaskId,\n+        removed_data: &mut Vec<CachedDataItem>,\n+    ) -> bool {\n         let mut task = ctx.task(task_id, TaskDataCategory::All);\n         let Some(in_progress) = remove!(task, InProgress) else {\n             panic!(\"Task execution completed, but task is not in progress: {task:#?}\");\n@@ -2114,22 +2183,20 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         drop(task);\n \n         if let Some(data_update) = data_update {\n-            AggregationUpdateQueue::run(data_update, &mut ctx);\n+            AggregationUpdateQueue::run(data_update, ctx);\n         }\n \n-        drop(removed_data);\n-\n-        //// STEP 4 ////\n+        false\n+    }\n \n+    fn task_execution_completed_cleanup(&self, ctx: &mut impl ExecuteContext<'_>, task_id: TaskId) {\n         let mut task = ctx.task(task_id, TaskDataCategory::All);\n         task.shrink_to_fit(CachedDataItemType::CellData);\n         task.shrink_to_fit(CachedDataItemType::CellTypeMaxIndex);\n         task.shrink_to_fit(CachedDataItemType::CellDependency);\n         task.shrink_to_fit(CachedDataItemType::OutputDependency);\n         task.shrink_to_fit(CachedDataItemType::CollectiblesDependency);\n         drop(task);\n-\n-        false\n     }\n \n     fn run_backend_job<'a>("
        },
        {
            "sha": "bf695796264fd1b956b470e419a3ee67e412c87f",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/prepare_new_children.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 3,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/c5d973404d7a89d756023afd455fdba832c8c6cd/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fprepare_new_children.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c5d973404d7a89d756023afd455fdba832c8c6cd/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fprepare_new_children.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fprepare_new_children.rs?ref=c5d973404d7a89d756023afd455fdba832c8c6cd",
            "patch": "@@ -18,9 +18,7 @@ pub fn prepare_new_children(\n     new_children: &FxHashSet<TaskId>,\n     queue: &mut AggregationUpdateQueue,\n ) {\n-    if new_children.is_empty() {\n-        return;\n-    }\n+    debug_assert!(!new_children.is_empty());\n     let children_count = new_children.len();\n \n     // Compute future parent aggregation number based on the number of children"
        }
    ],
    "stats": {
        "total": 119,
        "additions": 92,
        "deletions": 27
    }
}