{
    "author": "wyattjoh",
    "message": "feat: add Claude Code plugin marketplace with Cache Components skill (#87993)\n\n### What?\n\nAdds a Claude Code plugin marketplace to the Next.js repository with an\ninitial `cache-components` plugin that provides expert guidance for\nCache Components and Partial Prerendering (PPR).\n\n### Why?\n\nCache Components introduces a new programming model that combines\nPartial Prerendering, Dynamic I/O, and the `\"use cache\"` directive. Team\nmembers and contributors need guidance on:\n\n- The `'use cache'` directive and its variants (`private`, `remote`)\n- Cache lifetime configuration with `cacheLife()` and predefined\nprofiles\n- Cache tagging and invalidation with `cacheTag()`, `updateTag()`,\n`revalidateTag()`\n- Parameter permutation rendering and subshell generation with\n`generateStaticParams`\n- Migration from deprecated `revalidate` and `dynamic` segment configs\n- Build-time error resolution (dynamic data outside Suspense, uncached\ndata, etc.)\n\nA Claude Code plugin allows this knowledge to be distributed directly\nfrom the repo and proactively activated when working in projects with\n`cacheComponents: true`.\n\n### How?\n\nIntroduces the `.claude-plugin/` directory structure:\n\n```\n.claude-plugin/\n├── marketplace.json                       ← Marketplace catalog (name: \"nextjs\")\n└── plugins/\n    ├── README.md                          ← Documentation for adding plugins\n    └── cache-components/\n        ├── .claude-plugin/plugin.json     ← Plugin manifest\n        ├── README.md                      ← Plugin documentation\n        └── skills/cache-components/\n            ├── SKILL.md                   ← Core concepts, mental model (496 lines)\n            ├── REFERENCE.md               ← API reference, migrations (875 lines)\n            ├── PATTERNS.md                ← 12 production patterns (781 lines)\n            └── TROUBLESHOOTING.md         ← Build errors, debugging (721 lines)\n```\n\n**Installation:**\n```bash\n/plugin marketplace add vercel/next.js\n/plugin install cache-components@nextjs\n```\n\n**Key skill features:**\n- **Proactive activation** when `cacheComponents: true` is detected in\nnext.config\n- **Mental model decision tree** for thinking through caching decisions\n- **Cache scope clarification** explaining what creates new cache\nentries\n- **updateTag vs revalidateTag guide** with decision table and examples\n- **Migration scenarios** from deprecated `revalidate`/`dynamic` segment\nconfigs\n- **Quick debugging checklist** for common cache issues\n- **Parameter permutation rendering** (how `generateStaticParams`\ncreates subshells)\n- **12 production patterns** including e-commerce, multi-tenant SaaS,\nand subshell composition\n\n### Documentation Highlights\n\n| Section | Description |\n|---------|-------------|\n| Mental Model | Decision tree for when to use `'use cache'`, `'use\ncache: private'`, or `<Suspense>` |\n| Cache Scope | What creates new cache entries (function identity,\narguments, file path) |\n| updateTag vs revalidateTag | Decision guide with e-commerce examples |\n| Migration Scenarios | Before/after examples for `revalidate`,\n`force-dynamic`, and ISR patterns |\n| Quick Debugging Checklist | Copy-paste checklists for common issues |",
    "sha": "b9edb9175e15b433122afb114cbec6a2951d7d02",
    "files": [
        {
            "sha": "c695f585f5ef302bb0c87c188a965de2258a0e71",
            "filename": ".claude-plugin/marketplace.json",
            "status": "added",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/b9edb9175e15b433122afb114cbec6a2951d7d02/.claude-plugin%2Fmarketplace.json",
            "raw_url": "https://github.com/vercel/next.js/raw/b9edb9175e15b433122afb114cbec6a2951d7d02/.claude-plugin%2Fmarketplace.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/.claude-plugin%2Fmarketplace.json?ref=b9edb9175e15b433122afb114cbec6a2951d7d02",
            "patch": "@@ -0,0 +1,18 @@\n+{\n+  \"name\": \"nextjs\",\n+  \"owner\": {\n+    \"name\": \"Vercel\",\n+    \"url\": \"https://vercel.com\"\n+  },\n+  \"plugins\": [\n+    {\n+      \"name\": \"cache-components\",\n+      \"source\": \"./plugins/cache-components\",\n+      \"description\": \"Expert guidance for Next.js Cache Components and Partial Prerendering (PPR). Proactively activates in projects with cacheComponents enabled.\",\n+      \"version\": \"1.0.0\",\n+      \"author\": {\n+        \"name\": \"Next.js Team\"\n+      }\n+    }\n+  ]\n+}"
        },
        {
            "sha": "b01f279ddfe4f8c92fea9471c3f88f65606a3a97",
            "filename": ".claude-plugin/plugins/README.md",
            "status": "added",
            "additions": 128,
            "deletions": 0,
            "changes": 128,
            "blob_url": "https://github.com/vercel/next.js/blob/b9edb9175e15b433122afb114cbec6a2951d7d02/.claude-plugin%2Fplugins%2FREADME.md",
            "raw_url": "https://github.com/vercel/next.js/raw/b9edb9175e15b433122afb114cbec6a2951d7d02/.claude-plugin%2Fplugins%2FREADME.md",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/.claude-plugin%2Fplugins%2FREADME.md?ref=b9edb9175e15b433122afb114cbec6a2951d7d02",
            "patch": "@@ -0,0 +1,128 @@\n+# Next.js Claude Code Plugins\n+\n+This directory contains Claude Code plugins for Next.js development.\n+\n+## Using the Next.js Plugin Marketplace\n+\n+The Next.js repository serves as a Claude Code plugin marketplace. Team members and contributors can install plugins directly from this repo.\n+\n+### Quick Start\n+\n+```bash\n+# Add the Next.js marketplace\n+/plugin marketplace add vercel/next.js\n+\n+# List available plugins\n+/plugin list\n+\n+# Install a plugin\n+/plugin install cache-components@nextjs\n+```\n+\n+### Available Plugins\n+\n+| Plugin | Description |\n+|--------|-------------|\n+| `cache-components` | Expert guidance for Cache Components and PPR |\n+\n+## For Team Members\n+\n+To auto-enable plugins for everyone working in a Next.js project, add to `.claude/settings.json`:\n+\n+```json\n+{\n+  \"extraKnownMarketplaces\": {\n+    \"nextjs\": {\n+      \"source\": {\n+        \"source\": \"github\",\n+        \"repo\": \"vercel/next.js\"\n+      }\n+    }\n+  },\n+  \"enabledPlugins\": {\n+    \"cache-components@nextjs\": true\n+  }\n+}\n+```\n+\n+## Creating New Plugins\n+\n+To add a new plugin to the marketplace:\n+\n+### 1. Create Plugin Directory\n+\n+```bash\n+mkdir -p .claude-plugin/plugins/my-plugin/.claude-plugin\n+mkdir -p .claude-plugin/plugins/my-plugin/skills/my-skill\n+```\n+\n+### 2. Create Plugin Manifest\n+\n+**File**: `.claude-plugin/plugins/my-plugin/.claude-plugin/plugin.json`\n+\n+```json\n+{\n+  \"name\": \"my-plugin\",\n+  \"version\": \"1.0.0\",\n+  \"description\": \"What the plugin does\",\n+  \"author\": {\n+    \"name\": \"Next.js Team\"\n+  }\n+}\n+```\n+\n+### 3. Create Skill\n+\n+**File**: `.claude-plugin/plugins/my-plugin/skills/my-skill/SKILL.md`\n+\n+```yaml\n+---\n+name: my-skill\n+description: When to use this skill\n+---\n+\n+# My Skill\n+\n+Instructions for Claude...\n+```\n+\n+### 4. Register in Marketplace\n+\n+Add to `.claude-plugin/marketplace.json`:\n+\n+```json\n+{\n+  \"plugins\": [\n+    {\n+      \"name\": \"my-plugin\",\n+      \"source\": \"./plugins/my-plugin\",\n+      \"description\": \"What it does\"\n+    }\n+  ]\n+}\n+```\n+\n+### 5. Test Locally\n+\n+```bash\n+claude --plugin-dir .claude-plugin/plugins/my-plugin\n+```\n+\n+## Plugin Structure\n+\n+```\n+.claude-plugin/\n+├── marketplace.json                       ← Marketplace catalog\n+└── plugins/\n+    ├── README.md                          ← This file\n+    └── cache-components/\n+        ├── .claude-plugin/\n+        │   └── plugin.json                ← Plugin manifest\n+        ├── skills/\n+        │   └── cache-components/\n+        │       ├── SKILL.md               ← Main skill file\n+        │       ├── REFERENCE.md           ← API reference\n+        │       ├── PATTERNS.md            ← Usage patterns\n+        │       └── TROUBLESHOOTING.md     ← Debugging guide\n+        └── README.md                      ← Plugin documentation\n+```"
        },
        {
            "sha": "f17b461447331916d1803ae5135391d47b140474",
            "filename": ".claude-plugin/plugins/cache-components/.claude-plugin/plugin.json",
            "status": "added",
            "additions": 20,
            "deletions": 0,
            "changes": 20,
            "blob_url": "https://github.com/vercel/next.js/blob/b9edb9175e15b433122afb114cbec6a2951d7d02/.claude-plugin%2Fplugins%2Fcache-components%2F.claude-plugin%2Fplugin.json",
            "raw_url": "https://github.com/vercel/next.js/raw/b9edb9175e15b433122afb114cbec6a2951d7d02/.claude-plugin%2Fplugins%2Fcache-components%2F.claude-plugin%2Fplugin.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/.claude-plugin%2Fplugins%2Fcache-components%2F.claude-plugin%2Fplugin.json?ref=b9edb9175e15b433122afb114cbec6a2951d7d02",
            "patch": "@@ -0,0 +1,20 @@\n+{\n+  \"name\": \"cache-components\",\n+  \"version\": \"1.0.0\",\n+  \"description\": \"Expert guidance for Next.js Cache Components and Partial Prerendering (PPR). Proactively activates in projects with cacheComponents: true, providing patterns for 'use cache' directive, cacheLife(), cacheTag(), cache invalidation, and parameter permutation rendering.\",\n+  \"author\": {\n+    \"name\": \"Next.js Team\",\n+    \"url\": \"https://nextjs.org\"\n+  },\n+  \"homepage\": \"https://nextjs.org/docs/app/building-your-application/caching\",\n+  \"repository\": \"https://github.com/vercel/next.js\",\n+  \"license\": \"MIT\",\n+  \"keywords\": [\n+    \"nextjs\",\n+    \"cache\",\n+    \"ppr\",\n+    \"partial-prerendering\",\n+    \"react-server-components\",\n+    \"use-cache\"\n+  ]\n+}"
        },
        {
            "sha": "ea04c5218d7ced2f6c91c9ffe3e7ac2d5157356a",
            "filename": ".claude-plugin/plugins/cache-components/README.md",
            "status": "added",
            "additions": 112,
            "deletions": 0,
            "changes": 112,
            "blob_url": "https://github.com/vercel/next.js/blob/b9edb9175e15b433122afb114cbec6a2951d7d02/.claude-plugin%2Fplugins%2Fcache-components%2FREADME.md",
            "raw_url": "https://github.com/vercel/next.js/raw/b9edb9175e15b433122afb114cbec6a2951d7d02/.claude-plugin%2Fplugins%2Fcache-components%2FREADME.md",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/.claude-plugin%2Fplugins%2Fcache-components%2FREADME.md?ref=b9edb9175e15b433122afb114cbec6a2951d7d02",
            "patch": "@@ -0,0 +1,112 @@\n+# Cache Components Plugin for Claude Code\n+\n+Expert guidance for Next.js Cache Components and Partial Prerendering (PPR).\n+\n+## Features\n+\n+This plugin provides a comprehensive skill that:\n+\n+- **Proactively activates** in projects with `cacheComponents: true`\n+- Teaches the `'use cache'` directive, `cacheLife()`, `cacheTag()`, and invalidation APIs\n+- Explains **parameter permutation rendering** and subshell generation\n+- Covers migration from deprecated `revalidate`/`dynamic` segment configs\n+- Provides build-time error solutions and debugging guidance\n+\n+## Installation\n+\n+### Step 1: Add the Next.js Marketplace\n+\n+```\n+/plugin marketplace add vercel/next.js\n+```\n+\n+### Step 2: Install the Plugin\n+\n+```\n+/plugin install cache-components@nextjs\n+```\n+\n+Or install via CLI:\n+\n+```bash\n+claude plugin install cache-components@nextjs\n+```\n+\n+### Step 3 (Optional): Enable for Your Team\n+\n+Add to your project's `.claude/settings.json` to auto-enable for all team members:\n+\n+```json\n+{\n+  \"enabledPlugins\": {\n+    \"cache-components@nextjs\": true\n+  }\n+}\n+```\n+\n+## What's Included\n+\n+| File | Description |\n+|------|-------------|\n+| `SKILL.md` | Core concepts, APIs, and proactive application guidelines |\n+| `REFERENCE.md` | Complete API reference, generateStaticParams, deprecated configs |\n+| `PATTERNS.md` | 12 production patterns including subshell composition |\n+| `TROUBLESHOOTING.md` | Build errors, debugging techniques, common issues |\n+\n+## Usage\n+\n+Once installed, the skill automatically activates when:\n+\n+1. You're working in a Next.js project with `cacheComponents: true`\n+2. You ask about caching, PPR, or the `'use cache'` directive\n+3. You're writing React Server Components or Server Actions\n+\n+### Example Triggers\n+\n+- \"How do I cache this data fetching function?\"\n+- \"What's the difference between updateTag and revalidateTag?\"\n+- \"I'm getting a build error about uncached data outside Suspense\"\n+- \"Help me set up generateStaticParams for my product pages\"\n+\n+## Key Concepts Covered\n+\n+### Parameter Permutation Rendering\n+\n+When you provide `generateStaticParams`, Next.js renders ALL permutations:\n+\n+```\n+generateStaticParams returns:\n+  [{ category: 'jackets', slug: 'bomber' }]\n+\n+Next.js renders:\n+  /products/jackets/bomber     ← Complete page\n+  /products/jackets/[slug]     ← Category subshell (reusable!)\n+  /products/[category]/[slug]  ← Fallback shell\n+```\n+\n+### Deprecated Segment Configs\n+\n+| Old (Deprecated) | New (Cache Components) |\n+|------------------|------------------------|\n+| `export const revalidate = 3600` | `cacheLife('hours')` inside `'use cache'` |\n+| `export const dynamic = 'force-static'` | Use `'use cache'` + Suspense |\n+\n+## Contributing\n+\n+This plugin lives in the Next.js repository at `.claude-plugin/plugins/cache-components/`.\n+\n+To contribute improvements:\n+\n+1. Edit files in `.claude-plugin/plugins/cache-components/skills/cache-components/`\n+2. Test locally with `claude --plugin-dir .claude-plugin/plugins/cache-components`\n+3. Submit a PR to the Next.js repository\n+\n+## Version History\n+\n+### 1.0.0\n+\n+- Initial release\n+- Covers `'use cache'`, `cacheLife()`, `cacheTag()`, `updateTag()`, `revalidateTag()`\n+- Parameter permutation rendering and subshell generation\n+- Migration guide from deprecated segment configs\n+- Build-time feedback and troubleshooting"
        },
        {
            "sha": "dcb5e8fcc26016e981628ba88f058e3e6023b5a7",
            "filename": ".claude-plugin/plugins/cache-components/skills/cache-components/PATTERNS.md",
            "status": "added",
            "additions": 832,
            "deletions": 0,
            "changes": 832,
            "blob_url": "https://github.com/vercel/next.js/blob/b9edb9175e15b433122afb114cbec6a2951d7d02/.claude-plugin%2Fplugins%2Fcache-components%2Fskills%2Fcache-components%2FPATTERNS.md",
            "raw_url": "https://github.com/vercel/next.js/raw/b9edb9175e15b433122afb114cbec6a2951d7d02/.claude-plugin%2Fplugins%2Fcache-components%2Fskills%2Fcache-components%2FPATTERNS.md",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/.claude-plugin%2Fplugins%2Fcache-components%2Fskills%2Fcache-components%2FPATTERNS.md?ref=b9edb9175e15b433122afb114cbec6a2951d7d02",
            "patch": "@@ -0,0 +1,832 @@\n+# Cache Components Patterns & Recipes\n+\n+Common patterns for implementing Cache Components effectively.\n+\n+## Pattern 1: Static + Cached + Dynamic Page\n+\n+The foundational pattern for Partial Prerendering:\n+\n+```tsx\n+import { Suspense } from 'react'\n+import { cacheLife } from 'next/cache'\n+\n+// Static - no special handling needed\n+function Header() {\n+  return <header>My Blog</header>\n+}\n+\n+// Cached - included in static shell\n+async function FeaturedPosts() {\n+  'use cache'\n+  cacheLife('hours')\n+\n+  const posts = await db.posts.findMany({\n+    where: { featured: true },\n+    take: 5,\n+  })\n+\n+  return (\n+    <section>\n+      {posts.map((post) => (\n+        <PostCard key={post.id} post={post} />\n+      ))}\n+    </section>\n+  )\n+}\n+\n+// Dynamic - streams at request time\n+async function PersonalizedFeed() {\n+  const session = await getSession()\n+  const feed = await db.posts.findMany({\n+    where: { authorId: { in: session.following } },\n+  })\n+\n+  return <FeedList posts={feed} />\n+}\n+\n+// Page composition\n+export default async function HomePage() {\n+  return (\n+    <>\n+      <Header />\n+      <FeaturedPosts />\n+      <Suspense fallback={<FeedSkeleton />}>\n+        <PersonalizedFeed />\n+      </Suspense>\n+    </>\n+  )\n+}\n+```\n+\n+---\n+\n+## Pattern 2: Read-Your-Own-Writes with Server Actions\n+\n+Ensure users see their changes immediately:\n+\n+```tsx\n+// components/posts.tsx\n+import { cacheTag, cacheLife } from 'next/cache'\n+\n+async function PostsList() {\n+  'use cache'\n+  cacheTag('posts')\n+  cacheLife('hours')\n+\n+  const posts = await db.posts.findMany({ orderBy: { createdAt: 'desc' } })\n+  return (\n+    <ul>\n+      {posts.map((p) => (\n+        <PostItem key={p.id} post={p} />\n+      ))}\n+    </ul>\n+  )\n+}\n+\n+// actions/posts.ts\n+'use server'\n+import { updateTag } from 'next/cache'\n+\n+export async function createPost(formData: FormData) {\n+  const post = await db.posts.create({\n+    data: {\n+      title: formData.get('title') as string,\n+      content: formData.get('content') as string,\n+    },\n+  })\n+\n+  // Immediate invalidation - user sees new post right away\n+  updateTag('posts')\n+\n+  return { success: true, postId: post.id }\n+}\n+\n+// components/create-post-form.tsx\n+'use client'\n+import { useTransition } from 'react'\n+import { createPost } from '@/actions/posts'\n+\n+export function CreatePostForm() {\n+  const [isPending, startTransition] = useTransition()\n+\n+  return (\n+    <form\n+      action={(formData) => {\n+        startTransition(() => createPost(formData))\n+      }}\n+    >\n+      <input name=\"title\" required />\n+      <textarea name=\"content\" required />\n+      <button disabled={isPending}>\n+        {isPending ? 'Creating...' : 'Create Post'}\n+      </button>\n+    </form>\n+  )\n+}\n+```\n+\n+---\n+\n+## Pattern 3: Granular Cache Invalidation\n+\n+Tag caches at multiple levels for precise invalidation:\n+\n+```tsx\n+// Cached with multiple tags\n+async function BlogPost({ postId }: { postId: string }) {\n+  'use cache'\n+  cacheTag('posts', `post-${postId}`)\n+  cacheLife('days')\n+\n+  const post = await db.posts.findUnique({\n+    where: { id: postId },\n+    include: { author: true, comments: true },\n+  })\n+\n+  return <Article post={post} />\n+}\n+\n+async function AuthorPosts({ authorId }: { authorId: string }) {\n+  'use cache'\n+  cacheTag('posts', `author-${authorId}`)\n+  cacheLife('hours')\n+\n+  const posts = await db.posts.findMany({\n+    where: { authorId },\n+  })\n+\n+  return <PostGrid posts={posts} />\n+}\n+\n+// Server actions with targeted invalidation\n+'use server'\n+import { updateTag } from 'next/cache'\n+\n+export async function updatePost(postId: string, data: FormData) {\n+  const post = await db.posts.update({\n+    where: { id: postId },\n+    data: { title: data.get('title'), content: data.get('content') },\n+  })\n+\n+  // Invalidate specific post only\n+  updateTag(`post-${postId}`)\n+}\n+\n+export async function deleteAuthorPosts(authorId: string) {\n+  await db.posts.deleteMany({ where: { authorId } })\n+\n+  // Invalidate all author's posts\n+  updateTag(`author-${authorId}`)\n+}\n+\n+export async function clearAllPosts() {\n+  await db.posts.deleteMany()\n+\n+  // Nuclear option - invalidate everything tagged 'posts'\n+  updateTag('posts')\n+}\n+```\n+\n+---\n+\n+## Pattern 4: Cached Data Fetching Functions\n+\n+Create reusable cached data fetchers:\n+\n+```tsx\n+// lib/data.ts\n+import { cacheTag, cacheLife } from 'next/cache'\n+\n+export async function getUser(userId: string) {\n+  'use cache'\n+  cacheTag('users', `user-${userId}`)\n+  cacheLife('hours')\n+\n+  return db.users.findUnique({ where: { id: userId } })\n+}\n+\n+export async function getPostsByCategory(category: string) {\n+  'use cache'\n+  cacheTag('posts', `category-${category}`)\n+  cacheLife('minutes')\n+\n+  return db.posts.findMany({\n+    where: { category },\n+    orderBy: { createdAt: 'desc' },\n+  })\n+}\n+\n+export async function getPopularProducts() {\n+  'use cache'\n+  cacheTag('products', 'popular')\n+  cacheLife('hours')\n+\n+  return db.products.findMany({\n+    orderBy: { salesCount: 'desc' },\n+    take: 10,\n+  })\n+}\n+\n+// Usage in components\n+async function Sidebar() {\n+  const popular = await getPopularProducts()\n+  return <ProductList products={popular} />\n+}\n+```\n+\n+---\n+\n+## Pattern 5: Stale-While-Revalidate for Background Updates\n+\n+Use `revalidateTag` for non-critical updates:\n+\n+```tsx\n+// For background analytics or non-user-facing updates\n+'use server'\n+import { revalidateTag } from 'next/cache'\n+\n+export async function trackView(postId: string) {\n+  await db.posts.update({\n+    where: { id: postId },\n+    data: { views: { increment: 1 } },\n+  })\n+\n+  // Background revalidation - old count shown while updating\n+  revalidateTag(`post-${postId}`, 'max')\n+}\n+\n+// For user-facing mutations, use updateTag instead\n+export async function likePost(postId: string) {\n+  await db.likes.create({ data: { postId, userId: getCurrentUserId() } })\n+\n+  // Immediate - user sees their like right away\n+  updateTag(`post-${postId}`)\n+}\n+```\n+\n+---\n+\n+## Pattern 6: Conditional Caching Based on Content\n+\n+Cache based on content characteristics:\n+\n+```tsx\n+async function ContentBlock({ id }: { id: string }) {\n+  'use cache'\n+\n+  const content = await db.content.findUnique({ where: { id } })\n+\n+  // Adjust cache life based on content type\n+  if (content.type === 'static') {\n+    cacheLife('max')\n+    cacheTag('static-content')\n+  } else if (content.type === 'news') {\n+    cacheLife('minutes')\n+    cacheTag('news', `news-${id}`)\n+  } else {\n+    cacheLife('default')\n+    cacheTag('content', `content-${id}`)\n+  }\n+\n+  return <ContentRenderer content={content} />\n+}\n+```\n+\n+---\n+\n+## Pattern 7: Nested Cached Components\n+\n+Compose cached components for fine-grained caching:\n+\n+```tsx\n+// Each component caches independently\n+async function Header() {\n+  'use cache'\n+  cacheTag('layout', 'header')\n+  cacheLife('days')\n+\n+  const nav = await db.navigation.findFirst()\n+  return <Nav items={nav.items} />\n+}\n+\n+async function Footer() {\n+  'use cache'\n+  cacheTag('layout', 'footer')\n+  cacheLife('days')\n+\n+  const footer = await db.footer.findFirst()\n+  return <FooterContent data={footer} />\n+}\n+\n+async function Sidebar({ category }: { category: string }) {\n+  'use cache'\n+  cacheTag('sidebar', `category-${category}`)\n+  cacheLife('hours')\n+\n+  const related = await db.posts.findMany({\n+    where: { category },\n+    take: 5,\n+  })\n+  return <RelatedPosts posts={related} />\n+}\n+\n+// Page composes cached components\n+export default async function BlogLayout({\n+  children,\n+  params,\n+}: {\n+  children: React.ReactNode\n+  params: { category: string }\n+}) {\n+  return (\n+    <>\n+      <Header />\n+      <main>\n+        {children}\n+        <Sidebar category={params.category} />\n+      </main>\n+      <Footer />\n+    </>\n+  )\n+}\n+```\n+\n+---\n+\n+## Pattern 8: E-commerce Product Page\n+\n+Complete example for e-commerce:\n+\n+```tsx\n+// app/products/[id]/page.tsx\n+import { Suspense } from 'react'\n+import { cacheTag, cacheLife } from 'next/cache'\n+\n+// Cached product details (changes rarely)\n+async function ProductDetails({ productId }: { productId: string }) {\n+  'use cache'\n+  cacheTag('products', `product-${productId}`)\n+  cacheLife('hours')\n+\n+  const product = await db.products.findUnique({\n+    where: { id: productId },\n+    include: { images: true, specifications: true },\n+  })\n+\n+  return (\n+    <div>\n+      <ProductGallery images={product.images} />\n+      <ProductInfo product={product} />\n+      <Specifications specs={product.specifications} />\n+    </div>\n+  )\n+}\n+\n+// Cached reviews (moderate change frequency)\n+async function ProductReviews({ productId }: { productId: string }) {\n+  'use cache'\n+  cacheTag(`product-${productId}-reviews`)\n+  cacheLife('minutes')\n+\n+  const reviews = await db.reviews.findMany({\n+    where: { productId },\n+    orderBy: { createdAt: 'desc' },\n+    take: 10,\n+  })\n+\n+  return <ReviewsList reviews={reviews} />\n+}\n+\n+// Dynamic inventory (real-time)\n+async function InventoryStatus({ productId }: { productId: string }) {\n+  // No cache - always fresh\n+  const inventory = await db.inventory.findUnique({\n+    where: { productId },\n+  })\n+\n+  return (\n+    <div>\n+      {inventory.quantity > 0 ? (\n+        <span className=\"text-green-600\">In Stock ({inventory.quantity})</span>\n+      ) : (\n+        <span className=\"text-red-600\">Out of Stock</span>\n+      )}\n+    </div>\n+  )\n+}\n+\n+// Page composition\n+export default async function ProductPage({\n+  params,\n+}: {\n+  params: Promise<{ id: string }>\n+}) {\n+  const { id } = await params\n+\n+  return (\n+    <>\n+      <ProductDetails productId={id} />\n+\n+      <Suspense fallback={<InventorySkeleton />}>\n+        <InventoryStatus productId={id} />\n+      </Suspense>\n+\n+      {/* Suspense around cached components:\n+          - At BUILD TIME (PPR): Cached content is pre-rendered into the static shell,\n+            so the fallback is never shown for initial page loads.\n+          - At RUNTIME (cache miss/expiration): When the cache expires or on cold start,\n+            Suspense shows the fallback while fresh data loads.\n+          - For long-lived caches ('minutes', 'hours', 'days'), Suspense is optional\n+            but improves UX during the rare cache miss. */}\n+      <Suspense fallback={<ReviewsSkeleton />}>\n+        <ProductReviews productId={id} />\n+      </Suspense>\n+    </>\n+  )\n+}\n+```\n+\n+---\n+\n+## Pattern 9: Multi-tenant SaaS Application\n+\n+Handle tenant-specific caching:\n+\n+```tsx\n+// lib/tenant.ts\n+export async function getTenantId() {\n+  const host = (await headers()).get('host')\n+  return host?.split('.')[0] // subdomain as tenant ID\n+}\n+\n+// Tenant-scoped cached data\n+async function TenantDashboard({ tenantId }: { tenantId: string }) {\n+  'use cache'\n+  cacheTag(`tenant-${tenantId}`, 'dashboards')\n+  cacheLife('minutes')\n+\n+  const data = await db.dashboards.findFirst({\n+    where: { tenantId },\n+  })\n+\n+  return <Dashboard data={data} />\n+}\n+\n+// Page with tenant context\n+export default function DashboardPage() {\n+  return (\n+    <Suspense fallback={<DashboardSkeleton />}>\n+      <DashboardLoader />\n+    </Suspense>\n+  )\n+}\n+\n+async function DashboardLoader() {\n+  const tenantId = await getTenantId()\n+  return <TenantDashboard tenantId={tenantId} />\n+}\n+\n+// Tenant-specific invalidation\n+'use server'\n+import { updateTag } from 'next/cache'\n+\n+export async function updateTenantSettings(data: FormData) {\n+  const tenantId = await getTenantId()\n+\n+  await db.settings.update({\n+    where: { tenantId },\n+    data: {\n+      /* ... */\n+    },\n+  })\n+\n+  // Only invalidate this tenant's cache\n+  updateTag(`tenant-${tenantId}`)\n+}\n+```\n+\n+---\n+\n+## Pattern 10: Subshell Composition with generateStaticParams\n+\n+Leverage parameter permutations to create reusable subshells:\n+\n+```tsx\n+// app/products/[category]/[slug]/page.tsx\n+import { Suspense } from 'react'\n+import { cacheLife, cacheTag } from 'next/cache'\n+\n+// Product details - uses both params\n+async function ProductDetails({\n+  category,\n+  slug,\n+}: {\n+  category: string\n+  slug: string\n+}) {\n+  'use cache'\n+  cacheTag('products', `product-${slug}`)\n+  cacheLife('hours')\n+\n+  const product = await db.products.findUnique({\n+    where: { category, slug },\n+  })\n+\n+  return <ProductCard product={product} />\n+}\n+\n+export default async function ProductPage({\n+  params,\n+}: {\n+  params: Promise<{ category: string; slug: string }>\n+}) {\n+  const { category, slug } = await params\n+\n+  return <ProductDetails category={category} slug={slug} />\n+}\n+\n+// Provide params to enable subshell generation\n+export async function generateStaticParams() {\n+  const products = await db.products.findMany({\n+    select: { category: true, slug: true },\n+    take: 100,\n+  })\n+  return products.map(({ category, slug }) => ({ category, slug }))\n+}\n+```\n+\n+```tsx\n+// app/products/[category]/layout.tsx\n+import { Suspense } from 'react'\n+import { cacheLife, cacheTag } from 'next/cache'\n+\n+// Category header - uses only category param\n+async function CategoryHeader({ category }: { category: string }) {\n+  'use cache'\n+  cacheTag('categories', `category-${category}`)\n+  cacheLife('days')\n+\n+  const cat = await db.categories.findUnique({ where: { slug: category } })\n+  return (\n+    <header>\n+      <h1>{cat.name}</h1>\n+      <p>{cat.description}</p>\n+    </header>\n+  )\n+}\n+\n+export default async function CategoryLayout({\n+  children,\n+  params,\n+}: {\n+  children: React.ReactNode\n+  params: Promise<{ category: string }>\n+}) {\n+  const { category } = await params\n+\n+  return (\n+    <>\n+      <CategoryHeader category={category} />\n+      {/* Suspense enables subshell generation */}\n+      <Suspense fallback={<ProductSkeleton />}>{children}</Suspense>\n+    </>\n+  )\n+}\n+```\n+\n+**Result**: When users navigate to `/products/jackets/unknown-jacket`:\n+\n+1. Category subshell (`/products/jackets/[slug]`) served instantly\n+2. Product details stream in as they load\n+3. Future visits to any jacket product reuse the category shell\n+\n+---\n+\n+## Pattern 11: Hierarchical Params for Deep Routes\n+\n+For deeply nested routes, structure layouts to maximize subshell reuse:\n+\n+```tsx\n+// Route: /store/[region]/[category]/[productId]\n+\n+// app/store/[region]/layout.tsx\n+export default async function RegionLayout({\n+  children,\n+  params,\n+}: {\n+  children: React.ReactNode\n+  params: Promise<{ region: string }>\n+}) {\n+  const { region } = await params\n+\n+  return (\n+    <>\n+      <RegionHeader region={region} /> {/* Cached */}\n+      <RegionPromos region={region} /> {/* Cached */}\n+      <Suspense>{children}</Suspense> {/* Subshell boundary */}\n+    </>\n+  )\n+}\n+\n+// app/store/[region]/[category]/layout.tsx\n+export default async function CategoryLayout({\n+  children,\n+  params,\n+}: {\n+  children: React.ReactNode\n+  params: Promise<{ region: string; category: string }>\n+}) {\n+  const { region, category } = await params\n+\n+  return (\n+    <>\n+      <CategoryNav region={region} category={category} /> {/* Cached */}\n+      <Suspense>{children}</Suspense> {/* Subshell boundary */}\n+    </>\n+  )\n+}\n+\n+// app/store/[region]/[category]/[productId]/page.tsx\n+export default async function ProductPage({\n+  params,\n+}: {\n+  params: Promise<{ region: string; category: string; productId: string }>\n+}) {\n+  const { region, category, productId } = await params\n+\n+  return <ProductDetails region={region} productId={productId} />\n+}\n+\n+export async function generateStaticParams() {\n+  // Return popular products - subshells generated for all unique region/category combos\n+  return [\n+    { region: 'us', category: 'electronics', productId: 'iphone-16' },\n+    { region: 'us', category: 'electronics', productId: 'macbook-pro' },\n+    { region: 'us', category: 'clothing', productId: 'hoodie-xl' },\n+    { region: 'eu', category: 'electronics', productId: 'iphone-16' },\n+  ]\n+}\n+```\n+\n+**Generated subshells:**\n+\n+- `/store/us/[category]/[productId]` - US region shell\n+- `/store/eu/[category]/[productId]` - EU region shell\n+- `/store/us/electronics/[productId]` - US Electronics shell\n+- `/store/us/clothing/[productId]` - US Clothing shell\n+- `/store/eu/electronics/[productId]` - EU Electronics shell\n+\n+---\n+\n+## When to Use Suspense with Cached Components\n+\n+Understanding when Suspense is required vs. optional for cached components:\n+\n+### Dynamic Components (no cache) → Suspense Required\n+\n+```tsx\n+// Dynamic content MUST have Suspense for streaming\n+async function PersonalizedFeed() {\n+  const session = await getSession() // Dynamic - reads cookies\n+  const feed = await fetchFeed(session.userId)\n+  return <Feed posts={feed} />\n+}\n+\n+export default function Page() {\n+  return (\n+    <Suspense fallback={<FeedSkeleton />}>\n+      <PersonalizedFeed />\n+    </Suspense>\n+  )\n+}\n+```\n+\n+### Cached Components → Suspense Optional (but recommended)\n+\n+```tsx\n+// Cached content: Suspense is optional but improves UX\n+async function ProductReviews({ productId }: { productId: string }) {\n+  'use cache'\n+  cacheLife('minutes')\n+  const reviews = await fetchReviews(productId)\n+  return <ReviewsList reviews={reviews} />\n+}\n+\n+// ✅ With Suspense - handles cache miss gracefully\n+<Suspense fallback={<ReviewsSkeleton />}>\n+  <ProductReviews productId={id} />\n+</Suspense>\n+\n+// ✅ Without Suspense - also valid for long-lived caches\n+<ProductReviews productId={id} />\n+```\n+\n+### Why Cached Components Don't Always Need Suspense\n+\n+| Scenario | What Happens | Suspense Needed? |\n+|----------|--------------|------------------|\n+| **Build time (PPR enabled)** | Content pre-rendered into static shell | No - fallback never shown |\n+| **Runtime - cache hit** | Cached result returned immediately | No - no suspension |\n+| **Runtime - cache miss** | Async function executes, component suspends | Yes - for better UX |\n+\n+### Recommendations by Cache Lifetime\n+\n+| Cache Lifetime | Suspense Recommendation | Reasoning |\n+|----------------|------------------------|-----------|\n+| `'seconds'` | **Recommended** | Frequent cache misses |\n+| `'minutes'` | Optional | ~5 min expiry, occasional misses |\n+| `'hours'` / `'days'` | Optional | Rare cache misses |\n+| `'max'` | Not needed | Essentially static |\n+\n+### The Trade-off\n+\n+**Without Suspense**: On cache miss, the page waits for data before rendering anything downstream. For long-lived caches, this is rare and brief.\n+\n+**With Suspense**: On cache miss, users see the skeleton immediately while data loads. Better perceived performance, slightly more code.\n+\n+**Rule of thumb**: When in doubt, add Suspense. It never hurts and handles edge cases gracefully.\n+\n+---\n+\n+## Anti-Patterns to Avoid\n+\n+### ❌ Caching user-specific data without parameters\n+\n+```tsx\n+// BAD: Same cache for all users\n+async function UserProfile() {\n+  'use cache'\n+  const user = await getCurrentUser() // Different per user!\n+  return <Profile user={user} />\n+}\n+\n+// GOOD: User ID as parameter (becomes cache key)\n+async function UserProfile({ userId }: { userId: string }) {\n+  'use cache'\n+  cacheTag(`user-${userId}`)\n+  const user = await db.users.findUnique({ where: { id: userId } })\n+  return <Profile user={user} />\n+}\n+```\n+\n+### ❌ Over-caching volatile data\n+\n+```tsx\n+// BAD: Caching real-time data\n+async function StockPrice({ symbol }: { symbol: string }) {\n+  'use cache'\n+  cacheLife('hours') // Stale prices!\n+  return await fetchStockPrice(symbol)\n+}\n+\n+// GOOD: Don't cache, or use very short cache\n+async function StockPrice({ symbol }: { symbol: string }) {\n+  'use cache'\n+  cacheLife('seconds') // 1 second max\n+  return await fetchStockPrice(symbol)\n+}\n+\n+// BETTER: No cache for truly real-time\n+async function StockPrice({ symbol }: { symbol: string }) {\n+  return await fetchStockPrice(symbol)\n+}\n+```\n+\n+### ❌ Forgetting Suspense for dynamic content\n+\n+```tsx\n+// BAD: No fallback for DYNAMIC content - breaks streaming\n+export default async function Page() {\n+  return (\n+    <>\n+      <CachedHeader />\n+      <DynamicContent /> {/* Dynamic - NEEDS Suspense */}\n+    </>\n+  )\n+}\n+\n+// GOOD: Proper Suspense boundary for dynamic content\n+export default async function Page() {\n+  return (\n+    <>\n+      <CachedHeader />\n+      <Suspense fallback={<ContentSkeleton />}>\n+        <DynamicContent />\n+      </Suspense>\n+    </>\n+  )\n+}\n+\n+// ALSO GOOD: Cached content without Suspense (optional for long-lived caches)\n+export default async function Page() {\n+  return (\n+    <>\n+      <CachedHeader />       {/* 'use cache' - no Suspense needed */}\n+      <CachedSidebar />      {/* 'use cache' - no Suspense needed */}\n+      <Suspense fallback={<ContentSkeleton />}>\n+        <DynamicContent />   {/* Dynamic - Suspense required */}\n+      </Suspense>\n+    </>\n+  )\n+}\n+```"
        },
        {
            "sha": "bbf257d9d3ef792b59cdbfdec46792241bacd6b3",
            "filename": ".claude-plugin/plugins/cache-components/skills/cache-components/REFERENCE.md",
            "status": "added",
            "additions": 1089,
            "deletions": 0,
            "changes": 1089,
            "blob_url": "https://github.com/vercel/next.js/blob/b9edb9175e15b433122afb114cbec6a2951d7d02/.claude-plugin%2Fplugins%2Fcache-components%2Fskills%2Fcache-components%2FREFERENCE.md",
            "raw_url": "https://github.com/vercel/next.js/raw/b9edb9175e15b433122afb114cbec6a2951d7d02/.claude-plugin%2Fplugins%2Fcache-components%2Fskills%2Fcache-components%2FREFERENCE.md",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/.claude-plugin%2Fplugins%2Fcache-components%2Fskills%2Fcache-components%2FREFERENCE.md?ref=b9edb9175e15b433122afb114cbec6a2951d7d02",
            "patch": "@@ -0,0 +1,1089 @@\n+# Cache Components API Reference\n+\n+Complete API reference for Next.js Cache Components.\n+\n+## Directive: `'use cache'`\n+\n+Marks a function or file as cacheable. The cached output is included in the static shell during Partial Prerendering.\n+\n+### Syntax\n+\n+```tsx\n+// File-level (applies to all exports)\n+'use cache'\n+\n+export async function getData() {\n+  /* ... */\n+}\n+\n+// Function-level\n+async function Component() {\n+  'use cache'\n+  // ...\n+}\n+```\n+\n+### Variants\n+\n+| Directive             | Description              | Cache Storage            |\n+| --------------------- | ------------------------ | ------------------------ |\n+| `'use cache'`         | Standard cache (default) | Default handler + Remote |\n+| `'use cache: remote'` | Platform remote cache    | Remote handler only      |\n+\n+### `'use cache: remote'`\n+\n+Uses platform-specific remote cache handler. Requires network roundtrip.\n+\n+```tsx\n+async function HeavyComputation() {\n+  'use cache: remote'\n+  cacheLife('days')\n+\n+  return await expensiveCalculation()\n+}\n+```\n+\n+### Understanding Cache Handlers\n+\n+Next.js uses **cache handlers** to store and retrieve cached data. The directive variant determines which handlers are used:\n+\n+| Handler   | Description                                                                 |\n+| --------- | --------------------------------------------------------------------------- |\n+| `default` | Local in-memory cache with optional persistence. Fast, single-server scope |\n+| `remote`  | Platform-specific distributed cache. Network roundtrip, multi-server scope |\n+\n+**How variants map to handlers:**\n+\n+- `'use cache'` → Uses **both** default and remote handlers. Data is cached locally for fast access and remotely for sharing across instances\n+- `'use cache: remote'` → Uses **only** the remote handler. Skips local cache, always fetches from distributed cache\n+\n+**When to use each:**\n+\n+| Use Case                              | Recommended Variant   |\n+| ------------------------------------- | --------------------- |\n+| Most cached data                      | `'use cache'`         |\n+| Heavy computations to share globally  | `'use cache: remote'` |\n+| Data that must be consistent globally | `'use cache: remote'` |\n+\n+### Rules\n+\n+1. **Must be async** - All cached functions must return a Promise\n+2. **First statement** - `'use cache'` must be the first statement in the function body\n+3. **No runtime APIs** - Cannot call `cookies()`, `headers()`, `searchParams` directly\n+4. **Serializable arguments** - All arguments must be serializable (no functions, class instances)\n+5. **Serializable return values** - Cached functions must return serializable data (no functions, class instances)\n+\n+---\n+\n+## Function: `cacheLife()`\n+\n+Configures cache duration and revalidation behavior.\n+\n+### Import\n+\n+```tsx\n+import { cacheLife } from 'next/cache'\n+```\n+\n+### Signature\n+\n+```tsx\n+function cacheLife(profile: string): void\n+function cacheLife(options: CacheLifeOptions): void\n+\n+interface CacheLifeOptions {\n+  stale?: number // Client cache duration (seconds)\n+  revalidate?: number // Background revalidation window (seconds)\n+  expire?: number // Absolute expiration (seconds)\n+}\n+```\n+\n+### Parameters\n+\n+| Parameter    | Description                                             | Constraint            |\n+| ------------ | ------------------------------------------------------- | --------------------- |\n+| `stale`      | How long the client can cache without server validation | None                  |\n+| `revalidate` | When to start background refresh                        | `revalidate ≤ expire` |\n+| `expire`     | Absolute expiration; deopts to dynamic if exceeded      | Must be largest       |\n+\n+### Predefined Profiles\n+\n+| Profile     | stale | revalidate    | expire         |\n+| ----------- | ----- | ------------- | -------------- |\n+| `'default'` | 300\\* | 900 (15min)   | ∞ (INFINITE)   |\n+| `'seconds'` | 30    | 1             | 60             |\n+| `'minutes'` | 300   | 60 (1min)     | 3600 (1hr)     |\n+| `'hours'`   | 300   | 3600 (1hr)    | 86400 (1day)   |\n+| `'days'`    | 300   | 86400 (1day)  | 604800 (1wk)   |\n+| `'weeks'`   | 300   | 604800 (1wk)  | 2592000 (30d)  |\n+| `'max'`     | 300   | 2592000 (30d) | 31536000 (1yr) |\n+\n+\\* Default `stale` falls back to `experimental.staleTimes.static` (300 seconds)\n+\n+> **Important:** Profiles with `expire < 300` seconds (like `'seconds'`) are treated as **dynamic** and won't be included in the static shell during Partial Prerendering. See [Dynamic Threshold](#dynamic-threshold) below.\n+\n+### Custom Profiles\n+\n+Define custom profiles in `next.config.ts`:\n+\n+```typescript\n+const nextConfig: NextConfig = {\n+  cacheLife: {\n+    // Custom profile\n+    'blog-posts': {\n+      stale: 300, // 5 minutes\n+      revalidate: 3600, // 1 hour\n+      expire: 86400, // 1 day\n+    },\n+    // Override default\n+    default: {\n+      stale: 60,\n+      revalidate: 600,\n+      expire: 3600,\n+    },\n+  },\n+}\n+```\n+\n+### Usage\n+\n+```tsx\n+async function BlogPosts() {\n+  'use cache'\n+  cacheLife('blog-posts') // Custom profile\n+\n+  return await db.posts.findMany()\n+}\n+```\n+\n+### HTTP Cache-Control Mapping\n+\n+```\n+stale     → max-age\n+revalidate → s-maxage\n+expire - revalidate → stale-while-revalidate\n+\n+Example: stale=60, revalidate=3600, expire=86400\n+→ Cache-Control: max-age=60, s-maxage=3600, stale-while-revalidate=82800\n+```\n+\n+### Dynamic Threshold\n+\n+Cache entries with short expiration times are treated as **dynamic holes** during Partial Prerendering:\n+\n+| Condition               | Behavior                                 |\n+| ----------------------- | ---------------------------------------- |\n+| `expire < 300` seconds  | Treated as dynamic (not in static shell) |\n+| `revalidate === 0`      | Treated as dynamic (not in static shell) |\n+| `expire >= 300` seconds | Included in static shell                 |\n+\n+**Why `expire`, not `stale`?**\n+\n+The threshold uses `expire` (absolute expiration) because:\n+\n+- `expire` defines the **maximum lifetime** of the cache entry\n+- If `expire` is very short, the cached content would immediately become invalid in the static shell\n+- `stale` only affects **client-side freshness perception** - how long before the browser revalidates\n+- Including short-lived content in the static shell would serve guaranteed-stale data\n+\n+**Practical implications:**\n+\n+- `cacheLife('seconds')` (expire=60) → **Dynamic** - streams at request time\n+- `cacheLife('minutes')` (expire=3600) → **Static** - included in PPR shell\n+- Custom `cacheLife({ expire: 120 })` → **Dynamic** - below 300s threshold\n+\n+This 300-second threshold ensures that very short-lived caches don't pollute the static shell with immediately-stale content.\n+\n+```tsx\n+// This cache is DYNAMIC (expire=60 < 300)\n+async function RealtimePrice() {\n+  'use cache'\n+  cacheLife('seconds') // expire=60, below threshold\n+  return await fetchPrice()\n+}\n+\n+// This cache is STATIC (expire=3600 >= 300)\n+async function ProductDetails() {\n+  'use cache'\n+  cacheLife('minutes') // expire=3600, above threshold\n+  return await fetchProduct()\n+}\n+```\n+\n+---\n+\n+## Function: `cacheTag()`\n+\n+Tags cached data for targeted invalidation.\n+\n+### Import\n+\n+```tsx\n+import { cacheTag } from 'next/cache'\n+```\n+\n+### Signature\n+\n+```tsx\n+function cacheTag(...tags: string[]): void\n+```\n+\n+### Usage\n+\n+```tsx\n+async function UserProfile({ userId }: { userId: string }) {\n+  'use cache'\n+  cacheTag('users', `user-${userId}`) // Multiple tags\n+  cacheLife('hours')\n+\n+  return await db.users.findUnique({ where: { id: userId } })\n+}\n+```\n+\n+### Tagging Strategies\n+\n+**Entity-based tagging**:\n+\n+```tsx\n+cacheTag('posts') // All posts\n+cacheTag(`post-${postId}`) // Specific post\n+cacheTag(`user-${userId}-posts`) // User's posts\n+```\n+\n+**Feature-based tagging**:\n+\n+```tsx\n+cacheTag('homepage')\n+cacheTag('dashboard')\n+cacheTag('admin')\n+```\n+\n+**Combined approach**:\n+\n+```tsx\n+cacheTag('posts', `post-${id}`, `author-${authorId}`)\n+```\n+\n+### Tag Constraints\n+\n+Tags have enforced limits:\n+\n+| Limit          | Value          | Behavior if exceeded           |\n+| -------------- | -------------- | ------------------------------ |\n+| Max tag length | 256 characters | Warning logged, tag ignored    |\n+| Max total tags | 128 tags       | Warning logged, excess ignored |\n+\n+```tsx\n+// ❌ Tag too long (>256 chars) - will be ignored with warning\n+cacheTag('a'.repeat(300))\n+\n+// ❌ Too many tags (>128) - excess will be ignored with warning\n+cacheTag(...Array(200).fill('tag'))\n+\n+// ✅ Valid usage\n+cacheTag('products', `product-${id}`, `category-${category}`)\n+```\n+\n+### Implicit Tags (Automatic)\n+\n+In addition to explicit `cacheTag()` calls, Next.js automatically applies **implicit tags** based on the route hierarchy. This means `revalidatePath()` works without any explicit `cacheTag()` calls:\n+\n+```tsx\n+'use server'\n+import { revalidatePath } from 'next/cache'\n+\n+export async function publishBlogPost() {\n+  await db.posts.create({\n+    /* ... */\n+  })\n+\n+  // Works without explicit cacheTag() - uses implicit route-based tags\n+  revalidatePath('/blog', 'layout') // Invalidates all /blog/* routes\n+}\n+```\n+\n+**How it works:**\n+\n+- Each route segment (layout, page) automatically receives an internal tag\n+- `revalidatePath('/blog', 'layout')` invalidates the `/blog` layout and all nested routes\n+- `revalidatePath('/blog/my-post')` invalidates only that specific page\n+\n+**Choosing between implicit and explicit tags**:\n+\n+| Use Case                                 | Approach                            |\n+| ---------------------------------------- | ----------------------------------- |\n+| Invalidate all cached data under a route | `revalidatePath()` (uses implicit)  |\n+| Invalidate specific entity across routes | `cacheTag()` + `updateTag()`        |\n+| User needs to see their change (eager)   | `updateTag()` with explicit tag     |\n+| Background update, eventual OK (lazy)    | `revalidateTag()` with explicit tag |\n+\n+---\n+\n+## Understanding Cache Scope\n+\n+### What Creates a New Cache Entry?\n+\n+A new cache entry is created when ANY of these differ:\n+\n+| Factor                | Example                                 |\n+| --------------------- | --------------------------------------- |\n+| **Function identity** | Different functions = different entries |\n+| **Arguments**         | `getUser(\"123\")` vs `getUser(\"456\")`    |\n+| **File path**         | Same function name in different files   |\n+\n+### Cache Key Composition\n+\n+Cache keys are composed of multiple parts:\n+\n+```\n+[buildId, functionId, serializedArgs, (hmrRefreshHash)]\n+```\n+\n+| Part             | Description                                                     |\n+| ---------------- | --------------------------------------------------------------- |\n+| `buildId`        | Unique build identifier (prevents cross-deployment cache reuse) |\n+| `functionId`     | Server reference ID for the cached function                     |\n+| `serializedArgs` | React Flight-encoded function arguments                         |\n+| `hmrRefreshHash` | (Dev only) Invalidates cache on file changes                    |\n+\n+```tsx\n+// These create TWO separate cache entries (third call is a cache hit):\n+async function getProduct(id: string) {\n+  'use cache'\n+  return db.products.findUnique({ where: { id } })\n+}\n+\n+await getProduct('prod-1') // Cache entry 1: [buildId, getProduct, \"prod-1\"]\n+await getProduct('prod-2') // Cache entry 2: [buildId, getProduct, \"prod-2\"]\n+await getProduct('prod-1') // Cache HIT on entry 1\n+```\n+\n+### Object Arguments and Cache Keys\n+\n+Arguments are serialized using React's `encodeReply()`, which performs **structural serialization**:\n+\n+```tsx\n+async function getData(options: { limit: number }) {\n+  'use cache'\n+  return fetch(`/api?limit=${options.limit}`)\n+}\n+\n+// Objects with identical structure produce the same cache key\n+getData({ limit: 10 }) // Cache key includes serialized { limit: 10 }\n+getData({ limit: 10 }) // HIT! Same structural content\n+\n+// Different values = different cache keys\n+getData({ limit: 20 }) // MISS - different content\n+```\n+\n+**Best practice:** While objects work correctly, primitives are simpler to reason about:\n+\n+```tsx\n+// ✅ Clear and explicit\n+async function getData(limit: number) {\n+  'use cache'\n+  return fetch(`/api?limit=${limit}`)\n+}\n+```\n+\n+> **Note:** Non-serializable values (functions, class instances, Symbols) cannot be used as arguments to cached functions and will cause errors.\n+\n+---\n+\n+## Function: `updateTag()`\n+\n+Immediately invalidates cache entries and ensures read-your-own-writes.\n+\n+### Import\n+\n+```tsx\n+import { updateTag } from 'next/cache'\n+```\n+\n+### Signature\n+\n+```tsx\n+function updateTag(tag: string): void\n+```\n+\n+### Usage\n+\n+```tsx\n+'use server'\n+import { updateTag } from 'next/cache'\n+\n+export async function createPost(formData: FormData) {\n+  const post = await db.posts.create({ data: formData })\n+\n+  updateTag('posts') // Update all cache entries tagged with 'posts'\n+  updateTag(`user-${userId}`) // Update all cache entries tagged with this user\n+\n+  // Client immediately sees fresh data\n+}\n+```\n+\n+### Behavior\n+\n+- **Immediate**: Cache invalidated synchronously\n+- **Read-your-own-writes**: Subsequent reads return fresh data\n+- **Server Actions only**: Must be called from Server Actions\n+\n+---\n+\n+## Function: `revalidateTag()`\n+\n+Marks cache entries as stale for background revalidation.\n+\n+### Import\n+\n+```tsx\n+import { revalidateTag } from 'next/cache'\n+```\n+\n+### Signature\n+\n+```tsx\n+function revalidateTag(tag: string, profile: string | { expire?: number }): void\n+```\n+\n+### Parameters\n+\n+| Parameter | Type                            | Description                                                    |\n+| --------- | ------------------------------- | -------------------------------------------------------------- |\n+| `tag`     | `string`                        | The cache tag to invalidate                                    |\n+| `profile` | `string \\| { expire?: number }` | Cache profile name or object with expire time (seconds)        |\n+\n+> **Note:** Unlike `cacheLife()` which accepts `stale`, `revalidate`, and `expire`, the `revalidateTag()` object form only accepts `expire`. Use a predefined profile name (like `'hours'`) for full control over stale-while-revalidate behavior.\n+\n+### Usage\n+\n+```tsx\n+'use server'\n+import { revalidateTag } from 'next/cache'\n+\n+export async function updateSettings(data: FormData) {\n+  await db.settings.update({ data })\n+\n+  // With predefined profile (recommended)\n+  revalidateTag('settings', 'hours')\n+\n+  // With custom expiration\n+  revalidateTag('settings', { expire: 3600 })\n+}\n+```\n+\n+### Behavior\n+\n+- **Stale-while-revalidate**: Serves cached content while refreshing in background\n+- **Background refresh**: Cache entry is refreshed in the background after the next visit\n+- **Broader context**: Can be called from Route Handlers and Server Actions\n+\n+---\n+\n+## updateTag() vs revalidateTag(): When to Use Each\n+\n+The key distinction is **eager vs lazy** invalidation:\n+\n+- **`updateTag()`** - Eager invalidation. Cache is immediately invalidated, and the next read fetches fresh data synchronously. Use when the user who triggered the action needs to see the result.\n+- **`revalidateTag()`** - Lazy (SWR-style) invalidation. Stale data may be served while fresh data is fetched in the background. Use when eventual consistency is acceptable.\n+\n+Here's a decision guide:\n+\n+| Scenario                   | Use               | Why                                        |\n+| -------------------------- | ----------------- | ------------------------------------------ |\n+| User creates a post        | `updateTag()`     | User expects to see their post immediately |\n+| User updates their profile | `updateTag()`     | Read-your-own-writes semantics             |\n+| Admin publishes content    | `revalidateTag()` | Other users can see stale briefly          |\n+| Analytics/view counts      | `revalidateTag()` | Freshness less critical                    |\n+| Background sync job        | `revalidateTag()` | No user waiting for result                 |\n+| E-commerce cart update     | `updateTag()`     | User needs accurate cart state             |\n+\n+### E-commerce Example\n+\n+```tsx\n+'use server'\n+import { updateTag, revalidateTag } from 'next/cache'\n+\n+// When USER adds to cart → updateTag (they need accurate count)\n+export async function addToCart(productId: string, userId: string) {\n+  await db.cart.add({ productId, userId })\n+  updateTag(`cart-${userId}`) // Immediate - user sees their cart\n+}\n+\n+// When INVENTORY changes from warehouse sync → revalidateTag\n+export async function syncInventory(products: Product[]) {\n+  await db.inventory.bulkUpdate(products)\n+  revalidateTag('inventory', 'max') // Background - eventual consistency OK\n+}\n+\n+// When USER completes purchase → updateTag for buyer, revalidateTag for product\n+export async function completePurchase(orderId: string) {\n+  const order = await processOrder(orderId)\n+\n+  updateTag(`order-${orderId}`) // Buyer sees confirmation immediately\n+  updateTag(`cart-${order.userId}`) // Buyer's cart clears immediately\n+  revalidateTag(`product-${order.productId}`, 'max') // Others see updated stock eventually\n+}\n+```\n+\n+### The Rule of Thumb\n+\n+> **updateTag**: \"The person who triggered this action is waiting to see the result\"\n+>\n+> **revalidateTag**: \"This update affects others, but they don't know to wait for it\"\n+\n+---\n+\n+## Function: `revalidatePath()`\n+\n+Revalidates all cache entries associated with a path.\n+\n+### Import\n+\n+```tsx\n+import { revalidatePath } from 'next/cache'\n+```\n+\n+### Signature\n+\n+```tsx\n+function revalidatePath(path: string, type?: 'page' | 'layout'): void\n+```\n+\n+### Usage\n+\n+```tsx\n+'use server'\n+import { revalidatePath } from 'next/cache'\n+\n+export async function updateBlog() {\n+  await db.posts.update({\n+    /* ... */\n+  })\n+\n+  revalidatePath('/blog') // Specific path\n+  revalidatePath('/blog', 'layout') // Layout and all children\n+  revalidatePath('/', 'layout') // Entire app\n+}\n+```\n+\n+---\n+\n+## Configuration: `next.config.ts`\n+\n+### Enable Cache Components\n+\n+```typescript\n+import type { NextConfig } from 'next'\n+\n+const nextConfig: NextConfig = {\n+  cacheComponents: true,\n+}\n+\n+export default nextConfig\n+```\n+\n+### Configure Cache Handlers\n+\n+```typescript\n+const nextConfig: NextConfig = {\n+  cacheHandlers: {\n+    default: {\n+      maxMemorySize: 52428800, // 50MB\n+    },\n+    // Platform-specific remote handler\n+    remote: CustomRemoteHandler,\n+  },\n+}\n+```\n+\n+### Define Cache Profiles\n+\n+```typescript\n+const nextConfig: NextConfig = {\n+  cacheLife: {\n+    default: {\n+      stale: 60,\n+      revalidate: 3600,\n+      expire: 86400,\n+    },\n+    posts: {\n+      stale: 300,\n+      revalidate: 3600,\n+      expire: 604800,\n+    },\n+  },\n+}\n+```\n+\n+---\n+\n+## `generateStaticParams` with Cache Components\n+\n+When Cache Components is enabled, `generateStaticParams` behavior changes significantly.\n+\n+### Parameter Permutation Rendering\n+\n+Next.js renders ALL permutations of provided parameters to create reusable subshells:\n+\n+```tsx\n+// app/products/[category]/[slug]/page.tsx\n+export async function generateStaticParams() {\n+  return [\n+    { category: 'jackets', slug: 'bomber' },\n+    { category: 'jackets', slug: 'parka' },\n+    { category: 'shoes', slug: 'sneakers' },\n+  ]\n+}\n+```\n+\n+**Rendered routes:**\n+\n+| Route                         | Params Known       | Shell Type        |\n+| ----------------------------- | ------------------ | ----------------- |\n+| `/products/jackets/bomber`    | category ✓, slug ✓ | Complete page     |\n+| `/products/jackets/parka`     | category ✓, slug ✓ | Complete page     |\n+| `/products/shoes/sneakers`    | category ✓, slug ✓ | Complete page     |\n+| `/products/jackets/[slug]`    | category ✓, slug ✗ | Category subshell |\n+| `/products/shoes/[slug]`      | category ✓, slug ✗ | Category subshell |\n+| `/products/[category]/[slug]` | category ✗, slug ✗ | Fallback shell    |\n+\n+### Requirements\n+\n+1. **Must return at least one parameter set** - Empty arrays cause build errors\n+2. **Params validate static safety** - Next.js uses provided params to verify no dynamic APIs are accessed\n+3. **Subshells require Suspense** - If accessing unknown params without Suspense, no subshell is generated\n+\n+```tsx\n+// ❌ BUILD ERROR: Empty array not allowed\n+export function generateStaticParams() {\n+  return []\n+}\n+\n+// ✅ CORRECT: Provide at least one param set\n+export async function generateStaticParams() {\n+  const products = await getProducts({ limit: 100 })\n+  return products.map((p) => ({ category: p.category, slug: p.slug }))\n+}\n+```\n+\n+### Subshell Generation with Layouts\n+\n+Create category-level subshells by adding Suspense in layouts:\n+\n+```tsx\n+// app/products/[category]/layout.tsx\n+export default async function CategoryLayout({\n+  children,\n+  params,\n+}: {\n+  children: React.ReactNode\n+  params: Promise<{ category: string }>\n+}) {\n+  const { category } = await params\n+\n+  return (\n+    <>\n+      <h2>{category}</h2>\n+      <Suspense>{children}</Suspense> {/* Creates subshell boundary */}\n+    </>\n+  )\n+}\n+```\n+\n+Now `/products/jackets/[slug]` generates a reusable shell with the category header, streaming product details when visited.\n+\n+### Why Subshells Matter\n+\n+Without `generateStaticParams`, visiting `/products/jackets/unknown-product`:\n+\n+- **Before**: Full dynamic render, user waits for everything\n+- **After**: Cached category subshell served instantly, product details stream in\n+\n+---\n+\n+## Deprecated Segment Configurations\n+\n+These exports are **deprecated** when `cacheComponents: true`:\n+\n+### `export const revalidate` (Deprecated)\n+\n+**Before:**\n+\n+```tsx\n+// app/products/page.tsx\n+export const revalidate = 3600 // 1 hour\n+\n+export default async function ProductsPage() {\n+  const products = await db.products.findMany()\n+  return <ProductList products={products} />\n+}\n+```\n+\n+**Problems with this approach:**\n+\n+- Revalidation time lived at segment level, not with the data\n+- Couldn't vary revalidation based on fetched data\n+- No control over client-side caching (`stale`) or expiration\n+\n+**After (Cache Components):**\n+\n+```tsx\n+// app/products/page.tsx\n+import { cacheLife } from 'next/cache'\n+\n+async function getProducts() {\n+  'use cache'\n+  cacheLife('hours') // Co-located with the data\n+\n+  return await db.products.findMany()\n+}\n+\n+export default async function ProductsPage() {\n+  const products = await getProducts()\n+  return <ProductList products={products} />\n+}\n+```\n+\n+**Benefits:**\n+\n+- Cache lifetime co-located with data fetching\n+- Granular control: `stale`, `revalidate`, and `expire`\n+- Different functions can have different lifetimes\n+- Can conditionally set cache life based on data\n+\n+### `export const dynamic` (Deprecated)\n+\n+**Before:**\n+\n+```tsx\n+// app/products/page.tsx\n+export const dynamic = 'force-static'\n+\n+export default async function ProductsPage() {\n+  // Headers would return empty, silently breaking components\n+  const headers = await getHeaders()\n+  return <ProductList />\n+}\n+```\n+\n+**Problems:**\n+\n+- All-or-nothing approach\n+- `force-static` silently broke dynamic APIs (cookies, headers return empty)\n+- `force-dynamic` prevented any static optimization\n+- Hidden bugs when dynamic components received empty data\n+\n+**After (Cache Components):**\n+\n+```tsx\n+// app/products/page.tsx\n+export default async function ProductsPage() {\n+  return (\n+    <>\n+      <CachedProductList /> {/* Static via 'use cache' */}\n+      <Suspense fallback={<Skeleton />}>\n+        <DynamicUserRecommendations /> {/* Dynamic via Suspense */}\n+      </Suspense>\n+    </>\n+  )\n+}\n+```\n+\n+**Benefits:**\n+\n+- No silent API failures\n+- Granular static/dynamic at component level\n+- Build errors guide you to correct patterns\n+- Pages can be BOTH static AND dynamic\n+\n+### Migration Guide\n+\n+| Old Pattern                              | New Pattern                                            |\n+| ---------------------------------------- | ------------------------------------------------------ |\n+| `export const revalidate = 60`           | `cacheLife({ revalidate: 60 })` inside `'use cache'`   |\n+| `export const revalidate = 0`            | Remove cache or use `cacheLife('seconds')`             |\n+| `export const revalidate = false`        | `cacheLife('max')` for long-term caching               |\n+| `export const dynamic = 'force-static'`  | Use `'use cache'` on data fetching                     |\n+| `export const dynamic = 'force-dynamic'` | Wrap in `<Suspense>` without cache                     |\n+| `export const dynamic = 'auto'`          | Default behavior - not needed                          |\n+| `export const dynamic = 'error'`         | Default with Cache Components (build errors guide you) |\n+\n+---\n+\n+## Migration Scenarios\n+\n+### Scenario 1: Page with `revalidate` Export\n+\n+**Before:**\n+\n+```tsx\n+// app/products/page.tsx\n+export const revalidate = 3600\n+\n+export default async function ProductsPage() {\n+  const products = await db.products.findMany()\n+  return <ProductGrid products={products} />\n+}\n+```\n+\n+**After:**\n+\n+```tsx\n+// app/products/page.tsx\n+import { cacheLife } from 'next/cache'\n+\n+async function getProducts() {\n+  'use cache'\n+  cacheLife('hours') // Roughly equivalent to revalidate = 3600\n+\n+  return db.products.findMany()\n+}\n+\n+export default async function ProductsPage() {\n+  const products = await getProducts()\n+  return <ProductGrid products={products} />\n+}\n+```\n+\n+### Scenario 2: Page with `dynamic = 'force-dynamic'`\n+\n+**Before:**\n+\n+```tsx\n+// app/dashboard/page.tsx\n+export const dynamic = 'force-dynamic'\n+\n+export default async function Dashboard() {\n+  const user = await getCurrentUser()\n+  const stats = await getStats()\n+  const notifications = await getNotifications(user.id)\n+\n+  return (\n+    <div>\n+      <UserHeader user={user} />\n+      <Stats data={stats} />\n+      <Notifications items={notifications} />\n+    </div>\n+  )\n+}\n+```\n+\n+**After:**\n+\n+```tsx\n+// app/dashboard/page.tsx\n+import { Suspense } from 'react'\n+\n+// All data is dynamic - fetches user-specific content\n+async function DashboardContent() {\n+  const user = await getCurrentUser()\n+  const stats = await getStats()\n+  const notifications = await getNotifications(user.id)\n+\n+  return (\n+    <>\n+      <UserHeader user={user} />\n+      <Stats data={stats} />\n+      <Notifications items={notifications} />\n+    </>\n+  )\n+}\n+\n+export default function Dashboard() {\n+  return (\n+    <div>\n+      <Suspense fallback={<DashboardSkeleton />}>\n+        <DashboardContent /> {/* Streams dynamically */}\n+      </Suspense>\n+    </div>\n+  )\n+}\n+```\n+\n+**Key difference:** No `export const dynamic` needed. Components are dynamic by default - just wrap in Suspense to enable streaming.\n+\n+### Scenario 3: ISR with `revalidate` + On-Demand Revalidation\n+\n+**Before:**\n+\n+```tsx\n+// app/blog/[slug]/page.tsx\n+export const revalidate = 3600\n+\n+export async function generateStaticParams() {\n+  const posts = await getAllPosts()\n+  return posts.map((post) => ({ slug: post.slug }))\n+}\n+\n+export default async function BlogPost({\n+  params,\n+}: {\n+  params: Promise<{ slug: string }>\n+}) {\n+  const { slug } = await params\n+  const post = await getPost(slug)\n+  return <Article post={post} />\n+}\n+\n+// api/revalidate/route.ts\n+export async function POST(request: Request) {\n+  const { slug } = await request.json()\n+  revalidatePath(`/blog/${slug}`)\n+  return Response.json({ revalidated: true })\n+}\n+```\n+\n+**After:**\n+\n+```tsx\n+// lib/posts.ts\n+import { cacheTag, cacheLife } from 'next/cache'\n+\n+export async function getPost(slug: string) {\n+  'use cache'\n+  cacheTag('posts', `post-${slug}`)\n+  cacheLife('hours')\n+\n+  return db.posts.findUnique({ where: { slug } })\n+}\n+\n+// app/blog/[slug]/page.tsx\n+export default async function BlogPost({\n+  params,\n+}: {\n+  params: Promise<{ slug: string }>\n+}) {\n+  const { slug } = await params\n+  const post = await getPost(slug)\n+  return <Article post={post} />\n+}\n+\n+// app/api/revalidate/route.ts\n+import { revalidatePath } from 'next/cache'\n+\n+export async function POST(request: Request) {\n+  const { slug } = await request.json()\n+  revalidatePath(`/blog/${slug}`)\n+  return Response.json({ revalidated: true })\n+}\n+```\n+\n+**Key improvements:**\n+\n+- Cache configuration co-located with data fetching via `'use cache'`\n+- Explicit cache tags enable targeted invalidation\n+- Route Handler pattern preserved for external webhook integration\n+\n+---\n+\n+## Runtime Behaviors\n+\n+### Draft Mode\n+\n+When [Draft Mode](https://nextjs.org/docs/app/building-your-application/configuring/draft-mode) is enabled, cache entries are **not saved**:\n+\n+```tsx\n+import { draftMode } from 'next/headers'\n+\n+export default async function PreviewPage() {\n+  const { isEnabled } = await draftMode()\n+\n+  // When isEnabled is true:\n+  // - 'use cache' functions still execute\n+  // - But results are NOT stored in cache\n+  // - Ensures preview content is always fresh\n+}\n+```\n+\n+This prevents stale preview content from being cached and served to production users.\n+\n+### Cache Bypass Conditions\n+\n+Cache is bypassed (not read from) when:\n+\n+| Condition              | Description                                        |\n+| ---------------------- | -------------------------------------------------- |\n+| Draft Mode enabled     | `draftMode().isEnabled === true`                   |\n+| On-demand revalidation | `revalidateTag()` or `revalidatePath()` was called |\n+| Dev mode + no-cache    | Request includes `Cache-Control: no-cache` header  |\n+\n+### Prerender Timeout\n+\n+During static prerendering (build time), cached functions have a **50-second timeout**:\n+\n+- If a cached function doesn't complete within 50 seconds, it becomes a dynamic hole\n+- At request time, there is **no timeout** - background revalidation can take as long as needed\n+- Timeout errors throw `UseCacheTimeoutError` with code `'USE_CACHE_TIMEOUT'`\n+\n+```tsx\n+// If this takes >50s during build, it becomes dynamic\n+async function SlowData() {\n+  'use cache'\n+  return await verySlowApiCall() // May timeout during prerender\n+}\n+```\n+\n+### Development Mode: HMR Cache Invalidation\n+\n+In development, cache keys include an **HMR refresh hash**:\n+\n+- When you edit a file containing a cached function, the cache automatically invalidates\n+- No manual cache clearing needed during development\n+- This hash is not included in production builds\n+\n+### Cache Propagation (Nested Caches)\n+\n+When cached functions call other cached functions, cache metadata propagates **upward**:\n+\n+```tsx\n+async function Inner() {\n+  'use cache'\n+  cacheLife('seconds') // expire=60\n+  cacheTag('inner')\n+  return await fetchData()\n+}\n+\n+async function Outer() {\n+  'use cache'\n+  cacheLife('hours') // expire=86400\n+  cacheTag('outer')\n+\n+  const data = await Inner() // Calls inner cached function\n+  return process(data)\n+}\n+\n+// Outer's effective cache:\n+// - expire = min(86400, 60) = 60 (inherits Inner's shorter expiration)\n+// - tags = ['outer', 'inner'] (tags merge)\n+```\n+\n+This ensures parent caches don't outlive their dependencies.\n+\n+---\n+\n+## Type Definitions\n+\n+### CacheLife\n+\n+```typescript\n+type CacheLife = {\n+  stale?: number // Default: 300 (from staleTimes.static)\n+  revalidate?: number // Default: profile-dependent\n+  expire?: number // Default: profile-dependent\n+}\n+```\n+\n+### CacheLifeProfile\n+\n+```typescript\n+type CacheLifeProfile =\n+  | 'default'\n+  | 'seconds'\n+  | 'minutes'\n+  | 'hours'\n+  | 'days'\n+  | 'weeks'\n+  | 'max'\n+  | string // Custom profiles\n+```"
        },
        {
            "sha": "cc59337ab083ca6699a6ce46f25115e11739fadc",
            "filename": ".claude-plugin/plugins/cache-components/skills/cache-components/SKILL.md",
            "status": "added",
            "additions": 467,
            "deletions": 0,
            "changes": 467,
            "blob_url": "https://github.com/vercel/next.js/blob/b9edb9175e15b433122afb114cbec6a2951d7d02/.claude-plugin%2Fplugins%2Fcache-components%2Fskills%2Fcache-components%2FSKILL.md",
            "raw_url": "https://github.com/vercel/next.js/raw/b9edb9175e15b433122afb114cbec6a2951d7d02/.claude-plugin%2Fplugins%2Fcache-components%2Fskills%2Fcache-components%2FSKILL.md",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/.claude-plugin%2Fplugins%2Fcache-components%2Fskills%2Fcache-components%2FSKILL.md?ref=b9edb9175e15b433122afb114cbec6a2951d7d02",
            "patch": "@@ -0,0 +1,467 @@\n+---\n+name: cache-components\n+description: |\n+  Expert guidance for Next.js Cache Components and Partial Prerendering (PPR).\n+\n+  **PROACTIVE ACTIVATION**: Use this skill automatically when working in Next.js projects that have `cacheComponents: true` in their next.config.ts/next.config.js. When this config is detected, proactively apply Cache Components patterns and best practices to all React Server Component implementations.\n+\n+  **DETECTION**: At the start of a session in a Next.js project, check for `cacheComponents: true` in next.config. If enabled, this skill's patterns should guide all component authoring, data fetching, and caching decisions.\n+\n+  **USE CASES**: Implementing 'use cache' directive, configuring cache lifetimes with cacheLife(), tagging cached data with cacheTag(), invalidating caches with updateTag()/revalidateTag(), optimizing static vs dynamic content boundaries, debugging cache issues, and reviewing Cache Component implementations.\n+---\n+\n+# Next.js Cache Components\n+\n+> **Auto-activation**: This skill activates automatically in projects with `cacheComponents: true` in next.config.\n+\n+## Project Detection\n+\n+When starting work in a Next.js project, check if Cache Components are enabled:\n+\n+```bash\n+# Check next.config.ts or next.config.js for cacheComponents\n+grep -r \"cacheComponents\" next.config.* 2>/dev/null\n+```\n+\n+If `cacheComponents: true` is found, apply this skill's patterns proactively when:\n+\n+- Writing React Server Components\n+- Implementing data fetching\n+- Creating Server Actions with mutations\n+- Optimizing page performance\n+- Reviewing existing component code\n+\n+Cache Components enable **Partial Prerendering (PPR)** - mixing static HTML shells with dynamic streaming content for optimal performance.\n+\n+## Philosophy: Code Over Configuration\n+\n+Cache Components represents a shift from **segment configuration** to **compositional code**:\n+\n+| Before (Deprecated)                     | After (Cache Components)                  |\n+| --------------------------------------- | ----------------------------------------- |\n+| `export const revalidate = 3600`        | `cacheLife('hours')` inside `'use cache'` |\n+| `export const dynamic = 'force-static'` | Use `'use cache'` and Suspense boundaries |\n+| All-or-nothing static/dynamic           | Granular: static shell + cached + dynamic |\n+\n+**Key Principle**: Components co-locate their caching, not just their data. Next.js provides build-time feedback to guide you toward optimal patterns.\n+\n+## Core Concept\n+\n+```\n+┌─────────────────────────────────────────────────────┐\n+│                   Static Shell                       │\n+│  (Sent immediately to browser)                       │\n+│                                                      │\n+│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  │\n+│  │   Header    │  │  Cached     │  │  Suspense   │  │\n+│  │  (static)   │  │  Content    │  │  Fallback   │  │\n+│  └─────────────┘  └─────────────┘  └──────┬──────┘  │\n+│                                           │         │\n+│                                    ┌──────▼──────┐  │\n+│                                    │  Dynamic    │  │\n+│                                    │  (streams)  │  │\n+│                                    └─────────────┘  │\n+└─────────────────────────────────────────────────────┘\n+```\n+\n+## Mental Model: The Caching Decision Tree\n+\n+When writing a React Server Component, ask these questions in order:\n+\n+```\n+┌─────────────────────────────────────────────────────────┐\n+│ Does this component fetch data or perform I/O?          │\n+└─────────────────────┬───────────────────────────────────┘\n+                      │\n+           ┌──────────▼──────────┐\n+           │   YES               │ NO → Pure component, no action needed\n+           └──────────┬──────────┘\n+                      │\n+    ┌─────────────────▼─────────────────┐\n+    │ Does it depend on request context? │\n+    │ (cookies, headers, searchParams)   │\n+    └─────────────────┬─────────────────┘\n+                      │\n+         ┌────────────┴────────────┐\n+         │                         │\n+    ┌────▼────┐              ┌─────▼─────┐\n+    │   YES   │              │    NO     │\n+    └────┬────┘              └─────┬─────┘\n+         │                         │\n+         │                   ┌─────▼─────────────────┐\n+         │                   │ Can this be cached?   │\n+         │                   │ (same for all users?) │\n+         │                   └─────┬─────────────────┘\n+         │                         │\n+         │              ┌──────────┴──────────┐\n+         │              │                     │\n+         │         ┌────▼────┐          ┌─────▼─────┐\n+         │         │   YES   │          │    NO     │\n+         │         └────┬────┘          └─────┬─────┘\n+         │              │                     │\n+         │              ▼                     │\n+         │         'use cache'                │\n+         │         + cacheTag()               │\n+         │         + cacheLife()              │\n+         │                                    │\n+         └──────────────┬─────────────────────┘\n+                        │\n+                        ▼\n+              Wrap in <Suspense>\n+              (dynamic streaming)\n+```\n+\n+**Key insight**: The `'use cache'` directive is for data that's the _same across users_. User-specific data stays dynamic with Suspense.\n+\n+## Quick Start\n+\n+### Enable Cache Components\n+\n+```typescript\n+// next.config.ts\n+import type { NextConfig } from 'next'\n+\n+const nextConfig: NextConfig = {\n+  cacheComponents: true,\n+}\n+\n+export default nextConfig\n+```\n+\n+### Basic Usage\n+\n+```tsx\n+// Cached component - output included in static shell\n+async function CachedPosts() {\n+  'use cache'\n+  const posts = await db.posts.findMany()\n+  return <PostList posts={posts} />\n+}\n+\n+// Page with static + cached + dynamic content\n+export default async function BlogPage() {\n+  return (\n+    <>\n+      <Header /> {/* Static */}\n+      <CachedPosts /> {/* Cached */}\n+      <Suspense fallback={<Skeleton />}>\n+        <DynamicComments /> {/* Dynamic - streams */}\n+      </Suspense>\n+    </>\n+  )\n+}\n+```\n+\n+## Core APIs\n+\n+### 1. `'use cache'` Directive\n+\n+Marks code as cacheable. Can be applied at three levels:\n+\n+```tsx\n+// File-level: All exports are cached\n+'use cache'\n+export async function getData() {\n+  /* ... */\n+}\n+export async function Component() {\n+  /* ... */\n+}\n+\n+// Component-level\n+async function UserCard({ id }: { id: string }) {\n+  'use cache'\n+  const user = await fetchUser(id)\n+  return <Card>{user.name}</Card>\n+}\n+\n+// Function-level\n+async function fetchWithCache(url: string) {\n+  'use cache'\n+  return fetch(url).then((r) => r.json())\n+}\n+```\n+\n+**Important**: All cached functions must be `async`.\n+\n+### 2. `cacheLife()` - Control Cache Duration\n+\n+```tsx\n+import { cacheLife } from 'next/cache'\n+\n+async function Posts() {\n+  'use cache'\n+  cacheLife('hours') // Use a predefined profile\n+\n+  // Or custom configuration:\n+  cacheLife({\n+    stale: 60, // 1 min - client cache validity\n+    revalidate: 3600, // 1 hr - start background refresh\n+    expire: 86400, // 1 day - absolute expiration\n+  })\n+\n+  return await db.posts.findMany()\n+}\n+```\n+\n+**Predefined profiles**: `'default'`, `'seconds'`, `'minutes'`, `'hours'`, `'days'`, `'weeks'`, `'max'`\n+\n+### 3. `cacheTag()` - Tag for Invalidation\n+\n+```tsx\n+import { cacheTag } from 'next/cache'\n+\n+async function BlogPosts() {\n+  'use cache'\n+  cacheTag('posts')\n+  cacheLife('days')\n+\n+  return await db.posts.findMany()\n+}\n+\n+async function UserProfile({ userId }: { userId: string }) {\n+  'use cache'\n+  cacheTag('users', `user-${userId}`) // Multiple tags\n+\n+  return await db.users.findUnique({ where: { id: userId } })\n+}\n+```\n+\n+### 4. `updateTag()` - Immediate Invalidation\n+\n+For **read-your-own-writes** semantics:\n+\n+```tsx\n+'use server'\n+import { updateTag } from 'next/cache'\n+\n+export async function createPost(formData: FormData) {\n+  await db.posts.create({ data: formData })\n+\n+  updateTag('posts') // Client immediately sees fresh data\n+}\n+```\n+\n+### 5. `revalidateTag()` - Background Revalidation\n+\n+For stale-while-revalidate pattern:\n+\n+```tsx\n+'use server'\n+import { revalidateTag } from 'next/cache'\n+\n+export async function updatePost(id: string, data: FormData) {\n+  await db.posts.update({ where: { id }, data })\n+\n+  revalidateTag('posts', 'max') // Serve stale, refresh in background\n+}\n+```\n+\n+## When to Use Each Pattern\n+\n+| Content Type | API                 | Behavior                              |\n+| ------------ | ------------------- | ------------------------------------- |\n+| **Static**   | No directive        | Rendered at build time                |\n+| **Cached**   | `'use cache'`       | Included in static shell, revalidates |\n+| **Dynamic**  | Inside `<Suspense>` | Streams at request time               |\n+\n+## Parameter Permutations & Subshells\n+\n+**Critical Concept**: With Cache Components, Next.js renders ALL permutations of provided parameters to create reusable subshells.\n+\n+```tsx\n+// app/products/[category]/[slug]/page.tsx\n+export async function generateStaticParams() {\n+  return [\n+    { category: 'jackets', slug: 'classic-bomber' },\n+    { category: 'jackets', slug: 'essential-windbreaker' },\n+    { category: 'accessories', slug: 'thermal-fleece-gloves' },\n+  ]\n+}\n+```\n+\n+Next.js renders these routes:\n+\n+```\n+/products/jackets/classic-bomber        ← Full params (complete page)\n+/products/jackets/essential-windbreaker ← Full params (complete page)\n+/products/accessories/thermal-fleece-gloves ← Full params (complete page)\n+/products/jackets/[slug]                ← Partial params (category subshell)\n+/products/accessories/[slug]            ← Partial params (category subshell)\n+/products/[category]/[slug]             ← No params (fallback shell)\n+```\n+\n+**Why this matters**: The category subshell (`/products/jackets/[slug]`) can be reused for ANY jacket product, even ones not in `generateStaticParams`. Users navigating to an unlisted jacket get the cached category shell immediately, with product details streaming in.\n+\n+### `generateStaticParams` Requirements\n+\n+With Cache Components enabled:\n+\n+1. **Must provide at least one parameter** - Empty arrays now cause build errors (prevents silent production failures)\n+2. **Params prove static safety** - Providing params lets Next.js verify no dynamic APIs are called\n+3. **Partial params create subshells** - Each unique permutation generates a reusable shell\n+\n+```tsx\n+// ❌ ERROR with Cache Components\n+export function generateStaticParams() {\n+  return [] // Build error: must provide at least one param\n+}\n+\n+// ✅ CORRECT: Provide real params\n+export async function generateStaticParams() {\n+  const products = await getPopularProducts()\n+  return products.map(({ category, slug }) => ({ category, slug }))\n+}\n+```\n+\n+## Cache Key = Arguments\n+\n+Arguments become part of the cache key:\n+\n+```tsx\n+// Different userId = different cache entry\n+async function UserData({ userId }: { userId: string }) {\n+  'use cache'\n+  cacheTag(`user-${userId}`)\n+\n+  return await fetchUser(userId)\n+}\n+```\n+\n+## Build-Time Feedback\n+\n+Cache Components provides early feedback during development. These build errors **guide you toward optimal patterns**:\n+\n+### Error: Dynamic data outside Suspense\n+\n+```\n+Error: Accessing cookies/headers/searchParams outside a Suspense boundary\n+```\n+\n+**Solution**: Wrap dynamic components in `<Suspense>`:\n+\n+```tsx\n+<Suspense fallback={<Skeleton />}>\n+  <ComponentThatUsesCookies />\n+</Suspense>\n+```\n+\n+### Error: Uncached data outside Suspense\n+\n+```\n+Error: Accessing uncached data outside Suspense\n+```\n+\n+**Solution**: Either cache the data or wrap in Suspense:\n+\n+```tsx\n+// Option 1: Cache it\n+async function ProductData({ id }: { id: string }) {\n+  'use cache'\n+  return await db.products.findUnique({ where: { id } })\n+}\n+\n+// Option 2: Make it dynamic with Suspense\n+;<Suspense fallback={<Loading />}>\n+  <DynamicProductData id={id} />\n+</Suspense>\n+```\n+\n+### Error: Request data inside cache\n+\n+```\n+Error: Cannot access cookies/headers inside 'use cache'\n+```\n+\n+**Solution**: Extract runtime data outside cache boundary (see \"Handling Runtime Data\" above).\n+\n+## Additional Resources\n+\n+- For complete API reference, see [REFERENCE.md](REFERENCE.md)\n+- For common patterns and recipes, see [PATTERNS.md](PATTERNS.md)\n+- For debugging and troubleshooting, see [TROUBLESHOOTING.md](TROUBLESHOOTING.md)\n+\n+## Code Generation Guidelines\n+\n+When generating Cache Component code:\n+\n+1. **Always use `async`** - All cached functions must be async\n+2. **Place `'use cache'` first** - Must be first statement in function body\n+3. **Call `cacheLife()` early** - Should follow `'use cache'` directive\n+4. **Tag meaningfully** - Use semantic tags that match your invalidation needs\n+5. **Extract runtime data** - Move `cookies()`/`headers()` outside cached scope\n+6. **Wrap dynamic content** - Use `<Suspense>` for non-cached async components\n+\n+---\n+\n+## Proactive Application (When Cache Components Enabled)\n+\n+When `cacheComponents: true` is detected in the project, **automatically apply these patterns**:\n+\n+### When Writing Data Fetching Components\n+\n+Ask yourself: \"Can this data be cached?\" If yes, add `'use cache'`:\n+\n+```tsx\n+// Before: Uncached fetch\n+async function ProductList() {\n+  const products = await db.products.findMany()\n+  return <Grid products={products} />\n+}\n+\n+// After: With caching\n+async function ProductList() {\n+  'use cache'\n+  cacheTag('products')\n+  cacheLife('hours')\n+\n+  const products = await db.products.findMany()\n+  return <Grid products={products} />\n+}\n+```\n+\n+### When Writing Server Actions\n+\n+Always invalidate relevant caches after mutations:\n+\n+```tsx\n+'use server'\n+import { updateTag } from 'next/cache'\n+\n+export async function createProduct(data: FormData) {\n+  await db.products.create({ data })\n+  updateTag('products') // Don't forget!\n+}\n+```\n+\n+### When Composing Pages\n+\n+Structure with static shell + cached content + dynamic streaming:\n+\n+```tsx\n+export default async function Page() {\n+  return (\n+    <>\n+      <StaticHeader /> {/* No cache needed */}\n+      <CachedContent /> {/* 'use cache' */}\n+      <Suspense fallback={<Skeleton />}>\n+        <DynamicUserContent /> {/* Streams at runtime */}\n+      </Suspense>\n+    </>\n+  )\n+}\n+```\n+\n+### When Reviewing Code\n+\n+Flag these issues in Cache Components projects:\n+\n+- [ ] Data fetching without `'use cache'` where caching would benefit\n+- [ ] Missing `cacheTag()` calls (makes invalidation impossible)\n+- [ ] Missing `cacheLife()` (relies on defaults which may not be appropriate)\n+- [ ] Server Actions without `updateTag()`/`revalidateTag()` after mutations\n+- [ ] `cookies()`/`headers()` called inside `'use cache'` scope\n+- [ ] Dynamic components without `<Suspense>` boundaries\n+- [ ] **DEPRECATED**: `export const revalidate` - replace with `cacheLife()` in `'use cache'`\n+- [ ] **DEPRECATED**: `export const dynamic` - replace with Suspense + cache boundaries\n+- [ ] Empty `generateStaticParams()` return - must provide at least one param"
        },
        {
            "sha": "2cd9b5a26bd23451b5c38383d6a1a6c029a857af",
            "filename": ".claude-plugin/plugins/cache-components/skills/cache-components/TROUBLESHOOTING.md",
            "status": "added",
            "additions": 719,
            "deletions": 0,
            "changes": 719,
            "blob_url": "https://github.com/vercel/next.js/blob/b9edb9175e15b433122afb114cbec6a2951d7d02/.claude-plugin%2Fplugins%2Fcache-components%2Fskills%2Fcache-components%2FTROUBLESHOOTING.md",
            "raw_url": "https://github.com/vercel/next.js/raw/b9edb9175e15b433122afb114cbec6a2951d7d02/.claude-plugin%2Fplugins%2Fcache-components%2Fskills%2Fcache-components%2FTROUBLESHOOTING.md",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/.claude-plugin%2Fplugins%2Fcache-components%2Fskills%2Fcache-components%2FTROUBLESHOOTING.md?ref=b9edb9175e15b433122afb114cbec6a2951d7d02",
            "patch": "@@ -0,0 +1,719 @@\n+# Cache Components Troubleshooting\n+\n+Common issues, debugging techniques, and solutions for Cache Components.\n+\n+## Build-Time Feedback Philosophy\n+\n+Cache Components introduces **early feedback** during development. Unlike before where errors might only appear in production, Cache Components produces build errors that **guide you toward optimal patterns**.\n+\n+Key principle: **If it builds, it's correct.** The build process validates that:\n+\n+- Dynamic data isn't accessed outside Suspense boundaries\n+- Cached data doesn't depend on request-specific APIs\n+- `generateStaticParams` provides valid parameters to test rendering\n+\n+---\n+\n+## Quick Debugging Checklist\n+\n+Copy this checklist when debugging cache issues:\n+\n+### Cache Not Working\n+\n+- [ ] `cacheComponents: true` in next.config?\n+- [ ] Function is `async`?\n+- [ ] `'use cache'` is FIRST statement in function body?\n+- [ ] All arguments are serializable (no functions, class instances)?\n+- [ ] Not accessing `cookies()`/`headers()` inside cache?\n+\n+### Stale Data After Mutation\n+\n+- [ ] Called `updateTag()` or `revalidateTag()` after mutation?\n+- [ ] Tag in invalidation matches tag in `cacheTag()`?\n+- [ ] Using `updateTag()` (not `revalidateTag()`) for immediate updates?\n+\n+### Build Errors\n+\n+- [ ] Dynamic data wrapped in `<Suspense>`?\n+- [ ] `generateStaticParams` returns at least one param?\n+- [ ] Not mixing `'use cache'` with `cookies()`/`headers()`?\n+\n+### Performance Issues\n+\n+- [ ] Cache granularity appropriate? (not too coarse/fine)\n+- [ ] `cacheLife` set appropriately for data volatility?\n+- [ ] Using hierarchical tags for targeted invalidation?\n+\n+---\n+\n+## Error: UseCacheTimeoutError\n+\n+### Symptoms\n+\n+```\n+Error: A component used 'use cache' but didn't complete within 50 seconds.\n+```\n+\n+### Cause\n+\n+The cached function is accessing request-specific data (cookies, headers, searchParams) or making requests that depend on runtime context.\n+\n+### Solution\n+\n+User-specific content that depends on runtime data (cookies, headers, searchParams) should **not be cached**. Instead, stream it dynamically:\n+\n+```tsx\n+// ❌ WRONG: Trying to cache user-specific content\n+async function UserContent() {\n+  'use cache'\n+  const session = await cookies() // Causes timeout!\n+  return await fetchContent(session.userId)\n+}\n+\n+// ✅ CORRECT: Don't cache user-specific content, stream it instead\n+async function UserContent() {\n+  const session = await cookies()\n+  return await fetchContent(session.get('userId')?.value)\n+}\n+\n+export default function Page() {\n+  return (\n+    <Suspense fallback={<Loading />}>\n+      <UserContent /> {/* No 'use cache' - streams dynamically */}\n+    </Suspense>\n+  )\n+}\n+```\n+\n+**Key insight**: Cache Components are for content that can be shared across users (e.g., product details, blog posts). User-specific content should stream at request time.\n+\n+---\n+\n+## Error: Cannot use 'use cache' with sync function\n+\n+### Symptoms\n+\n+```\n+Error: 'use cache' can only be used in async functions\n+```\n+\n+### Cause\n+\n+Cache Components require async functions because cached outputs are streamed.\n+\n+### Solution\n+\n+```tsx\n+// ❌ WRONG: Synchronous function\n+function CachedComponent() {\n+  'use cache'\n+  return <div>Hello</div>\n+}\n+\n+// ✅ CORRECT: Async function\n+async function CachedComponent() {\n+  'use cache'\n+  return <div>Hello</div>\n+}\n+```\n+\n+---\n+\n+## Error: Dynamic Data Outside Suspense\n+\n+### Symptoms\n+\n+```\n+Error: Accessing cookies/headers/searchParams outside a Suspense boundary\n+```\n+\n+### Cause\n+\n+With Cache Components, accessing request-specific APIs (cookies, headers, searchParams, connection) requires a Suspense boundary so Next.js can provide a static fallback.\n+\n+### Why This Changed\n+\n+**Before Cache Components**: The page silently became fully dynamic - no static content served.\n+\n+**After Cache Components**: Build error ensures you explicitly handle the dynamic boundary.\n+\n+### Solution\n+\n+Wrap dynamic content in Suspense:\n+\n+```tsx\n+// ❌ ERROR: No Suspense boundary\n+export default async function Page() {\n+  return (\n+    <>\n+      <Header />\n+      <UserDeals /> {/* Uses cookies() */}\n+    </>\n+  )\n+}\n+\n+// ✅ CORRECT: Suspense provides static fallback\n+export default async function Page() {\n+  return (\n+    <>\n+      <Header />\n+      <Suspense fallback={<DealsSkeleton />}>\n+        <UserDeals />\n+      </Suspense>\n+    </>\n+  )\n+}\n+```\n+\n+> **See also**: Pattern 1 (Static + Cached + Dynamic Page) in PATTERNS.md shows the foundational Suspense boundary pattern.\n+\n+---\n+\n+## Error: Uncached Data Outside Suspense\n+\n+### Symptoms\n+\n+```\n+Error: Accessing uncached data outside Suspense\n+```\n+\n+### Cause\n+\n+With Cache Components, ALL **async** I/O is considered dynamic by default. Database queries, fetch calls, and file reads must either be cached or wrapped in Suspense.\n+\n+> **Note on synchronous databases**: Libraries with synchronous APIs (e.g., `better-sqlite3`) don't trigger this error because they don't involve async I/O. Synchronous operations complete during render and are included in the static shell. However, this also means they block the render thread - use judiciously for small, fast queries only.\n+\n+### Solution\n+\n+Either cache the data or wrap in Suspense:\n+\n+```tsx\n+// ❌ ERROR: Uncached database query without Suspense\n+export default async function ProductPage({ params }) {\n+  const product = await db.products.findUnique({ where: { id: params.id } })\n+  return <ProductCard product={product} />\n+}\n+\n+// ✅ OPTION 1: Cache the data\n+async function getProduct(id: string) {\n+  'use cache'\n+  cacheTag(`product-${id}`)\n+  cacheLife('hours')\n+\n+  return await db.products.findUnique({ where: { id } })\n+}\n+\n+export default async function ProductPage({ params }) {\n+  const product = await getProduct(params.id)\n+  return <ProductCard product={product} />\n+}\n+\n+// ✅ OPTION 2: Wrap in Suspense (streams dynamically)\n+export default async function ProductPage({ params }) {\n+  return (\n+    <Suspense fallback={<ProductSkeleton />}>\n+      <ProductContent id={params.id} />\n+    </Suspense>\n+  )\n+}\n+```\n+\n+> **See also**: Pattern 5 (Cached Data Fetching Functions) in PATTERNS.md shows reusable cached data fetcher patterns.\n+\n+---\n+\n+## Error: Empty generateStaticParams\n+\n+### Symptoms\n+\n+```\n+Error: generateStaticParams must return at least one parameter set\n+```\n+\n+### Cause\n+\n+With Cache Components, empty `generateStaticParams` is no longer allowed. This prevents a class of bugs where dynamic API usage in components would only error in production.\n+\n+### Why This Changed\n+\n+**Before**: Empty array = \"trust me, this is static\". Dynamic API usage in production caused runtime errors.\n+\n+**After**: Must provide at least one param set so Next.js can validate the page actually renders statically.\n+\n+### Solution\n+\n+```tsx\n+// ❌ ERROR: Empty array\n+export function generateStaticParams() {\n+  return []\n+}\n+\n+// ✅ CORRECT: Provide at least one param\n+export async function generateStaticParams() {\n+  const products = await getPopularProducts()\n+  return products.map(({ category, slug }) => ({ category, slug }))\n+}\n+\n+// ✅ ALSO CORRECT: Hardcoded for known routes\n+export function generateStaticParams() {\n+  return [{ slug: 'about' }, { slug: 'contact' }, { slug: 'pricing' }]\n+}\n+```\n+\n+---\n+\n+## Error: Request Data Inside Cache\n+\n+### Symptoms\n+\n+```\n+Error: Cannot access cookies/headers inside 'use cache'\n+```\n+\n+### Cause\n+\n+Cache contexts cannot depend on request-specific data because the cached result would be shared across all users.\n+\n+### Solution\n+\n+User-specific content should **not be cached**. Remove `'use cache'` and stream the content dynamically:\n+\n+```tsx\n+// ❌ ERROR: Cookies inside cache\n+async function UserDashboard() {\n+  'use cache'\n+  const session = await cookies() // Error!\n+  return await fetchDashboard(session.get('userId'))\n+}\n+\n+// ✅ CORRECT: Don't cache user-specific content\n+async function UserDashboard() {\n+  const session = await cookies()\n+  return await fetchDashboard(session.get('userId')?.value)\n+}\n+\n+export default function Page() {\n+  return (\n+    <Suspense fallback={<DashboardSkeleton />}>\n+      <UserDashboard /> {/* Streams at request time */}\n+    </Suspense>\n+  )\n+}\n+```\n+\n+**Key insight**: Cache Components are for content that can be shared across users. User-specific dashboards should stream dynamically.\n+\n+---\n+\n+## Issue: Cache Not Being Used\n+\n+### Symptoms\n+\n+- Data always fresh on every request\n+- No caching behavior observed\n+- Build logs don't show cached routes\n+\n+### Checklist\n+\n+**1. Is `cacheComponents` enabled?**\n+\n+```typescript\n+// next.config.ts\n+const nextConfig: NextConfig = {\n+  cacheComponents: true, // Required!\n+}\n+```\n+\n+**2. Is the function async?**\n+\n+```tsx\n+// Must be async\n+async function CachedData() {\n+  'use cache'\n+  return await fetchData()\n+}\n+```\n+\n+**3. Is `'use cache'` the first statement?**\n+\n+```tsx\n+// ❌ WRONG: Directive not first\n+async function CachedData() {\n+  const x = 1 // Something before 'use cache'\n+  ;('use cache')\n+  return await fetchData()\n+}\n+\n+// ✅ CORRECT: Directive first\n+async function CachedData() {\n+  'use cache'\n+  const x = 1\n+  return await fetchData()\n+}\n+```\n+\n+**4. Are arguments serializable?**\n+\n+```tsx\n+// ❌ WRONG: Function as argument (not serializable)\n+async function CachedData({ transform }: { transform: (x: any) => any }) {\n+  'use cache'\n+  const data = await fetchData()\n+  return transform(data)\n+}\n+\n+// ✅ CORRECT: Only serializable arguments\n+async function CachedData({ transformType }: { transformType: string }) {\n+  'use cache'\n+  const data = await fetchData()\n+  return applyTransform(data, transformType)\n+}\n+```\n+\n+---\n+\n+## Issue: Stale Data After Mutation\n+\n+### Symptoms\n+\n+- Created/updated data doesn't appear immediately\n+- Need to refresh page to see changes\n+\n+### Cause\n+\n+Cache not invalidated after mutation.\n+\n+### Solutions\n+\n+**1. Use `updateTag()` for immediate consistency:**\n+\n+```tsx\n+'use server'\n+import { updateTag } from 'next/cache'\n+\n+export async function createPost(data: FormData) {\n+  await db.posts.create({ data })\n+  updateTag('posts') // Immediate invalidation\n+}\n+```\n+\n+**2. Ensure tags match:**\n+\n+```tsx\n+// Cache uses this tag\n+async function Posts() {\n+  'use cache'\n+  cacheTag('posts') // Must match invalidation tag\n+  return await db.posts.findMany()\n+}\n+\n+// Invalidation must use same tag\n+export async function createPost(data: FormData) {\n+  await db.posts.create({ data })\n+  updateTag('posts') // Same tag!\n+}\n+```\n+\n+**3. Invalidate all relevant tags:**\n+\n+```tsx\n+export async function updatePost(postId: string, data: FormData) {\n+  const post = await db.posts.update({\n+    where: { id: postId },\n+    data,\n+  })\n+\n+  // Invalidate all affected caches\n+  updateTag('posts') // All posts list\n+  updateTag(`post-${postId}`) // Specific post\n+  updateTag(`author-${post.authorId}`) // Author's posts\n+}\n+```\n+\n+---\n+\n+## Issue: Different Cache Values for Same Key\n+\n+### Symptoms\n+\n+- Cache returns different values for what should be the same query\n+- Inconsistent behavior across requests\n+\n+### Cause\n+\n+Arguments are part of cache key. Different argument values = different cache entries.\n+\n+### Solution\n+\n+Normalize arguments:\n+\n+```tsx\n+// ❌ Problem: Object reference differs\n+async function CachedData({ options }: { options: { limit: number } }) {\n+  'use cache'\n+  return await fetchData(options)\n+}\n+\n+// Each call creates new object = new cache key\n+<CachedData options={{ limit: 10 }} />\n+<CachedData options={{ limit: 10 }} /> // Different cache entry!\n+\n+// ✅ Solution: Use primitives or stable references\n+async function CachedData({ limit }: { limit: number }) {\n+  'use cache'\n+  return await fetchData({ limit })\n+}\n+\n+<CachedData limit={10} />\n+<CachedData limit={10} /> // Same cache entry!\n+```\n+\n+---\n+\n+## Issue: Cache Too Aggressive (Stale Data)\n+\n+### Symptoms\n+\n+- Data doesn't update when expected\n+- Users see outdated content\n+\n+### Solutions\n+\n+**1. Reduce cache lifetime:**\n+\n+```tsx\n+async function FrequentlyUpdatedData() {\n+  'use cache'\n+  cacheLife('seconds') // Short cache\n+\n+  // Or custom short duration\n+  cacheLife({\n+    stale: 0,\n+    revalidate: 30,\n+    expire: 60,\n+  })\n+\n+  return await fetchData()\n+}\n+```\n+\n+**2. Don't cache volatile data:**\n+\n+```tsx\n+// For truly real-time data, skip caching\n+async function LiveData() {\n+  // No 'use cache'\n+  return await fetchLiveData()\n+}\n+\n+export default function Page() {\n+  return (\n+    <Suspense fallback={<Loading />}>\n+      <LiveData />\n+    </Suspense>\n+  )\n+}\n+```\n+\n+---\n+\n+## Issue: Build Takes Too Long\n+\n+### Symptoms\n+\n+- Build hangs during prerendering\n+- Timeout errors during `next build`\n+\n+### Cause\n+\n+Cached functions making slow network requests or accessing unavailable services during build.\n+\n+### Solutions\n+\n+**1. Use fallback data for build:**\n+\n+```tsx\n+async function CachedData() {\n+  'use cache'\n+\n+  try {\n+    return await fetchFromAPI()\n+  } catch (error) {\n+    // Return fallback during build if API unavailable\n+    return getFallbackData()\n+  }\n+}\n+```\n+\n+**2. Limit static generation scope:**\n+\n+```tsx\n+// app/[slug]/page.tsx\n+export function generateStaticParams() {\n+  // Only prerender most important pages at build time\n+  // Other pages will be generated on-demand at request time\n+  return [{ slug: 'home' }, { slug: 'about' }]\n+}\n+```\n+\n+**3. Use Suspense for truly dynamic content:**\n+\n+```tsx\n+// app/[slug]/page.tsx\n+import { Suspense } from 'react'\n+\n+export default function Page({\n+  params,\n+}: {\n+  params: Promise<{ slug: string }>\n+}) {\n+  return (\n+    <Suspense fallback={<PageSkeleton />}>\n+      <DynamicContent params={params} />\n+    </Suspense>\n+  )\n+}\n+```\n+\n+> **Note:** Avoid using `export const dynamic = 'force-dynamic'` as this segment config is deprecated with Cache Components. Use Suspense boundaries and `'use cache'` for granular control instead.\n+\n+---\n+\n+## Debugging Techniques\n+\n+### 1. Check Cache Headers\n+\n+In development, inspect response headers:\n+\n+```bash\n+curl -I http://localhost:3000/your-page\n+```\n+\n+Look for:\n+\n+- `x-nextjs-cache: HIT` - Served from cache\n+- `x-nextjs-cache: MISS` - Cache miss, recomputed\n+- `x-nextjs-cache: STALE` - Stale content, revalidating\n+\n+### 2. Enable Verbose Logging\n+\n+```bash\n+# Environment variable for cache debugging\n+NEXT_PRIVATE_DEBUG_CACHE=1 npm run dev\n+```\n+\n+### 3. Check Build Output\n+\n+```bash\n+npm run build\n+\n+# Look for:\n+# ○ (Static) - Fully static\n+# ◐ (Partial) - Partial prerender with cache\n+# λ (Dynamic) - Server-rendered\n+```\n+\n+### 4. Inspect Cache Tags\n+\n+Add logging to verify tags:\n+\n+```tsx\n+async function CachedData({ id }: { id: string }) {\n+  'use cache'\n+\n+  const tags = ['data', `item-${id}`]\n+  console.log('Cache tags:', tags) // Check during build\n+\n+  tags.forEach((tag) => cacheTag(tag))\n+  cacheLife('hours')\n+\n+  return await fetchData(id)\n+}\n+```\n+\n+---\n+\n+## Common Mistakes Checklist\n+\n+| Mistake                            | Symptom            | Fix                   |\n+| ---------------------------------- | ------------------ | --------------------- |\n+| Missing `cacheComponents: true`    | No caching         | Add to next.config.ts |\n+| Sync function with `'use cache'`   | Build error        | Make function async   |\n+| `'use cache'` not first statement  | Cache ignored      | Move to first line    |\n+| Accessing cookies/headers in cache | Timeout error      | Extract to wrapper    |\n+| Non-serializable arguments         | Inconsistent cache | Use primitives        |\n+| Missing Suspense for dynamic       | Streaming broken   | Wrap in Suspense      |\n+| Wrong tag in invalidation          | Stale data         | Match cache tags      |\n+| Over-caching volatile data         | Stale data         | Reduce cacheLife      |\n+\n+---\n+\n+## Performance Optimization Tips\n+\n+### 1. Profile Cache Hit Rates\n+\n+Monitor cache effectiveness:\n+\n+```tsx\n+async function CachedData() {\n+  'use cache'\n+\n+  const start = performance.now()\n+  const data = await fetchData()\n+  const duration = performance.now() - start\n+\n+  // Log for analysis\n+  console.log(`Cache execution: ${duration}ms`)\n+\n+  return data\n+}\n+```\n+\n+### 2. Optimize Cache Granularity\n+\n+```tsx\n+// ❌ Coarse: One big cached component\n+async function PageContent() {\n+  'use cache'\n+  const header = await fetchHeader()\n+  const posts = await fetchPosts()\n+  const sidebar = await fetchSidebar()\n+  return <>{/* everything */}</>\n+}\n+\n+// ✅ Fine-grained: Independent cached components\n+async function Header() {\n+  'use cache'\n+  cacheLife('days')\n+  return await fetchHeader()\n+}\n+\n+async function Posts() {\n+  'use cache'\n+  cacheLife('hours')\n+  return await fetchPosts()\n+}\n+\n+async function Sidebar() {\n+  'use cache'\n+  cacheLife('minutes')\n+  return await fetchSidebar()\n+}\n+```\n+\n+### 3. Strategic Tag Design\n+\n+```tsx\n+// Hierarchical tags for targeted invalidation\n+cacheTag(\n+  'posts', // All posts\n+  `category-${category}`, // Posts in category\n+  `post-${id}`, // Specific post\n+  `author-${authorId}` // Author's posts\n+)\n+\n+// Invalidate at appropriate level\n+updateTag(`post-${id}`) // Single post changed\n+updateTag(`author-${author}`) // Author updated all posts\n+updateTag('posts') // Nuclear option\n+```"
        },
        {
            "sha": "6e88cdbfd73ea021e47340712b70c30de24d2761",
            "filename": ".prettierignore",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/b9edb9175e15b433122afb114cbec6a2951d7d02/.prettierignore",
            "raw_url": "https://github.com/vercel/next.js/raw/b9edb9175e15b433122afb114cbec6a2951d7d02/.prettierignore",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/.prettierignore?ref=b9edb9175e15b433122afb114cbec6a2951d7d02",
            "patch": "@@ -20,6 +20,8 @@ packages/next/errors.json\n \n crates/**/tests/**/output*\n crates/core/tests/loader/issue-32553/input.js\n+# prettier destroys 'use server'/'use client' directives in multi-file code examples\n+.claude-plugin/**/*.md\n # prettier destroys the directives here\n crates/next-custom-transforms/tests/errors/react-server-components/client-graph/use-client/input.js\n crates/next-custom-transforms/tests/errors/react-server-components/server-graph/fake-client-entry/input.js"
        }
    ],
    "stats": {
        "total": 3387,
        "additions": 3387,
        "deletions": 0
    }
}