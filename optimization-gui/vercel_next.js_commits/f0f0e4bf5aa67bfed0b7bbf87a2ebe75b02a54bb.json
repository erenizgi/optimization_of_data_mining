{
    "author": "gnoff",
    "message": "[dynamicIO] Disallow only dynamic metadata (#78576)\n\nstacked on #78575 \n\nWhen I changed the dynamic validation rules to be based on the existence\nof a static shell I removed an important protection for apps that have\nstatic metadata. Now that metadata is implicitly rendered within a\nSuspense boundary it is always opted into allowing dynamic. For dynamic\nand partially static pages this is fine because we are going to be\ngenerating a response per request anyways. But if you have a fully\nstatic page and then later accidentally make your metadata dynamic your\npage will deopt to partially static without any warning.\n\nThis change reintroduces the heuristic where if the only dynamic thing\non the page is metadata the build errors. If there is at least one other\ndynamic thing on the page then dynamic metadata is allowed.\n\nA similar change is not necessary for viewport because that is never\nrendered in a Suspense boundary and the only way to have dynamic\nviewports is to opt the entire app into dynamic with a Suspense boundary\naround your root layout",
    "sha": "f0f0e4bf5aa67bfed0b7bbf87a2ebe75b02a54bb",
    "files": [
        {
            "sha": "eb94d010a8837940c220bc891fb8719253bd965e",
            "filename": "errors/next-prerender-dynamic-metadata.mdx",
            "status": "added",
            "additions": 151,
            "deletions": 0,
            "changes": 151,
            "blob_url": "https://github.com/vercel/next.js/blob/f0f0e4bf5aa67bfed0b7bbf87a2ebe75b02a54bb/errors%2Fnext-prerender-dynamic-metadata.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/f0f0e4bf5aa67bfed0b7bbf87a2ebe75b02a54bb/errors%2Fnext-prerender-dynamic-metadata.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/errors%2Fnext-prerender-dynamic-metadata.mdx?ref=f0f0e4bf5aa67bfed0b7bbf87a2ebe75b02a54bb",
            "patch": "@@ -0,0 +1,151 @@\n+---\n+title: Cannot access Request information or uncached data in `generateMetadata()` in an otherwise entirely static route\n+---\n+\n+## Why This Error Occurred\n+\n+When `dynamicIO` is enabled, Next.js requires that `generateMetadata()` not depend on uncached data or Request data unless some other part of the page also has similar requirements. The reason for this is that while you normally control your intention for what is allowed to be dynamic by adding or removing Suspense boundaries in your Layout and Page components you are not in control of rendering metadata itself.\n+\n+The heuristic Next.js uses to understand your intent with `generateMetadata()` is to look at the data requirements of the rest of the route. If other components depend on Request data or uncached data, then we allow `generateMetadata()` to have similar data requirements. If the rest of your page has no dependence on this type of data, we require that `generateMetadata()` also not have this type of data dependence.\n+\n+## Possible Ways to Fix It\n+\n+To fix this issue, you must first determine your goal for the affected route.\n+\n+### Caching External Data\n+\n+If your metadata does not depend on any request data, then it may be possible for you to indicate that the data is cacheable, which would allow Next.js to include it in the prerender for this route. Consider using `\"use cache\"` to mark the function producing the external data as cacheable.\n+\n+Before:\n+\n+```jsx filename=\"app/.../page.tsx\"\n+import { cms } from './cms'\n+\n+export async function generateMetadata() {\n+  // This data lookup is not cached at the moment so\n+  // Next.js will interpret this as needing to be rendered\n+  // on every request.\n+  const { title } = await cms.getPageData('/.../page')\n+  return {\n+    title,\n+  }\n+}\n+\n+async function getPageText() {\n+  'use cache'\n+  const { text } = await cms.getPageData('/.../page')\n+  return text\n+}\n+\n+export default async function Page() {\n+  // This text is cached so the main content of this route\n+  // is prerenderable.\n+  const text = await getPageText()\n+  return <article>{text}</article>\n+}\n+```\n+\n+After:\n+\n+```jsx filename=\"app/.../page.tsx\"\n+import { cms } from './cms'\n+\n+export async function generateMetadata() {\n+  // By marking this function as cacheable, Next.js\n+  // can now include it in the prerender for this route.\n+  'use cache'\n+  const { title } = await cms.getPageData('/.../page')\n+  return {\n+    title,\n+  }\n+}\n+\n+async function getPageText() {\n+  'use cache'\n+  const { text } = await cms.getPageData('/.../page')\n+  return text\n+}\n+\n+export default async function Page() {\n+  // This text is cached so the main content of this route\n+  // is prerenderable.\n+  const text = await getPageText()\n+  return <article>{text}</article>\n+}\n+```\n+\n+### If you must access Request Data or your external data is uncacheable\n+\n+If your metadata requires Request data or depends on external data which is not cacheable then Next.js will need to render this page dynamically on every request. However if you got this error, the rest of your page is able to be completely static. This is generally pretty rare, but if this is your actual constraint, you can indicate to Next.js that the page should be allowed to be dynamic by rendering any other component that is dynamic. Since your route doesn't have any genuine need for Request data, you can indicate an intentional dependency on a Request with `await connection()`. This is like telling Next.js that this component is never prerenderable and must be rendered on every user request.\n+\n+Before:\n+\n+```jsx filename=\"app/.../page.tsx\"\n+import { cookies } from 'next/headers'\n+import { getPersonalizedTitle } from './my-api'\n+\n+export async function generateMetadata() {\n+  // In this example, we are assuming we must fetch our title\n+  // from a protected external API. While the response is potentially\n+  // cacheable, the it still requires accessing a token from the Request cookies.\n+  const token = (await cookies()).get('token')\n+  const response = await getPersonalizedTitle(token)\n+  return {\n+    title: getTitle(response),\n+  }\n+}\n+\n+export default function Page() {\n+  return <article>This article is completely static</article>\n+}\n+```\n+\n+After:\n+\n+```jsx filename=\"app/.../page.tsx\"\n+import { Suspense } from 'react'\n+import { cookies } from 'next/headers'\n+import { connection } from 'next/server'\n+\n+export async function generateMetadata() {\n+  const token = (await cookies()).get('token')\n+  const response = await fetch(..., { headers: { Authorization: token } })\n+  return {\n+    title: getTitle(response),\n+  }\n+}\n+\n+async function DynamicMarker() {\n+  // This component renders nothing, but it will always\n+  // be dynamic because it waits for an actual connection.\n+  const Connection = async () => {\n+    await connection()\n+    return null\n+  }\n+  return (\n+    <Suspense>\n+      <Connection />\n+    </Suspense>\n+  )\n+}\n+\n+export default function Page() {\n+  return (\n+    <>\n+      <article>This article is completely static</article>\n+      {/* Rendering this DynamicMarker component tells Next.js that\n+          this Page has some dynamic content. */}\n+      <DynamicMarker />\n+    </>\n+  )\n+}\n+```\n+\n+Note: The reason to structure this `DynamicMarker` as a self-contained Suspense boundary is to avoid blocking the actual content of the page from being prerendered. When Partial Prerendering is enabled alongside `dynamicIO`, the static shell will still contain all of the prerenderable content, and only the metadata will stream in dynamically.\n+\n+## Useful Links\n+\n+- [`generateMetadata()`](/docs/app/api-reference/functions/generate-metadata)\n+- [`connection()`](/docs/app/api-reference/functions/connection)\n+- [`cookies()`](/docs/app/api-reference/functions/cookies)\n+- [`\"use cache\"`](/docs/app/api-reference/directives/use-cache)"
        },
        {
            "sha": "9c89e8182ddd16379dcf1bf7d3de648f3335664f",
            "filename": "errors/next-prerender-dynamic-viewport.mdx",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/f0f0e4bf5aa67bfed0b7bbf87a2ebe75b02a54bb/errors%2Fnext-prerender-dynamic-viewport.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/f0f0e4bf5aa67bfed0b7bbf87a2ebe75b02a54bb/errors%2Fnext-prerender-dynamic-viewport.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/errors%2Fnext-prerender-dynamic-viewport.mdx?ref=f0f0e4bf5aa67bfed0b7bbf87a2ebe75b02a54bb",
            "patch": "@@ -104,6 +104,6 @@ export default async function Layout({ children }) {\n \n ## Useful Links\n \n-- [`generateViewport()`](docs/app/api-reference/functions/generate-viewport)\n-- [`cookies()`](docs/app/api-reference/functions/cookies)\n+- [`generateViewport()`](/docs/app/api-reference/functions/generate-viewport)\n+- [`cookies()`](/docs/app/api-reference/functions/cookies)\n - [`\"use cache\"`](/docs/app/api-reference/directives/use-cache)"
        },
        {
            "sha": "1176ccf4f6c7bcb3e2989f3f151532945efeefee",
            "filename": "packages/next/src/server/app-render/app-render.tsx",
            "status": "modified",
            "additions": 14,
            "deletions": 13,
            "changes": 27,
            "blob_url": "https://github.com/vercel/next.js/blob/f0f0e4bf5aa67bfed0b7bbf87a2ebe75b02a54bb/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/f0f0e4bf5aa67bfed0b7bbf87a2ebe75b02a54bb/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx?ref=f0f0e4bf5aa67bfed0b7bbf87a2ebe75b02a54bb",
            "patch": "@@ -132,7 +132,7 @@ import {\n   createDynamicValidationState,\n   getFirstDynamicReason,\n   trackAllowedDynamicAccess,\n-  throwIfDisallowedEmptyStaticShell,\n+  throwIfDisallowedDynamic,\n   consumeDynamicAccess,\n   type DynamicAccess,\n } from './dynamic-rendering'\n@@ -2553,14 +2553,13 @@ async function spawnDynamicValidationInDev(\n       // If we've disabled throwing on empty static shell, then we don't need to\n       // track any dynamic access that occurs above the suspense boundary because\n       // we'll do so in the route shell.\n-      if (preludeIsEmpty && !ctx.renderOpts.doNotThrowOnEmptyStaticShell) {\n-        throwIfDisallowedEmptyStaticShell(\n-          route,\n-          dynamicValidation,\n-          serverDynamicTracking,\n-          clientDynamicTracking\n-        )\n-      }\n+      throwIfDisallowedDynamic(\n+        route,\n+        preludeIsEmpty,\n+        dynamicValidation,\n+        serverDynamicTracking,\n+        clientDynamicTracking\n+      )\n     } catch {}\n     return null\n   }\n@@ -3091,9 +3090,10 @@ async function prerenderToStream(\n         // If we've disabled throwing on empty static shell, then we don't need to\n         // track any dynamic access that occurs above the suspense boundary because\n         // we'll do so in the route shell.\n-        if (preludeIsEmpty && !ctx.renderOpts.doNotThrowOnEmptyStaticShell) {\n-          throwIfDisallowedEmptyStaticShell(\n+        if (!ctx.renderOpts.doNotThrowOnEmptyStaticShell) {\n+          throwIfDisallowedDynamic(\n             workStore.route,\n+            preludeIsEmpty,\n             dynamicValidation,\n             serverDynamicTracking,\n             clientDynamicTracking\n@@ -3577,10 +3577,11 @@ async function prerenderToStream(\n         // If we've disabled throwing on empty static shell, then we don't need to\n         // track any dynamic access that occurs above the suspense boundary because\n         // we'll do so in the route shell.\n-        if (preludeIsEmpty && !ctx.renderOpts.doNotThrowOnEmptyStaticShell) {\n+        if (!ctx.renderOpts.doNotThrowOnEmptyStaticShell) {\n           // We don't have a shell because the root errored when we aborted.\n-          throwIfDisallowedEmptyStaticShell(\n+          throwIfDisallowedDynamic(\n             workStore.route,\n+            preludeIsEmpty,\n             dynamicValidation,\n             serverDynamicTracking,\n             clientDynamicTracking"
        },
        {
            "sha": "82600a447d1a4f731a4bc992f7e880178fbc4107",
            "filename": "packages/next/src/server/app-render/dynamic-rendering.ts",
            "status": "modified",
            "additions": 56,
            "deletions": 39,
            "changes": 95,
            "blob_url": "https://github.com/vercel/next.js/blob/f0f0e4bf5aa67bfed0b7bbf87a2ebe75b02a54bb/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fdynamic-rendering.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f0f0e4bf5aa67bfed0b7bbf87a2ebe75b02a54bb/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fdynamic-rendering.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fdynamic-rendering.ts?ref=f0f0e4bf5aa67bfed0b7bbf87a2ebe75b02a54bb",
            "patch": "@@ -80,6 +80,7 @@ export type DynamicValidationState = {\n   hasSuspenseAboveBody: boolean\n   hasDynamicMetadata: boolean\n   hasDynamicViewport: boolean\n+  hasAllowedDynamic: boolean\n   dynamicErrors: Array<Error>\n }\n \n@@ -99,6 +100,7 @@ export function createDynamicValidationState(): DynamicValidationState {\n     hasSuspenseAboveBody: false,\n     hasDynamicMetadata: false,\n     hasDynamicViewport: false,\n+    hasAllowedDynamic: false,\n     dynamicErrors: [],\n   }\n }\n@@ -623,11 +625,13 @@ export function trackAllowedDynamicAccess(\n   } else if (hasSuspenseAfterBodyOrHtmlRegex.test(componentStack)) {\n     // This prerender has a Suspense boundary above the body which\n     // effectively opts the page into allowing 100% dynamic rendering\n+    dynamicValidation.hasAllowedDynamic = true\n     dynamicValidation.hasSuspenseAboveBody = true\n     return\n   } else if (hasSuspenseRegex.test(componentStack)) {\n     // this error had a Suspense boundary above it so we don't need to report it as a source\n     // of disallowed\n+    dynamicValidation.hasAllowedDynamic = true\n     return\n   } else {\n     const message = `Route \"${route}\": A component accessed data, headers, params, searchParams, or a short-lived cache without a Suspense boundary nor a \"use cache\" above it. We don't have the exact line number added to error messages yet but you can see which component in the stack below. See more info: https://nextjs.org/docs/messages/next-prerender-missing-suspense`\n@@ -646,54 +650,67 @@ function createErrorWithComponentStack(\n   return error\n }\n \n-export function throwIfDisallowedEmptyStaticShell(\n+export function throwIfDisallowedDynamic(\n   route: string,\n+  hasEmptyShell: boolean,\n   dynamicValidation: DynamicValidationState,\n   serverDynamic: DynamicTrackingState,\n   clientDynamic: DynamicTrackingState\n ): void {\n-  if (dynamicValidation.hasSuspenseAboveBody) {\n-    // This route has opted into allowing fully dynamic rendering\n-    // by including a Suspense boundary above the body. In this case\n-    // a lack of a shell is not considered disallowed so we simply return\n-    return\n-  }\n-\n-  if (serverDynamic.syncDynamicErrorWithStack) {\n-    // There is no shell and the server did something sync dynamic likely\n-    // leading to an early termination of the prerender before the shell\n-    // could be completed.\n-    console.error(serverDynamic.syncDynamicErrorWithStack)\n-    // We terminate the build/validating render\n-    throw new StaticGenBailoutError()\n-  }\n+  if (hasEmptyShell) {\n+    if (dynamicValidation.hasSuspenseAboveBody) {\n+      // This route has opted into allowing fully dynamic rendering\n+      // by including a Suspense boundary above the body. In this case\n+      // a lack of a shell is not considered disallowed so we simply return\n+      return\n+    }\n \n-  if (clientDynamic.syncDynamicErrorWithStack) {\n-    // Just like above but within the client render...\n-    console.error(clientDynamic.syncDynamicErrorWithStack)\n-    throw new StaticGenBailoutError()\n-  }\n+    if (serverDynamic.syncDynamicErrorWithStack) {\n+      // There is no shell and the server did something sync dynamic likely\n+      // leading to an early termination of the prerender before the shell\n+      // could be completed.\n+      console.error(serverDynamic.syncDynamicErrorWithStack)\n+      // We terminate the build/validating render\n+      throw new StaticGenBailoutError()\n+    }\n \n-  // We didn't have any sync bailouts but there may be user code which\n-  // blocked the root. We would have captured these during the prerender\n-  // and can log them here and then terminate the build/validating render\n-  const dynamicErrors = dynamicValidation.dynamicErrors\n-  if (dynamicErrors.length > 0) {\n-    for (let i = 0; i < dynamicErrors.length; i++) {\n-      console.error(dynamicErrors[i])\n+    if (clientDynamic.syncDynamicErrorWithStack) {\n+      // Just like above but within the client render...\n+      console.error(clientDynamic.syncDynamicErrorWithStack)\n+      throw new StaticGenBailoutError()\n     }\n \n-    throw new StaticGenBailoutError()\n-  }\n+    // We didn't have any sync bailouts but there may be user code which\n+    // blocked the root. We would have captured these during the prerender\n+    // and can log them here and then terminate the build/validating render\n+    const dynamicErrors = dynamicValidation.dynamicErrors\n+    if (dynamicErrors.length > 0) {\n+      for (let i = 0; i < dynamicErrors.length; i++) {\n+        console.error(dynamicErrors[i])\n+      }\n \n-  // If we got this far then the only other thing that could be blocking\n-  // the root is dynamic Viewport. If this is dynamic then\n-  // you need to opt into that by adding a Suspense boundary above the body\n-  // to indicate your are ok with fully dynamic rendering.\n-  if (dynamicValidation.hasDynamicViewport) {\n-    console.error(\n-      `Route \"${route}\" has a \\`generateViewport\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) without explicitly allowing fully dynamic rendering. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport`\n-    )\n-    throw new StaticGenBailoutError()\n+      throw new StaticGenBailoutError()\n+    }\n+\n+    // If we got this far then the only other thing that could be blocking\n+    // the root is dynamic Viewport. If this is dynamic then\n+    // you need to opt into that by adding a Suspense boundary above the body\n+    // to indicate your are ok with fully dynamic rendering.\n+    if (dynamicValidation.hasDynamicViewport) {\n+      console.error(\n+        `Route \"${route}\" has a \\`generateViewport\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) without explicitly allowing fully dynamic rendering. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport`\n+      )\n+      throw new StaticGenBailoutError()\n+    }\n+  } else {\n+    if (\n+      dynamicValidation.hasAllowedDynamic === false &&\n+      dynamicValidation.hasDynamicMetadata\n+    ) {\n+      console.error(\n+        `Route \"${route}\" has a \\`generateMetadata\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) when the rest of the route does not. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-metadata`\n+      )\n+      throw new StaticGenBailoutError()\n+    }\n   }\n }"
        },
        {
            "sha": "337fd4bdea38c6c33f6f09ce16c9dbb72d64bc7f",
            "filename": "test/e2e/app-dir/dynamic-io-errors/dynamic-io-errors.test.ts",
            "status": "modified",
            "additions": 13,
            "deletions": 17,
            "changes": 30,
            "blob_url": "https://github.com/vercel/next.js/blob/f0f0e4bf5aa67bfed0b7bbf87a2ebe75b02a54bb/test%2Fe2e%2Fapp-dir%2Fdynamic-io-errors%2Fdynamic-io-errors.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/f0f0e4bf5aa67bfed0b7bbf87a2ebe75b02a54bb/test%2Fe2e%2Fapp-dir%2Fdynamic-io-errors%2Fdynamic-io-errors.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fdynamic-io-errors%2Fdynamic-io-errors.test.ts?ref=f0f0e4bf5aa67bfed0b7bbf87a2ebe75b02a54bb",
            "patch": "@@ -71,20 +71,18 @@ function runTests(options: { withMinification: boolean }) {\n \n       // This test used to assert the opposite but now that metadata is streaming during prerenders\n       // we don't have to error the build when it is dynamic\n-      it('should not error the build if generateMetadata is dynamic', async () => {\n+      it('should error the build if generateMetadata is dynamic when the rest of the route is prerenderable', async () => {\n         try {\n           await next.start()\n         } catch {\n-          throw new Error('expected build not to fail')\n+          // we expect the build to fail\n         }\n+        const expectError = createExpectError(next.cliOutput)\n \n-        if (WITH_PPR) {\n-          expect(next.cliOutput).toContain('◐ / ')\n-        } else {\n-          expect(next.cliOutput).toContain('ƒ / ')\n-        }\n-        const $ = await next.render$('/')\n-        expect($('#sentinel').text()).toBe('sentinel')\n+        expectError(\n+          'Route \"/\" has a `generateMetadata` that depends on Request data (`cookies()`, etc...) or uncached external data (`fetch(...)`, etc...) when the rest of the route does not'\n+        )\n+        expectError('Error occurred prerendering page \"/\"')\n       })\n     })\n     describe('Dynamic Metadata - Error Route', () => {\n@@ -162,16 +160,14 @@ function runTests(options: { withMinification: boolean }) {\n         try {\n           await next.start()\n         } catch {\n-          throw new Error('expected build not to fail')\n+          // we expect the build to fail\n         }\n+        const expectError = createExpectError(next.cliOutput)\n \n-        if (WITH_PPR) {\n-          expect(next.cliOutput).toContain('◐ / ')\n-        } else {\n-          expect(next.cliOutput).toContain('ƒ / ')\n-        }\n-        const $ = await next.render$('/')\n-        expect($('#sentinel').text()).toBe('sentinel')\n+        expectError(\n+          'Route \"/\" has a `generateMetadata` that depends on Request data (`cookies()`, etc...) or uncached external data (`fetch(...)`, etc...) when the rest of the route does not'\n+        )\n+        expectError('Error occurred prerendering page \"/\"')\n       })\n     })\n "
        }
    ],
    "stats": {
        "total": 307,
        "additions": 236,
        "deletions": 71
    }
}