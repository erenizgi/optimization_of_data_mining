{
    "author": "ylacombe",
    "message": "Moshi integration (#33624)\n\n* clean mimi commit\r\n\r\n* some nits suggestions from Arthur\r\n\r\n* make fixup\r\n\r\n* first moshi WIP\r\n\r\n* converting weights working + configuration + generation configuration\r\n\r\n* finalize converting script - still missing tokenizer and FE and processor\r\n\r\n* fix saving model w/o default config\r\n\r\n* working generation\r\n\r\n* use GenerationMixin instead of inheriting\r\n\r\n* add delay pattern mask\r\n\r\n* fix right order: moshi codes then user codes\r\n\r\n* unconditional inputs + generation config\r\n\r\n* get rid of MoshiGenerationConfig\r\n\r\n* blank user inputs\r\n\r\n* update convert script:fix conversion, add  tokenizer, feature extractor and bf16\r\n\r\n* add and correct Auto classes\r\n\r\n* update modeling code, configuration and tests\r\n\r\n* make fixup\r\n\r\n* fix some copies\r\n\r\n* WIP: add integration tests\r\n\r\n* add dummy objects\r\n\r\n* propose better readiblity and code organisation\r\n\r\n* update tokenization tests\r\n\r\n* update docstrigns, eval and modeling\r\n\r\n* add .md\r\n\r\n* make fixup\r\n\r\n* add MoshiForConditionalGeneration to ignore Auto\r\n\r\n* revert mimi changes\r\n\r\n* re\r\n\r\n* further fix\r\n\r\n* Update moshi.md\r\n\r\n* correct md formating\r\n\r\n* move prepare causal mask to class\r\n\r\n* fix copies\r\n\r\n* fix depth decoder causal\r\n\r\n* fix and correct some tests\r\n\r\n* make style and update .md\r\n\r\n* correct config checkpoitn\r\n\r\n* Update tests/models/moshi/test_tokenization_moshi.py\r\n\r\nCo-authored-by: Arthur <48595927+ArthurZucker@users.noreply.github.com>\r\n\r\n* Update tests/models/moshi/test_tokenization_moshi.py\r\n\r\nCo-authored-by: Arthur <48595927+ArthurZucker@users.noreply.github.com>\r\n\r\n* make style\r\n\r\n* Update src/transformers/models/moshi/__init__.py\r\n\r\nCo-authored-by: Arthur <48595927+ArthurZucker@users.noreply.github.com>\r\n\r\n* fixup\r\n\r\n* change firm in copyrights\r\n\r\n* udpate config with nested dict\r\n\r\n* replace einsum\r\n\r\n* make style\r\n\r\n* change split to True\r\n\r\n* add back splt=False\r\n\r\n* remove tests in convert\r\n\r\n* Update tests/models/moshi/test_modeling_moshi.py\r\n\r\nCo-authored-by: Arthur <48595927+ArthurZucker@users.noreply.github.com>\r\n\r\n* add default config repo + add model to FA2 docstrings\r\n\r\n* remove logits float\r\n\r\n* fix some tokenization tests and ignore some others\r\n\r\n* make style tokenization tests\r\n\r\n* update modeling with sliding window + update modeling tests\r\n\r\n* [run-slow] moshi\r\n\r\n* remove prepare for generation frol CausalLM\r\n\r\n* isort\r\n\r\n* remove copied from\r\n\r\n* ignore offload tests\r\n\r\n* update causal mask and prepare 4D mask aligned with recent changes\r\n\r\n* further test refine + add back prepare_inputs_for_generation for depth decoder\r\n\r\n* correct conditional use of prepare mask\r\n\r\n* update slow integration tests\r\n\r\n* fix multi-device forward\r\n\r\n* remove previous solution to device_map\r\n\r\n* save_load is flaky\r\n\r\n* fix generate multi-devices\r\n\r\n* fix device\r\n\r\n* move tensor to int\r\n\r\n---------\r\n\r\nCo-authored-by: Arthur <48595927+ArthurZucker@users.noreply.github.com>\r\nCo-authored-by: Marc Sun <marc@huggingface.co>",
    "sha": "9ba021ea758429e5bed27a0a405dabf565235802",
    "files": [
        {
            "sha": "016d7279353d952d05b4f987d0421a3e0b474aa3",
            "filename": "docs/source/en/_toctree.yml",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/9ba021ea758429e5bed27a0a405dabf565235802/docs%2Fsource%2Fen%2F_toctree.yml",
            "raw_url": "https://github.com/huggingface/transformers/raw/9ba021ea758429e5bed27a0a405dabf565235802/docs%2Fsource%2Fen%2F_toctree.yml",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2F_toctree.yml?ref=9ba021ea758429e5bed27a0a405dabf565235802",
            "patch": "@@ -740,6 +740,8 @@\n         title: Mimi\n       - local: model_doc/mms\n         title: MMS\n+      - local: model_doc/moshi\n+        title: Moshi\n       - local: model_doc/musicgen\n         title: MusicGen\n       - local: model_doc/musicgen_melody"
        },
        {
            "sha": "bdea11a2456fefb1b959ca9a0bcd4ad327486c4c",
            "filename": "docs/source/en/index.md",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/9ba021ea758429e5bed27a0a405dabf565235802/docs%2Fsource%2Fen%2Findex.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/9ba021ea758429e5bed27a0a405dabf565235802/docs%2Fsource%2Fen%2Findex.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Findex.md?ref=9ba021ea758429e5bed27a0a405dabf565235802",
            "patch": "@@ -223,6 +223,7 @@ Flax), PyTorch, and/or TensorFlow.\n |                  [MobileNetV2](model_doc/mobilenet_v2)                   |       ✅        |         ❌         |      ❌      |\n |                     [MobileViT](model_doc/mobilevit)                     |       ✅        |         ✅         |      ❌      |\n |                   [MobileViTV2](model_doc/mobilevitv2)                   |       ✅        |         ❌         |      ❌      |\n+|                         [Moshi](model_doc/moshi)                         |       ✅        |         ❌         |      ❌      |\n |                         [MPNet](model_doc/mpnet)                         |       ✅        |         ✅         |      ❌      |\n |                           [MPT](model_doc/mpt)                           |       ✅        |         ❌         |      ❌      |\n |                           [MRA](model_doc/mra)                           |       ✅        |         ❌         |      ❌      |"
        },
        {
            "sha": "ad15a002da916625e5057d1b6bf1b861802510dc",
            "filename": "docs/source/en/model_doc/mimi.md",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/9ba021ea758429e5bed27a0a405dabf565235802/docs%2Fsource%2Fen%2Fmodel_doc%2Fmimi.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/9ba021ea758429e5bed27a0a405dabf565235802/docs%2Fsource%2Fen%2Fmodel_doc%2Fmimi.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Fmimi.md?ref=9ba021ea758429e5bed27a0a405dabf565235802",
            "patch": "@@ -66,4 +66,4 @@ The original code can be found [here](https://github.com/kyutai-labs/moshi).\n [[autodoc]] MimiModel\n     - decode\n     - encode\n-    - forward\n+    - forward\n\\ No newline at end of file"
        },
        {
            "sha": "64216f570e3ed01b4e45ab788c6b56f19af69058",
            "filename": "docs/source/en/model_doc/moshi.md",
            "status": "added",
            "additions": 183,
            "deletions": 0,
            "changes": 183,
            "blob_url": "https://github.com/huggingface/transformers/blob/9ba021ea758429e5bed27a0a405dabf565235802/docs%2Fsource%2Fen%2Fmodel_doc%2Fmoshi.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/9ba021ea758429e5bed27a0a405dabf565235802/docs%2Fsource%2Fen%2Fmodel_doc%2Fmoshi.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Fmoshi.md?ref=9ba021ea758429e5bed27a0a405dabf565235802",
            "patch": "@@ -0,0 +1,183 @@\n+<!--Copyright 2024 The HuggingFace Team. All rights reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+the License. You may obtain a copy of the License at\n+\n+http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+specific language governing permissions and limitations under the License.\n+\n+⚠️ Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\n+rendered properly in your Markdown viewer.\n+\n+-->\n+\n+# Moshi\n+\n+## Overview\n+\n+The Moshi model was proposed in [Moshi: a speech-text foundation model for real-time dialogue](https://kyutai.org/Moshi.pdf) by Alexandre Défossez, Laurent Mazaré, Manu Orsini, Amélie Royer, Patrick Pérez, Hervé Jégou, Edouard Grave and Neil Zeghidour.\n+\n+Moshi is a speech-text foundation model that casts spoken dialogue as speech-to-speech generation. Starting from a text language model backbone, Moshi generates speech as tokens from the residual quantizer of a neural audio codec, while modeling separately its own speech and that of the user into parallel streams. This allows for the removal of explicit speaker turns, and the modeling of arbitrary conversational dynamics. Moshi also predicts time-aligned text tokens as a prefix to audio tokens. This “Inner Monologue” method significantly improves the linguistic quality of generated speech and provides streaming speech recognition and text-to-speech. As a result, Moshi is the first real-time full-duplex spoken large language model, with a theoretical latency of 160ms, 200ms in practice.\n+\n+<div style=\"text-align: center\">\n+<img src=\"https://huggingface.co/datasets/ylacombe/benchmark-comparison/resolve/main/moshi_architecture.png\">\n+</div>\n+\n+The abstract from the paper is the following:\n+\n+*We introduce Moshi, a speech-text foundation model and full-duplex spoken dialogue framework. Current systems for spoken dialogue rely on pipelines of independent components, namely voice activity detection, speech recognition, textual dialogue and text-to-speech. Such frameworks cannot emulate the experience of real conversations. First, their complexity induces a latency of several seconds between interactions. Second, text being the intermediate modality for dialogue, non-linguistic information that modifies meaning— such as emotion or non-speech sounds— is lost in the interaction. Finally, they rely on a segmentation into speaker turns, which does not take into account overlapping speech, interruptions and interjections. Moshi solves these independent issues altogether by casting spoken dialogue as speech-to-speech generation. Starting from a text language model backbone, Moshi generates speech as tokens from the residual quantizer of a neural audio codec, while modeling separately its own speech and that of the user into parallel streams. This allows for the removal of explicit speaker turns, and the modeling of arbitrary conversational dynamics. We moreover extend the hierarchical semantic-to-acoustic token generation of previous work to first predict time-aligned text tokens as a prefix to audio tokens. Not only this “Inner Monologue” method significantly improves the linguistic quality of generated speech, but we also illustrate how it can provide streaming speech recognition and text-to-speech. Our resulting model is the first real-time full-duplex spoken large language model, with a theoretical latency of 160ms, 200ms in practice, and is available at github.com/kyutai-labs/moshi.* \n+\n+Moshi deals with 3 streams of information:\n+1. The user's audio\n+2. Moshi's audio\n+3. Moshi's textual output\n+\n+Similarly to [`~MusicgenModel`], audio is represented with audio codebooks, which can be interpreted like tokens. The main difference between text tokens and audio codebooks is that audio codebooks introduce an additional dimension of information.\n+Text tokens are typically of dim `(batch_size, sequence_length)` but audio tokens are of dim `(batch_size, num_codebooks, sequence_length)`.\n+\n+Moshi's made of 3 components:\n+\n+**1. The main decoder (Helium in the paper)**\n+\n+It corresponds to [`MoshiForCausalLM`]. It is strictly a classic text LLM, that uses an architecture similar to [` ~GemmaForCausalLM`]. In other words, it takes text tokens, embeds them, pass them through the decoder and a language head, to get text logits.\n+\n+**2. The depth decoder**\n+\n+On its own, it's also a classic LLM, but this time, instead of generating over the time dimension, it generates over the codebook dimension.\n+\n+It also means that its context length is `num_codebooks`, thus it can't generate more than `num_codebooks`.\n+\n+Note that each timestamp - i.e each codebook - gets its own set of Linear Layers and Embeddings.\n+\n+**3. [`MimiModel`]**\n+\n+It's the audio encoder from Kyutai, that has recently been integrated to transformers, which is used to \"tokenize\" audio. It has the same use that [`~EncodecModel`] has in [`~MusicgenModel`].\n+\n+\n+## Tips:\n+\n+The original checkpoints can be converted using the conversion script `src/transformers/models/moshi/convert_moshi_transformers.py` \n+\n+\n+### How to use the model:\n+\n+This implementation has two main aims:\n+1. quickly test model generation by simplifying the original API\n+2. simplify training. A training guide will come soon, but user contributions are welcomed!\n+\n+<Tip>\n+\n+It is designed for intermediate use. We strongly recommend using the original [implementation](https://github.com/kyutai-labs/moshi) to infer the model in real-time streaming.\n+\n+</Tip>\n+\n+**1. Model generation**\n+\n+Moshi is a streaming auto-regressive model with two streams of audio. To put it differently, one audio stream corresponds to what the model said/will say and the other audio stream corresponds to what the user said/will say.\n+\n+[`MoshiForConditionalGeneration.generate`] thus needs 3 inputs:\n+1. `input_ids` - corresponding to the text token history\n+2. `moshi_input_values` or `moshi_audio_codes`- corresponding to the model audio history\n+3. `user_input_values` or `user_audio_codes` - corresponding to the user audio history\n+\n+These three inputs must be synchronized. Meaning that their lengths must correspond to the same number of tokens.\n+\n+You can dynamically use the 3 inputs depending on what you want to test:\n+1. Simply check the model response to an user prompt - in that case, `input_ids` can be filled with pad tokens and `user_input_values` can be a zero tensor of the same shape than the user prompt.\n+2. Test more complex behaviour - in that case, you must be careful about how the input tokens are synchronized with the audios.\n+\n+<Tip>\n+\n+The original model is synchronized text with audio by padding the text in between each token enunciation.\n+\n+To follow the example of the following image, `\"Hello, I'm Moshi\"` could be transformed to `\"Hello,<pad><unk>I'm Moshi\"`.\n+\n+</Tip>\n+\n+<div style=\"text-align: center\">\n+<img src=\"https://huggingface.co/datasets/ylacombe/benchmark-comparison/resolve/main/moshi_text_sync.png\">\n+</div>\n+\n+\n+[`MoshiForConditionalGeneration.generate`] then auto-regressively feeds to itself its own audio stream, but since it doesn't have access to the user input stream while using `transformers`, it will thus **assume that the user is producing blank audio**.\n+\n+\n+\n+```python \n+>>> from datasets import load_dataset, Audio\n+>>> import torch, math\n+>>> from transformers import MoshiForConditionalGeneration, AutoFeatureExtractor, AutoTokenizer\n+>>> librispeech_dummy = load_dataset(\"hf-internal-testing/librispeech_asr_dummy\", \"clean\", split=\"validation\")\n+\n+\n+>>> # prepare user input audio \n+>>> librispeech_dummy = librispeech_dummy.cast_column(\"audio\", Audio(sampling_rate=feature_extractor.sampling_rate))\n+>>> audio_sample = librispeech_dummy[-1][\"audio\"][\"array\"]\n+>>> user_input_values = feature_extractor(raw_audio=audio_sample, sampling_rate=feature_extractor.sampling_rate, return_tensors=\"pt\").to(device=device, dtype=dtype)\n+\n+>>> # prepare moshi input values - we suppose moshi didn't say anything while the user spoke\n+>>> moshi_input_values = torch.zeros_like(user_input_values.input_values)\n+\n+>>> # prepare moshi input ids - we suppose moshi didn't say anything while the user spoke\n+>>> num_tokens = math.ceil(moshi_input_values.shape[-1] * waveform_to_token_ratio)\n+>>> input_ids = torch.ones((1, num_tokens), device=device, dtype=torch.int64) * tokenizer.encode(\"<pad>\")[0]\n+\n+>>> # generate 25 new tokens (around 2s of audio)\n+>>> output = model.generate(input_ids=input_ids, user_input_values=user_input_values.input_values, moshi_input_values=moshi_input_values, max_new_tokens=25)\n+\n+>>> text_tokens = output.sequences\n+>>> audio_waveforms = output.audio_sequences\n+```\n+\n+**2. Model training**\n+\n+Most of the work has to be done during data creation/pre-processing, because of the need to align/synchronize streams.\n+\n+Once it's done, you can simply forward `text_labels` and `audio_labels` to [`MoshiForConditionalGeneration.forward`], alongside the usual inputs, to get the model loss.\n+ \n+A training guide will come soon, but user contributions are welcomed!\n+\n+### How does the model forward the inputs / generate:\n+\n+1. The input streams are embedded and combined into `inputs_embeds`.\n+\n+2. `inputs_embeds` is passed through the main decoder, which processes it like a normal LLM would.\n+\n+3. The main decoder outputs `text logits` but also its `last hidden state` which is called `temporal context` in the paper.\n+\n+3. The depth decoder switches the dimension on which we forward / generate (codebooks instead of time). It uses the token generated from `text logits`  and the `temporal context` to auto-regressively generate audio codebooks.\n+\n+\n+This model was contributed by [Yoach Lacombe (ylacombe)](https://huggingface.co/ylacombe).\n+\n+The original code can be found [here](https://github.com/kyutai-labs/moshi).\n+\n+\n+\n+## MoshiConfig\n+\n+[[autodoc]] MoshiConfig\n+\n+## MoshiDepthConfig\n+\n+[[autodoc]] MoshiDepthConfig\n+\n+## MoshiModel\n+\n+[[autodoc]] MoshiModel\n+    - forward\n+\n+## MoshiForCausalLM\n+\n+[[autodoc]] MoshiForCausalLM\n+    - forward\n+\n+## MoshiForConditionalGeneration\n+\n+[[autodoc]] MoshiForConditionalGeneration\n+    - forward\n+    - generate\n+    - get_unconditional_inputs"
        },
        {
            "sha": "2f0e9deb841d4dc44a64af576bd265d7dc7d47e4",
            "filename": "docs/source/en/perf_infer_gpu_one.md",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/9ba021ea758429e5bed27a0a405dabf565235802/docs%2Fsource%2Fen%2Fperf_infer_gpu_one.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/9ba021ea758429e5bed27a0a405dabf565235802/docs%2Fsource%2Fen%2Fperf_infer_gpu_one.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fperf_infer_gpu_one.md?ref=9ba021ea758429e5bed27a0a405dabf565235802",
            "patch": "@@ -70,6 +70,7 @@ FlashAttention-2 is currently supported for the following architectures:\n * [MBart](https://huggingface.co/docs/transformers/model_doc/mbart#transformers.MBartModel)\n * [Mistral](https://huggingface.co/docs/transformers/model_doc/mistral#transformers.MistralModel)\n * [Mixtral](https://huggingface.co/docs/transformers/model_doc/mixtral#transformers.MixtralModel)\n+* [Moshi](https://huggingface.co/docs/transformers/model_doc/moshi#transformers.MoshiModel)\n * [Musicgen](https://huggingface.co/docs/transformers/model_doc/musicgen#transformers.MusicgenModel)\n * [MusicGen Melody](https://huggingface.co/docs/transformers/model_doc/musicgen_melody#transformers.MusicgenMelodyModel)\n * [Nemotron](https://huggingface.co/docs/transformers/model_doc/nemotron)\n@@ -241,6 +242,7 @@ For now, Transformers supports SDPA inference and training for the following arc\n * [Mistral](https://huggingface.co/docs/transformers/model_doc/mistral#transformers.MistralModel)\n * [Mllama](https://huggingface.co/docs/transformers/model_doc/mllama#transformers.MllamaForConditionalGeneration)\n * [Mixtral](https://huggingface.co/docs/transformers/model_doc/mixtral#transformers.MixtralModel)\n+* [Moshi](https://huggingface.co/docs/transformers/model_doc/moshi#transformers.MoshiModel)\n * [Musicgen](https://huggingface.co/docs/transformers/model_doc/musicgen#transformers.MusicgenModel)\n * [MusicGen Melody](https://huggingface.co/docs/transformers/model_doc/musicgen_melody#transformers.MusicgenMelodyModel)\n * [NLLB](https://huggingface.co/docs/transformers/model_doc/nllb)"
        },
        {
            "sha": "236333fb1cbd37077066139b2e84f7fa1eb3343c",
            "filename": "src/transformers/__init__.py",
            "status": "modified",
            "additions": 22,
            "deletions": 0,
            "changes": 22,
            "blob_url": "https://github.com/huggingface/transformers/blob/9ba021ea758429e5bed27a0a405dabf565235802/src%2Ftransformers%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/9ba021ea758429e5bed27a0a405dabf565235802/src%2Ftransformers%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2F__init__.py?ref=9ba021ea758429e5bed27a0a405dabf565235802",
            "patch": "@@ -590,6 +590,10 @@\n     \"models.mobilenet_v2\": [\"MobileNetV2Config\"],\n     \"models.mobilevit\": [\"MobileViTConfig\"],\n     \"models.mobilevitv2\": [\"MobileViTV2Config\"],\n+    \"models.moshi\": [\n+        \"MoshiConfig\",\n+        \"MoshiDepthConfig\",\n+    ],\n     \"models.mpnet\": [\n         \"MPNetConfig\",\n         \"MPNetTokenizer\",\n@@ -2783,6 +2787,14 @@\n             \"MobileViTV2PreTrainedModel\",\n         ]\n     )\n+    _import_structure[\"models.moshi\"].extend(\n+        [\n+            \"MoshiForCausalLM\",\n+            \"MoshiForConditionalGeneration\",\n+            \"MoshiModel\",\n+            \"MoshiPreTrainedModel\",\n+        ]\n+    )\n     _import_structure[\"models.mpnet\"].extend(\n         [\n             \"MPNetForMaskedLM\",\n@@ -5448,6 +5460,10 @@\n     from .models.mobilevitv2 import (\n         MobileViTV2Config,\n     )\n+    from .models.moshi import (\n+        MoshiConfig,\n+        MoshiDepthConfig,\n+    )\n     from .models.mpnet import (\n         MPNetConfig,\n         MPNetTokenizer,\n@@ -7386,6 +7402,12 @@\n             MobileViTV2Model,\n             MobileViTV2PreTrainedModel,\n         )\n+        from .models.moshi import (\n+            MoshiForCausalLM,\n+            MoshiForConditionalGeneration,\n+            MoshiModel,\n+            MoshiPreTrainedModel,\n+        )\n         from .models.mpnet import (\n             MPNetForMaskedLM,\n             MPNetForMultipleChoice,"
        },
        {
            "sha": "f37f589d5d53e0b624b18e3c31158c43040e392d",
            "filename": "src/transformers/convert_slow_tokenizer.py",
            "status": "modified",
            "additions": 41,
            "deletions": 0,
            "changes": 41,
            "blob_url": "https://github.com/huggingface/transformers/blob/9ba021ea758429e5bed27a0a405dabf565235802/src%2Ftransformers%2Fconvert_slow_tokenizer.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/9ba021ea758429e5bed27a0a405dabf565235802/src%2Ftransformers%2Fconvert_slow_tokenizer.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fconvert_slow_tokenizer.py?ref=9ba021ea758429e5bed27a0a405dabf565235802",
            "patch": "@@ -1405,6 +1405,47 @@ def converted(self) -> Tokenizer:\n         return tokenizer\n \n \n+class MoshiConverter(SpmConverter):\n+    handle_byte_fallback = True\n+\n+    def __init__(self, vocab_file, model_max_length=None, **kwargs):\n+        requires_backends(self, \"protobuf\")\n+\n+        Converter.__init__(self, vocab_file)\n+\n+        # from .utils import sentencepiece_model_pb2 as model_pb2\n+        model_pb2 = import_protobuf()\n+\n+        m = model_pb2.ModelProto()\n+        with open(vocab_file, \"rb\") as f:\n+            m.ParseFromString(f.read())\n+        self.proto = m\n+\n+    def normalizer(self, proto):\n+        precompiled_charsmap = proto.normalizer_spec.precompiled_charsmap\n+        _normalizers = [\n+            normalizers.Replace(\" \", \"▁\"),\n+        ]\n+        if not precompiled_charsmap:\n+            return normalizers.Sequence(_normalizers)\n+        else:\n+            return normalizers.Sequence([normalizers.Precompiled(precompiled_charsmap)] + _normalizers)\n+\n+    def decoder(self, replacement, add_prefix_space):\n+        sequence = [\n+            decoders.Replace(\"▁\", \" \"),\n+            decoders.ByteFallback(),\n+            decoders.Fuse(),\n+        ]\n+        if add_prefix_space:\n+            sequence += [decoders.Strip(content=\" \", left=1)]\n+        return decoders.Sequence(sequence)\n+\n+    def pre_tokenizer(self, replacement, add_prefix_space):\n+        prepend_scheme = \"first\"\n+        return pre_tokenizers.Metaspace(replacement=replacement, prepend_scheme=prepend_scheme, split=False)\n+\n+\n # Copied from transformers.models.gpt2.tokenization_gpt2.bytes_to_unicode\n def bytes_to_unicode():\n     \"\"\""
        },
        {
            "sha": "6d71b754d6f4e5d959f09cda8226c9101089b9c4",
            "filename": "src/transformers/generation/utils.py",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/9ba021ea758429e5bed27a0a405dabf565235802/src%2Ftransformers%2Fgeneration%2Futils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/9ba021ea758429e5bed27a0a405dabf565235802/src%2Ftransformers%2Fgeneration%2Futils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fgeneration%2Futils.py?ref=9ba021ea758429e5bed27a0a405dabf565235802",
            "patch": "@@ -1594,8 +1594,10 @@ def _get_cache(\n                     cache_dtype = self.get_output_embeddings().weight.dtype\n \n             def get_layer_device_map(execution_device_map: Optional[dict] = None):\n-                if execution_device_map is None or len(execution_device_map) <= 1:\n+                if execution_device_map is None:\n                     return None\n+                elif len(execution_device_map) == 1 and \"\" in execution_device_map:\n+                    return {idx: execution_device_map[\"\"] for idx in range(self.config.num_hidden_layers)}\n                 layer_device_map = {}\n                 for layer in execution_device_map:\n                     for idx in range(self.config.num_hidden_layers):"
        },
        {
            "sha": "069c7f90564fcef097f8e8bad71210b847406052",
            "filename": "src/transformers/models/__init__.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/9ba021ea758429e5bed27a0a405dabf565235802/src%2Ftransformers%2Fmodels%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/9ba021ea758429e5bed27a0a405dabf565235802/src%2Ftransformers%2Fmodels%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2F__init__.py?ref=9ba021ea758429e5bed27a0a405dabf565235802",
            "patch": "@@ -161,6 +161,7 @@\n     mobilenet_v2,\n     mobilevit,\n     mobilevitv2,\n+    moshi,\n     mpnet,\n     mpt,\n     mra,"
        },
        {
            "sha": "05d6e717be23d255f09b0c2975ac54410287c772",
            "filename": "src/transformers/models/auto/configuration_auto.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/9ba021ea758429e5bed27a0a405dabf565235802/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/9ba021ea758429e5bed27a0a405dabf565235802/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py?ref=9ba021ea758429e5bed27a0a405dabf565235802",
            "patch": "@@ -179,6 +179,7 @@\n         (\"mobilenet_v2\", \"MobileNetV2Config\"),\n         (\"mobilevit\", \"MobileViTConfig\"),\n         (\"mobilevitv2\", \"MobileViTV2Config\"),\n+        (\"moshi\", \"MoshiConfig\"),\n         (\"mpnet\", \"MPNetConfig\"),\n         (\"mpt\", \"MptConfig\"),\n         (\"mra\", \"MraConfig\"),\n@@ -490,6 +491,7 @@\n         (\"mobilenet_v2\", \"MobileNetV2\"),\n         (\"mobilevit\", \"MobileViT\"),\n         (\"mobilevitv2\", \"MobileViTV2\"),\n+        (\"moshi\", \"Moshi\"),\n         (\"mpnet\", \"MPNet\"),\n         (\"mpt\", \"MPT\"),\n         (\"mra\", \"MRA\"),"
        },
        {
            "sha": "0ddab5681f2e469773a3b50c570d544bbdcfbde2",
            "filename": "src/transformers/models/auto/feature_extraction_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/9ba021ea758429e5bed27a0a405dabf565235802/src%2Ftransformers%2Fmodels%2Fauto%2Ffeature_extraction_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/9ba021ea758429e5bed27a0a405dabf565235802/src%2Ftransformers%2Fmodels%2Fauto%2Ffeature_extraction_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Ffeature_extraction_auto.py?ref=9ba021ea758429e5bed27a0a405dabf565235802",
            "patch": "@@ -73,6 +73,7 @@\n         (\"mobilenet_v1\", \"MobileNetV1FeatureExtractor\"),\n         (\"mobilenet_v2\", \"MobileNetV2FeatureExtractor\"),\n         (\"mobilevit\", \"MobileViTFeatureExtractor\"),\n+        (\"moshi\", \"EncodecFeatureExtractor\"),\n         (\"nat\", \"ViTFeatureExtractor\"),\n         (\"owlvit\", \"OwlViTFeatureExtractor\"),\n         (\"perceiver\", \"PerceiverFeatureExtractor\"),"
        },
        {
            "sha": "5a98e761adc13b99963936d512b668e424c79241",
            "filename": "src/transformers/models/auto/modeling_auto.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/9ba021ea758429e5bed27a0a405dabf565235802/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/9ba021ea758429e5bed27a0a405dabf565235802/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py?ref=9ba021ea758429e5bed27a0a405dabf565235802",
            "patch": "@@ -169,6 +169,7 @@\n         (\"mobilenet_v2\", \"MobileNetV2Model\"),\n         (\"mobilevit\", \"MobileViTModel\"),\n         (\"mobilevitv2\", \"MobileViTV2Model\"),\n+        (\"moshi\", \"MoshiModel\"),\n         (\"mpnet\", \"MPNetModel\"),\n         (\"mpt\", \"MptModel\"),\n         (\"mra\", \"MraModel\"),\n@@ -506,6 +507,7 @@\n         (\"mistral\", \"MistralForCausalLM\"),\n         (\"mixtral\", \"MixtralForCausalLM\"),\n         (\"mllama\", \"MllamaForCausalLM\"),\n+        (\"moshi\", \"MoshiForCausalLM\"),\n         (\"mpt\", \"MptForCausalLM\"),\n         (\"musicgen\", \"MusicgenForCausalLM\"),\n         (\"musicgen_melody\", \"MusicgenMelodyForCausalLM\"),"
        },
        {
            "sha": "3a3428e09951477cc9093123893f6ecba2b9691a",
            "filename": "src/transformers/models/auto/tokenization_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/9ba021ea758429e5bed27a0a405dabf565235802/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/9ba021ea758429e5bed27a0a405dabf565235802/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py?ref=9ba021ea758429e5bed27a0a405dabf565235802",
            "patch": "@@ -309,6 +309,7 @@\n             (\"mllama\", (\"LlamaTokenizer\", \"LlamaTokenizerFast\" if is_tokenizers_available() else None)),\n             (\"mluke\", (\"MLukeTokenizer\" if is_sentencepiece_available() else None, None)),\n             (\"mobilebert\", (\"MobileBertTokenizer\", \"MobileBertTokenizerFast\" if is_tokenizers_available() else None)),\n+            (\"moshi\", (None, \"PreTrainedTokenizerFast\" if is_tokenizers_available() else None)),\n             (\"mpnet\", (\"MPNetTokenizer\", \"MPNetTokenizerFast\" if is_tokenizers_available() else None)),\n             (\"mpt\", (None, \"GPTNeoXTokenizerFast\" if is_tokenizers_available() else None)),\n             (\"mra\", (\"RobertaTokenizer\", \"RobertaTokenizerFast\" if is_tokenizers_available() else None)),"
        },
        {
            "sha": "69da6e940ea643a7a8c024a795e3845e5d89730b",
            "filename": "src/transformers/models/moshi/__init__.py",
            "status": "added",
            "additions": 27,
            "deletions": 0,
            "changes": 27,
            "blob_url": "https://github.com/huggingface/transformers/blob/9ba021ea758429e5bed27a0a405dabf565235802/src%2Ftransformers%2Fmodels%2Fmoshi%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/9ba021ea758429e5bed27a0a405dabf565235802/src%2Ftransformers%2Fmodels%2Fmoshi%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fmoshi%2F__init__.py?ref=9ba021ea758429e5bed27a0a405dabf565235802",
            "patch": "@@ -0,0 +1,27 @@\n+# Copyright 2024 The HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+from typing import TYPE_CHECKING\n+\n+from ...utils import _LazyModule\n+from ...utils.import_utils import define_import_structure\n+\n+\n+if TYPE_CHECKING:\n+    from .configuration_moshi import *\n+    from .modeling_moshi import *\n+else:\n+    import sys\n+\n+    _file = globals()[\"__file__\"]\n+    sys.modules[__name__] = _LazyModule(__name__, _file, define_import_structure(_file), module_spec=__spec__)"
        },
        {
            "sha": "654e4e82a491b78ee1e0ca3221225c2a11134407",
            "filename": "src/transformers/models/moshi/configuration_moshi.py",
            "status": "added",
            "additions": 333,
            "deletions": 0,
            "changes": 333,
            "blob_url": "https://github.com/huggingface/transformers/blob/9ba021ea758429e5bed27a0a405dabf565235802/src%2Ftransformers%2Fmodels%2Fmoshi%2Fconfiguration_moshi.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/9ba021ea758429e5bed27a0a405dabf565235802/src%2Ftransformers%2Fmodels%2Fmoshi%2Fconfiguration_moshi.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fmoshi%2Fconfiguration_moshi.py?ref=9ba021ea758429e5bed27a0a405dabf565235802",
            "patch": "@@ -0,0 +1,333 @@\n+# coding=utf-8\n+# Copyright 2024 Meta AI and The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Moshi model configuration\"\"\"\n+\n+from ...configuration_utils import PretrainedConfig\n+from ...utils import logging\n+from ..auto.configuration_auto import AutoConfig\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+class MoshiDepthConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`MoshiDepthDecoder`]. It is used to instantiate a\n+    Moshi depth decoder model according to the specified arguments, defining the Moshi depth decoder config.\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        vocab_size (`int`, *optional*, defaults to 32000):\n+            Vocabulary size of the MoshiDepthDecoder model. Defines the number of different tokens that can be\n+            represented by the `inputs_ids` passed when calling [`MoshiDepthDecoder`].\n+        hidden_size (`int`, *optional*, defaults to 1024):\n+            Dimensionality of the layers and the pooler layer of the depth decoder.\n+        input_size (`int`, *optional*, defaults to 4096):\n+            Dimensionality of the input hidden states. Used to connect the main decoder to the depth decoder.\n+        num_hidden_layers (`int`, *optional*, defaults to 6):\n+            Number of depth decoder layers.\n+        num_attention_heads (`int`, *optional*, defaults to 16):\n+            Number of attention heads for each attention layer in the depth decoder block.\n+        num_key_value_heads (`int`, *optional*):\n+            This is the number of key_value heads that should be used to implement Grouped Query Attention. If\n+            `num_key_value_heads=num_attention_heads`, the model will use Multi Head Attention (MHA), if\n+            `num_key_value_heads=1` the model will use Multi Query Attention (MQA) otherwise GQA is used. When\n+            converting a multi-head checkpoint to a GQA checkpoint, each group key and value head should be constructed\n+            by meanpooling all the original heads within that group. For more details checkout [this\n+            paper](https://arxiv.org/pdf/2305.13245.pdf). If it is not specified, will default to `num_attention_heads`.\n+        audio_vocab_size (`int`, *optional*, defaults to 2048):\n+            Vocabulary size of the audio part of model. Defines the number of different tokens that can be\n+            represented by the `audio_codes` passed when calling the Moshi models.\n+        max_position_embeddings (`int`, *optional*, defaults to 9):\n+            The maximum sequence length that this model might ever be used with. Typically, set this to something large\n+            just in case (e.g., 512 or 1024 or 2048).\n+        hidden_act (`str` or `function`, *optional*, defaults to `\"silu\"`):\n+            The non-linear activation function (function or string) in the depth decoder.\n+        head_dim (`int`, *optional*, defaults to `hidden_size // num_attention_heads`):\n+            The attention head dimension.\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+        use_cache (`bool`, *optional*, defaults to `True`):\n+            Whether or not the model should return the last key/values attentions (not used by all models). Only\n+            relevant if `config.is_decoder=True`.\n+        sliding_window (`int`, *optional*, defaults to 8):\n+            Sliding window attention window size. If not specified, will default to `8`.\n+        attention_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout ratio for the attention probabilities.\n+        ffn_dim (`int`, *optional*, defaults to 5632):\n+            Dimensionality of the \"intermediate\" (often named feed-forward) layer in the depth decoder block. Must be even.\n+        rms_norm_eps (`float`, *optional*, defaults to 1e-08):\n+            The epsilon used by the rms normalization layers.\n+        num_codebooks (`int`, *optional*, defaults to 8):\n+            The number of audio codebooks for each audio channels.\n+        tie_word_embeddings (`bool`, *optional*, defaults to `False`):\n+            Whether to tie weight embeddings\n+        kwargs (*optional*):\n+            Dictionary of keyword arguments. Notably:\n+                - **audio_encoder_config** ([`PretrainedConfig`], *optional*) -- An instance of a configuration object that\n+                  defines the audio encoder config.\n+\n+    Example:\n+\n+    ```python\n+    >>> from transformers import (\n+    ...     MoshiDepthConfig,\n+    ...     MoshiDepthDecoder,\n+    ... )\n+\n+    >>> configuration = MoshiDepthConfig()\n+\n+    >>> # Initializing a MoshiDepthDecoder (with random weights) from the kmhf/hf-moshiko style configuration\n+    >>> model = MoshiDepthDecoder(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"moshi_depth\"\n+    keys_to_ignore_at_inference = [\"past_key_values\"]\n+\n+    def __init__(\n+        self,\n+        vocab_size=32000,\n+        hidden_size=1024,\n+        input_size=4096,\n+        num_hidden_layers=6,\n+        num_attention_heads=16,\n+        num_key_value_heads=None,\n+        audio_vocab_size=2048,\n+        max_position_embeddings=9,\n+        hidden_act=\"silu\",\n+        head_dim=None,\n+        initializer_range=0.02,\n+        use_cache=True,\n+        sliding_window=8,\n+        attention_dropout=0.0,\n+        ffn_dim=5632,\n+        rms_norm_eps=1e-8,\n+        num_codebooks=8,\n+        tie_word_embeddings=False,\n+        **kwargs,\n+    ):\n+        self.vocab_size = vocab_size\n+        self.hidden_size = hidden_size\n+        self.input_size = input_size\n+        self.num_hidden_layers = num_hidden_layers\n+        self.num_attention_heads = num_attention_heads\n+        self.num_key_value_heads = num_key_value_heads if num_key_value_heads is not None else num_attention_heads\n+        self.max_position_embeddings = max_position_embeddings\n+        self.hidden_act = hidden_act\n+        self.head_dim = head_dim or hidden_size // num_attention_heads\n+        self.initializer_range = initializer_range\n+        self.use_cache = use_cache\n+        self.sliding_window = sliding_window\n+        self.attention_dropout = attention_dropout\n+        if ffn_dim % 2 == 1:\n+            raise ValueError(f\"`ffn_dim={ffn_dim}` must be even.\")\n+        self.ffn_dim = ffn_dim\n+        self.rms_norm_eps = rms_norm_eps\n+        self.num_codebooks = num_codebooks\n+        self.audio_vocab_size = audio_vocab_size\n+\n+        super().__init__(tie_word_embeddings=tie_word_embeddings, **kwargs)\n+\n+\n+class MoshiConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`MoshiModel`]. It is used to instantiate a\n+    Moshi model according to the specified arguments, defining the audio encoder, Moshi depth decoder and Moshi decoder\n+    configs. Instantiating a configuration with the defaults will yield a similar configuration to that of the Moshiko model,\n+    e.g. [kmhf/hf-moshiko](https://huggingface.co/kmhf/hf-moshiko)\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        vocab_size (`int`, *optional*, defaults to 32000):\n+            Vocabulary size of the MoshiDecoder model. Defines the number of different tokens that can be\n+            represented by the `inputs_ids` passed when calling [`MoshiDecoder`].\n+        hidden_size (`int`, *optional*, defaults to 4096):\n+            Dimensionality of the layers and the pooler layer of the main decoder.\n+        num_hidden_layers (`int`, *optional*, defaults to 32):\n+            Number of decoder layers.\n+        num_attention_heads (`int`, *optional*, defaults to 32):\n+            Number of attention heads for each attention layer in the main decoder block.\n+        num_key_value_heads (`int`, *optional*):\n+            This is the number of key_value heads that should be used to implement Grouped Query Attention. If\n+            `num_key_value_heads=num_attention_heads`, the model will use Multi Head Attention (MHA), if\n+            `num_key_value_heads=1` the model will use Multi Query Attention (MQA) otherwise GQA is used. When\n+            converting a multi-head checkpoint to a GQA checkpoint, each group key and value head should be constructed\n+            by meanpooling all the original heads within that group. For more details checkout [this\n+            paper](https://arxiv.org/pdf/2305.13245.pdf). If it is not specified, will default to `num_attention_heads`.\n+        audio_vocab_size (`int`, *optional*):\n+            Vocabulary size of the audio part of model. Defines the number of different tokens that can be\n+            represented by the `audio_codes` passed when calling the Moshi models.\n+        max_position_embeddings (`int`, *optional*, defaults to 3000):\n+            The maximum sequence length that this model might ever be used with. Typically, set this to something large\n+            just in case (e.g., 512 or 1024 or 2048).\n+        rope_theta (`float`, *optional*, defaults to 10000.0):\n+            The base period of the RoPE embeddings.\n+        hidden_act (`str` or `function`, *optional*, defaults to `\"silu\"`):\n+            The non-linear activation function (function or string) in the decoder.\n+        head_dim (`int`, *optional*, defaults to `hidden_size // num_attention_heads`):\n+            The attention head dimension.\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+        use_cache (`bool`, *optional*, defaults to `True`):\n+            Whether or not the model should return the last key/values attentions (not used by all models). Only\n+            relevant if `config.is_decoder=True`.\n+        sliding_window (`int`, *optional*, defaults to 3000):\n+            Sliding window attention window size. If not specified, will default to `3000`.\n+        attention_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout ratio for the attention probabilities.\n+        ffn_dim (`int`, *optional*, defaults to 22528):\n+            Dimensionality of the \"intermediate\" (often named feed-forward) layer in the main decoder block. Must be even.\n+        rms_norm_eps (`float`, *optional*, defaults to 1e-08):\n+            The epsilon used by the rms normalization layers.\n+        num_codebooks (`int`, *optional*, defaults to 8):\n+            The number of audio codebooks for each audio channels.\n+        tie_word_embeddings (`bool`, *optional*, defaults to `False`):\n+            Whether to tie weight embeddings\n+        kwargs (*optional*):\n+            Dictionary of keyword arguments. Notably:\n+                - **audio_encoder_config** ([`PretrainedConfig`], *optional*) -- An instance of a configuration object that\n+                  defines the audio encoder config.\n+                - **depth__config** ([`PretrainedConfig`], *optional*) -- An instance of a configuration object that\n+                  defines the depth decoder config.\n+\n+\n+    Example:\n+\n+    ```python\n+    >>> from transformers import (\n+    ...     MoshiConfig,\n+    ...     MoshiForConditionalGeneration,\n+    ... )\n+\n+    >>> configuration = MoshiConfig()\n+\n+    >>> # Initializing a MoshiForConditionalGeneration (with random weights) from the kmhf/hf-moshiko style configuration\n+    >>> model = MoshiForConditionalGeneration(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+\n+    >>> # Saving the model, including its configuration\n+    >>> model.save_pretrained(\"kmhf/hf-moshiko\")\n+\n+    >>> # loading model and config from pretrained folder\n+    >>> moshi_config = MoshiConfig.from_pretrained(\"kmhf/hf-moshiko\")\n+    >>> model = MoshiForConditionalGeneration.from_pretrained(\"kmhf/hf-moshiko\", config=moshi_config)\n+    ```\"\"\"\n+\n+    model_type = \"moshi\"\n+    is_composition = True\n+    keys_to_ignore_at_inference = [\"past_key_values\"]\n+\n+    def __init__(\n+        self,\n+        vocab_size=32000,\n+        hidden_size=4096,\n+        num_hidden_layers=32,\n+        num_attention_heads=32,\n+        num_key_value_heads=None,\n+        audio_vocab_size=None,\n+        max_position_embeddings=3000,\n+        rope_theta=10000.0,\n+        hidden_act=\"silu\",\n+        head_dim=None,\n+        initializer_range=0.02,\n+        use_cache=True,\n+        sliding_window=3000,\n+        attention_dropout=0.0,\n+        ffn_dim=22528,\n+        rms_norm_eps=1e-8,\n+        num_codebooks=8,\n+        tie_word_embeddings=False,\n+        **kwargs,\n+    ):\n+        self.vocab_size = vocab_size\n+        self.hidden_size = hidden_size\n+        self.num_hidden_layers = num_hidden_layers\n+        self.num_attention_heads = num_attention_heads\n+        self.num_key_value_heads = num_key_value_heads if num_key_value_heads is not None else num_attention_heads\n+        self.max_position_embeddings = max_position_embeddings\n+        self.rope_theta = rope_theta\n+        self.hidden_act = hidden_act\n+        self.head_dim = head_dim or hidden_size // num_attention_heads\n+        self.initializer_range = initializer_range\n+        self.use_cache = use_cache\n+        self.sliding_window = sliding_window\n+        self.attention_dropout = attention_dropout\n+        if ffn_dim % 2 == 1:\n+            raise ValueError(f\"`ffn_dim={ffn_dim}` must be even.\")\n+        self.ffn_dim = ffn_dim\n+        self.rms_norm_eps = rms_norm_eps\n+        self.num_codebooks = num_codebooks\n+\n+        audio_encoder_config = kwargs.pop(\"audio_encoder_config\", {})\n+        audio_encoder_model_type = audio_encoder_config.pop(\"model_type\", \"mimi\")\n+\n+        self.audio_encoder_config = AutoConfig.for_model(audio_encoder_model_type, **audio_encoder_config)\n+\n+        if self.num_codebooks > self.audio_encoder_config.num_codebooks:\n+            raise ValueError(\n+                f\"`num_codebooks={num_codebooks}` is greater than the maximum number of codebooks that the audio encoder can deal with ({self.audio_encoder_config.num_codebooks}). Please lower it.\"\n+            )\n+\n+        self.audio_vocab_size = (\n+            self.audio_encoder_config.codebook_size if audio_vocab_size is None else audio_vocab_size\n+        )\n+\n+        depth_decoder_config = kwargs.pop(\"depth_decoder_config\", {})\n+        depth_decoder_config.update(\n+            {\n+                \"audio_vocab_size\": self.audio_vocab_size,\n+                \"input_size\": hidden_size,\n+                \"vocab_size\": vocab_size,\n+                \"num_codebooks\": num_codebooks,\n+            }\n+        )\n+\n+        self.depth_decoder_config = MoshiDepthConfig(**depth_decoder_config)\n+\n+        super().__init__(tie_word_embeddings=tie_word_embeddings, **kwargs)\n+\n+    @property\n+    def sampling_rate(self):\n+        return self.audio_encoder_config.sampling_rate\n+\n+    @classmethod\n+    def from_audio_encoder_config(\n+        cls,\n+        audio_encoder_config: PretrainedConfig,\n+        **kwargs,\n+    ):\n+        r\"\"\"\n+        Instantiate a [`MoshiConfig`] (or a derived class) from an audio encoder configuration.\n+\n+        Returns:\n+            [`MoshiConfig`]: An instance of a configuration object\n+        \"\"\"\n+\n+        return cls(\n+            audio_encoder_config=audio_encoder_config.to_dict(),\n+            **kwargs,\n+        )\n+\n+\n+__all__ = [\"MoshiConfig\", \"MoshiDepthConfig\"]"
        },
        {
            "sha": "1caaee25ef6fa065642a020b71b43740d53b91ec",
            "filename": "src/transformers/models/moshi/convert_moshi_transformers.py",
            "status": "added",
            "additions": 311,
            "deletions": 0,
            "changes": 311,
            "blob_url": "https://github.com/huggingface/transformers/blob/9ba021ea758429e5bed27a0a405dabf565235802/src%2Ftransformers%2Fmodels%2Fmoshi%2Fconvert_moshi_transformers.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/9ba021ea758429e5bed27a0a405dabf565235802/src%2Ftransformers%2Fmodels%2Fmoshi%2Fconvert_moshi_transformers.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fmoshi%2Fconvert_moshi_transformers.py?ref=9ba021ea758429e5bed27a0a405dabf565235802",
            "patch": "@@ -0,0 +1,311 @@\n+# coding=utf-8\n+# Copyright 2024 The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Convert Moshi checkpoints.\"\"\"\n+\n+import argparse\n+\n+import safetensors\n+import sentencepiece\n+import torch\n+\n+from transformers import (\n+    AutoFeatureExtractor,\n+    GenerationConfig,\n+    MimiModel,  # initial audio encoder\n+    MoshiConfig,\n+    MoshiForConditionalGeneration,\n+    PreTrainedTokenizerFast,\n+    logging,\n+)\n+from transformers.convert_slow_tokenizer import MoshiConverter\n+\n+\n+logging.set_verbosity_info()\n+logger = logging.get_logger(\"transformers.models.mimi\")\n+\n+\n+def assert_param_count(model_1, model_2):\n+    count_1 = sum(p[1].numel() for p in model_1.named_parameters() if \"final_proj\" not in p[0])\n+    count_2 = sum(p[1].numel() for p in model_2.named_parameters() if \"final_proj\" not in p[0])\n+    assert count_1 == count_2, f\"{model_1.__class__}: {count_1} != {model_2.__class__}: {count_2}\"\n+\n+\n+def param_count(model):\n+    return sum(p[1].numel() for p in model.named_parameters() if \"final_proj\" not in p[0])\n+\n+\n+def _grab_best_device(use_gpu=True):\n+    if torch.cuda.device_count() > 0 and use_gpu:\n+        device = \"cuda\"\n+    else:\n+        device = \"cpu\"\n+    return torch.device(device)\n+\n+\n+convert_list = [\n+    # GENERAL\n+    (\"out_norm\", \"decoder.model.norm\"),\n+    (\"depformer_emb\", \"depth_decoder.emb\"),\n+    (\"depformer_text_emb\", \"depth_decoder.text_emb\"),\n+    (\"text_emb\", \"decoder.model.emb\"),\n+    (\"emb\", \"embed_tokens\"),\n+    (\"text_linear\", \"decoder.lm_head\"),\n+    (\"depformer\", \"depth_decoder\"),\n+    (\"transformer\", \"decoder.model\"),\n+    # TRANSFORMERS PART\n+    (\"gating.linear_in\", \"mlp.fc1\"),\n+    (\"gating.linear_out\", \"mlp.fc2\"),\n+    (\"self_attn.out_proj\", \"self_attn.o_proj.linear\"),\n+    (\"norm1\", \"input_layernorm\"),\n+    (\"norm2\", \"post_attention_layernorm\"),\n+    (\"layer_scale_1\", \"self_attn_layer_scale\"),\n+    (\"layer_scale_2\", \"mlp_layer_scale\"),\n+    (\"alpha\", \"weight\"),\n+]\n+\n+\n+def _preprocess_state_dict(state_dict, config):\n+    # Moshi original weights are using a gating mechanism\n+\n+    # pattern for depth transformer:\n+    # stack(gating.{i}.linear_in)->mlp.fc1\n+    # stack(gating.{i}.linear_out)->mlp.fc2\n+\n+    for layer_idx in range(config.depth_decoder_config.num_hidden_layers):\n+        linear_layers_in = [\n+            state_dict.pop(f\"depformer.layers.{layer_idx}.gating.{i}.linear_in.weight\")\n+            for i in range(config.num_codebooks)\n+        ]\n+        linear_layers_out = [\n+            state_dict.pop(f\"depformer.layers.{layer_idx}.gating.{i}.linear_out.weight\")\n+            for i in range(config.num_codebooks)\n+        ]\n+\n+        state_dict[f\"depth_decoder.layers.{layer_idx}.mlp.fc1.weight\"] = torch.stack(linear_layers_in)\n+        state_dict[f\"depth_decoder.layers.{layer_idx}.mlp.fc2.weight\"] = torch.stack(linear_layers_out)\n+\n+    input_projections = []\n+    lm_heads = []\n+    for codebook_idx in range(config.num_codebooks):\n+        input_projections.append(state_dict.pop(f\"depformer_in.{codebook_idx}.weight\"))\n+        lm_heads.append(state_dict.pop(f\"linears.{codebook_idx}.weight\"))\n+\n+    state_dict[\"depth_decoder.input_projections.weight\"] = torch.stack(input_projections, dim=0)\n+    state_dict[\"depth_decoder.lm_heads.weight\"] = torch.stack(lm_heads, dim=0)\n+\n+    return state_dict\n+\n+\n+def _convert_model(\n+    state_dict,\n+    hf_model,\n+    convert_list,\n+    device,\n+    config,\n+    unwanted_prefix=None,\n+):\n+    hidden_size = config.hidden_size\n+    head_dim = config.head_dim\n+    num_heads = int(config.hidden_size // config.head_dim)\n+    num_key_value_heads = config.num_key_value_heads\n+    key_value_head_dim = config.num_key_value_heads * head_dim\n+\n+    state_dict = _preprocess_state_dict(state_dict, config)\n+\n+    # permute for sliced rotary\n+    def permute(w, n_heads, dim1=hidden_size, dim2=hidden_size):\n+        return w.view(n_heads, dim1 // n_heads // 2, 2, dim2).transpose(1, 2).reshape(dim1, dim2)\n+\n+    for k, v in list(state_dict.items()):\n+        if \"audio_encoder\" not in k:\n+            new_k = k if unwanted_prefix is None else k[len(unwanted_prefix) :]\n+            for old_layer_name, new_layer_name in convert_list:\n+                if old_layer_name in new_k:\n+                    new_k = new_k.replace(old_layer_name, new_layer_name)\n+\n+            if \"alpha\" in k:\n+                state_dict[k] = state_dict[k].squeeze()\n+\n+            if \"in_proj_weight\" in new_k:\n+                # split qkv into query key and value\n+                mixed_qkv = state_dict.pop(k)\n+                if \"depth_decoder\" in new_k:\n+                    mixed_qkv = mixed_qkv.view(config.num_codebooks, -1, mixed_qkv.shape[-1])\n+\n+                    qkv_dim = mixed_qkv.size(1) // 3\n+\n+                    query_layer = mixed_qkv[:, :qkv_dim]\n+                    key_layer = mixed_qkv[:, qkv_dim : qkv_dim * 2]\n+                    value_layer = mixed_qkv[:, qkv_dim * 2 :]\n+                    state_dict[new_k.replace(\"in_proj_weight\", \"q_proj.linear.weight\")] = query_layer\n+                    state_dict[new_k.replace(\"in_proj_weight\", \"k_proj.linear.weight\")] = key_layer\n+\n+                else:\n+                    qkv_dim = mixed_qkv.size(0) // 3\n+\n+                    query_layer = mixed_qkv[:qkv_dim]\n+                    key_layer = mixed_qkv[qkv_dim : qkv_dim * 2]\n+                    value_layer = mixed_qkv[qkv_dim * 2 :]\n+                    state_dict[new_k.replace(\"in_proj_weight\", \"q_proj.linear.weight\")] = permute(\n+                        query_layer, num_heads, hidden_size, hidden_size\n+                    )\n+                    state_dict[new_k.replace(\"in_proj_weight\", \"k_proj.linear.weight\")] = permute(\n+                        key_layer, num_key_value_heads, key_value_head_dim, hidden_size\n+                    )\n+\n+                state_dict[new_k.replace(\"in_proj_weight\", \"v_proj.linear.weight\")] = value_layer\n+            elif \"o_proj\" in new_k and \"depth_decoder\" in new_k:\n+                output_layer = state_dict.pop(k)\n+                state_dict[new_k] = output_layer.view(config.num_codebooks, -1, output_layer.shape[-1])\n+            else:\n+                state_dict[new_k] = state_dict.pop(k)\n+\n+    # Do the last one by hand\n+    state_dict[\"depth_decoder.text_embed_tokens.weight\"] = state_dict.pop(\n+        \"depth_decoder.decoder.model.embed_tokens.weight\"\n+    )\n+\n+    extra_keys = set(state_dict.keys()) - set(hf_model.state_dict().keys())\n+    missing_keys = set(hf_model.state_dict().keys()) - set(state_dict.keys())\n+    if len(extra_keys) != 0:\n+        raise ValueError(f\"extra keys found: {extra_keys}\")\n+    if len(missing_keys) != 0:\n+        raise ValueError(f\"missing keys: {missing_keys}\")\n+    hf_model.load_state_dict(state_dict, strict=True)\n+    n_params = param_count(hf_model)\n+\n+    logger.info(f\"model loaded: {round(n_params/1e6,1)}M params\")\n+\n+    hf_model.eval()\n+    hf_model.to(device)\n+    del state_dict\n+\n+    return hf_model\n+\n+\n+@torch.no_grad()\n+def convert_checkpoint(\n+    checkpoint_path,\n+    pytorch_dump_folder_path,\n+    mimi_repo_id,\n+    config_path=None,\n+    repo_id=None,\n+):\n+    \"\"\"\n+    Copy/paste/tweak model's weights to transformers design.\n+    \"\"\"\n+    device = _grab_best_device()\n+\n+    mimi_model = MimiModel.from_pretrained(mimi_repo_id, torch_dtype=torch.bfloat16)\n+\n+    if config_path is not None:\n+        config = MoshiConfig.from_pretrained(config_path)\n+    else:\n+        audio_encoder_config = mimi_model.config\n+        config = MoshiConfig.from_audio_encoder_config(audio_encoder_config)\n+\n+    model = MoshiForConditionalGeneration(config).to(torch.bfloat16)\n+\n+    depth_decoder_generation_config = GenerationConfig(\n+        do_sample=True,\n+        temperature=0.8,\n+        top_k=250,\n+        min_length=config.num_codebooks + 1,\n+        max_length=config.num_codebooks + 1,\n+        cache_implementation=\"sliding_window\",\n+    )\n+\n+    generation_config = GenerationConfig(\n+        do_sample=True,\n+        temp=0.7,\n+        top_k=25,\n+        cache_implementation=\"sliding_window\",\n+        pad_token_id=config.vocab_size,\n+        bos_token_id=config.vocab_size,\n+    )\n+    generation_config.depth_decoder_config = depth_decoder_generation_config.to_diff_dict()\n+\n+    model.generation_config = generation_config\n+\n+    original_checkpoint = safetensors.torch.load_file(checkpoint_path)\n+    if \"best_state\" in original_checkpoint:\n+        # we might have a training state saved, in which case discard the yaml results and just retain the weights\n+        original_checkpoint = original_checkpoint[\"best_state\"]\n+\n+    audio_checkpoint = mimi_model.state_dict()\n+    original_checkpoint.update({f\"audio_encoder.{key}\": value for (key, value) in audio_checkpoint.items()})\n+\n+    model = _convert_model(original_checkpoint, model, convert_list, device, config)\n+\n+    model.save_pretrained(pytorch_dump_folder_path)\n+\n+    if repo_id:\n+        print(\"Pushing to the hub...\")\n+        model.push_to_hub(repo_id)\n+\n+\n+if __name__ == \"__main__\":\n+    parser = argparse.ArgumentParser()\n+    parser.add_argument(\"--checkpoint_path\", required=True, default=None, type=str, help=\"Path to original checkpoint\")\n+    parser.add_argument(\n+        \"--tokenizer_vocab_path\", required=False, default=None, type=str, help=\"Path to original tokenizer vocab file\"\n+    )\n+    parser.add_argument(\"--mimi_repo_id\", required=True, default=None, type=str, help=\"Repository id to HF Mimi.\")\n+    parser.add_argument(\"--config_path\", default=None, type=str, help=\"Path to hf config.json of model to convert\")\n+    parser.add_argument(\n+        \"--pytorch_dump_folder_path\", required=True, default=None, type=str, help=\"Path to the output PyTorch model.\"\n+    )\n+    parser.add_argument(\n+        \"--push_to_hub\", default=None, type=str, help=\"Where to upload the converted model on the 🤗 hub.\"\n+    )\n+\n+    args = parser.parse_args()\n+\n+    # convert tokenizer\n+    if args.tokenizer_vocab_path:\n+        original_tokenizer = sentencepiece.SentencePieceProcessor(args.tokenizer_vocab_path)\n+        tokenizer = MoshiConverter(args.tokenizer_vocab_path).converted()\n+        tokenizer = PreTrainedTokenizerFast(\n+            tokenizer_object=tokenizer,\n+            chat_template=None,\n+            unk_token=\"<unk>\",\n+            model_input_names=[\"input_ids\", \"attention_mask\"],\n+            clean_up_tokenization_spaces=False,\n+            bos_token_id=original_tokenizer.bos_id(),\n+            eos_token_id=original_tokenizer.eos_id(),\n+            pad_token_id=original_tokenizer.pad_id(),\n+        )\n+\n+        tokenizer.save_pretrained(args.pytorch_dump_folder_path)\n+\n+        if args.push_to_hub:\n+            print(\"Pushing the tokenizer to the hub...\")\n+            tokenizer.push_to_hub(args.push_to_hub)\n+\n+    # upload feature extractor\n+    feature_extractor = AutoFeatureExtractor.from_pretrained(args.mimi_repo_id)\n+    feature_extractor.save_pretrained(args.pytorch_dump_folder_path)\n+\n+    if args.push_to_hub:\n+        print(\"Pushing the feature extractor to the hub...\")\n+        feature_extractor.push_to_hub(args.push_to_hub)\n+\n+    convert_checkpoint(\n+        args.checkpoint_path,\n+        args.pytorch_dump_folder_path,\n+        args.mimi_repo_id,\n+        args.config_path,\n+        args.push_to_hub,\n+    )"
        },
        {
            "sha": "5746a5934bd31f3b0c30a2e0c978039b852dcdc5",
            "filename": "src/transformers/models/moshi/modeling_moshi.py",
            "status": "added",
            "additions": 2813,
            "deletions": 0,
            "changes": 2813,
            "blob_url": "https://github.com/huggingface/transformers/blob/9ba021ea758429e5bed27a0a405dabf565235802/src%2Ftransformers%2Fmodels%2Fmoshi%2Fmodeling_moshi.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/9ba021ea758429e5bed27a0a405dabf565235802/src%2Ftransformers%2Fmodels%2Fmoshi%2Fmodeling_moshi.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fmoshi%2Fmodeling_moshi.py?ref=9ba021ea758429e5bed27a0a405dabf565235802"
        },
        {
            "sha": "d7570c57c62f363d25d6ee3927a6288446c4b32d",
            "filename": "src/transformers/utils/dummy_pt_objects.py",
            "status": "modified",
            "additions": 28,
            "deletions": 0,
            "changes": 28,
            "blob_url": "https://github.com/huggingface/transformers/blob/9ba021ea758429e5bed27a0a405dabf565235802/src%2Ftransformers%2Futils%2Fdummy_pt_objects.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/9ba021ea758429e5bed27a0a405dabf565235802/src%2Ftransformers%2Futils%2Fdummy_pt_objects.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Futils%2Fdummy_pt_objects.py?ref=9ba021ea758429e5bed27a0a405dabf565235802",
            "patch": "@@ -6219,6 +6219,34 @@ def __init__(self, *args, **kwargs):\n         requires_backends(self, [\"torch\"])\n \n \n+class MoshiForCausalLM(metaclass=DummyObject):\n+    _backends = [\"torch\"]\n+\n+    def __init__(self, *args, **kwargs):\n+        requires_backends(self, [\"torch\"])\n+\n+\n+class MoshiForConditionalGeneration(metaclass=DummyObject):\n+    _backends = [\"torch\"]\n+\n+    def __init__(self, *args, **kwargs):\n+        requires_backends(self, [\"torch\"])\n+\n+\n+class MoshiModel(metaclass=DummyObject):\n+    _backends = [\"torch\"]\n+\n+    def __init__(self, *args, **kwargs):\n+        requires_backends(self, [\"torch\"])\n+\n+\n+class MoshiPreTrainedModel(metaclass=DummyObject):\n+    _backends = [\"torch\"]\n+\n+    def __init__(self, *args, **kwargs):\n+        requires_backends(self, [\"torch\"])\n+\n+\n class MPNetForMaskedLM(metaclass=DummyObject):\n     _backends = [\"torch\"]\n "
        },
        {
            "sha": "5165e43c0994160b13e83f8ed8321dbf03c66803",
            "filename": "tests/generation/test_utils.py",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/huggingface/transformers/blob/9ba021ea758429e5bed27a0a405dabf565235802/tests%2Fgeneration%2Ftest_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/9ba021ea758429e5bed27a0a405dabf565235802/tests%2Fgeneration%2Ftest_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fgeneration%2Ftest_utils.py?ref=9ba021ea758429e5bed27a0a405dabf565235802",
            "patch": "@@ -1098,6 +1098,7 @@ def test_assisted_decoding_matches_greedy_search(self, assistant_type):\n                     \"bigbirdpegasus\",\n                     \"led\",\n                     \"mega\",\n+                    \"moshi\",\n                     \"speech2text\",\n                     \"git\",\n                     \"prophetnet\",\n@@ -1172,6 +1173,7 @@ def test_prompt_lookup_decoding_matches_greedy_search(self):\n                     \"bigbirdpegasus\",\n                     \"led\",\n                     \"mega\",\n+                    \"moshi\",\n                     \"speech2text\",\n                     \"git\",\n                     \"prophetnet\",\n@@ -1285,6 +1287,7 @@ def test_assisted_decoding_sample(self):\n                     \"bigbirdpegasus\",\n                     \"led\",\n                     \"mega\",\n+                    \"moshi\",\n                     \"speech2text\",\n                     \"git\",\n                     \"prophetnet\","
        },
        {
            "sha": "074dceae155214f272e5631be520700de7a6a4e3",
            "filename": "tests/models/mimi/test_modeling_mimi.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/9ba021ea758429e5bed27a0a405dabf565235802/tests%2Fmodels%2Fmimi%2Ftest_modeling_mimi.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/9ba021ea758429e5bed27a0a405dabf565235802/tests%2Fmodels%2Fmimi%2Ftest_modeling_mimi.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fmimi%2Ftest_modeling_mimi.py?ref=9ba021ea758429e5bed27a0a405dabf565235802",
            "patch": "@@ -790,6 +790,7 @@ def test_integration_using_cache_decode(self):\n         }\n \n         librispeech_dummy = load_dataset(\"hf-internal-testing/librispeech_asr_dummy\", \"clean\", split=\"validation\")\n+\n         model_id = \"kyutai/mimi\"\n \n         model = MimiModel.from_pretrained(model_id, use_cache=True).to(torch_device)\n@@ -840,6 +841,7 @@ def test_integration(self):\n             \"32\": 1803071,\n         }\n         librispeech_dummy = load_dataset(\"hf-internal-testing/librispeech_asr_dummy\", \"clean\", split=\"validation\")\n+\n         model_id = \"kyutai/mimi\"\n \n         processor = AutoFeatureExtractor.from_pretrained(model_id)"
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "tests/models/moshi/__init__.py",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/huggingface/transformers/blob/9ba021ea758429e5bed27a0a405dabf565235802/tests%2Fmodels%2Fmoshi%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/9ba021ea758429e5bed27a0a405dabf565235802/tests%2Fmodels%2Fmoshi%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fmoshi%2F__init__.py?ref=9ba021ea758429e5bed27a0a405dabf565235802"
        },
        {
            "sha": "b299b414d609b1e1453a1b4ae88c1af00c9a6300",
            "filename": "tests/models/moshi/test_modeling_moshi.py",
            "status": "added",
            "additions": 1126,
            "deletions": 0,
            "changes": 1126,
            "blob_url": "https://github.com/huggingface/transformers/blob/9ba021ea758429e5bed27a0a405dabf565235802/tests%2Fmodels%2Fmoshi%2Ftest_modeling_moshi.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/9ba021ea758429e5bed27a0a405dabf565235802/tests%2Fmodels%2Fmoshi%2Ftest_modeling_moshi.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fmoshi%2Ftest_modeling_moshi.py?ref=9ba021ea758429e5bed27a0a405dabf565235802",
            "patch": "@@ -0,0 +1,1126 @@\n+# coding=utf-8\n+# Copyright 2024, The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Testing suite for the PyTorch Moshi model.\"\"\"\n+\n+import copy\n+import tempfile\n+import unittest\n+\n+import numpy as np\n+import pytest\n+from datasets import Audio, load_dataset\n+from parameterized import parameterized\n+\n+from transformers import (\n+    MoshiConfig,\n+    PretrainedConfig,\n+)\n+from transformers.integrations.deepspeed import (\n+    is_deepspeed_available,\n+    is_deepspeed_zero3_enabled,\n+)\n+from transformers.testing_utils import (\n+    is_flaky,\n+    is_torch_available,\n+    require_torch,\n+    require_torch_fp16,\n+    require_torch_sdpa,\n+    slow,\n+    torch_device,\n+)\n+from transformers.utils import cached_property\n+\n+from ...generation.test_utils import GenerationTesterMixin\n+from ...test_configuration_common import ConfigTester\n+from ...test_modeling_common import ModelTesterMixin, floats_tensor, ids_tensor\n+from ...test_pipeline_mixin import PipelineTesterMixin\n+\n+\n+if is_deepspeed_available():\n+    import deepspeed\n+\n+if is_torch_available():\n+    import torch\n+\n+    from transformers import (\n+        AutoFeatureExtractor,\n+        AutoTokenizer,\n+        MoshiForCausalLM,\n+        MoshiForConditionalGeneration,\n+        MoshiModel,\n+    )\n+\n+\n+def _config_zero_init(config):\n+    configs_no_init = copy.deepcopy(config)\n+    for key in configs_no_init.__dict__.keys():\n+        if \"_range\" in key or \"_std\" in key or \"initializer_factor\" in key or \"layer_scale\" in key:\n+            setattr(configs_no_init, key, 1e-10)\n+        if isinstance(getattr(configs_no_init, key, None), PretrainedConfig):\n+            no_init_subconfig = _config_zero_init(getattr(configs_no_init, key))\n+            setattr(configs_no_init, key, no_init_subconfig)\n+    return configs_no_init\n+\n+\n+class MoshiDecoderTester:\n+    def __init__(\n+        self,\n+        parent,\n+        batch_size=4,  # need batch_size != num_hidden_layers\n+        seq_length=7,\n+        is_training=True,\n+        vocab_size=99,\n+        hidden_size=32,\n+        num_hidden_layers=2,\n+        num_attention_heads=4,\n+        intermediate_size=4,\n+        hidden_act=\"silu\",\n+        rms_norm_eps=0.001,\n+        ffn_dim=32,\n+        hidden_dropout_prob=0.1,\n+        attention_probs_dropout_prob=0.1,\n+        max_position_embeddings=100,\n+        pad_token_id=25,\n+        num_codebooks=4,\n+        audio_encoder_type=\"mimi\",\n+        attn_implementation=\"eager\",\n+    ):\n+        self.parent = parent\n+        self.batch_size = batch_size\n+        self.seq_length = seq_length\n+        self.is_training = is_training\n+        self.vocab_size = vocab_size\n+        self.hidden_size = hidden_size\n+        self.num_hidden_layers = num_hidden_layers\n+        self.num_attention_heads = num_attention_heads\n+        self.intermediate_size = intermediate_size\n+        self.hidden_act = hidden_act\n+        self.rms_norm_eps = rms_norm_eps\n+        self.ffn_dim = ffn_dim\n+        self.hidden_dropout_prob = hidden_dropout_prob\n+        self.attention_probs_dropout_prob = attention_probs_dropout_prob\n+        self.max_position_embeddings = max_position_embeddings\n+        self.pad_token_id = pad_token_id\n+        self.num_codebooks = num_codebooks\n+        self.audio_encoder_type = audio_encoder_type\n+        self.attn_implementation = attn_implementation\n+\n+    def prepare_config_and_inputs(self, batch_size=None):\n+        batch_size = self.batch_size if batch_size is None else batch_size\n+        input_ids = ids_tensor([batch_size, self.seq_length], self.vocab_size)\n+        config = self.get_config()\n+\n+        attention_mask = input_ids.ne(self.pad_token_id)\n+\n+        inputs_dict = {\"input_ids\": input_ids, \"attention_mask\": attention_mask}\n+        return config, inputs_dict\n+\n+    def get_config(self):\n+        config = MoshiConfig(\n+            vocab_size=self.vocab_size,\n+            hidden_size=self.hidden_size,\n+            num_hidden_layers=self.num_hidden_layers,\n+            num_attention_heads=self.num_attention_heads,\n+            d_ff=self.intermediate_size,\n+            num_codebooks=self.num_codebooks,\n+            rms_norm_eps=self.rms_norm_eps,\n+            tie_word_embeddings=False,\n+            pad_token_id=self.pad_token_id,\n+            ffn_dim=self.ffn_dim,\n+            audio_encoder_config={\"model_type\": self.audio_encoder_type},\n+            attn_implementation=self.attn_implementation,\n+        )\n+        return config\n+\n+    def prepare_config_and_inputs_for_common(self, batch_size=None):\n+        config, inputs_dict = self.prepare_config_and_inputs(batch_size)\n+        return config, inputs_dict\n+\n+\n+@require_torch\n+class MoshiDecoderTest(ModelTesterMixin, GenerationTesterMixin, PipelineTesterMixin, unittest.TestCase):\n+    all_model_classes = (MoshiModel, MoshiForCausalLM) if is_torch_available() else ()\n+    all_generative_model_classes = (\n+        (MoshiForCausalLM,) if is_torch_available() else ()\n+    )  # we don't want to run all the generation tests, only a specific subset\n+    test_pruning = False\n+    test_resize_embeddings = True\n+    test_head_masking = False\n+    pipeline_model_mapping = (\n+        {\n+            \"feature-extraction\": MoshiModel,\n+            \"text-generation\": MoshiForCausalLM,\n+        }\n+        if is_torch_available()\n+        else {}\n+    )\n+\n+    def setUp(self):\n+        self.model_tester = MoshiDecoderTester(self)\n+        self.config_tester = ConfigTester(\n+            self,\n+            config_class=MoshiConfig,\n+            hidden_size=16,\n+            audio_encoder_config={\"model_type\": self.model_tester.audio_encoder_type},\n+        )\n+\n+    @unittest.skip(reason=\"The MoshiModel does not have support dynamic compile yet\")\n+    def test_sdpa_can_compile_dynamic(self):\n+        pass\n+\n+    def _get_input_ids_and_config(self, batch_size=1):\n+        config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common(batch_size)\n+        input_ids = inputs_dict.pop(\"input_ids\").to(torch_device)\n+        attention_mask = inputs_dict.pop(\"attention_mask\").to(torch_device)\n+\n+        return config, input_ids, attention_mask, inputs_dict\n+\n+    def _get_logits_processor_kwargs(self, do_sample=False, config=None):\n+        logits_processor_kwargs = {}\n+        return logits_processor_kwargs\n+\n+    @require_torch_sdpa\n+    @slow\n+    @parameterized.expand([(\"float16\",), (\"bfloat16\",), (\"float32\",)])\n+    def test_eager_matches_sdpa_inference(self, torch_dtype: str):\n+        self.skipTest(reason=\"Moshi has no strict equivalence between two modes, skipping this test.\")\n+\n+    # Copied from tests.test_modeling_common.ModelTesterMixin.test_resize_tokens_embeddings\n+    def test_resize_tokens_embeddings(self):\n+        if not self.test_resize_embeddings:\n+            self.skipTest(reason=\"test_resize_embeddings is set to `False`\")\n+\n+        (\n+            original_config,\n+            inputs_dict,\n+        ) = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+        for model_class in self.all_model_classes:\n+            config = copy.deepcopy(original_config)\n+            if is_deepspeed_zero3_enabled():\n+                with deepspeed.zero.Init():\n+                    model = model_class(config)\n+            else:\n+                model = model_class(config)\n+                model.to(torch_device)\n+\n+            model_embed_pre_resize = model.get_input_embeddings()\n+            type_model_embed_pre_resize = type(model_embed_pre_resize)\n+\n+            if self.model_tester.is_training is False:\n+                model.eval()\n+\n+            model_vocab_size = config.get_text_config().vocab_size\n+            # Retrieve the embeddings and clone theme\n+            model_embed = model.resize_token_embeddings(model_vocab_size)\n+            cloned_embeddings = model_embed.weight.clone()\n+\n+            # Check that resizing the token embeddings with a larger vocab size increases the model's vocab size\n+            model_embed = model.resize_token_embeddings(model_vocab_size + 10)\n+            new_model_vocab_size = model.config.get_text_config().vocab_size\n+            self.assertEqual(new_model_vocab_size, model_vocab_size + 10)\n+            # Check that it actually resizes the embeddings matrix\n+            self.assertEqual(model_embed.weight.shape[0], cloned_embeddings.shape[0] + 10)\n+            # Check to make sure the type of embeddings returned post resizing is same as type of input\n+            type_model_embed_post_resize = type(model_embed)\n+            self.assertEqual(type_model_embed_pre_resize, type_model_embed_post_resize)\n+            # Check that added embeddings mean is close to the old embeddings mean\n+            if is_deepspeed_zero3_enabled():\n+                with deepspeed.zero.GatheredParameters(model_embed.weight, modifier_rank=None):\n+                    old_embeddings_mean = torch.mean(model_embed.weight.data[:-10, :], axis=0)\n+                    new_embeddings_mean = torch.mean(model_embed.weight.data[-10:, :], axis=0)\n+            else:\n+                old_embeddings_mean = torch.mean(model_embed.weight.data[:-10, :], axis=0)\n+                new_embeddings_mean = torch.mean(model_embed.weight.data[-10:, :], axis=0)\n+            torch.testing.assert_close(old_embeddings_mean, new_embeddings_mean, atol=1e-3, rtol=1e-1)\n+\n+            # Check that the model can still do a forward pass successfully (every parameter should be resized)\n+            if not is_deepspeed_zero3_enabled():\n+                # A distriputed launcher is needed for the forward pass when deepspeed is enabled\n+                model(**self._prepare_for_class(inputs_dict, model_class))\n+\n+            # Check that resizing the token embeddings with a smaller vocab size decreases the model's vocab size\n+            model_embed = model.resize_token_embeddings(model_vocab_size - 15)\n+            new_model_vocab_size = model.config.get_text_config().vocab_size\n+            self.assertEqual(new_model_vocab_size, model_vocab_size - 15)\n+            # Check that it actually resizes the embeddings matrix\n+            self.assertEqual(model_embed.weight.shape[0], cloned_embeddings.shape[0] - 15)\n+\n+            # Check that the model can still do a forward pass successfully (every parameter should be resized)\n+            # Input ids should be clamped to the maximum size of the vocabulary\n+            inputs_dict[\"input_ids\"].clamp_(max=model_vocab_size - 15 - 1)\n+\n+            # make sure that decoder_input_ids are resized as well\n+            if not is_deepspeed_zero3_enabled():\n+                # A distriputed launcher is needed for the forward pass when deepspeed is enabled\n+                if \"decoder_input_ids\" in inputs_dict:\n+                    inputs_dict[\"decoder_input_ids\"].clamp_(max=model_vocab_size - 15 - 1)\n+                model(**self._prepare_for_class(inputs_dict, model_class))\n+\n+            # Check that adding and removing tokens has not modified the first part of the embedding matrix.\n+            models_equal = True\n+            for p1, p2 in zip(cloned_embeddings, model_embed.weight):\n+                if p1.data.ne(p2.data).sum() > 0:\n+                    models_equal = False\n+\n+            self.assertTrue(models_equal)\n+\n+            del model\n+            if is_deepspeed_zero3_enabled():\n+                with deepspeed.zero.Init():\n+                    model = model_class(config)\n+            else:\n+                model = model_class(config)\n+                model.to(torch_device)\n+\n+            model_vocab_size = config.get_text_config().vocab_size\n+            model.resize_token_embeddings(model_vocab_size + 10, pad_to_multiple_of=1)\n+            new_model_vocab_size = model.config.get_text_config().vocab_size\n+            self.assertTrue(new_model_vocab_size + 10, model_vocab_size)\n+\n+            model_embed = model.resize_token_embeddings(model_vocab_size, pad_to_multiple_of=64)\n+            new_model_vocab_size = model.config.get_text_config().vocab_size\n+            self.assertTrue(model_embed.weight.shape[0] // 64, 0)\n+\n+            self.assertTrue(model_embed.weight.shape[0], new_model_vocab_size)\n+            self.assertTrue(new_model_vocab_size, model.vocab_size)\n+\n+            model_embed = model.resize_token_embeddings(model_vocab_size + 13, pad_to_multiple_of=64)\n+            self.assertTrue(model_embed.weight.shape[0] // 64, 0)\n+\n+            # Check that resizing a model to a multiple of pad_to_multiple leads to a model of exactly that size\n+            target_dimension = 128\n+            model_embed = model.resize_token_embeddings(target_dimension, pad_to_multiple_of=64)\n+            self.assertTrue(model_embed.weight.shape[0], target_dimension)\n+\n+            with self.assertRaisesRegex(\n+                ValueError,\n+                \"Asking to pad the embedding matrix to a multiple of `1.3`, which is not and integer. Please make sure to pass an integer\",\n+            ):\n+                model.resize_token_embeddings(model_vocab_size, pad_to_multiple_of=1.3)\n+\n+            # Test when `vocab_size` is smaller than `hidden_size`.\n+            del model\n+            config.vocab_size = 4\n+            config.pad_token_id = 4  # Ignore copy\n+            if is_deepspeed_zero3_enabled():\n+                with deepspeed.zero.Init():\n+                    model = model_class(config)\n+            else:\n+                model = model_class(config)\n+                model.to(torch_device)\n+\n+            model_vocab_size = config.get_text_config().vocab_size\n+            # Retrieve the embeddings and clone theme\n+            model_embed = model.resize_token_embeddings(model_vocab_size)\n+            cloned_embeddings = model_embed.weight.clone()\n+\n+            # Check that resizing the token embeddings with a larger vocab size increases the model's vocab size\n+            model_embed = model.resize_token_embeddings(model_vocab_size + 10)\n+            new_model_vocab_size = model.config.get_text_config().vocab_size\n+            self.assertEqual(new_model_vocab_size, model_vocab_size + 10)\n+            # Check that it actually resizes the embeddings matrix\n+            self.assertEqual(model_embed.weight.shape[0], cloned_embeddings.shape[0] + 10)\n+            # Check to make sure the type of embeddings returned post resizing is same as type of input\n+            type_model_embed_post_resize = type(model_embed)\n+            self.assertEqual(type_model_embed_pre_resize, type_model_embed_post_resize)\n+            # Check that added embeddings mean is close to the old embeddings mean\n+            if is_deepspeed_zero3_enabled():\n+                with deepspeed.zero.GatheredParameters(model_embed.weight, modifier_rank=None):\n+                    old_embeddings_mean = torch.mean(model_embed.weight.data[:-10, :], axis=0)\n+                    new_embeddings_mean = torch.mean(model_embed.weight.data[-10:, :], axis=0)\n+            else:\n+                old_embeddings_mean = torch.mean(model_embed.weight.data[:-10, :], axis=0)\n+                new_embeddings_mean = torch.mean(model_embed.weight.data[-10:, :], axis=0)\n+            torch.testing.assert_close(old_embeddings_mean, new_embeddings_mean, atol=1e-3, rtol=1e-1)\n+\n+    @unittest.skip(reason=\"Some undefined behavior encountered with test versions of this model. Skip for now.\")\n+    def test_cpu_offload(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Some undefined behavior encountered with test versions of this model. Skip for now.\")\n+    def test_disk_offload_bin(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Some undefined behavior encountered with test versions of this model. Skip for now.\")\n+    def test_disk_offload_safetensors(self):\n+        pass\n+\n+    @is_flaky(max_attempts=5, description=\"flaky on some models.\")\n+    def test_save_load(self):\n+        super().test_save_load()\n+\n+\n+class MoshiTester:\n+    def __init__(\n+        self,\n+        parent,\n+        batch_size=4,  # need batch_size != num_hidden_layers\n+        seq_length=7,\n+        is_training=True,\n+        vocab_size=99,\n+        hidden_size=32,\n+        num_hidden_layers=2,\n+        num_attention_heads=8,\n+        intermediate_size=4,\n+        hidden_act=\"silu\",\n+        rms_norm_eps=0.001,\n+        ffn_dim=32,\n+        hidden_dropout_prob=0.1,\n+        attention_probs_dropout_prob=0.1,\n+        max_position_embeddings=100,\n+        pad_token_id=25,\n+        bos_token_id=25,\n+        num_codebooks=4,\n+        audio_encoder_type=\"mimi\",\n+        attn_implementation=\"eager\",\n+        depth_hidden_size=16,\n+        depth_num_hidden_layers=2,\n+        depth_max_position_embeddings=5,\n+        depth_num_attention_heads=8,\n+        depth_ffn_dim=16,\n+        depth_sliding_window=4,\n+        mimi_intermediate_size=40,\n+        mimi_hidden_size=32,\n+        mimi_num_filters=8,\n+        mimi_num_residual_layers=1,\n+        mimi_upsampling_ratios=[8, 4],\n+        mimi_codebook_size=64,\n+        mimi_vector_quantization_hidden_dimension=64,\n+        mimi_codebook_dim=64,\n+        mimi_upsample_groups=32,\n+        mimi_num_hidden_layers=2,\n+        mimi_num_attention_heads=2,\n+        mimi_num_key_value_heads=2,\n+        mimi_sliding_window=3,\n+        sampling_rate=800,\n+    ):\n+        self.parent = parent\n+        self.batch_size = batch_size\n+        self.seq_length = seq_length\n+        self.is_training = is_training\n+        self.vocab_size = vocab_size\n+        self.hidden_size = hidden_size\n+        self.num_hidden_layers = num_hidden_layers\n+        self.num_attention_heads = num_attention_heads\n+        self.intermediate_size = intermediate_size\n+        self.hidden_act = hidden_act\n+        self.rms_norm_eps = rms_norm_eps\n+        self.ffn_dim = ffn_dim\n+        self.hidden_dropout_prob = hidden_dropout_prob\n+        self.attention_probs_dropout_prob = attention_probs_dropout_prob\n+        self.max_position_embeddings = max_position_embeddings\n+        self.pad_token_id = pad_token_id\n+        self.bos_token_id = bos_token_id\n+        self.num_codebooks = num_codebooks\n+        self.attn_implementation = attn_implementation\n+        self.depth_hidden_size = depth_hidden_size\n+        self.depth_num_hidden_layers = depth_num_hidden_layers\n+        self.depth_max_position_embeddings = depth_max_position_embeddings\n+        self.depth_num_attention_heads = depth_num_attention_heads\n+        self.depth_ffn_dim = depth_ffn_dim\n+        self.depth_sliding_window = depth_sliding_window\n+\n+        self.audio_encoder_type = audio_encoder_type\n+        self.mimi_intermediate_size = mimi_intermediate_size\n+        self.mimi_hidden_size = mimi_hidden_size\n+        self.mimi_num_filters = mimi_num_filters\n+        self.mimi_num_residual_layers = mimi_num_residual_layers\n+        self.mimi_upsampling_ratios = mimi_upsampling_ratios\n+        self.mimi_codebook_size = mimi_codebook_size\n+        self.mimi_vector_quantization_hidden_dimension = mimi_vector_quantization_hidden_dimension\n+        self.mimi_codebook_dim = mimi_codebook_dim\n+        self.mimi_upsample_groups = mimi_upsample_groups\n+        self.mimi_num_hidden_layers = mimi_num_hidden_layers\n+        self.mimi_num_attention_heads = mimi_num_attention_heads\n+        self.mimi_num_key_value_heads = mimi_num_key_value_heads\n+        self.mimi_sliding_window = mimi_sliding_window\n+        self.sampling_rate = sampling_rate\n+\n+        self.num_hidden_states_types = 2\n+\n+    def prepare_config_and_inputs(self, batch_size=None):\n+        batch_size = self.batch_size if batch_size is None else batch_size\n+\n+        input_ids = ids_tensor([batch_size, self.seq_length], self.vocab_size)\n+\n+        moshi_audio_codes = ids_tensor([batch_size, self.num_codebooks, self.seq_length], self.mimi_codebook_size)\n+        user_audio_codes = ids_tensor([batch_size, self.num_codebooks, self.seq_length], self.mimi_codebook_size)\n+        attention_mask = input_ids.ne(self.pad_token_id)\n+\n+        config = self.get_config()\n+        inputs_dict = {\n+            \"input_ids\": input_ids,\n+            \"moshi_audio_codes\": moshi_audio_codes,\n+            \"user_audio_codes\": user_audio_codes,\n+            \"attention_mask\": attention_mask,\n+        }\n+        return config, inputs_dict\n+\n+    def get_config(self):\n+        mimi_dict_config = {\n+            \"model_type\": self.audio_encoder_type,\n+            \"audio_channels\": 1,\n+            \"hidden_size\": self.mimi_hidden_size,\n+            \"num_filters\": self.mimi_num_filters,\n+            \"num_residual_layers\": self.mimi_num_residual_layers,\n+            \"upsampling_ratios\": self.mimi_upsampling_ratios,\n+            \"codebook_size\": self.mimi_codebook_size,\n+            \"vector_quantization_hidden_dimension\": self.mimi_vector_quantization_hidden_dimension,\n+            \"upsample_groups\": self.mimi_upsample_groups,\n+            \"num_hidden_layers\": self.mimi_num_hidden_layers,\n+            \"num_attention_heads\": self.mimi_num_attention_heads,\n+            \"num_key_value_heads\": self.mimi_num_key_value_heads,\n+            \"sliding_window\": self.mimi_sliding_window,\n+            \"codebook_dim\": self.mimi_codebook_dim,\n+            \"use_cache\": False,\n+            \"sampling_rate\": self.sampling_rate,\n+        }\n+\n+        depth_dict_config = {\n+            \"hidden_size\": self.depth_hidden_size,\n+            \"num_hidden_layers\": self.depth_num_hidden_layers,\n+            \"max_position_embeddings\": self.depth_max_position_embeddings,\n+            \"num_attention_heads\": self.depth_num_attention_heads,\n+            \"ffn_dim\": self.depth_ffn_dim,\n+            \"sliding_window\": self.depth_sliding_window,\n+        }\n+\n+        config = MoshiConfig(\n+            vocab_size=self.vocab_size,\n+            hidden_size=self.hidden_size,\n+            num_hidden_layers=self.num_hidden_layers,\n+            num_attention_heads=self.num_attention_heads,\n+            d_ff=self.intermediate_size,\n+            num_codebooks=self.num_codebooks,\n+            rms_norm_eps=self.rms_norm_eps,\n+            tie_word_embeddings=False,\n+            pad_token_id=self.pad_token_id,\n+            bos_token_id=self.bos_token_id,\n+            ffn_dim=self.ffn_dim,\n+            audio_encoder_config=mimi_dict_config,\n+            depth_decoder_config=depth_dict_config,\n+            attn_implementation=self.attn_implementation,\n+        )\n+        return config\n+\n+    def prepare_config_and_inputs_for_common(self, batch_size=None):\n+        config, inputs_dict = self.prepare_config_and_inputs(batch_size)\n+        return config, inputs_dict\n+\n+\n+@require_torch\n+class MoshiTest(ModelTesterMixin, GenerationTesterMixin, unittest.TestCase):\n+    all_model_classes = (MoshiForConditionalGeneration,) if is_torch_available() else ()\n+    all_generative_model_classes = (MoshiForConditionalGeneration,) if is_torch_available() else ()\n+    test_pruning = False  # training is not supported yet for Moshi\n+    test_headmasking = False\n+    test_resize_embeddings = False\n+    test_torchscript = False\n+\n+    def setUp(self):\n+        self.model_tester = MoshiTester(self)\n+\n+    # special case for labels\n+    def _prepare_for_class(self, inputs_dict, model_class, return_labels=False):\n+        inputs_dict = super()._prepare_for_class(inputs_dict, model_class, return_labels=return_labels)\n+\n+        if return_labels:\n+            inputs_dict[\"text_labels\"] = torch.zeros(\n+                (self.model_tester.batch_size, self.model_tester.seq_length),\n+                dtype=torch.long,\n+                device=torch_device,\n+            )\n+        return inputs_dict\n+\n+    def _get_input_ids_and_config(self, batch_size=2):\n+        config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common(batch_size)\n+        input_ids = inputs_dict.pop(\"input_ids\").to(torch_device)\n+        attention_mask = inputs_dict.pop(\"attention_mask\").to(torch_device)\n+\n+        # Make sure we only return `input_ids`.\n+        # Note that audio_codes will still be generated internally, so the ability to test audio codes is still there.\n+        # There are further tests to test that audio waveforms and codes are well generated.\n+        inputs_dict[\"return_audio_waveforms\"] = False\n+        inputs_dict[\"return_audio_codes\"] = False\n+        inputs_dict[\"concat_unconditional_inputs\"] = False\n+\n+        return config, input_ids, attention_mask, inputs_dict\n+\n+    def prepare_config_and_inputs_for_generate(self, batch_size=2):\n+        config, filtered_inputs_dict = super().prepare_config_and_inputs_for_generate()\n+\n+        # Make sure we only return `input_ids`.\n+        # Note that audio_codes will still be generated internally, so the ability to test audio codes is still there.\n+        # There are further tests to test that audio waveforms and codes are well generated.\n+        filtered_inputs_dict[\"return_audio_waveforms\"] = False\n+        filtered_inputs_dict[\"return_audio_codes\"] = False\n+        filtered_inputs_dict[\"concat_unconditional_inputs\"] = False\n+\n+        return config, filtered_inputs_dict\n+\n+    def _check_hidden_states_for_generate(\n+        self, batch_size, hidden_states, min_length, max_length, config, use_cache=False, num_beam_groups=1\n+    ):\n+        # Overwrite because the generate method actually alway uses `inputs_embeds` so `use_cache` is always `True`\n+        self.assertIsInstance(hidden_states, tuple)\n+        self.assertListEqual(\n+            [isinstance(iter_hidden_states, tuple) for iter_hidden_states in hidden_states],\n+            [True] * len(hidden_states),\n+        )\n+        self.assertEqual(len(hidden_states), (max_length - min_length) * num_beam_groups)\n+\n+        for idx, iter_hidden_states in enumerate(hidden_states):\n+            seq_len = min_length if idx == 0 else 1\n+            expected_shape = (batch_size * num_beam_groups, seq_len, config.hidden_size)\n+            # check hidden size\n+            self.assertListEqual(\n+                [layer_hidden_states.shape for layer_hidden_states in iter_hidden_states],\n+                [expected_shape] * len(iter_hidden_states),\n+            )\n+\n+    def _check_outputs(self, output, input_ids, config, use_cache=False, num_return_sequences=1):\n+        # Overwrite because the generate method actually alway uses `inputs_embeds` so `use_cache` is always `True`\n+        super()._check_outputs(output, input_ids, config, use_cache=True, num_return_sequences=num_return_sequences)\n+\n+    def _check_hidden_states_for_generate(\n+        self, batch_size, hidden_states, min_length, max_length, config, use_cache=False, num_beam_groups=1\n+    ):\n+        # Overwrite because the generate method actually alway uses `inputs_embeds` so `use_cache` is always `True`\n+        self.assertIsInstance(hidden_states, tuple)\n+        self.assertListEqual(\n+            [isinstance(iter_hidden_states, tuple) for iter_hidden_states in hidden_states],\n+            [True] * len(hidden_states),\n+        )\n+        self.assertEqual(len(hidden_states), (max_length - min_length) * num_beam_groups)\n+\n+        for idx, iter_hidden_states in enumerate(hidden_states):\n+            seq_len = 1\n+            expected_shape = (batch_size * num_beam_groups, seq_len, config.hidden_size)\n+            # check hidden size\n+            self.assertListEqual(\n+                [layer_hidden_states.shape for layer_hidden_states in iter_hidden_states],\n+                [expected_shape] * len(iter_hidden_states),\n+            )\n+\n+    def _check_attentions_for_generate(\n+        self, batch_size, attentions, min_length, max_length, config, use_cache=False, num_beam_groups=1\n+    ):\n+        # Overwrite because the generate method actually alway uses `inputs_embeds` so `use_cache` is always `True`\n+        self.assertIsInstance(attentions, tuple)\n+        self.assertListEqual(\n+            [isinstance(iter_attentions, tuple) for iter_attentions in attentions], [True] * len(attentions)\n+        )\n+        self.assertEqual(len(attentions), (max_length - min_length) * num_beam_groups)\n+\n+        for idx, iter_attentions in enumerate(attentions):\n+            tgt_len = 1\n+            src_len = min_length + idx\n+\n+            expected_shape = (\n+                batch_size * num_beam_groups,\n+                config.num_attention_heads,\n+                tgt_len,\n+                src_len,\n+            )\n+            # check attn size\n+            self.assertListEqual(\n+                [layer_attention.shape for layer_attention in iter_attentions], [expected_shape] * len(iter_attentions)\n+            )\n+\n+    def test_initialization(self):\n+        config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+        configs_no_init = _config_zero_init(config)\n+        for model_class in self.all_model_classes:\n+            model = model_class(config=configs_no_init)\n+            for name, param in model.named_parameters():\n+                uniform_init_parms = [\"conv\", \"input_proj\", \"output_proj\"]\n+                if param.requires_grad:\n+                    if any(x in name for x in uniform_init_parms):\n+                        self.assertTrue(\n+                            -1.0 <= ((param.data.mean() * 1e9).round() / 1e9).item() <= 1.0,\n+                            msg=f\"Parameter {name} of model {model_class} seems not properly initialized\",\n+                        )\n+\n+    @pytest.mark.generate\n+    def test_generate_from_inputs_embeds_decoder_only(self):\n+        for model_class in self.all_generative_model_classes:\n+            config, input_ids, _, inputs_dict = self._get_input_ids_and_config()\n+\n+            model = model_class(config).to(torch_device).eval()\n+\n+            # Traditional way of generating text\n+            outputs_from_ids = model.generate(\n+                input_ids, max_new_tokens=5, return_dict_in_generate=True, output_scores=True, **inputs_dict\n+            )\n+            self.assertEqual(outputs_from_ids.sequences.shape, (input_ids.shape[0], input_ids.shape[1] + 5))\n+\n+            # Same thing, but from input embeddings (`input_ids` is passed so the prompt is present in the output)\n+            inputs_embeds = model.get_input_embeddings()(input_ids)\n+            outputs_from_embeds = model.generate(\n+                input_ids,\n+                inputs_embeds=inputs_embeds,\n+                max_new_tokens=5,\n+                return_dict_in_generate=True,\n+                output_scores=True,\n+                **inputs_dict,\n+            )\n+\n+            # But if we pass different inputs_embeds, we should get different outputs (the output text may be the\n+            # same, but the logits will almost surely be different)\n+            random_embeds = torch.rand_like(inputs_embeds)\n+            outputs_from_rand_embeds = model.generate(\n+                input_ids,\n+                inputs_embeds=random_embeds,\n+                max_new_tokens=5,\n+                return_dict_in_generate=True,\n+                output_scores=True,\n+                **inputs_dict,\n+            )\n+            for i in range(len(outputs_from_rand_embeds.scores)):\n+                self.assertFalse(torch.allclose(outputs_from_embeds.scores[i], outputs_from_rand_embeds.scores[i]))\n+\n+            # input_ids is not a required input -- if we don't pass it, the newly generated tokens will be the same\n+            outputs_from_embeds_wo_ids = model.generate(\n+                inputs_embeds=inputs_embeds,\n+                max_new_tokens=5,\n+                return_dict_in_generate=True,\n+                output_scores=True,\n+                **inputs_dict,\n+            )\n+            self.assertListEqual(\n+                outputs_from_embeds.sequences[:, inputs_embeds.shape[1] :].tolist(),\n+                outputs_from_embeds_wo_ids.sequences.tolist(),\n+            )\n+\n+    @unittest.skip(reason=\"Continuing from past key values is not straightforward as we're dealing with 3 inputs\")\n+    def test_generate_continue_from_past_key_values(self):\n+        pass\n+\n+    @unittest.skip(\"Moshi doesn't support contrastive generation yet.\")\n+    def test_contrastive_generate(self):\n+        pass\n+\n+    @unittest.skip(\"Moshi doesn't support contrastive generation yet.\")\n+    def test_contrastive_generate_dict_outputs_use_cache(self):\n+        pass\n+\n+    @unittest.skip(\"Moshi doesn't support contrastive generation yet.\")\n+    def test_contrastive_generate_low_memory(self):\n+        pass\n+\n+    @unittest.skip(\"Adapting this test is costly. `test_eager_matches_sdpa_generate` tests this already.\")\n+    @parameterized.expand([(\"float16\",), (\"bfloat16\",), (\"float32\",)])\n+    @require_torch_sdpa\n+    @slow\n+    def test_eager_matches_sdpa_inference(self, torch_dtype: str):\n+        pass\n+\n+    @unittest.skip(reason=\"The Moshi model does not have support dynamic compile yet\")\n+    def test_sdpa_can_compile_dynamic(self):\n+        pass\n+\n+    @pytest.mark.generate\n+    def test_left_padding_compatibility(self):\n+        # NOTE: left-padding results in small numerical differences. This is expected.\n+        # See https://github.com/huggingface/transformers/issues/25420#issuecomment-1775317535\n+\n+        # Then, test left-padding\n+\n+        for model_class in self.all_generative_model_classes:\n+            config, input_ids, attention_mask, input_dict = self._get_input_ids_and_config()\n+            model = model_class(config).to(torch_device).eval()\n+\n+            # no cache as some models require special cache classes to be init outside forward\n+            model.generation_config.use_cache = False\n+\n+            # Without padding\n+            next_logits_wo_padding = model(input_ids=input_ids, attention_mask=attention_mask, **input_dict).logits[\n+                :, -1, :\n+            ]\n+\n+            # With left-padding (length 32)\n+            # can hardcode pad_token to be 0 as we'll do attn masking anyway\n+            pad_token_id = (\n+                config.get_text_config().pad_token_id if config.get_text_config().pad_token_id is not None else 0\n+            )\n+            pad_size = (input_ids.shape[0], 32)\n+            padding = torch.ones(pad_size, dtype=input_ids.dtype, device=torch_device) * pad_token_id\n+            padded_input_ids = torch.cat((padding, input_ids), dim=1)\n+\n+            padded_attention_mask = torch.cat((torch.zeros_like(padding), attention_mask), dim=1)\n+\n+            padding = (\n+                torch.ones(\n+                    (pad_size[0], self.model_tester.num_codebooks, 32), dtype=input_ids.dtype, device=torch_device\n+                )\n+                * config.audio_vocab_size\n+            )\n+            padded_moshi_audio_codes = torch.cat((padding, input_dict[\"moshi_audio_codes\"]), dim=2)\n+            padded_user_audio_codes = torch.cat((padding, input_dict[\"user_audio_codes\"]), dim=2)\n+\n+            model_kwargs = {\n+                \"input_ids\": padded_input_ids,\n+                \"attention_mask\": padded_attention_mask,\n+                \"moshi_audio_codes\": padded_moshi_audio_codes,\n+                \"user_audio_codes\": padded_user_audio_codes,\n+            }\n+\n+            next_logits_with_padding = model(**model_kwargs).logits[:, -1, :]\n+\n+            # They should result in very similar logits\n+            self.assertTrue(torch.allclose(next_logits_wo_padding, next_logits_with_padding, atol=1e-5))\n+\n+    @require_torch_sdpa\n+    @slow\n+    @is_flaky(max_attempts=5, description=\"flaky on some models.\")\n+    def test_eager_matches_sdpa_generate(self):\n+        if not self.has_attentions:\n+            self.skipTest(reason=\"Model architecture does not support attentions\")\n+\n+        max_new_tokens = 5\n+\n+        if len(self.all_generative_model_classes) == 0:\n+            self.skipTest(f\"{self.__class__.__name__} tests a model that does support generate: skipping this test\")\n+\n+        for model_class in self.all_generative_model_classes:\n+            if not model_class._supports_sdpa:\n+                self.skipTest(f\"{model_class.__name__} does not support SDPA\")\n+\n+            config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+            dummy_input = inputs_dict[model_class.main_input_name]\n+            if dummy_input.dtype in [torch.float32, torch.bfloat16]:\n+                dummy_input = dummy_input.to(torch.float16)\n+\n+            inputs_dict[model_class.main_input_name] = dummy_input\n+\n+            # make sure that all models have enough positions for generation\n+            if hasattr(config, \"max_position_embeddings\"):\n+                config.max_position_embeddings = max_new_tokens + dummy_input.shape[1] + 1\n+\n+            model = model_class(config)\n+\n+            with tempfile.TemporaryDirectory() as tmpdirname:\n+                model.save_pretrained(tmpdirname)\n+\n+                model_sdpa = model_class.from_pretrained(\n+                    tmpdirname,\n+                    torch_dtype=torch.float16,\n+                    low_cpu_mem_usage=True,\n+                ).to(torch_device)\n+\n+                self.assertTrue(model_sdpa.config._attn_implementation == \"sdpa\")\n+\n+                model_eager = model_class.from_pretrained(\n+                    tmpdirname,\n+                    torch_dtype=torch.float16,\n+                    low_cpu_mem_usage=True,\n+                    attn_implementation=\"eager\",\n+                ).to(torch_device)\n+\n+                self.assertTrue(model_eager.config._attn_implementation == \"eager\")\n+\n+                for name, submodule in model_eager.named_modules():\n+                    class_name = submodule.__class__.__name__\n+                    if \"SdpaAttention\" in class_name or \"SdpaSelfAttention\" in class_name:\n+                        raise ValueError(\"The eager model should not have SDPA attention layers\")\n+\n+                has_sdpa = False\n+                for name, submodule in model_sdpa.named_modules():\n+                    class_name = submodule.__class__.__name__\n+                    if \"SdpaAttention\" in class_name or \"SdpaSelfAttention\" in class_name:\n+                        has_sdpa = True\n+                        break\n+                if not has_sdpa:\n+                    raise ValueError(\"The SDPA model should have SDPA attention layers\")\n+\n+                # Just test that a large cache works as expected\n+                res_eager = model_eager.generate(\n+                    **inputs_dict,\n+                    max_new_tokens=max_new_tokens,\n+                    do_sample=False,\n+                    depth_decoder_do_sample=False,\n+                )\n+\n+                res_sdpa = model_sdpa.generate(\n+                    **inputs_dict,\n+                    max_new_tokens=max_new_tokens,\n+                    do_sample=False,\n+                    depth_decoder_do_sample=False,\n+                )\n+\n+                self.assertTrue(torch.allclose(res_eager.sequences, res_sdpa.sequences))\n+                self.assertTrue(torch.allclose(res_eager.audio_sequences, res_sdpa.audio_sequences))\n+\n+    @pytest.mark.generate\n+    def test_generate_without_input_ids(self):\n+        config, _, _, _ = self._get_input_ids_and_config()\n+\n+        for model_class in self.all_generative_model_classes:\n+            model = model_class(config).to(torch_device)\n+            model.eval()\n+\n+            output_ids_generate = model.generate(\n+                do_sample=False, max_new_tokens=self.max_new_tokens, remove_invalid_values=True\n+            )\n+            self.assertIsNotNone(output_ids_generate)\n+\n+    @unittest.skip(reason=\"The audio encoder has no gradients.\")\n+    def test_training_gradient_checkpointing(self):\n+        pass\n+\n+    @unittest.skip(reason=\"The audio encoder has no gradients.\")\n+    def test_training_gradient_checkpointing_use_reentrant(self):\n+        pass\n+\n+    @unittest.skip(reason=\"The audio encoder has no gradients.\")\n+    def test_training_gradient_checkpointing_use_reentrant_false(self):\n+        pass\n+\n+    def test_generate_from_input_values(self):\n+        for model_class in self.all_generative_model_classes:\n+            config, input_ids, _, _ = self._get_input_ids_and_config()\n+\n+            model = model_class(config).to(torch_device).eval()\n+\n+            input_values_length = int(\n+                self.model_tester.seq_length * config.sampling_rate / config.audio_encoder_config.frame_rate\n+            )\n+\n+            user_input_values = floats_tensor((input_ids.shape[0], 1, input_values_length))\n+            moshi_input_values = floats_tensor((input_ids.shape[0], 1, input_values_length))\n+\n+            user_audio_codes = model.audio_encoder.encode(user_input_values, num_quantizers=model.num_codebooks)[0]\n+            moshi_audio_codes = model.audio_encoder.encode(moshi_input_values, num_quantizers=model.num_codebooks)[0]\n+\n+            outputs_from_audio_codes = model.generate(\n+                input_ids, max_new_tokens=5, user_audio_codes=user_audio_codes, moshi_audio_codes=moshi_audio_codes\n+            )\n+\n+            outputs_from_audio_values = model.generate(\n+                input_ids, max_new_tokens=5, user_input_values=user_input_values, moshi_input_values=moshi_input_values\n+            )\n+\n+            self.assertTrue((outputs_from_audio_values.sequences == outputs_from_audio_codes.sequences).all())\n+            self.assertTrue(\n+                torch.allclose(outputs_from_audio_codes.audio_sequences, outputs_from_audio_values.audio_sequences)\n+            )\n+\n+    def test_generate_depth_decoder_kwargs(self):\n+        # test sampling and beam search\n+        for model_class in self.all_generative_model_classes:\n+            config, input_ids, _, input_dict = self._get_input_ids_and_config()\n+\n+            model = model_class(config).to(torch_device).eval()\n+\n+            model.generate(input_ids, max_new_tokens=5, **input_dict, depth_decoder_do_sample=True)\n+\n+            model.generate(\n+                input_ids, max_new_tokens=5, **input_dict, depth_decoder_do_sample=True, depth_decoder_num_beams=5\n+            )\n+\n+    def test_generate_from_unconditional(self):\n+        # test sampling and beam search\n+        for model_class in self.all_generative_model_classes:\n+            config, input_ids, _, input_dict = self._get_input_ids_and_config()\n+\n+            model = model_class(config).to(torch_device).eval()\n+\n+            # check bs>1\n+            model.generate(\n+                **model.get_unconditional_inputs(num_samples=4), max_new_tokens=5, concat_unconditional_inputs=False\n+            )\n+\n+            # check same results from uncondtional or no inputs\n+            outputs_from_unconditional = model.generate(\n+                **model.get_unconditional_inputs(num_samples=1), max_new_tokens=5, concat_unconditional_inputs=False\n+            )\n+            outputs_from_none = model.generate(max_new_tokens=5)\n+\n+            self.assertTrue((outputs_from_unconditional.sequences == outputs_from_none.sequences).all())\n+            self.assertTrue(\n+                torch.allclose(outputs_from_unconditional.audio_sequences, outputs_from_none.audio_sequences)\n+            )\n+\n+    @unittest.skip(reason=\"Compile not yet supported because in Moshi models\")\n+    def test_sdpa_can_dispatch_on_flash(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Some undefined behavior encountered with test versions of this model. Skip for now.\")\n+    def test_cpu_offload(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Some undefined behavior encountered with test versions of this model. Skip for now.\")\n+    def test_disk_offload_bin(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Some undefined behavior encountered with test versions of this model. Skip for now.\")\n+    def test_disk_offload_safetensors(self):\n+        pass\n+\n+    @is_flaky(max_attempts=5, description=\"flaky on some models.\")\n+    def test_save_load(self):\n+        super().test_save_load()\n+\n+\n+def place_dict_on_device(dict_to_place, device):\n+    for key in dict_to_place:\n+        if dict_to_place[key] is not None and isinstance(dict_to_place[key], torch.Tensor):\n+            dict_to_place[key] = dict_to_place[key].to(device)\n+    return dict_to_place\n+\n+\n+@require_torch\n+class MoshiIntegrationTests(unittest.TestCase):\n+    @cached_property\n+    def feature_extractor(self):\n+        return AutoFeatureExtractor.from_pretrained(\"kmhf/hf-moshiko\")\n+\n+    @cached_property\n+    def tokenizer(self):\n+        return AutoTokenizer.from_pretrained(\"kmhf/hf-moshiko\")\n+\n+    def _load_datasample(self):\n+        ds = load_dataset(\"hf-internal-testing/librispeech_asr_dummy\", \"clean\", split=\"validation\")\n+        dataset = ds.cast_column(\"audio\", Audio(sampling_rate=self.feature_extractor.sampling_rate))\n+        # automatic decoding with librispeech\n+        speech_sample = dataset.sort(\"id\")[0][\"audio\"][\"array\"]\n+        return speech_sample\n+\n+    @slow\n+    def test_moshika_conditional_greedy(self):\n+        model = MoshiForConditionalGeneration.from_pretrained(\n+            \"kmhf/hf-moshika\", torch_dtype=torch.float16, device_map=\"auto\"\n+        )\n+        inputs = self.feature_extractor(self._load_datasample(), return_tensors=\"pt\").to(\n+            device=torch_device, dtype=torch.float16\n+        )\n+\n+        user_audio_codes = model.audio_encoder.encode(**inputs, num_quantizers=8).audio_codes\n+\n+        input_ids = self.tokenizer.encode(\"<pad><pad><pad><pad><unk> Hello,<pad><unk>\", return_tensors=\"pt\").to(\n+            torch_device\n+        )\n+\n+        # fmt: off\n+        moshi_audio_codes = [[[1049, 127, 1880, 972, 972, 1156, 1913, 415, 1933],\n+                              [1700, 243, 91, 91, 91, 745, 1478, 638, 57],\n+                              [1626, 457, 457, 457, 457, 1839, 200, 2011, 1142],\n+                              [546, 290, 390, 390, 290, 1408, 1812, 1187, 1911],\n+                              [306, 306, 1314, 1314, 1314, 759, 796, 854, 1466],\n+                              [1443, 1443, 1030, 317, 347, 1178, 613, 1576, 2023],\n+                              [1871, 428, 1433, 1433, 1978, 1405, 1755, 820, 610],\n+                              [2008, 1744, 1511, 568, 1533, 550, 237, 1412, 1401]]]\n+        # fmt: on\n+\n+        moshi_audio_codes = torch.tensor(moshi_audio_codes, device=torch_device)\n+        user_audio_codes = user_audio_codes[:, :, : moshi_audio_codes.shape[-1]]\n+\n+        model_outputs = model.generate(\n+            user_audio_codes=user_audio_codes,\n+            moshi_audio_codes=moshi_audio_codes,\n+            input_ids=input_ids,\n+            do_sample=False,\n+            depth_decoder_do_sample=False,\n+            return_audio_codes=True,\n+            max_new_tokens=2,\n+        )\n+\n+        expected_text_token = 452\n+        expected_audio_tokens = [916, 1396, 1238, 579, 1105, 914, 1257, 810]  # fmt: skip\n+\n+        self.assertTrue(expected_text_token == model_outputs.sequences[0, -2].cpu().item())\n+        self.assertTrue(expected_audio_tokens == model_outputs.audio_codes[0, :, -1].cpu().tolist())\n+\n+    @slow\n+    def test_moshiko_greedy_unconditional_fp16_eager(self):\n+        model = MoshiForConditionalGeneration.from_pretrained(\n+            \"kmhf/hf-moshiko\", torch_dtype=torch.float16, device_map=\"auto\"\n+        )\n+        some_expected_audio_tokens = [[1049, 127], [1700, 243], [1626, 457], [546, 290], [306, 306], [1443, 1443], [1871, 428], [2008, 1744]]  # fmt: skip\n+\n+        model_outputs = model.generate(\n+            do_sample=False, depth_decoder_do_sample=False, return_audio_codes=True, max_new_tokens=10\n+        )\n+\n+        # eager equivalence is not as strict as sdpa.\n+        self.assertTrue(some_expected_audio_tokens == model_outputs.audio_codes[0, :, :2].cpu().tolist())\n+\n+    @slow\n+    def test_moshiko_greedy_unconditional_fp32(self):\n+        model = MoshiForConditionalGeneration.from_pretrained(\n+            \"kmhf/hf-moshiko\", torch_dtype=torch.float32, device_map=\"auto\"\n+        )\n+\n+        expected_audio_codesum = 72065\n+        expected_text_tokens = [3, 3, 3, 0, 11725, 261, 3, 3, 3, 3]  # fmt: skip\n+        some_expected_audio_tokens = [[1049, 127], [1700, 243], [1626, 457], [546, 290], [306, 306], [1443, 1443], [1871, 428], [2008, 1744]]  # fmt: skip\n+\n+        model_outputs = model.generate(\n+            do_sample=False, depth_decoder_do_sample=False, return_audio_codes=True, max_new_tokens=10\n+        )\n+\n+        # make sure audio encoded codes are correct\n+        audio_code_sums = model_outputs.audio_codes.sum().item()\n+        self.assertTrue(np.abs(audio_code_sums - expected_audio_codesum) <= (3e-3 * audio_code_sums))\n+\n+        self.assertTrue(expected_text_tokens == model_outputs.sequences[0, 1:].cpu().tolist())\n+        self.assertTrue(some_expected_audio_tokens == model_outputs.audio_codes[0, :, :2].cpu().tolist())\n+\n+    @slow\n+    @require_torch_fp16\n+    def test_moshiko_greedy_unconditional_fp16(self):\n+        model = MoshiForConditionalGeneration.from_pretrained(\n+            \"kmhf/hf-moshiko\", torch_dtype=torch.float16, device_map=\"auto\"\n+        )\n+\n+        expected_audio_codesum = 72065\n+        expected_text_tokens = [3, 3, 3, 0, 11725, 261, 3, 3, 3, 3]  # fmt: skip\n+        some_expected_audio_tokens = [[1049, 127], [1700, 243], [1626, 457], [546, 290], [306, 306], [1443, 1443], [1871, 428], [2008, 1744]]  # fmt: skip\n+\n+        model_outputs = model.generate(\n+            do_sample=False, depth_decoder_do_sample=False, return_audio_codes=True, max_new_tokens=10\n+        )\n+\n+        # make sure audio encoded codes are correct\n+        audio_code_sums = model_outputs.audio_codes.sum().item()\n+        self.assertTrue(np.abs(audio_code_sums - expected_audio_codesum) <= (3e-3 * audio_code_sums))\n+\n+        self.assertTrue(expected_text_tokens == model_outputs.sequences[0, 1:].cpu().tolist())\n+        self.assertTrue(some_expected_audio_tokens == model_outputs.audio_codes[0, :, :2].cpu().tolist())\n+\n+    @slow\n+    @require_torch_fp16\n+    def test_moshika_greedy_unconditional_fp16(self):\n+        model = MoshiForConditionalGeneration.from_pretrained(\n+            \"kmhf/hf-moshika\", torch_dtype=torch.float16, device_map=\"auto\"\n+        )\n+\n+        expected_audio_codesum = 72932\n+        expected_text_tokens = [3, 3, 3, 0, 667, 263, 3, 3, 0, 705]  # fmt: skip\n+        some_expected_audio_tokens = [[1049, 127], [1700, 243], [1626, 457], [546, 290], [306, 306], [1443, 347], [1871, 428], [2008, 2008]]  # fmt: skip\n+\n+        model_outputs = model.generate(\n+            do_sample=False, depth_decoder_do_sample=False, return_audio_codes=True, max_new_tokens=10\n+        )\n+\n+        # make sure audio encoded codes are correct\n+        audio_code_sums = model_outputs.audio_codes.sum().item()\n+        self.assertTrue(np.abs(audio_code_sums - expected_audio_codesum) <= 2048)\n+\n+        self.assertTrue(expected_text_tokens == model_outputs.sequences[0, 1:].cpu().tolist())\n+        self.assertTrue(some_expected_audio_tokens == model_outputs.audio_codes[0, :, :2].cpu().tolist())"
        },
        {
            "sha": "ad3a34a197f0e4f5db0a406fd24092a1acb92280",
            "filename": "tests/models/moshi/test_tokenization_moshi.py",
            "status": "added",
            "additions": 447,
            "deletions": 0,
            "changes": 447,
            "blob_url": "https://github.com/huggingface/transformers/blob/9ba021ea758429e5bed27a0a405dabf565235802/tests%2Fmodels%2Fmoshi%2Ftest_tokenization_moshi.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/9ba021ea758429e5bed27a0a405dabf565235802/tests%2Fmodels%2Fmoshi%2Ftest_tokenization_moshi.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fmoshi%2Ftest_tokenization_moshi.py?ref=9ba021ea758429e5bed27a0a405dabf565235802",
            "patch": "@@ -0,0 +1,447 @@\n+# coding=utf-8\n+# Copyright 2024 The HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import inspect\n+import pickle\n+import shutil\n+import tempfile\n+import unittest\n+\n+from transformers import (\n+    SPIECE_UNDERLINE,\n+    AddedToken,\n+    AutoTokenizer,\n+    PreTrainedTokenizerFast,\n+    SpecialTokensMixin,\n+)\n+from transformers.convert_slow_tokenizer import MoshiConverter\n+from transformers.testing_utils import (\n+    get_tests_dir,\n+    nested_simplify,\n+    require_sentencepiece,\n+    require_tokenizers,\n+    require_torch,\n+)\n+\n+from ...test_tokenization_common import SMALL_TRAINING_CORPUS, TokenizerTesterMixin\n+\n+\n+SAMPLE_VOCAB = get_tests_dir(\"fixtures/test_sentencepiece.model\")\n+\n+\n+@require_sentencepiece\n+@require_tokenizers\n+class MoshiTokenizationTest(TokenizerTesterMixin, unittest.TestCase):\n+    from_pretrained_id = [\"kmhf/hf-moshiko\"]\n+    rust_tokenizer_class = PreTrainedTokenizerFast\n+\n+    test_slow_tokenizer = False\n+    test_rust_tokenizer = True\n+    from_pretrained_kwargs = {}\n+\n+    def setUp(self):\n+        super().setUp()\n+\n+        # We have a SentencePiece fixture for testing\n+        tokenizer = PreTrainedTokenizerFast(\n+            tokenizer_object=MoshiConverter(vocab_file=SAMPLE_VOCAB).converted(),\n+            bos_token=\"<s>\",\n+            unk_token=\"<unk>\",\n+            eos_token=\"</s>\",\n+        )\n+        tokenizer.pad_token = tokenizer.eos_token\n+        tokenizer.save_pretrained(self.tmpdirname)\n+\n+    def get_rust_tokenizer(self, **kwargs) -> PreTrainedTokenizerFast:\n+        return self.rust_tokenizer_class.from_pretrained(self.tmpdirname, **kwargs)\n+\n+    @unittest.skip(reason=\"No slow tokenizer\")\n+    def test_added_tokens_serialization(self):\n+        pass\n+\n+    @unittest.skip(reason=\"PreTrainedTokenizerFast doesn't have tokenizer_file in its signature\")\n+    def test_rust_tokenizer_signature(self):\n+        pass\n+\n+    @unittest.skip(reason=\"No slow tokenizer\")\n+    def test_encode_decode_with_spaces(self):\n+        pass\n+\n+    def test_full_tokenizer(self):\n+        tokenizer = PreTrainedTokenizerFast(\n+            tokenizer_object=MoshiConverter(vocab_file=SAMPLE_VOCAB).converted(),\n+            bos_token=\"<s>\",\n+            unk_token=\"<unk>\",\n+            eos_token=\"</s>\",\n+        )\n+\n+        tokens = tokenizer.tokenize(\"This is a test\")\n+        self.assertListEqual(tokens, [\"▁This\", \"▁is\", \"▁a\", \"▁t\", \"est\"])\n+\n+        self.assertListEqual(\n+            tokenizer.convert_tokens_to_ids(tokens),\n+            [285, 46, 10, 170, 382],\n+        )\n+\n+        tokens = tokenizer.tokenize(\"I was born in 92000, and this is falsé.\")\n+        self.assertListEqual(\n+            tokens,\n+            [\n+                SPIECE_UNDERLINE + \"I\",\n+                SPIECE_UNDERLINE + \"was\",\n+                SPIECE_UNDERLINE + \"b\",\n+                \"or\",\n+                \"n\",\n+                SPIECE_UNDERLINE + \"in\",\n+                SPIECE_UNDERLINE + \"\",\n+                \"9\",\n+                \"2\",\n+                \"0\",\n+                \"0\",\n+                \"0\",\n+                \",\",\n+                SPIECE_UNDERLINE + \"and\",\n+                SPIECE_UNDERLINE + \"this\",\n+                SPIECE_UNDERLINE + \"is\",\n+                SPIECE_UNDERLINE + \"f\",\n+                \"al\",\n+                \"s\",\n+                \"é\",\n+                \".\",\n+            ],\n+        )\n+        ids = tokenizer.convert_tokens_to_ids(tokens)\n+        self.assertListEqual(\n+            ids,\n+            [8, 21, 84, 55, 24, 19, 7, 0, 602, 347, 347, 347, 3, 12, 66, 46, 72, 80, 6, 0, 4],\n+        )\n+\n+        back_tokens = tokenizer.convert_ids_to_tokens(ids)\n+        self.assertListEqual(\n+            back_tokens,\n+            [\n+                SPIECE_UNDERLINE + \"I\",\n+                SPIECE_UNDERLINE + \"was\",\n+                SPIECE_UNDERLINE + \"b\",\n+                \"or\",\n+                \"n\",\n+                SPIECE_UNDERLINE + \"in\",\n+                SPIECE_UNDERLINE + \"\",\n+                \"<unk>\",\n+                \"2\",\n+                \"0\",\n+                \"0\",\n+                \"0\",\n+                \",\",\n+                SPIECE_UNDERLINE + \"and\",\n+                SPIECE_UNDERLINE + \"this\",\n+                SPIECE_UNDERLINE + \"is\",\n+                SPIECE_UNDERLINE + \"f\",\n+                \"al\",\n+                \"s\",\n+                \"<unk>\",\n+                \".\",\n+            ],\n+        )\n+\n+    def test_special_tokens_initialization(self):\n+        for tokenizer, pretrained_name, kwargs in self.tokenizers_list:\n+            with self.subTest(f\"{tokenizer.__class__.__name__} ({pretrained_name})\"):\n+                added_tokens = [AddedToken(\"<special>\", lstrip=True)]\n+\n+                tokenizer_r = self.rust_tokenizer_class.from_pretrained(\n+                    pretrained_name, additional_special_tokens=added_tokens, **kwargs\n+                )\n+                r_output = tokenizer_r.encode(\"Hey this is a <special> token\")\n+\n+                special_token_id = tokenizer_r.encode(\"<special>\", add_special_tokens=False)[0]\n+\n+                self.assertTrue(special_token_id in r_output)\n+\n+    def test_picklable(self):\n+        with tempfile.NamedTemporaryFile() as f:\n+            shutil.copyfile(SAMPLE_VOCAB, f.name)\n+            tokenizer = PreTrainedTokenizerFast(\n+                tokenizer_object=MoshiConverter(vocab_file=f.name).converted(),\n+                bos_token=\"<s>\",\n+                unk_token=\"<unk>\",\n+                eos_token=\"</s>\",\n+            )\n+            pickled_tokenizer = pickle.dumps(tokenizer)\n+        pickle.loads(pickled_tokenizer)\n+\n+    def test_training_new_tokenizer(self):\n+        # This feature only exists for fast tokenizers\n+        if not self.test_rust_tokenizer:\n+            self.skipTest(reason=\"test_rust_tokenizer is set to False\")\n+\n+        tokenizer = self.get_rust_tokenizer()\n+        new_tokenizer = tokenizer.train_new_from_iterator(SMALL_TRAINING_CORPUS, 100)\n+\n+        # Test we can use the new tokenizer with something not seen during training\n+        inputs = new_tokenizer([\"This is the first sentence\", \"This sentence is different 🤗.\"])\n+        self.assertEqual(len(inputs[\"input_ids\"]), 2)\n+        decoded_input = new_tokenizer.decode(inputs[\"input_ids\"][0], skip_special_tokens=True)\n+        expected_result = \"This is the first sentence\"\n+\n+        self.assertEqual(expected_result, decoded_input)\n+\n+        # We check that the parameters of the tokenizer remained the same\n+        # Check we have the same number of added_tokens for both pair and non-pair inputs.\n+        self.assertEqual(tokenizer.num_special_tokens_to_add(False), new_tokenizer.num_special_tokens_to_add(False))\n+        self.assertEqual(tokenizer.num_special_tokens_to_add(True), new_tokenizer.num_special_tokens_to_add(True))\n+\n+        # Check we have the correct max_length for both pair and non-pair inputs.\n+        self.assertEqual(tokenizer.max_len_single_sentence, new_tokenizer.max_len_single_sentence)\n+        self.assertEqual(tokenizer.max_len_sentences_pair, new_tokenizer.max_len_sentences_pair)\n+\n+        # Assert the set of special tokens match as we didn't ask to change them\n+        self.assertSequenceEqual(\n+            tokenizer.all_special_tokens_extended,\n+            new_tokenizer.all_special_tokens_extended,\n+        )\n+\n+        self.assertDictEqual(tokenizer.special_tokens_map, new_tokenizer.special_tokens_map)\n+\n+    def test_training_new_tokenizer_with_special_tokens_change(self):\n+        # This feature only exists for fast tokenizers\n+        if not self.test_rust_tokenizer:\n+            self.skipTest(reason=\"test_rust_tokenizer is set to False\")\n+\n+        tokenizer = self.get_rust_tokenizer()\n+        # Test with a special tokens map\n+        class_signature = inspect.signature(tokenizer.__class__)\n+        if \"cls_token\" in class_signature.parameters:\n+            new_tokenizer = tokenizer.train_new_from_iterator(\n+                SMALL_TRAINING_CORPUS, 100, special_tokens_map={tokenizer.cls_token: \"<cls>\"}\n+            )\n+            cls_id = new_tokenizer.get_vocab()[\"<cls>\"]\n+            self.assertEqual(new_tokenizer.cls_token, \"<cls>\")\n+            self.assertEqual(new_tokenizer.cls_token_id, cls_id)\n+\n+        # Create a new mapping from the special tokens defined in the original tokenizer\n+        special_tokens_list = SpecialTokensMixin.SPECIAL_TOKENS_ATTRIBUTES.copy()\n+        special_tokens_list.remove(\"additional_special_tokens\")\n+        special_tokens_map = {}\n+        for token in special_tokens_list:\n+            # Get the private one to avoid unnecessary warnings.\n+            if getattr(tokenizer, f\"_{token}\") is not None:\n+                special_token = getattr(tokenizer, token)\n+                special_tokens_map[special_token] = f\"{special_token}a\"\n+\n+        # Train new tokenizer\n+        new_tokenizer = tokenizer.train_new_from_iterator(\n+            SMALL_TRAINING_CORPUS, 100, special_tokens_map=special_tokens_map\n+        )\n+\n+        # Check the changes\n+        for token in special_tokens_list:\n+            # Get the private one to avoid unnecessary warnings.\n+            if getattr(tokenizer, f\"_{token}\") is None:\n+                continue\n+            special_token = getattr(tokenizer, token)\n+            if special_token in special_tokens_map:\n+                new_special_token = getattr(new_tokenizer, token)\n+                self.assertEqual(special_tokens_map[special_token], new_special_token)\n+\n+                new_id = new_tokenizer.get_vocab()[new_special_token]\n+                self.assertEqual(getattr(new_tokenizer, f\"{token}_id\"), new_id)\n+\n+        # Check if the AddedToken / string format has been kept\n+        for special_token in tokenizer.all_special_tokens_extended:\n+            if isinstance(special_token, AddedToken) and special_token.content not in special_tokens_map:\n+                # The special token must appear identically in the list of the new tokenizer.\n+                self.assertTrue(\n+                    special_token in new_tokenizer.all_special_tokens_extended,\n+                    f\"'{special_token}' should be in {new_tokenizer.all_special_tokens_extended}\",\n+                )\n+            elif isinstance(special_token, AddedToken):\n+                # The special token must appear in the list of the new tokenizer as an object of type AddedToken with\n+                # the same parameters as the old AddedToken except the content that the user has requested to change.\n+                special_token_str = special_token.content\n+                new_special_token_str = special_tokens_map[special_token_str]\n+\n+                find = False\n+                for candidate in new_tokenizer.all_special_tokens_extended:\n+                    if (\n+                        isinstance(candidate, AddedToken)\n+                        and candidate.content == new_special_token_str\n+                        and candidate.lstrip == special_token.lstrip\n+                        and candidate.rstrip == special_token.rstrip\n+                        and candidate.normalized == special_token.normalized\n+                        and candidate.single_word == special_token.single_word\n+                    ):\n+                        find = True\n+                        break\n+                special_token.content = new_special_token_str\n+                self.assertTrue(\n+                    find,\n+                    f\"'{special_token.__repr__()}' should appear as an `AddedToken` in the all_special_tokens_extended = \"\n+                    f\"{[k for k in new_tokenizer.all_special_tokens_extended if str(k)==new_special_token_str]} but it is missing\"\n+                    \", this means that the new tokenizers did not keep the `rstrip`, `lstrip`, `normalized` etc attributes.\",\n+                )\n+            elif special_token not in special_tokens_map:\n+                # The special token must appear identically in the list of the new tokenizer.\n+                self.assertTrue(\n+                    special_token in new_tokenizer.all_special_tokens_extended,\n+                    f\"'{special_token.__repr__()}' should be in {new_tokenizer.all_special_tokens_extended}\",\n+                )\n+\n+            else:\n+                # The special token must appear in the list of the new tokenizer as an object of type string.\n+                self.assertTrue(special_tokens_map[special_token] in new_tokenizer.all_special_tokens_extended)\n+\n+        # Test we can use the new tokenizer with something not seen during training\n+        inputs = new_tokenizer([\"This is the first sentence\", \"This sentence is different 🤗.\"])\n+        self.assertEqual(len(inputs[\"input_ids\"]), 2)\n+        decoded_input = new_tokenizer.decode(inputs[\"input_ids\"][0], skip_special_tokens=True)\n+        expected_result = \"This is the first sentence\"\n+\n+        self.assertEqual(expected_result, decoded_input)\n+\n+    def test_alignement_methods(self):\n+        # TODO: @ArthurZucker - alignment is broken\n+        pass\n+\n+    def test_added_tokens_do_lower_case(self):\n+        # TODO: @ArthurZucker\n+        pass\n+\n+\n+@require_torch\n+@require_sentencepiece\n+@require_tokenizers\n+class MoshiIntegrationTest(unittest.TestCase):\n+    @classmethod\n+    def setUpClass(cls):\n+        checkpoint_name = \"kmhf/hf-moshiko\"\n+        cls.rust_tokenizer = AutoTokenizer.from_pretrained(checkpoint_name)\n+        return cls\n+\n+    @require_torch\n+    def integration_tests(self):\n+        inputs = self.tokenizer(\n+            [\"The following string should be properly encoded: Hello.\", \"But ird and ปี   ird   ด\"],\n+            return_tensors=\"pt\",\n+        )\n+\n+        long_attention_mask = [1] * 21\n+\n+        # fmt: off\n+        self.assertEqual(\n+            nested_simplify(inputs),\n+            {\n+                \"input_ids\": [\n+                    [287, 547, 2359, 457, 297, 3708, 11488, 279, 11725, 263],\n+                    [588, 478, 1442, 267, 260, 228, 188, 159, 228, 188, 185, 260, 260, 478, 1442, 260, 260, 260, 228, 188, 152],\n+                ],\n+                \"attention_mask\": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1], long_attention_mask],\n+            },\n+        )\n+        # fmt: on\n+\n+    def test_fast_special_tokens(self):\n+        fast_tokenizer = self.rust_tokenizer\n+\n+        fast_tokenizer.add_eos_token = False\n+        fast = fast_tokenizer.encode(\"A sample test\", add_special_tokens=True)\n+        assert fast == [318, 1145, 694]\n+\n+        fast_tokenizer.add_eos_token = True\n+        fast = fast_tokenizer.encode(\"A sample test\", add_special_tokens=True)\n+        assert fast == [318, 1145, 694]\n+\n+        self.rust_tokenizer.add_eos_token = False\n+\n+    def test_simple_encode_decode(self):\n+        rust_tokenizer = self.rust_tokenizer\n+\n+        self.assertEqual(rust_tokenizer.encode(\"This is a test\"), [353, 275, 272, 694])\n+        self.assertEqual(rust_tokenizer.decode([353, 275, 272, 694], skip_special_tokens=True), \"This is a test\")\n+\n+        # bytefallback showcase\n+        bytefallback_tokens = [260, 235, 152, 163, 234, 184, 191, 13340, 235, 160, 163, 236, 180, 159, 234, 156, 179]  # fmt: skip\n+        self.assertEqual(rust_tokenizer.encode(\"生活的真谛是\"), bytefallback_tokens)\n+        self.assertEqual(\n+            rust_tokenizer.decode(bytefallback_tokens, skip_special_tokens=True),\n+            \"生活的真谛是\",\n+        )\n+\n+        # Inner spaces showcase\n+        self.assertEqual(rust_tokenizer.encode(\"Hi  Hello\"), [2769, 260, 11725])\n+        self.assertEqual(rust_tokenizer.decode([2769, 260, 11725], skip_special_tokens=True), \"Hi  Hello\")\n+\n+        self.assertEqual(rust_tokenizer.encode(\"Hi   Hello\"), [2769, 260, 260, 11725])\n+        self.assertEqual(rust_tokenizer.decode([2769, 260, 260, 11725], skip_special_tokens=True), \"Hi   Hello\")\n+\n+        # TODO: @ArthurZucker\n+        # self.assertEqual(rust_tokenizer.encode(\"\"), [])\n+\n+        # self.assertEqual(rust_tokenizer.encode(\" \"), [260, 260])\n+\n+        # self.assertEqual(rust_tokenizer.encode(\"  \"), [260, 260, 260])\n+\n+        # self.assertEqual(rust_tokenizer.encode(\" Hello\"), [260, 11725])\n+\n+        # self.assertEqual(rust_tokenizer.encode(\"<s>\"), [607, 266, 578])\n+\n+    def test_no_differences_decode(self):\n+        rust_tokenizer = self.rust_tokenizer\n+\n+        self.assertEqual(rust_tokenizer.decode([869]), \"levels\")\n+\n+        self.assertEqual(rust_tokenizer.decode([30112, 869]), \"unanswered levels\")\n+\n+\n+@require_sentencepiece\n+@require_tokenizers\n+class CommonSpmIntegrationTests(unittest.TestCase):\n+    \"\"\"\n+    A class that regroups important test to make sure that we properly handle the special tokens.\n+    \"\"\"\n+\n+    def test_edge_case_tabulation(self):\n+        fast_tokenizer = AutoTokenizer.from_pretrained(\"kmhf/hf-moshiko\")\n+        input_text = \"Hey<eos>. \\t\\t \\n\\nyou  é  @#😈  🤗!       , 1234 15 5,61\"\n+        EXPECTED_IDS = [11510, 934, 4451, 266, 578, 263, 260, 13, 13, 260, 14, 14, 5209, 260, 260, 1202, 260, 527, 1322, 244, 163, 156, 140, 260, 260, 244, 163, 168, 155, 430, 1047, 261, 260, 265, 270, 278, 281, 260, 265, 280, 260, 280, 261, 285, 265]  # fmt: skip\n+        EXPECTED_TOKENS = ['▁Hey', '<', 'eo', 's', '>', '.', '▁', '<0x09>', '<0x09>', '▁', '<0x0A>', '<0x0A>', 'you', '▁', '▁', 'é', '▁', '▁@', '#', '<0xF0>', '<0x9F>', '<0x98>', '<0x88>', '▁', '▁', '<0xF0>', '<0x9F>', '<0xA4>', '<0x97>', '!', '▁▁▁▁▁▁▁', ',', '▁', '1', '2', '3', '4', '▁', '1', '5', '▁', '5', ',', '6', '1']  # fmt: skip\n+\n+        tokens = fast_tokenizer.tokenize(input_text)\n+        with self.subTest(\"test fast edge case fast\"):\n+            self.assertEqual(tokens, EXPECTED_TOKENS)\n+\n+        input_ids = fast_tokenizer.encode(input_text)\n+        with self.subTest(\"test fast edge case fast\"):\n+            self.assertEqual(input_ids, EXPECTED_IDS)\n+\n+        text = fast_tokenizer.decode(EXPECTED_IDS)\n+        with self.subTest(\"test fast edge case fast\"):\n+            self.assertEqual(text, \"Hey<eos>. \\t\\t \\n\\nyou  é  @#😈  🤗!       , 1234 15 5,61\")\n+\n+        input_text = \"\\t\\t\\t\\t \\n\\n61\"\n+        EXPECTED_IDS = [260, 13, 13, 13, 13, 260, 14, 14, 285, 265]\n+        EXPECTED_TOKENS = [\"▁\", \"<0x09>\", \"<0x09>\", \"<0x09>\", \"<0x09>\", \"▁\", \"<0x0A>\", \"<0x0A>\", \"6\", \"1\"]\n+\n+        tokens = fast_tokenizer.tokenize(input_text)\n+        with self.subTest(\"test fast edge case fast\"):\n+            self.assertEqual(tokens, EXPECTED_TOKENS)\n+\n+        input_ids = fast_tokenizer.encode(input_text)\n+        with self.subTest(\"test fast edge case fast\"):\n+            self.assertEqual(input_ids, EXPECTED_IDS)\n+\n+        text = fast_tokenizer.decode(EXPECTED_IDS)\n+        with self.subTest(\"test fast edge case fast\"):\n+            self.assertEqual(text, \"\\t\\t\\t\\t \\n\\n61\")"
        },
        {
            "sha": "6872dada3d9384b50efd13938d3ededfdb45d8eb",
            "filename": "utils/check_repo.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/9ba021ea758429e5bed27a0a405dabf565235802/utils%2Fcheck_repo.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/9ba021ea758429e5bed27a0a405dabf565235802/utils%2Fcheck_repo.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/utils%2Fcheck_repo.py?ref=9ba021ea758429e5bed27a0a405dabf565235802",
            "patch": "@@ -327,6 +327,7 @@\n     \"SiglipVisionModel\",\n     \"SiglipTextModel\",\n     \"ChameleonVQVAE\",  # no autoclass for VQ-VAE models\n+    \"MoshiForConditionalGeneration\",  # no auto class for speech-to-speech\n ]\n \n # DO NOT edit this list!"
        }
    ],
    "stats": {
        "total": 5355,
        "additions": 5353,
        "deletions": 2
    }
}